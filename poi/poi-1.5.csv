name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
poi,1.5,org.apache.poi.hssf.record.LineFormatRecord,25,2,0,6,44,128,1,5,23,0.948863636,429,0.363636364,3,0.333333333,0.352,1,6,15.28,2,0.92,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class LineFormatRecord
    extends Record
{
    public final static short      sid                             = 0x1007;
    private  int        field_1_lineColor;
    private  short      field_2_linePattern;
    public final static short       LINE_PATTERN_SOLID             = 0;
    public final static short       LINE_PATTERN_DASH              = 1;
    public final static short       LINE_PATTERN_DOT               = 2;
    public final static short       LINE_PATTERN_DASH_DOT          = 3;
    public final static short       LINE_PATTERN_DASH_DOT_DOT      = 4;
    public final static short       LINE_PATTERN_NONE              = 5;
    public final static short       LINE_PATTERN_DARK_GRAY_PATTERN = 6;
    public final static short       LINE_PATTERN_MEDIUM_GRAY_PATTERN = 7;
    public final static short       LINE_PATTERN_LIGHT_GRAY_PATTERN = 8;
    private  short      field_3_weight;
    public final static short       WEIGHT_HAIRLINE                = -1;
    public final static short       WEIGHT_NARROW                  = 0;
    public final static short       WEIGHT_MEDIUM                  = 1;
    public final static short       WEIGHT_WIDE                    = 2;
    private  short      field_4_format;
    private BitField   auto                                       = new BitField(0x1);
    private BitField   drawTicks                                  = new BitField(0x4);
    private BitField   unknown                                    = new BitField(0x4);
    private  short      field_5_colourPaletteIndex;


    public LineFormatRecord()
    {

    }

    

    public LineFormatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public LineFormatRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a LineFormat record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_lineColor               = LittleEndian.getInt(data, 0x0 + offset);
        field_2_linePattern             = LittleEndian.getShort(data, 0x4 + offset);
        field_3_weight                  = LittleEndian.getShort(data, 0x6 + offset);
        field_4_format                  = LittleEndian.getShort(data, 0x8 + offset);
        field_5_colourPaletteIndex      = LittleEndian.getShort(data, 0xa + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[LineFormat]
"");

        buffer.append(""    .lineColor            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getLineColor()))
            .append("" ("").append(getLineColor()).append("" )
"");

        buffer.append(""    .linePattern          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getLinePattern()))
            .append("" ("").append(getLinePattern()).append("" )
"");

        buffer.append(""    .weight               = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getWeight()))
            .append("" ("").append(getWeight()).append("" )
"");

        buffer.append(""    .format               = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormat()))
            .append("" ("").append(getFormat()).append("" )
"");
        buffer.append(""         .auto                     = "").append(isAuto                ()).append('
');
        buffer.append(""         .drawTicks                = "").append(isDrawTicks           ()).append('
');
        buffer.append(""         .unknown                  = "").append(isUnknown             ()).append('
');

        buffer.append(""    .colourPaletteIndex   = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getColourPaletteIndex()))
            .append("" ("").append(getColourPaletteIndex()).append("" )
"");

        buffer.append(""[/LineFormat]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putInt(data, 4 + offset, field_1_lineColor);
        LittleEndian.putShort(data, 8 + offset, field_2_linePattern);
        LittleEndian.putShort(data, 10 + offset, field_3_weight);
        LittleEndian.putShort(data, 12 + offset, field_4_format);
        LittleEndian.putShort(data, 14 + offset, field_5_colourPaletteIndex);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 4 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public int getLineColor()
    {
        return field_1_lineColor;
    }

    
    public void setLineColor(int field_1_lineColor)
    {
        this.field_1_lineColor = field_1_lineColor;
    }

    
    public short getLinePattern()
    {
        return field_2_linePattern;
    }

    
    public void setLinePattern(short field_2_linePattern)
    {
        this.field_2_linePattern = field_2_linePattern;
    }

    
    public short getWeight()
    {
        return field_3_weight;
    }

    
    public void setWeight(short field_3_weight)
    {
        this.field_3_weight = field_3_weight;
    }

    
    public short getFormat()
    {
        return field_4_format;
    }

    
    public void setFormat(short field_4_format)
    {
        this.field_4_format = field_4_format;
    }

    
    public short getColourPaletteIndex()
    {
        return field_5_colourPaletteIndex;
    }

    
    public void setColourPaletteIndex(short field_5_colourPaletteIndex)
    {
        this.field_5_colourPaletteIndex = field_5_colourPaletteIndex;
    }

    
    public void setAuto(boolean value)
    {
        field_4_format = auto.setShortBoolean(field_4_format, value);
    }

    
    public boolean isAuto()
    {
        return auto.isSet(field_4_format);
    }

    
    public void setDrawTicks(boolean value)
    {
        field_4_format = drawTicks.setShortBoolean(field_4_format, value);
    }

    
    public boolean isDrawTicks()
    {
        return drawTicks.isSet(field_4_format);
    }

    
    public void setUnknown(boolean value)
    {
        field_4_format = unknown.setShortBoolean(field_4_format, value);
    }

    
    public boolean isUnknown()
    {
        return unknown.isSet(field_4_format);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.formula.AttrPtg,20,2,0,4,36,138,1,4,20,0.846889952,336,0.909090909,7,0.28,0.225,1,2,15.25,1,0.9,6,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.BitField;



public class AttrPtg
    extends Ptg
    implements OperationPtg
{
    public final static short sid  = 0x19;
    private final static int  SIZE = 4;
    private byte              field_1_options;
    private short             field_2_data;
    private BitField          semiVolatile = new BitField(0x01);
    private BitField          optiIf       = new BitField(0x02);
    private BitField          optiChoose   = new BitField(0x04);
    private BitField          optGoto      = new BitField(0x08);
    private BitField          sum          = new BitField(0x10);
    private BitField          baxcel       = new BitField(0x20);
    private BitField          space        = new BitField(0x40);

    

    public AttrPtg()
    {
    }

    public AttrPtg(byte [] data, int offset)
    {
        offset++;   
        field_1_options = data[ offset + 0 ];
        field_2_data    = LittleEndian.getShort(data, offset + 1);
        System.out.println(""OPTIONS = "" + Integer.toHexString(getOptions()));
        System.out.println(""OPTIONS & 0x10 = "" + (getOptions() & 0x10));
        System.out.println(toString());
    }

    public void setOptions(byte options)
    {
        field_1_options = options;
    }

    public byte getOptions()
    {
        return field_1_options;
    }

    public boolean isSemiVolatile()
    {
        return semiVolatile.isSet(getOptions());
    }

    public boolean isOptimizedIf()
    {
        return optiIf.isSet(getOptions());
    }

    public boolean isOptimizedChoose()
    {
        return optiChoose.isSet(getOptions());
    }

    
    public boolean isGoto()
    {
        return optGoto.isSet(getOptions());
    }

    public boolean isSum()
    {
        return sum.isSet(getOptions());
    }

    
    public boolean isBaxcel()
    {
        return baxcel.isSet(getOptions());
    }

    
    public boolean isSpace()
    {
        return space.isSet(getOptions());
    }

    public void setData(short data)
    {
        field_2_data = data;
    }

    public short getData()
    {
        return field_2_data;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""AttrPtg
"");
        buffer.append(""options="").append(field_1_options).append(""
"");
        buffer.append(""data   ="").append(field_2_data).append(""
"");
        buffer.append(""semi   ="").append(isSemiVolatile()).append(""
"");
        buffer.append(""optimif="").append(isOptimizedIf()).append(""
"");
        buffer.append(""optchos="").append(isOptimizedChoose()).append(""
"");
        buffer.append(""isGoto ="").append(isGoto()).append(""
"");
        buffer.append(""isSum  ="").append(isSum()).append(""
"");
        buffer.append(""isBaxce="").append(isBaxcel()).append(""
"");
        buffer.append(""isSpace="").append(isSpace()).append(""
"");
        return buffer.toString();
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return SIZE;
    }

    public String toFormulaString()
    {
        return ""SUM()"";
    }

    public String toFormulaString(Ptg [] operands)
    {
        return ""SUM("" + operands[ 0 ].toFormulaString() + "")"";
    }

    public int getNumberOfOperands()
    {
        return 1;
    }

    public int getType()
    {
        return -1;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.RKRecord,23,2,0,8,48,235,2,6,21,0.924242424,379,0.444444444,0,0.35483871,0.289855072,1,5,15.08695652,6,1.4783,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.hssf.util.RKUtil;



public class RKRecord
    extends Record
    implements CellValueRecordInterface
{
    public final static short sid                      = 0x27e;
    public final static short RK_IEEE_NUMBER           = 0;
    public final static short RK_IEEE_NUMBER_TIMES_100 = 1;
    public final static short RK_INTEGER               = 2;
    public final static short RK_INTEGER_TIMES_100     = 3;
    private short             field_1_row;
    private short             field_2_col;
    private short             field_3_xf_index;
    private int               field_4_rk_number;

    public RKRecord()
    {
    }

    

    public RKRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public RKRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid RK RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row       = LittleEndian.getShort(data, 0 + offset);
        field_2_col       = LittleEndian.getShort(data, 2 + offset);
        field_3_xf_index  = LittleEndian.getShort(data, 4 + offset);
        field_4_rk_number = LittleEndian.getInt(data, 6 + offset);
    }

    public short getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_col;
    }

    public short getXFIndex()
    {
        return field_3_xf_index;
    }

    public int getRKField()
    {
        return field_4_rk_number;
    }

    

    public short getRKType()
    {
        return ( short ) (field_4_rk_number & 3);
    }

    

    public double getRKNumber()
    {
        return RKUtil.decodeNumber(field_4_rk_number);
    }


    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[RK]
"");
        buffer.append(""    .row            = "")
            .append(Integer.toHexString(getRow())).append(""
"");
        buffer.append(""    .col            = "")
            .append(Integer.toHexString(getColumn())).append(""
"");
        buffer.append(""    .xfindex        = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        buffer.append(""    .rknumber       = "")
            .append(Integer.toHexString(getRKField())).append(""
"");
        buffer.append(""        .rktype     = "")
            .append(Integer.toHexString(getRKType())).append(""
"");
        buffer.append(""        .rknumber   = "").append(getRKNumber())
            .append(""
"");
        buffer.append(""[/RK]
"");
        return buffer.toString();
    }


    public int serialize(int offset, byte [] data)
    {
        NumberRecord rec = new NumberRecord();

        rec.setColumn(getColumn());
        rec.setRow(getRow());
        rec.setValue(getRKNumber());
        rec.setXFIndex(getXFIndex());
        return rec.serialize(offset, data);
    }

    

    public static void main(String ignored_args[])
    {
        int[]    values  =
        {
            0x3FF00000, 0x405EC001, 0x02F1853A, 0x02F1853B, 0xFCDD699A
        };
        double[] rvalues =
        {
            1, 1.23, 12345678, 123456.78, -13149594
        };

        for (int j = 0; j < values.length; j++)
        {
            System.out.println(""input = "" + Integer.toHexString(values[ j ])
                               + "" -> "" + rvalues[ j ] + "": ""
                               + RKUtil.decodeNumber(values[ j ]));
        }
    }

    public short getSid()
    {
        return this.sid;
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    public void setColumn(short col)
    {
    }

    public void setRow(short row)
    {
    }

    

    public void setXFIndex(short xf)
    {
    }
}
"
poi,1.5,org.apache.poi.hssf.record.UnicodeString,22,2,0,5,41,159,2,3,18,0.702380952,325,0.75,0,0.366666667,0.266233766,2,6,13.59090909,6,1.4545,3,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class UnicodeString
    extends Record
    implements Comparable
{
    public final static short sid = 0xFFF;
    private short             field_1_charCount;     
    private byte              field_2_optionflags;   
    private String            field_3_string;        

    public int hashCode()
    {
        return field_1_charCount;
    }

    public boolean equals(Object o)
    {
        if ((o == null) || (o.getClass() != this.getClass()))
        {
            return false;
        }
        UnicodeString other = ( UnicodeString ) o;

        return ((field_1_charCount == other.field_1_charCount)
                && (field_2_optionflags == other.field_2_optionflags)
                && field_3_string.equals(other.field_3_string));
    }

    public UnicodeString()
    {
    }

    

    public UnicodeString(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public UnicodeString(short id, short size, byte [] data, String prefix)
    {
        this(id, size, data);
        field_3_string = prefix + field_3_string;
        setCharCount();
    }

    

    protected void validateSid(short id)
    {

        
    }

    protected void fillFields(byte [] data, short size)
    {
        field_1_charCount   = LittleEndian.getShort(data, 0);
        field_2_optionflags = data[ 2 ];
        if ((field_2_optionflags & 1) == 0)
        {
            field_3_string = new String(data, 3, getCharCount());
        }
        else
        {
            char[] array = new char[ getCharCount() ];

            for (int j = 0; j < array.length; j++)
            {
                array[ j ] = ( char ) LittleEndian.getShort(data,
                                                            3 + (j * 2));
            }
            field_3_string = new String(array);
        }
    }

    

    public short getCharCount()
    {
        return field_1_charCount;
    }

    

    public void setCharCount(short cc)
    {
        field_1_charCount = cc;
    }

    

    public void setCharCount()
    {
        field_1_charCount = ( short ) field_3_string.length();
    }

    

    public byte getOptionFlags()
    {
        return field_2_optionflags;
    }

    

    public void setOptionFlags(byte of)
    {
        field_2_optionflags = of;
    }

    

    public String getString()
    {
        return field_3_string;
    }

    

    public void setString(String string)
    {
        field_3_string = string;
        if (getCharCount() < field_3_string.length())
        {
            setCharCount();
        }
    }

    

    public String toString()
    {
        return getString();
    }

    

    public String getDebugInfo()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[UNICODESTRING]
"");
        buffer.append(""    .charcount       = "")
            .append(Integer.toHexString(getCharCount())).append(""
"");
        buffer.append(""    .optionflags     = "")
            .append(Integer.toHexString(getOptionFlags())).append(""
"");
        buffer.append(""    .string          = "").append(getString())
            .append(""
"");
        buffer.append(""[/UNICODESTRING]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        int charsize = 1;

        if (getOptionFlags() == 1)
        {
            charsize = 2;
        }

        
        LittleEndian.putShort(data, 0 + offset, getCharCount());
        data[ 2 + offset ] = getOptionFlags();


        if (getOptionFlags() == 0)
        {
            StringUtil.putCompressedUnicode(getString(), data, 0x3 + offset);
        }
        else
        {
            StringUtil.putUncompressedUnicode(getString(), data,
                                              0x3 + offset);
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        int charsize = 1;

        if (getOptionFlags() == 1)
        {
            charsize = 2;
        }
        return 3 + (getString().length() * charsize);
    }

    public short getSid()
    {
        return this.sid;
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    public int compareTo(Object obj)
    {
        UnicodeString str = ( UnicodeString ) obj;

        return this.getString().compareTo(str.getString());
    }

    int maxBrokenLength(final int proposedBrokenLength)
    {
        int rval = proposedBrokenLength;

        if ((field_2_optionflags & 1) == 1)
        {
            int proposedStringLength = proposedBrokenLength - 3;

            if ((proposedStringLength % 2) == 1)
            {
                proposedStringLength--;
            }
            rval = proposedStringLength + 3;
        }
        return rval;
    }









}
"
poi,1.5,org.apache.poi.hpsf.MarkUnsupportedException,4,4,0,3,8,6,2,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,1,"

package org.apache.poi.hpsf;


public class MarkUnsupportedException extends HPSFException
{

    public MarkUnsupportedException()
    {
        super();
    }

    public MarkUnsupportedException(final String msg)
    {
        super(msg);
    }

    public MarkUnsupportedException(final Throwable reason)
    {
        super(reason);
    }

    public MarkUnsupportedException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,1.5,org.apache.poi.poifs.storage.HeaderBlockReader,7,1,0,6,20,9,2,4,7,0.833333333,173,1.0,5,0.0,0.571428571,0,0,22.85714286,2,1.0,1,"


package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LongField;
import org.apache.poi.util.ShortField;



public class HeaderBlockReader
    implements HeaderBlockConstants
{

    
    private IntegerField _bat_count;

    
    
    private IntegerField _property_start;

    
    
    private IntegerField _sbat_start;

    
    private IntegerField _xbat_start;
    private IntegerField _xbat_count;
    private byte[]       _data;

    

    public HeaderBlockReader(final InputStream stream)
        throws IOException
    {
        _data = new byte[ POIFSConstants.BIG_BLOCK_SIZE ];
        int byte_count = stream.read(_data);

        if (byte_count != POIFSConstants.BIG_BLOCK_SIZE)
        {
            String type = "" byte"" + ((byte_count == 1) ? ("""")
                                                       : (""s""));

            throw new IOException(""Unable to read entire header; ""
                                  + byte_count + type + "" read; expected ""
                                  + POIFSConstants.BIG_BLOCK_SIZE + "" bytes"");
        }

        
        LongField signature = new LongField(_signature_offset, _data);

        if (signature.get() != _signature)
        {
            throw new IOException(""Invalid header signature; read ""
                                  + signature.get() + "", expected ""
                                  + _signature);
        }
        _bat_count      = new IntegerField(_bat_count_offset, _data);
        _property_start = new IntegerField(_property_start_offset, _data);
        _sbat_start     = new IntegerField(_sbat_start_offset, _data);
        _xbat_start     = new IntegerField(_xbat_start_offset, _data);
        _xbat_count     = new IntegerField(_xbat_count_offset, _data);
    }

    

    public int getPropertyStart()
    {
        return _property_start.get();
    }

    

    public int getSBATStart()
    {
        return _sbat_start.get();
    }

    

    public int getBATCount()
    {
        return _bat_count.get();
    }

    

    public int [] getBATArray()
    {
        int[] result = new int[ _max_bats_in_header ];
        int   offset = _bat_array_offset;

        for (int j = 0; j < _max_bats_in_header; j++)
        {
            result[ j ] = LittleEndian.getInt(_data, offset);
            offset      += LittleEndianConsts.INT_SIZE;
        }
        return result;
    }

    

    public int getXBATCount()
    {
        return _xbat_count.get();
    }

    

    public int getXBATIndex()
    {
        return _xbat_start.get();
    }
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.ValueReferencePtg,14,2,0,4,24,37,2,3,14,0.833333333,151,0.833333333,2,0.368421053,0.375,1,2,9.357142857,1,0.8571,0,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.BitField;



public class ValueReferencePtg
    extends Ptg
{
    private final static int SIZE = 5;
    public final static byte sid  = 0x44;
    private short            field_1_row;
    private short            field_2_col;
    private BitField         rowRelative = new BitField(0x8000);
    private BitField         colRelative = new BitField(0x4000);

    

    public ValueReferencePtg()
    {
    }

    

    public ValueReferencePtg(byte [] data, int offset)
    {
        offset++;   
        field_1_row = LittleEndian.getShort(data, offset + 0);
        field_2_col = LittleEndian.getShort(data, offset + 2);
        System.out.println(toString());
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer(""[ValueReferencePtg]
"");

        buffer.append(""row = "").append(getRow()).append(""
"");
        buffer.append(""col = "").append(getColumnRaw()).append(""
"");
        buffer.append(""rowrelative = "").append(isRowRelative()).append(""
"");
        buffer.append(""colrelative = "").append(isColRelative()).append(""
"");
        return buffer.toString();
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public void setRow(short row)
    {
        field_1_row = row;
    }

    public short getRow()
    {
        return field_1_row;
    }

    public boolean isRowRelative()
    {
        return rowRelative.isSet(field_2_col);
    }

    public boolean isColRelative()
    {
        return rowRelative.isSet(field_2_col);
    }

    public void setColumnRaw(short col)
    {
        field_2_col = col;
    }

    public short getColumnRaw()
    {
        return field_2_col;
    }

    public void setColumn(short col)
    {
        field_2_col = col;   
    }

    public short getColumn()
    {
        return field_2_col;   
    }

    public int getSize()
    {
        return SIZE;
    }

    public String toFormulaString()
    {
        return ""NO IDEA YET VALUE REF"";
    }
}
"
poi,1.5,org.apache.poi.hssf.record.InterfaceHdrRecord,11,2,0,5,21,49,2,3,9,0.933333333,107,0.333333333,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class InterfaceHdrRecord
    extends Record
{
    public final static short sid = 0xe1;
    private short             field_1_codepage;   

    

    public final static short CODEPAGE = ( short ) 0x4b0;

    public InterfaceHdrRecord()
    {
    }

    

    public InterfaceHdrRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public InterfaceHdrRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A INTERFACEHDR RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_codepage = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setCodepage(short cp)
    {
        field_1_codepage = cp;
    }

    

    public short getCodepage()
    {
        return field_1_codepage;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[INTERFACEHDR]
"");
        buffer.append(""    .codepage        = "")
            .append(Integer.toHexString(getCodepage())).append(""
"");
        buffer.append(""[/INTERFACEHDR]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getCodepage());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.UnitsRecord,11,2,0,5,22,43,1,4,9,0.85,117,0.5,0,0.578947368,0.522727273,1,6,9.454545455,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class UnitsRecord
    extends Record
{
    public final static short      sid                             = 0x1001;
    private  short      field_1_units;


    public UnitsRecord()
    {

    }

    

    public UnitsRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public UnitsRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Units record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_units                   = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Units]
"");

        buffer.append(""    .units                = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getUnits()))
            .append("" ("").append(getUnits()).append("" )
"");

        buffer.append(""[/Units]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_units);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getUnits()
    {
        return field_1_units;
    }

    
    public void setUnits(short field_1_units)
    {
        this.field_1_units = field_1_units;
    }


}  




"
poi,1.5,org.apache.poi.hssf.dev.HSSF,4,1,0,10,49,0,0,10,4,0.0,492,1.0,2,0.0,0.5625,0,0,121.0,8,2.0,2,"


package org.apache.poi.hssf.dev;

import java.io.InputStream;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

import java.util.Random;

import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.model.*;
import org.apache.poi.hssf.usermodel.*;
import org.apache.poi.hssf.util.*;



public class HSSF
{
    private String         filename     = null;

    
    private InputStream    stream       = null;
    private Record[]       records      = null;
    protected HSSFWorkbook hssfworkbook = null;

    

    public HSSF(String filename)
        throws IOException
    {
        this.filename = filename;
        POIFSFileSystem fs =
            new POIFSFileSystem(new FileInputStream(filename));

        hssfworkbook = new HSSFWorkbook(fs);

        
    }

    

    public HSSF(String filename, boolean write)
        throws IOException
    {
        short            rownum = 0;
        FileOutputStream out    = new FileOutputStream(filename);
        HSSFWorkbook     wb     = new HSSFWorkbook();
        HSSFSheet        s      = wb.createSheet();
        HSSFRow          r      = null;
        HSSFCell         c      = null;
        HSSFCellStyle    cs     = wb.createCellStyle();
        HSSFCellStyle    cs2    = wb.createCellStyle();
        HSSFCellStyle    cs3    = wb.createCellStyle();
        HSSFFont         f      = wb.createFont();
        HSSFFont         f2     = wb.createFont();

        f.setFontHeightInPoints(( short ) 12);
        f.setColor(( short ) 0xA);
        f.setBoldweight(f.BOLDWEIGHT_BOLD);
        f2.setFontHeightInPoints(( short ) 10);
        f2.setColor(( short ) 0xf);
        f2.setBoldweight(f2.BOLDWEIGHT_BOLD);
        cs.setFont(f);
        cs.setDataFormat(HSSFDataFormat.getFormat(""($#,##0_);[Red]($#,##0)""));
        cs2.setBorderBottom(cs2.BORDER_THIN);
        cs2.setFillPattern(( short ) 1);   
        cs2.setFillForegroundColor(( short ) 0xA);
        cs2.setFont(f2);
        wb.setSheetName(0, ""HSSF Test"");
        for (rownum = ( short ) 0; rownum < 300; rownum++)
        {
            r = s.createRow(rownum);
            if ((rownum % 2) == 0)
            {
                r.setHeight(( short ) 0x249);
            }

            
            for (short cellnum = ( short ) 0; cellnum < 50; cellnum += 2)
            {
                c = r.createCell(cellnum, HSSFCell.CELL_TYPE_NUMERIC);
                c.setCellValue(rownum * 10000 + cellnum
                               + ((( double ) rownum / 1000)
                                  + (( double ) cellnum / 10000)));
                if ((rownum % 2) == 0)
                {
                    c.setCellStyle(cs);
                }
                c = r.createCell(( short ) (cellnum + 1),
                                 HSSFCell.CELL_TYPE_STRING);
                c.setCellValue(""TEST"");
                s.setColumnWidth(( short ) (cellnum + 1),
                                 ( short ) ((50 * 8) / (( double ) 1 / 20)));
                if ((rownum % 2) == 0)
                {
                    c.setCellStyle(cs2);
                }
            }   
        }

        
        rownum++;
        rownum++;
        r = s.createRow(rownum);
        cs3.setBorderBottom(cs3.BORDER_THICK);
        for (short cellnum = ( short ) 0; cellnum < 50; cellnum++)
        {
            c = r.createCell(cellnum, HSSFCell.CELL_TYPE_BLANK);

            
            c.setCellStyle(cs3);
        }
        s.addMergedRegion(new Region(( short ) 0, ( short ) 0, ( short ) 3,
                                     ( short ) 3));
        s.addMergedRegion(new Region(( short ) 100, ( short ) 100,
                                     ( short ) 110, ( short ) 110));

        
        
        s = wb.createSheet();
        wb.setSheetName(1, ""DeletedSheet"");
        wb.removeSheetAt(1);

        
        wb.write(out);
        out.close();
    }

    

    public HSSF(String infile, String outfile, boolean write)
        throws IOException
    {
        this.filename = filename;
        POIFSFileSystem fs =
            new POIFSFileSystem(new FileInputStream(filename));

        hssfworkbook = new HSSFWorkbook(fs);

        
    }

    

    public static void main(String [] args)
    {
        if (args.length < 2)
        {


        }
        else if (args.length == 2)
        {
            if (args[ 1 ].toLowerCase().equals(""write""))
            {
                System.out.println(""Write mode"");
                try
                {
                    long time = System.currentTimeMillis();
                    HSSF hssf = new HSSF(args[ 0 ], true);

                    System.out
                        .println("""" + (System.currentTimeMillis() - time)
                                 + "" ms generation time"");
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
            else
            {
                System.out.println(""readwrite test"");
                try
                {
                    HSSF             hssf   = new HSSF(args[ 0 ]);

                    
                    HSSFWorkbook     wb     = hssf.hssfworkbook;
                    FileOutputStream stream = new FileOutputStream(args[ 1 ]);

                    
                    
                    
                    
                    
                    wb.write(stream);
                    stream.close();
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }
        else if ((args.length == 3)
                 && args[ 2 ].toLowerCase().equals(""modify1""))
        {
            try   
            {
                HSSF             hssf   = new HSSF(args[ 0 ]);

                
                HSSFWorkbook     wb     = hssf.hssfworkbook;
                FileOutputStream stream = new FileOutputStream(args[ 1 ]);
                HSSFSheet        sheet  = wb.getSheetAt(0);

                for (int k = 0; k < 25; k++)
                {
                    HSSFRow row = sheet.getRow(k);

                    sheet.removeRow(row);
                }
                for (int k = 74; k < 100; k++)
                {
                    HSSFRow row = sheet.getRow(k);

                    sheet.removeRow(row);
                }
                HSSFRow  row  = sheet.getRow(39);
                HSSFCell cell = row.getCell(( short ) 3);

                cell.setCellType(HSSFCell.CELL_TYPE_STRING);
                cell.setCellValue(""MODIFIED CELL!!!!!"");

                
                
                
                
                
                wb.write(stream);
                stream.close();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}
"
poi,1.5,org.apache.poi.hpsf.DocumentSummaryInformation,16,3,0,4,27,120,1,3,16,2.0,105,0.0,0,0.625,0.53125,0,0,5.5625,1,0.9375,2,"

package org.apache.poi.hpsf;

import java.io.*;
import java.util.*;
import org.apache.poi.hpsf.wellknown.*;


public class DocumentSummaryInformation extends SpecialPropertySet
{

    
    public DocumentSummaryInformation(final PropertySet ps)
        throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isDocumentSummaryInformation())
            throw new UnexpectedPropertySetTypeException
                (""Not a "" + getClass().getName());
    }



    
    public String getCategory()
    {
        return (String) getProperty(PropertyIDMap.PID_CATEGORY);
    }



    
    public String getPresentationFormat()
    {
        return (String) getProperty(PropertyIDMap.PID_PRESFORMAT);
    }



    
    public int getByteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_BYTECOUNT);
    }



    
    public int getLineCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_LINECOUNT);
    }



    
    public int getParCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PARCOUNT);
    }



    
    public int getSlideCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SLIDECOUNT);
    }



    
    public int getNoteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_NOTECOUNT);
    }



    
    public int getHiddenCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_HIDDENCOUNT);
    }



    
    public int getMMClipCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_MMCLIPCOUNT);
    }



    
    public byte[] getScale()
    {
        if (true)
            throw new UnsupportedOperationException(""FIXME"");
        return (byte[]) getProperty(PropertyIDMap.PID_SCALE);
    }



    
    public byte[] getHeadingPair()
    {
        if (true)
            throw new UnsupportedOperationException(""FIXME"");
        return (byte[]) getProperty(PropertyIDMap.PID_HEADINGPAIR);
    }



    
    public byte[] getDocparts()
    {
        if (true)
            throw new UnsupportedOperationException(""FIXME"");
        return (byte[]) getProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public String getManager()
    {
        return (String) getProperty(PropertyIDMap.PID_MANAGER);
    }



    
    public String getCompany()
    {
        return (String) getProperty(PropertyIDMap.PID_COMPANY);
    }



    
    public byte[] getLinksDirty()
    {
        if (true)
            throw new UnsupportedOperationException(""FIXME"");
        return (byte[]) getProperty(PropertyIDMap.PID_LINKSDIRTY);
    }

}
"
poi,1.5,org.apache.poi.hssf.record.MergeCellsRecord,14,2,0,6,34,43,3,4,12,0.717948718,346,0.666666667,0,0.5,0.517857143,1,6,23.5,2,1.1429,1,"


package org.apache.poi.hssf.record;

import java.util.ArrayList;

import org.apache.poi.util.LittleEndian;



public class MergeCellsRecord
    extends Record
{
    public final static short sid = 0xe5;
    private short             field_1_num_areas;
    private ArrayList         field_2_regions;

    public MergeCellsRecord()
    {
    }

    

    public MergeCellsRecord(short sid, short size, byte [] data)
    {
        super(sid, size, data);
    }

    

    public MergeCellsRecord(short sid, short size, byte [] data, int offset)
    {
        super(sid, size, data, offset);
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_num_areas = LittleEndian.getShort(data, 0 + offset);
        field_2_regions   = new ArrayList(field_1_num_areas + 10);
        int pos = 2;

        for (int k = 0; k < field_1_num_areas; k++)
        {
            MergedRegion region =
                new MergedRegion(LittleEndian
                    .getShort(data, pos + offset), LittleEndian
                    .getShort(data, pos + 2 + offset), LittleEndian
                    .getShort(data, pos + 4 + offset), LittleEndian
                    .getShort(data, pos + 6 + offset));

            pos += 8;
            field_2_regions.add(region);
        }
    }

    

    public short getNumAreas()
    {
        return field_1_num_areas;
    }

    

    public void setNumAreas(short numareas)
    {
        field_1_num_areas = numareas;
    }

    

    public int addArea(short rowfrom, short colfrom, short rowto, short colto)
    {
        if (field_2_regions == null)
        {
            field_2_regions = new ArrayList(10);
        }
        MergedRegion region = new MergedRegion(rowfrom, rowto, colfrom,
                                               colto);

        field_2_regions.add(region);
        field_1_num_areas++;
        return field_2_regions.size() - 1;
    }

    

    public void removeAreaAt(int area)
    {
        field_2_regions.remove(area);
        field_1_num_areas--;
    }

    

    public MergedRegion getAreaAt(int index)
    {
        return ( MergedRegion ) field_2_regions.get(index);
    }

    public int getRecordSize()
    {
        int retValue;

        retValue = 6 + (8 * field_2_regions.size());
        return retValue;
    }

    public short getSid()
    {
        return sid;
    }

    public int serialize(int offset, byte [] data)
    {
        int recordsize = getRecordSize();
        int pos        = 6;

        LittleEndian.putShort(data, offset + 0, sid);
        LittleEndian.putShort(data, offset + 2, ( short ) (recordsize - 4));
        LittleEndian.putShort(data, offset + 4, getNumAreas());
        for (int k = 0; k < getNumAreas(); k++)
        {
            MergedRegion region = getAreaAt(k);

            LittleEndian.putShort(data, offset + pos, region.row_from);
            pos += 2;
            LittleEndian.putShort(data, offset + pos, region.row_to);
            pos += 2;
            LittleEndian.putShort(data, offset + pos, region.col_from);
            pos += 2;
            LittleEndian.putShort(data, offset + pos, region.col_to);
            pos += 2;
        }
        return recordsize;
    }

    public String toString()
    {
        StringBuffer retval = new StringBuffer();

        retval.append(""[MERGEDCELLS]"").append(""
"");
        retval.append(""     .sid        ="").append(sid).append(""
"");
        retval.append(""     .numregions ="").append(field_1_num_areas)
            .append(""
"");
        for (int k = 0; k < field_1_num_areas; k++)
        {
            MergedRegion region = ( MergedRegion ) field_2_regions.get(k);

            retval.append(""     .rowfrom    ="").append(region.row_from)
                .append(""
"");
            retval.append(""     .colfrom    ="").append(region.col_from)
                .append(""
"");
            retval.append(""     .rowto      ="").append(region.row_to)
                .append(""
"");
            retval.append(""     .colto      ="").append(region.col_to)
                .append(""
"");
        }
        retval.append(""[MERGEDCELLS]"").append(""
"");
        return retval.toString();
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A MERGEDCELLS RECORD!! ""
                                            + id);
        }
    }

    

    public class MergedRegion
    {

        

        public MergedRegion(short row_from, short row_to, short col_from,
                            short col_to)
        {
            this.row_from = row_from;
            this.row_to   = row_to;
            this.col_from = col_from;
            this.col_to   = col_to;
        }

        

        public short row_from;

        

        public short row_to;

        

        public short col_from;

        

        public short col_to;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.WindowProtectRecord,11,2,0,5,21,43,2,3,9,0.85,117,0.5,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class WindowProtectRecord
    extends Record
{
    public final static short sid = 0x19;
    private short             field_1_protect;

    public WindowProtectRecord()
    {
    }

    

    public WindowProtectRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public WindowProtectRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A WINDOWPROTECT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_protect = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setProtect(boolean protect)
    {
        if (protect == true)
        {
            field_1_protect = 1;
        }
        else
        {
            field_1_protect = 0;
        }
    }

    

    public boolean getProtect()
    {
        return (field_1_protect == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WINDOWPROTECT]
"");
        buffer.append(""    .protect         = "").append(getProtect())
            .append(""
"");
        buffer.append(""[/WINDOWPROTECT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, field_1_protect);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.UnknownPtg,5,2,0,1,6,10,0,1,5,1.0,18,1.0,0,0.7,0.6,1,2,2.4,1,0.6,3,"



package org.apache.poi.hssf.record.formula;



public class UnknownPtg
    extends Ptg
{
    private short size;

    

    public UnknownPtg()
    {
    }

    public UnknownPtg(byte [] data, int offset)
    {

        
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return size;
    }

    public String toFormulaString()
    {
        return ""UNKNOWN"";
    }
}
"
poi,1.5,org.apache.poi.hssf.record.FnGroupCountRecord,11,2,0,5,21,49,2,3,9,0.933333333,106,0.333333333,0,0.578947368,0.522727273,1,6,8.363636364,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class FnGroupCountRecord
    extends Record
{
    public final static short sid   = 0x9c;

    

    public final static short COUNT = 14;
    private short             field_1_count;

    public FnGroupCountRecord()
    {
    }

    

    public FnGroupCountRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FnGroupCountRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A FNGROUPCOUNT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_count = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setCount(short count)
    {
        field_1_count = count;
    }

    

    public short getCount()
    {
        return field_1_count;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FNGROUPCOUNT]
"");
        buffer.append(""    .count            = "").append(getCount())
            .append(""
"");
        buffer.append(""[/FNGROUPCOUNT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getCount());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.dev.BiffViewer,9,1,0,93,123,32,0,93,5,0.75,1079,0.5,0,0.0,0.253968254,0,0,118.6666667,89,11.1111,4,"


package org.apache.poi.hssf.dev;

import org.apache.poi.hssf.record.*;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;



public class BiffViewer
{
    String filename;
    private boolean dump;

    

    public BiffViewer(String[] args)
    {
        if (args.length > 0)
        {
            filename = args[0];
        } else
        {
            System.out.println(""BIFFVIEWER REQUIRES A FILENAME***"");
        }
    }

    

    public void run()
    {
        try
        {
            POIFSFileSystem fs =
                    new POIFSFileSystem(new FileInputStream(filename));
            InputStream stream =
                    fs.createDocumentInputStream(""Workbook"");
            Record[] records = createRecords(stream, dump);
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    

    public static Record[] createRecords(InputStream in, boolean dump)
            throws RecordFormatException
    {
        ArrayList records = new ArrayList();
        Record last_record = null;
        int loc = 0;

        try
        {

            short rectype = 0;

            do
            {
                rectype = LittleEndian.readShort(in);
                System.out.println(""============================================"");
                System.out.println(""Offset 0x"" + Integer.toHexString(loc) + "" ("" + loc + "")"");
                loc += 2;
                if (rectype != 0)
                {
                    short recsize = LittleEndian.readShort(in);

                    loc += 2;
                    byte[] data = new byte[(int) recsize];

                    in.read(data);
                    if ((rectype == WSBoolRecord.sid) && (recsize == 0))
                    {
                        System.out.println(loc);
                    }
                    loc += recsize;

                    if (dump)
                    {
                        dump(rectype, recsize, data);
                    }
                    Record[] recs = createRecord(rectype, recsize,
                            data);   

                    Record record = recs[0];

                    if ((record instanceof UnknownRecord)
                            && !dump)                 
                    {                                 
                        dumpUnknownRecord(data);
                    }
                    if (record != null)
                    {
                        if (rectype == ContinueRecord.sid)
                        {
                            dumpContinueRecord(last_record, dump, data);
                        } else
                        {
                            last_record = record;
                            records.add(record);
                        }
                    }
                }
            } while (rectype != 0);
        } catch (IOException e)
        {
            throw new RecordFormatException(""Error reading bytes"");
        }
        Record[] retval = new Record[records.size()];

        retval = (Record[]) records.toArray(retval);
        return retval;
    }

    private static void dumpContinueRecord(Record last_record, boolean dump, byte[] data) throws IOException
    {
        if (last_record == null)
        {
            throw new RecordFormatException(
                    ""First record is a ContinueRecord??"");
        }
        if (dump)
        {
            System.out.println(
                    ""-----PRECONTINUED LAST RECORD WOULD SERIALIZE LIKE:"");
            byte[] lr = last_record.serialize();

            if (lr != null)
            {
                HexDump.dump(last_record.serialize(),
                        0, System.out, 0);
            }
            System.out.println();
            System.out.println(
                    ""-----PRECONTINUED----------------------------------"");
        }
        last_record.processContinueRecord(data);
        if (dump)
        {
            System.out.println(
                    ""-----CONTINUED LAST RECORD WOULD SERIALIZE LIKE:"");
            HexDump.dump(last_record.serialize(), 0,
                    System.out, 0);
            System.out.println();
            System.out.println(
                    ""-----CONTINUED----------------------------------"");
        }
    }

    private static void dumpUnknownRecord(byte[] data) throws IOException
    {
        
        System.out.println(
                ""-----UNKNOWN----------------------------------"");
        if (data.length > 0)
        {
            HexDump.dump(data, 0, System.out, 0);
        } else
        {
            System.out.print(""**NO RECORD DATA**"");
        }
        System.out.println();
        System.out.println(
                ""-----UNKNOWN----------------------------------"");
    }

    private static void dump(short rectype, short recsize, byte[] data) throws IOException
    {


        System.out.print(""rectype = 0x""
                + Integer.toHexString(rectype));
        System.out.println("", recsize = 0x""
                + Integer.toHexString(recsize));
        System.out.println(
                ""-BEGIN DUMP---------------------------------"");
        if (data.length > 0)
        {
            HexDump.dump(data, 0, System.out, 0);
        } else
        {
            System.out.println(""**NO RECORD DATA**"");
        }

        System.out.println(
                ""-END DUMP-----------------------------------"");
    }

    

    private static Record[] createRecord(short rectype, short size,
                                         byte[] data)
    {
        Record retval = null;
        Record[] realretval = null;

        
        switch (rectype)
        {

            case ChartRecord.sid:
                retval = new ChartRecord(rectype, size, data);
                break;

            case ChartFormatRecord.sid:
                retval = new ChartFormatRecord(rectype, size, data);
                break;

            case SeriesRecord.sid:
                retval = new SeriesRecord(rectype, size, data);
                break;

            case BeginRecord.sid:
                retval = new BeginRecord(rectype, size, data);
                break;

            case EndRecord.sid:
                retval = new EndRecord(rectype, size, data);
                break;

            case BOFRecord.sid:
                retval = new BOFRecord(rectype, size, data);
                break;

            case InterfaceHdrRecord.sid:
                retval = new InterfaceHdrRecord(rectype, size, data);
                break;

            case MMSRecord.sid:
                retval = new MMSRecord(rectype, size, data);
                break;

            case InterfaceEndRecord.sid:
                retval = new InterfaceEndRecord(rectype, size, data);
                break;

            case WriteAccessRecord.sid:
                retval = new WriteAccessRecord(rectype, size, data);
                break;

            case CodepageRecord.sid:
                retval = new CodepageRecord(rectype, size, data);
                break;

            case DSFRecord.sid:
                retval = new DSFRecord(rectype, size, data);
                break;

            case TabIdRecord.sid:
                retval = new TabIdRecord(rectype, size, data);
                break;

            case FnGroupCountRecord.sid:
                retval = new FnGroupCountRecord(rectype, size, data);
                break;

            case WindowProtectRecord.sid:
                retval = new WindowProtectRecord(rectype, size, data);
                break;

            case ProtectRecord.sid:
                retval = new ProtectRecord(rectype, size, data);
                break;

            case PasswordRecord.sid:
                retval = new PasswordRecord(rectype, size, data);
                break;

            case ProtectionRev4Record.sid:
                retval = new ProtectionRev4Record(rectype, size, data);
                break;

            case PasswordRev4Record.sid:
                retval = new PasswordRev4Record(rectype, size, data);
                break;

            case WindowOneRecord.sid:
                retval = new WindowOneRecord(rectype, size, data);
                break;

            case BackupRecord.sid:
                retval = new BackupRecord(rectype, size, data);
                break;

            case HideObjRecord.sid:
                retval = new HideObjRecord(rectype, size, data);
                break;

            case DateWindow1904Record.sid:
                retval = new DateWindow1904Record(rectype, size, data);
                break;

            case PrecisionRecord.sid:
                retval = new PrecisionRecord(rectype, size, data);
                break;

            case RefreshAllRecord.sid:
                retval = new RefreshAllRecord(rectype, size, data);
                break;

            case BookBoolRecord.sid:
                retval = new BookBoolRecord(rectype, size, data);
                break;

            case FontRecord.sid:
                retval = new FontRecord(rectype, size, data);
                break;

            case FormatRecord.sid:
                retval = new FormatRecord(rectype, size, data);
                break;

            case ExtendedFormatRecord.sid:
                retval = new ExtendedFormatRecord(rectype, size, data);
                break;

            case StyleRecord.sid:
                retval = new StyleRecord(rectype, size, data);
                break;

            case UseSelFSRecord.sid:
                retval = new UseSelFSRecord(rectype, size, data);
                break;

            case BoundSheetRecord.sid:
                retval = new BoundSheetRecord(rectype, size, data);
                break;

            case CountryRecord.sid:
                retval = new CountryRecord(rectype, size, data);
                break;

            case SSTRecord.sid:
                retval = new SSTRecord(rectype, size, data);
                break;

            case ExtSSTRecord.sid:
                retval = new ExtSSTRecord(rectype, size, data);
                break;

            case EOFRecord.sid:
                retval = new EOFRecord(rectype, size, data);
                break;

            case IndexRecord.sid:
                retval = new IndexRecord(rectype, size, data);
                break;

            case CalcModeRecord.sid:
                retval = new CalcModeRecord(rectype, size, data);
                break;

            case CalcCountRecord.sid:
                retval = new CalcCountRecord(rectype, size, data);
                break;

            case RefModeRecord.sid:
                retval = new RefModeRecord(rectype, size, data);
                break;

            case IterationRecord.sid:
                retval = new IterationRecord(rectype, size, data);
                break;

            case DeltaRecord.sid:
                retval = new DeltaRecord(rectype, size, data);
                break;

            case SaveRecalcRecord.sid:
                retval = new SaveRecalcRecord(rectype, size, data);
                break;

            case PrintHeadersRecord.sid:
                retval = new PrintHeadersRecord(rectype, size, data);
                break;

            case PrintGridlinesRecord.sid:
                retval = new PrintGridlinesRecord(rectype, size, data);
                break;

            case GridsetRecord.sid:
                retval = new GridsetRecord(rectype, size, data);
                break;

            case GutsRecord.sid:
                retval = new GutsRecord(rectype, size, data);
                break;

            case DefaultRowHeightRecord.sid:
                retval = new DefaultRowHeightRecord(rectype, size, data);
                break;

            case WSBoolRecord.sid:
                retval = new WSBoolRecord(rectype, size, data);
                break;

            case HeaderRecord.sid:
                retval = new HeaderRecord(rectype, size, data);
                break;

            case FooterRecord.sid:
                retval = new FooterRecord(rectype, size, data);
                break;

            case HCenterRecord.sid:
                retval = new HCenterRecord(rectype, size, data);
                break;

            case VCenterRecord.sid:
                retval = new VCenterRecord(rectype, size, data);
                break;

            case PrintSetupRecord.sid:
                retval = new PrintSetupRecord(rectype, size, data);
                break;

            case DefaultColWidthRecord.sid:
                retval = new DefaultColWidthRecord(rectype, size, data);
                break;

            case DimensionsRecord.sid:
                retval = new DimensionsRecord(rectype, size, data);
                break;

            case RowRecord.sid:
                retval = new RowRecord(rectype, size, data);
                break;

            case LabelSSTRecord.sid:
                retval = new LabelSSTRecord(rectype, size, data);
                break;

            case RKRecord.sid:
                retval = new RKRecord(rectype, size, data);
                break;

            case NumberRecord.sid:
                retval = new NumberRecord(rectype, size, data);
                break;

            case DBCellRecord.sid:
                retval = new DBCellRecord(rectype, size, data);
                break;

            case WindowTwoRecord.sid:
                retval = new WindowTwoRecord(rectype, size, data);
                break;

            case SelectionRecord.sid:
                retval = new SelectionRecord(rectype, size, data);
                break;

            case ContinueRecord.sid:
                retval = new ContinueRecord(rectype, size, data);
                break;

            case LabelRecord.sid:
                retval = new LabelRecord(rectype, size, data);
                break;

            case MulRKRecord.sid:
                retval = new MulRKRecord(rectype, size, data);
                break;

            case MulBlankRecord.sid:
                retval = new MulBlankRecord(rectype, size, data);
                break;

            case BlankRecord.sid:
                retval = new BlankRecord(rectype, size, data);
                break;

            case BoolErrRecord.sid:
                retval = new BoolErrRecord(rectype, size, data);
                break;

            case ColumnInfoRecord.sid:
                retval = new ColumnInfoRecord(rectype, size, data);
                break;

            case MergeCellsRecord.sid:
                retval = new MergeCellsRecord(rectype, size, data);
                break;

            case AreaRecord.sid:
                retval = new AreaRecord(rectype, size, data);
                break;

            case DataFormatRecord.sid:
                retval = new DataFormatRecord(rectype, size, data);
                break;

            case BarRecord.sid:
                retval = new BarRecord(rectype, size, data);
                break;

            case DatRecord.sid:
                retval = new DatRecord(rectype, size, data);
                break;

            case PlotGrowthRecord.sid:
                retval = new PlotGrowthRecord(rectype, size, data);
                break;

            case UnitsRecord.sid:
                retval = new UnitsRecord(rectype, size, data);
                break;

            case FrameRecord.sid:
                retval = new FrameRecord(rectype, size, data);
                break;

            case ValueRangeRecord.sid:
                retval = new ValueRangeRecord(rectype, size, data);
                break;

            case SeriesListRecord.sid:
                retval = new SeriesListRecord(rectype, size, data);
                break;

            case FontBasisRecord.sid:
                retval = new FontBasisRecord(rectype, size, data);
                break;

            case FontIndexRecord.sid:
                retval = new FontIndexRecord(rectype, size, data);
                break;

            case LineFormatRecord.sid:
                retval = new LineFormatRecord(rectype, size, data);
                break;

            case AreaFormatRecord.sid:
                retval = new AreaFormatRecord(rectype, size, data);
                break;

            case LinkedDataRecord.sid:
                retval = new LinkedDataRecord(rectype, size, data);
                break;
                



                
            case SheetPropertiesRecord.sid:
                retval = new SheetPropertiesRecord(rectype, size, data);
                break;


            default :
                retval = new UnknownRecord(rectype, size, data);
        }
        if (realretval == null)
        {
            realretval = new Record[1];
            realretval[0] = retval;
            System.out.println(""recordid = 0x"" + Integer.toHexString(rectype) + "", size ="" + size);
            System.out.println(realretval[0].toString());
        }
        return realretval;
    }

    

    public void setDump(boolean dump)
    {
        this.dump = dump;
    }

    

    public static void main(String[] args)
    {
        try
        {
            BiffViewer viewer = new BiffViewer(args);

            if ((args.length > 1) && args[1].equals(""on""))
            {
                viewer.setDump(true);
            }
            if ((args.length > 1) && args[1].equals(""bfd""))
            {
                POIFSFileSystem fs =
                        new POIFSFileSystem(new FileInputStream(args[0]));
                InputStream stream =
                        fs.createDocumentInputStream(""Workbook"");
                int size = stream.available();
                byte[] data = new byte[size];

                stream.read(data);
                HexDump.dump(data, 0, System.out, 0);
            } else
            {
                viewer.run();
            }
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.SmallDocumentBlock,12,1,0,8,25,24,6,2,8,0.863636364,319,1.0,0,0.0,0.214285714,0,0,25.25,3,1.25,0,"


package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;



public class SmallDocumentBlock
    implements BlockWritable, ListManagedBlock
{
    private byte[]            _data;
    private static final byte _default_fill         = ( byte ) 0xff;
    private static final int  _block_size           = 64;
    private static final int  _blocks_per_big_block =
        POIFSConstants.BIG_BLOCK_SIZE / _block_size;

    private SmallDocumentBlock(final byte [] data, final int index)
    {
        this();
        System.arraycopy(data, index * _block_size, _data, 0, _block_size);
    }

    private SmallDocumentBlock()
    {
        _data = new byte[ _block_size ];
    }

    

    public static SmallDocumentBlock [] convert(final byte [] array,
                                                final int size)
    {
        SmallDocumentBlock[] rval   =
            new SmallDocumentBlock[ (size + _block_size - 1) / _block_size ];
        int                  offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new SmallDocumentBlock();
            if (offset < array.length)
            {
                int length = Math.min(_block_size, array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != _block_size)
                {
                    Arrays.fill(rval[ k ]._data, length, _block_size,
                                _default_fill);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_fill);
            }
            offset += _block_size;
        }
        return rval;
    }

    

    public static int fill(final List blocks)
    {
        int count           = blocks.size();
        int big_block_count = (count + _blocks_per_big_block - 1)
                              / _blocks_per_big_block;
        int full_count      = big_block_count * _blocks_per_big_block;

        for (; count < full_count; count++)
        {
            blocks.add(makeEmptySmallDocumentBlock());
        }
        return big_block_count;
    }

    

    public static SmallDocumentBlock [] convert(final BlockWritable [] store,
                                                final int size)
        throws IOException, ArrayIndexOutOfBoundsException
    {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();

        for (int j = 0; j < store.length; j++)
        {
            store[ j ].writeBlocks(stream);
        }
        byte[]               data = stream.toByteArray();
        SmallDocumentBlock[] rval =
            new SmallDocumentBlock[ convertToBlockCount(size) ];

        for (int index = 0; index < rval.length; index++)
        {
            rval[ index ] = new SmallDocumentBlock(data, index);
        }
        return rval;
    }

    

    public static List extract(ListManagedBlock [] blocks)
        throws IOException
    {
        List sdbs = new ArrayList();

        for (int j = 0; j < blocks.length; j++)
        {
            byte[] data = blocks[ j ].getData();

            for (int k = 0; k < _blocks_per_big_block; k++)
            {
                sdbs.add(new SmallDocumentBlock(data, k));
            }
        }
        return sdbs;
    }

    

    public static void read(final BlockWritable [] blocks,
                            final byte [] buffer, final int offset)
    {
        int firstBlockIndex  = offset / _block_size;
        int firstBlockOffset = offset % _block_size;
        int lastBlockIndex   = (offset + buffer.length - 1) / _block_size;

        if (firstBlockIndex == lastBlockIndex)
        {
            System.arraycopy(
                (( SmallDocumentBlock ) blocks[ firstBlockIndex ])._data,
                firstBlockOffset, buffer, 0, buffer.length);
        }
        else
        {
            int buffer_offset = 0;

            System.arraycopy(
                (( SmallDocumentBlock ) blocks[ firstBlockIndex ])._data,
                firstBlockOffset, buffer, buffer_offset,
                _block_size - firstBlockOffset);
            buffer_offset += _block_size - firstBlockOffset;
            for (int j = firstBlockIndex + 1; j < lastBlockIndex; j++)
            {
                System.arraycopy((( SmallDocumentBlock ) blocks[ j ])._data,
                                 0, buffer, buffer_offset, _block_size);
                buffer_offset += _block_size;
            }
            System.arraycopy(
                (( SmallDocumentBlock ) blocks[ lastBlockIndex ])._data, 0,
                buffer, buffer_offset, buffer.length - buffer_offset);
        }
    }

    

    public static int calcSize(int size)
    {
        return size * _block_size;
    }

    private static SmallDocumentBlock makeEmptySmallDocumentBlock()
    {
        SmallDocumentBlock block = new SmallDocumentBlock();

        Arrays.fill(block._data, _default_fill);
        return block;
    }

    private static int convertToBlockCount(final int size)
    {
        return (size + _block_size - 1) / _block_size;
    }

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        stream.write(_data);
    }

    
    

    

    public byte [] getData()
        throws IOException
    {
        return _data;
    }

    
}   

"
poi,1.5,org.apache.poi.poifs.storage.RawDataBlockList,5,2,0,8,16,10,4,4,5,2.0,50,0.0,0,0.555555556,0.5,0,0,9.0,1,0.8,0,"


package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;



public class RawDataBlockList
    extends BlockListImpl
{

    

    public RawDataBlockList(final InputStream stream)
        throws IOException
    {
        List blocks = new ArrayList();

        while (true)
        {
            RawDataBlock block = new RawDataBlock(stream);

            if (block.eof())
            {
                break;
            }
            blocks.add(block);
        }
        setBlocks(( RawDataBlock [] ) blocks.toArray(new RawDataBlock[ 0 ]));
    }
}   

"
poi,1.5,org.apache.poi.hssf.record.BarRecord,23,2,0,6,39,39,1,5,21,0.772727273,382,0.875,4,0.35483871,0.356521739,1,6,15.26086957,2,0.913,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class BarRecord
    extends Record
{
    public final static short      sid                             = 0x1017;
    private  short      field_1_barSpace;
    private  short      field_2_categorySpace;
    private  short      field_3_formatFlags;
    private BitField   horizontal                                 = new BitField(0x1);
    private BitField   stacked                                    = new BitField(0x2);
    private BitField   displayAsPercentage                        = new BitField(0x4);
    private BitField   shadow                                     = new BitField(0x8);


    public BarRecord()
    {
        field_2_categorySpace = 50;

    }

    

    public BarRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BarRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Bar record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_barSpace                = LittleEndian.getShort(data, 0x0 + offset);
        field_2_categorySpace           = LittleEndian.getShort(data, 0x2 + offset);
        field_3_formatFlags             = LittleEndian.getShort(data, 0x4 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Bar]
"");

        buffer.append(""    .barSpace             = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getBarSpace()))
            .append("" ("").append(getBarSpace()).append("" )
"");

        buffer.append(""    .categorySpace        = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getCategorySpace()))
            .append("" ("").append(getCategorySpace()).append("" )
"");

        buffer.append(""    .formatFlags          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormatFlags()))
            .append("" ("").append(getFormatFlags()).append("" )
"");
        buffer.append(""         .horizontal               = "").append(isHorizontal          ()).append('
');
        buffer.append(""         .stacked                  = "").append(isStacked             ()).append('
');
        buffer.append(""         .displayAsPercentage      = "").append(isDisplayAsPercentage ()).append('
');
        buffer.append(""         .shadow                   = "").append(isShadow              ()).append('
');

        buffer.append(""[/Bar]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_barSpace);
        LittleEndian.putShort(data, 6 + offset, field_2_categorySpace);
        LittleEndian.putShort(data, 8 + offset, field_3_formatFlags);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getBarSpace()
    {
        return field_1_barSpace;
    }

    
    public void setBarSpace(short field_1_barSpace)
    {
        this.field_1_barSpace = field_1_barSpace;
    }

    
    public short getCategorySpace()
    {
        return field_2_categorySpace;
    }

    
    public void setCategorySpace(short field_2_categorySpace)
    {
        this.field_2_categorySpace = field_2_categorySpace;
    }

    
    public short getFormatFlags()
    {
        return field_3_formatFlags;
    }

    
    public void setFormatFlags(short field_3_formatFlags)
    {
        this.field_3_formatFlags = field_3_formatFlags;
    }

    
    public void setHorizontal(boolean value)
    {
        field_3_formatFlags = horizontal.setShortBoolean(field_3_formatFlags, value);
    }

    
    public boolean isHorizontal()
    {
        return horizontal.isSet(field_3_formatFlags);
    }

    
    public void setStacked(boolean value)
    {
        field_3_formatFlags = stacked.setShortBoolean(field_3_formatFlags, value);
    }

    
    public boolean isStacked()
    {
        return stacked.isSet(field_3_formatFlags);
    }

    
    public void setDisplayAsPercentage(boolean value)
    {
        field_3_formatFlags = displayAsPercentage.setShortBoolean(field_3_formatFlags, value);
    }

    
    public boolean isDisplayAsPercentage()
    {
        return displayAsPercentage.isSet(field_3_formatFlags);
    }

    
    public void setShadow(boolean value)
    {
        field_3_formatFlags = shadow.setShortBoolean(field_3_formatFlags, value);
    }

    
    public boolean isShadow()
    {
        return shadow.isSet(field_3_formatFlags);
    }


}  




"
poi,1.5,org.apache.poi.hssf.eventmodel.HSSFListener,1,1,0,6,1,0,5,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.hssf.eventmodel;

import org.apache.poi.hssf.record.Record;



public interface HSSFListener
{

    

    public void processRecord(Record record);
}
"
poi,1.5,org.apache.poi.poifs.storage.BlockAllocationTableWriter,8,1,0,7,17,0,2,5,7,0.571428571,134,1.0,2,0.0,0.458333333,0,0,15.375,3,1.375,0,"


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.util.IntList;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;



public class BlockAllocationTableWriter
    implements BlockWritable, BATManaged
{
    private IntList    _entries;
    private BATBlock[] _blocks;
    private int        _start_block;

    

    public BlockAllocationTableWriter()
    {
        _start_block = POIFSConstants.END_OF_CHAIN;
        _entries     = new IntList();
        _blocks      = new BATBlock[ 0 ];
    }

    

    public int createBlocks()
    {
        int xbat_blocks = 0;
        int bat_blocks  = 0;

        while (true)
        {
            int calculated_bat_blocks  =
                BATBlock.calculateStorageRequirements(bat_blocks
                                                      + xbat_blocks
                                                      + _entries.size());
            int calculated_xbat_blocks =
                HeaderBlockWriter
                    .calculateXBATStorageRequirements(calculated_bat_blocks);

            if ((bat_blocks == calculated_bat_blocks)
                    && (xbat_blocks == calculated_xbat_blocks))
            {

                
                break;
            }
            else
            {
                bat_blocks  = calculated_bat_blocks;
                xbat_blocks = calculated_xbat_blocks;
            }
        }
        int startBlock = allocateSpace(bat_blocks);

        allocateSpace(xbat_blocks);
        simpleCreateBlocks();
        return startBlock;
    }

    

    public int allocateSpace(final int blockCount)
    {
        int startBlock = _entries.size();

        if (blockCount > 0)
        {
            int limit = blockCount - 1;
            int index = startBlock + 1;

            for (int k = 0; k < limit; k++)
            {
                _entries.add(index++);
            }
            _entries.add(POIFSConstants.END_OF_CHAIN);
        }
        return startBlock;
    }

    

    public int getStartBlock()
    {
        return _start_block;
    }

    

    void simpleCreateBlocks()
    {
        _blocks = BATBlock.createBATBlocks(_entries.toArray());
    }

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        for (int j = 0; j < _blocks.length; j++)
        {
            _blocks[ j ].writeBlocks(stream);
        }
    }

    
    

    

    public int countBlocks()
    {
        return _blocks.length;
    }

    

    public void setStartBlock(int start_block)
    {
        _start_block = start_block;
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.MemErrPtg,9,2,0,2,12,24,1,2,9,0.9375,48,0.75,0,0.5,0.416666667,1,2,3.888888889,1,0.7778,3,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.LittleEndian;



public class MemErrPtg
    extends Ptg
{
    public final static short sid  = 0x27;
    private final static int  SIZE = 7;
    private int               field_1_reserved;
    private short             field_2_subex_len;

    

    public MemErrPtg()
    {
    }

    public MemErrPtg(byte [] data, int offset)
    {
        field_1_reserved  = LittleEndian.getInt(data, 0);
        field_2_subex_len = LittleEndian.getShort(data, 4);
    }

    public void setReserved(int res)
    {
        field_1_reserved = res;
    }

    public int getReserved()
    {
        return field_1_reserved;
    }

    public void setSubexpressionLength(short subexlen)
    {
        field_2_subex_len = subexlen;
    }

    public short getSubexpressionLength()
    {
        return field_2_subex_len;
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return SIZE;
    }

    public String toFormulaString()
    {
        return ""ERR#"";
    }
}
"
poi,1.5,org.apache.poi.poifs.dev.POIFSViewer,3,1,0,2,21,3,0,2,2,2.0,112,0.0,0,0.0,0.333333333,0,0,36.33333333,4,2.3333,0,"


package org.apache.poi.poifs.dev;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.filesystem.POIFSFileSystem;



public class POIFSViewer
{

    

    public static void main(final String args[])
    {
        if (args.length < 0)
        {
            System.err.println(""Must specify at least one file to view"");
            System.exit(1);
        }
        boolean printNames = (args.length > 1);

        for (int j = 0; j < args.length; j++)
        {
            viewFile(args[ j ], printNames);
        }
    }

    private static void viewFile(final String filename,
                                 final boolean printName)
    {
        if (printName)
        {
            StringBuffer flowerbox = new StringBuffer();

            flowerbox.append(""."");
            for (int j = 0; j < filename.length(); j++)
            {
                flowerbox.append(""-"");
            }
            flowerbox.append(""."");
            System.out.println(flowerbox);
            System.out.println(""|"" + filename + ""|"");
            System.out.println(flowerbox);
        }
        try
        {
            POIFSViewable fs      =
                new POIFSFileSystem(new FileInputStream(filename));
            List          strings = POIFSViewEngine.inspectViewable(fs, true,
                                        0, ""  "");
            Iterator      iter    = strings.iterator();

            while (iter.hasNext())
            {
                System.out.print(iter.next());
            }
        }
        catch (IOException e)
        {
            System.out.println(e.getMessage());
        }
    }
}   

"
poi,1.5,org.apache.poi.hssf.record.CalcModeRecord,11,2,0,5,21,49,2,3,9,1.0,109,0.2,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class CalcModeRecord
    extends Record
{
    public final static short sid                     = 0xD;

    

    public final static short MANUAL                  = 0;

    

    public final static short AUTOMATIC               = 1;

    

    public final static short AUTOMATIC_EXCEPT_TABLES = -1;
    private short             field_1_calcmode;

    public CalcModeRecord()
    {
    }

    

    public CalcModeRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public CalcModeRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An Calc Mode RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_calcmode = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setCalcMode(short calcmode)
    {
        field_1_calcmode = calcmode;
    }

    

    public short getCalcMode()
    {
        return field_1_calcmode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CALCMODE]
"");
        buffer.append(""    .calcmode       = "")
            .append(Integer.toHexString(getCalcMode())).append(""
"");
        buffer.append(""[/CALCMODE]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, getCalcMode());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.AreaRecord,17,2,0,6,33,4,1,5,15,0.7,252,0.8,3,0.44,0.376470588,1,6,13.52941176,2,0.8824,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class AreaRecord
    extends Record
{
    public final static short      sid                             = 0x101A;
    private  short      field_1_formatFlags;
    private BitField   stacked                                    = new BitField(0x1);
    private BitField   displayAsPercentage                        = new BitField(0x2);
    private BitField   shadow                                     = new BitField(0x4);


    public AreaRecord()
    {

    }

    

    public AreaRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public AreaRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Area record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_formatFlags             = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Area]
"");

        buffer.append(""    .formatFlags          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormatFlags()))
            .append("" ("").append(getFormatFlags()).append("" )
"");
        buffer.append(""         .stacked                  = "").append(isStacked             ()).append('
');
        buffer.append(""         .displayAsPercentage      = "").append(isDisplayAsPercentage ()).append('
');
        buffer.append(""         .shadow                   = "").append(isShadow              ()).append('
');

        buffer.append(""[/Area]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_formatFlags);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getFormatFlags()
    {
        return field_1_formatFlags;
    }

    
    public void setFormatFlags(short field_1_formatFlags)
    {
        this.field_1_formatFlags = field_1_formatFlags;
    }

    
    public void setStacked(boolean value)
    {
        field_1_formatFlags = stacked.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isStacked()
    {
        return stacked.isSet(field_1_formatFlags);
    }

    
    public void setDisplayAsPercentage(boolean value)
    {
        field_1_formatFlags = displayAsPercentage.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isDisplayAsPercentage()
    {
        return displayAsPercentage.isSet(field_1_formatFlags);
    }

    
    public void setShadow(boolean value)
    {
        field_1_formatFlags = shadow.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isShadow()
    {
        return shadow.isSet(field_1_formatFlags);
    }


}  




"
poi,1.5,org.apache.poi.poifs.dev.POIFSViewable,4,1,0,6,4,6,6,0,4,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.dev;

import java.util.Iterator;



public interface POIFSViewable
{

    

    public Object [] getViewableArray();

    

    public Iterator getViewableIterator();

    

    public boolean preferArray();

    

    public String getShortDescription();
}   

"
poi,1.5,org.apache.poi.hpsf.Property,6,1,0,4,15,9,2,2,4,0.8,218,1.0,0,0.0,0.666666667,0,0,34.83333333,3,1.1667,4,"

package org.apache.poi.hpsf;

import java.util.*;
import org.apache.poi.hpsf.littleendian.*;


public class Property
{

    private int id;

    
    public int getID()
    {
        return id;
    }



    private int type;

    
    public int getType()
    {
        return type;
    }



    private Object value;

    
    public Object getValue()
    {
        return value;
    }



    
    public Property(final int id, final byte[] src, final int offset,
                    final int length)
    {
        this.id = id;

        
        if (id == 0)
        {
            value = readDictionary(src, offset, length);
            return;
        }

        








        int o = offset;
        type = new DWord(src, o).intValue();
        o += DWord.LENGTH;

        
        switch (type)
        {
            case Variant.VT_I4:
            {
                
                value = new Integer(new DWord(src, o).intValue());
                break;
            }
            case Variant.VT_FILETIME:
            {
                
                final int low = new DWord(src, o).intValue();
                o += DWord.LENGTH;
                final int high = new DWord(src, o).intValue();
                value = Util.filetimeToDate(high, low);
                break;
            }
            case Variant.VT_LPSTR:
            {
                
                final int first = o + DWord.LENGTH;
                int last = first + new DWord(src, o).intValue() - 1;
                o += DWord.LENGTH;
                while (src[last] == 0 && first <= last)
                    last--;
                value = new String(src, first, last - first + 1);
                break;
            }
            default:
            {
                final byte[] v = new byte[length];
                for (int i = 0; i < length; i++)
                    v[i] = src[offset + i];
                value = v;
                break;
            }
        }
    }



    
    protected Map readDictionary(final byte[] src, final int offset,
                                 final int length)
    {
        
        int o = offset;

        
        final int nrEntries = new DWord(src, o).intValue();
        o += DWord.LENGTH;

        final Map m = new HashMap(nrEntries, (float) 1.0);
        for (int i = 0; i < nrEntries; i++)
        {
            
            final Integer id = new Integer(new DWord(src, o).intValue());
            o += DWord.LENGTH;

            
            final int sLength = new DWord(src, o).intValue();
            o += DWord.LENGTH;
            
            int l = sLength;
            while (src[o + l - 1] == 0x00)
                l--;
            final String s = new String(src, o, l);
            o += sLength;
            m.put(id, s);
        }
        return m;
    }



    
    protected int readCodePage(final byte[] src, final int offset)
    {
        throw new UnsupportedOperationException(""FIXME"");
    }

}
"
poi,1.5,org.apache.poi.poifs.filesystem.POIFSWriterListener,1,1,0,7,1,0,6,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.filesystem;



public interface POIFSWriterListener
{

    

    public void processPOIFSWriterEvent(POIFSWriterEvent event);
}   

"
poi,1.5,org.apache.poi.hssf.record.LabelRecord,21,2,0,7,30,198,2,5,19,0.921428571,234,0.857142857,0,0.379310345,0.361904762,1,4,9.80952381,6,1.5714,3,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class LabelRecord
    extends Record
    implements CellValueRecordInterface
{
    public final static short sid = 0x204;
    private short             field_1_row;
    private short             field_2_column;
    private short             field_3_xf_index;
    private short             field_4_string_len;
    private byte              field_5_unicode_flag;
    private String            field_6_value;

    

    public LabelRecord()
    {
    }

    

    public LabelRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public LabelRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    

    protected void validateSid(short id)
    {
        if (id != this.sid)
        {
            throw new RecordFormatException(""Not a valid LabelRecord"");
        }
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row          = LittleEndian.getShort(data, 0 + offset);
        field_2_column       = LittleEndian.getShort(data, 2 + offset);
        field_3_xf_index     = LittleEndian.getShort(data, 4 + offset);
        field_4_string_len   = LittleEndian.getShort(data, 6 + offset);
        field_5_unicode_flag = data[ 8 + offset ];
        if (isUnCompressedUnicode())
        {
            field_6_value = StringUtil.getFromUnicode(data, 8 + offset,
                                                      field_4_string_len);
        }
        else
        {
            field_6_value = new String(data, 9 + offset, getStringLength());
        }
    }


    public short getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_column;
    }

    public short getXFIndex()
    {
        return field_3_xf_index;
    }

    

    public short getStringLength()
    {
        return field_4_string_len;
    }

    

    public boolean isUnCompressedUnicode()
    {
        return (field_5_unicode_flag == 1);
    }

    

    public String getValue()
    {
        return field_6_value;
    }

    

    public int serialize(int offset, byte [] data)
    {
        throw new RecordFormatException(
            ""Label Records are supported READ ONLY...convert to LabelSST"");
    }

    public short getSid()
    {
        return this.sid;
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    

    public void setColumn(short col)
    {
    }

    

    public void setRow(short row)
    {
    }

    

    public void setXFIndex(short xf)
    {
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.DocumentDescriptor,4,1,0,2,18,0,1,1,4,0.222222222,129,1.0,1,0.0,0.4375,1,1,30.5,6,2.5,0,"


package org.apache.poi.poifs.filesystem;



public class DocumentDescriptor
{
    private POIFSDocumentPath path;
    private String            name;
    private int               hashcode = 0;

    

    public DocumentDescriptor(final POIFSDocumentPath path, final String name)
    {
        if (path == null)
        {
            throw new NullPointerException(""path must not be null"");
        }
        if (name == null)
        {
            throw new NullPointerException(""name must not be null"");
        }
        if (name.length() == 0)
        {
            throw new IllegalArgumentException(""name cannot be empty"");
        }
        this.path = path;
        this.name = name;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                DocumentDescriptor descriptor = ( DocumentDescriptor ) o;

                rval = this.path.equals(descriptor.path)
                       && this.name.equals(descriptor.name);
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            hashcode = path.hashCode() ^ name.hashCode();
        }
        return hashcode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer(40 * (path.length() + 1));

        for (int j = 0; j < path.length(); j++)
        {
            buffer.append(path.getComponent(j)).append(""/"");
        }
        buffer.append(name);
        return buffer.toString();
    }
}   

"
poi,1.5,org.apache.poi.hssf.dev.EFBiffViewer,4,1,0,6,16,4,1,6,4,0.333333333,82,0.0,0,0.0,0.416666667,0,0,19.25,3,1.25,0,"


package org.apache.poi.hssf.dev;

import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;

import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.hssf.eventmodel.*;
import org.apache.poi.hssf.record.Record;



public class EFBiffViewer
{
    String file;

    

    public EFBiffViewer()
    {
    }

    public void run()
        throws IOException
    {
        FileInputStream fin   = new FileInputStream(file);
        POIFSFileSystem poifs = new POIFSFileSystem(fin);
        InputStream     din   = poifs.createDocumentInputStream(""Workbook"");
        HSSFRequest     req   = new HSSFRequest();

        req.addListenerForAllRecords(new HSSFListener()
        {
            public void processRecord(Record rec)
            {
                System.out.println(rec.toString());
            }
        });
        HSSFEventFactory factory = new HSSFEventFactory();

        factory.processEvents(req, din);
    }

    public void setFile(String file)
    {
        this.file = file;
    }

    public static void main(String [] args)
    {
        if ((args.length == 1) && !args[ 0 ].equals(""--help""))
        {
            try
            {
                EFBiffViewer viewer = new EFBiffViewer();

                viewer.setFile(args[ 0 ]);
                viewer.run();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
        }
        else
        {
            System.out.println(""EFBiffViewer"");
            System.out.println(
                ""Outputs biffview of records based on HSSFEventFactory"");
            System.out
                .println(""usage: java org.apache.poi.hssf.dev.EBBiffViewer ""
                         + ""filename"");
        }
    }
}
"
poi,1.5,org.apache.poi.hssf.record.FontIndexRecord,11,2,0,5,22,43,1,4,9,0.85,117,0.5,0,0.578947368,0.522727273,1,6,9.454545455,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class FontIndexRecord
    extends Record
{
    public final static short      sid                             = 0x1026;
    private  short      field_1_fontIndex;


    public FontIndexRecord()
    {

    }

    

    public FontIndexRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FontIndexRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a FontIndex record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_fontIndex               = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FontIndex]
"");

        buffer.append(""    .fontIndex            = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFontIndex()))
            .append("" ("").append(getFontIndex()).append("" )
"");

        buffer.append(""[/FontIndex]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_fontIndex);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getFontIndex()
    {
        return field_1_fontIndex;
    }

    
    public void setFontIndex(short field_1_fontIndex)
    {
        this.field_1_fontIndex = field_1_fontIndex;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.PrecisionRecord,11,2,0,5,21,43,2,3,9,0.85,117,0.0,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class PrecisionRecord
    extends Record
{
    public final static short sid = 0xE;
    public short              field_1_precision;

    public PrecisionRecord()
    {
    }

    

    public PrecisionRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PrecisionRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PRECISION RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_precision = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setFullPrecision(boolean fullprecision)
    {
        if (fullprecision == true)
        {
            field_1_precision = 1;
        }
        else
        {
            field_1_precision = 0;
        }
    }

    

    public boolean getFullPrecision()
    {
        return (field_1_precision == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRECISION]
"");
        buffer.append(""    .precision       = "").append(getFullPrecision())
            .append(""
"");
        buffer.append(""[/PRECISION]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, field_1_precision);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.CodepageRecord,11,2,0,5,21,49,2,3,9,0.933333333,107,0.333333333,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class CodepageRecord
    extends Record
{
    public final static short sid = 0x42;
    private short             field_1_codepage;   

    

    public final static short CODEPAGE = ( short ) 0x4b0;

    public CodepageRecord()
    {
    }

    

    public CodepageRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public CodepageRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A CODEPAGE RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_codepage = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setCodepage(short cp)
    {
        field_1_codepage = cp;
    }

    

    public short getCodepage()
    {
        return field_1_codepage;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CODEPAGE]
"");
        buffer.append(""    .codepage        = "")
            .append(Integer.toHexString(getCodepage())).append(""
"");
        buffer.append(""[/CODEPAGE]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getCodepage());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFErrorConstants,0,1,0,0,0,0,0,0,0,2.0,7,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"



package org.apache.poi.hssf.usermodel;



public interface HSSFErrorConstants
{
    public static final byte ERROR_NULL  = 0x00;   
    public static final byte ERROR_DIV_0 = 0x07;   
    public static final byte ERROR_VALUE = 0x0f;   
    public static final byte ERROR_REF   = 0x17;   
    public static final byte ERROR_NAME  = 0x1d;   
    public static final byte ERROR_NUM   = 0x24;   
    public static final byte ERROR_NA    = 0x2a;   
}
"
poi,1.5,org.apache.poi.poifs.filesystem.DirectoryEntry,7,1,0,6,7,21,4,3,7,2.0,7,0.0,0,0.0,0.4,0,0,0.0,1,1.0,1,"


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;



public interface DirectoryEntry
    extends Entry
{

    

    public Iterator getEntries();

    

    public boolean isEmpty();

    

    public int getEntryCount();

    

    public Entry getEntry(final String name)
        throws FileNotFoundException;

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException;

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException;

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException;
}   

"
poi,1.5,org.apache.poi.hssf.record.ValueRangeRecord,39,2,0,6,58,115,1,5,37,0.858552632,697,0.9375,9,0.234042553,0.277777778,1,6,16.46153846,2,0.9487,0,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class ValueRangeRecord
    extends Record
{
    public final static short      sid                             = 0x101f;
    private  double     field_1_minimumAxisValue;
    private  double     field_2_maximumAxisValue;
    private  double     field_3_majorIncrement;
    private  double     field_4_minorIncrement;
    private  double     field_5_categoryAxisCross;
    private  short      field_6_options;
    private BitField   automaticMinimum                           = new BitField(0x1);
    private BitField   automaticMaximum                           = new BitField(0x2);
    private BitField   automaticMajor                             = new BitField(0x4);
    private BitField   automaticMinor                             = new BitField(0x8);
    private BitField   automaticCategoryCrossing                  = new BitField(0x10);
    private BitField   logarithmicScale                           = new BitField(0x20);
    private BitField   valuesInReverse                            = new BitField(0x40);
    private BitField   crossCategoryAxisAtMaximum                 = new BitField(0x80);
    private BitField   reserved                                   = new BitField(0x100);


    public ValueRangeRecord()
    {

    }

    

    public ValueRangeRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ValueRangeRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a ValueRange record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_minimumAxisValue        = LittleEndian.getDouble(data, 0x0 + offset);
        field_2_maximumAxisValue        = LittleEndian.getDouble(data, 0x8 + offset);
        field_3_majorIncrement          = LittleEndian.getDouble(data, 0x10 + offset);
        field_4_minorIncrement          = LittleEndian.getDouble(data, 0x18 + offset);
        field_5_categoryAxisCross       = LittleEndian.getDouble(data, 0x20 + offset);
        field_6_options                 = LittleEndian.getShort(data, 0x28 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ValueRange]
"");

        buffer.append(""    .minimumAxisValue     = "")
            .append("" ("").append(getMinimumAxisValue()).append("" )
"");

        buffer.append(""    .maximumAxisValue     = "")
            .append("" ("").append(getMaximumAxisValue()).append("" )
"");

        buffer.append(""    .majorIncrement       = "")
            .append("" ("").append(getMajorIncrement()).append("" )
"");

        buffer.append(""    .minorIncrement       = "")
            .append("" ("").append(getMinorIncrement()).append("" )
"");

        buffer.append(""    .categoryAxisCross    = "")
            .append("" ("").append(getCategoryAxisCross()).append("" )
"");

        buffer.append(""    .options              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getOptions()))
            .append("" ("").append(getOptions()).append("" )
"");
        buffer.append(""         .automaticMinimum         = "").append(isAutomaticMinimum    ()).append('
');
        buffer.append(""         .automaticMaximum         = "").append(isAutomaticMaximum    ()).append('
');
        buffer.append(""         .automaticMajor           = "").append(isAutomaticMajor      ()).append('
');
        buffer.append(""         .automaticMinor           = "").append(isAutomaticMinor      ()).append('
');
        buffer.append(""         .automaticCategoryCrossing     = "").append(isAutomaticCategoryCrossing()).append('
');
        buffer.append(""         .logarithmicScale         = "").append(isLogarithmicScale    ()).append('
');
        buffer.append(""         .valuesInReverse          = "").append(isValuesInReverse     ()).append('
');
        buffer.append(""         .crossCategoryAxisAtMaximum     = "").append(isCrossCategoryAxisAtMaximum()).append('
');
        buffer.append(""         .reserved                 = "").append(isReserved            ()).append('
');

        buffer.append(""[/ValueRange]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putDouble(data, 4 + offset, field_1_minimumAxisValue);
        LittleEndian.putDouble(data, 12 + offset, field_2_maximumAxisValue);
        LittleEndian.putDouble(data, 20 + offset, field_3_majorIncrement);
        LittleEndian.putDouble(data, 28 + offset, field_4_minorIncrement);
        LittleEndian.putDouble(data, 36 + offset, field_5_categoryAxisCross);
        LittleEndian.putShort(data, 44 + offset, field_6_options);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 8 + 8 + 8 + 8 + 8 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public double getMinimumAxisValue()
    {
        return field_1_minimumAxisValue;
    }

    
    public void setMinimumAxisValue(double field_1_minimumAxisValue)
    {
        this.field_1_minimumAxisValue = field_1_minimumAxisValue;
    }

    
    public double getMaximumAxisValue()
    {
        return field_2_maximumAxisValue;
    }

    
    public void setMaximumAxisValue(double field_2_maximumAxisValue)
    {
        this.field_2_maximumAxisValue = field_2_maximumAxisValue;
    }

    
    public double getMajorIncrement()
    {
        return field_3_majorIncrement;
    }

    
    public void setMajorIncrement(double field_3_majorIncrement)
    {
        this.field_3_majorIncrement = field_3_majorIncrement;
    }

    
    public double getMinorIncrement()
    {
        return field_4_minorIncrement;
    }

    
    public void setMinorIncrement(double field_4_minorIncrement)
    {
        this.field_4_minorIncrement = field_4_minorIncrement;
    }

    
    public double getCategoryAxisCross()
    {
        return field_5_categoryAxisCross;
    }

    
    public void setCategoryAxisCross(double field_5_categoryAxisCross)
    {
        this.field_5_categoryAxisCross = field_5_categoryAxisCross;
    }

    
    public short getOptions()
    {
        return field_6_options;
    }

    
    public void setOptions(short field_6_options)
    {
        this.field_6_options = field_6_options;
    }

    
    public void setAutomaticMinimum(boolean value)
    {
        field_6_options = automaticMinimum.setShortBoolean(field_6_options, value);
    }

    
    public boolean isAutomaticMinimum()
    {
        return automaticMinimum.isSet(field_6_options);
    }

    
    public void setAutomaticMaximum(boolean value)
    {
        field_6_options = automaticMaximum.setShortBoolean(field_6_options, value);
    }

    
    public boolean isAutomaticMaximum()
    {
        return automaticMaximum.isSet(field_6_options);
    }

    
    public void setAutomaticMajor(boolean value)
    {
        field_6_options = automaticMajor.setShortBoolean(field_6_options, value);
    }

    
    public boolean isAutomaticMajor()
    {
        return automaticMajor.isSet(field_6_options);
    }

    
    public void setAutomaticMinor(boolean value)
    {
        field_6_options = automaticMinor.setShortBoolean(field_6_options, value);
    }

    
    public boolean isAutomaticMinor()
    {
        return automaticMinor.isSet(field_6_options);
    }

    
    public void setAutomaticCategoryCrossing(boolean value)
    {
        field_6_options = automaticCategoryCrossing.setShortBoolean(field_6_options, value);
    }

    
    public boolean isAutomaticCategoryCrossing()
    {
        return automaticCategoryCrossing.isSet(field_6_options);
    }

    
    public void setLogarithmicScale(boolean value)
    {
        field_6_options = logarithmicScale.setShortBoolean(field_6_options, value);
    }

    
    public boolean isLogarithmicScale()
    {
        return logarithmicScale.isSet(field_6_options);
    }

    
    public void setValuesInReverse(boolean value)
    {
        field_6_options = valuesInReverse.setShortBoolean(field_6_options, value);
    }

    
    public boolean isValuesInReverse()
    {
        return valuesInReverse.isSet(field_6_options);
    }

    
    public void setCrossCategoryAxisAtMaximum(boolean value)
    {
        field_6_options = crossCategoryAxisAtMaximum.setShortBoolean(field_6_options, value);
    }

    
    public boolean isCrossCategoryAxisAtMaximum()
    {
        return crossCategoryAxisAtMaximum.isSet(field_6_options);
    }

    
    public void setReserved(boolean value)
    {
        field_6_options = reserved.setShortBoolean(field_6_options, value);
    }

    
    public boolean isReserved()
    {
        return reserved.isSet(field_6_options);
    }


}  




"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFCellStyle,42,1,0,6,88,0,3,3,41,1.0,329,0.066666667,1,0.0,0.304761905,0,0,5.761904762,1,0.9762,2,"



package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.ExtendedFormatRecord;



public class HSSFCellStyle
    implements HSSFColorConstants
{
    private ExtendedFormatRecord format                     = null;
    private short                index                      = 0;
    private short                fontindex                  = 0;

    

    public final static short    ALIGN_GENERAL              = 0x0;

    

    public final static short    ALIGN_LEFT                 = 0x1;

    

    public final static short    ALIGN_CENTER               = 0x2;

    

    public final static short    ALIGN_RIGHT                = 0x3;

    

    public final static short    ALIGN_FILL                 = 0x4;

    

    public final static short    ALIGN_JUSTIFY              = 0x5;

    

    public final static short    ALIGN_CENTER_SELECTION     = 0x6;

    

    public final static short    VERTICAL_TOP               = 0x0;

    

    public final static short    VERTICAL_CENTER            = 0x1;

    

    public final static short    VERTICAL_BOTTOM            = 0x2;

    

    public final static short    VERTICAL_JUSTIFY           = 0x3;

    

    public final static short    BORDER_NONE                = 0x0;

    

    public final static short    BORDER_THIN                = 0x1;

    

    public final static short    BORDER_MEDIUM              = 0x2;

    

    public final static short    BORDER_DASHED              = 0x3;

    

    public final static short    BORDER_DOTTED              = 0x4;

    

    public final static short    BORDER_THICK               = 0x5;

    

    public final static short    BORDER_DOUBLE              = 0x6;

    

    public final static short    BORDER_HAIR                = 0x7;

    

    public final static short    BORDER_MEDIUM_DASHED       = 0x8;

    

    public final static short    BORDER_DASH_DOT            = 0x9;

    

    public final static short    BORDER_MEDIUM_DASH_DOT     = 0xA;

    

    public final static short    BORDER_DASH_DOT_DOT        = 0xB;

    

    public final static short    BORDER_MEDIUM_DASH_DOT_DOT = 0xC;

    

    public final static short    BORDER_SLANTED_DASH_DOT    = 0xD;

    
    public final static short     NO_FILL             = 0  ;
    
    public final static short     SOLID_FOREGROUND    = 1  ;
    
    public final static short     FINE_DOTS           = 2  ;
    
    public final static short     ALT_BARS            = 3  ;
    
    public final static short     SPARSE_DOTS         = 4  ;
    
    public final static short     THICK_HORZ_BANDS    = 5  ;
    
    public final static short     THICK_VERT_BANDS    = 6  ;
    
    public final static short     THICK_BACKWARD_DIAG = 7  ;
    
    public final static short     THICK_FORWARD_DIAG  = 8  ;
    
    public final static short     BIG_SPOTS           = 9  ;
    
    public final static short     BRICKS              = 10 ;
    
    public final static short     THIN_HORZ_BANDS     = 11 ;
    
    public final static short     THIN_VERT_BANDS     = 12 ;
    
    public final static short     THIN_BACKWARD_DIAG  = 13 ;
    
    public final static short     THIN_FORWARD_DIAG   = 14 ;
    
    public final static short     SQUARES             = 15 ;
    
    public final static short     DIAMONDS            = 16 ;


    

    protected HSSFCellStyle(short index, ExtendedFormatRecord rec)
    {
        this.index = index;
        format     = rec;
    }

    

    public short getIndex()
    {
        return index;
    }

    

    public void setDataFormat(short fmt)
    {
        format.setFormatIndex(fmt);
    }

    

    public short getDataFormat()
    {
        return format.getFormatIndex();
    }

    

    public void setFont(HSSFFont font)
    {
        format.setIndentNotParentFont(true);
        fontindex = font.getIndex();
        format.setFontIndex(fontindex);
    }

    public short getFontIndex()
    {
        return format.getFontIndex();
    }

    

    public void setHidden(boolean hidden)
    {
        format.setIndentNotParentCellOptions(true);
        format.setHidden(hidden);
    }

    

    public boolean getHidden()
    {
        return format.isHidden();
    }

    

    public void setLocked(boolean locked)
    {
        format.setIndentNotParentCellOptions(true);
        format.setLocked(locked);
    }

    

    public boolean getLocked()
    {
        return format.isLocked();
    }

    

    public void setAlignment(short align)
    {
        format.setIndentNotParentAlignment(true);
        format.setAlignment(align);
    }

    

    public short getAlignment()
    {
        return format.getAlignment();
    }

    






    






    

    public void setWrapText(boolean wrapped)
    {
        format.setIndentNotParentAlignment(true);
        format.setWrapText(wrapped);
    }

    

    public boolean getWrapText()
    {
        return format.getWrapText();
    }

    

    public void setVerticalAlignment(short align)
    {
        format.setVerticalAlignment(align);
    }

    

    public short getVerticalAlignment()
    {
        return format.getVerticalAlignment();
    }

    

    public void setRotation(short rotation)
    {
        format.setRotation(rotation);
    }

    

    public short getRotation()
    {
        return format.getRotation();
    }

    

    public void setIndention(short indent)
    {
        format.setIndent(indent);
    }

    

    public short getIndention()
    {
        return format.getIndent();
    }

    

    public void setBorderLeft(short border)
    {
        format.setIndentNotParentBorder(true);
        format.setBorderLeft(border);
    }

    

    public short getBorderLeft()
    {
        return format.getBorderLeft();
    }

    

    public void setBorderRight(short border)
    {
        format.setIndentNotParentBorder(true);
        format.setBorderRight(border);
    }

    

    public short getBorderRight()
    {
        return format.getBorderRight();
    }

    

    public void setBorderTop(short border)
    {
        format.setIndentNotParentBorder(true);
        format.setBorderTop(border);
    }

    

    public short getBorderTop()
    {
        return format.getBorderTop();
    }

    

    public void setBorderBottom(short border)
    {
        format.setIndentNotParentBorder(true);
        format.setBorderBottom(border);
    }

    

    public short getBorderBottom()
    {
        return format.getBorderBottom();
    }

    

    public void setLeftBorderColor(short color)
    {
        format.setLeftBorderPaletteIdx(color);
    }

    

    public short getLeftBorderColor()
    {
        return format.getLeftBorderPaletteIdx();
    }

    

    public void setRightBorderColor(short color)
    {
        format.setRightBorderPaletteIdx(color);
    }

    

    public short getRightBorderColor()
    {
        return format.getRightBorderPaletteIdx();
    }

    

    public void setTopBorderColor(short color)
    {
        format.setTopBorderPaletteIdx(color);
    }

    

    public short getTopBorderColor()
    {
        return format.getTopBorderPaletteIdx();
    }

    

    public void setBottomBorderColor(short color)
    {
        format.setBottomBorderPaletteIdx(color);
    }

    

    public short getBottomBorderColor()
    {
        return format.getBottomBorderPaletteIdx();
    }

    
    public void setFillPattern(short fp)
    {
        format.setAdtlFillPattern(fp);
    }

    

    public short getFillPattern()
    {
        return format.getAdtlFillPattern();
    }

    

    public void setFillBackgroundColor(short bg)
    {
        format.setFillBackground(bg);
    }

    

    public short getFillBackgroundColor()
    {
        return format.getFillBackground();
    }

    

    public void setFillForegroundColor(short bg)
    {
        format.setFillForeground(bg);
    }

    

    public short getFillForegroundColor()
    {
        return format.getFillForeground();
    }

}
"
poi,1.5,org.apache.poi.hssf.record.UnknownRecord,9,2,0,7,17,2,4,3,6,0.6875,145,0.75,0,0.611111111,0.527777778,1,6,14.66666667,3,1.1111,3,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class UnknownRecord
    extends Record
{
    private short  sid     = 0;
    private short  size    = 0;
    private byte[] thedata = null;
    int            offset  = 0;

    public UnknownRecord()
    {
    }

    

    public UnknownRecord(short id, short size, byte [] data)
    {
        sid     = id;
        size    = size;
        thedata = data;
    }

    

    public int serialize(int offset, byte [] data)
    {
        if (thedata == null)
        {
            thedata = new byte[ 0 ];
        }
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) (thedata.length));
        if (thedata.length > 0)
        {
            System.arraycopy(thedata, 0, data, 4 + offset, thedata.length);
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        int retval = 4;

        if (thedata != null)
        {
            retval += thedata.length;
        }
        return retval;
    }

    protected void fillFields(byte [] data, short sid)
    {
        sid     = sid;
        thedata = data;
    }

    

    protected void validateSid(short id)
    {

        
    }

    

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[UNKNOWN RECORD]
"");
        buffer.append(""    .id        = "").append(Integer.toHexString(sid))
            .append(""
"");
        buffer.append(""[/UNKNWON RECORD]
"");
        return buffer.toString();
    }

    public short getSid()
    {
        return this.sid;
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
        throw new RecordFormatException(
            ""Unknown record cannot be constructed via offset -- we need a copy of the data"");
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.DividePtg,8,2,0,4,13,28,3,2,8,1.142857143,56,0.0,0,0.538461538,0.40625,1,2,5.75,1,0.75,4,"



package org.apache.poi.hssf.record.formula;



public class DividePtg
    extends Ptg
    implements OperationPtg
{
    public final static int  SIZE = 1;
    public final static byte sid  = 0x06;

    

    public DividePtg()
    {
    }

    public DividePtg(byte [] data, int offset)
    {

        
    }

    public void writeBytes(byte [] array, int offset)
    {
        array[ offset + 0 ] = sid;
    }

    public int getSize()
    {
        return SIZE;
    }

    public int getType()
    {
        return TYPE_BINARY;
    }

    public int getNumberOfOperands()
    {
        return 2;
    }

    public String toFormulaString()
    {
        return ""/"";
    }

    public String toFormulaString(Ptg [] operands)
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(operands[ 0 ].toFormulaString());
        buffer.append(""/"");
        buffer.append(operands[ 1 ].toFormulaString());
        return buffer.toString();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.ExpPtg,5,2,0,1,6,10,1,1,5,1.25,18,0.5,0,0.7,0.6,1,2,2.2,1,0.6,5,"



package org.apache.poi.hssf.record.formula;



public class ExpPtg
    extends Ptg
{
    private final static int  SIZE = 5;
    public final static short sid  = 0x1;

    

    public ExpPtg()
    {
    }

    

    public ExpPtg(byte [] array, int offset)
    {
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return SIZE;
    }

    public String toFormulaString()
    {
        return ""NO IDEA SHARED FORMULA EXP PTG"";
    }
}
"
poi,1.5,org.apache.poi.hpsf.HPSFException,5,3,3,3,7,4,3,0,5,0.5,29,1.0,0,0.944444444,0.6,0,0,4.6,1,0.2,1,"

package org.apache.poi.hpsf;


public class HPSFException extends Exception
{

    private Throwable reason;



    
    public HPSFException()
    {
        super();
    }



    
    public HPSFException(final String msg)
    {
        super(msg);
    }



    
    public HPSFException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }

}
"
poi,1.5,org.apache.poi.hssf.record.BoundSheetRecord,19,2,0,7,34,141,3,4,17,0.814814815,253,0.833333333,0,0.407407407,0.307017544,1,6,12.0,2,0.8947,3,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class BoundSheetRecord
    extends Record
{
    public final static short sid = 0x85;
    private int               field_1_position_of_BOF;
    private short             field_2_option_flags;
    private byte              field_3_sheetname_length;
    private byte              field_4_compressed_unicode_flag;   
    private String            field_5_sheetname;

    public BoundSheetRecord()
    {
    }

    

    public BoundSheetRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BoundSheetRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A Bound Sheet RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_position_of_BOF         = LittleEndian.getInt(data,
                0 + offset);
        field_2_option_flags            = LittleEndian.getShort(data,
                4 + offset);
        field_3_sheetname_length        = data[ 6 + offset ];
        field_4_compressed_unicode_flag = data[ 7 + offset ];
        field_5_sheetname               = new String(data, 8 + offset,
                LittleEndian.ubyteToInt( field_3_sheetname_length));
    }

    

    public void setPositionOfBof(int pos)
    {
        field_1_position_of_BOF = pos;
    }

    

    public void setOptionFlags(short flags)
    {
        field_2_option_flags = flags;
    }

    

    public void setSheetnameLength(byte len)
    {
        field_3_sheetname_length = len;
    }

    

    public void setCompressedUnicodeFlag(byte flag)
    {
        field_4_compressed_unicode_flag = flag;
    }

    

    public void setSheetname(String sheetname)
    {
        field_5_sheetname = sheetname;
    }

    

    public int getPositionOfBof()
    {
        return field_1_position_of_BOF;
    }

    

    public short getOptionFlags()
    {
        return field_2_option_flags;
    }

    

    public byte getSheetnameLength()
    {
        return field_3_sheetname_length;
    }

    

    public byte getCompressedUnicodeFlag()
    {
        return field_4_compressed_unicode_flag;
    }

    

    public String getSheetname()
    {
        return field_5_sheetname;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BOUNDSHEET]
"");
        buffer.append(""    .bof             = "")
            .append(Integer.toHexString(getPositionOfBof())).append(""
"");
        buffer.append(""    .optionflags     = "")
            .append(Integer.toHexString(getOptionFlags())).append(""
"");
        buffer.append(""    .sheetname length= "")
            .append(Integer.toHexString(getSheetnameLength())).append(""
"");
        buffer.append(""    .unicodeflag     = "")
            .append(Integer.toHexString(getCompressedUnicodeFlag()))
            .append(""
"");
        buffer.append(""    .sheetname       = "").append(getSheetname())
            .append(""
"");
        buffer.append(""[/BOUNDSHEET]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) (0x08 + getSheetnameLength()));
        LittleEndian.putInt(data, 4 + offset, getPositionOfBof());
        LittleEndian.putShort(data, 8 + offset, getOptionFlags());
        data[ 10 + offset ] = getSheetnameLength();
        data[ 11 + offset ] = getCompressedUnicodeFlag();

        
        StringUtil.putCompressedUnicode(getSheetname(), data, 12 + offset);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 12 + getSheetnameLength();
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.POIFSDocumentPath,9,1,0,10,20,0,10,0,9,0.25,294,1.0,0,0.0,0.311111111,1,1,31.44444444,7,1.8889,0,"


package org.apache.poi.poifs.filesystem;

import java.io.File;



public class POIFSDocumentPath
{
    private String[] components;
    private int      hashcode = 0;

    

    public POIFSDocumentPath(final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ 0 ];
        }
        else
        {
            this.components = new String[ components.length ];
            for (int j = 0; j < components.length; j++)
            {
                if ((components[ j ] == null)
                        || (components[ j ].length() == 0))
                {
                    throw new IllegalArgumentException(
                        ""components cannot contain null or empty strings"");
                }
                this.components[ j ] = components[ j ];
            }
        }
    }

    

    public POIFSDocumentPath()
    {
        this.components = new String[ 0 ];
    }

    

    public POIFSDocumentPath(final POIFSDocumentPath path,
                             final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ path.components.length ];
        }
        else
        {
            this.components =
                new String[ path.components.length + components.length ];
        }
        for (int j = 0; j < path.components.length; j++)
        {
            this.components[ j ] = path.components[ j ];
        }
        if (components != null)
        {
            for (int j = 0; j < components.length; j++)
            {
                if ((components[ j ] == null)
                        || (components[ j ].length() == 0))
                {
                    throw new IllegalArgumentException(
                        ""components cannot contain null or empty strings"");
                }
                this.components[ j + path.components.length ] =
                    components[ j ];
            }
        }
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                POIFSDocumentPath path = ( POIFSDocumentPath ) o;

                if (path.components.length == this.components.length)
                {
                    rval = true;
                    for (int j = 0; j < this.components.length; j++)
                    {
                        if (!path.components[ j ]
                                .equals(this.components[ j ]))
                        {
                            rval = false;
                            break;
                        }
                    }
                }
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            for (int j = 0; j < components.length; j++)
            {
                hashcode += components[ j ].hashCode();
            }
        }
        return hashcode;
    }

    

    public int length()
    {
        return components.length;
    }

    

    public String getComponent(int n)
        throws ArrayIndexOutOfBoundsException
    {
        return components[ n ];
    }

    

    public POIFSDocumentPath getParent()
    {
        final int length = components.length - 1;

        if (length < 0)
        {
            return null;
        }
        POIFSDocumentPath parent = new POIFSDocumentPath(null);

        parent.components = new String[ length ];
        System.arraycopy(components, 0, parent.components, 0, length);
        return parent;
    }

    

    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int          l = length();

        b.append(File.separatorChar);
        for (int i = 0; i < l; i++)
        {
            b.append(getComponent(i));
            if (i < l - 1)
            {
                b.append(File.separatorChar);
            }
        }
        return b.toString();
    }
}   

"
poi,1.5,org.apache.poi.poifs.filesystem.POIFSWriterEvent,5,1,0,5,6,2,3,2,4,0.75,36,1.0,2,0.0,0.36,0,0,5.4,1,0.8,0,"


package org.apache.poi.poifs.filesystem;



public class POIFSWriterEvent
{
    private DocumentOutputStream stream;
    private POIFSDocumentPath    path;
    private String               documentName;
    private int                  limit;

    

    POIFSWriterEvent(final DocumentOutputStream stream,
                     final POIFSDocumentPath path, final String documentName,
                     final int limit)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
        this.limit        = limit;
    }

    

    public DocumentOutputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }

    

    public int getLimit()
    {
        return limit;
    }
}   

"
poi,1.5,org.apache.poi.poifs.property.Property,30,1,3,18,60,257,13,5,16,0.95841785,671,1.0,14,0.0,0.2,0,0,20.23333333,3,1.1333,1,"


package org.apache.poi.poifs.property;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.util.ByteField;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.ShortField;



public abstract class Property
    implements Child, POIFSViewable
{
    static final private byte   _default_fill             = ( byte ) 0x00;
    static final private int    _name_size_offset         = 0x40;
    static final private int    _max_name_length          =
        (_name_size_offset / LittleEndianConsts.SHORT_SIZE) - 1;
    static final protected int  _NO_INDEX                 = -1;

    
    static final private int    _node_color_offset        = 0x43;
    static final private int    _previous_property_offset = 0x44;
    static final private int    _next_property_offset     = 0x48;
    static final private int    _child_property_offset    = 0x4C;
    static final private int    _seconds_1_offset         = 0x64;
    static final private int    _days_1_offset            = 0x68;
    static final private int    _seconds_2_offset         = 0x6C;
    static final private int    _days_2_offset            = 0x70;
    static final private int    _start_block_offset       = 0x74;
    static final private int    _size_offset              = 0x78;

    
    static final protected byte _NODE_BLACK               = 1;
    static final protected byte _NODE_RED                 = 0;

    
    static final private int    _big_block_minimum_bytes  = 4096;
    private String              _name;
    private ShortField          _name_size;
    private ByteField           _property_type;
    private ByteField           _node_color;
    private IntegerField        _previous_property;
    private IntegerField        _next_property;
    private IntegerField        _child_property;
    private IntegerField        _seconds_1;
    private IntegerField        _days_1;
    private IntegerField        _seconds_2;
    private IntegerField        _days_2;
    private IntegerField        _start_block;
    private IntegerField        _size;
    private byte[]              _raw_data;
    private int                 _index;
    private Child               _next_child;
    private Child               _previous_child;

    

    protected Property()
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        Arrays.fill(_raw_data, _default_fill);
        _name_size         = new ShortField(_name_size_offset);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET);
        _node_color        = new ByteField(_node_color_offset);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _NO_INDEX, _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _NO_INDEX, _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _NO_INDEX, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, 0,
                                              _raw_data);
        _days_1            = new IntegerField(_days_1_offset, 0, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, 0,
                                              _raw_data);
        _days_2            = new IntegerField(_days_2_offset, 0, _raw_data);
        _start_block       = new IntegerField(_start_block_offset);
        _size              = new IntegerField(_size_offset, 0, _raw_data);
        _index             = _NO_INDEX;
        setName("""");
        setNextChild(null);
        setPreviousChild(null);
    }

    

    protected Property(final int index, final byte [] array, final int offset)
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        System.arraycopy(array, offset, _raw_data, 0,
                         POIFSConstants.PROPERTY_SIZE);
        _name_size         = new ShortField(_name_size_offset, _raw_data);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET, _raw_data);
        _node_color        = new ByteField(_node_color_offset, _raw_data);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, _raw_data);
        _days_1            = new IntegerField(_days_1_offset, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, _raw_data);
        _days_2            = new IntegerField(_days_2_offset, _raw_data);
        _start_block       = new IntegerField(_start_block_offset, _raw_data);
        _size              = new IntegerField(_size_offset, _raw_data);
        _index             = index;
        int name_length = (_name_size.get() / LittleEndianConsts.SHORT_SIZE)
                          - 1;

        if (name_length < 1)
        {
            _name = """";
        }
        else
        {
            char[] char_array  = new char[ name_length ];
            int    name_offset = 0;

            for (int j = 0; j < name_length; j++)
            {
                char_array[ j ] = ( char ) new ShortField(name_offset,
                                                          _raw_data).get();
                name_offset     += LittleEndianConsts.SHORT_SIZE;
            }
            _name = new String(char_array, 0, name_length);
        }
        _next_child     = null;
        _previous_child = null;
    }

    

    public void writeData(final OutputStream stream)
        throws IOException
    {
        stream.write(_raw_data);
    }

    

    public void setStartBlock(final int startBlock)
    {
        _start_block.set(startBlock, _raw_data);
    }

    

    public int getStartBlock()
    {
        return _start_block.get();
    }

    

    public int getSize()
    {
        return _size.get();
    }

    

    public boolean shouldUseSmallBlocks()
    {
        return Property.isSmall(_size.get());
    }

    

    public static boolean isSmall(final int length)
    {
        return length < _big_block_minimum_bytes;
    }

    

    public String getName()
    {
        return _name;
    }

    

    abstract public boolean isDirectory();

    

    protected final void setName(final String name)
    {
        char[] char_array = name.toCharArray();
        int    limit      = Math.min(char_array.length, _max_name_length);

        _name = new String(char_array, 0, limit);
        short offset = 0;
        int   j      = 0;

        for (; j < limit; j++)
        {
            new ShortField(offset, ( short ) char_array[ j ], _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }
        for (; j < _max_name_length + 1; j++)
        {
            new ShortField(offset, ( short ) 0, _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }

        
        _name_size
            .set(( short ) ((limit + 1)
                            * LittleEndianConsts.SHORT_SIZE), _raw_data);
    }

    

    protected void setPropertyType(final byte propertyType)
    {
        _property_type.set(propertyType, _raw_data);
    }

    

    protected void setNodeColor(final byte nodeColor)
    {
        _node_color.set(nodeColor, _raw_data);
    }

    

    protected void setChildProperty(final int child)
    {
        _child_property.set(child, _raw_data);
    }

    

    protected int getChildIndex()
    {
        return _child_property.get();
    }

    

    protected void setSize(final int size)
    {
        _size.set(size, _raw_data);
    }

    

    protected void setIndex(final int index)
    {
        _index = index;
    }

    

    protected int getIndex()
    {
        return _index;
    }

    

    abstract protected void preWrite();

    

    int getNextChildIndex()
    {
        return _next_property.get();
    }

    

    int getPreviousChildIndex()
    {
        return _previous_property.get();
    }

    

    static boolean isValidIndex(int index)
    {
        return index != _NO_INDEX;
    }

    

    

    public Child getNextChild()
    {
        return _next_child;
    }

    

    public Child getPreviousChild()
    {
        return _previous_child;
    }

    

    public void setNextChild(final Child child)
    {
        _next_child = child;
        _next_property.set((child == null) ? _NO_INDEX
                                           : (( Property ) child)
                                               .getIndex(), _raw_data);
    }

    

    public void setPreviousChild(final Child child)
    {
        _previous_child = child;
        _previous_property.set((child == null) ? _NO_INDEX
                                               : (( Property ) child)
                                                   .getIndex(), _raw_data);
    }

    
    

    

    public Object [] getViewableArray()
    {
        Object[] results = new Object[ 5 ];

        results[ 0 ] = ""Name          = """" + getName() + """""";
        results[ 1 ] = ""Property Type = "" + _property_type.get();
        results[ 2 ] = ""Node Color    = "" + _node_color.get();
        long time = _days_1.get();

        time         <<= 32;
        time         += (( long ) _seconds_1.get()) & 0x0000FFFFL;
        results[ 3 ] = ""Time 1        = "" + time;
        time         = _days_2.get();
        time         <<= 32;
        time         += (( long ) _seconds_2.get()) & 0x0000FFFFL;
        results[ 4 ] = ""Time 2        = "" + time;
        return results;
    }

    

    public Iterator getViewableIterator()
    {
        return Collections.EMPTY_LIST.iterator();
    }

    

    public boolean preferArray()
    {
        return true;
    }

    

    public String getShortDescription()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""Property: """").append(getName()).append("""""");
        return buffer.toString();
    }

    
}   

"
poi,1.5,org.apache.poi.util.POILogFactory,4,1,0,7,13,4,4,3,2,0.333333333,46,1.0,0,0.0,0.333333333,0,0,10.0,2,0.75,0,"

package org.apache.poi.util;

import java.io.FileInputStream;
import java.io.IOException;

import java.util.*;

import org.apache.commons.logging.*;



public class POILogFactory
{
    private static LogFactory   _creator = LogFactory.getFactory();

    
    private static Map          _loggers = new HashMap();;


    

    private POILogFactory()
    {
    }

    

    public static POILogger getLogger(final Class theclass)
    {
        return getLogger(theclass.getName());
    }
    
    

    public static POILogger getLogger(final String cat)
    {
        POILogger logger = null;

        if (_loggers.containsKey(cat))
        {
            logger = ( POILogger ) _loggers.get(cat);
        }
        else
        {
            logger = new POILogger(_creator.getInstance(cat));
            _loggers.put(cat, logger);
        }
        return logger;
    }
        
}   
"
poi,1.5,org.apache.poi.hssf.record.ContinueRecord,13,2,0,4,27,72,1,3,10,0.916666667,221,0.5,0,0.523809524,0.519230769,1,5,15.84615385,4,1.0769,2,"


package org.apache.poi.hssf.record;

import java.util.ArrayList;

import org.apache.poi.util.LittleEndian;



public class ContinueRecord
    extends Record
{
    public final static short sid = 0x003C;
    private byte[]            field_1_data;

    

    public ContinueRecord()
    {
    }

    

    public ContinueRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ContinueRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    

    public byte [] serialize()
    {
        byte[] retval = new byte[ field_1_data.length + 4 ];

        LittleEndian.putShort(retval, 0, sid);
        LittleEndian.putShort(retval, 2, ( short ) field_1_data.length);
        System.arraycopy(field_1_data, 0, retval, 4, field_1_data.length);
        return retval;
    }

    public int serialize(int offset, byte [] data)
    {
        throw new RecordFormatException(
            ""You're not supposed to serialize Continue records like this directly"");
    }

    

    public void setData(byte [] data)
    {
        field_1_data = data;
    }

    

    public byte [] getData()
    {
        return field_1_data;
    }

    

    public static byte [] processContinue(byte [] data)
    {   

        
        
        int       records   =
            (data.length
             / 8214);   
        int       offset    = 8214;

        
        ArrayList crs       = new ArrayList(records);
        int       totalsize = 8214;
        byte[]    retval    = null;

        for (int cr = 0; cr < records; cr++)
        {
            ContinueRecord contrec   = new ContinueRecord();
            int            arraysize = Math.min((8214 - 4),
                                                (data.length - offset));
            byte[]         crdata    = new byte[ arraysize ];

            System.arraycopy(data, offset, crdata, 0, arraysize);

            
            offset += crdata.length;
            contrec.setData(crdata);
            crs.add(contrec.serialize());
        }
        for (int cr = 0; cr < records; cr++)
        {
            totalsize += (( byte [] ) crs.get(cr)).length;
        }

        
        retval = new byte[ totalsize ];
        offset = 8214;
        System.arraycopy(data, 0, retval, 0, 8214);
        for (int cr = 0; cr < records; cr++)
        {
            byte[] src = ( byte [] ) crs.get(cr);

            System.arraycopy(src, 0, retval, offset, src.length);

            
            offset += src.length;
        }
        return retval;
    }

    

    protected void fillFields(byte [] ignored_parm1, short ignored_parm2)
    {

        
        
    }

    

    protected void validateSid(short id)
    {
        if (id != ContinueRecord.sid)
        {
            throw new RecordFormatException(""Not a Continue Record"");
        }
    }

    

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CONTINUE RECORD]
"");
        buffer.append(""    .id        = "").append(Integer.toHexString(sid))
            .append(""
"");
        buffer.append(""[/CONTINUE RECORD]
"");
        return buffer.toString();
    }

    public short getSid()
    {
        return this.sid;
    }

    

    protected void fillFields(byte [] ignored_parm1, short ignored_parm2, int ignored_parm3)
    {
    }
}
"
poi,1.5,org.apache.poi.hssf.record.ExtendedFormatRecord,96,2,0,9,117,3214,5,4,93,0.981194559,1478,0.483146067,34,0.106796117,0.313684211,1,6,13.46875,3,0.9896,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;



public class ExtendedFormatRecord
    extends Record
{
    public final static short     sid                 = 0xE0;

    
    public final static short     NULL                = (short)0xfff0;

    
    public final static short     XF_STYLE            = 1;
    public final static short     XF_CELL             = 0;

    
    public final static short     NONE                = 0x0;
    public final static short     THIN                = 0x1;
    public final static short     MEDIUM              = 0x2;
    public final static short     DASHED              = 0x3;
    public final static short     DOTTED              = 0x4;
    public final static short     THICK               = 0x5;
    public final static short     DOUBLE              = 0x6;
    public final static short     HAIR                = 0x7;
    public final static short     MEDIUM_DASHED       = 0x8;
    public final static short     DASH_DOT            = 0x9;
    public final static short     MEDIUM_DASH_DOT     = 0xA;
    public final static short     DASH_DOT_DOT        = 0xB;
    public final static short     MEDIUM_DASH_DOT_DOT = 0xC;
    public final static short     SLANTED_DASH_DOT    = 0xD;

    
    public final static short     GENERAL             = 0x0;
    public final static short     LEFT                = 0x1;
    public final static short     CENTER              = 0x2;
    public final static short     RIGHT               = 0x3;
    public final static short     FILL                = 0x4;
    public final static short     JUSTIFY             = 0x5;
    public final static short     CENTER_SELECTION    = 0x6;

    
    public final static short     VERTICAL_TOP        = 0x0;
    public final static short     VERTICAL_CENTER     = 0x1;
    public final static short     VERTICAL_BOTTOM     = 0x2;
    public final static short     VERTICAL_JUSTIFY    = 0x3;

    
    public final static short     NO_FILL             = 0  ;
    public final static short     SOLID_FILL          = 1  ;
    public final static short     FINE_DOTS           = 2  ;
    public final static short     ALT_BARS            = 3  ;
    public final static short     SPARSE_DOTS         = 4  ;
    public final static short     THICK_HORZ_BANDS    = 5  ;
    public final static short     THICK_VERT_BANDS    = 6  ;
    public final static short     THICK_BACKWARD_DIAG = 7  ;
    public final static short     THICK_FORWARD_DIAG  = 8  ;
    public final static short     BIG_SPOTS           = 9  ;
    public final static short     BRICKS              = 10 ;
    public final static short     THIN_HORZ_BANDS     = 11 ;
    public final static short     THIN_VERT_BANDS     = 12 ;
    public final static short     THIN_BACKWARD_DIAG  = 13 ;
    public final static short     THIN_FORWARD_DIAG   = 14 ;
    public final static short     SQUARES             = 15 ;
    public final static short     DIAMONDS            = 16 ;

    
    private short                 field_1_font_index;             
    private short                 field_2_format_index;           

    
    static final private BitField _locked       = new BitField(0x0001);
    static final private BitField _hidden       = new BitField(0x0002);
    static final private BitField _xf_type      = new BitField(0x0004);
    static final private BitField _123_prefix   = new BitField(0x0008);
    static final private BitField _parent_index = new BitField(0xFFF0);
    private short                 field_3_cell_options;

    
    static final private BitField _alignment          = new BitField(0x0007);
    static final private BitField _wrap_text          = new BitField(0x0008);
    static final private BitField _vertical_alignment = new BitField(0x0070);
    static final private BitField _justify_last       = new BitField(0x0080);
    static final private BitField _rotation           = new BitField(0xFF00);
    private short                 field_4_alignment_options;

    
    static final private BitField _indent                         =
        new BitField(0x000F);
    static final private BitField _shrink_to_fit                  =
        new BitField(0x0010);
    static final private BitField _merge_cells                    =
        new BitField(0x0020);
    static final private BitField _reading_order                  =
        new BitField(0x00C0);

    
    static final private BitField _indent_not_parent_format       =
        new BitField(0x0400);
    static final private BitField _indent_not_parent_font         =
        new BitField(0x0800);
    static final private BitField _indent_not_parent_alignment    =
        new BitField(0x1000);
    static final private BitField _indent_not_parent_border       =
        new BitField(0x2000);
    static final private BitField _indent_not_parent_pattern      =
        new BitField(0x4000);
    static final private BitField _indent_not_parent_cell_options =
        new BitField(0x8000);
    private short                 field_5_indention_options;

    
    static final private BitField _border_left   = new BitField(0x000F);
    static final private BitField _border_right  = new BitField(0x00F0);
    static final private BitField _border_top    = new BitField(0x0F00);
    static final private BitField _border_bottom = new BitField(0xF000);
    private short                 field_6_border_options;

    
    
    static final private BitField _left_border_palette_idx  =
        new BitField(0x007F);
    static final private BitField _right_border_palette_idx =
        new BitField(0x3F80);
    static final private BitField _diag                     =
        new BitField(0xC000);
    private short                 field_7_palette_options;

    
    static final private BitField _top_border_palette_idx    =
        new BitField(0x0000007F);
    static final private BitField _bottom_border_palette_idx =
        new BitField(0x00003F80);
    static final private BitField _adtl_diag                 =
        new BitField(0x001fc000);
    static final private BitField _adtl_diag_line_style      =
        new BitField(0x01e00000);

    
    static final private BitField _adtl_fill_pattern         =
        new BitField(0xfc000000);
    private int                   field_8_adtl_palette_options;   

    
    static final private BitField _fill_foreground = new BitField(0x007F);
    static final private BitField _fill_background = new BitField(0x3f80);

    
    private short                 field_9_fill_palette_options;

    

    public ExtendedFormatRecord()
    {
    }

    

    public ExtendedFormatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ExtendedFormatRecord(short id, short size, byte [] data,
                                int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A EXTENDED FORMAT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_font_index           = LittleEndian.getShort(data,
                0 + offset);
        field_2_format_index         = LittleEndian.getShort(data,
                2 + offset);
        field_3_cell_options         = LittleEndian.getShort(data,
                4 + offset);
        field_4_alignment_options    = LittleEndian.getShort(data,
                6 + offset);
        field_5_indention_options    = LittleEndian.getShort(data,
                8 + offset);
        field_6_border_options       = LittleEndian.getShort(data,
                10 + offset);
        field_7_palette_options      = LittleEndian.getShort(data,
                12 + offset);
        field_8_adtl_palette_options = LittleEndian.getInt(data, 14 + offset);
        field_9_fill_palette_options = LittleEndian.getShort(data,
                18 + offset);
    }

    

    public void setFontIndex(short index)
    {
        field_1_font_index = index;
    }

    

    public void setFormatIndex(short index)
    {
        field_2_format_index = index;
    }

    

    public void setCellOptions(short options)
    {
        field_3_cell_options = options;
    }

    

    

    public void setLocked(boolean locked)
    {
        field_3_cell_options = _locked.setShortBoolean(field_3_cell_options,
                locked);
    }

    

    public void setHidden(boolean hidden)
    {
        field_3_cell_options = _hidden.setShortBoolean(field_3_cell_options,
                hidden);
    }

    

    public void setXFType(short type)
    {
        field_3_cell_options = _xf_type.setShortValue(field_3_cell_options,
                type);
    }

    

    public void set123Prefix(boolean prefix)
    {
        field_3_cell_options =
            _123_prefix.setShortBoolean(field_3_cell_options, prefix);
    }

    

    

    public void setParentIndex(short parent)
    {
        field_3_cell_options =
            _parent_index.setShortValue(field_3_cell_options, parent);
    }

    

    

    public void setAlignmentOptions(short options)
    {
        field_4_alignment_options = options;
    }

    

    public void setAlignment(short align)
    {
        field_4_alignment_options =
            _alignment.setShortValue(field_4_alignment_options, align);
    }

    

    public void setWrapText(boolean wrapped)
    {
        field_4_alignment_options =
            _wrap_text.setShortBoolean(field_4_alignment_options, wrapped);
    }

    

    public void setVerticalAlignment(short align)
    {
        field_4_alignment_options =
            _vertical_alignment.setShortValue(field_4_alignment_options,
                                              align);
    }

    

    public void setJustifyLast(short justify)
    {   
        field_4_alignment_options =
            _justify_last.setShortValue(field_4_alignment_options, justify);
    }

    

    public void setRotation(short rotation)
    {
        field_4_alignment_options =
            _rotation.setShortValue(field_4_alignment_options, rotation);
    }

    

    public void setIndentionOptions(short options)
    {
        field_5_indention_options = options;
    }

    

    

    public void setIndent(short indent)
    {
        field_5_indention_options =
            _indent.setShortValue(field_5_indention_options, indent);
    }

    

    public void setShrinkToFit(boolean shrink)
    {
        field_5_indention_options =
            _shrink_to_fit.setShortBoolean(field_5_indention_options, shrink);
    }

    

    public void setMergeCells(boolean merge)
    {
        field_5_indention_options =
            _merge_cells.setShortBoolean(field_5_indention_options, merge);
    }

    

    public void setReadingOrder(short order)
    {   
        field_5_indention_options =
            _reading_order.setShortValue(field_5_indention_options, order);
    }

    

    public void setIndentNotParentFormat(boolean parent)
    {
        field_5_indention_options =
            _indent_not_parent_format
                .setShortBoolean(field_5_indention_options, parent);
    }

    

    public void setIndentNotParentFont(boolean font)
    {
        field_5_indention_options =
            _indent_not_parent_font.setShortBoolean(field_5_indention_options,
                                                    font);
    }

    

    public void setIndentNotParentAlignment(boolean alignment)
    {
        field_5_indention_options =
            _indent_not_parent_alignment
                .setShortBoolean(field_5_indention_options, alignment);
    }

    

    public void setIndentNotParentBorder(boolean border)
    {
        field_5_indention_options =
            _indent_not_parent_border
                .setShortBoolean(field_5_indention_options, border);
    }

    

    public void setIndentNotParentPattern(boolean pattern)
    {
        field_5_indention_options =
            _indent_not_parent_pattern
                .setShortBoolean(field_5_indention_options, pattern);
    }

    

    public void setIndentNotParentCellOptions(boolean options)
    {
        field_5_indention_options =
            _indent_not_parent_cell_options
                .setShortBoolean(field_5_indention_options, options);
    }

    

    

    public void setBorderOptions(short options)
    {
        field_6_border_options = options;
    }

    

    

    public void setBorderLeft(short border)
    {
        field_6_border_options =
            _border_left.setShortValue(field_6_border_options, border);
    }

    

    public void setBorderRight(short border)
    {
        field_6_border_options =
            _border_right.setShortValue(field_6_border_options, border);
    }

    

    public void setBorderTop(short border)
    {
        field_6_border_options =
            _border_top.setShortValue(field_6_border_options, border);
    }

    

    public void setBorderBottom(short border)
    {
        field_6_border_options =
            _border_bottom.setShortValue(field_6_border_options, border);
    }

    

    

    public void setPaletteOptions(short options)
    {
        field_7_palette_options = options;
    }

    

    

    public void setLeftBorderPaletteIdx(short border)
    {
        field_7_palette_options =
            _left_border_palette_idx.setShortValue(field_7_palette_options,
                                                   border);
    }

    

    public void setRightBorderPaletteIdx(short border)
    {
        field_7_palette_options =
            _right_border_palette_idx.setShortValue(field_7_palette_options,
                                                    border);
    }

    
    

    

    public void setDiag(short diag)
    {
        field_7_palette_options = _diag.setShortValue(field_7_palette_options,
                diag);
    }

    

    

    public void setAdtlPaletteOptions(short options)
    {
        field_8_adtl_palette_options = options;
    }

    

    

    public void setTopBorderPaletteIdx(short border)
    {
        field_8_adtl_palette_options =
            _top_border_palette_idx.setValue(field_8_adtl_palette_options,
                                             border);
    }

    

    public void setBottomBorderPaletteIdx(short border)
    {
        field_8_adtl_palette_options =
            _bottom_border_palette_idx.setValue(field_8_adtl_palette_options,
                                                border);
    }

    

    public void setAdtlDiag(short diag)
    {
        field_8_adtl_palette_options =
            _adtl_diag.setValue(field_8_adtl_palette_options, diag);
    }

    

    public void setAdtlDiagLineStyle(short diag)
    {
        field_8_adtl_palette_options =
            _adtl_diag_line_style.setValue(field_8_adtl_palette_options,
                                           diag);
    }

    

    public void setAdtlFillPattern(short fill)
    {
        field_8_adtl_palette_options =
            _adtl_fill_pattern.setValue(field_8_adtl_palette_options, fill);
    }

    

    

    public void setFillPaletteOptions(short options)
    {
        field_9_fill_palette_options = options;
    }

    

    public void setFillForeground(short color)
    {
        field_9_fill_palette_options =
            _fill_foreground.setShortValue(field_9_fill_palette_options,
                                           color);
    }

    

    public void setFillBackground(short color)
    {
        field_9_fill_palette_options =
            _fill_background.setShortValue(field_9_fill_palette_options,
                                           color);
    }

    

    public short getFontIndex()
    {
        return field_1_font_index;
    }

    

    public short getFormatIndex()
    {
        return field_2_format_index;
    }

    

    public short getCellOptions()
    {
        return field_3_cell_options;
    }

    

    

    public boolean isLocked()
    {
        return _locked.isSet(field_3_cell_options);
    }

    

    public boolean isHidden()
    {
        return _hidden.isSet(field_3_cell_options);
    }

    

    public short getXFType()
    {
        return _xf_type.getShortValue(field_3_cell_options);
    }

    

    public boolean get123Prefix()
    {
        return _123_prefix.isSet(field_3_cell_options);
    }

    

    public short getParentIndex()
    {
        return _parent_index.getShortValue(field_3_cell_options);
    }

    

    

    public short getAlignmentOptions()
    {
        return field_4_alignment_options;
    }

    

    

    public short getAlignment()
    {
        return _alignment.getShortValue(field_4_alignment_options);
    }

    

    public boolean getWrapText()
    {
        return _wrap_text.isSet(field_4_alignment_options);
    }

    

    public short getVerticalAlignment()
    {
        return _vertical_alignment.getShortValue(field_4_alignment_options);
    }

    

    public short getJustifyLast()
    {   
        return _justify_last.getShortValue(field_4_alignment_options);
    }

    

    public short getRotation()
    {
        return _rotation.getShortValue(field_4_alignment_options);
    }

    

    

    public short getIndentionOptions()
    {
        return field_5_indention_options;
    }

    

    

    public short getIndent()
    {
        return _indent.getShortValue(field_5_indention_options);
    }

    

    public boolean getShrinkToFit()
    {
        return _shrink_to_fit.isSet(field_5_indention_options);
    }

    

    public boolean getMergeCells()
    {
        return _merge_cells.isSet(field_5_indention_options);
    }

    

    public short getReadingOrder()
    {   
        return _reading_order.getShortValue(field_5_indention_options);
    }

    

    public boolean isIndentNotParentFormat()
    {
        return _indent_not_parent_format.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentFont()
    {
        return _indent_not_parent_font.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentAlignment()
    {
        return _indent_not_parent_alignment.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentBorder()
    {
        return _indent_not_parent_border.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentPattern()
    {
        return _indent_not_parent_pattern.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentCellOptions()
    {
        return _indent_not_parent_cell_options
            .isSet(field_5_indention_options);
    }

    
    

    

    public short getBorderOptions()
    {
        return field_6_border_options;
    }

    

    

    public short getBorderLeft()
    {
        return _border_left.getShortValue(field_6_border_options);
    }

    

    public short getBorderRight()
    {
        return _border_right.getShortValue(field_6_border_options);
    }

    

    public short getBorderTop()
    {
        return _border_top.getShortValue(field_6_border_options);
    }

    

    public short getBorderBottom()
    {
        return _border_bottom.getShortValue(field_6_border_options);
    }

    

    

    public short getPaletteOptions()
    {
        return field_7_palette_options;
    }

    

    

    public short getLeftBorderPaletteIdx()
    {
        return _left_border_palette_idx
            .getShortValue(field_7_palette_options);
    }

    

    public short getRightBorderPaletteIdx()
    {
        return _right_border_palette_idx
            .getShortValue(field_7_palette_options);
    }

    
    

    

    public short getDiag()
    {
        return _diag.getShortValue(field_7_palette_options);
    }

    
    

    

    public int getAdtlPaletteOptions()
    {
        return field_8_adtl_palette_options;
    }

    

    

    public short getTopBorderPaletteIdx()
    {
        return ( short ) _top_border_palette_idx
            .getValue(field_8_adtl_palette_options);
    }

    

    public short getBottomBorderPaletteIdx()
    {
        return ( short ) _bottom_border_palette_idx
            .getValue(field_8_adtl_palette_options);
    }

    

    public short getAdtlDiag()
    {
        return ( short ) _adtl_diag.getValue(field_8_adtl_palette_options);
    }

    

    public short getAdtlDiagLineStyle()
    {
        return ( short ) _adtl_diag_line_style
            .getValue(field_8_adtl_palette_options);
    }

    

    public short getAdtlFillPattern()
    {
        return ( short ) _adtl_fill_pattern
            .getValue(field_8_adtl_palette_options);
    }

    
    

    

    public short getFillPaletteOptions()
    {
        return field_9_fill_palette_options;
    }

    

    

    public short getFillForeground()
    {
        return _fill_foreground.getShortValue(field_9_fill_palette_options);
    }

    

    public short getFillBackground()
    {
        return _fill_background.getShortValue(field_9_fill_palette_options);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EXTENDEDFORMAT]
"");
        if (getXFType() == XF_STYLE)
        {
            buffer.append("" STYLE_RECORD_TYPE
"");
        }
        else if (getXFType() == XF_CELL)
        {
            buffer.append("" CELL_RECORD_TYPE
"");
        }
        buffer.append(""    .fontindex       = "")
            .append(Integer.toHexString(getFontIndex())).append(""
"");
        buffer.append(""    .formatindex     = "")
            .append(Integer.toHexString(getFormatIndex())).append(""
"");
        buffer.append(""    .celloptions     = "")
            .append(Integer.toHexString(getCellOptions())).append(""
"");
        buffer.append(""          .islocked  = "").append(isLocked())
            .append(""
"");
        buffer.append(""          .ishidden  = "").append(isHidden())
            .append(""
"");
        buffer.append(""          .recordtype= "")
            .append(Integer.toHexString(getXFType())).append(""
"");
        buffer.append(""          .parentidx = "")
            .append(Integer.toHexString(getParentIndex())).append(""
"");
        buffer.append(""    .alignmentoptions= "")
            .append(Integer.toHexString(getAlignmentOptions())).append(""
"");
        buffer.append(""          .alignment = "").append(getAlignment())
            .append(""
"");
        buffer.append(""          .wraptext  = "").append(getWrapText())
            .append(""
"");
        buffer.append(""          .valignment= "")
            .append(Integer.toHexString(getVerticalAlignment())).append(""
"");
        buffer.append(""          .justlast  = "")
            .append(Integer.toHexString(getJustifyLast())).append(""
"");
        buffer.append(""          .rotation  = "")
            .append(Integer.toHexString(getRotation())).append(""
"");
        buffer.append(""    .indentionoptions= "")
            .append(Integer.toHexString(getIndentionOptions())).append(""
"");
        buffer.append(""          .indent    = "")
            .append(Integer.toHexString(getIndent())).append(""
"");
        buffer.append(""          .shrinktoft= "").append(getShrinkToFit())
            .append(""
"");
        buffer.append(""          .mergecells= "").append(getMergeCells())
            .append(""
"");
        buffer.append(""          .readngordr= "")
            .append(Integer.toHexString(getReadingOrder())).append(""
"");
        buffer.append(""          .formatflag= "")
            .append(isIndentNotParentFormat()).append(""
"");
        buffer.append(""          .fontflag  = "")
            .append(isIndentNotParentFont()).append(""
"");
        buffer.append(""          .prntalgnmt= "")
            .append(isIndentNotParentAlignment()).append(""
"");
        buffer.append(""          .borderflag= "")
            .append(isIndentNotParentBorder()).append(""
"");
        buffer.append(""          .paternflag= "")
            .append(isIndentNotParentPattern()).append(""
"");
        buffer.append(""          .celloption= "")
            .append(isIndentNotParentCellOptions()).append(""
"");
        buffer.append(""    .borderoptns     = "")
            .append(Integer.toHexString(getBorderOptions())).append(""
"");
        buffer.append(""          .lftln     = "")
            .append(Integer.toHexString(getBorderLeft())).append(""
"");
        buffer.append(""          .rgtln     = "")
            .append(Integer.toHexString(getBorderRight())).append(""
"");
        buffer.append(""          .topln     = "")
            .append(Integer.toHexString(getBorderTop())).append(""
"");
        buffer.append(""          .btmln     = "")
            .append(Integer.toHexString(getBorderBottom())).append(""
"");
        buffer.append(""    .paleteoptns     = "")
            .append(Integer.toHexString(getPaletteOptions())).append(""
"");
        buffer.append(""          .leftborder= "")
            .append(Integer.toHexString(getLeftBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .rghtborder= "")
            .append(Integer.toHexString(getRightBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .diag      = "")
            .append(Integer.toHexString(getDiag())).append(""
"");
        buffer.append(""    .paleteoptn2     = "")
            .append(Integer.toHexString(getAdtlPaletteOptions()))
            .append(""
"");
        buffer.append(""          .topborder = "")
            .append(Integer.toHexString(getTopBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .botmborder= "")
            .append(Integer.toHexString(getBottomBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .adtldiag  = "")
            .append(Integer.toHexString(getAdtlDiag())).append(""
"");
        buffer.append(""          .diaglnstyl= "")
            .append(Integer.toHexString(getAdtlDiagLineStyle())).append(""
"");
        buffer.append(""          .fillpattrn= "")
            .append(Integer.toHexString(getAdtlFillPattern())).append(""
"");
        buffer.append(""    .fillpaloptn     = "")
            .append(Integer.toHexString(getFillPaletteOptions()))
            .append(""
"");
        buffer.append(""          .foreground= "")
            .append(Integer.toHexString(getFillForeground())).append(""
"");
        buffer.append(""          .background= "")
            .append(Integer.toHexString(getFillBackground())).append(""
"");
        buffer.append(""[/EXTENDEDFORMAT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) (20));   
        LittleEndian.putShort(data, 4 + offset, getFontIndex());
        LittleEndian.putShort(data, 6 + offset, getFormatIndex());
        LittleEndian.putShort(data, 8 + offset, getCellOptions());
        LittleEndian.putShort(data, 10 + offset, getAlignmentOptions());
        LittleEndian.putShort(data, 12 + offset, getIndentionOptions());
        LittleEndian.putShort(data, 14 + offset, getBorderOptions());
        LittleEndian.putShort(data, 16 + offset, getPaletteOptions());
        LittleEndian.putInt(data, 18 + offset, getAdtlPaletteOptions());
        LittleEndian.putShort(data, 22 + offset, getFillPaletteOptions());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 24;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.CalcCountRecord,11,2,0,5,21,49,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class CalcCountRecord
    extends Record
{
    public final static short sid = 0xC;
    private short             field_1_iterations;

    public CalcCountRecord()
    {
    }

    

    public CalcCountRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public CalcCountRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An Calc Count RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_iterations = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setIterations(short iterations)
    {
        field_1_iterations = iterations;
    }

    

    public short getIterations()
    {
        return field_1_iterations;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CALCCOUNT]
"");
        buffer.append(""    .iterations     = "")
            .append(Integer.toHexString(getIterations())).append(""
"");
        buffer.append(""[/CALCCOUNT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, getIterations());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.RawDataBlock,3,1,0,6,10,0,5,1,3,0.25,78,1.0,0,0.0,0.666666667,0,0,24.33333333,1,0.6667,1,"


package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSConstants;

import java.io.*;



public class RawDataBlock
    implements ListManagedBlock
{
    private byte[]  _data;
    private boolean _eof;

    

    public RawDataBlock(final InputStream stream)
        throws IOException
    {
        _data = new byte[ POIFSConstants.BIG_BLOCK_SIZE ];
        int count = stream.read(_data);

        if (count == -1)
        {
            _eof = true;
        }
        else if (count != POIFSConstants.BIG_BLOCK_SIZE)
        {
            String type = "" byte"" + ((count == 1) ? ("""")
                                                  : (""s""));

            throw new IOException(""Unable to read entire block; "" + count
                                  + type + "" read; expected ""
                                  + POIFSConstants.BIG_BLOCK_SIZE + "" bytes"");
        }
        else
        {
            _eof = false;
        }
    }

    

    public boolean eof()
        throws IOException
    {
        return _eof;
    }

    

    

    public byte [] getData()
        throws IOException
    {
        if (eof())
        {
            throw new IOException(""Cannot return empty data"");
        }
        return _data;
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.SeriesChartGroupIndexRecord,11,2,0,4,22,43,0,4,9,0.85,117,0.5,0,0.578947368,0.522727273,1,6,9.454545455,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class SeriesChartGroupIndexRecord
    extends Record
{
    public final static short      sid                             = 0x1045;
    private  short      field_1_chartGroupIndex;


    public SeriesChartGroupIndexRecord()
    {

    }

    

    public SeriesChartGroupIndexRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SeriesChartGroupIndexRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a SeriesChartGroupIndex record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_chartGroupIndex         = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SeriesChartGroupIndex]
"");

        buffer.append(""    .chartGroupIndex      = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getChartGroupIndex()))
            .append("" ("").append(getChartGroupIndex()).append("" )
"");

        buffer.append(""[/SeriesChartGroupIndex]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_chartGroupIndex);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getChartGroupIndex()
    {
        return field_1_chartGroupIndex;
    }

    
    public void setChartGroupIndex(short field_1_chartGroupIndex)
    {
        this.field_1_chartGroupIndex = field_1_chartGroupIndex;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.IterationRecord,11,2,0,5,21,43,2,3,9,0.85,116,0.5,0,0.578947368,0.418181818,1,6,9.363636364,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class IterationRecord
    extends Record
{
    public final static short sid = 0x11;
    private short             field_1_iteration;

    public IterationRecord()
    {
    }

    

    public IterationRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public IterationRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An ITERATION RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_iteration = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setIteration(boolean iterate)
    {
        if (iterate)
        {
            field_1_iteration = 1;
        }
        else
        {
            field_1_iteration = 0;
        }
    }

    

    public boolean getIteration()
    {
        return (field_1_iteration == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ITERATION]
"");
        buffer.append(""    .iteration      = "").append(getIteration())
            .append(""
"");
        buffer.append(""[/ITERATION]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, field_1_iteration);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.SaveRecalcRecord,11,2,0,5,21,43,2,3,9,0.85,116,0.5,0,0.578947368,0.418181818,1,6,9.363636364,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class SaveRecalcRecord
    extends Record
{
    public final static short sid = 0x5f;
    private short             field_1_recalc;

    public SaveRecalcRecord()
    {
    }

    

    public SaveRecalcRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SaveRecalcRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A Save Recalc RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_recalc = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setRecalc(boolean recalc)
    {
        field_1_recalc = ( short ) ((recalc == true) ? 1
                                                     : 0);
    }

    

    public boolean getRecalc()
    {
        return (field_1_recalc == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SAVERECALC]
"");
        buffer.append(""    .recalc         = "").append(getRecalc())
            .append(""
"");
        buffer.append(""[/SAVERECALC]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, field_1_recalc);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.PropertyBlock,4,2,0,5,11,4,1,4,2,0.833333333,108,1.0,1,0.5,0.4,1,1,25.5,3,1.25,0,"


package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;



public class PropertyBlock
    extends BigBlock
{
    private static final int _properties_per_block =
        POIFSConstants.BIG_BLOCK_SIZE / POIFSConstants.PROPERTY_SIZE;
    private Property[]       _properties;

    

    private PropertyBlock(final Property [] properties, final int offset)
    {
        _properties = new Property[ _properties_per_block ];
        for (int j = 0; j < _properties_per_block; j++)
        {
            _properties[ j ] = properties[ j + offset ];
        }
    }

    

    public static BlockWritable [] createPropertyBlockArray(
            final List properties)
    {
        int        block_count   =
            (properties.size() + _properties_per_block - 1)
            / _properties_per_block;
        Property[] to_be_written =
            new Property[ block_count * _properties_per_block ];

        System.arraycopy(properties.toArray(new Property[ 0 ]), 0,
                         to_be_written, 0, properties.size());
        for (int j = properties.size(); j < to_be_written.length; j++)
        {

            
            
            to_be_written[ j ] = new Property()
            {
                protected void preWrite()
                {
                }

                public boolean isDirectory()
                {
                    return false;
                }
            };
        }
        BlockWritable[] rvalue = new BlockWritable[ block_count ];

        for (int j = 0; j < block_count; j++)
        {
            rvalue[ j ] = new PropertyBlock(to_be_written,
                                            j * _properties_per_block);
        }
        return rvalue;
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        for (int j = 0; j < _properties_per_block; j++)
        {
            _properties[ j ].writeData(stream);
        }
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.RecordFactory,7,1,0,14,56,9,4,10,5,0.722222222,663,1.0,0,0.0,0.166666667,0,0,93.28571429,8,2.0,3,"


package org.apache.poi.hssf.record;

import java.io.InputStream;
import java.io.IOException;

import java.util.*;

import java.lang.reflect.Constructor;

import org.apache.poi.util.LittleEndian;



public class RecordFactory
{
    private static int           NUM_RECORDS = 10000;
    private static final Class[] records;
    
    static {
        if (FormulaRecord.EXPERIMENTAL_FORMULA_SUPPORT_ENABLED) {
            records = new Class[]
            {
                BOFRecord.class, InterfaceHdrRecord.class, MMSRecord.class,
                InterfaceEndRecord.class, WriteAccessRecord.class,
                CodepageRecord.class, DSFRecord.class, TabIdRecord.class,
                FnGroupCountRecord.class, WindowProtectRecord.class,
                ProtectRecord.class, PasswordRecord.class, ProtectionRev4Record.class,
                PasswordRev4Record.class, WindowOneRecord.class, BackupRecord.class,
                HideObjRecord.class, DateWindow1904Record.class,
                PrecisionRecord.class, RefreshAllRecord.class, BookBoolRecord.class,
                FontRecord.class, FormatRecord.class, ExtendedFormatRecord.class,
                StyleRecord.class, UseSelFSRecord.class, BoundSheetRecord.class,
                CountryRecord.class, SSTRecord.class, ExtSSTRecord.class,
                EOFRecord.class, IndexRecord.class, CalcModeRecord.class,
                CalcCountRecord.class, RefModeRecord.class, IterationRecord.class,
                DeltaRecord.class, SaveRecalcRecord.class, PrintHeadersRecord.class,
                PrintGridlinesRecord.class, GridsetRecord.class, GutsRecord.class,
                DefaultRowHeightRecord.class, WSBoolRecord.class, HeaderRecord.class,
                FooterRecord.class, HCenterRecord.class, VCenterRecord.class,
                PrintSetupRecord.class, DefaultColWidthRecord.class,
                DimensionsRecord.class, RowRecord.class, LabelSSTRecord.class,
                RKRecord.class, NumberRecord.class, DBCellRecord.class,
                WindowTwoRecord.class, SelectionRecord.class, ContinueRecord.class,
                LabelRecord.class, BlankRecord.class, ColumnInfoRecord.class,
                MulRKRecord.class, MulBlankRecord.class, MergeCellsRecord.class,
                FormulaRecord.class, BoolErrRecord.class
            };
        } else {
            records = new Class[]
            {
                BOFRecord.class, InterfaceHdrRecord.class, MMSRecord.class,
                InterfaceEndRecord.class, WriteAccessRecord.class,
                CodepageRecord.class, DSFRecord.class, TabIdRecord.class,
                FnGroupCountRecord.class, WindowProtectRecord.class,
                ProtectRecord.class, PasswordRecord.class, ProtectionRev4Record.class,
                PasswordRev4Record.class, WindowOneRecord.class, BackupRecord.class,
                HideObjRecord.class, DateWindow1904Record.class,
                PrecisionRecord.class, RefreshAllRecord.class, BookBoolRecord.class,
                FontRecord.class, FormatRecord.class, ExtendedFormatRecord.class,
                StyleRecord.class, UseSelFSRecord.class, BoundSheetRecord.class,
                CountryRecord.class, SSTRecord.class, ExtSSTRecord.class,
                EOFRecord.class, IndexRecord.class, CalcModeRecord.class,
                CalcCountRecord.class, RefModeRecord.class, IterationRecord.class,
                DeltaRecord.class, SaveRecalcRecord.class, PrintHeadersRecord.class,
                PrintGridlinesRecord.class, GridsetRecord.class, GutsRecord.class,
                DefaultRowHeightRecord.class, WSBoolRecord.class, HeaderRecord.class,
                FooterRecord.class, HCenterRecord.class, VCenterRecord.class,
                PrintSetupRecord.class, DefaultColWidthRecord.class,
                DimensionsRecord.class, RowRecord.class, LabelSSTRecord.class,
                RKRecord.class, NumberRecord.class, DBCellRecord.class,
                WindowTwoRecord.class, SelectionRecord.class, ContinueRecord.class,
                LabelRecord.class, BlankRecord.class, ColumnInfoRecord.class,
                MulRKRecord.class, MulBlankRecord.class, MergeCellsRecord.class,
                BoolErrRecord.class
            };
            
        }
    }
    private static Map           recordsMap  = recordsToMap(records);

    

    public static void setCapacity(int capacity)
    {
        NUM_RECORDS = capacity;
    }

    

    public static List createRecords(InputStream in)
        throws RecordFormatException
    {
        ArrayList records     = new ArrayList(NUM_RECORDS);
        Record    last_record = null;

        try
        {
            short rectype = 0;

            do
            {
                rectype = LittleEndian.readShort(in);
                if (rectype != 0)
                {
                    short  recsize = LittleEndian.readShort(in);
                    byte[] data    = new byte[ ( int ) recsize ];

                    in.read(data);
                    Record[] recs = createRecord(rectype, recsize,
                                                 data);   

                    if (recs.length > 1)
                    {
                        for (int k = 0; k < recs.length; k++)
                        {
                            records.add(
                                recs[ k ]);               
                            last_record =
                                recs[ k ];                
                        }                                 
                    }
                    else
                    {
                        Record record = recs[ 0 ];

                        if (record != null)
                        {
                            if (rectype == ContinueRecord.sid)
                            {
                                if (last_record == null)
                                {
                                    throw new RecordFormatException(
                                        ""First record is a ContinueRecord??"");
                                }
                                last_record.processContinueRecord(data);
                            }
                            else
                            {
                                last_record = record;
                                records.add(record);
                            }
                        }
                    }
                }
            }
            while (rectype != 0);
        }
        catch (IOException e)
        {
            throw new RecordFormatException(""Error reading bytes"");
        }

        
        
        return records;
    }

    public static Record [] createRecord(short rectype, short size,
                                         byte [] data)
    {
        Record   retval     = null;
        Record[] realretval = null;

        try
        {
            Constructor constructor =
                ( Constructor ) recordsMap.get(new Short(rectype));

            if (constructor != null)
            {
                retval = ( Record ) constructor.newInstance(new Object[]
                {
                    new Short(rectype), new Short(size), data
                });
            }
            else
            {
                retval = new UnknownRecord(rectype, size, data);
            }
        }
        catch (Exception introspectionException)
        {
            introspectionException.printStackTrace();
            throw new RecordFormatException(
                ""Unable to construct record instance, the following exception occured: "" + introspectionException.getMessage());
        }
        if (retval instanceof RKRecord)
        {
            RKRecord     rk  = ( RKRecord ) retval;
            NumberRecord num = new NumberRecord();

            num.setColumn(rk.getColumn());
            num.setRow(rk.getRow());
            num.setXFIndex(rk.getXFIndex());
            num.setValue(rk.getRKNumber());
            retval = num;
        }
        else if (retval instanceof DBCellRecord)
        {
            retval = null;
        }
        else if (retval instanceof MulRKRecord)
        {
            MulRKRecord mrk = ( MulRKRecord ) retval;

            realretval = new Record[ mrk.getNumColumns() ];
            for (int k = 0; k < mrk.getNumColumns(); k++)
            {
                NumberRecord nr = new NumberRecord();

                nr.setColumn(( short ) (k + mrk.getFirstColumn()));
                nr.setRow(mrk.getRow());
                nr.setXFIndex(mrk.getXFAt(k));
                nr.setValue(mrk.getRKNumberAt(k));
                realretval[ k ] = nr;
            }
        }
        else if (retval instanceof MulBlankRecord)
        {
            MulBlankRecord mb = ( MulBlankRecord ) retval;

            realretval = new Record[ mb.getNumColumns() ];
            for (int k = 0; k < mb.getNumColumns(); k++)
            {
                BlankRecord br = new BlankRecord();

                br.setColumn(( short ) (k + mb.getFirstColumn()));
                br.setRow(mb.getRow());
                br.setXFIndex(mb.getXFAt(k));
                realretval[ k ] = br;
            }
        }
        if (realretval == null)
        {
            realretval      = new Record[ 1 ];
            realretval[ 0 ] = retval;
        }
        return realretval;
    }

    public static short [] getAllKnownRecordSIDs()
    {
        short[] results = new short[ recordsMap.size() ];
        int     i       = 0;

        for (Iterator iterator = recordsMap.keySet().iterator();
                iterator.hasNext(); )
        {
            Short sid = ( Short ) iterator.next();

            results[ i++ ] = sid.shortValue();
        }
        return results;
    }

    private static Map recordsToMap(Class [] records)
    {
        Map         result = new HashMap();
        Constructor constructor;

        for (int i = 0; i < records.length; i++)
        {
            Class record = null;
            short sid    = 0;

            record = records[ i ];
            try
            {
                sid         = record.getField(""sid"").getShort(null);
                constructor = record.getConstructor(new Class[]
                {
                    short.class, short.class, byte [].class
                });
            }
            catch (Exception illegalArgumentException)
            {
                throw new RecordFormatException(
                    ""Unable to determine record types"");
            }
            result.put(new Short(sid), constructor);
        }
        return result;
    }
}
"
poi,1.5,org.apache.poi.hssf.model.Sheet,76,1,0,48,274,1888,4,44,45,0.880784314,2248,0.882352941,8,0.0,0.108571429,0,0,28.35526316,17,1.8421,20,"


package org.apache.poi.hssf.model;

import java.io.OutputStream;

import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

import org.apache.poi.util.POILogFactory;
import org.apache.poi.hssf
    .record.*;       
import org.apache.poi.hssf.record.formula.FormulaUtil;
import org.apache.poi.hssf.record.formula.Ptg;
import org.apache.poi.util.IntList;
import org.apache.poi.util.POILogger;
import org.apache.poi.hssf.record
    .aggregates.*;   



public class Sheet
    extends java.lang.Object
{
    protected ArrayList              records        = null;
    int                              preoffset      =
        0;      
    int                              loc            = 0;
    protected boolean                containsLabels = false;
    ;
    protected int                    dimsloc        = 0;
    protected DimensionsRecord       dims;
    protected DefaultColWidthRecord  defaultcolwidth  = null;
    protected DefaultRowHeightRecord defaultrowheight = null;
    protected GridsetRecord          gridset          = null;
    protected MergeCellsRecord       merged           = null;
    protected int                    mergedloc        = 0;
    private static POILogger         log              =
        POILogFactory.getLogger(Sheet.class);
    private ArrayList                columnSizes      =
        null;   
    protected ValueRecordsAggregate  cells            = null;
    protected RowRecordsAggregate    rows             = null;
    private Iterator                 valueRecIterator = null;
    private Iterator                 rowRecIterator   = null;

    

    public Sheet()
    {
    }

    
    public static Sheet createSheet(List recs, int sheetnum, int offset)
    {
        log.logFormatted(log.DEBUG,
                         ""Sheet createSheet (existing file) with %"",
                         new Integer(recs.size()));
        Sheet     retval             = new Sheet();
        ArrayList records            = new ArrayList(recs.size() / 5);
        boolean   isfirstcell        = true;
        boolean   isfirstrow         = true;
        int       bofEofNestingLevel = 0;

        for (int k = offset; k < recs.size(); k++)
        {
            Record rec = ( Record ) recs.get(k);

            if (rec.getSid() == LabelRecord.sid)
            {
                log.log(log.DEBUG, ""Hit label record"");
                retval.containsLabels = true;
            }
            else if (rec.getSid() == BOFRecord.sid)
            {
                bofEofNestingLevel++;
            }
            else if ((rec.getSid() == EOFRecord.sid)
                     && (--bofEofNestingLevel == 0))
            {
                log.log(log.DEBUG, ""Hit EOF record at "");
                records.add(rec);
                break;
            }
            else if (rec.getSid() == DimensionsRecord.sid)
            {
                retval.dims    = ( DimensionsRecord ) rec;
                retval.dimsloc = records.size();
            }
            else if (rec.getSid() == MergeCellsRecord.sid)
            {
                retval.merged    = ( MergeCellsRecord ) rec;
                retval.mergedloc = k - offset;
            }
            else if (rec.getSid() == ColumnInfoRecord.sid)
            {
                if (retval.columnSizes == null)
                {
                    retval.columnSizes = new ArrayList();
                }
                retval.columnSizes.add(( ColumnInfoRecord ) rec);
            }
            else if (rec.getSid() == DefaultColWidthRecord.sid)
            {
                retval.defaultcolwidth = ( DefaultColWidthRecord ) rec;
            }
            else if (rec.getSid() == DefaultRowHeightRecord.sid)
            {
                retval.defaultrowheight = ( DefaultRowHeightRecord ) rec;
            }
            else if (rec.isValue())
            {
                if (isfirstcell)
                {
                    retval.cells = new ValueRecordsAggregate();
                    rec          = retval.cells;
                    retval.cells.construct(k, recs);
                    isfirstcell = false;
                }
                else
                {
                    rec = null;
                }
            }
            else if (rec.getSid() == RowRecord.sid)
            {
                if (isfirstrow)
                {
                    retval.rows = new RowRecordsAggregate();
                    rec         = retval.rows;
                    retval.rows.construct(k, recs);
                    isfirstrow = false;
                }
                else
                {
                    rec = null;
                }
            }
            if (rec != null)
            {
                records.add(rec);
            }
        }
        retval.records = records;
        log.log(log.DEBUG, ""sheet createSheet (existing file) exited"");
        return retval;
    }

    

    public static Sheet createSheet(List records, int sheetnum)
    {
        log.log(log.DEBUG,
                ""Sheet createSheet (exisiting file) assumed offset 0"");
        return createSheet(records, sheetnum, 0);
    }

    

    public static Sheet createSheet()
    {
        log.log(log.DEBUG, ""Sheet createsheet from scratch called"");
        Sheet     retval  = new Sheet();
        ArrayList records = new ArrayList(30);

        records.add(retval.createBOF());

        
        records.add(retval.createCalcMode());
        records.add(retval.createCalcCount());
        records.add(retval.createRefMode());
        records.add(retval.createIteration());
        records.add(retval.createDelta());
        records.add(retval.createSaveRecalc());
        records.add(retval.createPrintHeaders());
        records.add(retval.createPrintGridlines());
        retval.gridset = ( GridsetRecord ) retval.createGridset();
        records.add(retval.gridset);
        records.add(retval.createGuts());
        retval.defaultrowheight =
            ( DefaultRowHeightRecord ) retval.createDefaultRowHeight();
        records.add(retval.defaultrowheight);
        records.add(retval.createWSBool());
        records.add(retval.createHeader());
        records.add(retval.createFooter());
        records.add(retval.createHCenter());
        records.add(retval.createVCenter());
        records.add(retval.createPrintSetup());
        retval.defaultcolwidth =
            ( DefaultColWidthRecord ) retval.createDefaultColWidth();
        records.add(retval.defaultcolwidth);
        retval.dims    = ( DimensionsRecord ) retval.createDimensions();
        retval.dimsloc = 19;
        records.add(retval.dims);
        records.add(retval.createWindowTwo());
        retval.setLoc(records.size() - 1);
        records.add(retval.createSelection());
        records.add(retval.createEOF());
        retval.records = records;
        log.log(log.DEBUG, ""Sheet createsheet from scratch exit"");
        return retval;
    }

    private void checkCells()
    {
        if (cells == null)
        {
            cells = new ValueRecordsAggregate();
            records.add(getDimsLoc() + 1, cells);
        }
    }

    private void checkRows()
    {
        if (rows == null)
        {
            rows = new RowRecordsAggregate();
            records.add(getDimsLoc() + 1, rows);
        }
    }

    public int addMergedRegion(short rowFrom, short colFrom, short rowTo,
                               short colTo)
    {
        if (merged == null)
        {
            merged    = ( MergeCellsRecord ) createMergedCells();
            mergedloc = records.size() - 1;
            records.add(records.size() - 1, merged);
        }
        return merged.addArea(rowFrom, colFrom, rowTo, colTo);
    }

    public void removeMergedRegion(int index)
    {
        merged.removeAreaAt(index);
        if (merged.getNumAreas() == 0)
        {
            merged = null;
            records.remove(mergedloc);
            mergedloc = 0;
        }
    }

    public MergeCellsRecord.MergedRegion getMergedRegionAt(int index)
    {
        return merged.getAreaAt(index);
    }

    public int getNumMergedRegions()
    {
        return merged.getNumAreas();
    }

    

    public void convertLabelRecords(Workbook wb)
    {
        log.log(log.DEBUG, ""convertLabelRecords called"");
        if (containsLabels)
        {
            for (int k = 0; k < records.size(); k++)
            {
                Record rec = ( Record ) records.get(k);

                if (rec.getSid() == LabelRecord.sid)
                {
                    LabelRecord oldrec = ( LabelRecord ) rec;

                    records.remove(k);
                    LabelSSTRecord newrec   = new LabelSSTRecord();
                    int            stringid =
                        wb.addSSTString(oldrec.getValue());

                    newrec.setRow(oldrec.getRow());
                    newrec.setColumn(oldrec.getColumn());
                    newrec.setXFIndex(oldrec.getXFIndex());
                    newrec.setSSTIndex(stringid);
                    records.add(k, newrec);
                }
            }
        }
        log.log(log.DEBUG, ""convertLabelRecords exit"");
    }

    

    public int getNumRecords()
    {
        checkCells();
        checkRows();
        log.log(log.DEBUG, ""Sheet.getNumRecords"");
        log.logFormatted(log.DEBUG, ""returning % + % + % - 2 = %"", new int[]
        {
            records.size(), cells.getPhysicalNumberOfCells(),
            rows.getPhysicalNumberOfRows(),
            records.size() + cells.getPhysicalNumberOfCells()
            + rows.getPhysicalNumberOfRows() - 2
        });
        return records.size() + cells.getPhysicalNumberOfCells()
               + rows.getPhysicalNumberOfRows() - 2;
    }

    

    public void setDimensions(short firstrow, short firstcol, short lastrow,
                              short lastcol)
    {
        log.log(log.DEBUG, ""Sheet.setDimensions"");
        log.log(log.DEBUG,
                (new StringBuffer(""firstrow"")).append(firstrow)
                    .append(""firstcol"").append(firstcol).append(""lastrow"")
                    .append(lastrow).append(""lastcol"").append(lastcol)
                    .toString());
        dims.setFirstCol(firstcol);
        dims.setFirstRow(firstrow);
        dims.setLastCol(lastcol);
        dims.setLastRow(lastrow);
        log.log(log.DEBUG, ""Sheet.setDimensions exiting"");
    }

    

    public void setLoc(int loc)
    {
        valueRecIterator = null;
        log.log(log.DEBUG, ""sheet.setLoc(): "" + loc);
        this.loc = loc;
    }

    

    public int getLoc()
    {
        log.log(log.DEBUG, ""sheet.getLoc():"" + loc);
        return loc;
    }

    

    public void setPreOffset(int offset)
    {
        this.preoffset = offset;
    }

    

    public int getPreOffset()
    {
        return preoffset;
    }

    

    public byte [] serialize()
    {
        log.log(log.DEBUG, ""Sheet.serialize"");

        
        byte[] retval    = null;

        
        int    arraysize = getSize();
        int    pos       = 0;

        
        
        
        
        
        
        
        
        
        
        
        retval = new byte[ arraysize ];
        for (int k = 0; k < records.size(); k++)
        {

            
            
            pos += (( Record ) records.get(k)).serialize(pos,
                    retval);   
        }
        log.log(log.DEBUG, ""Sheet.serialize returning "" + retval);
        return retval;
    }

    

    public int serialize(int offset, byte [] data)
    {
        log.log(log.DEBUG, ""Sheet.serialize using offsets"");

        
        
        
        int pos       = 0;

        
        
        
        
        
        
        
        
        
        
        
        for (int k = 0; k < records.size(); k++)
        {

            
            
            pos += (( Record ) records.get(k)).serialize(pos + offset,
                    data);   
        }
        log.log(log.DEBUG, ""Sheet.serialize returning "");
        return pos;
    }

    

    public RowRecord createRow(int row)
    {
        log.log(log.DEBUG, ""create row number "" + row);
        RowRecord rowrec = new RowRecord();

        rowrec.setRowNumber(( short ) row);
        rowrec.setHeight(( short ) 0xff);
        rowrec.setOptimize(( short ) 0x0);
        rowrec.setOptionFlags(( short ) 0x0);
        rowrec.setXFIndex(( short ) 0x0);
        return rowrec;
    }

    

    public LabelSSTRecord createLabelSST(short row, short col, int index)
    {
        log.logFormatted(log.DEBUG, ""create labelsst row,col,index %,%,%"",
                         new int[]
        {
            row, col, index
        });
        LabelSSTRecord rec = new LabelSSTRecord();

        rec.setRow(row);
        rec.setColumn(col);
        rec.setSSTIndex(index);
        rec.setXFIndex(( short ) 0x0f);
        return rec;
    }

    

    public NumberRecord createNumber(short row, short col, double value)
    {
        log.logFormatted(log.DEBUG, ""create number row,col,value %,%,%"",
                         new double[]
        {
            row, col, value
        });
        NumberRecord rec = new NumberRecord();

        rec.setRow(( short ) row);
        rec.setColumn(col);
        rec.setValue(value);
        rec.setXFIndex(( short ) 0x0f);
        return rec;
    }

    

    public BlankRecord createBlank(short row, short col)
    {
        log.logFormatted(log.DEBUG, ""create blank row,col %,%"", new short[]
        {
            row, col
        });
        BlankRecord rec = new BlankRecord();

        rec.setRow(( short ) row);
        rec.setColumn(col);
        rec.setXFIndex(( short ) 0x0f);
        return rec;
    }

    

    public FormulaRecord createFormula(short row, short col, String formula)
    {
        log.logFormatted(log.DEBUG, ""create formula row,col,formula %,%,%"",
                         new short[]
        {
            row, col
        }, formula);
        FormulaRecord rec = new FormulaRecord();

        rec.setRow(row);
        rec.setColumn(col);
        rec.setOptions(( short ) 2);
        rec.setValue(0);
        rec.setXFIndex(( short ) 0x0f);
        Ptg[] ptg  = FormulaUtil.parseFormula(formula);
        int   size = 0;

        for (int k = 0; k < ptg.length; k++)
        {
            size += ptg[ k ].getSize();
            rec.pushExpressionToken(ptg[ k ]);
        }
        rec.setExpressionLength(( short ) size);
        return rec;
    }

    

    public void addValueRecord(short row, CellValueRecordInterface col)
    {
        checkCells();
        log.logFormatted(log.DEBUG, ""add value record  row,loc %,%"", new int[]
        {
            row, loc
        });
        DimensionsRecord d = ( DimensionsRecord ) records.get(getDimsLoc());

        if (col.getColumn() > d.getLastCol())
        {
            d.setLastCol(( short ) (col.getColumn() + 1));
        }
        if (col.getColumn() < d.getFirstCol())
        {
            d.setFirstCol(col.getColumn());
        }
        cells.insertCell(col);

        
    }

    

    public void removeValueRecord(short row, CellValueRecordInterface col)
    {
        checkCells();
        log.logFormatted(log.DEBUG, ""remove value record row,dimsloc %,%"",
                         new int[]
        {
            row, dimsloc
        });
        loc = dimsloc;
        cells.removeCell(col);

        
    }

    

    public void replaceValueRecord(CellValueRecordInterface newval)
    {
        checkCells();
        setLoc(dimsloc);
        log.log(log.DEBUG, ""replaceValueRecord "");
        cells.insertCell(newval);

        
    }

    

    public void addRow(RowRecord row)
    {
        checkRows();
        log.log(log.DEBUG, ""addRow "");
        DimensionsRecord d = ( DimensionsRecord ) records.get(getDimsLoc());

        if (row.getRowNumber() > d.getLastRow())
        {
            d.setLastRow(row.getRowNumber() + 1);
        }
        if (row.getRowNumber() < d.getFirstRow())
        {
            d.setFirstRow(row.getRowNumber());
        }
        

        rows.insertRow(row);

        
        log.log(log.DEBUG, ""exit addRow"");
    }

    

    public void removeRow(RowRecord row)
    {
        checkRows();
        

        setLoc(getDimsLoc());
        rows.removeRow(row);

        
    }

    

    public CellValueRecordInterface getNextValueRecord()
    {
        log.log(log.DEBUG, ""getNextValue loc= "" + loc);
        if (valueRecIterator == null)
        {
            valueRecIterator = cells.getIterator();
        }
        if (!valueRecIterator.hasNext())
        {
            return null;
        }
        return ( CellValueRecordInterface ) valueRecIterator.next();

        
    }

    



    

    public RowRecord getNextRow()
    {
        log.log(log.DEBUG, ""getNextRow loc= "" + loc);
        if (rowRecIterator == null)
        {
            rowRecIterator = rows.getIterator();
        }
        if (!rowRecIterator.hasNext())
        {
            return null;
        }
        return ( RowRecord ) rowRecIterator.next();


    }

    

    public RowRecord getRow(short rownum)
    {
        log.log(log.DEBUG, ""getNextRow loc= "" + loc);
        return rows.getRow(rownum);

        

        
    }

    

    public void addDBCellRecords()
    {
        int         offset        = 0;
        int         recnum        = 0;
        int         rownum        = 0;
        
        
        IndexRecord index         = null;

        
        IntList     rowOffsets    = new IntList();

        for (recnum = 0; recnum < records.size(); recnum++)
        {
            Record rec = ( Record ) records.get(recnum);

            if (rec.getSid() == IndexRecord.sid)
            {
                index = ( IndexRecord ) rec;
            }
            if (rec.getSid() != RowRecord.sid)
            {
                offset += rec.serialize().length;
            }
            else
            {
                break;
            }
        }

        
        for (; recnum < records.size(); recnum++)
        {
            Record rec = ( Record ) records.get(recnum);

            if (rec.getSid() == RowRecord.sid)
            {
                rownum++;
                rowOffsets.add(offset);
                if ((rownum % 32) == 0)
                {

                    
                    
                    for (int rn = recnum; rn < records.size(); rn++)
                    {
                        rec = ( Record ) records.get(rn);
                        if ((!rec.isInValueSection())
                                || (rec.getSid() == RowRecord.sid))
                        {

                            
                            records.add(rn,
                                        createDBCell(offset, rowOffsets,
                                                     index));
                            recnum = rn;
                            break;
                        }
                    }
                }
                else
                {
                }
            }
            if (!rec.isInValueSection())
            {
                records.add(recnum, createDBCell(offset, rowOffsets, index));
                break;
            }
            offset += rec.serialize().length;
        }
    }

    

    private DBCellRecord createDBCell(int offset, IntList rowoffsets,
                                      IndexRecord index)
    {
        DBCellRecord rec = new DBCellRecord();

        rec.setRowOffset(offset - rowoffsets.get(0));

        
        rec.addCellOffset(( short ) 0x0);

        
        addDbCellToIndex(offset, index);
        return rec;
    }

    

    private void addDbCellToIndex(int offset, IndexRecord index)
    {
        int numdbcells = index.getNumDbcells() + 1;

        index.addDbcell(offset + preoffset);

        
        for (int k = 0; k < numdbcells; k++)
        {
            int dbval = index.getDbcellAt(k);

            index.setDbcell(k, dbval + 4);
        }
    }

    

    protected Record createBOF()
    {
        BOFRecord retval = new BOFRecord();

        retval.setVersion(( short ) 0x600);
        retval.setType(( short ) 0x010);

        
        retval.setBuild(( short ) 0x0dbb);
        retval.setBuildYear(( short ) 1996);
        retval.setHistoryBitMask(0xc1);
        retval.setRequiredVersion(0x6);
        return retval;
    }

    

    protected Record createIndex()
    {
        IndexRecord retval = new IndexRecord();

        retval.setFirstRow(0);   
        retval.setLastRowAdd1(0);
        return retval;
    }

    

    protected Record createCalcMode()
    {
        CalcModeRecord retval = new CalcModeRecord();

        retval.setCalcMode(( short ) 1);
        return retval;
    }

    

    protected Record createCalcCount()
    {
        CalcCountRecord retval = new CalcCountRecord();

        retval.setIterations(( short ) 0x64);   
        return retval;
    }

    

    protected Record createRefMode()
    {
        RefModeRecord retval = new RefModeRecord();

        retval.setMode(retval.USE_A1_MODE);
        return retval;
    }

    

    protected Record createIteration()
    {
        IterationRecord retval = new IterationRecord();

        retval.setIteration(false);
        return retval;
    }

    

    protected Record createDelta()
    {
        DeltaRecord retval = new DeltaRecord();

        retval.setMaxChange((( double ) 0.0010));
        return retval;
    }

    

    protected Record createSaveRecalc()
    {
        SaveRecalcRecord retval = new SaveRecalcRecord();

        retval.setRecalc(true);
        return retval;
    }

    

    protected Record createPrintHeaders()
    {
        PrintHeadersRecord retval = new PrintHeadersRecord();

        retval.setPrintHeaders(false);
        return retval;
    }

    

    protected Record createPrintGridlines()
    {
        PrintGridlinesRecord retval = new PrintGridlinesRecord();

        retval.setPrintGridlines(false);
        return retval;
    }

    

    protected Record createGridset()
    {
        GridsetRecord retval = new GridsetRecord();

        retval.setGridset(true);
        return retval;
    }

    

    protected Record createGuts()
    {
        GutsRecord retval = new GutsRecord();

        retval.setLeftRowGutter(( short ) 0);
        retval.setTopColGutter(( short ) 0);
        retval.setRowLevelMax(( short ) 0);
        retval.setColLevelMax(( short ) 0);
        return retval;
    }

    

    protected Record createDefaultRowHeight()
    {
        DefaultRowHeightRecord retval = new DefaultRowHeightRecord();

        retval.setOptionFlags(( short ) 0);
        retval.setRowHeight(( short ) 0xff);
        return retval;
    }

    

    protected Record createWSBool()
    {
        WSBoolRecord retval = new WSBoolRecord();

        retval.setWSBool1(( byte ) 0x4);
        retval.setWSBool2(( byte ) 0xffffffc1);
        return retval;
    }

    

    protected Record createHeader()
    {
        HeaderRecord retval = new HeaderRecord();

        retval.setHeaderLength(( byte ) 0);
        retval.setHeader(null);
        return retval;
    }

    

    protected Record createFooter()
    {
        FooterRecord retval = new FooterRecord();

        retval.setFooterLength(( byte ) 0);
        retval.setFooter(null);
        return retval;
    }

    

    protected Record createHCenter()
    {
        HCenterRecord retval = new HCenterRecord();

        retval.setHCenter(false);
        return retval;
    }

    

    protected Record createVCenter()
    {
        VCenterRecord retval = new VCenterRecord();

        retval.setVCenter(false);
        return retval;
    }

    

    protected Record createPrintSetup()
    {
        PrintSetupRecord retval = new PrintSetupRecord();

        retval.setPaperSize(( short ) 1);
        retval.setScale(( short ) 100);
        retval.setPageStart(( short ) 1);
        retval.setFitWidth(( short ) 1);
        retval.setFitHeight(( short ) 1);
        retval.setOptions(( short ) 2);
        retval.setHResolution(( short ) 300);
        retval.setVResolution(( short ) 300);
        retval.setHeaderMargin(( double ) 0.5);
        retval.setFooterMargin(( double ) 0.5);
        retval.setCopies(( short ) 0);
        return retval;
    }

    

    protected Record createDefaultColWidth()
    {
        DefaultColWidthRecord retval = new DefaultColWidthRecord();

        retval.setColWidth(( short ) 8);
        return retval;
    }

    

    protected Record createColInfo()
    {
        ColumnInfoRecord retval = new ColumnInfoRecord();

        retval.setColumnWidth(( short ) 0x8);
        retval.setOptions(( short ) 6);
        retval.setXFIndex(( short ) 0x0f);
        return retval;
    }

    

    public short getDefaultColumnWidth()
    {
        return defaultcolwidth.getColWidth();
    }

    

    public boolean isGridsPrinted()
    {
        return !gridset.getGridset();
    }

    

    public void setGridsPrinted(boolean value)
    {
        gridset.setGridset(!value);
    }

    

    public void setDefaultColumnWidth(short dcw)
    {
        defaultcolwidth.setColWidth(dcw);
    }

    

    public void setDefaultRowHeight(short dch)
    {
        defaultrowheight.setRowHeight(dch);
    }

    

    public short getDefaultRowHeight()
    {
        return defaultrowheight.getRowHeight();
    }

    

    public short getColumnWidth(short column)
    {
        short            retval = 0;
        ColumnInfoRecord ci     = null;
        int              k      = 0;

        if (columnSizes != null)
        {
            for (k = 0; k < columnSizes.size(); k++)
            {
                ci = ( ColumnInfoRecord ) columnSizes.get(k);
                if ((ci.getFirstColumn() >= column)
                        && (ci.getLastColumn() <= column))
                {
                    break;
                }
                ci = null;
            }
        }
        if (ci != null)
        {
            retval = ci.getColumnWidth();
        }
        else
        {
            retval = defaultcolwidth.getColWidth();
        }
        return retval;
    }

    

    public void setColumnWidth(short column, short width)
    {
        ColumnInfoRecord ci = null;
        int              k  = 0;

        if (columnSizes == null)
        {
            columnSizes = new ArrayList();
        }
        

        for (k = 0; k < columnSizes.size(); k++)
        {
            ci = ( ColumnInfoRecord ) columnSizes.get(k);
            if ((ci.getFirstColumn() >= column)
                    && (ci.getLastColumn() <= column))
            {
                break;
            }
            ci = null;
        }
        if (ci != null)
        {
            if (ci.getColumnWidth() == width)
            {

                
            }
            else if ((ci.getFirstColumn() == column)
                     && (ci.getLastColumn() == column))
            {                               
                ci.setColumnWidth(width);   
            }
            else if ((ci.getFirstColumn() == column)
                     || (ci.getLastColumn() == column))
            {

                
                
                if (ci.getFirstColumn() == column)
                {
                    ci.setFirstColumn(( short ) (column + 1));
                }
                else
                {
                    ci.setLastColumn(( short ) (column - 1));
                }
                ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo();

                nci.setFirstColumn(column);
                nci.setLastColumn(column);
                nci.setOptions(ci.getOptions());
                nci.setXFIndex(ci.getXFIndex());
                nci.setColumnWidth(width);
                columnSizes.add(k, nci);
                records.add((1 + getDimsLoc() - columnSizes.size()) + k, nci);
                dimsloc++;
            }
        }
        else
        {

            
            ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo();

            nci.setFirstColumn(column);
            nci.setLastColumn(column);
            nci.setColumnWidth(width);
            columnSizes.add(k, nci);
            records.add((1 + getDimsLoc() - columnSizes.size()) + k, nci);
            dimsloc++;
        }
    }

    

    protected Record createDimensions()
    {
        DimensionsRecord retval = new DimensionsRecord();

        retval.setFirstCol(( short ) 0);
        retval.setLastRow(1);             
        retval.setFirstRow(0);
        retval.setLastCol(( short ) 1);   
        return retval;
    }

    

    protected Record createWindowTwo()
    {
        WindowTwoRecord retval = new WindowTwoRecord();

        retval.setOptions(( short ) 0x6b6);
        retval.setTopRow(( short ) 0);
        retval.setLeftCol(( short ) 0);
        retval.setHeaderColor(0x40);
        retval.setPageBreakZoom(( short ) 0);
        retval.setNormalZoom(( short ) 0);
        return retval;
    }

    

    protected Record createSelection()
    {
        SelectionRecord retval = new SelectionRecord();

        retval.setPane(( byte ) 0x3);
        retval.setActiveCellCol(( short ) 0x0);
        retval.setActiveCellRow(( short ) 0x0);
        retval.setNumRefs(( short ) 0x0);
        return retval;
    }

    protected Record createMergedCells()
    {
        MergeCellsRecord retval = new MergeCellsRecord();

        retval.setNumAreas(( short ) 0);
        return retval;
    }

    

    protected Record createEOF()
    {
        return new EOFRecord();
    }

    

    public int getDimsLoc()
    {
        log.log(log.DEBUG, ""getDimsLoc dimsloc= "" + dimsloc);
        return dimsloc;
    }

    

    public void checkDimsLoc(Record rec, int recloc)
    {
        if (rec.getSid() == DimensionsRecord.sid)
        {
            loc     = recloc;
            dimsloc = recloc;
        }
    }

    public int getSize()
    {
        int retval = 0;

        for (int k = 0; k < records.size(); k++)
        {
            retval += (( Record ) records.get(k)).getRecordSize();
        }
        return retval;
    }

    public List getRecords()
    {
        return records;
    }

    

    public GridsetRecord getGridsetRecord()
    {
        return gridset;
    }

    

    public Record findFirstRecordBySid(short sid)
    {
        for (Iterator iterator = records.iterator(); iterator.hasNext(); )
        {
            Record record = ( Record ) iterator.next();

            if (record.getSid() == sid)
            {
                return record;
            }
        }
        return null;
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.DocumentEntry,1,1,0,7,1,0,6,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.filesystem;



public interface DocumentEntry
    extends Entry
{

    

    public int getSize();
}   

"
poi,1.5,org.apache.poi.hpsf.littleendian.Byte,2,2,0,2,3,1,1,1,2,2.0,10,0.0,0,0.75,0.666666667,1,1,3.5,1,0.5,0,"

package org.apache.poi.hpsf.littleendian;


public class Byte extends LittleEndian
{

    
    public Byte(final byte[] src, final int offset)
    {
        super(src, offset);
    }



    public final static int LENGTH = 1;

    public int length()
    {
        return LENGTH;
    }

}
"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFDataFormat,6,1,0,1,12,0,1,0,5,0.2,266,1.0,0,0.0,0.166666667,0,0,43.16666667,5,2.0,4,"



package org.apache.poi.hssf.usermodel;

import java.util.ArrayList;
import java.util.List;



public class HSSFDataFormat
{
    private static ArrayList formats;

    private static synchronized void populateFormats()
    {
        formats = new ArrayList();
        formats.add(0, ""General"");
        formats.add(1, ""0"");
        formats.add(2, ""0.00"");
        formats.add(3, ""#,##0"");
        formats.add(4, ""#,##0.00"");
        formats.add(5, ""($#,##0_);($#,##0)"");
        formats.add(6, ""($#,##0_);[Red]($#,##0)"");
        formats.add(7, ""($#,##0.00);($#,##0.00)"");
        formats.add(8, ""($#,##0.00_);[Red]($#,##0.00)"");
        formats.add(9, ""0%"");
        formats.add(0xa, ""0.00%"");
        formats.add(0xb, ""0.00E+00"");
        formats.add(0xc, ""# ?/?"");
        formats.add(0xd, ""# ??/??"");
        formats.add(0xe, ""m/d/yy"");
        formats.add(0xf, ""d-mmm-yy"");
        formats.add(0x10, ""d-mmm"");
        formats.add(0x11, ""mmm-yy"");
        formats.add(0x12, ""h:mm AM/PM"");
        formats.add(0x13, ""h:mm:ss AM/PM"");
        formats.add(0x14, ""h:mm"");
        formats.add(0x15, ""h:mm:ss"");
        formats.add(0x16, ""m/d/yy h:mm"");

        
        formats.add(0x17, ""0x17"");
        formats.add(0x18, ""0x18"");
        formats.add(0x19, ""0x19"");
        formats.add(0x1a, ""0x1a"");
        formats.add(0x1b, ""0x1b"");
        formats.add(0x1c, ""0x1c"");
        formats.add(0x1d, ""0x1d"");
        formats.add(0x1e, ""0x1e"");
        formats.add(0x1f, ""0x1f"");
        formats.add(0x20, ""0x20"");
        formats.add(0x21, ""0x21"");
        formats.add(0x22, ""0x22"");
        formats.add(0x23, ""0x23"");
        formats.add(0x24, ""0x24"");

        
        formats.add(0x25, ""(#,##0_);(#,##0)"");
        formats.add(0x26, ""(#,##0_);[Red](#,##0)"");
        formats.add(0x27, ""(#,##0.00_);(#,##0.00)"");
        formats.add(0x28, ""(#,##0.00_);[Red](#,##0.00)"");
        formats.add(0x29, ""_(*#,##0_);_(*(#,##0);_(* ""-""_);_(@_)"");
        formats.add(0x2a, ""_($*#,##0_);_($*(#,##0);_($* ""-""_);_(@_)"");
        formats.add(0x2b, ""_(*#,##0.00_);_(*(#,##0.00);_(*""-""??_);_(@_)"");
        formats.add(0x2c,
                    ""_($*#,##0.00_);_($*(#,##0.00);_($*""-""??_);_(@_)"");
        formats.add(0x2d, ""mm:ss"");
        formats.add(0x2e, ""[h]:mm:ss"");
        formats.add(0x2f, ""mm:ss.0"");
        formats.add(0x30, ""##0.0E+0"");
        formats.add(0x31, ""@"");
    }

    public static List getFormats()
    {
        if (formats == null)
        {
            populateFormats();
        }
        return formats;
    }

    

    public static short getFormat(String format)
    {
        if (formats == null)
        {
            populateFormats();
        }
        short retval = -1;

        for (short k = 0; k < 0x31; k++)
        {
            String nformat = ( String ) formats.get(k);

            if ((nformat != null) && nformat.equals(format))
            {
                retval = k;
                break;
            }
        }
        return retval;
    }

    

    public static String getFormat(short index)
    {
        if (formats == null)
        {
            populateFormats();
        }
        return ( String ) formats.get(index);
    }

    

    public static int getNumberOfBuiltinFormats()
    {
        if (formats == null)
        {
            populateFormats();
        }
        return formats.size();
    }
}
"
poi,1.5,org.apache.poi.hssf.eventmodel.HSSFEventFactory,3,1,0,9,12,3,2,7,3,2.0,121,0.0,0,0.0,0.583333333,0,0,39.33333333,1,0.6667,2,"


package org.apache.poi.hssf.eventmodel;

import java.io.InputStream;
import java.io.IOException;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.hssf.record.RecordFormatException;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordFactory;
import org.apache.poi.hssf.record.ContinueRecord;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;



public class HSSFEventFactory
{

    

    public HSSFEventFactory()
    {
    }

    

    public void processWorkbookEvents(HSSFRequest req, POIFSFileSystem fs)
        throws IOException
    {
        InputStream in = fs.createDocumentInputStream(""Workbook"");

        processEvents(req, in);
    }

    

    public void processEvents(HSSFRequest req, InputStream in)
        throws IOException
    {
        try
        {
            byte[] sidbytes  = new byte[ 2 ];
            int    bytesread = in.read(sidbytes);
            Record rec       = null;

            while (bytesread > 0)
            {
                short sid = 0;

                sid = LittleEndian.getShort(sidbytes);
                if ((rec != null) && (sid != ContinueRecord.sid))
                {
                    req.processRecord(rec);
                }
                if (sid != ContinueRecord.sid)
                {
                    short  size = LittleEndian.readShort(in);
                    byte[] data = new byte[ size ];

                    if (data.length > 0)
                    {
                        in.read(data);
                    }
                    Record[] recs = RecordFactory.createRecord(sid, size,
                                                               data);

                    if (recs.length > 1)
                    {                                
                        for (int k = 0; k < (recs.length - 1); k++)
                        {                            
                            req.processRecord(
                                recs[ k ]);          
                        }
                    }
                    rec = recs[ recs.length - 1 ];   

                    
                    
                    
                    
                }
                else
                {                                    
                    short  size = LittleEndian.readShort(in);
                    byte[] data = new byte[ size ];

                    if (data.length > 0)
                    {
                        in.read(data);
                    }
                    rec.processContinueRecord(data);
                }
                bytesread = in.read(sidbytes);       
            }
            if (rec != null)
            {
                req.processRecord(rec);
            }
        }
        catch (IOException e)
        {
            throw new RecordFormatException(""Error reading bytes"");
        }

        
        
        
    }
}
"
poi,1.5,org.apache.poi.hssf.record.WindowTwoRecord,47,2,0,7,63,193,3,4,45,0.879347826,856,0.95,12,0.2,0.327659574,1,6,16.78723404,3,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;



public class WindowTwoRecord
    extends Record
{
    public final static short sid = 0x23e;
    private short             field_1_options;

    
    private BitField          displayFormulas         = new BitField(0x01);
    private BitField          displayGridlines        = new BitField(0x02);
    private BitField          displayRowColHeadings   = new BitField(0x04);
    private BitField          freezePanes             = new BitField(0x08);
    private BitField          displayZeros            = new BitField(0x10);
    private BitField          defaultHeader           =
        new BitField(0x20);   

    
    
    private BitField          arabic                  =
        new BitField(0x40);   
    private BitField          displayGuts             = new BitField(0x80);
    private BitField          freezePanesNoSplit      = new BitField(0x100);
    private BitField          selected                = new BitField(0x200);
    private BitField          paged                   = new BitField(0x400);
    private BitField          savedInPageBreakPreview = new BitField(0x800);

    
    
    private short             field_2_top_row;
    private short             field_3_left_col;
    private int               field_4_header_color;
    private short             field_5_page_break_zoom;
    private short             field_6_normal_zoom;
    private int               field_7_reserved;

    public WindowTwoRecord()
    {
    }

    

    public WindowTwoRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public WindowTwoRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid WindowTwo RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_options      = LittleEndian.getShort(data, 0 + offset);
        field_2_top_row      = LittleEndian.getShort(data, 2 + offset);
        field_3_left_col     = LittleEndian.getShort(data, 4 + offset);
        field_4_header_color = LittleEndian.getInt(data, 6 + offset);
        if (size > 10)
        {
            field_5_page_break_zoom = LittleEndian.getShort(data,
                    10 + offset);
            field_6_normal_zoom     = LittleEndian.getShort(data,
                    12 + offset);
        }
        if (size > 14)
        {   
            field_7_reserved = LittleEndian.getInt(data, 14 + offset);
        }
    }

    

    public void setOptions(short options)
    {
        field_1_options = options;
    }

    

    

    public void setDisplayFormulas(boolean formulas)
    {
        field_1_options = displayFormulas.setShortBoolean(field_1_options, formulas);
    }

    

    public void setDisplayGridlines(boolean gridlines)
    {
        field_1_options = displayGridlines.setShortBoolean(field_1_options, gridlines);
    }

    

    public void setDisplayRowColHeadings(boolean headings)
    {
        field_1_options = displayRowColHeadings.setShortBoolean(field_1_options, headings);
    }

    

    public void setFreezePanes(boolean freezepanes)
    {
        field_1_options = freezePanes.setShortBoolean(field_1_options, freezepanes);
    }

    

    public void setDisplayZeros(boolean zeros)
    {
        field_1_options = displayZeros.setShortBoolean(field_1_options, zeros);
    }

    

    public void setDefaultHeader(boolean header)
    {
        field_1_options = defaultHeader.setShortBoolean(field_1_options, header);
    }

    

    public void setArabic(boolean isarabic)
    {
        field_1_options = arabic.setShortBoolean(field_1_options, isarabic);
    }

    

    public void setDisplayGuts(boolean guts)
    {
        field_1_options = displayGuts.setShortBoolean(field_1_options, guts);
    }

    

    public void setFreezePanesNoSplit(boolean freeze)
    {
        field_1_options = freezePanesNoSplit.setShortBoolean(field_1_options, freeze);
    }

    

    public void setSelected(boolean sel)
    {
        field_1_options = selected.setShortBoolean(field_1_options, sel);
    }

    

    public void setPaged(boolean p)
    {
        field_1_options = paged.setShortBoolean(field_1_options, p);
    }

    

    public void setSavedInPageBreakPreview(boolean p)
    {
        field_1_options = savedInPageBreakPreview.setShortBoolean(field_1_options, p);
    }

    

    

    public void setTopRow(short topRow)
    {
        field_2_top_row = topRow;
    }

    

    public void setLeftCol(short leftCol)
    {
        field_3_left_col = leftCol;
    }

    

    public void setHeaderColor(int color)
    {
        field_4_header_color = color;
    }

    

    public void setPageBreakZoom(short zoom)
    {
        field_5_page_break_zoom = zoom;
    }

    

    public void setNormalZoom(short zoom)
    {
        field_6_normal_zoom = zoom;
    }

    

    public void setReserved(int reserved)
    {
        field_7_reserved = reserved;
    }

    

    public short getOptions()
    {
        return field_1_options;
    }

    

    

    public boolean getDisplayFormulas()
    {
        return displayFormulas.isSet(field_1_options);
    }

    

    public boolean getDisplayGridlines()
    {
        return displayGridlines.isSet(field_1_options);
    }

    

    public boolean getDisplayRowColHeadings()
    {
        return displayRowColHeadings.isSet(field_1_options);
    }

    

    public boolean getFreezePanes()
    {
        return freezePanes.isSet(field_1_options);
    }

    

    public boolean getDisplayZeros()
    {
        return displayZeros.isSet(field_1_options);
    }

    

    public boolean getDefaultHeader()
    {
        return defaultHeader.isSet(field_1_options);
    }

    

    public boolean getArabic()
    {
        return arabic.isSet(field_1_options);
    }

    

    public boolean getDisplayGuts()
    {
        return displayGuts.isSet(field_1_options);
    }

    

    public boolean getFreezePanesNoSplit()
    {
        return freezePanesNoSplit.isSet(field_1_options);
    }

    

    public boolean getSelected()
    {
        return selected.isSet(field_1_options);
    }

    

    public boolean getPaged()
    {
        return paged.isSet(field_1_options);
    }

    

    public boolean getSavedInPageBreakPreview()
    {
        return savedInPageBreakPreview.isSet(field_1_options);
    }

    

    

    public short getTopRow()
    {
        return field_2_top_row;
    }

    

    public short getLeftCol()
    {
        return field_3_left_col;
    }

    

    public int getHeaderColor()
    {
        return field_4_header_color;
    }

    

    public short getPageBreakZoom()
    {
        return field_5_page_break_zoom;
    }

    

    public short getNormalZoom()
    {
        return field_6_normal_zoom;
    }

    

    public int getReserved()
    {
        return field_7_reserved;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WINDOW2]
"");
        buffer.append(""    .options        = "")
            .append(Integer.toHexString(getOptions())).append(""
"");
        buffer.append(""       .dispformulas= "").append(getDisplayFormulas())
            .append(""
"");
        buffer.append(""       .dispgridlins= "").append(getDisplayGridlines())
            .append(""
"");
        buffer.append(""       .disprcheadin= "")
            .append(getDisplayRowColHeadings()).append(""
"");
        buffer.append(""       .freezepanes = "").append(getFreezePanes())
            .append(""
"");
        buffer.append(""       .displayzeros= "").append(getDisplayZeros())
            .append(""
"");
        buffer.append(""       .defaultheadr= "").append(getDefaultHeader())
            .append(""
"");
        buffer.append(""       .arabic      = "").append(getArabic())
            .append(""
"");
        buffer.append(""       .displayguts = "").append(getDisplayGuts())
            .append(""
"");
        buffer.append(""       .frzpnsnosplt= "")
            .append(getFreezePanesNoSplit()).append(""
"");
        buffer.append(""       .selected    = "").append(getSelected())
            .append(""
"");
        buffer.append(""       .paged       = "").append(getPaged())
            .append(""
"");
        buffer.append(""       .svdinpgbrkpv= "")
            .append(getSavedInPageBreakPreview()).append(""
"");
        buffer.append(""    .toprow         = "")
            .append(Integer.toHexString(getTopRow())).append(""
"");
        buffer.append(""    .leftcol        = "")
            .append(Integer.toHexString(getLeftCol())).append(""
"");
        buffer.append(""    .headercolor    = "")
            .append(Integer.toHexString(getHeaderColor())).append(""
"");
        buffer.append(""    .pagebreakzoom  = "")
            .append(Integer.toHexString(getPageBreakZoom())).append(""
"");
        buffer.append(""    .normalzoom     = "")
            .append(Integer.toHexString(getNormalZoom())).append(""
"");
        buffer.append(""    .reserved       = "")
            .append(Integer.toHexString(getReserved())).append(""
"");
        buffer.append(""[/WINDOW2]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 18);
        LittleEndian.putShort(data, 4 + offset, getOptions());
        LittleEndian.putShort(data, 6 + offset, getTopRow());
        LittleEndian.putShort(data, 8 + offset, getLeftCol());
        LittleEndian.putInt(data, 10 + offset, getHeaderColor());
        LittleEndian.putShort(data, 14 + offset, getPageBreakZoom());
        LittleEndian.putShort(data, 16 + offset, getNormalZoom());
        LittleEndian.putInt(data, 18 + offset, getReserved());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 22;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.HeaderRecord,13,2,0,6,25,66,2,4,11,0.777777778,175,0.666666667,0,0.523809524,0.333333333,1,6,12.23076923,3,1.1538,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class HeaderRecord
    extends Record
{
    public final static short sid = 0x14;
    private byte              field_1_header_len;
    private String            field_2_header;

    public HeaderRecord()
    {
    }

    

    public HeaderRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public HeaderRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A HEADERRECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        if (size > 0)
        {
            field_1_header_len = data[ 0 + offset ];
            field_2_header     = new String(data, 3 + offset, 
                                            LittleEndian.ubyteToInt(field_1_header_len));
        }
    }

    

    public void setHeaderLength(byte len)
    {
        field_1_header_len = len;
    }

    

    public void setHeader(String header)
    {
        field_2_header = header;
    }

    

    public short getHeaderLength()
    {
        return (short)(0xFF & field_1_header_len); 
    }

    

    public String getHeader()
    {
        return field_2_header;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[HEADER]
"");
        buffer.append(""    .length         = "").append(getHeaderLength())
            .append(""
"");
        buffer.append(""    .header         = "").append(getHeader())
            .append(""
"");
        buffer.append(""[/HEADER]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        int len = 4;

        if (getHeaderLength() != 0)
        {
            len+=3; 
        }
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) ((len - 4) + getHeaderLength()));

        if (getHeaderLength() > 0)
        {
            data[ 4 + offset ] = (byte)getHeaderLength();
            StringUtil.putCompressedUnicode(getHeader(), data, 7 + offset); 
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        int retval = 4;

        if (getHeaderLength() != 0)
        {
            retval+=3; 
        }
        retval += getHeaderLength();
        return retval;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFWorkbook,27,1,0,18,82,0,2,16,24,0.723076923,553,0.8,2,0.0,0.183760684,0,0,19.2962963,5,1.4815,12,"


package org.apache.poi.hssf.usermodel;

import org.apache.poi.util.POILogFactory;
import org.apache.poi.hssf.model.Sheet;
import org.apache.poi.hssf.model.Workbook;
import org.apache.poi.hssf.record.*;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.util.POILogger;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;



public class HSSFWorkbook
        extends java.lang.Object
{
    private static final int DEBUG = POILogger.DEBUG;

    

    public final static int INITIAL_CAPACITY = 3;

    

    private Workbook workbook;

    

    private ArrayList sheets;
    private static POILogger log = POILogFactory.getLogger(HSSFWorkbook.class);

    

    public HSSFWorkbook()
    {
        workbook = Workbook.createWorkbook();
        sheets = new ArrayList(INITIAL_CAPACITY);
    }

    

    public HSSFWorkbook(POIFSFileSystem fs)
            throws IOException
    {
        sheets = new ArrayList(INITIAL_CAPACITY);
        InputStream stream = fs.createDocumentInputStream(""Workbook"");
        List records = RecordFactory.createRecords(stream);

        workbook = Workbook.createWorkbook(records);
        setPropertiesFromWorkbook(workbook);
        int numRecords = workbook.getNumRecords();
        int sheetNum = 0;

        while (numRecords < records.size())
        {
            Sheet sheet = Sheet.createSheet(records, sheetNum++, numRecords);

            numRecords += sheet.getNumRecords();
            sheet.convertLabelRecords(
                    workbook);   
            HSSFSheet hsheet = new HSSFSheet(workbook, sheet);

            sheets.add(hsheet);

            
        }
    }

    

    public HSSFWorkbook(InputStream s)
            throws IOException
    {
        this((new POIFSFileSystem(s)));
    }

    

    private void setPropertiesFromWorkbook(Workbook book)
    {
        this.workbook = book;

        
    }

    

    public void setSheetName(int sheet, String name)
    {
        if (sheet > (sheets.size() - 1))
        {
            throw new RuntimeException(""Sheet out of bounds"");
        }
        workbook.setSheetName(sheet, name);
    }

    

    public String getSheetName(int sheet)
    {
        if (sheet > (sheets.size() - 1))
        {
            throw new RuntimeException(""Sheet out of bounds"");
        }
        return workbook.getSheetName(sheet);
    }

    

    public int getSheetIndex(String name)
    {
        int retval = -1;

        for (int k = 0; k < sheets.size(); k++)
        {
            String sheet = workbook.getSheetName(k);

            if (sheet.equals(name))
            {
                retval = k;
                break;
            }
        }
        return retval;
    }

    

    public HSSFSheet createSheet()
    {



        HSSFSheet sheet = new HSSFSheet(workbook);

        sheets.add(sheet);
        workbook.setSheetName(sheets.size() - 1,
                ""Sheet"" + (sheets.size() - 1));
        WindowTwoRecord windowTwo = (WindowTwoRecord) sheet.getSheet().findFirstRecordBySid(WindowTwoRecord.sid);
        windowTwo.setSelected(sheets.size() == 1);
        windowTwo.setPaged(sheets.size() == 1);
        return sheet;
    }

    

    public HSSFSheet createSheet(String sheetname)
    {



        HSSFSheet sheet = new HSSFSheet(workbook);

        sheets.add(sheet);
        workbook.setSheetName(sheets.size() - 1, sheetname);
        WindowTwoRecord windowTwo = (WindowTwoRecord) sheet.getSheet().findFirstRecordBySid(WindowTwoRecord.sid);
        windowTwo.setSelected(sheets.size() == 1);
        windowTwo.setPaged(sheets.size() == 1);
        return sheet;
    }

    

    public int getNumberOfSheets()
    {
        return sheets.size();
    }

    

    public HSSFSheet getSheetAt(int index)
    {
        return (HSSFSheet) sheets.get(index);
    }

    

    public HSSFSheet getSheet(String name)
    {
        HSSFSheet retval = null;

        for (int k = 0; k < sheets.size(); k++)
        {
            String sheetname = workbook.getSheetName(k);

            if (sheetname.equals(name))
            {
                retval = (HSSFSheet) sheets.get(k);
            }
        }
        return retval;
    }

    

    public void removeSheetAt(int index)
    {
        sheets.remove(index);
        workbook.removeSheet(index);
    }

    

    public void setBackupFlag(boolean backupValue)
    {
        BackupRecord backupRecord = workbook.getBackupRecord();

        backupRecord.setBackup(backupValue ? (short) 1
                : (short) 0);
    }

    

    public boolean getBackupFlag()
    {
        BackupRecord backupRecord = workbook.getBackupRecord();

        return (backupRecord.getBackup() == 0) ? false
                : true;
    }

    

    public HSSFFont createFont()
    {
        FontRecord font = workbook.createNewFont();
        short fontindex = (short) (getNumberOfFonts() - 1);

        if (fontindex > 3)
        {
            fontindex++;   
        }
        HSSFFont retval = new HSSFFont(fontindex, font);

        return retval;
    }

    

    public short getNumberOfFonts()
    {
        return (short) workbook.getNumberOfFontRecords();
    }

    

    public HSSFFont getFontAt(short idx)
    {
        FontRecord font = workbook.getFontRecordAt(idx);
        HSSFFont retval = new HSSFFont(idx, font);

        return retval;
    }

    

    public HSSFCellStyle createCellStyle()
    {
        ExtendedFormatRecord xfr = workbook.createCellXF();
        short index = (short) (getNumCellStyles() - 1);
        HSSFCellStyle style = new HSSFCellStyle(index, xfr);

        return style;
    }

    

    public short getNumCellStyles()
    {
        return (short) workbook.getNumExFormats();
    }

    

    public HSSFCellStyle getCellStyleAt(short idx)
    {
        ExtendedFormatRecord xfr = workbook.getExFormatAt(idx);
        HSSFCellStyle style = new HSSFCellStyle(idx, xfr);

        return style;
    }

    

    public void write(OutputStream stream)
            throws IOException
    {
        byte[] bytes = getBytes();
        POIFSFileSystem fs = new POIFSFileSystem();

        fs.createDocument(new ByteArrayInputStream(bytes), ""Workbook"");
        fs.writeFilesystem(stream);
    }

    

    public byte[] getBytes()
    {
        log.log(DEBUG, ""HSSFWorkbook.getBytes()"");
        int wbsize = workbook.getSize();

        
        
        int totalsize = wbsize;

        for (int k = 0; k < sheets.size(); k++)
        {
            workbook.setSheetBof(k, totalsize);

            
            totalsize += ((HSSFSheet) sheets.get(k)).getSheet().getSize();
        }
        if (totalsize < 4096)
        {
            totalsize = 4096;
        }
        byte[] retval = new byte[totalsize];
        int pos = workbook.serialize(0, retval);

        
        for (int k = 0; k < sheets.size(); k++)
        {

            
            
            pos += ((HSSFSheet) sheets.get(k)).getSheet().serialize(pos,
                    retval);   
        }
        for (int k = pos; k < totalsize; k++)
        {
            retval[k] = 0;
        }
        return retval;
    }

    public int addSSTString(String string)
    {
        return workbook.addSSTString(string);
    }

    public String getSSTString(int index)
    {
        return workbook.getSSTString(index);
    }

    Workbook getWorkbook()
    {
        return workbook;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.WindowOneRecord,38,2,0,6,52,479,2,4,35,0.898648649,536,0.9375,6,0.244444444,0.335135135,1,6,12.68421053,2,0.9211,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;



public class WindowOneRecord
    extends Record
{
    public final static short     sid = 0x3d;

    
    private short                 field_1_h_hold;                  
    private short                 field_2_v_hold;                  
    private short                 field_3_width;
    private short                 field_4_height;
    private short                 field_5_options;
    static final private BitField hidden   =
        new BitField(0x01);                                        
    static final private BitField iconic   =
        new BitField(0x02);                                        
    static final private BitField reserved = new BitField(0x04);   
    static final private BitField hscroll  =
        new BitField(0x08);                                        
    static final private BitField vscroll  =
        new BitField(0x10);                                        
    static final private BitField tabs     =
        new BitField(0x20);                                        

    
    private short                 field_6_selected_tab;
    private short                 field_7_displayed_tab;
    private short                 field_8_num_selected_tabs;
    private short                 field_9_tab_width_ratio;

    public WindowOneRecord()
    {
    }

    

    public WindowOneRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public WindowOneRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A WINDOW1 RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_h_hold            = LittleEndian.getShort(data, 0 + offset);
        field_2_v_hold            = LittleEndian.getShort(data, 2 + offset);
        field_3_width             = LittleEndian.getShort(data, 4 + offset);
        field_4_height            = LittleEndian.getShort(data, 6 + offset);
        field_5_options           = LittleEndian.getShort(data, 8 + offset);
        field_6_selected_tab      = LittleEndian.getShort(data, 10 + offset);
        field_7_displayed_tab     = LittleEndian.getShort(data, 12 + offset);
        field_8_num_selected_tabs = LittleEndian.getShort(data, 14 + offset);
        field_9_tab_width_ratio   = LittleEndian.getShort(data, 16 + offset);
    }

    

    public void setHorizontalHold(short h)
    {
        field_1_h_hold = h;
    }

    

    public void setVerticalHold(short v)
    {
        field_2_v_hold = v;
    }

    

    public void setWidth(short w)
    {
        field_3_width = w;
    }

    

    public void setHeight(short h)
    {
        field_4_height = h;
    }

    

    public void setOptions(short o)
    {
        field_5_options = o;
    }

    

    

    public void setHidden(boolean ishidden)
    {
        field_5_options = hidden.setShortBoolean(field_5_options, ishidden);
    }

    

    public void setIconic(boolean isiconic)
    {
        field_5_options = iconic.setShortBoolean(field_5_options, isiconic);
    }

    

    public void setDisplayHorizonalScrollbar(boolean scroll)
    {
        field_5_options = hscroll.setShortBoolean(field_5_options, scroll);
    }

    

    public void setDisplayVerticalScrollbar(boolean scroll)
    {
        field_5_options = vscroll.setShortBoolean(field_5_options, scroll);
    }

    

    public void setDisplayTabs(boolean disptabs)
    {
        field_5_options = tabs.setShortBoolean(field_5_options, disptabs);
    }

    

    

    public void setSelectedTab(short s)
    {
        field_6_selected_tab = s;
    }

    

    public void setDisplayedTab(short t)
    {
        field_7_displayed_tab = t;
    }

    

    public void setNumSelectedTabs(short n)
    {
        field_8_num_selected_tabs = n;
    }

    

    public void setTabWidthRatio(short r)
    {
        field_9_tab_width_ratio = r;
    }

    

    public short getHorizontalHold()
    {
        return field_1_h_hold;
    }

    

    public short getVerticalHold()
    {
        return field_2_v_hold;
    }

    

    public short getWidth()
    {
        return field_3_width;
    }

    

    public short getHeight()
    {
        return field_4_height;
    }

    

    public short getOptions()
    {
        return field_5_options;
    }

    

    

    public boolean getHidden()
    {
        return hidden.isSet(field_5_options);
    }

    

    public boolean getIconic()
    {
        return iconic.isSet(field_5_options);
    }

    

    public boolean getDisplayHorizontalScrollbar()
    {
        return hscroll.isSet(field_5_options);
    }

    

    public boolean getDisplayVerticalScrollbar()
    {
        return vscroll.isSet(field_5_options);
    }

    

    public boolean getDisplayTabs()
    {
        return tabs.isSet(field_5_options);
    }

    

    

    public short getSelectedTab()
    {
        return field_6_selected_tab;
    }

    

    public short getDisplayedTab()
    {
        return field_7_displayed_tab;
    }

    

    public short getNumSelectedTabs()
    {
        return field_8_num_selected_tabs;
    }

    

    public short getTabWidthRatio()
    {
        return field_9_tab_width_ratio;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WINDOW1]
"");
        buffer.append(""    .h_hold          = "")
            .append(Integer.toHexString(getHorizontalHold())).append(""
"");
        buffer.append(""    .v_hold          = "")
            .append(Integer.toHexString(getVerticalHold())).append(""
"");
        buffer.append(""    .width           = "")
            .append(Integer.toHexString(getWidth())).append(""
"");
        buffer.append(""    .height          = "")
            .append(Integer.toHexString(getHeight())).append(""
"");
        buffer.append(""    .options         = "")
            .append(Integer.toHexString(getOptions())).append(""
"");
        buffer.append(""        .hidden      = "").append(getHidden())
            .append(""
"");
        buffer.append(""        .iconic      = "").append(getIconic())
            .append(""
"");
        buffer.append(""        .hscroll     = "")
            .append(getDisplayHorizontalScrollbar()).append(""
"");
        buffer.append(""        .vscroll     = "")
            .append(getDisplayVerticalScrollbar()).append(""
"");
        buffer.append(""        .tabs        = "").append(getDisplayTabs())
            .append(""
"");
        buffer.append(""    .selectedtab     = "")
            .append(Integer.toHexString(getSelectedTab())).append(""
"");
        buffer.append(""    .displayedtab    = "")
            .append(Integer.toHexString(getDisplayedTab())).append(""
"");
        buffer.append(""    .numselectedtabs = "")
            .append(Integer.toHexString(getNumSelectedTabs())).append(""
"");
        buffer.append(""    .tabwidthratio   = "")
            .append(Integer.toHexString(getTabWidthRatio())).append(""
"");
        buffer.append(""[/WINDOW1]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x12));   
        LittleEndian.putShort(data, 4 + offset, getHorizontalHold());
        LittleEndian.putShort(data, 6 + offset, getVerticalHold());
        LittleEndian.putShort(data, 8 + offset, getWidth());
        LittleEndian.putShort(data, 10 + offset, getHeight());
        LittleEndian.putShort(data, 12 + offset, getOptions());
        LittleEndian.putShort(data, 14 + offset, getSelectedTab());
        LittleEndian.putShort(data, 16 + offset, getDisplayedTab());
        LittleEndian.putShort(data, 18 + offset, getNumSelectedTabs());
        LittleEndian.putShort(data, 20 + offset, getTabWidthRatio());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 22;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.ColumnInfoRecord,26,2,0,6,41,217,2,4,23,0.864,341,0.9,3,0.333333333,0.352,1,6,11.73076923,2,0.8846,1,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.BitField;



public class ColumnInfoRecord
    extends Record
{
    public static final short     sid = 0x7d;
    private short                 field_1_first_col;
    private short                 field_2_last_col;
    private short                 field_3_col_width;
    private short                 field_4_xf_index;
    private short                 field_5_options;
    static final private BitField hidden    = new BitField(0x01);
    static final private BitField outlevel  = new BitField(0x0700);
    static final private BitField collapsed = new BitField(0x1000);
    private short                 field_6_reserved;

    public ColumnInfoRecord()
    {
    }

    

    public ColumnInfoRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ColumnInfoRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data);
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_first_col = LittleEndian.getShort(data, 0 + offset);
        field_2_last_col  = LittleEndian.getShort(data, 2 + offset);
        field_3_col_width = LittleEndian.getShort(data, 4 + offset);
        field_4_xf_index  = LittleEndian.getShort(data, 6 + offset);
        field_5_options   = LittleEndian.getShort(data, 8 + offset);
        field_6_reserved  = data[ 10 + offset ];
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A COLINFO RECORD!!"");
        }
    }

    

    public void setFirstColumn(short fc)
    {
        field_1_first_col = fc;
    }

    

    public void setLastColumn(short lc)
    {
        field_2_last_col = lc;
    }

    

    public void setColumnWidth(short cw)
    {
        field_3_col_width = cw;
    }

    

    public void setXFIndex(short xfi)
    {
        field_4_xf_index = xfi;
    }

    

    public void setOptions(short options)
    {
        field_5_options = options;
    }

    

    

    public void setHidden(boolean ishidden)
    {
        field_5_options = hidden.setShortBoolean(field_5_options, ishidden);
    }

    

    public void setOutlineLevel(short olevel)
    {
        field_5_options = outlevel.setShortValue(field_5_options, olevel);
    }

    

    public void setCollapsed(boolean iscollapsed)
    {
        field_5_options = collapsed.setShortBoolean(field_5_options,
                                                    iscollapsed);
    }

    

    

    public short getFirstColumn()
    {
        return field_1_first_col;
    }

    

    public short getLastColumn()
    {
        return field_2_last_col;
    }

    

    public short getColumnWidth()
    {
        return field_3_col_width;
    }

    

    public short getXFIndex()
    {
        return field_4_xf_index;
    }

    

    public short getOptions()
    {
        return field_5_options;
    }

    

    

    public boolean getHidden()
    {
        return hidden.isSet(field_5_options);
    }

    

    public short getOutlineLevel()
    {
        return outlevel.getShortValue(field_5_options);
    }

    

    public boolean getCollapsed()
    {
        return collapsed.isSet(field_5_options);
    }

    
    public short getSid()
    {
        return sid;
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 12);
        LittleEndian.putShort(data, 4 + offset, getFirstColumn());
        LittleEndian.putShort(data, 6 + offset, getLastColumn());
        LittleEndian.putShort(data, 8 + offset, getColumnWidth());
        LittleEndian.putShort(data, 10 + offset, getXFIndex());
        LittleEndian.putShort(data, 12 + offset, getOptions());
        LittleEndian.putShort(data, 14 + offset,
                              ( short ) 0x0);   
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 16;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[COLINFO]
"");
        buffer.append(""colfirst       = "").append(getFirstColumn())
            .append(""
"");
        buffer.append(""collast        = "").append(getLastColumn())
            .append(""
"");
        buffer.append(""colwidth       = "").append(getColumnWidth())
            .append(""
"");
        buffer.append(""xfindex        = "").append(getXFIndex()).append(""
"");
        buffer.append(""options        = "").append(getOptions()).append(""
"");
        buffer.append(""  hidden       = "").append(getHidden()).append(""
"");
        buffer.append(""  olevel       = "").append(getOutlineLevel())
            .append(""
"");
        buffer.append(""  collapsed    = "").append(getCollapsed())
            .append(""
"");
        buffer.append(""[/COLINFO]
"");
        return buffer.toString();
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.EntryNode,10,1,2,6,14,19,3,4,6,0.611111111,71,1.0,2,0.0,0.325,0,0,5.9,3,1.3,0,"


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.property.Property;



public abstract class EntryNode
    implements Entry
{

    
    private Property      _property;

    
    private DirectoryNode _parent;

    

    protected EntryNode(final Property property, final DirectoryNode parent)
    {
        _property = property;
        _parent   = parent;
    }

    

    protected Property getProperty()
    {
        return _property;
    }

    

    protected boolean isRoot()
    {

        
        return (_parent == null);
    }

    

    protected abstract boolean isDeleteOK();

    

    

    public String getName()
    {
        return _property.getName();
    }

    

    public boolean isDirectoryEntry()
    {
        return false;
    }

    

    public boolean isDocumentEntry()
    {
        return false;
    }

    

    public DirectoryEntry getParent()
    {
        return _parent;
    }

    

    public boolean delete()
    {
        boolean rval = false;

        if ((!isRoot()) && isDeleteOK())
        {
            rval = _parent.deleteEntry(this);
        }
        return rval;
    }

    

    public boolean renameTo(final String newName)
    {
        boolean rval = false;

        if (!isRoot())
        {
            rval = _parent.changeName(getName(), newName);
        }
        return rval;
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.OperationPtg,3,1,0,11,3,3,10,1,3,1.5,6,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,2,"



package org.apache.poi.hssf.record.formula;



public interface OperationPtg
{
    public final static int TYPE_UNARY    = 0;
    public final static int TYPE_BINARY   = 1;
    public final static int TYPE_FUNCTION = 2;

    public int getType();

    public int getNumberOfOperands();

    public String toFormulaString(Ptg [] operands);
}
"
poi,1.5,org.apache.poi.util.LongField,11,1,0,5,21,9,2,3,11,0.25,92,1.0,0,0.0,0.454545455,0,0,7.181818182,1,0.6364,0,"


package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class LongField
    implements FixedField
{
    private long      _value;
    private final int _offset;

    

    public LongField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(""Illegal offset: ""
                                                     + offset);
        }
        _offset = offset;
    }

    

    public LongField(final int offset, final long value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public LongField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public LongField(final int offset, final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public long get()
    {
        return _value;
    }

    

    public void set(final long value)
    {
        _value = value;
    }

    

    public void set(final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getLong(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readLong(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putLong(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.FontBasisRecord,19,2,0,5,30,119,1,4,17,0.824074074,281,0.833333333,0,0.407407407,0.460526316,1,6,13.47368421,2,0.8947,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class FontBasisRecord
    extends Record
{
    public final static short      sid                             = 0x1060;
    private  short      field_1_xBasis;
    private  short      field_2_yBasis;
    private  short      field_3_heightBasis;
    private  short      field_4_scale;
    private  short      field_5_indexToFontTable;


    public FontBasisRecord()
    {

    }

    

    public FontBasisRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FontBasisRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a FontBasis record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_xBasis                  = LittleEndian.getShort(data, 0x0 + offset);
        field_2_yBasis                  = LittleEndian.getShort(data, 0x2 + offset);
        field_3_heightBasis             = LittleEndian.getShort(data, 0x4 + offset);
        field_4_scale                   = LittleEndian.getShort(data, 0x6 + offset);
        field_5_indexToFontTable        = LittleEndian.getShort(data, 0x8 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FontBasis]
"");

        buffer.append(""    .xBasis               = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getXBasis()))
            .append("" ("").append(getXBasis()).append("" )
"");

        buffer.append(""    .yBasis               = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getYBasis()))
            .append("" ("").append(getYBasis()).append("" )
"");

        buffer.append(""    .heightBasis          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getHeightBasis()))
            .append("" ("").append(getHeightBasis()).append("" )
"");

        buffer.append(""    .scale                = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getScale()))
            .append("" ("").append(getScale()).append("" )
"");

        buffer.append(""    .indexToFontTable     = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getIndexToFontTable()))
            .append("" ("").append(getIndexToFontTable()).append("" )
"");

        buffer.append(""[/FontBasis]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_xBasis);
        LittleEndian.putShort(data, 6 + offset, field_2_yBasis);
        LittleEndian.putShort(data, 8 + offset, field_3_heightBasis);
        LittleEndian.putShort(data, 10 + offset, field_4_scale);
        LittleEndian.putShort(data, 12 + offset, field_5_indexToFontTable);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getXBasis()
    {
        return field_1_xBasis;
    }

    
    public void setXBasis(short field_1_xBasis)
    {
        this.field_1_xBasis = field_1_xBasis;
    }

    
    public short getYBasis()
    {
        return field_2_yBasis;
    }

    
    public void setYBasis(short field_2_yBasis)
    {
        this.field_2_yBasis = field_2_yBasis;
    }

    
    public short getHeightBasis()
    {
        return field_3_heightBasis;
    }

    
    public void setHeightBasis(short field_3_heightBasis)
    {
        this.field_3_heightBasis = field_3_heightBasis;
    }

    
    public short getScale()
    {
        return field_4_scale;
    }

    
    public void setScale(short field_4_scale)
    {
        this.field_4_scale = field_4_scale;
    }

    
    public short getIndexToFontTable()
    {
        return field_5_indexToFontTable;
    }

    
    public void setIndexToFontTable(short field_5_indexToFontTable)
    {
        this.field_5_indexToFontTable = field_5_indexToFontTable;
    }


}  




"
poi,1.5,org.apache.poi.util.FixedField,4,1,0,5,4,6,4,1,4,2.0,4,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"


package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public interface FixedField
{

    

    public void readFromBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public void readFromStream(InputStream stream)
        throws IOException, BufferUnderrunException;

    

    public void writeToBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public String toString();
}   

"
poi,1.5,org.apache.poi.hssf.record.BOFRecord,21,2,0,7,34,174,4,3,19,0.961764706,285,0.352941176,0,0.379310345,0.452380952,1,6,11.76190476,2,0.9048,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class BOFRecord
    extends Record
{

    

    public final static short sid = 0x809;
    private short             field_1_version;
    private short             field_2_type;
    private short             field_3_build;
    private short             field_4_year;
    private int               field_5_history;
    private int               field_6_rversion;

    

    public final static short VERSION             = 0x06;

    

    public final static short BUILD               = 0x10d3;

    

    public final static short BUILD_YEAR          = 0x07CC;   

    

    public final static short HISTORY_MASK        = 0x41;
    public final static short TYPE_WORKBOOK       = 0x05;
    public final static short TYPE_VB_MODULE      = 0x06;
    public final static short TYPE_WORKSHEET      = 0x10;
    public final static short TYPE_CHART          = 0x20;
    public final static short TYPE_EXCEL_4_MACRO  = 0x40;
    public final static short TYPE_WORKSPACE_FILE = 0x100;

    

    public BOFRecord()
    {
    }

    

    public BOFRecord(short id, short size, byte [] data)
    {
        super(id, size, data);

        
    }

    

    public BOFRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);

        
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A BOF RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_version  = LittleEndian.getShort(data, 0 + offset);
        field_2_type     = LittleEndian.getShort(data, 2 + offset);
        field_3_build    = LittleEndian.getShort(data, 4 + offset);
        field_4_year     = LittleEndian.getShort(data, 6 + offset);
        field_5_history  = LittleEndian.getInt(data, 8 + offset);
        field_6_rversion = LittleEndian.getInt(data, 12 + offset);
    }

    

    public void setVersion(short version)
    {
        field_1_version = version;
    }

    

    public void setType(short type)
    {
        field_2_type = type;
    }

    

    public void setBuild(short build)
    {
        field_3_build = build;
    }

    

    public void setBuildYear(short year)
    {
        field_4_year = year;
    }

    

    public void setHistoryBitMask(int bitmask)
    {
        field_5_history = bitmask;
    }

    

    public void setRequiredVersion(int version)
    {
        field_6_rversion = version;
    }

    

    public short getVersion()
    {
        return field_1_version;
    }

    

    public short getType()
    {
        return field_2_type;
    }

    

    public short getBuild()
    {
        return field_3_build;
    }

    

    public short getBuildYear()
    {
        return field_4_year;
    }

    

    public int getHistoryBitMask()
    {
        return field_5_history;
    }

    

    public int getRequiredVersion()
    {
        return field_6_rversion;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BOF RECORD]
"");
        buffer.append(""    .version         = "")
            .append(Integer.toHexString(getVersion())).append(""
"");
        buffer.append(""    .type            = "")
            .append(Integer.toHexString(getType())).append(""
"");
        buffer.append(""    .build           = "")
            .append(Integer.toHexString(getBuild())).append(""
"");
        buffer.append(""    .buildyear       = "").append(getBuildYear())
            .append(""
"");
        buffer.append(""    .history         = "")
            .append(Integer.toHexString(getHistoryBitMask())).append(""
"");
        buffer.append(""    .requiredversion = "")
            .append(Integer.toHexString(getRequiredVersion())).append(""
"");
        buffer.append(""[/BOF RECORD]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x10));   
        LittleEndian.putShort(data, 4 + offset, getVersion());
        LittleEndian.putShort(data, 6 + offset, getType());
        LittleEndian.putShort(data, 8 + offset, getBuild());
        LittleEndian.putShort(data, 10 + offset, getBuildYear());
        LittleEndian.putInt(data, 12 + offset, getHistoryBitMask());
        LittleEndian.putInt(data, 16 + offset, getRequiredVersion());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 20;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.ProtectRecord,11,2,0,5,21,49,2,3,9,0.85,112,0.5,0,0.578947368,0.418181818,1,6,9.0,2,0.9091,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class ProtectRecord
    extends Record
{
    public final static short sid = 0x12;
    private short             field_1_protect;

    public ProtectRecord()
    {
    }

    

    public ProtectRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ProtectRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PROTECT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_protect = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setProtect(boolean protect)
    {
        if (protect)
        {
            field_1_protect = 1;
        }
        else
        {
            field_1_protect = 0;
        }
    }

    

    public short getProtect()
    {
        return field_1_protect;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PROTECT]
"");
        buffer.append(""    .rowheight      = "")
            .append(Integer.toHexString(getProtect())).append(""
"");
        buffer.append(""[/PROTECT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getProtect());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.ByteField,11,1,0,4,15,21,1,3,11,0.533333333,90,1.0,0,0.0,0.454545455,0,0,6.909090909,1,0.6364,0,"


package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class ByteField
    implements FixedField
{
    private static final byte _default_value = 0;
    private byte              _value;
    private final int         _offset;

    

    public ByteField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, _default_value);
    }

    

    public ByteField(final int offset, final byte value)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(
                ""offset cannot be negative"");
        }
        _offset = offset;
        set(value);
    }

    

    public ByteField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ByteField(final int offset, final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, value);
        writeToBytes(data);
    }

    

    public byte get()
    {
        return _value;
    }

    

    public void set(final byte value)
    {
        _value = value;
    }

    

    public void set(final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        set(value);
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = data[ _offset ];
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value =
            (LittleEndian.readFromStream(stream,
                                         LittleEndianConsts.BYTE_SIZE))[ 0 ];
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        data[ _offset ] = _value;
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.ProtectionRev4Record,11,2,0,5,21,49,2,3,9,0.85,112,0.5,0,0.578947368,0.418181818,1,6,9.0,2,0.9091,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class ProtectionRev4Record
    extends Record
{
    public final static short sid = 0x1af;
    private short             field_1_protect;

    public ProtectionRev4Record()
    {
    }

    

    public ProtectionRev4Record(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ProtectionRev4Record(short id, short size, byte [] data,
                                int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PROTECTION REV 4 RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_protect = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setProtect(boolean protect)
    {
        if (protect)
        {
            field_1_protect = 1;
        }
        else
        {
            field_1_protect = 0;
        }
    }

    

    public short getProtect()
    {
        return field_1_protect;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PROT4REV]
"");
        buffer.append(""    .rowheight      = "")
            .append(Integer.toHexString(getProtect())).append(""
"");
        buffer.append(""[/PROT4REV]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getProtect());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hpsf.wellknown.PropertyIDMap,6,3,0,1,15,15,1,0,6,1.177142857,275,0.057142857,2,0.915254237,0.3,1,2,39.0,2,1.1667,3,"

package org.apache.poi.hpsf.wellknown;

import java.util.*;


public class PropertyIDMap extends HashMap
{

    
    public static final int PID_TITLE = 2;
    public static final int PID_SUBJECT = 3;
    public static final int PID_AUTHOR = 4;
    public static final int PID_KEYWORDS = 5;
    public static final int PID_COMMENTS = 6;
    public static final int PID_TEMPLATE = 7;
    public static final int PID_LASTAUTHOR = 8;
    public static final int PID_REVNUMBER = 9;
    public static final int PID_EDITTIME = 10;
    public static final int PID_LASTPRINTED = 11;
    public static final int PID_CREATE_DTM = 12;
    public static final int PID_LASTSAVE_DTM = 13;
    public static final int PID_PAGECOUNT = 14;
    public static final int PID_WORDCOUNT = 15;
    public static final int PID_CHARCOUNT = 16;
    public static final int PID_THUMBNAIL = 17;
    public static final int PID_APPNAME = 18;
    public static final int PID_SECURITY = 19;

    
    public static final int PID_CATEGORY = 2;
    public static final int PID_PRESFORMAT = 3;
    public static final int PID_BYTECOUNT = 4;
    public static final int PID_LINECOUNT = 5;
    public static final int PID_PARCOUNT = 6;
    public static final int PID_SLIDECOUNT = 7;
    public static final int PID_NOTECOUNT = 8;
    public static final int PID_HIDDENCOUNT = 9;
    public static final int PID_MMCLIPCOUNT = 10;
    public static final int PID_SCALE = 11;
    public static final int PID_HEADINGPAIR = 12;
    public static final int PID_DOCPARTS = 13;
    public static final int PID_MANAGER = 14;
    public static final int PID_COMPANY = 15;
    public static final int PID_LINKSDIRTY = 16;

    private static PropertyIDMap summaryInformationProperties;
    private static PropertyIDMap documentSummaryInformationProperties;



    public PropertyIDMap(int initialCapacity, float loadFactor)
    {
	super(initialCapacity, loadFactor);
    }



    
    public Object put(int id, String idString)
    {
	return put(new Integer(id), idString);
    }



    
    public Object get(int id)
    {
	return get(new Integer(id));
    }



    
    public static PropertyIDMap getSummaryInformationProperties()
    {
	if (summaryInformationProperties == null)
	{
	    PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);
	    m.put(PID_TITLE, ""PID_TITLE"");
	    m.put(PID_SUBJECT, ""PID_SUBJECT"");
	    m.put(PID_AUTHOR, ""PID_AUTHOR"");
	    m.put(PID_KEYWORDS, ""PID_KEYWORDS"");
	    m.put(PID_COMMENTS, ""PID_COMMENTS"");
	    m.put(PID_TEMPLATE, ""PID_TEMPLATE"");
	    m.put(PID_LASTAUTHOR, ""PID_LASTAUTHOR"");
	    m.put(PID_REVNUMBER, ""PID_REVNUMBER"");
	    m.put(PID_EDITTIME, ""PID_EDITTIME"");
	    m.put(PID_LASTPRINTED, ""PID_LASTPRINTED"");
	    m.put(PID_CREATE_DTM, ""PID_CREATE_DTM"");
	    m.put(PID_LASTSAVE_DTM, ""PID_LASTSAVE_DTM"");
	    m.put(PID_PAGECOUNT, ""PID_PAGECOUNT"");
	    m.put(PID_WORDCOUNT, ""PID_WORDCOUNT"");
	    m.put(PID_CHARCOUNT, ""PID_CHARCOUNT"");
	    m.put(PID_THUMBNAIL, ""PID_THUMBNAIL"");
	    m.put(PID_APPNAME, ""PID_APPNAME"");
	    m.put(PID_SECURITY, ""PID_SECURITY"");
	    summaryInformationProperties = m;
	}
	return summaryInformationProperties;
    }



    
    public static PropertyIDMap getDocumentSummaryInformationProperties()
    {
	if (documentSummaryInformationProperties == null)
	{
	    PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);
	    m.put(PID_CATEGORY, ""PID_CATEGORY"");
	    m.put(PID_PRESFORMAT, ""PID_PRESFORMAT"");
	    m.put(PID_BYTECOUNT, ""PID_BYTECOUNT"");
	    m.put(PID_LINECOUNT, ""PID_LINECOUNT"");
	    m.put(PID_PARCOUNT, ""PID_PARCOUNT"");
	    m.put(PID_SLIDECOUNT, ""PID_SLIDECOUNT"");
	    m.put(PID_NOTECOUNT, ""PID_NOTECOUNT"");
	    m.put(PID_HIDDENCOUNT, ""PID_HIDDENCOUNT"");
	    m.put(PID_MMCLIPCOUNT, ""PID_MMCLIPCOUNT"");
	    m.put(PID_SCALE, ""PID_SCALE"");
	    m.put(PID_HEADINGPAIR, ""PID_HEADINGPAIR"");
	    m.put(PID_DOCPARTS, ""PID_DOCPARTS"");
	    m.put(PID_MANAGER, ""PID_MANAGER"");
	    m.put(PID_COMPANY, ""PID_COMPANY"");
	    m.put(PID_LINKSDIRTY, ""PID_LINKSDIRTY"");
	    documentSummaryInformationProperties = m;
	}
	return documentSummaryInformationProperties;

    }



    public static void main(String args[])
    {
	PropertyIDMap s1 = getSummaryInformationProperties();
	PropertyIDMap s2 = getDocumentSummaryInformationProperties();
	System.out.println(""s1: "" + s1);
	System.out.println(""s2: "" + s2);
    }

}
"
poi,1.5,org.apache.poi.poifs.storage.BigBlock,4,1,4,5,6,6,4,1,1,2.0,15,0.0,0,0.0,0.666666667,0,0,2.75,1,0.75,0,"


package org.apache.poi.poifs.storage;



import java.io.IOException;
import java.io.OutputStream;

abstract class BigBlock
    implements BlockWritable
{

    

    protected void doWriteData(final OutputStream stream, final byte [] data)
        throws IOException
    {
        stream.write(data);
    }

    

    abstract void writeData(final OutputStream stream)
        throws IOException;

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        writeData(stream);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.TabIdRecord,11,2,0,5,25,43,2,3,9,0.8,182,0.0,0,0.578947368,0.418181818,1,6,15.36363636,2,1.0909,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class TabIdRecord
    extends Record
{
    public final static short sid = 0x13d;
    public short[]            field_1_tabids;

    public TabIdRecord()
    {
    }

    

    public TabIdRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public TabIdRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A TABID RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_tabids = new short[ size / 2 ];
        for (int k = 0; k < field_1_tabids.length; k++)
        {
            field_1_tabids[ k ] = LittleEndian.getShort(data,
                                                        (k * 2) + offset);
        }
    }

    

    public void setTabIdArray(short [] array)
    {
        field_1_tabids = array;
    }

    

    public short [] getTabIdArray()
    {
        return field_1_tabids;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[TABID]
"");
        buffer.append(""    .elements        = "").append(field_1_tabids.length)
            .append(""
"");
        for (int k = 0; k < field_1_tabids.length; k++)
        {
            buffer.append(""    .element_"" + k + ""       = "")
                .append(field_1_tabids[ k ]).append(""
"");
        }
        buffer.append(""[/TABID]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        short[] tabids     = getTabIdArray();
        short   length     = ( short ) (tabids.length * 2);
        int     byteoffset = 4;

        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) length));   

        
        for (int k = 0; k < (length / 2); k++)
        {
            LittleEndian.putShort(data, byteoffset + offset, tabids[ k ]);
            byteoffset += 2;
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 4 + (getTabIdArray().length * 2);
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hpsf.littleendian.Word,2,2,0,4,3,1,3,1,2,2.0,10,0.0,0,0.75,0.666666667,1,1,3.5,1,0.5,0,"

package org.apache.poi.hpsf.littleendian;


public class Word extends LittleEndian
{

    
    public Word(final byte[] src, final int offset)
    {
        super(src, offset);
    }


    public final static int LENGTH = 2;

    public int length()
    {
        return LENGTH;
    }

}
"
poi,1.5,org.apache.poi.poifs.storage.BlockWritable,1,1,0,9,1,0,9,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;



public interface BlockWritable
{

    

    public void writeBlocks(final OutputStream stream)
        throws IOException;
}   

"
poi,1.5,org.apache.poi.hssf.record.EOFRecord,9,2,0,6,17,36,3,3,7,1.125,72,0.0,0,0.647058824,0.555555556,1,6,6.888888889,2,0.7778,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class EOFRecord
    extends Record
{
    public final static short sid = 0x0A;

    public EOFRecord()
    {
    }

    

    public EOFRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public EOFRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An EOF RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EOF]
"");
        buffer.append(""[/EOF]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0));   
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 4;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.property.PropertyFactory,2,1,0,5,10,1,1,4,0,2.0,82,0.0,0,0.0,0.5,0,0,40.0,1,0.5,0,"


package org.apache.poi.poifs.property;

import java.io.IOException;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.storage.ListManagedBlock;



class PropertyFactory
{

    
    private PropertyFactory()
    {
    }

    

    static List convertToProperties(ListManagedBlock [] blocks)
        throws IOException
    {
        List properties = new ArrayList();

        for (int j = 0; j < blocks.length; j++)
        {
            byte[] data           = blocks[ j ].getData();
            int    property_count = data.length
                                    / POIFSConstants.PROPERTY_SIZE;
            int    offset         = 0;

            for (int k = 0; k < property_count; k++)
            {
                switch (data[ offset + PropertyConstants.PROPERTY_TYPE_OFFSET ])
                {

                    case PropertyConstants.DIRECTORY_TYPE :
                        properties
                            .add(new DirectoryProperty(properties.size(),
                                                       data, offset));
                        break;

                    case PropertyConstants.DOCUMENT_TYPE :
                        properties.add(new DocumentProperty(properties.size(),
                                                            data, offset));
                        break;

                    case PropertyConstants.ROOT_TYPE :
                        properties.add(new RootProperty(properties.size(),
                                                        data, offset));
                        break;

                    default :
                        properties.add(null);
                        break;
                }
                offset += POIFSConstants.PROPERTY_SIZE;
            }
        }
        return properties;
    }
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.ValueVariableFunctionPtg,9,2,0,4,13,30,1,4,9,0.90625,106,0.375,4,0.5,0.388888889,1,2,9.888888889,1,0.7778,1,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;



public class ValueVariableFunctionPtg
    extends Ptg
    implements OperationPtg
{
    public final static short  sid  = 0x42;
    private final static short SIZE = 4;
    private byte               field_1_byte_1;
    BitField                   numArgs = new BitField(0x7f);
    BitField                   prompt  = new BitField(0x80);
    private short              field_2_bytes;
    BitField                   functionIndex = new BitField(0x7FFF);
    BitField                   command       = new BitField(0x8000);

    

    public ValueVariableFunctionPtg()
    {
    }

    public ValueVariableFunctionPtg(byte [] data, int offset)
    {
        offset++;
        field_1_byte_1 = data[ offset + 0 ];
        field_2_bytes  = LittleEndian.getShort(data, offset + 1);
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return SIZE;
    }

    public short getNumArgs()
    {
        return numArgs.getShortValue(field_1_byte_1);
    }

    public int getNumberOfOperands()
    {
        return getNumArgs();
    }

    public int getType()
    {
        return -1;
    }

    public String toFormulaString()
    {
        return ""NO IDEA YET VALUE VARIABLE"";
    }

    public String toFormulaString(Ptg [] operands)
    {
        return toFormulaString();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.LegendRecord,35,2,0,5,55,217,0,5,33,0.923273657,642,0.565217391,6,0.255813953,0.280952381,1,6,16.68571429,2,0.9429,2,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class LegendRecord
    extends Record
{
    public final static short      sid                             = 0x1015;
    private  int        field_1_xPosition;
    private  int        field_2_yPosition;
    private  int        field_3_xSize;
    private  int        field_4_ySize;
    private  byte       field_5_type;
    public final static byte        TYPE_BOTTOM                    = 0;
    public final static byte        TYPE_CORNER                    = 1;
    public final static byte        TYPE_TOP                       = 2;
    public final static byte        TYPE_RIGHT                     = 3;
    public final static byte        TYPE_LEFT                      = 4;
    public final static byte        TYPE_NOT_DOCKED                = 7;
    private  byte       field_6_spacing;
    public final static byte        SPACING_CLOSE                  = 0;
    public final static byte        SPACING_MEDIUM                 = 1;
    public final static byte        SPACING_OPEN                   = 2;
    private  short      field_7_options;
    private BitField   autoPosition                               = new BitField(0x1);
    private BitField   autoSeries                                 = new BitField(0x2);
    private BitField   autoPosX                                   = new BitField(0x4);
    private BitField   autoPosY                                   = new BitField(0x8);
    private BitField   vert                                       = new BitField(0x10);
    private BitField   containsDataTable                          = new BitField(0x20);


    public LegendRecord()
    {

    }

    

    public LegendRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public LegendRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Legend record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_xPosition               = LittleEndian.getInt(data, 0x0 + offset);
        field_2_yPosition               = LittleEndian.getInt(data, 0x4 + offset);
        field_3_xSize                   = LittleEndian.getInt(data, 0x8 + offset);
        field_4_ySize                   = LittleEndian.getInt(data, 0xc + offset);
        field_5_type                    = data[ 0x10 + offset ];
        field_6_spacing                 = data[ 0x11 + offset ];
        field_7_options                 = LittleEndian.getShort(data, 0x12 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Legend]
"");

        buffer.append(""    .xPosition            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getXPosition()))
            .append("" ("").append(getXPosition()).append("" )
"");

        buffer.append(""    .yPosition            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getYPosition()))
            .append("" ("").append(getYPosition()).append("" )
"");

        buffer.append(""    .xSize                = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getXSize()))
            .append("" ("").append(getXSize()).append("" )
"");

        buffer.append(""    .ySize                = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getYSize()))
            .append("" ("").append(getYSize()).append("" )
"");

        buffer.append(""    .type                 = "")
            .append(""0x"")
            .append(HexDump.toHex((byte)getType()))
            .append("" ("").append(getType()).append("" )
"");

        buffer.append(""    .spacing              = "")
            .append(""0x"")
            .append(HexDump.toHex((byte)getSpacing()))
            .append("" ("").append(getSpacing()).append("" )
"");

        buffer.append(""    .options              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getOptions()))
            .append("" ("").append(getOptions()).append("" )
"");
        buffer.append(""         .autoPosition             = "").append(isAutoPosition        ()).append('
');
        buffer.append(""         .autoSeries               = "").append(isAutoSeries          ()).append('
');
        buffer.append(""         .autoPosX                 = "").append(isAutoPosX            ()).append('
');
        buffer.append(""         .autoPosY                 = "").append(isAutoPosY            ()).append('
');
        buffer.append(""         .vert                     = "").append(isVert                ()).append('
');
        buffer.append(""         .containsDataTable        = "").append(isContainsDataTable   ()).append('
');

        buffer.append(""[/Legend]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putInt(data, 4 + offset, field_1_xPosition);
        LittleEndian.putInt(data, 8 + offset, field_2_yPosition);
        LittleEndian.putInt(data, 12 + offset, field_3_xSize);
        LittleEndian.putInt(data, 16 + offset, field_4_ySize);
        data[ 20 + offset ] = field_5_type;
        data[ 21 + offset ] = field_6_spacing;
        LittleEndian.putShort(data, 22 + offset, field_7_options);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 4 + 4 + 4 + 4 + 1 + 1 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public int getXPosition()
    {
        return field_1_xPosition;
    }

    
    public void setXPosition(int field_1_xPosition)
    {
        this.field_1_xPosition = field_1_xPosition;
    }

    
    public int getYPosition()
    {
        return field_2_yPosition;
    }

    
    public void setYPosition(int field_2_yPosition)
    {
        this.field_2_yPosition = field_2_yPosition;
    }

    
    public int getXSize()
    {
        return field_3_xSize;
    }

    
    public void setXSize(int field_3_xSize)
    {
        this.field_3_xSize = field_3_xSize;
    }

    
    public int getYSize()
    {
        return field_4_ySize;
    }

    
    public void setYSize(int field_4_ySize)
    {
        this.field_4_ySize = field_4_ySize;
    }

    
    public byte getType()
    {
        return field_5_type;
    }

    
    public void setType(byte field_5_type)
    {
        this.field_5_type = field_5_type;
    }

    
    public byte getSpacing()
    {
        return field_6_spacing;
    }

    
    public void setSpacing(byte field_6_spacing)
    {
        this.field_6_spacing = field_6_spacing;
    }

    
    public short getOptions()
    {
        return field_7_options;
    }

    
    public void setOptions(short field_7_options)
    {
        this.field_7_options = field_7_options;
    }

    
    public void setAutoPosition(boolean value)
    {
        field_7_options = autoPosition.setShortBoolean(field_7_options, value);
    }

    
    public boolean isAutoPosition()
    {
        return autoPosition.isSet(field_7_options);
    }

    
    public void setAutoSeries(boolean value)
    {
        field_7_options = autoSeries.setShortBoolean(field_7_options, value);
    }

    
    public boolean isAutoSeries()
    {
        return autoSeries.isSet(field_7_options);
    }

    
    public void setAutoPosX(boolean value)
    {
        field_7_options = autoPosX.setShortBoolean(field_7_options, value);
    }

    
    public boolean isAutoPosX()
    {
        return autoPosX.isSet(field_7_options);
    }

    
    public void setAutoPosY(boolean value)
    {
        field_7_options = autoPosY.setShortBoolean(field_7_options, value);
    }

    
    public boolean isAutoPosY()
    {
        return autoPosY.isSet(field_7_options);
    }

    
    public void setVert(boolean value)
    {
        field_7_options = vert.setShortBoolean(field_7_options, value);
    }

    
    public boolean isVert()
    {
        return vert.isSet(field_7_options);
    }

    
    public void setContainsDataTable(boolean value)
    {
        field_7_options = containsDataTable.setShortBoolean(field_7_options, value);
    }

    
    public boolean isContainsDataTable()
    {
        return containsDataTable.isSet(field_7_options);
    }


}  




"
poi,1.5,org.apache.poi.util.IntegerField,11,1,0,7,17,9,4,3,11,0.25,85,1.0,0,0.0,0.522727273,0,0,6.545454545,1,0.6364,0,"


package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class IntegerField
    implements FixedField
{
    private int       _value;
    private final int _offset;

    

    public IntegerField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(""negative offset"");
        }
        _offset = offset;
    }

    

    public IntegerField(final int offset, final int value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public IntegerField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public IntegerField(final int offset, final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public int get()
    {
        return _value;
    }

    

    public void set(final int value)
    {
        _value = value;
    }

    

    public void set(final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getInt(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readInt(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putInt(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.SeriesListRecord,11,2,0,4,22,35,1,3,9,0.8,119,0.5,0,0.578947368,0.418181818,1,6,9.636363636,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class SeriesListRecord
    extends Record
{
    public final static short      sid                             = 0x1016;
    private  short[]    field_1_seriesNumbers;


    public SeriesListRecord()
    {

    }

    

    public SeriesListRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SeriesListRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a SeriesList record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_seriesNumbers           = LittleEndian.getShortArray(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SeriesList]
"");

        buffer.append(""    .seriesNumbers        = "")
            .append("" ("").append(getSeriesNumbers()).append("" )
"");

        buffer.append(""[/SeriesList]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShortArray(data, 4 + offset, field_1_seriesNumbers);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + field_1_seriesNumbers.length * 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short[] getSeriesNumbers()
    {
        return field_1_seriesNumbers;
    }

    
    public void setSeriesNumbers(short[] field_1_seriesNumbers)
    {
        this.field_1_seriesNumbers = field_1_seriesNumbers;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.formula.Ptg,8,1,15,21,29,28,21,13,8,2.0,166,0.0,0,0.0,0.458333333,0,0,19.75,15,2.625,11,"



package org.apache.poi.hssf.record.formula;

import java.util.List;
import java.util.ArrayList;



public abstract class Ptg
{

    
    
    public Ptg()
    {
    }
    
    
    
    
    

    public static Ptg createPtg(byte [] data, int offset)
    {
        byte id     = data[ offset + 0 ];
        Ptg  retval = null;

        System.out.println(""PTG = "" + Integer.toHexString(id) + "" ("" + id
                           + "")"");
        switch (id)
        {

            case AddPtg.sid :
                retval = new AddPtg(data, offset);
                break;

            case SubtractPtg.sid :
                retval = new SubtractPtg(data, offset);
                break;

            case IntPtg.sid :
                retval = new IntPtg(data, offset);
                break;

            case DividePtg.sid :
                retval = new DividePtg(data, offset);
                break;

            case MultiplyPtg.sid :
                retval = new MultiplyPtg(data, offset);
                break;

            case PowerPtg.sid :
                retval = new PowerPtg(data, offset);
                break;

            case AreaPtg.sid :
                retval = new AreaPtg(data, offset);
                break;

            case MemErrPtg.sid :
                retval = new MemErrPtg(data, offset);
                break;

            case AttrPtg.sid :
                retval = new AttrPtg(data, offset);
                break;

            case ValueReferencePtg.sid :
                retval = new ValueReferencePtg(data, offset);
                break;

    
      
        

            case ValueVariableFunctionPtg.sid :
                retval = new ValueVariableFunctionPtg(data, offset);
                break;

            case NamePtg.sid :
                retval = new NamePtg(data, offset);
                break;

            case ExpPtg.sid :
                retval = new ExpPtg(data, offset);
                break;

            default :

                
                throw new RuntimeException(""Unknown PTG = ""
                                           + Integer.toHexString(( int ) id)
                                           + "" ("" + ( int ) id + "")"");
        }
        return retval;
    }

    public abstract int getSize();

    public final byte [] getBytes()
    {
        int    size  = getSize();
        byte[] bytes = new byte[ size ];

        writeBytes(bytes, 0);
        return bytes;
    }

    public abstract void writeBytes(byte [] array, int offset);

    public abstract String toFormulaString();
    
    



    
    public int getPrecedence() {
        return 100;
    }
    
    public int getStringLength() {
        return 0;
    }
    
    
}
"
poi,1.5,org.apache.poi.hssf.record.formula.AddPtg,12,2,0,4,21,66,3,2,11,1.090909091,97,0.333333333,0,0.4375,0.333333333,1,2,6.833333333,5,1.0833,4,"



package org.apache.poi.hssf.record.formula;



public class AddPtg
    extends Ptg
    implements OperationPtg
{
    public final static int  SIZE = 1;
    public final static byte sid  = 0x03;
    
    private final static String ADD = ""+"";

    

    public AddPtg()
    {
    }

    public AddPtg(byte [] data, int offset)
    {

        
    }
    
    protected AddPtg(String formula, int offset) {
        
    }

    public void writeBytes(byte [] array, int offset)
    {
        array[ offset + 0 ] = sid;
    }

    public int getSize()
    {
        return SIZE;
    }

    public int getType()
    {
        return TYPE_BINARY;
    }

    public int getNumberOfOperands()
    {
        return 2;
    }

    public String toFormulaString()
    {
        return ""+"";
    }
    
    
    public static boolean isNextStringToken(String formula, int pos) {
        boolean retval = false;
        while (pos < formula.length() && Character.isWhitespace(formula.charAt(pos))) {
            pos++;
        }
        
        if (pos < formula.length()) {
            if (formula.charAt(pos) == ADD.toCharArray()[0]) {
                retval = true;
            }
        }
        return retval;
    }

    public String toFormulaString(Ptg [] operands)
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(operands[ 0 ].toFormulaString());
        buffer.append(""+"");
        buffer.append(operands[ 1 ].toFormulaString());
        return buffer.toString();
    }
    
    public int getPrecedence() {
        return 5;
    }
    
    public int getStringLength() {
        return 1;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.AxisUsedRecord,11,2,0,4,22,43,0,4,9,0.85,117,0.5,0,0.578947368,0.522727273,1,6,9.454545455,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class AxisUsedRecord
    extends Record
{
    public final static short      sid                             = 0x1046;
    private  short      field_1_numAxis;


    public AxisUsedRecord()
    {

    }

    

    public AxisUsedRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public AxisUsedRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a AxisUsed record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_numAxis                 = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[AxisUsed]
"");

        buffer.append(""    .numAxis              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getNumAxis()))
            .append("" ("").append(getNumAxis()).append("" )
"");

        buffer.append(""[/AxisUsed]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_numAxis);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getNumAxis()
    {
        return field_1_numAxis;
    }

    
    public void setNumAxis(short field_1_numAxis)
    {
        this.field_1_numAxis = field_1_numAxis;
    }


}  




"
poi,1.5,org.apache.poi.hpsf.SummaryInformation,19,3,0,4,30,171,1,3,19,2.0,126,0.0,0,0.581395349,0.526315789,0,0,5.631578947,1,0.9474,1,"

package org.apache.poi.hpsf;

import java.io.*;
import java.util.*;
import org.apache.poi.hpsf.wellknown.*;


public class SummaryInformation extends SpecialPropertySet
{

    
    public SummaryInformation(final PropertySet ps)
        throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isSummaryInformation())
            throw new UnexpectedPropertySetTypeException
                (""Not a "" + getClass().getName());
    }



    
    public String getTitle()
    {
        return (String) getProperty(PropertyIDMap.PID_TITLE);
    }



    
    public String getSubject()
    {
        return (String) getProperty(PropertyIDMap.PID_SUBJECT);
    }



    
    public String getAuthor()
    {
        return (String) getProperty(PropertyIDMap.PID_AUTHOR);
    }



    
    public String getKeywords()
    {
        return (String) getProperty(PropertyIDMap.PID_KEYWORDS);
    }



    
    public String getComments()
    {
        return (String) getProperty(PropertyIDMap.PID_COMMENTS);
    }



    
    public String getTemplate()
    {
        return (String) getProperty(PropertyIDMap.PID_TEMPLATE);
    }



    
    public String getLastAuthor()
    {
        return (String) getProperty(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public String getRevNumber()
    {
        return (String) getProperty(PropertyIDMap.PID_REVNUMBER);
    }



    
    public Date getEditTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_EDITTIME);
    }



    
    public Date getLastPrinted()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public Date getCreateDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public Date getLastSaveDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public int getPageCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public int getWordCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public int getCharCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public byte[] getThumbnail()
    {
        if (true)
            throw new UnsupportedOperationException(""FIXME"");
        return (byte[]) getProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public String getApplicationName()
    {
        return (String) getProperty(PropertyIDMap.PID_APPNAME);
    }



    
    public int getSecurity()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SECURITY);
    }

}
"
poi,1.5,org.apache.poi.hssf.record.MulRKRecord,15,2,0,7,33,87,2,5,12,0.871428571,230,0.8,0,0.47826087,0.516666667,1,5,14.0,2,1.0,0,"



package org.apache.poi.hssf.record;

import java.util.ArrayList;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.hssf.util.RKUtil;



public class MulRKRecord
    extends Record
{
    public final static short sid = 0xbd;
    private short             field_1_row;
    private short             field_2_first_col;
    private ArrayList         field_3_rks;
    private short             field_4_last_col;

    

    public MulRKRecord()
    {
    }

    

    public MulRKRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public MulRKRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    public short getRow()
    {
        return field_1_row;
    }

    

    public short getFirstColumn()
    {
        return field_2_first_col;
    }

    

    public short getLastColumn()
    {
        return field_4_last_col;
    }

    

    public int getNumColumns()
    {
        return field_4_last_col - field_2_first_col + 1;
    }

    

    public short getXFAt(int coffset)
    {
        return (( RkRec ) field_3_rks.get(coffset)).xf;
    }

    

    public double getRKNumberAt(int coffset)
    {
        return RKUtil.decodeNumber((( RkRec ) field_3_rks.get(coffset)).rk);
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row       = LittleEndian.getShort(data, 0 + offset);
        field_2_first_col = LittleEndian.getShort(data, 2 + offset);
        field_3_rks       = parseRKs(data, 4, offset, size);
        field_4_last_col  = LittleEndian.getShort(data,
                                                  (field_3_rks.size() * 6)
                                                  + 4 + offset);
    }

    private ArrayList parseRKs(byte [] data, int offset, int recoffset,
                               short size)
    {
        ArrayList retval = new ArrayList();

        for (; offset < size - 2; )
        {
            RkRec rec = new RkRec();

            rec.xf = LittleEndian.getShort(data, offset + recoffset);
            offset += 2;
            rec.rk = LittleEndian.getInt(data, offset + recoffset);
            offset += 4;
            retval.add(rec);
        }
        return retval;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[MULRK]
"");
        buffer.append(""firstcol  = "")
            .append(Integer.toHexString(getFirstColumn())).append(""
"");
        buffer.append("" lastcol  = "")
            .append(Integer.toHexString(getLastColumn())).append(""
"");
        for (int k = 0; k < getNumColumns(); k++)
        {
            buffer.append(""xf"").append(k).append(""        = "")
                .append(Integer.toHexString(getXFAt(k))).append(""
"");
            buffer.append(""rk"").append(k).append(""        = "")
                .append(getRKNumberAt(k)).append(""
"");
        }
        buffer.append(""[/MULRK]
"");
        return buffer.toString();
    }

    

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a MulRKRecord!"");
        }
    }

    public short getSid()
    {
        return this.sid;
    }

    public int serialize(int offset, byte [] data)
    {
        throw new RecordFormatException(
            ""Sorry, you can't serialize a MulRK in this release"");
    }
}

class RkRec
{
    public short xf;
    public int   rk;
}
"
poi,1.5,org.apache.poi.poifs.eventfilesystem.POIFSReaderListener,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.eventfilesystem;



public interface POIFSReaderListener
{

    

    public void processPOIFSReaderEvent(POIFSReaderEvent event);
}   

"
poi,1.5,org.apache.poi.hssf.record.ChartRecord,17,2,0,5,29,94,1,4,15,0.8125,240,0.8,0,0.44,0.470588235,1,6,12.82352941,2,0.8824,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class ChartRecord
    extends Record
{
    public final static short      sid                             = 0x1002;
    private  int        field_1_x;
    private  int        field_2_y;
    private  int        field_3_width;
    private  int        field_4_height;


    public ChartRecord()
    {

    }

    

    public ChartRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ChartRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Chart record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_x                       = LittleEndian.getInt(data, 0x0 + offset);
        field_2_y                       = LittleEndian.getInt(data, 0x4 + offset);
        field_3_width                   = LittleEndian.getInt(data, 0x8 + offset);
        field_4_height                  = LittleEndian.getInt(data, 0xc + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Chart]
"");

        buffer.append(""    .x                    = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getX()))
            .append("" ("").append(getX()).append("" )
"");

        buffer.append(""    .y                    = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getY()))
            .append("" ("").append(getY()).append("" )
"");

        buffer.append(""    .width                = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getWidth()))
            .append("" ("").append(getWidth()).append("" )
"");

        buffer.append(""    .height               = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getHeight()))
            .append("" ("").append(getHeight()).append("" )
"");

        buffer.append(""[/Chart]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putInt(data, 4 + offset, field_1_x);
        LittleEndian.putInt(data, 8 + offset, field_2_y);
        LittleEndian.putInt(data, 12 + offset, field_3_width);
        LittleEndian.putInt(data, 16 + offset, field_4_height);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 4 + 4 + 4 + 4;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public int getX()
    {
        return field_1_x;
    }

    
    public void setX(int field_1_x)
    {
        this.field_1_x = field_1_x;
    }

    
    public int getY()
    {
        return field_2_y;
    }

    
    public void setY(int field_2_y)
    {
        this.field_2_y = field_2_y;
    }

    
    public int getWidth()
    {
        return field_3_width;
    }

    
    public void setWidth(int field_3_width)
    {
        this.field_3_width = field_3_width;
    }

    
    public int getHeight()
    {
        return field_4_height;
    }

    
    public void setHeight(int field_4_height)
    {
        this.field_4_height = field_4_height;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.BoolErrRecord,28,2,0,6,42,312,2,4,26,0.796296296,434,0.833333333,0,0.305555556,0.21875,1,6,14.28571429,7,1.8571,2,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class BoolErrRecord
    extends Record
    implements CellValueRecordInterface, Comparable
{
    public final static short sid = 0x205;
    private short             field_1_row;
    private short             field_2_column;
    private short             field_3_xf_index;
    private byte              field_4_bBoolErr;
    private byte              field_5_fError;

    

    public BoolErrRecord()
    {
    }

    

    public BoolErrRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BoolErrRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row      = LittleEndian.getShort(data, 0 + offset);
        field_2_column   = LittleEndian.getShort(data, 2 + offset);
        field_3_xf_index = LittleEndian.getShort(data, 4 + offset);
        field_4_bBoolErr = data[ 6 + offset ];
        field_5_fError   = data[ 7 + offset ];
    }

    public void setRow(short row)
    {
        field_1_row = row;
    }

    public void setColumn(short col)
    {
        field_2_column = col;
    }

    

    public void setXFIndex(short xf)
    {
        field_3_xf_index = xf;
    }

    

    public void setValue(boolean value)
    {
        field_4_bBoolErr = value ? ( byte ) 1
                                 : ( byte ) 0;
        field_5_fError   = ( byte ) 0;
    }

    

    public void setValue(byte value)
    {
        field_4_bBoolErr = value;
        field_5_fError   = ( byte ) 1;
    }

    public short getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_column;
    }

    

    public short getXFIndex()
    {
        return field_3_xf_index;
    }

    

    public boolean getBooleanValue()
    {
        return (field_4_bBoolErr != 0);
    }

    

    public byte getErrorValue()
    {
        return field_4_bBoolErr;
    }

    

    public boolean isBoolean()
    {
        return (field_5_fError == ( byte ) 0);
    }

    

    public boolean isError()
    {
        return (field_5_fError != ( byte ) 0);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BOOLERR]
"");
        buffer.append(""    .row            = "")
            .append(Integer.toHexString(getRow())).append(""
"");
        buffer.append(""    .col            = "")
            .append(Integer.toHexString(getColumn())).append(""
"");
        buffer.append(""    .xfindex        = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        if (isBoolean())
        {
            buffer.append(""    .booleanValue   = "").append(getBooleanValue())
                .append(""
"");
        }
        else
        {
            buffer.append(""    .errorValue     = "").append(getErrorValue())
                .append(""
"");
        }
        buffer.append(""[/BOOLERR]
"");
        return buffer.toString();
    }

    

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 8);
        LittleEndian.putShort(data, 4 + offset, getRow());
        LittleEndian.putShort(data, 6 + offset, getColumn());
        LittleEndian.putShort(data, 8 + offset, getXFIndex());
        data[ 10 + offset ] = field_4_bBoolErr;
        data[ 11 + offset ] = field_5_fError;
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 12;
    }

    

    protected void validateSid(short id)
    {
        if (id != this.sid)
        {
            throw new RecordFormatException(""Not a valid BoolErrRecord"");
        }
    }

    public short getSid()
    {
        return this.sid;
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    public int compareTo(Object obj)
    {
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return 0;
        }
        if (this.getRow() < loc.getRow())
        {
            return -1;
        }
        if (this.getRow() > loc.getRow())
        {
            return 1;
        }
        if (this.getColumn() < loc.getColumn())
        {
            return -1;
        }
        if (this.getColumn() > loc.getColumn())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof CellValueRecordInterface))
        {
            return false;
        }
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.FrameRecord,17,2,0,6,33,40,1,5,15,0.830357143,250,0.571428571,2,0.44,0.376470588,1,6,13.29411765,2,0.8824,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class FrameRecord
    extends Record
{
    public final static short      sid                             = 0x1032;
    private  short      field_1_borderType;
    public final static short       BORDER_TYPE_REGULAR            = 0;
    public final static short       BORDER_TYPE_SHADOW             = 1;
    private  short      field_2_options;
    private BitField   autoSize                                   = new BitField(0x1);
    private BitField   autoPosition                               = new BitField(0x2);


    public FrameRecord()
    {

    }

    

    public FrameRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FrameRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Frame record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_borderType              = LittleEndian.getShort(data, 0x0 + offset);
        field_2_options                 = LittleEndian.getShort(data, 0x2 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Frame]
"");

        buffer.append(""    .borderType           = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getBorderType()))
            .append("" ("").append(getBorderType()).append("" )
"");

        buffer.append(""    .options              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getOptions()))
            .append("" ("").append(getOptions()).append("" )
"");
        buffer.append(""         .autoSize                 = "").append(isAutoSize            ()).append('
');
        buffer.append(""         .autoPosition             = "").append(isAutoPosition        ()).append('
');

        buffer.append(""[/Frame]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_borderType);
        LittleEndian.putShort(data, 6 + offset, field_2_options);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getBorderType()
    {
        return field_1_borderType;
    }

    
    public void setBorderType(short field_1_borderType)
    {
        this.field_1_borderType = field_1_borderType;
    }

    
    public short getOptions()
    {
        return field_2_options;
    }

    
    public void setOptions(short field_2_options)
    {
        this.field_2_options = field_2_options;
    }

    
    public void setAutoSize(boolean value)
    {
        field_2_options = autoSize.setShortBoolean(field_2_options, value);
    }

    
    public boolean isAutoSize()
    {
        return autoSize.isSet(field_2_options);
    }

    
    public void setAutoPosition(boolean value)
    {
        field_2_options = autoPosition.setShortBoolean(field_2_options, value);
    }

    
    public boolean isAutoPosition()
    {
        return autoPosition.isSet(field_2_options);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.GridsetRecord,11,2,0,5,21,43,2,3,9,0.85,117,0.0,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class GridsetRecord
    extends Record
{
    public final static short sid = 0x82;
    public short              field_1_gridset_flag;

    public GridsetRecord()
    {
    }

    

    public GridsetRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public GridsetRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A Gridset RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_gridset_flag = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setGridset(boolean gridset)
    {
        if (gridset == true)
        {
            field_1_gridset_flag = 1;
        }
        else
        {
            field_1_gridset_flag = 0;
        }
    }

    

    public boolean getGridset()
    {
        return (field_1_gridset_flag == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[GRIDSET]
"");
        buffer.append(""    .gridset        = "").append(getGridset())
            .append(""
"");
        buffer.append(""[/GRIDSET]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, field_1_gridset_flag);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.property.DirectoryProperty,8,2,1,11,37,0,7,5,6,0.357142857,278,1.0,0,0.823529412,0.375,1,1,33.5,6,1.625,0,"


package org.apache.poi.poifs.property;

import java.util.*;

import java.io.IOException;

import org.apache.poi.poifs.storage.SmallDocumentBlock;



public class DirectoryProperty
    extends Property
    implements Parent
{

    
    private List _children;

    
    private Set  _children_names;

    

    public DirectoryProperty(String name)
    {
        super();
        _children       = new ArrayList();
        _children_names = new HashSet();
        setName(name);
        setSize(0);
        setPropertyType(PropertyConstants.DIRECTORY_TYPE);
        setStartBlock(0);
        setNodeColor(_NODE_BLACK);   
    }

    

    protected DirectoryProperty(final int index, final byte [] array,
                                final int offset)
    {
        super(index, array, offset);
        _children       = new ArrayList();
        _children_names = new HashSet();
    }

    

    public boolean changeName(final Property property, final String newName)
    {
        boolean result;
        String  oldName = property.getName();

        property.setName(newName);
        String cleanNewName = property.getName();

        if (_children_names.contains(cleanNewName))
        {

            
            property.setName(oldName);
            result = false;
        }
        else
        {
            _children_names.add(cleanNewName);
            _children_names.remove(oldName);
            result = true;
        }
        return result;
    }

    

    public boolean deleteChild(final Property property)
    {
        boolean result = _children.remove(property);

        if (result)
        {
            _children_names.remove(property.getName());
        }
        return result;
    }

    private class PropertyComparator
        implements Comparator
    {

        

        public boolean equals(Object o)
        {
            return this == o;
        }

        

        public int compare(Object o1, Object o2)
        {
            String name1  = (( Property ) o1).getName();
            String name2  = (( Property ) o2).getName();
            int    result = name1.length() - name2.length();

            if (result == 0)
            {
                result = name1.compareTo(name2);
            }
            return result;
        }
    }   

    

    

    public boolean isDirectory()
    {
        return true;
    }

    

    protected void preWrite()
    {
        if (_children.size() > 0)
        {
            Property[] children =
                ( Property [] ) _children.toArray(new Property[ 0 ]);

            Arrays.sort(children, new PropertyComparator());
            int midpoint = children.length / 2;

            setChildProperty(children[ midpoint ].getIndex());
            children[ 0 ].setPreviousChild(null);
            children[ 0 ].setNextChild(null);
            for (int j = 1; j < midpoint; j++)
            {
                children[ j ].setPreviousChild(children[ j - 1 ]);
                children[ j ].setNextChild(null);
            }
            if (midpoint != 0)
            {
                children[ midpoint ]
                    .setPreviousChild(children[ midpoint - 1 ]);
            }
            if (midpoint != (children.length - 1))
            {
                children[ midpoint ].setNextChild(children[ midpoint + 1 ]);
                for (int j = midpoint + 1; j < children.length - 1; j++)
                {
                    children[ j ].setPreviousChild(null);
                    children[ j ].setNextChild(children[ j + 1 ]);
                }
                children[ children.length - 1 ].setPreviousChild(null);
                children[ children.length - 1 ].setNextChild(null);
            }
            else
            {
                children[ midpoint ].setNextChild(null);
            }
        }
    }

    
    

    

    public Iterator getChildren()
    {
        return _children.iterator();
    }

    

    public void addChild(final Property property)
        throws IOException
    {
        String name = property.getName();

        if (_children_names.contains(name))
        {
            throw new IOException(""Duplicate name """" + name + """""");
        }
        _children_names.add(name);
        _children.add(property);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.LabelSSTRecord,24,2,0,8,38,252,4,4,22,0.782608696,366,0.8,0,0.34375,0.305555556,1,6,14.04166667,7,1.7917,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class LabelSSTRecord
    extends Record
    implements CellValueRecordInterface, Comparable
{
    public final static short sid = 0xfd;
    private short             field_1_row;
    private short             field_2_column;
    private short             field_3_xf_index;
    private int               field_4_sst_index;

    public LabelSSTRecord()
    {
    }

    

    public LabelSSTRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public LabelSSTRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid LabelSST RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row       = LittleEndian.getShort(data, 0 + offset);
        field_2_column    = LittleEndian.getShort(data, 2 + offset);
        field_3_xf_index  = LittleEndian.getShort(data, 4 + offset);
        field_4_sst_index = LittleEndian.getInt(data, 6 + offset);
    }

    public void setRow(short row)
    {
        field_1_row = row;
    }

    public void setColumn(short col)
    {
        field_2_column = col;
    }

    

    public void setXFIndex(short index)
    {
        field_3_xf_index = index;
    }

    

    public void setSSTIndex(int index)
    {
        field_4_sst_index = index;
    }

    public short getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_column;
    }

    

    public short getXFIndex()
    {
        return field_3_xf_index;
    }

    

    public int getSSTIndex()
    {
        return field_4_sst_index;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[LABELSST]
"");
        buffer.append(""    .row            = "")
            .append(Integer.toHexString(getRow())).append(""
"");
        buffer.append(""    .column         = "")
            .append(Integer.toHexString(getColumn())).append(""
"");
        buffer.append(""    .xfindex        = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        buffer.append(""    .sstindex       = "")
            .append(Integer.toHexString(getSSTIndex())).append(""
"");
        buffer.append(""[/LABELSST]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 10);
        LittleEndian.putShort(data, 4 + offset, getRow());
        LittleEndian.putShort(data, 6 + offset, getColumn());
        LittleEndian.putShort(data, 8 + offset, getXFIndex());
        LittleEndian.putInt(data, 10 + offset, getSSTIndex());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 14;
    }

    public short getSid()
    {
        return this.sid;
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    public int compareTo(Object obj)
    {
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return 0;
        }
        if (this.getRow() < loc.getRow())
        {
            return -1;
        }
        if (this.getRow() > loc.getRow())
        {
            return 1;
        }
        if (this.getColumn() < loc.getColumn())
        {
            return -1;
        }
        if (this.getColumn() > loc.getColumn())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof CellValueRecordInterface))
        {
            return false;
        }
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.PowerPtg,8,2,0,3,13,28,2,2,8,1.142857143,56,0.0,0,0.538461538,0.40625,1,2,5.75,1,0.75,5,"



package org.apache.poi.hssf.record.formula;



public class PowerPtg
    extends Ptg
    implements OperationPtg
{
    public final static int  SIZE = 1;
    public final static byte sid  = 0x07;

    

    public PowerPtg()
    {
    }

    public PowerPtg(byte [] data, int offset)
    {

        
    }

    public void writeBytes(byte [] array, int offset)
    {
        array[ offset + 0 ] = sid;
    }

    public int getSize()
    {
        return SIZE;
    }

    public int getType()
    {
        return TYPE_BINARY;
    }

    public int getNumberOfOperands()
    {
        return 2;
    }

    public String toFormulaString()
    {
        return ""^"";
    }

    public String toFormulaString(Ptg [] operands)
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(operands[ 1 ].toFormulaString());
        buffer.append(""^"");
        buffer.append(operands[ 0 ].toFormulaString());
        return buffer.toString();
    }
}
"
poi,1.5,org.apache.poi.poifs.dev.POIFSViewEngine,4,1,0,2,24,4,1,1,2,0.333333333,146,1.0,0,0.0,0.466666667,0,0,35.25,3,1.25,0,"


package org.apache.poi.poifs.dev;

import java.io.*;

import java.util.*;



public class POIFSViewEngine
{
    private static final String _EOL = System.getProperty(""line.separator"");

    

    public static List inspectViewable(final Object viewable,
                                       final boolean drilldown,
                                       final int indentLevel,
                                       final String indentString)
    {
        List objects = new ArrayList();

        if (viewable instanceof POIFSViewable)
        {
            POIFSViewable inspected = ( POIFSViewable ) viewable;

            objects.add(indent(indentLevel, indentString,
                               inspected.getShortDescription()));
            if (drilldown)
            {
                if (inspected.preferArray())
                {
                    Object[] data = inspected.getViewableArray();

                    for (int j = 0; j < data.length; j++)
                    {
                        objects.addAll(inspectViewable(data[ j ], drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
                else
                {
                    Iterator iter = inspected.getViewableIterator();

                    while (iter.hasNext())
                    {
                        objects.addAll(inspectViewable(iter.next(),
                                                       drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
            }
        }
        else
        {
            objects.add(indent(indentLevel, indentString,
                               viewable.toString()));
        }
        return objects;
    }

    private static String indent(final int indentLevel,
                                 final String indentString, final String data)
    {
        StringBuffer finalBuffer  = new StringBuffer();
        StringBuffer indentPrefix = new StringBuffer();

        for (int j = 0; j < indentLevel; j++)
        {
            indentPrefix.append(indentString);
        }
        LineNumberReader reader =
            new LineNumberReader(new StringReader(data));

        try
        {
            String line = reader.readLine();

            while (line != null)
            {
                finalBuffer.append(indentPrefix).append(line).append(_EOL);
                line = reader.readLine();
            }
        }
        catch (IOException e)
        {
            finalBuffer.append(indentPrefix).append(e.getMessage())
                .append(_EOL);
        }
        return finalBuffer.toString();
    }
}   

"
poi,1.5,org.apache.poi.hssf.record.UseSelFSRecord,11,2,0,5,21,49,2,3,9,0.975,108,0.25,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class UseSelFSRecord
    extends Record
{
    public final static short sid   = 0x160;
    public final static short TRUE  = 1;
    public final static short FALSE = 0;
    private short             field_1_flag;

    public UseSelFSRecord()
    {
    }

    

    public UseSelFSRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public UseSelFSRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A UseSelFS RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_flag = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setFlag(short flag)
    {
        field_1_flag = flag;
    }

    

    public short getFlag()
    {
        return field_1_flag;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[USESELFS]
"");
        buffer.append(""    .flag            = "")
            .append(Integer.toHexString(getFlag())).append(""
"");
        buffer.append(""[/USESELFS]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getFlag());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.AreaFormatRecord,25,2,0,6,44,164,1,5,23,0.828703704,412,0.888888889,2,0.333333333,0.352,1,6,15.12,2,0.92,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class AreaFormatRecord
    extends Record
{
    public final static short      sid                             = 0x100a;
    private  int        field_1_foregroundColor;
    private  int        field_2_backgroundColor;
    private  short      field_3_pattern;
    private  short      field_4_formatFlags;
    private BitField   automatic                                  = new BitField(0x1);
    private BitField   invert                                     = new BitField(0x2);
    private  short      field_5_forecolorIndex;
    private  short      field_6_backcolorIndex;


    public AreaFormatRecord()
    {

    }

    

    public AreaFormatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public AreaFormatRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a AreaFormat record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_foregroundColor         = LittleEndian.getInt(data, 0x0 + offset);
        field_2_backgroundColor         = LittleEndian.getInt(data, 0x4 + offset);
        field_3_pattern                 = LittleEndian.getShort(data, 0x8 + offset);
        field_4_formatFlags             = LittleEndian.getShort(data, 0xa + offset);
        field_5_forecolorIndex          = LittleEndian.getShort(data, 0xc + offset);
        field_6_backcolorIndex          = LittleEndian.getShort(data, 0xe + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[AreaFormat]
"");

        buffer.append(""    .foregroundColor      = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getForegroundColor()))
            .append("" ("").append(getForegroundColor()).append("" )
"");

        buffer.append(""    .backgroundColor      = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getBackgroundColor()))
            .append("" ("").append(getBackgroundColor()).append("" )
"");

        buffer.append(""    .pattern              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getPattern()))
            .append("" ("").append(getPattern()).append("" )
"");

        buffer.append(""    .formatFlags          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormatFlags()))
            .append("" ("").append(getFormatFlags()).append("" )
"");
        buffer.append(""         .automatic                = "").append(isAutomatic           ()).append('
');
        buffer.append(""         .invert                   = "").append(isInvert              ()).append('
');

        buffer.append(""    .forecolorIndex       = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getForecolorIndex()))
            .append("" ("").append(getForecolorIndex()).append("" )
"");

        buffer.append(""    .backcolorIndex       = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getBackcolorIndex()))
            .append("" ("").append(getBackcolorIndex()).append("" )
"");

        buffer.append(""[/AreaFormat]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putInt(data, 4 + offset, field_1_foregroundColor);
        LittleEndian.putInt(data, 8 + offset, field_2_backgroundColor);
        LittleEndian.putShort(data, 12 + offset, field_3_pattern);
        LittleEndian.putShort(data, 14 + offset, field_4_formatFlags);
        LittleEndian.putShort(data, 16 + offset, field_5_forecolorIndex);
        LittleEndian.putShort(data, 18 + offset, field_6_backcolorIndex);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 4 + 4 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public int getForegroundColor()
    {
        return field_1_foregroundColor;
    }

    
    public void setForegroundColor(int field_1_foregroundColor)
    {
        this.field_1_foregroundColor = field_1_foregroundColor;
    }

    
    public int getBackgroundColor()
    {
        return field_2_backgroundColor;
    }

    
    public void setBackgroundColor(int field_2_backgroundColor)
    {
        this.field_2_backgroundColor = field_2_backgroundColor;
    }

    
    public short getPattern()
    {
        return field_3_pattern;
    }

    
    public void setPattern(short field_3_pattern)
    {
        this.field_3_pattern = field_3_pattern;
    }

    
    public short getFormatFlags()
    {
        return field_4_formatFlags;
    }

    
    public void setFormatFlags(short field_4_formatFlags)
    {
        this.field_4_formatFlags = field_4_formatFlags;
    }

    
    public short getForecolorIndex()
    {
        return field_5_forecolorIndex;
    }

    
    public void setForecolorIndex(short field_5_forecolorIndex)
    {
        this.field_5_forecolorIndex = field_5_forecolorIndex;
    }

    
    public short getBackcolorIndex()
    {
        return field_6_backcolorIndex;
    }

    
    public void setBackcolorIndex(short field_6_backcolorIndex)
    {
        this.field_6_backcolorIndex = field_6_backcolorIndex;
    }

    
    public void setAutomatic(boolean value)
    {
        field_4_formatFlags = automatic.setShortBoolean(field_4_formatFlags, value);
    }

    
    public boolean isAutomatic()
    {
        return automatic.isSet(field_4_formatFlags);
    }

    
    public void setInvert(boolean value)
    {
        field_4_formatFlags = invert.setShortBoolean(field_4_formatFlags, value);
    }

    
    public boolean isInvert()
    {
        return invert.isSet(field_4_formatFlags);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.SSTRecord,38,2,0,8,87,349,3,5,18,0.888288288,1625,0.933333333,1,0.239130435,0.243421053,2,7,41.36842105,13,2.3158,5,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.BinaryTree;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;

import java.util.*;



public class SSTRecord
    extends Record
{

    
    
    private static final int  _max                     = 8228;

    
    
    private static final int  _std_record_overhead     =
        2 * LittleEndianConsts.SHORT_SIZE;

    
    
    private static final int  _sst_record_overhead     =
        (_std_record_overhead + (2 * LittleEndianConsts.INT_SIZE));

    
    
    private static final int  _max_data_space          =
        _max - _sst_record_overhead;

    
    
    private static final int  _string_minimal_overhead =
        LittleEndianConsts.SHORT_SIZE + LittleEndianConsts.BYTE_SIZE;
    public static final short sid                      = 0xfc;

    
    private int               field_1_num_strings;

    
    private int               field_2_num_unique_strings;
    private BinaryTree        field_3_strings;

    
    
    private int               __expected_chars;

    
    
    private String            _unfinished_string;

    
    private int               _total_length_bytes;

    
    
    private int               _string_data_offset;

    
    private boolean           _wide_char;
    private List              _record_lengths = null;

    

    public SSTRecord()
    {
        field_1_num_strings        = 0;
        field_2_num_unique_strings = 0;
        field_3_strings            = new BinaryTree();
        setExpectedChars(0);
        _unfinished_string  = """";
        _total_length_bytes = 0;
        _string_data_offset = 0;
        _wide_char          = false;
    }

    

    public SSTRecord(final short id, final short size, final byte [] data)
    {
        super(id, size, data);
    }

    

    public SSTRecord(final short id, final short size, final byte [] data,
                     int offset)
    {
        super(id, size, data, offset);
    }

    

    public int addString(final String string)
    {
        int rval;

        if (string == null)
        {
            rval = addString("""", false);
        }
        else
        {

            
            
            
            boolean useUTF16 = false;
            int     strlen   = string.length();

            for (int j = 0; j < strlen; j++)
            {
                if (string.charAt(j) > 255)
                {
                    useUTF16 = true;
                    break;
                }
            }
            rval = addString(string, useUTF16);
        }
        return rval;
    }

    

    public int addString(final String string, final boolean useUTF16)
    {
        field_1_num_strings++;
        String        str  = (string == null) ? """"
                                              : string;
        int           rval = -1;
        UnicodeString ucs  = new UnicodeString();

        ucs.setString(str);
        ucs.setCharCount(( short ) str.length());
        ucs.setOptionFlags(( byte ) (useUTF16 ? 1
                                              : 0));
        Integer integer = ( Integer ) field_3_strings.getKeyForValue(ucs);

        if (integer != null)
        {
            rval = integer.intValue();
        }
        else
        {

            
            
            rval = field_3_strings.size();
            field_2_num_unique_strings++;
            integer = new Integer(rval);
            field_3_strings.put(integer, ucs);
        }
        return rval;
    }

    

    public int getNumStrings()
    {
        return field_1_num_strings;
    }

    

    public int getNumUniqueStrings()
    {
        return field_2_num_unique_strings;
    }

    

    public void setNumStrings(final int count)
    {
        field_1_num_strings = count;
    }

    

    public void getNumUniqueStrings(final int count)
    {
        field_2_num_unique_strings = count;
    }

    

    public String getString(final int id)
    {
        return (( UnicodeString ) field_3_strings.get(new Integer(id)))
            .getString();
    }

    public boolean getString16bit(final int id)
    {
        return ((( UnicodeString ) field_3_strings.get(new Integer(id)))
            .getOptionFlags() == 1);
    }

    

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SST]
"");
        buffer.append(""    .numstrings     = "")
            .append(Integer.toHexString(getNumStrings())).append(""
"");
        buffer.append(""    .uniquestrings  = "")
            .append(Integer.toHexString(getNumUniqueStrings())).append(""
"");
        for (int k = 0; k < field_3_strings.size(); k++)
        {
            buffer.append(""    .string_"" + k + ""      = "")
                .append((( UnicodeString ) field_3_strings
                .get(new Integer(k))).toString()).append(""
"");
        }
        buffer.append(""[/SST]
"");
        return buffer.toString();
    }

    

    public int serialize(int offset, byte [] data)
    {
        int rval                = getRecordSize();
        int record_length_index = 0;

        
        int unicodesize         = calculateUnicodeSize();

        if (unicodesize > _max_data_space)
        {
            byte[]  stringreminant     = null;
            int     unipos             = 0;
            boolean lastneedcontinue   = false;
            int     stringbyteswritten = 0;
            boolean first_record       = true;
            int     totalWritten       = 0;
            int     size               = 0;

            while (totalWritten != rval)
            {
                int pos = 0;

                
                int available;

                if (first_record)
                {
                    size         =
                        (( Integer ) _record_lengths
                            .get(record_length_index++)).intValue();
                    available    = size - 8;
                    pos          = writeSSTHeader(data,
                                                  pos + offset
                                                  + totalWritten, size);
                    size         += _std_record_overhead;
                    first_record = false;
                }
                else
                {
                    pos = 0;
                    int to_be_written = (unicodesize - stringbyteswritten)
                                        + (lastneedcontinue ? 1
                                                            : 0);           

                    size      =
                        (( Integer ) _record_lengths
                            .get(record_length_index++)).intValue();
                    available = size;
                    pos       = writeContinueHeader(data,
                                                    pos + offset
                                                    + totalWritten, size);
                    size      = size + _std_record_overhead;
                }

                
                
                if (lastneedcontinue)
                {

                    
                    
                    if (stringreminant.length <= available)
                    {

                        
                        System.arraycopy(stringreminant, 0, data,
                                         pos + offset + totalWritten,
                                         stringreminant.length);
                        stringbyteswritten += stringreminant.length - 1;
                        pos                += stringreminant.length;
                        lastneedcontinue   = false;
                        available          -= stringreminant.length;
                    }
                    else
                    {

                        
                        System.arraycopy(stringreminant, 0, data,
                                         pos + offset + totalWritten,
                                         available);
                        stringbyteswritten += available - 1;
                        pos                += available;
                        byte[] leftover =
                            new byte[ (stringreminant.length - available) + LittleEndianConsts.BYTE_SIZE ];

                        System.arraycopy(stringreminant, available, leftover,
                                         LittleEndianConsts.BYTE_SIZE,
                                         stringreminant.length - available);
                        leftover[ 0 ]    = stringreminant[ 0 ];
                        stringreminant   = leftover;
                        available        = 0;
                        lastneedcontinue = true;
                    }
                }

                
                
                
                for (; unipos < field_3_strings.size(); unipos++)
                {
                    Integer       intunipos = new Integer(unipos);
                    UnicodeString unistr    =
                        (( UnicodeString ) field_3_strings.get(intunipos));

                    if (unistr.getRecordSize() <= available)
                    {
                        unistr.serialize(pos + offset + totalWritten, data);
                        int rsize = unistr.getRecordSize();

                        stringbyteswritten += rsize;
                        pos                += rsize;
                        available          -= rsize;
                    }
                    else
                    {

                        
                        if (available >= _string_minimal_overhead)
                        {

                            
                            byte[] ucs = unistr.serialize();

                            System.arraycopy(ucs, 0, data,
                                             pos + offset + totalWritten,
                                             available);
                            stringbyteswritten += available;
                            stringreminant     =
                                new byte[ (ucs.length - available) + LittleEndianConsts.BYTE_SIZE ];
                            System.arraycopy(ucs, available, stringreminant,
                                             LittleEndianConsts.BYTE_SIZE,
                                             ucs.length - available);
                            stringreminant[ 0 ] =
                                ucs[ LittleEndianConsts.SHORT_SIZE ];
                            available           = 0;
                            lastneedcontinue    = true;
                            unipos++;
                        }
                        break;
                    }
                }
                totalWritten += size;
            }
        }
        else
        {

            
            int datasize = _sst_record_overhead + unicodesize;           

            writeSSTHeader(
                data, 0 + offset,
                _sst_record_overhead
                + (( Integer ) _record_lengths.get(
                record_length_index++)).intValue() - _std_record_overhead);
            int pos = _sst_record_overhead;

            for (int k = 0; k < field_3_strings.size(); k++)
            {
                UnicodeString unistr =
                    (( UnicodeString ) field_3_strings.get(new Integer(k)));

                System.arraycopy(unistr.serialize(), 0, data, pos + offset,
                                 unistr.getRecordSize());
                pos += unistr.getRecordSize();
            }
        }
        return rval;
    }

    
    private int calculateStringsize()
    {
        int retval = 0;

        for (int k = 0; k < field_3_strings.size(); k++)
        {
            retval +=
                (( UnicodeString ) field_3_strings.get(new Integer(k)))
                    .getRecordSize();
        }
        return retval;
    }

    

    public void processContinueRecord(final byte [] record)
    {
        if (getExpectedChars() == 0)
        {
            _unfinished_string  = """";
            _total_length_bytes = 0;
            _string_data_offset = 0;
            _wide_char          = false;
            manufactureStrings(record, 0, ( short ) record.length);
        }
        else
        {
            int data_length = record.length - LittleEndianConsts.BYTE_SIZE;

            if (calculateByteCount(getExpectedChars()) > data_length)
            {

                
                byte[] input =
                    new byte[ record.length + LittleEndianConsts.SHORT_SIZE ];
                short  size  = ( short ) (((record[ 0 ] & 1) == 1)
                                          ? (data_length
                                             / LittleEndianConsts.SHORT_SIZE)
                                          : (data_length
                                             / LittleEndianConsts.BYTE_SIZE));

                LittleEndian.putShort(input, ( byte ) 0, size);
                System.arraycopy(record, 0, input,
                                 LittleEndianConsts.SHORT_SIZE,
                                 record.length);
                UnicodeString ucs = new UnicodeString(UnicodeString.sid,
                                                      ( short ) input.length,
                                                      input);

                _unfinished_string = _unfinished_string + ucs.getString();
                setExpectedChars(getExpectedChars() - size);
            }
            else
            {
                setupStringParameters(record, -LittleEndianConsts.SHORT_SIZE,
                                      getExpectedChars());
                byte[] str_data = new byte[ _total_length_bytes ];
                int    length   = _string_minimal_overhead
                                  + (calculateByteCount(getExpectedChars()));
                byte[] bstring  = new byte[ length ];

                
                
                
                System.arraycopy(record, 0, str_data,
                                 LittleEndianConsts.SHORT_SIZE,
                                 str_data.length
                                 - LittleEndianConsts.SHORT_SIZE);

                
                LittleEndian.putShort(bstring, 0,
                                      ( short ) getExpectedChars());

                
                bstring[ LittleEndianConsts.SHORT_SIZE ] =
                    str_data[ LittleEndianConsts.SHORT_SIZE ];

                
                
                System.arraycopy(str_data, _string_data_offset, bstring,
                                 _string_minimal_overhead,
                                 bstring.length - _string_minimal_overhead);

                
                UnicodeString string  =
                    new UnicodeString(UnicodeString.sid,
                                      ( short ) bstring.length, bstring,
                                      _unfinished_string);
                Integer       integer = new Integer(field_3_strings.size());

                field_3_strings.put(integer, string);
                manufactureStrings(record,
                                   _total_length_bytes
                                   - LittleEndianConsts
                                       .SHORT_SIZE, ( short ) record.length);
            }
        }
    }

    

    public short getSid()
    {
        return sid;
    }

    

    public int hashCode()
    {
        return field_2_num_unique_strings;
    }

    

    public boolean equals(Object o)
    {
        if ((o == null) || (o.getClass() != this.getClass()))
        {
            return false;
        }
        SSTRecord other = ( SSTRecord ) o;

        return ((field_1_num_strings == other
            .field_1_num_strings) && (field_2_num_unique_strings == other
                .field_2_num_unique_strings) && field_3_strings
                    .equals(other.field_3_strings));
    }

    

    protected void validateSid(final short id)
        throws RecordFormatException
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An SST RECORD"");
        }
    }

    

    protected void fillFields(final byte [] data, final short size,
                              int offset)
    {

        
        
        
        field_1_num_strings        = LittleEndian.getInt(data, 0 + offset);
        field_2_num_unique_strings = LittleEndian.getInt(data, 4 + offset);
        field_3_strings            = new BinaryTree();
        setExpectedChars(0);
        _unfinished_string  = """";
        _total_length_bytes = 0;
        _string_data_offset = 0;
        _wide_char          = false;
        manufactureStrings(data, 8 + offset, size);
    }

    

    int getExpectedChars()
    {
        return __expected_chars;
    }

    

    Iterator getStrings()
    {
        return field_3_strings.values().iterator();
    }

    

    int countStrings()
    {
        return field_3_strings.size();
    }

    

    String getUnfinishedString()
    {
        return _unfinished_string;
    }

    

    int getTotalLength()
    {
        return _total_length_bytes;
    }

    

    int getStringDataOffset()
    {
        return _string_data_offset;
    }

    

    boolean isWideChar()
    {
        return _wide_char;
    }

    private int writeSSTHeader(final byte [] data, final int pos,
                               final int recsize)
    {
        int offset = pos;

        LittleEndian.putShort(data, offset, sid);
        offset += LittleEndianConsts.SHORT_SIZE;
        LittleEndian.putShort(data, offset, ( short ) (recsize));
        offset += LittleEndianConsts.SHORT_SIZE;
        LittleEndian.putInt(data, offset, getNumStrings());
        offset += LittleEndianConsts.INT_SIZE;
        LittleEndian.putInt(data, offset, getNumUniqueStrings());
        offset += LittleEndianConsts.INT_SIZE;
        return offset - pos;
    }

    private int writeContinueHeader(final byte [] data, final int pos,
                                    final int recsize)
    {
        int offset = pos;

        LittleEndian.putShort(data, offset, ContinueRecord.sid);
        offset += LittleEndianConsts.SHORT_SIZE;
        LittleEndian.putShort(data, offset, ( short ) (recsize));
        offset += LittleEndianConsts.SHORT_SIZE;
        return offset - pos;
    }

    private int calculateUCArrayLength(final byte [][] ucarray)
    {
        int retval = 0;

        for (int k = 0; k < ucarray.length; k++)
        {
            retval += ucarray[ k ].length;
        }
        return retval;
    }

    private void manufactureStrings(final byte [] data, final int index,
                                    short size)
    {
        int offset = index;

        while (offset < size)
        {
            int remaining = size - offset;

            if ((remaining > 0)
                    && (remaining < LittleEndianConsts.SHORT_SIZE))
            {
                throw new RecordFormatException(
                    ""Cannot get length of the last string in SSTRecord"");
            }
            if (remaining == LittleEndianConsts.SHORT_SIZE)
            {
                setExpectedChars(LittleEndian.getShort(data, offset));
                _unfinished_string = """";
                break;
            }
            short char_count = LittleEndian.getShort(data, offset);

            setupStringParameters(data, offset, char_count);
            if (remaining < _total_length_bytes)
            {
                setExpectedChars(calculateCharCount(_total_length_bytes
                                                    - remaining));
                char_count          -= getExpectedChars();
                _total_length_bytes = remaining;
            }
            else
            {
                setExpectedChars(0);
            }
            processString(data, offset, char_count);
            offset += _total_length_bytes;
            if (getExpectedChars() != 0)
            {
                break;
            }
        }
    }

    private void setupStringParameters(final byte [] data, final int index,
                                       final int char_count)
    {
        byte flag = data[ index + LittleEndianConsts.SHORT_SIZE ];

        _wide_char = (flag & 1) == 1;
        boolean extended      = (flag & 4) == 4;
        boolean formatted_run = (flag & 8) == 8;

        _total_length_bytes = _string_minimal_overhead
                              + calculateByteCount(char_count);
        _string_data_offset = _string_minimal_overhead;
        if (formatted_run)
        {
            short run_count = LittleEndian.getShort(data,
                                                    index
                                                    + _string_data_offset);

            _string_data_offset += LittleEndianConsts.SHORT_SIZE;
            _total_length_bytes += LittleEndianConsts.SHORT_SIZE
                                   + (LittleEndianConsts.INT_SIZE
                                      * run_count);
        }
        if (extended)
        {
            int extension_length = LittleEndian.getInt(data,
                                                       index
                                                       + _string_data_offset);

            _string_data_offset += LittleEndianConsts.INT_SIZE;
            _total_length_bytes += LittleEndianConsts.INT_SIZE
                                   + extension_length;
        }
    }

    private void processString(final byte [] data, final int index,
                               final short char_count)
    {
        byte[] str_data = new byte[ _total_length_bytes ];
        int    length   = _string_minimal_overhead
                          + calculateByteCount(char_count);
        byte[] bstring  = new byte[ length ];

        System.arraycopy(data, index, str_data, 0, str_data.length);
        int offset = 0;

        LittleEndian.putShort(bstring, offset, char_count);
        offset            += LittleEndianConsts.SHORT_SIZE;
        bstring[ offset ] = str_data[ offset ];
        System.arraycopy(str_data, _string_data_offset, bstring,
                         _string_minimal_overhead,
                         bstring.length - _string_minimal_overhead);
        UnicodeString string = new UnicodeString(UnicodeString.sid,
                                                 ( short ) bstring.length,
                                                 bstring);

        if (getExpectedChars() != 0)
        {
            _unfinished_string = string.getString();
        }
        else
        {
            Integer integer = new Integer(field_3_strings.size());

            field_3_strings.put(integer, string);
        }
    }

    private void setExpectedChars(final int count)
    {
        __expected_chars = count;
    }

    private int calculateByteCount(final int character_count)
    {
        return character_count * (_wide_char ? LittleEndianConsts.SHORT_SIZE
                                             : LittleEndianConsts.BYTE_SIZE);
    }

    private int calculateCharCount(final int byte_count)
    {
        return byte_count / (_wide_char ? LittleEndianConsts.SHORT_SIZE
                                        : LittleEndianConsts.BYTE_SIZE);
    }

    
    
    public int getRecordSize()
    {
        _record_lengths = new ArrayList();
        int retval      = 0;
        int unicodesize = calculateUnicodeSize();

        if (unicodesize > _max_data_space)
        {
            UnicodeString unistr             = null;
            int           stringreminant     = 0;
            int           unipos             = 0;
            boolean       lastneedcontinue   = false;
            int           stringbyteswritten = 0;
            boolean       finished           = false;
            boolean       first_record       = true;
            int           totalWritten       = 0;

            while (!finished)
            {
                int record = 0;
                int pos    = 0;

                if (first_record)
                {

                    
                    record       = _max;
                    pos          = 12;
                    first_record = false;
                    _record_lengths.add(new Integer(record
                                                    - _std_record_overhead));
                }
                else
                {

                    
                    pos = 0;
                    int to_be_written = (unicodesize - stringbyteswritten)
                                        + (lastneedcontinue ? 1
                                                            : 0);
                    int size          = Math.min(_max - _std_record_overhead,
                                                 to_be_written);

                    if (size == to_be_written)
                    {
                        finished = true;
                    }
                    record = size + _std_record_overhead;
                    _record_lengths.add(new Integer(size));
                    pos = 4;
                }
                if (lastneedcontinue)
                {
                    int available = _max - pos;

                    if (stringreminant <= available)
                    {

                        
                        stringbyteswritten += stringreminant - 1;
                        pos                += stringreminant;
                        lastneedcontinue   = false;
                    }
                    else
                    {

                        
                        int toBeWritten = unistr.maxBrokenLength(available);

                        if (available != toBeWritten)
                        {
                            int shortrecord = record
                                              - (available - toBeWritten);

                            _record_lengths.set(
                                _record_lengths.size() - 1,
                                new Integer(
                                    shortrecord - _std_record_overhead));
                            record = shortrecord;
                        }
                        stringbyteswritten += toBeWritten - 1;
                        pos                += toBeWritten;
                        stringreminant     -= toBeWritten - 1;
                        lastneedcontinue   = true;
                    }
                }
                for (; unipos < field_3_strings.size(); unipos++)
                {
                    int     available = _max - pos;
                    Integer intunipos = new Integer(unipos);

                    unistr =
                        (( UnicodeString ) field_3_strings.get(intunipos));
                    if (unistr.getRecordSize() <= available)
                    {
                        stringbyteswritten += unistr.getRecordSize();
                        pos                += unistr.getRecordSize();
                    }
                    else
                    {
                        if (available >= _string_minimal_overhead)
                        {
                            int toBeWritten =
                                unistr.maxBrokenLength(available);

                            stringbyteswritten += toBeWritten;
                            stringreminant     =
                                (unistr.getRecordSize() - toBeWritten)
                                + LittleEndianConsts.BYTE_SIZE;
                            if (available != toBeWritten)
                            {
                                int shortrecord = record
                                                  - (available - toBeWritten);

                                _record_lengths.set(
                                    _record_lengths.size() - 1,
                                    new Integer(
                                        shortrecord - _std_record_overhead));
                                record = shortrecord;
                            }
                            lastneedcontinue = true;
                            unipos++;
                        }
                        else
                        {
                            int shortrecord = record - available;

                            _record_lengths.set(
                                _record_lengths.size() - 1,
                                new Integer(
                                    shortrecord - _std_record_overhead));
                            record = shortrecord;
                        }
                        break;
                    }
                }
                totalWritten += record;
            }
            retval = totalWritten;
        }
        else
        {

            
            retval = _sst_record_overhead + unicodesize;
            _record_lengths.add(new Integer(unicodesize));
        }
        return retval;
    }

    private int calculateUnicodeSize()
    {
        int retval = 0;

        for (int k = 0; k < field_3_strings.size(); k++)
        {
            UnicodeString string =
                ( UnicodeString ) field_3_strings.get(new Integer(k));

            retval += string.getRecordSize();
        }
        return retval;
    }
}
"
poi,1.5,org.apache.poi.hssf.model.Workbook,59,1,0,39,187,1269,5,34,24,0.892572944,2395,1.0,2,0.0,0.187192118,0,0,39.37288136,10,1.4407,14,"


package org.apache.poi.hssf.model;

import java.io.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;

import org.apache.poi.hssf.record.*;
import org.apache.poi.util.POILogger;
import org.apache.poi.util.POILogFactory;



public class Workbook
{
    private static final int   DEBUG       = POILogger.DEBUG;

    

    private final static short CODEPAGE    = ( short ) 0x4b0;

    

    protected ArrayList        records     = null;

    

    protected SSTRecord        sst         = null;

    

    protected ArrayList        boundsheets = new ArrayList();
    protected int              bspos       =
        0;   
    protected int              tabpos      =
        0;   
    protected int              fontpos     =
        0;   
    protected int              numfonts    =
        0;   
    protected int              xfpos       =
        0;   
    protected int              numxfs      =
        0;   
    private int                backuppos   =
        0;   
    private static POILogger   log         =
        POILogFactory.getLogger(Workbook.class);

    

    public Workbook()
    {
    }

    

    public static Workbook createWorkbook(List recs)
    {
        log.log(DEBUG, ""Workbook (readfile) created with reclen="",
                new Integer(recs.size()));
        Workbook  retval  = new Workbook();
        ArrayList records = new ArrayList(recs.size() / 3);

        for (int k = 0; k < recs.size(); k++)
        {
            Record rec = ( Record ) recs.get(k);

            if (rec.getSid() == EOFRecord.sid)
            {
                records.add(rec);
                log.log(DEBUG, ""found workbook eof record at "" + k);
                break;
            }
            switch (rec.getSid())
            {

                case BoundSheetRecord.sid :
                    log.log(DEBUG, ""found boundsheet record at "" + k);
                    retval.boundsheets.add(rec);
                    retval.bspos = k;
                    break;

                case SSTRecord.sid :
                    log.log(DEBUG, ""found sst record at "" + k);
                    retval.sst = ( SSTRecord ) rec;
                    break;

                case FontRecord.sid :
                    log.log(DEBUG, ""found font record at "" + k);
                    retval.fontpos = k;
                    retval.numfonts++;
                    break;

                case ExtendedFormatRecord.sid :
                    log.log(DEBUG, ""found XF record at "" + k);
                    retval.xfpos = k;
                    retval.numxfs++;
                    break;

                case TabIdRecord.sid :
                    log.log(DEBUG, ""found tabid record at "" + k);
                    retval.tabpos = k;
                    break;

                case BackupRecord.sid :
                    log.log(DEBUG, ""found backup record at "" + k);
                    retval.backuppos = k;
                    break;

                default :
            }
            records.add(rec);
        }
        retval.records = records;
        log.log(DEBUG, ""exit create workbook from existing file function"");
        return retval;
    }

    

    public static Workbook createWorkbook()
    {
        log.log(DEBUG, ""creating new workbook from scratch"");
        Workbook  retval  = new Workbook();
        ArrayList records = new ArrayList(30);

        records.add(retval.createBOF());
        records.add(retval.createInterfaceHdr());
        records.add(retval.createMMS());
        records.add(retval.createInterfaceEnd());
        records.add(retval.createWriteAccess());
        records.add(retval.createCodepage());
        records.add(retval.createDSF());
        records.add(retval.createTabId());
        retval.tabpos = records.size() - 1;
        records.add(retval.createFnGroupCount());
        records.add(retval.createWindowProtect());
        records.add(retval.createProtect());
        records.add(retval.createPassword());
        records.add(retval.createProtectionRev4());
        records.add(retval.createPasswordRev4());
        records.add(retval.createWindowOne());
        records.add(retval.createBackup());
        retval.backuppos = records.size() - 1;
        records.add(retval.createHideObj());
        records.add(retval.createDateWindow1904());
        records.add(retval.createPrecision());
        records.add(retval.createRefreshAll());
        records.add(retval.createBookBool());
        records.add(retval.createFont());
        records.add(retval.createFont());
        records.add(retval.createFont());
        records.add(retval.createFont());
        retval.fontpos  = records.size() - 1;   
        retval.numfonts = 4;
        records.add(retval.createFormat(0));
        records.add(retval.createFormat(1));
        records.add(retval.createFormat(2));
        records.add(retval.createFormat(3));
        records.add(retval.createFormat(4));
        records.add(retval.createFormat(5));
        records.add(retval.createFormat(6));
        records.add(retval.createFormat(7));
        for (int k = 0; k < 21; k++)
        {
            records.add(retval.createExtendedFormat(k));
            retval.numxfs++;
        }
        retval.xfpos = records.size() - 1;
        for (int k = 0; k < 6; k++)
        {
            records.add(retval.createStyle(k));
        }
        records.add(retval.createUseSelFS());
        for (int k = 0; k < 1; k++)
        {   
            BoundSheetRecord bsr =
                ( BoundSheetRecord ) retval.createBoundSheet(k);

            records.add(bsr);
            retval.boundsheets.add(bsr);
            retval.bspos = records.size() - 1;
        }
        records.add(retval.createCountry());
        retval.sst = ( SSTRecord ) retval.createSST();
        records.add(retval.sst);
        records.add(retval.createExtendedSST());

        
        records.add(retval.createEOF());
        retval.records = records;
        log.log(DEBUG, ""exit create new workbook from scratch"");
        return retval;
    }

    public int getNumRecords()
    {
        return records.size();
    }

    

    public FontRecord getFontRecordAt(int idx)
    {
        int index = idx;

        if (index > 4)
        {
            index -= 1;   
        }
        if (index > (numfonts - 1))
        {
            throw new ArrayIndexOutOfBoundsException(
                ""There are only "" + numfonts
                + "" font records, you asked for "" + idx);
        }
        FontRecord retval =
            ( FontRecord ) records.get((fontpos - (numfonts - 1)) + index);

        return retval;
    }

    

    public FontRecord createNewFont()
    {
        FontRecord rec = ( FontRecord ) createFont();

        ++fontpos;
        ++bspos;
        ++xfpos;
        records.add(fontpos, rec);
        numfonts++;
        return rec;
    }

    

    public int getNumberOfFontRecords()
    {
        return numfonts;
    }

    

    public void setSheetBof(int sheetnum, int pos)
    {
        log.log(DEBUG, ""setting bof for sheetnum ="", new Integer(sheetnum),
                "" at pos="", new Integer(pos));
        checkSheets(sheetnum);
        (( BoundSheetRecord ) boundsheets.get(sheetnum))
            .setPositionOfBof(pos);
    }

    

    public BackupRecord getBackupRecord()
    {
        return ( BackupRecord ) records.get(backuppos);
    }

    

    public void setSheetName(int sheetnum, String sheetname)
    {
        checkSheets(sheetnum);
        (( BoundSheetRecord ) boundsheets.get(sheetnum))
            .setSheetname(sheetname);
        (( BoundSheetRecord ) boundsheets.get(sheetnum))
            .setSheetnameLength(( byte ) sheetname.length());
    }

    

    public String getSheetName(int sheetnum)
    {
        return (( BoundSheetRecord ) boundsheets.get(sheetnum))
            .getSheetname();
    }

    

    private void checkSheets(int sheetnum)
    {
        if ((boundsheets.size()) <= sheetnum)
        {   
            if ((boundsheets.size() + 1) <= sheetnum)
            {
                throw new RuntimeException(""Sheet number out of bounds!"");
            }
            BoundSheetRecord bsr =
                ( BoundSheetRecord ) createBoundSheet(sheetnum);

            records.add(++bspos, bsr);
            boundsheets.add(bsr);
            fixTabIdRecord();
        }
    }

    public void removeSheet(int sheetnum)
    {
        if (boundsheets.size() > sheetnum)
        {
            records.remove(bspos - (boundsheets.size() - 1) + sheetnum);
            bspos--;
            boundsheets.remove(sheetnum);
            fixTabIdRecord();
        }
    }

    

    private void fixTabIdRecord()
    {
        TabIdRecord tir = ( TabIdRecord ) records.get(tabpos);
        short[]     tia = new short[ boundsheets.size() ];

        for (short k = 0; k < tia.length; k++)
        {
            tia[ k ] = k;
        }
        tir.setTabIdArray(tia);
    }

    

    public int getNumSheets()
    {
        log.log(DEBUG, ""getNumSheets="", new Integer(boundsheets.size()));
        return boundsheets.size();
    }

    

    public int getNumExFormats()
    {
        log.log(DEBUG, ""getXF="", new Integer(boundsheets.size()));
        return numxfs;
    }

    

    public ExtendedFormatRecord getExFormatAt(int index)
    {
        int xfptr = xfpos - (numxfs - 1);

        xfptr += index;
        ExtendedFormatRecord retval =
            ( ExtendedFormatRecord ) records.get(xfptr);

        return retval;
    }

    

    public ExtendedFormatRecord createCellXF()
    {
        ExtendedFormatRecord xf = createExtendedFormat();

        ++xfpos;
        ++bspos;
        records.add(xfpos, xf);
        numxfs++;
        return xf;
    }

    

    public int addSSTString(String string, boolean use16bits)
    {
        log.log(DEBUG, ""insert to sst string='"", string, ""' and use16bits= "",
                new Boolean(use16bits));
        if (sst == null)
        {
            insertSST();
        }
        return sst.addString(string, use16bits);
    }

    

    public int addSSTString(String string)
    {
        return addSSTString(string, false);
    }

    

    public String getSSTString(int str)
    {
        if (sst == null)
        {
            insertSST();
        }
        String retval = sst.getString(str);

        log.log(DEBUG, ""Returning SST for index="", new Integer(str),
                "" String= "", retval);
        return retval;
    }

    

    public void insertSST()
    {
        log.log(DEBUG, ""creating new SST via insertSST!"");
        sst = ( SSTRecord ) createSST();
        records.add(records.size() - 1, createExtendedSST());
        records.add(records.size() - 2, sst);
    }

    

    public byte [] serialize()
    {
        log.log(DEBUG, ""Serializing Workbook!"");
        byte[] retval    = null;

        
        int    arraysize = getSize();
        int    pos       = 0;

        
        
        

        
        
        
        
        retval = new byte[ arraysize ];
        for (int k = 0; k < records.size(); k++)
        {

            
            
            pos += (( Record ) records.get(k)).serialize(pos,
                    retval);   
        }
        log.log(DEBUG, ""Exiting serialize workbook"");
        return retval;
    }

    

    public int serialize(int offset, byte [] data)
    {
        log.log(DEBUG, ""Serializing Workbook with offsets"");

        

        int pos       = 0;










        for (int k = 0; k < records.size(); k++)
        {

            
            
            pos += (( Record ) records.get(k)).serialize(pos + offset,
                    data);   
        }
        log.log(DEBUG, ""Exiting serialize workbook"");
        return pos;
    }

    public int getSize()
    {
        int retval = 0;

        for (int k = 0; k < records.size(); k++)
        {
            retval += (( Record ) records.get(k)).getRecordSize();
        }
        return retval;
    }

    

    protected Record createBOF()
    {
        BOFRecord retval = new BOFRecord();

        retval.setVersion(( short ) 0x600);
        retval.setType(( short ) 5);
        retval.setBuild(( short ) 0x10d3);


        retval.setBuildYear(( short ) 1996);
        retval.setHistoryBitMask(0x41);   
        retval.setRequiredVersion(0x6);
        return retval;
    }

    

    protected Record createInterfaceHdr()
    {
        InterfaceHdrRecord retval = new InterfaceHdrRecord();

        retval.setCodepage(CODEPAGE);
        return retval;
    }

    

    protected Record createMMS()
    {
        MMSRecord retval = new MMSRecord();

        retval.setAddMenuCount(( byte ) 0);
        retval.setDelMenuCount(( byte ) 0);
        return retval;
    }

    

    protected Record createInterfaceEnd()
    {
        return new InterfaceEndRecord();
    }

    

    protected Record createWriteAccess()
    {
        WriteAccessRecord retval = new WriteAccessRecord();

        retval.setUsername(System.getProperty(""user.name""));
        return retval;
    }

    

    protected Record createCodepage()
    {
        CodepageRecord retval = new CodepageRecord();

        retval.setCodepage(CODEPAGE);
        return retval;
    }

    

    protected Record createDSF()
    {
        DSFRecord retval = new DSFRecord();

        retval.setDsf(
            ( short ) 0);   
        return retval;
    }

    

    protected Record createTabId()
    {
        TabIdRecord retval     = new TabIdRecord();
        short[]     tabidarray =
        {
            0
        };

        retval.setTabIdArray(tabidarray);
        return retval;
    }

    

    protected Record createFnGroupCount()
    {
        FnGroupCountRecord retval = new FnGroupCountRecord();

        retval.setCount(( short ) 14);
        return retval;
    }

    

    protected Record createWindowProtect()
    {
        WindowProtectRecord retval = new WindowProtectRecord();

        retval.setProtect(
            false);   
        return retval;   
    }

    

    protected Record createProtect()
    {
        ProtectRecord retval = new ProtectRecord();

        retval.setProtect(
            false);   
        return retval;   
    }

    

    protected Record createPassword()
    {
        PasswordRecord retval = new PasswordRecord();

        retval.setPassword(( short ) 0);   
        return retval;
    }

    

    protected Record createProtectionRev4()
    {
        ProtectionRev4Record retval = new ProtectionRev4Record();

        retval.setProtect(false);
        return retval;
    }

    

    protected Record createPasswordRev4()
    {
        PasswordRev4Record retval = new PasswordRev4Record();

        retval.setPassword(( short ) 0);   
        return retval;
    }

    

    protected Record createWindowOne()
    {
        WindowOneRecord retval = new WindowOneRecord();

        retval.setHorizontalHold(( short ) 0x168);
        retval.setVerticalHold(( short ) 0x10e);
        retval.setWidth(( short ) 0x3a5c);
        retval.setHeight(( short ) 0x23be);
        retval.setOptions(( short ) 0x38);
        retval.setSelectedTab(( short ) 0x0);
        retval.setDisplayedTab(( short ) 0x0);
        retval.setNumSelectedTabs(( short ) 1);
        retval.setTabWidthRatio(( short ) 0x258);
        return retval;
    }

    

    protected Record createBackup()
    {
        BackupRecord retval = new BackupRecord();

        retval.setBackup(
            ( short ) 0);   
        return retval;
    }

    

    protected Record createHideObj()
    {
        HideObjRecord retval = new HideObjRecord();

        retval.setHideObj(( short ) 0);   
        return retval;
    }

    

    protected Record createDateWindow1904()
    {
        DateWindow1904Record retval = new DateWindow1904Record();

        retval.setWindowing(
            ( short ) 0);   
        return retval;
    }

    

    protected Record createPrecision()
    {
        PrecisionRecord retval = new PrecisionRecord();

        retval.setFullPrecision(
            true);   
        return retval;
    }

    

    protected Record createRefreshAll()
    {
        RefreshAllRecord retval = new RefreshAllRecord();

        retval.setRefreshAll(false);
        return retval;
    }

    

    protected Record createBookBool()
    {
        BookBoolRecord retval = new BookBoolRecord();

        retval.setSaveLinkValues(( short ) 0);
        return retval;
    }

    

    protected Record createFont()
    {
        FontRecord retval = new FontRecord();

        retval.setFontHeight(( short ) 0xc8);
        retval.setAttributes(( short ) 0x0);
        retval.setColorPaletteIndex(( short ) 0x7fff);
        retval.setBoldWeight(( short ) 0x190);
        retval.setFontNameLength(( byte ) 5);
        retval.setFontName(""Arial"");
        return retval;
    }

    

    protected Record createFormat(int id)
    {   
        FormatRecord retval = new FormatRecord();   

        switch (id)
        {

            case 0 :
                retval.setIndexCode(( short ) 5);
                retval.setFormatStringLength(( byte ) 0x17);
                retval.setFormatString(""""$""#,##0_);\(""$""#,##0\)"");
                break;

            case 1 :
                retval.setIndexCode(( short ) 6);
                retval.setFormatStringLength(( byte ) 0x1c);
                retval.setFormatString(""""$""#,##0_);[Red]\(""$""#,##0\)"");
                break;

            case 2 :
                retval.setIndexCode(( short ) 7);
                retval.setFormatStringLength(( byte ) 0x1d);
                retval.setFormatString(""""$""#,##0.00_);\(""$""#,##0.00\)"");
                break;

            case 3 :
                retval.setIndexCode(( short ) 8);
                retval.setFormatStringLength(( byte ) 0x22);
                retval.setFormatString(
                    """"$""#,##0.00_);[Red]\(""$""#,##0.00\)"");
                break;

            case 4 :
                retval.setIndexCode(( short ) 0x2a);
                retval.setFormatStringLength(( byte ) 0x32);
                retval.setFormatString(
                    ""_(""$""* #,##0_);_(""$""* \(#,##0\);_(""$""* ""-""_);_(@_)"");
                break;

            case 5 :
                retval.setIndexCode(( short ) 0x29);
                retval.setFormatStringLength(( byte ) 0x29);
                retval.setFormatString(
                    ""_(* #,##0_);_(* \(#,##0\);_(* ""-""_);_(@_)"");
                break;

            case 6 :
                retval.setIndexCode(( short ) 0x2c);
                retval.setFormatStringLength(( byte ) 0x3a);
                retval.setFormatString(
                    ""_(""$""* #,##0.00_);_(""$""* \(#,##0.00\);_(""$""* ""-""??_);_(@_)"");
                break;

            case 7 :
                retval.setIndexCode(( short ) 0x2b);
                retval.setFormatStringLength(( byte ) 0x31);
                retval.setFormatString(
                    ""_(* #,##0.00_);_(* \(#,##0.00\);_(* ""-""??_);_(@_)"");
                break;
        }
        return retval;
    }

    

    protected Record createExtendedFormat(int id)
    {   
        ExtendedFormatRecord retval = new ExtendedFormatRecord();

        switch (id)
        {

            case 0 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 1 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 2 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 3 :
                retval.setFontIndex(( short ) 2);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 4 :
                retval.setFontIndex(( short ) 2);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 5 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 6 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 7 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 8 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 9 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 10 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 11 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 12 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 13 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 14 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff400);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            
            case 15 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0);
                retval.setCellOptions(( short ) 0x1);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0x0);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            
            case 16 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0x2b);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff800);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 17 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0x29);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff800);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 18 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0x2c);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff800);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 19 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0x2a);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff800);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 20 :
                retval.setFontIndex(( short ) 1);
                retval.setFormatIndex(( short ) 0x9);
                retval.setCellOptions(( short ) 0xfffffff5);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0xfffff800);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            
            case 21 :
                retval.setFontIndex(( short ) 5);
                retval.setFormatIndex(( short ) 0x0);
                retval.setCellOptions(( short ) 0x1);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0x800);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 22 :
                retval.setFontIndex(( short ) 6);
                retval.setFormatIndex(( short ) 0x0);
                retval.setCellOptions(( short ) 0x1);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0x5c00);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 23 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0x31);
                retval.setCellOptions(( short ) 0x1);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0x5c00);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 24 :
                retval.setFontIndex(( short ) 0);
                retval.setFormatIndex(( short ) 0x8);
                retval.setCellOptions(( short ) 0x1);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0x5c00);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;

            case 25 :
                retval.setFontIndex(( short ) 6);
                retval.setFormatIndex(( short ) 0x8);
                retval.setCellOptions(( short ) 0x1);
                retval.setAlignmentOptions(( short ) 0x20);
                retval.setIndentionOptions(( short ) 0x5c00);
                retval.setBorderOptions(( short ) 0);
                retval.setPaletteOptions(( short ) 0);
                retval.setAdtlPaletteOptions(( short ) 0);
                retval.setFillPaletteOptions(( short ) 0x20c0);
                break;
        }
        return retval;
    }

    

    protected ExtendedFormatRecord createExtendedFormat()
    {
        ExtendedFormatRecord retval = new ExtendedFormatRecord();

        retval.setFontIndex(( short ) 0);
        retval.setFormatIndex(( short ) 0x0);
        retval.setCellOptions(( short ) 0x1);
        retval.setAlignmentOptions(( short ) 0x20);
        retval.setIndentionOptions(( short ) 0);
        retval.setBorderOptions(( short ) 0);
        retval.setPaletteOptions(( short ) 0);
        retval.setAdtlPaletteOptions(( short ) 0);
        retval.setFillPaletteOptions(( short ) 0x20c0);
        return retval;
    }

    

    protected Record createStyle(int id)
    {   
        StyleRecord retval = new StyleRecord();

        switch (id)
        {

            case 0 :
                retval.setIndex(( short ) 0xffff8010);
                retval.setBuiltin(( byte ) 3);
                retval.setOutlineStyleLevel(( byte ) 0xffffffff);
                break;

            case 1 :
                retval.setIndex(( short ) 0xffff8011);
                retval.setBuiltin(( byte ) 6);
                retval.setOutlineStyleLevel(( byte ) 0xffffffff);
                break;

            case 2 :
                retval.setIndex(( short ) 0xffff8012);
                retval.setBuiltin(( byte ) 4);
                retval.setOutlineStyleLevel(( byte ) 0xffffffff);
                break;

            case 3 :
                retval.setIndex(( short ) 0xffff8013);
                retval.setBuiltin(( byte ) 7);
                retval.setOutlineStyleLevel(( byte ) 0xffffffff);
                break;

            case 4 :
                retval.setIndex(( short ) 0xffff8000);
                retval.setBuiltin(( byte ) 0);
                retval.setOutlineStyleLevel(( byte ) 0xffffffff);
                break;

            case 5 :
                retval.setIndex(( short ) 0xffff8014);
                retval.setBuiltin(( byte ) 5);
                retval.setOutlineStyleLevel(( byte ) 0xffffffff);
                break;
        }
        return retval;
    }

    

    protected Record createUseSelFS()
    {
        UseSelFSRecord retval = new UseSelFSRecord();

        retval.setFlag(( short ) 0);
        return retval;
    }

    

    protected Record createBoundSheet(int id)
    {   
        BoundSheetRecord retval = new BoundSheetRecord();

        switch (id)
        {

            case 0 :
                retval.setPositionOfBof(0x0);   
                retval.setOptionFlags(( short ) 0);
                retval.setSheetnameLength(( byte ) 0x6);
                retval.setCompressedUnicodeFlag(( byte ) 0);
                retval.setSheetname(""Sheet1"");
                break;

            case 1 :
                retval.setPositionOfBof(0x0);   
                retval.setOptionFlags(( short ) 0);
                retval.setSheetnameLength(( byte ) 0x6);
                retval.setCompressedUnicodeFlag(( byte ) 0);
                retval.setSheetname(""Sheet2"");
                break;

            case 2 :
                retval.setPositionOfBof(0x0);   
                retval.setOptionFlags(( short ) 0);
                retval.setSheetnameLength(( byte ) 0x6);
                retval.setCompressedUnicodeFlag(( byte ) 0);
                retval.setSheetname(""Sheet3"");
                break;
        }
        return retval;
    }

    

    protected Record createCountry()
    {   
        CountryRecord retval = new CountryRecord();

        retval.setDefaultCountry(( short ) 1);
        retval.setCurrentCountry(( short ) 1);
        return retval;
    }

    

    protected Record createSST()
    {
        return new SSTRecord();
    }

    

    protected Record createExtendedSST()
    {
        ExtSSTRecord retval = new ExtSSTRecord();

        retval.setNumStringsPerBucket(( short ) 0x8);
        return retval;
    }

    

    protected Record createEOF()
    {
        return new EOFRecord();
    }

    

    public Record findFirstRecordBySid(short sid)
    {
        for (Iterator iterator = records.iterator(); iterator.hasNext(); )
        {
            Record record = ( Record ) iterator.next();

            if (record.getSid() == sid)
            {
                return record;
            }
        }
        return null;
    }
}
"
poi,1.5,org.apache.poi.poifs.property.DocumentProperty,7,2,0,6,14,9,5,2,5,0.5,48,1.0,1,0.848484848,0.342857143,0,0,5.714285714,1,0.7143,0,"


package org.apache.poi.poifs.property;

import org.apache.poi.poifs.filesystem.POIFSDocument;



public class DocumentProperty
    extends Property
{

    
    private POIFSDocument _document;

    

    public DocumentProperty(final String name, final int size)
    {
        super();
        _document = null;
        setName(name);
        setSize(size);
        setNodeColor(_NODE_BLACK);   
        setPropertyType(PropertyConstants.DOCUMENT_TYPE);
    }

    

    protected DocumentProperty(final int index, final byte [] array,
                               final int offset)
    {
        super(index, array, offset);
        _document = null;
    }

    

    public void setDocument(POIFSDocument doc)
    {
        _document = doc;
    }

    

    public POIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public boolean shouldUseSmallBlocks()
    {
        return super.shouldUseSmallBlocks();
    }

    

    public boolean isDirectory()
    {
        return false;
    }

    

    protected void preWrite()
    {

        
    }

    
}   

"
poi,1.5,org.apache.poi.hpsf.Util,6,1,0,2,8,15,2,0,6,1.2,137,0.0,0,0.0,0.333333333,0,0,21.66666667,4,2.0,4,"

package org.apache.poi.hpsf;

import java.util.*;


public class Util
{

    
    public static boolean equal(final byte[] a, final byte[] b)
    {
        if (a.length != b.length)
            return false;
        for (int i = 0; i < a.length; i++)
            if (a[i] != b[i])
                return false;
        return true;
    }



    
    public static void copy(final byte[] src, final int srcOffset,
                            final int length,
                            final byte[] dst, final int dstOffset)
    {
        for (int i = 0; i < length; i++)
            dst[dstOffset + i] = src[srcOffset + i];
    }



    
    public static byte[] cat(final byte[][] byteArrays)
    {
        int capacity = 0;
        for (int i = 0; i < byteArrays.length; i++)
            capacity += byteArrays[i].length;
        final byte[] result = new byte[capacity];
        int r = 0;
        for (int i = 0; i < byteArrays.length; i++)
            for (int j = 0; j < byteArrays[i].length; j++)
                result[r++] = byteArrays[i][j];
        return result;
    }



    
    public static byte[] copy(final byte[] src, final int offset,
                              final int length)
    {
        final byte[] result = new byte[length];
        copy(src, offset, length, result, 0);
        return result;
    }



    
    public final static long EPOCH_DIFF = 11644473600000L;

    
    public static Date filetimeToDate(final int high, final int low)
    {
        final long filetime = ((long) high) << 32 | ((long) low);
        final long ms_since_16010101 = filetime / (1000 * 10);
        final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF;
        return new Date(ms_since_19700101);
    }

}

"
poi,1.5,org.apache.poi.hpsf.littleendian.DWord,3,2,0,6,4,3,5,1,3,1.5,38,0.0,0,0.6,0.555555556,1,1,11.33333333,2,1.0,0,"

package org.apache.poi.hpsf.littleendian;


public class DWord extends LittleEndian
{

    
    public DWord(final byte[] src, final int offset)
    {
        super(src, offset);
    }



    public final static int LENGTH = 4;

    public int length()
    {
        return LENGTH;
    }



    
    public int intValue()
    {
        int value = 0;
        final int length = length();
        for (int i = 0; i < length; i++)
        {
            final int b = 0xFF & bytes[i];
            value = value << 8 | b;
        }
        return value;
    }

}
"
poi,1.5,org.apache.poi.poifs.storage.BATBlock,12,2,0,6,18,54,4,2,8,0.924242424,222,1.0,1,0.230769231,0.3125,1,2,17.0,5,1.3333,0,"


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;

import java.util.Arrays;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;



public class BATBlock
    extends BigBlock
{
    private static final int  _entries_per_block      =
        POIFSConstants.BIG_BLOCK_SIZE / LittleEndianConsts.INT_SIZE;
    private static final int  _entries_per_xbat_block = _entries_per_block
                                                            - 1;
    private static final int  _xbat_chain_offset      =
        _entries_per_xbat_block * LittleEndianConsts.INT_SIZE;
    private static final byte _default_value          = ( byte ) 0xFF;
    private IntegerField[]    _fields;
    private byte[]            _data;

    

    private BATBlock()
    {
        _data = new byte[ POIFSConstants.BIG_BLOCK_SIZE ];
        Arrays.fill(_data, _default_value);
        _fields = new IntegerField[ _entries_per_block ];
        int offset = 0;

        for (int j = 0; j < _entries_per_block; j++)
        {
            _fields[ j ] = new IntegerField(offset);
            offset       += LittleEndianConsts.INT_SIZE;
        }
    }

    

    public static BATBlock [] createBATBlocks(final int [] entries)
    {
        int        block_count = calculateStorageRequirements(entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        for (int j = 0; j < entries.length; j += _entries_per_block)
        {
            blocks[ index++ ] = new BATBlock(entries, j,
                                             (remaining > _entries_per_block)
                                             ? j + _entries_per_block
                                             : entries.length);
            remaining         -= _entries_per_block;
        }
        return blocks;
    }

    

    public static BATBlock [] createXBATBlocks(final int [] entries,
                                               final int startBlock)
    {
        int        block_count =
            calculateXBATStorageRequirements(entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        if (block_count != 0)
        {
            for (int j = 0; j < entries.length; j += _entries_per_xbat_block)
            {
                blocks[ index++ ] =
                    new BATBlock(entries, j,
                                 (remaining > _entries_per_xbat_block)
                                 ? j + _entries_per_xbat_block
                                 : entries.length);
                remaining         -= _entries_per_xbat_block;
            }
            for (index = 0; index < blocks.length - 1; index++)
            {
                blocks[ index ].setXBATChain(startBlock + index + 1);
            }
            blocks[ index ].setXBATChain(POIFSConstants.END_OF_CHAIN);
        }
        return blocks;
    }

    

    public static int calculateStorageRequirements(final int entryCount)
    {
        return (entryCount + _entries_per_block - 1) / _entries_per_block;
    }

    

    public static int calculateXBATStorageRequirements(final int entryCount)
    {
        return (entryCount + _entries_per_xbat_block - 1)
               / _entries_per_xbat_block;
    }

    

    public static final int entriesPerBlock()
    {
        return _entries_per_block;
    }

    

    public static final int entriesPerXBATBlock()
    {
        return _entries_per_xbat_block;
    }

    

    public static final int getXBATChainOffset()
    {
        return _xbat_chain_offset;
    }

    private void setXBATChain(int chainIndex)
    {
        _fields[ _entries_per_xbat_block ].set(chainIndex, _data);
    }

    

    private BATBlock(final int [] entries, final int start_index,
                     final int end_index)
    {
        this();
        for (int k = start_index; k < end_index; k++)
        {
            _fields[ k - start_index ].set(entries[ k ], _data);
        }
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        doWriteData(stream, _data);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.IndexRecord,17,2,0,6,38,104,2,4,15,0.883928571,293,0.0,1,0.44,0.485294118,1,6,15.82352941,2,1.1765,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.IntList;
import org.apache.poi.util.LittleEndian;



public class IndexRecord
    extends Record
{
    public final static short sid             = 0x20B;
    public final static int   DBCELL_CAPACITY = 30;
    public int                field_1_zero;            
    public int                field_2_first_row;       
    public int                field_3_last_row_add1;   
    public int                field_4_zero;            
    public IntList            field_5_dbcells;         

    public IndexRecord()
    {
    }

    

    public IndexRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public IndexRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An Index RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_5_dbcells       =
            new IntList(DBCELL_CAPACITY);   
        field_1_zero          = LittleEndian.getInt(data, 0 + offset);
        field_2_first_row     = LittleEndian.getInt(data, 4 + offset);
        field_3_last_row_add1 = LittleEndian.getInt(data, 8 + offset);
        field_4_zero          = LittleEndian.getInt(data, 12 + offset);
        for (int k = 16; k < size; k = k + 4)
        {

            
            field_5_dbcells.add(LittleEndian.getInt(data, k + offset));
        }
    }

    public void setFirstRow(int row)
    {
        field_2_first_row = row;
    }

    public void setLastRowAdd1(int row)
    {
        field_3_last_row_add1 = row;
    }

    public void addDbcell(int cell)
    {
        if (field_5_dbcells == null)
        {
            field_5_dbcells = new IntList();
        }
        field_5_dbcells.add(cell);
    }

    public void setDbcell(int cell, int value)
    {
        field_5_dbcells.set(cell, value);
    }

    public int getFirstRow()
    {
        return field_2_first_row;
    }

    public int getLastRowAdd1()
    {
        return field_3_last_row_add1;
    }

    public int getNumDbcells()
    {
        if (field_5_dbcells == null)
        {
            return 0;
        }
        return field_5_dbcells.size();
    }

    public int getDbcellAt(int cellnum)
    {
        return field_5_dbcells.get(cellnum);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[INDEX]
"");
        buffer.append(""    .firstrow       = "")
            .append(Integer.toHexString(getFirstRow())).append(""
"");
        buffer.append(""    .lastrowadd1    = "")
            .append(Integer.toHexString(getLastRowAdd1())).append(""
"");
        for (int k = 0; k < getNumDbcells(); k++)
        {
            buffer.append(""    .dbcell_"" + k + ""       = "")
                .append(Integer.toHexString(getDbcellAt(k))).append(""
"");
        }
        buffer.append(""[/INDEX]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) (16 + (getNumDbcells() * 4)));
        LittleEndian.putInt(data, 4 + offset, 0);
        LittleEndian.putInt(data, 8 + offset, getFirstRow());
        LittleEndian.putInt(data, 12 + offset, getLastRowAdd1());
        LittleEndian.putInt(data, 16 + offset, 0);
        for (int k = 0; k < getNumDbcells(); k++)
        {
            LittleEndian.putInt(data, (k * 4) + 20 + offset, getDbcellAt(k));
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 20 + (getNumDbcells() * 4);
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.LittleEndianConsts,0,1,0,1,0,0,1,0,0,2.0,5,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"


package org.apache.poi.util;



public interface LittleEndianConsts
{

    
    public static final int BYTE_SIZE   = 1;
    public static final int SHORT_SIZE  = 2;
    public static final int INT_SIZE    = 4;
    public static final int LONG_SIZE   = 8;
    public static final int DOUBLE_SIZE = 8;
}   

"
poi,1.5,org.apache.poi.dev.RecordGenerator,3,1,0,1,30,3,0,1,2,2.0,315,0.0,0,0.0,0.333333333,0,0,104.0,1,0.6667,1,"

package org.apache.poi.dev;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;

public class RecordGenerator
{
    public static void main(String[] args)
            throws Exception
    {
        
        Class.forName(""org.apache.poi.generator.FieldIterator"");

        if (args.length != 4)
        {
            System.out.println(""Usage:"");
            System.out.println(""  java org.apache.poi.hssf.util.RecordGenerator RECORD_DEFINTIONS RECORD_STYLES DEST_SRC_PATH TEST_SRC_PATH"");
        } else
        {
            generateRecords(args[0], args[1], args[2], args[3]);
        }
    }

    private static void generateRecords(String defintionsDir, String recordStyleDir, String destSrcPathDir, String testSrcPathDir)
            throws Exception
    {
        File definitionsFile = new File(defintionsDir);

        for (int i = 0; i < definitionsFile.listFiles().length; i++)
        {
            File file = definitionsFile.listFiles()[i];
            if (file.isFile() &&
                    (file.getName().endsWith(""_record.xml"") ||
                    file.getName().endsWith(""_type.xml"")
                    )
            )
            {
                
                DocumentBuilderFactory factory =
                        DocumentBuilderFactory.newInstance();
                DocumentBuilder builder = factory.newDocumentBuilder();
                Document document = builder.parse(file);
                Element record = document.getDocumentElement();
                String extendstg = record.getElementsByTagName(""extends"").item(0).getFirstChild().getNodeValue();
                String suffix = record.getElementsByTagName(""suffix"").item(0).getFirstChild().getNodeValue();
                String recordName = record.getAttributes().getNamedItem(""name"").getNodeValue();
                String packageName = record.getAttributes().getNamedItem(""package"").getNodeValue();
                packageName = packageName.replace('.', '/');

                
                String destinationPath = destSrcPathDir + ""/"" + packageName;
                File destinationPathFile = new File(destinationPath);
                destinationPathFile.mkdirs();
                String destinationFilepath = destinationPath + ""/"" + recordName + suffix + "".java"";
                String args[] = new String[]{""-in"", file.getAbsolutePath(), ""-xsl"", recordStyleDir + ""/"" + extendstg.toLowerCase() + "".xsl"",
                                             ""-out"", destinationFilepath,
                                             ""-TEXT""};

                org.apache.xalan.xslt.Process.main(args);
                System.out.println(""Generated "" + suffix + "": "" + destinationFilepath);

                
                destinationPath = testSrcPathDir + ""/"" + packageName;
                destinationPathFile = new File(destinationPath);
                destinationPathFile.mkdirs();
                destinationFilepath = destinationPath + ""/Test"" + recordName + suffix + "".java"";
                if (new File(destinationFilepath).exists() == false)
                {
                    String temp = (recordStyleDir + ""/"" + extendstg.toLowerCase() + ""_test.xsl"");
                    args = new String[]{""-in"", file.getAbsolutePath(), ""-xsl"",
                                        temp,
                                        ""-out"", destinationFilepath,
                                        ""-TEXT""};
                    org.apache.xalan.xslt.Process.main(args);
                    System.out.println(""Generated test: "" + destinationFilepath);
                } else
                {
                    System.out.println(""Skipped test generation: "" + destinationFilepath);
                }
            }
        }
    }
}
"
poi,1.5,org.apache.poi.util.ShortList,25,1,0,0,29,0,0,0,24,0.388888889,629,1.0,0,0.0,0.313333333,1,1,24.04,9,2.6,0,"


package org.apache.poi.util;

import java.util.*;



public class ShortList
{
    private short[]          _array;
    private int              _limit;
    private static final int _default_size = 128;

    

    public ShortList()
    {
        this(_default_size);
    }

    

    public ShortList(final ShortList list)
    {
        this(list._array.length);
        System.arraycopy(list._array, 0, _array, 0, _array.length);
        _limit = list._limit;
    }

    

    public ShortList(final int initialCapacity)
    {
        _array = new short[ initialCapacity ];
        _limit = 0;
    }

    

    public void add(final int index, final short value)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (index == _limit)
        {
            add(value);
        }
        else
        {

            
            if (_limit == _array.length)
            {
                growArray(_limit * 2);
            }
            System.arraycopy(_array, index, _array, index + 1,
                             _limit - index);
            _array[ index ] = value;
            _limit++;
        }
    }

    

    public boolean add(final short value)
    {
        if (_limit == _array.length)
        {
            growArray(_limit * 2);
        }
        _array[ _limit++ ] = value;
        return true;
    }

    

    public boolean addAll(final ShortList c)
    {
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }
            System.arraycopy(c._array, 0, _array, _limit, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public boolean addAll(final int index, final ShortList c)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }

            
            System.arraycopy(_array, index, _array, index + c._limit,
                             _limit - index);

            
            System.arraycopy(c._array, 0, _array, index, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public void clear()
    {
        _limit = 0;
    }

    

    public boolean contains(final short o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (_array[ j ] == o)
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean containsAll(final ShortList c)
    {
        boolean rval = true;

        if (this != c)
        {
            for (int j = 0; rval && (j < c._limit); j++)
            {
                if (!contains(c._array[ j ]))
                {
                    rval = false;
                }
            }
        }
        return rval;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = this == o;

        if (!rval && (o != null) && (o.getClass() == this.getClass()))
        {
            ShortList other = ( ShortList ) o;

            if (other._limit == _limit)
            {

                
                rval = true;
                for (int j = 0; rval && (j < _limit); j++)
                {
                    rval = _array[ j ] == other._array[ j ];
                }
            }
        }
        return rval;
    }

    

    public short get(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        return _array[ index ];
    }

    

    public int hashCode()
    {
        int hash = 0;

        for (int j = 0; j < _limit; j++)
        {
            hash = (31 * hash) + _array[ j ];
        }
        return hash;
    }

    

    public int indexOf(final short o)
    {
        int rval = 0;

        for (; rval < _limit; rval++)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        if (rval == _limit)
        {
            rval = -1;   
        }
        return rval;
    }

    

    public boolean isEmpty()
    {
        return _limit == 0;
    }

    

    public int lastIndexOf(final short o)
    {
        int rval = _limit - 1;

        for (; rval >= 0; rval--)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        return rval;
    }

    

    public short remove(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        short rval = _array[ index ];

        System.arraycopy(_array, index + 1, _array, index, _limit - index);
        _limit--;
        return rval;
    }

    

    public boolean removeValue(final short o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (o == _array[ j ])
            {
                System.arraycopy(_array, j + 1, _array, j, _limit - j);
                _limit--;
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean removeAll(final ShortList c)
    {
        boolean rval = false;

        for (int j = 0; j < c._limit; j++)
        {
            if (removeValue(c._array[ j ]))
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean retainAll(final ShortList c)
    {
        boolean rval = false;

        for (int j = 0; j < _limit; )
        {
            if (!c.contains(_array[ j ]))
            {
                remove(j);
                rval = true;
            }
            else
            {
                j++;
            }
        }
        return rval;
    }

    

    public short set(final int index, final short element)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        short rval = _array[ index ];

        _array[ index ] = element;
        return rval;
    }

    

    public int size()
    {
        return _limit;
    }

    

    public short [] toArray()
    {
        short[] rval = new short[ _limit ];

        System.arraycopy(_array, 0, rval, 0, _limit);
        return rval;
    }

    

    public short [] toArray(final short [] a)
    {
        short[] rval;

        if (a.length == _limit)
        {
            System.arraycopy(_array, 0, a, 0, _limit);
            rval = a;
        }
        else
        {
            rval = toArray();
        }
        return rval;
    }

    private void growArray(final int new_size)
    {
        int     size      = (new_size == _array.length) ? new_size + 1
                                                        : new_size;
        short[] new_array = new short[ size ];

        System.arraycopy(_array, 0, new_array, 0, _limit);
        _array = new_array;
    }
}   

"
poi,1.5,org.apache.poi.hpsf.PropertySetFactory,2,1,0,6,8,1,0,6,2,2.0,28,0.0,0,0.0,0.5,0,0,13.0,1,0.5,2,"

package org.apache.poi.hpsf;

import java.io.*;


public class PropertySetFactory
{

    
    public static PropertySet create(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               UnexpectedPropertySetTypeException, IOException
    {
        final PropertySet ps = new PropertySet(stream);
        if (ps.isSummaryInformation())
            return new SummaryInformation(ps);
        else if (ps.isDocumentSummaryInformation())
            return new DocumentSummaryInformation(ps);
        else
            return ps;
    }

}
"
poi,1.5,org.apache.poi.hssf.record.CellValueRecordInterface,9,1,0,12,9,36,12,0,9,2.0,9,0.0,0,0.0,0.555555556,0,0,0.0,1,1.0,1,"



package org.apache.poi.hssf.record;



public interface CellValueRecordInterface
{

    

    public short getRow();

    

    public short getColumn();

    

    public void setRow(short row);

    

    public void setColumn(short col);

    public void setXFIndex(short xf);

    public short getXFIndex();

    

    public boolean isBefore(CellValueRecordInterface i);

    

    public boolean isAfter(CellValueRecordInterface i);

    

    public boolean isEqual(CellValueRecordInterface i);
}
"
poi,1.5,org.apache.poi.hssf.record.DateWindow1904Record,11,2,0,5,21,49,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class DateWindow1904Record
    extends Record
{
    public final static short sid = 0x22;
    private short             field_1_window;

    public DateWindow1904Record()
    {
    }

    

    public DateWindow1904Record(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DateWindow1904Record(short id, short size, byte [] data,
                                int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A 1904 RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_window = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setWindowing(short window)
    {   
        field_1_window = window;
    }

    

    public short getWindowing()
    {
        return field_1_window;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[1904]
"");
        buffer.append(""    .is1904          = "")
            .append(Integer.toHexString(getWindowing())).append(""
"");
        buffer.append(""[/1904]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getWindowing());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.RefreshAllRecord,11,2,0,5,21,43,2,3,9,0.85,116,0.5,0,0.578947368,0.418181818,1,6,9.363636364,2,1.0,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class RefreshAllRecord
    extends Record
{
    public final static short sid = 0x1B7;
    private short             field_1_refreshall;

    public RefreshAllRecord()
    {
    }

    

    public RefreshAllRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public RefreshAllRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A REFRESHALL RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_refreshall = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setRefreshAll(boolean refreshall)
    {
        if (refreshall)
        {
            field_1_refreshall = 1;
        }
        else
        {
            field_1_refreshall = 0;
        }
    }

    

    public boolean getRefreshAll()
    {
        return (field_1_refreshall == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[REFRESHALL]
"");
        buffer.append(""    .refreshall      = "").append(getRefreshAll())
            .append(""
"");
        buffer.append(""[/REFRESHALL]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, field_1_refreshall);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.IntList,25,1,0,4,29,0,4,0,24,0.388888889,629,1.0,0,0.0,0.36,1,1,24.04,9,2.6,0,"


package org.apache.poi.util;

import java.util.*;



public class IntList
{
    private int[]            _array;
    private int              _limit;
    private static final int _default_size = 128;

    

    public IntList()
    {
        this(_default_size);
    }

    

    public IntList(final IntList list)
    {
        this(list._array.length);
        System.arraycopy(list._array, 0, _array, 0, _array.length);
        _limit = list._limit;
    }

    

    public IntList(final int initialCapacity)
    {
        _array = new int[ initialCapacity ];
        _limit = 0;
    }

    

    public void add(final int index, final int value)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (index == _limit)
        {
            add(value);
        }
        else
        {

            
            if (_limit == _array.length)
            {
                growArray(_limit * 2);
            }
            System.arraycopy(_array, index, _array, index + 1,
                             _limit - index);
            _array[ index ] = value;
            _limit++;
        }
    }

    

    public boolean add(final int value)
    {
        if (_limit == _array.length)
        {
            growArray(_limit * 2);
        }
        _array[ _limit++ ] = value;
        return true;
    }

    

    public boolean addAll(final IntList c)
    {
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }
            System.arraycopy(c._array, 0, _array, _limit, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public boolean addAll(final int index, final IntList c)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }

            
            System.arraycopy(_array, index, _array, index + c._limit,
                             _limit - index);

            
            System.arraycopy(c._array, 0, _array, index, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public void clear()
    {
        _limit = 0;
    }

    

    public boolean contains(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (_array[ j ] == o)
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean containsAll(final IntList c)
    {
        boolean rval = true;

        if (this != c)
        {
            for (int j = 0; rval && (j < c._limit); j++)
            {
                if (!contains(c._array[ j ]))
                {
                    rval = false;
                }
            }
        }
        return rval;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = this == o;

        if (!rval && (o != null) && (o.getClass() == this.getClass()))
        {
            IntList other = ( IntList ) o;

            if (other._limit == _limit)
            {

                
                rval = true;
                for (int j = 0; rval && (j < _limit); j++)
                {
                    rval = _array[ j ] == other._array[ j ];
                }
            }
        }
        return rval;
    }

    

    public int get(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        return _array[ index ];
    }

    

    public int hashCode()
    {
        int hash = 0;

        for (int j = 0; j < _limit; j++)
        {
            hash = (31 * hash) + _array[ j ];
        }
        return hash;
    }

    

    public int indexOf(final int o)
    {
        int rval = 0;

        for (; rval < _limit; rval++)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        if (rval == _limit)
        {
            rval = -1;   
        }
        return rval;
    }

    

    public boolean isEmpty()
    {
        return _limit == 0;
    }

    

    public int lastIndexOf(final int o)
    {
        int rval = _limit - 1;

        for (; rval >= 0; rval--)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        return rval;
    }

    

    public int remove(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        System.arraycopy(_array, index + 1, _array, index, _limit - index);
        _limit--;
        return rval;
    }

    

    public boolean removeValue(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (o == _array[ j ])
            {
                System.arraycopy(_array, j + 1, _array, j, _limit - j);
                _limit--;
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean removeAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < c._limit; j++)
        {
            if (removeValue(c._array[ j ]))
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean retainAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < _limit; )
        {
            if (!c.contains(_array[ j ]))
            {
                remove(j);
                rval = true;
            }
            else
            {
                j++;
            }
        }
        return rval;
    }

    

    public int set(final int index, final int element)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        _array[ index ] = element;
        return rval;
    }

    

    public int size()
    {
        return _limit;
    }

    

    public int [] toArray()
    {
        int[] rval = new int[ _limit ];

        System.arraycopy(_array, 0, rval, 0, _limit);
        return rval;
    }

    

    public int [] toArray(final int [] a)
    {
        int[] rval;

        if (a.length == _limit)
        {
            System.arraycopy(_array, 0, a, 0, _limit);
            rval = a;
        }
        else
        {
            rval = toArray();
        }
        return rval;
    }

    private void growArray(final int new_size)
    {
        int   size      = (new_size == _array.length) ? new_size + 1
                                                      : new_size;
        int[] new_array = new int[ size ];

        System.arraycopy(_array, 0, new_array, 0, _limit);
        _array = new_array;
    }
}   

"
poi,1.5,org.apache.poi.hssf.util.Region,16,1,0,3,17,78,2,1,16,0.533333333,172,1.0,0,0.0,0.291666667,0,0,9.5,9,1.625,0,"


package org.apache.poi.hssf.util;

import org.apache.poi.hssf.record.MergeCellsRecord.MergedRegion;



public class Region
    implements Comparable
{
    private int   rowFrom;
    private short colFrom;
    private int   rowTo;
    private short colTo;

    

    public Region()
    {
    }

    public Region(int rowFrom, short colFrom, int rowTo, short colTo)
    {
        this.rowFrom = rowFrom;
        this.rowTo   = rowTo;
        this.colFrom = colFrom;
        this.colTo   = colTo;
    }

    

    public Region(MergedRegion region)
    {
        this(region.row_from, region.col_from, region.row_to, region.col_to);
    }

    

    public short getColumnFrom()
    {
        return colFrom;
    }

    

    public int getRowFrom()
    {
        return rowFrom;
    }

    

    public short getColumnTo()
    {
        return colTo;
    }

    

    public int getRowTo()
    {
        return rowTo;
    }

    

    public void setColumnFrom(short colFrom)
    {
        this.colFrom = colFrom;
    }

    

    public void setRowFrom(int rowFrom)
    {
        this.rowFrom = rowFrom;
    }

    

    public void setColumnTo(short colTo)
    {
        this.colTo = colTo;
    }

    

    public void setRowTo(int rowTo)
    {
        this.rowTo = rowTo;
    }

    

    public boolean contains(int row, short col)
    {
        if ((this.rowFrom <= row) && (this.rowTo >= row)
                && (this.colFrom <= col) && (this.colTo >= col))
        {



            return true;
        }
        return false;
    }

    public boolean equals(Region r)
    {
        return (compareTo(r) == 0);
    }

    

    public int compareTo(Region r)
    {
        if ((this.getRowFrom() == r.getRowFrom())
                && (this.getColumnFrom() == r.getColumnFrom())
                && (this.getRowTo() == r.getRowTo())
                && (this.getColumnTo() == r.getColumnTo()))
        {
            return 0;
        }
        if ((this.getRowFrom() < r.getRowFrom())
                || (this.getColumnFrom() < r.getColumnFrom())
                || (this.getRowTo() < r.getRowTo())
                || (this.getColumnTo() < r.getColumnTo()))
        {
            return 1;
        }
        return -1;
    }

    public int compareTo(Object o)
    {
        return compareTo(( Region ) o);
    }

    

    public int getArea()
    {
        return ((1 + (getRowTo() - getRowFrom()))
                * (1 + (getColumnTo() - getColumnFrom())));
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.FormulaUtil,20,1,0,8,39,190,1,7,13,2.0,433,0.0,0,0.0,0.2,0,0,20.65,6,1.7,0,"



package org.apache.poi.hssf.record.formula;



public class FormulaUtil
{

    

    public FormulaUtil()
    {
    }

    public static Ptg [] parseFormula(String formula)
    {
        Ptg[]        ptg = null;
        StringBuffer f   = new StringBuffer(formula);

        if (isIntAddition(formula))
        {
            int loc = getLoc(formula, '+');

            System.out.println(formula.substring(0, loc).trim() + "",""
                               + formula.substring(loc + 1,
                                                   formula.length()).trim());
            ptg = formulaAddTwoInts(Short
                .parseShort(formula.substring(0, loc).trim()), Short
                .parseShort(formula.substring(loc + 1, formula.length())
                    .trim()));
        }
        else if (isIntSubtraction(formula))
        {
            int loc = getLoc(formula, '-');

            ptg = formulaSubtractTwoInts(Short
                .parseShort(formula.substring(0, loc).trim()), Short
                .parseShort(formula.substring(loc + 1, formula.length())
                    .trim()));
        }
        else if (isIntMultiplication(formula))
        {
            int loc = getLoc(formula, '*');

            ptg = formulaMultiplyTwoInts(Short
                .parseShort(formula.substring(0, loc).trim()), Short
                .parseShort(formula.substring(loc + 1, formula.length())
                    .trim()));
        }
        else if (isIntDivision(formula))
        {
            int loc = getLoc(formula, '/');

            ptg = formulaDivideTwoInts(Short
                .parseShort(formula.substring(0, loc).trim()), Short
                .parseShort(formula.substring(loc + 1, formula.length())
                    .trim()));
        }
        else if (isIntPower(formula))
        {
            int loc = getLoc(formula, '^');

            ptg = formulaPowerTwoInts(Short
                .parseShort(formula.substring(0, loc).trim()), Short
                .parseShort(formula.substring(loc + 1, formula.length())
                    .trim()));
        }
        return ptg;
    }

    public static Ptg [] formulaAddTwoInts(short first, short second)
    {
        Ptg[] ptg = new Ptg[ 3 ];

        ptg[ 0 ] = createInteger(first);
        ptg[ 1 ] = createInteger(second);
        ptg[ 2 ] = createAdd();
        return ptg;
    }

    public static Ptg [] formulaSubtractTwoInts(short first, short second)
    {
        Ptg[] ptg = new Ptg[ 3 ];

        ptg[ 0 ] = createInteger(first);
        ptg[ 1 ] = createInteger(second);
        ptg[ 2 ] = createSubtract();
        return ptg;
    }

    public static Ptg [] formulaMultiplyTwoInts(short first, short second)
    {
        Ptg[] ptg = new Ptg[ 3 ];

        ptg[ 0 ] = createInteger(first);
        ptg[ 1 ] = createInteger(second);
        ptg[ 2 ] = createMultiply();
        return ptg;
    }

    public static Ptg [] formulaPowerTwoInts(short first, short second)
    {
        Ptg[] ptg = new Ptg[ 3 ];

        ptg[ 0 ] = createInteger(second);
        ptg[ 1 ] = createInteger(first);
        ptg[ 2 ] = createPower();
        return ptg;
    }

    public static Ptg [] formulaDivideTwoInts(short first, short second)
    {
        Ptg[] ptg = new Ptg[ 3 ];

        ptg[ 0 ] = createInteger(first);
        ptg[ 1 ] = createInteger(second);
        ptg[ 2 ] = createDivide();
        return ptg;
    }

    public static Ptg createInteger(short value)
    {
        IntPtg ptg = new IntPtg();

        ptg.setValue(value);
        return ptg;
    }

    public static Ptg createAdd()
    {
        AddPtg ptg = new AddPtg();

        return ptg;
    }

    public static Ptg createSubtract()
    {
        SubtractPtg ptg = new SubtractPtg();

        return ptg;
    }

    public static Ptg createMultiply()
    {
        MultiplyPtg ptg = new MultiplyPtg();

        return ptg;
    }

    public static Ptg createDivide()
    {
        DividePtg ptg = new DividePtg();

        return ptg;
    }

    public static Ptg createPower()
    {
        PowerPtg ptg = new PowerPtg();

        return ptg;
    }

    private static boolean isIntAddition(String formula)
    {
        StringBuffer buffer = new StringBuffer(formula);

        if (instr(formula, ""+""))
        {
            return true;
        }
        return false;
    }

    private static boolean isIntSubtraction(String formula)
    {
        StringBuffer buffer = new StringBuffer(formula);

        if (instr(formula, ""-""))
        {
            return true;
        }
        return false;
    }

    private static boolean isIntMultiplication(String formula)
    {
        StringBuffer buffer = new StringBuffer(formula);

        if (instr(formula, ""*""))
        {
            return true;
        }
        return false;
    }

    private static boolean isIntDivision(String formula)
    {
        StringBuffer buffer = new StringBuffer(formula);

        if (instr(formula, ""/""))
        {
            return true;
        }
        return false;
    }

    private static boolean isIntPower(String formula)
    {
        StringBuffer buffer = new StringBuffer(formula);

        if (instr(formula, ""^""))
        {
            return true;
        }
        return false;
    }

    private static boolean instr(String matchin, String matchon)
    {
        int lenmatchin = matchin.length();
        int lenmatchon = matchon.length();
        int pos        = 0;

        if (lenmatchon > lenmatchin)
        {
            return false;
        }
        while (pos + lenmatchon < lenmatchin)
        {
            String sub = matchin.substring(pos, pos + lenmatchon);

            if (sub.equals(matchon))
            {
                return true;
            }
            pos++;
        }
        return false;
    }

    private static int getLoc(String matchin, char matchon)
    {
        int retval = -1;

        for (int pos = 0; pos < matchin.length(); pos++)
        {
            if (matchin.charAt(pos) == matchon)
            {
                retval = pos;
                break;
            }
        }
        return retval;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.BlankRecord,22,2,0,8,34,213,4,4,20,0.75,330,0.75,0,0.366666667,0.310606061,1,6,13.81818182,7,1.8636,1,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class BlankRecord
    extends Record
    implements CellValueRecordInterface, Comparable
{
    public final static short sid = 0x201;
    private short             field_1_row;
    private short             field_2_col;
    private short             field_3_xf;

    

    public BlankRecord()
    {
    }

    

    public BlankRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BlankRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row = LittleEndian.getShort(data, 0 + offset);
        field_2_col = LittleEndian.getShort(data, 2 + offset);
        field_3_xf  = LittleEndian.getShort(data, 4 + offset);
    }

    

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A BLANKRECORD!"");
        }
    }

    

    public void setRow(short row)
    {
        field_1_row = row;
    }

    

    public short getRow()
    {
        return field_1_row;
    }

    

    public short getColumn()
    {
        return field_2_col;
    }

    

    public void setXFIndex(short xf)
    {
        field_3_xf = xf;
    }

    

    public short getXFIndex()
    {
        return field_3_xf;
    }

    

    public void setColumn(short col)
    {
        field_2_col = col;
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    

    public short getSid()
    {
        return BlankRecord.sid;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BLANK]
"");
        buffer.append(""row       = "").append(Integer.toHexString(getRow()))
            .append(""
"");
        buffer.append(""col       = "").append(Integer.toHexString(getColumn()))
            .append(""
"");
        buffer.append(""xf        = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        buffer.append(""[/BLANK]
"");
        return buffer.toString();
    }

    

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 6);
        LittleEndian.putShort(data, 4 + offset, getRow());
        LittleEndian.putShort(data, 6 + offset, getColumn());
        LittleEndian.putShort(data, 8 + offset, getXFIndex());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 10;
    }

    public int compareTo(Object obj)
    {
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return 0;
        }
        if (this.getRow() < loc.getRow())
        {
            return -1;
        }
        if (this.getRow() > loc.getRow())
        {
            return 1;
        }
        if (this.getColumn() < loc.getColumn())
        {
            return -1;
        }
        if (this.getColumn() > loc.getColumn())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof CellValueRecordInterface))
        {
            return false;
        }
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.DeltaRecord,11,2,0,5,22,49,2,3,9,0.933333333,106,0.333333333,0,0.578947368,0.418181818,1,6,8.363636364,2,0.8182,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class DeltaRecord
    extends Record
{
    public final static short  sid           = 0x10;
    public final static double DEFAULT_VALUE = 0.0010;   

    
    
    private double             field_1_max_change;

    public DeltaRecord()
    {
    }

    

    public DeltaRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DeltaRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A DELTA RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_max_change = LittleEndian.getDouble(data, 0 + offset);
    }

    

    public void setMaxChange(double maxChange)
    {
        field_1_max_change = maxChange;
    }

    

    public double getMaxChange()
    {
        return field_1_max_change;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DELTA]
"");
        buffer.append(""    .maxchange      = "").append(getMaxChange())
            .append(""
"");
        buffer.append(""[/DELTA]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x8);
        LittleEndian.putDouble(data, 4 + offset, getMaxChange());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 12;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.LinkedDataRecord,21,2,0,6,38,122,1,5,19,0.94,334,0.4,1,0.379310345,0.301587302,1,6,14.19047619,2,0.9048,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class LinkedDataRecord
    extends Record
{
    public final static short      sid                             = 0x1051;
    private  byte       field_1_linkType;
    public final static byte        LINK_TYPE_TITLE_OR_TEXT        = 0;
    public final static byte        LINK_TYPE_VALUES               = 1;
    public final static byte        LINK_TYPE_CATEGORIES           = 1;
    private  byte       field_2_referenceType;
    public final static byte        REFERENCE_TYPE_DEFAULT_CATEGORIES = 0;
    public final static byte        REFERENCE_TYPE_DIRECT          = 1;
    public final static byte        REFERENCE_TYPE_WORKSHEET       = 2;
    public final static byte        REFERENCE_TYPE_NOT_USED        = 3;
    public final static byte        REFERENCE_TYPE_ERROR_REPORTED  = 4;
    private  short      field_3_options;
    private BitField   customNumberFormat                         = new BitField(0x1);
    private  short      field_4_indexNumberFmtRecord;
    private  short      field_5_formulaOfLink;


    public LinkedDataRecord()
    {

    }

    

    public LinkedDataRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public LinkedDataRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a LinkedData record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_linkType                = data[ 0x0 + offset ];
        field_2_referenceType           = data[ 0x1 + offset ];
        field_3_options                 = LittleEndian.getShort(data, 0x2 + offset);
        field_4_indexNumberFmtRecord    = LittleEndian.getShort(data, 0x4 + offset);
        field_5_formulaOfLink           = LittleEndian.getShort(data, 0x6 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[LinkedData]
"");

        buffer.append(""    .linkType             = "")
            .append(""0x"")
            .append(HexDump.toHex((byte)getLinkType()))
            .append("" ("").append(getLinkType()).append("" )
"");

        buffer.append(""    .referenceType        = "")
            .append(""0x"")
            .append(HexDump.toHex((byte)getReferenceType()))
            .append("" ("").append(getReferenceType()).append("" )
"");

        buffer.append(""    .options              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getOptions()))
            .append("" ("").append(getOptions()).append("" )
"");
        buffer.append(""         .customNumberFormat       = "").append(isCustomNumberFormat  ()).append('
');

        buffer.append(""    .indexNumberFmtRecord = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getIndexNumberFmtRecord()))
            .append("" ("").append(getIndexNumberFmtRecord()).append("" )
"");

        buffer.append(""    .formulaOfLink        = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormulaOfLink()))
            .append("" ("").append(getFormulaOfLink()).append("" )
"");

        buffer.append(""[/LinkedData]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        data[ 4 + offset ] = field_1_linkType;
        data[ 5 + offset ] = field_2_referenceType;
        LittleEndian.putShort(data, 6 + offset, field_3_options);
        LittleEndian.putShort(data, 8 + offset, field_4_indexNumberFmtRecord);
        LittleEndian.putShort(data, 10 + offset, field_5_formulaOfLink);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 1 + 1 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public byte getLinkType()
    {
        return field_1_linkType;
    }

    
    public void setLinkType(byte field_1_linkType)
    {
        this.field_1_linkType = field_1_linkType;
    }

    
    public byte getReferenceType()
    {
        return field_2_referenceType;
    }

    
    public void setReferenceType(byte field_2_referenceType)
    {
        this.field_2_referenceType = field_2_referenceType;
    }

    
    public short getOptions()
    {
        return field_3_options;
    }

    
    public void setOptions(short field_3_options)
    {
        this.field_3_options = field_3_options;
    }

    
    public short getIndexNumberFmtRecord()
    {
        return field_4_indexNumberFmtRecord;
    }

    
    public void setIndexNumberFmtRecord(short field_4_indexNumberFmtRecord)
    {
        this.field_4_indexNumberFmtRecord = field_4_indexNumberFmtRecord;
    }

    
    public short getFormulaOfLink()
    {
        return field_5_formulaOfLink;
    }

    
    public void setFormulaOfLink(short field_5_formulaOfLink)
    {
        this.field_5_formulaOfLink = field_5_formulaOfLink;
    }

    
    public void setCustomNumberFormat(boolean value)
    {
        field_3_options = customNumberFormat.setShortBoolean(field_3_options, value);
    }

    
    public boolean isCustomNumberFormat()
    {
        return customNumberFormat.isSet(field_3_options);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.AxisRecord,19,2,0,4,33,119,0,4,17,0.901234568,284,0.555555556,0,0.407407407,0.460526316,1,6,13.47368421,2,0.8947,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class AxisRecord
    extends Record
{
    public final static short      sid                             = 0x101d;
    private  short      field_1_axisType;
    public final static short       AXIS_TYPE_CATEGORY_OR_X_AXIS   = 0;
    public final static short       AXIS_TYPE_VALUE_AXIS           = 1;
    public final static short       AXIS_TYPE_SERIES_AXIS          = 2;
    private  int        field_2_reserved1;
    private  int        field_3_reserved2;
    private  int        field_4_reserved3;
    private  int        field_5_reserved4;


    public AxisRecord()
    {

    }

    

    public AxisRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public AxisRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Axis record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_axisType                = LittleEndian.getShort(data, 0x0 + offset);
        field_2_reserved1               = LittleEndian.getInt(data, 0x2 + offset);
        field_3_reserved2               = LittleEndian.getInt(data, 0x6 + offset);
        field_4_reserved3               = LittleEndian.getInt(data, 0xa + offset);
        field_5_reserved4               = LittleEndian.getInt(data, 0xe + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Axis]
"");

        buffer.append(""    .axisType             = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getAxisType()))
            .append("" ("").append(getAxisType()).append("" )
"");

        buffer.append(""    .reserved1            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getReserved1()))
            .append("" ("").append(getReserved1()).append("" )
"");

        buffer.append(""    .reserved2            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getReserved2()))
            .append("" ("").append(getReserved2()).append("" )
"");

        buffer.append(""    .reserved3            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getReserved3()))
            .append("" ("").append(getReserved3()).append("" )
"");

        buffer.append(""    .reserved4            = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getReserved4()))
            .append("" ("").append(getReserved4()).append("" )
"");

        buffer.append(""[/Axis]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_axisType);
        LittleEndian.putInt(data, 6 + offset, field_2_reserved1);
        LittleEndian.putInt(data, 10 + offset, field_3_reserved2);
        LittleEndian.putInt(data, 14 + offset, field_4_reserved3);
        LittleEndian.putInt(data, 18 + offset, field_5_reserved4);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 4 + 4 + 4 + 4;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getAxisType()
    {
        return field_1_axisType;
    }

    
    public void setAxisType(short field_1_axisType)
    {
        this.field_1_axisType = field_1_axisType;
    }

    
    public int getReserved1()
    {
        return field_2_reserved1;
    }

    
    public void setReserved1(int field_2_reserved1)
    {
        this.field_2_reserved1 = field_2_reserved1;
    }

    
    public int getReserved2()
    {
        return field_3_reserved2;
    }

    
    public void setReserved2(int field_3_reserved2)
    {
        this.field_3_reserved2 = field_3_reserved2;
    }

    
    public int getReserved3()
    {
        return field_4_reserved3;
    }

    
    public void setReserved3(int field_4_reserved3)
    {
        this.field_4_reserved3 = field_4_reserved3;
    }

    
    public int getReserved4()
    {
        return field_5_reserved4;
    }

    
    public void setReserved4(int field_5_reserved4)
    {
        this.field_5_reserved4 = field_5_reserved4;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.ExtSSTInfoSubRecord,13,2,0,3,24,64,1,2,11,0.833333333,144,0.75,0,0.523809524,0.5,1,6,9.769230769,1,0.7692,2,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class ExtSSTInfoSubRecord
    extends Record
{
    public final static short sid =
        0xFFF;                                             
    private int               field_1_stream_pos;          
    private short             field_2_bucket_sst_offset;   
    private short             field_3_zero;                

    

    public ExtSSTInfoSubRecord()
    {
    }

    public ExtSSTInfoSubRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    public ExtSSTInfoSubRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {

        
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_stream_pos        = LittleEndian.getInt(data, 0 + offset);
        field_2_bucket_sst_offset = LittleEndian.getShort(data, 4 + offset);
        field_3_zero              = LittleEndian.getShort(data, 6 + offset);
    }

    public void setStreamPos(int pos)
    {
        field_1_stream_pos = pos;
    }

    public void setBucketSSTOffset(short offset)
    {
        field_2_bucket_sst_offset = offset;
    }

    public int getStreamPos()
    {
        return field_1_stream_pos;
    }

    public short getBucketSSTOffset()
    {
        return field_2_bucket_sst_offset;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EXTSST]
"");
        buffer.append(""    .streampos      = "")
            .append(Integer.toHexString(getStreamPos())).append(""
"");
        buffer.append(""    .bucketsstoffset= "")
            .append(Integer.toHexString(getBucketSSTOffset())).append(""
"");
        buffer.append(""    .zero           = "")
            .append(Integer.toHexString(field_3_zero)).append(""
"");
        buffer.append(""[/EXTSST]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putInt(data, 0 + offset, getStreamPos());
        LittleEndian.putShort(data, 4 + offset, getBucketSSTOffset());
        LittleEndian.putShort(data, 6 + offset, ( short ) 0);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 8;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.ShortField,11,1,0,5,21,9,2,3,11,0.25,92,1.0,0,0.0,0.454545455,0,0,7.181818182,1,0.6364,0,"


package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class ShortField
    implements FixedField
{
    private short     _value;
    private final int _offset;

    

    public ShortField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(""Illegal offset: ""
                                                     + offset);
        }
        _offset = offset;
    }

    

    public ShortField(final int offset, final short value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public ShortField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ShortField(final int offset, final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public short get()
    {
        return _value;
    }

    

    public void set(final short value)
    {
        _value = value;
    }

    

    public void set(final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getShort(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readShort(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putShort(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,1.5,org.apache.poi.poifs.common.POIFSConstants,0,1,0,0,0,0,0,0,0,2.0,4,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.poi.poifs.common;



public interface POIFSConstants
{
    public static final int BIG_BLOCK_SIZE = 0x0200;
    public static final int END_OF_CHAIN   = -2;
    public static final int PROPERTY_SIZE  = 0x0080;
    public static final int UNUSED_BLOCK   = -1;
}   
"
poi,1.5,org.apache.poi.poifs.property.Child,4,1,0,3,4,6,3,0,4,2.0,4,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.property;



public interface Child
{

    

    public Child getNextChild();

    

    public Child getPreviousChild();

    

    public void setNextChild(final Child child);

    

    public void setPreviousChild(final Child child);
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.SubtractPtg,8,2,0,4,13,28,3,2,8,1.142857143,56,0.0,0,0.538461538,0.40625,1,2,5.75,1,0.75,4,"



package org.apache.poi.hssf.record.formula;



public class SubtractPtg
    extends Ptg
    implements OperationPtg
{
    public final static int  SIZE = 1;
    public final static byte sid  = 0x04;

    

    public SubtractPtg()
    {
    }

    public SubtractPtg(byte [] data, int offset)
    {

        
    }

    public void writeBytes(byte [] array, int offset)
    {
        array[ offset + 0 ] = sid;
    }

    public int getSize()
    {
        return SIZE;
    }

    public int getType()
    {
        return TYPE_BINARY;
    }

    public int getNumberOfOperands()
    {
        return 2;
    }

    public String toFormulaString()
    {
        return ""-"";
    }

    public String toFormulaString(Ptg [] operands)
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(operands[ 0 ].toFormulaString());
        buffer.append(""-"");
        buffer.append(operands[ 1 ].toFormulaString());
        return buffer.toString();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.RecordFormatException,1,4,0,99,2,0,99,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"


package org.apache.poi.hssf.record;



public class RecordFormatException
    extends RuntimeException
{
    public RecordFormatException(String exception)
    {
        super(exception);
    }
}
"
poi,1.5,org.apache.poi.hssf.record.SeriesLabelsRecord,23,2,0,5,39,0,0,5,21,0.744318182,387,0.875,6,0.35483871,0.356521739,1,6,15.47826087,2,0.913,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class SeriesLabelsRecord
    extends Record
{
    public final static short      sid                             = 0x100c;
    private  short      field_1_formatFlags;
    private BitField   showActual                                 = new BitField(0x1);
    private BitField   showPercent                                = new BitField(0x2);
    private BitField   labelAsPercentage                          = new BitField(0x4);
    private BitField   smoothedLine                               = new BitField(0x8);
    private BitField   showLabel                                  = new BitField(0x10);
    private BitField   showBubbleSizes                            = new BitField(0x20);


    public SeriesLabelsRecord()
    {

    }

    

    public SeriesLabelsRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SeriesLabelsRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a SeriesLabels record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_formatFlags             = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SeriesLabels]
"");

        buffer.append(""    .formatFlags          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormatFlags()))
            .append("" ("").append(getFormatFlags()).append("" )
"");
        buffer.append(""         .showActual               = "").append(isShowActual          ()).append('
');
        buffer.append(""         .showPercent              = "").append(isShowPercent         ()).append('
');
        buffer.append(""         .labelAsPercentage        = "").append(isLabelAsPercentage   ()).append('
');
        buffer.append(""         .smoothedLine             = "").append(isSmoothedLine        ()).append('
');
        buffer.append(""         .showLabel                = "").append(isShowLabel           ()).append('
');
        buffer.append(""         .showBubbleSizes          = "").append(isShowBubbleSizes     ()).append('
');

        buffer.append(""[/SeriesLabels]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_formatFlags);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getFormatFlags()
    {
        return field_1_formatFlags;
    }

    
    public void setFormatFlags(short field_1_formatFlags)
    {
        this.field_1_formatFlags = field_1_formatFlags;
    }

    
    public void setShowActual(boolean value)
    {
        field_1_formatFlags = showActual.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isShowActual()
    {
        return showActual.isSet(field_1_formatFlags);
    }

    
    public void setShowPercent(boolean value)
    {
        field_1_formatFlags = showPercent.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isShowPercent()
    {
        return showPercent.isSet(field_1_formatFlags);
    }

    
    public void setLabelAsPercentage(boolean value)
    {
        field_1_formatFlags = labelAsPercentage.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isLabelAsPercentage()
    {
        return labelAsPercentage.isSet(field_1_formatFlags);
    }

    
    public void setSmoothedLine(boolean value)
    {
        field_1_formatFlags = smoothedLine.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isSmoothedLine()
    {
        return smoothedLine.isSet(field_1_formatFlags);
    }

    
    public void setShowLabel(boolean value)
    {
        field_1_formatFlags = showLabel.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isShowLabel()
    {
        return showLabel.isSet(field_1_formatFlags);
    }

    
    public void setShowBubbleSizes(boolean value)
    {
        field_1_formatFlags = showBubbleSizes.setShortBoolean(field_1_formatFlags, value);
    }

    
    public boolean isShowBubbleSizes()
    {
        return showBubbleSizes.isSet(field_1_formatFlags);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.PlotGrowthRecord,13,2,0,5,25,56,1,4,11,0.805555556,158,0.666666667,0,0.523809524,0.5,1,6,10.92307692,2,0.8462,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class PlotGrowthRecord
    extends Record
{
    public final static short      sid                             = 0x1064;
    private  int        field_1_horizontalScale;
    private  int        field_2_verticalScale;


    public PlotGrowthRecord()
    {

    }

    

    public PlotGrowthRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PlotGrowthRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a PlotGrowth record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_horizontalScale         = LittleEndian.getInt(data, 0x0 + offset);
        field_2_verticalScale           = LittleEndian.getInt(data, 0x4 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PlotGrowth]
"");

        buffer.append(""    .horizontalScale      = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getHorizontalScale()))
            .append("" ("").append(getHorizontalScale()).append("" )
"");

        buffer.append(""    .verticalScale        = "")
            .append(""0x"")
            .append(HexDump.toHex((int)getVerticalScale()))
            .append("" ("").append(getVerticalScale()).append("" )
"");

        buffer.append(""[/PlotGrowth]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putInt(data, 4 + offset, field_1_horizontalScale);
        LittleEndian.putInt(data, 8 + offset, field_2_verticalScale);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 4 + 4;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public int getHorizontalScale()
    {
        return field_1_horizontalScale;
    }

    
    public void setHorizontalScale(int field_1_horizontalScale)
    {
        this.field_1_horizontalScale = field_1_horizontalScale;
    }

    
    public int getVerticalScale()
    {
        return field_2_verticalScale;
    }

    
    public void setVerticalScale(int field_2_verticalScale)
    {
        this.field_2_verticalScale = field_2_verticalScale;
    }


}  




"
poi,1.5,org.apache.poi.poifs.property.RootProperty,3,3,0,8,10,3,6,2,1,2.0,27,0.0,0,0.971428571,0.666666667,1,1,8.0,1,0.3333,0,"


package org.apache.poi.poifs.property;

import java.util.*;

import java.io.IOException;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.storage.SmallDocumentBlock;



public class RootProperty
    extends DirectoryProperty
{

    

    RootProperty()
    {
        super(""Root Entry"");

        
        setNodeColor(_NODE_BLACK);
        setPropertyType(PropertyConstants.ROOT_TYPE);
        setStartBlock(POIFSConstants.END_OF_CHAIN);
    }

    

    protected RootProperty(final int index, final byte [] array,
                           final int offset)
    {
        super(index, array, offset);
    }

    

    public void setSize(int size)
    {
        super.setSize(SmallDocumentBlock.calcSize(size));
    }
}   

"
poi,1.5,org.apache.poi.poifs.storage.SmallDocumentBlockList,5,2,0,5,12,10,1,4,5,2.0,32,0.0,0,0.555555556,0.5,0,0,5.4,1,0.8,0,"


package org.apache.poi.poifs.storage;

import java.util.*;



public class SmallDocumentBlockList
    extends BlockListImpl
{

    

    public SmallDocumentBlockList(final List blocks)
    {
        setBlocks(( SmallDocumentBlock [] ) blocks
            .toArray(new SmallDocumentBlock[ 0 ]));
    }
}   

"
poi,1.5,org.apache.poi.hpsf.littleendian.LittleEndian,4,1,4,4,5,4,4,0,4,0.333333333,46,1.0,0,0.0,0.666666667,0,0,10.25,2,1.0,0,"

package org.apache.poi.hpsf.littleendian;


public abstract class LittleEndian
{

    


    
    protected byte[] bytes;



    
    public LittleEndian(final byte[] src, final int offset)
    {
        read(src, offset);
    }



    
    public byte[] getBytes()
    {
        return bytes;
    }



    
    public byte[] read(final byte[] src, final int offset)
    {
        final int length = length();
        bytes = new byte[length];
        for (int i = 0; i < length; i++)
            bytes[i] = src[offset + length - 1 - i];
        return bytes;
    }


    
    public abstract int length();

}
"
poi,1.5,org.apache.poi.hssf.record.DataFormatRecord,19,2,0,6,35,93,1,5,17,0.796296296,285,0.833333333,1,0.407407407,0.368421053,1,6,13.68421053,2,0.8947,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class DataFormatRecord
    extends Record
{
    public final static short      sid                             = 0x1006;
    private  short      field_1_pointNumber;
    private  short      field_2_seriesIndex;
    private  short      field_3_seriesNumber;
    private  short      field_4_formatFlags;
    private BitField   useExcel4Colors                            = new BitField(0x1);


    public DataFormatRecord()
    {

    }

    

    public DataFormatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DataFormatRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a DataFormat record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_pointNumber             = LittleEndian.getShort(data, 0x0 + offset);
        field_2_seriesIndex             = LittleEndian.getShort(data, 0x2 + offset);
        field_3_seriesNumber            = LittleEndian.getShort(data, 0x4 + offset);
        field_4_formatFlags             = LittleEndian.getShort(data, 0x6 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DataFormat]
"");

        buffer.append(""    .pointNumber          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getPointNumber()))
            .append("" ("").append(getPointNumber()).append("" )
"");

        buffer.append(""    .seriesIndex          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getSeriesIndex()))
            .append("" ("").append(getSeriesIndex()).append("" )
"");

        buffer.append(""    .seriesNumber         = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getSeriesNumber()))
            .append("" ("").append(getSeriesNumber()).append("" )
"");

        buffer.append(""    .formatFlags          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormatFlags()))
            .append("" ("").append(getFormatFlags()).append("" )
"");
        buffer.append(""         .useExcel4Colors          = "").append(isUseExcel4Colors     ()).append('
');

        buffer.append(""[/DataFormat]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_pointNumber);
        LittleEndian.putShort(data, 6 + offset, field_2_seriesIndex);
        LittleEndian.putShort(data, 8 + offset, field_3_seriesNumber);
        LittleEndian.putShort(data, 10 + offset, field_4_formatFlags);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getPointNumber()
    {
        return field_1_pointNumber;
    }

    
    public void setPointNumber(short field_1_pointNumber)
    {
        this.field_1_pointNumber = field_1_pointNumber;
    }

    
    public short getSeriesIndex()
    {
        return field_2_seriesIndex;
    }

    
    public void setSeriesIndex(short field_2_seriesIndex)
    {
        this.field_2_seriesIndex = field_2_seriesIndex;
    }

    
    public short getSeriesNumber()
    {
        return field_3_seriesNumber;
    }

    
    public void setSeriesNumber(short field_3_seriesNumber)
    {
        this.field_3_seriesNumber = field_3_seriesNumber;
    }

    
    public short getFormatFlags()
    {
        return field_4_formatFlags;
    }

    
    public void setFormatFlags(short field_4_formatFlags)
    {
        this.field_4_formatFlags = field_4_formatFlags;
    }

    
    public void setUseExcel4Colors(boolean value)
    {
        field_4_formatFlags = useExcel4Colors.setShortBoolean(field_4_formatFlags, value);
    }

    
    public boolean isUseExcel4Colors()
    {
        return useExcel4Colors.isSet(field_4_formatFlags);
    }


}  




"
poi,1.5,org.apache.poi.poifs.filesystem.DocumentInputStream,13,2,0,13,23,0,10,3,11,0.642857143,271,1.0,1,0.45,0.256410256,1,2,19.30769231,2,0.9231,0,"


package org.apache.poi.poifs.filesystem;

import java.io.*;



public class DocumentInputStream
    extends InputStream
{

    
    private int              _current_offset;

    
    
    private int              _marked_offset;

    
    private int              _document_size;

    
    private boolean          _closed;

    
    private POIFSDocument    _document;

    
    private byte[]           _tiny_buffer;

    
    static private final int EOD = -1;

    

    public DocumentInputStream(final DocumentEntry document)
        throws IOException
    {
        _current_offset = 0;
        _marked_offset  = 0;
        _document_size  = document.getSize();
        _closed         = false;
        _tiny_buffer    = null;
        if (document instanceof DocumentNode)
        {
            _document = (( DocumentNode ) document).getDocument();
        }
        else
        {
            throw new IOException(""Cannot open internal document storage"");
        }
    }

    

    public DocumentInputStream(final POIFSDocument document)
        throws IOException
    {
        _current_offset = 0;
        _marked_offset  = 0;
        _document_size  = document.getSize();
        _closed         = false;
        _tiny_buffer    = null;
        _document       = document;
    }

    

    public int available()
        throws IOException
    {
        dieIfClosed();
        return _document_size - _current_offset;
    }

    

    public void close()
        throws IOException
    {
        _closed = true;
    }

    

    public void mark(int ignoredReadlimit)
    {
        _marked_offset = _current_offset;
    }

    

    public boolean markSupported()
    {
        return true;
    }

    

    public int read()
        throws IOException
    {
        dieIfClosed();
        if (atEOD())
        {
            return EOD;
        }
        if (_tiny_buffer == null)
        {
            _tiny_buffer = new byte[ 1 ];
        }
        _document.read(_tiny_buffer, _current_offset++);
        return ((int)_tiny_buffer[ 0 ]) & 0x000000FF;
    }

    

    public int read(final byte [] b)
        throws IOException, NullPointerException
    {
        return read(b, 0, b.length);
    }

    

    public int read(final byte [] b, final int off, final int len)
        throws IOException, NullPointerException, IndexOutOfBoundsException
    {
        dieIfClosed();
        if (b == null)
        {
            throw new NullPointerException(""buffer is null"");
        }
        if ((off < 0) || (len < 0) || (b.length < (off + len)))
        {
            throw new IndexOutOfBoundsException(
                ""can't read past buffer boundaries"");
        }
        if (len == 0)
        {
            return 0;
        }
        if (atEOD())
        {
            return EOD;
        }
        int limit = Math.min(available(), len);

        if ((off == 0) && (limit == b.length))
        {
            _document.read(b, _current_offset);
        }
        else
        {
            byte[] buffer = new byte[ limit ];

            _document.read(buffer, _current_offset);
            System.arraycopy(buffer, 0, b, off, limit);
        }
        _current_offset += limit;
        return limit;
    }

    

    public void reset()
    {
        _current_offset = _marked_offset;
    }

    

    public long skip(final long n)
        throws IOException
    {
        dieIfClosed();
        if (n < 0)
        {
            return 0;
        }
        int new_offset = _current_offset + ( int ) n;

        if (new_offset < _current_offset)
        {

            
            new_offset = _document_size;
        }
        else if (new_offset > _document_size)
        {
            new_offset = _document_size;
        }
        long rval = new_offset - _current_offset;

        _current_offset = new_offset;
        return rval;
    }

    private void dieIfClosed()
        throws IOException
    {
        if (_closed)
        {
            throw new IOException(
                ""cannot perform requested operation on a closed stream"");
        }
    }

    private boolean atEOD()
    {
        return _current_offset == _document_size;
    }
}   

"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFCell,26,1,0,16,78,65,4,12,19,0.75,984,0.6,4,0.0,0.147928994,0,0,36.07692308,20,2.8846,7,"



package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.model.Workbook;
import org.apache.poi.hssf.model.Sheet;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.FormulaRecord;
import org.apache.poi.hssf.record.LabelSSTRecord;
import org.apache.poi.hssf.record.NumberRecord;
import org.apache.poi.hssf.record.BlankRecord;
import org.apache.poi.hssf.record.BoolErrRecord;
import org.apache.poi.hssf.record.ExtendedFormatRecord;

import java.util.Date;
import java.util.Calendar;



public class HSSFCell
{

    

    public final static int          CELL_TYPE_NUMERIC           = 0;

    

    public final static int          CELL_TYPE_STRING            = 1;

    

    public final static int          CELL_TYPE_FORMULA           = 2;

    

    public final static int          CELL_TYPE_BLANK             = 3;

    

    public final static int          CELL_TYPE_BOOLEAN           = 4;

    

    public final static int          CELL_TYPE_ERROR             = 5;
    public final static short        ENCODING_COMPRESSED_UNICODE = 0;
    public final static short        ENCODING_UTF_16             = 1;
    private short                    cellNum;
    private int                      cellType;
    private HSSFCellStyle            cellStyle;
    private double                   cellValue;
    private String                   stringValue;
    private boolean                  booleanValue;
    private byte                     errorValue;
    private short                    encoding;
    private Workbook                 book;
    private Sheet                    sheet;
    private short                    row;
    private CellValueRecordInterface record;

    

    protected HSSFCell(Workbook book, Sheet sheet, short row, short col)
    {
        cellNum      = col;
        this.row     = row;
        cellStyle    = null;
        cellValue    = 0;
        stringValue  = null;
        booleanValue = false;
        errorValue   = ( byte ) 0;
        this.book    = book;
        this.sheet   = sheet;

        
        
        
        setCellType(CELL_TYPE_BLANK, false);
        ExtendedFormatRecord xf = book.getExFormatAt(0xf);

        setCellStyle(new HSSFCellStyle(( short ) 0xf, xf));
    }

    

    protected HSSFCell(Workbook book, Sheet sheet, short row, short col,
                       int type)
    {
        cellNum      = col;
        this.row     = row;
        cellType     = type;
        cellStyle    = null;
        cellValue    = 0;
        stringValue  = null;
        booleanValue = false;
        errorValue   = ( byte ) 0;
        this.book    = book;
        this.sheet   = sheet;
        switch (type)
        {

            case CELL_TYPE_NUMERIC :
                record = new NumberRecord();
                (( NumberRecord ) record).setColumn(col);
                (( NumberRecord ) record).setRow(row);
                (( NumberRecord ) record).setValue(( short ) 0);
                (( NumberRecord ) record).setXFIndex(( short ) 0);
                break;

            case CELL_TYPE_STRING :
                record = new LabelSSTRecord();
                (( LabelSSTRecord ) record).setColumn(col);
                (( LabelSSTRecord ) record).setRow(row);
                (( LabelSSTRecord ) record).setXFIndex(( short ) 0);
                break;

            case CELL_TYPE_BLANK :
                record = new BlankRecord();
                (( BlankRecord ) record).setColumn(col);
                (( BlankRecord ) record).setRow(row);
                (( BlankRecord ) record).setXFIndex(( short ) 0);
                break;

            case CELL_TYPE_FORMULA :
                record = new FormulaRecord();
                (( FormulaRecord ) record).setColumn(col);
                (( FormulaRecord ) record).setRow(row);
                (( FormulaRecord ) record).setXFIndex(( short ) 0);
            case CELL_TYPE_BOOLEAN :
                record = new BoolErrRecord();
                (( BoolErrRecord ) record).setColumn(col);
                (( BoolErrRecord ) record).setRow(row);
                (( BoolErrRecord ) record).setXFIndex(( short ) 0);
                (( BoolErrRecord ) record).setValue(false);
                break;

            case CELL_TYPE_ERROR :
                record = new BoolErrRecord();
                (( BoolErrRecord ) record).setColumn(col);
                (( BoolErrRecord ) record).setRow(row);
                (( BoolErrRecord ) record).setXFIndex(( short ) 0);
                (( BoolErrRecord ) record).setValue(( byte ) 0);
                break;
        }
        ExtendedFormatRecord xf = book.getExFormatAt(0xf);

        setCellStyle(new HSSFCellStyle(( short ) 0xf, xf));
    }

    

    protected HSSFCell(Workbook book, Sheet sheet, short row,
                       CellValueRecordInterface cval)
    {
        cellNum     = cval.getColumn();
        record      = cval;
        this.row    = row;
        cellType    = determineType(cval);
        cellStyle   = null;
        stringValue = null;
        this.book   = book;
        this.sheet  = sheet;
        switch (cellType)
        {

            case CELL_TYPE_NUMERIC :
                cellValue = (( NumberRecord ) cval).getValue();
                break;

            case CELL_TYPE_STRING :
                stringValue =
                    book
                    .getSSTString((( LabelSSTRecord ) cval).getSSTIndex());
                break;

            case CELL_TYPE_BLANK :
                break;

            case CELL_TYPE_FORMULA :
                cellValue = (( FormulaRecord ) cval).getValue();
                break;

            case CELL_TYPE_BOOLEAN :
                booleanValue = (( BoolErrRecord ) cval).getBooleanValue();
                break;

            case CELL_TYPE_ERROR :
                errorValue = (( BoolErrRecord ) cval).getErrorValue();
                break;
        }
        ExtendedFormatRecord xf = book.getExFormatAt(cval.getXFIndex());

        setCellStyle(new HSSFCellStyle(( short ) cval.getXFIndex(), xf));
    }

    
    private HSSFCell()
    {
    }

    
    private int determineType(CellValueRecordInterface cval)
    {
        Record record = ( Record ) cval;
        int    sid    = record.getSid();
        int    retval = 0;

        switch (sid)
        {

            case NumberRecord.sid :
                retval = HSSFCell.CELL_TYPE_NUMERIC;
                break;

            case BlankRecord.sid :
                retval = HSSFCell.CELL_TYPE_BLANK;
                break;

            case LabelSSTRecord.sid :
                retval = HSSFCell.CELL_TYPE_STRING;
                break;

            case FormulaRecord.sid :
                retval = HSSFCell.CELL_TYPE_FORMULA;
                break;

            case BoolErrRecord.sid :
                BoolErrRecord boolErrRecord = ( BoolErrRecord ) record;

                retval = (boolErrRecord.isBoolean())
                         ? HSSFCell.CELL_TYPE_BOOLEAN
                         : HSSFCell.CELL_TYPE_ERROR;
                break;
        }
        return retval;
    }

    

    public void setCellNum(short num)
    {
        cellNum = num;
        record.setColumn(num);
    }

    

    public short getCellNum()
    {
        return cellNum;
    }

    

    public void setCellType(int cellType)
    {
        setCellType(cellType, true);
    }

    

    private void setCellType(int cellType, boolean setValue)
    {

        
        
        
        
        
        if (cellType > CELL_TYPE_ERROR)
        {
            throw new RuntimeException(""I have no idea what type that is!"");
        }
        switch (cellType)
        {

            case CELL_TYPE_FORMULA :
                FormulaRecord frec = null;

                if (cellType != this.cellType)
                {
                    frec = new FormulaRecord();
                }
                else
                {
                    frec = ( FormulaRecord ) record;
                }
                frec.setColumn(getCellNum());
                if (setValue)
                {
                    frec.setValue(getNumericCellValue());
                }
                frec.setXFIndex(( short ) cellStyle.getIndex());
                frec.setRow(row);
                record = frec;
                break;

            case CELL_TYPE_NUMERIC :
                NumberRecord nrec = null;

                if (cellType != this.cellType)
                {
                    nrec = new NumberRecord();
                }
                else
                {
                    nrec = ( NumberRecord ) record;
                }
                nrec.setColumn(getCellNum());
                if (setValue)
                {
                    nrec.setValue(getNumericCellValue());
                }
                nrec.setXFIndex(( short ) cellStyle.getIndex());
                nrec.setRow(row);
                record = nrec;
                break;

            case CELL_TYPE_STRING :
                LabelSSTRecord lrec = null;

                if (cellType != this.cellType)
                {
                    lrec = new LabelSSTRecord();
                }
                else
                {
                    lrec = ( LabelSSTRecord ) record;
                }
                lrec.setColumn(getCellNum());
                lrec.setRow(row);
                lrec.setXFIndex(( short ) cellStyle.getIndex());
                if (setValue)
                {
                    if ((getStringCellValue() != null)
                            && (!getStringCellValue().equals("""")))
                    {
                        int sst = 0;

                        if (encoding == ENCODING_COMPRESSED_UNICODE)
                        {
                            sst = book.addSSTString(getStringCellValue());
                        }
                        if (encoding == ENCODING_UTF_16)
                        {
                            sst = book.addSSTString(getStringCellValue(),
                                                    true);
                        }
                        lrec.setSSTIndex(sst);
                    }
                }
                record = lrec;
                break;

            case CELL_TYPE_BLANK :
                BlankRecord brec = null;

                if (cellType != this.cellType)
                {
                    brec = new BlankRecord();
                }
                else
                {
                    brec = ( BlankRecord ) record;
                }
                brec.setColumn(getCellNum());

                
                if (cellStyle != null)
                {
                    brec.setXFIndex(( short ) cellStyle.getIndex());
                }
                else
                {
                    brec.setXFIndex(( short ) 0);
                }
                brec.setRow(row);
                record = brec;
                break;

            case CELL_TYPE_BOOLEAN :
                BoolErrRecord boolRec = null;

                if (cellType != this.cellType)
                {
                    boolRec = new BoolErrRecord();
                }
                else
                {
                    boolRec = ( BoolErrRecord ) record;
                }
                boolRec.setColumn(getCellNum());
                if (setValue)
                {
                    boolRec.setValue(getBooleanCellValue());
                }
                boolRec.setXFIndex(( short ) cellStyle.getIndex());
                boolRec.setRow(row);
                record = boolRec;
                break;

            case CELL_TYPE_ERROR :
                BoolErrRecord errRec = null;

                if (cellType != this.cellType)
                {
                    errRec = new BoolErrRecord();
                }
                else
                {
                    errRec = ( BoolErrRecord ) record;
                }
                errRec.setColumn(getCellNum());
                if (setValue)
                {
                    errRec.setValue(getErrorCellValue());
                }
                errRec.setXFIndex(( short ) cellStyle.getIndex());
                errRec.setRow(row);
                record = errRec;
                break;
        }
        if (cellType != this.cellType)
        {
            int loc = sheet.getLoc();

            sheet.replaceValueRecord(record);
            sheet.setLoc(loc);
        }
        this.cellType = cellType;
    }

    

    public int getCellType()
    {
        return cellType;
    }

    
    public void setCellValue(double value)
    {
        if ((cellType != CELL_TYPE_NUMERIC) && (cellType != CELL_TYPE_FORMULA))
        {
            setCellType(CELL_TYPE_NUMERIC, false);
        }
        (( NumberRecord ) record).setValue(value);
        cellValue = value;
    }

    
    public void setCellValue(Date value)
    {
        setCellValue(HSSFDateUtil.getExcelDate(value));
    }

    
    public void setCellValue(Calendar value)
    {
        setCellValue(value.getTime());
    }

    

    public void setCellValue(String value)
    {
        if (value == null)
        {
            setCellType(CELL_TYPE_BLANK, false);
        }
        else
        {
            if ((cellType != CELL_TYPE_STRING)
                    && (cellType != CELL_TYPE_FORMULA))
            {
                setCellType(CELL_TYPE_STRING, false);
            }
            int index = 0;

            if (encoding == ENCODING_COMPRESSED_UNICODE)
            {
                index = book.addSSTString(value);
            }
            if (encoding == ENCODING_UTF_16)
            {
                index = book.addSSTString(value, true);
            }
            (( LabelSSTRecord ) record).setSSTIndex(index);
            stringValue = value;
        }
    }

    

    public double getNumericCellValue()
    {
        if (cellType == CELL_TYPE_BLANK)
        {
            return 0;
        }
        if (cellType == CELL_TYPE_STRING)
        {
            throw new NumberFormatException(
                ""You cannot get a numeric value from a String based cell"");
        }
        if (cellType == CELL_TYPE_BOOLEAN)
        {
            throw new NumberFormatException(
                ""You cannot get a numeric value from a boolean cell"");
        }
        if (cellType == CELL_TYPE_ERROR)
        {
            throw new NumberFormatException(
                ""You cannot get a numeric value from an error cell"");
        }
        return cellValue;
    }

    
    public Date getDateCellValue()
    {
        if (cellType == CELL_TYPE_BLANK)
        {
            return null;
        }
        if (cellType == CELL_TYPE_STRING)
        {
            throw new NumberFormatException(
                ""You cannot get a date value from a String based cell"");
        }
        if (cellType == CELL_TYPE_BOOLEAN)
        {
            throw new NumberFormatException(
                ""You cannot get a date value from a boolean cell"");
        }
        if (cellType == CELL_TYPE_ERROR)
        {
            throw new NumberFormatException(
                ""You cannot get a date value from an error cell"");
        }
        return HSSFDateUtil.getJavaDate(cellValue);
    }

    

    public String getStringCellValue()
    {
        if (cellType == CELL_TYPE_BLANK)
        {
            return """";
        }
        if (cellType == CELL_TYPE_NUMERIC)
        {
            throw new NumberFormatException(
                ""You cannot get a string value from a numeric cell"");
        }
        if (cellType == CELL_TYPE_BOOLEAN)
        {
            throw new NumberFormatException(
                ""You cannot get a string value from a boolean cell"");
        }
        if (cellType == CELL_TYPE_ERROR)
        {
            throw new NumberFormatException(
                ""You cannot get a string value from an error cell"");
        }
        return stringValue;
    }

    

    public void setCellValue(boolean value)
    {
        if ((cellType != CELL_TYPE_BOOLEAN)
                && (cellType != CELL_TYPE_FORMULA))
        {
            setCellType(CELL_TYPE_BOOLEAN, false);
        }
        (( BoolErrRecord ) record).setValue(value);
        booleanValue = value;
    }

    

    public void setCellErrorValue(byte value)
    {
        if ((cellType != CELL_TYPE_ERROR) && (cellType != CELL_TYPE_FORMULA))
        {
            setCellType(CELL_TYPE_ERROR, false);
        }
        (( BoolErrRecord ) record).setValue(value);
        errorValue = value;
    }

    

    public boolean getBooleanCellValue()
    {
        if (cellType == CELL_TYPE_BOOLEAN)
        {
            return booleanValue;
        }
        if (cellType == CELL_TYPE_BLANK)
        {
            return false;
        }
        throw new NumberFormatException(
            ""You cannot get a boolean value from a non-boolean cell"");
    }

    

    public byte getErrorCellValue()
    {
        if (cellType == CELL_TYPE_ERROR)
        {
            return errorValue;
        }
        if (cellType == CELL_TYPE_BLANK)
        {
            return ( byte ) 0;
        }
        throw new NumberFormatException(
            ""You cannot get an error value from a non-error cell"");
    }

    

    public void setCellStyle(HSSFCellStyle style)
    {
        cellStyle = style;
        record.setXFIndex(style.getIndex());
    }

    

    public HSSFCellStyle getCellStyle()
    {
        return cellStyle;
    }

    

    public short getEncoding()
    {
        return encoding;
    }

    

    public void setEncoding(short encoding)
    {
        this.encoding = encoding;
    }

    

    protected CellValueRecordInterface getCellValueRecord()
    {
        return record;
    }
}
"
poi,1.5,org.apache.poi.util.HexDump,10,1,0,26,28,31,26,0,5,0.577777778,414,0.8,0,0.0,0.206349206,0,0,39.9,2,1.2,5,"


package org.apache.poi.util;

import java.io.*;



public class HexDump
{

    
    private HexDump()
    {
    }

    

    public synchronized static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index)
        throws IOException, ArrayIndexOutOfBoundsException,
                IllegalArgumentException
    {
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                ""illegal index: "" + index + "" into array of length ""
                + data.length);
        }
        if (stream == null)
        {
            throw new IllegalArgumentException(""cannot write to nullstream"");
        }
        long         display_offset = offset + index;
        StringBuffer buffer         = new StringBuffer(74);

        for (int j = index; j < data.length; j += 16)
        {
            int chars_read = data.length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(dump(display_offset)).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append(""  "");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            stream.write(buffer.toString().getBytes());
            stream.flush();
            buffer.setLength(0);
            display_offset += chars_read;
        }
    }

    public static final String        EOL         =
        System.getProperty(""line.separator"");
    private static final StringBuffer _lbuffer    = new StringBuffer(8);
    private static final StringBuffer _cbuffer    = new StringBuffer(2);
    private static final char         _hexcodes[] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D',
        'E', 'F'
    };
    private static final int          _shifts[]   =
    {
        28, 24, 20, 16, 12, 8, 4, 0
    };

    private static StringBuffer dump(final long value)
    {
        _lbuffer.setLength(0);
        for (int j = 0; j < 8; j++)
        {
            _lbuffer
                .append(_hexcodes[ (( int ) (value >> _shifts[ j ])) & 15 ]);
        }
        return _lbuffer;
    }

    private static StringBuffer dump(final byte value)
    {
        _cbuffer.setLength(0);
        for (int j = 0; j < 2; j++)
        {
            _cbuffer.append(_hexcodes[ (value >> _shifts[ j + 6 ]) & 15 ]);
        }
        return _cbuffer;
    }

    
    public static String toHex(final byte[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        for(int x = 0; x < value.length; x++)
        {
            retVal.append(toHex(value[x]));
            retVal.append("", "");
        }
        retVal.append(']');
        return retVal.toString();
    }
    
    public static String toHex(final short value)
    {
        return toHex(value, 4);
    }

    
    public static String toHex(final byte value)
    {
        return toHex(value, 2);
    }

    
    public static String toHex(final int value)
    {
        return toHex(value, 8);
    }


    private static String toHex(final long value, final int digits)
    {
        StringBuffer result = new StringBuffer(digits);
        for (int j = 0; j < digits; j++)
        {
            result.append( _hexcodes[ (int) ((value >> _shifts[ j + (8 - digits) ]) & 15)]);
        }
        return result.toString();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.BackupRecord,11,2,0,6,21,49,3,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class BackupRecord
    extends Record
{
    public final static short sid = 0x40;
    private short             field_1_backup;   

    public BackupRecord()
    {
    }

    

    public BackupRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BackupRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A BACKUP RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_backup = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setBackup(short backup)
    {
        field_1_backup = backup;
    }

    

    public short getBackup()
    {
        return field_1_backup;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BACKUP]
"");
        buffer.append(""    .backup          = "")
            .append(Integer.toHexString(getBackup())).append(""
"");
        buffer.append(""[/BACKUP]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getBackup());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.MulBlankRecord,14,2,0,5,24,77,2,3,11,0.876923077,202,0.8,0,0.5,0.517857143,1,5,13.07142857,2,1.0,1,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class MulBlankRecord
    extends Record
{
    public final static short sid = 0xbe;
    private short             field_1_row;
    private short             field_2_first_col;
    private short[]           field_3_xfs;
    private short             field_4_last_col;

    

    public MulBlankRecord()
    {
    }

    

    public MulBlankRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public MulBlankRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    

    public short getRow()
    {
        return field_1_row;
    }

    

    public short getFirstColumn()
    {
        return field_2_first_col;
    }

    

    public short getLastColumn()
    {
        return field_4_last_col;
    }

    

    public int getNumColumns()
    {
        return field_4_last_col - field_2_first_col + 1;
    }

    

    public short getXFAt(int coffset)
    {
        return field_3_xfs[ coffset ];
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row       = LittleEndian.getShort(data, 0 + offset);
        field_2_first_col = LittleEndian.getShort(data, 2 + offset);
        field_3_xfs       = parseXFs(data, 4, offset, size);
        field_4_last_col  = LittleEndian.getShort(data,
                                                  (field_3_xfs.length * 2)
                                                  + 4 + offset);
    }

    private short [] parseXFs(byte [] data, int offset, int recoffset,
                              short size)
    {
        short[] retval = new short[ ((size - offset) - 2) / 2 ];
        int     idx    = 0;

        for (; offset < size - 2; )
        {
            short xf = 0;

            xf            = LittleEndian.getShort(data, offset + recoffset);
            offset        += 2;
            retval[ idx ] = xf;
            idx++;
        }
        return retval;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[MULBLANK]
"");
        buffer.append(""firstcol  = "")
            .append(Integer.toHexString(getFirstColumn())).append(""
"");
        buffer.append("" lastcol  = "")
            .append(Integer.toHexString(getLastColumn())).append(""
"");
        for (int k = 0; k < getNumColumns(); k++)
        {
            buffer.append(""xf"").append(k).append(""        = "")
                .append(Integer.toHexString(getXFAt(k))).append(""
"");
        }
        buffer.append(""[/MULBLANK]
"");
        return buffer.toString();
    }

    

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a MulBlankRecord!"");
        }
    }

    public short getSid()
    {
        return this.sid;
    }

    public int serialize(int offset, byte [] data)
    {
        throw new RecordFormatException(
            ""Sorry, you can't serialize a MulBlank in this release"");
    }
}
"
poi,1.5,org.apache.poi.util.StringUtil,7,1,0,9,30,21,9,0,5,2.0,350,0.0,0,0.0,0.306122449,0,0,49.0,10,3.5714,7,"


package org.apache.poi.util;

import java.io.UnsupportedEncodingException;

import java.text.NumberFormat;
import java.text.FieldPosition;



public class StringUtil
{
    private StringUtil()
    {
    }

    

    public static String getFromUnicode(final byte [] string,
                                        final int offset, final int len)
        throws ArrayIndexOutOfBoundsException, IllegalArgumentException
    {
        if ((offset < 0) || (offset >= string.length))
        {
            throw new ArrayIndexOutOfBoundsException(""Illegal offset"");
        }
        if ((len < 0) || (((string.length - offset) / 2) < len))
        {
            throw new IllegalArgumentException(""Illegal length"");
        }
        byte[] bstring = new byte[ len ];
        int    index   = offset + 1;   

        for (int k = 0; k < len; k++)
        {
            bstring[ k ] = string[ index ];
            index        += 2;
        }
        return new String(bstring);
    }

    

    public static String getFromUnicode(final byte [] string)
    {
        return getFromUnicode(string, 0, string.length / 2);
    }

    

    public static void putCompressedUnicode(final String input,
                                            final byte [] output,
                                            final int offset)
    {
        int strlen = input.length();

        for (int k = 0; k < strlen; k++)
        {
            output[ offset + k ] = ( byte ) input.charAt(k);
        }
    }

    

    public static void putUncompressedUnicode(final String input,
                                              final byte [] output,
                                              final int offset)
    {
        int strlen = input.length();

        for (int k = 0; k < strlen; k++)
        {
            char c = input.charAt(k);

            output[ offset + (2 * k) ]     = ( byte ) c;
            output[ offset + (2 * k) + 1 ] = ( byte ) (c >> 8);
        }
    }

    public static String format(String message, Object [] params)
    {
        int          currentParamNumber = 0;
        StringBuffer formattedMessage   = new StringBuffer();

        for (int i = 0; i < message.length(); i++)
        {
            if (message.charAt(i) == '%')
            {
                if (currentParamNumber >= params.length)
                {
                    formattedMessage.append(""?missing data?"");
                }
                else if ((params[ currentParamNumber ] instanceof Number)
                         && (i + 1 < message.length()))
                {
                    i += matchOptionalFormatting(
                        ( Number ) params[ currentParamNumber++ ],
                        message.substring(i + 1), formattedMessage);
                }
                else
                {
                    formattedMessage
                        .append(params[ currentParamNumber++ ].toString());
                }
            }
            else
            {
                if ((message.charAt(i) == '\') && (i + 1 < message.length())
                        && (message.charAt(i + 1) == '%'))
                {
                    formattedMessage.append('%');
                    i++;
                }
                else
                {
                    formattedMessage.append(message.charAt(i));
                }
            }
        }
        return formattedMessage.toString();
    }

    private static int matchOptionalFormatting(Number number,
                                               String formatting,
                                               StringBuffer outputTo)
    {
        NumberFormat numberFormat = NumberFormat.getInstance();

        if ((0 < formatting.length())
                && Character.isDigit(formatting.charAt(0)))
        {
            numberFormat
                .setMinimumIntegerDigits(Integer
                    .parseInt(formatting.charAt(0) + """"));
            if ((2 < formatting.length()) && (formatting.charAt(1) == '.')
                    && Character.isDigit(formatting.charAt(2)))
            {
                numberFormat
                    .setMaximumFractionDigits(Integer
                        .parseInt(formatting.charAt(2) + """"));
                numberFormat.format(number, outputTo, new FieldPosition(0));
                return 3;
            }
            numberFormat.format(number, outputTo, new FieldPosition(0));
            return 1;
        }
        else if ((0 < formatting.length()) && (formatting.charAt(0) == '.'))
        {
            if ((1 < formatting.length())
                    && Character.isDigit(formatting.charAt(1)))
            {
                numberFormat
                    .setMaximumFractionDigits(Integer
                        .parseInt(formatting.charAt(1) + """"));
                numberFormat.format(number, outputTo, new FieldPosition(0));
                return 2;
            }
        }
        numberFormat.format(number, outputTo, new FieldPosition(0));
        return 1;
    }
}
"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFFont,20,1,0,5,39,0,3,2,19,0.978947368,140,0.133333333,1,0.0,0.258333333,0,0,5.25,1,0.95,1,"



package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.FontRecord;



public class HSSFFont
    implements HSSFColorConstants
{

    

    public final static String FONT_ARIAL          = ""Arial"";

    

    public final static short  BOLDWEIGHT_NORMAL   = 190;

    

    public final static short  BOLDWEIGHT_BOLD     = 0x2bc;

    

    public final static short  COLOR_NORMAL        = 0x7fff;

    

    public final static short  COLOR_RED           = 0xa;

    

    public final static short  SS_NONE             = 0;

    

    public final static short  SS_SUPER            = 1;

    

    public final static short  SS_SUB              = 2;

    

    public final static byte   U_NONE              = 0;

    

    public final static byte   U_SINGLE            = 1;

    

    public final static byte   U_DOUBLE            = 2;

    

    public final static byte   U_SINGLE_ACCOUNTING = 0x21;

    

    public final static byte   U_DOUBLE_ACCOUNTING = 0x22;
    private FontRecord         font;
    private short              index;

    

    protected HSSFFont(short index, FontRecord rec)
    {
        font       = rec;
        this.index = index;
    }

    

    public void setFontName(String name)
    {
        font.setFontName(name);
        font.setFontNameLength(( byte ) name.length());
    }

    

    public String getFontName()
    {
        return font.getFontName();
    }

    

    public short getIndex()
    {
        return index;
    }

    

    public void setFontHeight(short height)
    {
        font.setFontHeight(height);
    }

    

    public void setFontHeightInPoints(short height)
    {
        font.setFontHeight(( short ) (height * 20));
    }

    

    public short getFontHeight()
    {
        return font.getFontHeight();
    }

    

    public short getFontHeightInPoints()
    {
        return ( short ) (font.getFontHeight() / 20);
    }

    

    public void setItalic(boolean italic)
    {
        font.setItalic(italic);
    }

    

    public boolean getItalic()
    {
        return font.isItalic();
    }

    

    public void setStrikeout(boolean strikeout)
    {
        font.setStrikeout(strikeout);
    }

    

    public boolean getStrikeout()
    {
        return font.isStruckout();
    }

    

    public void setColor(short color)
    {
        font.setColorPaletteIndex(color);
    }

    

    public short getColor()
    {
        return font.getColorPaletteIndex();
    }

    

    public void setBoldweight(short boldweight)
    {
        font.setBoldWeight(boldweight);
    }

    

    public short getBoldweight()
    {
        return font.getBoldWeight();
    }

    

    public void setTypeOffset(short offset)
    {
        font.setSuperSubScript(offset);
    }

    

    public short getTypeOffset()
    {
        return font.getSuperSubScript();
    }

    

    public void setUnderline(byte underline)
    {
        font.setUnderline(underline);
    }

    

    public byte getUnderline()
    {
        return font.getUnderline();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.PrintGridlinesRecord,11,2,0,5,21,43,2,3,9,0.85,117,0.5,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class PrintGridlinesRecord
    extends Record
{
    public final static short sid = 0x2b;
    private short             field_1_print_gridlines;

    public PrintGridlinesRecord()
    {
    }

    

    public PrintGridlinesRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PrintGridlinesRecord(short id, short size, byte [] data,
                                int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PrintGridlines RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_print_gridlines = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setPrintGridlines(boolean pg)
    {
        if (pg == true)
        {
            field_1_print_gridlines = 1;
        }
        else
        {
            field_1_print_gridlines = 0;
        }
    }

    

    public boolean getPrintGridlines()
    {
        return (field_1_print_gridlines == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRINTGRIDLINES]
"");
        buffer.append(""    .printgridlines = "").append(getPrintGridlines())
            .append(""
"");
        buffer.append(""[/PRINTGRIDLINES]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, field_1_print_gridlines);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.BeginRecord,9,2,0,4,17,36,1,3,7,1.125,72,0.0,0,0.647058824,0.555555556,1,6,6.888888889,2,0.7778,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class BeginRecord
    extends Record
{
    public static final short sid = 0x1033;

    public BeginRecord()
    {
    }

    

    public BeginRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BeginRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A BEGIN RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BEGIN]
"");
        buffer.append(""[/BEGIN]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0));   
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 4;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.property.Parent,4,1,0,3,4,6,1,2,4,2.0,4,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.property;

import java.util.Iterator;

import java.io.IOException;



public interface Parent
    extends Child
{

    

    public Iterator getChildren();

    

    public void addChild(final Property property)
        throws IOException;

    

    public void setPreviousChild(final Child child);

    

    public void setNextChild(final Child child);

    

}   

"
poi,1.5,org.apache.poi.poifs.eventfilesystem.POIFSReaderEvent,4,1,0,5,5,0,3,2,3,0.666666667,28,1.0,2,0.0,0.4375,0,0,5.25,1,0.75,0,"


package org.apache.poi.poifs.eventfilesystem;

import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;



public class POIFSReaderEvent
{
    private DocumentInputStream stream;
    private POIFSDocumentPath   path;
    private String              documentName;

    

    POIFSReaderEvent(final DocumentInputStream stream,
                     final POIFSDocumentPath path, final String documentName)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
    }

    

    public DocumentInputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }
}   

"
poi,1.5,org.apache.poi.hssf.record.CategorySeriesAxisRecord,23,2,0,5,39,91,0,5,21,0.795454545,375,0.875,3,0.35483871,0.356521739,1,6,14.95652174,2,0.913,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class CategorySeriesAxisRecord
    extends Record
{
    public final static short      sid                             = 0x1020;
    private  short      field_1_crossingPoint;
    private  short      field_2_labelFrequency;
    private  short      field_3_tickMarkFrequency;
    private  short      field_4_options;
    private BitField   valueAxisCrossing                          = new BitField(0x1);
    private BitField   crossesFarRight                            = new BitField(0x2);
    private BitField   reversed                                   = new BitField(0x4);


    public CategorySeriesAxisRecord()
    {

    }

    

    public CategorySeriesAxisRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public CategorySeriesAxisRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a CategorySeriesAxis record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_crossingPoint           = LittleEndian.getShort(data, 0x0 + offset);
        field_2_labelFrequency          = LittleEndian.getShort(data, 0x2 + offset);
        field_3_tickMarkFrequency       = LittleEndian.getShort(data, 0x4 + offset);
        field_4_options                 = LittleEndian.getShort(data, 0x6 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CategorySeriesAxis]
"");

        buffer.append(""    .crossingPoint        = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getCrossingPoint()))
            .append("" ("").append(getCrossingPoint()).append("" )
"");

        buffer.append(""    .labelFrequency       = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getLabelFrequency()))
            .append("" ("").append(getLabelFrequency()).append("" )
"");

        buffer.append(""    .tickMarkFrequency    = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getTickMarkFrequency()))
            .append("" ("").append(getTickMarkFrequency()).append("" )
"");

        buffer.append(""    .options              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getOptions()))
            .append("" ("").append(getOptions()).append("" )
"");
        buffer.append(""         .valueAxisCrossing        = "").append(isValueAxisCrossing   ()).append('
');
        buffer.append(""         .crossesFarRight          = "").append(isCrossesFarRight     ()).append('
');
        buffer.append(""         .reversed                 = "").append(isReversed            ()).append('
');

        buffer.append(""[/CategorySeriesAxis]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_crossingPoint);
        LittleEndian.putShort(data, 6 + offset, field_2_labelFrequency);
        LittleEndian.putShort(data, 8 + offset, field_3_tickMarkFrequency);
        LittleEndian.putShort(data, 10 + offset, field_4_options);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getCrossingPoint()
    {
        return field_1_crossingPoint;
    }

    
    public void setCrossingPoint(short field_1_crossingPoint)
    {
        this.field_1_crossingPoint = field_1_crossingPoint;
    }

    
    public short getLabelFrequency()
    {
        return field_2_labelFrequency;
    }

    
    public void setLabelFrequency(short field_2_labelFrequency)
    {
        this.field_2_labelFrequency = field_2_labelFrequency;
    }

    
    public short getTickMarkFrequency()
    {
        return field_3_tickMarkFrequency;
    }

    
    public void setTickMarkFrequency(short field_3_tickMarkFrequency)
    {
        this.field_3_tickMarkFrequency = field_3_tickMarkFrequency;
    }

    
    public short getOptions()
    {
        return field_4_options;
    }

    
    public void setOptions(short field_4_options)
    {
        this.field_4_options = field_4_options;
    }

    
    public void setValueAxisCrossing(boolean value)
    {
        field_4_options = valueAxisCrossing.setShortBoolean(field_4_options, value);
    }

    
    public boolean isValueAxisCrossing()
    {
        return valueAxisCrossing.isSet(field_4_options);
    }

    
    public void setCrossesFarRight(boolean value)
    {
        field_4_options = crossesFarRight.setShortBoolean(field_4_options, value);
    }

    
    public boolean isCrossesFarRight()
    {
        return crossesFarRight.isSet(field_4_options);
    }

    
    public void setReversed(boolean value)
    {
        field_4_options = reversed.setShortBoolean(field_4_options, value);
    }

    
    public boolean isReversed()
    {
        return reversed.isSet(field_4_options);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.FooterRecord,13,2,0,6,25,66,2,4,11,0.777777778,174,0.666666667,0,0.523809524,0.333333333,1,6,12.15384615,3,1.1538,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class FooterRecord
    extends Record
{
    public final static short sid = 0x15;
    private byte              field_1_footer_len;
    private String            field_2_footer;

    public FooterRecord()
    {
    }

    

    public FooterRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FooterRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A FooterRECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        if (size > 0)
        {
            field_1_footer_len = data[ 0 + offset ];
            field_2_footer     = new String(data, 3 + offset, 
                                            LittleEndian.ubyteToInt( field_1_footer_len) );
        }
    }

    

    public void setFooterLength(byte len)
    {
        field_1_footer_len = len;
    }

    

    public void setFooter(String footer)
    {
        field_2_footer = footer;
    }

    

    public short getFooterLength()
    {
        return (short)(0xFF & field_1_footer_len); 
    }

    

    public String getFooter()
    {
        return field_2_footer;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FOOTER]
"");
        buffer.append(""    .footerlen      = "")
            .append(Integer.toHexString(getFooterLength())).append(""
"");
        buffer.append(""    .footer         = "").append(getFooter())
            .append(""
"");
        buffer.append(""[/FOOTER]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        int len = 4;

        if (getFooterLength() > 0)
        {
            len+=3; 
        }
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) ((len - 4) + getFooterLength()));
        if (getFooterLength() > 0)
        {
            data[ 4 + offset ] = (byte)getFooterLength();
            StringUtil.putCompressedUnicode(getFooter(), data, 7 + offset); 
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        int retval = 4;

        if (getFooterLength() > 0)
        {
            retval+=3; 
        }
        return retval + getFooterLength();
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.WriteAccessRecord,11,2,0,6,29,43,2,4,9,0.85,156,0.5,0,0.578947368,0.418181818,1,6,13.0,2,0.9091,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class WriteAccessRecord
    extends Record
{
    public final static short sid = 0x5c;
    private String            field_1_username;

    public WriteAccessRecord()
    {
    }

    

    public WriteAccessRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public WriteAccessRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A WRITEACCESS RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_username = new String(data, 3 + offset, data.length - 4);
    }

    

    public void setUsername(String username)
    {
        field_1_username = username;
    }

    

    public String getUsername()
    {
        return field_1_username;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WRITEACCESS]
"");
        buffer.append(""    .name            = "")
            .append(field_1_username.toString()).append(""
"");
        buffer.append(""[/WRITEACCESS]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        String       username = getUsername();
        StringBuffer temp     = new StringBuffer(0x70 - (0x3));

        temp.append(username);
        while (temp.length() < 0x70 - 0x3)
        {
            temp.append(
                "" "");   
        }
        username = temp.toString();
        UnicodeString str = new UnicodeString();

        str.setString(username);
        str.setOptionFlags(( byte ) 0x0);
        str.setCharCount(( short ) 0x4);
        byte[] stringbytes = str.serialize();

        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) (stringbytes
                                  .length));   
        System.arraycopy(stringbytes, 0, data, 4 + offset,
                         stringbytes.length);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 116;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.AreaPtg,23,2,0,2,36,201,1,2,23,0.833333333,379,0.833333333,0,0.25,0.369565217,1,2,15.2173913,2,1.1304,8,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.LittleEndian;



public class AreaPtg
    extends Ptg
{
    public final static short sid  = 0x25;
    private final static int  SIZE = 9;
    private short             field_1_first_row;
    private short             field_2_last_row;
    private short             field_3_first_column;
    private short             field_4_last_column;

    

    public AreaPtg()
    {
    }

    public AreaPtg(byte [] data, int offset)
    {
        offset++;
        field_1_first_row    = LittleEndian.getShort(data, 0 + offset);
        field_2_last_row     = LittleEndian.getShort(data, 2 + offset);
        field_3_first_column = LittleEndian.getShort(data, 4 + offset);
        field_4_last_column  = LittleEndian.getShort(data, 6 + offset);
        System.out.println(toString());
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""AreaPtg
"");
        buffer.append(""firstRow = "" + getFirstRow()).append(""
"");
        buffer.append(""lastRow  = "" + getLastRow()).append(""
"");
        buffer.append(""firstCol = "" + getFirstColumn()).append(""
"");
        buffer.append(""lastCol  = "" + getLastColumn()).append(""
"");
        buffer.append(""firstColRowRel= ""
                      + isFirstColRowRelative()).append(""
"");
        buffer.append(""lastColRowRel = ""
                      + isLastColRowRelative()).append(""
"");
        buffer.append(""firstColRel   = "" + isFirstColRelative()).append(""
"");
        buffer.append(""lastColRel    = "" + isLastColRelative()).append(""
"");
        return buffer.toString();
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return SIZE;
    }

    public short getFirstRow()
    {
        return field_1_first_row;
    }

    public void setFirstRow(short row)
    {
        field_1_first_row = row;
    }

    public short getLastRow()
    {
        return field_2_last_row;
    }

    public void setLastRow(short row)
    {
        field_2_last_row = row;
    }

    public short getFirstColumn()
    {
        return ( short ) (field_3_first_column & 0x3FFF);
    }

    public short getFirstColumnRaw()
    {
        return field_3_first_column;
    }

    public boolean isFirstColRowRelative()
    {
        return (((getFirstColumnRaw()) & 0x8000) == 0x8000);
    }

    public boolean isFirstColRelative()
    {
        return (((getFirstColumnRaw()) & 0x4000) == 0x4000);
    }

    public void setFirstColumn(short column)
    {
        field_3_first_column = column;   
    }

    public void setFirstColumnRaw(short column)
    {
        field_3_first_column = column;
    }

    public short getLastColumn()
    {
        return ( short ) (field_4_last_column & 0x3FFF);   
    }

    public short getLastColumnRaw()
    {
        return field_4_last_column;
    }

    public boolean isLastColRowRelative()
    {
        return (((getLastColumnRaw()) & 0x8000) == 1);
    }

    public boolean isLastColRelative()
    {
        return (((getFirstColumnRaw()) & 0x4000) == 1);
    }

    public void setLastColumn(short column)
    {
        field_4_last_column = column;   
    }

    public void setLastColumnRaw(short column)
    {
        field_4_last_column = column;
    }

    public String toFormulaString()
    {
        String firstrow = """" + (getFirstRow() + 1);
        String lastrow  = null;

        if (isLastColRowRelative())
        {
            lastrow = """" + (getFirstRow() + getLastRow());
        }
        else
        {
            lastrow = """" + (getLastRow() + 1);
        }

        
        
        return colNumToLetter(getFirstColumn()) + firstrow + "":""
               + colNumToLetter(getLastColumn()) + lastrow;
    }

    public String colNumToLetter(int col)
    {
        byte[] b =
        {
            0x41
        };

        b[ 0 ] += ( byte ) col;
        String retval = null;

        try
        {
            retval = new String(b, ""UTF-8"");
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(
                ""NON JDK 1.3 COMPLIANT JVM -- YOUR JVM MUST SUPPORT UTF-8 encoding as per docs!"");
        }
        return retval;
    }
}
"
poi,1.5,org.apache.poi.poifs.property.PropertyTable,11,1,0,11,34,0,2,9,10,0.566666667,210,1.0,1,0.0,0.272727273,0,0,17.81818182,3,1.0909,0,"


package org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.PropertyBlock;
import org.apache.poi.poifs.storage.RawDataBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;



public class PropertyTable
    implements BATManaged, BlockWritable
{
    private int             _start_block;
    private List            _properties;
    private BlockWritable[] _blocks;

    

    public PropertyTable()
    {
        _start_block = POIFSConstants.END_OF_CHAIN;
        _properties  = new ArrayList();
        addProperty(new RootProperty());
        _blocks = null;
    }

    

    public PropertyTable(final int startBlock,
                         final RawDataBlockList blockList)
        throws IOException
    {
        _start_block = POIFSConstants.END_OF_CHAIN;
        _blocks      = null;
        _properties  =
            PropertyFactory
                .convertToProperties(blockList.fetchBlocks(startBlock));
        populatePropertyTree(( DirectoryProperty ) _properties.get(0));
    }

    

    public void addProperty(final Property property)
    {
        _properties.add(property);
    }

    

    public void removeProperty(final Property property)
    {
        _properties.remove(property);
    }

    

    public RootProperty getRoot()
    {

        
        return ( RootProperty ) _properties.get(0);
    }

    

    public void preWrite()
    {
        Property[] properties =
            ( Property [] ) _properties.toArray(new Property[ 0 ]);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].setIndex(k);
        }

        
        _blocks = PropertyBlock.createPropertyBlockArray(_properties);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].preWrite();
        }
    }

    

    public int getStartBlock()
    {
        return _start_block;
    }

    private void populatePropertyTree(DirectoryProperty root)
        throws IOException
    {
        int index = root.getChildIndex();

        if (!Property.isValidIndex(index))
        {

            
            return;
        }
        Stack children = new Stack();

        children.push(_properties.get(index));
        while (!children.empty())
        {
            Property property = ( Property ) children.pop();

            root.addChild(property);
            if (property.isDirectory())
            {
                populatePropertyTree(( DirectoryProperty ) property);
            }
            index = property.getPreviousChildIndex();
            if (Property.isValidIndex(index))
            {
                children.push(_properties.get(index));
            }
            index = property.getNextChildIndex();
            if (Property.isValidIndex(index))
            {
                children.push(_properties.get(index));
            }
        }
    }

    

    

    public int countBlocks()
    {
        return (_blocks == null) ? 0
                                 : _blocks.length;
    }

    

    public void setStartBlock(final int index)
    {
        _start_block = index;
    }

    
    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        if (_blocks != null)
        {
            for (int j = 0; j < _blocks.length; j++)
            {
                _blocks[ j ].writeBlocks(stream);
            }
        }
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFColorConstants,0,1,0,2,0,0,2,0,0,2.0,41,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"



package org.apache.poi.hssf.usermodel;



public interface HSSFColorConstants
{

    public final static short AUTOMATIC       = 0x40;

    public final static short BLACK           = 0x8;    
    public final static short BROWN           = 0x3c;   
    public final static short OLIVE_GREEN     = 0x3b;   
    public final static short DARK_GREEN      = 0x3a;   
    public final static short DARK_TEAL       = 0x38;   
    public final static short DARK_BLUE       = 0x12;   
    public final static short INDIGO          = 0x3e;   
    public final static short GREY_80_PERCENT = 0x3f;   
    public final static short DARK_RED        = 0x10;   
    public final static short ORANGE          = 0x35;   
    public final static short DARK_YELLOW     = 0x13;   
    public final static short GREEN           = 0x11;   
    public final static short TEAL            = 0x15;   
    public final static short BLUE            = 0xc;    
    public final static short BLUE_GREY       = 0x36;   
    public final static short GREY_50_PERCENT = 0x17;   
    public final static short RED             = 0xa;    
    public final static short LIGHT_ORANGE    = 0x34;   
    public final static short LIME            = 0x32;   
    public final static short SEA_GREEN       = 0x39;   
    public final static short AQUA            = 0x31;   
    public final static short LIGHT_BLUE      = 0x30;   
    public final static short VIOLET          = 0x14;   
    public final static short GREY_40_PERCENT = 0x37;   
    public final static short PINK            = 0xe;    
    public final static short GOLD            = 0x33;   
    public final static short YELLOW          = 0xd;    
    public final static short BRIGHT_GREEN    = 0xb;    
    public final static short TURQUOISE       = 0xf;    
    public final static short SKY_BLUE        = 0x28;   
    public final static short PLUM            = 0x3d;   
    public final static short GREY_25_PERCENT = 0x16;   
    public final static short ROSE            = 0x2d;   
    public final static short TAN             = 0x2f;   
    public final static short LIGHT_YELLOW    = 0x2b;   
    public final static short LIGHT_GREEN     = 0x2a;   
    public final static short LIGHT_TURQUOISE = 0x29;   
    public final static short PALE_BLUE       = 0x2c;   
    public final static short LAVENDER        = 0x2e;   
    public final static short WHITE           = 0x9;    
}
"
poi,1.5,org.apache.poi.hssf.record.BookBoolRecord,11,2,0,5,21,43,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class BookBoolRecord
    extends Record
{
    public final static short sid = 0xDA;
    private short             field_1_save_link_values;

    public BookBoolRecord()
    {
    }

    

    public BookBoolRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public BookBoolRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A BOOKBOOL RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_save_link_values = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setSaveLinkValues(short flag)
    {
        field_1_save_link_values = flag;
    }

    

    public short getSaveLinkValues()
    {
        return field_1_save_link_values;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BOOKBOOL]
"");
        buffer.append(""    .savelinkvalues  = "")
            .append(Integer.toHexString(getSaveLinkValues())).append(""
"");
        buffer.append(""[/BOOKBOOL]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, field_1_save_link_values);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.NumberRecord,24,2,0,10,39,252,6,4,22,0.782608696,365,0.8,0,0.34375,0.261904762,1,6,14.0,7,1.7917,1,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.hssf.record.Record;



public class NumberRecord
    extends Record
    implements CellValueRecordInterface, Comparable
{
    public static final short sid = 0x203;
    private short             field_1_row;
    private short             field_2_col;
    private short             field_3_xf;
    private double            field_4_value;

    
    public NumberRecord()
    {
    }

    

    public NumberRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public NumberRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row   = LittleEndian.getShort(data, 0 + offset);
        field_2_col   = LittleEndian.getShort(data, 2 + offset);
        field_3_xf    = LittleEndian.getShort(data, 4 + offset);
        field_4_value = LittleEndian.getDouble(data, 6 + offset);
    }

    public void setRow(short row)
    {
        field_1_row = row;
    }

    public void setColumn(short col)
    {
        field_2_col = col;
    }

    

    public void setXFIndex(short xf)
    {
        field_3_xf = xf;
    }

    

    public void setValue(double value)
    {
        field_4_value = value;
    }

    public short getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_col;
    }

    

    public short getXFIndex()
    {
        return field_3_xf;
    }

    

    public double getValue()
    {
        return field_4_value;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[NUMBER]
"");
        buffer.append(""    .row            = "")
            .append(Integer.toHexString(getRow())).append(""
"");
        buffer.append(""    .col            = "")
            .append(Integer.toHexString(getColumn())).append(""
"");
        buffer.append(""    .xfindex        = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        buffer.append(""    .value          = "").append(getValue())
            .append(""
"");
        buffer.append(""[/NUMBER]
"");
        return buffer.toString();
    }

    

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 14);
        LittleEndian.putShort(data, 4 + offset, getRow());
        LittleEndian.putShort(data, 6 + offset, getColumn());
        LittleEndian.putShort(data, 8 + offset, getXFIndex());
        LittleEndian.putDouble(data, 10 + offset, getValue());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 18;
    }

    

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A Number RECORD"");
        }
    }

    public short getSid()
    {
        return this.sid;
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    public int compareTo(Object obj)
    {
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return 0;
        }
        if (this.getRow() < loc.getRow())
        {
            return -1;
        }
        if (this.getRow() > loc.getRow())
        {
            return 1;
        }
        if (this.getColumn() < loc.getColumn())
        {
            return -1;
        }
        if (this.getColumn() > loc.getColumn())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof CellValueRecordInterface))
        {
            return false;
        }
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.FormulaParser,30,1,0,9,66,297,0,9,4,0.659003831,583,1.0,0,0.0,0.353448276,0,0,18.13333333,5,1.9,6,"



package org.apache.poi.hssf.record.formula;

import java.util.List;
import java.util.ArrayList;
import java.util.Stack;


public class FormulaParser {
    
    private String formulaString;
    private int pointer=0;
    
    private Stack operationsList = new java.util.Stack();
    private Stack operandsList = new java.util.Stack();
    private List result = new ArrayList();
    private int numParen;
    
    
    
    
    private static char TAB = '	';
    private static char CR = '
';
    
    
    
    
    private char Look;              
    
    public FormulaParser(String formula){
        formulaString = formula;
        pointer=0;
    }
    
    
    
    
    private void GetChar() {
        Look=formulaString.charAt(pointer++);
        System.out.println(""Got char: ""+Look);
    }
    
    
    
    
    private void Error(String s) {
        System.out.println(""Error: ""+s);
    }
    
    
    
    
    
    private void Abort(String s) {
        Error(s);
        
        throw new RuntimeException(""Cannot Parse, sorry"");
    }
    
    
    
    
    
    private void Expected(String s) {
        Abort(s + "" Expected"");
    }
    
    
    
    
    
    private boolean IsAlpha(char c) {
        return Character.isLetter(c);
        
    }
    
    
    
    
    
    private boolean IsDigit(char c) {
        System.out.println(""Checking digit for""+c);
        return Character.isDigit(c);
        
        
    }
    
    
    
    
    
    private boolean  IsAlNum(char c) {
        return  (IsAlpha(c) || IsDigit(c));
    }
    
    
    
    
    
    private boolean IsAddop( char c) {
        return (c =='+' || c =='-');
    }
    
    
    
    
    
    private boolean IsWhite( char c) {
        return  (c ==' ' || c== TAB);
    }
    
    
    
    
    
    private void SkipWhite() {
        while (IsWhite(Look)) {
            GetChar();
        }
    }
    
    
    
    
    
    private void Match(char x) {
        if (Look != x) {
            Expected("""" + x + """");
        }else {
            GetChar();
            SkipWhite();
        }
    }
    
    
    
    
    
    private String GetName() {
        String Token;
        Token = """";
        if (!IsAlpha(Look)) {
            Expected(""Name"");
        }
        while (IsAlNum(Look)) {
            Token = Token + Character.toUpperCase(Look);
            GetChar();
        }
        
        SkipWhite();
        return Token;
    }
    
    
    
    
    
    private String GetNum() {
        String Value ="""";
        if  (!IsDigit(Look)) Expected(""Integer"");
        while (IsDigit(Look)){
            Value = Value + Look;
            GetChar();
        }
        SkipWhite();
        return Value;
    }
    
    
    
    
    
    private void  Emit(String s){
        System.out.print(TAB+s);
    }
    
    
    
    
    
    private void EmitLn(String s) {
        Emit(s);
        System.out.println();;
    }
    
    
    
    
    
    private void Ident() {
        String Name;
        Name = GetName();
        if (Look == '('){
            Match('(');
            
            Match(')');
            
            
        } else {
            
            
            
            boolean cellRef = true ; 
            if (cellRef) {
                operationsList.add(new ValueReferencePtg()); 
            }else {
                
            }
        }
    }

    
    
    
    
    
    
    private void Factor() {
        if (Look == '(' ) {
            Match('(');
            operationsList.add(new ParenthesisPtg());
            Expression();
            Match(')');
            operationsList.add(new ParenthesisPtg());
            return;
        } else if (IsAlpha(Look)){
            Ident();
        }else{
            
            IntPtg p = new IntPtg();
            p.setValue(Short.parseShort(GetNum()));
            operandsList.add(p);
        }
    }

    
    
    
    
    private void Multiply(){
        Match('*');
        Factor();
        operationsList.add(new MultiplyPtg());
        
    }
    
    
    
    
    
    private void Divide() {
        Match('/');
        Factor();
        operationsList.add(new DividePtg());
        
        
        
    }
    
    
    
    
    
    private void  Term(){
        Factor();
        while (Look == '*' || Look == '/' ) {
            
            
            if (Look == '*') Multiply();
            if (Look == '/') Divide();
        }
    }
    
    
    
    
    
    private void Add() {
        Match('+');
        Term();
        
        operationsList.add(new AddPtg());
    }
    
    
    
    
    
    private void Subtract() {
        Match('-');
        Term();
        operationsList.add(new SubtractPtg());
        
        
    }
    
    
    
    
    
    private void Expression() {
        if (IsAddop(Look)) {
            EmitLn(""CLR D0"");  
        } else {
            Term();
        }
        while (IsAddop(Look)) {
            EmitLn(""MOVE D0,-(SP)"");
            if ( Look == '+' )  Add();
            if (Look == '-') Subtract();
        }
    }
    
    
    
    
    
    
    
    
    
    private void  Init() {
        GetChar();
        SkipWhite();
    }
    
    public void parse() {
        Init();
        Expression();
        
        tokenToRPN();
    }
    
    private void tokenToRPN() {
        OperationPtg op;
        Ptg operand;
        int numOper = 0;
        int numOnStack = 0;
        result.add(operandsList.pop()); numOnStack++;
        
        while (!operationsList.isEmpty()) {
            op = (OperationPtg) operationsList.pop();
            if (op instanceof ParenthesisPtg) {
                
            }
            
            
            for (numOper = op.getNumberOfOperands();numOper>0;numOper--) {
                if (numOnStack==0) {
                    result.add(operandsList.pop());
                } else {
                    numOnStack--;
                }
            }
            result.add(op);
            numOnStack++;
        }
    }
    
    public String toString() {
        StringBuffer buf = new StringBuffer();
           for (int i=0;i<result.size();i++) {
            buf.append( ( (Ptg)result.get(i)).toFormulaString());
            buf.append(' ');
        } 
        return buf.toString();
    }
    
    
    
    
    public static void main(String[] argv) {
        FormulaParser fp = new FormulaParser(argv[0]+"";"");
        fp.parse();
        System.out.println(fp.toString());
        
        
    }
    
    
} "
poi,1.5,org.apache.poi.poifs.storage.ListManagedBlock,1,1,0,13,1,0,13,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.storage;

import java.io.IOException;



public interface ListManagedBlock
{

    

    public byte [] getData()
        throws IOException;
}   

"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFRow,24,1,0,8,51,84,3,5,16,0.673913043,451,0.833333333,3,0.0,0.183333333,0,0,17.54166667,5,1.7083,0,"


package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.model.Sheet;
import org.apache.poi.hssf.model.Workbook;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.RowRecord;

import java.util.HashMap;
import java.util.Iterator;



public class HSSFRow
        implements Comparable
{

    
    public final static int INITIAL_CAPACITY = 5;
    private short rowNum;
    private HashMap cells;



    

    private RowRecord row;

    

    private Workbook book;

    

    private Sheet sheet;

    protected HSSFRow()
    {
    }

    

    protected HSSFRow(Workbook book, Sheet sheet, short rowNum)
    {
        this.rowNum = rowNum;
        cells = new HashMap(10);   
        this.book = book;
        this.sheet = sheet;
        row = new RowRecord();
        row.setHeight((short) 0xff);
        row.setLastCol((short) -1);
        row.setFirstCol((short) -1);

        
        setRowNum(rowNum);
    }

    

    protected HSSFRow(Workbook book, Sheet sheet, RowRecord record)
    {
        this.rowNum = rowNum;
        cells = new HashMap();   
        this.book = book;
        this.sheet = sheet;
        row = record;

        
        
        setRowNum(record.getRowNumber());


    }

    

    public HSSFCell createCell(short column)
    {
        HSSFCell cell = new HSSFCell(book, sheet, getRowNum(), column);

        addCell(cell);
        sheet.addValueRecord(getRowNum(), cell.getCellValueRecord());
        return cell;
    }

    

    public HSSFCell createCell(short column, int type)
    {
        HSSFCell cell = new HSSFCell(book, sheet, getRowNum(), column, type);

        addCell(cell);
        sheet.addValueRecord(getRowNum(), cell.getCellValueRecord());
        return cell;
    }

    
    public void removeCell(HSSFCell cell)
    {
        CellValueRecordInterface cval = cell.getCellValueRecord();

        sheet.removeValueRecord(getRowNum(), cval);
        cells.remove(new Integer(cell.getCellNum()));

        if (cell.getCellNum() == row.getLastCol())
        {
            row.setLastCol(findLastCell(row.getLastCol()));
        }
        if (cell.getCellNum() == row.getFirstCol())
        {
            row.setFirstCol(findFirstCell(row.getFirstCol()));
        }
    }

    

    protected HSSFCell createCellFromRecord(CellValueRecordInterface cell)
    {
        HSSFCell hcell = new HSSFCell(book, sheet, getRowNum(), cell);

        addCell(hcell);

        
        return hcell;
    }

    

    public void setRowNum(short rowNum)
    {
        this.rowNum = rowNum;
        if (row != null)
        {
            row.setRowNumber(rowNum);   
        }
    }

    

    public short getRowNum()
    {
        return rowNum;
    }

    

    private void addCell(HSSFCell cell)
    {
        if (row.getFirstCol() == -1)
        {
            row.setFirstCol(cell.getCellNum());
        }
        if (row.getLastCol() == -1)
        {
            row.setLastCol(cell.getCellNum());
        }
        cells.put(new Integer(cell.getCellNum()), cell);

        if (cell.getCellNum() < row.getFirstCol())
        {
            row.setFirstCol(cell.getCellNum());
        }
        if (cell.getCellNum() > row.getLastCol())
        {
            row.setLastCol(cell.getCellNum());
        }
    }

    

    public HSSFCell getCell(short cellnum)
    {


        return (HSSFCell) cells.get(new Integer(cellnum));
    }

    

    public short getFirstCellNum()
    {
        if (getPhysicalNumberOfCells() == 0)
            return -1;
        else
            return row.getFirstCol();
    }

    

    public short getLastCellNum()
    {
        if (getPhysicalNumberOfCells() == 0)
            return -1;
        else
            return row.getLastCol();
    }


    

    public int getPhysicalNumberOfCells()
    {
        if (cells == null)
        {
            return 0;   
        }
        return cells.size();
    }

    

    public void setHeight(short height)
    {

        
        row.setBadFontHeight(true);
        row.setHeight(height);
    }

    

    public void setHeightInPoints(float height)
    {

        
        row.setBadFontHeight(true);
        row.setHeight((short) (height * 20));
    }

    

    public short getHeight()
    {
        return row.getHeight();
    }

    

    public float getHeightInPoints()
    {
        return (row.getHeight() / 20);
    }

    

    protected RowRecord getRowRecord()
    {
        return row;
    }

    

    private short findLastCell(short lastcell)
    {
        short cellnum = (short) (lastcell - 1);
        HSSFCell r = getCell(cellnum);

        while (r == null && cellnum >= 0)
        {
            r = getCell(--cellnum);
        }
        return cellnum;
    }

    

    private short findFirstCell(short firstcell)
    {
        short cellnum = (short) (firstcell + 1);
        HSSFCell r = getCell(cellnum);

        while (r == null && cellnum <= getLastCellNum())
        {
            r = getCell(++cellnum);
        }
        if (cellnum > getLastCellNum())
            return -1;
        return cellnum;
    }

    

    public Iterator cellIterator()
    {
        return cells.values().iterator();
    }

    public int compareTo(Object obj)
    {
        HSSFRow loc = (HSSFRow) obj;

        if (this.getRowNum() == loc.getRowNum())
        {
            return 0;
        }
        if (this.getRowNum() < loc.getRowNum())
        {
            return -1;
        }
        if (this.getRowNum() > loc.getRowNum())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof HSSFRow))
        {
            return false;
        }
        HSSFRow loc = (HSSFRow) obj;

        if (this.getRowNum() == loc.getRowNum())
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.POIFSDocument,16,1,0,20,55,0,9,14,14,0.5,453,1.0,3,0.0,0.198863636,0,0,27.0625,6,1.0625,0,"


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.ListManagedBlock;
import org.apache.poi.poifs.storage.DocumentBlock;
import org.apache.poi.poifs.storage.RawDataBlock;
import org.apache.poi.poifs.storage.SmallDocumentBlock;
import org.apache.poi.util.HexDump;



public class POIFSDocument
    implements BATManaged, BlockWritable, POIFSViewable
{
    private DocumentProperty _property;
    private int              _size;

    
    private SmallBlockStore  _small_store;
    private BigBlockStore    _big_store;

    

    public POIFSDocument(final String name, final RawDataBlock [] blocks,
                         final int length)
        throws IOException
    {
        _size        = length;
        _big_store   = new BigBlockStore(blocks);
        _property    = new DocumentProperty(name, _size);
        _small_store = new SmallBlockStore(new BlockWritable[ 0 ]);
        _property.setDocument(this);
    }

    

    public POIFSDocument(final String name,
                         final SmallDocumentBlock [] blocks, final int length)
    {
        _size = length;
        try
        {
            _big_store = new BigBlockStore(new RawDataBlock[ 0 ]);
        }
        catch (IOException ignored)
        {

            
        }
        _property    = new DocumentProperty(name, _size);
        _small_store = new SmallBlockStore(blocks);
        _property.setDocument(this);
    }

    

    public POIFSDocument(final String name, final ListManagedBlock [] blocks,
                         final int length)
        throws IOException
    {
        _size     = length;
        _property = new DocumentProperty(name, _size);
        _property.setDocument(this);
        if (Property.isSmall(_size))
        {
            _big_store   = new BigBlockStore(new RawDataBlock[ 0 ]);
            _small_store = new SmallBlockStore(blocks);
        }
        else
        {
            _big_store   = new BigBlockStore(blocks);
            _small_store = new SmallBlockStore(new BlockWritable[ 0 ]);
        }
    }

    

    public POIFSDocument(final String name, final InputStream stream)
        throws IOException
    {
        List blocks = new ArrayList();

        _size = 0;
        while (true)
        {
            DocumentBlock block     = new DocumentBlock(stream);
            int           blockSize = block.size();

            if (blockSize > 0)
            {
                blocks.add(block);
                _size += blockSize;
            }
            if (block.partiallyRead())
            {
                break;
            }
        }
        DocumentBlock[] bigBlocks =
            ( DocumentBlock [] ) blocks.toArray(new DocumentBlock[ 0 ]);

        _big_store = new BigBlockStore(bigBlocks);
        _property  = new DocumentProperty(name, _size);
        _property.setDocument(this);
        if (_property.shouldUseSmallBlocks())
        {
            _small_store =
                new SmallBlockStore(SmallDocumentBlock.convert(bigBlocks,
                    _size));
            _big_store   = new BigBlockStore(new DocumentBlock[ 0 ]);
        }
        else
        {
            _small_store = new SmallBlockStore(new BlockWritable[ 0 ]);
        }
    }

    

    public POIFSDocument(final String name, final int size,
                         final POIFSDocumentPath path,
                         final POIFSWriterListener writer)
        throws IOException
    {
        _size     = size;
        _property = new DocumentProperty(name, _size);
        _property.setDocument(this);
        if (_property.shouldUseSmallBlocks())
        {
            _small_store = new SmallBlockStore(path, name, size, writer);
            _big_store   = new BigBlockStore(new Object[ 0 ]);
        }
        else
        {
            _small_store = new SmallBlockStore(new BlockWritable[ 0 ]);
            _big_store   = new BigBlockStore(path, name, size, writer);
        }
    }

    

    public BlockWritable [] getSmallBlocks()
    {
        return _small_store.getBlocks();
    }

    

    public int getSize()
    {
        return _size;
    }

    

    void read(final byte [] buffer, final int offset)
    {
        if (_property.shouldUseSmallBlocks())
        {
            SmallDocumentBlock.read(_small_store.getBlocks(), buffer, offset);
        }
        else
        {
            DocumentBlock.read(_big_store.getBlocks(), buffer, offset);
        }
    }

    

    DocumentProperty getDocumentProperty()
    {
        return _property;
    }

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        _big_store.writeBlocks(stream);
    }

    
    

    

    public int countBlocks()
    {
        return _big_store.countBlocks();
    }

    

    public void setStartBlock(final int index)
    {
        _property.setStartBlock(index);
    }

    
    

    

    public Object [] getViewableArray()
    {
        Object[] results = new Object[ 1 ];
        String   result;

        try
        {
            ByteArrayOutputStream output = new ByteArrayOutputStream();
            BlockWritable[]       blocks = null;

            if (_big_store.isValid())
            {
                blocks = _big_store.getBlocks();
            }
            else if (_small_store.isValid())
            {
                blocks = _small_store.getBlocks();
            }
            if (blocks != null)
            {
                for (int k = 0; k < blocks.length; k++)
                {
                    blocks[ k ].writeBlocks(output);
                }
                byte[] data = output.toByteArray();

                if (data.length > _property.getSize())
                {
                    byte[] tmp = new byte[ _property.getSize() ];

                    System.arraycopy(data, 0, tmp, 0, tmp.length);
                    data = tmp;
                }
                output = new ByteArrayOutputStream();
                HexDump.dump(data, 0, output, 0);
                result = output.toString();
            }
            else
            {
                result = ""<NO DATA>"";
            }
        }
        catch (IOException e)
        {
            result = e.getMessage();
        }
        results[ 0 ] = result;
        return results;
    }

    

    public Iterator getViewableIterator()
    {
        return Collections.EMPTY_LIST.iterator();
    }

    

    public boolean preferArray()
    {
        return true;
    }

    

    public String getShortDescription()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""Document: """").append(_property.getName())
            .append("""""");
        buffer.append("" size = "").append(getSize());
        return buffer.toString();
    }

    
    private class SmallBlockStore
    {
        private SmallDocumentBlock[] smallBlocks;
        private POIFSDocumentPath    path;
        private String               name;
        private int                  size;
        private POIFSWriterListener  writer;

        

        SmallBlockStore(final Object [] blocks)
        {
            smallBlocks = new SmallDocumentBlock[ blocks.length ];
            for (int j = 0; j < blocks.length; j++)
            {
                smallBlocks[ j ] = ( SmallDocumentBlock ) blocks[ j ];
            }
            this.path   = null;
            this.name   = null;
            this.size   = -1;
            this.writer = null;
        }

        

        SmallBlockStore(final POIFSDocumentPath path, final String name,
                        final int size, final POIFSWriterListener writer)
        {
            smallBlocks = new SmallDocumentBlock[ 0 ];
            this.path   = path;
            this.name   = name;
            this.size   = size;
            this.writer = writer;
        }

        

        boolean isValid()
        {
            return ((smallBlocks.length > 0) || (writer != null));
        }

        

        BlockWritable [] getBlocks()
        {
            if (isValid() && (writer != null))
            {
                ByteArrayOutputStream stream  =
                    new ByteArrayOutputStream(size);
                DocumentOutputStream  dstream =
                    new DocumentOutputStream(stream, size);

                writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream,
                        path, name, size));
                smallBlocks = SmallDocumentBlock.convert(stream.toByteArray(),
                                                         size);
            }
            return smallBlocks;
        }
    }   

    private class BigBlockStore
    {
        private DocumentBlock[]     bigBlocks;
        private POIFSDocumentPath   path;
        private String              name;
        private int                 size;
        private POIFSWriterListener writer;

        

        BigBlockStore(final Object [] blocks)
            throws IOException
        {
            bigBlocks = new DocumentBlock[ blocks.length ];
            for (int j = 0; j < blocks.length; j++)
            {
                if (blocks[ j ] instanceof DocumentBlock)
                {
                    bigBlocks[ j ] = ( DocumentBlock ) blocks[ j ];
                }
                else
                {
                    bigBlocks[ j ] =
                        new DocumentBlock(( RawDataBlock ) blocks[ j ]);
                }
            }
            this.path   = null;
            this.name   = null;
            this.size   = -1;
            this.writer = null;
        }

        

        BigBlockStore(final POIFSDocumentPath path, final String name,
                      final int size, final POIFSWriterListener writer)
        {
            bigBlocks   = new DocumentBlock[ 0 ];
            this.path   = path;
            this.name   = name;
            this.size   = size;
            this.writer = writer;
        }

        

        boolean isValid()
        {
            return ((bigBlocks.length > 0) || (writer != null));
        }

        

        DocumentBlock [] getBlocks()
        {
            if (isValid() && (writer != null))
            {
                ByteArrayOutputStream stream  =
                    new ByteArrayOutputStream(size);
                DocumentOutputStream  dstream =
                    new DocumentOutputStream(stream, size);

                writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream,
                        path, name, size));
                bigBlocks = DocumentBlock.convert(stream.toByteArray(), size);
            }
            return bigBlocks;
        }

        

        void writeBlocks(OutputStream stream)
            throws IOException
        {
            if (isValid())
            {
                if (writer != null)
                {
                    DocumentOutputStream dstream =
                        new DocumentOutputStream(stream, size);

                    writer.processPOIFSWriterEvent(
                        new POIFSWriterEvent(dstream, path, name, size));
                    dstream.writeFiller(countBlocks()
                                        * POIFSConstants
                                            .BIG_BLOCK_SIZE, DocumentBlock
                                            .getFillByte());
                }
                else
                {
                    for (int k = 0; k < bigBlocks.length; k++)
                    {
                        bigBlocks[ k ].writeBlocks(stream);
                    }
                }
            }
        }

        

        int countBlocks()
        {
            int rval = 0;

            if (isValid())
            {
                if (writer != null)
                {
                    rval = (size + POIFSConstants.BIG_BLOCK_SIZE - 1)
                           / POIFSConstants.BIG_BLOCK_SIZE;
                }
                else
                {
                    rval = bigBlocks.length;
                }
            }
            return rval;
        }
    }   
}       

"
poi,1.5,org.apache.poi.hpsf.Section,10,1,0,6,22,27,2,4,8,0.80952381,222,1.0,2,0.0,0.5,0,0,20.5,4,1.5,6,"

package org.apache.poi.hpsf;

import java.util.*;
import org.apache.poi.hpsf.littleendian.*;
import org.apache.poi.hpsf.wellknown.*;


public class Section
{

    
    protected Map dictionary;



    private ClassID formatID;

    
    public ClassID getFormatID()
    {
        return formatID;
    }



    private int offset;

    
    public int getOffset()
    {
        return offset;
    }



    private int size;

    
    public int getSize()
    {
        return size;
    }



    private int propertyCount;

    
    public int getPropertyCount()
    {
        return propertyCount;
    }



    private Property[] properties;

    
    public Property[] getProperties()
    {
        return properties;
    }



    
    public Section(final byte[] src, int offset)
    {
        
        formatID = new ClassID(src, offset);
        offset += ClassID.LENGTH;

        
        this.offset = new DWord(src, offset).intValue();
        offset = this.offset;

        
        size = new DWord(src, offset).intValue();
        offset += DWord.LENGTH;

        
        propertyCount = new DWord(src, offset).intValue();
        offset += DWord.LENGTH;

        
        properties = new Property[propertyCount];
        for (int i = 0; i < properties.length; i++)
        {
            final int id = new DWord(src, offset).intValue();
            offset += DWord.LENGTH;

            
            final int sOffset = new DWord(src, offset).intValue();
            offset += DWord.LENGTH;

            
            int length;
            if (i == properties.length - 1)
                length = src.length - this.offset - sOffset;
            else
                length =
                    new DWord(src, offset + DWord.LENGTH).intValue() - sOffset;

            
            properties[i] =
                new Property(id, src, this.offset + sOffset, length);
        }

        
        dictionary = (Map) getProperty(0);
    }



    
    protected Object getProperty(final int id)
    {
        wasNull = false;
        for (int i = 0; i < properties.length; i++)
            if (id == properties[i].getID())
                return properties[i].getValue();
        wasNull = true;
        return null;
    }



    
    protected int getPropertyIntValue(final int id)
    {
        final Integer i = (Integer) getProperty(id);
        if (i != null)
            return i.intValue();
        else
            return 0;
    }



    private boolean wasNull;

    
    public boolean wasNull()
    {
        return wasNull;
    }



    
    public String getPIDString(final int pid)
    {
        String s = null;
        if (dictionary != null)
            s = (String) dictionary.get(new Integer(pid));
        if (s == null)
            s =  SectionIDMap.getPIDString(getFormatID().getBytes(), pid);
        if (s == null)
            s = SectionIDMap.UNDEFINED;
        return s;
    }

}
"
poi,1.5,org.apache.poi.hssf.record.InterfaceEndRecord,9,2,0,5,17,36,2,3,7,1.125,72,0.0,0,0.647058824,0.555555556,1,6,6.888888889,2,0.7778,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class InterfaceEndRecord
    extends Record
{
    public final static short sid = 0xe2;

    public InterfaceEndRecord()
    {
    }

    

    public InterfaceEndRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public InterfaceEndRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A INTERFACEEND RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[INTERFACEEND]
"");
        buffer.append(""[/INTERFACEEND]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x00));   
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 4;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.aggregates.RowRecordsAggregate,14,2,0,4,33,35,1,3,12,0.673076923,183,0.0,0,0.458333333,0.297619048,1,5,11.78571429,5,1.5714,3,"


package org.apache.poi.hssf.record.aggregates;

import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RowRecord;
import org.apache.poi.hssf.record.UnknownRecord;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;



public class RowRecordsAggregate
    extends Record
{
    int     firstrow = -1;
    int     lastrow  = -1;
    HashMap records  = null;
    int     size     = 0;

    

    public RowRecordsAggregate()
    {
        records = new HashMap();
    }

    public void insertRow(RowRecord row)
    {
        size += row.getRecordSize();

        
        records.put(row, row);
        if ((row.getRowNumber() < firstrow) || (firstrow == -1))
        {
            firstrow = row.getRowNumber();
        }
        if ((row.getRowNumber() > lastrow) || (lastrow == -1))
        {
            lastrow = row.getRowNumber();
        }
    }

    public void removeRow(RowRecord row)
    {
        size -= row.getRecordSize();

        
        records.remove(row);
    }

    public RowRecord getRow(int rownum)
    {

        
        RowRecord row = new RowRecord();

        row.setRowNumber(( short ) rownum);
        return ( RowRecord ) records.get(row);
    }

    public int getPhysicalNumberOfRows()
    {
        return records.size();
    }

    public int getFirstRowNum()
    {
        return firstrow;
    }

    public int getLastRowNum()
    {
        return lastrow;
    }

    public int construct(int offset, List records)
    {
        int k = 0;

        for (k = offset; k < records.size(); k++)
        {
            Record rec = ( Record ) records.get(k);

            if (!rec.isInValueSection() && !(rec instanceof UnknownRecord))
            {
                break;
            }
            if (rec.getSid() == RowRecord.sid)
            {
                insertRow(( RowRecord ) rec);
            }
        }
        return k;
    }

    

    public int serialize(int offset, byte [] data)
    {
        Iterator itr = records.values().iterator();
        int      pos = offset;

        while (itr.hasNext())
        {
            pos += (( Record ) itr.next()).serialize(pos, data);
        }
        return pos - offset;
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    

    protected void validateSid(short id)
    {
    }

    

    public short getSid()
    {
        return -1000;
    }

    public int getRecordSize()
    {
        return size;
    }

    public Iterator getIterator()
    {
        return records.values().iterator();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.SelectionRecord,19,2,0,5,29,141,2,3,17,0.865079365,266,0.857142857,0,0.407407407,0.368421053,1,6,12.63157895,2,0.8947,1,"


package org.apache.poi.hssf.record;

import java.util.*;

import org.apache.poi.util.LittleEndian;



public class SelectionRecord
    extends Record
{
    public final static short sid = 0x1d;
    private byte              field_1_pane;
    private short             field_2_row_active_cell;
    private short             field_3_col_active_cell;
    private short             field_4_ref_active_cell;
    private short             field_5_num_refs;
    private ArrayList         field_6_refs;     

    public SelectionRecord()
    {
    }

    

    public SelectionRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SelectionRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid Selection RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_pane            = data[ 0 + offset ];
        field_2_row_active_cell = LittleEndian.getShort(data, 1 + offset);
        field_3_col_active_cell = LittleEndian.getShort(data, 3 + offset);
        field_4_ref_active_cell = LittleEndian.getShort(data, 5 + offset);
        field_5_num_refs        = LittleEndian.getShort(data, 7 + offset);
    }

    

    public void setPane(byte pane)
    {
        field_1_pane = pane;
    }

    

    public void setActiveCellRow(short row)
    {
        field_2_row_active_cell = row;
    }

    

    public void setActiveCellCol(short col)
    {
        field_3_col_active_cell = col;
    }

    

    public void setActiveCellRef(short ref)
    {
        field_4_ref_active_cell = ref;
    }

    

    public void setNumRefs(short refs)
    {
        field_5_num_refs = refs;
    }

    

    public byte getPane()
    {
        return field_1_pane;
    }

    

    public short getActiveCellRow()
    {
        return field_2_row_active_cell;
    }

    

    public short getActiveCellCol()
    {
        return field_3_col_active_cell;
    }

    

    public short getActiveCellRef()
    {
        return field_4_ref_active_cell;
    }

    

    public short getNumRefs()
    {
        return field_5_num_refs;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SELECTION]
"");
        buffer.append(""    .pane            = "")
            .append(Integer.toHexString(getPane())).append(""
"");
        buffer.append(""    .activecellrow   = "")
            .append(Integer.toHexString(getActiveCellRow())).append(""
"");
        buffer.append(""    .activecellcol   = "")
            .append(Integer.toHexString(getActiveCellCol())).append(""
"");
        buffer.append(""    .activecellref   = "")
            .append(Integer.toHexString(getActiveCellRef())).append(""
"");
        buffer.append(""    .numrefs         = "")
            .append(Integer.toHexString(getNumRefs())).append(""
"");
        buffer.append(""[/SELECTION]
"");
        return buffer.toString();
    }


    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 15);
        data[ 4 + offset ] = getPane();
        LittleEndian.putShort(data, 5 + offset, getActiveCellRow());
        LittleEndian.putShort(data, 7 + offset, getActiveCellCol());
        LittleEndian.putShort(data, 9 + offset, getActiveCellRef());
        LittleEndian.putShort(data, 11 + offset, ( short ) 1);
        LittleEndian.putShort(data, 13 + offset, ( short ) 0);
        LittleEndian.putShort(data, 15 + offset, ( short ) 0);
        data[ 17 + offset ] = 0;
        data[ 18 + offset ] = 0;
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 19;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.POILogger,25,1,0,7,53,28,5,2,21,0.895833333,840,0.166666667,0,0.0,0.485714286,0,0,32.36,12,2.84,0,"

package org.apache.poi.util;

import org.apache.commons.logging.Log;

import java.util.*;



public class POILogger
{
    private Log             log   = null;
    public static final int DEBUG = 1;
    public static final int INFO  = 3;
    public static final int WARN  = 5;
    public static final int ERROR = 7;
    public static final int FATAL = 9;

    

    POILogger(final Log log)
    {
        this.log = log;
    }

    

    public void log(final int level, final Object obj1)
    {
        if(level==FATAL)
        {
          if(log.isFatalEnabled())
          {
            log.fatal(obj1);
          }
        }
        else if(level==ERROR)
        {
          if(log.isErrorEnabled())
          {
            log.error(obj1);
          }
        }
        else if(level==WARN)
        {
          if(log.isWarnEnabled())
          {
            log.warn(obj1);
          }
        }
        else if(level==INFO)
        {
          if(log.isInfoEnabled())
          {
            log.info(obj1);
          }
        }
        else if(level==DEBUG)
        {
          if(log.isDebugEnabled())
          {
            log.debug(obj1);
          }
        }
        else
        {
          if(log.isTraceEnabled())
          {
            log.trace(obj1);
          }
        }

    }

    

    public boolean check(final Log log, final int level)
    {
        if(level==FATAL)
        {
          if(log.isFatalEnabled())
          {
            return true;
          }
        }
        else if(level==ERROR)
        {
          if(log.isErrorEnabled())
          {
            return true;
          }
        }
        else if(level==WARN)
        {
          if(log.isWarnEnabled())
          {
            return true;
          }
        }
        else if(level==INFO)
        {
          if(log.isInfoEnabled())
          {
            return true;
          }
        }
        else if(level==DEBUG)
        {
          if(log.isDebugEnabled())
          {
            return true;
          }
        }

        return false;

    }

    

    public void log(final int level, final Object obj1, final Object obj2)
    {
        if (check(log, level))
        {
            log(level, new StringBuffer(32).append(obj1).append(obj2));
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3)
    {
        

        if (check(log, level))
        {
            log(level,
                    new StringBuffer(48).append(obj1).append(obj2)
                        .append(obj3));
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4)
    {
        

        if (check(log, level))
        {
            log(level,
                    new StringBuffer(64).append(obj1).append(obj2)
                        .append(obj3).append(obj4));
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5)
    {
        

        if (check(log, level))
        {
            log(level,
                    new StringBuffer(80).append(obj1).append(obj2)
                        .append(obj3).append(obj4).append(obj5));
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Object obj6)
    {
        

        if (check(log, level))
        {
            log(level ,
                    new StringBuffer(96).append(obj1).append(obj2)
                        .append(obj3).append(obj4).append(obj5).append(obj6));
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Object obj6, final Object obj7)
    {
        

        if (check(log, level))
        {
            log(level,
                    new StringBuffer(112).append(obj1).append(obj2)
                        .append(obj3).append(obj4).append(obj5).append(obj6)
                        .append(obj7));
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Object obj6, final Object obj7, final Object obj8)
    {
        

        if (check(log, level))
        {
            log(level,
                    new StringBuffer(128).append(obj1).append(obj2)
                        .append(obj3).append(obj4).append(obj5).append(obj6)
                        .append(obj7).append(obj8));
        }
    }

    

    public void log(final int level, final Object obj1,
                    final Throwable exception)
    {
        log(level , obj1, exception);
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level, new StringBuffer(32).append(obj1).append(obj2),
                    exception);
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level, new StringBuffer(48).append(obj1).append(obj2)
                .append(obj3), exception);
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4,
                    final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level, new StringBuffer(64).append(obj1).append(obj2)
                .append(obj3).append(obj4), exception);
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level, new StringBuffer(80).append(obj1).append(obj2)
                .append(obj3).append(obj4).append(obj5), exception);
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Object obj6, final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level , new StringBuffer(96).append(obj1)
                .append(obj2).append(obj3).append(obj4).append(obj5)
                .append(obj6), exception);
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Object obj6, final Object obj7,
                    final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level, new StringBuffer(112).append(obj1).append(obj2)
                .append(obj3).append(obj4).append(obj5).append(obj6)
                .append(obj7), exception);
        }
    }

    

    public void log(final int level, final Object obj1, final Object obj2,
                    final Object obj3, final Object obj4, final Object obj5,
                    final Object obj6, final Object obj7, final Object obj8,
                    final Throwable exception)
    {
        

        if (check(log, level))
        {
            log(level, new StringBuffer(128).append(obj1).append(obj2)
                .append(obj3).append(obj4).append(obj5).append(obj6)
                .append(obj7).append(obj8), exception);
        }
    }

    

    public void logFormatted(final int level, final String message,
                             final Object obj1)
    {
        commonLogFormatted(level, message, new Object[]
        {
            obj1
        });
    }

    

    public void logFormatted(final int level, final String message,
                             final Object obj1, final Object obj2)
    {
        commonLogFormatted(level, message, new Object[]
        {
            obj1, obj2
        });
    }

    

    public void logFormatted(final int level, final String message,
                             final Object obj1, final Object obj2,
                             final Object obj3)
    {
        commonLogFormatted(level, message, new Object[]
        {
            obj1, obj2, obj3
        });
    }

    

    public void logFormatted(final int level, final String message,
                             final Object obj1, final Object obj2,
                             final Object obj3, final Object obj4)
    {
        commonLogFormatted(level, message, new Object[]
        {
            obj1, obj2, obj3, obj4
        });
    }

    private void commonLogFormatted(final int level, final String message,
                                    final Object [] unflatParams)
    {
        

        if (check(log, level))
        {
            Object[] params = flattenArrays(unflatParams);

            if (params[ params.length - 1 ] instanceof Throwable)
            {
                log(level, StringUtil.format(message, params),
                    ( Throwable ) params[ params.length - 1 ]);
            }
            else
            {
                log(level, StringUtil.format(message, params));
            }
        }
    }

    

    private Object [] flattenArrays(final Object [] objects)
    {
        List results = new ArrayList();

        for (int i = 0; i < objects.length; i++)
        {
            results.addAll(objectToObjectArray(objects[ i ]));
        }
        return ( Object [] ) results.toArray(new Object[ results.size() ]);
    }

    private List objectToObjectArray(Object object)
    {
        List results = new ArrayList();

        if (object instanceof byte [])
        {
            byte[] array = ( byte [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Byte(array[ j ]));
            }
        }
        if (object instanceof char [])
        {
            char[] array = ( char [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Character(array[ j ]));
            }
        }
        else if (object instanceof short [])
        {
            short[] array = ( short [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Short(array[ j ]));
            }
        }
        else if (object instanceof int [])
        {
            int[] array = ( int [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Integer(array[ j ]));
            }
        }
        else if (object instanceof long [])
        {
            long[] array = ( long [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Long(array[ j ]));
            }
        }
        else if (object instanceof float [])
        {
            float[] array = ( float [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Float(array[ j ]));
            }
        }
        else if (object instanceof double [])
        {
            double[] array = ( double [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(new Double(array[ j ]));
            }
        }
        else if (object instanceof Object [])
        {
            Object[] array = ( Object [] ) object;

            for (int j = 0; j < array.length; j++)
            {
                results.add(array[ j ]);
            }
        }
        else
        {
            results.add(object);
        }
        return results;
    }
}   

"
poi,1.5,org.apache.poi.hpsf.Variant,1,1,0,0,2,0,0,0,1,2.0,51,0.0,0,0.0,1.0,0,0,3.0,0,0.0,3,"

package org.apache.poi.hpsf;


public class Variant
{

    
    public final static int VT_EMPTY = 0;

    
    public final static int VT_NULL = 1;

    
    public final static int VT_I2 = 2;

    
    public final static int VT_I4 = 3;

    
    public final static int VT_R4 = 4;

    
    public final static int VT_R8 = 5;

    
    public final static int VT_CY = 6;

    
    public final static int VT_DATE = 7;

    
    public final static int VT_BSTR = 8;

    
    public final static int VT_DISPATCH = 9;

    
    public final static int VT_ERROR = 10;

    
    public final static int VT_BOOL = 11;

    
    public final static int VT_VARIANT = 12;

    
    public final static int VT_UNKNOWN = 13;

    
    public final static int VT_DECIMAL = 14;

    
    public final static int VT_I1 = 16;

    
    public final static int VT_UI1 = 17;

    
    public final static int VT_UI2 = 18;

    
    public final static int VT_UI4 = 19;

    
    public final static int VT_I8 = 20;

    
    public final static int VT_UI8 = 21;

    
    public final static int VT_INT = 22;

    
    public final static int VT_UINT = 23;

    
    public final static int VT_VOID = 24;

    
    public final static int VT_HRESULT = 25;

    
    public final static int VT_PTR = 26;

    
    public final static int VT_SAFEARRAY = 27;

    
    public final static int VT_CARRAY = 28;

    
    public final static int VT_USERDEFINED = 29;

    
    public final static int VT_LPSTR = 30;

    
    public final static int VT_LPWSTR = 31;

    
    public final static int VT_FILETIME = 64;

    
    public final static int VT_BLOB = 65;

    
    public final static int VT_STREAM = 66;

    
    public final static int VT_STORAGE = 67;

    
    public final static int VT_STREAMED_OBJECT = 68;

    
    public final static int VT_STORED_OBJECT = 69;

    
    public final static int VT_BLOB_OBJECT = 70;

    
    public final static int VT_CF = 71;

    
    public final static int VT_CLSID = 72;

    
    public final static int VT_VECTOR = 0x1000;

    
    public final static int VT_ARRAY = 0x2000;

    
    public final static int VT_BYREF = 0x4000;

    public final static int VT_RESERVED = 0x8000;

    public final static int VT_ILLEGAL = 0xFFFF;

    public final static int VT_ILLEGALMASKED = 0xFFF;

    public final static int VT_TYPEMASK = 0xFFF;

}
"
poi,1.5,org.apache.poi.hssf.util.HSSFColor,5,1,40,40,46,10,40,38,5,1.25,288,1.0,0,0.0,0.8,0,0,56.4,1,0.8,1,"


package org.apache.poi.hssf.util;

import java.util.*;



public class HSSFColor
{
    private final static int PALETTE_SIZE = 50;

    

    public HSSFColor()
    {
    }

    

    public final static Hashtable getTripletHash()
    {
        Hashtable hash = new Hashtable(PALETTE_SIZE);

        hash.put(HSSFColor.BLACK.hexString, new HSSFColor.BLACK());
        hash.put(HSSFColor.BROWN.hexString, new HSSFColor.BROWN());
        hash.put(HSSFColor.OLIVE_GREEN.hexString,
                 new HSSFColor.OLIVE_GREEN());
        hash.put(HSSFColor.DARK_GREEN.hexString, new HSSFColor.DARK_GREEN());
        hash.put(HSSFColor.DARK_TEAL.hexString, new HSSFColor.DARK_TEAL());
        hash.put(HSSFColor.DARK_BLUE.hexString, new HSSFColor.DARK_BLUE());
        hash.put(HSSFColor.INDIGO.hexString, new HSSFColor.INDIGO());
        hash.put(HSSFColor.GREY_80_PERCENT.hexString,
                 new HSSFColor.GREY_80_PERCENT());
        hash.put(HSSFColor.ORANGE.hexString, new HSSFColor.ORANGE());
        hash.put(HSSFColor.DARK_YELLOW.hexString,
                 new HSSFColor.DARK_YELLOW());
        hash.put(HSSFColor.GREEN.hexString, new HSSFColor.GREEN());
        hash.put(HSSFColor.TEAL.hexString, new HSSFColor.TEAL());
        hash.put(HSSFColor.BLUE.hexString, new HSSFColor.BLUE());
        hash.put(HSSFColor.BLUE_GREY.hexString, new HSSFColor.BLUE_GREY());
        hash.put(HSSFColor.GREY_50_PERCENT.hexString,
                 new HSSFColor.GREY_50_PERCENT());
        hash.put(HSSFColor.RED.hexString, new HSSFColor.RED());
        hash.put(HSSFColor.LIGHT_ORANGE.hexString,
                 new HSSFColor.LIGHT_ORANGE());
        hash.put(HSSFColor.LIME.hexString, new HSSFColor.LIME());
        hash.put(HSSFColor.SEA_GREEN.hexString, new HSSFColor.SEA_GREEN());
        hash.put(HSSFColor.AQUA.hexString, new HSSFColor.AQUA());
        hash.put(HSSFColor.LIGHT_BLUE.hexString, new HSSFColor.LIGHT_BLUE());
        hash.put(HSSFColor.VIOLET.hexString, new HSSFColor.VIOLET());
        hash.put(HSSFColor.GREY_40_PERCENT.hexString,
                 new HSSFColor.GREY_40_PERCENT());
        hash.put(HSSFColor.PINK.hexString, new HSSFColor.PINK());
        hash.put(HSSFColor.GOLD.hexString, new HSSFColor.GOLD());
        hash.put(HSSFColor.YELLOW.hexString, new HSSFColor.YELLOW());
        hash.put(HSSFColor.BRIGHT_GREEN.hexString,
                 new HSSFColor.BRIGHT_GREEN());
        hash.put(HSSFColor.BRIGHT_GREEN.hexString, new HSSFColor.TURQUOISE());
        hash.put(HSSFColor.SKY_BLUE.hexString, new HSSFColor.SKY_BLUE());
        hash.put(HSSFColor.PLUM.hexString, new HSSFColor.PLUM());
        hash.put(HSSFColor.GREY_25_PERCENT.hexString,
                 new HSSFColor.GREY_25_PERCENT());
        hash.put(HSSFColor.ROSE.hexString, new HSSFColor.ROSE());
        hash.put(HSSFColor.LIGHT_YELLOW.hexString,
                 new HSSFColor.LIGHT_YELLOW());
        hash.put(HSSFColor.LIGHT_GREEN.hexString,
                 new HSSFColor.LIGHT_GREEN());
        hash.put(HSSFColor.LIGHT_TURQUOISE.hexString,
                 new HSSFColor.LIGHT_TURQUOISE());
        hash.put(HSSFColor.PALE_BLUE.hexString, new HSSFColor.PALE_BLUE());
        hash.put(HSSFColor.LAVENDER.hexString, new HSSFColor.LAVENDER());
        hash.put(HSSFColor.WHITE.hexString, new HSSFColor.WHITE());
        return hash;
    }

    

    public short getIndex()
    {
        return BLACK.index;
    }

    

    public short [] getTriplet()
    {
        return BLACK.triplet;
    }

    

    

    public String getHexString()
    {
        return BLACK.hexString;
    }

    

    public final static class BLACK
        extends HSSFColor
    {
        public final static short   index     = 0x8;
        public final static short[] triplet   =
        {
            0, 0, 0
        };
        public final static String  hexString = ""0:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BROWN
        extends HSSFColor
    {
        public final static short   index     = 0x3c;
        public final static short[] triplet   =
        {
            153, 51, 0
        };
        public final static String  hexString = ""9999:3333:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public static class OLIVE_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x3b;
        public final static short[] triplet   =
        {
            51, 51, 0
        };
        public final static String  hexString = ""3333:3333:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x3a;
        public final static short[] triplet   =
        {
            0, 51, 0
        };
        public final static String  hexString = ""0:3333:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_TEAL
        extends HSSFColor
    {
        public final static short   index     = 0x38;
        public final static short[] triplet   =
        {
            0, 51, 102
        };
        public final static String  hexString = ""0:3333:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x12;
        public final static short[] triplet   =
        {
            0, 0, 128
        };
        public final static String  hexString = ""0:0:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class INDIGO
        extends HSSFColor
    {
        public final static short   index     = 0x3e;
        public final static short[] triplet   =
        {
            51, 51, 153
        };
        public final static String  hexString = ""3333:3333:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_80_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x3f;
        public final static short[] triplet   =
        {
            51, 51, 51
        };
        public final static String  hexString = ""3333:3333:3333"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_RED
        extends HSSFColor
    {
        public final static short   index     = 0x10;
        public final static short[] triplet   =
        {
            128, 0, 0
        };
        public final static String  hexString = ""8080:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class ORANGE
        extends HSSFColor
    {
        public final static short   index     = 0x35;
        public final static short[] triplet   =
        {
            255, 102, 0
        };
        public final static String  hexString = ""FFFF:6666:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_YELLOW
        extends HSSFColor
    {
        public final static short   index     = 0x13;
        public final static short[] triplet   =
        {
            128, 128, 0
        };
        public final static String  hexString = ""8080:8080:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x11;
        public final static short[] triplet   =
        {
            0, 128, 0
        };
        public final static String  hexString = ""0:8080:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class TEAL
        extends HSSFColor
    {
        public final static short   index     = 0x15;
        public final static short[] triplet   =
        {
            0, 128, 128
        };
        public final static String  hexString = ""0:8080:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BLUE
        extends HSSFColor
    {
        public final static short   index     = 0xc;
        public final static short[] triplet   =
        {
            0, 0, 255
        };
        public final static String  hexString = ""0:0:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BLUE_GREY
        extends HSSFColor
    {
        public final static short   index     = 0x36;
        public final static short[] triplet   =
        {
            102, 102, 153
        };
        public final static String  hexString = ""6666:6666:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_50_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x17;
        public final static short[] triplet   =
        {
            128, 128, 128
        };
        public final static String  hexString = ""8080:8080:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class RED
        extends HSSFColor
    {
        public final static short   index     = 0xa;
        public final static short[] triplet   =
        {
            255, 0, 0
        };
        public final static String  hexString = ""FFFF:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_ORANGE
        extends HSSFColor
    {
        public final static short   index     = 0x34;
        public final static short[] triplet   =
        {
            255, 153, 0
        };
        public final static String  hexString = ""FFF:9999:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIME
        extends HSSFColor
    {
        public final static short   index     = 0x32;
        public final static short[] triplet   =
        {
            153, 204, 0
        };
        public final static String  hexString = ""9999:CCCC:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class SEA_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x39;
        public final static short[] triplet   =
        {
            51, 153, 102
        };
        public final static String  hexString = ""3333:9999:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class AQUA
        extends HSSFColor
    {
        public final static short   index     = 0x31;
        public final static short[] triplet   =
        {
            51, 204, 204
        };
        public final static String  hexString = ""3333:CCCC:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x30;
        public final static short[] triplet   =
        {
            51, 102, 255
        };
        public final static String  hexString = ""3333:6666:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class VIOLET
        extends HSSFColor
    {
        public final static short   index     = 0x14;
        public final static short[] triplet   =
        {
            128, 0, 128
        };
        public final static String  hexString = ""8080:0:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_40_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x37;
        public final static short[] triplet   =
        {
            150, 150, 150
        };
        public final static String  hexString = ""9696:9696:9696"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class PINK
        extends HSSFColor
    {
        public final static short   index     = 0xe;
        public final static short[] triplet   =
        {
            255, 0, 255
        };
        public final static String  hexString = ""FFFF:0:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GOLD
        extends HSSFColor
    {
        public final static short   index     = 0x33;
        public final static short[] triplet   =
        {
            255, 204, 0
        };
        public final static String  hexString = ""FFFF:CCCC:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class YELLOW
        extends HSSFColor
    {
        public final static short   index     = 0xd;
        public final static short[] triplet   =
        {
            255, 255, 0
        };
        public final static String  hexString = ""FFFF:FFFF:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BRIGHT_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0xb;
        public final static short[] triplet   =
        {
            0, 255, 0
        };
        public final static String  hexString = ""0:FFFF:0"";

        public short getIndex()
        {
            return index;
        }

        public String getHexString()
        {
            return hexString;
        }

        public short [] getTriplet()
        {
            return triplet;
        }
    }

    

    public final static class TURQUOISE
        extends HSSFColor
    {
        public final static short   index     = 0xf;
        public final static short[] triplet   =
        {
            0, 255, 255
        };
        public final static String  hexString = ""0:FFFF:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class SKY_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x28;
        public final static short[] triplet   =
        {
            0, 204, 255
        };
        public final static String  hexString = ""0:CCCC:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class PLUM
        extends HSSFColor
    {
        public final static short   index     = 0x3d;
        public final static short[] triplet   =
        {
            153, 51, 102
        };
        public final static String  hexString = ""9999:3333:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_25_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x16;
        public final static short[] triplet   =
        {
            192, 192, 192
        };
        public final static String  hexString = ""C0C0:C0C0:C0C0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class ROSE
        extends HSSFColor
    {
        public final static short   index     = 0x2d;
        public final static short[] triplet   =
        {
            255, 153, 204
        };
        public final static String  hexString = ""FFFF:9999:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class TAN
        extends HSSFColor
    {
        public final static short   index     = 0x2f;
        public final static short[] triplet   =
        {
            255, 204, 153
        };
        public final static String  hexString = ""FFFF:CCCC:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_YELLOW
        extends HSSFColor
    {
        public final static short   index     = 0x2b;
        public final static short[] triplet   =
        {
            255, 255, 153
        };
        public final static String  hexString = ""FFFF:FFFF:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x2a;
        public final static short[] triplet   =
        {
            204, 255, 204
        };
        public final static String  hexString = ""CCCC:FFFF:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_TURQUOISE
        extends HSSFColor
    {
        public final static short   index     = 0x29;
        public final static short[] triplet   =
        {
            204, 255, 255
        };
        public final static String  hexString = ""CCCC:FFFF:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class PALE_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x2c;
        public final static short[] triplet   =
        {
            153, 204, 255
        };
        public final static String  hexString = ""9999:CCCC:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LAVENDER
        extends HSSFColor
    {
        public final static short   index     = 0x2e;
        public final static short[] triplet   =
        {
            204, 153, 255
        };
        public final static String  hexString = ""CCCC:9999:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class WHITE
        extends HSSFColor
    {
        public final static short   index     = 0x9;
        public final static short[] triplet   =
        {
            255, 255, 255
        };
        public final static String  hexString = ""FFFF:FFFF:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }
}
"
poi,1.5,org.apache.poi.hssf.record.RowRecord,36,2,0,10,52,366,6,4,34,0.865306122,621,0.928571429,5,0.25,0.282407407,1,6,15.86111111,4,1.1389,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;



public class RowRecord
    extends Record
    implements Comparable
{
    public final static short sid = 0x208;
    private short             field_1_row_number;
    private short             field_2_first_col;
    private short             field_3_last_col;   
    private short             field_4_height;
    private short             field_5_optimize;   

    
    private short             field_6_reserved;
    private short             field_7_option_flags;
    private BitField          outlineLevel  = new BitField(0x07);

    
    private BitField          colapsed      = new BitField(0x10);
    private BitField          zeroHeight    = new BitField(0x20);
    private BitField          badFontHeight = new BitField(0x40);
    private BitField          formatted     = new BitField(0x80);
    private short             field_8_xf_index;   

    public RowRecord()
    {
    }

    

    public RowRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public RowRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid ROW RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row_number   = LittleEndian.getShort(data, 0 + offset);
        field_2_first_col    = LittleEndian.getShort(data, 2 + offset);
        field_3_last_col     = LittleEndian.getShort(data, 4 + offset);
        field_4_height       = LittleEndian.getShort(data, 6 + offset);
        field_5_optimize     = LittleEndian.getShort(data, 8 + offset);
        field_6_reserved     = LittleEndian.getShort(data, 10 + offset);
        field_7_option_flags = LittleEndian.getShort(data, 12 + offset);
        field_8_xf_index     = LittleEndian.getShort(data, 14 + offset);
    }

    

    public void setRowNumber(short row)
    {
        field_1_row_number = row;
    }

    

    public void setFirstCol(short col)
    {
        field_2_first_col = col;
    }

    

    public void setLastCol(short col)
    {
        field_3_last_col = col;
    }

    

    public void setHeight(short height)
    {
        field_4_height = height;
    }

    

    public void setOptimize(short optimize)
    {
        field_5_optimize = optimize;
    }

    

    public void setOptionFlags(short options)
    {
        field_7_option_flags = options;
    }

    

    

    public void setOutlineLevel(short ol)
    {
        field_7_option_flags =
            outlineLevel.setShortValue(field_7_option_flags, ol);
    }

    

    public void setColapsed(boolean c)
    {
        field_7_option_flags = colapsed.setShortBoolean(field_7_option_flags,
                c);
    }

    

    public void setZeroHeight(boolean z)
    {
        field_7_option_flags =
            zeroHeight.setShortBoolean(field_7_option_flags, z);
    }

    

    public void setBadFontHeight(boolean f)
    {
        field_7_option_flags =
            badFontHeight.setShortBoolean(field_7_option_flags, f);
    }

    

    public void setFormatted(boolean f)
    {
        field_7_option_flags = formatted.setShortBoolean(field_7_option_flags,
                f);
    }

    

    

    public void setXFIndex(short index)
    {
        field_8_xf_index = index;
    }

    

    public short getRowNumber()
    {
        return field_1_row_number;
    }

    

    public short getFirstCol()
    {
        return field_2_first_col;
    }

    

    public short getLastCol()
    {
        return field_3_last_col;
    }

    

    public short getHeight()
    {
        return field_4_height;
    }

    

    public short getOptimize()
    {
        return field_5_optimize;
    }

    

    public short getOptionFlags()
    {
        return field_7_option_flags;
    }

    

    

    public short getOutlineLevel()
    {
        return outlineLevel.getShortValue(field_7_option_flags);
    }

    

    public boolean getColapsed()
    {
        return (colapsed.isSet(field_7_option_flags));
    }

    

    public boolean getZeroHeight()
    {
        return zeroHeight.isSet(field_7_option_flags);
    }

    

    public boolean getBadFontHeight()
    {
        return badFontHeight.isSet(field_7_option_flags);
    }

    

    public boolean getFormatted()
    {
        return formatted.isSet(field_7_option_flags);
    }

    

    

    public short getXFIndex()
    {
        return field_8_xf_index;
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ROW]
"");
        buffer.append(""    .rownumber      = "")
            .append(Integer.toHexString(getRowNumber())).append(""
"");
        buffer.append(""    .firstcol       = "")
            .append(Integer.toHexString(getFirstCol())).append(""
"");
        buffer.append(""    .lastcol        = "")
            .append(Integer.toHexString(getLastCol())).append(""
"");
        buffer.append(""    .height         = "")
            .append(Integer.toHexString(getHeight())).append(""
"");
        buffer.append(""    .optimize       = "")
            .append(Integer.toHexString(getOptimize())).append(""
"");
        buffer.append(""    .reserved       = "")
            .append(Integer.toHexString(field_6_reserved)).append(""
"");
        buffer.append(""    .optionflags    = "")
            .append(Integer.toHexString(getOptionFlags())).append(""
"");
        buffer.append(""        .outlinelvl = "")
            .append(Integer.toHexString(getOutlineLevel())).append(""
"");
        buffer.append(""        .colapsed   = "").append(getColapsed())
            .append(""
"");
        buffer.append(""        .zeroheight = "").append(getZeroHeight())
            .append(""
"");
        buffer.append(""        .badfontheig= "").append(getBadFontHeight())
            .append(""
"");
        buffer.append(""        .formatted  = "").append(getFormatted())
            .append(""
"");
        buffer.append(""    .xfindex        = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        buffer.append(""[/ROW]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 16);
        LittleEndian.putShort(data, 4 + offset, getRowNumber());
        LittleEndian.putShort(data, 6 + offset, getFirstCol() == -1 ? (short)0 : getFirstCol());
        LittleEndian.putShort(data, 8 + offset, getLastCol() == -1 ? (short)0 : getLastCol());
        LittleEndian.putShort(data, 10 + offset, getHeight());
        LittleEndian.putShort(data, 12 + offset, getOptimize());
        LittleEndian.putShort(data, 14 + offset, field_6_reserved);
        LittleEndian.putShort(data, 16 + offset, getOptionFlags());


        LittleEndian.putShort(data, 18 + offset, getXFIndex());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 20;
    }

    public short getSid()
    {
        return this.sid;
    }

    public int compareTo(Object obj)
    {
        RowRecord loc = ( RowRecord ) obj;

        if (this.getRowNumber() == loc.getRowNumber())
        {
            return 0;
        }
        if (this.getRowNumber() < loc.getRowNumber())
        {
            return -1;
        }
        if (this.getRowNumber() > loc.getRowNumber())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof RowRecord))
        {
            return false;
        }
        RowRecord loc = ( RowRecord ) obj;

        if (this.getRowNumber() == loc.getRowNumber())
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.hpsf.NoSingleSectionException,4,5,0,2,8,6,1,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,1,"

package org.apache.poi.hpsf;


public class NoSingleSectionException extends HPSFRuntimeException
{

    public NoSingleSectionException()
    {
	super();
    }

    public NoSingleSectionException(final String msg)
    {
	super(msg);
    }

    public NoSingleSectionException(final Throwable reason)
    {
	super(reason);
    }

    public NoSingleSectionException(final String msg, final Throwable reason)
    {
	super(msg, reason);
    }

}
"
poi,1.5,org.apache.poi.hssf.record.RefModeRecord,11,2,0,5,21,49,2,3,9,0.975,108,0.25,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class RefModeRecord
    extends Record
{
    public final static short sid           = 0xf;
    public final static short USE_A1_MODE   = 1;
    public final static short USE_R1C1_MODE = 0;
    private short             field_1_mode;

    public RefModeRecord()
    {
    }

    

    public RefModeRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public RefModeRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An RefMode RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_mode = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setMode(short mode)
    {
        field_1_mode = mode;
    }

    

    public short getMode()
    {
        return field_1_mode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[REFMODE]
"");
        buffer.append(""    .mode           = "")
            .append(Integer.toHexString(getMode())).append(""
"");
        buffer.append(""[/REFMODE]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, getMode());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.FormatRecord,15,2,0,6,28,85,2,4,13,0.814285714,209,0.8,0,0.47826087,0.322222222,1,6,12.6,2,0.8667,3,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class FormatRecord
    extends Record
{
    public final static short sid = 0x41e;
    private short             field_1_index_code;
    private byte              field_2_formatstring_len;
    private short             field_3_zero;   
    private String            field_4_formatstring;

    public FormatRecord()
    {
    }

    

    public FormatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FormatRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A FORMAT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_index_code       = LittleEndian.getShort(data, 0 + offset);
        field_2_formatstring_len = data[ 2 + offset ];
        field_3_zero             = LittleEndian.getShort(data, 3 + offset);
        field_4_formatstring     = new String(data, 5 + offset,
                                              LittleEndian.ubyteToInt(field_2_formatstring_len));
    }

    

    public void setIndexCode(short index)
    {
        field_1_index_code = index;
    }

    

    public void setFormatStringLength(byte len)
    {
        field_2_formatstring_len = len;
    }

    

    public void setFormatString(String fs)
    {
        field_4_formatstring = fs;
    }

    

    public short getIndexCode()
    {
        return field_1_index_code;
    }

    

    public byte getFormatStringLength()
    {
        return field_2_formatstring_len;
    }

    

    public String getFormatString()
    {
        return field_4_formatstring;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FORMAT]
"");
        buffer.append(""    .indexcode       = "")
            .append(Integer.toHexString(getIndexCode())).append(""
"");
        buffer.append(""    .formatstringlen = "")
            .append(Integer.toHexString(getFormatStringLength()))
            .append(""
"");
        buffer.append(""    .zero            = "")
            .append(Integer.toHexString(field_3_zero)).append(""
"");
        buffer.append(""    .formatstring    = "").append(getFormatString())
            .append(""
"");
        buffer.append(""[/FORMAT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              ( short ) (5 + getFormatStringLength()));

        
        LittleEndian.putShort(data, 4 + offset, getIndexCode());
        data[ 6 + offset ] = getFormatStringLength();
        LittleEndian.putShort(data, 7 + offset, ( short ) 0);
        StringUtil.putCompressedUnicode(getFormatString(), data, 9 + offset);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 9 + getFormatStringLength();
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.DimensionsRecord,17,2,0,5,29,110,2,3,15,0.833333333,232,0.833333333,0,0.44,0.470588235,1,6,12.29411765,2,0.8824,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class DimensionsRecord
    extends Record
{
    public final static short sid = 0x200;
    private int               field_1_first_row;
    private int               field_2_last_row;   
    private short             field_3_first_col;
    private short             field_4_last_col;
    private short             field_5_zero;       

    public DimensionsRecord()
    {
    }

    

    public DimensionsRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DimensionsRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid DIMENSIONS RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_first_row = LittleEndian.getInt(data, 0 + offset);
        field_2_last_row  = LittleEndian.getInt(data, 4 + offset);
        field_3_first_col = LittleEndian.getShort(data, 8 + offset);
        field_4_last_col  = LittleEndian.getShort(data, 10 + offset);
        field_5_zero      = LittleEndian.getShort(data, 12 + offset);
    }

    

    public void setFirstRow(int row)
    {
        field_1_first_row = row;
    }

    

    public void setLastRow(int row)
    {
        field_2_last_row = row;
    }

    

    public void setFirstCol(short col)
    {
        field_3_first_col = col;
    }

    

    public void setLastCol(short col)
    {
        field_4_last_col = col;
    }

    

    public int getFirstRow()
    {
        return field_1_first_row;
    }

    

    public int getLastRow()
    {
        return field_2_last_row;
    }

    

    public short getFirstCol()
    {
        return field_3_first_col;
    }

    

    public short getLastCol()
    {
        return field_4_last_col;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DIMENSIONS]
"");
        buffer.append(""    .firstrow       = "")
            .append(Integer.toHexString(getFirstRow())).append(""
"");
        buffer.append(""    .lastrow        = "")
            .append(Integer.toHexString(getLastRow())).append(""
"");
        buffer.append(""    .firstcol       = "")
            .append(Integer.toHexString(getFirstCol())).append(""
"");
        buffer.append(""    .lastcol        = "")
            .append(Integer.toHexString(getLastCol())).append(""
"");
        buffer.append(""    .zero           = "")
            .append(Integer.toHexString(field_5_zero)).append(""
"");
        buffer.append(""[/DIMENSIONS]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 14);
        LittleEndian.putInt(data, 4 + offset, getFirstRow());
        LittleEndian.putInt(data, 8 + offset, getLastRow());
        LittleEndian.putShort(data, 12 + offset, getFirstCol());
        LittleEndian.putShort(data, 14 + offset, getLastCol());
        LittleEndian.putShort(data, 16 + offset, ( short ) 0);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 18;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hpsf.PropertySet,21,1,1,14,53,176,4,10,16,0.725,353,0.75,4,0.0,0.3625,0,0,15.42857143,4,1.0,3,"

package org.apache.poi.hpsf;

import java.io.*;
import java.util.*;
import org.apache.poi.hpsf.littleendian.*;
import org.apache.poi.hpsf.wellknown.*;
import org.apache.poi.poifs.filesystem.*;


public class PropertySet
{
    static final byte[] BYTE_ORDER_ASSERTION =
        new byte[] {(byte) 0xFF, (byte) 0xFE};
    static final byte[] FORMAT_ASSERTION =
        new byte[] {(byte) 0x00, (byte) 0x00};



    private Word byteOrder; 

    
    public Word getByteOrder()
    {
        return byteOrder;
    }



    private Word format;    

    
    public Word getFormat()
    {
        return format;
    }



    private DWord osVersion;

    
    public DWord getOSVersion()
    {
        return osVersion;
    }



    private ClassID classID;

    
    public ClassID getClassID()
    {
        return classID;
    }



    private int sectionCount;

    
    public int getSectionCount()
    {
        return sectionCount;
    }



    private List sections;

    
    public List getSections()
    {
        return sections;
    }



    
    protected PropertySet()
    {}



    
    public PropertySet(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               IOException
    {
        if (isPropertySetStream(stream))
        {
            final int avail = stream.available();
            final byte[] buffer = new byte[avail];
            stream.read(buffer, 0, buffer.length);
            init(buffer, 0, buffer.length);
        }
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream, final int offset, final int length)
        throws NoPropertySetStreamException
    {
        if (isPropertySetStream(stream, offset, length))
            init(stream, offset, length);
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream)
        throws NoPropertySetStreamException
    {
        this(stream, 0, stream.length);
    }



    
    public static boolean isPropertySetStream(final InputStream stream)
        throws MarkUnsupportedException, IOException
    {
        
        final int BUFFER_SIZE = 50;

        
        if (!stream.markSupported())
            throw new MarkUnsupportedException(stream.getClass().getName());
        stream.mark(BUFFER_SIZE);

        
        final byte[] buffer = new byte[BUFFER_SIZE];
        final int bytes =
            stream.read(buffer, 0,
                        Math.min(buffer.length, stream.available()));
        final boolean isPropertySetStream =
            isPropertySetStream(buffer, 0, bytes);
        stream.reset();
        return isPropertySetStream;
    }



    
    public static boolean isPropertySetStream(final byte[] src, int offset,
                                              final int length)
    {
        
        final Word byteOrder = new Word(src, offset);
        offset += Word.LENGTH;
        if (!Util.equal(byteOrder.getBytes(), BYTE_ORDER_ASSERTION))
            return false;
        final Word format = new Word(src, offset);
        offset += Word.LENGTH;
        if (!Util.equal(format.getBytes(), FORMAT_ASSERTION))
            return false;
        final DWord osVersion = new DWord(src, offset);
        offset += DWord.LENGTH;
        final ClassID classID = new ClassID(src, offset);
        offset += ClassID.LENGTH;
        final DWord sectionCount = new DWord(src, offset);
        offset += DWord.LENGTH;
        if (sectionCount.intValue() < 1)
            return false;
        return true;
    }



    
    private void init(final byte[] src, int offset, final int length)
    {
        
        byteOrder = new Word(src, offset);
        offset += Word.LENGTH;
        format = new Word(src, offset);
        offset += Word.LENGTH;
        osVersion = new DWord(src, offset);
        offset += DWord.LENGTH;
        classID = new ClassID(src, offset);
        offset += ClassID.LENGTH;
        sectionCount = new DWord(src, offset).intValue();
        offset += DWord.LENGTH;
        
        
        
        sections = new ArrayList(2);

        
        for (int i = 0; i < sectionCount; i++)
        {
            final Section s = new Section(src, offset);
            offset += ClassID.LENGTH + DWord.LENGTH;
            sections.add(s);
        }
    }



    
    public boolean isSummaryInformation()
    {
        return Util.equal(((Section) sections.get(0)).getFormatID().getBytes(),
                          SectionIDMap.SUMMARY_INFORMATION_ID);
    }



    
    public boolean isDocumentSummaryInformation()
    {
        return Util.equal(((Section) sections.get(0)).getFormatID().getBytes(),
                          SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID);
    }



    
    public Property[] getProperties()
        throws NoSingleSectionException
    {
        return getSingleSection().getProperties();
    }



    
    protected Object getProperty(final int id)
        throws NoSingleSectionException
    {
        return getSingleSection().getProperty(id);
    }



    
    protected int getPropertyIntValue(final int id)
        throws NoSingleSectionException
    {
        return getSingleSection().getPropertyIntValue(id);
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return getSingleSection().wasNull();
    }



    
    public Section getSingleSection()
    {
        if (sectionCount != 1)
            throw new NoSingleSectionException
                (""Property set contains "" + sectionCount + "" sections."");
        return ((Section) sections.get(0));
    }

}
"
poi,1.5,org.apache.poi.poifs.filesystem.Entry,6,1,0,5,6,15,5,1,6,2.0,6,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.filesystem;



public interface Entry
{

    

    public String getName();

    

    public boolean isDirectoryEntry();

    

    public boolean isDocumentEntry();

    

    public DirectoryEntry getParent();

    

    public boolean delete();

    

    public boolean renameTo(final String newName);
}   

"
poi,1.5,org.apache.poi.poifs.filesystem.BATManaged,2,1,0,5,2,1,5,0,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.filesystem;



public interface BATManaged
{

    

    public int countBlocks();

    

    public void setStartBlock(final int index);
}   

"
poi,1.5,org.apache.poi.hssf.record.aggregates.ValueRecordsAggregate,13,2,0,4,30,34,1,3,11,0.75,191,0.0,0,0.47826087,0.294871795,1,5,13.30769231,6,1.6923,4,"


package org.apache.poi.hssf.record.aggregates;

import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.UnknownRecord;

import java.util.Iterator;
import java.util.List;
import java.util.TreeMap;



public class ValueRecordsAggregate
    extends Record
{
    public final static short sid       = -1000;
    int                       firstcell = -1;
    int                       lastcell  = -1;
    TreeMap                   records   = null;
    int                       size      = 0;

    

    public ValueRecordsAggregate()
    {
        records = new TreeMap();
    }

    public void insertCell(CellValueRecordInterface cell)
    {
        if (records.get(cell) == null)
        {
            size += (( Record ) cell).getRecordSize();
        }
        else
        {
            size += (( Record ) cell).getRecordSize()
                    - (( Record ) records.get(cell)).getRecordSize();
        }

        
        records.put(cell, cell);
        if ((cell.getColumn() < firstcell) || (firstcell == -1))
        {
            firstcell = cell.getColumn();
        }
        if ((cell.getColumn() > lastcell) || (lastcell == -1))
        {
            lastcell = cell.getColumn();
        }
    }

    public void removeCell(CellValueRecordInterface cell)
    {
        size -= (( Record ) cell).getRecordSize();

        
        records.remove(cell);
    }

    public int getPhysicalNumberOfCells()
    {
        return records.size();
    }

    public int getFirstCellNum()
    {
        return firstcell;
    }

    public int getLastCellNum()
    {
        return lastcell;
    }

    public int construct(int offset, List records)
    {
        int k = 0;

        for (k = offset; k < records.size(); k++)
        {
            Record rec = ( Record ) records.get(k);

            if (!rec.isInValueSection() && !(rec instanceof UnknownRecord))
            {
                break;
            }
            if (rec.isValue())
            {
                insertCell(( CellValueRecordInterface ) rec);
            }
        }
        return k;
    }

    

    public int serialize(int offset, byte [] data)
    {
        Iterator itr = records.values().iterator();
        int      pos = offset;

        while (itr.hasNext())
        {
            pos += (( Record ) itr.next()).serialize(pos, data);
        }
        return pos - offset;
    }

    

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    

    protected void validateSid(short id)
    {
    }

    

    public short getSid()
    {
        return sid;
    }

    public int getRecordSize()
    {
        return size;
    }

    public Iterator getIterator()
    {
        return records.values().iterator();
    }
}


"
poi,1.5,org.apache.poi.hpsf.littleendian.ClassID,3,2,0,7,8,3,3,4,3,1.5,168,0.0,0,0.6,0.777777778,1,4,54.66666667,4,1.6667,0,"

package org.apache.poi.hpsf.littleendian;

import java.io.*;


public class ClassID extends LittleEndian
{

    
    public ClassID(final byte[] src, final int offset)
    {
        super(src, offset);
    }



    public final static int LENGTH = 16;

    public int length()
    {
        return LENGTH;
    }



    public byte[] read(byte[] src, int offset)
    {
        LittleEndian[] b = new LittleEndian[11];
        b[0] = new DWord(src, offset);
        b[1] = new Word(src, offset += DWord.LENGTH);
        b[2] = new Word(src, offset += Word.LENGTH);
        b[3] = new Byte(src, offset += Word.LENGTH);
        b[4] = new Byte(src, offset += Byte.LENGTH);
        b[5] = new Byte(src, offset += Byte.LENGTH);
        b[6] = new Byte(src, offset += Byte.LENGTH);
        b[7] = new Byte(src, offset += Byte.LENGTH);
        b[8] = new Byte(src, offset += Byte.LENGTH);
        b[9] = new Byte(src, offset += Byte.LENGTH);
        b[10] = new Byte(src, offset += Byte.LENGTH);
        int capacity = 0;
        for (int i = 0; i < b.length; i++)
            capacity += b[i].getBytes().length;
        bytes = new byte[capacity];
        int pos = 0;
        for (int i = 0; i < b.length; i++)
        {
            byte[] s = b[i].getBytes();
            for (int j = 0; j < s.length; j++)
                bytes[pos++] = s[j];
        }
        return bytes;
    }

}
"
poi,1.5,org.apache.poi.hpsf.HPSFRuntimeException,5,4,1,1,7,4,1,0,5,0.5,29,1.0,0,0.944444444,0.6,0,0,4.6,1,0.2,1,"

package org.apache.poi.hpsf;


public class HPSFRuntimeException extends RuntimeException
{

    private Throwable reason;



    
    public HPSFRuntimeException()
    {
        super();
    }



    
    public HPSFRuntimeException(final String msg)
    {
        super(msg);
    }



    
    public HPSFRuntimeException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFRuntimeException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }

}
"
poi,1.5,org.apache.poi.util.LittleEndian,31,1,0,116,38,463,114,2,27,0.866666667,340,1.0,0,0.0,0.203703704,0,0,9.870967742,2,1.0968,3,"

package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;



public class LittleEndian
        implements LittleEndianConsts
{

    
    
    private LittleEndian()
    {
    }

    

    public static short getShort(final byte[] data, final int offset)
    {
        return (short) getNumber(data, offset, SHORT_SIZE);
    }

    
    public static short[] getSimpleShortArray(final byte[] data, final int offset, final int size)
    {
        short[] results = new short[size];
        for (int i = 0; i < size; i++)
        {
            results[i] = getShort(data, offset + 2 + (i * 2));
        }
        return results;
    }
    
    public static short[] getShortArray(final byte[] data, final int offset)
    {
        int size = (short) getNumber(data, offset, SHORT_SIZE);
        short[] results = getSimpleShortArray(data, offset, size);
        return results;
    }

    

    public static short getShort(final byte[] data)
    {
        return getShort(data, 0);
    }

    

    public static int getInt(final byte[] data, final int offset)
    {
        return (int) getNumber(data, offset, INT_SIZE);
    }

    

    public static int getInt(final byte[] data)
    {
        return getInt(data, 0);
    }

    

    public static long getLong(final byte[] data, final int offset)
    {
        return getNumber(data, offset, LONG_SIZE);
    }

    

    public static long getLong(final byte[] data)
    {
        return getLong(data, 0);
    }

    

    public static double getDouble(final byte[] data, final int offset)
    {
        return Double.longBitsToDouble(getNumber(data, offset, DOUBLE_SIZE));
    }

    

    public static double getDouble(final byte[] data)
    {
        return getDouble(data, 0);
    }

    

    public static void putShort(final byte[] data, final int offset,
                                final short value)
    {
        putNumber(data, offset, value, SHORT_SIZE);
    }

    
    public static void putShortArray(final byte[] data, final int offset, final short[] value)
    {
        putNumber(data, offset, value.length, SHORT_SIZE);
        for (int i = 0; i < value.length; i++)
        {
            putNumber(data, offset + 2 + (i * 2), value[i], SHORT_SIZE);
        }
    }

    

    public static void putShort(final byte[] data, final short value)
    {
        putShort(data, 0, value);
    }

    

    public static void putInt(final byte[] data, final int offset,
                              final int value)
    {
        putNumber(data, offset, value, INT_SIZE);
    }

    

    public static void putInt(final byte[] data, final int value)
    {
        putInt(data, 0, value);
    }

    

    public static void putLong(final byte[] data, final int offset,
                               final long value)
    {
        putNumber(data, offset, value, LONG_SIZE);
    }

    

    public static void putLong(final byte[] data, final long value)
    {
        putLong(data, 0, value);
    }

    

    public static void putDouble(final byte[] data, final int offset,
                                 final double value)
    {
        putNumber(data, offset, Double.doubleToLongBits(value), DOUBLE_SIZE);
    }

    

    public static void putDouble(final byte[] data, final double value)
    {
        putDouble(data, 0, value);
    }

    

    public static class BufferUnderrunException
            extends IOException
    {

        

        BufferUnderrunException()
        {
            super(""buffer underrun"");
        }
    }

    

    public static short readShort(final InputStream stream)
            throws IOException, BufferUnderrunException
    {
        return getShort(readFromStream(stream, SHORT_SIZE));
    }

    

    public static int readInt(final InputStream stream)
            throws IOException, BufferUnderrunException
    {
        return getInt(readFromStream(stream, INT_SIZE));
    }

    

    public static long readLong(final InputStream stream)
            throws IOException, BufferUnderrunException
    {
        return getLong(readFromStream(stream, LONG_SIZE));
    }

    private static final byte[] _short_buffer = new byte[SHORT_SIZE];
    private static final byte[] _int_buffer = new byte[INT_SIZE];
    private static final byte[] _long_buffer = new byte[LONG_SIZE];

    

    public static byte[] readFromStream(final InputStream stream,
                                        final int size)
            throws IOException, BufferUnderrunException
    {
        byte[] buffer = null;

        switch (size)
        {

            case SHORT_SIZE:
                buffer = _short_buffer;
                break;

            case INT_SIZE:
                buffer = _int_buffer;
                break;

            case LONG_SIZE:
                buffer = _long_buffer;
                break;

            default :
                buffer = new byte[size];
                break;
        }
        int count = stream.read(buffer);

        if (count == -1)
        {

            
            Arrays.fill(buffer, (byte) 0);
        } else if (count != size)
        {
            throw new BufferUnderrunException();
        }
        return buffer;
    }

    private static long getNumber(final byte[] data, final int offset,
                                  final int size)
    {
        long result = 0;

        for (int j = offset + size - 1; j >= offset; j--)
        {
            result <<= 8;
            result |= 0xff & data[j];
        }
        return result;
    }

    private static void putNumber(final byte[] data, final int offset,
                                  final long value, final int size)
    {
        int limit = size + offset;
        long v = value;

        for (int j = offset; j < limit; j++)
        {
            data[j] = (byte) (v & 0xFF);
            v >>= 8;
        }
    }

    
    public static int ubyteToInt(byte b)
    {
        return ((b & 0x80) == 0 ? (int) b : (int) (b & (byte) 0x7f) + 0x80);
    }

    
    public static int getUnsignedByte(final byte[] data, final int offset)
    {
        return (int) getNumber(data, offset, BYTE_SIZE);
    }

    
    public static int getUnsignedByte(final byte[] data)
    {
        return getUnsignedByte(data, 0);
    }
    
    public static byte[] getByteArray(final byte[] data, int offset, int size)
    {
        byte[] copy = new byte[size];
        System.arraycopy(data, offset, copy, 0, size);

        return copy;
    }

}
"
poi,1.5,org.apache.poi.hpsf.wellknown.SectionIDMap,8,3,0,3,15,26,2,1,7,0.857142857,219,0.25,1,0.9,0.342857143,1,1,25.875,3,1.125,1,"

package org.apache.poi.hpsf.wellknown;

import java.util.*;


public class SectionIDMap extends HashMap
{

    
    public final static byte[] SUMMARY_INFORMATION_ID =
        new byte[]{(byte) 0xF2, (byte) 0x9F, (byte) 0x85, (byte) 0xE0,
                   (byte) 0x4F, (byte) 0xF9, (byte) 0x10, (byte) 0x68,
                   (byte) 0xAB, (byte) 0x91, (byte) 0x08, (byte) 0x00,
                   (byte) 0x2B, (byte) 0x27, (byte) 0xB3, (byte) 0xD9};

    
    public final static byte[] DOCUMENT_SUMMARY_INFORMATION_ID =
        new byte[]{(byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x02,
                   (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
                   (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
                   (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE};

    public final static String UNDEFINED = ""[undefined]"";



    private static SectionIDMap defaultMap;



    
    public static SectionIDMap getInstance()
    {
        if (defaultMap == null)
        {
            final SectionIDMap m = new SectionIDMap();
            m.put(SUMMARY_INFORMATION_ID,
                  PropertyIDMap.getSummaryInformationProperties());
            m.put(DOCUMENT_SUMMARY_INFORMATION_ID,
                  PropertyIDMap.getDocumentSummaryInformationProperties());
            defaultMap = m;
        }
        return defaultMap;
    }



    
    public static String getPIDString(final byte[] sectionFormatID,
                                      final int pid)
    {
        final PropertyIDMap m =
            (PropertyIDMap) getInstance().get(sectionFormatID);
        if (m == null)
            return UNDEFINED;
        else
        {
            final String s = (String) m.get(pid);
            if (s == null)
                return UNDEFINED;
            return s;
        }
    }



    
    public PropertyIDMap get(final byte[] sectionFormatID)
    {
        return (PropertyIDMap) super.get(new String(sectionFormatID));
    }



    
    public Object get(final Object sectionFormatID)
    {
        return get((byte[]) sectionFormatID);
    }



    
    public Object put(final byte[] sectionFormatID,
                      final PropertyIDMap propertyIDMap)
    {
        return super.put(new String(sectionFormatID), propertyIDMap);
    }



    
    public Object put(final Object key, final Object value)
    {
        return put((byte[]) key, (PropertyIDMap) value);
    }

}
"
poi,1.5,org.apache.poi.hssf.record.MMSRecord,13,2,0,5,22,66,2,3,11,0.805555556,140,0.666666667,0,0.523809524,0.4,1,6,9.538461538,2,0.8462,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class MMSRecord
    extends Record
{
    public final static short sid = 0xC1;
    private byte              field_1_addMenuCount;   
    private byte              field_2_delMenuCount;   

    public MMSRecord()
    {
    }

    

    public MMSRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public MMSRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A MMS RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_addMenuCount = data[ 0 + offset ];
        field_2_delMenuCount = data[ 1 + offset ];
    }

    

    public void setAddMenuCount(byte am)
    {
        field_1_addMenuCount = am;
    }

    

    public void setDelMenuCount(byte dm)
    {
        field_2_delMenuCount = dm;
    }

    

    public byte getAddMenuCount()
    {
        return field_1_addMenuCount;
    }

    

    public byte getDelMenuCount()
    {
        return field_2_delMenuCount;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[MMS]
"");
        buffer.append(""    .addMenu        = "")
            .append(Integer.toHexString(getAddMenuCount())).append(""
"");
        buffer.append(""    .delMenu        = "")
            .append(Integer.toHexString(getDelMenuCount())).append(""
"");
        buffer.append(""[/MMS]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        data[ 4 + offset ] = getAddMenuCount();
        data[ 5 + offset ] = getDelMenuCount();
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.BlockAllocationTableReader,7,1,0,12,29,1,7,6,1,0.0,257,1.0,1,0.0,0.514285714,0,0,35.57142857,2,0.7143,0,"


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IntList;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;



public class BlockAllocationTableReader
{
    private IntList _entries;

    

    public BlockAllocationTableReader(final int block_count,
                                      final int [] block_array,
                                      final int xbat_count,
                                      final int xbat_index,
                                      final BlockList raw_block_list)
        throws IOException
    {
        this();
        if (block_count <= 0)
        {
            throw new IOException(
                ""Illegal block count; minimum count is 1, got "" + block_count
                + "" instead"");
        }

        
        RawDataBlock blocks[] = new RawDataBlock[ block_count ];
        int          limit    = Math.min(block_count, block_array.length);
        int          block_index;

        for (block_index = 0; block_index < limit; block_index++)
        {
            blocks[ block_index ] =
                ( RawDataBlock ) raw_block_list
                    .remove(block_array[ block_index ]);
        }
        if (block_index < block_count)
        {

            
            if (xbat_index < 0)
            {
                throw new IOException(
                    ""BAT count exceeds limit, yet XBAT index indicates no valid entries"");
            }
            int chain_index           = xbat_index;
            int max_entries_per_block = BATBlock.entriesPerXBATBlock();
            int chain_index_offset    = BATBlock.getXBATChainOffset();

            for (int j = 0; j < xbat_count; j++)
            {
                limit = Math.min(block_count - block_index,
                                 max_entries_per_block);
                byte[] data   = raw_block_list.remove(chain_index).getData();
                int    offset = 0;

                for (int k = 0; k < limit; k++)
                {
                    blocks[ block_index++ ] =
                        ( RawDataBlock ) raw_block_list
                            .remove(LittleEndian.getInt(data, offset));
                    offset                  += LittleEndianConsts.INT_SIZE;
                }
                chain_index = LittleEndian.getInt(data, chain_index_offset);
                if (chain_index == POIFSConstants.END_OF_CHAIN)
                {
                    break;
                }
            }
        }
        if (block_index != block_count)
        {
            throw new IOException(""Could not find all blocks"");
        }

        
        
        setEntries(blocks, raw_block_list);
    }

    

    BlockAllocationTableReader(final ListManagedBlock [] blocks,
                               final BlockList raw_block_list)
        throws IOException
    {
        this();
        setEntries(blocks, raw_block_list);
    }

    

    BlockAllocationTableReader()
    {
        _entries = new IntList();
    }

    

    ListManagedBlock [] fetchBlocks(final int startBlock,
                                    final BlockList blockList)
        throws IOException
    {
        List blocks       = new ArrayList();
        int  currentBlock = startBlock;

        while (currentBlock != POIFSConstants.END_OF_CHAIN)
        {
            blocks.add(blockList.remove(currentBlock));
            currentBlock = _entries.get(currentBlock);
        }
        return ( ListManagedBlock [] ) blocks
            .toArray(new ListManagedBlock[ 0 ]);
    }

    

    

    boolean isUsed(final int index)
    {
        boolean rval = false;

        try
        {
            rval = _entries.get(index) != -1;
        }
        catch (IndexOutOfBoundsException ignored)
        {
        }
        return rval;
    }

    

    int getNextBlockIndex(final int index)
        throws IOException
    {
        if (isUsed(index))
        {
            return _entries.get(index);
        }
        else
        {
            throw new IOException(""index "" + index + "" is unused"");
        }
    }

    

    private void setEntries(final ListManagedBlock [] blocks,
                            final BlockList raw_blocks)
        throws IOException
    {
        int limit = BATBlock.entriesPerBlock();

        for (int block_index = 0; block_index < blocks.length; block_index++)
        {
            byte[] data   = blocks[ block_index ].getData();
            int    offset = 0;

            for (int k = 0; k < limit; k++)
            {
                int entry = LittleEndian.getInt(data, offset);

                if (entry == POIFSConstants.UNUSED_BLOCK)
                {
                    raw_blocks.zap(_entries.size());
                }
                _entries.add(entry);
                offset += LittleEndianConsts.INT_SIZE;
            }

            
            blocks[ block_index ] = null;
        }
        raw_blocks.setBAT(this);
    }
}   

"
poi,1.5,org.apache.poi.hpsf.UnexpectedPropertySetTypeException,4,4,0,4,8,6,3,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,1,"

package org.apache.poi.hpsf;


public class UnexpectedPropertySetTypeException extends HPSFException
{

    public UnexpectedPropertySetTypeException()
    {
        super();
    }

    public UnexpectedPropertySetTypeException(final String msg)
    {
        super(msg);
    }

    public UnexpectedPropertySetTypeException(final Throwable reason)
    {
        super(reason);
    }

    public UnexpectedPropertySetTypeException(final String msg,
                                              final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,1.5,org.apache.poi.hssf.record.HideObjRecord,11,2,0,5,21,49,2,3,9,1.0,109,0.2,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class HideObjRecord
    extends Record
{
    public final static short sid               = 0x8d;
    public final static short HIDE_ALL          = 2;
    public final static short SHOW_PLACEHOLDERS = 1;
    public final static short SHOW_ALL          = 0;
    private short             field_1_hide_obj;

    public HideObjRecord()
    {
    }

    

    public HideObjRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public HideObjRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A HIDEOBJ RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_hide_obj = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setHideObj(short hide)
    {
        field_1_hide_obj = hide;
    }

    

    public short getHideObj()
    {
        return field_1_hide_obj;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[HIDEOBJ]
"");
        buffer.append(""    .hideobj         = "")
            .append(Integer.toHexString(getHideObj())).append(""
"");
        buffer.append(""[/HIDEOBJ]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getHideObj());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.DefaultRowHeightRecord,13,2,0,5,23,66,2,3,11,0.805555556,140,0.666666667,0,0.523809524,0.5,1,6,9.538461538,2,0.8462,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class DefaultRowHeightRecord
    extends Record
{
    public final static short sid = 0x225;
    private short             field_1_option_flags;
    private short             field_2_row_height;

    public DefaultRowHeightRecord()
    {
    }

    

    public DefaultRowHeightRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DefaultRowHeightRecord(short id, short size, byte [] data,
                                  int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A DefaultRowHeight RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_option_flags = LittleEndian.getShort(data, 0 + offset);
        field_2_row_height   = LittleEndian.getShort(data, 2 + offset);
    }

    

    public void setOptionFlags(short flags)
    {
        field_1_option_flags = flags;
    }

    

    public void setRowHeight(short height)
    {
        field_2_row_height = height;
    }

    

    public short getOptionFlags()
    {
        return field_1_option_flags;
    }

    

    public short getRowHeight()
    {
        return field_2_row_height;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DEFAULTROWHEIGHT]
"");
        buffer.append(""    .optionflags    = "")
            .append(Integer.toHexString(getOptionFlags())).append(""
"");
        buffer.append(""    .rowheight      = "")
            .append(Integer.toHexString(getRowHeight())).append(""
"");
        buffer.append(""[/DEFAULTROWHEIGHT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x4);
        LittleEndian.putShort(data, 4 + offset, getOptionFlags());
        LittleEndian.putShort(data, 6 + offset, getRowHeight());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 8;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.BinaryTree,57,2,0,15,87,1362,14,7,17,0.927083333,1806,1.0,1,0.25,0.265306122,1,7,30.47368421,19,2.5263,0,"


package org.apache.poi.util;

import java.util.*;


public final class BinaryTree   

    extends AbstractMap
{
    private Node[]                _root             = new Node[]
    {
        null, null
    };
    private int                   _size             = 0;
    private int                   _modifications    = 0;
    private Set[]                 _key_set          = new Set[]
    {
        null, null
    };
    private Set[]                 _entry_set        = new Set[]
    {
        null, null
    };
    private Collection[]          _value_collection = new Collection[]
    {
        null, null
    };
    private static final int      _KEY              = 0;
    private static final int      _VALUE            = 1;
    private static final int      _INDEX_SUM        = _KEY + _VALUE;
    private static final int      _MINIMUM_INDEX    = 0;
    private static final int      _INDEX_COUNT      = 2;
    private static final String[] _data_name        = new String[]
    {
        ""key"", ""value""
    };

    

    public BinaryTree()
    {
    }

    

    public BinaryTree(final Map map)
        throws ClassCastException, NullPointerException,
                IllegalArgumentException
    {
        putAll(map);
    }

    

    public Object getKeyForValue(final Object value)
        throws ClassCastException, NullPointerException
    {
        return doGet(( Comparable ) value, _VALUE);
    }

    

    public Object removeValue(final Object value)
    {
        return doRemove(( Comparable ) value, _VALUE);
    }

    

    public Set entrySetByValue()
    {
        if (_entry_set[ _VALUE ] == null)
        {
            _entry_set[ _VALUE ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_VALUE)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node;
                        }
                    };
                }

                public boolean contains(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    key   = entry.getKey();
                    Node      node  = lookup(( Comparable ) entry.getValue(),
                                             _VALUE);

                    return (node != null) && node.getData(_KEY).equals(key);
                }

                public boolean remove(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    key   = entry.getKey();
                    Node      node  = lookup(( Comparable ) entry.getValue(),
                                             _VALUE);

                    if ((node != null) && node.getData(_KEY).equals(key))
                    {
                        doRedBlackDelete(node);
                        return true;
                    }
                    return false;
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _entry_set[ _VALUE ];
    }

    

    public Set keySetByValue()
    {
        if (_key_set[ _VALUE ] == null)
        {
            _key_set[ _VALUE ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_VALUE)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_KEY);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsKey(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    BinaryTree.this.remove(o);
                    return _size != old_size;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _key_set[ _VALUE ];
    }

    

    public Collection valuesByValue()
    {
        if (_value_collection[ _VALUE ] == null)
        {
            _value_collection[ _VALUE ] = new AbstractCollection()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_VALUE)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_VALUE);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsValue(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    removeValue(o);
                    return _size != old_size;
                }

                public boolean removeAll(Collection c)
                {
                    boolean  modified = false;
                    Iterator iter     = c.iterator();

                    while (iter.hasNext())
                    {
                        if (removeValue(iter.next()) != null)
                        {
                            modified = true;
                        }
                    }
                    return modified;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _value_collection[ _VALUE ];
    }

    

    private Object doRemove(final Comparable o, final int index)
    {
        Node   node = lookup(o, index);
        Object rval = null;

        if (node != null)
        {
            rval = node.getData(oppositeIndex(index));
            doRedBlackDelete(node);
        }
        return rval;
    }

    

    private Object doGet(final Comparable o, final int index)
    {
        checkNonNullComparable(o, index);
        Node node = lookup(o, index);

        return ((node == null) ? null
                               : node.getData(oppositeIndex(index)));
    }

    

    private int oppositeIndex(final int index)
    {

        
        
        
        return _INDEX_SUM - index;
    }

    

    private Node lookup(final Comparable data, final int index)
    {
        Node rval = null;
        Node node = _root[ index ];

        while (node != null)
        {
            int cmp = compare(data, node.getData(index));

            if (cmp == 0)
            {
                rval = node;
                break;
            }
            else
            {
                node = (cmp < 0) ? node.getLeft(index)
                                 : node.getRight(index);
            }
        }
        return rval;
    }

    

    private static int compare(final Comparable o1, final Comparable o2)
    {
        return (( Comparable ) o1).compareTo(o2);
    }

    

    private static Node leastNode(final Node node, final int index)
    {
        Node rval = node;

        if (rval != null)
        {
            while (rval.getLeft(index) != null)
            {
                rval = rval.getLeft(index);
            }
        }
        return rval;
    }

    

    private Node nextGreater(final Node node, final int index)
    {
        Node rval = null;

        if (node == null)
        {
            rval = null;
        }
        else if (node.getRight(index) != null)
        {

            
            
            rval = leastNode(node.getRight(index), index);
        }
        else
        {

            
            
            
            
            
            
            Node parent = node.getParent(index);
            Node child  = node;

            while ((parent != null) && (child == parent.getRight(index)))
            {
                child  = parent;
                parent = parent.getParent(index);
            }
            rval = parent;
        }
        return rval;
    }

    

    private static void copyColor(final Node from, final Node to,
                                  final int index)
    {
        if (to != null)
        {
            if (from == null)
            {

                
                to.setBlack(index);
            }
            else
            {
                to.copyColor(from, index);
            }
        }
    }

    

    private static boolean isRed(final Node node, final int index)
    {
        return ((node == null) ? false
                               : node.isRed(index));
    }

    

    private static boolean isBlack(final Node node, final int index)
    {
        return ((node == null) ? true
                               : node.isBlack(index));
    }

    

    private static void makeRed(final Node node, final int index)
    {
        if (node != null)
        {
            node.setRed(index);
        }
    }

    

    private static void makeBlack(final Node node, final int index)
    {
        if (node != null)
        {
            node.setBlack(index);
        }
    }

    

    private static Node getGrandParent(final Node node, final int index)
    {
        return getParent(getParent(node, index), index);
    }

    

    private static Node getParent(final Node node, final int index)
    {
        return ((node == null) ? null
                               : node.getParent(index));
    }

    

    private static Node getRightChild(final Node node, final int index)
    {
        return (node == null) ? null
                              : node.getRight(index);
    }

    

    private static Node getLeftChild(final Node node, final int index)
    {
        return (node == null) ? null
                              : node.getLeft(index);
    }

    

    private static boolean isLeftChild(final Node node, final int index)
    {
        return (node == null) ? true
                              : ((node.getParent(index) == null) ? false
                                                                 : (node
                                                                    == node.getParent(
                                                                        index).getLeft(
                                                                        index)));
    }

    

    private static boolean isRightChild(final Node node, final int index)
    {
        return (node == null) ? true
                              : ((node.getParent(index) == null) ? false
                                                                 : (node
                                                                    == node.getParent(
                                                                        index).getRight(
                                                                        index)));
    }

    

    private void rotateLeft(final Node node, final int index)
    {
        Node right_child = node.getRight(index);

        node.setRight(right_child.getLeft(index), index);
        if (right_child.getLeft(index) != null)
        {
            right_child.getLeft(index).setParent(node, index);
        }
        right_child.setParent(node.getParent(index), index);
        if (node.getParent(index) == null)
        {

            
            _root[ index ] = right_child;
        }
        else if (node.getParent(index).getLeft(index) == node)
        {
            node.getParent(index).setLeft(right_child, index);
        }
        else
        {
            node.getParent(index).setRight(right_child, index);
        }
        right_child.setLeft(node, index);
        node.setParent(right_child, index);
    }

    

    private void rotateRight(final Node node, final int index)
    {
        Node left_child = node.getLeft(index);

        node.setLeft(left_child.getRight(index), index);
        if (left_child.getRight(index) != null)
        {
            left_child.getRight(index).setParent(node, index);
        }
        left_child.setParent(node.getParent(index), index);
        if (node.getParent(index) == null)
        {

            
            _root[ index ] = left_child;
        }
        else if (node.getParent(index).getRight(index) == node)
        {
            node.getParent(index).setRight(left_child, index);
        }
        else
        {
            node.getParent(index).setLeft(left_child, index);
        }
        left_child.setRight(node, index);
        node.setParent(left_child, index);
    }

    

    private void doRedBlackInsert(final Node inserted_node, final int index)
    {
        Node current_node = inserted_node;

        makeRed(current_node, index);
        while ((current_node != null) && (current_node != _root[ index ])
                && (isRed(current_node.getParent(index), index)))
        {
            if (isLeftChild(getParent(current_node, index), index))
            {
                Node y = getRightChild(getGrandParent(current_node, index),
                                       index);

                if (isRed(y, index))
                {
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(y, index);
                    makeRed(getGrandParent(current_node, index), index);
                    current_node = getGrandParent(current_node, index);
                }
                else
                {
                    if (isRightChild(current_node, index))
                    {
                        current_node = getParent(current_node, index);
                        rotateLeft(current_node, index);
                    }
                    makeBlack(getParent(current_node, index), index);
                    makeRed(getGrandParent(current_node, index), index);
                    if (getGrandParent(current_node, index) != null)
                    {
                        rotateRight(getGrandParent(current_node, index),
                                    index);
                    }
                }
            }
            else
            {

                
                Node y = getLeftChild(getGrandParent(current_node, index),
                                      index);

                if (isRed(y, index))
                {
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(y, index);
                    makeRed(getGrandParent(current_node, index), index);
                    current_node = getGrandParent(current_node, index);
                }
                else
                {
                    if (isLeftChild(current_node, index))
                    {
                        current_node = getParent(current_node, index);
                        rotateRight(current_node, index);
                    }
                    makeBlack(getParent(current_node, index), index);
                    makeRed(getGrandParent(current_node, index), index);
                    if (getGrandParent(current_node, index) != null)
                    {
                        rotateLeft(getGrandParent(current_node, index),
                                   index);
                    }
                }
            }
        }
        makeBlack(_root[ index ], index);
    }

    

    private void doRedBlackDelete(final Node deleted_node)
    {
        for (int index = _MINIMUM_INDEX; index < _INDEX_COUNT; index++)
        {

            
            
            if ((deleted_node.getLeft(index) != null)
                    && (deleted_node.getRight(index) != null))
            {
                swapPosition(nextGreater(deleted_node, index), deleted_node,
                             index);
            }
            Node replacement = ((deleted_node.getLeft(index) != null)
                                ? deleted_node.getLeft(index)
                                : deleted_node.getRight(index));

            if (replacement != null)
            {
                replacement.setParent(deleted_node.getParent(index), index);
                if (deleted_node.getParent(index) == null)
                {
                    _root[ index ] = replacement;
                }
                else if (deleted_node
                         == deleted_node.getParent(index).getLeft(index))
                {
                    deleted_node.getParent(index).setLeft(replacement, index);
                }
                else
                {
                    deleted_node.getParent(index).setRight(replacement,
                                           index);
                }
                deleted_node.setLeft(null, index);
                deleted_node.setRight(null, index);
                deleted_node.setParent(null, index);
                if (isBlack(deleted_node, index))
                {
                    doRedBlackDeleteFixup(replacement, index);
                }
            }
            else
            {

                
                if (deleted_node.getParent(index) == null)
                {

                    
                    _root[ index ] = null;
                }
                else
                {

                    
                    if (isBlack(deleted_node, index))
                    {
                        doRedBlackDeleteFixup(deleted_node, index);
                    }
                    if (deleted_node.getParent(index) != null)
                    {
                        if (deleted_node
                                == deleted_node.getParent(index)
                                    .getLeft(index))
                        {
                            deleted_node.getParent(index).setLeft(null,
                                                   index);
                        }
                        else
                        {
                            deleted_node.getParent(index).setRight(null,
                                                   index);
                        }
                        deleted_node.setParent(null, index);
                    }
                }
            }
        }
        shrink();
    }

    

    private void doRedBlackDeleteFixup(final Node replacement_node,
                                       final int index)
    {
        Node current_node = replacement_node;

        while ((current_node != _root[ index ])
                && (isBlack(current_node, index)))
        {
            if (isLeftChild(current_node, index))
            {
                Node sibling_node =
                    getRightChild(getParent(current_node, index), index);

                if (isRed(sibling_node, index))
                {
                    makeBlack(sibling_node, index);
                    makeRed(getParent(current_node, index), index);
                    rotateLeft(getParent(current_node, index), index);
                    sibling_node =
                        getRightChild(getParent(current_node, index), index);
                }
                if (isBlack(getLeftChild(sibling_node, index), index)
                        && isBlack(getRightChild(sibling_node, index), index))
                {
                    makeRed(sibling_node, index);
                    current_node = getParent(current_node, index);
                }
                else
                {
                    if (isBlack(getRightChild(sibling_node, index), index))
                    {
                        makeBlack(getLeftChild(sibling_node, index), index);
                        makeRed(sibling_node, index);
                        rotateRight(sibling_node, index);
                        sibling_node =
                            getRightChild(getParent(current_node, index),
                                          index);
                    }
                    copyColor(getParent(current_node, index), sibling_node,
                              index);
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(getRightChild(sibling_node, index), index);
                    rotateLeft(getParent(current_node, index), index);
                    current_node = _root[ index ];
                }
            }
            else
            {
                Node sibling_node =
                    getLeftChild(getParent(current_node, index), index);

                if (isRed(sibling_node, index))
                {
                    makeBlack(sibling_node, index);
                    makeRed(getParent(current_node, index), index);
                    rotateRight(getParent(current_node, index), index);
                    sibling_node =
                        getLeftChild(getParent(current_node, index), index);
                }
                if (isBlack(getRightChild(sibling_node, index), index)
                        && isBlack(getLeftChild(sibling_node, index), index))
                {
                    makeRed(sibling_node, index);
                    current_node = getParent(current_node, index);
                }
                else
                {
                    if (isBlack(getLeftChild(sibling_node, index), index))
                    {
                        makeBlack(getRightChild(sibling_node, index), index);
                        makeRed(sibling_node, index);
                        rotateLeft(sibling_node, index);
                        sibling_node =
                            getLeftChild(getParent(current_node, index),
                                         index);
                    }
                    copyColor(getParent(current_node, index), sibling_node,
                              index);
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(getLeftChild(sibling_node, index), index);
                    rotateRight(getParent(current_node, index), index);
                    current_node = _root[ index ];
                }
            }
        }
        makeBlack(current_node, index);
    }

    

    private void swapPosition(final Node x, final Node y, final int index)
    {

        
        Node    x_old_parent      = x.getParent(index);
        Node    x_old_left_child  = x.getLeft(index);
        Node    x_old_right_child = x.getRight(index);
        Node    y_old_parent      = y.getParent(index);
        Node    y_old_left_child  = y.getLeft(index);
        Node    y_old_right_child = y.getRight(index);
        boolean x_was_left_child  =
            (x.getParent(index) != null)
            && (x == x.getParent(index).getLeft(index));
        boolean y_was_left_child  =
            (y.getParent(index) != null)
            && (y == y.getParent(index).getLeft(index));

        
        if (x == y_old_parent)
        {   
            x.setParent(y, index);
            if (y_was_left_child)
            {
                y.setLeft(x, index);
                y.setRight(x_old_right_child, index);
            }
            else
            {
                y.setRight(x, index);
                y.setLeft(x_old_left_child, index);
            }
        }
        else
        {
            x.setParent(y_old_parent, index);
            if (y_old_parent != null)
            {
                if (y_was_left_child)
                {
                    y_old_parent.setLeft(x, index);
                }
                else
                {
                    y_old_parent.setRight(x, index);
                }
            }
            y.setLeft(x_old_left_child, index);
            y.setRight(x_old_right_child, index);
        }
        if (y == x_old_parent)
        {   
            y.setParent(x, index);
            if (x_was_left_child)
            {
                x.setLeft(y, index);
                x.setRight(y_old_right_child, index);
            }
            else
            {
                x.setRight(y, index);
                x.setLeft(y_old_left_child, index);
            }
        }
        else
        {
            y.setParent(x_old_parent, index);
            if (x_old_parent != null)
            {
                if (x_was_left_child)
                {
                    x_old_parent.setLeft(y, index);
                }
                else
                {
                    x_old_parent.setRight(y, index);
                }
            }
            x.setLeft(y_old_left_child, index);
            x.setRight(y_old_right_child, index);
        }

        
        if (x.getLeft(index) != null)
        {
            x.getLeft(index).setParent(x, index);
        }
        if (x.getRight(index) != null)
        {
            x.getRight(index).setParent(x, index);
        }
        if (y.getLeft(index) != null)
        {
            y.getLeft(index).setParent(y, index);
        }
        if (y.getRight(index) != null)
        {
            y.getRight(index).setParent(y, index);
        }
        x.swapColors(y, index);

        
        if (_root[ index ] == x)
        {
            _root[ index ] = y;
        }
        else if (_root[ index ] == y)
        {
            _root[ index ] = x;
        }
    }

    

    private static void checkNonNullComparable(final Object o,
                                               final int index)
    {
        if (o == null)
        {
            throw new NullPointerException(_data_name[ index ]
                                           + "" cannot be null"");
        }
        if (!(o instanceof Comparable))
        {
            throw new ClassCastException(_data_name[ index ]
                                         + "" must be Comparable"");
        }
    }

    

    private static void checkKey(final Object key)
    {
        checkNonNullComparable(key, _KEY);
    }

    

    private static void checkValue(final Object value)
    {
        checkNonNullComparable(value, _VALUE);
    }

    

    private static void checkKeyAndValue(final Object key, final Object value)
    {
        checkKey(key);
        checkValue(value);
    }

    

    private void modify()
    {
        _modifications++;
    }

    

    private void grow()
    {
        modify();
        _size++;
    }

    

    private void shrink()
    {
        modify();
        _size--;
    }

    

    private void insertValue(final Node newNode)
        throws IllegalArgumentException
    {
        Node node = _root[ _VALUE ];

        while (true)
        {
            int cmp = compare(newNode.getData(_VALUE), node.getData(_VALUE));

            if (cmp == 0)
            {
                throw new IllegalArgumentException(
                    ""Cannot store a duplicate value (""""
                    + newNode.getData(_VALUE) + """") in this Map"");
            }
            else if (cmp < 0)
            {
                if (node.getLeft(_VALUE) != null)
                {
                    node = node.getLeft(_VALUE);
                }
                else
                {
                    node.setLeft(newNode, _VALUE);
                    newNode.setParent(node, _VALUE);
                    doRedBlackInsert(newNode, _VALUE);
                    break;
                }
            }
            else
            {   
                if (node.getRight(_VALUE) != null)
                {
                    node = node.getRight(_VALUE);
                }
                else
                {
                    node.setRight(newNode, _VALUE);
                    newNode.setParent(node, _VALUE);
                    doRedBlackInsert(newNode, _VALUE);
                    break;
                }
            }
        }
    }

    

    

    public int size()
    {
        return _size;
    }

    

    public boolean containsKey(final Object key)
        throws ClassCastException, NullPointerException
    {
        checkKey(key);
        return lookup(( Comparable ) key, _KEY) != null;
    }

    

    public boolean containsValue(final Object value)
    {
        checkValue(value);
        return lookup(( Comparable ) value, _VALUE) != null;
    }

    

    public Object get(final Object key)
        throws ClassCastException, NullPointerException
    {
        return doGet(( Comparable ) key, _KEY);
    }

    

    public Object put(final Object key, final Object value)
        throws ClassCastException, NullPointerException,
                IllegalArgumentException
    {
        checkKeyAndValue(key, value);
        Node node = _root[ _KEY ];

        if (node == null)
        {
            Node root = new Node(( Comparable ) key, ( Comparable ) value);

            _root[ _KEY ]   = root;
            _root[ _VALUE ] = root;
            grow();
        }
        else
        {
            while (true)
            {
                int cmp = compare(( Comparable ) key, node.getData(_KEY));

                if (cmp == 0)
                {
                    throw new IllegalArgumentException(
                        ""Cannot store a duplicate key ("""" + key
                        + """") in this Map"");
                }
                else if (cmp < 0)
                {
                    if (node.getLeft(_KEY) != null)
                    {
                        node = node.getLeft(_KEY);
                    }
                    else
                    {
                        Node newNode = new Node(( Comparable ) key,
                                                ( Comparable ) value);

                        insertValue(newNode);
                        node.setLeft(newNode, _KEY);
                        newNode.setParent(node, _KEY);
                        doRedBlackInsert(newNode, _KEY);
                        grow();
                        break;
                    }
                }
                else
                {   
                    if (node.getRight(_KEY) != null)
                    {
                        node = node.getRight(_KEY);
                    }
                    else
                    {
                        Node newNode = new Node(( Comparable ) key,
                                                ( Comparable ) value);

                        insertValue(newNode);
                        node.setRight(newNode, _KEY);
                        newNode.setParent(node, _KEY);
                        doRedBlackInsert(newNode, _KEY);
                        grow();
                        break;
                    }
                }
            }
        }
        return null;
    }

    

    public Object remove(final Object key)
    {
        return doRemove(( Comparable ) key, _KEY);
    }

    

    public void clear()
    {
        modify();
        _size           = 0;
        _root[ _KEY ]   = null;
        _root[ _VALUE ] = null;
    }

    

    public Set keySet()
    {
        if (_key_set[ _KEY ] == null)
        {
            _key_set[ _KEY ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_KEY)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_KEY);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsKey(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    BinaryTree.this.remove(o);
                    return _size != old_size;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _key_set[ _KEY ];
    }

    

    public Collection values()
    {
        if (_value_collection[ _KEY ] == null)
        {
            _value_collection[ _KEY ] = new AbstractCollection()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_KEY)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_VALUE);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsValue(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    removeValue(o);
                    return _size != old_size;
                }

                public boolean removeAll(Collection c)
                {
                    boolean  modified = false;
                    Iterator iter     = c.iterator();

                    while (iter.hasNext())
                    {
                        if (removeValue(iter.next()) != null)
                        {
                            modified = true;
                        }
                    }
                    return modified;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _value_collection[ _KEY ];
    }

    

    public Set entrySet()
    {
        if (_entry_set[ _KEY ] == null)
        {
            _entry_set[ _KEY ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_KEY)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node;
                        }
                    };
                }

                public boolean contains(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    value = entry.getValue();
                    Node      node  = lookup(( Comparable ) entry.getKey(),
                                             _KEY);

                    return (node != null)
                           && node.getData(_VALUE).equals(value);
                }

                public boolean remove(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    value = entry.getValue();
                    Node      node  = lookup(( Comparable ) entry.getKey(),
                                             _KEY);

                    if ((node != null) && node.getData(_VALUE).equals(value))
                    {
                        doRedBlackDelete(node);
                        return true;
                    }
                    return false;
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _entry_set[ _KEY ];
    }

    
    private abstract class BinaryTreeIterator
        implements Iterator
    {
        private int    _expected_modifications;
        protected Node _last_returned_node;
        private Node   _next_node;
        private int    _type;

        

        BinaryTreeIterator(final int type)
        {
            _type                   = type;
            _expected_modifications = BinaryTree.this._modifications;
            _last_returned_node     = null;
            _next_node              = leastNode(_root[ _type ], _type);
        }

        

        protected abstract Object doGetNext();

        

        

        public final boolean hasNext()
        {
            return _next_node != null;
        }

        

        public final Object next()
            throws NoSuchElementException, ConcurrentModificationException
        {
            if (_next_node == null)
            {
                throw new NoSuchElementException();
            }
            if (_modifications != _expected_modifications)
            {
                throw new ConcurrentModificationException();
            }
            _last_returned_node = _next_node;
            _next_node          = nextGreater(_next_node, _type);
            return doGetNext();
        }

        

        public final void remove()
            throws IllegalStateException, ConcurrentModificationException
        {
            if (_last_returned_node == null)
            {
                throw new IllegalStateException();
            }
            if (_modifications != _expected_modifications)
            {
                throw new ConcurrentModificationException();
            }
            doRedBlackDelete(_last_returned_node);
            _expected_modifications++;
            _last_returned_node = null;
        }

        
    }   

    
    private static final class Node
        implements Map.Entry
    {
        private Comparable[] _data;
        private Node[]       _left;
        private Node[]       _right;
        private Node[]       _parent;
        private boolean[]    _black;
        private int          _hashcode;
        private boolean      _calculated_hashcode;

        

        Node(final Comparable key, final Comparable value)
        {
            _data                = new Comparable[]
            {
                key, value
            };
            _left                = new Node[]
            {
                null, null
            };
            _right               = new Node[]
            {
                null, null
            };
            _parent              = new Node[]
            {
                null, null
            };
            _black               = new boolean[]
            {
                true, true
            };
            _calculated_hashcode = false;
        }

        

        private Comparable getData(final int index)
        {
            return _data[ index ];
        }

        

        private void setLeft(final Node node, final int index)
        {
            _left[ index ] = node;
        }

        

        private Node getLeft(final int index)
        {
            return _left[ index ];
        }

        

        private void setRight(final Node node, final int index)
        {
            _right[ index ] = node;
        }

        

        private Node getRight(final int index)
        {
            return _right[ index ];
        }

        

        private void setParent(final Node node, final int index)
        {
            _parent[ index ] = node;
        }

        

        private Node getParent(final int index)
        {
            return _parent[ index ];
        }

        

        private void swapColors(final Node node, final int index)
        {

            
            _black[ index ]      ^= node._black[ index ];
            node._black[ index ] ^= _black[ index ];
            _black[ index ]      ^= node._black[ index ];
        }

        

        private boolean isBlack(final int index)
        {
            return _black[ index ];
        }

        

        private boolean isRed(final int index)
        {
            return !_black[ index ];
        }

        

        private void setBlack(final int index)
        {
            _black[ index ] = true;
        }

        

        private void setRed(final int index)
        {
            _black[ index ] = false;
        }

        

        private void copyColor(final Node node, final int index)
        {
            _black[ index ] = node._black[ index ];
        }

        

        

        public Object getKey()
        {
            return _data[ _KEY ];
        }

        

        public Object getValue()
        {
            return _data[ _VALUE ];
        }

        

        public Object setValue(Object ignored)
            throws UnsupportedOperationException
        {
            throw new UnsupportedOperationException(
                ""Map.Entry.setValue is not supported"");
        }

        

        public boolean equals(Object o)
        {
            if (this == o)
            {
                return true;
            }
            if (!(o instanceof Map.Entry))
            {
                return false;
            }
            Map.Entry e = ( Map.Entry ) o;

            return _data[ _KEY ].equals(e.getKey())
                   && _data[ _VALUE ].equals(e.getValue());
        }

        

        public int hashCode()
        {
            if (!_calculated_hashcode)
            {
                _hashcode            = _data[ _KEY ].hashCode()
                                       ^ _data[ _VALUE ].hashCode();
                _calculated_hashcode = true;
            }
            return _hashcode;
        }

        
    }
}   

"
poi,1.5,org.apache.poi.poifs.eventfilesystem.POIFSReaderRegistry,6,1,0,4,22,0,1,3,0,0.333333333,163,1.0,0,0.0,0.5,0,0,25.66666667,5,2.3333,0,"


package org.apache.poi.poifs.eventfilesystem;

import java.util.*;

import org.apache.poi.poifs.filesystem.DocumentDescriptor;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;



class POIFSReaderRegistry
{

    
    private Set omnivorousListeners;

    
    
    
    
    private Map selectiveListeners;

    
    
    
    
    
    private Map chosenDocumentDescriptors;

    

    POIFSReaderRegistry()
    {
        omnivorousListeners       = new HashSet();
        selectiveListeners        = new HashMap();
        chosenDocumentDescriptors = new HashMap();
    }

    

    void registerListener(final POIFSReaderListener listener,
                          final POIFSDocumentPath path,
                          final String documentName)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            Set descriptors = ( Set ) selectiveListeners.get(listener);

            if (descriptors == null)
            {

                
                descriptors = new HashSet();
                selectiveListeners.put(listener, descriptors);
            }
            DocumentDescriptor descriptor = new DocumentDescriptor(path,
                                                documentName);

            if (descriptors.add(descriptor))
            {

                
                
                
                Set listeners =
                    ( Set ) chosenDocumentDescriptors.get(descriptor);

                if (listeners == null)
                {

                    
                    listeners = new HashSet();
                    chosenDocumentDescriptors.put(descriptor, listeners);
                }
                listeners.add(listener);
            }
        }
    }

    

    void registerListener(final POIFSReaderListener listener)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            
            
            removeSelectiveListener(listener);
            omnivorousListeners.add(listener);
        }
    }

    

    Iterator getListeners(final POIFSDocumentPath path, final String name)
    {
        Set rval               = new HashSet(omnivorousListeners);
        Set selectiveListeners =
            ( Set ) chosenDocumentDescriptors.get(new DocumentDescriptor(path,
                name));

        if (selectiveListeners != null)
        {
            rval.addAll(selectiveListeners);
        }
        return rval.iterator();
    }

    private void removeSelectiveListener(final POIFSReaderListener listener)
    {
        Set selectedDescriptors = ( Set ) selectiveListeners.remove(listener);

        if (selectedDescriptors != null)
        {
            Iterator iter = selectedDescriptors.iterator();

            while (iter.hasNext())
            {
                dropDocument(listener, ( DocumentDescriptor ) iter.next());
            }
        }
    }

    private void dropDocument(final POIFSReaderListener listener,
                              final DocumentDescriptor descriptor)
    {
        Set listeners = ( Set ) chosenDocumentDescriptors.get(descriptor);

        listeners.remove(listener);
        if (listeners.size() == 0)
        {
            chosenDocumentDescriptors.remove(descriptor);
        }
    }
}   

"
poi,1.5,org.apache.poi.poifs.storage.HeaderBlockWriter,7,2,0,8,18,1,2,6,5,0.80952381,314,1.0,5,0.333333333,0.571428571,1,2,42.85714286,4,1.4286,1,"


package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LongField;
import org.apache.poi.util.ShortField;



public class HeaderBlockWriter
    extends BigBlock
    implements HeaderBlockConstants
{
    private static final byte _default_value = ( byte ) 0xFF;

    
    private IntegerField      _bat_count;

    
    
    private IntegerField      _property_start;

    
    
    private IntegerField      _sbat_start;

    
    private IntegerField      _xbat_start;
    private IntegerField      _xbat_count;
    private byte[]            _data;

    

    public HeaderBlockWriter()
    {
        _data = new byte[ POIFSConstants.BIG_BLOCK_SIZE ];
        Arrays.fill(_data, _default_value);
        new LongField(_signature_offset, _signature, _data);
        new IntegerField(0x08, 0, _data);
        new IntegerField(0x0c, 0, _data);
        new IntegerField(0x10, 0, _data);
        new IntegerField(0x14, 0, _data);
        new ShortField(0x18, ( short ) 0x3b, _data);
        new ShortField(0x1a, ( short ) 0x3, _data);
        new ShortField(0x1c, ( short ) -2, _data);
        new ShortField(0x1e, ( short ) 0x9, _data);
        new IntegerField(0x20, 0x6, _data);
        new IntegerField(0x24, 0, _data);
        new IntegerField(0x28, 0, _data);
        _bat_count      = new IntegerField(_bat_count_offset, 0, _data);
        _property_start = new IntegerField(_property_start_offset,
                                           POIFSConstants.END_OF_CHAIN,
                                           _data);
        new IntegerField(0x34, 0, _data);
        new IntegerField(0x38, 0x1000, _data);
        _sbat_start = new IntegerField(_sbat_start_offset,
                                       POIFSConstants.END_OF_CHAIN, _data);
        new IntegerField(0x40, 1, _data);
        _xbat_start = new IntegerField(_xbat_start_offset,
                                       POIFSConstants.END_OF_CHAIN, _data);
        _xbat_count = new IntegerField(_xbat_count_offset, 0, _data);
    }

    

    public BATBlock [] setBATBlocks(final int blockCount,
                                    final int startBlock)
    {
        BATBlock[] rvalue;

        _bat_count.set(blockCount, _data);
        int limit  = Math.min(blockCount, _max_bats_in_header);
        int offset = _bat_array_offset;

        for (int j = 0; j < limit; j++)
        {
            new IntegerField(offset, startBlock + j, _data);
            offset += LittleEndianConsts.INT_SIZE;
        }
        if (blockCount > _max_bats_in_header)
        {
            int   excess_blocks      = blockCount - _max_bats_in_header;
            int[] excess_block_array = new int[ excess_blocks ];

            for (int j = 0; j < excess_blocks; j++)
            {
                excess_block_array[ j ] = startBlock + j
                                          + _max_bats_in_header;
            }
            rvalue = BATBlock.createXBATBlocks(excess_block_array,
                                               startBlock + blockCount);
            _xbat_start.set(startBlock + blockCount, _data);
        }
        else
        {
            rvalue = BATBlock.createXBATBlocks(new int[ 0 ], 0);
            _xbat_start.set(POIFSConstants.END_OF_CHAIN, _data);
        }
        _xbat_count.set(rvalue.length, _data);
        return rvalue;
    }

    

    public void setPropertyStart(final int startBlock)
    {
        _property_start.set(startBlock, _data);
    }

    

    public void setSBATStart(final int startBlock)
    {
        _sbat_start.set(startBlock, _data);
    }

    

    static int calculateXBATStorageRequirements(final int blockCount)
    {
        return (blockCount > _max_bats_in_header)
               ? BATBlock.calculateXBATStorageRequirements(blockCount
                   - _max_bats_in_header)
               : 0;
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        doWriteData(stream, _data);
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.EndRecord,9,2,0,4,17,36,1,3,7,1.125,72,0.0,0,0.647058824,0.555555556,1,6,6.888888889,2,0.7778,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class EndRecord
    extends Record
{
    public static final short sid = 0x1034;

    public EndRecord()
    {
    }

    

    public EndRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public EndRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An END RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[END]
"");
        buffer.append(""[/END]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0));   
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 4;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.IntPtg,12,2,0,4,26,48,3,2,10,0.890909091,171,0.6,0,0.4375,0.35,1,2,12.83333333,9,1.5,4,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.LittleEndian;



public class IntPtg
    extends Ptg
{
    public final static int  SIZE = 3;
    public final static byte sid  = 0x1e;
    private short            field_1_value;

    private String val;
    private int strlen = 0;
    

    public IntPtg()
    {
    }

    public IntPtg(byte [] data, int offset)
    {
        setValue(LittleEndian.getShort(data, offset + 1));
    }
    
    protected IntPtg(String formula, int offset) {
        val = parseString(formula, offset);
        if (val == null) throw new RuntimeException(""WHOOAA there...thats got no int!"");
        strlen=val.length();
        field_1_value = Short.parseShort(val);
    }
    

    public void setValue(short value)
    {
        field_1_value = value;
    }

    public short getValue()
    {
        return field_1_value;
    }

    public void writeBytes(byte [] array, int offset)
    {
        array[ offset + 0 ] = sid;
        LittleEndian.putShort(array, offset + 1, getValue());
    }

    public int getSize()
    {
        return SIZE;
    }

    public String toFormulaString()
    {
        return """" + getValue();
    }
    
    private static String parseString(String formula, int pos) {
        String retval = null;
        while (pos < formula.length() && Character.isWhitespace(formula.charAt(pos))) {
            pos++;
        }
        
        if (pos < formula.length()) {
            if (Character.isDigit(formula.charAt(pos)) ) {
                int numpos = pos;
                
                while (numpos < formula.length() && Character.isDigit(formula.charAt(numpos))){
                    numpos++;
                }
                
                if (numpos == formula.length() || formula.charAt(numpos) != '.') {
                    String numberstr = formula.substring(pos,numpos);
                    try {
                        int number = Short.parseShort(numberstr);
                        retval = numberstr;
                    } catch (NumberFormatException e) {
                        retval = null;
                    }
                }
            }
        }
        return retval;
        
    }
    
    public static boolean isNextStringToken(String formula, int pos) {
        return (parseString(formula,pos) != null);
    }
    
    public int getPrecedence() {
        return 5;
    }
    
    public int getStringLength() {
        return strlen;
    }    
}
"
poi,1.5,org.apache.poi.hssf.record.SheetPropertiesRecord,23,2,0,6,40,0,1,5,21,0.838842975,386,0.636363636,5,0.35483871,0.297101449,1,6,15.30434783,2,0.913,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class SheetPropertiesRecord
    extends Record
{
    public final static short      sid                             = 0x1044;
    private  short      field_1_flags;
    private BitField   chartTypeManuallyFormatted                 = new BitField(0x1);
    private BitField   plotVisibleOnly                            = new BitField(0x2);
    private BitField   doNotSizeWithWindow                        = new BitField(0x4);
    private BitField   defaultPlotDimensions                      = new BitField(0x8);
    private BitField   autoPlotArea                               = new BitField(0x10);
    private  byte       field_2_empty;
    public final static byte        EMPTY_NOT_PLOTTED              = 0;
    public final static byte        EMPTY_ZERO                     = 1;
    public final static byte        EMPTY_INTERPOLATED             = 2;


    public SheetPropertiesRecord()
    {

    }

    

    public SheetPropertiesRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SheetPropertiesRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a SheetProperties record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_flags                   = LittleEndian.getShort(data, 0x0 + offset);
        field_2_empty                   = data[ 0x2 + offset ];

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SheetProperties]
"");

        buffer.append(""    .flags                = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFlags()))
            .append("" ("").append(getFlags()).append("" )
"");
        buffer.append(""         .chartTypeManuallyFormatted     = "").append(isChartTypeManuallyFormatted()).append('
');
        buffer.append(""         .plotVisibleOnly          = "").append(isPlotVisibleOnly     ()).append('
');
        buffer.append(""         .doNotSizeWithWindow      = "").append(isDoNotSizeWithWindow ()).append('
');
        buffer.append(""         .defaultPlotDimensions     = "").append(isDefaultPlotDimensions()).append('
');
        buffer.append(""         .autoPlotArea             = "").append(isAutoPlotArea        ()).append('
');

        buffer.append(""    .empty                = "")
            .append(""0x"")
            .append(HexDump.toHex((byte)getEmpty()))
            .append("" ("").append(getEmpty()).append("" )
"");

        buffer.append(""[/SheetProperties]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_flags);
        data[ 6 + offset ] = field_2_empty;

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 1;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getFlags()
    {
        return field_1_flags;
    }

    
    public void setFlags(short field_1_flags)
    {
        this.field_1_flags = field_1_flags;
    }

    
    public byte getEmpty()
    {
        return field_2_empty;
    }

    
    public void setEmpty(byte field_2_empty)
    {
        this.field_2_empty = field_2_empty;
    }

    
    public void setChartTypeManuallyFormatted(boolean value)
    {
        field_1_flags = chartTypeManuallyFormatted.setShortBoolean(field_1_flags, value);
    }

    
    public boolean isChartTypeManuallyFormatted()
    {
        return chartTypeManuallyFormatted.isSet(field_1_flags);
    }

    
    public void setPlotVisibleOnly(boolean value)
    {
        field_1_flags = plotVisibleOnly.setShortBoolean(field_1_flags, value);
    }

    
    public boolean isPlotVisibleOnly()
    {
        return plotVisibleOnly.isSet(field_1_flags);
    }

    
    public void setDoNotSizeWithWindow(boolean value)
    {
        field_1_flags = doNotSizeWithWindow.setShortBoolean(field_1_flags, value);
    }

    
    public boolean isDoNotSizeWithWindow()
    {
        return doNotSizeWithWindow.isSet(field_1_flags);
    }

    
    public void setDefaultPlotDimensions(boolean value)
    {
        field_1_flags = defaultPlotDimensions.setShortBoolean(field_1_flags, value);
    }

    
    public boolean isDefaultPlotDimensions()
    {
        return defaultPlotDimensions.isSet(field_1_flags);
    }

    
    public void setAutoPlotArea(boolean value)
    {
        field_1_flags = autoPlotArea.setShortBoolean(field_1_flags, value);
    }

    
    public boolean isAutoPlotArea()
    {
        return autoPlotArea.isSet(field_1_flags);
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.PrintSetupRecord,48,2,0,6,65,694,2,4,45,0.911702128,677,0.95,8,0.2,0.273049645,1,6,12.6875,2,0.9375,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.BitField;



public class PrintSetupRecord
    extends Record
{
    public final static short     sid = 0xa1;
    private short                 field_1_paper_size;
    private short                 field_2_scale;
    private short                 field_3_page_start;
    private short                 field_4_fit_width;
    private short                 field_5_fit_height;
    private short                 field_6_options;
    static final private BitField lefttoright   =
        new BitField(0x01);   
    static final private BitField landscape     =
        new BitField(0x02);   
    static final private BitField validsettings = new BitField(
        0x04);                

    
    
    static final private BitField nocolor       =
        new BitField(0x08);   
    static final private BitField draft         =
        new BitField(0x10);   
    static final private BitField notes         =
        new BitField(0x20);   
    static final private BitField noOrientation =
        new BitField(0x40);   
    static final private BitField usepage       =
        new BitField(0x80);   
    private short                 field_7_hresolution;
    private short                 field_8_vresolution;
    private double                field_9_headermargin;
    private double                field_10_footermargin;
    private short                 field_11_copies;

    public PrintSetupRecord()
    {
    }

    

    public PrintSetupRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PrintSetupRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(
                ""NOT A valid PrintSetup record RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_paper_size    = LittleEndian.getShort(data, 0 + offset);
        field_2_scale         = LittleEndian.getShort(data, 2 + offset);
        field_3_page_start    = LittleEndian.getShort(data, 4 + offset);
        field_4_fit_width     = LittleEndian.getShort(data, 6 + offset);
        field_5_fit_height    = LittleEndian.getShort(data, 8 + offset);
        field_6_options       = LittleEndian.getShort(data, 10 + offset);
        field_7_hresolution   = LittleEndian.getShort(data, 12 + offset);
        field_8_vresolution   = LittleEndian.getShort(data, 14 + offset);
        field_9_headermargin  = LittleEndian.getDouble(data, 16 + offset);
        field_10_footermargin = LittleEndian.getDouble(data, 24 + offset);
        field_11_copies       = LittleEndian.getShort(data, 32 + offset);
    }

    public void setPaperSize(short size)
    {
        field_1_paper_size = size;
    }

    public void setScale(short scale)
    {
        field_2_scale = scale;
    }

    public void setPageStart(short start)
    {
        field_3_page_start = start;
    }

    public void setFitWidth(short width)
    {
        field_4_fit_width = width;
    }

    public void setFitHeight(short height)
    {
        field_5_fit_height = height;
    }

    public void setOptions(short options)
    {
        field_6_options = options;
    }

    
    public void setLeftToRight(boolean ltor)
    {
        field_6_options = lefttoright.setShortBoolean(field_6_options, ltor);
    }

    public void setLandscape(boolean ls)
    {
        field_6_options = landscape.setShortBoolean(field_6_options, ls);
    }

    public void setValidSettings(boolean valid)
    {
        field_6_options = validsettings.setShortBoolean(field_6_options, valid);
    }

    public void setNoColor(boolean mono)
    {
        field_6_options = nocolor.setShortBoolean(field_6_options, mono);
    }

    public void setDraft(boolean d)
    {
        field_6_options = draft.setShortBoolean(field_6_options, d);
    }

    public void setNotes(boolean printnotes)
    {
        field_6_options = notes.setShortBoolean(field_6_options, printnotes);
    }

    public void setNoOrientation(boolean orientation)
    {
        field_6_options = noOrientation.setShortBoolean(field_6_options, orientation);
    }

    public void setUsePage(boolean page)
    {
        field_6_options = usepage.setShortBoolean(field_6_options, page);
    }

    
    public void setHResolution(short resolution)
    {
        field_7_hresolution = resolution;
    }

    public void setVResolution(short resolution)
    {
        field_8_vresolution = resolution;
    }

    public void setHeaderMargin(double headermargin)
    {
        field_9_headermargin = headermargin;
    }

    public void setFooterMargin(double footermargin)
    {
        field_10_footermargin = footermargin;
    }

    public void setCopies(short copies)
    {
        field_11_copies = copies;
    }

    public short getPaperSize()
    {
        return field_1_paper_size;
    }

    public short getScale()
    {
        return field_2_scale;
    }

    public short getPageStart()
    {
        return field_3_page_start;
    }

    public short getFitWidth()
    {
        return field_4_fit_width;
    }

    public short getFitHeight()
    {
        return field_5_fit_height;
    }

    public short getOptions()
    {
        return field_6_options;
    }

    
    public boolean getLeftToRight()
    {
        return lefttoright.isSet(field_6_options);
    }

    public boolean getLandscape()
    {
        return landscape.isSet(field_6_options);
    }

    public boolean getValidSettings()
    {
        return validsettings.isSet(field_6_options);
    }

    public boolean getNoColor()
    {
        return nocolor.isSet(field_6_options);
    }

    public boolean getDraft()
    {
        return draft.isSet(field_6_options);
    }

    public boolean getNotes()
    {
        return notes.isSet(field_6_options);
    }

    public boolean getNoOrientation()
    {
        return noOrientation.isSet(field_6_options);
    }

    public boolean getUsePage()
    {
        return usepage.isSet(field_6_options);
    }

    
    public short getHResolution()
    {
        return field_7_hresolution;
    }

    public short getVResolution()
    {
        return field_8_vresolution;
    }

    public double getHeaderMargin()
    {
        return field_9_headermargin;
    }

    public double getFooterMargin()
    {
        return field_10_footermargin;
    }

    public short getCopies()
    {
        return field_11_copies;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRINTSETUP]
"");
        buffer.append(""    .papersize      = "").append(getPaperSize())
            .append(""
"");
        buffer.append(""    .scale          = "").append(getScale())
            .append(""
"");
        buffer.append(""    .pagestart      = "").append(getPageStart())
            .append(""
"");
        buffer.append(""    .fitwidth       = "").append(getFitWidth())
            .append(""
"");
        buffer.append(""    .fitheight      = "").append(getFitHeight())
            .append(""
"");
        buffer.append(""    .options        = "").append(getOptions())
            .append(""
"");
        buffer.append(""        .ltor       = "").append(getLeftToRight())
            .append(""
"");
        buffer.append(""        .landscape  = "").append(getLandscape())
            .append(""
"");
        buffer.append(""        .valid      = "").append(getValidSettings())
            .append(""
"");
        buffer.append(""        .mono       = "").append(getNoColor())
            .append(""
"");
        buffer.append(""        .draft      = "").append(getDraft())
            .append(""
"");
        buffer.append(""        .notes      = "").append(getNotes())
            .append(""
"");
        buffer.append(""        .noOrientat = "").append(getNoOrientation())
            .append(""
"");
        buffer.append(""        .usepage    = "").append(getUsePage())
            .append(""
"");
        buffer.append(""    .hresolution    = "").append(getHResolution())
            .append(""
"");
        buffer.append(""    .vresolution    = "").append(getVResolution())
            .append(""
"");
        buffer.append(""    .headermargin   = "").append(getHeaderMargin())
            .append(""
"");
        buffer.append(""    .footermargin   = "").append(getFooterMargin())
            .append(""
"");
        buffer.append(""    .copies         = "").append(getCopies())
            .append(""
"");
        buffer.append(""[/PRINTSETUP]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 34);
        LittleEndian.putShort(data, 4 + offset, getPaperSize());
        LittleEndian.putShort(data, 6 + offset, getScale());
        LittleEndian.putShort(data, 8 + offset, getPageStart());
        LittleEndian.putShort(data, 10 + offset, getFitWidth());
        LittleEndian.putShort(data, 12 + offset, getFitHeight());
        LittleEndian.putShort(data, 14 + offset, getOptions());
        LittleEndian.putShort(data, 16 + offset, getHResolution());
        LittleEndian.putShort(data, 18 + offset, getVResolution());
        LittleEndian.putDouble(data, 20 + offset, getHeaderMargin());
        LittleEndian.putDouble(data, 28 + offset, getFooterMargin());
        LittleEndian.putShort(data, 36 + offset, getCopies());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 38;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.FormulaRecord,35,2,0,8,53,535,3,5,30,0.941176471,396,0.818181818,0,0.255813953,0.225,1,5,10.0,7,1.6,10,"



package org.apache.poi.hssf.record;

import java.util.Stack;
import java.util.List;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.hssf.record.formula.*;



public class FormulaRecord
    extends Record
    implements CellValueRecordInterface, Comparable
{
    
    public static final boolean EXPERIMENTAL_FORMULA_SUPPORT_ENABLED=false;
    
    public static final short sid =
        0x06;   
    
    private short             field_1_row;
    private short             field_2_column;
    private short             field_3_xf;
    private double            field_4_value;
    private short             field_5_options;
    private int               field_6_zero;
    private short             field_7_expression_len;
    private Stack             field_8_parsed_expr;
    
    private byte[]            all_data; 
                                        

    

    public FormulaRecord()
    {
        field_8_parsed_expr = new Stack();
    }

    

    public FormulaRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FormulaRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        if (EXPERIMENTAL_FORMULA_SUPPORT_ENABLED) {
        field_1_row            = LittleEndian.getShort(data, 0 + offset);
        field_2_column         = LittleEndian.getShort(data, 2 + offset);
        field_3_xf             = LittleEndian.getShort(data, 4 + offset);
        field_4_value          = LittleEndian.getDouble(data, 6 + offset);
        field_5_options        = LittleEndian.getShort(data, 14 + offset);
        field_6_zero           = LittleEndian.getInt(data, 16 + offset);
        field_7_expression_len = LittleEndian.getShort(data, 20 + offset);
        field_8_parsed_expr    = getParsedExpressionTokens(data, size,
                                 offset);
        
        } else {
            all_data = new byte[size+4];
            LittleEndian.putShort(all_data,0,sid);
            LittleEndian.putShort(all_data,2,size);
            System.arraycopy(data,offset,all_data,4,size);
        }

    }

    private Stack getParsedExpressionTokens(byte [] data, short size,
                                            int offset)
    {
        Stack stack = new Stack();
        
        return stack;
    }

    public void setRow(short row)
    {
        field_1_row = row;
    }

    public void setColumn(short column)
    {
        field_2_column = column;
    }

    public void setXFIndex(short xf)
    {
        field_3_xf = xf;
    }

    

    public void setValue(double value)
    {
        field_4_value = value;
    }

    

    public void setOptions(short options)
    {
        field_5_options = options;
    }

    

    public void setExpressionLength(short len)
    {
        field_7_expression_len = len;
    }

    public short getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_column;
    }

    public short getXFIndex()
    {
        return field_3_xf;
    }

    

    public double getValue()
    {
        return field_4_value;
    }

    

    public short getOptions()
    {
        return field_5_options;
    }

    

    public short getExpressionLength()
    {
        return field_7_expression_len;
    }

    

    public void pushExpressionToken(Ptg ptg)
    {
        field_8_parsed_expr.push(ptg);
    }

    

    public Ptg popExpressionToken()
    {
        return ( Ptg ) field_8_parsed_expr.pop();
    }

    

    public Ptg peekExpressionToken()
    {
        return ( Ptg ) field_8_parsed_expr.peek();
    }

    

    public int getNumberOfExpressionTokens()
    {
        return field_8_parsed_expr.size();
    }

    

    public List getParsedExpression()
    {
        return ( List ) field_8_parsed_expr;
    }

    

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A FORMULA RECORD"");
        }
    }

    public short getSid()
    {
        return sid;
    }

    

    public int serialize(int offset, byte [] data)
    {
        if (EXPERIMENTAL_FORMULA_SUPPORT_ENABLED) {
        int ptgSize = getTotalPtgSize();

        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) (24 + ptgSize));
        LittleEndian.putShort(data, 4 + offset, getRow());
        LittleEndian.putShort(data, 6 + offset, getColumn());
        LittleEndian.putShort(data, 8 + offset, getXFIndex());
        LittleEndian.putDouble(data, 10 + offset, getValue());
        LittleEndian.putShort(data, 18 + offset, getOptions());
        LittleEndian.putInt(data, 20 + offset, field_6_zero);
        LittleEndian.putShort(data, 24 + offset, getExpressionLength());
        } else {
            System.arraycopy(all_data,0,data,offset,all_data.length);
        }

        
        return getRecordSize();
    }

    public int getRecordSize()
    {
        int retval =0;
        
        if (EXPERIMENTAL_FORMULA_SUPPORT_ENABLED) {
            retval = getTotalPtgSize() + 28;
        } else {
            retval =all_data.length;
        }
        return retval;

        
    }

    private int getTotalPtgSize()
    {
        List list   = getParsedExpression();
        int  retval = 0;

        for (int k = 0; k < list.size(); k++)
        {
            Ptg ptg = ( Ptg ) list.get(k);

            retval += ptg.getSize();
        }
        return retval;
    }

    private void serializePtgs(byte [] data, int offset)
    {
        int pos = offset;

        for (int k = 0; k < field_8_parsed_expr.size(); k++)
        {
            Ptg ptg = ( Ptg ) field_8_parsed_expr.get(k);

            ptg.writeBytes(data, pos);
            pos += ptg.getSize();
        }
    }

    public boolean isBefore(CellValueRecordInterface i)
    {
        if (this.getRow() > i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() > i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isAfter(CellValueRecordInterface i)
    {
        if (this.getRow() < i.getRow())
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() < i.getColumn()))
        {
            return false;
        }
        if ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()))
        {
            return false;
        }
        return true;
    }

    public boolean isEqual(CellValueRecordInterface i)
    {
        return ((this.getRow() == i.getRow())
                && (this.getColumn() == i.getColumn()));
    }

    public boolean isInValueSection()
    {
        return true;
    }

    public boolean isValue()
    {
        return true;
    }

    public int compareTo(Object obj)
    {
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return 0;
        }
        if (this.getRow() < loc.getRow())
        {
            return -1;
        }
        if (this.getRow() > loc.getRow())
        {
            return 1;
        }
        if (this.getColumn() < loc.getColumn())
        {
            return -1;
        }
        if (this.getColumn() > loc.getColumn())
        {
            return 1;
        }
        return -1;
    }

    public boolean equals(Object obj)
    {
        if (!(obj instanceof CellValueRecordInterface))
        {
            return false;
        }
        CellValueRecordInterface loc = ( CellValueRecordInterface ) obj;

        if ((this.getRow() == loc.getRow())
                && (this.getColumn() == loc.getColumn()))
        {
            return true;
        }
        return false;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.BlockListImpl,6,1,2,5,13,0,2,3,4,0.5,107,1.0,2,0.0,0.458333333,0,0,16.5,3,1.1667,0,"


package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;



class BlockListImpl
    implements BlockList
{
    private ListManagedBlock[]         _blocks;
    private BlockAllocationTableReader _bat;

    

    protected BlockListImpl()
    {
        _blocks = new ListManagedBlock[ 0 ];
        _bat    = null;
    }

    

    protected void setBlocks(final ListManagedBlock [] blocks)
    {
        _blocks = blocks;
    }

    

    

    public void zap(final int index)
    {
        if ((index >= 0) && (index < _blocks.length))
        {
            _blocks[ index ] = null;
        }
    }

    

    public ListManagedBlock remove(final int index)
        throws IOException
    {
        ListManagedBlock result = null;

        try
        {
            result = _blocks[ index ];
            if (result == null)
            {
                throw new IOException(""block[ "" + index
                                      + "" ] already removed"");
            }
            _blocks[ index ] = null;
        }
        catch (ArrayIndexOutOfBoundsException ignored)
        {
            throw new IOException(""Cannot remove block[ "" + index
                                  + "" ]; out of range"");
        }
        return result;
    }

    

    public ListManagedBlock [] fetchBlocks(final int startBlock)
        throws IOException
    {
        if (_bat == null)
        {
            throw new IOException(
                ""Improperly initialized list: no block allocation table provided"");
        }
        return _bat.fetchBlocks(startBlock, this);
    }

    

    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException
    {
        if (_bat != null)
        {
            throw new IOException(
                ""Attempt to replace existing BlockAllocationTable"");
        }
        _bat = bat;
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.PasswordRecord,11,2,0,5,21,49,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class PasswordRecord
    extends Record
{
    public final static short sid = 0x13;
    private short             field_1_password;   

    public PasswordRecord()
    {
    }

    

    public PasswordRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PasswordRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PASSWORD RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_password = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setPassword(short password)
    {
        field_1_password = password;
    }

    

    public short getPassword()
    {
        return field_1_password;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PASSWORD]
"");
        buffer.append(""    .password       = "")
            .append(Integer.toHexString(getPassword())).append(""
"");
        buffer.append(""[/PASSWORD]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getPassword());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.NumberFormatIndexRecord,11,2,0,4,22,43,0,4,9,0.85,117,0.5,0,0.578947368,0.522727273,1,6,9.454545455,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class NumberFormatIndexRecord
    extends Record
{
    public final static short      sid                             = 0x104e;
    private  short      field_1_formatIndex;


    public NumberFormatIndexRecord()
    {

    }

    

    public NumberFormatIndexRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public NumberFormatIndexRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a NumberFormatIndex record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_formatIndex             = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[NumberFormatIndex]
"");

        buffer.append(""    .formatIndex          = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getFormatIndex()))
            .append("" ("").append(getFormatIndex()).append("" )
"");

        buffer.append(""[/NumberFormatIndex]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_formatIndex);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getFormatIndex()
    {
        return field_1_formatIndex;
    }

    
    public void setFormatIndex(short field_1_formatIndex)
    {
        this.field_1_formatIndex = field_1_formatIndex;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.StyleRecord,24,2,0,6,37,210,2,4,21,0.875,368,0.625,0,0.34375,0.298611111,1,6,14.0,3,1.2083,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;



public class StyleRecord
    extends Record
{
    public final static short sid                = 0x293;
    public final static short STYLE_USER_DEFINED = 0;
    public final static short STYLE_BUILT_IN     = 1;

    
    private short             field_1_xf_index;   

    
    private byte              field_2_builtin_style;
    private byte              field_3_outline_style_level;

    
    private byte              field_2_name_length;
    private String            field_3_name;

    public StyleRecord()
    {
    }

    

    public StyleRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public StyleRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A STYLE RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_xf_index = LittleEndian.getShort(data, 0 + offset);
        if (getType() == 1)
        {
            field_2_builtin_style       = data[ 2 + offset ];
            field_3_outline_style_level = data[ 3 + offset ];
        }
        else if (getType() == 0)
        {
            field_2_name_length = data[ 2 + offset ];
            field_3_name        = new String(data, 3 + offset,
                                             LittleEndian.ubyteToInt(field_2_name_length));
        }

        
    }

    

    public void setIndex(short index)
    {
        field_1_xf_index = index;
    }

    

    

    public void setType(short type)
    {
        field_1_xf_index = setField(field_1_xf_index, type, 0x8000, 15);
    }

    

    public void setXFIndex(short index)
    {
        field_1_xf_index = setField(field_1_xf_index, index, 0x1FFF, 0);
    }

    
    

    

    public void setNameLength(byte length)
    {
        field_2_name_length = length;
    }

    

    public void setName(String name)
    {
        field_3_name = name;
    }

    
    

    

    public void setBuiltin(byte builtin)
    {
        field_2_builtin_style = builtin;
    }

    

    public void setOutlineStyleLevel(byte level)
    {
        field_3_outline_style_level = level;
    }

    
    

    

    public short getIndex()
    {
        return field_1_xf_index;
    }

    

    

    public short getType()
    {
        return ( short ) ((field_1_xf_index & 0x8000) >> 15);
    }

    

    public short getXFIndex()
    {
        return ( short ) (field_1_xf_index & 0x1FFF);
    }

    
    

    

    public byte getNameLength()
    {
        return field_2_name_length;
    }

    

    public String getName()
    {
        return field_3_name;
    }

    
    

    

    public byte getBuiltin()
    {
        return field_2_builtin_style;
    }

    

    public byte getOutlineStyleLevel()
    {
        return field_3_outline_style_level;
    }

    
    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[STYLE]
"");
        buffer.append(""    .xf_index_raw    = "")
            .append(Integer.toHexString(getIndex())).append(""
"");
        buffer.append(""        .type        = "")
            .append(Integer.toHexString(getType())).append(""
"");
        buffer.append(""        .xf_index    = "")
            .append(Integer.toHexString(getXFIndex())).append(""
"");
        if (getType() == STYLE_BUILT_IN)
        {
            buffer.append(""    .builtin_style   = "")
                .append(Integer.toHexString(getBuiltin())).append(""
"");
            buffer.append(""    .outline_level   = "")
                .append(Integer.toHexString(getOutlineStyleLevel()))
                .append(""
"");
        }
        else if (getType() == STYLE_USER_DEFINED)
        {
            buffer.append(""    .name_length     = "")
                .append(Integer.toHexString(getNameLength())).append(""
"");
            buffer.append(""    .name            = "").append(getName())
                .append(""
"");
        }
        buffer.append(""[/STYLE]
"");
        return buffer.toString();
    }

    private short setField(int fieldValue, int new_value, int mask,
                           int shiftLeft)
    {
        return ( short ) ((fieldValue & ~mask)
                          | ((new_value << shiftLeft) & mask));
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        if (getType() == STYLE_BUILT_IN)
        {
            LittleEndian.putShort(data, 2 + offset,
                                  (( short ) 0x04));   
        }
        else
        {
            LittleEndian.putShort(data, 2 + offset,
                                  (( short ) (0x03 + getNameLength())));
        }
        LittleEndian.putShort(data, 4 + offset, getIndex());
        if (getType() == STYLE_BUILT_IN)
        {
            data[ 6 + offset ] = getBuiltin();
            data[ 7 + offset ] = getOutlineStyleLevel();
        }
        else
        {
            data[ 6 + offset ] = getNameLength();
            StringUtil.putCompressedUnicode(getName(), data, 7 + offset);
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        int retval;

        if (getType() == STYLE_BUILT_IN)
        {
            retval = 8;
        }
        else
        {
            retval = 7 + getNameLength();
        }
        return retval;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.BlockList,4,1,0,6,4,6,5,2,4,2.0,4,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"


package org.apache.poi.poifs.storage;

import java.io.IOException;



public interface BlockList
{

    

    public void zap(final int index);

    

    public ListManagedBlock remove(final int index)
        throws IOException;

    

    public ListManagedBlock [] fetchBlocks(final int startBlock)
        throws IOException;

    

    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException;
}   

"
poi,1.5,org.apache.poi.hssf.record.Record,14,1,100,115,16,85,115,0,11,0.846153846,125,0.75,0,0.0,0.5,0,0,7.642857143,1,0.7857,1,"


package org.apache.poi.hssf.record;



public abstract class Record
{

    

    public short   sid  = 0;
    private short  id   = 0;
    private short  size = 0;
    private byte[] data = null;

    

    public Record()
    {
    }

    

    public Record(short id, short size, byte [] data)
    {
        this.id   = id;
        this.size = size;
        this.data = data;
        validateSid(id);
        fillFields(data, size);
    }

    

    public Record(short id, short size, byte [] data, int offset)
    {
        this.id   = id;
        this.size = size;
        this.data = data;
        validateSid(id);
        fillFields(data, size, offset);
    }

    

    protected abstract void validateSid(short id);

    

    protected void fillFields(byte [] data, short size)
    {
        fillFields(data, size, 0);
    }

    

    protected abstract void fillFields(byte [] data, short size, int offset);

    

    public byte [] serialize()
    {
        byte[] retval = new byte[ getRecordSize() ];

        serialize(0, retval);
        return retval;
    }

    

    public abstract int serialize(int offset, byte [] data);

    

    public int getRecordSize()
    {

        
        
        return serialize().length;
    }

    

    public boolean isValue()
    {
        return false;
    }

    

    public boolean isInValueSection()
    {
        return false;
    }

    

    public String toString()
    {
        return super.toString();
    }

    

    

    
    public void processContinueRecord(byte [] record)
    {

        
    }

    

    public abstract short getSid();
}
"
poi,1.5,org.apache.poi.hssf.record.WSBoolRecord,30,2,0,7,43,183,3,4,27,0.864942529,391,0.916666667,9,0.297297297,0.287356322,1,6,11.63333333,2,0.9,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;



public class WSBoolRecord
    extends Record
{
    public final static short     sid = 0x81;
    private byte                  field_1_wsbool;         
    private byte                  field_2_wsbool;         

    
    static final private BitField autobreaks          =
        new BitField(0x01);                               

    
    static final private BitField dialog              =
        new BitField(0x10);                               
    static final private BitField applystyles         =
        new BitField(0x20);                               
    static final private BitField rowsumsbelow        = new BitField(
        0x40);                                            
    static final private BitField rowsumsright        = new BitField(
        0x80);                                            
    static final private BitField fittopage           =
        new BitField(0x01);                               

    
    static final private BitField displayguts         = new BitField(
        0x06);                                            

    
    static final private BitField alternateexpression =   
        new BitField(0x40);
    static final private BitField alternateformula    =   
        new BitField(0x80);

    public WSBoolRecord()
    {
    }

    

    public WSBoolRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public WSBoolRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A WSBoolRECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_wsbool =
            data[ 1 + offset ];   
        field_2_wsbool =
            data[ 0 + offset ];   
    }                             

    
    
    
    
    

    

    public void setWSBool1(byte bool1)
    {
        field_1_wsbool = bool1;
    }

    

    

    public void setAutobreaks(boolean ab)
    {
        field_1_wsbool = autobreaks.setByteBoolean(field_1_wsbool, ab);
    }

    

    public void setDialog(boolean isDialog)
    {
        field_1_wsbool = dialog.setByteBoolean(field_1_wsbool, isDialog);
    }

    

    public void setRowSumsBelow(boolean below)
    {
        field_1_wsbool = rowsumsbelow.setByteBoolean(field_1_wsbool, below);
    }

    

    public void setRowSumsRight(boolean right)
    {
        field_1_wsbool = rowsumsright.setByteBoolean(field_1_wsbool, right);
    }

    

    

    public void setWSBool2(byte bool2)
    {
        field_2_wsbool = field_2_wsbool = bool2;
    }

    

    

    public void setFitToPage(boolean fit2page)
    {
        field_2_wsbool = fittopage.setByteBoolean(field_2_wsbool, fit2page);
    }

    

    public void setDisplayGuts(boolean guts)
    {
        field_2_wsbool = displayguts.setByteBoolean(field_2_wsbool, guts);
    }

    

    public void setAlternateExpression(boolean altexp)
    {
        field_2_wsbool = alternateexpression.setByteBoolean(field_2_wsbool,
                altexp);
    }

    

    public void setAlternateFormula(boolean formula)
    {
        field_2_wsbool = alternateformula.setByteBoolean(field_2_wsbool,
                formula);
    }

    

    

    public byte getWSBool1()
    {
        return field_1_wsbool;
    }

    

    

    public boolean getAutobreaks()
    {
        return autobreaks.isSet(field_1_wsbool);
    }

    

    public boolean getDialog()
    {
        return dialog.isSet(field_1_wsbool);
    }

    

    public boolean getRowSumsBelow()
    {
        return rowsumsbelow.isSet(field_1_wsbool);
    }

    

    public boolean getRowSumsRight()
    {
        return rowsumsright.isSet(field_1_wsbool);
    }

    

    

    public byte getWSBool2()
    {
        return field_2_wsbool;
    }

    

    

    public boolean getFitToPage()
    {
        return fittopage.isSet(field_2_wsbool);
    }

    

    public boolean getDisplayGuts()
    {
        return displayguts.isSet(field_2_wsbool);
    }

    

    public boolean getAlternateExpression()
    {
        return alternateexpression.isSet(field_2_wsbool);
    }

    

    public boolean getAlternateFormula()
    {
        return alternateformula.isSet(field_2_wsbool);
    }

    
    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WSBOOL]
"");
        buffer.append(""    .wsbool1        = "")
            .append(Integer.toHexString(getWSBool1())).append(""
"");
        buffer.append(""        .autobreaks = "").append(getAutobreaks())
            .append(""
"");
        buffer.append(""        .dialog     = "").append(getDialog())
            .append(""
"");
        buffer.append(""        .rowsumsbelw= "").append(getRowSumsBelow())
            .append(""
"");
        buffer.append(""        .rowsumsrigt= "").append(getRowSumsRight())
            .append(""
"");
        buffer.append(""    .wsbool2        = "")
            .append(Integer.toHexString(getWSBool2())).append(""
"");
        buffer.append(""        .fittopage  = "").append(getFitToPage())
            .append(""
"");
        buffer.append(""        .displayguts= "").append(getDisplayGuts())
            .append(""
"");
        buffer.append(""        .alternateex= "")
            .append(getAlternateExpression()).append(""
"");
        buffer.append(""        .alternatefo= "").append(getAlternateFormula())
            .append(""
"");
        buffer.append(""[/WSBOOL]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        data[ 5 + offset ] = getWSBool1();
        data[ 4 + offset ] = getWSBool2();
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.SeriesRecord,21,2,0,5,32,148,1,4,19,0.971052632,334,0.315789474,0,0.379310345,0.452380952,1,6,14.0,2,0.9048,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class SeriesRecord
    extends Record
{
    public final static short      sid                             = 0x1003;
    private  short      field_1_categoryDataType;
    public final static short       CATEGORY_DATA_TYPE_DATES       = 0;
    public final static short       CATEGORY_DATA_TYPE_NUMERIC     = 1;
    public final static short       CATEGORY_DATA_TYPE_SEQUENCE    = 2;
    public final static short       CATEGORY_DATA_TYPE_TEXT        = 3;
    private  short      field_2_valuesDataType;
    public final static short       VALUES_DATA_TYPE_DATES         = 0;
    public final static short       VALUES_DATA_TYPE_NUMERIC       = 1;
    public final static short       VALUES_DATA_TYPE_SEQUENCE      = 2;
    public final static short       VALUES_DATA_TYPE_TEXT          = 3;
    private  short      field_3_numCategories;
    private  short      field_4_numValues;
    private  short      field_5_bubbleSeriesType;
    public final static short       BUBBLE_SERIES_TYPE_DATES       = 0;
    public final static short       BUBBLE_SERIES_TYPE_NUMERIC     = 1;
    public final static short       BUBBLE_SERIES_TYPE_SEQUENCE    = 2;
    public final static short       BUBBLE_SERIES_TYPE_TEXT        = 3;
    private  short      field_6_numBubbleValues;


    public SeriesRecord()
    {

    }

    

    public SeriesRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public SeriesRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Series record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_categoryDataType        = LittleEndian.getShort(data, 0x0 + offset);
        field_2_valuesDataType          = LittleEndian.getShort(data, 0x2 + offset);
        field_3_numCategories           = LittleEndian.getShort(data, 0x4 + offset);
        field_4_numValues               = LittleEndian.getShort(data, 0x6 + offset);
        field_5_bubbleSeriesType        = LittleEndian.getShort(data, 0x8 + offset);
        field_6_numBubbleValues         = LittleEndian.getShort(data, 0xa + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Series]
"");

        buffer.append(""    .categoryDataType     = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getCategoryDataType()))
            .append("" ("").append(getCategoryDataType()).append("" )
"");

        buffer.append(""    .valuesDataType       = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getValuesDataType()))
            .append("" ("").append(getValuesDataType()).append("" )
"");

        buffer.append(""    .numCategories        = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getNumCategories()))
            .append("" ("").append(getNumCategories()).append("" )
"");

        buffer.append(""    .numValues            = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getNumValues()))
            .append("" ("").append(getNumValues()).append("" )
"");

        buffer.append(""    .bubbleSeriesType     = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getBubbleSeriesType()))
            .append("" ("").append(getBubbleSeriesType()).append("" )
"");

        buffer.append(""    .numBubbleValues      = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getNumBubbleValues()))
            .append("" ("").append(getNumBubbleValues()).append("" )
"");

        buffer.append(""[/Series]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_categoryDataType);
        LittleEndian.putShort(data, 6 + offset, field_2_valuesDataType);
        LittleEndian.putShort(data, 8 + offset, field_3_numCategories);
        LittleEndian.putShort(data, 10 + offset, field_4_numValues);
        LittleEndian.putShort(data, 12 + offset, field_5_bubbleSeriesType);
        LittleEndian.putShort(data, 14 + offset, field_6_numBubbleValues);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2 + 2 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getCategoryDataType()
    {
        return field_1_categoryDataType;
    }

    
    public void setCategoryDataType(short field_1_categoryDataType)
    {
        this.field_1_categoryDataType = field_1_categoryDataType;
    }

    
    public short getValuesDataType()
    {
        return field_2_valuesDataType;
    }

    
    public void setValuesDataType(short field_2_valuesDataType)
    {
        this.field_2_valuesDataType = field_2_valuesDataType;
    }

    
    public short getNumCategories()
    {
        return field_3_numCategories;
    }

    
    public void setNumCategories(short field_3_numCategories)
    {
        this.field_3_numCategories = field_3_numCategories;
    }

    
    public short getNumValues()
    {
        return field_4_numValues;
    }

    
    public void setNumValues(short field_4_numValues)
    {
        this.field_4_numValues = field_4_numValues;
    }

    
    public short getBubbleSeriesType()
    {
        return field_5_bubbleSeriesType;
    }

    
    public void setBubbleSeriesType(short field_5_bubbleSeriesType)
    {
        this.field_5_bubbleSeriesType = field_5_bubbleSeriesType;
    }

    
    public short getNumBubbleValues()
    {
        return field_6_numBubbleValues;
    }

    
    public void setNumBubbleValues(short field_6_numBubbleValues)
    {
        this.field_6_numBubbleValues = field_6_numBubbleValues;
    }


}  




"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFDateUtil,8,1,0,1,20,26,1,0,3,1.047619048,169,1.0,0,0.0,0.2,0,0,19.75,2,1.25,1,"



package org.apache.poi.hssf.usermodel;

import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;



public class HSSFDateUtil
{
    private HSSFDateUtil()
    {
    }

    private static final int    BAD_DATE          =
        -1;   
    private static final long   DAY_MILLISECONDS  = 24 * 60 * 60 * 1000;
    private static final double CAL_1900_ABSOLUTE =
        ( double ) absoluteDay(new GregorianCalendar(1900, Calendar
        .JANUARY, 1)) - 2.0;

    

    public static double getExcelDate(Date date)
    {
        Calendar calStart = new GregorianCalendar();

        calStart.setTime(
            date);   
        if (calStart.get(Calendar.YEAR) < 1900)
        {
            return BAD_DATE;
        }
        else
        {
            calStart = dayStart(calStart);
            double fraction = (date.getTime() - calStart.getTime().getTime())
                              / ( double ) DAY_MILLISECONDS;

            return fraction + ( double ) absoluteDay(calStart)
                   - CAL_1900_ABSOLUTE;
        }
    }

    

    public static Date getJavaDate(double date)
    {
        if (isValidExcelDate(date))
        {
            int               wholeDaysSince1900 = ( int ) Math.floor(date);
            GregorianCalendar calendar           = new GregorianCalendar(1900,
                                                       0, wholeDaysSince1900
                                                       - 1);
            int               millisecondsInDay  =
                ( int ) ((date - Math.floor(date))
                         * ( double ) DAY_MILLISECONDS + 0.5);

            calendar.set(GregorianCalendar.MILLISECOND, millisecondsInDay);
            return calendar.getTime();
        }
        else
        {
            return null;
        }
    }

    

    public static boolean isValidExcelDate(double value)
    {
        return (value > -Double.MIN_VALUE);
    }

    

    private static int absoluteDay(Calendar cal)
    {
        return cal.get(Calendar.DAY_OF_YEAR)
               + daysInPriorYears(cal.get(Calendar.YEAR));
    }

    

    private static int daysInPriorYears(int yr)
    {
        if (yr < 1601)
        {
            throw new IllegalArgumentException(
                ""'year' must be 1601 or greater"");
        }
        int y    = yr - 1601;
        int days = 365 * y      
                   + y / 4      
                   - y / 100    
                   + y / 400;   

        return days;
    }

    
    private static Calendar dayStart(final Calendar cal)
    {
        cal.get(Calendar
            .HOUR_OF_DAY);   
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        cal.get(Calendar
            .HOUR_OF_DAY);   
        return cal;
    }

    
}
"
poi,1.5,org.apache.poi.hssf.record.PrintHeadersRecord,11,2,0,5,21,43,2,3,9,0.85,117,0.5,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class PrintHeadersRecord
    extends Record
{
    public final static short sid = 0x2a;
    private short             field_1_print_headers;

    public PrintHeadersRecord()
    {
    }

    

    public PrintHeadersRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PrintHeadersRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PrintHeaders RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_print_headers = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setPrintHeaders(boolean p)
    {
        if (p == true)
        {
            field_1_print_headers = 1;
        }
        else
        {
            field_1_print_headers = 0;
        }
    }

    

    public boolean getPrintHeaders()
    {
        return (field_1_print_headers == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRINTHEADERS]
"");
        buffer.append(""    .printheaders   = "").append(getPrintHeaders())
            .append(""
"");
        buffer.append(""[/PRINTHEADERS]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, field_1_print_headers);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.eventmodel.HSSFRequest,4,1,0,6,16,0,3,3,3,0.0,97,1.0,0,0.0,0.5,0,0,23.0,3,1.75,0,"


package org.apache.poi.hssf.eventmodel;

import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordFactory;



public class HSSFRequest
{
    private HashMap records;

    

    public HSSFRequest()
    {
        records =
            new HashMap(50);   
    }

    

    public void addListener(HSSFListener lsnr, short sid)
    {
        List   list = null;
        Object obj  = records.get(new Short(sid));

        if (obj != null)
        {
            list = ( List ) obj;
        }
        else
        {
            list = new ArrayList(
                1);   
            list.add(lsnr);
            records.put(new Short(sid), list);
        }
    }

    

    public void addListenerForAllRecords(HSSFListener lsnr)
    {
        short[] rectypes = RecordFactory.getAllKnownRecordSIDs();

        for (int k = 0; k < rectypes.length; k++)
        {
            addListener(lsnr, rectypes[ k ]);
        }
    }

    

    protected void processRecord(Record rec)
    {
        Object obj = records.get(new Short(rec.getSid()));

        if (obj != null)
        {
            List listeners = ( List ) obj;

            for (int k = 0; k < listeners.size(); k++)
            {
                HSSFListener listener = ( HSSFListener ) listeners.get(k);

                listener.processRecord(rec);
            }
        }
    }
}
"
poi,1.5,org.apache.poi.hssf.record.DefaultDataLabelTextPropertiesRecord,11,2,0,4,22,43,0,4,9,1.0,120,0.2,0,0.578947368,0.522727273,1,6,9.454545455,2,0.8182,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class DefaultDataLabelTextPropertiesRecord
    extends Record
{
    public final static short      sid                             = 0x1024;
    private  short      field_1_categoryDataType;
    public final static short       CATEGORY_DATA_TYPE_SHOW_LABELS_CHARACTERISTIC = 0;
    public final static short       CATEGORY_DATA_TYPE_VALUE_AND_PERCENTAGE_CHARACTERISTIC = 1;
    public final static short       CATEGORY_DATA_TYPE_ALL_TEXT_CHARACTERISTIC = 2;


    public DefaultDataLabelTextPropertiesRecord()
    {

    }

    

    public DefaultDataLabelTextPropertiesRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DefaultDataLabelTextPropertiesRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a DefaultDataLabelTextProperties record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_categoryDataType        = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DefaultDataLabelTextProperties]
"");

        buffer.append(""    .categoryDataType     = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getCategoryDataType()))
            .append("" ("").append(getCategoryDataType()).append("" )
"");

        buffer.append(""[/DefaultDataLabelTextProperties]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_categoryDataType);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getCategoryDataType()
    {
        return field_1_categoryDataType;
    }

    
    public void setCategoryDataType(short field_1_categoryDataType)
    {
        this.field_1_categoryDataType = field_1_categoryDataType;
    }


}  




"
poi,1.5,org.apache.poi.hssf.record.CountryRecord,13,2,0,5,23,66,2,3,11,0.805555556,140,0.666666667,0,0.523809524,0.5,1,6,9.538461538,2,0.8462,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class CountryRecord
    extends Record
{
    public final static short sid = 0x8c;

    
    private short             field_1_default_country;
    private short             field_2_current_country;

    public CountryRecord()
    {
    }

    

    public CountryRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public CountryRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A Country RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_default_country = LittleEndian.getShort(data, 0 + offset);
        field_2_current_country = LittleEndian.getShort(data, 2 + offset);
    }

    

    public void setDefaultCountry(short country)
    {
        field_1_default_country = country;
    }

    

    public void setCurrentCountry(short country)
    {
        field_2_current_country = country;
    }

    

    public short getDefaultCountry()
    {
        return field_1_default_country;
    }

    

    public short getCurrentCountry()
    {
        return field_2_current_country;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[COUNTRY]
"");
        buffer.append(""    .defaultcountry  = "")
            .append(Integer.toHexString(getDefaultCountry())).append(""
"");
        buffer.append(""    .currentcountry  = "")
            .append(Integer.toHexString(getCurrentCountry())).append(""
"");
        buffer.append(""[/COUNTRY]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x04));   
        LittleEndian.putShort(data, 4 + offset, getDefaultCountry());
        LittleEndian.putShort(data, 6 + offset, getCurrentCountry());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 8;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.POIFSFileSystem,17,1,0,35,91,106,9,27,13,0.354166667,453,1.0,2,0.0,0.14479638,0,0,25.47058824,2,1.1176,2,"


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.property.PropertyTable;
import org.apache.poi.poifs.storage.BATBlock;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockAllocationTableWriter;
import org.apache.poi.poifs.storage.BlockList;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.HeaderBlockReader;
import org.apache.poi.poifs.storage.HeaderBlockWriter;
import org.apache.poi.poifs.storage.RawDataBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;
import org.apache.poi.poifs.storage.SmallBlockTableReader;
import org.apache.poi.poifs.storage.SmallBlockTableWriter;
import org.apache.poi.poifs.storage.SmallDocumentBlock;



public class POIFSFileSystem
    implements POIFSViewable
{
    private PropertyTable _property_table;
    private List          _documents;
    private DirectoryNode _root;

    

    public POIFSFileSystem()
    {
        _property_table = new PropertyTable();
        _documents      = new ArrayList();
        _root           = null;
    }

    

    public POIFSFileSystem(final InputStream stream)
        throws IOException
    {
        this();

        
        HeaderBlockReader header_block_reader = new HeaderBlockReader(stream);

        
        RawDataBlockList  data_blocks         = new RawDataBlockList(stream);

        
        
        new BlockAllocationTableReader(header_block_reader.getBATCount(),
                                       header_block_reader.getBATArray(),
                                       header_block_reader.getXBATCount(),
                                       header_block_reader.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block_reader.getPropertyStart(),
                              data_blocks);

        
        processProperties(SmallBlockTableReader
            .getSmallDocumentBlocks(data_blocks, properties
                .getRoot(), header_block_reader
                    .getSBATStart()), data_blocks, properties.getRoot()
                        .getChildren(), null);
    }

    

    public DocumentEntry createDocument(final InputStream stream,
                                        final String name)
        throws IOException
    {
        return getRoot().createDocument(name, stream);
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        return getRoot().createDocument(name, size, writer);
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        return getRoot().createDirectory(name);
    }

    

    public void writeFilesystem(final OutputStream stream)
        throws IOException
    {

        
        _property_table.preWrite();

        
        SmallBlockTableWriter      sbtw       =
            new SmallBlockTableWriter(_documents, _property_table.getRoot());

        
        BlockAllocationTableWriter bat        =
            new BlockAllocationTableWriter();

        
        
        List                       bm_objects = new ArrayList();

        bm_objects.addAll(_documents);
        bm_objects.add(_property_table);
        bm_objects.add(sbtw);
        bm_objects.add(sbtw.getSBAT());

        
        
        Iterator iter = bm_objects.iterator();

        while (iter.hasNext())
        {
            BATManaged bmo         = ( BATManaged ) iter.next();
            int        block_count = bmo.countBlocks();

            if (block_count != 0)
            {
                bmo.setStartBlock(bat.allocateSpace(block_count));
            }
            else
            {

                
                
                
            }
        }

        
        
        int               batStartBlock       = bat.createBlocks();

        
        HeaderBlockWriter header_block_writer = new HeaderBlockWriter();
        BATBlock[]        xbat_blocks         =
            header_block_writer.setBATBlocks(bat.countBlocks(),
                                             batStartBlock);

        
        header_block_writer.setPropertyStart(_property_table.getStartBlock());

        
        header_block_writer.setSBATStart(sbtw.getSBAT().getStartBlock());

        
        
        
        
        
        List writers = new ArrayList();

        writers.add(header_block_writer);
        writers.addAll(_documents);
        writers.add(_property_table);
        writers.add(sbtw);
        writers.add(sbtw.getSBAT());
        writers.add(bat);
        for (int j = 0; j < xbat_blocks.length; j++)
        {
            writers.add(xbat_blocks[ j ]);
        }

        
        iter = writers.iterator();
        while (iter.hasNext())
        {
            BlockWritable writer = ( BlockWritable ) iter.next();

            writer.writeBlocks(stream);
        }
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length != 2)
        {
            System.err.println(
                ""two arguments required: input filename and output filename"");
            System.exit(1);
        }
        FileInputStream  istream = new FileInputStream(args[ 0 ]);
        FileOutputStream ostream = new FileOutputStream(args[ 1 ]);

        new POIFSFileSystem(istream).writeFilesystem(ostream);
        istream.close();
        ostream.close();
    }

    

    public DirectoryEntry getRoot()
    {
        if (_root == null)
        {
            _root = new DirectoryNode(_property_table.getRoot(), this, null);
        }
        return _root;
    }

    

    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
        Entry document = getRoot().getEntry(documentName);

        if (!document.isDocumentEntry())
        {
            throw new IOException(""Entry '"" + documentName
                                  + ""' is not a DocumentEntry"");
        }
        return new DocumentInputStream(( DocumentEntry ) document);
    }

    

    void addDocument(final POIFSDocument document)
    {
        _documents.add(document);
        _property_table.addProperty(document.getDocumentProperty());
    }

    

    void addDirectory(final DirectoryProperty directory)
    {
        _property_table.addProperty(directory);
    }

    

    void remove(EntryNode entry)
    {
        _property_table.removeProperty(entry.getProperty());
        if (entry.isDocumentEntry())
        {
            _documents.remove((( DocumentNode ) entry).getDocument());
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator properties,
                                   final DirectoryNode dir)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property      property = ( Property ) properties.next();
            String        name     = property.getName();
            DirectoryNode parent   = (dir == null)
                                     ? (( DirectoryNode ) getRoot())
                                     : dir;

            if (property.isDirectory())
            {
                DirectoryNode new_dir =
                    ( DirectoryNode ) parent.createDirectory(name);

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(), new_dir);
            }
            else
            {
                int           startBlock = property.getStartBlock();
                int           size       = property.getSize();
                POIFSDocument document   = null;

                if (property.shouldUseSmallBlocks())
                {
                    document =
                        new POIFSDocument(name, small_blocks
                            .fetchBlocks(startBlock), size);
                }
                else
                {
                    document =
                        new POIFSDocument(name,
                                          big_blocks.fetchBlocks(startBlock),
                                          size);
                }
                parent.createDocument(document);
            }
        }
    }

    

    

    public Object [] getViewableArray()
    {
        if (preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableArray();
        }
        else
        {
            return new Object[ 0 ];
        }
    }

    

    public Iterator getViewableIterator()
    {
        if (!preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableIterator();
        }
        else
        {
            return Collections.EMPTY_LIST.iterator();
        }
    }

    

    public boolean preferArray()
    {
        return (( POIFSViewable ) getRoot()).preferArray();
    }

    

    public String getShortDescription()
    {
        return ""POIFS FileSystem"";
    }

    
}   

"
poi,1.5,org.apache.poi.poifs.filesystem.DirectoryNode,18,2,0,13,61,57,3,13,13,0.607843137,316,1.0,2,0.346153846,0.172222222,1,1,16.38888889,3,1.1667,1,"


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;



public class DirectoryNode
    extends EntryNode
    implements DirectoryEntry, POIFSViewable
{

    
    private Map               _entries;

    
    private POIFSFileSystem   _filesystem;

    
    private POIFSDocumentPath _path;

    

    DirectoryNode(final DirectoryProperty property,
                  final POIFSFileSystem filesystem,
                  final DirectoryNode parent)
    {
        super(property, parent);
        if (parent == null)
        {
            _path = new POIFSDocumentPath();
        }
        else
        {
            _path = new POIFSDocumentPath(parent._path, new String[]
            {
                property.getName()
            });
        }
        _filesystem = filesystem;
        _entries    = new HashMap();
        Iterator iter = property.getChildren();

        while (iter.hasNext())
        {
            Property child     = ( Property ) iter.next();
            Entry    childNode = null;

            if (child.isDirectory())
            {
                childNode = new DirectoryNode(( DirectoryProperty ) child,
                                              _filesystem, this);
            }
            else
            {
                childNode = new DocumentNode(( DocumentProperty ) child,
                                             this);
            }
            _entries.put(childNode.getName(), childNode);
        }
    }

    

    public POIFSDocumentPath getPath()
    {
        return _path;
    }

    

    DocumentEntry createDocument(final POIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _filesystem.addDocument(document);
        _entries.put(property.getName(), rval);
        return rval;
    }

    

    boolean changeName(final String oldName, final String newName)
    {
        boolean   rval  = false;
        EntryNode child = ( EntryNode ) _entries.get(oldName);

        if (child != null)
        {
            rval = (( DirectoryProperty ) getProperty())
                .changeName(child.getProperty(), newName);
            if (rval)
            {
                _entries.remove(oldName);
                _entries.put(child.getProperty().getName(), child);
            }
        }
        return rval;
    }

    

    boolean deleteEntry(final EntryNode entry)
    {
        boolean rval =
            (( DirectoryProperty ) getProperty())
                .deleteChild(entry.getProperty());

        if (rval)
        {
            _entries.remove(entry.getName());
            _filesystem.remove(entry);
        }
        return rval;
    }

    

    

    public Iterator getEntries()
    {
        return _entries.values().iterator();
    }

    

    public boolean isEmpty()
    {
        return _entries.isEmpty();
    }

    

    public int getEntryCount()
    {
        return _entries.size();
    }

    

    public Entry getEntry(final String name)
        throws FileNotFoundException
    {
        Entry rval = null;

        if (name != null)
        {
            rval = ( Entry ) _entries.get(name);
        }
        if (rval == null)
        {

            
            throw new FileNotFoundException(""no such entry: """" + name
                                            + """""");
        }
        return rval;
    }

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException
    {
        return createDocument(new POIFSDocument(name, stream));
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        return createDocument(new POIFSDocument(name, size, _path, writer));
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        DirectoryProperty property = new DirectoryProperty(name);
        DirectoryNode     rval     = new DirectoryNode(property, _filesystem,
                                         this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _filesystem.addDirectory(property);
        _entries.put(name, rval);
        return rval;
    }

    
    

    

    public boolean isDirectoryEntry()
    {
        return true;
    }

    
    

    

    protected boolean isDeleteOK()
    {

        
        return isEmpty();
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    

    public Iterator getViewableIterator()
    {
        List components = new ArrayList();

        components.add(getProperty());
        SortedMap sortedEntries = new TreeMap(_entries);
        Iterator  iter          = sortedEntries.values().iterator();

        while (iter.hasNext())
        {
            components.add(iter.next());
        }
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.MultiplyPtg,8,2,0,4,13,28,3,2,8,1.142857143,56,0.0,0,0.538461538,0.40625,1,2,5.75,1,0.75,4,"



package org.apache.poi.hssf.record.formula;



public class MultiplyPtg
    extends Ptg
    implements OperationPtg
{
    public final static int  SIZE = 1;
    public final static byte sid  = 0x05;

    

    public MultiplyPtg()
    {
    }

    public MultiplyPtg(byte [] data, int offset)
    {

        
    }

    public void writeBytes(byte [] array, int offset)
    {
        array[ offset + 0 ] = sid;
    }

    public int getSize()
    {
        return SIZE;
    }

    public int getType()
    {
        return TYPE_BINARY;
    }

    public int getNumberOfOperands()
    {
        return 2;
    }

    public String toFormulaString()
    {
        return ""*"";
    }

    public String toFormulaString(Ptg [] operands)
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(operands[ 0 ].toFormulaString());
        buffer.append(""*"");
        buffer.append(operands[ 1 ].toFormulaString());
        return buffer.toString();
    }
}
"
poi,1.5,org.apache.poi.hssf.record.formula.NamePtg,5,2,0,2,7,10,1,2,5,1.1,41,0.8,0,0.7,0.6,1,2,6.2,1,0.6,6,"



package org.apache.poi.hssf.record.formula;

import org.apache.poi.util.LittleEndian;



public class NamePtg
    extends Ptg
{
    public final static short sid  = 0x23;
    private final static int  SIZE = 7;
    private short             field_1_ixti;   
    private short             field_2_label_index;
    private short             field_3_zero;   

    

    public NamePtg()
    {
    }

    

    public NamePtg(byte [] data, int offset)
    {
        offset++;
        field_1_ixti        = LittleEndian.getShort(data, offset);
        field_2_label_index = LittleEndian.getShort(data, offset + 2);
        field_3_zero        = LittleEndian.getShort(data, offset + 4);
    }

    public void writeBytes(byte [] array, int offset)
    {
    }

    public int getSize()
    {
        return SIZE;
    }

    public String toFormulaString()
    {
        return ""NO IDEA - NAME"";
    }
}
"
poi,1.5,org.apache.poi.hssf.record.DSFRecord,11,2,0,5,21,49,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class DSFRecord
    extends Record
{
    public final static short sid = 0x161;
    private short             field_1_dsf;

    public DSFRecord()
    {
    }

    

    public DSFRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DSFRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A DSF RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_dsf = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setDsf(short dsfflag)
    {
        field_1_dsf = dsfflag;
    }

    

    public short getDsf()
    {
        return field_1_dsf;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DSF]
"");
        buffer.append(""    .isDSF           = "")
            .append(Integer.toHexString(getDsf())).append(""
"");
        buffer.append(""[/DSF]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getDsf());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.PasswordRev4Record,11,2,0,5,21,49,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class PasswordRev4Record
    extends Record
{
    public final static short sid = 0x1BC;
    private short             field_1_password;

    public PasswordRev4Record()
    {
    }

    

    public PasswordRev4Record(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public PasswordRev4Record(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A PROT4REVPASSWORD RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_password = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setPassword(short pw)
    {
        field_1_password = pw;
    }

    

    public short getPassword()
    {
        return field_1_password;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PROT4REVPASSWORD]
"");
        buffer.append(""    .password       = "")
            .append(Integer.toHexString(getPassword())).append(""
"");
        buffer.append(""[/PROT4REVPASSWORD]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 0x02));   
        LittleEndian.putShort(data, 4 + offset, getPassword());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.ExtSSTRecord,14,2,0,6,34,65,2,4,12,0.794871795,234,0.666666667,0,0.5,0.4,1,6,15.5,2,1.0714,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;

import java.util.ArrayList;



public class ExtSSTRecord
    extends Record
{
    public final static short sid = 0xff;
    private short             field_1_strings_per_bucket;
    private ArrayList         field_2_sst_info;

    public ExtSSTRecord()
    {
        field_2_sst_info = new ArrayList();
    }

    

    public ExtSSTRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ExtSSTRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT An EXTSST RECORD"");
        }
    }

    
    protected void fillFields(byte [] data, short size, int offset)
    {
        field_2_sst_info           = new ArrayList();
        field_1_strings_per_bucket = LittleEndian.getShort(data, 0 + offset);
        for (int k = 2; k < ((data.length - offset) - size); k += 8)
        {
            byte[] tempdata = new byte[ 8 + offset ];

            System.arraycopy(data, k, tempdata, 0, 8);
            ExtSSTInfoSubRecord rec = new ExtSSTInfoSubRecord(( short ) 0,
                                          ( short ) 8, tempdata);

            field_2_sst_info.add(rec);
        }
    }

    public void setNumStringsPerBucket(short numStrings)
    {
        field_1_strings_per_bucket = numStrings;
    }

    public void addInfoRecord(ExtSSTInfoSubRecord rec)
    {
        field_2_sst_info.add(rec);
    }

    public short getNumStringsPerBucket()
    {
        return field_1_strings_per_bucket;
    }

    public int getNumInfoRecords()
    {
        return field_2_sst_info.size();
    }

    public ExtSSTInfoSubRecord getInfoRecordAt(int elem)
    {
        return ( ExtSSTInfoSubRecord ) field_2_sst_info.get(elem);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EXTSST]
"");
        buffer.append(""    .dsst           = "")
            .append(Integer.toHexString(getNumStringsPerBucket()))
            .append(""
"");
        buffer.append(""    .numInfoRecords = "").append(getNumInfoRecords())
            .append(""
"");
        for (int k = 0; k < getNumInfoRecords(); k++)
        {
            buffer.append(""    .inforecord     = "").append(k).append(""
"");
            buffer.append(""    .streampos      = "")
                .append(Integer
                .toHexString(getInfoRecordAt(k).getStreamPos())).append(""
"");
            buffer.append(""    .sstoffset      = "")
                .append(Integer
                .toHexString(getInfoRecordAt(k).getBucketSSTOffset()))
                    .append(""
"");
        }
        buffer.append(""[/EXTSST]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);


        LittleEndian.putShort(data, 2 + offset, ( short ) (2 + (0x3fa - 2)));
        int pos = 4;

        for (int k = 0; k < getNumInfoRecords(); k++)
        {
            System.arraycopy(getInfoRecordAt(k).serialize(), 0, data,
                             pos + offset, 8);
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6 + 0x3fa - 2;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.VCenterRecord,11,2,0,6,21,43,3,3,9,0.85,117,0.5,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class VCenterRecord
    extends Record
{
    public final static short sid = 0x84;
    private short             field_1_vcenter;

    public VCenterRecord()
    {
    }

    

    public VCenterRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public VCenterRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A VCenter RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_vcenter = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setVCenter(boolean hc)
    {
        if (hc == true)
        {
            field_1_vcenter = 1;
        }
        else
        {
            field_1_vcenter = 0;
        }
    }

    

    public boolean getVCenter()
    {
        return (field_1_vcenter == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[VCENTER]
"");
        buffer.append(""    .vcenter        = "").append(getVCenter())
            .append(""
"");
        buffer.append(""[/VCENTER]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, ( short ) field_1_vcenter);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.DocumentBlock,10,2,0,4,19,5,2,2,8,0.740740741,223,1.0,0,0.3,0.228571429,1,2,21.0,3,1.2,1,"


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import java.util.Arrays;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;



public class DocumentBlock
    extends BigBlock
{
    private static final byte _default_value = ( byte ) 0xFF;
    private byte[]            _data;
    private int               _bytes_read;

    

    public DocumentBlock(final RawDataBlock block)
        throws IOException
    {
        _data       = block.getData();
        _bytes_read = _data.length;
    }

    

    public DocumentBlock(final InputStream stream)
        throws IOException
    {
        this();
        int count = stream.read(_data);

        _bytes_read = (count == -1) ? 0
                                    : count;
    }

    

    private DocumentBlock()
    {
        _data = new byte[ POIFSConstants.BIG_BLOCK_SIZE ];
        Arrays.fill(_data, _default_value);
    }

    

    public int size()
    {
        return _bytes_read;
    }

    

    public boolean partiallyRead()
    {
        return _bytes_read != POIFSConstants.BIG_BLOCK_SIZE;
    }

    

    public static byte getFillByte()
    {
        return _default_value;
    }

    

    public static DocumentBlock [] convert(final byte [] array,
                                           final int size)
    {
        DocumentBlock[] rval   =
            new DocumentBlock[ (size + POIFSConstants.BIG_BLOCK_SIZE - 1) / POIFSConstants.BIG_BLOCK_SIZE ];
        int             offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new DocumentBlock();
            if (offset < array.length)
            {
                int length = Math.min(POIFSConstants.BIG_BLOCK_SIZE,
                                      array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != POIFSConstants.BIG_BLOCK_SIZE)
                {
                    Arrays.fill(rval[ k ]._data, length,
                                POIFSConstants.BIG_BLOCK_SIZE,
                                _default_value);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_value);
            }
            offset += POIFSConstants.BIG_BLOCK_SIZE;
        }
        return rval;
    }

    

    public static void read(final DocumentBlock [] blocks,
                            final byte [] buffer, final int offset)
    {
        int firstBlockIndex  = offset / POIFSConstants.BIG_BLOCK_SIZE;
        int firstBlockOffset = offset % POIFSConstants.BIG_BLOCK_SIZE;
        int lastBlockIndex   = (offset + buffer.length - 1)
                               / POIFSConstants.BIG_BLOCK_SIZE;

        if (firstBlockIndex == lastBlockIndex)
        {
            System.arraycopy(blocks[ firstBlockIndex ]._data,
                             firstBlockOffset, buffer, 0, buffer.length);
        }
        else
        {
            int buffer_offset = 0;

            System.arraycopy(blocks[ firstBlockIndex ]._data,
                             firstBlockOffset, buffer, buffer_offset,
                             POIFSConstants.BIG_BLOCK_SIZE
                             - firstBlockOffset);
            buffer_offset += POIFSConstants.BIG_BLOCK_SIZE - firstBlockOffset;
            for (int j = firstBlockIndex + 1; j < lastBlockIndex; j++)
            {
                System.arraycopy(blocks[ j ]._data, 0, buffer, buffer_offset,
                                 POIFSConstants.BIG_BLOCK_SIZE);
                buffer_offset += POIFSConstants.BIG_BLOCK_SIZE;
            }
            System.arraycopy(blocks[ lastBlockIndex ]._data, 0, buffer,
                             buffer_offset, buffer.length - buffer_offset);
        }
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        doWriteData(stream, _data);
    }

    
}   

"
poi,1.5,org.apache.poi.poifs.eventfilesystem.POIFSReader,7,1,0,17,51,3,0,17,6,0.083333333,282,1.0,1,0.0,0.303571429,0,0,39.0,6,1.8571,0,"


package org.apache.poi.poifs.eventfilesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.POIFSDocument;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.property.PropertyTable;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockList;
import org.apache.poi.poifs.storage.HeaderBlockReader;
import org.apache.poi.poifs.storage.RawDataBlockList;
import org.apache.poi.poifs.storage.SmallBlockTableReader;



public class POIFSReader
{
    private POIFSReaderRegistry registry;
    private boolean             registryClosed;

    

    public POIFSReader()
    {
        registry       = new POIFSReaderRegistry();
        registryClosed = false;
    }

    

    public void read(final InputStream stream)
        throws IOException
    {
        registryClosed = true;

        
        HeaderBlockReader header_block_reader = new HeaderBlockReader(stream);

        
        RawDataBlockList  data_blocks         = new RawDataBlockList(stream);

        
        
        new BlockAllocationTableReader(header_block_reader.getBATCount(),
                                       header_block_reader.getBATArray(),
                                       header_block_reader.getXBATCount(),
                                       header_block_reader.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block_reader.getPropertyStart(),
                              data_blocks);

        
        processProperties(SmallBlockTableReader
            .getSmallDocumentBlocks(data_blocks, properties
                .getRoot(), header_block_reader
                    .getSBATStart()), data_blocks, properties.getRoot()
                        .getChildren(), new POIFSDocumentPath());
    }

    

    public void registerListener(final POIFSReaderListener listener)
    {
        if (listener == null)
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final String name)
    {
        registerListener(listener, null, name);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final POIFSDocumentPath path,
                                 final String name)
    {
        if ((listener == null) || (name == null) || (name.length() == 0))
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener,
                                  (path == null) ? new POIFSDocumentPath()
                                                 : path, name);
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length == 0)
        {
            System.err
                .println(""at least one argument required: input filename(s)"");
            System.exit(1);
        }

        
        for (int j = 0; j < args.length; j++)
        {
            POIFSReader         reader   = new POIFSReader();
            POIFSReaderListener listener = new SampleListener();

            reader.registerListener(listener);
            System.out.println(""reading "" + args[ j ]);
            FileInputStream istream = new FileInputStream(args[ j ]);

            reader.read(istream);
            istream.close();
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator properties,
                                   final POIFSDocumentPath path)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property property = ( Property ) properties.next();
            String   name     = property.getName();

            if (property.isDirectory())
            {
                POIFSDocumentPath new_path = new POIFSDocumentPath(path,
                                                 new String[]
                {
                    name
                });

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(), new_path);
            }
            else
            {
                int      startBlock = property.getStartBlock();
                Iterator listeners  = registry.getListeners(path, name);

                if (listeners.hasNext())
                {
                    int           size     = property.getSize();
                    POIFSDocument document = null;

                    if (property.shouldUseSmallBlocks())
                    {
                        document =
                            new POIFSDocument(name, small_blocks
                                .fetchBlocks(startBlock), size);
                    }
                    else
                    {
                        document =
                            new POIFSDocument(name, big_blocks
                                .fetchBlocks(startBlock), size);
                    }
                    while (listeners.hasNext())
                    {
                        POIFSReaderListener listener =
                            ( POIFSReaderListener ) listeners.next();

                        listener.processPOIFSReaderEvent(
                            new POIFSReaderEvent(
                                new DocumentInputStream(document), path,
                                name));
                    }
                }
                else
                {

                    
                    if (property.shouldUseSmallBlocks())
                    {
                        small_blocks.fetchBlocks(startBlock);
                    }
                    else
                    {
                        big_blocks.fetchBlocks(startBlock);
                    }
                }
            }
        }
    }

    private static class SampleListener
        implements POIFSReaderListener
    {

        

        SampleListener()
        {
        }

        

        public void processPOIFSReaderEvent(final POIFSReaderEvent event)
        {
            DocumentInputStream istream = event.getStream();
            POIFSDocumentPath   path    = event.getPath();
            String              name    = event.getName();

            try
            {
                byte[] data = new byte[ istream.available() ];

                istream.read(data);
                int pathLength = path.length();

                for (int k = 0; k < pathLength; k++)
                {
                    System.out.print(""/"" + path.getComponent(k));
                }
                System.out.println(""/"" + name + "": "" + data.length
                                   + "" bytes read"");
            }
            catch (IOException ignored)
            {
            }
        }
    }   
}       

"
poi,1.5,org.apache.poi.hssf.util.RKUtil,2,1,0,2,4,1,2,0,1,2.0,39,0.0,0,0.0,0.5,0,0,18.5,3,1.5,0,"

package org.apache.poi.hssf.util;


public class RKUtil
{
    private RKUtil()
    {
    }

    

    public static double decodeNumber(int number)
    {
        long raw_number = number;

        
        
        raw_number = raw_number >> 2;
        double rvalue = 0;

        if ((number & 0x02) == 0x02)
        {
            
            
            rvalue = ( double ) (raw_number);
        }
        else
        {

            
            
            
            rvalue = Double.longBitsToDouble(raw_number << 34);
        }
        if ((number & 0x01) == 0x01)
        {

            
            
            
            rvalue /= 100;
        }

        return rvalue;
    }

}
"
poi,1.5,org.apache.poi.hssf.record.FontRecord,38,2,0,9,56,511,4,5,35,0.938063063,603,0.625,4,0.244444444,0.239382239,1,6,14.23684211,3,0.9737,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.BitField;



public class FontRecord
    extends Record
{
    public final static short     sid                 =
        0x31;                                                 
    public final static short     SS_NONE             = 0;
    public final static short     SS_SUPER            = 1;
    public final static short     SS_SUB              = 2;
    public final static byte      U_NONE              = 0;
    public final static byte      U_SINGLE            = 1;
    public final static byte      U_DOUBLE            = 2;
    public final static byte      U_SINGLE_ACCOUNTING = 0x21;
    public final static byte      U_DOUBLE_ACCOUNTING = 0x22;
    private short                 field_1_font_height;        
    private short                 field_2_attributes;

    
    static final private BitField italic     =
        new BitField(0x02);                                   

    
    static final private BitField strikeout  =
        new BitField(0x08);                                   
    static final private BitField macoutline = new BitField(
        0x10);                                                
    static final private BitField macshadow  = new BitField(
        0x20);                                                

    
    
    private short                 field_3_color_palette_index;
    private short                 field_4_bold_weight;
    private short                 field_5_super_sub_script;   
    private byte                  field_6_underline;          
    private byte                  field_7_family;             
    private byte                  field_8_charset;            
    private byte                  field_9_zero = 0;           
    private byte                  field_10_font_name_len;     
    private String                field_11_font_name;         

    public FontRecord()
    {
    }

    

    public FontRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public FontRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A FONT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_font_height         = LittleEndian.getShort(data, 0 + offset);
        field_2_attributes          = LittleEndian.getShort(data, 2 + offset);
        field_3_color_palette_index = LittleEndian.getShort(data, 4 + offset);
        field_4_bold_weight         = LittleEndian.getShort(data, 6 + offset);
        field_5_super_sub_script    = LittleEndian.getShort(data, 8 + offset);
        field_6_underline           = data[ 10 + offset ];
        field_7_family              = data[ 11 + offset ];
        field_8_charset             = data[ 12 + offset ];
        field_9_zero                = data[ 13 + offset ];
        field_10_font_name_len      = data[ 14 + offset ];
        if (field_10_font_name_len > 0)
        {
            if (data[ 15 ] == 0)
            {   
                field_11_font_name = new String(data, 16,
                                                LittleEndian.ubyteToInt(field_10_font_name_len));
            }
            else
            {   
                field_11_font_name = StringUtil.getFromUnicode(data, 15,
                        field_10_font_name_len);
            }
        }
    }

    

    public void setFontHeight(short height)
    {
        field_1_font_height = height;
    }

    

    public void setAttributes(short attributes)
    {
        field_2_attributes = attributes;
    }

    

    

    public void setItalic(boolean italics)
    {
        field_2_attributes = italic.setShortBoolean(field_2_attributes, italics);
    }

    

    public void setStrikeout(boolean strike)
    {
        field_2_attributes = strikeout.setShortBoolean(field_2_attributes, strike);
    }

    

    public void setMacoutline(boolean mac)
    {
        field_2_attributes = macoutline.setShortBoolean(field_2_attributes, mac);
    }

    

    public void setMacshadow(boolean mac)
    {
        field_2_attributes = macshadow.setShortBoolean(field_2_attributes, mac);
    }

    

    public void setColorPaletteIndex(short cpi)
    {
        field_3_color_palette_index = cpi;
    }

    

    public void setBoldWeight(short bw)
    {
        field_4_bold_weight = bw;
    }

    

    public void setSuperSubScript(short sss)
    {
        field_5_super_sub_script = sss;
    }

    

    public void setUnderline(byte u)
    {
        field_6_underline = u;
    }

    

    public void setFamily(byte f)
    {
        field_7_family = f;
    }

    

    public void setCharset(byte charset)
    {
        field_8_charset = charset;
    }

    

    public void setFontNameLength(byte len)
    {
        field_10_font_name_len = len;
    }

    

    public void setFontName(String fn)
    {
        field_11_font_name = fn;
    }

    

    public short getFontHeight()
    {
        return field_1_font_height;
    }

    

    public short getAttributes()
    {
        return field_2_attributes;
    }

    

    public boolean isItalic()
    {
        return italic.isSet(field_2_attributes);
    }

    

    public boolean isStruckout()
    {
        return strikeout.isSet(field_2_attributes);
    }

    

    public boolean isMacoutlined()
    {
        return macoutline.isSet(field_2_attributes);
    }

    

    public boolean isMacshadowed()
    {
        return macshadow.isSet(field_2_attributes);
    }

    

    public short getColorPaletteIndex()
    {
        return field_3_color_palette_index;
    }

    

    public short getBoldWeight()
    {
        return field_4_bold_weight;
    }

    

    public short getSuperSubScript()
    {
        return field_5_super_sub_script;
    }

    

    public byte getUnderline()
    {
        return field_6_underline;
    }

    

    public byte getFamily()
    {
        return field_7_family;
    }

    

    public byte getCharset()
    {
        return field_8_charset;
    }

    

    public byte getFontNameLength()
    {
        return field_10_font_name_len;
    }

    

    public String getFontName()
    {
        return field_11_font_name;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FONT]
"");
        buffer.append(""    .fontheight      = "")
            .append(Integer.toHexString(getFontHeight())).append(""
"");
        buffer.append(""    .attributes      = "")
            .append(Integer.toHexString(getAttributes())).append(""
"");
        buffer.append(""         .italic     = "").append(isItalic())
            .append(""
"");
        buffer.append(""         .strikout   = "").append(isStruckout())
            .append(""
"");
        buffer.append(""         .macoutlined= "").append(isMacoutlined())
            .append(""
"");
        buffer.append(""         .macshadowed= "").append(isMacshadowed())
            .append(""
"");
        buffer.append(""    .colorpalette    = "")
            .append(Integer.toHexString(getColorPaletteIndex())).append(""
"");
        buffer.append(""    .boldweight      = "")
            .append(Integer.toHexString(getBoldWeight())).append(""
"");
        buffer.append(""    .supersubscript  = "")
            .append(Integer.toHexString(getSuperSubScript())).append(""
"");
        buffer.append(""    .underline       = "")
            .append(Integer.toHexString(getUnderline())).append(""
"");
        buffer.append(""    .family          = "")
            .append(Integer.toHexString(getFamily())).append(""
"");
        buffer.append(""    .charset         = "")
            .append(Integer.toHexString(getCharset())).append(""
"");
        buffer.append(""    .namelength      = "")
            .append(Integer.toHexString(getFontNameLength())).append(""
"");
        buffer.append(""    .fontname        = "").append(getFontName())
            .append(""
"");
        buffer.append(""[/FONT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        int realflen = getFontNameLength() * 2;

        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(
            data, 2 + offset,
            ( short ) (15 + realflen
                       + 1));   

        
        LittleEndian.putShort(data, 4 + offset, getFontHeight());
        LittleEndian.putShort(data, 6 + offset, getAttributes());
        LittleEndian.putShort(data, 8 + offset, getColorPaletteIndex());
        LittleEndian.putShort(data, 10 + offset, getBoldWeight());
        LittleEndian.putShort(data, 12 + offset, getSuperSubScript());
        data[ 14 + offset ] = getUnderline();
        data[ 15 + offset ] = getFamily();
        data[ 16 + offset ] = getCharset();
        data[ 17 + offset ] = (( byte ) 0);
        data[ 18 + offset ] = getFontNameLength();
        data[ 19 + offset ] = ( byte ) 1;
        StringUtil.putUncompressedUnicode(getFontName(), data, 20 + offset);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return (getFontNameLength() * 2) + 20;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.util.BitField,18,1,0,25,19,107,25,0,18,0.382352941,170,1.0,0,0.0,0.433333333,0,0,8.333333333,2,1.2222,0,"


package org.apache.poi.util;



public class BitField
{
    private final int _mask;
    private final int _shift_count;

    

    public BitField(final int mask)
    {
        _mask = mask;
        int count       = 0;
        int bit_pattern = mask;

        if (bit_pattern != 0)
        {
            while ((bit_pattern & 1) == 0)
            {
                count++;
                bit_pattern >>= 1;
            }
        }
        _shift_count = count;
    }

    

    public int getValue(final int holder)
    {
        return getRawValue(holder) >> _shift_count;
    }

    

    public short getShortValue(final short holder)
    {
        return ( short ) getValue(holder);
    }

    

    public int getRawValue(final int holder)
    {
        return (holder & _mask);
    }

    

    public short getShortRawValue(final short holder)
    {
        return ( short ) getRawValue(holder);
    }

    

    public boolean isSet(final int holder)
    {
        return (holder & _mask) != 0;
    }

    

    public boolean isAllSet(final int holder)
    {
        return (holder & _mask) == _mask;
    }

    

    public int setValue(final int holder, final int value)
    {
        return (holder & ~_mask) | ((value << _shift_count) & _mask);
    }

    

    public short setShortValue(final short holder, final short value)
    {
        return ( short ) setValue(holder, value);
    }

    

    public int clear(final int holder)
    {
        return holder & ~_mask;
    }

    

    public short clearShort(final short holder)
    {
        return ( short ) clear(holder);
    }

    

    public byte clearByte(final byte holder)
    {
        return ( byte ) clear(holder);
    }

    

    public int set(final int holder)
    {
        return holder | _mask;
    }

    

    public short setShort(final short holder)
    {
        return ( short ) set(holder);
    }

    

    public byte setByte(final byte holder)
    {
        return ( byte ) set(holder);
    }

    

    public int setBoolean(final int holder, final boolean flag)
    {
        return flag ? set(holder)
                    : clear(holder);
    }

    

    public short setShortBoolean(final short holder, final boolean flag)
    {
        return flag ? setShort(holder)
                    : clearShort(holder);
    }

    

    public byte setByteBoolean(final byte holder, final boolean flag)
    {
        return flag ? setByte(holder)
                    : clearByte(holder);
    }
}   

"
poi,1.5,org.apache.poi.poifs.storage.HeaderBlockConstants,0,1,0,2,0,0,2,0,0,2.0,9,0.0,0,0.0,0.0,0,0,0.0,0,0.0,1,"


package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LongField;
import org.apache.poi.util.ShortField;



public interface HeaderBlockConstants
{
    public static final long _signature             = 0xE11AB1A1E011CFD0L;
    public static final int  _bat_array_offset      = 0x4c;
    public static final int  _max_bats_in_header    =
        (POIFSConstants.BIG_BLOCK_SIZE - _bat_array_offset)
        / LittleEndianConsts.INT_SIZE;

    
    public static final int  _signature_offset      = 0;
    public static final int  _bat_count_offset      = 0x2C;
    public static final int  _property_start_offset = 0x30;
    public static final int  _sbat_start_offset     = 0x3C;
    public static final int  _xbat_start_offset     = 0x44;
    public static final int  _xbat_count_offset     = 0x48;
}   

"
poi,1.5,org.apache.poi.hssf.record.DBCellRecord,15,2,0,6,31,79,3,3,13,0.785714286,251,0.666666667,0,0.47826087,0.483333333,1,6,15.53333333,3,1.2,2,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;

import java.util.ArrayList;



public class DBCellRecord
    extends Record
{
    public final static short sid = 0xd7;
    private int               field_1_row_offset;
    private short[]           field_2_cell_offsets;

    public DBCellRecord()
    {
    }

    

    public DBCellRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DBCellRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A valid DBCell RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_row_offset   = LittleEndian.getShort(data, 0 + offset);
        field_2_cell_offsets = new short[ (size - 4) / 2 ];
        int element = 0;

        for (int k = 4; k < data.length; k += 2)
        {
            field_2_cell_offsets[ element++ ] = LittleEndian.getShort(data,
                    k + offset);
        }
    }

    

    public void setRowOffset(int offset)
    {
        field_1_row_offset = offset;
    }

    
    public void addCellOffset(short offset)
    {
        if (field_2_cell_offsets == null)
        {
            field_2_cell_offsets = new short[ 1 ];
        }
        else
        {
            short[] temp = new short[ field_2_cell_offsets.length + 1 ];

            System.arraycopy(field_2_cell_offsets, 0, temp, 0,
                             field_2_cell_offsets.length);
            field_2_cell_offsets = temp;
        }
        field_2_cell_offsets[ field_2_cell_offsets.length - 1 ] = offset;
    }

    

    public int getRowOffset()
    {
        return field_1_row_offset;
    }

    

    public short getCellOffsetAt(int index)
    {
        return field_2_cell_offsets[ index ];
    }

    

    public int getNumCellOffsets()
    {
        return field_2_cell_offsets.length;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DBCELL]
"");
        buffer.append(""    .rowoffset       = "")
            .append(Integer.toHexString(getRowOffset())).append(""
"");
        for (int k = 0; k < getNumCellOffsets(); k++)
        {
            buffer.append(""    .cell_"" + k + ""          = "")
                .append(Integer.toHexString(getCellOffsetAt(k))).append(""
"");
        }
        buffer.append(""[/DBCELL]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        if (field_2_cell_offsets == null)
        {
            field_2_cell_offsets = new short[ 0 ];
        }
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) (4 + (getNumCellOffsets() * 2))));
        LittleEndian.putInt(data, 4 + offset, getRowOffset());
        for (int k = 0; k < getNumCellOffsets(); k++)
        {
            LittleEndian.putShort(data, 8 + k + offset, getCellOffsetAt(k));
        }
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 8 + (getNumCellOffsets() * 2);
    }

    public short getSid()
    {
        return this.sid;
    }

    public boolean isInValueSection()
    {
        return true;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.DatRecord,19,2,0,6,35,0,1,5,17,0.712962963,297,0.833333333,4,0.407407407,0.368421053,1,6,14.31578947,2,0.8947,1,"



package org.apache.poi.hssf.record;



import org.apache.poi.util.BitField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;
import org.apache.poi.util.HexDump;


public class DatRecord
    extends Record
{
    public final static short      sid                             = 0x1063;
    private  short      field_1_options;
    private BitField   horizontalBorder                           = new BitField(0x1);
    private BitField   verticalBorder                             = new BitField(0x2);
    private BitField   border                                     = new BitField(0x4);
    private BitField   showSeriesKey                              = new BitField(0x8);


    public DatRecord()
    {

    }

    

    public DatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DatRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    
    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""Not a Dat record"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_options                 = LittleEndian.getShort(data, 0x0 + offset);

    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[Dat]
"");

        buffer.append(""    .options              = "")
            .append(""0x"")
            .append(HexDump.toHex((short)getOptions()))
            .append("" ("").append(getOptions()).append("" )
"");
        buffer.append(""         .horizontalBorder         = "").append(isHorizontalBorder    ()).append('
');
        buffer.append(""         .verticalBorder           = "").append(isVerticalBorder      ()).append('
');
        buffer.append(""         .border                   = "").append(isBorder              ()).append('
');
        buffer.append(""         .showSeriesKey            = "").append(isShowSeriesKey       ()).append('
');

        buffer.append(""[/Dat]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        LittleEndian.putShort(data, 4 + offset, field_1_options);

        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 4 + 2;
    }

    public short getSid()
    {
        return this.sid;
    }


    
    public short getOptions()
    {
        return field_1_options;
    }

    
    public void setOptions(short field_1_options)
    {
        this.field_1_options = field_1_options;
    }

    
    public void setHorizontalBorder(boolean value)
    {
        field_1_options = horizontalBorder.setShortBoolean(field_1_options, value);
    }

    
    public boolean isHorizontalBorder()
    {
        return horizontalBorder.isSet(field_1_options);
    }

    
    public void setVerticalBorder(boolean value)
    {
        field_1_options = verticalBorder.setShortBoolean(field_1_options, value);
    }

    
    public boolean isVerticalBorder()
    {
        return verticalBorder.isSet(field_1_options);
    }

    
    public void setBorder(boolean value)
    {
        field_1_options = border.setShortBoolean(field_1_options, value);
    }

    
    public boolean isBorder()
    {
        return border.isSet(field_1_options);
    }

    
    public void setShowSeriesKey(boolean value)
    {
        field_1_options = showSeriesKey.setShortBoolean(field_1_options, value);
    }

    
    public boolean isShowSeriesKey()
    {
        return showSeriesKey.isSet(field_1_options);
    }


}  




"
poi,1.5,org.apache.poi.hssf.dev.FormulaViewer,6,1,0,7,34,13,0,7,6,0.6,233,1.0,0,0.0,0.375,0,0,37.66666667,4,1.6667,5,"



package org.apache.poi.hssf.dev;

import java.io.InputStream;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;


import java.util.List;

import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.HexDump;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.record.formula.*;
import org.apache.poi.hssf.model.*;
import org.apache.poi.hssf.usermodel.*;



public class FormulaViewer
{
    private String file;

    

    public FormulaViewer()
    {
    }

    

    public void run()
        throws Exception
    {
        POIFSFileSystem fs      =
            new POIFSFileSystem(new FileInputStream(file));
        List            records =
            RecordFactory
                .createRecords(fs.createDocumentInputStream(""Workbook""));

        for (int k = 0; k < records.size(); k++)
        {
            Record record = ( Record ) records.get(k);

            if (record.getSid() == FormulaRecord.sid)
            {
                parseFormulaRecord(( FormulaRecord ) record);
            }
        }
    }

    

    public void parseFormulaRecord(FormulaRecord record)
    {
        System.out.println(""In ParseFormula Record"");
        System.out.println(""row   = "" + record.getRow());
        System.out.println(""col   = "" + record.getColumn());
        System.out.println(""value = "" + record.getValue());
        System.out.println(""xf    = "" + record.getXFIndex());
        System.out.println(""number of ptgs = ""
                           + record.getNumberOfExpressionTokens());
        System.out.println(""options = "" + record.getOptions());
        System.out.println(composeForumla(record));
    }

    public String composeForumla(FormulaRecord record)
    {
        StringBuffer formula = new StringBuffer(""="");
        int          numptgs = record.getNumberOfExpressionTokens();
        List         ptgs    = record.getParsedExpression();

        for (int ptgnum = numptgs - 1; ptgnum > (-1); ptgnum--)
        {
            Ptg          ptg      = ( Ptg ) ptgs.get(ptgnum);
            OperationPtg optg     = ( OperationPtg ) ptg;
            int          numops   = optg.getNumberOfOperands();
            Ptg[]        ops      = new Ptg[ numops ];
            int          opoffset = 1;

            for (int opnum = ops.length - 1; opnum > -1; opnum--)
            {
                ops[ opnum ] = ( Ptg ) ptgs.get(ptgnum - opoffset);
                opoffset++;
            }
            formula.append(optg.toFormulaString(ops));
            ptgnum -= ops.length;
        }
        return formula.toString();
    }

    

    public void setFile(String file)
    {
        this.file = file;
    }

    

    public static void main(String args[])
    {
        if ((args == null) || (args.length != 1)
                || args[ 0 ].equals(""--help""))
        {
            System.out.println(
                ""FormulaViewer .8 proof that the devil lies in the details (or just in BIFF8 files in general)"");
            System.out.println(""usage: Give me a big fat file name"");
        }
        else
        {
            try
            {
                FormulaViewer viewer = new FormulaViewer();

                viewer.setFile(args[ 0 ]);
                viewer.run();
            }
            catch (Exception e)
            {
                System.out.println(""Whoops!"");
                e.printStackTrace();
            }
        }
    }
}
"
poi,1.5,org.apache.poi.poifs.property.PropertyConstants,0,1,0,0,0,0,0,0,0,2.0,4,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"


package org.apache.poi.poifs.property;



public interface PropertyConstants
{
    public static final int  PROPERTY_TYPE_OFFSET = 0x42;

    
    public static final byte DIRECTORY_TYPE       = 1;
    public static final byte DOCUMENT_TYPE        = 2;
    public static final byte ROOT_TYPE            = 5;
}   

"
poi,1.5,org.apache.poi.hssf.dev.EFHSSF,6,1,0,17,45,5,1,17,6,0.55,247,0.0,2,0.0,0.375,0,0,39.5,10,2.6667,0,"


package org.apache.poi.hssf.dev;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;

import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.eventmodel.*;
import org.apache.poi.hssf.usermodel.*;



public class EFHSSF
{
    String       infile;
    String       outfile;
    HSSFWorkbook workbook = null;
    HSSFSheet    cursheet = null;

    

    public EFHSSF()
    {
    }

    public void setInputFile(String infile)
    {
        this.infile = infile;
    }

    public void setOutputFile(String outfile)
    {
        this.outfile = outfile;
    }

    public void run()
        throws IOException
    {
        FileInputStream fin   = new FileInputStream(infile);
        POIFSFileSystem poifs = new POIFSFileSystem(fin);
        InputStream     din   = poifs.createDocumentInputStream(""Workbook"");
        HSSFRequest     req   = new HSSFRequest();

        req.addListenerForAllRecords(new EFHSSFListener(this));
        HSSFEventFactory factory = new HSSFEventFactory();

        factory.processEvents(req, din);
        fin.close();
        din.close();
        FileOutputStream fout = new FileOutputStream(outfile);

        workbook.write(fout);
        fout.close();
        System.out.println(""done."");
    }

    public void recordHandler(Record record)
    {
        HSSFRow  row      = null;
        HSSFCell cell     = null;
        int      sheetnum = -1;

        switch (record.getSid())
        {

            case BOFRecord.sid :
                BOFRecord bof = ( BOFRecord ) record;

                if (bof.getType() == bof.TYPE_WORKBOOK)
                {
                    workbook = new HSSFWorkbook();
                }
                else if (bof.getType() == bof.TYPE_WORKSHEET)
                {
                    sheetnum++;
                    cursheet = workbook.getSheetAt(sheetnum);
                }
                break;

            case BoundSheetRecord.sid :
                BoundSheetRecord bsr = ( BoundSheetRecord ) record;

                workbook.createSheet(bsr.getSheetname());
                break;

            case RowRecord.sid :
                RowRecord rowrec = ( RowRecord ) record;

                cursheet.createRow(rowrec.getRowNumber());
                break;

            case NumberRecord.sid :
                NumberRecord numrec = ( NumberRecord ) record;

                row  = cursheet.getRow(numrec.getRow());
                cell = row.createCell(numrec.getColumn(),
                                      HSSFCell.CELL_TYPE_NUMERIC);
                cell.setCellValue(numrec.getValue());
                break;

            case SSTRecord.sid :
                SSTRecord sstrec = ( SSTRecord ) record;

                for (int k = 0; k < sstrec.getNumUniqueStrings(); k++)
                {
                    workbook.addSSTString(sstrec.getString(k));
                }
                break;

            case LabelSSTRecord.sid :
                LabelSSTRecord lrec = ( LabelSSTRecord ) record;

                row  = cursheet.getRow(lrec.getRow());
                cell = row.createCell(lrec.getColumn(),
                                      HSSFCell.CELL_TYPE_STRING);
                cell.setCellValue(workbook.getSSTString(lrec.getSSTIndex()));
                break;
        }
    }

    public static void main(String [] args)
    {
        if ((args.length < 2) || !args[ 0 ].equals(""--help""))
        {
            try
            {
                EFHSSF viewer = new EFHSSF();

                viewer.setInputFile(args[ 0 ]);
                viewer.setOutputFile(args[ 1 ]);
                viewer.run();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
        }
        else
        {
            System.out.println(""EFHSSF"");
            System.out.println(
                ""General testbed for HSSFEventFactory based testing and ""
                + ""Code examples"");
            System.out.println(""Usage: java org.apache.poi.hssf.dev.EFHSSF ""
                               + ""file1 file2"");
            System.out.println(
                ""   --will rewrite the file reading with the event api"");
            System.out.println(""and writing with the standard API"");
        }
    }
}

class EFHSSFListener
    implements HSSFListener
{
    EFHSSF efhssf;

    public EFHSSFListener(EFHSSF efhssf)
    {
        this.efhssf = efhssf;
    }

    public void processRecord(Record record)
    {
        efhssf.recordHandler(record);
    }
}
"
poi,1.5,org.apache.poi.hpsf.SpecialPropertySet,10,2,2,7,20,0,2,5,10,0.0,53,1.0,1,0.64,0.55,1,2,4.2,1,0.9,1,"

package org.apache.poi.hpsf;

import java.util.*;
import org.apache.poi.hpsf.littleendian.*;


public abstract class SpecialPropertySet extends PropertySet
{

    private PropertySet delegate;



    public SpecialPropertySet(PropertySet ps)
    {
        delegate = ps;
    }



    public Word getByteOrder()
    {
        return delegate.getByteOrder();
    }



    public Word getFormat()
    {
        return delegate.getFormat();
    }



    public DWord getOSVersion()
    {
        return delegate.getOSVersion();
    }



    public ClassID getClassID()
    {
        return delegate.getClassID();
    }



    public int getSectionCount()
    {
        return delegate.getSectionCount();
    }



    public List getSections()
    {
        return delegate.getSections();
    }



    public boolean isSummaryInformation()
    {
        return delegate.isSummaryInformation();
    }



    public boolean isDocumentSummaryInformation()
    {
        return delegate.isDocumentSummaryInformation();
    }



    public Section getSingleSection()
    {
        return delegate.getSingleSection();
    }

}
"
poi,1.5,org.apache.poi.hssf.record.DefaultColWidthRecord,11,2,0,5,21,49,2,3,9,0.85,106,0.5,0,0.578947368,0.522727273,1,6,8.454545455,2,0.8182,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class DefaultColWidthRecord
    extends Record
{
    public final static short sid = 0x55;
    private short             field_1_col_width;

    public DefaultColWidthRecord()
    {
    }

    

    public DefaultColWidthRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public DefaultColWidthRecord(short id, short size, byte [] data,
                                 int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A DefaultColWidth RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_col_width = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setColWidth(short height)
    {
        field_1_col_width = height;
    }

    

    public short getColWidth()
    {
        return field_1_col_width;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DEFAULTCOLWIDTH]
"");
        buffer.append(""    .colwidth      = "")
            .append(Integer.toHexString(getColWidth())).append(""
"");
        buffer.append(""[/DEFAULTCOLWIDTH]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, getColWidth());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.DocumentOutputStream,8,2,0,3,15,4,3,0,5,0.428571429,90,1.0,0,0.416666667,0.425,1,1,9.875,1,0.875,0,"


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;



public class DocumentOutputStream
    extends OutputStream
{
    private OutputStream stream;
    private int          limit;
    private int          written;

    

    DocumentOutputStream(final OutputStream stream, final int limit)
    {
        this.stream  = stream;
        this.limit   = limit;
        this.written = 0;
    }

    

    public void write(final int b)
        throws IOException
    {
        limitCheck(1);
        stream.write(b);
    }

    

    public void write(final byte b[])
        throws IOException
    {
        write(b, 0, b.length);
    }

    

    public void write(final byte b[], final int off, final int len)
        throws IOException
    {
        limitCheck(len);
        stream.write(b, off, len);
    }

    

    public void flush()
        throws IOException
    {
        stream.flush();
    }

    

    public void close()
        throws IOException
    {

        
    }

    

    void writeFiller(final int totalLimit, final byte fill)
        throws IOException
    {
        if (totalLimit > written)
        {
            byte[] filler = new byte[ totalLimit - written ];

            Arrays.fill(filler, fill);
            stream.write(filler);
        }
    }

    private void limitCheck(final int toBeWritten)
        throws IOException
    {
        if ((written + toBeWritten) > limit)
        {
            throw new IOException(""tried to write too much data"");
        }
        written += toBeWritten;
    }
}   

"
poi,1.5,org.apache.poi.hssf.usermodel.HSSFSheet,48,1,0,16,117,0,3,13,39,0.832446809,617,0.875,3,0.0,0.165957447,0,0,11.6875,5,1.2708,4,"


package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.model.Sheet;
import org.apache.poi.hssf.model.Workbook;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.RowRecord;
import org.apache.poi.hssf.record.VCenterRecord;
import org.apache.poi.hssf.record.WSBoolRecord;
import org.apache.poi.hssf.util.Region;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;

import java.util.Iterator;
import java.util.TreeMap;



public class HSSFSheet
{
    private static final int DEBUG = POILogger.DEBUG;

    

    public final static int INITIAL_CAPACITY = 20;

    

    private Sheet sheet;
    private TreeMap rows;
    private Workbook book;
    private int firstrow;
    private int lastrow;
    private static POILogger log = POILogFactory.getLogger(HSSFSheet.class);

    

    protected HSSFSheet(Workbook book)
    {
        sheet = Sheet.createSheet();
        rows = new TreeMap();   
        this.book = book;
    }

    

    protected HSSFSheet(Workbook book, Sheet sheet)
    {
        this.sheet = sheet;
        rows = new TreeMap();
        this.book = book;
        setPropertiesFromSheet(sheet);
    }


    

    private void setPropertiesFromSheet(Sheet sheet)
    {
        int sloc = sheet.getLoc();
        RowRecord row = sheet.getNextRow();

        while (row != null)
        {
            createRowFromRecord(row);

            row = sheet.getNextRow();
        }
        sheet.setLoc(sloc);
        CellValueRecordInterface cval = sheet.getNextValueRecord();
        long timestart = System.currentTimeMillis();

        log.log(DEBUG, ""Time at start of cell creating in HSSF sheet = "",
                new Long(timestart));
        HSSFRow lastrow = null;

        while (cval != null)
        {
            long cellstart = System.currentTimeMillis();
            HSSFRow hrow = lastrow;

            if ((lastrow == null) || (lastrow.getRowNum() != cval.getRow()))
            {
                hrow = getRow(cval.getRow());
            }
            lastrow = hrow;
            hrow.createCellFromRecord(cval);
            cval = sheet.getNextValueRecord();
            log.log(DEBUG, ""record took "",
                    new Long(System.currentTimeMillis() - cellstart));
        }
        log.log(DEBUG, ""total sheet cell creation took "",
                new Long(System.currentTimeMillis() - timestart));
    }

    

    public HSSFRow createRow(short rownum)
    {
        HSSFRow row = new HSSFRow(book, sheet, rownum);

        addRow(row, true);
        return row;
    }

    

    private HSSFRow createRowFromRecord(RowRecord row)
    {
        HSSFRow hrow = new HSSFRow(book, sheet, row);

        addRow(hrow, false);
        return hrow;
    }

    

    public void removeRow(HSSFRow row)
    {
        sheet.setLoc(sheet.getDimsLoc());
        if (rows.size() > 0)
        {
            rows.remove(row);
            if (row.getRowNum() == getLastRowNum())
            {
                lastrow = findLastRow(lastrow);
            }
            if (row.getRowNum() == getFirstRowNum())
            {
                firstrow = findFirstRow(firstrow);
            }
            Iterator iter = row.cellIterator();

            while (iter.hasNext())
            {
                HSSFCell cell = (HSSFCell) iter.next();

                sheet.removeValueRecord(row.getRowNum(),
                        cell.getCellValueRecord());
            }
            sheet.removeRow(row.getRowRecord());
        }
    }

    

    private int findLastRow(int lastrow)
    {
        int rownum = lastrow - 1;
        HSSFRow r = getRow(rownum);

        while (r == null && rownum >= 0)
        {
            r = getRow(--rownum);
        }
        return rownum;
    }

    

    private int findFirstRow(int firstrow)
    {
        int rownum = firstrow + 1;
        HSSFRow r = getRow(rownum);

        while (r == null && rownum <= getLastRowNum())
        {
            r = getRow(++rownum);
        }

        if (rownum > getLastRowNum())
            return -1;

        return rownum;
    }

    

    private void addRow(HSSFRow row, boolean addLow)
    {
        rows.put(row, row);
        if (addLow)
        {
            sheet.addRow(row.getRowRecord());
        }
        if (row.getRowNum() > getLastRowNum())
        {
            lastrow = row.getRowNum();
        }
        if (row.getRowNum() < getFirstRowNum())
        {
            firstrow = row.getRowNum();
        }
    }

    

    public HSSFRow getRow(int rownum)
    {
        HSSFRow row = new HSSFRow();

        row.setRowNum((short) rownum);
        return (HSSFRow) rows.get(row);
    }

    

    public int getPhysicalNumberOfRows()
    {
        return rows.size();
    }

    

    public int getFirstRowNum()
    {
        return firstrow;
    }

    

    public int getLastRowNum()
    {
        return lastrow;
    }

    

    public void setColumnWidth(short column, short width)
    {
        sheet.setColumnWidth(column, width);
    }

    

    public short getColumnWidth(short column)
    {
        return sheet.getColumnWidth(column);
    }

    

    public short getDefaultColumnWidth()
    {
        return sheet.getDefaultColumnWidth();
    }

    

    public short getDefaultRowHeight()
    {
        return sheet.getDefaultRowHeight();
    }

    

    public float getDefaultRowHeightInPoints()
    {
        return (sheet.getDefaultRowHeight() / 20);
    }

    

    public void setDefaultColumnWidth(short width)
    {
        sheet.setDefaultColumnWidth(width);
    }

    

    public void setDefaultRowHeight(short height)
    {
        sheet.setDefaultRowHeight(height);
    }

    

    public void setDefaultRowHeightInPoints(float height)
    {
        sheet.setDefaultRowHeight((short) (height * 20));
    }

    

    public boolean isGridsPrinted()
    {
        return sheet.isGridsPrinted();
    }

    

    public void setGridsPrinted(boolean value)
    {
        sheet.setGridsPrinted(value);
    }

    

    public int addMergedRegion(Region region)
    {
        return sheet.addMergedRegion((short) region.getRowFrom(),
                region.getColumnFrom(),
                (short) region.getRowTo(),
                region.getColumnTo());
    }

    

    public void setVerticallyCenter(boolean value)
    {
        VCenterRecord record =
                (VCenterRecord) sheet.findFirstRecordBySid(VCenterRecord.sid);

        record.setVCenter(value);
    }

    

    public boolean getVerticallyCenter(boolean value)
    {
        VCenterRecord record =
                (VCenterRecord) sheet.findFirstRecordBySid(VCenterRecord.sid);

        return record.getVCenter();
    }

    

    public void removeMergedRegion(int index)
    {
        sheet.removeMergedRegion(index);
    }

    

    public int getNumMergedRegions()
    {
        return sheet.getNumMergedRegions();
    }

    

    public Region getMergedRegionAt(int index)
    {
        return new Region(sheet.getMergedRegionAt(index));
    }

    

    public Iterator rowIterator()
    {
        return rows.values().iterator();
    }

    

    protected Sheet getSheet()
    {
        return sheet;
    }

    

    public void setAlternativeExpression(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setAlternateExpression(b);
    }

    

    public void setAlternativeFormula(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setAlternateFormula(b);
    }

    

    public void setAutobreaks(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setAutobreaks(b);
    }

    

    public void setDialog(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setDialog(b);
    }

    

    public void setDisplayGuts(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setDisplayGuts(b);
    }

    

    public void setFitToPage(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setFitToPage(b);
    }

    

    public void setRowSumsBelow(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setRowSumsBelow(b);
    }

    

    public void setRowSumsRight(boolean b)
    {
        WSBoolRecord record =
                (WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setRowSumsRight(b);
    }

    

    public boolean getAlternateExpression()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getAlternateExpression();
    }

    

    public boolean getAlternateFormula()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getAlternateFormula();
    }

    

    public boolean getAutobreaks()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getAutobreaks();
    }

    

    public boolean getDialog()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getDialog();
    }

    

    public boolean getDisplayGuts()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getDisplayGuts();
    }

    

    public boolean getFitToPage()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getFitToPage();
    }

    

    public boolean getRowSumsBelow()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getRowSumsBelow();
    }

    

    public boolean getRowSumsRight()
    {
        return ((WSBoolRecord) sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getRowSumsRight();
    }
}
"
poi,1.5,org.apache.poi.hpsf.NoPropertySetStreamException,4,4,0,3,8,6,2,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,1,"

package org.apache.poi.hpsf;


public class NoPropertySetStreamException extends HPSFException
{

    public NoPropertySetStreamException()
    {
        super();
    }

    public NoPropertySetStreamException(final String msg)
    {
        super(msg);
    }

    public NoPropertySetStreamException(final Throwable reason)
    {
        super(reason);
    }

    public NoPropertySetStreamException(final String msg,
                                        final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,1.5,org.apache.poi.hssf.record.ChartFormatRecord,19,2,0,5,35,109,1,4,17,0.817460317,265,0.857142857,1,0.407407407,0.368421053,1,6,12.57894737,2,0.8947,0,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.BitField;



public class ChartFormatRecord
    extends Record
{
    public static final short sid = 0x1014;

    
    private int               field1_x_position;   
    private int               field2_y_position;   
    private int               field3_width;
    private int               field4_height;
    private short             field5_grbit;
    private BitField          varyDisplayPattern = new BitField(0x01);

    public ChartFormatRecord()
    {
    }

    

    public ChartFormatRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public ChartFormatRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A CHARTFORMAT RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field1_x_position = LittleEndian.getInt(data, 0 + offset);
        field2_y_position = LittleEndian.getInt(data, 4 + offset);
        field3_width      = LittleEndian.getInt(data, 8 + offset);
        field4_height     = LittleEndian.getInt(data, 12 + offset);
        field5_grbit      = LittleEndian.getShort(data, 16 + offset);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CHARTFORMAT]
"");
        buffer.append(""    .xPosition       = "").append(getXPosition())
            .append(""
"");
        buffer.append(""    .yPosition       = "").append(getYPosition())
            .append(""
"");
        buffer.append(""    .width           = "").append(getWidth())
            .append(""
"");
        buffer.append(""    .height          = "").append(getHeight())
            .append(""
"");
        buffer.append(""    .grBit           = "")
            .append(Integer.toHexString(field5_grbit)).append(""
"");
        buffer.append(""[/CHARTFORMAT]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset,
                              (( short ) 22));   
        LittleEndian.putInt(data, 4 + offset, getXPosition());
        LittleEndian.putInt(data, 8 + offset, getYPosition());
        LittleEndian.putInt(data, 12 + offset, getWidth());
        LittleEndian.putInt(data, 16 + offset, getHeight());
        LittleEndian.putShort(data, 20 + offset, field5_grbit);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 22;
    }

    public short getSid()
    {
        return this.sid;
    }

    public int getXPosition()
    {
        return field1_x_position;
    }

    public void setXPosition(int xPosition)
    {
        this.field1_x_position = xPosition;
    }

    public int getYPosition()
    {
        return field2_y_position;
    }

    public void setYPosition(int yPosition)
    {
        this.field2_y_position = yPosition;
    }

    public int getWidth()
    {
        return field3_width;
    }

    public void setWidth(int width)
    {
        this.field3_width = width;
    }

    public int getHeight()
    {
        return field4_height;
    }

    public void setHeight(int height)
    {
        this.field4_height = height;
    }

    public boolean getVaryDisplayPattern()
    {
        return varyDisplayPattern.isSet(field5_grbit);
    }

    public void setVaryDisplayPattern(boolean value)
    {
        field5_grbit = varyDisplayPattern.setShortBoolean(field5_grbit,
                value);
    }
}
"
poi,1.5,org.apache.poi.poifs.filesystem.DocumentNode,9,2,0,9,17,30,3,7,6,0.75,55,1.0,1,0.529411765,0.407407407,1,1,5.0,1,0.8889,0,"


package org.apache.poi.poifs.filesystem;

import java.util.*;

import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;



public class DocumentNode
    extends EntryNode
    implements DocumentEntry, POIFSViewable
{

    
    private POIFSDocument _document;

    

    DocumentNode(final DocumentProperty property, final DirectoryNode parent)
    {
        super(property, parent);
        _document = property.getDocument();
    }

    

    POIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public int getSize()
    {
        return getProperty().getSize();
    }

    
    

    

    public boolean isDocumentEntry()
    {
        return true;
    }

    
    

    

    protected boolean isDeleteOK()
    {
        return true;
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    

    public Iterator getViewableIterator()
    {
        List components = new ArrayList();

        components.add(getProperty());
        components.add(_document);
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
}   

"
poi,1.5,org.apache.poi.hssf.record.formula.ParenthesisPtg,7,2,0,3,8,21,1,2,7,2.0,21,0.0,0,0.538461538,0.357142857,1,2,2.0,1,0.8571,4,"


package org.apache.poi.hssf.record.formula;


public class ParenthesisPtg
    extends Ptg
    implements OperationPtg
{
   

   

    public void writeBytes(byte [] array, int offset)
    {
        
    }

    public int getSize()
    {
        return 0;
    }

    public int getType()
    {
        return TYPE_BINARY;
    }

    public int getNumberOfOperands()
    {
        return 0;
    }

    public String toFormulaString()
    {
        return ""("";
    }

    public String toFormulaString(Ptg [] operands)
    {
        return ""("";
    }
}

"
poi,1.5,org.apache.poi.poifs.storage.SmallBlockTableReader,2,1,0,9,8,1,2,7,2,2.0,24,0.0,0,0.0,0.5,0,0,11.0,1,0.5,0,"


package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.property.RootProperty;

import java.util.*;

import java.io.*;



public class SmallBlockTableReader
{

    

    public static BlockList getSmallDocumentBlocks(
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
        BlockList list =
            new SmallDocumentBlockList(SmallDocumentBlock
                .extract(blockList.fetchBlocks(root.getStartBlock())));

        new BlockAllocationTableReader(blockList.fetchBlocks(sbatStart),
                                       list);
        return list;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.HCenterRecord,11,2,0,5,21,43,2,3,9,0.85,117,0.5,0,0.578947368,0.418181818,1,6,9.454545455,2,1.0,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class HCenterRecord
    extends Record
{
    public final static short sid = 0x83;
    private short             field_1_hcenter;

    public HCenterRecord()
    {
    }

    

    public HCenterRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public HCenterRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A HCenter RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_hcenter = LittleEndian.getShort(data, 0 + offset);
    }

    

    public void setHCenter(boolean hc)
    {
        if (hc == true)
        {
            field_1_hcenter = 1;
        }
        else
        {
            field_1_hcenter = 0;
        }
    }

    

    public boolean getHCenter()
    {
        return (field_1_hcenter == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[HCENTER]
"");
        buffer.append(""    .hcenter        = "").append(getHCenter())
            .append(""
"");
        buffer.append(""[/HCENTER]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x2);
        LittleEndian.putShort(data, 4 + offset, ( short ) field_1_hcenter);
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 6;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.hssf.record.GutsRecord,17,2,0,5,27,112,2,3,15,0.8125,208,0.8,0,0.44,0.470588235,1,6,10.94117647,2,0.8824,1,"


package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndian;



public class GutsRecord
    extends Record
{
    public final static short sid = 0x80;
    private short             field_1_left_row_gutter;   
    private short             field_2_top_col_gutter;    
    private short             field_3_row_level_max;     
    private short             field_4_col_level_max;     

    public GutsRecord()
    {
    }

    

    public GutsRecord(short id, short size, byte [] data)
    {
        super(id, size, data);
    }

    

    public GutsRecord(short id, short size, byte [] data, int offset)
    {
        super(id, size, data, offset);
    }

    protected void validateSid(short id)
    {
        if (id != sid)
        {
            throw new RecordFormatException(""NOT A Guts RECORD"");
        }
    }

    protected void fillFields(byte [] data, short size, int offset)
    {
        field_1_left_row_gutter = LittleEndian.getShort(data, 0 + offset);
        field_2_top_col_gutter  = LittleEndian.getShort(data, 2 + offset);
        field_3_row_level_max   = LittleEndian.getShort(data, 4 + offset);
        field_4_col_level_max   = LittleEndian.getShort(data, 6 + offset);
    }

    

    public void setLeftRowGutter(short gut)
    {
        field_1_left_row_gutter = gut;
    }

    

    public void setTopColGutter(short gut)
    {
        field_2_top_col_gutter = gut;
    }

    

    public void setRowLevelMax(short max)
    {
        field_3_row_level_max = max;
    }

    

    public void setColLevelMax(short max)
    {
        field_4_col_level_max = max;
    }

    

    public short getLeftRowGutter()
    {
        return field_1_left_row_gutter;
    }

    

    public short getTopColGutter()
    {
        return field_2_top_col_gutter;
    }

    

    public short getRowLevelMax()
    {
        return field_3_row_level_max;
    }

    

    public short getColLevelMax()
    {
        return field_4_col_level_max;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[GUTS]
"");
        buffer.append(""    .leftgutter     = "")
            .append(Integer.toHexString(getLeftRowGutter())).append(""
"");
        buffer.append(""    .topgutter      = "")
            .append(Integer.toHexString(getTopColGutter())).append(""
"");
        buffer.append(""    .rowlevelmax    = "")
            .append(Integer.toHexString(getRowLevelMax())).append(""
"");
        buffer.append(""    .collevelmax    = "")
            .append(Integer.toHexString(getColLevelMax())).append(""
"");
        buffer.append(""[/GUTS]
"");
        return buffer.toString();
    }

    public int serialize(int offset, byte [] data)
    {
        LittleEndian.putShort(data, 0 + offset, sid);
        LittleEndian.putShort(data, 2 + offset, ( short ) 0x8);
        LittleEndian.putShort(data, 4 + offset, getLeftRowGutter());
        LittleEndian.putShort(data, 6 + offset, getTopColGutter());
        LittleEndian.putShort(data, 8 + offset, getRowLevelMax());
        LittleEndian.putShort(data, 10 + offset, getColLevelMax());
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 12;
    }

    public short getSid()
    {
        return this.sid;
    }
}
"
poi,1.5,org.apache.poi.poifs.storage.SmallBlockTableWriter,5,1,0,7,21,2,1,6,5,0.75,103,1.0,2,0.0,0.36,0,0,18.8,1,0.8,1,"


package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.poifs.filesystem.POIFSDocument;
import org.apache.poi.poifs.property.RootProperty;

import java.util.*;

import java.io.*;



public class SmallBlockTableWriter
    implements BlockWritable, BATManaged
{
    private BlockAllocationTableWriter _sbat;
    private List                       _small_blocks;
    private int                        _big_block_count;
    private RootProperty               _root;

    

    public SmallBlockTableWriter(final List documents,
                                 final RootProperty root)
    {
        _sbat         = new BlockAllocationTableWriter();
        _small_blocks = new ArrayList();
        _root         = root;
        Iterator iter = documents.iterator();

        while (iter.hasNext())
        {
            POIFSDocument   doc    = ( POIFSDocument ) iter.next();
            BlockWritable[] blocks = doc.getSmallBlocks();

            if (blocks.length != 0)
            {
                doc.setStartBlock(_sbat.allocateSpace(blocks.length));
                for (int j = 0; j < blocks.length; j++)
                {
                    _small_blocks.add(blocks[ j ]);
                }
            }
        }
        _sbat.simpleCreateBlocks();
        _root.setSize(_small_blocks.size());
        _big_block_count = SmallDocumentBlock.fill(_small_blocks);
    }

    

    public BlockAllocationTableWriter getSBAT()
    {
        return _sbat;
    }

    

    

    public int countBlocks()
    {
        return _big_block_count;
    }

    

    public void setStartBlock(int start_block)
    {
        _root.setStartBlock(start_block);
    }

    
    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        Iterator iter = _small_blocks.iterator();

        while (iter.hasNext())
        {
            (( BlockWritable ) iter.next()).writeBlocks(stream);
        }
    }

    
}
"
