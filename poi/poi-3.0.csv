name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
poi,3,org.apache.poi.hssf.usermodel.HSSFChildAnchor,5,2,0,5,7,6,4,1,5,2.0,46,0.0,0,0.769230769,0.7,1,1,8.2,2,1.0,1,"

package org.apache.poi.hssf.usermodel;


import org.apache.poi.ddf.EscherChildAnchorRecord;
import org.apache.poi.ddf.EscherRecord;

public final class HSSFChildAnchor extends HSSFAnchor {

    private EscherChildAnchorRecord _escherChildAnchor;

    
    public HSSFChildAnchor(EscherChildAnchorRecord escherChildAnchorRecord) {
        this._escherChildAnchor = escherChildAnchorRecord;
    }

    public HSSFChildAnchor() {
        _escherChildAnchor = new EscherChildAnchorRecord();
    }

    
    public HSSFChildAnchor(int dx1, int dy1, int dx2, int dy2) {
        super(Math.min(dx1, dx2), Math.min(dy1, dy2), Math.max(dx1, dx2), Math.max(dy1, dy2));
        if (dx1 > dx2){
            _isHorizontallyFlipped = true;
        }
        if (dy1 > dy2){
            _isVerticallyFlipped = true;
        }
    }

    @Override
    public int getDx1() {
        return _escherChildAnchor.getDx1();
    }

    @Override
    public void setDx1(int dx1) {
        _escherChildAnchor.setDx1(dx1);
    }

    @Override
    public int getDy1() {
        return _escherChildAnchor.getDy1();
    }

    @Override
    public void setDy1(int dy1) {
        _escherChildAnchor.setDy1(dy1);
    }

    @Override
    public int getDy2() {
        return _escherChildAnchor.getDy2();
    }

    @Override
    public void setDy2(int dy2) {
        _escherChildAnchor.setDy2(dy2);
    }

    @Override
    public int getDx2() {
        return _escherChildAnchor.getDx2();
    }

    @Override
    public void setDx2(int dx2) {
        _escherChildAnchor.setDx2(dx2);
    }

    
    public void setAnchor(int dx1, int dy1, int dx2, int dy2) {
        setDx1(Math.min(dx1, dx2));
        setDy1(Math.min(dy1, dy2));
        setDx2(Math.max(dx1, dx2));
        setDy2(Math.max(dy1, dy2));
    }


    public boolean isHorizontallyFlipped() {
        return _isHorizontallyFlipped;
    }


    public boolean isVerticallyFlipped() {
        return _isVerticallyFlipped;
    }

    @Override
    protected EscherRecord getEscherAnchor() {
        return _escherChildAnchor;
    }

    @Override
    protected void createEscherAnchor() {
        _escherChildAnchor = new EscherChildAnchorRecord();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (obj == this)
            return true;
        if (obj.getClass() != getClass())
            return false;
        HSSFChildAnchor anchor = (HSSFChildAnchor) obj;

        return anchor.getDx1() == getDx1() && anchor.getDx2() == getDx2() && anchor.getDy1() == getDy1()
                && anchor.getDy2() == getDy2();
    }

    @Override
    public int hashCode() {
        assert false : ""hashCode not designed"";
        return 42; 
    }
}
"
poi,3,org.apache.poi.hssf.record.LeftMarginRecord,11,2,0,7,21,35,2,5,9,0.8,107,0.5,0,0.55,0.257575758,1,4,8.545454545,2,0.9091,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class LeftMarginRecord extends StandardRecord implements Margin
{
    public final static short sid = 0x0026;
    private double field_1_margin;

    public LeftMarginRecord()    {    }

    public LeftMarginRecord(RecordInputStream in)
    {
        field_1_margin = in.readDouble();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();
        buffer.append( ""[LeftMargin]
"" );
        buffer.append( ""    .margin               = "" ).append( "" ("" ).append( getMargin() ).append( "" )
"" );
        buffer.append( ""[/LeftMargin]
"" );
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeDouble(field_1_margin);
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid()    {
        return sid;
    }

    
    public double getMargin()    {
        return field_1_margin;
    }

    
    public void setMargin( double field_1_margin )
    {
        this.field_1_margin = field_1_margin;
    }

    public Object clone()
    {
        LeftMarginRecord rec = new LeftMarginRecord();
        rec.field_1_margin = this.field_1_margin;
        return rec;
    }
}  "
poi,3,org.apache.poi.ddf.EscherProperties,7,1,0,6,16,9,5,1,3,1.164242424,1460,0.003636364,0,0.0,0.19047619,0,0,168.2857143,2,1.2857,2,"

package org.apache.poi.ddf;

import java.util.HashMap;
import java.util.Map;


public final class EscherProperties {

	
	public static final short TRANSFORM__ROTATION = 4;
	public static final short PROTECTION__LOCKROTATION = 119;
	public static final short PROTECTION__LOCKASPECTRATIO = 120;
	public static final short PROTECTION__LOCKPOSITION = 121;
	public static final short PROTECTION__LOCKAGAINSTSELECT = 122;
	public static final short PROTECTION__LOCKCROPPING = 123;
	public static final short PROTECTION__LOCKVERTICES = 124;
	public static final short PROTECTION__LOCKTEXT = 125;
	public static final short PROTECTION__LOCKADJUSTHANDLES = 126;
	public static final short PROTECTION__LOCKAGAINSTGROUPING = 127;
	public static final short TEXT__TEXTID = 128;
	public static final short TEXT__TEXTLEFT = 129;
	public static final short TEXT__TEXTTOP = 130;
	public static final short TEXT__TEXTRIGHT = 131;
	public static final short TEXT__TEXTBOTTOM = 132;
	public static final short TEXT__WRAPTEXT = 133;
	public static final short TEXT__SCALETEXT = 134;
	public static final short TEXT__ANCHORTEXT = 135;
	public static final short TEXT__TEXTFLOW = 136;
	public static final short TEXT__FONTROTATION = 137;
	public static final short TEXT__IDOFNEXTSHAPE = 138;
	public static final short TEXT__BIDIR = 139;
	public static final short TEXT__SINGLECLICKSELECTS = 187;
	public static final short TEXT__USEHOSTMARGINS = 188;
	public static final short TEXT__ROTATETEXTWITHSHAPE = 189;
	public static final short TEXT__SIZESHAPETOFITTEXT = 190;
	public static final short TEXT__SIZE_TEXT_TO_FIT_SHAPE = 191;
	public static final short GEOTEXT__UNICODE = 192;
	public static final short GEOTEXT__RTFTEXT = 193;
	public static final short GEOTEXT__ALIGNMENTONCURVE = 194;
	public static final short GEOTEXT__DEFAULTPOINTSIZE = 195;
	public static final short GEOTEXT__TEXTSPACING = 196;
	public static final short GEOTEXT__FONTFAMILYNAME = 197;
	public static final short GEOTEXT__REVERSEROWORDER = 240;
	public static final short GEOTEXT__HASTEXTEFFECT = 241;
	public static final short GEOTEXT__ROTATECHARACTERS = 242;
	public static final short GEOTEXT__KERNCHARACTERS = 243;
	public static final short GEOTEXT__TIGHTORTRACK = 244;
	public static final short GEOTEXT__STRETCHTOFITSHAPE = 245;
	public static final short GEOTEXT__CHARBOUNDINGBOX = 246;
	public static final short GEOTEXT__SCALETEXTONPATH = 247;
	public static final short GEOTEXT__STRETCHCHARHEIGHT = 248;
	public static final short GEOTEXT__NOMEASUREALONGPATH = 249;
	public static final short GEOTEXT__BOLDFONT = 250;
	public static final short GEOTEXT__ITALICFONT = 251;
	public static final short GEOTEXT__UNDERLINEFONT = 252;
	public static final short GEOTEXT__SHADOWFONT = 253;
	public static final short GEOTEXT__SMALLCAPSFONT = 254;
	public static final short GEOTEXT__STRIKETHROUGHFONT = 255;
	public static final short BLIP__CROPFROMTOP = 256;
	public static final short BLIP__CROPFROMBOTTOM = 257;
	public static final short BLIP__CROPFROMLEFT = 258;
	public static final short BLIP__CROPFROMRIGHT = 259;
	public static final short BLIP__BLIPTODISPLAY = 260;
	public static final short BLIP__BLIPFILENAME = 261;
	public static final short BLIP__BLIPFLAGS = 262;
	public static final short BLIP__TRANSPARENTCOLOR = 263;
	public static final short BLIP__CONTRASTSETTING = 264;
	public static final short BLIP__BRIGHTNESSSETTING = 265;
	public static final short BLIP__GAMMA = 266;
	public static final short BLIP__PICTUREID = 267;
	public static final short BLIP__DOUBLEMOD = 268;
	public static final short BLIP__PICTUREFILLMOD = 269;
	public static final short BLIP__PICTURELINE = 270;
	public static final short BLIP__PRINTBLIP = 271;
	public static final short BLIP__PRINTBLIPFILENAME = 272;
	public static final short BLIP__PRINTFLAGS = 273;
	public static final short BLIP__NOHITTESTPICTURE = 316;
	public static final short BLIP__PICTUREGRAY = 317;
	public static final short BLIP__PICTUREBILEVEL = 318;
	public static final short BLIP__PICTUREACTIVE = 319;
	public static final short GEOMETRY__LEFT = 320;
	public static final short GEOMETRY__TOP = 321;
	public static final short GEOMETRY__RIGHT = 322;
	public static final short GEOMETRY__BOTTOM = 323;
	public static final short GEOMETRY__SHAPEPATH = 324;
	public static final short GEOMETRY__VERTICES = 325;
	public static final short GEOMETRY__SEGMENTINFO = 326;
	public static final short GEOMETRY__ADJUSTVALUE = 327;
	public static final short GEOMETRY__ADJUST2VALUE = 328;
	public static final short GEOMETRY__ADJUST3VALUE = 329;
	public static final short GEOMETRY__ADJUST4VALUE = 330;
	public static final short GEOMETRY__ADJUST5VALUE = 331;
	public static final short GEOMETRY__ADJUST6VALUE = 332;
	public static final short GEOMETRY__ADJUST7VALUE = 333;
	public static final short GEOMETRY__ADJUST8VALUE = 334;
	public static final short GEOMETRY__ADJUST9VALUE = 335;
	public static final short GEOMETRY__ADJUST10VALUE = 336;
	public static final short GEOMETRY__SHADOWok = 378;
	public static final short GEOMETRY__3DOK = 379;
	public static final short GEOMETRY__LINEOK = 380;
	public static final short GEOMETRY__GEOTEXTOK = 381;
	public static final short GEOMETRY__FILLSHADESHAPEOK = 382;
	public static final short GEOMETRY__FILLOK = 383;
	public static final short FILL__FILLTYPE = 384;
	public static final short FILL__FILLCOLOR = 385;
	public static final short FILL__FILLOPACITY = 386;
	public static final short FILL__FILLBACKCOLOR = 387;
	public static final short FILL__BACKOPACITY = 388;
	public static final short FILL__CRMOD = 389;
	public static final short FILL__PATTERNTEXTURE = 390;
	public static final short FILL__BLIPFILENAME = 391;
	public static final short FILL__BLIPFLAGS = 392;
	public static final short FILL__WIDTH = 393;
	public static final short FILL__HEIGHT = 394;
	public static final short FILL__ANGLE = 395;
	public static final short FILL__FOCUS = 396;
	public static final short FILL__TOLEFT = 397;
	public static final short FILL__TOTOP = 398;
	public static final short FILL__TORIGHT = 399;
	public static final short FILL__TOBOTTOM = 400;
	public static final short FILL__RECTLEFT = 401;
	public static final short FILL__RECTTOP = 402;
	public static final short FILL__RECTRIGHT = 403;
	public static final short FILL__RECTBOTTOM = 404;
	public static final short FILL__DZTYPE = 405;
	public static final short FILL__SHADEPRESET = 406;
	public static final short FILL__SHADECOLORS = 407;
	public static final short FILL__ORIGINX = 408;
	public static final short FILL__ORIGINY = 409;
	public static final short FILL__SHAPEORIGINX = 410;
	public static final short FILL__SHAPEORIGINY = 411;
	public static final short FILL__SHADETYPE = 412;
	public static final short FILL__FILLED = 443;
	public static final short FILL__HITTESTFILL = 444;
	public static final short FILL__SHAPE = 445;
	public static final short FILL__USERECT = 446;
	public static final short FILL__NOFILLHITTEST = 447;
	public static final short LINESTYLE__COLOR = 448;
	public static final short LINESTYLE__OPACITY = 449;
	public static final short LINESTYLE__BACKCOLOR = 450;
	public static final short LINESTYLE__CRMOD = 451;
	public static final short LINESTYLE__LINETYPE = 452;
	public static final short LINESTYLE__FILLBLIP = 453;
	public static final short LINESTYLE__FILLBLIPNAME = 454;
	public static final short LINESTYLE__FILLBLIPFLAGS = 455;
	public static final short LINESTYLE__FILLWIDTH = 456;
	public static final short LINESTYLE__FILLHEIGHT = 457;
	public static final short LINESTYLE__FILLDZTYPE = 458;
	public static final short LINESTYLE__LINEWIDTH = 459;
	public static final short LINESTYLE__LINEMITERLIMIT = 460;
	public static final short LINESTYLE__LINESTYLE = 461;
	public static final short LINESTYLE__LINEDASHING = 462;
	public static final short LINESTYLE__LINEDASHSTYLE = 463;
	public static final short LINESTYLE__LINESTARTARROWHEAD = 464;
	public static final short LINESTYLE__LINEENDARROWHEAD = 465;
	public static final short LINESTYLE__LINESTARTARROWWIDTH = 466;
	public static final short LINESTYLE__LINEESTARTARROWLENGTH = 467;
	public static final short LINESTYLE__LINEENDARROWWIDTH = 468;
	public static final short LINESTYLE__LINEENDARROWLENGTH = 469;
	public static final short LINESTYLE__LINEJOINSTYLE = 470;
	public static final short LINESTYLE__LINEENDCAPSTYLE = 471;
	public static final short LINESTYLE__ARROWHEADSOK = 507;
	public static final short LINESTYLE__ANYLINE = 508;
	public static final short LINESTYLE__HITLINETEST = 509;
	public static final short LINESTYLE__LINEFILLSHAPE = 510;
	public static final short LINESTYLE__NOLINEDRAWDASH = 511;
	public static final short SHADOWSTYLE__TYPE = 512;
	public static final short SHADOWSTYLE__COLOR = 513;
	public static final short SHADOWSTYLE__HIGHLIGHT = 514;
	public static final short SHADOWSTYLE__CRMOD = 515;
	public static final short SHADOWSTYLE__OPACITY = 516;
	public static final short SHADOWSTYLE__OFFSETX = 517;
	public static final short SHADOWSTYLE__OFFSETY = 518;
	public static final short SHADOWSTYLE__SECONDOFFSETX = 519;
	public static final short SHADOWSTYLE__SECONDOFFSETY = 520;
	public static final short SHADOWSTYLE__SCALEXTOX = 521;
	public static final short SHADOWSTYLE__SCALEYTOX = 522;
	public static final short SHADOWSTYLE__SCALEXTOY = 523;
	public static final short SHADOWSTYLE__SCALEYTOY = 524;
	public static final short SHADOWSTYLE__PERSPECTIVEX = 525;
	public static final short SHADOWSTYLE__PERSPECTIVEY = 526;
	public static final short SHADOWSTYLE__WEIGHT = 527;
	public static final short SHADOWSTYLE__ORIGINX = 528;
	public static final short SHADOWSTYLE__ORIGINY = 529;
	public static final short SHADOWSTYLE__SHADOW = 574;
	public static final short SHADOWSTYLE__SHADOWOBSURED = 575;
	public static final short PERSPECTIVE__TYPE = 576;
	public static final short PERSPECTIVE__OFFSETX = 577;
	public static final short PERSPECTIVE__OFFSETY = 578;
	public static final short PERSPECTIVE__SCALEXTOX = 579;
	public static final short PERSPECTIVE__SCALEYTOX = 580;
	public static final short PERSPECTIVE__SCALEXTOY = 581;
	public static final short PERSPECTIVE__SCALEYTOY = 582;
	public static final short PERSPECTIVE__PERSPECTIVEX = 583;
	public static final short PERSPECTIVE__PERSPECTIVEY = 584;
	public static final short PERSPECTIVE__WEIGHT = 585;
	public static final short PERSPECTIVE__ORIGINX = 586;
	public static final short PERSPECTIVE__ORIGINY = 587;
	public static final short PERSPECTIVE__PERSPECTIVEON = 639;
	public static final short THREED__SPECULARAMOUNT = 640;
	public static final short THREED__DIFFUSEAMOUNT = 661;
	public static final short THREED__SHININESS = 662;
	public static final short THREED__EDGETHICKNESS = 663;
	public static final short THREED__EXTRUDEFORWARD = 664;
	public static final short THREED__EXTRUDEBACKWARD = 665;
	public static final short THREED__EXTRUDEPLANE = 666;
	public static final short THREED__EXTRUSIONCOLOR = 667;
	public static final short THREED__CRMOD = 648;
	public static final short THREED__3DEFFECT = 700;
	public static final short THREED__METALLIC = 701;
	public static final short THREED__USEEXTRUSIONCOLOR = 702;
	public static final short THREED__LIGHTFACE = 703;
	public static final short THREEDSTYLE__YROTATIONANGLE = 704;
	public static final short THREEDSTYLE__XROTATIONANGLE = 705;
	public static final short THREEDSTYLE__ROTATIONAXISX = 706;
	public static final short THREEDSTYLE__ROTATIONAXISY = 707;
	public static final short THREEDSTYLE__ROTATIONAXISZ = 708;
	public static final short THREEDSTYLE__ROTATIONANGLE = 709;
	public static final short THREEDSTYLE__ROTATIONCENTERX = 710;
	public static final short THREEDSTYLE__ROTATIONCENTERY = 711;
	public static final short THREEDSTYLE__ROTATIONCENTERZ = 712;
	public static final short THREEDSTYLE__RENDERMODE = 713;
	public static final short THREEDSTYLE__TOLERANCE = 714;
	public static final short THREEDSTYLE__XVIEWPOINT = 715;
	public static final short THREEDSTYLE__YVIEWPOINT = 716;
	public static final short THREEDSTYLE__ZVIEWPOINT = 717;
	public static final short THREEDSTYLE__ORIGINX = 718;
	public static final short THREEDSTYLE__ORIGINY = 719;
	public static final short THREEDSTYLE__SKEWANGLE = 720;
	public static final short THREEDSTYLE__SKEWAMOUNT = 721;
	public static final short THREEDSTYLE__AMBIENTINTENSITY = 722;
	public static final short THREEDSTYLE__KEYX = 723;
	public static final short THREEDSTYLE__KEYY = 724;
	public static final short THREEDSTYLE__KEYZ = 725;
	public static final short THREEDSTYLE__KEYINTENSITY = 726;
	public static final short THREEDSTYLE__FILLX = 727;
	public static final short THREEDSTYLE__FILLY = 728;
	public static final short THREEDSTYLE__FILLZ = 729;
	public static final short THREEDSTYLE__FILLINTENSITY = 730;
	public static final short THREEDSTYLE__CONSTRAINROTATION = 763;
	public static final short THREEDSTYLE__ROTATIONCENTERAUTO = 764;
	public static final short THREEDSTYLE__PARALLEL = 765;
	public static final short THREEDSTYLE__KEYHARSH = 766;
	public static final short THREEDSTYLE__FILLHARSH = 767;
	public static final short SHAPE__MASTER = 769;
	public static final short SHAPE__CONNECTORSTYLE = 771;
	public static final short SHAPE__BLACKANDWHITESETTINGS = 772;
	public static final short SHAPE__WMODEPUREBW = 773;
	public static final short SHAPE__WMODEBW = 774;
	public static final short SHAPE__OLEICON = 826;
	public static final short SHAPE__PREFERRELATIVERESIZE = 827;
	public static final short SHAPE__LOCKSHAPETYPE = 828;
	public static final short SHAPE__DELETEATTACHEDOBJECT = 830;
	public static final short SHAPE__BACKGROUNDSHAPE = 831;
	public static final short CALLOUT__CALLOUTTYPE = 832;
	public static final short CALLOUT__XYCALLOUTGAP = 833;
	public static final short CALLOUT__CALLOUTANGLE = 834;
	public static final short CALLOUT__CALLOUTDROPTYPE = 835;
	public static final short CALLOUT__CALLOUTDROPSPECIFIED = 836;
	public static final short CALLOUT__CALLOUTLENGTHSPECIFIED = 837;
	public static final short CALLOUT__ISCALLOUT = 889;
	public static final short CALLOUT__CALLOUTACCENTBAR = 890;
	public static final short CALLOUT__CALLOUTTEXTBORDER = 891;
	public static final short CALLOUT__CALLOUTMINUSX = 892;
	public static final short CALLOUT__CALLOUTMINUSY = 893;
	public static final short CALLOUT__DROPAUTO = 894;
	public static final short CALLOUT__LENGTHSPECIFIED = 895;
	public static final short GROUPSHAPE__SHAPENAME = 0x0380;
	public static final short GROUPSHAPE__DESCRIPTION = 0x0381;
    public static final short GROUPSHAPE__HYPERLINK = 0x0382;
	public static final short GROUPSHAPE__WRAPPOLYGONVERTICES = 0x0383;
	public static final short GROUPSHAPE__WRAPDISTLEFT = 0x0384;
	public static final short GROUPSHAPE__WRAPDISTTOP = 0x0385;
	public static final short GROUPSHAPE__WRAPDISTRIGHT = 0x0386;
	public static final short GROUPSHAPE__WRAPDISTBOTTOM = 0x0387;
    public static final short GROUPSHAPE__REGROUPID = 0x0388;
    public static final short GROUPSHAPE__UNUSED906 = 0x038A;
    public static final short GROUPSHAPE__TOOLTIP = 0x038D;
    public static final short GROUPSHAPE__SCRIPT = 0x038E;
    public static final short GROUPSHAPE__POSH = 0x038F;
    public static final short GROUPSHAPE__POSRELH = 0x0390;
    public static final short GROUPSHAPE__POSV = 0x0391;
    public static final short GROUPSHAPE__POSRELV = 0x0392;
    public static final short GROUPSHAPE__HR_PCT = 0x0393;
    public static final short GROUPSHAPE__HR_ALIGN = 0x0394;
    public static final short GROUPSHAPE__HR_HEIGHT = 0x0395;
    public static final short GROUPSHAPE__HR_WIDTH = 0x0396;
    public static final short GROUPSHAPE__SCRIPTEXT = 0x0397;
    public static final short GROUPSHAPE__SCRIPTLANG = 0x0398;
    public static final short GROUPSHAPE__BORDERTOPCOLOR = 0x039B;
    public static final short GROUPSHAPE__BORDERLEFTCOLOR = 0x039C;
    public static final short GROUPSHAPE__BORDERBOTTOMCOLOR = 0x039D;
    public static final short GROUPSHAPE__BORDERRIGHTCOLOR = 0x039E;
    public static final short GROUPSHAPE__TABLEPROPERTIES = 0x039F;
    public static final short GROUPSHAPE__TABLEROWPROPERTIES = 0x03A0;
    public static final short GROUPSHAPE__WEBBOT = 0x03A5;
    public static final short GROUPSHAPE__METROBLOB = 0x03A9;
    public static final short GROUPSHAPE__ZORDER = 0x03AA;
    public static final short GROUPSHAPE__FLAGS = 0x03BF;
	public static final short GROUPSHAPE__EDITEDWRAP = 953;
	public static final short GROUPSHAPE__BEHINDDOCUMENT = 954;
	public static final short GROUPSHAPE__ONDBLCLICKNOTIFY = 955;
	public static final short GROUPSHAPE__ISBUTTON = 956;
	public static final short GROUPSHAPE__1DADJUSTMENT = 957;
	public static final short GROUPSHAPE__HIDDEN = 958;
	public static final short GROUPSHAPE__PRINT = 959;

	private static final Map<Short, EscherPropertyMetaData> properties = initProps();

	private static Map<Short, EscherPropertyMetaData> initProps() {
		Map<Short, EscherPropertyMetaData> m = new HashMap<Short, EscherPropertyMetaData>();
		addProp(m, TRANSFORM__ROTATION, ""transform.rotation"");
		addProp(m, PROTECTION__LOCKROTATION, ""protection.lockrotation"");
		addProp(m, PROTECTION__LOCKASPECTRATIO, ""protection.lockaspectratio"");
		addProp(m, PROTECTION__LOCKPOSITION, ""protection.lockposition"");
		addProp(m, PROTECTION__LOCKAGAINSTSELECT, ""protection.lockagainstselect"");
		addProp(m, PROTECTION__LOCKCROPPING, ""protection.lockcropping"");
		addProp(m, PROTECTION__LOCKVERTICES, ""protection.lockvertices"");
		addProp(m, PROTECTION__LOCKTEXT, ""protection.locktext"");
		addProp(m, PROTECTION__LOCKADJUSTHANDLES, ""protection.lockadjusthandles"");
		addProp(m, PROTECTION__LOCKAGAINSTGROUPING, ""protection.lockagainstgrouping"", EscherPropertyMetaData.TYPE_BOOLEAN);
		addProp(m, TEXT__TEXTID, ""text.textid"");
		addProp(m, TEXT__TEXTLEFT, ""text.textleft"");
		addProp(m, TEXT__TEXTTOP, ""text.texttop"");
		addProp(m, TEXT__TEXTRIGHT, ""text.textright"");
		addProp(m, TEXT__TEXTBOTTOM, ""text.textbottom"");
		addProp(m, TEXT__WRAPTEXT, ""text.wraptext"");
		addProp(m, TEXT__SCALETEXT, ""text.scaletext"");
		addProp(m, TEXT__ANCHORTEXT, ""text.anchortext"");
		addProp(m, TEXT__TEXTFLOW, ""text.textflow"");
		addProp(m, TEXT__FONTROTATION, ""text.fontrotation"");
		addProp(m, TEXT__IDOFNEXTSHAPE, ""text.idofnextshape"");
		addProp(m, TEXT__BIDIR, ""text.bidir"");
		addProp(m, TEXT__SINGLECLICKSELECTS, ""text.singleclickselects"");
		addProp(m, TEXT__USEHOSTMARGINS, ""text.usehostmargins"");
		addProp(m, TEXT__ROTATETEXTWITHSHAPE, ""text.rotatetextwithshape"");
		addProp(m, TEXT__SIZESHAPETOFITTEXT, ""text.sizeshapetofittext"");
		addProp(m, TEXT__SIZE_TEXT_TO_FIT_SHAPE, ""text.sizetexttofitshape"", EscherPropertyMetaData.TYPE_BOOLEAN);
		addProp(m, GEOTEXT__UNICODE, ""geotext.unicode"");
		addProp(m, GEOTEXT__RTFTEXT, ""geotext.rtftext"");
		addProp(m, GEOTEXT__ALIGNMENTONCURVE, ""geotext.alignmentoncurve"");
		addProp(m, GEOTEXT__DEFAULTPOINTSIZE, ""geotext.defaultpointsize"");
		addProp(m, GEOTEXT__TEXTSPACING, ""geotext.textspacing"");
		addProp(m, GEOTEXT__FONTFAMILYNAME, ""geotext.fontfamilyname"");
		addProp(m, GEOTEXT__REVERSEROWORDER, ""geotext.reverseroworder"");
		addProp(m, GEOTEXT__HASTEXTEFFECT, ""geotext.hastexteffect"");
		addProp(m, GEOTEXT__ROTATECHARACTERS, ""geotext.rotatecharacters"");
		addProp(m, GEOTEXT__KERNCHARACTERS, ""geotext.kerncharacters"");
		addProp(m, GEOTEXT__TIGHTORTRACK, ""geotext.tightortrack"");
		addProp(m, GEOTEXT__STRETCHTOFITSHAPE, ""geotext.stretchtofitshape"");
		addProp(m, GEOTEXT__CHARBOUNDINGBOX, ""geotext.charboundingbox"");
		addProp(m, GEOTEXT__SCALETEXTONPATH, ""geotext.scaletextonpath"");
		addProp(m, GEOTEXT__STRETCHCHARHEIGHT, ""geotext.stretchcharheight"");
		addProp(m, GEOTEXT__NOMEASUREALONGPATH, ""geotext.nomeasurealongpath"");
		addProp(m, GEOTEXT__BOLDFONT, ""geotext.boldfont"");
		addProp(m, GEOTEXT__ITALICFONT, ""geotext.italicfont"");
		addProp(m, GEOTEXT__UNDERLINEFONT, ""geotext.underlinefont"");
		addProp(m, GEOTEXT__SHADOWFONT, ""geotext.shadowfont"");
		addProp(m, GEOTEXT__SMALLCAPSFONT, ""geotext.smallcapsfont"");
		addProp(m, GEOTEXT__STRIKETHROUGHFONT, ""geotext.strikethroughfont"");
		addProp(m, BLIP__CROPFROMTOP, ""blip.cropfromtop"");
		addProp(m, BLIP__CROPFROMBOTTOM, ""blip.cropfrombottom"");
		addProp(m, BLIP__CROPFROMLEFT, ""blip.cropfromleft"");
		addProp(m, BLIP__CROPFROMRIGHT, ""blip.cropfromright"");
		addProp(m, BLIP__BLIPTODISPLAY, ""blip.bliptodisplay"");
		addProp(m, BLIP__BLIPFILENAME, ""blip.blipfilename"");
		addProp(m, BLIP__BLIPFLAGS, ""blip.blipflags"");
		addProp(m, BLIP__TRANSPARENTCOLOR, ""blip.transparentcolor"");
		addProp(m, BLIP__CONTRASTSETTING, ""blip.contrastsetting"");
		addProp(m, BLIP__BRIGHTNESSSETTING, ""blip.brightnesssetting"");
		addProp(m, BLIP__GAMMA, ""blip.gamma"");
		addProp(m, BLIP__PICTUREID, ""blip.pictureid"");
		addProp(m, BLIP__DOUBLEMOD, ""blip.doublemod"");
		addProp(m, BLIP__PICTUREFILLMOD, ""blip.picturefillmod"");
		addProp(m, BLIP__PICTURELINE, ""blip.pictureline"");
		addProp(m, BLIP__PRINTBLIP, ""blip.printblip"");
		addProp(m, BLIP__PRINTBLIPFILENAME, ""blip.printblipfilename"");
		addProp(m, BLIP__PRINTFLAGS, ""blip.printflags"");
		addProp(m, BLIP__NOHITTESTPICTURE, ""blip.nohittestpicture"");
		addProp(m, BLIP__PICTUREGRAY, ""blip.picturegray"");
		addProp(m, BLIP__PICTUREBILEVEL, ""blip.picturebilevel"");
		addProp(m, BLIP__PICTUREACTIVE, ""blip.pictureactive"");
		addProp(m, GEOMETRY__LEFT, ""geometry.left"");
		addProp(m, GEOMETRY__TOP, ""geometry.top"");
		addProp(m, GEOMETRY__RIGHT, ""geometry.right"");
		addProp(m, GEOMETRY__BOTTOM, ""geometry.bottom"");
		addProp(m, GEOMETRY__SHAPEPATH, ""geometry.shapepath"", EscherPropertyMetaData.TYPE_SHAPEPATH);
		addProp(m, GEOMETRY__VERTICES, ""geometry.vertices"", EscherPropertyMetaData.TYPE_ARRAY);
		addProp(m, GEOMETRY__SEGMENTINFO, ""geometry.segmentinfo"", EscherPropertyMetaData.TYPE_ARRAY);
		addProp(m, GEOMETRY__ADJUSTVALUE, ""geometry.adjustvalue"");
		addProp(m, GEOMETRY__ADJUST2VALUE, ""geometry.adjust2value"");
		addProp(m, GEOMETRY__ADJUST3VALUE, ""geometry.adjust3value"");
		addProp(m, GEOMETRY__ADJUST4VALUE, ""geometry.adjust4value"");
		addProp(m, GEOMETRY__ADJUST5VALUE, ""geometry.adjust5value"");
		addProp(m, GEOMETRY__ADJUST6VALUE, ""geometry.adjust6value"");
		addProp(m, GEOMETRY__ADJUST7VALUE, ""geometry.adjust7value"");
		addProp(m, GEOMETRY__ADJUST8VALUE, ""geometry.adjust8value"");
		addProp(m, GEOMETRY__ADJUST9VALUE, ""geometry.adjust9value"");
		addProp(m, GEOMETRY__ADJUST10VALUE, ""geometry.adjust10value"");
		addProp(m, GEOMETRY__SHADOWok, ""geometry.shadowOK"");
		addProp(m, GEOMETRY__3DOK, ""geometry.3dok"");
		addProp(m, GEOMETRY__LINEOK, ""geometry.lineok"");
		addProp(m, GEOMETRY__GEOTEXTOK, ""geometry.geotextok"");
		addProp(m, GEOMETRY__FILLSHADESHAPEOK, ""geometry.fillshadeshapeok"");
		addProp(m, GEOMETRY__FILLOK, ""geometry.fillok"", EscherPropertyMetaData.TYPE_BOOLEAN);
		addProp(m, FILL__FILLTYPE, ""fill.filltype"");
		addProp(m, FILL__FILLCOLOR, ""fill.fillcolor"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, FILL__FILLOPACITY, ""fill.fillopacity"");
		addProp(m, FILL__FILLBACKCOLOR, ""fill.fillbackcolor"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, FILL__BACKOPACITY, ""fill.backopacity"");
		addProp(m, FILL__CRMOD, ""fill.crmod"");
		addProp(m, FILL__PATTERNTEXTURE, ""fill.patterntexture"");
		addProp(m, FILL__BLIPFILENAME, ""fill.blipfilename"");
		addProp(m, FILL__BLIPFLAGS, ""fill.blipflags"");
		addProp(m, FILL__WIDTH, ""fill.width"");
		addProp(m, FILL__HEIGHT, ""fill.height"");
		addProp(m, FILL__ANGLE, ""fill.angle"");
		addProp(m, FILL__FOCUS, ""fill.focus"");
		addProp(m, FILL__TOLEFT, ""fill.toleft"");
		addProp(m, FILL__TOTOP, ""fill.totop"");
		addProp(m, FILL__TORIGHT, ""fill.toright"");
		addProp(m, FILL__TOBOTTOM, ""fill.tobottom"");
		addProp(m, FILL__RECTLEFT, ""fill.rectleft"");
		addProp(m, FILL__RECTTOP, ""fill.recttop"");
		addProp(m, FILL__RECTRIGHT, ""fill.rectright"");
		addProp(m, FILL__RECTBOTTOM, ""fill.rectbottom"");
		addProp(m, FILL__DZTYPE, ""fill.dztype"");
		addProp(m, FILL__SHADEPRESET, ""fill.shadepreset"");
		addProp(m, FILL__SHADECOLORS, ""fill.shadecolors"", EscherPropertyMetaData.TYPE_ARRAY);
		addProp(m, FILL__ORIGINX, ""fill.originx"");
		addProp(m, FILL__ORIGINY, ""fill.originy"");
		addProp(m, FILL__SHAPEORIGINX, ""fill.shapeoriginx"");
		addProp(m, FILL__SHAPEORIGINY, ""fill.shapeoriginy"");
		addProp(m, FILL__SHADETYPE, ""fill.shadetype"");
		addProp(m, FILL__FILLED, ""fill.filled"");
		addProp(m, FILL__HITTESTFILL, ""fill.hittestfill"");
		addProp(m, FILL__SHAPE, ""fill.shape"");
		addProp(m, FILL__USERECT, ""fill.userect"");
		addProp(m, FILL__NOFILLHITTEST, ""fill.nofillhittest"", EscherPropertyMetaData.TYPE_BOOLEAN);
		addProp(m, LINESTYLE__COLOR, ""linestyle.color"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, LINESTYLE__OPACITY, ""linestyle.opacity"");
		addProp(m, LINESTYLE__BACKCOLOR, ""linestyle.backcolor"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, LINESTYLE__CRMOD, ""linestyle.crmod"");
		addProp(m, LINESTYLE__LINETYPE, ""linestyle.linetype"");
		addProp(m, LINESTYLE__FILLBLIP, ""linestyle.fillblip"");
		addProp(m, LINESTYLE__FILLBLIPNAME, ""linestyle.fillblipname"");
		addProp(m, LINESTYLE__FILLBLIPFLAGS, ""linestyle.fillblipflags"");
		addProp(m, LINESTYLE__FILLWIDTH, ""linestyle.fillwidth"");
		addProp(m, LINESTYLE__FILLHEIGHT, ""linestyle.fillheight"");
		addProp(m, LINESTYLE__FILLDZTYPE, ""linestyle.filldztype"");
		addProp(m, LINESTYLE__LINEWIDTH, ""linestyle.linewidth"");
		addProp(m, LINESTYLE__LINEMITERLIMIT, ""linestyle.linemiterlimit"");
		addProp(m, LINESTYLE__LINESTYLE, ""linestyle.linestyle"");
		addProp(m, LINESTYLE__LINEDASHING, ""linestyle.linedashing"");
		addProp(m, LINESTYLE__LINEDASHSTYLE, ""linestyle.linedashstyle"", EscherPropertyMetaData.TYPE_ARRAY);
		addProp(m, LINESTYLE__LINESTARTARROWHEAD, ""linestyle.linestartarrowhead"");
		addProp(m, LINESTYLE__LINEENDARROWHEAD, ""linestyle.lineendarrowhead"");
		addProp(m, LINESTYLE__LINESTARTARROWWIDTH, ""linestyle.linestartarrowwidth"");
		addProp(m, LINESTYLE__LINEESTARTARROWLENGTH, ""linestyle.lineestartarrowlength"");
		addProp(m, LINESTYLE__LINEENDARROWWIDTH, ""linestyle.lineendarrowwidth"");
		addProp(m, LINESTYLE__LINEENDARROWLENGTH, ""linestyle.lineendarrowlength"");
		addProp(m, LINESTYLE__LINEJOINSTYLE, ""linestyle.linejoinstyle"");
		addProp(m, LINESTYLE__LINEENDCAPSTYLE, ""linestyle.lineendcapstyle"");
		addProp(m, LINESTYLE__ARROWHEADSOK, ""linestyle.arrowheadsok"");
		addProp(m, LINESTYLE__ANYLINE, ""linestyle.anyline"");
		addProp(m, LINESTYLE__HITLINETEST, ""linestyle.hitlinetest"");
		addProp(m, LINESTYLE__LINEFILLSHAPE, ""linestyle.linefillshape"");
		addProp(m, LINESTYLE__NOLINEDRAWDASH, ""linestyle.nolinedrawdash"", EscherPropertyMetaData.TYPE_BOOLEAN);
		addProp(m, SHADOWSTYLE__TYPE, ""shadowstyle.type"");
		addProp(m, SHADOWSTYLE__COLOR, ""shadowstyle.color"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, SHADOWSTYLE__HIGHLIGHT, ""shadowstyle.highlight"");
		addProp(m, SHADOWSTYLE__CRMOD, ""shadowstyle.crmod"");
		addProp(m, SHADOWSTYLE__OPACITY, ""shadowstyle.opacity"");
		addProp(m, SHADOWSTYLE__OFFSETX, ""shadowstyle.offsetx"");
		addProp(m, SHADOWSTYLE__OFFSETY, ""shadowstyle.offsety"");
		addProp(m, SHADOWSTYLE__SECONDOFFSETX, ""shadowstyle.secondoffsetx"");
		addProp(m, SHADOWSTYLE__SECONDOFFSETY, ""shadowstyle.secondoffsety"");
		addProp(m, SHADOWSTYLE__SCALEXTOX, ""shadowstyle.scalextox"");
		addProp(m, SHADOWSTYLE__SCALEYTOX, ""shadowstyle.scaleytox"");
		addProp(m, SHADOWSTYLE__SCALEXTOY, ""shadowstyle.scalextoy"");
		addProp(m, SHADOWSTYLE__SCALEYTOY, ""shadowstyle.scaleytoy"");
		addProp(m, SHADOWSTYLE__PERSPECTIVEX, ""shadowstyle.perspectivex"");
		addProp(m, SHADOWSTYLE__PERSPECTIVEY, ""shadowstyle.perspectivey"");
		addProp(m, SHADOWSTYLE__WEIGHT, ""shadowstyle.weight"");
		addProp(m, SHADOWSTYLE__ORIGINX, ""shadowstyle.originx"");
		addProp(m, SHADOWSTYLE__ORIGINY, ""shadowstyle.originy"");
		addProp(m, SHADOWSTYLE__SHADOW, ""shadowstyle.shadow"");
		addProp(m, SHADOWSTYLE__SHADOWOBSURED, ""shadowstyle.shadowobsured"");
		addProp(m, PERSPECTIVE__TYPE, ""perspective.type"");
		addProp(m, PERSPECTIVE__OFFSETX, ""perspective.offsetx"");
		addProp(m, PERSPECTIVE__OFFSETY, ""perspective.offsety"");
		addProp(m, PERSPECTIVE__SCALEXTOX, ""perspective.scalextox"");
		addProp(m, PERSPECTIVE__SCALEYTOX, ""perspective.scaleytox"");
		addProp(m, PERSPECTIVE__SCALEXTOY, ""perspective.scalextoy"");
		addProp(m, PERSPECTIVE__SCALEYTOY, ""perspective.scaleytoy"");
		addProp(m, PERSPECTIVE__PERSPECTIVEX, ""perspective.perspectivex"");
		addProp(m, PERSPECTIVE__PERSPECTIVEY, ""perspective.perspectivey"");
		addProp(m, PERSPECTIVE__WEIGHT, ""perspective.weight"");
		addProp(m, PERSPECTIVE__ORIGINX, ""perspective.originx"");
		addProp(m, PERSPECTIVE__ORIGINY, ""perspective.originy"");
		addProp(m, PERSPECTIVE__PERSPECTIVEON, ""perspective.perspectiveon"");
		addProp(m, THREED__SPECULARAMOUNT, ""3d.specularamount"");
		addProp(m, THREED__DIFFUSEAMOUNT, ""3d.diffuseamount"");
		addProp(m, THREED__SHININESS, ""3d.shininess"");
		addProp(m, THREED__EDGETHICKNESS, ""3d.edgethickness"");
		addProp(m, THREED__EXTRUDEFORWARD, ""3d.extrudeforward"");
		addProp(m, THREED__EXTRUDEBACKWARD, ""3d.extrudebackward"");
		addProp(m, THREED__EXTRUDEPLANE, ""3d.extrudeplane"");
		addProp(m, THREED__EXTRUSIONCOLOR, ""3d.extrusioncolor"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, THREED__CRMOD, ""3d.crmod"");
		addProp(m, THREED__3DEFFECT, ""3d.3deffect"");
		addProp(m, THREED__METALLIC, ""3d.metallic"");
		addProp(m, THREED__USEEXTRUSIONCOLOR, ""3d.useextrusioncolor"", EscherPropertyMetaData.TYPE_RGB);
		addProp(m, THREED__LIGHTFACE, ""3d.lightface"");
		addProp(m, THREEDSTYLE__YROTATIONANGLE, ""3dstyle.yrotationangle"");
		addProp(m, THREEDSTYLE__XROTATIONANGLE, ""3dstyle.xrotationangle"");
		addProp(m, THREEDSTYLE__ROTATIONAXISX, ""3dstyle.rotationaxisx"");
		addProp(m, THREEDSTYLE__ROTATIONAXISY, ""3dstyle.rotationaxisy"");
		addProp(m, THREEDSTYLE__ROTATIONAXISZ, ""3dstyle.rotationaxisz"");
		addProp(m, THREEDSTYLE__ROTATIONANGLE, ""3dstyle.rotationangle"");
		addProp(m, THREEDSTYLE__ROTATIONCENTERX, ""3dstyle.rotationcenterx"");
		addProp(m, THREEDSTYLE__ROTATIONCENTERY, ""3dstyle.rotationcentery"");
		addProp(m, THREEDSTYLE__ROTATIONCENTERZ, ""3dstyle.rotationcenterz"");
		addProp(m, THREEDSTYLE__RENDERMODE, ""3dstyle.rendermode"");
		addProp(m, THREEDSTYLE__TOLERANCE, ""3dstyle.tolerance"");
		addProp(m, THREEDSTYLE__XVIEWPOINT, ""3dstyle.xviewpoint"");
		addProp(m, THREEDSTYLE__YVIEWPOINT, ""3dstyle.yviewpoint"");
		addProp(m, THREEDSTYLE__ZVIEWPOINT, ""3dstyle.zviewpoint"");
		addProp(m, THREEDSTYLE__ORIGINX, ""3dstyle.originx"");
		addProp(m, THREEDSTYLE__ORIGINY, ""3dstyle.originy"");
		addProp(m, THREEDSTYLE__SKEWANGLE, ""3dstyle.skewangle"");
		addProp(m, THREEDSTYLE__SKEWAMOUNT, ""3dstyle.skewamount"");
		addProp(m, THREEDSTYLE__AMBIENTINTENSITY, ""3dstyle.ambientintensity"");
		addProp(m, THREEDSTYLE__KEYX, ""3dstyle.keyx"");
		addProp(m, THREEDSTYLE__KEYY, ""3dstyle.keyy"");
		addProp(m, THREEDSTYLE__KEYZ, ""3dstyle.keyz"");
		addProp(m, THREEDSTYLE__KEYINTENSITY, ""3dstyle.keyintensity"");
		addProp(m, THREEDSTYLE__FILLX, ""3dstyle.fillx"");
		addProp(m, THREEDSTYLE__FILLY, ""3dstyle.filly"");
		addProp(m, THREEDSTYLE__FILLZ, ""3dstyle.fillz"");
		addProp(m, THREEDSTYLE__FILLINTENSITY, ""3dstyle.fillintensity"");
		addProp(m, THREEDSTYLE__CONSTRAINROTATION, ""3dstyle.constrainrotation"");
		addProp(m, THREEDSTYLE__ROTATIONCENTERAUTO, ""3dstyle.rotationcenterauto"");
		addProp(m, THREEDSTYLE__PARALLEL, ""3dstyle.parallel"");
		addProp(m, THREEDSTYLE__KEYHARSH, ""3dstyle.keyharsh"");
		addProp(m, THREEDSTYLE__FILLHARSH, ""3dstyle.fillharsh"");
		addProp(m, SHAPE__MASTER, ""shape.master"");
		addProp(m, SHAPE__CONNECTORSTYLE, ""shape.connectorstyle"");
		addProp(m, SHAPE__BLACKANDWHITESETTINGS, ""shape.blackandwhitesettings"");
		addProp(m, SHAPE__WMODEPUREBW, ""shape.wmodepurebw"");
		addProp(m, SHAPE__WMODEBW, ""shape.wmodebw"");
		addProp(m, SHAPE__OLEICON, ""shape.oleicon"");
		addProp(m, SHAPE__PREFERRELATIVERESIZE, ""shape.preferrelativeresize"");
		addProp(m, SHAPE__LOCKSHAPETYPE, ""shape.lockshapetype"");
		addProp(m, SHAPE__DELETEATTACHEDOBJECT, ""shape.deleteattachedobject"");
		addProp(m, SHAPE__BACKGROUNDSHAPE, ""shape.backgroundshape"");
		addProp(m, CALLOUT__CALLOUTTYPE, ""callout.callouttype"");
		addProp(m, CALLOUT__XYCALLOUTGAP, ""callout.xycalloutgap"");
		addProp(m, CALLOUT__CALLOUTANGLE, ""callout.calloutangle"");
		addProp(m, CALLOUT__CALLOUTDROPTYPE, ""callout.calloutdroptype"");
		addProp(m, CALLOUT__CALLOUTDROPSPECIFIED, ""callout.calloutdropspecified"");
		addProp(m, CALLOUT__CALLOUTLENGTHSPECIFIED, ""callout.calloutlengthspecified"");
		addProp(m, CALLOUT__ISCALLOUT, ""callout.iscallout"");
		addProp(m, CALLOUT__CALLOUTACCENTBAR, ""callout.calloutaccentbar"");
		addProp(m, CALLOUT__CALLOUTTEXTBORDER, ""callout.callouttextborder"");
		addProp(m, CALLOUT__CALLOUTMINUSX, ""callout.calloutminusx"");
		addProp(m, CALLOUT__CALLOUTMINUSY, ""callout.calloutminusy"");
		addProp(m, CALLOUT__DROPAUTO, ""callout.dropauto"");
		addProp(m, CALLOUT__LENGTHSPECIFIED, ""callout.lengthspecified"");
		addProp(m, GROUPSHAPE__SHAPENAME, ""groupshape.shapename"");
		addProp(m, GROUPSHAPE__DESCRIPTION, ""groupshape.description"");
		addProp(m, GROUPSHAPE__HYPERLINK, ""groupshape.hyperlink"");
		addProp(m, GROUPSHAPE__WRAPPOLYGONVERTICES, ""groupshape.wrappolygonvertices"", EscherPropertyMetaData.TYPE_ARRAY);
		addProp(m, GROUPSHAPE__WRAPDISTLEFT, ""groupshape.wrapdistleft"");
		addProp(m, GROUPSHAPE__WRAPDISTTOP, ""groupshape.wrapdisttop"");
		addProp(m, GROUPSHAPE__WRAPDISTRIGHT, ""groupshape.wrapdistright"");
		addProp(m, GROUPSHAPE__WRAPDISTBOTTOM, ""groupshape.wrapdistbottom"");
		addProp(m, GROUPSHAPE__REGROUPID, ""groupshape.regroupid"");
        addProp( m, GROUPSHAPE__UNUSED906, ""unused906"" ); 
        addProp( m, GROUPSHAPE__TOOLTIP, ""groupshape.wzTooltip"" ); 
        addProp( m, GROUPSHAPE__SCRIPT, ""groupshape.wzScript"" ); 
        addProp( m, GROUPSHAPE__POSH, ""groupshape.posh"" ); 
        addProp( m, GROUPSHAPE__POSRELH, ""groupshape.posrelh"" ); 
        addProp( m, GROUPSHAPE__POSV, ""groupshape.posv"" ); 
        addProp( m, GROUPSHAPE__POSRELV, ""groupshape.posrelv"" ); 
        addProp( m, GROUPSHAPE__HR_PCT, ""groupshape.pctHR"" ); 
        addProp( m, GROUPSHAPE__HR_ALIGN, ""groupshape.alignHR"" ); 
        addProp( m, GROUPSHAPE__HR_HEIGHT, ""groupshape.dxHeightHR"" ); 
        addProp( m, GROUPSHAPE__HR_WIDTH, ""groupshape.dxWidthHR"" ); 
        addProp( m, GROUPSHAPE__SCRIPTEXT, ""groupshape.wzScriptExtAttr"" ); 
        addProp( m, GROUPSHAPE__SCRIPTLANG, ""groupshape.scriptLang"" ); 
        addProp( m, GROUPSHAPE__BORDERTOPCOLOR, ""groupshape.borderTopColor"" ); 
        addProp( m, GROUPSHAPE__BORDERLEFTCOLOR, ""groupshape.borderLeftColor"" ); 
        addProp( m, GROUPSHAPE__BORDERBOTTOMCOLOR, ""groupshape.borderBottomColor"" ); 
        addProp( m, GROUPSHAPE__BORDERRIGHTCOLOR, ""groupshape.borderRightColor"" ); 
        addProp( m, GROUPSHAPE__TABLEPROPERTIES, ""groupshape.tableProperties"" ); 
        addProp( m, GROUPSHAPE__TABLEROWPROPERTIES, ""groupshape.tableRowProperties"" ); 
        addProp( m, GROUPSHAPE__WEBBOT, ""groupshape.wzWebBot"" ); 
        addProp( m, GROUPSHAPE__METROBLOB, ""groupshape.metroBlob"" ); 
        addProp( m, GROUPSHAPE__ZORDER, ""groupshape.dhgt"" ); 
        addProp( m, GROUPSHAPE__FLAGS, ""groupshape.GroupShapeBooleanProperties"" ); 

		addProp(m, GROUPSHAPE__EDITEDWRAP, ""groupshape.editedwrap"");
		addProp(m, GROUPSHAPE__BEHINDDOCUMENT, ""groupshape.behinddocument"");
		addProp(m, GROUPSHAPE__ONDBLCLICKNOTIFY, ""groupshape.ondblclicknotify"");
		addProp(m, GROUPSHAPE__ISBUTTON, ""groupshape.isbutton"");
		addProp(m, GROUPSHAPE__1DADJUSTMENT, ""groupshape.1dadjustment"");
		addProp(m, GROUPSHAPE__HIDDEN, ""groupshape.hidden"");
		addProp(m, GROUPSHAPE__PRINT, ""groupshape.print"", EscherPropertyMetaData.TYPE_BOOLEAN);
		return m;
	}

	private static void addProp(Map<Short, EscherPropertyMetaData> m, int s, String propName) {
		m.put(Short.valueOf((short) s), new EscherPropertyMetaData(propName));
	}

	private static void addProp(Map<Short, EscherPropertyMetaData> m, int s, String propName, byte type) {
		m.put(Short.valueOf((short) s), new EscherPropertyMetaData(propName, type));
	}

	public static String getPropertyName(short propertyId) {
		EscherPropertyMetaData o = properties.get(Short.valueOf(propertyId));
		return o == null ? ""unknown"" : o.getDescription();
	}

	public static byte getPropertyType(short propertyId) {
		EscherPropertyMetaData escherPropertyMetaData = properties.get(Short.valueOf(propertyId));
		return escherPropertyMetaData == null ? 0 : escherPropertyMetaData.getType();
	}
}
"
poi,3,org.apache.poi.ddf.EscherComplexProperty,9,2,1,6,32,0,2,4,9,0.125,172,0.0,0,0.533333333,0.351851852,1,1,18.0,4,1.1111,1,"

package org.apache.poi.ddf;

import java.util.Arrays;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public class EscherComplexProperty extends EscherProperty {
    
    protected byte[] _complexData;

    
    public EscherComplexProperty(short id, byte[] complexData) {
        super(id);
        _complexData = complexData;
    }

    
    public EscherComplexProperty(short propertyNumber, boolean isBlipId, byte[] complexData) {
        super(propertyNumber, true, isBlipId);
        _complexData = complexData;
    }

    
    public int serializeSimplePart(byte[] data, int pos) {
        LittleEndian.putShort(data, pos, getId());
        LittleEndian.putInt(data, pos + 2, _complexData.length);
        return 6;
    }

    
    public int serializeComplexPart(byte[] data, int pos) {
        System.arraycopy(_complexData, 0, data, pos, _complexData.length);
        return _complexData.length;
    }

    
    public byte[] getComplexData() {
        return _complexData;
    }

    
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof EscherComplexProperty)) {
            return false;
        }

        EscherComplexProperty escherComplexProperty = (EscherComplexProperty) o;

        if ( !Arrays.equals( _complexData, escherComplexProperty._complexData ) ) return false;

        return true;
    }

    
    public int getPropertySize() {
        return 6 + _complexData.length;
    }

    public int hashCode() {
        return getId() * 11;
    }

    
    public String toString() {
        String dataStr = HexDump.toHex( _complexData, 32);

        return ""propNum: "" + getPropertyNumber()
                + "", propName: "" + EscherProperties.getPropertyName( getPropertyNumber() )
                + "", complex: "" + isComplex()
                + "", blipId: "" + isBlipId()
                + "", data: "" + System.getProperty(""line.separator"") + dataStr;
    }

    public String toXml(String tab){
        String dataStr = HexDump.toHex( _complexData, 32);
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("" id=""0x"").append(HexDump.toHex(getId()))
                .append("""" name="""").append(getName()).append("""" blipId="""")
                .append(isBlipId()).append("""">
"");
        
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.util.POILogger,26,1,3,11,42,325,10,1,22,1.04,693,0.0,0,0.0,0.544871795,0,0,25.46153846,10,1.9615,1,"

package org.apache.poi.util;

import java.util.ArrayList;
import java.util.List;


@Internal
public abstract class POILogger {

    public static final int DEBUG = 1;
    public static final int INFO  = 3;
    public static final int WARN  = 5;
    public static final int ERROR = 7;
    public static final int FATAL = 9;

    
    protected static final String LEVEL_STRINGS_SHORT[] = {""?"", ""D"", ""?"", ""I"", ""?"", ""W"", ""?"", ""E"", ""?"", ""F"", ""?""};
    
    protected static final String LEVEL_STRINGS[] = {""?0?"", ""DEBUG"", ""?2?"", ""INFO"", ""?4?"", ""WARN"", ""?6?"", ""ERROR"", ""?8?"", ""FATAL"", ""?10+?""};


    
    POILogger() {
        
    }

    abstract public void initialize(String cat);

    
    abstract protected void log(int level, Object obj1);

    
    abstract protected void log(int level, Object obj1, final Throwable exception);


    
    abstract public boolean check(int level);

   
    public void log(int level, Object... objs) {
        if (!check(level)) return;
        StringBuilder sb = new StringBuilder(32);
        Throwable lastEx = null;
        for (int i=0; i<objs.length; i++) {
            if (i == objs.length-1 && objs[i] instanceof Throwable) {
                lastEx = (Throwable)objs[i];
            } else {
                sb.append(objs[i]);
            }
        }
        
        String msg = sb.toString();
        msg = msg.replaceAll(""[
]+"", "" "");  
        
        
        
        if (lastEx == null) {
            log(level, msg);
        } else {
            log(level, msg, lastEx);
        }
    }

    
    public void logFormatted(int level, String message, Object... unflatParams) {
        if (!check(level)) return;
        Object[] params = flattenArrays(unflatParams);
        String msg = StringUtil.format(message, params);
        msg = msg.replaceAll(""[
]+"", "" ""); 

        if (params.length > 0 && params[params.length-1] instanceof Throwable) {
            log(level, msg, (Throwable)params[params.length-1]);
        } else {
            log(level, msg);
        }
    }

    
    private Object[] flattenArrays(Object... unflatParams) {
        List<Object> results = new ArrayList<Object>();
        for (Object obj : unflatParams) {
            flattenObject(results, obj);
        }
        return results.toArray(new Object[results.size()]);
    }

    private void flattenObject(List<Object> results, Object object) {
        if (object instanceof byte[]) {
            for (byte b : (byte[])object) {
                results.add(Byte.valueOf(b));
            }
        } else if (object instanceof char[]) {
            for (char c : (char[])object) {
                results.add(Character.valueOf(c));
            }
        } else if (object instanceof short[]) {
            for (short s : (short[])object) {
                results.add(Short.valueOf(s));
            }
        } else if (object instanceof int[]) {
            for (int i : (int[])object) {
                results.add(Integer.valueOf(i));
            }
        } else if (object instanceof long[]) {
            for (long l : (long[])object) {
                results.add(Long.valueOf(l));
            }
        } else if (object instanceof float[]) {
            for (float f : (float[])object) {
                results.add(Float.valueOf(f));
            }
        } else if (object instanceof double[]) {
            for (double d : (double[])object) {
                results.add(Double.valueOf(d));
            }
        } else if (object instanceof Object[]) {
            for (Object o : (Object[])object) {
                results.add(o);
            }
        } else {
            results.add(object);
        }
    }
}
"
poi,3,org.apache.poi.ddf.EscherRGBProperty,5,3,0,4,6,0,3,1,5,2.0,35,0.0,0,0.777777778,0.466666667,0,0,6.0,1,0.8,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;


public class EscherRGBProperty
        extends EscherSimpleProperty
{

    public EscherRGBProperty( short propertyNumber, int rgbColor )
    {
        super( propertyNumber, rgbColor );
    }

    public int getRgbColor()
    {
        return propertyValue;
    }

    public byte getRed()
    {
        return (byte) ( propertyValue & 0xFF );
    }

    public byte getGreen()
    {
        return (byte) ( (propertyValue >> 8) & 0xFF );
    }

    public byte getBlue()
    {
        return (byte) ( (propertyValue >> 16) & 0xFF );
    }

    public String toXml(String tab){
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("" id=""0x"").append(HexDump.toHex(getId()))
                .append("""" name="""").append(getName()).append("""" blipId="""")
                .append(isBlipId()).append("""" value=""0x"").append(HexDump.toHex(propertyValue)).append(""""/>
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.hssf.util.HSSFColor,6,1,49,51,56,15,51,46,6,1.2,923,1.0,0,0.0,0.666666667,0,0,152.5,1,0.8333,0,"

package org.apache.poi.hssf.util;

import java.lang.reflect.Field;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Map;

import org.apache.poi.ss.usermodel.Color;



public class HSSFColor implements Color {
    private static Map<Integer,HSSFColor> indexHash; 

    
    public HSSFColor()
    {
    }

    
    public final static Map<Integer,HSSFColor> getIndexHash() {
        if(indexHash == null) {
           indexHash = Collections.unmodifiableMap( createColorsByIndexMap() );
        }

        return indexHash;
    }
    
    public final static Hashtable<Integer,HSSFColor> getMutableIndexHash() {
       return createColorsByIndexMap();
    }

    private static Hashtable<Integer,HSSFColor> createColorsByIndexMap() {
        HSSFColor[] colors = getAllColors();
        Hashtable<Integer,HSSFColor> result = new Hashtable<Integer,HSSFColor>(colors.length * 3 / 2);

        for (int i = 0; i < colors.length; i++) {
            HSSFColor color = colors[i];

            Integer index1 = Integer.valueOf(color.getIndex());
            if (result.containsKey(index1)) {
                HSSFColor prevColor = result.get(index1);
                throw new RuntimeException(""Dup color index ("" + index1
                        + "") for colors ("" + prevColor.getClass().getName()
                        + ""),("" + color.getClass().getName() + "")"");
            }
            result.put(index1, color);
        }

        for (int i = 0; i < colors.length; i++) {
            HSSFColor color = colors[i];
            Integer index2 = getIndex2(color);
            if (index2 == null) {
                
                continue;
            }
            if (result.containsKey(index2)) {
                if (false) { 
                    HSSFColor prevColor = (HSSFColor)result.get(index2);
                    throw new RuntimeException(""Dup color index ("" + index2
                            + "") for colors ("" + prevColor.getClass().getName()
                            + ""),("" + color.getClass().getName() + "")"");
                }
            }
            result.put(index2, color);
        }
        return result;
    }

    private static Integer getIndex2(HSSFColor color) {

        Field f;
        try {
            f = color.getClass().getDeclaredField(""index2"");
        } catch (NoSuchFieldException e) {
            
            return null;
        }

        Short s;
        try {
            s = (Short) f.get(color);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        return Integer.valueOf(s.intValue());
    }

    private static HSSFColor[] getAllColors() {

        return new HSSFColor[] {
                new BLACK(), new BROWN(), new OLIVE_GREEN(), new DARK_GREEN(),
                new DARK_TEAL(), new DARK_BLUE(), new INDIGO(), new GREY_80_PERCENT(),
                new ORANGE(), new DARK_YELLOW(), new GREEN(), new TEAL(), new BLUE(),
                new BLUE_GREY(), new GREY_50_PERCENT(), new RED(), new LIGHT_ORANGE(), new LIME(),
                new SEA_GREEN(), new AQUA(), new LIGHT_BLUE(), new VIOLET(), new GREY_40_PERCENT(),
                new PINK(), new GOLD(), new YELLOW(), new BRIGHT_GREEN(), new TURQUOISE(),
                new DARK_RED(), new SKY_BLUE(), new PLUM(), new GREY_25_PERCENT(), new ROSE(),
                new LIGHT_YELLOW(), new LIGHT_GREEN(), new LIGHT_TURQUOISE(), new PALE_BLUE(),
                new LAVENDER(), new WHITE(), new CORNFLOWER_BLUE(), new LEMON_CHIFFON(),
                new MAROON(), new ORCHID(), new CORAL(), new ROYAL_BLUE(),
                new LIGHT_CORNFLOWER_BLUE(), new TAN(),
        };
    }

    
    public final static Hashtable<String,HSSFColor> getTripletHash()
    {
        return createColorsByHexStringMap();
    }

    private static Hashtable<String,HSSFColor> createColorsByHexStringMap() {
        HSSFColor[] colors = getAllColors();
        Hashtable<String,HSSFColor> result = new Hashtable<String,HSSFColor>(colors.length * 3 / 2);

        for (int i = 0; i < colors.length; i++) {
            HSSFColor color = colors[i];

            String hexString = color.getHexString();
            if (result.containsKey(hexString)) {
            	HSSFColor other = result.get(hexString);
                throw new RuntimeException(
                		""Dup color hexString ("" + hexString
                        + "") for color ("" + color.getClass().getName() + "") - ""
                        + "" already taken by ("" + other.getClass().getName() + "")""
                );
            }
            result.put(hexString, color);
        }
        return result;
    }

    

    public short getIndex()
    {
        return BLACK.index;
    }

    

    public short [] getTriplet()
    {
        return BLACK.triplet;
    }

    

    

    public String getHexString()
    {
        return BLACK.hexString;
    }
    
    public static HSSFColor toHSSFColor(Color color) {
        if (color != null && !(color instanceof HSSFColor)) {
            throw new IllegalArgumentException(""Only HSSFColor objects are supported"");
        }
        return (HSSFColor)color;
    }

    

    public final static class BLACK
        extends HSSFColor
    {
        public final static short   index     = 0x8;
        public final static short[] triplet   =
        {
            0, 0, 0
        };
        public final static String  hexString = ""0:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BROWN
        extends HSSFColor
    {
        public final static short   index     = 0x3c;
        public final static short[] triplet   =
        {
            153, 51, 0
        };
        public final static String  hexString = ""9999:3333:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public static class OLIVE_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x3b;
        public final static short[] triplet   =
        {
            51, 51, 0
        };
        public final static String  hexString = ""3333:3333:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x3a;
        public final static short[] triplet   =
        {
            0, 51, 0
        };
        public final static String  hexString = ""0:3333:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_TEAL
        extends HSSFColor
    {
        public final static short   index     = 0x38;
        public final static short[] triplet   =
        {
            0, 51, 102
        };
        public final static String  hexString = ""0:3333:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x12;
        public final static short   index2    = 0x20;
        public final static short[] triplet   =
        {
            0, 0, 128
        };
        public final static String  hexString = ""0:0:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class INDIGO
        extends HSSFColor
    {
        public final static short   index     = 0x3e;
        public final static short[] triplet   =
        {
            51, 51, 153
        };
        public final static String  hexString = ""3333:3333:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_80_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x3f;
        public final static short[] triplet   =
        {
            51, 51, 51
        };
        public final static String  hexString = ""3333:3333:3333"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_RED
        extends HSSFColor
    {
        public final static short   index     = 0x10;
        public final static short   index2    = 0x25;
        public final static short[] triplet   =
        {
            128, 0, 0
        };
        public final static String  hexString = ""8080:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class ORANGE
        extends HSSFColor
    {
        public final static short   index     = 0x35;
        public final static short[] triplet   =
        {
            255, 102, 0
        };
        public final static String  hexString = ""FFFF:6666:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class DARK_YELLOW
        extends HSSFColor
    {
        public final static short   index     = 0x13;
        public final static short[] triplet   =
        {
            128, 128, 0
        };
        public final static String  hexString = ""8080:8080:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x11;
        public final static short[] triplet   =
        {
            0, 128, 0
        };
        public final static String  hexString = ""0:8080:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class TEAL
        extends HSSFColor
    {
        public final static short   index     = 0x15;
        public final static short   index2    = 0x26;
        public final static short[] triplet   =
        {
            0, 128, 128
        };
        public final static String  hexString = ""0:8080:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BLUE
        extends HSSFColor
    {
        public final static short   index     = 0xc;
        public final static short   index2    = 0x27;
        public final static short[] triplet   =
        {
            0, 0, 255
        };
        public final static String  hexString = ""0:0:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BLUE_GREY
        extends HSSFColor
    {
        public final static short   index     = 0x36;
        public final static short[] triplet   =
        {
            102, 102, 153
        };
        public final static String  hexString = ""6666:6666:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_50_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x17;
        public final static short[] triplet   =
        {
            128, 128, 128
        };
        public final static String  hexString = ""8080:8080:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class RED
        extends HSSFColor
    {
        public final static short   index     = 0xa;
        public final static short[] triplet   =
        {
            255, 0, 0
        };
        public final static String  hexString = ""FFFF:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_ORANGE
        extends HSSFColor
    {
        public final static short   index     = 0x34;
        public final static short[] triplet   =
        {
            255, 153, 0
        };
        public final static String  hexString = ""FFFF:9999:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIME
        extends HSSFColor
    {
        public final static short   index     = 0x32;
        public final static short[] triplet   =
        {
            153, 204, 0
        };
        public final static String  hexString = ""9999:CCCC:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class SEA_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x39;
        public final static short[] triplet   =
        {
            51, 153, 102
        };
        public final static String  hexString = ""3333:9999:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class AQUA
        extends HSSFColor
    {
        public final static short   index     = 0x31;
        public final static short[] triplet   =
        {
            51, 204, 204
        };
        public final static String  hexString = ""3333:CCCC:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x30;
        public final static short[] triplet   =
        {
            51, 102, 255
        };
        public final static String  hexString = ""3333:6666:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class VIOLET
        extends HSSFColor
    {
        public final static short   index     = 0x14;
        public final static short   index2    = 0x24;
        public final static short[] triplet   =
        {
            128, 0, 128
        };
        public final static String  hexString = ""8080:0:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_40_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x37;
        public final static short[] triplet   =
        {
            150, 150, 150
        };
        public final static String  hexString = ""9696:9696:9696"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class PINK
        extends HSSFColor
    {
        public final static short   index     = 0xe;
        public final static short   index2    = 0x21;
        public final static short[] triplet   =
        {
            255, 0, 255
        };
        public final static String  hexString = ""FFFF:0:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GOLD
        extends HSSFColor
    {
        public final static short   index     = 0x33;
        public final static short[] triplet   =
        {
            255, 204, 0
        };
        public final static String  hexString = ""FFFF:CCCC:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class YELLOW
        extends HSSFColor
    {
        public final static short   index     = 0xd;
        public final static short   index2    = 0x22;
        public final static short[] triplet   =
        {
            255, 255, 0
        };
        public final static String  hexString = ""FFFF:FFFF:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class BRIGHT_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0xb;
        public final static short   index2    = 0x23;
        public final static short[] triplet   =
        {
            0, 255, 0
        };
        public final static String  hexString = ""0:FFFF:0"";

        public short getIndex()
        {
            return index;
        }

        public String getHexString()
        {
            return hexString;
        }

        public short [] getTriplet()
        {
            return triplet;
        }
    }

    

    public final static class TURQUOISE
        extends HSSFColor
    {
        public final static short   index     = 0xf;
        public final static short   index2    = 0x23;
        public final static short[] triplet   =
        {
            0, 255, 255
        };
        public final static String  hexString = ""0:FFFF:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class SKY_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x28;
        public final static short[] triplet   =
        {
            0, 204, 255
        };
        public final static String  hexString = ""0:CCCC:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class PLUM
        extends HSSFColor
    {
        public final static short   index     = 0x3d;
        public final static short   index2    = 0x19;
        public final static short[] triplet   =
        {
            153, 51, 102
        };
        public final static String  hexString = ""9999:3333:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class GREY_25_PERCENT
        extends HSSFColor
    {
        public final static short   index     = 0x16;
        public final static short[] triplet   =
        {
            192, 192, 192
        };
        public final static String  hexString = ""C0C0:C0C0:C0C0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class ROSE
        extends HSSFColor
    {
        public final static short   index     = 0x2d;
        public final static short[] triplet   =
        {
            255, 153, 204
        };
        public final static String  hexString = ""FFFF:9999:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class TAN
        extends HSSFColor
    {
        public final static short   index     = 0x2f;
        public final static short[] triplet   =
        {
            255, 204, 153
        };
        public final static String  hexString = ""FFFF:CCCC:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_YELLOW
        extends HSSFColor
    {
        public final static short   index     = 0x2b;
        public final static short[] triplet   =
        {
            255, 255, 153
        };
        public final static String  hexString = ""FFFF:FFFF:9999"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_GREEN
        extends HSSFColor
    {
        public final static short   index     = 0x2a;
        public final static short[] triplet   =
        {
            204, 255, 204
        };
        public final static String  hexString = ""CCCC:FFFF:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LIGHT_TURQUOISE
        extends HSSFColor
    {
        public final static short   index     = 0x29;
        public final static short   index2    = 0x1b;
        public final static short[] triplet   =
        {
            204, 255, 255
        };
        public final static String  hexString = ""CCCC:FFFF:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class PALE_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x2c;
        public final static short[] triplet   =
        {
            153, 204, 255
        };
        public final static String  hexString = ""9999:CCCC:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class LAVENDER
        extends HSSFColor
    {
        public final static short   index     = 0x2e;
        public final static short[] triplet   =
        {
            204, 153, 255
        };
        public final static String  hexString = ""CCCC:9999:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    

    public final static class WHITE
        extends HSSFColor
    {
        public final static short   index     = 0x9;
        public final static short[] triplet   =
        {
            255, 255, 255
        };
        public final static String  hexString = ""FFFF:FFFF:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class CORNFLOWER_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x18;
        public final static short[] triplet   =
        {
            153, 153, 255
        };
        public final static String  hexString = ""9999:9999:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }


    
    public final static class LEMON_CHIFFON
        extends HSSFColor
    {
        public final static short   index     = 0x1a;
        public final static short[] triplet   =
        {
            255, 255, 204
        };
        public final static String  hexString = ""FFFF:FFFF:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class MAROON
        extends HSSFColor
    {
        public final static short   index     = 0x19;
        public final static short[] triplet   =
        {
            127, 0, 0
        };
        public final static String  hexString = ""8000:0:0"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class ORCHID
        extends HSSFColor
    {
        public final static short   index     = 0x1c;
        public final static short[] triplet   =
        {
            102, 0, 102
        };
        public final static String  hexString = ""6666:0:6666"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class CORAL
        extends HSSFColor
    {
        public final static short   index     = 0x1d;
        public final static short[] triplet   =
        {
            255, 128, 128
        };
        public final static String  hexString = ""FFFF:8080:8080"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class ROYAL_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x1e;
        public final static short[] triplet   =
        {
            0, 102, 204
        };
        public final static String  hexString = ""0:6666:CCCC"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class LIGHT_CORNFLOWER_BLUE
        extends HSSFColor
    {
        public final static short   index     = 0x1f;
        public final static short[] triplet   =
        {
            204, 204, 255
        };
        public final static String  hexString = ""CCCC:CCCC:FFFF"";

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return triplet;
        }

        public String getHexString()
        {
            return hexString;
        }
    }

    
    public final static class AUTOMATIC extends HSSFColor
    {
        private static HSSFColor instance = new AUTOMATIC();

        public final static short   index     = 0x40;

        public short getIndex()
        {
            return index;
        }

        public short [] getTriplet()
        {
            return BLACK.triplet;
        }

        public String getHexString()
        {
            return BLACK.hexString;
        }

        public static HSSFColor getInstance() {
          return instance;
        }
    }
}
"
poi,3,org.apache.poi.util.IOUtils,3,1,0,3,5,3,3,0,2,2.0,43,0.0,0,0.0,0.5,0,0,13.33333333,1,0.6667,3,"

package org.apache.poi.util;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import org.apache.poi.EmptyFileException;

public final class IOUtils {
    private static final POILogger logger = POILogFactory.getLogger( IOUtils.class );

    private IOUtils() {
        
    }

    
    public static byte[] peekFirst8Bytes(InputStream stream) throws IOException, EmptyFileException {
        
        stream.mark(8);

        byte[] header = new byte[8];
        int read = IOUtils.readFully(stream, header);

        if (read < 1)
            throw new EmptyFileException();

        
        if(stream instanceof PushbackInputStream) {
            PushbackInputStream pin = (PushbackInputStream)stream;
            pin.unread(header);
        } else {
            stream.reset();
        }

        return header;
    }

    
    public static byte[] toByteArray(InputStream stream) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        byte[] buffer = new byte[4096];
        int read = 0;
        while (read != -1) {
            read = stream.read(buffer);
            if (read > 0) {
                baos.write(buffer, 0, read);
            }
        }

        return baos.toByteArray();
    }

    
    public static byte[] toByteArray(ByteBuffer buffer, int length) {
        if(buffer.hasArray() && buffer.arrayOffset() == 0) {
            
            return buffer.array();
        }

        byte[] data = new byte[length];
        buffer.get(data);
        return data;
    }

    
    public static int readFully(InputStream in, byte[] b) throws IOException {
        return readFully(in, b, 0, b.length);
    }

    
    public static int readFully(InputStream in, byte[] b, int off, int len) throws IOException {
        int total = 0;
        while (true) {
            int got = in.read(b, off + total, len - total);
            if (got < 0) {
                return (total == 0) ? -1 : total;
            }
            total += got;
            if (total == len) {
                return total;
            }
        }
    }

    
    public static int readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {
        int total = 0;
        while (true) {
            int got = channel.read(b);
            if (got < 0) {
                return (total == 0) ? -1 : total;
            }
            total += got;
            if (total == b.capacity() || b.position() == b.capacity()) {
                return total;
            }
        }
    }

    
    public static void copy(InputStream inp, OutputStream out) throws IOException {
        byte[] buff = new byte[4096];
        int count;
        while ((count = inp.read(buff)) != -1) {
            if (count > 0) {
                out.write(buff, 0, count);
            }
        }
    }

    public static long calculateChecksum(byte[] data) {
        Checksum sum = new CRC32();
        sum.update(data, 0, data.length);
        return sum.getValue();
    }

    
    public static void closeQuietly( final Closeable closeable ) {
        try {
            closeable.close();
        } catch ( Exception exc ) {
            logger.log( POILogger.ERROR, ""Unable to close resource: "" + exc,
                    exc );
        }
    }
}
"
poi,3,org.apache.poi.poifs.storage.RawDataBlock,3,1,0,7,10,0,5,2,3,0.25,83,1.0,0,0.0,0.666666667,0,0,26.0,1,0.6667,1,"

        

package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;

import java.io.*;



public class RawDataBlock
    implements ListManagedBlock
{
    private byte[]  _data;
    private boolean _eof;
    private boolean _hasData;
    private static POILogger log = POILogFactory.getLogger(RawDataBlock.class);

    
    public RawDataBlock(final InputStream stream)
    		throws IOException {
    	this(stream, POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
    }
    
    public RawDataBlock(final InputStream stream, int blockSize)
    		throws IOException {
        _data = new byte[ blockSize ];
        int count = IOUtils.readFully(stream, _data);
        _hasData = (count > 0);

        if (count == -1) {
            _eof = true;
        }
        else if (count != blockSize) {
        	
        	
        	
            _eof = true;
            String type = "" byte"" + ((count == 1) ? ("""")
                                                  : (""s""));

            log.log(POILogger.ERROR,
            		""Unable to read entire block; "" + count
                     + type + "" read before EOF; expected ""
                     + blockSize + "" bytes. Your document ""
                     + ""was either written by software that ""
                     + ""ignores the spec, or has been truncated!""
            );
        }
        else {
            _eof = false;
        }
    }

    
    public boolean eof() {
        return _eof;
    }
    
    public boolean hasData() {
    	return _hasData;
    }
    
    public String toString() {
       return ""RawDataBlock of size "" + _data.length; 
    }

    

    
    public byte [] getData()
        throws IOException
    {
        if (! hasData())
        {
            throw new IOException(""Cannot return empty data"");
        }
        return _data;
    }
    
    
    public int getBigBlockSize() {
       return _data.length;
    }

    
}   

"
poi,3,org.apache.poi.ddf.EscherSpRecord,12,2,0,13,34,32,8,5,11,1.034090909,323,0.125,0,0.633333333,0.35,1,5,24.58333333,14,2.0,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public class EscherSpRecord
    extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF00A;
    public static final String RECORD_DESCRIPTION = ""MsofbtSp"";

    public static final int FLAG_GROUP = 0x0001;
    public static final int FLAG_CHILD = 0x0002;
    public static final int FLAG_PATRIARCH = 0x0004;
    public static final int FLAG_DELETED = 0x0008;
    public static final int FLAG_OLESHAPE = 0x0010;
    public static final int FLAG_HAVEMASTER = 0x0020;
    public static final int FLAG_FLIPHORIZ = 0x0040;
    public static final int FLAG_FLIPVERT = 0x0080;
    public static final int FLAG_CONNECTOR = 0x0100;
    public static final int FLAG_HAVEANCHOR = 0x0200;
    public static final int FLAG_BACKGROUND = 0x0400;
    public static final int FLAG_HASSHAPETYPE = 0x0800;

    private int field_1_shapeId;
    private int field_2_flags;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
         readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;
        field_1_shapeId    =  LittleEndian.getInt( data, pos + size );     size += 4;
        field_2_flags      =  LittleEndian.getInt( data, pos + size );     size += 4;



        return getRecordSize();
    }

    
    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {
        listener.beforeRecordSerialize( offset, getRecordId(), this );
        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );
        int remainingBytes = 8;
        LittleEndian.putInt( data, offset + 4, remainingBytes );
        LittleEndian.putInt( data, offset + 8, field_1_shapeId );
        LittleEndian.putInt( data, offset + 12, field_2_flags );


        listener.afterRecordSerialize( offset + getRecordSize(), getRecordId(), getRecordSize(), this );
        return 8 + 8;
    }

    public int getRecordSize()
    {
        return 8 + 8;
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""Sp"";
    }


    
    public String toString()
    {
        String nl = System.getProperty(""line.separator"");

        return getClass().getName() + "":"" + nl +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + nl +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + nl +
                ""  ShapeType: 0x"" + HexDump.toHex(getShapeType()) + nl +
                ""  ShapeId: "" + field_1_shapeId + nl +
                ""  Flags: "" + decodeFlags(field_2_flags) + "" (0x"" + HexDump.toHex(field_2_flags) + "")"" + nl;

    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<ShapeType>0x"").append(HexDump.toHex(getShapeType())).append(""</ShapeType>
"")
                .append(tab).append(""	"").append(""<ShapeId>"").append(field_1_shapeId).append(""</ShapeId>
"")
                .append(tab).append(""	"").append(""<Flags>"").append(decodeFlags(field_2_flags) + "" (0x"" + HexDump.toHex(field_2_flags) + "")"").append(""</Flags>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    private String decodeFlags( int flags )
    {
        StringBuffer result = new StringBuffer();
        result.append( ( flags & FLAG_GROUP ) != 0 ? ""|GROUP"" : """" );
        result.append( ( flags & FLAG_CHILD ) != 0 ? ""|CHILD"" : """" );
        result.append( ( flags & FLAG_PATRIARCH ) != 0 ? ""|PATRIARCH"" : """" );
        result.append( ( flags & FLAG_DELETED ) != 0 ? ""|DELETED"" : """" );
        result.append( ( flags & FLAG_OLESHAPE ) != 0 ? ""|OLESHAPE"" : """" );
        result.append( ( flags & FLAG_HAVEMASTER ) != 0 ? ""|HAVEMASTER"" : """" );
        result.append( ( flags & FLAG_FLIPHORIZ ) != 0 ? ""|FLIPHORIZ"" : """" );
        result.append( ( flags & FLAG_FLIPVERT ) != 0 ? ""|FLIPVERT"" : """" );
        result.append( ( flags & FLAG_CONNECTOR ) != 0 ? ""|CONNECTOR"" : """" );
        result.append( ( flags & FLAG_HAVEANCHOR ) != 0 ? ""|HAVEANCHOR"" : """" );
        result.append( ( flags & FLAG_BACKGROUND ) != 0 ? ""|BACKGROUND"" : """" );
        result.append( ( flags & FLAG_HASSHAPETYPE ) != 0 ? ""|HASSHAPETYPE"" : """" );

        
        if(result.length() > 0) {
            result.deleteCharAt(0);
        }
        return result.toString();
    }

    
    public int getShapeId()
    {
        return field_1_shapeId;
    }

    
    public void setShapeId( int field_1_shapeId )
    {
        this.field_1_shapeId = field_1_shapeId;
    }

    
    public int getFlags()
    {
        return field_2_flags;
    }

    
    public void setFlags( int field_2_flags )
    {
        this.field_2_flags = field_2_flags;
    }

    
    public short getShapeType()
    {
        return getInstance();
    }

    
    public void setShapeType( short value )
    {
        setInstance( value );
    }
}
"
poi,3,org.apache.poi.hpsf.CustomProperties,16,3,0,4,52,82,1,3,14,0.266666667,416,1.0,0,0.782608696,0.1875,2,7,24.8125,3,1.1875,0,"

package org.apache.poi.hpsf;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;


@SuppressWarnings(""serial"")
public class CustomProperties extends HashMap<Object,CustomProperty>
{

    
    private Map<Long,String> dictionaryIDToName = new HashMap<Long,String>();

    
    private Map<String,Long> dictionaryNameToID = new HashMap<String,Long>();

    
    private boolean isPure = true;


    
    public CustomProperty put(final String name, final CustomProperty cp)
    {
        if (name == null)
        {
            
            isPure = false;
            return null;
        }
        if (!(name.equals(cp.getName())))
            throw new IllegalArgumentException(""Parameter ""name"" ("" + name +
                    "") and custom property's name ("" + cp.getName() +
                    "") do not match."");

        
        final Long idKey = Long.valueOf(cp.getID());
        final Long oldID = dictionaryNameToID.get(name);
        dictionaryIDToName.remove(oldID);
        dictionaryNameToID.put(name, idKey);
        dictionaryIDToName.put(idKey, name);

        
        final CustomProperty oldCp = super.remove(oldID);
        super.put(idKey, cp);
        return oldCp;
    }



    
    private Object put(final CustomProperty customProperty) throws ClassCastException
    {
        final String name = customProperty.getName();

        
        final Long oldId = dictionaryNameToID.get(name);
        if (oldId != null)
            customProperty.setID(oldId.longValue());
        else
        {
            long max = 1;
            for (final Iterator<Long> i = dictionaryIDToName.keySet().iterator(); i.hasNext();)
            {
                final long id = i.next().longValue();
                if (id > max)
                    max = id;
            }
            customProperty.setID(max + 1);
        }
        return this.put(name, customProperty);
    }



    
    public Object remove(final String name)
    {
        final Long id = dictionaryNameToID.get(name);
        if (id == null)
            return null;
        dictionaryIDToName.remove(id);
        dictionaryNameToID.remove(name);
        return super.remove(id);
    }

    
    public Object put(final String name, final String value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_LPWSTR);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Long value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_I8);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Double value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_R8);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Integer value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_I4);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Boolean value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_BOOL);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }


    
    public Object get(final String name)
    {
        final Long id = dictionaryNameToID.get(name);
        final CustomProperty cp = super.get(id);
        return cp != null ? cp.getValue() : null;
    }



    
    public Object put(final String name, final Date value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_FILETIME);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Set keySet() {
        return dictionaryNameToID.keySet();
    }

    
    public Set<String> nameSet() {
        return dictionaryNameToID.keySet();
    }

    
    public Set<String> idSet() {
        return dictionaryNameToID.keySet();
    }


    
    public void setCodepage(final int codepage)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(PropertyIDMap.PID_CODEPAGE);
        p.setType(Variant.VT_I2);
        p.setValue(Integer.valueOf(codepage));
        put(new CustomProperty(p));
    }



    
    Map<Long,String> getDictionary()
    {
        return dictionaryIDToName;
    }


    
   public boolean containsKey(Object key) {
      if(key instanceof Long) {
         return super.containsKey(key);
      }
      if(key instanceof String) {
         return super.containsKey(dictionaryNameToID.get(key));
      }
      return false;
   }

   
   public boolean containsValue(Object value) {
      if(value instanceof CustomProperty) {
         return super.containsValue(value);
      } else {
         for(CustomProperty cp : super.values()) {
            if(cp.getValue() == value) {
               return true;
            }
         }
      }
      return false;
   }



   
    public int getCodepage()
    {
        int codepage = -1;
        for (final Iterator<CustomProperty> i = this.values().iterator(); codepage == -1 && i.hasNext();)
        {
            final CustomProperty cp = i.next();
            if (cp.getID() == PropertyIDMap.PID_CODEPAGE)
                codepage = ((Integer) cp.getValue()).intValue();
        }
        return codepage;
    }



    
    public boolean isPure()
    {
        return isPure;
    }

    
    public void setPure(final boolean isPure)
    {
        this.isPure = isPure;
    }
}
"
poi,3,org.apache.poi.hssf.record.IterationRecord,11,2,0,6,20,35,2,4,9,0.8,112,0.5,0,0.55,0.257575758,1,4,9.0,2,1.0909,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class IterationRecord extends StandardRecord {
    public final static short sid = 0x0011;

    private static final BitField iterationOn = BitFieldFactory.getInstance(0x0001);

    private int _flags;

    public IterationRecord(boolean iterateOn) {
        _flags = iterationOn.setBoolean(0, iterateOn);
    }

    public IterationRecord(RecordInputStream in)
    {
        _flags = in.readShort();
    }

    
    public void setIteration(boolean iterate) {
        _flags = iterationOn.setBoolean(_flags, iterate);
    }

    
    public boolean getIteration() {
        return iterationOn.isSet(_flags);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ITERATION]
"");
        buffer.append(""    .flags      = "").append(HexDump.shortToHex(_flags)).append(""
"");
        buffer.append(""[/ITERATION]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_flags);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
        return new IterationRecord(getIteration());
    }
}
"
poi,3,org.apache.poi.poifs.storage.PropertyBlock,4,2,0,5,11,4,1,4,2,0.833333333,108,1.0,1,0.5,0.4,1,1,25.5,3,1.25,1,"

package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.property.Property;


public final class PropertyBlock extends BigBlock {
    private Property[]       _properties;

    

    private PropertyBlock(final POIFSBigBlockSize bigBlockSize, final Property [] properties, final int offset)
    {
        super(bigBlockSize);
        
        _properties = new Property[ bigBlockSize.getPropertiesPerBlock() ]; 
        for (int j = 0; j < _properties.length; j++)
        {
            _properties[ j ] = properties[ j + offset ];
        }
    }

    

    public static BlockWritable [] createPropertyBlockArray(
            final POIFSBigBlockSize bigBlockSize, final List<Property> properties)
    {
        int _properties_per_block = bigBlockSize.getPropertiesPerBlock();
        int        block_count   =
            (properties.size() + _properties_per_block - 1)
            / _properties_per_block;
        Property[] to_be_written =
            new Property[ block_count * _properties_per_block ];

        System.arraycopy(properties.toArray(new Property[ 0 ]), 0,
                         to_be_written, 0, properties.size());
        for (int j = properties.size(); j < to_be_written.length; j++)
        {

            
            
            to_be_written[ j ] = new Property()
            {
                protected void preWrite()
                {
                }

                public boolean isDirectory()
                {
                    return false;
                }
            };
        }
        BlockWritable[] rvalue = new BlockWritable[ block_count ];

        for (int j = 0; j < block_count; j++)
        {
            rvalue[ j ] = new PropertyBlock(bigBlockSize, to_be_written,
                                            j * _properties_per_block);
        }
        return rvalue;
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        int _properties_per_block = bigBlockSize.getPropertiesPerBlock();
        for (int j = 0; j < _properties_per_block; j++)
        {
            _properties[ j ].writeData(stream);
        }
    }

    
}   

"
poi,3,org.apache.poi.hssf.record.RecordInputStream,26,2,1,214,54,111,212,3,25,0.552,595,0.8,0,0.264705882,0.288461538,1,1,21.5,7,1.6923,6,"

package org.apache.poi.hssf.record;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;

import org.apache.poi.hssf.dev.BiffViewer;
import org.apache.poi.hssf.record.crypto.Biff8DecryptingStream;
import org.apache.poi.hssf.record.crypto.Biff8EncryptionKey;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianInputStream;


public final class RecordInputStream implements LittleEndianInput {
	
	public final static short MAX_RECORD_DATA_SIZE = 8224;
	private static final int INVALID_SID_VALUE = -1;
	
	private static final int DATA_LEN_NEEDS_TO_BE_READ = -1;
	private static final byte[] EMPTY_BYTE_ARRAY = { };

	
	@SuppressWarnings(""serial"")
	public static final class LeftoverDataException extends RuntimeException {
		public LeftoverDataException(int sid, int remainingByteCount) {
			super(""Initialisation of record 0x"" + Integer.toHexString(sid).toUpperCase()
					+ "" left "" + remainingByteCount + "" bytes remaining still to be read."");
		}
	}

	
	private final BiffHeaderInput _bhi;
	
	private final LittleEndianInput _dataInput;
	
	private int _currentSid;
	
	private int _currentDataLength;
	
	private int _nextSid;
	
	private int _currentDataOffset;

	private static final class SimpleHeaderInput implements BiffHeaderInput {

		private final LittleEndianInput _lei;

		public SimpleHeaderInput(InputStream in) {
			_lei = getLEI(in);
		}
		public int available() {
			return _lei.available();
		}
		public int readDataSize() {
			return _lei.readUShort();
		}
		public int readRecordSID() {
			return _lei.readUShort();
		}
	}

	public RecordInputStream(InputStream in) throws RecordFormatException {
		this (in, null, 0);
	}

	public RecordInputStream(InputStream in, Biff8EncryptionKey key, int initialOffset) throws RecordFormatException {
		if (key == null) {
			_dataInput = getLEI(in);
			_bhi = new SimpleHeaderInput(in);
		} else {
			Biff8DecryptingStream bds = new Biff8DecryptingStream(in, initialOffset, key);
			_bhi = bds;
			_dataInput = bds;
		}
		_nextSid = readNextSid();
	}

	static LittleEndianInput getLEI(InputStream is) {
		if (is instanceof LittleEndianInput) {
			
			return (LittleEndianInput) is;
		}
		
		return new LittleEndianInputStream(is);
	}

	
	public int available() {
		return remaining();
	}

	public int read(byte[] b, int off, int len) {
		int limit = Math.min(len, remaining());
		if (limit == 0) {
			return 0;
		}
		readFully(b, off,limit);
		return limit;
	}

	public short getSid() {
		return (short) _currentSid;
	}

	
	public boolean hasNextRecord() throws LeftoverDataException {
		if (_currentDataLength != -1 && _currentDataLength != _currentDataOffset) {
			throw new LeftoverDataException(_currentSid, remaining());
		}
		if (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {
			_nextSid = readNextSid();
		}
		return _nextSid != INVALID_SID_VALUE;
	}

	
	private int readNextSid() {
		int nAvailable  = _bhi.available();
		if (nAvailable < EOFRecord.ENCODED_SIZE) {
			if (nAvailable > 0) {
				
				
				
			}
			return INVALID_SID_VALUE;
		}
		int result = _bhi.readRecordSID();
		if (result == INVALID_SID_VALUE) {
			throw new RecordFormatException(""Found invalid sid ("" + result + "")"");
		}
		_currentDataLength = DATA_LEN_NEEDS_TO_BE_READ;
		return result;
	}

	
	public void nextRecord() throws RecordFormatException {
		if (_nextSid == INVALID_SID_VALUE) {
			throw new IllegalStateException(""EOF - next record not available"");
		}
		if (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {
			throw new IllegalStateException(""Cannot call nextRecord() without checking hasNextRecord() first"");
		}
		_currentSid = _nextSid;
		_currentDataOffset = 0;
		_currentDataLength = _bhi.readDataSize();
		if (_currentDataLength > MAX_RECORD_DATA_SIZE) {
			throw new RecordFormatException(""The content of an excel record cannot exceed ""
					+ MAX_RECORD_DATA_SIZE + "" bytes"");
		}
	}

	private void checkRecordPosition(int requiredByteCount) {

		int nAvailable = remaining();
		if (nAvailable >= requiredByteCount) {
			
			return;
		}
		if (nAvailable == 0 && isContinueNext()) {
			nextRecord();
			return;
		}
		throw new RecordFormatException(""Not enough data ("" + nAvailable
				+ "") to read requested ("" + requiredByteCount +"") bytes"");
	}

	
	public byte readByte() {
		checkRecordPosition(LittleEndian.BYTE_SIZE);
		_currentDataOffset += LittleEndian.BYTE_SIZE;
		return _dataInput.readByte();
	}

	
	public short readShort() {
		checkRecordPosition(LittleEndian.SHORT_SIZE);
		_currentDataOffset += LittleEndian.SHORT_SIZE;
		return _dataInput.readShort();
	}

	
	public int readInt() {
		checkRecordPosition(LittleEndian.INT_SIZE);
		_currentDataOffset += LittleEndian.INT_SIZE;
		return _dataInput.readInt();
	}

	
	public long readLong() {
		checkRecordPosition(LittleEndian.LONG_SIZE);
		_currentDataOffset += LittleEndian.LONG_SIZE;
		return _dataInput.readLong();
	}

	
	public int readUByte() {
		return readByte() & 0x00FF;
	}

	
	public int readUShort() {
		checkRecordPosition(LittleEndian.SHORT_SIZE);
		_currentDataOffset += LittleEndian.SHORT_SIZE;
		return _dataInput.readUShort();
	}

	public double readDouble() {
		long valueLongBits = readLong();
		double result = Double.longBitsToDouble(valueLongBits);
		if (Double.isNaN(result)) {
            
            
            
            
		}
		return result;
	}
	public void readFully(byte[] buf) {
		readFully(buf, 0, buf.length);
	}

	public void readFully(byte[] buf, int off, int len) {
	    int origLen = len;
	    if (buf == null) {
	        throw new NullPointerException();
	    } else if (off < 0 || len < 0 || len > buf.length - off) {
	        throw new IndexOutOfBoundsException();
	    }
	    
	    while (len > 0) {
	        int nextChunk = Math.min(available(),len);
	        if (nextChunk == 0) {
	            if (!hasNextRecord()) {
	                throw new RecordFormatException(""Can't read the remaining ""+len+"" bytes of the requested ""+origLen+"" bytes. No further record exists."");
	            } else {
	                nextRecord();
	                nextChunk = Math.min(available(),len);
	                assert(nextChunk > 0);
	            }
	        }
	        checkRecordPosition(nextChunk);
	        _dataInput.readFully(buf, off, nextChunk);
	        _currentDataOffset+=nextChunk;
	        off += nextChunk;
	        len -= nextChunk;
	    }
	}

	public String readString() {
		int requestedLength = readUShort();
		byte compressFlag = readByte();
		return readStringCommon(requestedLength, compressFlag == 0);
	}
	
	public String readUnicodeLEString(int requestedLength) {
		return readStringCommon(requestedLength, false);
	}

	public String readCompressedUnicode(int requestedLength) {
		return readStringCommon(requestedLength, true);
	}

	private String readStringCommon(int requestedLength, boolean pIsCompressedEncoding) {
		
		if (requestedLength < 0 || requestedLength > 0x100000) { 
			throw new IllegalArgumentException(""Bad requested string length ("" + requestedLength + "")"");
		}
		char[] buf = new char[requestedLength];
		boolean isCompressedEncoding = pIsCompressedEncoding;
		int curLen = 0;
		while(true) {
			int availableChars =isCompressedEncoding ?  remaining() : remaining() / LittleEndian.SHORT_SIZE;
			if (requestedLength - curLen <= availableChars) {
				
				while(curLen < requestedLength) {
					char ch;
					if (isCompressedEncoding) {
						ch = (char)readUByte();
					} else {
						ch = (char)readShort();
					}
					buf[curLen] = ch;
					curLen++;
				}
				return new String(buf);
			}
			
			
			while(availableChars > 0) {
				char ch;
				if (isCompressedEncoding) {
					ch = (char)readUByte();
				} else {
					ch = (char)readShort();
				}
				buf[curLen] = ch;
				curLen++;
				availableChars--;
			}
			if (!isContinueNext()) {
				throw new RecordFormatException(""Expected to find a ContinueRecord in order to read remaining ""
						+ (requestedLength-curLen) + "" of "" + requestedLength + "" chars"");
			}
			if(remaining() != 0) {
				throw new RecordFormatException(""Odd number of bytes("" + remaining() + "") left behind"");
			}
			nextRecord();
			
			byte compressFlag = readByte();
            assert(compressFlag == 0 || compressFlag == 1);
			isCompressedEncoding = (compressFlag == 0);
		}
	}

	
	public byte[] readRemainder() {
		int size = remaining();
		if (size ==0) {
			return EMPTY_BYTE_ARRAY;
		}
		byte[] result = new byte[size];
		readFully(result);
		return result;
	}

  
  public byte[] readAllContinuedRemainder() {
    
    
    ByteArrayOutputStream out = new ByteArrayOutputStream(2*MAX_RECORD_DATA_SIZE);

    while (true) {
      byte[] b = readRemainder();
      out.write(b, 0, b.length);
      if (!isContinueNext()) {
          break;
      }
      nextRecord();
    }
    return out.toByteArray();
  }

	
	public int remaining() {
		if (_currentDataLength == DATA_LEN_NEEDS_TO_BE_READ) {
			
			return 0;
		}
		return _currentDataLength - _currentDataOffset;
	}

	
	private boolean isContinueNext() {
		if (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ && _currentDataOffset != _currentDataLength) {
			throw new IllegalStateException(""Should never be called before end of current record"");
		}
		if (!hasNextRecord()) {
			return false;
		}
		
		
		
		
		
		return _nextSid == ContinueRecord.sid;
	}

    
    public int getNextSid() {
        return _nextSid;
    }
}
"
poi,3,org.apache.poi.hpsf.HPSFRuntimeException,8,4,4,11,16,22,11,0,8,0.428571429,66,1.0,0,0.80952381,0.35,1,1,7.125,2,0.75,0,"

package org.apache.poi.hpsf;



public class HPSFRuntimeException extends RuntimeException
{
	private static final long serialVersionUID = -7804271670232727159L;
	
    private Throwable reason;



    
    public HPSFRuntimeException()
    {
        super();
    }



    
    public HPSFRuntimeException(final String msg)
    {
        super(msg);
    }



    
    public HPSFRuntimeException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFRuntimeException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }











































}
"
poi,3,org.apache.poi.hssf.record.VerticalPageBreakRecord,4,3,0,3,7,6,1,2,4,1.333333333,18,0.0,0,0.96,0.5,1,3,3.25,1,0.25,1,"

package org.apache.poi.hssf.record;

import java.util.Iterator;


public final class VerticalPageBreakRecord extends PageBreakRecord {

	public static final short sid = 0x001A;

	
	public VerticalPageBreakRecord() {

	}

	
	public VerticalPageBreakRecord(RecordInputStream in) {
		super(in);
	}

	public short getSid() {
		return sid;
	}

	public Object clone() {
		PageBreakRecord result = new VerticalPageBreakRecord();
		Iterator<Break> iterator = getBreaksIterator();
		while (iterator.hasNext()) {
			Break original = iterator.next();
			result.addBreak(original.main, original.subFrom, original.subTo);
		}
		return result;
	}
}
"
poi,3,org.apache.poi.hpsf.wellknown.SectionIDMap,8,3,0,5,15,26,4,1,7,0.857142857,295,0.25,1,0.9,0.342857143,1,1,35.375,3,1.125,1,"

package org.apache.poi.hpsf.wellknown;

import java.util.HashMap;


public class SectionIDMap extends HashMap {

    
    public static final byte[] SUMMARY_INFORMATION_ID = new byte[]
    {
        (byte) 0xF2, (byte) 0x9F, (byte) 0x85, (byte) 0xE0,
        (byte) 0x4F, (byte) 0xF9, (byte) 0x10, (byte) 0x68,
        (byte) 0xAB, (byte) 0x91, (byte) 0x08, (byte) 0x00,
        (byte) 0x2B, (byte) 0x27, (byte) 0xB3, (byte) 0xD9
    };

    
    public static final byte[][] DOCUMENT_SUMMARY_INFORMATION_ID = new byte[][]
    {
        {
            (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x02,
            (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
            (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
            (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE
        },
        {
            (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x05,
            (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
            (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
            (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE
        }
    };

    
    public static final String UNDEFINED = ""[undefined]"";

    
    private static SectionIDMap defaultMap;



    
    public static SectionIDMap getInstance()
    {
        if (defaultMap == null)
        {
            final SectionIDMap m = new SectionIDMap();
            m.put(SUMMARY_INFORMATION_ID,
                  PropertyIDMap.getSummaryInformationProperties());
            m.put(DOCUMENT_SUMMARY_INFORMATION_ID[0],
                  PropertyIDMap.getDocumentSummaryInformationProperties());
            defaultMap = m;
        }
        return defaultMap;
    }



    
    public static String getPIDString(final byte[] sectionFormatID,
                                      final long pid)
    {
        final PropertyIDMap m = getInstance().get(sectionFormatID);
        if (m == null) {
            return UNDEFINED;
        }
        final String s = (String) m.get(pid);
        if (s == null)
            return UNDEFINED;
        return s;
    }



    
    public PropertyIDMap get(final byte[] sectionFormatID)
    {
        return (PropertyIDMap) super.get(new String(sectionFormatID));
    }



    
    public Object get(final Object sectionFormatID)
    {
        return get((byte[]) sectionFormatID);
    }



    
    public Object put(final byte[] sectionFormatID,
                      final PropertyIDMap propertyIDMap)
    {
        return super.put(new String(sectionFormatID), propertyIDMap);
    }



    
    public Object put(final Object key, final Object value)
    {
        return put((byte[]) key, (PropertyIDMap) value);
    }

}
"
poi,3,org.apache.poi.hssf.eventusermodel.HSSFUserException,5,3,0,3,7,4,3,0,5,0.5,29,1.0,0,0.944444444,0.6,0,0,4.6,1,0.2,0,"


package org.apache.poi.hssf.eventusermodel;


public class HSSFUserException extends Exception
{

    private Throwable reason;



    
    public HSSFUserException()
    {
        super();
    }



    
    public HSSFUserException(final String msg)
    {
        super(msg);
    }



    
    public HSSFUserException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HSSFUserException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }

}
"
poi,3,org.apache.poi.hssf.eventusermodel.HSSFRequest,4,1,0,7,17,0,2,5,3,0.0,116,1.0,0,0.0,0.5,0,0,27.75,2,1.25,0,"

package org.apache.poi.hssf.eventusermodel;

import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;

import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordFactory;


public class HSSFRequest {
	private final Map<Short, List<HSSFListener>> _records;

	
	public HSSFRequest() {
		_records = new HashMap<Short, List<HSSFListener>>(50); 
	}

	
	public void addListener(HSSFListener lsnr, short sid) {
		List<HSSFListener> list = _records.get(Short.valueOf(sid));

		if (list == null) {
			list = new ArrayList<HSSFListener>(1); 
			_records.put(Short.valueOf(sid), list);
		}
		list.add(lsnr);
	}

	
	public void addListenerForAllRecords(HSSFListener lsnr) {
		short[] rectypes = RecordFactory.getAllKnownRecordSIDs();

		for (int k = 0; k < rectypes.length; k++) {
			addListener(lsnr, rectypes[k]);
		}
	}

	
	protected short processRecord(Record rec) throws HSSFUserException {
		List<HSSFListener> listeners = _records.get(Short.valueOf(rec.getSid()));
		short userCode = 0;

		if (listeners != null) {

			for (int k = 0; k < listeners.size(); k++) {
				Object listenObj = listeners.get(k);
				if (listenObj instanceof AbortableHSSFListener) {
					AbortableHSSFListener listener = (AbortableHSSFListener) listenObj;
					userCode = listener.abortableProcessRecord(rec);
					if (userCode != 0)
						break;
				} else {
					HSSFListener listener = (HSSFListener) listenObj;
					listener.processRecord(rec);
				}
			}
		}
		return userCode;
	}
}
"
poi,3,org.apache.poi.hssf.dev.BiffViewer,8,1,0,133,166,24,1,133,5,0.714285714,1000,0.5,0,0.0,0.234375,0,0,123.75,126,17.125,2,"

package org.apache.poi.hssf.dev;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.record.RecordInputStream.LeftoverDataException;
import org.apache.poi.hssf.record.chart.AreaFormatRecord;
import org.apache.poi.hssf.record.chart.AreaRecord;
import org.apache.poi.hssf.record.chart.AxisLineFormatRecord;
import org.apache.poi.hssf.record.chart.AxisOptionsRecord;
import org.apache.poi.hssf.record.chart.AxisParentRecord;
import org.apache.poi.hssf.record.chart.AxisRecord;
import org.apache.poi.hssf.record.chart.AxisUsedRecord;
import org.apache.poi.hssf.record.chart.BarRecord;
import org.apache.poi.hssf.record.chart.BeginRecord;
import org.apache.poi.hssf.record.chart.CatLabRecord;
import org.apache.poi.hssf.record.chart.CategorySeriesAxisRecord;
import org.apache.poi.hssf.record.chart.ChartEndBlockRecord;
import org.apache.poi.hssf.record.chart.ChartEndObjectRecord;
import org.apache.poi.hssf.record.chart.ChartFRTInfoRecord;
import org.apache.poi.hssf.record.chart.ChartFormatRecord;
import org.apache.poi.hssf.record.chart.ChartRecord;
import org.apache.poi.hssf.record.chart.ChartStartBlockRecord;
import org.apache.poi.hssf.record.chart.ChartStartObjectRecord;
import org.apache.poi.hssf.record.chart.DatRecord;
import org.apache.poi.hssf.record.chart.DataFormatRecord;
import org.apache.poi.hssf.record.chart.DefaultDataLabelTextPropertiesRecord;
import org.apache.poi.hssf.record.chart.EndRecord;
import org.apache.poi.hssf.record.chart.FontBasisRecord;
import org.apache.poi.hssf.record.chart.FontIndexRecord;
import org.apache.poi.hssf.record.chart.FrameRecord;
import org.apache.poi.hssf.record.chart.LegendRecord;
import org.apache.poi.hssf.record.chart.LineFormatRecord;
import org.apache.poi.hssf.record.chart.LinkedDataRecord;
import org.apache.poi.hssf.record.chart.ObjectLinkRecord;
import org.apache.poi.hssf.record.chart.PlotAreaRecord;
import org.apache.poi.hssf.record.chart.PlotGrowthRecord;
import org.apache.poi.hssf.record.chart.SeriesIndexRecord;
import org.apache.poi.hssf.record.chart.SeriesListRecord;
import org.apache.poi.hssf.record.chart.SeriesRecord;
import org.apache.poi.hssf.record.chart.SeriesTextRecord;
import org.apache.poi.hssf.record.chart.SeriesToChartGroupRecord;
import org.apache.poi.hssf.record.chart.SheetPropertiesRecord;
import org.apache.poi.hssf.record.chart.TextRecord;
import org.apache.poi.hssf.record.chart.TickRecord;
import org.apache.poi.hssf.record.chart.UnitsRecord;
import org.apache.poi.hssf.record.chart.ValueRangeRecord;
import org.apache.poi.hssf.record.pivottable.DataItemRecord;
import org.apache.poi.hssf.record.pivottable.ExtendedPivotTableViewFieldsRecord;
import org.apache.poi.hssf.record.pivottable.PageItemRecord;
import org.apache.poi.hssf.record.pivottable.StreamIDRecord;
import org.apache.poi.hssf.record.pivottable.ViewDefinitionRecord;
import org.apache.poi.hssf.record.pivottable.ViewFieldsRecord;
import org.apache.poi.hssf.record.pivottable.ViewSourceRecord;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public final class BiffViewer {
    static final char[] NEW_LINE_CHARS = System.getProperty(""line.separator"").toCharArray();

    private BiffViewer() {
        
    }

    
    public static Record[] createRecords(InputStream is, PrintStream ps, BiffRecordListener recListener, boolean dumpInterpretedRecords)
            throws RecordFormatException {
        List<Record> temp = new ArrayList<Record>();

        RecordInputStream recStream = new RecordInputStream(is);
        while (true) {
            boolean hasNext;
            try {
                hasNext = recStream.hasNextRecord();
            } catch (LeftoverDataException e) {
                e.printStackTrace();
                System.err.println(""Discarding "" + recStream.remaining() + "" bytes and continuing"");
                recStream.readRemainder();
                hasNext = recStream.hasNextRecord();
            }
            if (!hasNext) {
                break;
            }
            recStream.nextRecord();
            if (recStream.getSid() == 0) {
                continue;
            }
            Record record;
            if (dumpInterpretedRecords) {
                record = createRecord (recStream);
                if (record.getSid() == ContinueRecord.sid) {
                    continue;
                }
                temp.add(record);

                if (dumpInterpretedRecords) {
                    for (String header : recListener.getRecentHeaders()) {
                        ps.println(header);
                    }
                    ps.print(record.toString());
                }
            } else {
                recStream.readRemainder();
            }
            ps.println();
        }
        Record[] result = new Record[temp.size()];
        temp.toArray(result);
        return result;
    }


    
    private static Record createRecord(RecordInputStream in) {
        switch (in.getSid()) {
            case AreaFormatRecord.sid:        return new AreaFormatRecord(in);
            case AreaRecord.sid:              return new AreaRecord(in);
            case ArrayRecord.sid:             return new ArrayRecord(in);
            case AxisLineFormatRecord.sid:    return new AxisLineFormatRecord(in);
            case AxisOptionsRecord.sid:       return new AxisOptionsRecord(in);
            case AxisParentRecord.sid:        return new AxisParentRecord(in);
            case AxisRecord.sid:              return new AxisRecord(in);
            case AxisUsedRecord.sid:          return new AxisUsedRecord(in);
            case AutoFilterInfoRecord.sid:    return new AutoFilterInfoRecord(in);
            case BOFRecord.sid:               return new BOFRecord(in);
            case BackupRecord.sid:            return new BackupRecord(in);
            case BarRecord.sid:               return new BarRecord(in);
            case BeginRecord.sid:             return new BeginRecord(in);
            case BlankRecord.sid:             return new BlankRecord(in);
            case BookBoolRecord.sid:          return new BookBoolRecord(in);
            case BoolErrRecord.sid:           return new BoolErrRecord(in);
            case BottomMarginRecord.sid:      return new BottomMarginRecord(in);
            case BoundSheetRecord.sid:        return new BoundSheetRecord(in);
            case CFHeaderRecord.sid:          return new CFHeaderRecord(in);
            case CFHeader12Record.sid:        return new CFHeader12Record(in);
            case CFRuleRecord.sid:            return new CFRuleRecord(in);
            case CFRule12Record.sid:          return new CFRule12Record(in);
            
            case CalcCountRecord.sid:         return new CalcCountRecord(in);
            case CalcModeRecord.sid:          return new CalcModeRecord(in);
            case CategorySeriesAxisRecord.sid:return new CategorySeriesAxisRecord(in);
            case ChartFormatRecord.sid:       return new ChartFormatRecord(in);
            case ChartRecord.sid:             return new ChartRecord(in);
            case CodepageRecord.sid:          return new CodepageRecord(in);
            case ColumnInfoRecord.sid:        return new ColumnInfoRecord(in);
            case ContinueRecord.sid:          return new ContinueRecord(in);
            case CountryRecord.sid:           return new CountryRecord(in);
            case DBCellRecord.sid:            return new DBCellRecord(in);
            case DSFRecord.sid:               return new DSFRecord(in);
            case DatRecord.sid:               return new DatRecord(in);
            case DataFormatRecord.sid:        return new DataFormatRecord(in);
            case DateWindow1904Record.sid:    return new DateWindow1904Record(in);
            case DConRefRecord.sid:           return new DConRefRecord(in);
            case DefaultColWidthRecord.sid:   return new DefaultColWidthRecord(in);
            case DefaultDataLabelTextPropertiesRecord.sid: return new DefaultDataLabelTextPropertiesRecord(in);
            case DefaultRowHeightRecord.sid:  return new DefaultRowHeightRecord(in);
            case DeltaRecord.sid:             return new DeltaRecord(in);
            case DimensionsRecord.sid:        return new DimensionsRecord(in);
            case DrawingGroupRecord.sid:      return new DrawingGroupRecord(in);
            case DrawingRecordForBiffViewer.sid: return new DrawingRecordForBiffViewer(in);
            case DrawingSelectionRecord.sid:  return new DrawingSelectionRecord(in);
            case DVRecord.sid:                return new DVRecord(in);
            case DVALRecord.sid:              return new DVALRecord(in);
            case EOFRecord.sid:               return new EOFRecord(in);
            case EndRecord.sid:               return new EndRecord(in);
            case ExtSSTRecord.sid:            return new ExtSSTRecord(in);
            case ExtendedFormatRecord.sid:    return new ExtendedFormatRecord(in);
            case ExternSheetRecord.sid:       return new ExternSheetRecord(in);
            case ExternalNameRecord.sid:      return new ExternalNameRecord(in);
            case FeatRecord.sid:              return new FeatRecord(in);
            case FeatHdrRecord.sid:           return new FeatHdrRecord(in);
            case FilePassRecord.sid:          return new FilePassRecord(in);
            case FileSharingRecord.sid:       return new FileSharingRecord(in);
            case FnGroupCountRecord.sid:      return new FnGroupCountRecord(in);
            case FontBasisRecord.sid:         return new FontBasisRecord(in);
            case FontIndexRecord.sid:         return new FontIndexRecord(in);
            case FontRecord.sid:              return new FontRecord(in);
            case FooterRecord.sid:            return new FooterRecord(in);
            case FormatRecord.sid:            return new FormatRecord(in);
            case FormulaRecord.sid:           return new FormulaRecord(in);
            case FrameRecord.sid:             return new FrameRecord(in);
            case GridsetRecord.sid:           return new GridsetRecord(in);
            case GutsRecord.sid:              return new GutsRecord(in);
            case HCenterRecord.sid:           return new HCenterRecord(in);
            case HeaderRecord.sid:            return new HeaderRecord(in);
            case HideObjRecord.sid:           return new HideObjRecord(in);
            case HorizontalPageBreakRecord.sid: return new HorizontalPageBreakRecord(in);
            case HyperlinkRecord.sid:         return new HyperlinkRecord(in);
            case IndexRecord.sid:             return new IndexRecord(in);
            case InterfaceEndRecord.sid:      return InterfaceEndRecord.create(in);
            case InterfaceHdrRecord.sid:      return new InterfaceHdrRecord(in);
            case IterationRecord.sid:         return new IterationRecord(in);
            case LabelRecord.sid:             return new LabelRecord(in);
            case LabelSSTRecord.sid:          return new LabelSSTRecord(in);
            case LeftMarginRecord.sid:        return new LeftMarginRecord(in);
            case LegendRecord.sid:            return new LegendRecord(in);
            case LineFormatRecord.sid:        return new LineFormatRecord(in);
            case LinkedDataRecord.sid:        return new LinkedDataRecord(in);
            case MMSRecord.sid:               return new MMSRecord(in);
            case MergeCellsRecord.sid:        return new MergeCellsRecord(in);
            case MulBlankRecord.sid:          return new MulBlankRecord(in);
            case MulRKRecord.sid:             return new MulRKRecord(in);
            case NameRecord.sid:              return new NameRecord(in);
            case NameCommentRecord.sid:       return new NameCommentRecord(in);
            case NoteRecord.sid:              return new NoteRecord(in);
            case NumberRecord.sid:            return new NumberRecord(in);
            case ObjRecord.sid:               return new ObjRecord(in);
            case ObjectLinkRecord.sid:        return new ObjectLinkRecord(in);
            case PaletteRecord.sid:           return new PaletteRecord(in);
            case PaneRecord.sid:              return new PaneRecord(in);
            case PasswordRecord.sid:          return new PasswordRecord(in);
            case PasswordRev4Record.sid:      return new PasswordRev4Record(in);
            case PlotAreaRecord.sid:          return new PlotAreaRecord(in);
            case PlotGrowthRecord.sid:        return new PlotGrowthRecord(in);
            case PrecisionRecord.sid:         return new PrecisionRecord(in);
            case PrintGridlinesRecord.sid:    return new PrintGridlinesRecord(in);
            case PrintHeadersRecord.sid:      return new PrintHeadersRecord(in);
            case PrintSetupRecord.sid:        return new PrintSetupRecord(in);
            case ProtectRecord.sid:           return new ProtectRecord(in);
            case ProtectionRev4Record.sid:    return new ProtectionRev4Record(in);
            case RKRecord.sid:                return new RKRecord(in);
            case RecalcIdRecord.sid:          return new RecalcIdRecord(in);
            case RefModeRecord.sid:           return new RefModeRecord(in);
            case RefreshAllRecord.sid:        return new RefreshAllRecord(in);
            case RightMarginRecord.sid:       return new RightMarginRecord(in);
            case RowRecord.sid:               return new RowRecord(in);
            case SCLRecord.sid:               return new SCLRecord(in);
            case SSTRecord.sid:               return new SSTRecord(in);
            case SaveRecalcRecord.sid:        return new SaveRecalcRecord(in);
            case SelectionRecord.sid:         return new SelectionRecord(in);
            case SeriesIndexRecord.sid:       return new SeriesIndexRecord(in);
            case SeriesListRecord.sid:        return new SeriesListRecord(in);
            case SeriesRecord.sid:            return new SeriesRecord(in);
            case SeriesTextRecord.sid:        return new SeriesTextRecord(in);
            case SeriesToChartGroupRecord.sid:return new SeriesToChartGroupRecord(in);
            case SharedFormulaRecord.sid:     return new SharedFormulaRecord(in);
            case SheetPropertiesRecord.sid:   return new SheetPropertiesRecord(in);
            case StringRecord.sid:            return new StringRecord(in);
            case StyleRecord.sid:             return new StyleRecord(in);
            case SupBookRecord.sid:           return new SupBookRecord(in);
            case TabIdRecord.sid:             return new TabIdRecord(in);
            case TableStylesRecord.sid:       return new TableStylesRecord(in);
            case TableRecord.sid:             return new TableRecord(in);
            case TextObjectRecord.sid:        return new TextObjectRecord(in);
            case TextRecord.sid:              return new TextRecord(in);
            case TickRecord.sid:              return new TickRecord(in);
            case TopMarginRecord.sid:         return new TopMarginRecord(in);
            case UncalcedRecord.sid:          return new UncalcedRecord(in);
            case UnitsRecord.sid:             return new UnitsRecord(in);
            case UseSelFSRecord.sid:          return new UseSelFSRecord(in);
            case VCenterRecord.sid:           return new VCenterRecord(in);
            case ValueRangeRecord.sid:        return new ValueRangeRecord(in);
            case VerticalPageBreakRecord.sid: return new VerticalPageBreakRecord(in);
            case WSBoolRecord.sid:            return new WSBoolRecord(in);
            case WindowOneRecord.sid:         return new WindowOneRecord(in);
            case WindowProtectRecord.sid:     return new WindowProtectRecord(in);
            case WindowTwoRecord.sid:         return new WindowTwoRecord(in);
            case WriteAccessRecord.sid:       return new WriteAccessRecord(in);
            case WriteProtectRecord.sid:      return new WriteProtectRecord(in);

            
            case CatLabRecord.sid:            return new CatLabRecord(in);
            case ChartEndBlockRecord.sid:     return new ChartEndBlockRecord(in);
            case ChartEndObjectRecord.sid:    return new ChartEndObjectRecord(in);
            case ChartFRTInfoRecord.sid:      return new ChartFRTInfoRecord(in);
            case ChartStartBlockRecord.sid:   return new ChartStartBlockRecord(in);
            case ChartStartObjectRecord.sid:  return new ChartStartObjectRecord(in);

            
            case StreamIDRecord.sid:           return new StreamIDRecord(in);
            case ViewSourceRecord.sid:         return new ViewSourceRecord(in);
            case PageItemRecord.sid:           return new PageItemRecord(in);
            case ViewDefinitionRecord.sid:     return new ViewDefinitionRecord(in);
            case ViewFieldsRecord.sid:         return new ViewFieldsRecord(in);
            case DataItemRecord.sid:           return new DataItemRecord(in);
            case ExtendedPivotTableViewFieldsRecord.sid: return new ExtendedPivotTableViewFieldsRecord(in);
        }
        return new UnknownRecord(in);
    }

    private static final class CommandArgs {

        private final boolean _biffhex;
        private final boolean _noint;
        private final boolean _out;
        private final boolean _rawhex;
        private final boolean _noHeader;
        private final File _file;

        private CommandArgs(boolean biffhex, boolean noint, boolean out, boolean rawhex, boolean noHeader, File file) {
            _biffhex = biffhex;
            _noint = noint;
            _out = out;
            _rawhex = rawhex;
            _file = file;
            _noHeader = noHeader;
        }

        public static CommandArgs parse(String[] args) throws CommandParseException {
            int nArgs = args.length;
            boolean biffhex = false;
            boolean noint = false;
            boolean out = false;
            boolean rawhex = false;
            boolean noheader = false;
            File file = null;
            for (int i=0; i<nArgs; i++) {
                String arg = args[i];
                if (arg.startsWith(""--"")) {
                    if (""--biffhex"".equals(arg)) {
                        biffhex = true;
                    } else if (""--noint"".equals(arg)) {
                        noint = true;
                    } else if (""--out"".equals(arg)) {
                        out = true;
                    } else if (""--escher"".equals(arg)) {
                        System.setProperty(""poi.deserialize.escher"", ""true"");
                    } else if (""--rawhex"".equals(arg)) {
                        rawhex = true;
                    } else if (""--noheader"".equals(arg)) {
                        noheader = true;
                    } else {
                        throw new CommandParseException(""Unexpected option '"" + arg + ""'"");
                    }
                    continue;
                }
                file = new File(arg);
                if (!file.exists()) {
                    throw new CommandParseException(""Specified file '"" + arg + ""' does not exist"");
                }
                if (i+1<nArgs) {
                    throw new CommandParseException(""File name must be the last arg"");
                }
            }
            if (file == null) {
                throw new CommandParseException(""Biff viewer needs a filename"");
            }
            return new CommandArgs(biffhex, noint, out, rawhex, noheader, file);
        }
        public boolean shouldDumpBiffHex() {
            return _biffhex;
        }
        public boolean shouldDumpRecordInterpretations() {
            return !_noint;
        }
        public boolean shouldOutputToFile() {
            return _out;
        }
        public boolean shouldOutputRawHexOnly() {
            return _rawhex;
        }
        public boolean suppressHeader() {
            return _noHeader;
        }
        public File getFile() {
            return _file;
        }
    }
    private static final class CommandParseException extends Exception {
        public CommandParseException(String msg) {
            super(msg);
        }
    }

	
	public static void main(String[] args) {
		
		CommandArgs cmdArgs;
		try {
			cmdArgs = CommandArgs.parse(args);
		} catch (CommandParseException e) {
			e.printStackTrace();
			return;
		}

		try {

			PrintStream ps;
			if (cmdArgs.shouldOutputToFile()) {
				OutputStream os = new FileOutputStream(cmdArgs.getFile().getAbsolutePath() + "".out"");
				ps = new PrintStream(os);
			} else {
				ps = System.out;
			}

			InputStream is = getPOIFSInputStream(cmdArgs.getFile());

			if (cmdArgs.shouldOutputRawHexOnly()) {
				int size = is.available();
				byte[] data = new byte[size];

				is.read(data);
				HexDump.dump(data, 0, System.out, 0);
			} else {
				boolean dumpInterpretedRecords = cmdArgs.shouldDumpRecordInterpretations();
				boolean dumpHex = cmdArgs.shouldDumpBiffHex();
				boolean zeroAlignHexDump = dumpInterpretedRecords;  
				runBiffViewer(ps, is, dumpInterpretedRecords, dumpHex, zeroAlignHexDump,
						cmdArgs.suppressHeader());
			}
			ps.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	protected static InputStream getPOIFSInputStream(File file)
			throws IOException, FileNotFoundException {
		NPOIFSFileSystem fs = new NPOIFSFileSystem(new FileInputStream(file));
		String workbookName = HSSFWorkbook.getWorkbookDirEntryName(fs.getRoot());
		return fs.createDocumentInputStream(workbookName);
	}

	protected static void runBiffViewer(PrintStream ps, InputStream is,
			boolean dumpInterpretedRecords, boolean dumpHex, boolean zeroAlignHexDump,
			boolean suppressHeader) {
		BiffRecordListener recListener = new BiffRecordListener(dumpHex ? new OutputStreamWriter(ps) : null, zeroAlignHexDump, suppressHeader);
		is = new BiffDumpingStream(is, recListener);
		createRecords(is, ps, recListener, dumpInterpretedRecords);
	}

	private static final class BiffRecordListener implements IBiffRecordListener {
		private final Writer _hexDumpWriter;
		private List<String> _headers;
		private final boolean _zeroAlignEachRecord;
		private final boolean _noHeader;
		public BiffRecordListener(Writer hexDumpWriter, boolean zeroAlignEachRecord, boolean noHeader) {
			_hexDumpWriter = hexDumpWriter;
			_zeroAlignEachRecord = zeroAlignEachRecord;
			_noHeader = noHeader;
			_headers = new ArrayList<String>();
		}

		public void processRecord(int globalOffset, int recordCounter, int sid, int dataSize,
				byte[] data) {
			String header = formatRecordDetails(globalOffset, sid, dataSize, recordCounter);
			if(!_noHeader) _headers.add(header);
			Writer w = _hexDumpWriter;
			if (w != null) {
				try {
					w.write(header);
					w.write(NEW_LINE_CHARS);
					hexDumpAligned(w, data, dataSize+4, globalOffset, _zeroAlignEachRecord);
					w.flush();
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
		}
		public List<String> getRecentHeaders() {
		    List<String> result = _headers;
		    _headers = new ArrayList<String>();
		    return result;
		}
		private static String formatRecordDetails(int globalOffset, int sid, int size, int recordCounter) {
			StringBuffer sb = new StringBuffer(64);
			sb.append(""Offset="").append(HexDump.intToHex(globalOffset)).append(""("").append(globalOffset).append("")"");
			sb.append("" recno="").append(recordCounter);
			sb.append(  "" sid="").append(HexDump.shortToHex(sid));
			sb.append( "" size="").append(HexDump.shortToHex(size)).append(""("").append(size).append("")"");
			return sb.toString();
		}
	}

	private static interface IBiffRecordListener {

		void processRecord(int globalOffset, int recordCounter, int sid, int dataSize, byte[] data);

	}

	
	private static final class BiffDumpingStream extends InputStream {
		private final DataInputStream _is;
		private final IBiffRecordListener _listener;
		private final byte[] _data;
		private int _recordCounter;
		private int _overallStreamPos;
		private int _currentPos;
		private int _currentSize;
		private boolean _innerHasReachedEOF;

		public BiffDumpingStream(InputStream is, IBiffRecordListener listener) {
			_is = new DataInputStream(is);
			_listener = listener;
			_data = new byte[RecordInputStream.MAX_RECORD_DATA_SIZE + 4];
			_recordCounter = 0;
			_overallStreamPos = 0;
			_currentSize = 0;
			_currentPos = 0;
		}

		@Override
		public int read() throws IOException {
			if (_currentPos >= _currentSize) {
				fillNextBuffer();
			}
			if (_currentPos >= _currentSize) {
				return -1;
			}
			int result = _data[_currentPos] & 0x00FF;
			_currentPos ++;
			_overallStreamPos ++;
			formatBufferIfAtEndOfRec();
			return result;
		}
		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			if (_currentPos >= _currentSize) {
				fillNextBuffer();
			}
			if (_currentPos >= _currentSize) {
				return -1;
			}
			int availSize = _currentSize - _currentPos;
			int result;
			if (len > availSize) {
				System.err.println(""Unexpected request to read past end of current biff record"");
				result = availSize;
			} else {
				result = len;
			}
			System.arraycopy(_data, _currentPos, b, off, result);
			_currentPos += result;
			_overallStreamPos += result;
			formatBufferIfAtEndOfRec();
			return result;
		}

		@Override
		public int available() throws IOException {
			return _currentSize - _currentPos + _is.available();
		}
		private void fillNextBuffer() throws IOException {
			if (_innerHasReachedEOF) {
				return;
			}
			int b0 = _is.read();
			if (b0 == -1) {
				_innerHasReachedEOF = true;
				return;
			}
			_data[0] = (byte) b0;
			_is.readFully(_data, 1, 3);
			int len = LittleEndian.getShort(_data, 2);
			_is.readFully(_data, 4, len);
			_currentPos = 0;
			_currentSize = len + 4;
			_recordCounter++;
		}
		private void formatBufferIfAtEndOfRec() {
			if (_currentPos != _currentSize) {
				return;
			}
			int dataSize = _currentSize-4;
			int sid = LittleEndian.getShort(_data, 0);
			int globalOffset = _overallStreamPos-_currentSize;
			_listener.processRecord(globalOffset, _recordCounter, sid, dataSize, _data);
		}
		@Override
		public void close() throws IOException {
			_is.close();
		}
	}

	private static final int DUMP_LINE_LEN = 16;
	private static final char[] COLUMN_SEPARATOR = "" | "".toCharArray();
	
	static void hexDumpAligned(Writer w, byte[] data, int dumpLen, int globalOffset,
			boolean zeroAlignEachRecord) {
		int baseDataOffset = 0;

		
		int globalStart = globalOffset + baseDataOffset;
		int globalEnd = globalOffset + baseDataOffset + dumpLen;
		int startDelta = globalStart % DUMP_LINE_LEN;
		int endDelta = globalEnd % DUMP_LINE_LEN;
		if (zeroAlignEachRecord) {
			endDelta -= startDelta;
			if (endDelta < 0) {
				endDelta += DUMP_LINE_LEN;
			}
			startDelta = 0;
		}
		int startLineAddr;
		int endLineAddr;
		if (zeroAlignEachRecord) {
			endLineAddr = globalEnd - endDelta - (globalStart - startDelta);
			startLineAddr = 0;
		} else {
			startLineAddr = globalStart - startDelta;
			endLineAddr = globalEnd - endDelta;
		}

		int lineDataOffset = baseDataOffset - startDelta;
		int lineAddr = startLineAddr;

		
		if (startLineAddr == endLineAddr) {
			hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, endDelta);
			return;
		}
		hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, DUMP_LINE_LEN);

		
		while (true) {
			lineAddr += DUMP_LINE_LEN;
			lineDataOffset += DUMP_LINE_LEN;
			if (lineAddr >= endLineAddr) {
				break;
			}
			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, DUMP_LINE_LEN);
		}


		
		if (endDelta != 0) {
			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, endDelta);
		}
	}

	private static void hexDumpLine(Writer w, byte[] data, int lineStartAddress, int lineDataOffset, int startDelta, int endDelta) {
		if (startDelta >= endDelta) {
			throw new IllegalArgumentException(""Bad start/end delta"");
		}
		try {
			writeHex(w, lineStartAddress, 8);
			w.write(COLUMN_SEPARATOR);
			
			for (int i=0; i< DUMP_LINE_LEN; i++) {
				if (i>0) {
					w.write("" "");
				}
				if (i >= startDelta && i < endDelta) {
					writeHex(w, data[lineDataOffset+i], 2);
				} else {
					w.write(""  "");
				}
			}
			w.write(COLUMN_SEPARATOR);

			
			for (int i=0; i< DUMP_LINE_LEN; i++) {
				if (i >= startDelta && i < endDelta) {
					w.write(getPrintableChar(data[lineDataOffset+i]));
				} else {
					w.write("" "");
				}
			}
			w.write(NEW_LINE_CHARS);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	private static char getPrintableChar(byte b) {
		char ib = (char) (b & 0x00FF);
		if (ib < 32 || ib > 126) {
			return '.';
		}
		return ib;
	}

	private static void writeHex(Writer w, int value, int nDigits) throws IOException {
		char[] buf = new char[nDigits];
		int acc = value;
		for(int i=nDigits-1; i>=0; i--) {
			int digit = acc & 0x0F;
			buf[i] = (char) (digit < 10 ? ('0' + digit) : ('A' + digit - 10));
			acc >>= 4;
		}
		w.write(buf);
	}
}
"
poi,3,org.apache.poi.poifs.storage.RawDataBlockList,5,2,0,8,16,10,4,4,5,2.0,50,0.0,0,0.555555556,0.5,0,0,9.0,1,0.8,0,"

        

package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSBigBlockSize;



public class RawDataBlockList
    extends BlockListImpl
{

    

    public RawDataBlockList(final InputStream stream, POIFSBigBlockSize bigBlockSize)
        throws IOException
    {
        List<RawDataBlock> blocks = new ArrayList<RawDataBlock>();

        while (true)
        {
            RawDataBlock block = new RawDataBlock(stream, bigBlockSize.getBigBlockSize());
            
            
            if(block.hasData()) {
            	blocks.add(block);
            }

            
            if (block.eof()) {
                break;
            }
        }
        setBlocks( blocks.toArray(new RawDataBlock[ blocks.size() ]) );
    }
}   

"
poi,3,org.apache.poi.hssf.usermodel.HSSFCell,36,1,0,28,144,104,5,24,27,0.846428571,1294,0.4375,5,0.0,0.124074074,0,0,34.5,18,2.7778,14,"

package org.apache.poi.hssf.usermodel;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.hssf.model.HSSFFormulaParser;
import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.BlankRecord;
import org.apache.poi.hssf.record.BoolErrRecord;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.ExtendedFormatRecord;
import org.apache.poi.hssf.record.FormulaRecord;
import org.apache.poi.hssf.record.HyperlinkRecord;
import org.apache.poi.hssf.record.LabelSSTRecord;
import org.apache.poi.hssf.record.NumberRecord;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordBase;
import org.apache.poi.hssf.record.aggregates.FormulaRecordAggregate;
import org.apache.poi.hssf.record.common.UnicodeString;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.formula.FormulaType;
import org.apache.poi.ss.formula.eval.ErrorEval;
import org.apache.poi.ss.formula.ptg.ExpPtg;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Comment;
import org.apache.poi.ss.usermodel.FormulaError;
import org.apache.poi.ss.usermodel.Hyperlink;
import org.apache.poi.ss.usermodel.RichTextString;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.ss.util.NumberToTextConverter;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public class HSSFCell implements Cell {
    private static POILogger log = POILogFactory.getLogger(HSSFCell.class);

    private static final String FILE_FORMAT_NAME  = ""BIFF8"";
    
    public static final int LAST_COLUMN_NUMBER  = SpreadsheetVersion.EXCEL97.getLastColumnIndex(); 
    private static final String LAST_COLUMN_NAME  = SpreadsheetVersion.EXCEL97.getLastColumnName();

    public final static short        ENCODING_UNCHANGED          = -1;
    public final static short        ENCODING_COMPRESSED_UNICODE = 0;
    public final static short        ENCODING_UTF_16             = 1;

    private final HSSFWorkbook       _book;
    private final HSSFSheet          _sheet;
    private int                      _cellType;
    private HSSFRichTextString       _stringValue;
    private CellValueRecordInterface _record;
    private HSSFComment              _comment;

    
    protected HSSFCell(HSSFWorkbook book, HSSFSheet sheet, int row, short col)
    {
        checkBounds(col);
        _stringValue  = null;
        _book    = book;
        _sheet   = sheet;

        
        
        
        short xfindex = sheet.getSheet().getXFIndexForColAt(col);
        setCellType(CELL_TYPE_BLANK, false, row, col,xfindex);
    }

    
    public HSSFSheet getSheet() {
        return _sheet;
    }

    
    public HSSFRow getRow() {
        int rowIndex = getRowIndex();
        return _sheet.getRow(rowIndex);
    }

    
    protected HSSFCell(HSSFWorkbook book, HSSFSheet sheet, int row, short col,
                       int type)
    {
        checkBounds(col);
        _cellType     = -1; 
        _stringValue  = null;
        _book    = book;
        _sheet   = sheet;

        short xfindex = sheet.getSheet().getXFIndexForColAt(col);
        setCellType(type,false,row,col,xfindex);
    }

    
    protected HSSFCell(HSSFWorkbook book, HSSFSheet sheet, CellValueRecordInterface cval) {
        _record      = cval;
        _cellType    = determineType(cval);
        _stringValue = null;
        _book   = book;
        _sheet  = sheet;
        switch (_cellType)
        {
            case CELL_TYPE_STRING :
                _stringValue = new HSSFRichTextString(book.getWorkbook(), (LabelSSTRecord ) cval);
                break;

            case CELL_TYPE_BLANK :
                break;

            case CELL_TYPE_FORMULA :
                _stringValue=new HSSFRichTextString(((FormulaRecordAggregate) cval).getStringValue());
                break;
        }
    }


    
    private static int determineType(CellValueRecordInterface cval) {
        if (cval instanceof FormulaRecordAggregate) {
            return HSSFCell.CELL_TYPE_FORMULA;
        }
        
        Record record = ( Record ) cval;
        switch (record.getSid()) {

            case NumberRecord.sid :   return HSSFCell.CELL_TYPE_NUMERIC;
            case BlankRecord.sid :    return HSSFCell.CELL_TYPE_BLANK;
            case LabelSSTRecord.sid : return HSSFCell.CELL_TYPE_STRING;
            case BoolErrRecord.sid :
                BoolErrRecord boolErrRecord = ( BoolErrRecord ) record;

                return boolErrRecord.isBoolean()
                         ? HSSFCell.CELL_TYPE_BOOLEAN
                         : HSSFCell.CELL_TYPE_ERROR;
        }
        throw new RuntimeException(""Bad cell value rec ("" + cval.getClass().getName() + "")"");
    }

    
    protected InternalWorkbook getBoundWorkbook() {
        return _book.getWorkbook();
    }

    
    public int getRowIndex() {
        return _record.getRow();
    }
    
    public void setCellNum(short num)
    {
        _record.setColumn(num);
    }

    
    protected void updateCellNum(short num)
    {
        _record.setColumn(num);
    }

    
    public short getCellNum() {
        return (short) getColumnIndex();
    }

    public int getColumnIndex() {
        return _record.getColumn() & 0xFFFF;
    }

    
    public void setCellType(int cellType) {
        notifyFormulaChanging();
        if(isPartOfArrayFormulaGroup()){
            notifyArrayFormulaChanging();
        }
        int row=_record.getRow();
        short col=_record.getColumn();
        short styleIndex=_record.getXFIndex();
        setCellType(cellType, true, row, col, styleIndex);
    }

    

    private void setCellType(int cellType, boolean setValue, int row,short col, short styleIndex)
    {

        if (cellType > CELL_TYPE_ERROR)
        {
            throw new RuntimeException(""I have no idea what type that is!"");
        }
        switch (cellType)
        {

            case CELL_TYPE_FORMULA :
                FormulaRecordAggregate frec;

                if (cellType != _cellType) {
                    frec = _sheet.getSheet().getRowsAggregate().createFormula(row, col);
                } else {
                    frec = (FormulaRecordAggregate) _record;
                    frec.setRow(row);
                    frec.setColumn(col);
                }
                if (setValue)
                {
                    frec.getFormulaRecord().setValue(getNumericCellValue());
                }
                frec.setXFIndex(styleIndex);
                _record = frec;
                break;

            case CELL_TYPE_NUMERIC :
                NumberRecord nrec = null;

                if (cellType != _cellType)
                {
                    nrec = new NumberRecord();
                }
                else
                {
                    nrec = ( NumberRecord ) _record;
                }
                nrec.setColumn(col);
                if (setValue)
                {
                    nrec.setValue(getNumericCellValue());
                }
                nrec.setXFIndex(styleIndex);
                nrec.setRow(row);
                _record = nrec;
                break;

            case CELL_TYPE_STRING :
                LabelSSTRecord lrec;

                if (cellType == _cellType) {
                    lrec = (LabelSSTRecord) _record;
                } else {
                    lrec = new LabelSSTRecord();
                    lrec.setColumn(col);
                    lrec.setRow(row);
                    lrec.setXFIndex(styleIndex);
                }
                if (setValue) {
                    String str = convertCellValueToString();
                    int sstIndex = _book.getWorkbook().addSSTString(new UnicodeString(str));
                    lrec.setSSTIndex(sstIndex);
                    UnicodeString us = _book.getWorkbook().getSSTString(sstIndex);
                    _stringValue = new HSSFRichTextString();
                    _stringValue.setUnicodeString(us);
                }
                _record = lrec;
                break;

            case CELL_TYPE_BLANK :
                BlankRecord brec = null;

                if (cellType != _cellType)
                {
                    brec = new BlankRecord();
                }
                else
                {
                    brec = ( BlankRecord ) _record;
                }
                brec.setColumn(col);

                
                brec.setXFIndex(styleIndex);
                brec.setRow(row);
                _record = brec;
                break;

            case CELL_TYPE_BOOLEAN :
                BoolErrRecord boolRec = null;

                if (cellType != _cellType)
                {
                    boolRec = new BoolErrRecord();
                }
                else
                {
                    boolRec = ( BoolErrRecord ) _record;
                }
                boolRec.setColumn(col);
                if (setValue)
                {
                    boolRec.setValue(convertCellValueToBoolean());
                }
                boolRec.setXFIndex(styleIndex);
                boolRec.setRow(row);
                _record = boolRec;
                break;

            case CELL_TYPE_ERROR :
                BoolErrRecord errRec = null;

                if (cellType != _cellType)
                {
                    errRec = new BoolErrRecord();
                }
                else
                {
                    errRec = ( BoolErrRecord ) _record;
                }
                errRec.setColumn(col);
                if (setValue)
                {
                    errRec.setValue((byte)HSSFErrorConstants.ERROR_VALUE);
                }
                errRec.setXFIndex(styleIndex);
                errRec.setRow(row);
                _record = errRec;
                break;
        }
        if (cellType != _cellType &&
            _cellType!=-1 )  
        {
            _sheet.getSheet().replaceValueRecord(_record);
        }
        _cellType = cellType;
    }

    

    public int getCellType()
    {
        return _cellType;
    }

    
    public void setCellValue(double value) {
        if(Double.isInfinite(value)) {
            
            
            setCellErrorValue(FormulaError.DIV0.getCode());
        } else if (Double.isNaN(value)){
            
            
            setCellErrorValue(FormulaError.NUM.getCode());
        } else {
            int row=_record.getRow();
            short col=_record.getColumn();
            short styleIndex=_record.getXFIndex();

            switch (_cellType) {
                default:
                    setCellType(CELL_TYPE_NUMERIC, false, row, col, styleIndex);
                case CELL_TYPE_NUMERIC:
                    (( NumberRecord ) _record).setValue(value);
                    break;
                case CELL_TYPE_FORMULA:
                    ((FormulaRecordAggregate)_record).setCachedDoubleResult(value);
                    break;
            }
        }

    }

    
    public void setCellValue(Date value)
    {
        setCellValue(HSSFDateUtil.getExcelDate(value, _book.getWorkbook().isUsing1904DateWindowing()));
    }

    
    public void setCellValue(Calendar value)
    {
        setCellValue( HSSFDateUtil.getExcelDate(value, _book.getWorkbook().isUsing1904DateWindowing()) );
    }

    
    public void setCellValue(String value) {
        HSSFRichTextString str = value == null ? null :  new HSSFRichTextString(value);
        setCellValue(str);
    }

    

    public void setCellValue(RichTextString value)
    {
        int row=_record.getRow();
        short col=_record.getColumn();
        short styleIndex=_record.getXFIndex();
        if (value == null)
        {
            notifyFormulaChanging();
            setCellType(CELL_TYPE_BLANK, false, row, col, styleIndex);
            return;
        }

        if(value.length() > SpreadsheetVersion.EXCEL97.getMaxTextLength()){
            throw new IllegalArgumentException(""The maximum length of cell contents (text) is 32,767 characters"");
        }

        if (_cellType == CELL_TYPE_FORMULA) {
            
            
            FormulaRecordAggregate fr = (FormulaRecordAggregate) _record;
            fr.setCachedStringResult(value.getString());
            
            _stringValue = new HSSFRichTextString(value.getString());

            
            return;
        }

        
        

        if (_cellType != CELL_TYPE_STRING) {
            setCellType(CELL_TYPE_STRING, false, row, col, styleIndex);
        }
        int index = 0;

        HSSFRichTextString hvalue = (HSSFRichTextString) value;
        UnicodeString str = hvalue.getUnicodeString();
        index = _book.getWorkbook().addSSTString(str);
        (( LabelSSTRecord ) _record).setSSTIndex(index);
        _stringValue = hvalue;
        _stringValue.setWorkbookReferences(_book.getWorkbook(), (( LabelSSTRecord ) _record));
        _stringValue.setUnicodeString(_book.getWorkbook().getSSTString(index));
    }

    public void setCellFormula(String formula) {
        if(isPartOfArrayFormulaGroup()){
            notifyArrayFormulaChanging();
        }

        int row=_record.getRow();
        short col=_record.getColumn();
        short styleIndex=_record.getXFIndex();

        if (formula==null) {
            notifyFormulaChanging();
            setCellType(CELL_TYPE_BLANK, false, row, col, styleIndex);
            return;
        }
        int sheetIndex = _book.getSheetIndex(_sheet);
        Ptg[] ptgs = HSSFFormulaParser.parse(formula, _book, FormulaType.CELL, sheetIndex);
        setCellType(CELL_TYPE_FORMULA, false, row, col, styleIndex);
        FormulaRecordAggregate agg = (FormulaRecordAggregate) _record;
        FormulaRecord frec = agg.getFormulaRecord();
        frec.setOptions((short) 2);
        frec.setValue(0);

        
        if (agg.getXFIndex() == (short)0) {
            agg.setXFIndex((short) 0x0f);
        }
        agg.setParsedExpression(ptgs);
    }
    
    private void notifyFormulaChanging() {
        if (_record instanceof FormulaRecordAggregate) {
            ((FormulaRecordAggregate)_record).notifyFormulaChanging();
        }
    }

    public String getCellFormula() {
        if (!(_record instanceof FormulaRecordAggregate)) {
            throw typeMismatch(CELL_TYPE_FORMULA, _cellType, true);
        }
        return HSSFFormulaParser.toFormulaString(_book, ((FormulaRecordAggregate)_record).getFormulaTokens());
    }

    
    private static String getCellTypeName(int cellTypeCode) {
        switch (cellTypeCode) {
            case CELL_TYPE_BLANK:   return ""blank"";
            case CELL_TYPE_STRING:  return ""text"";
            case CELL_TYPE_BOOLEAN: return ""boolean"";
            case CELL_TYPE_ERROR:   return ""error"";
            case CELL_TYPE_NUMERIC: return ""numeric"";
            case CELL_TYPE_FORMULA: return ""formula"";
        }
        return ""#unknown cell type ("" + cellTypeCode + "")#"";
    }

    private static RuntimeException typeMismatch(int expectedTypeCode, int actualTypeCode, boolean isFormulaCell) {
        String msg = ""Cannot get a ""
            + getCellTypeName(expectedTypeCode) + "" value from a ""
            + getCellTypeName(actualTypeCode) + "" "" + (isFormulaCell ? ""formula "" : """") + ""cell"";
        return new IllegalStateException(msg);
    }
    private static void checkFormulaCachedValueType(int expectedTypeCode, FormulaRecord fr) {
        int cachedValueType = fr.getCachedResultType();
        if (cachedValueType != expectedTypeCode) {
            throw typeMismatch(expectedTypeCode, cachedValueType, true);
        }
    }

    
    public double getNumericCellValue() {

        switch(_cellType) {
            case CELL_TYPE_BLANK:
                return 0.0;
            case CELL_TYPE_NUMERIC:
                return ((NumberRecord)_record).getValue();
            default:
                throw typeMismatch(CELL_TYPE_NUMERIC, _cellType, false);
            case CELL_TYPE_FORMULA:
                break;
        }
        FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();
        checkFormulaCachedValueType(CELL_TYPE_NUMERIC, fr);
        return fr.getValue();
    }

    
    public Date getDateCellValue() {

        if (_cellType == CELL_TYPE_BLANK) {
            return null;
        }
        double value = getNumericCellValue();
        if (_book.getWorkbook().isUsing1904DateWindowing()) {
            return HSSFDateUtil.getJavaDate(value, true);
        }
        return HSSFDateUtil.getJavaDate(value, false);
    }

    
    public String getStringCellValue()
    {
      HSSFRichTextString str = getRichStringCellValue();
      return str.getString();
    }

    
    public HSSFRichTextString getRichStringCellValue() {

        switch(_cellType) {
            case CELL_TYPE_BLANK:
                return new HSSFRichTextString("""");
            case CELL_TYPE_STRING:
                return _stringValue;
            default:
                throw typeMismatch(CELL_TYPE_STRING, _cellType, false);
            case CELL_TYPE_FORMULA:
                break;
        }
        FormulaRecordAggregate fra = ((FormulaRecordAggregate)_record);
        checkFormulaCachedValueType(CELL_TYPE_STRING, fra.getFormulaRecord());
        String strVal = fra.getStringValue();
        return new HSSFRichTextString(strVal == null ? """" : strVal);
    }

    
    public void setCellValue(boolean value) {
        int row=_record.getRow();
        short col=_record.getColumn();
        short styleIndex=_record.getXFIndex();

        switch (_cellType) {
            default:
                setCellType(CELL_TYPE_BOOLEAN, false, row, col, styleIndex);
            case CELL_TYPE_BOOLEAN:
                (( BoolErrRecord ) _record).setValue(value);
                break;
            case CELL_TYPE_FORMULA:
                ((FormulaRecordAggregate)_record).setCachedBooleanResult(value);
                break;
        }
    }

    
    public void setCellErrorValue(byte errorCode) {
        int row=_record.getRow();
        short col=_record.getColumn();
        short styleIndex=_record.getXFIndex();
        switch (_cellType) {
            default:
                setCellType(CELL_TYPE_ERROR, false, row, col, styleIndex);
            case CELL_TYPE_ERROR:
                (( BoolErrRecord ) _record).setValue(errorCode);
                break;
            case CELL_TYPE_FORMULA:
                ((FormulaRecordAggregate)_record).setCachedErrorResult(errorCode);
                break;
        }
    }
    
    private boolean convertCellValueToBoolean() {

        switch (_cellType) {
            case CELL_TYPE_BOOLEAN:
                return (( BoolErrRecord ) _record).getBooleanValue();
            case CELL_TYPE_STRING:
                int sstIndex = ((LabelSSTRecord)_record).getSSTIndex();
                String text = _book.getWorkbook().getSSTString(sstIndex).getString();
                return Boolean.valueOf(text).booleanValue();
            case CELL_TYPE_NUMERIC:
                return ((NumberRecord)_record).getValue() != 0;

            case CELL_TYPE_FORMULA:
                
                FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();
                checkFormulaCachedValueType(CELL_TYPE_BOOLEAN, fr);
                return fr.getCachedBooleanValue();
            
            
            case CELL_TYPE_ERROR:
            case CELL_TYPE_BLANK:
                return false;
        }
        throw new RuntimeException(""Unexpected cell type ("" + _cellType + "")"");
    }
    private String convertCellValueToString() {

        switch (_cellType) {
            case CELL_TYPE_BLANK:
                return """";
            case CELL_TYPE_BOOLEAN:
                return ((BoolErrRecord) _record).getBooleanValue() ? ""TRUE"" : ""FALSE"";
            case CELL_TYPE_STRING:
                int sstIndex = ((LabelSSTRecord)_record).getSSTIndex();
                return _book.getWorkbook().getSSTString(sstIndex).getString();
            case CELL_TYPE_NUMERIC:
                return NumberToTextConverter.toText(((NumberRecord)_record).getValue());
            case CELL_TYPE_ERROR:
                   return HSSFErrorConstants.getText(((BoolErrRecord) _record).getErrorValue());
            case CELL_TYPE_FORMULA:
                
                
                break;
            default:
                throw new IllegalStateException(""Unexpected cell type ("" + _cellType + "")"");
        }
        FormulaRecordAggregate fra = ((FormulaRecordAggregate)_record);
        FormulaRecord fr = fra.getFormulaRecord();
        switch (fr.getCachedResultType()) {
            case CELL_TYPE_BOOLEAN:
                return fr.getCachedBooleanValue() ? ""TRUE"" : ""FALSE"";
            case CELL_TYPE_STRING:
                return fra.getStringValue();
            case CELL_TYPE_NUMERIC:
                return NumberToTextConverter.toText(fr.getValue());
            case CELL_TYPE_ERROR:
                   return HSSFErrorConstants.getText(fr.getCachedErrorValue());
        }
        throw new IllegalStateException(""Unexpected formula result type ("" + _cellType + "")"");
    }

    
    public boolean getBooleanCellValue() {

        switch(_cellType) {
            case CELL_TYPE_BLANK:
                return false;
            case CELL_TYPE_BOOLEAN:
                return (( BoolErrRecord ) _record).getBooleanValue();
            default:
                throw typeMismatch(CELL_TYPE_BOOLEAN, _cellType, false);
            case CELL_TYPE_FORMULA:
                break;
        }
        FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();
        checkFormulaCachedValueType(CELL_TYPE_BOOLEAN, fr);
        return fr.getCachedBooleanValue();
    }

    
    public byte getErrorCellValue() {
        switch(_cellType) {
            case CELL_TYPE_ERROR:
                return (( BoolErrRecord ) _record).getErrorValue();
            default:
                throw typeMismatch(CELL_TYPE_ERROR, _cellType, false);
            case CELL_TYPE_FORMULA:
                break;
        }
        FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();
        checkFormulaCachedValueType(CELL_TYPE_ERROR, fr);
        return (byte) fr.getCachedErrorValue();
    }

    
    public void setCellStyle(CellStyle style) {
        setCellStyle( (HSSFCellStyle)style );
    }
    public void setCellStyle(HSSFCellStyle style) {
        
        if (style == null) {
            _record.setXFIndex((short)0xf);
            return;
        }

        
        style.verifyBelongsToWorkbook(_book);

        short styleIndex;
        if(style.getUserStyleName() != null) {
            styleIndex = applyUserCellStyle(style);
        } else {
            styleIndex = style.getIndex();
        }

        
        _record.setXFIndex(styleIndex);
    }

    
    public HSSFCellStyle getCellStyle()
    {
      short styleIndex=_record.getXFIndex();
      ExtendedFormatRecord xf = _book.getWorkbook().getExFormatAt(styleIndex);
      return new HSSFCellStyle(styleIndex, xf, _book);
    }

    

    protected CellValueRecordInterface getCellValueRecord()
    {
        return _record;
    }

    
    private static void checkBounds(int cellIndex) {
        if (cellIndex < 0 || cellIndex > LAST_COLUMN_NUMBER) {
            throw new IllegalArgumentException(""Invalid column index ("" + cellIndex
                    + "").  Allowable column range for "" + FILE_FORMAT_NAME + "" is (0..""
                    + LAST_COLUMN_NUMBER + "") or ('A'..'"" + LAST_COLUMN_NAME + ""')"");
        }
    }

    
    public void setAsActiveCell()
    {
        int row=_record.getRow();
        short col=_record.getColumn();
        _sheet.getSheet().setActiveCellRow(row);
        _sheet.getSheet().setActiveCellCol(col);
    }

    
    public String toString() {
        switch (getCellType()) {
            case CELL_TYPE_BLANK:
                return """";
            case CELL_TYPE_BOOLEAN:
                return getBooleanCellValue()?""TRUE"":""FALSE"";
            case CELL_TYPE_ERROR:
                return ErrorEval.getText((( BoolErrRecord ) _record).getErrorValue());
            case CELL_TYPE_FORMULA:
                return getCellFormula();
            case CELL_TYPE_NUMERIC:
                
                if (HSSFDateUtil.isCellDateFormatted(this)) {
                    DateFormat sdf = new SimpleDateFormat(""dd-MMM-yyyy"");
                    return sdf.format(getDateCellValue());
                }
				return  String.valueOf(getNumericCellValue());
            case CELL_TYPE_STRING:
                return getStringCellValue();
            default:
                return ""Unknown Cell Type: "" + getCellType();
        }
    }

    
    public void setCellComment(Comment comment){
        if(comment == null) {
            removeCellComment();
            return;
        }

        comment.setRow(_record.getRow());
        comment.setColumn(_record.getColumn());
        _comment = (HSSFComment)comment;
    }

    
     public HSSFComment getCellComment(){
        if (_comment == null) {
            _comment = _sheet.findCellComment(_record.getRow(), _record.getColumn());
        }
        return _comment;
    }

    
    public void removeCellComment() {
        HSSFComment comment = _sheet.findCellComment(_record.getRow(), _record.getColumn());
        _comment = null;
        if (null == comment){
            return;
        }
        _sheet.getDrawingPatriarch().removeShape(comment);
    }

    
    public HSSFHyperlink getHyperlink(){
        for (Iterator<RecordBase> it = _sheet.getSheet().getRecords().iterator(); it.hasNext(); ) {
            RecordBase rec = it.next();
            if (rec instanceof HyperlinkRecord){
                HyperlinkRecord link = (HyperlinkRecord)rec;
                if(link.getFirstColumn() == _record.getColumn() && link.getFirstRow() == _record.getRow()){
                    return new HSSFHyperlink(link);
                }
            }
        }
        return null;
    }

    
    public void setHyperlink(Hyperlink hyperlink){
        if (hyperlink == null) {
            removeHyperlink();
            return;
        }

        HSSFHyperlink link = (HSSFHyperlink)hyperlink;

        link.setFirstRow(_record.getRow());
        link.setLastRow(_record.getRow());
        link.setFirstColumn(_record.getColumn());
        link.setLastColumn(_record.getColumn());

        switch(link.getType()){
            case HSSFHyperlink.LINK_EMAIL:
            case HSSFHyperlink.LINK_URL:
                link.setLabel(""url"");
                break;
            case HSSFHyperlink.LINK_FILE:
                link.setLabel(""file"");
                break;
            case HSSFHyperlink.LINK_DOCUMENT:
                link.setLabel(""place"");
                break;
        }

        List<RecordBase> records = _sheet.getSheet().getRecords();
        int eofLoc = records.size() - 1;
        records.add( eofLoc, link.record );
    }

    
    public void removeHyperlink() {
        for (Iterator<RecordBase> it = _sheet.getSheet().getRecords().iterator(); it.hasNext();) {
            RecordBase rec = it.next();
            if (rec instanceof HyperlinkRecord) {
                HyperlinkRecord link = (HyperlinkRecord) rec;
                if (link.getFirstColumn() == _record.getColumn() && link.getFirstRow() == _record.getRow()) {
                    it.remove();
                    return;
                }
            }
        }
    }

    
    public int getCachedFormulaResultType() {
        if (_cellType != CELL_TYPE_FORMULA) {
            throw new IllegalStateException(""Only formula cells have cached results"");
        }
        return ((FormulaRecordAggregate)_record).getFormulaRecord().getCachedResultType();
    }

    void setCellArrayFormula(CellRangeAddress range) {
        int row = _record.getRow();
        short col = _record.getColumn();
        short styleIndex = _record.getXFIndex();
        setCellType(CELL_TYPE_FORMULA, false, row, col, styleIndex);

        
        Ptg[] ptgsForCell = {new ExpPtg(range.getFirstRow(), range.getFirstColumn())};
        FormulaRecordAggregate agg = (FormulaRecordAggregate) _record;
        agg.setParsedExpression(ptgsForCell);
    }

    public CellRangeAddress getArrayFormulaRange() {
        if (_cellType != CELL_TYPE_FORMULA) {
            String ref = new CellReference(this).formatAsString();
            throw new IllegalStateException(""Cell "" + ref
                    + "" is not part of an array formula."");
        }
        return ((FormulaRecordAggregate)_record).getArrayFormulaRange();
    }

    public boolean isPartOfArrayFormulaGroup() {
        if (_cellType != CELL_TYPE_FORMULA) {
            return false;
        }
        return ((FormulaRecordAggregate)_record).isPartOfArrayFormula();
    }

    
    void notifyArrayFormulaChanging(String msg){
        CellRangeAddress cra = getArrayFormulaRange();
        if(cra.getNumberOfCells() > 1) {
            throw new IllegalStateException(msg);
        }
        
        getRow().getSheet().removeArrayFormula(this);
    }

    
    void notifyArrayFormulaChanging(){
        CellReference ref = new CellReference(this);
        String msg = ""Cell ""+ref.formatAsString()+"" is part of a multi-cell array formula. "" +
                ""You cannot change part of an array."";
        notifyArrayFormulaChanging(msg);
    }

    
    private short applyUserCellStyle(HSSFCellStyle style){
        if(style.getUserStyleName() == null) {
            throw new IllegalArgumentException(""Expected user-defined style"");
        }

        InternalWorkbook iwb = _book.getWorkbook();
        short userXf = -1;
        int numfmt = iwb.getNumExFormats();
        for(short i = 0; i < numfmt; i++){
            ExtendedFormatRecord xf = iwb.getExFormatAt(i);
            if(xf.getXFType() == ExtendedFormatRecord.XF_CELL && xf.getParentIndex() == style.getIndex() ){
                userXf = i;
                break;
            }
        }
        short styleIndex;
        if (userXf == -1){
            ExtendedFormatRecord xfr = iwb.createCellXF();
            xfr.cloneStyleFrom(iwb.getExFormatAt(style.getIndex()));
            xfr.setIndentionOptions((short)0);
            xfr.setXFType(ExtendedFormatRecord.XF_CELL);
            xfr.setParentIndex(style.getIndex());
            styleIndex = (short)numfmt;
        } else {
            styleIndex = userXf;
        }

        return styleIndex;
    }
}
"
poi,3,org.apache.poi.poifs.storage.BlockAllocationTableWriter,8,1,0,7,17,0,2,5,7,0.571428571,134,1.0,2,0.0,0.458333333,0,0,15.375,3,1.375,1,"

package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.util.IntList;


public final class BlockAllocationTableWriter implements BlockWritable, BATManaged {
    private IntList    _entries;
    private BATBlock[] _blocks;
    private int        _start_block;
    private POIFSBigBlockSize _bigBlockSize;

    
    public BlockAllocationTableWriter(POIFSBigBlockSize bigBlockSize)
    {
       _bigBlockSize = bigBlockSize; 
        _start_block  = POIFSConstants.END_OF_CHAIN;
        _entries      = new IntList();
        _blocks       = new BATBlock[ 0 ];
    }

    
    public int createBlocks()
    {
        int xbat_blocks = 0;
        int bat_blocks  = 0;

        while (true)
        {
            int calculated_bat_blocks  =
                BATBlock.calculateStorageRequirements(_bigBlockSize,
                                                      bat_blocks
                                                      + xbat_blocks
                                                      + _entries.size());
            int calculated_xbat_blocks =
                HeaderBlockWriter.calculateXBATStorageRequirements(
                      _bigBlockSize, calculated_bat_blocks);

            if ((bat_blocks == calculated_bat_blocks)
                    && (xbat_blocks == calculated_xbat_blocks))
            {

                
                break;
            }
            bat_blocks  = calculated_bat_blocks;
            xbat_blocks = calculated_xbat_blocks;
        }
        int startBlock = allocateSpace(bat_blocks);

        allocateSpace(xbat_blocks);
        simpleCreateBlocks();
        return startBlock;
    }

    
    public int allocateSpace(final int blockCount)
    {
        int startBlock = _entries.size();

        if (blockCount > 0)
        {
            int limit = blockCount - 1;
            int index = startBlock + 1;

            for (int k = 0; k < limit; k++)
            {
                _entries.add(index++);
            }
            _entries.add(POIFSConstants.END_OF_CHAIN);
        }
        return startBlock;
    }

    
    public int getStartBlock()
    {
        return _start_block;
    }

    
    void simpleCreateBlocks()
    {
        _blocks = BATBlock.createBATBlocks(_bigBlockSize, _entries.toArray());
    }

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        for (int j = 0; j < _blocks.length; j++)
        {
            _blocks[ j ].writeBlocks(stream);
        }
    }
    
    
    public static void writeBlock(final BATBlock bat, final ByteBuffer block) 
        throws IOException
    {
        bat.writeData(block);
    }

    
    public int countBlocks()
    {
        return _blocks.length;
    }

    
    public void setStartBlock(int start_block)
    {
        _start_block = start_block;
    }
}
"
poi,3,org.apache.poi.poifs.dev.POIFSViewer,3,1,0,2,21,3,0,2,2,2.0,112,0.0,0,0.0,0.333333333,0,0,36.33333333,4,2.3333,0,"

        

package org.apache.poi.poifs.dev;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;



public class POIFSViewer
{

    

    public static void main(final String args[])
    {
        if (args.length < 0)
        {
            System.err.println(""Must specify at least one file to view"");
            System.exit(1);
        }
        boolean printNames = (args.length > 1);

        for (int j = 0; j < args.length; j++)
        {
            viewFile(args[ j ], printNames);
        }
    }

    private static void viewFile(final String filename,
                                 final boolean printName)
    {
        if (printName)
        {
            StringBuffer flowerbox = new StringBuffer();

            flowerbox.append(""."");
            for (int j = 0; j < filename.length(); j++)
            {
                flowerbox.append(""-"");
            }
            flowerbox.append(""."");
            System.out.println(flowerbox);
            System.out.println(""|"" + filename + ""|"");
            System.out.println(flowerbox);
        }
        try
        {
            POIFSViewable fs      =
                new NPOIFSFileSystem(new File(filename));
            List<String>  strings = POIFSViewEngine.inspectViewable(fs, true,
                                        0, ""  "");
            Iterator<String> iter = strings.iterator();

            while (iter.hasNext())
            {
                System.out.print(iter.next());
            }
        }
        catch (IOException e)
        {
            System.out.println(e.getMessage());
        }
    }
}   

"
poi,3,org.apache.poi.util.StringUtil,14,1,0,12,42,91,12,0,12,1.076923077,458,1.0,0,0.0,0.255102041,0,0,31.64285714,10,2.5714,1,"

package org.apache.poi.util;

import java.nio.charset.Charset;
import java.text.FieldPosition;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;

import org.apache.poi.hssf.record.RecordInputStream;

public class StringUtil {
	private static final Charset ISO_8859_1 = Charset.forName(""ISO-8859-1"");
	private static final Charset UTF16LE = Charset.forName(""UTF-16LE"");
    private static Map<Integer,Integer> msCodepointToUnicode;

	private StringUtil() {
		
	}

	
	public static String getFromUnicodeLE(
		final byte[] string,
		final int offset,
		final int len)
		throws ArrayIndexOutOfBoundsException, IllegalArgumentException {
		if ((offset < 0) || (offset >= string.length)) {
			throw new ArrayIndexOutOfBoundsException(""Illegal offset "" + offset + "" (String data is of length "" + string.length + "")"");
		}
		if ((len < 0) || (((string.length - offset) / 2) < len)) {
			throw new IllegalArgumentException(""Illegal length "" + len);
		}

		return new String(string, offset, len * 2, UTF16LE);
	}

	
	public static String getFromUnicodeLE(byte[] string) {
        if(string.length == 0) { return """"; }
        return getFromUnicodeLE(string, 0, string.length / 2);
	}
	
	
	public static byte[] getToUnicodeLE(String string) {
	    return string.getBytes(UTF16LE);
	}

	
	public static String getFromCompressedUnicode(
		final byte[] string,
		final int offset,
		final int len) {
		int len_to_use = Math.min(len, string.length - offset);
		return new String(string, offset, len_to_use, ISO_8859_1);
	}
	
	public static String readCompressedUnicode(LittleEndianInput in, int nChars) {
		byte[] buf = new byte[nChars];
		in.readFully(buf);
		return new String(buf, ISO_8859_1);
	}
	
	
	public static String readUnicodeString(LittleEndianInput in) {

		int nChars = in.readUShort();
		byte flag = in.readByte();
		if ((flag & 0x01) == 0) {
			return readCompressedUnicode(in, nChars);
		}
		return readUnicodeLE(in, nChars);
	}
	
	public static String readUnicodeString(LittleEndianInput in, int nChars) {
		byte is16Bit = in.readByte();
		if ((is16Bit & 0x01) == 0) {
			return readCompressedUnicode(in, nChars);
		}
		return readUnicodeLE(in, nChars);
	}
	
	public static void writeUnicodeString(LittleEndianOutput out, String value) {

		int nChars = value.length();
		out.writeShort(nChars);
		boolean is16Bit = hasMultibyte(value);
		out.writeByte(is16Bit ? 0x01 : 0x00);
		if (is16Bit) {
			putUnicodeLE(value, out);
		} else {
			putCompressedUnicode(value, out);
		}
	}
	
	public static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String value) {
		boolean is16Bit = hasMultibyte(value);
		out.writeByte(is16Bit ? 0x01 : 0x00);
		if (is16Bit) {
			putUnicodeLE(value, out);
		} else {
			putCompressedUnicode(value, out);
		}
	}

	
	public static int getEncodedSize(String value) {
		int result = 2 + 1;
		result += value.length() * (StringUtil.hasMultibyte(value) ? 2 : 1);
		return result;
	}

	
	public static void putCompressedUnicode(String input, byte[] output, int offset) {
		byte[] bytes = input.getBytes(ISO_8859_1);
		System.arraycopy(bytes, 0, output, offset, bytes.length);
	}

	public static void putCompressedUnicode(String input, LittleEndianOutput out) {
		byte[] bytes = input.getBytes(ISO_8859_1);
		out.write(bytes);
	}

	
	public static void putUnicodeLE(String input, byte[] output, int offset) {
		byte[] bytes = input.getBytes(UTF16LE);
		System.arraycopy(bytes, 0, output, offset, bytes.length);
	}
	public static void putUnicodeLE(String input, LittleEndianOutput out) {
		byte[] bytes = input.getBytes(UTF16LE);
		out.write(bytes);
	}

	public static String readUnicodeLE(LittleEndianInput in, int nChars) {
        byte[] bytes = new byte[nChars*2];
        in.readFully(bytes);
        return new String(bytes, UTF16LE);
	}

	
	public static String format(String message, Object[] params) {
		int currentParamNumber = 0;
		StringBuffer formattedMessage = new StringBuffer();
		for (int i = 0; i < message.length(); i++) {
			if (message.charAt(i) == '%') {
				if (currentParamNumber >= params.length) {
					formattedMessage.append(""?missing data?"");
				} else if (
					(params[currentParamNumber] instanceof Number)
						&& (i + 1 < message.length())) {
					i
						+= matchOptionalFormatting(
							(Number) params[currentParamNumber++],
							message.substring(i + 1),
							formattedMessage);
				} else {
					formattedMessage.append(
						params[currentParamNumber++].toString());
				}
			} else {
				if ((message.charAt(i) == '\')
					&& (i + 1 < message.length())
					&& (message.charAt(i + 1) == '%')) {
					formattedMessage.append('%');
					i++;
				} else {
					formattedMessage.append(message.charAt(i));
				}
			}
		}
		return formattedMessage.toString();
	}


	private static int matchOptionalFormatting(
		Number number,
		String formatting,
		StringBuffer outputTo) {
		NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
		if ((0 < formatting.length())
			&& Character.isDigit(formatting.charAt(0))) {
			numberFormat.setMinimumIntegerDigits(
				Integer.parseInt(formatting.charAt(0) + """"));
			if ((2 < formatting.length())
				&& (formatting.charAt(1) == '.')
				&& Character.isDigit(formatting.charAt(2))) {
				numberFormat.setMaximumFractionDigits(
					Integer.parseInt(formatting.charAt(2) + """"));
				numberFormat.format(number, outputTo, new FieldPosition(0));
				return 3;
			}
			numberFormat.format(number, outputTo, new FieldPosition(0));
			return 1;
		} else if (
			(0 < formatting.length()) && (formatting.charAt(0) == '.')) {
			if ((1 < formatting.length())
				&& Character.isDigit(formatting.charAt(1))) {
				numberFormat.setMaximumFractionDigits(
					Integer.parseInt(formatting.charAt(1) + """"));
				numberFormat.format(number, outputTo, new FieldPosition(0));
				return 2;
			}
		}
		numberFormat.format(number, outputTo, new FieldPosition(0));
		return 1;
	}

	
	public static String getPreferredEncoding() {
		return ISO_8859_1.name();
	}

	
	public static boolean hasMultibyte(String value) {
		if (value == null)
			return false;
		for (int i = 0; i < value.length(); i++) {
			char c = value.charAt(i);
			if (c > 0xFF) {
				return true;
			}
		}
		return false;
	}

	
	public static boolean isUnicodeString(final String value) {
        return !value.equals(new String(value.getBytes(ISO_8859_1), ISO_8859_1));
	}
	
   
   public static class StringsIterator implements Iterator<String> {
      private String[] strings;
      private int position = 0;
      public StringsIterator(String[] strings) {
         if(strings != null) {
            this.strings = strings;
         } else {
            this.strings = new String[0];
         }
      }

      public boolean hasNext() {
         return position < strings.length;
      }
      public String next() {
         int ourPos = position++;
         if(ourPos >= strings.length)
            throw new ArrayIndexOutOfBoundsException(ourPos);
         return strings[ourPos];
      }
      public void remove() {}
   }


   
   public static String mapMsCodepointString(String string) {
       if (string == null || """".equals(string)) return string;
       initMsCodepointMap();
       
       StringBuilder sb = new StringBuilder();
       final int length = string.length();
       for (int offset = 0; offset < length; ) {
          Integer msCodepoint = string.codePointAt(offset);
          Integer uniCodepoint = msCodepointToUnicode.get(msCodepoint);
          sb.appendCodePoint(uniCodepoint == null ? msCodepoint : uniCodepoint);
          offset += Character.charCount(msCodepoint);
       }
       
       return sb.toString();
   }
   
   public static synchronized void mapMsCodepoint(int msCodepoint, int unicodeCodepoint) {
       initMsCodepointMap();
       msCodepointToUnicode.put(msCodepoint, unicodeCodepoint);
   }
   
   private static synchronized void initMsCodepointMap() {
       if (msCodepointToUnicode != null) return;
       msCodepointToUnicode = new HashMap<Integer,Integer>();
       int i=0xF020;
       for (int ch : symbolMap_f020) {
           msCodepointToUnicode.put(i++, ch);
       }
       i = 0xf0a0;
       for (int ch : symbolMap_f0a0) {
           msCodepointToUnicode.put(i++, ch);
       }       
   }
   
   private static final int symbolMap_f020[] = {
       ' ', 
       '!', 
       8704, 
       '#', 
       8707, 
       '%', 
       '&', 
       8717, 
       '(', 
       ')', 
       8727, 
       '+', 
       ',', 
       8722, 
       '.', 
       '/', 
       '0', 
       '1', 
       '2', 
       '3', 
       '4', 
       '5', 
       '6', 
       '7', 
       '8', 
       '9', 
       ':', 
       ';', 
       '<', 
       '=', 
       '>', 
       '?', 
       8773, 
       913, 
       914, 
       935, 
       916, 
       917, 
       934, 
       915, 
       919, 
       921, 
       977, 
       922, 
       923, 
       924, 
       925, 
       927, 
       928, 
       920, 
       929, 
       931, 
       932, 
       933, 
       962, 
       937, 
       926, 
       936, 
       918, 
       '[', 
       8765, 
       ']', 
       8869, 
       '_', 
       ' ', 
       945, 
       946, 
       967, 
       948, 
       949, 
       966, 
       947, 
       951, 
       953, 
       981, 
       954, 
       955, 
       956, 
       957, 
       959, 
       960, 
       952, 
       961, 
       963, 
       964, 
       965, 
       982, 
       969, 
       958, 
       968, 
       950, 
       '{', 
       '|', 
       '}', 
       8764, 
       ' ', 
   };

   private static final int symbolMap_f0a0[] = {
       8364, 
       978, 
       8242, 
       8804, 
       8260, 
       8734, 
       402, 
       9827, 
       9830, 
       9829, 
       9824, 
       8596, 
       8591, 
       8593, 
       8594, 
       8595, 
       176, 
       177, 
       8243, 
       8805, 
       215, 
       181, 
       8706, 
       8729, 
       247, 
       8800, 
       8801, 
       8776, 
       8230, 
       9168, 
       9135, 
       8629, 
       8501, 
       8475, 
       8476, 
       8472, 
       8855, 
       8853, 
       8709, 
       8745, 
       8746, 
       8835, 
       8839, 
       8836, 
       8834, 
       8838, 
       8712, 
       8713, 
       8736, 
       8711, 
       174, 
       169, 
       8482, 
       8719, 
       8730, 
       8901, 
       172, 
       8743, 
       8744, 
       8660, 
       8656, 
       8657, 
       8658, 
       8659, 
       9674, 
       9001, 
       174, 
       169, 
       8482, 
       8721, 
       9115, 
       9116, 
       9117, 
       9121, 
       9122, 
       9123, 
       9127, 
       9128, 
       9129, 
       9130, 
       ' ', 
       9002, 
       8747, 
       8992, 
       9134, 
       8993, 
       9118, 
       9119, 
       9120, 
       9124, 
       9125, 
       9126, 
       9131, 
       9132, 
       9133, 
       ' ', 
   };
}
"
poi,3,org.apache.poi.hssf.record.BlankRecord,22,2,0,10,34,199,5,5,20,0.714285714,331,0.75,0,0.35483871,0.227272727,1,4,13.86363636,7,1.9091,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class BlankRecord extends StandardRecord implements CellValueRecordInterface {
    public final static short sid = 0x0201;
    private int             field_1_row;
    private short             field_2_col;
    private short             field_3_xf;

    
    public BlankRecord()
    {
    }

    public BlankRecord(RecordInputStream in)
    {
        field_1_row = in.readUShort();
        field_2_col = in.readShort();
        field_3_xf  = in.readShort();
    }

    
    public void setRow(int row)
    {
        field_1_row = row;
    }

    
    public int getRow()
    {
        return field_1_row;
    }

    
    public short getColumn()
    {
        return field_2_col;
    }

    
    public void setXFIndex(short xf)
    {
        field_3_xf = xf;
    }

    
    public short getXFIndex()
    {
        return field_3_xf;
    }

    

    public void setColumn(short col)
    {
        field_2_col = col;
    }

    
    public short getSid()
    {
        return sid;
    }

    public String toString()
    {
        StringBuffer sb = new StringBuffer();

        sb.append(""[BLANK]
"");
        sb.append(""    row= "").append(HexDump.shortToHex(getRow())).append(""
"");
        sb.append(""    col= "").append(HexDump.shortToHex(getColumn())).append(""
"");
        sb.append(""    xf = "").append(HexDump.shortToHex(getXFIndex())).append(""
"");
        sb.append(""[/BLANK]
"");
        return sb.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getRow());
        out.writeShort(getColumn());
        out.writeShort(getXFIndex());
    }

    protected int getDataSize() {
        return 6;
    }

    public Object clone() {
      BlankRecord rec = new BlankRecord();
      rec.field_1_row = field_1_row;
      rec.field_2_col = field_2_col;
      rec.field_3_xf = field_3_xf;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.DrawingRecordForBiffViewer,4,3,0,3,6,6,1,2,3,1.333333333,16,0.0,0,0.923076923,0.625,1,2,2.75,1,0.5,0,"

package org.apache.poi.hssf.record;

import java.io.ByteArrayInputStream;


public final class DrawingRecordForBiffViewer extends AbstractEscherHolderRecord {
    public static final short sid = 0xEC;

    public DrawingRecordForBiffViewer()
    {
    }

    public DrawingRecordForBiffViewer( RecordInputStream in)
    {
        super(in);
    }

    public DrawingRecordForBiffViewer(DrawingRecord r)
    {
    	super(convertToInputStream(r));
    	convertRawBytesToEscherRecords();
    }
    private static RecordInputStream convertToInputStream(DrawingRecord r)
    {
    	byte[] data = r.serialize();
    	RecordInputStream rinp = new RecordInputStream(
    			new ByteArrayInputStream(data)
    	);
    	rinp.nextRecord();
    	return rinp;
    }

    protected String getRecordName()
    {
        return ""MSODRAWING"";
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.ddf.EscherDgRecord,13,2,0,8,29,34,3,5,13,0.854166667,179,0.5,0,0.612903226,0.323076923,1,5,12.46153846,1,0.9231,1,"


package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public class EscherDgRecord
    extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF008;
    public static final String RECORD_DESCRIPTION = ""MsofbtDg"";

    private int field_1_numShapes;
    private int field_2_lastMSOSPID;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
         readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;
        field_1_numShapes   =  LittleEndian.getInt( data, pos + size );     size += 4;
        field_2_lastMSOSPID =  LittleEndian.getInt( data, pos + size );     size += 4;



        return getRecordSize();
    }

    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );
        LittleEndian.putInt( data, offset + 4, 8 );
        LittleEndian.putInt( data, offset + 8, field_1_numShapes );
        LittleEndian.putInt( data, offset + 12, field_2_lastMSOSPID );



        listener.afterRecordSerialize( offset + 16, getRecordId(), getRecordSize(), this );
        return getRecordSize();
    }

    
    public int getRecordSize()
    {
        return 8 + 8;
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""Dg"";
    }

    
    public String toString() {
        return getClass().getName() + "":"" + '
' +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + '
' +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + '
' +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + '
' +
                ""  NumShapes: "" + field_1_numShapes + '
' +
                ""  LastMSOSPID: "" + field_2_lastMSOSPID + '
';
    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<NumShapes>"").append(field_1_numShapes).append(""</NumShapes>
"")
                .append(tab).append(""	"").append(""<LastMSOSPID>"").append(field_2_lastMSOSPID).append(""</LastMSOSPID>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public int getNumShapes()
    {
        return field_1_numShapes;
    }

    
    public void setNumShapes( int field_1_numShapes )
    {
        this.field_1_numShapes = field_1_numShapes;
    }

    
    public int getLastMSOSPID()
    {
        return field_2_lastMSOSPID;
    }

    
    public void setLastMSOSPID( int field_2_lastMSOSPID )
    {
        this.field_2_lastMSOSPID = field_2_lastMSOSPID;
    }

    
    public short getDrawingGroupId()
    {
        return (short) ( getOptions() >> 4 );
    }

    public void incrementShapeCount()
    {
        this.field_1_numShapes++;
    }
}
"
poi,3,org.apache.poi.hssf.eventmodel.ERFListener,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.poi.hssf.eventmodel;

import org.apache.poi.hssf.record.Record;


public interface ERFListener
{
    
    public boolean processRecord(Record rec);
}
"
poi,3,org.apache.poi.hssf.record.SupBookRecord,12,2,0,6,22,44,2,4,10,0.757575758,123,0.666666667,0,0.523809524,0.316666667,1,4,9.0,2,0.9167,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;
import org.apache.poi.util.StringUtil;


public final class SupBookRecord extends StandardRecord {

    private final static POILogger logger = POILogFactory.getLogger(SupBookRecord.class);
	
    public final static short sid = 0x01AE;

    private static final short SMALL_RECORD_SIZE = 4;
    private static final short TAG_INTERNAL_REFERENCES = 0x0401;
    private static final short TAG_ADD_IN_FUNCTIONS = 0x3A01;

    private short field_1_number_of_sheets;
    private String field_2_encoded_url;
    private String[] field_3_sheet_names;
    private boolean _isAddInFunctions;

    protected static final char CH_VOLUME = 1;
    protected static final char CH_SAME_VOLUME = 2;
    protected static final char CH_DOWN_DIR = 3;
    protected static final char CH_UP_DIR = 4;
    protected static final char CH_LONG_VOLUME = 5;
    protected static final char CH_STARTUP_DIR = 6;
    protected static final char CH_ALT_STARTUP_DIR = 7;
    protected static final char CH_LIB_DIR = 8;
    protected static final String PATH_SEPERATOR = System.getProperty(""file.separator"");

    public static SupBookRecord createInternalReferences(short numberOfSheets) {
        return new SupBookRecord(false, numberOfSheets);
    }
    public static SupBookRecord createAddInFunctions() {
        return new SupBookRecord(true, (short)1 );
    }
    public static SupBookRecord createExternalReferences(String url, String[] sheetNames) {
        return new SupBookRecord(url, sheetNames);
    }
    private SupBookRecord(boolean isAddInFuncs, short numberOfSheets) {
        
        field_1_number_of_sheets = numberOfSheets;
        field_2_encoded_url = null;
        field_3_sheet_names = null;
        _isAddInFunctions = isAddInFuncs;
    }
    public SupBookRecord(String url, String[] sheetNames) {
        field_1_number_of_sheets = (short) sheetNames.length;
        field_2_encoded_url = url;
        field_3_sheet_names = sheetNames;
        _isAddInFunctions = false;
    }

    public boolean isExternalReferences() {
        return field_3_sheet_names != null;
    }
    public boolean isInternalReferences() {
        return field_3_sheet_names == null && !_isAddInFunctions;
    }
    public boolean isAddInFunctions() {
        return field_3_sheet_names == null && _isAddInFunctions;
    }
    
    public SupBookRecord(RecordInputStream in) {
        int recLen = in.remaining();

        field_1_number_of_sheets = in.readShort();

        if(recLen > SMALL_RECORD_SIZE) {
            
            _isAddInFunctions = false;

            field_2_encoded_url = in.readString();
            String[] sheetNames = new String[field_1_number_of_sheets];
            for (int i = 0; i < sheetNames.length; i++) {
                sheetNames[i] = in.readString();
            }
            field_3_sheet_names = sheetNames;
            return;
        }
        
        field_2_encoded_url = null;
        field_3_sheet_names = null;

        short nextShort = in.readShort();
        if(nextShort == TAG_INTERNAL_REFERENCES) {
            
            _isAddInFunctions = false;
        } else if(nextShort == TAG_ADD_IN_FUNCTIONS) {
            
            _isAddInFunctions = true;
            if(field_1_number_of_sheets != 1) {
                throw new RuntimeException(""Expected 0x0001 for number of sheets field in 'Add-In Functions' but got (""
                     + field_1_number_of_sheets + "")"");
            }
        } else {
            throw new RuntimeException(""invalid EXTERNALBOOK code (""
                     + Integer.toHexString(nextShort) + "")"");
        }
     }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(""[SUPBOOK "");

        if(isExternalReferences()) {
            sb.append(""External References]
"");
            sb.append("" .url     = "").append(field_2_encoded_url).append(""
"");
            sb.append("" .nSheets = "").append(field_1_number_of_sheets).append(""
"");
            for (String sheetname : field_3_sheet_names) {
                sb.append(""    .name = "").append(sheetname).append(""
"");
            }
            sb.append(""[/SUPBOOK"");
        } else if(_isAddInFunctions) {
            sb.append(""Add-In Functions"");
        } else {
            sb.append(""Internal References"");
            sb.append("" nSheets="").append(field_1_number_of_sheets);
        }
        sb.append(""]"");
        return sb.toString();
    }
    protected int getDataSize() {
        if(!isExternalReferences()) {
            return SMALL_RECORD_SIZE;
        }
        int sum = 2; 

        sum += StringUtil.getEncodedSize(field_2_encoded_url);

        for(int i=0; i<field_3_sheet_names.length; i++) {
            sum += StringUtil.getEncodedSize(field_3_sheet_names[i]);
        }
        return sum;
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_number_of_sheets);

        if(isExternalReferences()) {
            StringUtil.writeUnicodeString(out, field_2_encoded_url);

            for(int i=0; i<field_3_sheet_names.length; i++) {
                StringUtil.writeUnicodeString(out, field_3_sheet_names[i]);
            }
        } else {
            int field2val = _isAddInFunctions ? TAG_ADD_IN_FUNCTIONS : TAG_INTERNAL_REFERENCES;

            out.writeShort(field2val);
        }
    }

    public void setNumberOfSheets(short number){
        field_1_number_of_sheets = number;
    }

    public short getNumberOfSheets(){
        return field_1_number_of_sheets;
    }

    public short getSid()
    {
        return sid;
    }
    public String getURL() {
        String encodedUrl = field_2_encoded_url;
        switch(encodedUrl.charAt(0)) {
            case 0: 
                return encodedUrl.substring(1); 
            case 1: 
                return decodeFileName(encodedUrl);
            case 2: 
                return encodedUrl.substring(1);

        }
        return encodedUrl;
    }
    private static String decodeFileName(String encodedUrl) {
        
    	StringBuilder sb = new StringBuilder();
        for(int i=1; i<encodedUrl.length(); i++) {
        	char c = encodedUrl.charAt(i);
        	switch (c) {
        	case CH_VOLUME:
        		char driveLetter = encodedUrl.charAt(++i);
        		if (driveLetter == '@') {
        			sb.append(""\\"");
        		} else {
        			
        			sb.append(driveLetter).append("":"");
        		}
        		break;
        	case CH_SAME_VOLUME:
        		sb.append(PATH_SEPERATOR);
        		break;
        	case CH_DOWN_DIR:
        		sb.append(PATH_SEPERATOR);
        		break;
        	case CH_UP_DIR:
        		sb.append("".."").append(PATH_SEPERATOR);
        		break;
        	case CH_LONG_VOLUME:
        		
        		logger.log(POILogger.WARN, ""Found unexpected key: ChLongVolume - IGNORING"");
        		break;
        	case CH_STARTUP_DIR:
        	case CH_ALT_STARTUP_DIR:
        	case CH_LIB_DIR:
        		logger.log(POILogger.WARN, ""EXCEL.EXE path unkown - using this directoy instead: ."");
        		sb.append(""."").append(PATH_SEPERATOR);
        		break;
        	default:
        		sb.append(c);
        	}
        }
        return sb.toString();
    }
    public String[] getSheetNames() {
        return field_3_sheet_names.clone();
    }
    
    public void setURL(String pUrl) {
    	
    	field_2_encoded_url = field_2_encoded_url.substring(0, 1) + pUrl; 
    }
}
"
poi,3,org.apache.poi.hssf.record.TopMarginRecord,11,2,0,7,21,35,2,5,9,0.8,107,0.5,0,0.55,0.257575758,1,4,8.545454545,2,0.9091,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.*;


public final class TopMarginRecord extends StandardRecord implements Margin {
    public final static short sid = 0x28;
    private double field_1_margin;

    public TopMarginRecord()    {    }

    
    public TopMarginRecord( RecordInputStream in )
    {
        field_1_margin = in.readDouble();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();
        buffer.append( ""[TopMargin]
"" );
        buffer.append( ""    .margin               = "" ).append( "" ("" ).append( getMargin() ).append( "" )
"" );
        buffer.append( ""[/TopMargin]
"" );
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeDouble(field_1_margin);
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid()    {        return sid;    }

    
    public double getMargin()    {        return field_1_margin;    }

    
    public void setMargin( double field_1_margin )
    {        this.field_1_margin = field_1_margin;    }

    public Object clone()
    {
        TopMarginRecord rec = new TopMarginRecord();
        rec.field_1_margin = this.field_1_margin;
        return rec;
    }
}  "
poi,3,org.apache.poi.hssf.model.AbstractShape,6,1,5,23,30,15,6,22,3,2.0,207,0.0,0,0.0,0.333333333,0,0,33.5,7,2.5,0,"

package org.apache.poi.hssf.model;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.hssf.usermodel.*;


@Deprecated
public abstract class AbstractShape
{
    
    public static AbstractShape createShape( HSSFShape hssfShape, int shapeId )
    {
        AbstractShape shape;
        if (hssfShape instanceof HSSFComment)
        {
            shape = new CommentShape( (HSSFComment)hssfShape, shapeId );
        }
        else if (hssfShape instanceof HSSFTextbox)
        {
            shape = new TextboxShape( (HSSFTextbox)hssfShape, shapeId );
        }
        else if (hssfShape instanceof HSSFPolygon)
        {
            shape = new PolygonShape( (HSSFPolygon) hssfShape, shapeId );
        }
        else if (hssfShape instanceof HSSFSimpleShape)
        {
            HSSFSimpleShape simpleShape = (HSSFSimpleShape) hssfShape;
            switch ( simpleShape.getShapeType() )
            {
                case HSSFSimpleShape.OBJECT_TYPE_PICTURE:
                    shape = new PictureShape( simpleShape, shapeId );
                    break;
                case HSSFSimpleShape.OBJECT_TYPE_LINE:
                    shape = new LineShape( simpleShape, shapeId );
                    break;
                case HSSFSimpleShape.OBJECT_TYPE_OVAL:
                case HSSFSimpleShape.OBJECT_TYPE_RECTANGLE:
                    shape = new SimpleFilledShape( simpleShape, shapeId );
                    break;
                case HSSFSimpleShape.OBJECT_TYPE_COMBO_BOX:
                    shape = new ComboboxShape( simpleShape, shapeId );
                    break;
                default:
                    throw new IllegalArgumentException(""Do not know how to handle this type of shape"");
            }
        }
        else
        {
            throw new IllegalArgumentException(""Unknown shape type"");
        }
        EscherSpRecord sp = shape.getSpContainer().getChildById(EscherSpRecord.RECORD_ID);
        if (hssfShape.getParent() != null)
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_CHILD);
        return shape;
    }

    protected AbstractShape()
    {
    }

    
    public abstract EscherContainerRecord getSpContainer();

    
    public abstract ObjRecord getObjRecord();

    
    protected EscherRecord createAnchor( HSSFAnchor userAnchor )
    {
        return ConvertAnchor.createAnchor(userAnchor);
    }

    
    protected int addStandardOptions( HSSFShape shape, EscherOptRecord opt )
    {
        opt.addEscherProperty( new EscherBoolProperty( EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE, 0x080000 ) );

        if ( shape.isNoFill() )
        {
            
            opt.addEscherProperty( new EscherBoolProperty( EscherProperties.FILL__NOFILLHITTEST, 0x00110000 ) );
        }
        else
        {
            opt.addEscherProperty( new EscherBoolProperty( EscherProperties.FILL__NOFILLHITTEST, 0x00010000 ) );
        }
        opt.addEscherProperty( new EscherRGBProperty( EscherProperties.FILL__FILLCOLOR, shape.getFillColor() ) );
        opt.addEscherProperty( new EscherBoolProperty( EscherProperties.GROUPSHAPE__PRINT, 0x080000 ) );
        opt.addEscherProperty( new EscherRGBProperty( EscherProperties.LINESTYLE__COLOR, shape.getLineStyleColor() ) );
        int options = 5;
        if (shape.getLineWidth() != HSSFShape.LINEWIDTH_DEFAULT)
        {
            opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.LINESTYLE__LINEWIDTH, shape.getLineWidth()));
            options++;
        }
        if (shape.getLineStyle() != HSSFShape.LINESTYLE_SOLID)
        {
            opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.LINESTYLE__LINEDASHING, shape.getLineStyle()));
            opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.LINESTYLE__LINEENDCAPSTYLE, 0));
            if (shape.getLineStyle() == HSSFShape.LINESTYLE_NONE)
                opt.addEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080000));
            else
                opt.addEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));
            options += 3;
        }
        opt.sortProperties();
        return options;   
    }

    
    int getCmoObjectId(int shapeId){
        return shapeId - 1024;
    }
}
"
poi,3,org.apache.poi.hssf.record.DSFRecord,10,2,0,6,19,39,2,4,8,0.833333333,91,0.5,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class DSFRecord extends StandardRecord {
    public final static short sid = 0x0161;

    private static final BitField biff5BookStreamFlag = BitFieldFactory.getInstance(0x0001);

    private int _options;

    private DSFRecord(int options) {
        _options = options;
    }
    public DSFRecord(boolean isBiff5BookStreamPresent) {
        this(0);
        _options = biff5BookStreamFlag.setBoolean(0, isBiff5BookStreamPresent);
    }

    public DSFRecord(RecordInputStream in) {
        this(in.readShort());
    }

    public boolean isBiff5BookStreamPresent() {
        return biff5BookStreamFlag.isSet(_options);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DSF]
"");
        buffer.append(""    .options = "").append(HexDump.shortToHex(_options)).append(""
"");
        buffer.append(""[/DSF]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_options);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.ExtSSTRecord,16,2,0,9,39,62,4,5,14,0.853333333,285,0.4,0,0.44,0.223214286,1,4,16.5,3,1.3125,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.cont.ContinuableRecord;
import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;
import org.apache.poi.util.LittleEndianOutput;

import java.util.ArrayList;


public final class ExtSSTRecord extends ContinuableRecord {
    public final static short sid = 0x00FF;
    public static final int DEFAULT_BUCKET_SIZE = 8;
    
    
    public static final int MAX_BUCKETS = 128;
    
    
    public static final class InfoSubRecord {
    	public static final int ENCODED_SIZE = 8;
        private int field_1_stream_pos;          
        private int field_2_bucket_sst_offset;   
        
        private short field_3_zero;

        

        public InfoSubRecord(int streamPos, int bucketSstOffset) {
            field_1_stream_pos        = streamPos;
            field_2_bucket_sst_offset = bucketSstOffset;
        }

        public InfoSubRecord(RecordInputStream in)
        {
            field_1_stream_pos        = in.readInt();
            field_2_bucket_sst_offset = in.readShort();
            field_3_zero              = in.readShort();
        }

        public int getStreamPos() {
            return field_1_stream_pos;
        }

        public int getBucketSSTOffset() {
            return field_2_bucket_sst_offset;
        }

        public void serialize(LittleEndianOutput out) {
            out.writeInt(field_1_stream_pos);
            out.writeShort(field_2_bucket_sst_offset);
            out.writeShort(field_3_zero);
        }
    }
    
    
    private short _stringsPerBucket;
    private InfoSubRecord[] _sstInfos;


    public ExtSSTRecord() {
    	_stringsPerBucket = DEFAULT_BUCKET_SIZE;
        _sstInfos = new InfoSubRecord[0];
    }

    public ExtSSTRecord(RecordInputStream in) {
        _stringsPerBucket = in.readShort();

        int nInfos = in.remaining() / InfoSubRecord.ENCODED_SIZE;
        ArrayList<InfoSubRecord> lst = new ArrayList<InfoSubRecord>(nInfos);

        while (in.available() > 0) {
            InfoSubRecord info = new InfoSubRecord(in);
            lst.add(info);

            if(in.available() == 0 && in.hasNextRecord() && in.getNextSid() == ContinueRecord.sid) {
                in.nextRecord();
            }
        }
        _sstInfos = lst.toArray(new InfoSubRecord[lst.size()]);
    }

    public void setNumStringsPerBucket(short numStrings) {
        _stringsPerBucket = numStrings;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EXTSST]
"");
        buffer.append(""    .dsst           = "")
            .append(Integer.toHexString(_stringsPerBucket))
            .append(""
"");
        buffer.append(""    .numInfoRecords = "").append(_sstInfos.length)
            .append(""
"");
        for (int k = 0; k < _sstInfos.length; k++)
        {
            buffer.append(""    .inforecord     = "").append(k).append(""
"");
            buffer.append(""    .streampos      = "")
                .append(Integer
                .toHexString(_sstInfos[k].getStreamPos())).append(""
"");
            buffer.append(""    .sstoffset      = "")
                .append(Integer
                .toHexString(_sstInfos[k].getBucketSSTOffset()))
                    .append(""
"");
        }
        buffer.append(""[/EXTSST]
"");
        return buffer.toString();
    }

    public void serialize(ContinuableRecordOutput out) {
        out.writeShort(_stringsPerBucket);
        for (int k = 0; k < _sstInfos.length; k++) {
            _sstInfos[k].serialize(out);
        }
    }
    protected int getDataSize() {
    	return 2 + InfoSubRecord.ENCODED_SIZE*_sstInfos.length;
    }

    protected InfoSubRecord[] getInfoSubRecords() {
        return _sstInfos;
    }

    public static final int getNumberOfInfoRecsForStrings(int numStrings) {
      int infoRecs = (numStrings / DEFAULT_BUCKET_SIZE);
      if ((numStrings % DEFAULT_BUCKET_SIZE) != 0)
        infoRecs ++;
      
      
      if (infoRecs > MAX_BUCKETS)
        infoRecs = MAX_BUCKETS;
      return infoRecs;
    }

    
    public static final int getRecordSizeForStrings(int numStrings) {
        return 4 + 2 + getNumberOfInfoRecsForStrings(numStrings) * 8;
    }

    public short getSid() {
        return sid;
    }

    public void setBucketOffsets(int[] bucketAbsoluteOffsets, int[] bucketRelativeOffsets) {
    	
        _sstInfos = new InfoSubRecord[bucketAbsoluteOffsets.length];
        for (int i = 0; i < bucketAbsoluteOffsets.length; i++) {
            _sstInfos[i] = new InfoSubRecord(bucketAbsoluteOffsets[i], bucketRelativeOffsets[i]);
        }
    }
}
"
poi,3,org.apache.poi.util.BitFieldFactory,3,1,0,37,9,1,36,1,2,0.5,37,1.0,0,0.0,0.5,0,0,11.0,2,0.6667,1,"


package org.apache.poi.util;

import java.util.*;


public class BitFieldFactory {
    private static Map<Integer, BitField> instances = new HashMap<Integer, BitField>();

    public static BitField getInstance(int mask) {
      BitField f = instances.get(Integer.valueOf(mask));
      if (f == null) {
        f = new BitField(mask);
        instances.put(Integer.valueOf(mask), f);
      }
      return f;
    }
}
"
poi,3,org.apache.poi.hpsf.NoFormatIDException,4,5,0,2,8,6,1,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class NoFormatIDException extends HPSFRuntimeException
{

    
    public NoFormatIDException()
    {
        super();
    }


    
    public NoFormatIDException(final String msg)
    {
        super(msg);
    }


    
    public NoFormatIDException(final Throwable reason)
    {
        super(reason);
    }


    
    public NoFormatIDException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.hssf.record.BoolErrRecord,29,2,0,7,49,298,2,5,27,0.767857143,476,0.833333333,0,0.289473684,0.172413793,1,4,15.20689655,8,2.1379,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.ss.usermodel.ErrorConstants;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class BoolErrRecord extends CellRecord {
	public final static short sid = 0x0205;
	private int _value;
	
	private boolean _isError;

	
	public BoolErrRecord() {
		
	}

	
	public BoolErrRecord(RecordInputStream in) {
		super(in);
		switch (in.remaining()) {
			case 2:
				_value = in.readByte();
				break;
			case 3:
				_value = in.readUShort();
				break;
			default:
				throw new RecordFormatException(""Unexpected size (""
						+ in.remaining() + "") for BOOLERR record."");
		}
		int flag = in.readUByte();
		switch (flag) {
			case 0:
				_isError = false;
				break;
			case 1:
				_isError = true;
				break;
			default:
				throw new RecordFormatException(""Unexpected isError flag (""
						+ flag + "") for BOOLERR record."");
		}
	}

	
	public void setValue(boolean value) {
		_value = value ? 1 : 0;
		_isError = false;
	}

	
	public void setValue(byte value) {
		switch(value) {
			case ErrorConstants.ERROR_NULL:
			case ErrorConstants.ERROR_DIV_0:
			case ErrorConstants.ERROR_VALUE:
			case ErrorConstants.ERROR_REF:
			case ErrorConstants.ERROR_NAME:
			case ErrorConstants.ERROR_NUM:
			case ErrorConstants.ERROR_NA:
				_value = value;
				_isError = true;
				return;
		}
		throw new IllegalArgumentException(""Error Value can only be 0,7,15,23,29,36 or 42. It cannot be ""+value);
	}

	
	public boolean getBooleanValue() {
		return _value != 0;
	}

	
	public byte getErrorValue() {
		return (byte)_value;
	}

	
	public boolean isBoolean() {
		return !_isError;
	}

	
	public boolean isError() {
		return _isError;
	}

	@Override
	protected String getRecordName() {
		return ""BOOLERR"";
	}
	@Override
	protected void appendValueText(StringBuilder sb) {
		if (isBoolean()) {
			sb.append(""  .boolVal = "");
			sb.append(getBooleanValue());
		} else {
			sb.append(""  .errCode = "");
			sb.append(ErrorConstants.getText(getErrorValue()));
			sb.append("" ("").append(HexDump.byteToHex(getErrorValue())).append("")"");
		}
	}
	@Override
	protected void serializeValue(LittleEndianOutput out) {
		out.writeByte(_value);
		out.writeByte(_isError ? 1 : 0);
	}

	@Override
	protected int getValueDataSize() {
		return 2;
	}

	public short getSid() {
		return sid;
	}

	public Object clone() {
	  BoolErrRecord rec = new BoolErrRecord();
	  copyBaseFields(rec);
	  rec._value = _value;
	  rec._isError = _isError;
	  return rec;
	}
}
"
poi,3,org.apache.poi.poifs.eventfilesystem.POIFSReader,7,1,0,17,51,3,0,17,6,0.083333333,282,1.0,1,0.0,0.303571429,0,0,39.0,6,1.8571,1,"

        

package org.apache.poi.poifs.eventfilesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.OPOIFSDocument;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.property.PropertyTable;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockList;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;
import org.apache.poi.poifs.storage.SmallBlockTableReader;



public class POIFSReader
{
    private POIFSReaderRegistry registry;
    private boolean             registryClosed;

    

    public POIFSReader()
    {
        registry       = new POIFSReaderRegistry();
        registryClosed = false;
    }

    

    public void read(final InputStream stream)
        throws IOException
    {
        registryClosed = true;

        
        HeaderBlock header_block = new HeaderBlock(stream);

        
        RawDataBlockList data_blocks = new RawDataBlockList(stream, header_block.getBigBlockSize());

        
        
        new BlockAllocationTableReader(header_block.getBigBlockSize(),
                                       header_block.getBATCount(),
                                       header_block.getBATArray(),
                                       header_block.getXBATCount(),
                                       header_block.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block, data_blocks);

        
        processProperties(SmallBlockTableReader
            .getSmallDocumentBlocks(
                  header_block.getBigBlockSize(),
                  data_blocks, properties.getRoot(), 
                  header_block.getSBATStart()), 
                  data_blocks, properties.getRoot()
                        .getChildren(), new POIFSDocumentPath());
    }

    

    public void registerListener(final POIFSReaderListener listener)
    {
        if (listener == null)
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final String name)
    {
        registerListener(listener, null, name);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final POIFSDocumentPath path,
                                 final String name)
    {
        if ((listener == null) || (name == null) || (name.length() == 0))
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener,
                                  (path == null) ? new POIFSDocumentPath()
                                                 : path, name);
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length == 0)
        {
            System.err
                .println(""at least one argument required: input filename(s)"");
            System.exit(1);
        }

        
        for (int j = 0; j < args.length; j++)
        {
            POIFSReader         reader   = new POIFSReader();
            POIFSReaderListener listener = new SampleListener();

            reader.registerListener(listener);
            System.out.println(""reading "" + args[ j ]);
            FileInputStream istream = new FileInputStream(args[ j ]);

            reader.read(istream);
            istream.close();
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator properties,
                                   final POIFSDocumentPath path)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property property = ( Property ) properties.next();
            String   name     = property.getName();

            if (property.isDirectory())
            {
                POIFSDocumentPath new_path = new POIFSDocumentPath(path,
                                                 new String[]
                {
                    name
                });

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(), new_path);
            }
            else
            {
                int      startBlock = property.getStartBlock();
                Iterator listeners  = registry.getListeners(path, name);

                if (listeners.hasNext())
                {
                    int            size     = property.getSize();
                    OPOIFSDocument document = null;

                    if (property.shouldUseSmallBlocks())
                    {
                        document =
                            new OPOIFSDocument(name, small_blocks
                                .fetchBlocks(startBlock, -1), size);
                    }
                    else
                    {
                        document =
                            new OPOIFSDocument(name, big_blocks
                                .fetchBlocks(startBlock, -1), size);
                    }
                    while (listeners.hasNext())
                    {
                        POIFSReaderListener listener =
                            ( POIFSReaderListener ) listeners.next();

                        listener.processPOIFSReaderEvent(
                            new POIFSReaderEvent(
                                new DocumentInputStream(document), path,
                                name));
                    }
                }
                else
                {

                    
                    if (property.shouldUseSmallBlocks())
                    {
                        small_blocks.fetchBlocks(startBlock, -1);
                    }
                    else
                    {
                        big_blocks.fetchBlocks(startBlock, -1);
                    }
                }
            }
        }
    }

    private static class SampleListener
        implements POIFSReaderListener
    {

        

        SampleListener()
        {
        }

        

        public void processPOIFSReaderEvent(final POIFSReaderEvent event)
        {
            DocumentInputStream istream = event.getStream();
            POIFSDocumentPath   path    = event.getPath();
            String              name    = event.getName();

            try
            {
                byte[] data = new byte[ istream.available() ];

                istream.read(data);
                int pathLength = path.length();

                for (int k = 0; k < pathLength; k++)
                {
                    System.out.print(""/"" + path.getComponent(k));
                }
                System.out.println(""/"" + name + "": "" + data.length
                                   + "" bytes read"");
            }
            catch (IOException ignored)
            {
            }
        }
    }   
}       

"
poi,3,org.apache.poi.hssf.record.GridsetRecord,11,2,0,6,20,35,2,4,9,0.8,113,0.0,0,0.55,0.257575758,1,4,9.090909091,2,1.0909,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class GridsetRecord
    extends StandardRecord
{
    public final static short sid = 0x82;
    public short              field_1_gridset_flag;

    public GridsetRecord()
    {
    }

    public GridsetRecord(RecordInputStream in)
    {
        field_1_gridset_flag = in.readShort();
    }

    

    public void setGridset(boolean gridset)
    {
        if (gridset == true)
        {
            field_1_gridset_flag = 1;
        }
        else
        {
            field_1_gridset_flag = 0;
        }
    }

    

    public boolean getGridset()
    {
        return (field_1_gridset_flag == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[GRIDSET]
"");
        buffer.append(""    .gridset        = "").append(getGridset())
            .append(""
"");
        buffer.append(""[/GRIDSET]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_gridset_flag);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      GridsetRecord rec = new GridsetRecord();
      rec.field_1_gridset_flag = field_1_gridset_flag;
      return rec;
    }
}
"
poi,3,org.apache.poi.poifs.storage.HeaderBlockConstants,0,1,0,2,0,0,2,0,0,2.0,10,0.0,0,0.0,0.0,0,0,0.0,0,0.0,1,"

package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.LittleEndianConsts;


public interface HeaderBlockConstants
{
    public static final long _signature               = 0xE11AB1A1E011CFD0L;
    public static final int  _bat_array_offset        = 0x4c;
    public static final int  _max_bats_in_header      =
        (POIFSConstants.SMALLER_BIG_BLOCK_SIZE - _bat_array_offset)
        / LittleEndianConsts.INT_SIZE; 

    
    
    
    
    
    
    public static final int  _signature_offset        = 0;
    public static final int  _bat_count_offset        = 0x2C;
    public static final int  _property_start_offset   = 0x30;
    public static final int  _sbat_start_offset       = 0x3C;
    public static final int  _sbat_block_count_offset = 0x40;
    public static final int  _xbat_start_offset       = 0x44;
    public static final int  _xbat_count_offset       = 0x48;
}   

"
poi,3,org.apache.poi.hssf.dev.FormulaViewer,9,1,0,11,43,28,0,11,6,0.6875,416,1.0,0,0.0,0.333333333,0,0,45.0,13,3.2222,0,"

package org.apache.poi.hssf.dev;

import java.io.File;
import java.util.List;

import org.apache.poi.hssf.model.HSSFFormulaParser;
import org.apache.poi.hssf.record.FormulaRecord;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordFactory;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.formula.ptg.ExpPtg;
import org.apache.poi.ss.formula.ptg.FuncPtg;
import org.apache.poi.ss.formula.ptg.OperationPtg;
import org.apache.poi.ss.formula.ptg.Ptg;



public class FormulaViewer
{
    private String file;
    private boolean list=false;

    

    public FormulaViewer()
    {
    }

    

    public void run()
        throws Exception
    {
        List<Record>    records =
            RecordFactory
                .createRecords(BiffViewer.getPOIFSInputStream(new File(file)));

        for (int k = 0; k < records.size(); k++)
        {
            Record record = records.get(k);

            if (record.getSid() == FormulaRecord.sid)
            {
               if (list) {
                    listFormula((FormulaRecord) record);
               }else {
                    parseFormulaRecord(( FormulaRecord ) record);
               }
            }
        }
    }
    
    private void listFormula(FormulaRecord record) {
        String sep=""~"";
        Ptg[] tokens= record.getParsedExpression();
        Ptg token;
        int numptgs = tokens.length;
        String numArg;
            token = tokens[numptgs-1];
            if (token instanceof FuncPtg) {
                numArg = String.valueOf(numptgs-1);
            } else { 
            	numArg = String.valueOf(-1);
            }
            
            StringBuffer buf = new StringBuffer();
            
            if (token instanceof ExpPtg) return;
            buf.append(((OperationPtg) token).toFormulaString());
            buf.append(sep);
            switch (token.getPtgClass()) {
                case Ptg.CLASS_REF :
                    buf.append(""REF"");
                    break;
                case Ptg.CLASS_VALUE :
                    buf.append(""VALUE"");
                    break;
                case Ptg.CLASS_ARRAY :
                    buf.append(""ARRAY"");
                    break;
            }
            
            buf.append(sep);
            if (numptgs>1) {
                token = tokens[numptgs-2];
                switch (token.getPtgClass()) {
                    case Ptg.CLASS_REF :
                        buf.append(""REF"");
                        break;
                    case Ptg.CLASS_VALUE :
                        buf.append(""VALUE"");
                        break;
                    case Ptg.CLASS_ARRAY :
                        buf.append(""ARRAY"");
                        break;
                }
            }else {
                buf.append(""VALUE"");
            }
            buf.append(sep);
            buf.append(numArg);
            System.out.println(buf.toString());
    }

    

    public void parseFormulaRecord(FormulaRecord record)
    {
        System.out.println(""=============================="");
        System.out.print(""row = "" + record.getRow());
        System.out.println("", col = "" + record.getColumn());
        System.out.println(""value = "" + record.getValue());
        System.out.print(""xf = "" + record.getXFIndex());
        System.out.print("", number of ptgs = ""
                           + record.getParsedExpression().length);
        System.out.println("", options = "" + record.getOptions());
        System.out.println(""RPN List = ""+formulaString(record));
        System.out.println(""Formula text = ""+ composeFormula(record));
    }

    private String formulaString(FormulaRecord record) {

        StringBuffer buf = new StringBuffer();
		Ptg[] tokens = record.getParsedExpression();
		for (int i = 0; i < tokens.length; i++) {
			Ptg token = tokens[i];
            buf.append( token.toFormulaString());
            switch (token.getPtgClass()) {
                case Ptg.CLASS_REF :
                    buf.append(""(R)"");
                    break;
                case Ptg.CLASS_VALUE :
                    buf.append(""(V)"");
                    break;
                case Ptg.CLASS_ARRAY :
                    buf.append(""(A)"");
                    break;
            }
            buf.append(' ');
        } 
        return buf.toString();
    }
    
    
    private static String composeFormula(FormulaRecord record)
    {
       return  HSSFFormulaParser.toFormulaString((HSSFWorkbook)null, record.getParsedExpression());
    }

    

    public void setFile(String file)
    {
        this.file = file;
    }
    
    public void setList(boolean list) {
        this.list=list;
    }

    

    public static void main(String args[])
    {
        if ((args == null) || (args.length >2 )
                || args[ 0 ].equals(""--help""))
        {
            System.out.println(
                ""FormulaViewer .8 proof that the devil lies in the details (or just in BIFF8 files in general)"");
            System.out.println(""usage: Give me a big fat file name"");
        } else if (args[0].equals(""--listFunctions"")) { 
            try {
                FormulaViewer viewer = new FormulaViewer();
                viewer.setFile(args[1]);
                viewer.setList(true);
                viewer.run();
            }
            catch (Exception e) {
                System.out.println(""Whoops!"");
                e.printStackTrace();
            }
        }
        else
        {
            try
            {
                FormulaViewer viewer = new FormulaViewer();

                viewer.setFile(args[ 0 ]);
                viewer.run();
            }
            catch (Exception e)
            {
                System.out.println(""Whoops!"");
                e.printStackTrace();
            }
        }
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFName,7,1,0,4,26,0,1,3,5,0.083333333,118,1.0,2,0.0,0.428571429,0,0,15.57142857,4,1.4286,5,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.model.HSSFFormulaParser;
import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.NameCommentRecord;
import org.apache.poi.hssf.record.NameRecord;
import org.apache.poi.ss.formula.FormulaType;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.ss.usermodel.Name;


public final class HSSFName implements Name {
    private HSSFWorkbook _book;
    private NameRecord _definedNameRec;
    private NameCommentRecord _commentRec;

    
     HSSFName(HSSFWorkbook book, NameRecord name) {
      this(book, name, null);
    }
    
     HSSFName(final HSSFWorkbook book, final NameRecord name, final NameCommentRecord comment) {
        _book = book;
        _definedNameRec = name;
        _commentRec = comment;
    }

    
    public String getSheetName() {
        int indexToExternSheet = _definedNameRec.getExternSheetNumber();

        return _book.getWorkbook().findSheetFirstNameFromExternSheet(indexToExternSheet);
    }

    
    public String getNameName(){
        return _definedNameRec.getNameText();
    }

    
    public void setNameName(String nameName){
        validateName(nameName);

        InternalWorkbook wb = _book.getWorkbook();
        _definedNameRec.setNameText(nameName);

        int sheetNumber = _definedNameRec.getSheetNumber();

        
        for ( int i = wb.getNumNames()-1; i >=0; i-- )
        {
            NameRecord rec = wb.getNameRecord(i);
            if (rec != _definedNameRec) {
                if (rec.getNameText().equalsIgnoreCase(nameName) && sheetNumber == rec.getSheetNumber()){
                    String msg = ""The ""+(sheetNumber == 0 ? ""workbook"" : ""sheet"")+"" already contains this name: "" + nameName;
                    _definedNameRec.setNameText(nameName + ""(2)"");
                    throw new IllegalArgumentException(msg);
                }
            }
        }
        
        
        if(_commentRec != null) {
           String oldName = _commentRec.getNameText();
           _commentRec.setNameText(nameName);
           _book.getWorkbook().updateNameCommentRecordCache(_commentRec);
        }
    }

    private static void validateName(String name){
        if(name.length() == 0)  throw new IllegalArgumentException(""Name cannot be blank"");

        char c = name.charAt(0);
        if(!(c == '_' || Character.isLetter(c)) || name.indexOf(' ') != -1) {
            throw new IllegalArgumentException(""Invalid name: '""+name+""'; Names must begin with a letter or underscore and not contain spaces"");
        }
    }

    
    public String getReference() {
        return getRefersToFormula();
    }

    
    public void setReference(String ref){
        setRefersToFormula(ref);
    }

    public void setRefersToFormula(String formulaText) {
        Ptg[] ptgs = HSSFFormulaParser.parse(formulaText, _book, FormulaType.NAMEDRANGE, getSheetIndex());
        _definedNameRec.setNameDefinition(ptgs);
    }

    public String getRefersToFormula() {
        if (_definedNameRec.isFunctionName()) {
            throw new IllegalStateException(""Only applicable to named ranges"");
        }
        Ptg[] ptgs = _definedNameRec.getNameDefinition();
        if (ptgs.length < 1) {
            
            return null;
        }
        return HSSFFormulaParser.toFormulaString(_book, ptgs);
    }


    
    void setNameDefinition(Ptg[] ptgs) {
      _definedNameRec.setNameDefinition(ptgs);
    }


    public boolean isDeleted(){
        Ptg[] ptgs = _definedNameRec.getNameDefinition();
        return Ptg.doesFormulaReferToDeletedCell(ptgs);
    }

    
    public boolean isFunctionName() {
        return _definedNameRec.isFunctionName();
    }

    public String toString() {
        StringBuffer sb = new StringBuffer(64);
        sb.append(getClass().getName()).append("" ["");
        sb.append(_definedNameRec.getNameText());
        sb.append(""]"");
        return sb.toString();
    }

    
    public void setSheetIndex(int index){
        int lastSheetIx = _book.getNumberOfSheets() - 1;
        if (index < -1 || index > lastSheetIx) {
            throw new IllegalArgumentException(""Sheet index ("" + index +"") is out of range"" +
                    (lastSheetIx == -1 ? """" : ("" (0.."" +    lastSheetIx + "")"")));
        }

        _definedNameRec.setSheetNumber(index + 1);
    }

    
    public int getSheetIndex(){
        return _definedNameRec.getSheetNumber() - 1;
    }

    
    public String getComment() {
        if(_commentRec != null) {
           
           if(_commentRec.getCommentText() != null &&
                 _commentRec.getCommentText().length() > 0) {
              return _commentRec.getCommentText();
           }
        }
        return _definedNameRec.getDescriptionText();
    }

    
    public void setComment(String comment){
        
        _definedNameRec.setDescriptionText(comment);
        
        if(_commentRec != null) {
           _commentRec.setCommentText(comment);
        }
    }

    
    public void setFunction(boolean value) {
        _definedNameRec.setFunction(value);
    }
}
"
poi,3,org.apache.poi.hssf.record.SSTSerializer,6,1,0,7,16,1,1,6,4,0.833333333,145,0.333333333,2,0.0,0.5,0,0,22.16666667,6,1.6667,0,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.common.UnicodeString;
import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;
import org.apache.poi.util.IntMapper;


final class SSTSerializer {

	private final int _numStrings;
	private final int _numUniqueStrings;

    private final IntMapper<UnicodeString> strings;

    
    private final int[] bucketAbsoluteOffsets;
    
    private final int[] bucketRelativeOffsets;

    public SSTSerializer( IntMapper<UnicodeString> strings, int numStrings, int numUniqueStrings )
    {
        this.strings = strings;
		_numStrings = numStrings;
		_numUniqueStrings = numUniqueStrings;

        int infoRecs = ExtSSTRecord.getNumberOfInfoRecsForStrings(strings.size());
        this.bucketAbsoluteOffsets = new int[infoRecs];
        this.bucketRelativeOffsets = new int[infoRecs];
    }

    public void serialize(ContinuableRecordOutput out) {
        out.writeInt(_numStrings);
        out.writeInt(_numUniqueStrings);

        for ( int k = 0; k < strings.size(); k++ )
        {
            if (k % ExtSSTRecord.DEFAULT_BUCKET_SIZE == 0)
            {
              int rOff = out.getTotalSize();
              int index = k/ExtSSTRecord.DEFAULT_BUCKET_SIZE;
              if (index < ExtSSTRecord.MAX_BUCKETS) {
                 
                 bucketAbsoluteOffsets[index] = rOff;
                 bucketRelativeOffsets[index] = rOff;
              }
          }
          UnicodeString s = getUnicodeString(k);
          s.serialize(out);
        }
    }


    private UnicodeString getUnicodeString( int index )
    {
        return getUnicodeString(strings, index);
    }

    private static UnicodeString getUnicodeString( IntMapper<UnicodeString> strings, int index )
    {
        return ( strings.get( index ) );
    }

    public int[] getBucketAbsoluteOffsets()
    {
        return bucketAbsoluteOffsets;
    }

    public int[] getBucketRelativeOffsets()
    {
        return bucketRelativeOffsets;
    }
}
"
poi,3,org.apache.poi.hssf.model.ConvertAnchor,2,1,0,8,37,1,2,6,2,2.0,139,0.0,0,0.0,0.5,0,0,68.5,2,1.0,2,"

package org.apache.poi.hssf.model;

import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.ddf.EscherClientAnchorRecord;
import org.apache.poi.ddf.EscherChildAnchorRecord;
import org.apache.poi.hssf.usermodel.HSSFAnchor;
import org.apache.poi.hssf.usermodel.HSSFClientAnchor;
import org.apache.poi.hssf.usermodel.HSSFChildAnchor;


public class ConvertAnchor
{
    public static EscherRecord createAnchor( HSSFAnchor userAnchor )
    {
        if (userAnchor instanceof HSSFClientAnchor)
        {
            HSSFClientAnchor a = (HSSFClientAnchor) userAnchor;

            EscherClientAnchorRecord anchor = new EscherClientAnchorRecord();
            anchor.setRecordId( EscherClientAnchorRecord.RECORD_ID );
            anchor.setOptions( (short) 0x0000 );
            anchor.setFlag( (short) a.getAnchorType() );
            anchor.setCol1( (short) Math.min(a.getCol1(), a.getCol2()) );
            anchor.setDx1( (short) a.getDx1() );
            anchor.setRow1( (short) Math.min(a.getRow1(), a.getRow2()) );
            anchor.setDy1( (short) a.getDy1() );

            anchor.setCol2( (short) Math.max(a.getCol1(), a.getCol2()) );
            anchor.setDx2( (short) a.getDx2() );
            anchor.setRow2( (short) Math.max(a.getRow1(), a.getRow2()) );
            anchor.setDy2( (short) a.getDy2() );
            return anchor;
        }
        HSSFChildAnchor a = (HSSFChildAnchor) userAnchor;
        EscherChildAnchorRecord anchor = new EscherChildAnchorRecord();
        anchor.setRecordId( EscherChildAnchorRecord.RECORD_ID );
        anchor.setOptions( (short) 0x0000 );
        anchor.setDx1( (short) Math.min(a.getDx1(), a.getDx2()) );
        anchor.setDy1( (short) Math.min(a.getDy1(), a.getDy2()) );
        anchor.setDx2( (short) Math.max(a.getDx2(), a.getDx1()) );
        anchor.setDy2( (short) Math.max(a.getDy2(), a.getDy1()) );
        return anchor;
    }
}
"
poi,3,org.apache.poi.util.ArrayUtil,3,1,0,1,10,3,1,0,3,2.0,244,0.0,0,0.0,0.416666667,0,0,80.33333333,10,5.6667,0,"

package org.apache.poi.util;



public class ArrayUtil
{
    
    public static void arraycopy(byte[] src, int src_position, byte[] dst, int dst_position, int length)
    {
        if (src_position < 0)
            throw new IllegalArgumentException(""src_position was less than 0.  Actual value "" + src_position);
        if (src_position >= src.length)
            throw new IllegalArgumentException( ""src_position was greater than src array size.  Tried to write starting at position "" + src_position + "" but the array length is "" + src.length );
        if (src_position + length > src.length)
            throw new IllegalArgumentException(""src_position + length would overrun the src array.  Expected end at "" + (src_position + length) + "" actual end at "" + src.length);
        if (dst_position < 0)
            throw new IllegalArgumentException(""dst_position was less than 0.  Actual value "" + dst_position);
        if (dst_position >= dst.length)
            throw new IllegalArgumentException( ""dst_position was greater than dst array size.  Tried to write starting at position "" + dst_position + "" but the array length is "" + dst.length );
        if (dst_position + length > dst.length)
            throw new IllegalArgumentException(""dst_position + length would overrun the dst array.  Expected end at "" + (dst_position + length) + "" actual end at "" + dst.length);

        System.arraycopy( src, src_position, dst, dst_position, length);
    }

    
    public static void arrayMoveWithin(Object[] array, int moveFrom, int moveTo, int numToMove) {
    	
    	if(numToMove <= 0) { return; }
    	if(moveFrom == moveTo) { return; }
    	
    	
    	if(moveFrom < 0 || moveFrom >= array.length) {
    		throw new IllegalArgumentException(""The moveFrom must be a valid array index"");
    	}
    	if(moveTo < 0 || moveTo >= array.length) {
    		throw new IllegalArgumentException(""The moveTo must be a valid array index"");
    	}
    	if(moveFrom+numToMove > array.length) {
    		throw new IllegalArgumentException(""Asked to move more entries than the array has"");
    	}
    	if(moveTo+numToMove > array.length) {
    		throw new IllegalArgumentException(""Asked to move to a position that doesn't have enough space"");
    	}
    	
    	
    	Object[] toMove = new Object[numToMove];
    	System.arraycopy(array, moveFrom, toMove, 0, numToMove);
    	
    	
    	Object[] toShift;
    	int shiftTo;
    	if(moveFrom > moveTo) {
    		
    		
    		toShift = new Object[(moveFrom-moveTo)];
    		System.arraycopy(array, moveTo, toShift, 0, toShift.length);
    		shiftTo = moveTo + numToMove;
    	} else {
    		
    		
    		toShift = new Object[(moveTo-moveFrom)];
    		System.arraycopy(array, moveFrom+numToMove, toShift, 0, toShift.length);
    		shiftTo = moveFrom;
    	}
    	
    	
    	System.arraycopy(toMove, 0, array, moveTo, toMove.length);
    	
    	
    	System.arraycopy(toShift, 0, array, shiftTo, toShift.length);
    	
    	
    	
    }

}
"
poi,3,org.apache.poi.hssf.model.LineShape,5,2,0,16,41,6,1,16,2,0.75,181,1.0,2,0.555555556,0.55,1,1,34.8,3,1.2,1,"


package org.apache.poi.hssf.model;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.usermodel.*;


@Deprecated
public class LineShape
        extends AbstractShape
{
    private EscherContainerRecord spContainer;
    private ObjRecord objRecord;

    
    LineShape( HSSFSimpleShape hssfShape, int shapeId )
    {
        spContainer = createSpContainer(hssfShape, shapeId);
        objRecord = createObjRecord(hssfShape, shapeId);
    }

    
    private EscherContainerRecord createSpContainer(HSSFSimpleShape hssfShape, int shapeId)
    {
        HSSFShape shape = hssfShape;

        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherRecord anchor = new EscherClientAnchorRecord();
        EscherClientDataRecord clientData = new EscherClientDataRecord();

        spContainer.setRecordId( EscherContainerRecord.SP_CONTAINER );
        spContainer.setOptions( (short) 0x000F );
        sp.setRecordId( EscherSpRecord.RECORD_ID );
        sp.setOptions( (short) ( (EscherAggregate.ST_LINE << 4) | 0x2 ) );

        sp.setShapeId( shapeId );
        sp.setFlags( EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        opt.setRecordId( EscherOptRecord.RECORD_ID );
        opt.addEscherProperty( new EscherShapePathProperty( EscherProperties.GEOMETRY__SHAPEPATH, EscherShapePathProperty.COMPLEX ) );
        opt.addEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 1048592 ) );
        addStandardOptions(shape, opt);
        HSSFAnchor userAnchor = shape.getAnchor();
        if (userAnchor.isHorizontallyFlipped())
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);
        if (userAnchor.isVerticallyFlipped())
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);
        anchor = createAnchor(userAnchor);
        clientData.setRecordId( EscherClientDataRecord.RECORD_ID );
        clientData.setOptions( (short) 0x0000 );

        spContainer.addChildRecord(sp);
        spContainer.addChildRecord(opt);
        spContainer.addChildRecord(anchor);
        spContainer.addChildRecord(clientData);

        return spContainer;
    }

    
    private ObjRecord createObjRecord(HSSFShape hssfShape, int shapeId)
    {
        HSSFShape shape = hssfShape;

        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType((short) ((HSSFSimpleShape)shape).getShapeType());
        c.setObjectId(  getCmoObjectId(shapeId) );
        c.setLocked(true);
        c.setPrintable(true);
        c.setAutofill(true);
        c.setAutoline(true);
        EndSubRecord e = new EndSubRecord();

        obj.addSubRecord(c);
        obj.addSubRecord(e);

        return obj;
    }

    public EscherContainerRecord getSpContainer()
    {
        return spContainer;
    }

    public ObjRecord getObjRecord()
    {
        return objRecord;
    }

}
"
poi,3,org.apache.poi.hssf.record.IndexRecord,18,2,0,7,40,103,2,5,16,0.848739496,301,0.0,1,0.407407407,0.311111111,1,4,15.33333333,2,1.2222,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.IntList;
import org.apache.poi.util.LittleEndianOutput;


public class IndexRecord extends StandardRecord {
    public final static short sid = 0x020B;
    private int                field_2_first_row;       
    private int                field_3_last_row_add1;   
    private int                field_4_zero;            
    private IntList            field_5_dbcells;         

    public IndexRecord()
    {
    }

    public IndexRecord(RecordInputStream in)
    {
        int field_1_zero          = in.readInt();
        if (field_1_zero != 0) {
        	throw new RecordFormatException(""Expected zero for field 1 but got "" + field_1_zero);
        }
        field_2_first_row     = in.readInt();
        field_3_last_row_add1 = in.readInt();
        field_4_zero      = in.readInt();
        
        int nCells = in.remaining() / 4;
        field_5_dbcells = new IntList(nCells);
        for(int i=0; i<nCells; i++) {
            field_5_dbcells.add(in.readInt());
        }
    }

    public void setFirstRow(int row)
    {
        field_2_first_row = row;
    }

    public void setLastRowAdd1(int row)
    {
        field_3_last_row_add1 = row;
    }

    public void addDbcell(int cell)
    {
        if (field_5_dbcells == null)
        {
            field_5_dbcells = new IntList();
        }
        field_5_dbcells.add(cell);
    }

    public void setDbcell(int cell, int value)
    {
        field_5_dbcells.set(cell, value);
    }

    public int getFirstRow()
    {
        return field_2_first_row;
    }

    public int getLastRowAdd1()
    {
        return field_3_last_row_add1;
    }

    public int getNumDbcells()
    {
        if (field_5_dbcells == null)
        {
            return 0;
        }
        return field_5_dbcells.size();
    }

    public int getDbcellAt(int cellnum)
    {
        return field_5_dbcells.get(cellnum);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[INDEX]
"");
        buffer.append(""    .firstrow       = "")
            .append(Integer.toHexString(getFirstRow())).append(""
"");
        buffer.append(""    .lastrowadd1    = "")
            .append(Integer.toHexString(getLastRowAdd1())).append(""
"");
        for (int k = 0; k < getNumDbcells(); k++) {
            buffer.append(""    .dbcell_"").append(k).append("" = "")
                .append(Integer.toHexString(getDbcellAt(k))).append(""
"");
        }
        buffer.append(""[/INDEX]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {

        out.writeInt(0);
        out.writeInt(getFirstRow());
        out.writeInt(getLastRowAdd1());
        out.writeInt(field_4_zero);
        for (int k = 0; k < getNumDbcells(); k++) {
        	out.writeInt(getDbcellAt(k));
        }
    }

    protected int getDataSize() {
        return 16 
        	+ getNumDbcells() * 4;
    }
    
    
    public static int getRecordSizeForBlockCount(int blockCount) {
        return 20 + 4 * blockCount;
    }  

    public short getSid() {
        return sid;
    }

    public Object clone() {
      IndexRecord rec = new IndexRecord();
      rec.field_2_first_row = field_2_first_row;
      rec.field_3_last_row_add1 = field_3_last_row_add1;
      rec.field_4_zero = field_4_zero;
      rec.field_5_dbcells = new IntList();
      rec.field_5_dbcells.addAll(field_5_dbcells);
      return rec;
    }
}
"
poi,3,org.apache.poi.hpsf.WritingNotSupportedException,1,6,0,7,2,0,6,1,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class WritingNotSupportedException
    extends UnsupportedVariantTypeException
{

    
    public WritingNotSupportedException(final long variantType,
                                        final Object value)
    {
        super(variantType, value);
    }

}
"
poi,3,org.apache.poi.hssf.record.WindowTwoRecord,47,2,0,9,63,167,3,6,45,0.87173913,741,0.95,12,0.196428571,0.25177305,1,4,14.34042553,3,1.0213,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.LittleEndianOutput;


public final class WindowTwoRecord extends StandardRecord {
    public final static short sid = 0x023E;

    
    private static final BitField displayFormulas         = BitFieldFactory.getInstance(0x01);
    private static final BitField displayGridlines        = BitFieldFactory.getInstance(0x02);
    private static final BitField displayRowColHeadings   = BitFieldFactory.getInstance(0x04);
    private static final BitField freezePanes             = BitFieldFactory.getInstance(0x08);
    private static final BitField displayZeros            = BitFieldFactory.getInstance(0x10);
    
    private static final BitField defaultHeader           = BitFieldFactory.getInstance(0x20);   
    private static final BitField arabic                  = BitFieldFactory.getInstance(0x040);
    private static final BitField displayGuts             = BitFieldFactory.getInstance(0x080);
    private static final BitField freezePanesNoSplit      = BitFieldFactory.getInstance(0x100);
    private static final BitField selected                = BitFieldFactory.getInstance(0x200);
    private static final BitField active                  = BitFieldFactory.getInstance(0x400);
    private static final BitField savedInPageBreakPreview = BitFieldFactory.getInstance(0x800);
    
    

    private short             field_1_options;
    private short             field_2_top_row;
    private short             field_3_left_col;
    private int               field_4_header_color;
    private short             field_5_page_break_zoom;
    private short             field_6_normal_zoom;
    private int               field_7_reserved;

    public WindowTwoRecord()
    {
    }

    public WindowTwoRecord(RecordInputStream in)
    {
      int size = in.remaining();
        field_1_options      = in.readShort();
        field_2_top_row      = in.readShort();
        field_3_left_col     = in.readShort();
        field_4_header_color = in.readInt();
        if (size > 10)
        {
            field_5_page_break_zoom = in.readShort();
            field_6_normal_zoom     = in.readShort();
        }
        if (size > 14)
        {   
            field_7_reserved = in.readInt();
        }
    }

    

    public void setOptions(short options)
    {
        field_1_options = options;
    }

    

    

    public void setDisplayFormulas(boolean formulas)
    {
        field_1_options = displayFormulas.setShortBoolean(field_1_options, formulas);
    }

    

    public void setDisplayGridlines(boolean gridlines)
    {
        field_1_options = displayGridlines.setShortBoolean(field_1_options, gridlines);
    }

    

    public void setDisplayRowColHeadings(boolean headings)
    {
        field_1_options = displayRowColHeadings.setShortBoolean(field_1_options, headings);
    }

    

    public void setFreezePanes(boolean freezepanes)
    {
        field_1_options = freezePanes.setShortBoolean(field_1_options, freezepanes);
    }

    

    public void setDisplayZeros(boolean zeros)
    {
        field_1_options = displayZeros.setShortBoolean(field_1_options, zeros);
    }

    

    public void setDefaultHeader(boolean header)
    {
        field_1_options = defaultHeader.setShortBoolean(field_1_options, header);
    }

    

    public void setArabic(boolean isarabic)
    {
        field_1_options = arabic.setShortBoolean(field_1_options, isarabic);
    }

    

    public void setDisplayGuts(boolean guts)
    {
        field_1_options = displayGuts.setShortBoolean(field_1_options, guts);
    }

    

    public void setFreezePanesNoSplit(boolean freeze)
    {
        field_1_options = freezePanesNoSplit.setShortBoolean(field_1_options, freeze);
    }

    

    public void setSelected(boolean sel)
    {
        field_1_options = selected.setShortBoolean(field_1_options, sel);
    }

    
    public void setActive(boolean p) {
        field_1_options = active.setShortBoolean(field_1_options, p);
    }
    
    public void setPaged(boolean p) {
    	setActive(p);
    }
    

    public void setSavedInPageBreakPreview(boolean p)
    {
        field_1_options = savedInPageBreakPreview.setShortBoolean(field_1_options, p);
    }

    

    

    public void setTopRow(short topRow)
    {
        field_2_top_row = topRow;
    }

    

    public void setLeftCol(short leftCol)
    {
        field_3_left_col = leftCol;
    }

    

    public void setHeaderColor(int color)
    {
        field_4_header_color = color;
    }

    

    public void setPageBreakZoom(short zoom)
    {
        field_5_page_break_zoom = zoom;
    }

    

    public void setNormalZoom(short zoom)
    {
        field_6_normal_zoom = zoom;
    }

    

    public void setReserved(int reserved)
    {
        field_7_reserved = reserved;
    }

    

    public short getOptions()
    {
        return field_1_options;
    }

    

    

    public boolean getDisplayFormulas()
    {
        return displayFormulas.isSet(field_1_options);
    }

    

    public boolean getDisplayGridlines()
    {
        return displayGridlines.isSet(field_1_options);
    }

    

    public boolean getDisplayRowColHeadings()
    {
        return displayRowColHeadings.isSet(field_1_options);
    }

    

    public boolean getFreezePanes()
    {
        return freezePanes.isSet(field_1_options);
    }

    

    public boolean getDisplayZeros()
    {
        return displayZeros.isSet(field_1_options);
    }

    

    public boolean getDefaultHeader()
    {
        return defaultHeader.isSet(field_1_options);
    }

    

    public boolean getArabic()
    {
        return arabic.isSet(field_1_options);
    }

    

    public boolean getDisplayGuts()
    {
        return displayGuts.isSet(field_1_options);
    }

    

    public boolean getFreezePanesNoSplit()
    {
        return freezePanesNoSplit.isSet(field_1_options);
    }

    

    public boolean getSelected()
    {
        return selected.isSet(field_1_options);
    }

    

    public boolean isActive() {
        return active.isSet(field_1_options);
    }
    
    public boolean getPaged() {
        return isActive();
    }

    

    public boolean getSavedInPageBreakPreview()
    {
        return savedInPageBreakPreview.isSet(field_1_options);
    }

    

    

    public short getTopRow()
    {
        return field_2_top_row;
    }

    

    public short getLeftCol()
    {
        return field_3_left_col;
    }

    

    public int getHeaderColor()
    {
        return field_4_header_color;
    }

    

    public short getPageBreakZoom()
    {
        return field_5_page_break_zoom;
    }

    

    public short getNormalZoom()
    {
        return field_6_normal_zoom;
    }

    

    public int getReserved()
    {
        return field_7_reserved;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WINDOW2]
"");
        buffer.append(""    .options        = "")
            .append(Integer.toHexString(getOptions())).append(""
"");
        buffer.append(""       .dispformulas= "").append(getDisplayFormulas())
            .append(""
"");
        buffer.append(""       .dispgridlins= "").append(getDisplayGridlines())
            .append(""
"");
        buffer.append(""       .disprcheadin= "")
            .append(getDisplayRowColHeadings()).append(""
"");
        buffer.append(""       .freezepanes = "").append(getFreezePanes())
            .append(""
"");
        buffer.append(""       .displayzeros= "").append(getDisplayZeros())
            .append(""
"");
        buffer.append(""       .defaultheadr= "").append(getDefaultHeader())
            .append(""
"");
        buffer.append(""       .arabic      = "").append(getArabic())
            .append(""
"");
        buffer.append(""       .displayguts = "").append(getDisplayGuts())
            .append(""
"");
        buffer.append(""       .frzpnsnosplt= "")
            .append(getFreezePanesNoSplit()).append(""
"");
        buffer.append(""       .selected    = "").append(getSelected())
            .append(""
"");
        buffer.append(""       .active       = "").append(isActive())
            .append(""
"");
        buffer.append(""       .svdinpgbrkpv= "")
            .append(getSavedInPageBreakPreview()).append(""
"");
        buffer.append(""    .toprow         = "")
            .append(Integer.toHexString(getTopRow())).append(""
"");
        buffer.append(""    .leftcol        = "")
            .append(Integer.toHexString(getLeftCol())).append(""
"");
        buffer.append(""    .headercolor    = "")
            .append(Integer.toHexString(getHeaderColor())).append(""
"");
        buffer.append(""    .pagebreakzoom  = "")
            .append(Integer.toHexString(getPageBreakZoom())).append(""
"");
        buffer.append(""    .normalzoom     = "")
            .append(Integer.toHexString(getNormalZoom())).append(""
"");
        buffer.append(""    .reserved       = "")
            .append(Integer.toHexString(getReserved())).append(""
"");
        buffer.append(""[/WINDOW2]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getOptions());
        out.writeShort(getTopRow());
        out.writeShort(getLeftCol());
        out.writeInt(getHeaderColor());
        out.writeShort(getPageBreakZoom());
        out.writeShort(getNormalZoom());
        out.writeInt(getReserved());
    }

    protected int getDataSize() {
        return 18;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      WindowTwoRecord rec = new WindowTwoRecord();
      rec.field_1_options = field_1_options;
      rec.field_2_top_row = field_2_top_row;
      rec.field_3_left_col = field_3_left_col;
      rec.field_4_header_color = field_4_header_color;
      rec.field_5_page_break_zoom = field_5_page_break_zoom;
      rec.field_6_normal_zoom = field_6_normal_zoom;
      rec.field_7_reserved = field_7_reserved;
      return rec;
    }
}
"
poi,3,org.apache.poi.poifs.storage.BlockAllocationTableReader,7,1,0,12,29,1,7,6,1,0.0,257,1.0,1,0.0,0.514285714,0,0,35.57142857,2,0.7143,4,"

package org.apache.poi.poifs.storage;

import java.io.IOException;

import java.util.*;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.*;


public final class BlockAllocationTableReader {
    private static final POILogger _logger = POILogFactory.getLogger(BlockAllocationTableReader.class);

    
    private static final int MAX_BLOCK_COUNT = 65535;
    private final IntList _entries;
    private POIFSBigBlockSize bigBlockSize;

    
    public BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, int block_count, int [] block_array,
            int xbat_count, int xbat_index, BlockList raw_block_list) throws IOException {
        this(bigBlockSize);
        
        sanityCheckBlockCount(block_count);

        
        
        
        
        
        
        int          limit    = Math.min(block_count, block_array.length);
        int          block_index;
        
        
        RawDataBlock blocks[] = new RawDataBlock[ block_count ];

        
        for (block_index = 0; block_index < limit; block_index++)
        {
            
            int nextOffset = block_array[ block_index ];
            if(nextOffset > raw_block_list.blockCount()) {
               throw new IOException(""Your file contains "" + raw_block_list.blockCount() + 
                     "" sectors, but the initial DIFAT array at index "" + block_index +
                     "" referenced block # "" + nextOffset + "". This isn't allowed and "" +
                     "" your file is corrupt"");
            }
            
            blocks[ block_index ] =
                ( RawDataBlock ) raw_block_list.remove(nextOffset);
        }
        
        
        if (block_index < block_count)
        {

            
            if (xbat_index < 0)
            {
                throw new IOException(
                    ""BAT count exceeds limit, yet XBAT index indicates no valid entries"");
            }
            int chain_index           = xbat_index;
            int max_entries_per_block = bigBlockSize.getXBATEntriesPerBlock(); 
            int chain_index_offset    = bigBlockSize.getNextXBATChainOffset(); 

            
            
            
            for (int j = 0; j < xbat_count; j++)
            {
                limit = Math.min(block_count - block_index,
                                 max_entries_per_block);
                byte[] data   = raw_block_list.remove(chain_index).getData();
                int    offset = 0;

                for (int k = 0; k < limit; k++)
                {
                    blocks[ block_index++ ] =
                        ( RawDataBlock ) raw_block_list
                            .remove(LittleEndian.getInt(data, offset));
                    offset                  += LittleEndianConsts.INT_SIZE;
                }
                chain_index = LittleEndian.getInt(data, chain_index_offset);
                if (chain_index == POIFSConstants.END_OF_CHAIN)
                {
                    break;
                }
            }
        }
        if (block_index != block_count)
        {
            throw new IOException(""Could not find all blocks"");
        }

        
        
        setEntries(blocks, raw_block_list);
    }

    
    BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, BlockList raw_block_list)
            throws IOException {
        this(bigBlockSize);
        setEntries(blocks, raw_block_list);
    }

    BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize) {
        this.bigBlockSize = bigBlockSize;
        _entries = new IntList();
    }
    
    public static void sanityCheckBlockCount(int block_count) throws IOException {
       if (block_count <= 0) {
          throw new IOException(
                ""Illegal block count; minimum count is 1, got "" + 
                block_count + "" instead""
          );
       }
       if (block_count > MAX_BLOCK_COUNT) {
          throw new IOException(
                ""Block count "" + block_count + 
                "" is too high. POI maximum is "" + MAX_BLOCK_COUNT + "".""
          );
       }
    }

    
    ListManagedBlock[] fetchBlocks(int startBlock, int headerPropertiesStartBlock,
            BlockList blockList) throws IOException {
        List<ListManagedBlock> blocks = new ArrayList<ListManagedBlock>();
        int  currentBlock = startBlock;
        boolean firstPass = true;
        ListManagedBlock dataBlock = null;

        
        
        
        
        while (currentBlock != POIFSConstants.END_OF_CHAIN) {
            try {
                
                dataBlock = blockList.remove(currentBlock);
                blocks.add(dataBlock);
                
                currentBlock = _entries.get(currentBlock);
                firstPass = false;
            } catch(IOException e) {
                if(currentBlock == headerPropertiesStartBlock) {
                    
                    _logger.log(POILogger.WARN, ""Warning, header block comes after data blocks in POIFS block listing"");
                    currentBlock = POIFSConstants.END_OF_CHAIN;
                } else if(currentBlock == 0 && firstPass) {
                    
                    
                    _logger.log(POILogger.WARN, ""Warning, incorrectly terminated empty data blocks in POIFS block listing (should end at -2, ended at 0)"");
                    currentBlock = POIFSConstants.END_OF_CHAIN;
                } else {
                    
                    throw e;
                }
            }
        }

        return blocks.toArray(new ListManagedBlock[blocks.size()]);
    }

    

    
    boolean isUsed(int index) {

        try {
            return _entries.get(index) != -1;
        } catch (IndexOutOfBoundsException e) {
            
            return false;
        }
    }

    
    int getNextBlockIndex(int index) throws IOException {
        if (isUsed(index)) {
            return _entries.get(index);
        }
        throw new IOException(""index "" + index + "" is unused"");
    }

    
    private void setEntries(ListManagedBlock[] blocks, BlockList raw_blocks) throws IOException {
        int limit = bigBlockSize.getBATEntriesPerBlock(); 

        for (int block_index = 0; block_index < blocks.length; block_index++)
        {
            byte[] data   = blocks[ block_index ].getData();
            int    offset = 0;

            for (int k = 0; k < limit; k++)
            {
                int entry = LittleEndian.getInt(data, offset);

                if (entry == POIFSConstants.UNUSED_BLOCK)
                {
                    raw_blocks.zap(_entries.size());
                }
                _entries.add(entry);
                offset += LittleEndianConsts.INT_SIZE;
            }

            
            blocks[ block_index ] = null;
        }
        raw_blocks.setBAT(this);
    }
}
"
poi,3,org.apache.poi.hpsf.UnexpectedPropertySetTypeException,4,4,0,4,8,6,3,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class UnexpectedPropertySetTypeException extends HPSFException
{

    
    public UnexpectedPropertySetTypeException()
    {
        super();
    }


    
    public UnexpectedPropertySetTypeException(final String msg)
    {
        super(msg);
    }


    
    public UnexpectedPropertySetTypeException(final Throwable reason)
    {
        super(reason);
    }


    
    public UnexpectedPropertySetTypeException(final String msg,
                                              final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.util.BinaryTree,57,2,0,15,87,1362,14,7,17,0.927083333,1806,1.0,1,0.25,0.265306122,1,7,30.47368421,19,2.5263,1,"

package org.apache.poi.util;

import java.util.*;



@SuppressWarnings(""rawtypes"")
public class BinaryTree extends AbstractMap {
    final Node[] _root;
    int _size = 0;
    int _modifications = 0;
    private final Set[] _key_set = new Set[] { null, null };
    private final Set[] _entry_set = new Set[] { null, null };
    private final Collection[] _value_collection = new Collection[] { null, null };
    static int      _KEY              = 0;
    static int      _VALUE            = 1;
    private static int      _INDEX_SUM        = _KEY + _VALUE;
    private static int      _MINIMUM_INDEX    = 0;
    private static int      _INDEX_COUNT      = 2;
    private static String[] _data_name        = new String[]
    {
        ""key"", ""value""
    };

    
    public BinaryTree() {
        _root = new Node[]{ null, null, };
    }

    
    public BinaryTree(Map map)
        throws ClassCastException, NullPointerException,
                IllegalArgumentException
    {
    	this();
        putAll(map);
    }

    
    public Object getKeyForValue(Object value)
        throws ClassCastException, NullPointerException
    {
        return doGet(( Comparable ) value, _VALUE);
    }

    
    public Object removeValue(Object value)
    {
        return doRemove(( Comparable ) value, _VALUE);
    }

    
    public Set entrySetByValue()
    {
        if (_entry_set[ _VALUE ] == null)
        {
            _entry_set[ _VALUE ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_VALUE)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node;
                        }
                    };
                }

                public boolean contains(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    key   = entry.getKey();
                    Node      node  = lookup(( Comparable ) entry.getValue(),
                                             _VALUE);

                    return (node != null) && node.getData(_KEY).equals(key);
                }

                public boolean remove(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    key   = entry.getKey();
                    Node      node  = lookup(( Comparable ) entry.getValue(),
                                             _VALUE);

                    if ((node != null) && node.getData(_KEY).equals(key))
                    {
                        doRedBlackDelete(node);
                        return true;
                    }
                    return false;
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _entry_set[ _VALUE ];
    }

    

    public Set keySetByValue()
    {
        if (_key_set[ _VALUE ] == null)
        {
            _key_set[ _VALUE ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_VALUE)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_KEY);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsKey(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    BinaryTree.this.remove(o);
                    return _size != old_size;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _key_set[ _VALUE ];
    }

    

    public Collection valuesByValue()
    {
        if (_value_collection[ _VALUE ] == null)
        {
            _value_collection[ _VALUE ] = new AbstractCollection()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_VALUE)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_VALUE);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsValue(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    removeValue(o);
                    return _size != old_size;
                }

                public boolean removeAll(Collection c)
                {
                    boolean  modified = false;
                    Iterator iter     = c.iterator();

                    while (iter.hasNext())
                    {
                        if (removeValue(iter.next()) != null)
                        {
                            modified = true;
                        }
                    }
                    return modified;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _value_collection[ _VALUE ];
    }

    
    private Object doRemove(Comparable o, int index)
    {
        Node   node = lookup(o, index);
        Object rval = null;

        if (node != null)
        {
            rval = node.getData(oppositeIndex(index));
            doRedBlackDelete(node);
        }
        return rval;
    }

    
    private Object doGet(Comparable o, int index)
    {
        checkNonNullComparable(o, index);
        Node node = lookup(o, index);

        return ((node == null) ? null
                               : node.getData(oppositeIndex(index)));
    }

    
    private int oppositeIndex(int index)
    {

        
        
        
        return _INDEX_SUM - index;
    }

    
    public Node lookup(Comparable data, int index)
    {
        Node rval = null;
        Node node = _root[ index ];

        while (node != null)
        {
            int cmp = compare(data, node.getData(index));

            if (cmp == 0)
            {
                rval = node;
                break;
            }
            node = (cmp < 0) ? node.getLeft(index)
                             : node.getRight(index);
        }
        return rval;
    }

    
    private static int compare(Comparable o1, Comparable o2)
    {
        return o1.compareTo(o2);
    }

    
    static Node leastNode(Node node, int index)
    {
        Node rval = node;

        if (rval != null)
        {
            while (rval.getLeft(index) != null)
            {
                rval = rval.getLeft(index);
            }
        }
        return rval;
    }

    
    static Node nextGreater(Node node, int index)
    {
        Node rval = null;

        if (node == null)
        {
            rval = null;
        }
        else if (node.getRight(index) != null)
        {

            
            
            rval = leastNode(node.getRight(index), index);
        }
        else
        {

            
            
            
            
            
            
            Node parent = node.getParent(index);
            Node child  = node;

            while ((parent != null) && (child == parent.getRight(index)))
            {
                child  = parent;
                parent = parent.getParent(index);
            }
            rval = parent;
        }
        return rval;
    }

    
    private static void copyColor(Node from, Node to, int index)
    {
        if (to != null)
        {
            if (from == null)
            {

                
                to.setBlack(index);
            }
            else
            {
                to.copyColor(from, index);
            }
        }
    }

    
    private static boolean isRed(Node node, int index)
    {
        return node == null ? false : node.isRed(index);
    }

    
    private static boolean isBlack(Node node, int index)
    {
        return node == null ? true : node.isBlack(index);
    }

    
    private static void makeRed(Node node, int index)
    {
        if (node != null)
        {
            node.setRed(index);
        }
    }

    
    private static void makeBlack(Node node, int index)
    {
        if (node != null)
        {
            node.setBlack(index);
        }
    }

    
    private static Node getGrandParent(Node node, int index)
    {
        return getParent(getParent(node, index), index);
    }

    
    private static Node getParent(Node node, int index)
    {
        return ((node == null) ? null
                               : node.getParent(index));
    }

    
    private static Node getRightChild(Node node, int index)
    {
        return (node == null) ? null
                              : node.getRight(index);
    }

    
    private static Node getLeftChild(Node node, int index)
    {
        return (node == null) ? null
                              : node.getLeft(index);
    }

    
    private static boolean isLeftChild(Node node, int index) {
        if (node == null) {
            return true;
        }
        if (node.getParent(index) == null) {
            return false;
        }
        return node == node.getParent(index).getLeft(index);
    }

    
    private static boolean isRightChild(Node node, int index)
    {
        if (node == null) {
            return true;
        }
        if (node.getParent(index) == null) {
            return false;
        }
        return node == node.getParent(index).getRight(index);
    }

    
    private void rotateLeft(Node node, int index)
    {
        Node right_child = node.getRight(index);

        node.setRight(right_child.getLeft(index), index);
        if (right_child.getLeft(index) != null)
        {
            right_child.getLeft(index).setParent(node, index);
        }
        right_child.setParent(node.getParent(index), index);
        if (node.getParent(index) == null)
        {

            
            _root[ index ] = right_child;
        }
        else if (node.getParent(index).getLeft(index) == node)
        {
            node.getParent(index).setLeft(right_child, index);
        }
        else
        {
            node.getParent(index).setRight(right_child, index);
        }
        right_child.setLeft(node, index);
        node.setParent(right_child, index);
    }

    
    private void rotateRight(Node node, int index)
    {
        Node left_child = node.getLeft(index);

        node.setLeft(left_child.getRight(index), index);
        if (left_child.getRight(index) != null)
        {
            left_child.getRight(index).setParent(node, index);
        }
        left_child.setParent(node.getParent(index), index);
        if (node.getParent(index) == null)
        {

            
            _root[ index ] = left_child;
        }
        else if (node.getParent(index).getRight(index) == node)
        {
            node.getParent(index).setRight(left_child, index);
        }
        else
        {
            node.getParent(index).setLeft(left_child, index);
        }
        left_child.setRight(node, index);
        node.setParent(left_child, index);
    }

    
    private void doRedBlackInsert(Node inserted_node, int index)
    {
        Node current_node = inserted_node;

        makeRed(current_node, index);
        while ((current_node != null) && (current_node != _root[ index ])
                && (isRed(current_node.getParent(index), index)))
        {
            if (isLeftChild(getParent(current_node, index), index))
            {
                Node y = getRightChild(getGrandParent(current_node, index),
                                       index);

                if (isRed(y, index))
                {
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(y, index);
                    makeRed(getGrandParent(current_node, index), index);
                    current_node = getGrandParent(current_node, index);
                }
                else
                {
                    if (isRightChild(current_node, index))
                    {
                        current_node = getParent(current_node, index);
                        rotateLeft(current_node, index);
                    }
                    makeBlack(getParent(current_node, index), index);
                    makeRed(getGrandParent(current_node, index), index);
                    if (getGrandParent(current_node, index) != null)
                    {
                        rotateRight(getGrandParent(current_node, index),
                                    index);
                    }
                }
            }
            else
            {

                
                Node y = getLeftChild(getGrandParent(current_node, index),
                                      index);

                if (isRed(y, index))
                {
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(y, index);
                    makeRed(getGrandParent(current_node, index), index);
                    current_node = getGrandParent(current_node, index);
                }
                else
                {
                    if (isLeftChild(current_node, index))
                    {
                        current_node = getParent(current_node, index);
                        rotateRight(current_node, index);
                    }
                    makeBlack(getParent(current_node, index), index);
                    makeRed(getGrandParent(current_node, index), index);
                    if (getGrandParent(current_node, index) != null)
                    {
                        rotateLeft(getGrandParent(current_node, index),
                                   index);
                    }
                }
            }
        }
        makeBlack(_root[ index ], index);
    }

    
    void doRedBlackDelete(Node deleted_node)
    {
        for (int index = _MINIMUM_INDEX; index < _INDEX_COUNT; index++)
        {

            
            
            if ((deleted_node.getLeft(index) != null)
                    && (deleted_node.getRight(index) != null))
            {
                swapPosition(nextGreater(deleted_node, index), deleted_node,
                             index);
            }
            Node replacement = ((deleted_node.getLeft(index) != null)
                                ? deleted_node.getLeft(index)
                                : deleted_node.getRight(index));

            if (replacement != null)
            {
                replacement.setParent(deleted_node.getParent(index), index);
                if (deleted_node.getParent(index) == null)
                {
                    _root[ index ] = replacement;
                }
                else if (deleted_node
                         == deleted_node.getParent(index).getLeft(index))
                {
                    deleted_node.getParent(index).setLeft(replacement, index);
                }
                else
                {
                    deleted_node.getParent(index).setRight(replacement,
                                           index);
                }
                deleted_node.setLeft(null, index);
                deleted_node.setRight(null, index);
                deleted_node.setParent(null, index);
                if (isBlack(deleted_node, index))
                {
                    doRedBlackDeleteFixup(replacement, index);
                }
            }
            else
            {

                
                if (deleted_node.getParent(index) == null)
                {

                    
                    _root[ index ] = null;
                }
                else
                {

                    
                    if (isBlack(deleted_node, index))
                    {
                        doRedBlackDeleteFixup(deleted_node, index);
                    }
                    if (deleted_node.getParent(index) != null)
                    {
                        if (deleted_node
                                == deleted_node.getParent(index)
                                    .getLeft(index))
                        {
                            deleted_node.getParent(index).setLeft(null,
                                                   index);
                        }
                        else
                        {
                            deleted_node.getParent(index).setRight(null,
                                                   index);
                        }
                        deleted_node.setParent(null, index);
                    }
                }
            }
        }
        shrink();
    }

    
    private void doRedBlackDeleteFixup(Node replacement_node,
                                       int index)
    {
        Node current_node = replacement_node;

        while ((current_node != _root[ index ])
                && (isBlack(current_node, index)))
        {
            if (isLeftChild(current_node, index))
            {
                Node sibling_node =
                    getRightChild(getParent(current_node, index), index);

                if (isRed(sibling_node, index))
                {
                    makeBlack(sibling_node, index);
                    makeRed(getParent(current_node, index), index);
                    rotateLeft(getParent(current_node, index), index);
                    sibling_node =
                        getRightChild(getParent(current_node, index), index);
                }
                if (isBlack(getLeftChild(sibling_node, index), index)
                        && isBlack(getRightChild(sibling_node, index), index))
                {
                    makeRed(sibling_node, index);
                    current_node = getParent(current_node, index);
                }
                else
                {
                    if (isBlack(getRightChild(sibling_node, index), index))
                    {
                        makeBlack(getLeftChild(sibling_node, index), index);
                        makeRed(sibling_node, index);
                        rotateRight(sibling_node, index);
                        sibling_node =
                            getRightChild(getParent(current_node, index),
                                          index);
                    }
                    copyColor(getParent(current_node, index), sibling_node,
                              index);
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(getRightChild(sibling_node, index), index);
                    rotateLeft(getParent(current_node, index), index);
                    current_node = _root[ index ];
                }
            }
            else
            {
                Node sibling_node =
                    getLeftChild(getParent(current_node, index), index);

                if (isRed(sibling_node, index))
                {
                    makeBlack(sibling_node, index);
                    makeRed(getParent(current_node, index), index);
                    rotateRight(getParent(current_node, index), index);
                    sibling_node =
                        getLeftChild(getParent(current_node, index), index);
                }
                if (isBlack(getRightChild(sibling_node, index), index)
                        && isBlack(getLeftChild(sibling_node, index), index))
                {
                    makeRed(sibling_node, index);
                    current_node = getParent(current_node, index);
                }
                else
                {
                    if (isBlack(getLeftChild(sibling_node, index), index))
                    {
                        makeBlack(getRightChild(sibling_node, index), index);
                        makeRed(sibling_node, index);
                        rotateLeft(sibling_node, index);
                        sibling_node =
                            getLeftChild(getParent(current_node, index),
                                         index);
                    }
                    copyColor(getParent(current_node, index), sibling_node,
                              index);
                    makeBlack(getParent(current_node, index), index);
                    makeBlack(getLeftChild(sibling_node, index), index);
                    rotateRight(getParent(current_node, index), index);
                    current_node = _root[ index ];
                }
            }
        }
        makeBlack(current_node, index);
    }

    
    private void swapPosition(Node x, Node y, int index)
    {

        
        Node    x_old_parent      = x.getParent(index);
        Node    x_old_left_child  = x.getLeft(index);
        Node    x_old_right_child = x.getRight(index);
        Node    y_old_parent      = y.getParent(index);
        Node    y_old_left_child  = y.getLeft(index);
        Node    y_old_right_child = y.getRight(index);
        boolean x_was_left_child  =
            (x.getParent(index) != null)
            && (x == x.getParent(index).getLeft(index));
        boolean y_was_left_child  =
            (y.getParent(index) != null)
            && (y == y.getParent(index).getLeft(index));

        
        if (x == y_old_parent)
        {   
            x.setParent(y, index);
            if (y_was_left_child)
            {
                y.setLeft(x, index);
                y.setRight(x_old_right_child, index);
            }
            else
            {
                y.setRight(x, index);
                y.setLeft(x_old_left_child, index);
            }
        }
        else
        {
            x.setParent(y_old_parent, index);
            if (y_old_parent != null)
            {
                if (y_was_left_child)
                {
                    y_old_parent.setLeft(x, index);
                }
                else
                {
                    y_old_parent.setRight(x, index);
                }
            }
            y.setLeft(x_old_left_child, index);
            y.setRight(x_old_right_child, index);
        }
        if (y == x_old_parent)
        {   
            y.setParent(x, index);
            if (x_was_left_child)
            {
                x.setLeft(y, index);
                x.setRight(y_old_right_child, index);
            }
            else
            {
                x.setRight(y, index);
                x.setLeft(y_old_left_child, index);
            }
        }
        else
        {
            y.setParent(x_old_parent, index);
            if (x_old_parent != null)
            {
                if (x_was_left_child)
                {
                    x_old_parent.setLeft(y, index);
                }
                else
                {
                    x_old_parent.setRight(y, index);
                }
            }
            x.setLeft(y_old_left_child, index);
            x.setRight(y_old_right_child, index);
        }

        
        if (x.getLeft(index) != null)
        {
            x.getLeft(index).setParent(x, index);
        }
        if (x.getRight(index) != null)
        {
            x.getRight(index).setParent(x, index);
        }
        if (y.getLeft(index) != null)
        {
            y.getLeft(index).setParent(y, index);
        }
        if (y.getRight(index) != null)
        {
            y.getRight(index).setParent(y, index);
        }
        x.swapColors(y, index);

        
        if (_root[ index ] == x)
        {
            _root[ index ] = y;
        }
        else if (_root[ index ] == y)
        {
            _root[ index ] = x;
        }
    }

    
    private static void checkNonNullComparable(Object o,
                                               int index)
    {
        if (o == null)
        {
            throw new NullPointerException(_data_name[ index ]
                                           + "" cannot be null"");
        }
        if (!(o instanceof Comparable))
        {
            throw new ClassCastException(_data_name[ index ]
                                         + "" must be Comparable"");
        }
    }

    
    private static void checkKey(Object key)
    {
        checkNonNullComparable(key, _KEY);
    }

    
    private static void checkValue(Object value)
    {
        checkNonNullComparable(value, _VALUE);
    }

    
    private static void checkKeyAndValue(Object key, Object value)
    {
        checkKey(key);
        checkValue(value);
    }

    
    private void modify()
    {
        _modifications++;
    }

    
    private void grow()
    {
        modify();
        _size++;
    }

    
    private void shrink()
    {
        modify();
        _size--;
    }

    
    private void insertValue(Node newNode)
        throws IllegalArgumentException
    {
        Node node = _root[ _VALUE ];

        while (true)
        {
            int cmp = compare(newNode.getData(_VALUE), node.getData(_VALUE));

            if (cmp == 0)
            {
                throw new IllegalArgumentException(
                    ""Cannot store a duplicate value (""""
                    + newNode.getData(_VALUE) + """") in this Map"");
            }
            else if (cmp < 0)
            {
                if (node.getLeft(_VALUE) != null)
                {
                    node = node.getLeft(_VALUE);
                }
                else
                {
                    node.setLeft(newNode, _VALUE);
                    newNode.setParent(node, _VALUE);
                    doRedBlackInsert(newNode, _VALUE);
                    break;
                }
            }
            else
            {   
                if (node.getRight(_VALUE) != null)
                {
                    node = node.getRight(_VALUE);
                }
                else
                {
                    node.setRight(newNode, _VALUE);
                    newNode.setParent(node, _VALUE);
                    doRedBlackInsert(newNode, _VALUE);
                    break;
                }
            }
        }
    }

    

    
    public int size()
    {
        return _size;
    }

    
    public boolean containsKey(Object key)
        throws ClassCastException, NullPointerException
    {
        checkKey(key);
        return lookup(( Comparable ) key, _KEY) != null;
    }

    
    public boolean containsValue(Object value)
    {
        checkValue(value);
        return lookup(( Comparable ) value, _VALUE) != null;
    }

    
    public Object get(Object key)
        throws ClassCastException, NullPointerException
    {
        return doGet(( Comparable ) key, _KEY);
    }

    
    public Object put(Object key, Object value)
        throws ClassCastException, NullPointerException,
                IllegalArgumentException
    {
        checkKeyAndValue(key, value);
        Node node = _root[ _KEY ];

        if (node == null)
        {
            Node root = new Node(( Comparable ) key, ( Comparable ) value);

            _root[ _KEY ]   = root;
            _root[ _VALUE ] = root;
            grow();
        }
        else
        {
            while (true)
            {
                int cmp = compare(( Comparable ) key, node.getData(_KEY));

                if (cmp == 0)
                {
                    throw new IllegalArgumentException(
                        ""Cannot store a duplicate key ("""" + key
                        + """") in this Map"");
                }
                else if (cmp < 0)
                {
                    if (node.getLeft(_KEY) != null)
                    {
                        node = node.getLeft(_KEY);
                    }
                    else
                    {
                        Node newNode = new Node(( Comparable ) key,
                                                ( Comparable ) value);

                        insertValue(newNode);
                        node.setLeft(newNode, _KEY);
                        newNode.setParent(node, _KEY);
                        doRedBlackInsert(newNode, _KEY);
                        grow();
                        break;
                    }
                }
                else
                {   
                    if (node.getRight(_KEY) != null)
                    {
                        node = node.getRight(_KEY);
                    }
                    else
                    {
                        Node newNode = new Node(( Comparable ) key,
                                                ( Comparable ) value);

                        insertValue(newNode);
                        node.setRight(newNode, _KEY);
                        newNode.setParent(node, _KEY);
                        doRedBlackInsert(newNode, _KEY);
                        grow();
                        break;
                    }
                }
            }
        }
        return null;
    }

    
    public Object remove(Object key)
    {
        return doRemove(( Comparable ) key, _KEY);
    }

    
    public void clear()
    {
        modify();
        _size           = 0;
        _root[ _KEY ]   = null;
        _root[ _VALUE ] = null;
    }

    
    public Set keySet()
    {
        if (_key_set[ _KEY ] == null)
        {
            _key_set[ _KEY ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_KEY)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_KEY);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsKey(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    BinaryTree.this.remove(o);
                    return _size != old_size;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _key_set[ _KEY ];
    }

    
    public Collection values()
    {
        if (_value_collection[ _KEY ] == null)
        {
            _value_collection[ _KEY ] = new AbstractCollection()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_KEY)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node.getData(_VALUE);
                        }
                    };
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public boolean contains(Object o)
                {
                    return containsValue(o);
                }

                public boolean remove(Object o)
                {
                    int old_size = _size;

                    removeValue(o);
                    return _size != old_size;
                }

                public boolean removeAll(Collection c)
                {
                    boolean  modified = false;
                    Iterator iter     = c.iterator();

                    while (iter.hasNext())
                    {
                        if (removeValue(iter.next()) != null)
                        {
                            modified = true;
                        }
                    }
                    return modified;
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _value_collection[ _KEY ];
    }

    
    public Set entrySet()
    {
        if (_entry_set[ _KEY ] == null)
        {
            _entry_set[ _KEY ] = new AbstractSet()
            {
                public Iterator iterator()
                {
                    return new BinaryTreeIterator(_KEY)
                    {
                        protected Object doGetNext()
                        {
                            return _last_returned_node;
                        }
                    };
                }

                public boolean contains(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    value = entry.getValue();
                    Node      node  = lookup(( Comparable ) entry.getKey(),
                                             _KEY);

                    return (node != null)
                           && node.getData(_VALUE).equals(value);
                }

                public boolean remove(Object o)
                {
                    if (!(o instanceof Map.Entry))
                    {
                        return false;
                    }
                    Map.Entry entry = ( Map.Entry ) o;
                    Object    value = entry.getValue();
                    Node      node  = lookup(( Comparable ) entry.getKey(),
                                             _KEY);

                    if ((node != null) && node.getData(_VALUE).equals(value))
                    {
                        doRedBlackDelete(node);
                        return true;
                    }
                    return false;
                }

                public int size()
                {
                    return BinaryTree.this.size();
                }

                public void clear()
                {
                    BinaryTree.this.clear();
                }
            };
        }
        return _entry_set[ _KEY ];
    }

    
    private abstract class BinaryTreeIterator
        implements Iterator
    {
        private int    _expected_modifications;
        protected Node _last_returned_node;
        private Node   _next_node;
        private int    _type;

        
        BinaryTreeIterator(int type)
        {
            _type                   = type;
            _expected_modifications = BinaryTree.this._modifications;
            _last_returned_node     = null;
            _next_node              = leastNode(_root[ _type ], _type);
        }

        

        protected abstract Object doGetNext();

        

        

        public boolean hasNext()
        {
            return _next_node != null;
        }

        

        public Object next()
            throws NoSuchElementException, ConcurrentModificationException
        {
            if (_next_node == null)
            {
                throw new NoSuchElementException();
            }
            if (_modifications != _expected_modifications)
            {
                throw new ConcurrentModificationException();
            }
            _last_returned_node = _next_node;
            _next_node          = nextGreater(_next_node, _type);
            return doGetNext();
        }

        

        public void remove()
            throws IllegalStateException, ConcurrentModificationException
        {
            if (_last_returned_node == null)
            {
                throw new IllegalStateException();
            }
            if (_modifications != _expected_modifications)
            {
                throw new ConcurrentModificationException();
            }
            doRedBlackDelete(_last_returned_node);
            _expected_modifications++;
            _last_returned_node = null;
        }

        
    }   

    
    private static final class Node
        implements Map.Entry
    {
        private Comparable[] _data;
        private Node[]       _left;
        private Node[]       _right;
        private Node[]       _parent;
        private boolean[]    _black;
        private int          _hashcode;
        private boolean      _calculated_hashcode;

        

        Node(Comparable key, Comparable value)
        {
            _data                = new Comparable[]
            {
                key, value
            };
            _left                = new Node[]
            {
                null, null
            };
            _right               = new Node[]
            {
                null, null
            };
            _parent              = new Node[]
            {
                null, null
            };
            _black               = new boolean[]
            {
                true, true
            };
            _calculated_hashcode = false;
        }

        
        public Comparable getData(int index)
        {
            return _data[ index ];
        }

        
        public void setLeft(Node node, int index)
        {
            _left[ index ] = node;
        }

        

        public Node getLeft(int index)
        {
            return _left[ index ];
        }

        
        public void setRight(Node node, int index)
        {
            _right[ index ] = node;
        }

        

        public Node getRight(int index)
        {
            return _right[ index ];
        }

        
        public void setParent(Node node, int index)
        {
            _parent[ index ] = node;
        }

        
        public Node getParent(int index)
        {
            return _parent[ index ];
        }

        
        public void swapColors(Node node, int index)
        {

            
            _black[ index ]      ^= node._black[ index ];
            node._black[ index ] ^= _black[ index ];
            _black[ index ]      ^= node._black[ index ];
        }

        
        public boolean isBlack(int index)
        {
            return _black[ index ];
        }

        
        public boolean isRed(int index)
        {
            return !_black[ index ];
        }

        
        public void setBlack(int index)
        {
            _black[ index ] = true;
        }

        
        public void setRed(int index)
        {
            _black[ index ] = false;
        }

        
        public void copyColor(Node node, int index)
        {
            _black[ index ] = node._black[ index ];
        }

        

        
        public Object getKey()
        {
            return _data[ _KEY ];
        }

        
        public Object getValue()
        {
            return _data[ _VALUE ];
        }

        
        public Object setValue(Object ignored)
            throws UnsupportedOperationException
        {
            throw new UnsupportedOperationException(
                ""Map.Entry.setValue is not supported"");
        }

        
        public boolean equals(Object o)
        {
            if (this == o)
            {
                return true;
            }
            if (!(o instanceof Map.Entry))
            {
                return false;
            }
            Map.Entry e = ( Map.Entry ) o;

            return _data[ _KEY ].equals(e.getKey())
                   && _data[ _VALUE ].equals(e.getValue());
        }

        

        public int hashCode()
        {
            if (!_calculated_hashcode)
            {
                _hashcode            = _data[ _KEY ].hashCode()
                                       ^ _data[ _VALUE ].hashCode();
                _calculated_hashcode = true;
            }
            return _hashcode;
        }

        
    }
}
"
poi,3,org.apache.poi.poifs.eventfilesystem.POIFSReaderRegistry,6,1,0,4,22,0,1,3,0,0.333333333,163,1.0,0,0.0,0.5,0,0,25.66666667,5,2.3333,0,"

        

package org.apache.poi.poifs.eventfilesystem;

import java.util.*;

import org.apache.poi.poifs.filesystem.DocumentDescriptor;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;



class POIFSReaderRegistry
{

    
    private Set omnivorousListeners;

    
    
    
    
    private Map selectiveListeners;

    
    
    
    
    
    private Map chosenDocumentDescriptors;

    

    POIFSReaderRegistry()
    {
        omnivorousListeners       = new HashSet();
        selectiveListeners        = new HashMap();
        chosenDocumentDescriptors = new HashMap();
    }

    

    void registerListener(final POIFSReaderListener listener,
                          final POIFSDocumentPath path,
                          final String documentName)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            Set descriptors = ( Set ) selectiveListeners.get(listener);

            if (descriptors == null)
            {

                
                descriptors = new HashSet();
                selectiveListeners.put(listener, descriptors);
            }
            DocumentDescriptor descriptor = new DocumentDescriptor(path,
                                                documentName);

            if (descriptors.add(descriptor))
            {

                
                
                
                Set listeners =
                    ( Set ) chosenDocumentDescriptors.get(descriptor);

                if (listeners == null)
                {

                    
                    listeners = new HashSet();
                    chosenDocumentDescriptors.put(descriptor, listeners);
                }
                listeners.add(listener);
            }
        }
    }

    

    void registerListener(final POIFSReaderListener listener)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            
            
            removeSelectiveListener(listener);
            omnivorousListeners.add(listener);
        }
    }

    

    Iterator getListeners(final POIFSDocumentPath path, final String name)
    {
        Set rval               = new HashSet(omnivorousListeners);
        Set selectiveListeners =
            ( Set ) chosenDocumentDescriptors.get(new DocumentDescriptor(path,
                name));

        if (selectiveListeners != null)
        {
            rval.addAll(selectiveListeners);
        }
        return rval.iterator();
    }

    private void removeSelectiveListener(final POIFSReaderListener listener)
    {
        Set selectedDescriptors = ( Set ) selectiveListeners.remove(listener);

        if (selectedDescriptors != null)
        {
            Iterator iter = selectedDescriptors.iterator();

            while (iter.hasNext())
            {
                dropDocument(listener, ( DocumentDescriptor ) iter.next());
            }
        }
    }

    private void dropDocument(final POIFSReaderListener listener,
                              final DocumentDescriptor descriptor)
    {
        Set listeners = ( Set ) chosenDocumentDescriptors.get(descriptor);

        listeners.remove(listener);
        if (listeners.size() == 0)
        {
            chosenDocumentDescriptors.remove(descriptor);
        }
    }
}   

"
poi,3,org.apache.poi.util.LongField,11,1,0,5,21,9,2,3,11,0.25,92,1.0,0,0.0,0.454545455,0,0,7.181818182,1,0.6364,0,"

        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class LongField
    implements FixedField
{
    private long      _value;
    private final int _offset;

    

    public LongField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(""Illegal offset: ""
                                                     + offset);
        }
        _offset = offset;
    }

    

    public LongField(final int offset, final long value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public LongField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public LongField(final int offset, final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public long get()
    {
        return _value;
    }

    

    public void set(final long value)
    {
        _value = value;
    }

    

    public void set(final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getLong(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readLong(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putLong(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,3,org.apache.poi.hssf.record.RecordProcessor,1,1,0,0,2,0,0,0,0,2.0,4,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"

        

package org.apache.poi.hssf.record;



class RecordProcessor
{
  
}

"
poi,3,org.apache.poi.hpsf.UnsupportedVariantTypeException,1,5,2,8,8,0,5,3,1,2.0,32,0.0,0,1.0,1.0,0,0,31.0,0,0.0,0,"

package org.apache.poi.hpsf;

import org.apache.poi.util.HexDump;


public abstract class UnsupportedVariantTypeException
extends VariantTypeException
{

    
    public UnsupportedVariantTypeException(final long variantType,
                                           final Object value)
    {
        super(variantType, value,
              ""HPSF does not yet support the variant type "" + variantType + 
              "" ("" + Variant.getVariantName(variantType) + "", "" +
              HexDump.toHex(variantType) + ""). If you want support for "" +
              ""this variant type in one of the next POI releases please "" +
              ""submit a request for enhancement (RFE) to "" +
              ""<http:
    }



}
"
poi,3,org.apache.poi.ddf.EscherClientDataRecord,9,2,0,11,27,6,6,5,9,0.875,180,0.333333333,0,0.703703704,0.355555556,1,5,18.66666667,2,1.1111,1,"


package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;

import java.io.ByteArrayOutputStream;


public class EscherClientDataRecord
    extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF011;
    public static final String RECORD_DESCRIPTION = ""MsofbtClientData"";

    private byte[] remainingData;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
        int pos            = offset + 8;
        remainingData  =  new byte[bytesRemaining];
        System.arraycopy( data, pos, remainingData, 0, bytesRemaining );
        return 8 + bytesRemaining;
    }

    public int serialize(int offset, byte[] data, EscherSerializationListener listener) {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        if (remainingData == null) remainingData = new byte[0];
        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );
        LittleEndian.putInt( data, offset + 4, remainingData.length );
        System.arraycopy( remainingData, 0, data, offset + 8, remainingData.length );
        int pos = offset + 8 + remainingData.length;

        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        return pos - offset;
    }

    public int getRecordSize()
    {
        return 8 + (remainingData == null ? 0 : remainingData.length);
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""ClientData"";
    }

    
    public String toString()
    {
        String nl = System.getProperty(""line.separator"");

        String extraData;
        ByteArrayOutputStream b = new ByteArrayOutputStream();
        try
        {
            HexDump.dump(this.remainingData, 0, b, 0);
            extraData = b.toString();
        }
        catch ( Exception e )
        {
            extraData = ""error
"";
        }
        return getClass().getName() + "":"" + nl +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + nl +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + nl +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + nl +
                ""  Extra Data:"" + nl +
                extraData;

    }

    @Override
    public String toXml(String tab) {
        String extraData;
        ByteArrayOutputStream b = new ByteArrayOutputStream();
        try
        {
            HexDump.dump(this.remainingData, 0, b, 0);
            extraData = b.toString();
        }
        catch ( Exception e )
        {
            extraData = ""error"";
        }
        if (extraData.contains(""No Data"")){
            extraData = ""No Data"";
        }
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()),
                HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<ExtraData>"").append(extraData).append(""</ExtraData>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public byte[] getRemainingData()
    {
        return remainingData;
    }

    
    public void setRemainingData( byte[] remainingData )
    {
        this.remainingData = remainingData;
    }
}
"
poi,3,org.apache.poi.hssf.record.LabelRecord,22,2,0,6,36,197,2,4,20,0.843537415,310,0.857142857,0,0.35483871,0.25,1,3,12.77272727,6,1.6364,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public final class LabelRecord extends Record implements CellValueRecordInterface {
    private final static POILogger logger = POILogFactory.getLogger(LabelRecord.class);

    public final static short sid = 0x0204;

    private int               field_1_row;
    private short             field_2_column;
    private short             field_3_xf_index;
    private short             field_4_string_len;
    private byte              field_5_unicode_flag;
    private String            field_6_value;

    
    public LabelRecord()
    {
    }

    
    public LabelRecord(RecordInputStream in)
    {
        field_1_row          = in.readUShort();
        field_2_column       = in.readShort();
        field_3_xf_index     = in.readShort();
        field_4_string_len   = in.readShort();
        field_5_unicode_flag = in.readByte();
        if (field_4_string_len > 0) {
            if (isUnCompressedUnicode()) {
                field_6_value = in.readUnicodeLEString(field_4_string_len);
            } else {
                field_6_value = in.readCompressedUnicode(field_4_string_len);
            }
        } else {
            field_6_value = """";
        }

        if (in.remaining() > 0) {
           logger.log(POILogger.INFO,
                   ""LabelRecord data remains: "" + in.remaining() +
                           "" : "" + HexDump.toHex(in.readRemainder())
           );
        }
    }


    public int getRow()
    {
        return field_1_row;
    }

    public short getColumn()
    {
        return field_2_column;
    }

    public short getXFIndex()
    {
        return field_3_xf_index;
    }

    
    public short getStringLength()
    {
        return field_4_string_len;
    }

    
    public boolean isUnCompressedUnicode()
    {
        return (field_5_unicode_flag & 0x01) != 0;
    }

    
    public String getValue()
    {
        return field_6_value;
    }

    
    public int serialize(int offset, byte [] data) {
        throw new RecordFormatException(""Label Records are supported READ ONLY...convert to LabelSST"");
    }
    public int getRecordSize() {
        throw new RecordFormatException(""Label Records are supported READ ONLY...convert to LabelSST"");
    }

    public short getSid()
    {
        return sid;
    }

    public String toString()
    {
        StringBuffer sb = new StringBuffer();
		sb.append(""[LABEL]
"");
		sb.append(""    .row       = "").append(HexDump.shortToHex(getRow())).append(""
"");
		sb.append(""    .column    = "").append(HexDump.shortToHex(getColumn())).append(""
"");
		sb.append(""    .xfindex   = "").append(HexDump.shortToHex(getXFIndex())).append(""
"");
		sb.append(""    .string_len= "").append(HexDump.shortToHex(field_4_string_len)).append(""
"");
		sb.append(""    .unicode_flag= "").append(HexDump.byteToHex(field_5_unicode_flag)).append(""
"");
		sb.append(""    .value       = "").append(getValue()).append(""
"");
		sb.append(""[/LABEL]
"");
        return sb.toString();
    }

    
    public void setColumn(short col)
    {
    }

    
    public void setRow(int row)
    {
    }

    
    public void setXFIndex(short xf)
    {
    }

    public Object clone() {
      LabelRecord rec = new LabelRecord();
      rec.field_1_row = field_1_row;
      rec.field_2_column = field_2_column;
      rec.field_3_xf_index = field_3_xf_index;
      rec.field_4_string_len = field_4_string_len;
      rec.field_5_unicode_flag = field_5_unicode_flag;
      rec.field_6_value = field_6_value;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFErrorConstants,0,1,0,0,0,0,0,0,0,2.0,7,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.poi.hssf.usermodel;
import org.apache.poi.ss.usermodel.ErrorConstants;


public final class HSSFErrorConstants extends ErrorConstants {
}
"
poi,3,org.apache.poi.hpsf.VariantSupport,8,2,0,10,61,22,4,7,6,0.642857143,725,1.0,0,0.0,0.196428571,0,0,89.375,54,7.75,1,"

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public class VariantSupport extends Variant
{
	private static final POILogger logger = POILogFactory.getLogger(VariantSupport.class);
    private static boolean logUnsupportedTypes = false;

    
    public static void setLogUnsupportedTypes(final boolean logUnsupportedTypes)
    {
        VariantSupport.logUnsupportedTypes = logUnsupportedTypes;
    }

    
    public static boolean isLogUnsupportedTypes()
    {
        return logUnsupportedTypes;
    }



    
    protected static List<Long> unsupportedMessage;

    
    protected static void writeUnsupportedTypeMessage
        (final UnsupportedVariantTypeException ex)
    {
        if (isLogUnsupportedTypes())
        {
            if (unsupportedMessage == null)
                unsupportedMessage = new LinkedList<Long>();
            Long vt = Long.valueOf(ex.getVariantType());
            if (!unsupportedMessage.contains(vt))
            {
            	logger.log( POILogger.ERROR, ex.getMessage());
                unsupportedMessage.add(vt);
            }
        }
    }


    
    final static public int[] SUPPORTED_TYPES = { Variant.VT_EMPTY,
            Variant.VT_I2, Variant.VT_I4, Variant.VT_I8, Variant.VT_R8,
            Variant.VT_FILETIME, Variant.VT_LPSTR, Variant.VT_LPWSTR,
            Variant.VT_CF, Variant.VT_BOOL };



    
    public boolean isSupportedType(final int variantType)
    {
        for (int i = 0; i < SUPPORTED_TYPES.length; i++)
            if (variantType == SUPPORTED_TYPES[i])
                return true;
        return false;
    }



    
    public static Object read( final byte[] src, final int offset,
            final int length, final long type, final int codepage )
            throws ReadingNotSupportedException, UnsupportedEncodingException
    {
        TypedPropertyValue typedPropertyValue = new TypedPropertyValue(
                (int) type, null );
        int unpadded;
        try
        {
            unpadded = typedPropertyValue.readValue( src, offset );
        }
        catch ( UnsupportedOperationException exc )
        {
            int propLength = Math.min( length, src.length - offset );
            final byte[] v = new byte[propLength];
            System.arraycopy( src, offset, v, 0, propLength );
            throw new ReadingNotSupportedException( type, v );
        }

        switch ( (int) type )
        {
        case Variant.VT_EMPTY:
        case Variant.VT_I4:
        case Variant.VT_I8:
        case Variant.VT_R8:
            
            return typedPropertyValue.getValue();

        case Variant.VT_I2:
        {
            
            return Integer.valueOf( ( (Short) typedPropertyValue.getValue() )
                    .intValue() );
        }
        case Variant.VT_FILETIME:
        {
            Filetime filetime = (Filetime) typedPropertyValue.getValue();
            return Util.filetimeToDate( (int) filetime.getHigh(),
                    (int) filetime.getLow() );
        }
        case Variant.VT_LPSTR:
        {
            CodePageString string = (CodePageString) typedPropertyValue
                    .getValue();
            return string.getJavaValue( codepage );
        }
        case Variant.VT_LPWSTR:
        {
            UnicodeString string = (UnicodeString) typedPropertyValue
                    .getValue();
            return string.toJavaString();
        }
        case Variant.VT_CF:
        {
            
            
            
            
            
            
            
            
            ClipboardData clipboardData = (ClipboardData) typedPropertyValue
                    .getValue();
            return clipboardData.toByteArray();
        }

        case Variant.VT_BOOL:
        {
            VariantBool bool = (VariantBool) typedPropertyValue.getValue();
            return Boolean.valueOf( bool.getValue() );
        }

        default:
        {
            
            final byte[] v = new byte[unpadded];
            System.arraycopy( src, offset, v, 0, unpadded );
            throw new ReadingNotSupportedException( type, v );
        }
        }
    }

    
    public static String codepageToEncoding(final int codepage)
    throws UnsupportedEncodingException
    {
        return CodePageUtil.codepageToEncoding(codepage);
    }


    
    public static int write(final OutputStream out, final long type,
                            final Object value, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        switch ((int) type)
        {
            case Variant.VT_BOOL:
            {
                if ( ( (Boolean) value ).booleanValue() )
                {
                    out.write( 0xff );
                    out.write( 0xff );
                }
                else
                {
                    out.write( 0x00 );
                    out.write( 0x00 );
                }
                length += 2;
                break;
            }
            case Variant.VT_LPSTR:
            {
                CodePageString codePageString = new CodePageString( (String) value,
                        codepage );
                length += codePageString.write( out );
                break;
            }
            case Variant.VT_LPWSTR:
            {
                final int nrOfChars = ( (String) value ).length() + 1;
                length += TypeWriter.writeUIntToStream( out, nrOfChars );
                char[] s = ( (String) value ).toCharArray();
                for ( int i = 0; i < s.length; i++ )
                {
                    final int high = ( ( s[i] & 0x0000ff00 ) >> 8 );
                    final int low = ( s[i] & 0x000000ff );
                    final byte highb = (byte) high;
                    final byte lowb = (byte) low;
                    out.write( lowb );
                    out.write( highb );
                    length += 2;
                }
                
                out.write( 0x00 );
                out.write( 0x00 );
                length += 2;
                break;
            }
            case Variant.VT_CF:
            {
                final byte[] b = (byte[]) value;
                out.write(b);
                length = b.length;
                break;
            }
            case Variant.VT_EMPTY:
            {
                length += TypeWriter.writeUIntToStream( out, Variant.VT_EMPTY );
                break;
            }
            case Variant.VT_I2:
            {
                length += TypeWriter.writeToStream( out,
                        ( (Integer) value ).shortValue() );
                break;
            }
            case Variant.VT_I4:
            {
                if (!(value instanceof Integer))
                {
                    throw new ClassCastException(""Could not cast an object to ""
                            + Integer.class.toString() + "": ""
                            + value.getClass().toString() + "", ""
                            + value.toString());
                }
                length += TypeWriter.writeToStream(out,
                          ((Integer) value).intValue());
                break;
            }
            case Variant.VT_I8:
            {
                length += TypeWriter.writeToStream(out, ((Long) value).longValue());
                break;
            }
            case Variant.VT_R8:
            {
                length += TypeWriter.writeToStream(out,
                          ((Double) value).doubleValue());
                break;
            }
            case Variant.VT_FILETIME:
            {
                long filetime = Util.dateToFileTime((Date) value);
                int high = (int) ((filetime >> 32) & 0x00000000FFFFFFFFL);
                int low = (int) (filetime & 0x00000000FFFFFFFFL);
                Filetime filetimeValue = new Filetime( low, high);
                length += filetimeValue.write( out );
                break;
            }
            default:
            {
                
                if (value instanceof byte[])
                {
                    final byte[] b = (byte[]) value;
                    out.write(b);
                    length = b.length;
                    writeUnsupportedTypeMessage
                        (new WritingNotSupportedException(type, value));
                }
                else
                    throw new WritingNotSupportedException(type, value);
                break;
            }
        }

        
        while ( ( length & 0x3 ) != 0 )
        {
            out.write( 0x00 );
            length++;
        }

        return length;
    }
}
"
poi,3,org.apache.poi.poifs.filesystem.DirectoryEntry,9,1,0,10,9,36,7,4,9,2.0,9,0.0,0,0.0,0.314814815,0,0,0.0,1,1.0,0,"



package org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;

import org.apache.poi.hpsf.ClassID;



public interface DirectoryEntry
    extends Entry, Iterable<Entry>
{

    

    public Iterator<Entry> getEntries();
    
    
    public Set<String> getEntryNames();

    

    public boolean isEmpty();

    

    public int getEntryCount();

    

    public boolean hasEntry( final String name );

    

    public Entry getEntry(final String name)
        throws FileNotFoundException;

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException;

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException;

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException;

    
    public ClassID getStorageClsid();

    
    public void setStorageClsid(ClassID clsidStorage);

}   

"
poi,3,org.apache.poi.hssf.usermodel.HSSFCellStyle,43,1,0,7,90,0,5,2,41,1.001035197,397,0.043478261,1,0.0,0.302325581,0,0,7.162790698,5,1.2093,2,"


package org.apache.poi.hssf.usermodel;

import java.util.List;

import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.ExtendedFormatRecord;
import org.apache.poi.hssf.record.FontRecord;
import org.apache.poi.hssf.record.FormatRecord;
import org.apache.poi.hssf.record.StyleRecord;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Font;


public final class HSSFCellStyle implements CellStyle {
    private ExtendedFormatRecord _format                     = null;
    private short                _index                      = 0;
    private InternalWorkbook             _workbook                   = null;


    
    protected HSSFCellStyle(short index, ExtendedFormatRecord rec, HSSFWorkbook workbook)
    {
    	this(index, rec, workbook.getWorkbook());
    }
    protected HSSFCellStyle(short index, ExtendedFormatRecord rec, InternalWorkbook workbook)
    {
        _workbook = workbook;
        _index = index;
        _format     = rec;
    }

    
    public short getIndex()
    {
        return _index;
    }

    
    public HSSFCellStyle getParentStyle() {
        short parentIndex = _format.getParentIndex();
        
    	if(parentIndex == 0 || parentIndex == 0xFFF) {
    		return null;
    	}
    	return new HSSFCellStyle(
    			parentIndex,
    			_workbook.getExFormatAt(parentIndex),
    			_workbook
    	);
    }

    
    public void setDataFormat(short fmt)
    {
        _format.setFormatIndex(fmt);
    }

    

    public short getDataFormat()
    {
        return _format.getFormatIndex();
    }

    
    
    
    private static ThreadLocal<Short> lastDateFormat = new ThreadLocal<Short>() {
        protected Short initialValue() {
            return Short.MIN_VALUE;
        }
    };
    private static ThreadLocal<List<FormatRecord>> lastFormats = new ThreadLocal<List<FormatRecord>>();
    private static ThreadLocal<String> getDataFormatStringCache = new ThreadLocal<String>();

    
    public String getDataFormatString() {
        if (getDataFormatStringCache.get() != null) {
            if (lastDateFormat.get() == getDataFormat() && _workbook.getFormats().equals(lastFormats.get())) {
                return getDataFormatStringCache.get();
            }
        }

        lastFormats.set(_workbook.getFormats());
        lastDateFormat.set(getDataFormat());

        getDataFormatStringCache.set(getDataFormatString(_workbook));

        return getDataFormatStringCache.get();
    }

    
    public String getDataFormatString(org.apache.poi.ss.usermodel.Workbook workbook) {
    	HSSFDataFormat format = new HSSFDataFormat( ((HSSFWorkbook)workbook).getWorkbook() );

        int idx = getDataFormat();
        return idx == -1 ? ""General"" : format.getFormat(getDataFormat());
    }
    
    public String getDataFormatString(org.apache.poi.hssf.model.InternalWorkbook workbook) {
    	HSSFDataFormat format = new HSSFDataFormat( workbook );

        return format.getFormat(getDataFormat());
    }

    
    public void setFont(Font font) {
		setFont((HSSFFont)font);
	}
	public void setFont(HSSFFont font) {
        _format.setIndentNotParentFont(true);
        short fontindex = font.getIndex();
        _format.setFontIndex(fontindex);
    }

    
    public short getFontIndex()
    {
        return _format.getFontIndex();
    }

    
    public HSSFFont getFont(org.apache.poi.ss.usermodel.Workbook parentWorkbook) {
    	return ((HSSFWorkbook) parentWorkbook).getFontAt(getFontIndex());
    }

    
    public void setHidden(boolean hidden)
    {
        _format.setIndentNotParentCellOptions(true);
        _format.setHidden(hidden);
    }

    
    public boolean getHidden()
    {
        return _format.isHidden();
    }

    
    public void setLocked(boolean locked)
    {
        _format.setIndentNotParentCellOptions(true);
        _format.setLocked(locked);
    }

    
    public boolean getLocked()
    {
        return _format.isLocked();
    }

    
    public void setAlignment(short align)
    {
        _format.setIndentNotParentAlignment(true);
        _format.setAlignment(align);
    }

    
    public short getAlignment()
    {
        return _format.getAlignment();
    }

    
    public void setWrapText(boolean wrapped)
    {
        _format.setIndentNotParentAlignment(true);
        _format.setWrapText(wrapped);
    }

    
    public boolean getWrapText()
    {
        return _format.getWrapText();
    }

    
    public void setVerticalAlignment(short align)
    {
        _format.setVerticalAlignment(align);
    }

    
    public short getVerticalAlignment()
    {
        return _format.getVerticalAlignment();
    }

    
    public void setRotation(short rotation)
    {
      if (rotation == 0xff) {
          
      } 
      else if ((rotation < 0)&&(rotation >= -90)) {
        
        
        rotation = (short)(90 - rotation);
      }
      else if ((rotation < -90)  ||(rotation > 90)) {
        
        throw new IllegalArgumentException(""The rotation must be between -90 and 90 degrees, or 0xff"");
      }
      _format.setRotation(rotation);
    }

    
    public short getRotation()
    {
      short rotation = _format.getRotation();
      if (rotation == 0xff) {
         
         return rotation;
      }
      if (rotation > 90) {
        
        rotation = (short)(90-rotation);
      }
      return rotation;
    }

    
    public void setIndention(short indent)
    {
        _format.setIndent(indent);
    }

    
    public short getIndention()
    {
        return _format.getIndent();
    }

    
    public void setBorderLeft(short border)
    {
        _format.setIndentNotParentBorder(true);
        _format.setBorderLeft(border);
    }

    
    public short getBorderLeft()
    {
        return _format.getBorderLeft();
    }

    
    public void setBorderRight(short border)
    {
        _format.setIndentNotParentBorder(true);
        _format.setBorderRight(border);
    }

    
    public short getBorderRight()
    {
        return _format.getBorderRight();
    }

    
    public void setBorderTop(short border)
    {
        _format.setIndentNotParentBorder(true);
        _format.setBorderTop(border);
    }

    
    public short getBorderTop()
    {
        return _format.getBorderTop();
    }

    
    public void setBorderBottom(short border)
    {
        _format.setIndentNotParentBorder(true);
        _format.setBorderBottom(border);
    }

    
    public short getBorderBottom()
    {
        return _format.getBorderBottom();
    }

    
    public void setLeftBorderColor(short color)
    {
        _format.setLeftBorderPaletteIdx(color);
    }

    
    public short getLeftBorderColor()
    {
        return _format.getLeftBorderPaletteIdx();
    }

    
    public void setRightBorderColor(short color)
    {
        _format.setRightBorderPaletteIdx(color);
    }

    
    public short getRightBorderColor()
    {
        return _format.getRightBorderPaletteIdx();
    }

    
    public void setTopBorderColor(short color)
    {
        _format.setTopBorderPaletteIdx(color);
    }

    
    public short getTopBorderColor()
    {
        return _format.getTopBorderPaletteIdx();
    }

    
    public void setBottomBorderColor(short color)
    {
        _format.setBottomBorderPaletteIdx(color);
    }

    
    public short getBottomBorderColor()
    {
        return _format.getBottomBorderPaletteIdx();
    }

    
    public void setFillPattern(short fp)
    {
        _format.setAdtlFillPattern(fp);
    }

    
    public short getFillPattern()
    {
        return _format.getAdtlFillPattern();
    }

    
    private void checkDefaultBackgroundFills() {
      if (_format.getFillForeground() == org.apache.poi.hssf.util.HSSFColor.AUTOMATIC.index) {
    	  
    	  
    	  
    	  if (_format.getFillBackground() != (org.apache.poi.hssf.util.HSSFColor.AUTOMATIC.index+1))
    		  setFillBackgroundColor((short)(org.apache.poi.hssf.util.HSSFColor.AUTOMATIC.index+1));
      } else if (_format.getFillBackground() == org.apache.poi.hssf.util.HSSFColor.AUTOMATIC.index+1)
    	  
    	  if (_format.getFillForeground() != org.apache.poi.hssf.util.HSSFColor.AUTOMATIC.index)
    		  setFillBackgroundColor(org.apache.poi.hssf.util.HSSFColor.AUTOMATIC.index);
    }

    
    public void setFillBackgroundColor(short bg)
    {
        _format.setFillBackground(bg);
        checkDefaultBackgroundFills();
    }

    
    public short getFillBackgroundColor()
    {
    	short result = _format.getFillBackground();
    	
    	
    	if (result == (HSSFColor.AUTOMATIC.index+1)) {
			return HSSFColor.AUTOMATIC.index;
		}
    	return result;
    }
    
    public HSSFColor getFillBackgroundColorColor() {
       HSSFPalette pallette = new HSSFPalette(
             _workbook.getCustomPalette()
       );
       return pallette.getColor(
             getFillBackgroundColor()
       );
    }

    
    public void setFillForegroundColor(short bg)
    {
        _format.setFillForeground(bg);
        checkDefaultBackgroundFills();
    }

    
    public short getFillForegroundColor()
    {
        return _format.getFillForeground();
    }

    public HSSFColor getFillForegroundColorColor() {
       HSSFPalette pallette = new HSSFPalette(
             _workbook.getCustomPalette()
       );
       return pallette.getColor(
             getFillForegroundColor()
       );
    }

    
    public String getUserStyleName() {
    	StyleRecord sr = _workbook.getStyleRecord(_index);
    	if(sr == null) {
    		return null;
    	}
    	if(sr.isBuiltin()) {
    		return null;
    	}
    	return sr.getName();
    }

    
    public void setUserStyleName(String styleName) {
    	StyleRecord sr = _workbook.getStyleRecord(_index);
    	if(sr == null) {
    		sr = _workbook.createStyleRecord(_index);
    	}
    	
    	
    	if(sr.isBuiltin() && _index <= 20) {
    		throw new IllegalArgumentException(""Unable to set user specified style names for built in styles!"");
    	}
    	sr.setName(styleName);
    }

    
    public void setShrinkToFit(boolean shrinkToFit) {
    	_format.setShrinkToFit(shrinkToFit);
    }
    
    public boolean getShrinkToFit() {
    	return _format.getShrinkToFit();
    }
	
    
    public short getReadingOrder() {
        return _format.getReadingOrder();
    }
    
    public void setReadingOrder(short order) {
        _format.setReadingOrder(order);
    }
    
    
    public void verifyBelongsToWorkbook(HSSFWorkbook wb) {
		if(wb.getWorkbook() != _workbook) {
			throw new IllegalArgumentException(""This Style does not belong to the supplied Workbook. Are you trying to assign a style from one workbook to the cell of a differnt workbook?"");
		}
	}

    
    public void cloneStyleFrom(CellStyle source) {
		if(source instanceof HSSFCellStyle) {
			this.cloneStyleFrom((HSSFCellStyle)source);
		} else {
		    throw new IllegalArgumentException(""Can only clone from one HSSFCellStyle to another, not between HSSFCellStyle and XSSFCellStyle"");
		}
	}
    public void cloneStyleFrom(HSSFCellStyle source) {
    	
    	
    	_format.cloneStyleFrom(source._format);

    	
    	if(_workbook != source._workbook) {

            lastDateFormat.set(Short.MIN_VALUE);
            lastFormats.set(null);
            getDataFormatStringCache.set(null);
    	   
			
			
    		short fmt = (short)_workbook.createFormat(source.getDataFormatString() );
    		setDataFormat(fmt);

			
			
    		FontRecord fr = _workbook.createNewFont();
    		fr.cloneStyleFrom(
    				source._workbook.getFontRecordAt(
    						source.getFontIndex()
    				)
    		);

    		HSSFFont font = new HSSFFont(
    				(short)_workbook.getFontIndex(fr), fr
    		);
    		setFont(font);
    	}
    }


	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((_format == null) ? 0 : _format.hashCode());
		result = prime * result + _index;
		return result;
	}

	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (obj instanceof HSSFCellStyle) {
			final HSSFCellStyle other = (HSSFCellStyle) obj;
			if (_format == null) {
				if (other._format != null)
					return false;
			} else if (!_format.equals(other._format))
				return false;
			if (_index != other._index)
				return false;
			return true;
		}
		return false;
	}
	
}
"
poi,3,org.apache.poi.poifs.filesystem.DocumentNode,9,2,0,9,17,30,3,7,6,0.75,55,1.0,1,0.529411765,0.407407407,1,1,5.0,1,0.8889,0,"

        

package org.apache.poi.poifs.filesystem;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;


public class DocumentNode
    extends EntryNode
    implements DocumentEntry, POIFSViewable
{

    
    private OPOIFSDocument _document;

    

    DocumentNode(final DocumentProperty property, final DirectoryNode parent)
    {
        super(property, parent);
        _document = property.getDocument();
    }

    
    OPOIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public int getSize()
    {
        return getProperty().getSize();
    }

    
    

    

    @Override
    public boolean isDocumentEntry()
    {
        return true;
    }

    
    

    

    @Override
    protected boolean isDeleteOK()
    {
        return true;
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        List<Object> components = new ArrayList<Object>();

        components.add(getProperty());
        components.add(_document);
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
}   

"
poi,3,org.apache.poi.hpsf.PropertySetFactory,4,1,0,11,16,6,0,11,4,2.0,83,0.0,0,0.0,0.25,0,0,19.75,1,0.75,0,"

package org.apache.poi.hpsf;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;

import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.DocumentEntry;
import org.apache.poi.poifs.filesystem.DocumentInputStream;


public class PropertySetFactory
{
    
    public static PropertySet create(final DirectoryEntry dir, final String name)
        throws FileNotFoundException, NoPropertySetStreamException,
               IOException, UnsupportedEncodingException
    {
        InputStream inp = null;
        try {
            DocumentEntry entry = (DocumentEntry)dir.getEntry(name);
            inp = new DocumentInputStream(entry);
            try {
                return create(inp);
            } catch (MarkUnsupportedException e) { return null; }
        } finally {
            if (inp != null) inp.close();
        }
    }

    
    public static PropertySet create(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               UnsupportedEncodingException, IOException
    {
        final PropertySet ps = new PropertySet(stream);
        try
        {
            if (ps.isSummaryInformation())
                return new SummaryInformation(ps);
            else if (ps.isDocumentSummaryInformation())
                return new DocumentSummaryInformation(ps);
            else
                return ps;
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new IllegalStateException(ex);
        }
    }

    
    public static SummaryInformation newSummaryInformation()
    {
        final MutablePropertySet ps = new MutablePropertySet();
        final MutableSection s = (MutableSection) ps.getFirstSection();
        s.setFormatID(SectionIDMap.SUMMARY_INFORMATION_ID);
        try
        {
            return new SummaryInformation(ps);
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new HPSFRuntimeException(ex);
        }
    }

    
    public static DocumentSummaryInformation newDocumentSummaryInformation()
    {
        final MutablePropertySet ps = new MutablePropertySet();
        final MutableSection s = (MutableSection) ps.getFirstSection();
        s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);
        try
        {
            return new DocumentSummaryInformation(ps);
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new HPSFRuntimeException(ex);
        }
    }
}"
poi,3,org.apache.poi.hssf.record.CellValueRecordInterface,10,1,0,14,10,45,14,0,10,2.0,10,0.0,0,0.0,0.4,0,0,0.0,1,1.0,0,"

package org.apache.poi.hssf.record;


public interface CellValueRecordInterface {

    
    int getRow();

    
    short getColumn();

    
    void setRow(int row);

    
    void setColumn(short col);

    void setXFIndex(short xf);

    short getXFIndex();
}
"
poi,3,org.apache.poi.hssf.util.PaneInformation,7,1,0,2,8,9,2,0,7,0.966666667,59,0.6,0,0.0,0.357142857,0,0,6.0,1,0.8571,0,"

package org.apache.poi.hssf.util;


public class PaneInformation
{
	
    public static final byte PANE_LOWER_RIGHT = (byte)0;
    
    public static final byte PANE_UPPER_RIGHT = (byte)1;
    
    public static final byte PANE_LOWER_LEFT = (byte)2;
    
    public static final byte PANE_UPPER_LEFT = (byte)3;
    
	private short x;
	private short y;
	private short topRow;
	private short leftColumn;
	private byte activePane;
	private boolean frozen = false;
	
	public PaneInformation(short x, short y, short top, short left, byte active, boolean frozen) {
		this.x = x;
		this.y = y;
		this.topRow = top;
		this.leftColumn = left;
		this.activePane = active;
		this.frozen = frozen;
	}


	
	public short getVerticalSplitPosition() {
	  return x;
	}
	
	
	public short getHorizontalSplitPosition() {
	  return y;
	}
	
	
	public short getHorizontalSplitTopRow() {
	  return topRow;
	}
	
	
	public short getVerticalSplitLeftColumn() {
	  return leftColumn;
	}
	
	
	public byte getActivePane() {
	  return activePane;
	}
	
	
	public boolean isFreezePane() {
		return frozen;
	}
}
"
poi,3,org.apache.poi.poifs.storage.SmallBlockTableWriter,6,1,0,7,22,3,1,6,6,0.75,111,1.0,2,0.0,0.333333333,0,0,16.83333333,1,0.8333,1,"

        

package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.poifs.filesystem.OPOIFSDocument;
import org.apache.poi.poifs.property.RootProperty;

import java.util.*;

import java.io.*;



public class SmallBlockTableWriter
    implements BlockWritable, BATManaged
{
    private BlockAllocationTableWriter _sbat;
    private List<SmallDocumentBlock>   _small_blocks;
    private int                        _big_block_count;
    private RootProperty               _root;

    
    public SmallBlockTableWriter(final POIFSBigBlockSize bigBlockSize,
                                 final List<OPOIFSDocument> documents,
                                 final RootProperty root)
    {
        _sbat         = new BlockAllocationTableWriter(bigBlockSize);
        _small_blocks = new ArrayList<SmallDocumentBlock>();
        _root         = root;

        for (OPOIFSDocument doc : documents)
        {
            SmallDocumentBlock[] blocks = doc.getSmallBlocks();

            if (blocks.length != 0)
            {
                doc.setStartBlock(_sbat.allocateSpace(blocks.length));
                for (int j = 0; j < blocks.length; j++)
                {
                    _small_blocks.add(blocks[ j ]);
                }
            } else {
            	doc.setStartBlock(POIFSConstants.END_OF_CHAIN);
            }
        }
        _sbat.simpleCreateBlocks();
        _root.setSize(_small_blocks.size());
        _big_block_count = SmallDocumentBlock.fill(bigBlockSize,_small_blocks);
    }

    
    
    public int getSBATBlockCount()
    {
	return (_big_block_count + 15) / 16;
    }

    

    public BlockAllocationTableWriter getSBAT()
    {
        return _sbat;
    }

    

    

    public int countBlocks()
    {
        return _big_block_count;
    }

    

    public void setStartBlock(int start_block)
    {
        _root.setStartBlock(start_block);
    }

    
    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        for (BlockWritable block : _small_blocks) {
            block.writeBlocks(stream);
        }
    }

    
}
"
poi,3,org.apache.poi.hpsf.Thumbnail,8,1,0,2,12,8,0,2,7,0.821428571,129,0.083333333,0,0.0,0.642857143,0,0,13.625,1,0.625,1,"

package org.apache.poi.hpsf;

import org.apache.poi.util.LittleEndian;

public final class Thumbnail {

    
    public static final int OFFSET_CFTAG = 4;

    
    public static final int OFFSET_CF = 8;

    
    public static final int OFFSET_WMFDATA = 20;

    
    public static final int CFTAG_WINDOWS = -1;

    
    public static final int CFTAG_MACINTOSH = -2;

    
    public static final int CFTAG_FMTID = -3;

    
    public static final int CFTAG_NODATA = 0;

    
    public static final int CF_METAFILEPICT = 3;

    
    public static final int CF_DIB = 8;

    
    public static final int CF_ENHMETAFILE = 14;

    
    public static final int CF_BITMAP = 2;

    
    private byte[] _thumbnailData = null;



    
    public Thumbnail()
    {
        super();
    }



    
    public Thumbnail(final byte[] thumbnailData)
    {
        this._thumbnailData = thumbnailData;
    }



    
    public byte[] getThumbnail()
    {
        return _thumbnailData;
    }



    
    public void setThumbnail(final byte[] thumbnail)
    {
        this._thumbnailData = thumbnail;
    }



    
    public long getClipboardFormatTag()
    {
        long clipboardFormatTag = LittleEndian.getInt(getThumbnail(),
                                                       OFFSET_CFTAG);
        return clipboardFormatTag;
    }



    
    public long getClipboardFormat() throws HPSFException
    {
        if (!(getClipboardFormatTag() == CFTAG_WINDOWS))
            throw new HPSFException(""Clipboard Format Tag of Thumbnail must "" +
                                    ""be CFTAG_WINDOWS."");

        return LittleEndian.getInt(getThumbnail(), OFFSET_CF);
    }



    
    public byte[] getThumbnailAsWMF() throws HPSFException
    {
        if (!(getClipboardFormatTag() == CFTAG_WINDOWS))
            throw new HPSFException(""Clipboard Format Tag of Thumbnail must "" +
                                    ""be CFTAG_WINDOWS."");
        if (!(getClipboardFormat() == CF_METAFILEPICT)) {
            throw new HPSFException(""Clipboard Format of Thumbnail must "" +
                                    ""be CF_METAFILEPICT."");
        }
        byte[] thumbnail = getThumbnail();
        int wmfImageLength = thumbnail.length - OFFSET_WMFDATA;
        byte[] wmfImage = new byte[wmfImageLength];
        System.arraycopy(thumbnail,
                         OFFSET_WMFDATA,
                         wmfImage,
                         0,
                         wmfImageLength);
        return wmfImage;
    }
}
"
poi,3,org.apache.poi.hssf.model.PolygonShape,5,2,0,17,48,6,1,17,2,0.916666667,439,0.666666667,2,0.555555556,0.55,1,1,86.2,4,1.4,1,"


package org.apache.poi.hssf.model;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.hssf.record.EscherAggregate;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.EndSubRecord;
import org.apache.poi.hssf.usermodel.HSSFShape;
import org.apache.poi.hssf.usermodel.HSSFPolygon;
import org.apache.poi.util.LittleEndian;

@Deprecated
public class PolygonShape
        extends AbstractShape
{
    public final static short       OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING = 30;

    private EscherContainerRecord spContainer;
    private ObjRecord objRecord;

    
    PolygonShape( HSSFPolygon hssfShape, int shapeId )
    {
        spContainer = createSpContainer( hssfShape, shapeId );
        objRecord = createObjRecord( hssfShape, shapeId );
    }

    
    private EscherContainerRecord createSpContainer( HSSFPolygon hssfShape, int shapeId )
    {
        HSSFShape shape = hssfShape;

        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherClientDataRecord clientData = new EscherClientDataRecord();

        spContainer.setRecordId( EscherContainerRecord.SP_CONTAINER );
        spContainer.setOptions( (short) 0x000F );
        sp.setRecordId( EscherSpRecord.RECORD_ID );
        sp.setOptions( (short) ( ( EscherAggregate.ST_NOT_PRIMATIVE << 4 ) | 0x2 ) );
        sp.setShapeId( shapeId );
        if (hssfShape.getParent() == null)
            sp.setFlags( EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        else
            sp.setFlags( EscherSpRecord.FLAG_CHILD | EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        opt.setRecordId( EscherOptRecord.RECORD_ID );
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TRANSFORM__ROTATION, false, false, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, false, false, hssfShape.getDrawAreaWidth()));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, false, false, hssfShape.getDrawAreaHeight()));
        opt.addEscherProperty(new EscherShapePathProperty(EscherProperties.GEOMETRY__SHAPEPATH, EscherShapePathProperty.COMPLEX));
        EscherArrayProperty verticesProp = new EscherArrayProperty(EscherProperties.GEOMETRY__VERTICES, false, new byte[0] );
        verticesProp.setNumberOfElementsInArray(hssfShape.getXPoints().length+1);
        verticesProp.setNumberOfElementsInMemory(hssfShape.getXPoints().length+1);
        verticesProp.setSizeOfElements(0xFFF0);
        for (int i = 0; i < hssfShape.getXPoints().length; i++)
        {
            byte[] data = new byte[4];
            LittleEndian.putShort(data, 0, (short)hssfShape.getXPoints()[i]);
            LittleEndian.putShort(data, 2, (short)hssfShape.getYPoints()[i]);
            verticesProp.setElement(i, data);
        }
        int point = hssfShape.getXPoints().length;
        byte[] data = new byte[4];
        LittleEndian.putShort(data, 0, (short)hssfShape.getXPoints()[0]);
        LittleEndian.putShort(data, 2, (short)hssfShape.getYPoints()[0]);
        verticesProp.setElement(point, data);
        opt.addEscherProperty(verticesProp);
        EscherArrayProperty segmentsProp = new EscherArrayProperty(EscherProperties.GEOMETRY__SEGMENTINFO, false, null );
        segmentsProp.setSizeOfElements(0x0002);
        segmentsProp.setNumberOfElementsInArray(hssfShape.getXPoints().length * 2 + 4);
        segmentsProp.setNumberOfElementsInMemory(hssfShape.getXPoints().length * 2 + 4);
        segmentsProp.setElement(0, new byte[] { (byte)0x00, (byte)0x40 } );
        segmentsProp.setElement(1, new byte[] { (byte)0x00, (byte)0xAC } );
        for (int i = 0; i < hssfShape.getXPoints().length; i++)
        {
            segmentsProp.setElement(2 + i * 2, new byte[] { (byte)0x01, (byte)0x00 } );
            segmentsProp.setElement(3 + i * 2, new byte[] { (byte)0x00, (byte)0xAC } );
        }
        segmentsProp.setElement(segmentsProp.getNumberOfElementsInArray() - 2, new byte[] { (byte)0x01, (byte)0x60 } );
        segmentsProp.setElement(segmentsProp.getNumberOfElementsInArray() - 1, new byte[] { (byte)0x00, (byte)0x80 } );
        opt.addEscherProperty(segmentsProp);
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__FILLOK, false, false, 0x00010001));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINESTARTARROWHEAD, false, false, 0x0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDARROWHEAD, false, false, 0x0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDCAPSTYLE, false, false, 0x0));

        addStandardOptions(shape, opt);

        EscherRecord anchor = createAnchor( shape.getAnchor() );
        clientData.setRecordId( EscherClientDataRecord.RECORD_ID );
        clientData.setOptions( (short) 0x0000 );

        spContainer.addChildRecord( sp );
        spContainer.addChildRecord( opt );
        spContainer.addChildRecord( anchor );
        spContainer.addChildRecord( clientData );

        return spContainer;
    }

    
    private ObjRecord createObjRecord( HSSFShape hssfShape, int shapeId )
    {
        HSSFShape shape = hssfShape;

        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType( OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING );
        c.setObjectId( getCmoObjectId(shapeId) );
        c.setLocked( true );
        c.setPrintable( true );
        c.setAutofill( true );
        c.setAutoline( true );
        EndSubRecord e = new EndSubRecord();

        obj.addSubRecord( c );
        obj.addSubRecord( e );

        return obj;
    }

    public EscherContainerRecord getSpContainer()
    {
        return spContainer;
    }

    public ObjRecord getObjRecord()
    {
        return objRecord;
    }

}
"
poi,3,org.apache.poi.hssf.record.DeltaRecord,11,2,0,6,21,43,2,4,9,0.9,102,0.333333333,0,0.55,0.257575758,1,4,8.0,2,0.9091,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class DeltaRecord extends StandardRecord {
    public final static short sid = 0x0010;
    public final static double DEFAULT_VALUE = 0.0010;   

    
    
    private double field_1_max_change;

    public DeltaRecord(double maxChange) {
        field_1_max_change = maxChange;
    }

    public DeltaRecord(RecordInputStream in) {
        field_1_max_change = in.readDouble();
    }

    
    public double getMaxChange() {
        return field_1_max_change;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DELTA]
"");
        buffer.append(""    .maxchange = "").append(getMaxChange()).append(""
"");
        buffer.append(""[/DELTA]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeDouble(getMaxChange());
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
        
        return this;
    }
}
"
poi,3,org.apache.poi.hpsf.MarkUnsupportedException,4,4,0,3,8,6,2,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class MarkUnsupportedException extends HPSFException
{

    
    public MarkUnsupportedException()
    {
        super();
    }


    
    public MarkUnsupportedException(final String msg)
    {
        super(msg);
    }


    
    public MarkUnsupportedException(final Throwable reason)
    {
        super(reason);
    }


   
    public MarkUnsupportedException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.util.ShortField,11,1,0,5,21,9,2,3,11,0.25,92,1.0,0,0.0,0.454545455,0,0,7.181818182,1,0.6364,0,"

        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class ShortField
    implements FixedField
{
    private short     _value;
    private final int _offset;

    

    public ShortField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(""Illegal offset: ""
                                                     + offset);
        }
        _offset = offset;
    }

    

    public ShortField(final int offset, final short value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public ShortField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ShortField(final int offset, final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public short get()
    {
        return _value;
    }

    

    public void set(final short value)
    {
        _value = value;
    }

    

    public void set(final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getShort(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readShort(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putShort(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,3,org.apache.poi.util.DrawingDump,2,1,0,3,15,1,0,3,2,2.0,56,0.0,0,0.0,0.5,0,0,27.0,1,0.5,0,"

        
package org.apache.poi.util;

import java.io.File;
import java.io.IOException;

import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;


public class DrawingDump
{
    public static void main( String[] args ) throws IOException
    {
        NPOIFSFileSystem fs      =
                new NPOIFSFileSystem(new File(args[0]));
        HSSFWorkbook wb = new HSSFWorkbook(fs);
        try {
            System.out.println( ""Drawing group:"" );
            wb.dumpDrawingGroupRecords(true);
    
            for (int sheetNum = 1; sheetNum <= wb.getNumberOfSheets(); sheetNum++)
            {
                System.out.println( ""Sheet "" + sheetNum + "":"" );
                HSSFSheet sheet = wb.getSheetAt(sheetNum - 1);
                sheet.dumpDrawingRecords(true);
            }
        } finally {
            wb.close();
        }
    }
}
"
poi,3,org.apache.poi.hpsf.HPSFException,5,3,4,5,7,4,5,0,5,0.5,29,1.0,0,0.944444444,0.6,0,0,4.6,1,0.2,0,"

package org.apache.poi.hpsf;


public class HPSFException extends Exception
{

    
    private Throwable reason;



    
    public HPSFException()
    {
        super();
    }



    
    public HPSFException(final String msg)
    {
        super(msg);
    }



    
    public HPSFException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }

}
"
poi,3,org.apache.poi.hssf.eventusermodel.AbortableHSSFListener,3,1,0,4,4,3,1,3,3,2.0,7,0.0,0,0.0,0.833333333,0,0,1.333333333,1,0.6667,1,"


package org.apache.poi.hssf.eventusermodel;

import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.eventusermodel.HSSFUserException;



public abstract class AbortableHSSFListener implements HSSFListener
{
    
	public void processRecord(Record record)
	{
	}

   
    public abstract short abortableProcessRecord(Record record) throws HSSFUserException;
}
"
poi,3,org.apache.poi.hssf.record.SelectionRecord,19,2,0,7,33,119,3,5,17,0.80952381,303,0.857142857,0,0.392857143,0.254385965,1,4,14.57894737,2,1.0,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.util.CellRangeAddress8Bit;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class SelectionRecord extends StandardRecord {
    public final static short sid = 0x001D;
    private byte        field_1_pane;
    private int         field_2_row_active_cell;
    private int         field_3_col_active_cell;
    private int         field_4_active_cell_ref_index;
    private CellRangeAddress8Bit[] field_6_refs;

    
    public SelectionRecord(int activeCellRow, int activeCellCol) {
        field_1_pane = 3; 
        field_2_row_active_cell = activeCellRow;
        field_3_col_active_cell = activeCellCol;
        field_4_active_cell_ref_index = 0;
        field_6_refs = new CellRangeAddress8Bit[] {
            new CellRangeAddress8Bit(activeCellRow, activeCellRow, activeCellCol, activeCellCol),
        };
    }

    public SelectionRecord(RecordInputStream in) {
        field_1_pane            = in.readByte();
        field_2_row_active_cell = in.readUShort();
        field_3_col_active_cell = in.readShort();
        field_4_active_cell_ref_index = in.readShort();
        int field_5_num_refs    = in.readUShort();

        field_6_refs = new CellRangeAddress8Bit[field_5_num_refs];
        for (int i = 0; i < field_6_refs.length; i++) {
            field_6_refs[i] = new CellRangeAddress8Bit(in);
        }
    }

    
    public void setPane(byte pane) {
        field_1_pane = pane;
    }

    
    public void setActiveCellRow(int row) {
        field_2_row_active_cell = row;
    }

    
    public void setActiveCellCol(short col) {
        field_3_col_active_cell = col;
    }

    
    public void setActiveCellRef(short ref) {
        field_4_active_cell_ref_index = ref;
    }

    
    public byte getPane() {
        return field_1_pane;
    }

    
    public int getActiveCellRow() {
        return field_2_row_active_cell;
    }

    
    public int getActiveCellCol() {
        return field_3_col_active_cell;
    }

    
    public int getActiveCellRef() {
        return field_4_active_cell_ref_index;
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();

        sb.append(""[SELECTION]
"");
        sb.append(""    .pane            = "").append(HexDump.byteToHex(getPane())).append(""
"");
        sb.append(""    .activecellrow   = "").append(HexDump.shortToHex(getActiveCellRow())).append(""
"");
        sb.append(""    .activecellcol   = "").append(HexDump.shortToHex(getActiveCellCol())).append(""
"");
        sb.append(""    .activecellref   = "").append(HexDump.shortToHex(getActiveCellRef())).append(""
"");
        sb.append(""    .numrefs         = "").append(HexDump.shortToHex(field_6_refs.length)).append(""
"");
        sb.append(""[/SELECTION]
"");
        return sb.toString();
    }
    protected int getDataSize() {
        return 9 
            + CellRangeAddress8Bit.getEncodedSize(field_6_refs.length);
    }
    public void serialize(LittleEndianOutput out) {
        out.writeByte(getPane());
        out.writeShort(getActiveCellRow());
        out.writeShort(getActiveCellCol());
        out.writeShort(getActiveCellRef());
        int nRefs = field_6_refs.length;
        out.writeShort(nRefs);
        for (int i = 0; i < field_6_refs.length; i++) {
            field_6_refs[i].serialize(out);
        }
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
        SelectionRecord rec = new SelectionRecord(field_2_row_active_cell, field_3_col_active_cell);
        rec.field_1_pane = field_1_pane;
        rec.field_4_active_cell_ref_index = field_4_active_cell_ref_index;
        rec.field_6_refs = field_6_refs;
        return rec;
    }
}
"
poi,3,org.apache.poi.hpsf.Variant,4,1,1,3,16,2,3,0,3,1.272727273,798,0.036363636,0,0.0,0.5,0,0,184.75,2,1.0,0,"

package org.apache.poi.hpsf;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class Variant
{

    
    public static final int VT_EMPTY = 0;

    
    public static final int VT_NULL = 1;

    
    public static final int VT_I2 = 2;

    
    public static final int VT_I4 = 3;

    
    public static final int VT_R4 = 4;

    
    public static final int VT_R8 = 5;

    
    public static final int VT_CY = 6;

    
    public static final int VT_DATE = 7;

    
    public static final int VT_BSTR = 8;

    
    public static final int VT_DISPATCH = 9;

    
    public static final int VT_ERROR = 10;

    
    public static final int VT_BOOL = 11;

    
    public static final int VT_VARIANT = 12;

    
    public static final int VT_UNKNOWN = 13;

    
    public static final int VT_DECIMAL = 14;

    
    public static final int VT_I1 = 16;

    
    public static final int VT_UI1 = 17;

    
    public static final int VT_UI2 = 18;

    
    public static final int VT_UI4 = 19;

    
    public static final int VT_I8 = 20;

    
    public static final int VT_UI8 = 21;

    
    public static final int VT_INT = 22;

    
    public static final int VT_UINT = 23;

    
    public static final int VT_VOID = 24;

    
    public static final int VT_HRESULT = 25;

    
    public static final int VT_PTR = 26;

    
    public static final int VT_SAFEARRAY = 27;

    
    public static final int VT_CARRAY = 28;

    
    public static final int VT_USERDEFINED = 29;

    
    public static final int VT_LPSTR = 30;

    
    public static final int VT_LPWSTR = 31;

    
    public static final int VT_FILETIME = 64;

    
    public static final int VT_BLOB = 65;

    
    public static final int VT_STREAM = 66;

    
    public static final int VT_STORAGE = 67;

    
    public static final int VT_STREAMED_OBJECT = 68;

    
    public static final int VT_STORED_OBJECT = 69;

    
    public static final int VT_BLOB_OBJECT = 70;

    
    public static final int VT_CF = 71;

    
    public static final int VT_CLSID = 72;

    
    public static final int VT_VERSIONED_STREAM = 0x0049;

    
    public static final int VT_VECTOR = 0x1000;

    
    public static final int VT_ARRAY = 0x2000;

    
    public static final int VT_BYREF = 0x4000;

    
    public static final int VT_RESERVED = 0x8000;

    
    public static final int VT_ILLEGAL = 0xFFFF;

    
    public static final int VT_ILLEGALMASKED = 0xFFF;

    
    public static final int VT_TYPEMASK = 0xFFF;



    
    private static Map<Long,String> numberToName;

    private static Map<Long,Integer> numberToLength;

    
    public static final Integer LENGTH_UNKNOWN = Integer.valueOf(-2);

    
    public static final Integer LENGTH_VARIABLE = Integer.valueOf(-1);

    
    public static final Integer LENGTH_0 = Integer.valueOf(0);

    
    public static final Integer LENGTH_2 = Integer.valueOf(2);

    
    public static final Integer LENGTH_4 = Integer.valueOf(4);

    
    public static final Integer LENGTH_8 = Integer.valueOf(8);



    static
    {
        
        Map<Long,String> tm1 = new HashMap<Long,String>();
        tm1.put(Long.valueOf(0), ""VT_EMPTY"");
        tm1.put(Long.valueOf(1), ""VT_NULL"");
        tm1.put(Long.valueOf(2), ""VT_I2"");
        tm1.put(Long.valueOf(3), ""VT_I4"");
        tm1.put(Long.valueOf(4), ""VT_R4"");
        tm1.put(Long.valueOf(5), ""VT_R8"");
        tm1.put(Long.valueOf(6), ""VT_CY"");
        tm1.put(Long.valueOf(7), ""VT_DATE"");
        tm1.put(Long.valueOf(8), ""VT_BSTR"");
        tm1.put(Long.valueOf(9), ""VT_DISPATCH"");
        tm1.put(Long.valueOf(10), ""VT_ERROR"");
        tm1.put(Long.valueOf(11), ""VT_BOOL"");
        tm1.put(Long.valueOf(12), ""VT_VARIANT"");
        tm1.put(Long.valueOf(13), ""VT_UNKNOWN"");
        tm1.put(Long.valueOf(14), ""VT_DECIMAL"");
        tm1.put(Long.valueOf(16), ""VT_I1"");
        tm1.put(Long.valueOf(17), ""VT_UI1"");
        tm1.put(Long.valueOf(18), ""VT_UI2"");
        tm1.put(Long.valueOf(19), ""VT_UI4"");
        tm1.put(Long.valueOf(20), ""VT_I8"");
        tm1.put(Long.valueOf(21), ""VT_UI8"");
        tm1.put(Long.valueOf(22), ""VT_INT"");
        tm1.put(Long.valueOf(23), ""VT_UINT"");
        tm1.put(Long.valueOf(24), ""VT_VOID"");
        tm1.put(Long.valueOf(25), ""VT_HRESULT"");
        tm1.put(Long.valueOf(26), ""VT_PTR"");
        tm1.put(Long.valueOf(27), ""VT_SAFEARRAY"");
        tm1.put(Long.valueOf(28), ""VT_CARRAY"");
        tm1.put(Long.valueOf(29), ""VT_USERDEFINED"");
        tm1.put(Long.valueOf(30), ""VT_LPSTR"");
        tm1.put(Long.valueOf(31), ""VT_LPWSTR"");
        tm1.put(Long.valueOf(64), ""VT_FILETIME"");
        tm1.put(Long.valueOf(65), ""VT_BLOB"");
        tm1.put(Long.valueOf(66), ""VT_STREAM"");
        tm1.put(Long.valueOf(67), ""VT_STORAGE"");
        tm1.put(Long.valueOf(68), ""VT_STREAMED_OBJECT"");
        tm1.put(Long.valueOf(69), ""VT_STORED_OBJECT"");
        tm1.put(Long.valueOf(70), ""VT_BLOB_OBJECT"");
        tm1.put(Long.valueOf(71), ""VT_CF"");
        tm1.put(Long.valueOf(72), ""VT_CLSID"");
        Map<Long,String> tm2 = new HashMap<Long,String>(tm1.size(), 1.0F);
        tm2.putAll(tm1);
        numberToName = Collections.unmodifiableMap(tm2);

        
        Map<Long,Integer> tm3 = new HashMap<Long,Integer>();
        tm3.put(Long.valueOf(0), LENGTH_0);
        tm3.put(Long.valueOf(1), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(2), LENGTH_2);
        tm3.put(Long.valueOf(3), LENGTH_4);
        tm3.put(Long.valueOf(4), LENGTH_4);
        tm3.put(Long.valueOf(5), LENGTH_8);
        tm3.put(Long.valueOf(6), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(7), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(8), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(9), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(10), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(11), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(12), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(13), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(14), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(16), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(17), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(18), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(19), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(20), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(21), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(22), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(23), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(24), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(25), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(26), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(27), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(28), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(29), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(30), LENGTH_VARIABLE);
        tm3.put(Long.valueOf(31), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(64), LENGTH_8);
        tm3.put(Long.valueOf(65), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(66), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(67), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(68), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(69), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(70), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(71), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(72), LENGTH_UNKNOWN);
        Map<Long,Integer> tm4 = new HashMap<Long,Integer>(tm1.size(), 1.0F);
        tm4.putAll(tm3);
        numberToLength = Collections.unmodifiableMap(tm4);
    }



    
    public static String getVariantName(final long variantType)
    {
        final String name = numberToName.get(Long.valueOf(variantType));
        return name != null ? name : ""unknown variant type"";
    }

    
    public static int getVariantLength(final long variantType)
    {
        final Long key = Long.valueOf((int) variantType);
        final Integer length = numberToLength.get(key);
        if (length == null)
            return -2;
        return length.intValue();
    }

}
"
poi,3,org.apache.poi.hssf.record.RowRecord,37,2,0,11,53,394,5,6,34,0.883333333,543,0.866666667,5,0.244444444,0.218253968,1,4,13.27027027,4,1.1351,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class RowRecord extends StandardRecord {
    public final static short sid = 0x0208;

    public static final int ENCODED_SIZE = 20;
    
    private static final int OPTION_BITS_ALWAYS_SET = 0x0100;
    

    private int field_1_row_number;
    private int field_2_first_col;
    private int field_3_last_col; 
    private short field_4_height;
    private short field_5_optimize; 

    
    private short field_6_reserved;
    
    private int field_7_option_flags;
    private static final BitField          outlineLevel  = BitFieldFactory.getInstance(0x07);
    
    private static final BitField          colapsed      = BitFieldFactory.getInstance(0x10);
    private static final BitField          zeroHeight    = BitFieldFactory.getInstance(0x20);
    private static final BitField          badFontHeight = BitFieldFactory.getInstance(0x40);
    private static final BitField          formatted     = BitFieldFactory.getInstance(0x80);
    
    
    private int field_8_option_flags;   
    private static final BitField          xfIndex       = BitFieldFactory.getInstance(0xFFF);
    private static final BitField          topBorder     = BitFieldFactory.getInstance(0x1000);
    private static final BitField          bottomBorder  = BitFieldFactory.getInstance(0x2000);
    private static final BitField          phoeneticGuide  = BitFieldFactory.getInstance(0x4000);
    

    public RowRecord(int rowNumber) {
    	if(rowNumber < 0) {
    		throw new IllegalArgumentException(""Invalid row number ("" + rowNumber + "")"");
    	}
        field_1_row_number = rowNumber;
        field_4_height = (short)0xFF;
        field_5_optimize = ( short ) 0;
        field_6_reserved = ( short ) 0;
        field_7_option_flags = OPTION_BITS_ALWAYS_SET; 

        field_8_option_flags = ( short ) 0xf;
        setEmpty();
    }

    public RowRecord(RecordInputStream in) {
        field_1_row_number   = in.readUShort();
    	if(field_1_row_number < 0) {
    		throw new IllegalArgumentException(""Invalid row number "" + field_1_row_number + "" found in InputStream"");
    	}
        field_2_first_col    = in.readShort();
        field_3_last_col     = in.readShort();
        field_4_height       = in.readShort();
        field_5_optimize     = in.readShort();
        field_6_reserved     = in.readShort();
        field_7_option_flags = in.readShort();
        field_8_option_flags = in.readShort();
    }

    
    public void setEmpty() {
        field_2_first_col = 0;
        field_3_last_col = 0;
    }
    public boolean isEmpty() {
        return (field_2_first_col | field_3_last_col) == 0;
    }
    
    
    public void setRowNumber(int row) {
        field_1_row_number = row;
    }

    
    public void setFirstCol(int col) {
        field_2_first_col = col;
    }

    
    public void setLastCol(int col) {
        field_3_last_col = col;
    }

    
    public void setHeight(short height) {
        field_4_height = height;
    }

    
    public void setOptimize(short optimize) {
        field_5_optimize = optimize;
    }

    

    
    public void setOutlineLevel(short ol) {
        field_7_option_flags = outlineLevel.setValue(field_7_option_flags, ol);
    }

    
    public void setColapsed(boolean c) {
        field_7_option_flags = colapsed.setBoolean(field_7_option_flags, c);
    }

    
    public void setZeroHeight(boolean z) {
        field_7_option_flags = zeroHeight.setBoolean(field_7_option_flags, z);
    }

    
    public void setBadFontHeight(boolean f) {
        field_7_option_flags = badFontHeight.setBoolean(field_7_option_flags, f);
    }

    
    public void setFormatted(boolean f) {
        field_7_option_flags = formatted.setBoolean(field_7_option_flags, f);
    }

    

    
    public void setXFIndex(short index) {
    	field_8_option_flags = xfIndex.setValue(field_8_option_flags, index);
    }

    
    public void setTopBorder(boolean f) {
    	field_8_option_flags = topBorder.setBoolean(field_8_option_flags, f);
    }
    
    
    public void setBottomBorder(boolean f) {
    	field_8_option_flags = bottomBorder.setBoolean(field_8_option_flags, f);
    }
    
    
    public void setPhoeneticGuide(boolean f) {
    	field_8_option_flags = phoeneticGuide.setBoolean(field_8_option_flags, f);
    }
    
    
    public int getRowNumber() {
        return field_1_row_number;
    }

    
    public int getFirstCol() {
        return field_2_first_col;
    }

    
    public int getLastCol() {
        return field_3_last_col;
    }

    
    public short getHeight() {
        return field_4_height;
    }

    
    public short getOptimize() {
        return field_5_optimize;
    }

    
    public short getOptionFlags() {
        return (short)field_7_option_flags;
    }

    

    
    public short getOutlineLevel() {
        return (short)outlineLevel.getValue(field_7_option_flags);
    }

    
    public boolean getColapsed() {
        return (colapsed.isSet(field_7_option_flags));
    }

    
    public boolean getZeroHeight() {
        return zeroHeight.isSet(field_7_option_flags);
    }

    
    public boolean getBadFontHeight() {
        return badFontHeight.isSet(field_7_option_flags);
    }

    
    public boolean getFormatted() {
        return formatted.isSet(field_7_option_flags);
    }

    

    
    public short getOptionFlags2() {
        return (short)field_8_option_flags;
    }
    
    
    public short getXFIndex() {
    	return xfIndex.getShortValue((short)field_8_option_flags);
    }

    
    public boolean getTopBorder() {
    	return topBorder.isSet(field_8_option_flags);
    }

    
    public boolean getBottomBorder() {
    	return bottomBorder.isSet(field_8_option_flags);
    }

    
    public boolean getPhoeneticGuide() {
    	return phoeneticGuide.isSet(field_8_option_flags);
    }
    
    public String toString() {
        StringBuffer sb = new StringBuffer();

        sb.append(""[ROW]
"");
        sb.append(""    .rownumber      = "").append(Integer.toHexString(getRowNumber()))
                .append(""
"");
        sb.append(""    .firstcol       = "").append(HexDump.shortToHex(getFirstCol())).append(""
"");
        sb.append(""    .lastcol        = "").append(HexDump.shortToHex(getLastCol())).append(""
"");
        sb.append(""    .height         = "").append(HexDump.shortToHex(getHeight())).append(""
"");
        sb.append(""    .optimize       = "").append(HexDump.shortToHex(getOptimize())).append(""
"");
        sb.append(""    .reserved       = "").append(HexDump.shortToHex(field_6_reserved)).append(""
"");
        sb.append(""    .optionflags    = "").append(HexDump.shortToHex(getOptionFlags())).append(""
"");
        sb.append(""        .outlinelvl = "").append(Integer.toHexString(getOutlineLevel())).append(""
"");
        sb.append(""        .colapsed   = "").append(getColapsed()).append(""
"");
        sb.append(""        .zeroheight = "").append(getZeroHeight()).append(""
"");
        sb.append(""        .badfontheig= "").append(getBadFontHeight()).append(""
"");
        sb.append(""        .formatted  = "").append(getFormatted()).append(""
"");
        sb.append(""    .optionsflags2  = "").append(HexDump.shortToHex(getOptionFlags2())).append(""
"");
        sb.append(""        .xfindex       = "").append(Integer.toHexString(getXFIndex())).append(""
"");
        sb.append(""        .topBorder     = "").append(getTopBorder()).append(""
"");
        sb.append(""        .bottomBorder  = "").append(getBottomBorder()).append(""
"");
        sb.append(""        .phoeneticGuide= "").append(getPhoeneticGuide()).append(""
"");
        sb.append(""[/ROW]
"");
        return sb.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getRowNumber());
        out.writeShort(getFirstCol() == -1 ? (short)0 : getFirstCol());
        out.writeShort(getLastCol() == -1 ? (short)0 : getLastCol());
        out.writeShort(getHeight());
        out.writeShort(getOptimize());
        out.writeShort(field_6_reserved);
        out.writeShort(getOptionFlags());
        out.writeShort(getOptionFlags2());
    }

    protected int getDataSize() {
        return ENCODED_SIZE - 4;
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
      RowRecord rec = new RowRecord(field_1_row_number);
      rec.field_2_first_col = field_2_first_col;
      rec.field_3_last_col = field_3_last_col;
      rec.field_4_height = field_4_height;
      rec.field_5_optimize = field_5_optimize;
      rec.field_6_reserved = field_6_reserved;
      rec.field_7_option_flags = field_7_option_flags;
      rec.field_8_option_flags = field_8_option_flags;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.CalcCountRecord,11,2,0,6,20,43,2,4,9,0.8,102,0.5,0,0.55,0.309090909,1,4,8.090909091,2,0.9091,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class CalcCountRecord
    extends StandardRecord
{
    public final static short sid = 0xC;
    private short             field_1_iterations;

    public CalcCountRecord()
    {
    }

    public CalcCountRecord(RecordInputStream in)
    {
        field_1_iterations = in.readShort();
    }

    

    public void setIterations(short iterations)
    {
        field_1_iterations = iterations;
    }

    

    public short getIterations()
    {
        return field_1_iterations;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CALCCOUNT]
"");
        buffer.append(""    .iterations     = "")
            .append(Integer.toHexString(getIterations())).append(""
"");
        buffer.append(""[/CALCCOUNT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getIterations());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      CalcCountRecord rec = new CalcCountRecord();
      rec.field_1_iterations = field_1_iterations;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.DimensionsRecord,17,2,0,6,28,90,2,4,15,0.78125,232,0.833333333,0,0.423076923,0.305882353,1,4,12.29411765,2,0.9412,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class DimensionsRecord
    extends StandardRecord
{
    public final static short sid = 0x200;
    private int               field_1_first_row;
    private int               field_2_last_row;   
    private short             field_3_first_col;
    private short             field_4_last_col;
    private short             field_5_zero;       

    public DimensionsRecord()
    {
    }

    public DimensionsRecord(RecordInputStream in)
    {
        field_1_first_row = in.readInt();
        field_2_last_row  = in.readInt();
        field_3_first_col = in.readShort();
        field_4_last_col  = in.readShort();
        field_5_zero      = in.readShort();
    }

    

    public void setFirstRow(int row)
    {
        field_1_first_row = row;
    }

    

    public void setLastRow(int row)
    {
        field_2_last_row = row;
    }

    

    public void setFirstCol(short col)
    {
        field_3_first_col = col;
    }

    

    public void setLastCol(short col)
    {
        field_4_last_col = col;
    }

    

    public int getFirstRow()
    {
        return field_1_first_row;
    }

    

    public int getLastRow()
    {
        return field_2_last_row;
    }

    

    public short getFirstCol()
    {
        return field_3_first_col;
    }

    

    public short getLastCol()
    {
        return field_4_last_col;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DIMENSIONS]
"");
        buffer.append(""    .firstrow       = "")
            .append(Integer.toHexString(getFirstRow())).append(""
"");
        buffer.append(""    .lastrow        = "")
            .append(Integer.toHexString(getLastRow())).append(""
"");
        buffer.append(""    .firstcol       = "")
            .append(Integer.toHexString(getFirstCol())).append(""
"");
        buffer.append(""    .lastcol        = "")
            .append(Integer.toHexString(getLastCol())).append(""
"");
        buffer.append(""    .zero           = "")
            .append(Integer.toHexString(field_5_zero)).append(""
"");
        buffer.append(""[/DIMENSIONS]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeInt(getFirstRow());
        out.writeInt(getLastRow());
        out.writeShort(getFirstCol());
        out.writeShort(getLastCol());
        out.writeShort(( short ) 0);
    }

    protected int getDataSize() {
        return 14;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      DimensionsRecord rec = new DimensionsRecord();
      rec.field_1_first_row = field_1_first_row;
      rec.field_2_last_row = field_2_last_row;
      rec.field_3_first_col = field_3_first_col;
      rec.field_4_last_col = field_4_last_col;
      rec.field_5_zero = field_5_zero;
      return rec;
    }
}
"
poi,3,org.apache.poi.hpsf.MutablePropertySet,11,2,1,15,51,25,2,13,11,0.6,305,1.0,0,0.64,0.227272727,1,5,26.63636364,2,0.9091,1,"

package org.apache.poi.hpsf;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.LinkedList;

import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.Entry;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;


public class MutablePropertySet extends PropertySet
{

    
    public MutablePropertySet()
    {
        
        byteOrder = LittleEndian.getUShort(BYTE_ORDER_ASSERTION);

        
        format = LittleEndian.getUShort(FORMAT_ASSERTION);

        
        osVersion = (OS_WIN32 << 16) | 0x0A04;

        
        classID = new ClassID();

        
        sections = new LinkedList<Section>();
        sections.add(new MutableSection());
    }



    
    public MutablePropertySet(final PropertySet ps)
    {
        byteOrder = ps.getByteOrder();
        format = ps.getFormat();
        osVersion = ps.getOSVersion();
        setClassID(ps.getClassID());
        clearSections();
        if (sections == null)
            sections = new LinkedList<Section>();
        for (final Section section : ps.getSections())
        {
            final MutableSection s = new MutableSection(section);
            addSection(s);
        }
    }



    
    private final int OFFSET_HEADER =
        BYTE_ORDER_ASSERTION.length + 
        FORMAT_ASSERTION.length +     
        LittleEndianConsts.INT_SIZE + 
        ClassID.LENGTH +              
        LittleEndianConsts.INT_SIZE;  



    
    public void setByteOrder(final int byteOrder)
    {
        this.byteOrder = byteOrder;
    }



    
    public void setFormat(final int format)
    {
        this.format = format;
    }



    
    public void setOSVersion(final int osVersion)
    {
        this.osVersion = osVersion;
    }



    
    public void setClassID(final ClassID classID)
    {
        this.classID = classID;
    }



    
    public void clearSections()
    {
        sections = null;
    }



    
    public void addSection(final Section section)
    {
        if (sections == null)
            sections = new LinkedList<Section>();
        sections.add(section);
    }



    
    public void write(final OutputStream out)
        throws WritingNotSupportedException, IOException
    {
        
        final int nrSections = sections.size();
        int length = 0;

        
        length += TypeWriter.writeToStream(out, (short) getByteOrder());
        length += TypeWriter.writeToStream(out, (short) getFormat());
        length += TypeWriter.writeToStream(out, getOSVersion());
        length += TypeWriter.writeToStream(out, getClassID());
        length += TypeWriter.writeToStream(out, nrSections);
        int offset = OFFSET_HEADER;

        
        offset += nrSections * (ClassID.LENGTH + LittleEndian.INT_SIZE);
        final int sectionsBegin = offset;
        for (final Section section : sections)
        {
            final MutableSection s = (MutableSection)section;
            final ClassID formatID = s.getFormatID();
            if (formatID == null)
                throw new NoFormatIDException();
            length += TypeWriter.writeToStream(out, s.getFormatID());
            length += TypeWriter.writeUIntToStream(out, offset);
            try
            {
                offset += s.getSize();
            }
            catch (HPSFRuntimeException ex)
            {
                final Throwable cause = ex.getReason();
                if (cause instanceof UnsupportedEncodingException) {
                    throw new IllegalPropertySetDataException(cause);
                }
                throw ex;
            }
        }

        
        offset = sectionsBegin;
        for (final Section section : sections)
        {
            final MutableSection s = (MutableSection)section;
            offset += s.write(out);
        }
        
        
        out.close();
    }



    
    public InputStream toInputStream()
        throws IOException, WritingNotSupportedException
    {
        final ByteArrayOutputStream psStream = new ByteArrayOutputStream();
        try {
            write(psStream);
        } finally {
            psStream.close();
        }
        final byte[] streamData = psStream.toByteArray();
        return new ByteArrayInputStream(streamData);
    }

    
    public void write(final DirectoryEntry dir, final String name)
    throws WritingNotSupportedException, IOException
    {
        
        try
        {
            final Entry e = dir.getEntry(name);
            e.delete();
        }
        catch (FileNotFoundException ex)
        {
            
        }
        
        dir.createDocument(name, toInputStream());
    }

}
"
poi,3,org.apache.poi.hssf.record.RecordFactory,7,1,0,20,59,9,4,16,5,0.722222222,754,1.0,0,0.0,0.166666667,0,0,106.2857143,8,2.0,13,"

package org.apache.poi.hssf.record;

import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.hssf.record.chart.BeginRecord;
import org.apache.poi.hssf.record.chart.CatLabRecord;
import org.apache.poi.hssf.record.chart.ChartEndBlockRecord;
import org.apache.poi.hssf.record.chart.ChartEndObjectRecord;
import org.apache.poi.hssf.record.chart.ChartFRTInfoRecord;
import org.apache.poi.hssf.record.chart.ChartRecord;
import org.apache.poi.hssf.record.chart.ChartStartBlockRecord;
import org.apache.poi.hssf.record.chart.ChartStartObjectRecord;
import org.apache.poi.hssf.record.chart.ChartTitleFormatRecord;
import org.apache.poi.hssf.record.chart.DataFormatRecord;
import org.apache.poi.hssf.record.chart.EndRecord;
import org.apache.poi.hssf.record.chart.LegendRecord;
import org.apache.poi.hssf.record.chart.LinkedDataRecord;
import org.apache.poi.hssf.record.chart.SeriesRecord;
import org.apache.poi.hssf.record.chart.SeriesTextRecord;
import org.apache.poi.hssf.record.chart.SeriesToChartGroupRecord;
import org.apache.poi.hssf.record.chart.ValueRangeRecord;
import org.apache.poi.hssf.record.pivottable.DataItemRecord;
import org.apache.poi.hssf.record.pivottable.ExtendedPivotTableViewFieldsRecord;
import org.apache.poi.hssf.record.pivottable.PageItemRecord;
import org.apache.poi.hssf.record.pivottable.StreamIDRecord;
import org.apache.poi.hssf.record.pivottable.ViewDefinitionRecord;
import org.apache.poi.hssf.record.pivottable.ViewFieldsRecord;
import org.apache.poi.hssf.record.pivottable.ViewSourceRecord;


public final class RecordFactory {
    private static final int NUM_RECORDS = 512;

    private interface I_RecordCreator {
        Record create(RecordInputStream in);

        Class<? extends Record> getRecordClass();
    }
    private static final class ReflectionConstructorRecordCreator implements I_RecordCreator {

        private final Constructor<? extends Record> _c;
        public ReflectionConstructorRecordCreator(Constructor<? extends Record> c) {
            _c = c;
        }
        public Record create(RecordInputStream in) {
            Object[] args = { in, };
            try {
                return _c.newInstance(args);
            } catch (IllegalArgumentException e) {
                throw new RuntimeException(e);
            } catch (InstantiationException e) {
                throw new RuntimeException(e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (InvocationTargetException e) {
                Throwable t = e.getTargetException();
                if (t instanceof RecordFormatException) {
                    throw (RecordFormatException)t;
                } else if (t instanceof EncryptedDocumentException) {
                    throw (EncryptedDocumentException)t;
                } else {
                    throw new RecordFormatException(""Unable to construct record instance"" , t);
                }
            }
        }
        public Class<? extends Record> getRecordClass() {
            return _c.getDeclaringClass();
        }
    }
    
    private static final class ReflectionMethodRecordCreator implements I_RecordCreator {
        private final Method _m;
        public ReflectionMethodRecordCreator(Method m) {
            _m = m;
        }
        public Record create(RecordInputStream in) {
            Object[] args = { in, };
            try {
                return (Record) _m.invoke(null, args);
            } catch (IllegalArgumentException e) {
                throw new RuntimeException(e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (InvocationTargetException e) {
                throw new RecordFormatException(""Unable to construct record instance"" , e.getTargetException());
            }
        }
        @SuppressWarnings(""unchecked"")
        public Class<? extends Record> getRecordClass() {
            return (Class<? extends Record>) _m.getDeclaringClass();
        }
    }

    private static final Class<?>[] CONSTRUCTOR_ARGS = { RecordInputStream.class, };

    
    @SuppressWarnings(""unchecked"")
    private static final Class<? extends Record>[] recordClasses = new Class[] {
        ArrayRecord.class,
        AutoFilterInfoRecord.class,
        BackupRecord.class,
        BlankRecord.class,
        BOFRecord.class,
        BookBoolRecord.class,
        BoolErrRecord.class,
        BottomMarginRecord.class,
        BoundSheetRecord.class,
        CalcCountRecord.class,
        CalcModeRecord.class,
        CFHeaderRecord.class,
        CFHeader12Record.class,
        CFRuleRecord.class,
        CFRule12Record.class,
        ChartRecord.class,
        ChartTitleFormatRecord.class,
        CodepageRecord.class,
        ColumnInfoRecord.class,
        ContinueRecord.class,
        CountryRecord.class,
        CRNCountRecord.class,
        CRNRecord.class,
        DateWindow1904Record.class,
        DBCellRecord.class,
        DConRefRecord.class,
        DefaultColWidthRecord.class,
        DefaultRowHeightRecord.class,
        DeltaRecord.class,
        DimensionsRecord.class,
        DrawingGroupRecord.class,
        DrawingRecord.class,
        DrawingSelectionRecord.class,
        DSFRecord.class,
        DVALRecord.class,
        DVRecord.class,
        EOFRecord.class,
        ExtendedFormatRecord.class,
        ExternalNameRecord.class,
        ExternSheetRecord.class,
        ExtSSTRecord.class,
        FeatRecord.class,
        FeatHdrRecord.class,
        FilePassRecord.class,
        FileSharingRecord.class,
        FnGroupCountRecord.class,
        FontRecord.class,
        FooterRecord.class,
        FormatRecord.class,
        FormulaRecord.class,
        GridsetRecord.class,
        GutsRecord.class,
        HCenterRecord.class,
        HeaderRecord.class,
        HeaderFooterRecord.class,
        HideObjRecord.class,
        HorizontalPageBreakRecord.class,
        HyperlinkRecord.class,
        IndexRecord.class,
        InterfaceEndRecord.class,
        InterfaceHdrRecord.class,
        IterationRecord.class,
        LabelRecord.class,
        LabelSSTRecord.class,
        LeftMarginRecord.class,
        LegendRecord.class,
        MergeCellsRecord.class,
        MMSRecord.class,
        MulBlankRecord.class,
        MulRKRecord.class,
        NameRecord.class,
        NameCommentRecord.class,
        NoteRecord.class,
        NumberRecord.class,
        ObjectProtectRecord.class,
        ObjRecord.class,
        PaletteRecord.class,
        PaneRecord.class,
        PasswordRecord.class,
        PasswordRev4Record.class,
        PrecisionRecord.class,
        PrintGridlinesRecord.class,
        PrintHeadersRecord.class,
        PrintSetupRecord.class,
        ProtectionRev4Record.class,
        ProtectRecord.class,
        RecalcIdRecord.class,
        RefModeRecord.class,
        RefreshAllRecord.class,
        RightMarginRecord.class,
        RKRecord.class,
        RowRecord.class,
        SaveRecalcRecord.class,
        ScenarioProtectRecord.class,
        SelectionRecord.class,
        SeriesRecord.class,
        SeriesTextRecord.class,
        SharedFormulaRecord.class,
        SSTRecord.class,
        StringRecord.class,
        StyleRecord.class,
        SupBookRecord.class,
        TabIdRecord.class,
        TableRecord.class,
        TableStylesRecord.class,
        TextObjectRecord.class,
        TopMarginRecord.class,
        UncalcedRecord.class,
        UseSelFSRecord.class,
        UserSViewBegin.class,
        UserSViewEnd.class,
        ValueRangeRecord.class,
        VCenterRecord.class,
        VerticalPageBreakRecord.class,
        WindowOneRecord.class,
        WindowProtectRecord.class,
        WindowTwoRecord.class,
        WriteAccessRecord.class,
        WriteProtectRecord.class,
        WSBoolRecord.class,

        
        BeginRecord.class,
        ChartFRTInfoRecord.class,
        ChartStartBlockRecord.class,
        ChartEndBlockRecord.class,
        
        ChartStartObjectRecord.class,
        ChartEndObjectRecord.class,
        CatLabRecord.class,
        DataFormatRecord.class,
        EndRecord.class,
        LinkedDataRecord.class,
        SeriesToChartGroupRecord.class,

        
        DataItemRecord.class,
        ExtendedPivotTableViewFieldsRecord.class,
        PageItemRecord.class,
        StreamIDRecord.class,
        ViewDefinitionRecord.class,
        ViewFieldsRecord.class,
        ViewSourceRecord.class,
    };

    
    private static final Map<Integer, I_RecordCreator> _recordCreatorsById  = recordsToMap(recordClasses);

    private static short[] _allKnownRecordSIDs;

    
    public static Class<? extends Record> getRecordClass(int sid) {
        I_RecordCreator rc = _recordCreatorsById.get(Integer.valueOf(sid));
        if (rc == null) {
            return null;
        }
        return rc.getRecordClass();
    }
    
    public static Record [] createRecord(RecordInputStream in) {
        Record record = createSingleRecord(in);
        if (record instanceof DBCellRecord) {
            
            return new Record[] { null, };
        }
        if (record instanceof RKRecord) {
            return new Record[] { convertToNumberRecord((RKRecord) record), };
        }
        if (record instanceof MulRKRecord) {
            return convertRKRecords((MulRKRecord)record);
        }
        return new Record[] { record, };
    }

    public static Record createSingleRecord(RecordInputStream in) {
        I_RecordCreator constructor = _recordCreatorsById.get(Integer.valueOf(in.getSid()));

        if (constructor == null) {
            return new UnknownRecord(in);
        }

        return constructor.create(in);
    }

    
    public static NumberRecord convertToNumberRecord(RKRecord rk) {
        NumberRecord num = new NumberRecord();

        num.setColumn(rk.getColumn());
        num.setRow(rk.getRow());
        num.setXFIndex(rk.getXFIndex());
        num.setValue(rk.getRKNumber());
        return num;
    }

    
    public static NumberRecord[] convertRKRecords(MulRKRecord mrk) {
        NumberRecord[] mulRecs = new NumberRecord[mrk.getNumColumns()];
        for (int k = 0; k < mrk.getNumColumns(); k++) {
            NumberRecord nr = new NumberRecord();

            nr.setColumn((short) (k + mrk.getFirstColumn()));
            nr.setRow(mrk.getRow());
            nr.setXFIndex(mrk.getXFAt(k));
            nr.setValue(mrk.getRKNumberAt(k));
            mulRecs[k] = nr;
        }
        return mulRecs;
    }

    
    public static BlankRecord[] convertBlankRecords(MulBlankRecord mbk) {
        BlankRecord[] mulRecs = new BlankRecord[mbk.getNumColumns()];
        for (int k = 0; k < mbk.getNumColumns(); k++) {
            BlankRecord br = new BlankRecord();

            br.setColumn((short) (k + mbk.getFirstColumn()));
            br.setRow(mbk.getRow());
            br.setXFIndex(mbk.getXFAt(k));
            mulRecs[k] = br;
        }
        return mulRecs;
    }

    
    public static short[] getAllKnownRecordSIDs() {
        if (_allKnownRecordSIDs == null) {
            short[] results = new short[ _recordCreatorsById.size() ];
            int i = 0;

            for (Iterator<Integer> iterator = _recordCreatorsById.keySet().iterator(); iterator.hasNext(); ) {
                Integer sid = iterator.next();

                results[i++] = sid.shortValue();
            }
            Arrays.sort(results);
            _allKnownRecordSIDs = results;
        }

        return _allKnownRecordSIDs.clone();
    }

    
    private static Map<Integer, I_RecordCreator> recordsToMap(Class<? extends Record> [] records) {
        Map<Integer, I_RecordCreator> result = new HashMap<Integer, I_RecordCreator>();
        Set<Class<?>> uniqueRecClasses = new HashSet<Class<?>>(records.length * 3 / 2);

        for (int i = 0; i < records.length; i++) {

            Class<? extends Record> recClass = records[ i ];
            if(!Record.class.isAssignableFrom(recClass)) {
                throw new RuntimeException(""Invalid record sub-class ("" + recClass.getName() + "")"");
            }
            if(Modifier.isAbstract(recClass.getModifiers())) {
                throw new RuntimeException(""Invalid record class ("" + recClass.getName() + "") - must not be abstract"");
            }
            if(!uniqueRecClasses.add(recClass)) {
                throw new RuntimeException(""duplicate record class ("" + recClass.getName() + "")"");
            }

            int sid;
            try {
                sid = recClass.getField(""sid"").getShort(null);
            } catch (Exception illegalArgumentException) {
                throw new RecordFormatException(
                        ""Unable to determine record types"");
            }
            Integer key = Integer.valueOf(sid);
            if (result.containsKey(key)) {
                Class<?> prevClass = result.get(key).getRecordClass();
                throw new RuntimeException(""duplicate record sid 0x"" + Integer.toHexString(sid).toUpperCase()
                        + "" for classes ("" + recClass.getName() + "") and ("" + prevClass.getName() + "")"");
            }
            result.put(key, getRecordCreator(recClass));
        }
        
        return result;
    }

    private static I_RecordCreator getRecordCreator(Class<? extends Record> recClass) {
        try {
            Constructor<? extends Record> constructor;
            constructor = recClass.getConstructor(CONSTRUCTOR_ARGS);
            return new ReflectionConstructorRecordCreator(constructor);
        } catch (NoSuchMethodException e) {
            
        }
        try {
            Method m = recClass.getDeclaredMethod(""create"", CONSTRUCTOR_ARGS);
            return new ReflectionMethodRecordCreator(m);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(""Failed to find constructor or create method for ("" + recClass.getName() + "")."");
        }
    }
    
    public static List<Record> createRecords(InputStream in) throws RecordFormatException {

        List<Record> records = new ArrayList<Record>(NUM_RECORDS);

        RecordFactoryInputStream recStream = new RecordFactoryInputStream(in, true);

        Record record;
        while ((record = recStream.nextRecord())!=null) {
            records.add(record);
        }

        return records;
    }
}
"
poi,3,org.apache.poi.poifs.filesystem.BATManaged,2,1,0,5,2,1,5,0,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.filesystem;



public interface BATManaged
{

    

    public int countBlocks();

    

    public void setStartBlock(final int index);
}   

"
poi,3,org.apache.poi.poifs.filesystem.DocumentEntry,1,1,0,8,1,0,7,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.filesystem;



public interface DocumentEntry
    extends Entry
{

    

    public int getSize();
}   

"
poi,3,org.apache.poi.hssf.record.aggregates.ValueRecordsAggregate,17,2,0,11,42,108,3,9,15,0.796875,514,0.0,1,0.407407407,0.243697479,1,3,29.0,14,3.3529,4,"

package org.apache.poi.hssf.record.aggregates;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.hssf.model.RecordStream;
import org.apache.poi.hssf.record.BlankRecord;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.FormulaRecord;
import org.apache.poi.hssf.record.MulBlankRecord;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordBase;
import org.apache.poi.hssf.record.StringRecord;
import org.apache.poi.hssf.record.aggregates.RecordAggregate.RecordVisitor;
import org.apache.poi.ss.formula.FormulaShifter;
import org.apache.poi.ss.formula.ptg.Ptg;


public final class ValueRecordsAggregate implements Iterable<CellValueRecordInterface> {
	private static final int MAX_ROW_INDEX = 0XFFFF;
	private static final int INDEX_NOT_SET = -1;
	private int firstcell = INDEX_NOT_SET;
	private int lastcell  = INDEX_NOT_SET;
	private CellValueRecordInterface[][] records;

	

	public ValueRecordsAggregate() {
		this(INDEX_NOT_SET, INDEX_NOT_SET, new CellValueRecordInterface[30][]); 
	}
	private ValueRecordsAggregate(int firstCellIx, int lastCellIx, CellValueRecordInterface[][] pRecords) {
		firstcell = firstCellIx;
		lastcell = lastCellIx;
		records = pRecords;
	}

	public void insertCell(CellValueRecordInterface cell) {
		short column = cell.getColumn();
		int row = cell.getRow();
		if (row >= records.length) {
			CellValueRecordInterface[][] oldRecords = records;
			int newSize = oldRecords.length * 2;
			if (newSize < row + 1)
				newSize = row + 1;
			records = new CellValueRecordInterface[newSize][];
			System.arraycopy(oldRecords, 0, records, 0, oldRecords.length);
		}
		CellValueRecordInterface[] rowCells = records[row];
		if (rowCells == null) {
			int newSize = column + 1;
			if (newSize < 10)
				newSize = 10;
			rowCells = new CellValueRecordInterface[newSize];
			records[row] = rowCells;
		}
		if (column >= rowCells.length) {
			CellValueRecordInterface[] oldRowCells = rowCells;
			int newSize = oldRowCells.length * 2;
			if (newSize < column + 1)
				newSize = column + 1;
			
			rowCells = new CellValueRecordInterface[newSize];
			System.arraycopy(oldRowCells, 0, rowCells, 0, oldRowCells.length);
			records[row] = rowCells;
		}
		rowCells[column] = cell;

		if (column < firstcell || firstcell == INDEX_NOT_SET) {
			firstcell = column;
		}
		if (column > lastcell || lastcell == INDEX_NOT_SET) {
			lastcell = column;
		}
	}

	public void removeCell(CellValueRecordInterface cell) {
		if (cell == null) {
			throw new IllegalArgumentException(""cell must not be null"");
		}
		int row = cell.getRow();
		if (row >= records.length) {
			throw new RuntimeException(""cell row is out of range"");
		}
		CellValueRecordInterface[] rowCells = records[row];
		if (rowCells == null) {
			throw new RuntimeException(""cell row is already empty"");
		}
		short column = cell.getColumn();
		if (column >= rowCells.length) {
			throw new RuntimeException(""cell column is out of range"");
		}
		rowCells[column] = null;
	}

	public void removeAllCellsValuesForRow(int rowIndex) {
		if (rowIndex < 0 || rowIndex > MAX_ROW_INDEX) {
			throw new IllegalArgumentException(""Specified rowIndex "" + rowIndex
					+ "" is outside the allowable range (0.."" +MAX_ROW_INDEX + "")"");
		}
		if (rowIndex >= records.length) {
			
			
			return;
		}

		records[rowIndex] = null;
	}


	public int getPhysicalNumberOfCells() {
		int count = 0;
		for (int r = 0; r < records.length; r++) {
			CellValueRecordInterface[] rowCells = records[r];
			if (rowCells != null) {
				for (int c = 0; c < rowCells.length; c++) {
					if (rowCells[c] != null)
						count++;
				}
			}
		}
		return count;
	}

	public int getFirstCellNum() {
		return firstcell;
	}

	public int getLastCellNum() {
		return lastcell;
	}

	public void addMultipleBlanks(MulBlankRecord mbr) {
		for (int j = 0; j < mbr.getNumColumns(); j++) {
			BlankRecord br = new BlankRecord();

			br.setColumn(( short ) (j + mbr.getFirstColumn()));
			br.setRow(mbr.getRow());
			br.setXFIndex(mbr.getXFAt(j));
			insertCell(br);
		}
	}

	
	public void construct(CellValueRecordInterface rec, RecordStream rs, SharedValueManager sfh) {
		if (rec instanceof FormulaRecord) {
			FormulaRecord formulaRec = (FormulaRecord)rec;
			
			StringRecord cachedText;
			Class<? extends Record> nextClass = rs.peekNextClass();
			if (nextClass == StringRecord.class) {
				cachedText = (StringRecord) rs.getNext();
			} else {
				cachedText = null;
			}
			insertCell(new FormulaRecordAggregate(formulaRec, cachedText, sfh));
		} else {
			insertCell(rec);
		}
	}

	
	public int getRowCellBlockSize(int startRow, int endRow) {
		int result = 0;
		for(int rowIx=startRow; rowIx<=endRow && rowIx<records.length; rowIx++) {
			result += getRowSerializedSize(records[rowIx]);
		}
		return result;
	}

	
	public boolean rowHasCells(int row) {
		if (row >= records.length) {
			return false;
		}
		CellValueRecordInterface[] rowCells=records[row];
		if(rowCells==null) return false;
		for(int col=0;col<rowCells.length;col++) {
			if(rowCells[col]!=null) return true;
		}
		return false;
	}

	private static int getRowSerializedSize(CellValueRecordInterface[] rowCells) {
		if(rowCells == null) {
			return 0;
		}
		int result = 0;
		for (int i = 0; i < rowCells.length; i++) {
			RecordBase cvr = (RecordBase) rowCells[i];
			if(cvr == null) {
				continue;
			}
			int nBlank = countBlanks(rowCells, i);
			if (nBlank > 1) {
				result += (10 + 2*nBlank);
				i+=nBlank-1;
			} else {
				result += cvr.getRecordSize();
			}
		}
		return result;
	}

	public void visitCellsForRow(int rowIndex, RecordVisitor rv) {

		CellValueRecordInterface[] rowCells = records[rowIndex];
		if(rowCells == null) {
			throw new IllegalArgumentException(""Row ["" + rowIndex + ""] is empty"");
		}


		for (int i = 0; i < rowCells.length; i++) {
			RecordBase cvr = (RecordBase) rowCells[i];
			if(cvr == null) {
				continue;
			}
			int nBlank = countBlanks(rowCells, i);
			if (nBlank > 1) {
				rv.visitRecord(createMBR(rowCells, i, nBlank));
				i+=nBlank-1;
			} else if (cvr instanceof RecordAggregate) {
				RecordAggregate agg = (RecordAggregate) cvr;
				agg.visitContainedRecords(rv);
			} else {
				rv.visitRecord((Record) cvr);
			}
		}
	}

	
	private static int countBlanks(CellValueRecordInterface[] rowCellValues, int startIx) {
		int i = startIx;
		while(i < rowCellValues.length) {
			CellValueRecordInterface cvr = rowCellValues[i];
			if (!(cvr instanceof BlankRecord)) {
				break;
			}
			i++;
		}
		return i - startIx;
	}

	private MulBlankRecord createMBR(CellValueRecordInterface[] cellValues, int startIx, int nBlank) {

		short[] xfs = new short[nBlank];
		for (int i = 0; i < xfs.length; i++) {
			xfs[i] = ((BlankRecord)cellValues[startIx + i]).getXFIndex();
		}
		int rowIx = cellValues[startIx].getRow();
		return new MulBlankRecord(rowIx, startIx, xfs);
	}

	public void updateFormulasAfterRowShift(FormulaShifter shifter, int currentExternSheetIndex) {
		for (int i = 0; i < records.length; i++) {
			CellValueRecordInterface[] rowCells = records[i];
			if (rowCells == null) {
				continue;
			}
			for (int j = 0; j < rowCells.length; j++) {
				CellValueRecordInterface cell = rowCells[j];
				if (cell instanceof FormulaRecordAggregate) {
                    FormulaRecordAggregate fra = (FormulaRecordAggregate)cell;
                    Ptg[] ptgs = fra.getFormulaTokens(); 
                    Ptg[] ptgs2 = ((FormulaRecordAggregate)cell).getFormulaRecord().getParsedExpression(); 

                    if (shifter.adjustFormula(ptgs, currentExternSheetIndex)) {
                        fra.setParsedExpression(ptgs);
                    }
                }
			}
		}
	}

	
	class ValueIterator implements Iterator<CellValueRecordInterface> {

		int curRowIndex = 0, curColIndex = -1;
		int nextRowIndex = 0, nextColIndex = -1;

		public ValueIterator() {
			getNextPos();
		}

		void getNextPos() {
			if (nextRowIndex >= records.length)
				return; 

			while (nextRowIndex < records.length) {
				++nextColIndex;
				if (records[nextRowIndex] == null || nextColIndex >= records[nextRowIndex].length) {
					++nextRowIndex;
					nextColIndex = -1;
					continue;
				}

				if (records[nextRowIndex][nextColIndex] != null)
					return; 
			}
			
		}

		public boolean hasNext() {
			return nextRowIndex < records.length;
		}

		public CellValueRecordInterface next() {
			if (!hasNext())
				throw new IndexOutOfBoundsException(""iterator has no next"");

			curRowIndex = nextRowIndex;
			curColIndex = nextColIndex;
			final CellValueRecordInterface ret = records[curRowIndex][curColIndex];
			getNextPos();
			return ret;
		}

		public void remove() {
			records[curRowIndex][curColIndex] = null;
		}
	}

	
	public Iterator<CellValueRecordInterface> iterator() {
		return new ValueIterator();
	}

	
	@Deprecated
	public CellValueRecordInterface[] getValueRecords() {
		List<CellValueRecordInterface> temp = new ArrayList<CellValueRecordInterface>();

		for (int rowIx = 0; rowIx < records.length; rowIx++) {
			CellValueRecordInterface[] rowCells = records[rowIx];
			if (rowCells == null) {
				continue;
			}
			for (int colIx = 0; colIx < rowCells.length; colIx++) {
				CellValueRecordInterface cell = rowCells[colIx];
				if (cell != null) {
					temp.add(cell);
				}
			}
		}

		CellValueRecordInterface[] result = new CellValueRecordInterface[temp.size()];
		temp.toArray(result);
		return result;
	}

	public Object clone() {
		throw new RuntimeException(""clone() should not be called.  ValueRecordsAggregate should be copied via Sheet.cloneSheet()"");
	}
}
"
poi,3,org.apache.poi.hssf.record.HorizontalPageBreakRecord,4,3,0,3,7,6,1,2,4,1.333333333,18,0.0,0,0.96,0.5,1,3,3.25,1,0.25,1,"

package org.apache.poi.hssf.record;

import java.util.Iterator;


public final class HorizontalPageBreakRecord extends PageBreakRecord {

	public static final short sid = 0x001B;

	
	public HorizontalPageBreakRecord() {
		
	}

	
	public HorizontalPageBreakRecord(RecordInputStream in) {
		super(in);
	}

	public short getSid() {
		return sid;
	}

	public Object clone() {
		PageBreakRecord result = new HorizontalPageBreakRecord();
		Iterator<Break> iterator = getBreaksIterator();
		while (iterator.hasNext()) {
			Break original = iterator.next();
			result.addBreak(original.main, original.subFrom, original.subTo);
		}
		return result;
	}
}
"
poi,3,org.apache.poi.poifs.storage.BigBlock,4,1,4,5,6,6,4,1,1,2.0,15,0.0,0,0.0,0.666666667,0,0,2.75,1,0.75,0,"

        

package org.apache.poi.poifs.storage;



import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;

abstract class BigBlock
    implements BlockWritable
{
    
    protected POIFSBigBlockSize bigBlockSize;
    
    protected BigBlock(POIFSBigBlockSize bigBlockSize) {
       this.bigBlockSize = bigBlockSize;
    }

    

    protected void doWriteData(final OutputStream stream, final byte [] data)
        throws IOException
    {
        stream.write(data);
    }

    

    abstract void writeData(final OutputStream stream)
        throws IOException;

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        writeData(stream);
    }

    
}   

"
poi,3,org.apache.poi.hssf.record.CommonObjectDataSubRecord,29,3,0,15,48,146,9,7,27,0.977891156,538,0.238095238,4,0.307692308,0.252873563,1,4,16.10344828,2,0.9655,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;


public final class CommonObjectDataSubRecord extends SubRecord {
    public final static short sid = 0x0015;

    private static final BitField locked    = BitFieldFactory.getInstance(0x0001);
    private static final BitField printable = BitFieldFactory.getInstance(0x0010);
    private static final BitField autofill  = BitFieldFactory.getInstance(0x2000);
    private static final BitField autoline  = BitFieldFactory.getInstance(0x4000);

    public final static short OBJECT_TYPE_GROUP              = 0;
    public final static short OBJECT_TYPE_LINE               = 1;
    public final static short OBJECT_TYPE_RECTANGLE          = 2;
    public final static short OBJECT_TYPE_OVAL               = 3;
    public final static short OBJECT_TYPE_ARC                = 4;
    public final static short OBJECT_TYPE_CHART              = 5;
    public final static short OBJECT_TYPE_TEXT               = 6;
    public final static short OBJECT_TYPE_BUTTON             = 7;
    public final static short OBJECT_TYPE_PICTURE            = 8;
    public final static short OBJECT_TYPE_POLYGON            = 9;
    public final static short OBJECT_TYPE_RESERVED1          = 10;
    public final static short OBJECT_TYPE_CHECKBOX           = 11;
    public final static short OBJECT_TYPE_OPTION_BUTTON      = 12;
    public final static short OBJECT_TYPE_EDIT_BOX           = 13;
    public final static short OBJECT_TYPE_LABEL              = 14;
    public final static short OBJECT_TYPE_DIALOG_BOX         = 15;
    public final static short OBJECT_TYPE_SPINNER            = 16;
    public final static short OBJECT_TYPE_SCROLL_BAR         = 17;
    public final static short OBJECT_TYPE_LIST_BOX           = 18;
    public final static short OBJECT_TYPE_GROUP_BOX          = 19;
    public final static short OBJECT_TYPE_COMBO_BOX          = 20;
    public final static short OBJECT_TYPE_RESERVED2          = 21;
    public final static short OBJECT_TYPE_RESERVED3          = 22;
    public final static short OBJECT_TYPE_RESERVED4          = 23;
    public final static short OBJECT_TYPE_RESERVED5          = 24;
    public final static short OBJECT_TYPE_COMMENT            = 25;
    public final static short OBJECT_TYPE_RESERVED6          = 26;
    public final static short OBJECT_TYPE_RESERVED7          = 27;
    public final static short OBJECT_TYPE_RESERVED8          = 28;
    public final static short OBJECT_TYPE_RESERVED9          = 29;
    public final static short OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING = 30;
    
    private  short      field_1_objectType;
    private  int        field_2_objectId;
    private  short      field_3_option;
    private  int        field_4_reserved1;
    private  int        field_5_reserved2;
    private  int        field_6_reserved3;


    public CommonObjectDataSubRecord()
    {

    }

    public CommonObjectDataSubRecord(LittleEndianInput in, int size) {
        if (size != 18) {
            throw new RecordFormatException(""Expected size 18 but got ("" + size + "")"");
        }
        field_1_objectType             = in.readShort();
        field_2_objectId               = in.readUShort();
        field_3_option                 = in.readShort();
        field_4_reserved1              = in.readInt();
        field_5_reserved2              = in.readInt();
        field_6_reserved3              = in.readInt();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ftCmo]
"");
        buffer.append(""    .objectType           = "")
            .append(""0x"").append(HexDump.toHex(  getObjectType ()))
            .append("" ("").append( getObjectType() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .objectId             = "")
            .append(""0x"").append(HexDump.toHex(  getObjectId ()))
            .append("" ("").append( getObjectId() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .option               = "")
            .append(""0x"").append(HexDump.toHex(  getOption ()))
            .append("" ("").append( getOption() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""         .locked                   = "").append(isLocked()).append('
'); 
        buffer.append(""         .printable                = "").append(isPrintable()).append('
'); 
        buffer.append(""         .autofill                 = "").append(isAutofill()).append('
'); 
        buffer.append(""         .autoline                 = "").append(isAutoline()).append('
'); 
        buffer.append(""    .reserved1            = "")
            .append(""0x"").append(HexDump.toHex(  getReserved1 ()))
            .append("" ("").append( getReserved1() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .reserved2            = "")
            .append(""0x"").append(HexDump.toHex(  getReserved2 ()))
            .append("" ("").append( getReserved2() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .reserved3            = "")
            .append(""0x"").append(HexDump.toHex(  getReserved3 ()))
            .append("" ("").append( getReserved3() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 

        buffer.append(""[/ftCmo]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {

        out.writeShort(sid);
        out.writeShort(getDataSize());

        out.writeShort(field_1_objectType);
        out.writeShort(field_2_objectId);
        out.writeShort(field_3_option);
        out.writeInt(field_4_reserved1);
        out.writeInt(field_5_reserved2);
        out.writeInt(field_6_reserved3);
    }

	protected int getDataSize() {
        return 2 + 2 + 2 + 4 + 4 + 4;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
        CommonObjectDataSubRecord rec = new CommonObjectDataSubRecord();
    
        rec.field_1_objectType = field_1_objectType;
        rec.field_2_objectId = field_2_objectId;
        rec.field_3_option = field_3_option;
        rec.field_4_reserved1 = field_4_reserved1;
        rec.field_5_reserved2 = field_5_reserved2;
        rec.field_6_reserved3 = field_6_reserved3;
        return rec;
    }


    
    public short getObjectType()
    {
        return field_1_objectType;
    }

    
    public void setObjectType(short field_1_objectType)
    {
        this.field_1_objectType = field_1_objectType;
    }

    
    public int getObjectId()
    {
        return field_2_objectId;
    }

    
    public void setObjectId(int field_2_objectId)
    {
        this.field_2_objectId = field_2_objectId;
    }

    
    public short getOption()
    {
        return field_3_option;
    }

    
    public void setOption(short field_3_option)
    {
        this.field_3_option = field_3_option;
    }

    
    public int getReserved1()
    {
        return field_4_reserved1;
    }

    
    public void setReserved1(int field_4_reserved1)
    {
        this.field_4_reserved1 = field_4_reserved1;
    }

    
    public int getReserved2()
    {
        return field_5_reserved2;
    }

    
    public void setReserved2(int field_5_reserved2)
    {
        this.field_5_reserved2 = field_5_reserved2;
    }

    
    public int getReserved3()
    {
        return field_6_reserved3;
    }

    
    public void setReserved3(int field_6_reserved3)
    {
        this.field_6_reserved3 = field_6_reserved3;
    }

    
    public void setLocked(boolean value)
    {
        field_3_option = locked.setShortBoolean(field_3_option, value);
    }

    
    public boolean isLocked()
    {
        return locked.isSet(field_3_option);
    }

    
    public void setPrintable(boolean value)
    {
        field_3_option = printable.setShortBoolean(field_3_option, value);
    }

    
    public boolean isPrintable()
    {
        return printable.isSet(field_3_option);
    }

    
    public void setAutofill(boolean value)
    {
        field_3_option = autofill.setShortBoolean(field_3_option, value);
    }

    
    public boolean isAutofill()
    {
        return autofill.isSet(field_3_option);
    }

    
    public void setAutoline(boolean value)
    {
        field_3_option = autoline.setShortBoolean(field_3_option, value);
    }

    
    public boolean isAutoline()
    {
        return autoline.isSet(field_3_option);
    }
}
"
poi,3,org.apache.poi.poifs.storage.BlockWritable,1,1,0,9,1,0,9,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;



public interface BlockWritable
{

    

    public void writeBlocks(final OutputStream stream)
        throws IOException;
}   

"
poi,3,org.apache.poi.hssf.record.EOFRecord,9,2,0,7,16,36,3,4,7,1.125,67,0.0,0,0.611111111,0.311111111,1,4,6.333333333,2,0.8889,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class EOFRecord extends StandardRecord {
    public final static short sid = 0x0A;
	public static final int ENCODED_SIZE = 4;

	public static final EOFRecord instance = new EOFRecord();
	
    private EOFRecord() {
    	
    }

    
    public EOFRecord(RecordInputStream in)
    {
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EOF]
"");
        buffer.append(""[/EOF]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
    }

    protected int getDataSize() {
        return ENCODED_SIZE - 4;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      return instance;
    }
}
"
poi,3,org.apache.poi.util.IntegerField,11,1,0,7,17,9,4,3,11,0.25,85,1.0,0,0.0,0.522727273,0,0,6.545454545,1,0.6364,0,"

        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class IntegerField
    implements FixedField
{
    private int       _value;
    private final int _offset;

    

    public IntegerField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(""negative offset"");
        }
        _offset = offset;
    }

    

    public IntegerField(final int offset, final int value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public IntegerField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public IntegerField(final int offset, final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public int get()
    {
        return _value;
    }

    

    public void set(final int value)
    {
        _value = value;
    }

    

    public void set(final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getInt(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readInt(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putInt(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,3,org.apache.poi.hssf.record.ObjRecord,13,2,0,18,42,0,12,6,11,0.666666667,235,0.5,0,0.5,0.269230769,1,4,16.92307692,3,1.3846,2,"
        
package org.apache.poi.hssf.record;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.List;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.LittleEndianInputStream;


public final class ObjRecord extends Record {
	public final static short sid = 0x005D;

	private static final int NORMAL_PAD_ALIGNMENT = 2;
	private static int MAX_PAD_ALIGNMENT = 4;
	
	private List<SubRecord> subrecords;
	
	private final byte[] _uninterpretedData;
	
	private boolean _isPaddedToQuadByteMultiple;

	
	


	public ObjRecord() {
		subrecords = new ArrayList<SubRecord>(2);
		
		_uninterpretedData = null;
	}

	public ObjRecord(RecordInputStream in) {
		
		
		
		
		
		
		
		

		
		
		byte[] subRecordData = in.readRemainder();
		if (LittleEndian.getUShort(subRecordData, 0) != CommonObjectDataSubRecord.sid) {
			
			
			
			_uninterpretedData = subRecordData;
			subrecords = null;
			return;
		}

        
        

		subrecords = new ArrayList<SubRecord>();
		ByteArrayInputStream bais = new ByteArrayInputStream(subRecordData);
		LittleEndianInputStream subRecStream = new LittleEndianInputStream(bais);
		CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord)SubRecord.createSubRecord(subRecStream, 0);
        subrecords.add(cmo);
        while (true) {
			SubRecord subRecord = SubRecord.createSubRecord(subRecStream, cmo.getObjectType());
			subrecords.add(subRecord);
			if (subRecord.isTerminating()) {
				break;
			}
		}
		int nRemainingBytes = bais.available();
		if (nRemainingBytes > 0) {
			
			_isPaddedToQuadByteMultiple = subRecordData.length % MAX_PAD_ALIGNMENT == 0;
			if (nRemainingBytes >= (_isPaddedToQuadByteMultiple ? MAX_PAD_ALIGNMENT : NORMAL_PAD_ALIGNMENT)) {
				if (!canPaddingBeDiscarded(subRecordData, nRemainingBytes)) {
					String msg = ""Leftover "" + nRemainingBytes 
						+ "" bytes in subrecord data "" + HexDump.toHex(subRecordData);
					throw new RecordFormatException(msg);
				}
				_isPaddedToQuadByteMultiple = false;
			}

        } else {
			_isPaddedToQuadByteMultiple = false;
		}
		_uninterpretedData = null;
	}

	
	private static boolean canPaddingBeDiscarded(byte[] data, int nRemainingBytes) {
        
		for(int i=data.length-nRemainingBytes; i<data.length; i++) {
			if (data[i] != 0x00) {
				return false;
			}
		}
		return true;
	}

	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();

		sb.append(""[OBJ]
"");
		if(subrecords != null) {	
    		for (int i = 0; i < subrecords.size(); i++) {
    			SubRecord record = subrecords.get(i);
    			sb.append(""SUBRECORD: "").append(record.toString());
    		}
		}
		sb.append(""[/OBJ]
"");
		return sb.toString();
	}
	
	@Override
	public int getRecordSize() {
		if (_uninterpretedData != null) {
			return _uninterpretedData.length + 4;
		}
		int size = 0;
		for (int i=subrecords.size()-1; i>=0; i--) {
			SubRecord record = subrecords.get(i);
			size += record.getDataSize()+4;
		}
		if (_isPaddedToQuadByteMultiple) {
			while (size % MAX_PAD_ALIGNMENT != 0) {
				size++;
			}
		} else {
			while (size % NORMAL_PAD_ALIGNMENT != 0) {
				size++;
			}
		}
		return size + 4;
	}

	@Override
	public int serialize(int offset, byte[] data) {
		int recSize = getRecordSize();
		int dataSize = recSize - 4;
		LittleEndianByteArrayOutputStream out = new LittleEndianByteArrayOutputStream(data, offset, recSize);

		out.writeShort(sid);
		out.writeShort(dataSize);

		if (_uninterpretedData == null) {

			for (int i = 0; i < subrecords.size(); i++) {
				SubRecord record = subrecords.get(i);
				record.serialize(out);
			}
			int expectedEndIx = offset+dataSize;
			
			while (out.getWriteIndex() < expectedEndIx) {
				out.writeByte(0);
			}
		} else {
			out.write(_uninterpretedData);
		}
		return recSize;
	}

	@Override
	public short getSid() {
		return sid;
	}

	public List<SubRecord> getSubRecords() {
		return subrecords;
	}

	public void clearSubRecords() {
		subrecords.clear();
	}

	public void addSubRecord(int index, SubRecord element) {
		subrecords.add(index, element);
	}

	public boolean addSubRecord(SubRecord o) {
		return subrecords.add(o);
	}

	@Override
	public Object clone() {
		ObjRecord rec = new ObjRecord();

		for (int i = 0; i < subrecords.size(); i++) {
			SubRecord record = subrecords.get(i);
			rec.addSubRecord((SubRecord) record.clone());
		}
		return rec;
	}
}
"
poi,3,org.apache.poi.hssf.record.CountryRecord,12,2,0,6,21,54,2,4,10,0.787878788,122,0.666666667,0,0.523809524,0.316666667,1,4,8.916666667,2,0.9167,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class CountryRecord
    extends StandardRecord
{
    public final static short sid = 0x8c;

    
    private short             field_1_default_country;
    private short             field_2_current_country;

    public CountryRecord()
    {
    }

    public CountryRecord(RecordInputStream in)
    {
        field_1_default_country = in.readShort();
        field_2_current_country = in.readShort();
    }

    

    public void setDefaultCountry(short country)
    {
        field_1_default_country = country;
    }

    

    public void setCurrentCountry(short country)
    {
        field_2_current_country = country;
    }

    

    public short getDefaultCountry()
    {
        return field_1_default_country;
    }

    

    public short getCurrentCountry()
    {
        return field_2_current_country;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[COUNTRY]
"");
        buffer.append(""    .defaultcountry  = "")
            .append(Integer.toHexString(getDefaultCountry())).append(""
"");
        buffer.append(""    .currentcountry  = "")
            .append(Integer.toHexString(getCurrentCountry())).append(""
"");
        buffer.append(""[/COUNTRY]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getDefaultCountry());
        out.writeShort(getCurrentCountry());
    }

    protected int getDataSize() {
        return 4;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.NameRecord,60,2,0,15,98,1374,5,11,55,0.957181088,1116,0.473684211,0,0.161764706,0.162962963,1,4,16.96666667,7,1.4833,8,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.cont.ContinuableRecord;
import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;
import org.apache.poi.ss.formula.ptg.Area3DPtg;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.ss.formula.ptg.Ref3DPtg;
import org.apache.poi.ss.formula.Formula;
import org.apache.poi.util.*;


public final class NameRecord extends ContinuableRecord {
    public final static short sid = 0x0018;
	
	public final static byte  BUILTIN_CONSOLIDATE_AREA      = 1;
	
	public final static byte  BUILTIN_AUTO_OPEN             = 2;
	
	public final static byte  BUILTIN_AUTO_CLOSE            = 3;
	
	public final static byte  BUILTIN_DATABASE              = 4;
	
	public final static byte  BUILTIN_CRITERIA              = 5;

	public final static byte  BUILTIN_PRINT_AREA            = 6;
	public final static byte  BUILTIN_PRINT_TITLE           = 7;

	
	public final static byte  BUILTIN_RECORDER              = 8;
	
	public final static byte  BUILTIN_DATA_FORM             = 9;
	
	public final static byte  BUILTIN_AUTO_ACTIVATE         = 10;
	
	public final static byte  BUILTIN_AUTO_DEACTIVATE       = 11;
	
	public final static byte  BUILTIN_SHEET_TITLE           = 12;

	public final static byte  BUILTIN_FILTER_DB             = 13;

	private static final class Option {
		public static final int OPT_HIDDEN_NAME =   0x0001;
		public static final int OPT_FUNCTION_NAME = 0x0002;
		public static final int OPT_COMMAND_NAME =  0x0004;
		public static final int OPT_MACRO =         0x0008;
		public static final int OPT_COMPLEX =       0x0010;
		public static final int OPT_BUILTIN =       0x0020;
		public static final int OPT_BINDATA =       0x1000;
		public static final boolean isFormula(int optValue) {
			return (optValue & 0x0F) == 0;
		}
	}

	private short             field_1_option_flag;
	private byte              field_2_keyboard_shortcut;
	
	private short             field_5_externSheetIndex_plus1;
	
	private int               field_6_sheetNumber;
	private boolean           field_11_nameIsMultibyte;
	private byte              field_12_built_in_code;
	private String            field_12_name_text;
	private Formula           field_13_name_definition;
	private String            field_14_custom_menu_text;
	private String            field_15_description_text;
	private String            field_16_help_topic_text;
	private String            field_17_status_bar_text;


	
	public NameRecord() {
		field_13_name_definition = Formula.create(Ptg.EMPTY_PTG_ARRAY);

		field_12_name_text = """";
		field_14_custom_menu_text = """";
		field_15_description_text = """";
		field_16_help_topic_text = """";
		field_17_status_bar_text = """";
	}

	
	public NameRecord(byte builtin, int sheetNumber)
	{
		this();
		field_12_built_in_code = builtin;
		setOptionFlag((short)(field_1_option_flag | Option.OPT_BUILTIN));
		field_6_sheetNumber = sheetNumber; 
	}

	
	public void setOptionFlag(short flag){
		field_1_option_flag = flag;
	}


	
	public void setKeyboardShortcut(byte shortcut){
		field_2_keyboard_shortcut = shortcut;
	}

	
	public int getSheetNumber()
	{
		return field_6_sheetNumber;
	}

	
	public byte getFnGroup() {
		int masked = field_1_option_flag & 0x0fc0;
		return (byte) (masked >> 4);
	}


	public void setSheetNumber(int value)
	{
		field_6_sheetNumber = value;
	}


	
	public void setNameText(String name){
		field_12_name_text = name;
		field_11_nameIsMultibyte = StringUtil.hasMultibyte(name);
	}

	
	public void setCustomMenuText(String text){
		field_14_custom_menu_text = text;
	}

	
	public void setDescriptionText(String text){
		field_15_description_text = text;
	}

	
	public void setHelpTopicText(String text){
		field_16_help_topic_text = text;
	}

	
	public void setStatusBarText(String text){
		field_17_status_bar_text = text;
	}

	
	public short getOptionFlag(){
		return field_1_option_flag;
	}

	
	public byte getKeyboardShortcut(){
		return field_2_keyboard_shortcut ;
	}

	
	private int getNameTextLength(){
		if (isBuiltInName()) {
			return 1;
		}
		return field_12_name_text.length();
	}


	
	public boolean isHiddenName() {
		return (field_1_option_flag & Option.OPT_HIDDEN_NAME) != 0;
	}
	public void setHidden(boolean b) {
		if (b) {
			field_1_option_flag |= Option.OPT_HIDDEN_NAME;
		} else {
			field_1_option_flag &= (~Option.OPT_HIDDEN_NAME);
		}
	}
	
	public boolean isFunctionName() {
		return (field_1_option_flag & Option.OPT_FUNCTION_NAME) != 0;
	}

	
	public void setFunction(boolean function){
		if (function) {
			field_1_option_flag |= Option.OPT_FUNCTION_NAME;
		} else {
			field_1_option_flag &= (~Option.OPT_FUNCTION_NAME);
		}
	}

	
	public boolean hasFormula() {
		return Option.isFormula(field_1_option_flag) && field_13_name_definition.getEncodedTokenSize() > 0;
	}

	
	public boolean isCommandName() {
		return (field_1_option_flag & Option.OPT_COMMAND_NAME) != 0;
	}
	
	public boolean isMacro() {
		return (field_1_option_flag & Option.OPT_MACRO) != 0;
	}
	
	public boolean isComplexFunction() {
		return (field_1_option_flag & Option.OPT_COMPLEX) != 0;
	}

	
	public boolean isBuiltInName()
	{
		return ((field_1_option_flag & Option.OPT_BUILTIN) != 0);
	}


	
	public String getNameText(){

		return isBuiltInName() ? translateBuiltInName(getBuiltInName()) : field_12_name_text;
	}

	
	public byte getBuiltInName()
	{
		return field_12_built_in_code;
	}


	
	public Ptg[] getNameDefinition() {
		return field_13_name_definition.getTokens();
	}

	public void setNameDefinition(Ptg[] ptgs) {
		field_13_name_definition = Formula.create(ptgs);
	}

	
	public String getCustomMenuText(){
		return field_14_custom_menu_text;
	}

	
	public String getDescriptionText(){
		return field_15_description_text;
	}

	
	public String getHelpTopicText(){
		return field_16_help_topic_text;
	}

	
	public String getStatusBarText(){
		return field_17_status_bar_text;
	}

    
	public void serialize(ContinuableRecordOutput out) {

		int field_7_length_custom_menu = field_14_custom_menu_text.length();
		int field_8_length_description_text = field_15_description_text.length();
		int field_9_length_help_topic_text = field_16_help_topic_text.length();
		int field_10_length_status_bar_text = field_17_status_bar_text.length();

		
		out.writeShort(getOptionFlag());
		out.writeByte(getKeyboardShortcut());
		out.writeByte(getNameTextLength());
		
		out.writeShort(field_13_name_definition.getEncodedTokenSize());
		out.writeShort(field_5_externSheetIndex_plus1);
		out.writeShort(field_6_sheetNumber);
		out.writeByte(field_7_length_custom_menu);
		out.writeByte(field_8_length_description_text);
		out.writeByte(field_9_length_help_topic_text);
		out.writeByte(field_10_length_status_bar_text);
		out.writeByte(field_11_nameIsMultibyte ? 1 : 0);

		if (isBuiltInName()) {
			
			out.writeByte(field_12_built_in_code);
		} else {
			String nameText = field_12_name_text;
			if (field_11_nameIsMultibyte) {
				StringUtil.putUnicodeLE(nameText, out);
			} else {
				StringUtil.putCompressedUnicode(nameText, out);
			}
		}
		field_13_name_definition.serializeTokens(out);
		field_13_name_definition.serializeArrayConstantData(out);

		StringUtil.putCompressedUnicode( getCustomMenuText(), out);
		StringUtil.putCompressedUnicode( getDescriptionText(), out);
		StringUtil.putCompressedUnicode( getHelpTopicText(), out);
		StringUtil.putCompressedUnicode( getStatusBarText(), out);
	}
	private int getNameRawSize() {
		if (isBuiltInName()) {
			return 1;
		}
		int nChars = field_12_name_text.length();
		if(field_11_nameIsMultibyte) {
			return 2 * nChars;
		}
		return nChars;
	}

	protected int getDataSize() {
		return 13 
			+ getNameRawSize()
			+ field_14_custom_menu_text.length()
			+ field_15_description_text.length()
			+ field_16_help_topic_text.length()
			+ field_17_status_bar_text.length()
			+ field_13_name_definition.getEncodedSize();
	}

	
	public int getExternSheetNumber(){
	    Ptg[] tokens = field_13_name_definition.getTokens();
		if (tokens.length == 0) {
			return 0;
		}

		Ptg ptg = tokens[0];
		if (ptg.getClass() == Area3DPtg.class){
			return ((Area3DPtg) ptg).getExternSheetIndex();

		}
		if (ptg.getClass() == Ref3DPtg.class){
			return ((Ref3DPtg) ptg).getExternSheetIndex();
		}
		return 0;
	}

	
	public NameRecord(RecordInputStream ris) {
        
        

        
        byte[] remainder = ris.readAllContinuedRemainder();
        LittleEndianInput in = new LittleEndianByteArrayInputStream(remainder);

		field_1_option_flag                 = in.readShort();
		field_2_keyboard_shortcut           = in.readByte();
		int field_3_length_name_text        = in.readUByte();
		int field_4_length_name_definition  = in.readShort();
		field_5_externSheetIndex_plus1      = in.readShort();
		field_6_sheetNumber                 = in.readUShort();
		int f7_customMenuLen      = in.readUByte();
		int f8_descriptionTextLen = in.readUByte();
		int f9_helpTopicTextLen  = in.readUByte();
		int f10_statusBarTextLen = in.readUByte();

		
		field_11_nameIsMultibyte = (in.readByte() != 0);
		if (isBuiltInName()) {
			field_12_built_in_code = in.readByte();
		} else {
			if (field_11_nameIsMultibyte) {
				field_12_name_text = StringUtil.readUnicodeLE(in, field_3_length_name_text);
			} else {
				field_12_name_text = StringUtil.readCompressedUnicode(in, field_3_length_name_text);
			}
		}

		int nBytesAvailable = in.available() - (f7_customMenuLen
				+ f8_descriptionTextLen + f9_helpTopicTextLen + f10_statusBarTextLen);
		field_13_name_definition = Formula.read(field_4_length_name_definition, in, nBytesAvailable);

		
		field_14_custom_menu_text = StringUtil.readCompressedUnicode(in, f7_customMenuLen);
		field_15_description_text = StringUtil.readCompressedUnicode(in, f8_descriptionTextLen);
		field_16_help_topic_text  = StringUtil.readCompressedUnicode(in, f9_helpTopicTextLen);
		field_17_status_bar_text  = StringUtil.readCompressedUnicode(in, f10_statusBarTextLen);
	}

	
	public short getSid() {
		return sid;
	}
	
	

	public String toString() {
		StringBuffer sb = new StringBuffer();

		sb.append(""[NAME]
"");
		sb.append(""    .option flags           = "").append(HexDump.shortToHex(field_1_option_flag)).append(""
"");
		sb.append(""    .keyboard shortcut      = "").append(HexDump.byteToHex(field_2_keyboard_shortcut)).append(""
"");
		sb.append(""    .length of the name     = "").append(getNameTextLength()).append(""
"");
		sb.append(""    .extSheetIx(1-based, 0=Global)= "").append( field_5_externSheetIndex_plus1 ).append(""
"");
		sb.append(""    .sheetTabIx             = "").append(field_6_sheetNumber ).append(""
"");
		sb.append(""    .Menu text length       = "").append(field_14_custom_menu_text.length()).append(""
"");
		sb.append(""    .Description text length= "").append(field_15_description_text.length()).append(""
"");
		sb.append(""    .Help topic text length = "").append(field_16_help_topic_text.length()).append(""
"");
		sb.append(""    .Status bar text length = "").append(field_17_status_bar_text.length()).append(""
"");
		sb.append(""    .NameIsMultibyte        = "").append(field_11_nameIsMultibyte).append(""
"");
		sb.append(""    .Name (Unicode text)    = "").append( getNameText() ).append(""
"");
		Ptg[] ptgs = field_13_name_definition.getTokens();
		sb.append(""    .Formula (nTokens="").append(ptgs.length).append(""):"") .append(""
"");
		for (int i = 0; i < ptgs.length; i++) {
			Ptg ptg = ptgs[i];
			sb.append(""       "" + ptg.toString()).append(ptg.getRVAType()).append(""
"");
		}

		sb.append(""    .Menu text       = "").append(field_14_custom_menu_text).append(""
"");
		sb.append(""    .Description text= "").append(field_15_description_text).append(""
"");
		sb.append(""    .Help topic text = "").append(field_16_help_topic_text).append(""
"");
		sb.append(""    .Status bar text = "").append(field_17_status_bar_text).append(""
"");
		sb.append(""[/NAME]
"");

		return sb.toString();
	}

	
	private static String translateBuiltInName(byte name)
	{
		switch (name)
		{
			case NameRecord.BUILTIN_AUTO_ACTIVATE :     return ""Auto_Activate"";
			case NameRecord.BUILTIN_AUTO_CLOSE :        return ""Auto_Close"";
			case NameRecord.BUILTIN_AUTO_DEACTIVATE :   return ""Auto_Deactivate"";
			case NameRecord.BUILTIN_AUTO_OPEN :         return ""Auto_Open"";
			case NameRecord.BUILTIN_CONSOLIDATE_AREA :  return ""Consolidate_Area"";
			case NameRecord.BUILTIN_CRITERIA :          return ""Criteria"";
			case NameRecord.BUILTIN_DATABASE :          return ""Database"";
			case NameRecord.BUILTIN_DATA_FORM :         return ""Data_Form"";
			case NameRecord.BUILTIN_PRINT_AREA :        return ""Print_Area"";
			case NameRecord.BUILTIN_PRINT_TITLE :       return ""Print_Titles"";
			case NameRecord.BUILTIN_RECORDER :          return ""Recorder"";
			case NameRecord.BUILTIN_SHEET_TITLE :       return ""Sheet_Title"";
			case NameRecord.BUILTIN_FILTER_DB  :        return ""_FilterDatabase"";

		}

		return ""Unknown"";
	}
}
"
poi,3,org.apache.poi.poifs.dev.POIFSViewable,4,1,0,6,4,6,6,0,4,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.dev;

import java.util.Iterator;



public interface POIFSViewable
{

    

    public Object [] getViewableArray();
    
    
    public Iterator<Object> getViewableIterator();

    

    public boolean preferArray();

    

    public String getShortDescription();
}   

"
poi,3,org.apache.poi.hpsf.Property,12,1,1,17,49,18,10,7,8,0.484848485,595,1.0,0,0.0,0.366666667,1,1,48.33333333,12,2.3333,1,"

package org.apache.poi.hpsf;

import java.io.UnsupportedEncodingException;
import java.util.LinkedHashMap;
import java.util.Map;

import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public class Property
{

    
    protected long id;


    
    public long getID()
    {
        return id;
    }



    
    protected long type;


    
    public long getType()
    {
        return type;
    }



    
    protected Object value;


    
    public Object getValue()
    {
        return value;
    }



    
    public Property(final long id, final long type, final Object value)
    {
        this.id = id;
        this.type = type;
        this.value = value;
    }



    
    public Property(final long id, final byte[] src, final long offset,
                    final int length, final int codepage)
    throws UnsupportedEncodingException
    {
        this.id = id;

        
        if (id == 0)
        {
            value = readDictionary(src, offset, length, codepage);
            return;
        }

        int o = (int) offset;
        type = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        try
        {
            value = VariantSupport.read(src, o, length, (int) type, codepage);
        }
        catch (UnsupportedVariantTypeException ex)
        {
            VariantSupport.writeUnsupportedTypeMessage(ex);
            value = ex.getValue();
        }
    }



    
    protected Property()
    { }



    
    protected Map<?, ?> readDictionary(final byte[] src, final long offset,
                                 final int length, final int codepage)
    throws UnsupportedEncodingException
    {
        
        if (offset < 0 || offset > src.length)
            throw new HPSFRuntimeException
                (""Illegal offset "" + offset + "" while HPSF stream contains "" +
                 length + "" bytes."");
        int o = (int) offset;

        
        final long nrEntries = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        final Map<Object, Object> m = new LinkedHashMap<Object, Object>(
                (int) nrEntries, (float) 1.0 );

        try
        {
            for (int i = 0; i < nrEntries; i++)
            {
                
                final Long id = Long.valueOf(LittleEndian.getUInt(src, o));
                o += LittleEndian.INT_SIZE;

                
                long sLength = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;

                
                final StringBuffer b = new StringBuffer();
                switch (codepage)
                {
                    case -1:
                    {
                        
                        b.append(new String(src, o, (int) sLength));
                        break;
                    }
                    case CodePageUtil.CP_UNICODE:
                    {
                        
                        final int nrBytes = (int) (sLength * 2);
                        final byte[] h = new byte[nrBytes];
                        for (int i2 = 0; i2 < nrBytes; i2 += 2)
                        {
                            h[i2] = src[o + i2 + 1];
                            h[i2 + 1] = src[o + i2];
                        }
                        b.append(new String(h, 0, nrBytes,
                                CodePageUtil.codepageToEncoding(codepage)));
                        break;
                    }
                    default:
                    {
                        
                        b.append(new String(src, o, (int) sLength,
                                 VariantSupport.codepageToEncoding(codepage)));
                        break;
                    }
                }

                
                while (b.length() > 0 && b.charAt(b.length() - 1) == 0x00)
                    b.setLength(b.length() - 1);
                if (codepage == CodePageUtil.CP_UNICODE)
                {
                    if (sLength % 2 == 1)
                        sLength++;
                    o += (sLength + sLength);
                }
                else
                    o += sLength;
                m.put(id, b.toString());
            }
        }
        catch (RuntimeException ex)
        {
            final POILogger l = POILogFactory.getLogger(getClass());
            l.log(POILogger.WARN,
                    ""The property set's dictionary contains bogus data. ""
                    + ""All dictionary entries starting with the one with ID ""
                    + id + "" will be ignored."", ex);
        }
        return m;
    }



    
    protected int getSize() throws WritingNotSupportedException
    {
        int length = VariantSupport.getVariantLength(type);
        if (length >= 0)
            return length; 
        if (length == -2)
            
            throw new WritingNotSupportedException(type, null);

        
        final int PADDING = 4; 
        switch ((int) type)
        {
            case Variant.VT_LPSTR:
            {
                int l = ((String) value).length() + 1;
                int r = l % PADDING;
                if (r > 0)
                    l += PADDING - r;
                length += l;
                break;
            }
            case Variant.VT_EMPTY:
                break;
            default:
                throw new WritingNotSupportedException(type, value);
        }
        return length;
    }



    
    public boolean equals(final Object o)
    {
        if (!(o instanceof Property)) {
            return false;
        }
        final Property p = (Property) o;
        final Object pValue = p.getValue();
        final long pId = p.getID();
        if (id != pId || (id != 0 && !typesAreEqual(type, p.getType())))
            return false;
        if (value == null && pValue == null)
            return true;
        if (value == null || pValue == null)
            return false;

        
        final Class<?> valueClass = value.getClass();
        final Class<?> pValueClass = pValue.getClass();
        if (!(valueClass.isAssignableFrom(pValueClass)) &&
            !(pValueClass.isAssignableFrom(valueClass)))
            return false;

        if (value instanceof byte[])
            return Util.equal((byte[]) value, (byte[]) pValue);

        return value.equals(pValue);
    }



    private boolean typesAreEqual(final long t1, final long t2)
    {
        if (t1 == t2 ||
            (t1 == Variant.VT_LPSTR && t2 == Variant.VT_LPWSTR) ||
            (t2 == Variant.VT_LPSTR && t1 == Variant.VT_LPWSTR)) {
            return true;
        }
        return false;
    }



    
    public int hashCode()
    {
        long hashCode = 0;
        hashCode += id;
        hashCode += type;
        if (value != null)
            hashCode += value.hashCode();
        final int returnHashCode = (int) (hashCode & 0x0ffffffffL );
        return returnHashCode;

    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        b.append(getClass().getName());
        b.append('[');
        b.append(""id: "");
        b.append(getID());
        b.append("", type: "");
        b.append(getType());
        final Object value = getValue();
        b.append("", value: "");
        if (value instanceof String)
        {
            b.append(value.toString());
            final String s = (String) value;
            final int l = s.length();
            final byte[] bytes = new byte[l * 2];
            for (int i = 0; i < l; i++)
            {
                final char c = s.charAt(i);
                final byte high = (byte) ((c & 0x00ff00) >> 8);
                final byte low  = (byte) ((c & 0x0000ff) >> 0);
                bytes[i * 2]     = high;
                bytes[i * 2 + 1] = low;
            }
            b.append("" ["");
            if(bytes.length > 0) {
                final String hex = HexDump.dump(bytes, 0L, 0);
                b.append(hex);
            }
            b.append(""]"");
        }
        else if (value instanceof byte[])
        {
            byte[] bytes = (byte[])value;
            if(bytes.length > 0) {
                String hex = HexDump.dump(bytes, 0L, 0);
                b.append(hex);
            }
        }
        else
        {
            b.append(value.toString());
        }
        b.append(']');
        return b.toString();
    }

}
"
poi,3,org.apache.poi.ddf.EscherShapePathProperty,1,3,0,4,2,0,3,1,1,2.0,13,0.0,0,1.0,1.0,0,0,7.0,0,0.0,1,"

package org.apache.poi.ddf;


public class EscherShapePathProperty extends EscherSimpleProperty {

    public static final int LINE_OF_STRAIGHT_SEGMENTS = 0;
    public static final int CLOSED_POLYGON = 1;
    public static final int CURVES = 2;
    public static final int CLOSED_CURVES = 3;
    public static final int COMPLEX = 4;

    public EscherShapePathProperty( short propertyNumber, int shapePath )
    {
        super( propertyNumber, false, false, shapePath );
    }
}
"
poi,3,org.apache.poi.util.TempFile,3,1,0,0,15,1,0,0,2,0.75,53,0.0,0,0.0,0.5,0,0,16.0,1,0.3333,1,"

package org.apache.poi.util;

import java.io.File;
import java.io.IOException;


public final class TempFile {
    
    
    private static TempFileCreationStrategy strategy = new DefaultTempFileCreationStrategy();
    
    
    public static void setTempFileCreationStrategy(TempFileCreationStrategy strategy) {
        if (strategy == null) {
            throw new IllegalArgumentException(""strategy == null"");
        }
        TempFile.strategy = strategy;
    }
    
    
    public static File createTempFile(String prefix, String suffix) throws IOException {
        return strategy.createTempFile(prefix, suffix);
    }
    
    
    public static class DefaultTempFileCreationStrategy implements TempFileCreationStrategy {
        
        
        private File dir;
        
        
        public DefaultTempFileCreationStrategy() {
            this(null);
        }
        
        
        public DefaultTempFileCreationStrategy(File dir) {
            this.dir = dir;
        }
        
        @Override
        public File createTempFile(String prefix, String suffix) throws IOException {
            
            if (dir == null)
            {
                dir = new File(System.getProperty(""java.io.tmpdir""), ""poifiles"");
                dir.mkdir();
                if (System.getProperty(""poi.keep.tmp.files"") == null)
                    dir.deleteOnExit();
            }

            
            File newFile = File.createTempFile(prefix, suffix, dir);

            
            if (System.getProperty(""poi.keep.tmp.files"") == null)
                newFile.deleteOnExit();

            
            return newFile;
        }
        
    }
}
"
poi,3,org.apache.poi.hssf.dev.EFBiffViewer,4,1,0,6,16,4,1,6,4,0.333333333,82,0.0,0,0.0,0.416666667,0,0,19.25,3,1.25,0,"

package org.apache.poi.hssf.dev;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.hssf.eventusermodel.HSSFEventFactory;
import org.apache.poi.hssf.eventusermodel.HSSFListener;
import org.apache.poi.hssf.eventusermodel.HSSFRequest;
import org.apache.poi.hssf.record.Record;



public class EFBiffViewer
{
    String file;

    

    public EFBiffViewer()
    {
    }

    public void run() throws IOException {
        InputStream     din   = BiffViewer.getPOIFSInputStream(new File(file));
        HSSFRequest     req   = new HSSFRequest();

        req.addListenerForAllRecords(new HSSFListener()
        {
            public void processRecord(Record rec)
            {
                System.out.println(rec.toString());
            }
        });
        HSSFEventFactory factory = new HSSFEventFactory();

        factory.processEvents(req, din);
    }

    public void setFile(String file)
    {
        this.file = file;
    }

    public static void main(String [] args)
    {
        if ((args.length == 1) && !args[ 0 ].equals(""--help""))
        {
            try
            {
                EFBiffViewer viewer = new EFBiffViewer();

                viewer.setFile(args[ 0 ]);
                viewer.run();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
        }
        else
        {
            System.out.println(""EFBiffViewer"");
            System.out.println(
                ""Outputs biffview of records based on HSSFEventFactory"");
            System.out
                .println(""usage: java org.apache.poi.hssf.dev.EBBiffViewer ""
                         + ""filename"");
        }
    }
}
"
poi,3,org.apache.poi.hssf.record.WriteAccessRecord,10,2,0,9,26,33,2,7,8,0.833333333,148,0.5,0,0.578947368,0.266666667,1,4,13.6,2,1.0,2,"

package org.apache.poi.hssf.record;

import java.util.Arrays;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;


public final class WriteAccessRecord extends StandardRecord {
	public final static short sid = 0x005C;

	private static final byte PAD_CHAR = (byte) ' ';
	private static final int DATA_SIZE = 112;
	private String field_1_username;
	
	private static final byte[] PADDING = new byte[DATA_SIZE];
	static {
		Arrays.fill(PADDING, PAD_CHAR);
	}

	public WriteAccessRecord() {
		setUsername("""");
	}

	public WriteAccessRecord(RecordInputStream in) {
		if (in.remaining() > DATA_SIZE) {
			throw new RecordFormatException(""Expected data size ("" + DATA_SIZE + "") but got (""
					+ in.remaining() + "")"");
		}
		
		

		int nChars = in.readUShort();
		int is16BitFlag = in.readUByte();
		if (nChars > DATA_SIZE || (is16BitFlag & 0xFE) != 0) {
			
			
			
			byte[] data = new byte[3 + in.remaining()];
			LittleEndian.putUShort(data, 0, nChars);
			LittleEndian.putByte(data, 2, is16BitFlag);
			in.readFully(data, 3, data.length-3);
			String rawValue = new String(data);
			setUsername(rawValue.trim());
			return;
		}

		String rawText;
		if ((is16BitFlag & 0x01) == 0x00) {
			rawText = StringUtil.readCompressedUnicode(in, nChars);
		} else {
			rawText = StringUtil.readUnicodeLE(in, nChars);
		}
		field_1_username = rawText.trim();

		
		int padSize = in.remaining();
		while (padSize > 0) {
			
			in.readUByte();
			padSize--;
		}
	}

	
	public void setUsername(String username) {
		boolean is16bit = StringUtil.hasMultibyte(username);
		int encodedByteCount = 3 + username.length() * (is16bit ? 2 : 1);
		int paddingSize = DATA_SIZE - encodedByteCount;
		if (paddingSize < 0) {
			throw new IllegalArgumentException(""Name is too long: "" + username);
		}

		field_1_username = username;
	}

	
	public String getUsername() {
		return field_1_username;
	}

	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[WRITEACCESS]
"");
		buffer.append(""    .name = "").append(field_1_username).append(""
"");
		buffer.append(""[/WRITEACCESS]
"");
		return buffer.toString();
	}

	public void serialize(LittleEndianOutput out) {
		String username = getUsername();
		boolean is16bit = StringUtil.hasMultibyte(username);

		out.writeShort(username.length());
		out.writeByte(is16bit ? 0x01 : 0x00);
		if (is16bit) {
			StringUtil.putUnicodeLE(username, out);
		} else {
			StringUtil.putCompressedUnicode(username, out);
		}
		int encodedByteCount = 3 + username.length() * (is16bit ? 2 : 1);
		int paddingSize = DATA_SIZE - encodedByteCount;
		out.write(PADDING, 0, paddingSize);
	}

	protected int getDataSize() {
		return DATA_SIZE;
	}

	public short getSid() {
		return sid;
	}
}
"
poi,3,org.apache.poi.hssf.record.PrecisionRecord,10,2,0,6,19,33,2,4,8,0.833333333,102,0.0,0,0.578947368,0.266666667,1,4,9.0,2,1.1,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class PrecisionRecord
    extends StandardRecord
{
    public final static short sid = 0xE;
    public short              field_1_precision;

    public PrecisionRecord()
    {
    }

    public PrecisionRecord(RecordInputStream in)
    {
        field_1_precision = in.readShort();
    }

    

    public void setFullPrecision(boolean fullprecision)
    {
        if (fullprecision == true)
        {
            field_1_precision = 1;
        }
        else
        {
            field_1_precision = 0;
        }
    }

    

    public boolean getFullPrecision()
    {
        return (field_1_precision == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRECISION]
"");
        buffer.append(""    .precision       = "").append(getFullPrecision())
            .append(""
"");
        buffer.append(""[/PRECISION]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_precision);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFShapeGroup,13,2,0,11,26,4,3,8,13,0.683333333,174,0.0,0,0.571428571,0.338461538,1,1,12.0,2,1.0,0,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Iterator;


public class HSSFShapeGroup extends HSSFShape implements HSSFShapeContainer {
    private final List<HSSFShape> shapes = new ArrayList<HSSFShape>();
    private EscherSpgrRecord _spgrRecord;

    public HSSFShapeGroup(EscherContainerRecord spgrContainer, ObjRecord objRecord) {
        super(spgrContainer, objRecord);

        
        EscherContainerRecord spContainer = spgrContainer.getChildContainers().get(0);
        _spgrRecord = (EscherSpgrRecord) spContainer.getChild(0);
        for (EscherRecord ch : spContainer.getChildRecords()) {
            switch (ch.getRecordId()) {
                case EscherSpgrRecord.RECORD_ID:
                    break;
                case EscherClientAnchorRecord.RECORD_ID:
                    anchor = new HSSFClientAnchor((EscherClientAnchorRecord) ch);
                    break;
                case EscherChildAnchorRecord.RECORD_ID:
                    anchor = new HSSFChildAnchor((EscherChildAnchorRecord) ch);
                    break;
            }
        }
    }

    public HSSFShapeGroup(HSSFShape parent, HSSFAnchor anchor) {
        super(parent, anchor);
        _spgrRecord = ((EscherContainerRecord)getEscherContainer().getChild(0)).getChildById(EscherSpgrRecord.RECORD_ID);
    }

    @Override
    protected EscherContainerRecord createSpContainer() {
        EscherContainerRecord spgrContainer = new EscherContainerRecord();
        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpgrRecord spgr = new EscherSpgrRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherRecord anchor;
        EscherClientDataRecord clientData = new EscherClientDataRecord();

        spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);
        spgrContainer.setOptions((short) 0x000F);
        spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);
        spContainer.setOptions((short) 0x000F);
        spgr.setRecordId(EscherSpgrRecord.RECORD_ID);
        spgr.setOptions((short) 0x0001);
        spgr.setRectX1(0);
        spgr.setRectY1(0);
        spgr.setRectX2(1023);
        spgr.setRectY2(255);
        sp.setRecordId(EscherSpRecord.RECORD_ID);
        sp.setOptions((short) 0x0002);
        if (getAnchor() instanceof HSSFClientAnchor) {
            sp.setFlags(EscherSpRecord.FLAG_GROUP | EscherSpRecord.FLAG_HAVEANCHOR);
        } else {
            sp.setFlags(EscherSpRecord.FLAG_GROUP | EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_CHILD);
        }
        opt.setRecordId(EscherOptRecord.RECORD_ID);
        opt.setOptions((short) 0x0023);
        opt.addEscherProperty(new EscherBoolProperty(EscherProperties.PROTECTION__LOCKAGAINSTGROUPING, 0x00040004));
        opt.addEscherProperty(new EscherBoolProperty(EscherProperties.GROUPSHAPE__PRINT, 0x00080000));

        anchor = getAnchor().getEscherAnchor();
        clientData.setRecordId(EscherClientDataRecord.RECORD_ID);
        clientData.setOptions((short) 0x0000);

        spgrContainer.addChildRecord(spContainer);
        spContainer.addChildRecord(spgr);
        spContainer.addChildRecord(sp);
        spContainer.addChildRecord(opt);
        spContainer.addChildRecord(anchor);
        spContainer.addChildRecord(clientData);
        return spgrContainer;
    }

    @Override
    protected ObjRecord createObjRecord() {
        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord cmo = new CommonObjectDataSubRecord();
        cmo.setObjectType(CommonObjectDataSubRecord.OBJECT_TYPE_GROUP);
        cmo.setLocked(true);
        cmo.setPrintable(true);
        cmo.setAutofill(true);
        cmo.setAutoline(true);
        GroupMarkerSubRecord gmo = new GroupMarkerSubRecord();
        EndSubRecord end = new EndSubRecord();
        obj.addSubRecord(cmo);
        obj.addSubRecord(gmo);
        obj.addSubRecord(end);
        return obj;
    }

    @Override
    protected void afterRemove(HSSFPatriarch patriarch) {
        patriarch._getBoundAggregate().removeShapeToObjRecord(getEscherContainer().getChildContainers().get(0)
                .getChildById(EscherClientDataRecord.RECORD_ID));
        for ( int i=0; i<shapes.size(); i++ ) {
            HSSFShape shape = shapes.get(i);
            removeShape(shape);
            shape.afterRemove(getPatriarch());
        }
        shapes.clear();
    }

    private void onCreate(HSSFShape shape){
        if(getPatriarch() != null){
            EscherContainerRecord spContainer = shape.getEscherContainer();
            int shapeId = getPatriarch().newShapeId();
            shape.setShapeId(shapeId);
            getEscherContainer().addChildRecord(spContainer);
            shape.afterInsert(getPatriarch());
            EscherSpRecord sp;
            if (shape instanceof HSSFShapeGroup){
                sp = shape.getEscherContainer().getChildContainers().get(0).getChildById(EscherSpRecord.RECORD_ID);
            } else {
                sp = shape.getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
            }
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_CHILD);
        }
    }

    
    public HSSFShapeGroup createGroup(HSSFChildAnchor anchor) {
        HSSFShapeGroup group = new HSSFShapeGroup(this, anchor);
        group.setParent(this);
        group.setAnchor(anchor);
        shapes.add(group);
        onCreate(group);
        return group;
    }

    public void addShape(HSSFShape shape) {
        shape.setPatriarch(this.getPatriarch());
        shape.setParent(this);
        shapes.add(shape);
    }

    
    public HSSFSimpleShape createShape(HSSFChildAnchor anchor) {
        HSSFSimpleShape shape = new HSSFSimpleShape(this, anchor);
        shape.setParent(this);
        shape.setAnchor(anchor);
        shapes.add(shape);
        onCreate(shape);
        EscherSpRecord sp = shape.getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        if (shape.getAnchor().isHorizontallyFlipped()){
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);
        }
        if (shape.getAnchor().isVerticallyFlipped()){
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);
        }
        return shape;
    }

    
    public HSSFTextbox createTextbox(HSSFChildAnchor anchor) {
        HSSFTextbox shape = new HSSFTextbox(this, anchor);
        shape.setParent(this);
        shape.setAnchor(anchor);
        shapes.add(shape);
        onCreate(shape);
        return shape;
    }

    
    public HSSFPolygon createPolygon(HSSFChildAnchor anchor) {
        HSSFPolygon shape = new HSSFPolygon(this, anchor);
        shape.setParent(this);
        shape.setAnchor(anchor);
        shapes.add(shape);
        onCreate(shape);
        return shape;
    }

    
    public HSSFPicture createPicture(HSSFChildAnchor anchor, int pictureIndex) {
        HSSFPicture shape = new HSSFPicture(this, anchor);
        shape.setParent(this);
        shape.setAnchor(anchor);
        shape.setPictureIndex(pictureIndex);
        shapes.add(shape);
        onCreate(shape);
        EscherSpRecord sp = shape.getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        if (shape.getAnchor().isHorizontallyFlipped()){
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);
        }
        if (shape.getAnchor().isVerticallyFlipped()){
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);
        }
        return shape;
    }

    
    public List<HSSFShape> getChildren() {
        return Collections.unmodifiableList(shapes);
    }

    
    public void setCoordinates(int x1, int y1, int x2, int y2) {
        _spgrRecord.setRectX1(x1);
        _spgrRecord.setRectX2(x2);
        _spgrRecord.setRectY1(y1);
        _spgrRecord.setRectY2(y2);
    }

    public void clear() {
        ArrayList <HSSFShape> copy = new ArrayList<HSSFShape>(shapes);
        for (HSSFShape shape: copy){
            removeShape(shape);
        }
    }

    
    public int getX1() {
        return _spgrRecord.getRectX1();
    }

    
    public int getY1() {
        return _spgrRecord.getRectY1();
    }

    
    public int getX2() {
        return _spgrRecord.getRectX2();
    }

    
    public int getY2() {
        return _spgrRecord.getRectY2();
    }

    
    public int countOfAllChildren() {
        int count = shapes.size();
        for (Iterator<HSSFShape> iterator = shapes.iterator(); iterator.hasNext(); ) {
            HSSFShape shape = iterator.next();
            count += shape.countOfAllChildren();
        }
        return count;
    }

    @Override
    void afterInsert(HSSFPatriarch patriarch){
        EscherAggregate agg = patriarch._getBoundAggregate();
        EscherContainerRecord containerRecord = getEscherContainer().getChildById(EscherContainerRecord.SP_CONTAINER);
        agg.associateShapeToObjRecord(containerRecord.getChildById(EscherClientDataRecord.RECORD_ID), getObjRecord());
    }

    @Override
    void setShapeId(int shapeId){
        EscherContainerRecord containerRecord = getEscherContainer().getChildById(EscherContainerRecord.SP_CONTAINER);
        EscherSpRecord spRecord = containerRecord.getChildById(EscherSpRecord.RECORD_ID);
        spRecord.setShapeId(shapeId);
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) getObjRecord().getSubRecords().get(0);
        cod.setObjectId((short) (shapeId % 1024));
    }

    @Override
    int getShapeId(){
        EscherContainerRecord containerRecord = getEscherContainer().getChildById(EscherContainerRecord.SP_CONTAINER);
        return ((EscherSpRecord)containerRecord.getChildById(EscherSpRecord.RECORD_ID)).getShapeId();
    }

    @Override
    protected HSSFShape cloneShape() {
        throw new IllegalStateException(""Use method cloneShape(HSSFPatriarch patriarch)"");
    }

    protected HSSFShape cloneShape(HSSFPatriarch patriarch) {
        EscherContainerRecord spgrContainer = new EscherContainerRecord();
        spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);
        spgrContainer.setOptions((short) 0x000F);
        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherContainerRecord cont = getEscherContainer().getChildById(EscherContainerRecord.SP_CONTAINER);
        byte [] inSp = cont.serialize();
        spContainer.fillFields(inSp, 0, new DefaultEscherRecordFactory());

        spgrContainer.addChildRecord(spContainer);
        ObjRecord obj = null;
        if (null != getObjRecord()){
            obj = (ObjRecord) getObjRecord().cloneViaReserialise();
        }

        HSSFShapeGroup group = new HSSFShapeGroup(spgrContainer, obj);
        group.setPatriarch(patriarch);

        for (HSSFShape shape: getChildren()){
            HSSFShape newShape;
            if (shape instanceof HSSFShapeGroup){
                newShape = ((HSSFShapeGroup)shape).cloneShape(patriarch);
            } else {
                newShape = shape.cloneShape();
            }
            group.addShape(newShape);
            group.onCreate(newShape);
        }
        return group;
    }

    public boolean removeShape(HSSFShape shape) {
        boolean  isRemoved = getEscherContainer().removeChildRecord(shape.getEscherContainer());
        if (isRemoved){
            shape.afterRemove(this.getPatriarch());
            shapes.remove(shape);
        }
        return isRemoved;
    }

    public Iterator<HSSFShape> iterator() {
        return shapes.iterator();
    }
}
"
poi,3,org.apache.poi.hssf.record.CodepageRecord,10,2,0,6,19,39,2,4,8,0.925925926,92,0.333333333,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.LittleEndianOutput;



public final class CodepageRecord
    extends StandardRecord
{
    public final static short sid = 0x42;
    private short             field_1_codepage;   

    
    public final static short CODEPAGE = ( short ) 0x4b0;

    public CodepageRecord()
    {
    }

    public CodepageRecord(RecordInputStream in)
    {
        field_1_codepage = in.readShort();
    }

    

    public void setCodepage(short cp)
    {
        field_1_codepage = cp;
    }

    

    public short getCodepage()
    {
        return field_1_codepage;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CODEPAGE]
"");
        buffer.append(""    .codepage        = "")
            .append(Integer.toHexString(getCodepage())).append(""
"");
        buffer.append(""[/CODEPAGE]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getCodepage());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.ddf.EscherSplitMenuColorsRecord,15,2,0,7,33,43,1,6,15,0.833333333,258,0.666666667,0,0.575757576,0.333333333,1,5,15.8,2,1.0,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.RecordFormatException;


public class EscherSplitMenuColorsRecord
    extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF11E;
    public static final String RECORD_DESCRIPTION = ""MsofbtSplitMenuColors"";

    private int field_1_color1;
    private int field_2_color2;
    private int field_3_color3;
    private int field_4_color4;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;
        field_1_color1 =  LittleEndian.getInt( data, pos + size );size+=4;
        field_2_color2 =  LittleEndian.getInt( data, pos + size );size+=4;
        field_3_color3 =  LittleEndian.getInt( data, pos + size );size+=4;
        field_4_color4 =  LittleEndian.getInt( data, pos + size );size+=4;
        bytesRemaining -= size;
        if (bytesRemaining != 0)
            throw new RecordFormatException(""Expecting no remaining data but got "" + bytesRemaining + "" byte(s)."");
        return 8 + size + bytesRemaining;
    }

    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {

        listener.beforeRecordSerialize( offset, getRecordId(), this );

        int pos = offset;
        LittleEndian.putShort( data, pos, getOptions() );     pos += 2;
        LittleEndian.putShort( data, pos, getRecordId() );    pos += 2;
        int remainingBytes =  getRecordSize() - 8;

        LittleEndian.putInt( data, pos, remainingBytes );          pos += 4;
        LittleEndian.putInt( data, pos, field_1_color1 );          pos += 4;
        LittleEndian.putInt( data, pos, field_2_color2 );          pos += 4;
        LittleEndian.putInt( data, pos, field_3_color3 );          pos += 4;
        LittleEndian.putInt( data, pos, field_4_color4 );          pos += 4;
        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        return getRecordSize();
    }

    public int getRecordSize()
    {
        return 8 + 4 * 4;
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""SplitMenuColors"";
    }

    
    public String toString() {
        return getClass().getName() + "":"" + '
' +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + '
' +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + '
' +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + '
' +
                ""  Color1: 0x"" + HexDump.toHex(field_1_color1) + '
' +
                ""  Color2: 0x"" + HexDump.toHex(field_2_color2) + '
' +
                ""  Color3: 0x"" + HexDump.toHex(field_3_color3) + '
' +
                ""  Color4: 0x"" + HexDump.toHex(field_4_color4) + '
' +
                """";
    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<Color1>0x"").append(HexDump.toHex(field_1_color1)).append(""</Color1>
"")
                .append(tab).append(""	"").append(""<Color2>0x"").append(HexDump.toHex(field_2_color2)).append(""</Color2>
"")
                .append(tab).append(""	"").append(""<Color3>0x"").append(HexDump.toHex(field_3_color3)).append(""</Color3>
"")
                .append(tab).append(""	"").append(""<Color4>0x"").append(HexDump.toHex(field_4_color4)).append(""</Color4>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    public int getColor1()
    {
        return field_1_color1;
    }

    public void setColor1( int field_1_color1 )
    {
        this.field_1_color1 = field_1_color1;
    }

    public int getColor2()
    {
        return field_2_color2;
    }

    public void setColor2( int field_2_color2 )
    {
        this.field_2_color2 = field_2_color2;
    }

    public int getColor3()
    {
        return field_3_color3;
    }

    public void setColor3( int field_3_color3 )
    {
        this.field_3_color3 = field_3_color3;
    }

    public int getColor4()
    {
        return field_4_color4;
    }

    public void setColor4( int field_4_color4 )
    {
        this.field_4_color4 = field_4_color4;
    }

}
"
poi,3,org.apache.poi.util.HexRead,6,1,0,1,27,15,1,0,5,2.0,264,0.0,0,0.0,0.291666667,0,0,43.0,1,0.8333,0,"

package org.apache.poi.util;

import java.io.*;
import java.util.List;
import java.util.ArrayList;


public class HexRead
{
    
    public static byte[] readData( String filename ) throws IOException
    {
        File file = new File( filename );
        FileInputStream stream = new FileInputStream( file );
        try
        {
            return readData( stream, -1 );
        }
        finally
        {
            stream.close();
        }
    }

    
    public static byte[] readData(InputStream stream, String section ) throws IOException {

        try
        {
            StringBuffer sectionText = new StringBuffer();
            boolean inSection = false;
            int c = stream.read();
            while ( c != -1 )
            {
                switch ( c )
                {
                    case '[':
                        inSection = true;
                        break;
                    case '
':
                    case '
':
                        inSection = false;
                        sectionText = new StringBuffer();
                        break;
                    case ']':
                        inSection = false;
                        if ( sectionText.toString().equals( section ) ) return readData( stream, '[' );
                        sectionText = new StringBuffer();
                        break;
                    default:
                        if ( inSection ) sectionText.append( (char) c );
                }
                c = stream.read();
            }
        }
        finally
        {
            stream.close();
        }
        throw new IOException( ""Section '"" + section + ""' not found"" );
    }
    public static byte[] readData( String filename, String section ) throws IOException
    {
        File file = new File( filename );
        FileInputStream stream = new FileInputStream( file );
        return readData(stream, section);
    }

    static public byte[] readData( InputStream stream, int eofChar )
            throws IOException
    {
        int characterCount = 0;
        byte b = (byte) 0;
        List<Byte> bytes = new ArrayList<Byte>();
        boolean done = false;
        while ( !done )
        {
            int count = stream.read();
            char baseChar = 'a';
            if ( count == eofChar ) break;
            switch ( count )
            {
                case '#':
                    readToEOL( stream );
                    break;
                case '0': case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
                    b <<= 4;
                    b += (byte) ( count - '0' );
                    characterCount++;
                    if ( characterCount == 2 )
                    {
                        bytes.add( Byte.valueOf( b ) );
                        characterCount = 0;
                        b = (byte) 0;
                    }
                    break;
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                    baseChar = 'A';
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                    b <<= 4;
                    b += (byte) ( count + 10 - baseChar );
                    characterCount++;
                    if ( characterCount == 2 )
                    {
                        bytes.add( Byte.valueOf( b ) );
                        characterCount = 0;
                        b = (byte) 0;
                    }
                    break;
                case -1:
                    done = true;
                    break;
                default :
                    break;
            }
        }
        Byte[] polished = bytes.toArray( new Byte[0] );
        byte[] rval = new byte[polished.length];
        for ( int j = 0; j < polished.length; j++ )
        {
            rval[j] = polished[j].byteValue();
        }
        return rval;
    }

    static public byte[] readFromString(String data) {
        try {
            return readData(new ByteArrayInputStream( data.getBytes() ), -1);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    static private void readToEOL( InputStream stream ) throws IOException
    {
        int c = stream.read();
        while ( c != -1 && c != '
' && c != '
' )
        {
            c = stream.read();
        }
    }
}
"
poi,3,org.apache.poi.ddf.EscherRecord,20,1,14,37,36,164,36,4,18,0.842105263,141,1.0,0,0.0,0.2375,0,0,5.95,2,1.05,2,"


package org.apache.poi.ddf;

import java.io.PrintWriter;
import java.util.Collections;
import java.util.List;

import org.apache.poi.util.*;


public abstract class EscherRecord {
    private static BitField fInstance = BitFieldFactory.getInstance(0xfff0);
    private static BitField fVersion = BitFieldFactory.getInstance(0x000f);

    private short _options;
    private short _recordId;

    
    public EscherRecord() {
        
    }

    
    protected int fillFields( byte[] data, EscherRecordFactory f )
    {
        return fillFields( data, 0, f );
    }

    
    public abstract int fillFields( byte[] data, int offset, EscherRecordFactory recordFactory );

    
    protected int readHeader( byte[] data, int offset )
    {
        _options = LittleEndian.getShort( data, offset );
        _recordId = LittleEndian.getShort( data, offset + 2 );
        int remainingBytes = LittleEndian.getInt( data, offset + 4 );
        return remainingBytes;
    }

    
    protected static short readInstance( byte data[], int offset )
    {
        final short options = LittleEndian.getShort( data, offset );
        return fInstance.getShortValue( options );
    }

    
    public boolean isContainerRecord() {
        return getVersion() == (short)0x000f;
    }

    
    @Internal
    public short getOptions()
    {
        return _options;
    }

    
    @Internal
    public void setOptions( short options ) {
        
        setVersion( fVersion.getShortValue( options ) );
        setInstance( fInstance.getShortValue( options ) );
        _options = options;
    }

    
    public byte[] serialize()
    {
        byte[] retval = new byte[getRecordSize()];

        serialize( 0, retval );
        return retval;
    }

    
    public int serialize( int offset, byte[] data)
    {
        return serialize( offset, data, new NullEscherSerializationListener() );
    }

    
    public abstract int serialize( int offset, byte[] data, EscherSerializationListener listener );

    
    abstract public int getRecordSize();

    
    public short getRecordId() {
        return _recordId;
    }

    
    public void setRecordId( short recordId ) {
        _recordId = recordId;
    }

    
    public List<EscherRecord> getChildRecords() { return Collections.emptyList(); }

    
    public void setChildRecords(List<EscherRecord> childRecords) {
        throw new UnsupportedOperationException(""This record does not support child records."");
    }

    
    public Object clone()
    {
        throw new RuntimeException( ""The class "" + getClass().getName() + "" needs to define a clone method"" );
    }

    
    public EscherRecord getChild( int index ) {
        return getChildRecords().get(index);
    }

    
    public void display(PrintWriter w, int indent)
    {
        for (int i = 0; i < indent * 4; i++) w.print(' ');
        w.println(getRecordName());
    }

    
    public abstract String getRecordName();

    
    public short getInstance()
    {
        return fInstance.getShortValue( _options );
    }

    
    public void setInstance( short value )
    {
        _options = fInstance.setShortValue( _options, value );
    }

    
    public short getVersion()
    {
        return fVersion.getShortValue( _options );
    }

    
    public void setVersion( short value )
    {
        _options = fVersion.setShortValue( _options, value );
    }

    
    public String toXml(String tab){
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("">
"")
                .append(tab).append(""	"").append(""<RecordId>0x"").append(HexDump.toHex(_recordId)).append(""</RecordId>
"")
                .append(tab).append(""	"").append(""<Options>"").append(_options).append(""</Options>
"")
                .append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }
    
    protected String formatXmlRecordHeader(String className, String recordId, String version, String instance){
        StringBuilder builder = new StringBuilder();
        builder.append(""<"").append(className).append("" recordId=""0x"").append(recordId).append("""" version=""0x"")
                .append(version).append("""" instance=""0x"").append(instance).append("""" size="""").append(getRecordSize()).append("""">
"");
        return builder.toString();
    }
    
    public String toXml(){
        return toXml("""");
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFRow,27,1,0,9,54,107,4,6,18,0.711538462,515,0.833333333,4,0.0,0.148148148,0,0,17.85185185,7,1.963,4,"

package org.apache.poi.hssf.usermodel;

import java.util.Iterator;
import java.util.NoSuchElementException;

import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.ExtendedFormatRecord;
import org.apache.poi.hssf.record.RowRecord;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.util.Configurator;


public final class HSSFRow implements Row {

    
    public final static int INITIAL_CAPACITY = Configurator.getIntValue(""HSSFRow.ColInitialCapacity"", 5);

    private int rowNum;
    private HSSFCell[] cells;

    
    private RowRecord row;

    
    private HSSFWorkbook book;

    
    private HSSFSheet sheet;

    
    HSSFRow(HSSFWorkbook book, HSSFSheet sheet, int rowNum) {
        this(book, sheet, new RowRecord(rowNum));
    }

    
    HSSFRow(HSSFWorkbook book, HSSFSheet sheet, RowRecord record) {
        this.book = book;
        this.sheet = sheet;
        row = record;
        setRowNum(record.getRowNumber());
        
        
        
        
        cells = new HSSFCell[record.getLastCol()+INITIAL_CAPACITY];
        
        
        
        record.setEmpty();
        
    }

    
    public HSSFCell createCell(short columnIndex) {
        return createCell((int)columnIndex);
    }
    
    public HSSFCell createCell(short columnIndex, int type) {
        return createCell((int)columnIndex, type);
    }
    
    public HSSFCell createCell(int column)
    {
        return this.createCell(column,HSSFCell.CELL_TYPE_BLANK);
    }

    
    public HSSFCell createCell(int columnIndex, int type)
    {
        short shortCellNum = (short)columnIndex;
        if(columnIndex > 0x7FFF) {
            shortCellNum = (short)(0xffff - columnIndex);
        }

        HSSFCell cell = new HSSFCell(book, sheet, getRowNum(), shortCellNum, type);
        addCell(cell);
        sheet.getSheet().addValueRecord(getRowNum(), cell.getCellValueRecord());
        return cell;
    }

    
    public void removeCell(Cell cell) {
        if(cell == null) {
            throw new IllegalArgumentException(""cell must not be null"");
        }
        removeCell((HSSFCell)cell, true);
    }
    private void removeCell(HSSFCell cell, boolean alsoRemoveRecords) {

        int column=cell.getColumnIndex();
        if(column < 0) {
            throw new RuntimeException(""Negative cell indexes not allowed"");
        }
        if(column >= cells.length || cell != cells[column]) {
            throw new RuntimeException(""Specified cell is not from this row"");
        }
        if(cell.isPartOfArrayFormulaGroup()){
            cell.notifyArrayFormulaChanging();
        }

        cells[column]=null;

        if(alsoRemoveRecords) {
            CellValueRecordInterface cval = cell.getCellValueRecord();
            sheet.getSheet().removeValueRecord(getRowNum(), cval);
        }
        if (cell.getColumnIndex()+1 == row.getLastCol()) {
            row.setLastCol(calculateNewLastCellPlusOne(row.getLastCol()));
        }
        if (cell.getColumnIndex() == row.getFirstCol()) {
            row.setFirstCol(calculateNewFirstCell(row.getFirstCol()));
        }
    }

    
    protected void removeAllCells() {
        for(int i=0; i<cells.length; i++) {
            if(cells[i] != null) {
                removeCell(cells[i], true);
            }
        }
        cells=new HSSFCell[INITIAL_CAPACITY];
    }

    
    HSSFCell createCellFromRecord(CellValueRecordInterface cell) {
        HSSFCell hcell = new HSSFCell(book, sheet, cell);

        addCell(hcell);
        int colIx = cell.getColumn();
        if (row.isEmpty()) {
            row.setFirstCol(colIx);
            row.setLastCol(colIx + 1);
        } else {
            if (colIx < row.getFirstCol()) {
                row.setFirstCol(colIx);
            } else if (colIx > row.getLastCol()) {
                row.setLastCol(colIx + 1);
            } else {
                
            }
        }
        
        return hcell;
    }

    
    public void setRowNum(int rowIndex) {
        int maxrow = SpreadsheetVersion.EXCEL97.getLastRowIndex();
        if ((rowIndex < 0) || (rowIndex > maxrow)) {
          throw new IllegalArgumentException(""Invalid row number ("" + rowIndex
                  + "") outside allowable range (0.."" + maxrow + "")"");
        }
        rowNum = rowIndex;
        if (row != null) {
            row.setRowNumber(rowIndex);   
        }
    }

    
    public int getRowNum()
    {
        return rowNum;
    }

    
    public HSSFSheet getSheet()
    {
        return sheet;
    }

    
    public int getOutlineLevel() {
        return row.getOutlineLevel();
    }

    
    public void moveCell(HSSFCell cell, short newColumn) {
        
        if(cells.length > newColumn && cells[newColumn] != null) {
            throw new IllegalArgumentException(""Asked to move cell to column "" + newColumn + "" but there's already a cell there"");
        }

        
        if(! cells[cell.getColumnIndex()].equals(cell)) {
            throw new IllegalArgumentException(""Asked to move a cell, but it didn't belong to our row"");
        }

        
        
        removeCell(cell, false);
        cell.updateCellNum(newColumn);
        addCell(cell);
    }

    
    private void addCell(HSSFCell cell) {

        int column=cell.getColumnIndex();
        
        if(column>=cells.length) {
            HSSFCell[] oldCells=cells;
            
            int newSize=oldCells.length*3/2+1;
            if(newSize<column+1) {
                newSize=column+INITIAL_CAPACITY;
            }
            cells=new HSSFCell[newSize];
            System.arraycopy(oldCells,0,cells,0,oldCells.length);
        }
        cells[column]=cell;

        
        if (row.isEmpty() || column < row.getFirstCol()) {
            row.setFirstCol((short)column);
        }

        if (row.isEmpty() || column >= row.getLastCol()) {
            row.setLastCol((short) (column+1)); 
        }
    }

    
    private HSSFCell retrieveCell(int cellIndex) {
        if(cellIndex<0||cellIndex>=cells.length) {
            return null;
        }
        return cells[cellIndex];
    }

    
    public HSSFCell getCell(short cellnum) {
        int ushortCellNum = cellnum & 0x0000FFFF; 
        return getCell(ushortCellNum);
    }

    
    public HSSFCell getCell(int cellnum) {
        return getCell(cellnum, book.getMissingCellPolicy());
    }

    
    public HSSFCell getCell(int cellnum, MissingCellPolicy policy) {
        HSSFCell cell = retrieveCell(cellnum);
        if(policy == RETURN_NULL_AND_BLANK) {
            return cell;
        }
        if(policy == RETURN_BLANK_AS_NULL) {
            if(cell == null) return cell;
            if(cell.getCellType() == HSSFCell.CELL_TYPE_BLANK) {
                return null;
            }
            return cell;
        }
        if(policy == CREATE_NULL_AS_BLANK) {
            if(cell == null) {
                return createCell(cellnum, HSSFCell.CELL_TYPE_BLANK);
            }
            return cell;
        }
        throw new IllegalArgumentException(""Illegal policy "" + policy + "" ("" + policy.id + "")"");
    }

    
    public short getFirstCellNum() {
        if (row.isEmpty()) {
            return -1;
        }
        return (short) row.getFirstCol();
    }

    
    public short getLastCellNum() {
        if (row.isEmpty()) {
            return -1;
        }
        return (short) row.getLastCol();
    }


    

    public int getPhysicalNumberOfCells()
    {
      int count=0;
      for(int i=0;i<cells.length;i++)
      {
        if(cells[i]!=null) count++;
      }
      return count;
    }

    

    public void setHeight(short height)
    {
        if(height == -1){
            row.setHeight((short)(0xFF | 0x8000));
            row.setBadFontHeight(false);
        } else {
            row.setBadFontHeight(true);
            row.setHeight(height);
        }
    }

    
    public void setZeroHeight(boolean zHeight) {
        row.setZeroHeight(zHeight);
    }

    
    public boolean getZeroHeight() {
        return row.getZeroHeight();
    }

    

    public void setHeightInPoints(float height)
    {
        if(height == -1){
            row.setHeight((short)(0xFF | 0x8000));
        } else {
            row.setBadFontHeight(true);
            row.setHeight((short) (height * 20));
        }
    }

    

    public short getHeight()
    {
        short height = row.getHeight();

        
        
        if ((height & 0x8000) != 0) height = sheet.getSheet().getDefaultRowHeight();
        else height &= 0x7FFF;

        return height;
    }

    

    public float getHeightInPoints()
    {
        return ((float)getHeight() / 20);
    }

    

    protected RowRecord getRowRecord()
    {
        return row;
    }

    
    private int calculateNewLastCellPlusOne(int lastcell) {
        int cellIx = lastcell - 1;
        HSSFCell r = retrieveCell(cellIx);

        while (r == null) {
            if (cellIx < 0) {
                return 0;
            }
            r = retrieveCell(--cellIx);
        }
        return cellIx+1;
    }

    
    private int calculateNewFirstCell(int firstcell) {
        int cellIx = firstcell + 1;
        HSSFCell r = retrieveCell(cellIx);

        while (r == null) {
            if (cellIx <= cells.length) {
                return 0;
            }
            r = retrieveCell(++cellIx);
        }
        return cellIx;
    }

    
    public boolean isFormatted() {
        return row.getFormatted();
    }
    
    public HSSFCellStyle getRowStyle() {
        if(!isFormatted()) { return null; }
        short styleIndex = row.getXFIndex();
        ExtendedFormatRecord xf = book.getWorkbook().getExFormatAt(styleIndex);
        return new HSSFCellStyle(styleIndex, xf, book);
    }
    
    public void setRowStyle(HSSFCellStyle style) {
        row.setFormatted(true);
        row.setXFIndex(style.getIndex());
    }
    
    public void setRowStyle(CellStyle style) {
        setRowStyle((HSSFCellStyle)style);
    }

    
    public Iterator<Cell> cellIterator()
    {
      return new CellIterator();
    }
    
    public Iterator<Cell> iterator() {
       return cellIterator();
    }

    
    private class CellIterator implements Iterator<Cell> {
      int thisId=-1;
      int nextId=-1;

      public CellIterator()
      {
        findNext();
      }

      public boolean hasNext() {
        return nextId<cells.length;
      }

      public Cell next() {
          if (!hasNext())
              throw new NoSuchElementException(""At last element"");
        HSSFCell cell=cells[nextId];
        thisId=nextId;
        findNext();
        return cell;
      }

      public void remove() {
          if (thisId == -1)
              throw new IllegalStateException(""remove() called before next()"");
        cells[thisId]=null;
      }

      private void findNext()
      {
        int i=nextId+1;
        for(;i<cells.length;i++)
        {
          if(cells[i]!=null) break;
        }
        nextId=i;
      }

    }

    public int compareTo(Object obj)
    {
        HSSFRow loc = (HSSFRow) obj;

        if (this.getRowNum() == loc.getRowNum())
        {
            return 0;
        }
        if (this.getRowNum() < loc.getRowNum())
        {
            return -1;
        }
        if (this.getRowNum() > loc.getRowNum())
        {
            return 1;
        }
        return -1;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (!(obj instanceof HSSFRow))
        {
            return false;
        }
        HSSFRow loc = (HSSFRow) obj;

        if (this.getRowNum() == loc.getRowNum())
        {
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        assert false : ""hashCode not designed"";
        return 42; 
    }
}
"
poi,3,org.apache.poi.hpsf.IllegalVariantTypeException,2,5,0,3,9,1,0,3,2,2.0,33,0.0,0,1.0,0.875,0,0,15.5,0,0.0,0,"

package org.apache.poi.hpsf;

import org.apache.poi.util.HexDump;


public class IllegalVariantTypeException extends VariantTypeException
{

    
    public IllegalVariantTypeException(final long variantType,
                                       final Object value, final String msg)
    {
        super(variantType, value, msg);
    }

    
    public IllegalVariantTypeException(final long variantType,
                                       final Object value)
    {
        this(variantType, value, ""The variant type "" + variantType + "" ("" +
             Variant.getVariantName(variantType) + "", "" + 
             HexDump.toHex(variantType) + "") is illegal in this context."");
    }

}
"
poi,3,org.apache.poi.poifs.eventfilesystem.POIFSReaderListener,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.eventfilesystem;



public interface POIFSReaderListener
{

    

    public void processPOIFSReaderEvent(POIFSReaderEvent event);
}   

"
poi,3,org.apache.poi.hssf.model.TextboxShape,8,2,1,21,59,20,3,19,4,0.821428571,267,1.0,4,0.416666667,0.666666667,1,1,31.875,1,0.875,2,"


package org.apache.poi.hssf.model;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.usermodel.*;


@Deprecated
public class TextboxShape
        extends AbstractShape
{
    private EscherContainerRecord spContainer;
    private TextObjectRecord textObjectRecord;
    private ObjRecord objRecord;
    private EscherTextboxRecord escherTextbox;

    
    TextboxShape( HSSFTextbox hssfShape, int shapeId )
    {
        spContainer = createSpContainer( hssfShape, shapeId );
        objRecord = createObjRecord( hssfShape, shapeId );
        textObjectRecord = createTextObjectRecord( hssfShape, shapeId );
    }

    
    private ObjRecord createObjRecord( HSSFTextbox hssfShape, int shapeId )
    {
        HSSFShape shape = hssfShape;

        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType( (short) ( (HSSFSimpleShape) shape ).getShapeType() );
        c.setObjectId( getCmoObjectId(shapeId) );
        c.setLocked( true );
        c.setPrintable( true );
        c.setAutofill( true );
        c.setAutoline( true );
        EndSubRecord e = new EndSubRecord();

        obj.addSubRecord( c );
        obj.addSubRecord( e );

        return obj;
    }

    
    private EscherContainerRecord createSpContainer( HSSFTextbox hssfShape, int shapeId )
    {
        HSSFTextbox shape = hssfShape;

        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherRecord anchor = new EscherClientAnchorRecord();
        EscherClientDataRecord clientData = new EscherClientDataRecord();
        escherTextbox = new EscherTextboxRecord();

        spContainer.setRecordId( EscherContainerRecord.SP_CONTAINER );
        spContainer.setOptions( (short) 0x000F );
        sp.setRecordId( EscherSpRecord.RECORD_ID );
        sp.setOptions( (short) ( ( EscherAggregate.ST_TEXTBOX << 4 ) | 0x2 ) );

        sp.setShapeId( shapeId );
        sp.setFlags( EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        opt.setRecordId( EscherOptRecord.RECORD_ID );
        
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__TEXTID, 0 ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__TEXTLEFT, shape.getMarginLeft() ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__TEXTRIGHT, shape.getMarginRight() ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__TEXTBOTTOM, shape.getMarginBottom() ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__TEXTTOP, shape.getMarginTop() ) );

        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__WRAPTEXT, 0 ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.TEXT__ANCHORTEXT, 0 ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.GROUPSHAPE__PRINT, 0x00080000 ) );

        addStandardOptions( shape, opt );
        HSSFAnchor userAnchor = shape.getAnchor();
        
        
        
        
        anchor = createAnchor( userAnchor );
        clientData.setRecordId( EscherClientDataRecord.RECORD_ID );
        clientData.setOptions( (short) 0x0000 );
        escherTextbox.setRecordId( EscherTextboxRecord.RECORD_ID );
        escherTextbox.setOptions( (short) 0x0000 );

        spContainer.addChildRecord( sp );
        spContainer.addChildRecord( opt );
        spContainer.addChildRecord( anchor );
        spContainer.addChildRecord( clientData );
        spContainer.addChildRecord( escherTextbox );

        return spContainer;
    }

    
    private TextObjectRecord createTextObjectRecord( HSSFTextbox hssfShape, int shapeId )
    {
        HSSFTextbox shape = hssfShape;

        TextObjectRecord obj = new TextObjectRecord();
        obj.setHorizontalTextAlignment(hssfShape.getHorizontalAlignment());
        obj.setVerticalTextAlignment(hssfShape.getVerticalAlignment());
        obj.setTextLocked(true);
        obj.setTextOrientation(TextObjectRecord.TEXT_ORIENTATION_NONE);
        obj.setStr(shape.getString());

        return obj;
    }

    public EscherContainerRecord getSpContainer()
    {
        return spContainer;
    }

    public ObjRecord getObjRecord()
    {
        return objRecord;
    }

    public TextObjectRecord getTextObjectRecord()
    {
        return textObjectRecord;
    }

    public EscherRecord getEscherTextbox()
    {
        return escherTextbox;
    }

}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFPatriarch,14,1,0,12,29,1,2,11,13,0.794871795,193,0.0,1,0.0,0.328571429,0,0,12.35714286,2,1.0,1,"

package org.apache.poi.hssf.usermodel;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.poi.ddf.EscherComplexProperty;
import org.apache.poi.ddf.EscherContainerRecord;
import org.apache.poi.ddf.EscherDgRecord;
import org.apache.poi.ddf.EscherOptRecord;
import org.apache.poi.ddf.EscherProperty;
import org.apache.poi.ddf.EscherSpRecord;
import org.apache.poi.ddf.EscherSpgrRecord;
import org.apache.poi.hssf.model.DrawingManager2;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.EmbeddedObjectRefSubRecord;
import org.apache.poi.hssf.record.EndSubRecord;
import org.apache.poi.hssf.record.EscherAggregate;
import org.apache.poi.hssf.record.FtCfSubRecord;
import org.apache.poi.hssf.record.FtPioGrbitSubRecord;
import org.apache.poi.hssf.record.NoteRecord;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.hssf.util.CellReference;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.ss.usermodel.Chart;
import org.apache.poi.ss.usermodel.ClientAnchor;
import org.apache.poi.ss.usermodel.Drawing;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.Internal;
import org.apache.poi.util.StringUtil;


public final class HSSFPatriarch implements HSSFShapeContainer, Drawing {
    
    private final List<HSSFShape> _shapes = new ArrayList<HSSFShape>();

    private final EscherSpgrRecord _spgrRecord;
    private final EscherContainerRecord _mainSpgrContainer;

    
    private EscherAggregate _boundAggregate;
    private final HSSFSheet _sheet;

    
    HSSFPatriarch(HSSFSheet sheet, EscherAggregate boundAggregate) {
        _sheet = sheet;
        _boundAggregate = boundAggregate;
        _mainSpgrContainer = _boundAggregate.getEscherContainer().getChildContainers().get(0);
        EscherContainerRecord spContainer = (EscherContainerRecord) _boundAggregate.getEscherContainer()
                .getChildContainers().get(0).getChild(0);
        _spgrRecord = spContainer.getChildById(EscherSpgrRecord.RECORD_ID);
        buildShapeTree();
    }

    
    static HSSFPatriarch createPatriarch(HSSFPatriarch patriarch, HSSFSheet sheet){
        HSSFPatriarch newPatriarch = new HSSFPatriarch(sheet, new EscherAggregate(true));
        newPatriarch.afterCreate();
        for (HSSFShape shape: patriarch.getChildren()){
            HSSFShape newShape;
            if (shape instanceof HSSFShapeGroup){
                newShape = ((HSSFShapeGroup)shape).cloneShape(newPatriarch);
            } else {
                newShape = shape.cloneShape();
            }
            newPatriarch.onCreate(newShape);
            newPatriarch.addShape(newShape);
        }
        return newPatriarch;
    }

    
    protected void preSerialize(){
        Map<Integer, NoteRecord> tailRecords = _boundAggregate.getTailRecords();
        
        Set<String> coordinates = new HashSet<String>(tailRecords.size());
        for(NoteRecord rec : tailRecords.values()){
            String noteRef = new CellReference(rec.getRow(),
                    rec.getColumn()).formatAsString(); 
            if(coordinates.contains(noteRef )){
                throw new IllegalStateException(""found multiple cell comments for cell "" + noteRef );
            } else {
                coordinates.add(noteRef);
            }
        }
    }

    
    public boolean removeShape(HSSFShape shape) {
        boolean  isRemoved = _mainSpgrContainer.removeChildRecord(shape.getEscherContainer());
        if (isRemoved){
            shape.afterRemove(this);
            _shapes.remove(shape);
        }
        return isRemoved;
    }

    void afterCreate() {
        DrawingManager2 drawingManager = _sheet.getWorkbook().getWorkbook().getDrawingManager();
        short dgId = drawingManager.findNewDrawingGroupId();
        _boundAggregate.setDgId(dgId);
        _boundAggregate.setMainSpRecordId(newShapeId());
        drawingManager.incrementDrawingsSaved();
    }

    
    public HSSFShapeGroup createGroup(HSSFClientAnchor anchor) {
        HSSFShapeGroup group = new HSSFShapeGroup(null, anchor);
        addShape(group);
        onCreate(group);
        return group;
    }

    
    public HSSFSimpleShape createSimpleShape(HSSFClientAnchor anchor) {
        HSSFSimpleShape shape = new HSSFSimpleShape(null, anchor);
        addShape(shape);
        
        onCreate(shape);
        return shape;
    }

    
    public HSSFPicture createPicture(HSSFClientAnchor anchor, int pictureIndex) {
        HSSFPicture shape = new HSSFPicture(null, anchor);
        shape.setPictureIndex(pictureIndex);
        addShape(shape);
        
        onCreate(shape);
        return shape;
    }

    
    public HSSFPicture createPicture(ClientAnchor anchor, int pictureIndex) {
        return createPicture((HSSFClientAnchor) anchor, pictureIndex);
    }

    
    public HSSFObjectData createObjectData(HSSFClientAnchor anchor, int storageId, int pictureIndex) {
        ObjRecord obj = new ObjRecord();

        CommonObjectDataSubRecord ftCmo = new CommonObjectDataSubRecord();
        ftCmo.setObjectType(CommonObjectDataSubRecord.OBJECT_TYPE_PICTURE);
        
        ftCmo.setLocked(true);
        ftCmo.setPrintable(true);
        ftCmo.setAutofill(true);
        ftCmo.setAutoline(true);
        ftCmo.setReserved1(0);
        ftCmo.setReserved2(0);
        ftCmo.setReserved3(0);
        obj.addSubRecord(ftCmo);
        
        
        FtCfSubRecord ftCf = new FtCfSubRecord();
        HSSFPictureData pictData = getSheet().getWorkbook().getAllPictures().get(pictureIndex-1);
        switch (pictData.getFormat()) {
	        case HSSFWorkbook.PICTURE_TYPE_WMF:
	        case HSSFWorkbook.PICTURE_TYPE_EMF:
	        	
	            ftCf.setFlags(FtCfSubRecord.METAFILE_BIT);
	            break;
	        case HSSFWorkbook.PICTURE_TYPE_DIB:
	        case HSSFWorkbook.PICTURE_TYPE_PNG:
	        case HSSFWorkbook.PICTURE_TYPE_JPEG:
	        case HSSFWorkbook.PICTURE_TYPE_PICT:
	            ftCf.setFlags(FtCfSubRecord.BITMAP_BIT);
	            break;
        }
        obj.addSubRecord(ftCf);
        
        FtPioGrbitSubRecord ftPioGrbit = new FtPioGrbitSubRecord();
        ftPioGrbit.setFlagByBit(FtPioGrbitSubRecord.AUTO_PICT_BIT, true);
        obj.addSubRecord(ftPioGrbit);
        
        EmbeddedObjectRefSubRecord ftPictFmla = new EmbeddedObjectRefSubRecord();
        ftPictFmla.setUnknownFormulaData(new byte[]{2, 0, 0, 0, 0});
        ftPictFmla.setOleClassname(""Paket"");
        ftPictFmla.setStorageId(storageId);
        
        obj.addSubRecord(ftPictFmla);
        obj.addSubRecord(new EndSubRecord());

        String entryName = ""MBD""+HexDump.toHex(storageId);
        DirectoryEntry oleRoot;
        try {
            DirectoryNode dn = _sheet.getWorkbook().getRootDirectory();
        	if (dn == null) throw new FileNotFoundException();
        	oleRoot = (DirectoryEntry)dn.getEntry(entryName);
        } catch (FileNotFoundException e) {
        	throw new IllegalStateException(""trying to add ole shape without actually adding data first - use HSSFWorkbook.addOlePackage first"", e);
        }
        
        
        HSSFPicture shape = new HSSFPicture(null, anchor);
        shape.setPictureIndex(pictureIndex);
        EscherContainerRecord spContainer = shape.getEscherContainer();
        EscherSpRecord spRecord = spContainer.getChildById(EscherSpRecord.RECORD_ID);
        spRecord.setFlags(spRecord.getFlags() |  EscherSpRecord.FLAG_OLESHAPE);
        
        HSSFObjectData oleShape = new HSSFObjectData(spContainer, obj, oleRoot); 
        addShape(oleShape);
        onCreate(oleShape);
        
        
        return oleShape;
    }
    
    
    public HSSFPolygon createPolygon(HSSFClientAnchor anchor) {
        HSSFPolygon shape = new HSSFPolygon(null, anchor);
        addShape(shape);
        onCreate(shape);
        return shape;
    }

    
    public HSSFTextbox createTextbox(HSSFClientAnchor anchor) {
        HSSFTextbox shape = new HSSFTextbox(null, anchor);
        addShape(shape);
        onCreate(shape);
        return shape;
    }

    
    public HSSFComment createComment(HSSFAnchor anchor) {
        HSSFComment shape = new HSSFComment(null, anchor);
        addShape(shape);
        onCreate(shape);
        return shape;
    }

    
    HSSFSimpleShape createComboBox(HSSFAnchor anchor) {
        HSSFCombobox shape = new HSSFCombobox(null, anchor);
        addShape(shape);
        onCreate(shape);
        return shape;
    }

    public HSSFComment createCellComment(ClientAnchor anchor) {
        return createComment((HSSFAnchor) anchor);
    }

    
    public List<HSSFShape> getChildren() {
        return Collections.unmodifiableList(_shapes);
    }

    
    @Internal
    public void addShape(HSSFShape shape) {
        shape.setPatriarch(this);
        _shapes.add(shape);
    }

    private void onCreate(HSSFShape shape) {
        EscherContainerRecord spgrContainer =
                _boundAggregate.getEscherContainer().getChildContainers().get(0);

        EscherContainerRecord spContainer = shape.getEscherContainer();
        int shapeId = newShapeId();
        shape.setShapeId(shapeId);

        spgrContainer.addChildRecord(spContainer);
        shape.afterInsert(this);
        setFlipFlags(shape);
    }

    
    public int countOfAllChildren() {
        int count = _shapes.size();
        for (Iterator<HSSFShape> iterator = _shapes.iterator(); iterator.hasNext(); ) {
            HSSFShape shape = iterator.next();
            count += shape.countOfAllChildren();
        }
        return count;
    }

    
    public void setCoordinates(int x1, int y1, int x2, int y2) {
        _spgrRecord.setRectY1(y1);
        _spgrRecord.setRectY2(y2);
        _spgrRecord.setRectX1(x1);
        _spgrRecord.setRectX2(x2);
    }

    
    public void clear() {
        ArrayList <HSSFShape> copy = new ArrayList<HSSFShape>(_shapes);
        for (HSSFShape shape: copy){
            removeShape(shape);
        }
    }

    
    int newShapeId() {
        DrawingManager2 dm = _sheet.getWorkbook().getWorkbook().getDrawingManager();
        EscherDgRecord dg =
                _boundAggregate.getEscherContainer().getChildById(EscherDgRecord.RECORD_ID);
        short drawingGroupId = dg.getDrawingGroupId();
        return dm.allocateShapeId(drawingGroupId, dg);
    }

    
    public boolean containsChart() {
        

        
        EscherOptRecord optRecord = (EscherOptRecord)
                _boundAggregate.findFirstWithId(EscherOptRecord.RECORD_ID);
        if (optRecord == null) {
            
            return false;
        }

        for (Iterator<EscherProperty> it = optRecord.getEscherProperties().iterator(); it.hasNext(); ) {
            EscherProperty prop = it.next();
            if (prop.getPropertyNumber() == 896 && prop.isComplex()) {
                EscherComplexProperty cp = (EscherComplexProperty) prop;
                String str = StringUtil.getFromUnicodeLE(cp.getComplexData());

                if (str.equals(""Chart 1 "")) {
                    return true;
                }
            }
        }

        return false;
    }

    
    public int getX1() {
        return _spgrRecord.getRectX1();
    }

    
    public int getY1() {
        return _spgrRecord.getRectY1();
    }

    
    public int getX2() {
        return _spgrRecord.getRectX2();
    }

    
    public int getY2() {
        return _spgrRecord.getRectY2();
    }

    
    protected EscherAggregate _getBoundAggregate() {
        return _boundAggregate;
    }

    
    public HSSFClientAnchor createAnchor(int dx1, int dy1, int dx2, int dy2, int col1, int row1, int col2, int row2) {
        return new HSSFClientAnchor(dx1, dy1, dx2, dy2, (short) col1, row1, (short) col2, row2);
    }

    public Chart createChart(ClientAnchor anchor) {
        throw new RuntimeException(""NotImplemented"");
    }


    
    void buildShapeTree() {
        EscherContainerRecord dgContainer = _boundAggregate.getEscherContainer();
        if (dgContainer == null) {
            return;
        }
        EscherContainerRecord spgrConrainer = dgContainer.getChildContainers().get(0);
        List<EscherContainerRecord> spgrChildren = spgrConrainer.getChildContainers();

        for (int i = 0; i < spgrChildren.size(); i++) {
            EscherContainerRecord spContainer = spgrChildren.get(i);
            if (i != 0) {
                HSSFShapeFactory.createShapeTree(spContainer, _boundAggregate, this, _sheet.getWorkbook().getRootDirectory());
            }
        }
    }

    private void setFlipFlags(HSSFShape shape){
        EscherSpRecord sp = shape.getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        if (shape.getAnchor().isHorizontallyFlipped()) {
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);
        }
        if (shape.getAnchor().isVerticallyFlipped()) {
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);
        }
    }

    public Iterator<HSSFShape> iterator() {
        return _shapes.iterator();
    }

    protected HSSFSheet getSheet() {
        return _sheet;
    }
}
"
poi,3,org.apache.poi.poifs.property.DirectoryProperty,8,2,1,10,37,0,6,4,6,0.357142857,276,1.0,0,0.823529412,0.375,1,1,33.25,6,1.625,1,"

package org.apache.poi.poifs.property;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;


public class DirectoryProperty extends Property implements Parent, Iterable<Property> { 

    
    private List<Property> _children;

    
    private Set<String>  _children_names;

    
    public DirectoryProperty(String name)
    {
        super();
        _children       = new ArrayList<Property>();
        _children_names = new HashSet<String>();
        setName(name);
        setSize(0);
        setPropertyType(PropertyConstants.DIRECTORY_TYPE);
        setStartBlock(0);
        setNodeColor(_NODE_BLACK);   
    }

    
    protected DirectoryProperty(final int index, final byte [] array,
                                final int offset)
    {
        super(index, array, offset);
        _children       = new ArrayList<Property>();
        _children_names = new HashSet<String>();
    }

    
    public boolean changeName(Property property, String newName)
    {
        boolean result;
        String  oldName = property.getName();

        property.setName(newName);
        String cleanNewName = property.getName();

        if (_children_names.contains(cleanNewName))
        {

            
            property.setName(oldName);
            result = false;
        }
        else
        {
            _children_names.add(cleanNewName);
            _children_names.remove(oldName);
            result = true;
        }
        return result;
    }

    
    public boolean deleteChild(Property property)
    {
        boolean result = _children.remove(property);

        if (result)
        {
            _children_names.remove(property.getName());
        }
        return result;
    }

    public static class PropertyComparator implements Comparator<Property> {

        
        public int compare(Property o1, Property o2)
        {
            String VBA_PROJECT = ""_VBA_PROJECT"";
            String name1  = o1.getName();
            String name2  = o2.getName();
            int  result = name1.length() - name2.length();

            if (result == 0)
            {
              
              if (name1.compareTo(VBA_PROJECT) == 0)
                result = 1;
              else if (name2.compareTo(VBA_PROJECT) == 0)
                result = -1;
              else
              {
                if (name1.startsWith(""__"") && name2.startsWith(""__""))
                {
                  
                  result = name1.compareToIgnoreCase(name2);
                }
                else if (name1.startsWith(""__""))
                {
                  
                  result = 1;
                }
                else if (name2.startsWith(""__""))
                {
                  
                  result = -1;
                }
                else
                  
                  
                  result = name1.compareToIgnoreCase(name2);
              }
            }
            return result;
        }
    }

    
    public boolean isDirectory()
    {
        return true;
    }

    
    protected void preWrite()
    {
        if (_children.size() > 0)
        {
            Property[] children = _children.toArray(new Property[ 0 ]);

            Arrays.sort(children, new PropertyComparator());
            int midpoint = children.length / 2;

            setChildProperty(children[ midpoint ].getIndex());
            children[ 0 ].setPreviousChild(null);
            children[ 0 ].setNextChild(null);
            for (int j = 1; j < midpoint; j++)
            {
                children[ j ].setPreviousChild(children[ j - 1 ]);
                children[ j ].setNextChild(null);
            }
            if (midpoint != 0)
            {
                children[ midpoint ]
                    .setPreviousChild(children[ midpoint - 1 ]);
            }
            if (midpoint != (children.length - 1))
            {
                children[ midpoint ].setNextChild(children[ midpoint + 1 ]);
                for (int j = midpoint + 1; j < children.length - 1; j++)
                {
                    children[ j ].setPreviousChild(null);
                    children[ j ].setNextChild(children[ j + 1 ]);
                }
                children[ children.length - 1 ].setPreviousChild(null);
                children[ children.length - 1 ].setNextChild(null);
            }
            else
            {
                children[ midpoint ].setNextChild(null);
            }
        }
    }

    
    public Iterator<Property> getChildren()
    {
        return _children.iterator();
    }
    
    public Iterator<Property> iterator() {
        return getChildren();
    }

    
    public void addChild(final Property property)
        throws IOException
    {
        String name = property.getName();

        if (_children_names.contains(name))
        {
            throw new IOException(""Duplicate name """" + name + """""");
        }
        _children_names.add(name);
        _children.add(property);
    }
}
"
poi,3,org.apache.poi.hssf.record.NoteStructureSubRecord,8,3,0,6,23,8,2,5,6,0.785714286,125,0.5,0,0.666666667,0.325,1,4,14.375,2,0.875,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;


public final class NoteStructureSubRecord extends SubRecord {
    public final static short sid = 0x0D;
    private static final int ENCODED_SIZE = 22;

    private byte[] reserved;

    
    public NoteStructureSubRecord()
    {
        
        reserved = new byte[ENCODED_SIZE];
    }

    
    public NoteStructureSubRecord(LittleEndianInput in, int size) {
        if (size != ENCODED_SIZE) {
            throw new RecordFormatException(""Unexpected size ("" + size + "")"");
        }
        
        byte[] buf = new byte[size];
        in.readFully(buf);
        reserved = buf;
    }

    
    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ftNts ]"").append(""
"");
        buffer.append(""  size     = "").append(getDataSize()).append(""
"");
        buffer.append(""  reserved = "").append(HexDump.toHex(reserved)).append(""
"");
        buffer.append(""[/ftNts ]"").append(""
"");
        return buffer.toString();
    }

    
    public void serialize(LittleEndianOutput out) {
        out.writeShort(sid);
        out.writeShort(reserved.length);
        out.write(reserved);
    }

	protected int getDataSize() {
        return reserved.length;
    }

    
    public short getSid()
    {
        return sid;
    }

    public Object clone() {
        NoteStructureSubRecord rec = new NoteStructureSubRecord();
        byte[] recdata = new byte[reserved.length];
        System.arraycopy(reserved, 0, recdata, 0, recdata.length);
        rec.reserved = recdata;
        return rec;
    }

}


"
poi,3,org.apache.poi.hssf.record.FontRecord,37,2,0,11,55,474,4,7,34,0.936342593,549,0.625,4,0.244444444,0.190972222,1,4,13.18918919,3,1.027,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;


public final class FontRecord extends StandardRecord {
	public final static short     sid                 = 0x0031;                                                 
	public final static short     SS_NONE             = 0;
	public final static short     SS_SUPER            = 1;
	public final static short     SS_SUB              = 2;
	public final static byte      U_NONE              = 0;
	public final static byte      U_SINGLE            = 1;
	public final static byte      U_DOUBLE            = 2;
	public final static byte      U_SINGLE_ACCOUNTING = 0x21;
	public final static byte      U_DOUBLE_ACCOUNTING = 0x22;
	private short                 field_1_font_height;        
	private short                 field_2_attributes;

	
	private static final BitField italic     = BitFieldFactory.getInstance(0x02); 

	
	private static final BitField strikeout  =BitFieldFactory.getInstance(0x08);  
	private static final BitField macoutline = BitFieldFactory.getInstance(0x10); 
	private static final BitField macshadow  = BitFieldFactory.getInstance(0x20); 

	
	
	private short                 field_3_color_palette_index;
	private short                 field_4_bold_weight;
	private short                 field_5_super_sub_script;   
	private byte                  field_6_underline;          
	private byte                  field_7_family;             
	private byte                  field_8_charset;            
	private byte                  field_9_zero = 0;           
	
	private String                field_11_font_name;

	public FontRecord() {
	}

	public FontRecord(RecordInputStream in) {
		field_1_font_height         = in.readShort();
		field_2_attributes          = in.readShort();
		field_3_color_palette_index = in.readShort();
		field_4_bold_weight         = in.readShort();
		field_5_super_sub_script    = in.readShort();
		field_6_underline           = in.readByte();
		field_7_family              = in.readByte();
		field_8_charset             = in.readByte();
		field_9_zero                = in.readByte();
		int field_10_font_name_len  = in.readUByte();
		int unicodeFlags            = in.readUByte(); 

		if (field_10_font_name_len > 0) {
			if (unicodeFlags == 0) {   
				field_11_font_name = in.readCompressedUnicode(field_10_font_name_len);
			} else {   
				field_11_font_name = in.readUnicodeLEString(field_10_font_name_len);
			}
		} else {
			field_11_font_name = """";
		}
	}

	
	public void setFontHeight(short height) {
		field_1_font_height = height;
	}

	
	public void setAttributes(short attributes) {
		field_2_attributes = attributes;
	}

	

	
	public void setItalic(boolean italics) {
		field_2_attributes = italic.setShortBoolean(field_2_attributes, italics);
	}

	
	public void setStrikeout(boolean strike) {
		field_2_attributes = strikeout.setShortBoolean(field_2_attributes, strike);
	}

	
	public void setMacoutline(boolean mac) {
		field_2_attributes = macoutline.setShortBoolean(field_2_attributes, mac);
	}

	
	public void setMacshadow(boolean mac) {
		field_2_attributes = macshadow.setShortBoolean(field_2_attributes, mac);
	}

	
	public void setColorPaletteIndex(short cpi) {
		field_3_color_palette_index = cpi;
	}

	
	public void setBoldWeight(short bw) {
		field_4_bold_weight = bw;
	}

	
	public void setSuperSubScript(short sss) {
		field_5_super_sub_script = sss;
	}

	
	public void setUnderline(byte u) {
		field_6_underline = u;
	}

	
	public void setFamily(byte f) {
		field_7_family = f;
	}

	
	public void setCharset(byte charset) {
		field_8_charset = charset;
	}


	
	public void setFontName(String fn) {
		field_11_font_name = fn;
	}

	
	public short getFontHeight() {
		return field_1_font_height;
	}

	
	public short getAttributes() {
		return field_2_attributes;
	}

	
	public boolean isItalic() {
		return italic.isSet(field_2_attributes);
	}

	
	public boolean isStruckout(){
		return strikeout.isSet(field_2_attributes);
	}

	
	public boolean isMacoutlined(){
		return macoutline.isSet(field_2_attributes);
	}

	
	public boolean isMacshadowed(){
		return macshadow.isSet(field_2_attributes);
	}

	
	public short getColorPaletteIndex(){
		return field_3_color_palette_index;
	}

	
	public short getBoldWeight(){
		return field_4_bold_weight;
	}

	
	public short getSuperSubScript(){
		return field_5_super_sub_script;
	}

	
	public byte getUnderline() {
		return field_6_underline;
	}

	
	public byte getFamily() {
		return field_7_family;
	}

	
	public byte getCharset() {
		return field_8_charset;
	}

	
	public String getFontName() {
		return field_11_font_name;
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();

		sb.append(""[FONT]
"");
		sb.append(""    .fontheight    = "").append(HexDump.shortToHex(getFontHeight())).append(""
"");
		sb.append(""    .attributes    = "").append(HexDump.shortToHex(getAttributes())).append(""
"");
		sb.append(""       .italic     = "").append(isItalic()).append(""
"");
		sb.append(""       .strikout   = "").append(isStruckout()).append(""
"");
		sb.append(""       .macoutlined= "").append(isMacoutlined()).append(""
"");
		sb.append(""       .macshadowed= "").append(isMacshadowed()).append(""
"");
		sb.append(""    .colorpalette  = "").append(HexDump.shortToHex(getColorPaletteIndex())).append(""
"");
		sb.append(""    .boldweight    = "").append(HexDump.shortToHex(getBoldWeight())).append(""
"");
		sb.append(""    .supersubscript= "").append(HexDump.shortToHex(getSuperSubScript())).append(""
"");
		sb.append(""    .underline     = "").append(HexDump.byteToHex(getUnderline())).append(""
"");
		sb.append(""    .family        = "").append(HexDump.byteToHex(getFamily())).append(""
"");
		sb.append(""    .charset       = "").append(HexDump.byteToHex(getCharset())).append(""
"");
		sb.append(""    .fontname      = "").append(getFontName()).append(""
"");
		sb.append(""[/FONT]
"");
		return sb.toString();
	}

	public void serialize(LittleEndianOutput out) {

		out.writeShort(getFontHeight());
		out.writeShort(getAttributes());
		out.writeShort(getColorPaletteIndex());
		out.writeShort(getBoldWeight());
		out.writeShort(getSuperSubScript());
		out.writeByte(getUnderline());
		out.writeByte(getFamily());
		out.writeByte(getCharset());
		out.writeByte(field_9_zero);
		int fontNameLen = field_11_font_name.length();
		out.writeByte(fontNameLen);
		boolean hasMultibyte = StringUtil.hasMultibyte(field_11_font_name);
		out.writeByte(hasMultibyte ? 0x01 : 0x00);
		if (fontNameLen > 0) {
			if (hasMultibyte) {
			   StringUtil.putUnicodeLE(field_11_font_name, out);
			} else {
				StringUtil.putCompressedUnicode(field_11_font_name, out);
			}
		}
	}
	protected int getDataSize() {
		int size = 16; 
		int fontNameLen = field_11_font_name.length();
		if (fontNameLen < 1) {
			return size;
		}

		boolean hasMultibyte = StringUtil.hasMultibyte(field_11_font_name);
		return size + fontNameLen * (hasMultibyte ? 2 : 1);
	}

	public short getSid() {
		return sid;
	}

	
	public void cloneStyleFrom(FontRecord source) {
		field_1_font_height         = source.field_1_font_height;
		field_2_attributes          = source.field_2_attributes;
		field_3_color_palette_index = source.field_3_color_palette_index;
		field_4_bold_weight         = source.field_4_bold_weight;
		field_5_super_sub_script    = source.field_5_super_sub_script;
		field_6_underline           = source.field_6_underline;
		field_7_family              = source.field_7_family;
		field_8_charset             = source.field_8_charset;
		field_9_zero                = source.field_9_zero;
		field_11_font_name          = source.field_11_font_name;
	}

	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime
				* result
				+ ((field_11_font_name == null) ? 0 : field_11_font_name
						.hashCode());
		result = prime * result + field_1_font_height;
		result = prime * result + field_2_attributes;
		result = prime * result + field_3_color_palette_index;
		result = prime * result + field_4_bold_weight;
		result = prime * result + field_5_super_sub_script;
		result = prime * result + field_6_underline;
		result = prime * result + field_7_family;
		result = prime * result + field_8_charset;
		result = prime * result + field_9_zero;
		return result;
	}

	
	public boolean sameProperties(FontRecord other) {
		return
		field_1_font_height         == other.field_1_font_height &&
		field_2_attributes          == other.field_2_attributes &&
		field_3_color_palette_index == other.field_3_color_palette_index &&
		field_4_bold_weight         == other.field_4_bold_weight &&
		field_5_super_sub_script    == other.field_5_super_sub_script &&
		field_6_underline           == other.field_6_underline &&
		field_7_family              == other.field_7_family &&
		field_8_charset             == other.field_8_charset &&
		field_9_zero                == other.field_9_zero &&
        stringEquals(this.field_11_font_name, other.field_11_font_name)
		;
	}

    public boolean equals(Object o) {
        return (o instanceof FontRecord) ? sameProperties((FontRecord)o) : false;
    }
    
    private static boolean stringEquals(String s1, String s2) {
        return (s1 == s2 || (s1 != null && s1.equals(s2)));
    }
}
"
poi,3,org.apache.poi.hssf.record.LabelSSTRecord,24,2,0,10,38,234,5,5,22,0.747826087,366,0.8,0,0.333333333,0.226190476,1,4,14.04166667,7,1.8333,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class LabelSSTRecord extends CellRecord {
    public final static short sid = 0xfd;
    private int field_4_sst_index;

    public LabelSSTRecord() {
    	
    }

    public LabelSSTRecord(RecordInputStream in) {
        super(in);
        field_4_sst_index = in.readInt();
    }

    
    public void setSSTIndex(int index) {
        field_4_sst_index = index;
    }


    
    public int getSSTIndex() {
        return field_4_sst_index;
    }
    
    @Override
    protected String getRecordName() {
    	return ""LABELSST"";
    }

    @Override
    protected void appendValueText(StringBuilder sb) {
		sb.append(""  .sstIndex = "");
    	sb.append(HexDump.shortToHex(getSSTIndex()));
    }
    @Override
    protected void serializeValue(LittleEndianOutput out) {
        out.writeInt(getSSTIndex());
    }

    @Override
    protected int getValueDataSize() {
        return 4;
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
      LabelSSTRecord rec = new LabelSSTRecord();
      copyBaseFields(rec);
      rec.field_4_sst_index = field_4_sst_index;
      return rec;
    }
}
"
poi,3,org.apache.poi.util.BitField,18,1,0,37,19,107,37,0,18,0.382352941,170,1.0,0,0.0,0.433333333,0,0,8.333333333,2,1.2222,0,"

        

package org.apache.poi.util;



public class BitField
{
    private final int _mask;
    private final int _shift_count;

    

    public BitField(final int mask)
    {
        _mask = mask;
        int count       = 0;
        int bit_pattern = mask;

        if (bit_pattern != 0)
        {
            while ((bit_pattern & 1) == 0)
            {
                count++;
                bit_pattern >>= 1;
            }
        }
        _shift_count = count;
    }

    

    public int getValue(final int holder)
    {
        return getRawValue(holder) >>> _shift_count;
    }

    

    public short getShortValue(final short holder)
    {
        return ( short ) getValue(holder);
    }

    

    public int getRawValue(final int holder)
    {
        return (holder & _mask);
    }

    

    public short getShortRawValue(final short holder)
    {
        return ( short ) getRawValue(holder);
    }

    

    public boolean isSet(final int holder)
    {
        return (holder & _mask) != 0;
    }

    

    public boolean isAllSet(final int holder)
    {
        return (holder & _mask) == _mask;
    }

    

    public int setValue(final int holder, final int value)
    {
        return (holder & ~_mask) | ((value << _shift_count) & _mask);
    }

    

    public short setShortValue(final short holder, final short value)
    {
        return ( short ) setValue(holder, value);
    }

    

    public int clear(final int holder)
    {
        return holder & ~_mask;
    }

    

    public short clearShort(final short holder)
    {
        return ( short ) clear(holder);
    }

    

    public byte clearByte(final byte holder)
    {
        return ( byte ) clear(holder);
    }

    

    public int set(final int holder)
    {
        return holder | _mask;
    }

    

    public short setShort(final short holder)
    {
        return ( short ) set(holder);
    }

    

    public byte setByte(final byte holder)
    {
        return ( byte ) set(holder);
    }

    

    public int setBoolean(final int holder, final boolean flag)
    {
        return flag ? set(holder)
                    : clear(holder);
    }

    

    public short setShortBoolean(final short holder, final boolean flag)
    {
        return flag ? setShort(holder)
                    : clearShort(holder);
    }

    

    public byte setByteBoolean(final byte holder, final boolean flag)
    {
        return flag ? setByte(holder)
                    : clearByte(holder);
    }
}   

"
poi,3,org.apache.poi.util.BlockingInputStream,10,2,0,0,19,0,0,0,10,0.0,86,1.0,0,0.5,0.32,1,2,7.5,1,0.9,0,"

        

package org.apache.poi.util;

import java.io.InputStream;
import java.io.IOException;


public class BlockingInputStream
      extends InputStream
{
      protected InputStream is;

      public BlockingInputStream(InputStream is)
      {
          this.is = is;
      }

      public int available()
        throws IOException
      {
          return is.available();
      }

      public void close()
        throws IOException
      {
          is.close();
      }

      public void mark(int readLimit)
      {
          is.mark(readLimit);
      }

      public boolean markSupported()
      {
          return is.markSupported();
      }

      public int read()
        throws IOException
      {
          return is.read();
      }
      
      
      public int read(byte[] bf)
        throws IOException
      {
          
          int i = 0;
          int b = 4611;
          while ( i < bf.length )
          {
              b = is.read();
              if ( b == -1 )
                  break;
              bf[i++] = (byte) b;
          }
          if ( i == 0 && b == -1 )
              return -1;
          return i;
      }

      public int read(byte[] bf, int s, int l)
        throws IOException
      {
          return is.read(bf, s, l);
      }

      public void reset()
        throws IOException
      {
          is.reset();
      }

      public long skip(long n)
        throws IOException
      {
          return is.skip(n);
      }
}

"
poi,3,org.apache.poi.hssf.record.DBCellRecord,15,2,0,8,32,79,4,4,13,0.857142857,242,0.5,0,0.458333333,0.306666667,1,4,14.86666667,3,1.2667,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class DBCellRecord extends StandardRecord {
    public final static short sid = 0x00D7;
    public final static int BLOCK_SIZE = 32;
    
    public static final class Builder {
        private short[] _cellOffsets;
        private int _nCellOffsets;
        public Builder() {
        	_cellOffsets = new short[4];
		}

        public void addCellOffset(int cellRefOffset) {
            if (_cellOffsets.length <= _nCellOffsets) {
                short[] temp = new short[_nCellOffsets * 2];
                System.arraycopy(_cellOffsets, 0, temp, 0, _nCellOffsets);
                _cellOffsets = temp;
            }
            _cellOffsets[_nCellOffsets] = (short) cellRefOffset;
            _nCellOffsets++;
        }

        public DBCellRecord build(int rowOffset) {
            short[] cellOffsets = new short[_nCellOffsets];
            System.arraycopy(_cellOffsets, 0, cellOffsets, 0, _nCellOffsets);
            return new DBCellRecord(rowOffset, cellOffsets);
        }
    }
    
    private final int     field_1_row_offset;
    private final short[] field_2_cell_offsets;

    DBCellRecord(int rowOffset, short[]cellOffsets) {
        field_1_row_offset = rowOffset;
        field_2_cell_offsets = cellOffsets;
    }

    public DBCellRecord(RecordInputStream in) {
        field_1_row_offset   = in.readUShort();
        int size = in.remaining();        
        field_2_cell_offsets = new short[ size / 2 ];

        for (int i=0;i<field_2_cell_offsets.length;i++)
        {
            field_2_cell_offsets[ i ] = in.readShort();
        }
    }


    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DBCELL]
"");
        buffer.append(""    .rowoffset = "").append(HexDump.intToHex(field_1_row_offset)).append(""
"");
        for (int k = 0; k < field_2_cell_offsets.length; k++) {
            buffer.append(""    .cell_"").append(k).append("" = "")
                .append(HexDump.shortToHex(field_2_cell_offsets[ k ])).append(""
"");
        }
        buffer.append(""[/DBCELL]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeInt(field_1_row_offset);
        for (int k = 0; k < field_2_cell_offsets.length; k++) {
            out.writeShort(field_2_cell_offsets[ k ]);
        }
    }
    protected int getDataSize() {
        return 4 + field_2_cell_offsets.length * 2;
    }
    
    
    public static int calculateSizeOfRecords(int nBlocks, int nRows) {
        
        
        
        return nBlocks * 8 + nRows * 2;
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
        
        return this;
    }
}
"
poi,3,org.apache.poi.poifs.property.PropertyConstants,0,1,0,0,0,0,0,0,0,2.0,4,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

        

package org.apache.poi.poifs.property;



public interface PropertyConstants
{
    public static final int  PROPERTY_TYPE_OFFSET = 0x42;

    
    public static final byte DIRECTORY_TYPE       = 1;
    public static final byte DOCUMENT_TYPE        = 2;
    public static final byte ROOT_TYPE            = 5;
}   

"
poi,3,org.apache.poi.hpsf.MissingSectionException,4,5,0,2,8,6,1,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class MissingSectionException extends HPSFRuntimeException
{

    
    public MissingSectionException()
    {
        super();
    }


    
    public MissingSectionException(final String msg)
    {
        super(msg);
    }


    
    public MissingSectionException(final Throwable reason)
    {
        super(reason);
    }


    
    public MissingSectionException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.hpsf.Util,15,1,0,7,34,105,6,1,14,1.071428571,338,0.0,0,0.0,0.103030303,0,0,21.46666667,6,1.8667,1,"

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collection;
import java.util.Date;


public class Util
{

    
    public static boolean equal(final byte[] a, final byte[] b)
    {
        if (a.length != b.length)
            return false;
        for (int i = 0; i < a.length; i++)
            if (a[i] != b[i])
                return false;
        return true;
    }



    
    public static void copy(final byte[] src, final int srcOffset,
                            final int length, final byte[] dst,
                            final int dstOffset)
    {
        for (int i = 0; i < length; i++)
            dst[dstOffset + i] = src[srcOffset + i];
    }



    
    public static byte[] cat(final byte[][] byteArrays)
    {
        int capacity = 0;
        for (int i = 0; i < byteArrays.length; i++)
            capacity += byteArrays[i].length;
        final byte[] result = new byte[capacity];
        int r = 0;
        for (int i = 0; i < byteArrays.length; i++)
            for (int j = 0; j < byteArrays[i].length; j++)
                result[r++] = byteArrays[i][j];
        return result;
    }



    
    public static byte[] copy(final byte[] src, final int offset,
                              final int length)
    {
        final byte[] result = new byte[length];
        copy(src, offset, length, result, 0);
        return result;
    }



    
    public static final long EPOCH_DIFF = 11644473600000L;


    
    public static Date filetimeToDate(final int high, final int low)
    {
        final long filetime = ((long) high) << 32 | (low & 0xffffffffL);
        return filetimeToDate(filetime);
    }

    
    public static Date filetimeToDate(final long filetime)
    {
        final long ms_since_16010101 = filetime / (1000 * 10);
        final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF;
        return new Date(ms_since_19700101);
    }



    
    public static long dateToFileTime(final Date date)
    {
        long ms_since_19700101 = date.getTime();
        long ms_since_16010101 = ms_since_19700101 + EPOCH_DIFF;
        return ms_since_16010101 * (1000 * 10);
    }


    
    public static boolean equals(Collection<?> c1, Collection<?> c2)
    {
        Object[] o1 = c1.toArray();
        Object[] o2 = c2.toArray();
        return internalEquals(o1, o2);
    }



    
    public static boolean equals(Object[] c1, Object[] c2)
    {
        final Object[] o1 = c1.clone();
        final Object[] o2 = c2.clone();
        return internalEquals(o1, o2);
    }

    private static boolean internalEquals(Object[] o1, Object[] o2)
    {
        for (int i1 = 0; i1 < o1.length; i1++)
        {
            final Object obj1 = o1[i1];
            boolean matchFound = false;
            for (int i2 = 0; !matchFound && i2 < o1.length; i2++)
            {
                final Object obj2 = o2[i2];
                if (obj1.equals(obj2))
                {
                    matchFound = true;
                    o2[i2] = null;
                }
            }
            if (!matchFound)
                return false;
        }
        return true;
    }



    
    public static byte[] pad4(final byte[] ba)
    {
        final int PAD = 4;
        final byte[] result;
        int l = ba.length % PAD;
        if (l == 0)
            result = ba;
        else
        {
            l = PAD - l;
            result = new byte[ba.length + l];
            System.arraycopy(ba, 0, result, 0, ba.length);
        }
        return result;
    }



    
    public static char[] pad4(final char[] ca)
    {
        final int PAD = 4;
        final char[] result;
        int l = ca.length % PAD;
        if (l == 0)
            result = ca;
        else
        {
            l = PAD - l;
            result = new char[ca.length + l];
            System.arraycopy(ca, 0, result, 0, ca.length);
        }
        return result;
    }



    
    public static char[] pad4(final String s)
    {
        return pad4(s.toCharArray());
    }



    
    public static String toString(final Throwable t)
    {
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        t.printStackTrace(pw);
        pw.close();
        try
        {
            sw.close();
            return sw.toString();
        }
        catch (IOException e)
        {
            final StringBuffer b = new StringBuffer(t.getMessage());
            b.append(""
"");
            b.append(""Could not create a stacktrace. Reason: "");
            b.append(e.getMessage());
            return b.toString();
        }
    }

}
"
poi,3,org.apache.poi.util.NullLogger,23,2,0,2,24,253,1,1,23,2.0,49,0.0,0,0.52173913,0.669565217,1,2,1.130434783,1,0.9565,1,"

package org.apache.poi.util;


public class NullLogger extends POILogger {
    @Override
    public void initialize(final String cat){
       
    }

    

    @Override
    public void log(final int level, final Object obj1)
    {
        
    }

    
    public void log(int level, Object obj1, final Throwable exception) {
        
    }

    
    
    @Override
    public boolean check(final int level) {
       return false;
    }
}

"
poi,3,org.apache.poi.hpsf.NoPropertySetStreamException,4,4,0,3,8,6,2,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class NoPropertySetStreamException extends HPSFException
{

    
    public NoPropertySetStreamException()
    {
        super();
    }



    
    public NoPropertySetStreamException(final String msg)
    {
        super(msg);
    }



    
    public NoPropertySetStreamException(final Throwable reason)
    {
        super(reason);
    }



    
    public NoPropertySetStreamException(final String msg,
                                        final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFClientAnchor,18,2,0,7,32,85,4,3,16,0.776470588,398,0.0,0,0.384615385,0.355555556,1,1,20.83333333,4,1.5,2,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.EscherClientAnchorRecord;
import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.ss.usermodel.ClientAnchor;


public final class HSSFClientAnchor extends HSSFAnchor implements ClientAnchor {

    private EscherClientAnchorRecord _escherClientAnchor;

    public HSSFClientAnchor(EscherClientAnchorRecord escherClientAnchorRecord) {
        this._escherClientAnchor = escherClientAnchorRecord;
    }

    
    public HSSFClientAnchor() {
    }

    
    public HSSFClientAnchor(int dx1, int dy1, int dx2, int dy2, short col1, int row1, short col2, int row2) {
        super(dx1, dy1, dx2, dy2);

        checkRange(dx1, 0, 1023, ""dx1"");
        checkRange(dx2, 0, 1023, ""dx2"");
        checkRange(dy1, 0, 255, ""dy1"");
        checkRange(dy2, 0, 255, ""dy2"");
        checkRange(col1, 0, 255, ""col1"");
        checkRange(col2, 0, 255, ""col2"");
        checkRange(row1, 0, 255 * 256, ""row1"");
        checkRange(row2, 0, 255 * 256, ""row2"");

        setCol1((short) Math.min(col1, col2));
        setCol2((short) Math.max(col1, col2));
        setRow1((short) Math.min(row1, row2));
        setRow2((short) Math.max(row1, row2));

        if (col1 > col2){
            _isHorizontallyFlipped = true;
        }
        if (row1 > row2){
            _isVerticallyFlipped = true;
        }
    }

    
    public float getAnchorHeightInPoints(HSSFSheet sheet) {
        int y1 = getDy1();
        int y2 = getDy2();
        int row1 = Math.min(getRow1(), getRow2());
        int row2 = Math.max(getRow1(), getRow2());

        float points = 0;
        if (row1 == row2) {
            points = ((y2 - y1) / 256.0f) * getRowHeightInPoints(sheet, row2);
        } else {
            points += ((256.0f - y1) / 256.0f) * getRowHeightInPoints(sheet, row1);
            for (int i = row1 + 1; i < row2; i++) {
                points += getRowHeightInPoints(sheet, i);
            }
            points += (y2 / 256.0f) * getRowHeightInPoints(sheet, row2);
        }

        return points;
    }

    private float getRowHeightInPoints(HSSFSheet sheet, int rowNum) {
        HSSFRow row = sheet.getRow(rowNum);
        if (row == null) {
            return sheet.getDefaultRowHeightInPoints();
        }
        return row.getHeightInPoints();
    }

    
    public short getCol1() {
        return _escherClientAnchor.getCol1();
    }

    
    public void setCol1(short col1) {
        checkRange(col1, 0, 255, ""col1"");
        _escherClientAnchor.setCol1(col1);
    }

    
    public void setCol1(int col1) {
        setCol1((short) col1);
    }

    
    public short getCol2() {
        return _escherClientAnchor.getCol2();
    }

    
    public void setCol2(short col2) {
        checkRange(col2, 0, 255, ""col2"");
        _escherClientAnchor.setCol2(col2);
    }

    
    public void setCol2(int col2) {
        setCol2((short) col2);
    }

    
    public int getRow1() {
        return _escherClientAnchor.getRow1();
    }

    
    public void setRow1(int row1) {
        checkRange(row1, 0, 256 * 256, ""row1"");
        _escherClientAnchor.setRow1(Integer.valueOf(row1).shortValue());
    }

    
    public int getRow2() {
        return _escherClientAnchor.getRow2();
    }

    
    public void setRow2(int row2) {
        checkRange(row2, 0, 256 * 256, ""row2"");
        _escherClientAnchor.setRow2(Integer.valueOf(row2).shortValue());
    }

    
    public void setAnchor(short col1, int row1, int x1, int y1, short col2, int row2, int x2, int y2) {
        checkRange(getDx1(), 0, 1023, ""dx1"");
        checkRange(getDx2(), 0, 1023, ""dx2"");
        checkRange(getDy1(), 0, 255, ""dy1"");
        checkRange(getDy2(), 0, 255, ""dy2"");
        checkRange(getCol1(), 0, 255, ""col1"");
        checkRange(getCol2(), 0, 255, ""col2"");
        checkRange(getRow1(), 0, 255 * 256, ""row1"");
        checkRange(getRow2(), 0, 255 * 256, ""row2"");

        setCol1(col1);
        setRow1(row1);
        setDx1(x1);
        setDy1(y1);
        setCol2(col2);
        setRow2(row2);
        setDx2(x2);
        setDy2(y2);
    }

    public boolean isHorizontallyFlipped() {
        return _isHorizontallyFlipped;
    }

    public boolean isVerticallyFlipped() {
        return _isVerticallyFlipped;
    }

    @Override
    protected EscherRecord getEscherAnchor() {
        return _escherClientAnchor;
    }

    @Override
    protected void createEscherAnchor() {
        _escherClientAnchor = new EscherClientAnchorRecord();
    }

    
    public int getAnchorType() {
        return _escherClientAnchor.getFlag();
    }

    
    public void setAnchorType(int anchorType) {
        _escherClientAnchor.setFlag(Integer.valueOf(anchorType).shortValue());
    }

    private void checkRange(int value, int minRange, int maxRange, String varName) {
        if (value < minRange || value > maxRange)
            throw new IllegalArgumentException(varName + "" must be between "" + minRange + "" and "" + maxRange + "", but was: "" + value);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (obj == this)
            return true;
        if (obj.getClass() != getClass())
            return false;
        HSSFClientAnchor anchor = (HSSFClientAnchor) obj;

        return anchor.getCol1() == getCol1() && anchor.getCol2() == getCol2() && anchor.getDx1() == getDx1()
                && anchor.getDx2() == getDx2() && anchor.getDy1() == getDy1() && anchor.getDy2() == getDy2()
                && anchor.getRow1() == getRow1() && anchor.getRow2() == getRow2() && anchor.getAnchorType() == getAnchorType();
    }

    @Override
    public int hashCode() {
        assert false : ""hashCode not designed"";
        return 42; 
      }

    @Override
    public int getDx1() {
        return _escherClientAnchor.getDx1();
    }

    @Override
    public void setDx1(int dx1) {
        _escherClientAnchor.setDx1(Integer.valueOf(dx1).shortValue());
    }

    @Override
    public int getDy1() {
        return _escherClientAnchor.getDy1();
    }

    @Override
    public void setDy1(int dy1) {
        _escherClientAnchor.setDy1(Integer.valueOf(dy1).shortValue());
    }

    @Override
    public int getDy2() {
        return _escherClientAnchor.getDy2();
    }

    @Override
    public void setDy2(int dy2) {
        _escherClientAnchor.setDy2(Integer.valueOf(dy2).shortValue());
    }

    @Override
    public int getDx2() {
        return _escherClientAnchor.getDx2();
    }

    @Override
    public void setDx2(int dx2) {
        _escherClientAnchor.setDx2(Integer.valueOf(dx2).shortValue());
    }
}
"
poi,3,org.apache.poi.hpsf.IllegalPropertySetDataException,4,5,0,4,8,6,3,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class IllegalPropertySetDataException extends HPSFRuntimeException
{

    
    public IllegalPropertySetDataException()
    {
        super();
    }



    
    public IllegalPropertySetDataException(final String msg)
    {
        super(msg);
    }



    
    public IllegalPropertySetDataException(final Throwable reason)
    {
        super(reason);
    }



    
    public IllegalPropertySetDataException(final String msg,
                                           final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.poifs.property.RootProperty,3,3,0,8,10,3,6,2,1,2.0,27,0.0,0,0.971428571,0.666666667,1,1,8.0,1,0.3333,1,"

package org.apache.poi.poifs.property;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.storage.SmallDocumentBlock;


public final class RootProperty extends DirectoryProperty {
   private static final String NAME = ""Root Entry"";

    RootProperty()
    {
        super(NAME);

        
        setNodeColor(_NODE_BLACK);
        setPropertyType(PropertyConstants.ROOT_TYPE);
        setStartBlock(POIFSConstants.END_OF_CHAIN);
    }

    
    protected RootProperty(final int index, final byte [] array,
                           final int offset)
    {
        super(index, array, offset);
    }

    
    public void setSize(int size)
    {
        super.setSize(SmallDocumentBlock.calcSize(size));
    }

    
    @Override
    public String getName() {
        return NAME;
    }
}
"
poi,3,org.apache.poi.hssf.record.aggregates.ColumnInfoRecordsAggregate,25,2,0,4,67,0,1,3,22,0.208333333,991,0.0,0,0.314285714,0.212,1,3,38.6,26,3.8,0,"

package org.apache.poi.hssf.record.aggregates;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.apache.poi.hssf.model.RecordStream;
import org.apache.poi.hssf.record.ColumnInfoRecord;


public final class ColumnInfoRecordsAggregate extends RecordAggregate {
	
	private final List<ColumnInfoRecord> records;


	private static final class CIRComparator implements Comparator<ColumnInfoRecord> {
		public static final Comparator<ColumnInfoRecord> instance = new CIRComparator();
		private CIRComparator() {
			
		}
		public int compare(ColumnInfoRecord a, ColumnInfoRecord b) {
			return compareColInfos(a, b);
		}
		public static int compareColInfos(ColumnInfoRecord a, ColumnInfoRecord b) {
			return a.getFirstColumn()-b.getFirstColumn();
		}
	}

	
	public ColumnInfoRecordsAggregate() {
		records = new ArrayList<ColumnInfoRecord>();
	}
	public ColumnInfoRecordsAggregate(RecordStream rs) {
		this();

		boolean isInOrder = true;
		ColumnInfoRecord cirPrev = null;
		while(rs.peekNextClass() == ColumnInfoRecord.class) {
			ColumnInfoRecord cir = (ColumnInfoRecord) rs.getNext();
			records.add(cir);
			if (cirPrev != null && CIRComparator.compareColInfos(cirPrev, cir) > 0) {
				isInOrder = false;
			}
			cirPrev = cir;
		}
		if (records.size() < 1) {
			throw new RuntimeException(""No column info records found"");
		}
		if (!isInOrder) {
			Collections.sort(records, CIRComparator.instance);
		}
	}

	
	public Object clone() {
		ColumnInfoRecordsAggregate rec = new ColumnInfoRecordsAggregate();
		for (int k = 0; k < records.size(); k++) {
			ColumnInfoRecord ci = records.get(k);
			rec.records.add((ColumnInfoRecord) ci.clone());
		}
		return rec;
	}

	
	public void insertColumn(ColumnInfoRecord col) {
		records.add(col);
		Collections.sort(records, CIRComparator.instance);
	}

	
	private void insertColumn(int idx, ColumnInfoRecord col) {
		records.add(idx, col);
	}

	 int getNumColumns() {
		return records.size();
	}

	public void visitContainedRecords(RecordVisitor rv) {
		int nItems = records.size();
		if (nItems < 1) {
			return;
		}
		ColumnInfoRecord cirPrev = null;
		for(int i=0; i<nItems; i++) {
			ColumnInfoRecord cir = records.get(i);
			rv.visitRecord(cir);
			if (cirPrev != null && CIRComparator.compareColInfos(cirPrev, cir) > 0) {
				
				
				throw new RuntimeException(""Column info records are out of order"");
			}
			cirPrev = cir;
		}
	}

	private int findStartOfColumnOutlineGroup(int pIdx) {
		
		ColumnInfoRecord columnInfo = records.get(pIdx);
		int level = columnInfo.getOutlineLevel();
		int idx = pIdx;
		while (idx != 0) {
			ColumnInfoRecord prevColumnInfo = records.get(idx - 1);
			if (!prevColumnInfo.isAdjacentBefore(columnInfo)) {
				break;
			}
			if (prevColumnInfo.getOutlineLevel() < level) {
				break;
			}
			idx--;
			columnInfo = prevColumnInfo;
		}

		return idx;
	}

	private int findEndOfColumnOutlineGroup(int colInfoIndex) {
		
		ColumnInfoRecord columnInfo = records.get(colInfoIndex);
		int level = columnInfo.getOutlineLevel();
		int idx = colInfoIndex;
		while (idx < records.size() - 1) {
			ColumnInfoRecord nextColumnInfo = records.get(idx + 1);
			if (!columnInfo.isAdjacentBefore(nextColumnInfo)) {
				break;
			}
			if (nextColumnInfo.getOutlineLevel() < level) {
				break;
			}
			idx++;
			columnInfo = nextColumnInfo;
		}
		return idx;
	}

	private ColumnInfoRecord getColInfo(int idx) {
		return records.get( idx );
	}

	
	private boolean isColumnGroupCollapsed(int idx) {
		int endOfOutlineGroupIdx = findEndOfColumnOutlineGroup(idx);
		int nextColInfoIx = endOfOutlineGroupIdx+1;
		if (nextColInfoIx >= records.size()) {
			return false;
		}
		ColumnInfoRecord nextColInfo = getColInfo(nextColInfoIx);
		if (!getColInfo(endOfOutlineGroupIdx).isAdjacentBefore(nextColInfo)) {
			return false;
		}
		return nextColInfo.getCollapsed();
	}


	private boolean isColumnGroupHiddenByParent(int idx) {
		
		int endLevel = 0;
		boolean endHidden = false;
		int endOfOutlineGroupIdx = findEndOfColumnOutlineGroup( idx );
		if (endOfOutlineGroupIdx < records.size()) {
			ColumnInfoRecord nextInfo = getColInfo(endOfOutlineGroupIdx + 1);
			if (getColInfo(endOfOutlineGroupIdx).isAdjacentBefore(nextInfo)) {
				endLevel = nextInfo.getOutlineLevel();
				endHidden = nextInfo.getHidden();
			}
		}
		
		int startLevel = 0;
		boolean startHidden = false;
		int startOfOutlineGroupIdx = findStartOfColumnOutlineGroup( idx );
		if (startOfOutlineGroupIdx > 0) {
			ColumnInfoRecord prevInfo = getColInfo(startOfOutlineGroupIdx - 1);
			if (prevInfo.isAdjacentBefore(getColInfo(startOfOutlineGroupIdx))) {
				startLevel = prevInfo.getOutlineLevel();
				startHidden = prevInfo.getHidden();
			}
		}
		if (endLevel > startLevel) {
			return endHidden;
		}
		return startHidden;
	}

	public void collapseColumn(int columnIndex) {
		int colInfoIx = findColInfoIdx(columnIndex, 0);
		if (colInfoIx == -1) {
			return;
		}

		
		int groupStartColInfoIx = findStartOfColumnOutlineGroup(colInfoIx);
		ColumnInfoRecord columnInfo = getColInfo(groupStartColInfoIx);

		
		int lastColIx = setGroupHidden(groupStartColInfoIx, columnInfo.getOutlineLevel(), true);

		
		setColumn(lastColIx + 1, null, null, null, null, Boolean.TRUE);
	}
	
	private int setGroupHidden(int pIdx, int level, boolean hidden) {
		int idx = pIdx;
		ColumnInfoRecord columnInfo = getColInfo(idx);
		while (idx < records.size()) {
			columnInfo.setHidden(hidden);
			if (idx + 1 < records.size()) {
				ColumnInfoRecord nextColumnInfo = getColInfo(idx + 1);
				if (!columnInfo.isAdjacentBefore(nextColumnInfo)) {
					break;
				}
				if (nextColumnInfo.getOutlineLevel() < level) {
					break;
				}
				columnInfo = nextColumnInfo;
			}
			idx++;
		}
		return columnInfo.getLastColumn();
	}


	public void expandColumn(int columnIndex) {
		int idx = findColInfoIdx(columnIndex, 0);
		if (idx == -1) {
			return;
		}

		
		if (!isColumnGroupCollapsed(idx)) {
			return;
		}

		
		int startIdx = findStartOfColumnOutlineGroup(idx);
		int endIdx = findEndOfColumnOutlineGroup(idx);

		
		
		
		
		
		
		
		ColumnInfoRecord columnInfo = getColInfo(endIdx);
		if (!isColumnGroupHiddenByParent(idx)) {
			int outlineLevel = columnInfo.getOutlineLevel();
			for (int i = startIdx; i <= endIdx; i++) {
				ColumnInfoRecord ci = getColInfo(i);
				if (outlineLevel == ci.getOutlineLevel())
					ci.setHidden(false);
			}
		}

		
		setColumn(columnInfo.getLastColumn() + 1, null, null, null, null, Boolean.FALSE);
	}

	private static ColumnInfoRecord copyColInfo(ColumnInfoRecord ci) {
		return (ColumnInfoRecord) ci.clone();
	}


	public void setColumn(int targetColumnIx, Short xfIndex, Integer width,
					Integer level, Boolean hidden, Boolean collapsed) {
		ColumnInfoRecord ci = null;
		int k  = 0;

		for (k = 0; k < records.size(); k++) {
			ColumnInfoRecord tci = records.get(k);
			if (tci.containsColumn(targetColumnIx)) {
				ci = tci;
				break;
			}
			if (tci.getFirstColumn() > targetColumnIx) {
				
				break; 
			}
		}

		if (ci == null) {
			
			ColumnInfoRecord nci = new ColumnInfoRecord();

			nci.setFirstColumn(targetColumnIx);
			nci.setLastColumn(targetColumnIx);
			setColumnInfoFields( nci, xfIndex, width, level, hidden, collapsed );
			insertColumn(k, nci);
			attemptMergeColInfoRecords(k);
			return;
		}

		boolean styleChanged = xfIndex != null && ci.getXFIndex() != xfIndex.shortValue();
		boolean widthChanged = width != null && ci.getColumnWidth() != width.shortValue();
		boolean levelChanged = level != null && ci.getOutlineLevel() != level.intValue();
		boolean hiddenChanged = hidden != null && ci.getHidden() != hidden.booleanValue();
		boolean collapsedChanged = collapsed != null && ci.getCollapsed() != collapsed.booleanValue();

		boolean columnChanged = styleChanged || widthChanged || levelChanged || hiddenChanged || collapsedChanged;
		if (!columnChanged) {
			
			return;
		}

		if (ci.getFirstColumn() == targetColumnIx && ci.getLastColumn() == targetColumnIx) {
			
			setColumnInfoFields(ci, xfIndex, width, level, hidden, collapsed);
			attemptMergeColInfoRecords(k);
			return;
		}

		if (ci.getFirstColumn() == targetColumnIx || ci.getLastColumn() == targetColumnIx) {
			
			
			if (ci.getFirstColumn() == targetColumnIx) {
				ci.setFirstColumn(targetColumnIx + 1);
			} else {
				ci.setLastColumn(targetColumnIx - 1);
				k++; 
			}
			ColumnInfoRecord nci = copyColInfo(ci);

			nci.setFirstColumn(targetColumnIx);
			nci.setLastColumn(targetColumnIx);
			setColumnInfoFields( nci, xfIndex, width, level, hidden, collapsed );

			insertColumn(k, nci);
			attemptMergeColInfoRecords(k);
		} else {
			
			ColumnInfoRecord ciStart = ci;
			ColumnInfoRecord ciMid = copyColInfo(ci);
			ColumnInfoRecord ciEnd = copyColInfo(ci);
			int lastcolumn = ci.getLastColumn();

			ciStart.setLastColumn(targetColumnIx - 1);

			ciMid.setFirstColumn(targetColumnIx);
			ciMid.setLastColumn(targetColumnIx);
			setColumnInfoFields(ciMid, xfIndex, width, level, hidden, collapsed);
			insertColumn(++k, ciMid);

			ciEnd.setFirstColumn(targetColumnIx+1);
			ciEnd.setLastColumn(lastcolumn);
			insertColumn(++k, ciEnd);
			
			
		}
	}

	
	private static void setColumnInfoFields(ColumnInfoRecord ci, Short xfStyle, Integer width,
				Integer level, Boolean hidden, Boolean collapsed) {
		if (xfStyle != null) {
			ci.setXFIndex(xfStyle.shortValue());
		}
		if (width != null) {
			ci.setColumnWidth(width.intValue());
		}
		if (level != null) {
			ci.setOutlineLevel( level.shortValue() );
		}
		if (hidden != null) {
			ci.setHidden( hidden.booleanValue() );
		}
		if (collapsed != null) {
			ci.setCollapsed( collapsed.booleanValue() );
		}
	}

	private int findColInfoIdx(int columnIx, int fromColInfoIdx) {
		if (columnIx < 0) {
			throw new IllegalArgumentException( ""column parameter out of range: "" + columnIx );
		}
		if (fromColInfoIdx < 0) {
			throw new IllegalArgumentException( ""fromIdx parameter out of range: "" + fromColInfoIdx );
		}

		for (int k = fromColInfoIdx; k < records.size(); k++) {
			ColumnInfoRecord ci = getColInfo(k);
			if (ci.containsColumn(columnIx)) {
				return k;
			}
			if (ci.getFirstColumn() > columnIx) {
				break;
			}
		}
		return -1;
	}

	
	private void attemptMergeColInfoRecords(int colInfoIx) {
		int nRecords = records.size();
		if (colInfoIx < 0 || colInfoIx >= nRecords) {
			throw new IllegalArgumentException(""colInfoIx "" + colInfoIx
					+ "" is out of range (0.."" + (nRecords-1) + "")"");
		}
		ColumnInfoRecord currentCol = getColInfo(colInfoIx);
		int nextIx = colInfoIx+1;
		if (nextIx < nRecords) {
			if (mergeColInfoRecords(currentCol, getColInfo(nextIx))) {
    			records.remove(nextIx);
			}
		}
		if (colInfoIx > 0) {
			if (mergeColInfoRecords(getColInfo(colInfoIx - 1), currentCol)) {
    			records.remove(colInfoIx);
    		}
		}
	}
	
	private static boolean mergeColInfoRecords(ColumnInfoRecord ciA, ColumnInfoRecord ciB) {
		if (ciA.isAdjacentBefore(ciB) && ciA.formatMatches(ciB)) {
			ciA.setLastColumn(ciB.getLastColumn());
			return true;
		}
		return false;
	}
	
	public void groupColumnRange(int fromColumnIx, int toColumnIx, boolean indent) {

		int colInfoSearchStartIdx = 0; 
		for (int i = fromColumnIx; i <= toColumnIx; i++) {
			int level = 1;
			int colInfoIdx = findColInfoIdx(i, colInfoSearchStartIdx);
			if (colInfoIdx != -1) {
				level = getColInfo(colInfoIdx).getOutlineLevel();
				if (indent) {
					level++;
				} else {
					level--;
				}
				level = Math.max(0, level);
				level = Math.min(7, level);
				colInfoSearchStartIdx = Math.max(0, colInfoIdx - 1); 
			}
			setColumn(i, null, null, Integer.valueOf(level), null, null);
		}
	}
	
	public ColumnInfoRecord findColumnInfo(int columnIndex) {
		int nInfos = records.size();
		for(int i=0; i< nInfos; i++) {
			ColumnInfoRecord ci = getColInfo(i);
			if (ci.containsColumn(columnIndex)) {
				return ci;
			}
		}
		return null;
	}
	public int getMaxOutlineLevel() {
		int result = 0;
		int count=records.size();
		for (int i=0; i<count; i++) {
			ColumnInfoRecord columnInfoRecord = getColInfo(i);
			result = Math.max(columnInfoRecord.getOutlineLevel(), result);
		}
		return result;
	}
	public int getOutlineLevel(int columnIndex) {
	    ColumnInfoRecord ci = findColumnInfo(columnIndex);
	    if (ci != null) {
            return ci.getOutlineLevel();
	    } else {
	        return 0;
	    }
	}
}
"
poi,3,org.apache.poi.poifs.storage.SmallDocumentBlockList,5,2,0,5,12,10,1,4,5,2.0,32,0.0,0,0.555555556,0.5,0,0,5.4,1,0.8,0,"

        

package org.apache.poi.poifs.storage;

import java.util.*;


public class SmallDocumentBlockList
    extends BlockListImpl
{
    

    public SmallDocumentBlockList(final List<SmallDocumentBlock> blocks)
    {
        setBlocks(blocks.toArray(new SmallDocumentBlock[blocks.size()]));
    }
}

"
poi,3,org.apache.poi.hssf.record.DrawingGroupRecord,11,3,0,11,25,55,4,7,6,1.1,207,0.333333333,0,0.727272727,0.454545455,2,5,17.54545455,4,1.5455,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.ddf.NullEscherSerializationListener;
import org.apache.poi.util.LittleEndian;

import java.util.Iterator;
import java.util.List;


public final class DrawingGroupRecord extends AbstractEscherHolderRecord {
    public static final short sid = 0xEB;

    static final int MAX_RECORD_SIZE = 8228;
    private static final int MAX_DATA_SIZE = MAX_RECORD_SIZE - 4;

    public DrawingGroupRecord()
    {
    }

    public DrawingGroupRecord( RecordInputStream in )
    {
        super( in );
    }

    protected String getRecordName()
    {
        return ""MSODRAWINGGROUP"";
    }

    public short getSid()
    {
        return sid;
    }

    public int serialize(int offset, byte[] data)
    {
        byte[] rawData = getRawData();
        if (getEscherRecords().size() == 0 && rawData != null)
        {
            return writeData( offset, data, rawData );
        }
        byte[] buffer = new byte[getRawDataSize()];
        int pos = 0;
        for ( Iterator<EscherRecord> iterator = getEscherRecords().iterator(); iterator.hasNext(); )
        {
            EscherRecord r = iterator.next();
            pos += r.serialize(pos, buffer, new NullEscherSerializationListener() );
        }

        return writeData( offset, data, buffer );
    }

    
    public void processChildRecords() {
    	convertRawBytesToEscherRecords();
    }

    public int getRecordSize() {
        
        return grossSizeFromDataSize(getRawDataSize());
    }

    private int getRawDataSize() {
        List<EscherRecord> escherRecords = getEscherRecords();
        byte[] rawData = getRawData();
        if (escherRecords.size() == 0 && rawData != null)
        {
            return rawData.length;
        }
        int size = 0;
        for ( Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext(); )
        {
            EscherRecord r = iterator.next();
            size += r.getRecordSize();
        }
        return size;
    }

    static int grossSizeFromDataSize(int dataSize)
    {
        return dataSize + ( (dataSize - 1) / MAX_DATA_SIZE + 1 ) * 4;
    }

    private int writeData( int offset, byte[] data, byte[] rawData )
    {
        int writtenActualData = 0;
        int writtenRawData = 0;
        while (writtenRawData < rawData.length)
        {
            int segmentLength = Math.min( rawData.length - writtenRawData, MAX_DATA_SIZE);
            if (writtenRawData / MAX_DATA_SIZE >= 2)
                writeContinueHeader( data, offset, segmentLength );
            else
                writeHeader( data, offset, segmentLength );
            writtenActualData += 4;
            offset += 4;
            System.arraycopy( rawData, writtenRawData, data, offset, segmentLength );
            offset += segmentLength;
            writtenRawData += segmentLength;
            writtenActualData += segmentLength;
        }
        return writtenActualData;
    }

    private void writeHeader( byte[] data, int offset, int sizeExcludingHeader )
    {
        LittleEndian.putShort(data, 0 + offset, getSid());
        LittleEndian.putShort(data, 2 + offset, (short) sizeExcludingHeader);
    }

    private void writeContinueHeader( byte[] data, int offset, int sizeExcludingHeader )
    {
        LittleEndian.putShort(data, 0 + offset, ContinueRecord.sid);
        LittleEndian.putShort(data, 2 + offset, (short) sizeExcludingHeader);
    }
}
"
poi,3,org.apache.poi.hssf.record.aggregates.FormulaRecordAggregate,25,2,0,8,45,0,3,5,23,0.694444444,181,0.666666667,2,0.314285714,0.182222222,1,4,6.12,2,1.12,5,"

package org.apache.poi.hssf.record.aggregates;

import org.apache.poi.hssf.record.ArrayRecord;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.FormulaRecord;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordFormatException;
import org.apache.poi.hssf.record.SharedFormulaRecord;
import org.apache.poi.hssf.record.StringRecord;
import org.apache.poi.ss.formula.ptg.ExpPtg;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.hssf.util.CellRangeAddress8Bit;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.ss.formula.Formula;
import org.apache.poi.ss.util.CellRangeAddress;


public final class FormulaRecordAggregate extends RecordAggregate implements CellValueRecordInterface {

	private final FormulaRecord _formulaRecord;
	private SharedValueManager _sharedValueManager;
	
	private StringRecord _stringRecord;
	private SharedFormulaRecord _sharedFormulaRecord;

	
	public FormulaRecordAggregate(FormulaRecord formulaRec, StringRecord stringRec, SharedValueManager svm) {
		if (svm == null) {
			throw new IllegalArgumentException(""sfm must not be null"");
		}
		if (formulaRec.hasCachedResultString()) {
			if (stringRec == null) {
				throw new RecordFormatException(""Formula record flag is set but String record was not found"");
			}
			_stringRecord = stringRec;
		} else {
			
			
			
			_stringRecord = null;
		}

		_formulaRecord = formulaRec;
		_sharedValueManager = svm;
		if (formulaRec.isSharedFormula()) {
			CellReference firstCell = formulaRec.getFormula().getExpReference();
			if (firstCell == null) {
				handleMissingSharedFormulaRecord(formulaRec);
			} else {
				_sharedFormulaRecord = svm.linkSharedFormulaRecord(firstCell, this);
			}
		}
	}
	
	private static void handleMissingSharedFormulaRecord(FormulaRecord formula) {
		
		Ptg firstToken = formula.getParsedExpression()[0];
		if (firstToken instanceof ExpPtg) {
			throw new RecordFormatException(
					""SharedFormulaRecord not found for FormulaRecord with (isSharedFormula=true)"");
		}
		
		formula.setSharedFormula(false); 
	}

	public FormulaRecord getFormulaRecord() {
		return _formulaRecord;
	}

	
	public StringRecord getStringRecord() {
		return _stringRecord;
	}

	public short getXFIndex() {
		return _formulaRecord.getXFIndex();
	}

	public void setXFIndex(short xf) {
		_formulaRecord.setXFIndex(xf);
	}

	public void setColumn(short col) {
		_formulaRecord.setColumn(col);
	}

	public void setRow(int row) {
		_formulaRecord.setRow(row);
	}

	public short getColumn() {
		return _formulaRecord.getColumn();
	}

	public int getRow() {
		return _formulaRecord.getRow();
	}

	public String toString() {
		return _formulaRecord.toString();
	}

	public void visitContainedRecords(RecordVisitor rv) {
		 rv.visitRecord(_formulaRecord);
		 Record sharedFormulaRecord = _sharedValueManager.getRecordForFirstCell(this);
		 if (sharedFormulaRecord != null) {
			 rv.visitRecord(sharedFormulaRecord);
		 }
		 if (_formulaRecord.hasCachedResultString() && _stringRecord != null) {
			 rv.visitRecord(_stringRecord);
		 }
	}

	public String getStringValue() {
		if(_stringRecord==null) {
			return null;
		}
		return _stringRecord.getString();
	}

	public void setCachedStringResult(String value) {

		
		if(_stringRecord == null) {
			_stringRecord = new StringRecord();
		}
		_stringRecord.setString(value);
		if (value.length() < 1) {
			_formulaRecord.setCachedResultTypeEmptyString();
		} else {
			_formulaRecord.setCachedResultTypeString();
		}
	}
	public void setCachedBooleanResult(boolean value) {
		_stringRecord = null;
		_formulaRecord.setCachedResultBoolean(value);
	}
	public void setCachedErrorResult(int errorCode) {
		_stringRecord = null;
		_formulaRecord.setCachedResultErrorCode(errorCode);
	}
	public void setCachedDoubleResult(double value) {
		_stringRecord = null;
		_formulaRecord.setValue(value);
	}

	public Ptg[] getFormulaTokens() {
		if (_sharedFormulaRecord != null) {
			return _sharedFormulaRecord.getFormulaTokens(_formulaRecord);
		}
		CellReference expRef = _formulaRecord.getFormula().getExpReference();
		if (expRef != null) {
			ArrayRecord arec = _sharedValueManager.getArrayRecord(expRef.getRow(), expRef.getCol());
			return arec.getFormulaTokens();
		}
		return _formulaRecord.getParsedExpression();
	}

	
	public void setParsedExpression(Ptg[] ptgs) {
		notifyFormulaChanging();
		_formulaRecord.setParsedExpression(ptgs);
	}

	public void unlinkSharedFormula() {
		SharedFormulaRecord sfr = _sharedFormulaRecord;
		if (sfr == null) {
			throw new IllegalStateException(""Formula not linked to shared formula"");
		}
		Ptg[] ptgs = sfr.getFormulaTokens(_formulaRecord);
		_formulaRecord.setParsedExpression(ptgs);
		
		_formulaRecord.setSharedFormula(false);
		_sharedFormulaRecord = null;
	}
	
	public void notifyFormulaChanging() {
		if (_sharedFormulaRecord != null) {
			_sharedValueManager.unlink(_sharedFormulaRecord);
		}
	}
	public boolean isPartOfArrayFormula() {
		if (_sharedFormulaRecord != null) {
			return false;
		}
        CellReference expRef = _formulaRecord.getFormula().getExpReference();
        ArrayRecord arec = expRef == null ? null : _sharedValueManager.getArrayRecord(expRef.getRow(), expRef.getCol());
		return arec != null;
	}

	public CellRangeAddress getArrayFormulaRange() {
		if (_sharedFormulaRecord != null) {
			throw new IllegalStateException(""not an array formula cell."");
		}
		CellReference expRef = _formulaRecord.getFormula().getExpReference();
		if (expRef == null) {
			throw new IllegalStateException(""not an array formula cell."");
		}
		ArrayRecord arec = _sharedValueManager.getArrayRecord(expRef.getRow(), expRef.getCol());
		if (arec == null) {
			throw new IllegalStateException(""ArrayRecord was not found for the locator "" + expRef.formatAsString());
		}
		CellRangeAddress8Bit a = arec.getRange();
		return new CellRangeAddress(a.getFirstRow(), a.getLastRow(), a.getFirstColumn(),a.getLastColumn());
	}

	public void setArrayFormula(CellRangeAddress r, Ptg[] ptgs) {

		ArrayRecord arr = new ArrayRecord(Formula.create(ptgs), new CellRangeAddress8Bit(r.getFirstRow(), r.getLastRow(), r.getFirstColumn(), r.getLastColumn()));
		_sharedValueManager.addArrayRecord(arr);
	}
	
	public CellRangeAddress removeArrayFormula(int rowIndex, int columnIndex) {
		CellRangeAddress8Bit a = _sharedValueManager.removeArrayFormula(rowIndex, columnIndex);
        
        _formulaRecord.setParsedExpression(null);
        return new CellRangeAddress(a.getFirstRow(), a.getLastRow(), a.getFirstColumn(), a.getLastColumn());
	}
}
"
poi,3,org.apache.poi.poifs.filesystem.DocumentInputStream,13,2,0,12,23,0,9,3,11,0.642857143,271,1.0,1,0.45,0.256410256,1,2,19.30769231,2,0.9231,0,"

package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.util.LittleEndianInput;


public class DocumentInputStream extends InputStream implements LittleEndianInput {
	
	protected static final int EOF = -1;

	protected static final int SIZE_SHORT = 2;
	protected static final int SIZE_INT = 4;
	protected static final int SIZE_LONG = 8;
	
	private DocumentInputStream delegate;
	
	
	protected DocumentInputStream() {}

	
	public DocumentInputStream(DocumentEntry document) throws IOException {
	   if (!(document instanceof DocumentNode)) {
	      throw new IOException(""Cannot open internal document storage"");
	   }
	   DocumentNode documentNode = (DocumentNode)document;
	   DirectoryNode parentNode = (DirectoryNode)document.getParent();

	   if(documentNode.getDocument() != null) {
	      delegate = new ODocumentInputStream(document);
	   } else if(parentNode.getOFileSystem() != null) {
	      delegate = new ODocumentInputStream(document);
	   } else if(parentNode.getNFileSystem() != null) {
	      delegate = new NDocumentInputStream(document);
	   } else {
	      throw new IOException(""No FileSystem bound on the parent, can't read contents"");
	   }
	}

	
	public DocumentInputStream(OPOIFSDocument document) {
	   delegate = new ODocumentInputStream(document);
	}

   
   public DocumentInputStream(NPOIFSDocument document) {
      delegate = new NDocumentInputStream(document);
   }

	public int available() {
	   return delegate.available();
	}

	public void close() {
	   delegate.close();
	}

	public void mark(int ignoredReadlimit) {
		delegate.mark(ignoredReadlimit);
	}

	
	public boolean markSupported() {
		return true;
	}

	public int read() throws IOException {
	   return delegate.read();
	}

	public int read(byte[] b) throws IOException {
		return read(b, 0, b.length);
	}

	public int read(byte[] b, int off, int len) throws IOException {
	   return delegate.read(b, off, len);
	}

	
	public void reset() {
	   delegate.reset();
	}

	public long skip(long n) throws IOException {
	   return delegate.skip(n);
	}

	public byte readByte() {
	   return delegate.readByte();
	}

	public double readDouble() {
	   return delegate.readDouble();
	}

	public short readShort() {
		return (short) readUShort();
	}

   public void readFully(byte[] buf) {
      readFully(buf, 0, buf.length);
   }

	public void readFully(byte[] buf, int off, int len) {
	   delegate.readFully(buf, off, len);
	}

	public long readLong() {
	   return delegate.readLong();
	}

	public int readInt() {
	   return delegate.readInt();
	}

	public int readUShort() {
	   return delegate.readUShort();
	}

	public int readUByte() {
	   return delegate.readUByte();
	}
	
    public long readUInt() {
        int i = readInt();
        return i & 0xFFFFFFFFL;
    }
}
"
poi,3,org.apache.poi.hssf.eventmodel.EventRecordFactory,10,1,0,14,59,15,2,12,6,0.644444444,732,1.0,0,0.0,0.180555556,0,0,71.7,8,2.0,1,"

package org.apache.poi.hssf.eventmodel;

import java.io.InputStream;
import java.util.Arrays;

import org.apache.poi.hssf.record.*;


public final class EventRecordFactory {

	private final ERFListener _listener;
	private final short[] _sids;

	
	public EventRecordFactory(ERFListener listener, short[] sids) {
		_listener = listener;
		if (sids == null) {
			_sids = null;
		} else {
			_sids = sids.clone();
			Arrays.sort(_sids); 
		}
	}
	private boolean isSidIncluded(short sid) {
		if (_sids == null) {
			return true;
		}
		return Arrays.binarySearch(_sids, sid) >= 0;
	}


	
	private boolean processRecord(Record record) {
		if (!isSidIncluded(record.getSid())) {
			return true;
		}
		return _listener.processRecord(record);
	}

	
	public void processRecords(InputStream in) throws RecordFormatException {
		Record last_record = null;

		RecordInputStream recStream = new RecordInputStream(in);

		while (recStream.hasNextRecord()) {
			recStream.nextRecord();
			Record[] recs = RecordFactory.createRecord(recStream);   
			if (recs.length > 1) {
				for (int k = 0; k < recs.length; k++) {
					if ( last_record != null ) {
						if (!processRecord(last_record)) {
							return;
						}
					}
					last_record = recs[ k ]; 
				}							
			} else {
				Record record = recs[ 0 ];

				if (record != null) {
					if (last_record != null) {
						if (!processRecord(last_record)) {
							return;
						}
					}
					 last_record = record;
				}
			}
		}

		if (last_record != null) {
			processRecord(last_record);
		}
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFFont,23,1,0,7,48,0,6,1,22,0.984848485,167,0.111111111,1,0.0,0.253623188,0,0,5.47826087,1,0.9565,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.FontRecord;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.Font;


public final class HSSFFont implements Font {

    

    public final static String FONT_ARIAL = ""Arial"";


    private FontRecord         font;
    private short              index;

    

    protected HSSFFont(short index, FontRecord rec)
    {
        font       = rec;
        this.index = index;
    }

    

    public void setFontName(String name)
    {
        font.setFontName(name);
    }

    

    public String getFontName()
    {
        return font.getFontName();
    }

    

    public short getIndex()
    {
        return index;
    }

    

    public void setFontHeight(short height)
    {
        font.setFontHeight(height);
    }

    

    public void setFontHeightInPoints(short height)
    {
        font.setFontHeight(( short ) (height * 20));
    }

    

    public short getFontHeight()
    {
        return font.getFontHeight();
    }

    

    public short getFontHeightInPoints()
    {
        return ( short ) (font.getFontHeight() / 20);
    }

    

    public void setItalic(boolean italic)
    {
        font.setItalic(italic);
    }

    

    public boolean getItalic()
    {
        return font.isItalic();
    }

    

    public void setStrikeout(boolean strikeout)
    {
        font.setStrikeout(strikeout);
    }

    

    public boolean getStrikeout()
    {
        return font.isStruckout();
    }

    

    public void setColor(short color)
    {
        font.setColorPaletteIndex(color);
    }

    
    public short getColor()
    {
        return font.getColorPaletteIndex();
    }
    
    
    public HSSFColor getHSSFColor(HSSFWorkbook wb)
    {
       HSSFPalette pallette = wb.getCustomPalette();
       return pallette.getColor( getColor() );
    }

    
    public void setBoldweight(short boldweight)
    {
        font.setBoldWeight(boldweight);
    }
    
    
    public void setBold(boolean bold)
    {
        if (bold)
            font.setBoldWeight(BOLDWEIGHT_BOLD);
        else
            font.setBoldWeight(BOLDWEIGHT_NORMAL);
    }

    
    public short getBoldweight()
    {
        return font.getBoldWeight();
    }
    
    
    public boolean getBold()
    {
        return getBoldweight() == BOLDWEIGHT_BOLD;
    }

    

    public void setTypeOffset(short offset)
    {
        font.setSuperSubScript(offset);
    }

    

    public short getTypeOffset()
    {
        return font.getSuperSubScript();
    }

    

    public void setUnderline(byte underline)
    {
        font.setUnderline(underline);
    }

    

    public byte getUnderline()
    {
        return font.getUnderline();
    }


    
    public int getCharSet()
    {
        byte charset = font.getCharset();
        if(charset >= 0) {
           return charset;
        } else {
           return charset + 256;
        }
    }

    
    public void setCharSet(int charset)
    {
        byte cs = (byte)charset;
        if(charset > 127) {
           cs = (byte)(charset-256);
        }
        setCharSet(cs);
    }

    
    public void setCharSet(byte charset)
    {
        font.setCharset(charset);
    }

    public String toString()
    {
        return ""org.apache.poi.hssf.usermodel.HSSFFont{"" +
                 font +
                ""}"";
    }

	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((font == null) ? 0 : font.hashCode());
		result = prime * result + index;
		return result;
	}

	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (obj instanceof HSSFFont) {
			final HSSFFont other = (HSSFFont) obj;
			if (font == null) {
				if (other.font != null)
					return false;
			} else if (!font.equals(other.font))
				return false;
			if (index != other.index)
				return false;
			return true;
		}
		return false;
	}
}
"
poi,3,org.apache.poi.hssf.record.RecalcIdRecord,12,2,0,5,26,42,1,4,10,0.787878788,182,0.333333333,0,0.523809524,0.226190476,1,4,13.91666667,2,1.1667,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class RecalcIdRecord extends StandardRecord {
    public final static short sid = 0x01C1;
    private final int _reserved0;

    
    private int _engineId;

    public RecalcIdRecord() {
        _reserved0 = 0;
        _engineId = 0;
    }

    public RecalcIdRecord(RecordInputStream in) {
    	in.readUShort(); 
    	_reserved0 = in.readUShort();
    	_engineId = in.readInt();
    }

    public boolean isNeeded() {
        return true;
    }

    public void setEngineId(int val) {
        _engineId = val;
    }

    public int getEngineId() {
        return _engineId;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[RECALCID]
"");
        buffer.append(""    .reserved = "").append(HexDump.shortToHex(_reserved0)).append(""
"");
        buffer.append(""    .engineId = "").append(HexDump.intToHex(_engineId)).append(""
"");
        buffer.append(""[/RECALCID]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(sid); 
        out.writeShort(_reserved0);
        out.writeInt(_engineId);
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFDateUtil,11,1,0,2,24,53,1,2,6,1.033333333,241,1.0,0,0.0,0.157142857,0,0,20.63636364,4,1.6364,3,"




package org.apache.poi.hssf.usermodel;

import java.util.Calendar;

import org.apache.poi.ss.usermodel.DateUtil;


public class HSSFDateUtil extends DateUtil {
	protected static int absoluteDay(Calendar cal, boolean use1904windowing) {
		return DateUtil.absoluteDay(cal, use1904windowing);
	}
}
"
poi,3,org.apache.poi.hssf.record.PrintHeadersRecord,11,2,0,6,20,35,2,4,9,0.8,113,0.5,0,0.55,0.257575758,1,4,9.090909091,2,1.0909,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class PrintHeadersRecord
    extends StandardRecord
{
    public final static short sid = 0x2a;
    private short             field_1_print_headers;

    public PrintHeadersRecord()
    {
    }

    public PrintHeadersRecord(RecordInputStream in)
    {
        field_1_print_headers = in.readShort();
    }

    

    public void setPrintHeaders(boolean p)
    {
        if (p == true)
        {
            field_1_print_headers = 1;
        }
        else
        {
            field_1_print_headers = 0;
        }
    }

    

    public boolean getPrintHeaders()
    {
        return (field_1_print_headers == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRINTHEADERS]
"");
        buffer.append(""    .printheaders   = "").append(getPrintHeaders())
            .append(""
"");
        buffer.append(""[/PRINTHEADERS]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_print_headers);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      PrintHeadersRecord rec = new PrintHeadersRecord();
      rec.field_1_print_headers = field_1_print_headers;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFPolygon,8,2,0,7,9,14,5,2,6,0.785714286,73,0.0,0,0.695652174,0.325,0,0,7.625,2,1.0,0,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public class HSSFPolygon  extends HSSFSimpleShape {
	private static POILogger logger = POILogFactory.getLogger(HSSFPolygon.class);
    public final static short OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING = 0x1E;

    public HSSFPolygon(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord _textObjectRecord) {
        super(spContainer, objRecord, _textObjectRecord);
    }

    public HSSFPolygon(EscherContainerRecord spContainer, ObjRecord objRecord) {
        super(spContainer, objRecord);
    }

    HSSFPolygon(HSSFShape parent, HSSFAnchor anchor) {
        super(parent, anchor);
    }

    @Override
    protected TextObjectRecord createTextObjRecord() {
        return null;
    }

    
    protected EscherContainerRecord createSpContainer() {
        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherClientDataRecord clientData = new EscherClientDataRecord();

        spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);
        spContainer.setOptions((short) 0x000F);
        sp.setRecordId(EscherSpRecord.RECORD_ID);
        sp.setOptions((short) ((EscherAggregate.ST_NOT_PRIMATIVE << 4) | 0x2));
        if (getParent() == null) {
            sp.setFlags(EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE);
        } else {
            sp.setFlags(EscherSpRecord.FLAG_CHILD | EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE);
        }
        opt.setRecordId(EscherOptRecord.RECORD_ID);
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.TRANSFORM__ROTATION, false, false, 0));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, false, false, 100));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, false, false, 100));
        opt.setEscherProperty(new EscherShapePathProperty(EscherProperties.GEOMETRY__SHAPEPATH, EscherShapePathProperty.COMPLEX));

        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__FILLOK, false, false, 0x00010001));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINESTARTARROWHEAD, false, false, 0x0));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDARROWHEAD, false, false, 0x0));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDCAPSTYLE, false, false, 0x0));

        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEDASHING, LINESTYLE_SOLID));
        opt.setEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEWIDTH, LINEWIDTH_DEFAULT));
        opt.setEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, FILL__FILLCOLOR_DEFAULT));
        opt.setEscherProperty(new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, LINESTYLE__COLOR_DEFAULT));
        opt.setEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, 1));

        opt.setEscherProperty(new EscherBoolProperty( EscherProperties.GROUPSHAPE__PRINT, 0x080000));

        EscherRecord anchor = getAnchor().getEscherAnchor();
        clientData.setRecordId(EscherClientDataRecord.RECORD_ID);
        clientData.setOptions((short) 0x0000);

        spContainer.addChildRecord(sp);
        spContainer.addChildRecord(opt);
        spContainer.addChildRecord(anchor);
        spContainer.addChildRecord(clientData);

        return spContainer;
    }

    
    protected ObjRecord createObjRecord() {
        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType(OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING);
        c.setLocked(true);
        c.setPrintable(true);
        c.setAutofill(true);
        c.setAutoline(true);
        EndSubRecord e = new EndSubRecord();
        obj.addSubRecord(c);
        obj.addSubRecord(e);
        return obj;
    }

    @Override
    protected void afterRemove(HSSFPatriarch patriarch) {
        patriarch._getBoundAggregate().removeShapeToObjRecord(getEscherContainer().getChildById(EscherClientDataRecord.RECORD_ID));
    }

    
    public int[] getXPoints() {
        EscherArrayProperty verticesProp = getOptRecord().lookup(EscherProperties.GEOMETRY__VERTICES);
        if (null == verticesProp){
            return new int[]{};
        }
        int []array = new int[verticesProp.getNumberOfElementsInArray()-1];
        for (int i=0; i< verticesProp.getNumberOfElementsInArray()-1; i++){
            byte[] property = verticesProp.getElement(i);
            short x = LittleEndian.getShort(property, 0);
            array[i] = x;
        }
        return array;
    }

    
    public int[] getYPoints() {
        EscherArrayProperty verticesProp = getOptRecord().lookup(EscherProperties.GEOMETRY__VERTICES);
        if (null == verticesProp){
            return new int[]{};
        }
        int []array = new int[verticesProp.getNumberOfElementsInArray()-1];
        for (int i=0; i< verticesProp.getNumberOfElementsInArray()-1; i++){
            byte[] property = verticesProp.getElement(i);
            short x = LittleEndian.getShort(property, 2);
            array[i] = x;
        }
        return array;
    }

    
    public void setPoints(int[] xPoints, int[] yPoints) {
        if (xPoints.length != yPoints.length){
        	logger.log( POILogger.ERROR, ""xPoint.length must be equal to yPoints.length"");
            return;
        }
        if (xPoints.length == 0){
        	logger.log( POILogger.ERROR, ""HSSFPolygon must have at least one point"");
        }
        EscherArrayProperty verticesProp = new EscherArrayProperty(EscherProperties.GEOMETRY__VERTICES, false, new byte[0] );
        verticesProp.setNumberOfElementsInArray(xPoints.length+1);
        verticesProp.setNumberOfElementsInMemory(xPoints.length+1);
        verticesProp.setSizeOfElements(0xFFF0);
        for (int i = 0; i < xPoints.length; i++)
        {
            byte[] data = new byte[4];
            LittleEndian.putShort(data, 0, (short)xPoints[i]);
            LittleEndian.putShort(data, 2, (short)yPoints[i]);
            verticesProp.setElement(i, data);
        }
        int point = xPoints.length;
        byte[] data = new byte[4];
        LittleEndian.putShort(data, 0, (short)xPoints[0]);
        LittleEndian.putShort(data, 2, (short)yPoints[0]);
        verticesProp.setElement(point, data);
        setPropertyValue(verticesProp);

        EscherArrayProperty segmentsProp = new EscherArrayProperty(EscherProperties.GEOMETRY__SEGMENTINFO, false, null );
        segmentsProp.setSizeOfElements(0x0002);
        segmentsProp.setNumberOfElementsInArray(xPoints.length * 2 + 4);
        segmentsProp.setNumberOfElementsInMemory(xPoints.length * 2 + 4);
        segmentsProp.setElement(0, new byte[] { (byte)0x00, (byte)0x40 } );
        segmentsProp.setElement(1, new byte[] { (byte)0x00, (byte)0xAC } );
        for (int i = 0; i < xPoints.length; i++)
        {
            segmentsProp.setElement(2 + i * 2, new byte[] { (byte)0x01, (byte)0x00 } );
            segmentsProp.setElement(3 + i * 2, new byte[] { (byte)0x00, (byte)0xAC } );
        }
        segmentsProp.setElement(segmentsProp.getNumberOfElementsInArray() - 2, new byte[] { (byte)0x01, (byte)0x60 } );
        segmentsProp.setElement(segmentsProp.getNumberOfElementsInArray() - 1, new byte[] { (byte)0x00, (byte)0x80 } );
        setPropertyValue(segmentsProp);
    }

    
    public void setPolygonDrawArea(int width, int height) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, width));
        setPropertyValue(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, height));
    }

    
    public int getDrawAreaWidth() {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.GEOMETRY__RIGHT);
        return property == null ? 100: property.getPropertyValue();
    }

    
    public int getDrawAreaHeight() {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.GEOMETRY__BOTTOM);
        return property == null ? 100: property.getPropertyValue();
    }
}
"
poi,3,org.apache.poi.hssf.record.DrawingSelectionRecord,4,3,0,3,6,6,1,2,3,1.333333333,16,0.0,0,0.923076923,0.625,1,2,2.75,1,0.5,0,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;


public final class DrawingSelectionRecord extends StandardRecord {
	public static final short sid = 0x00ED;

	
	private static final class OfficeArtRecordHeader {
		public static final int ENCODED_SIZE = 8;
		
		private final int _verAndInstance;
		
		private final int _type;
		private final int _length;

		public OfficeArtRecordHeader(LittleEndianInput in) {
			_verAndInstance = in.readUShort();
			_type = in.readUShort();
			_length = in.readInt();
		}

		public void serialize(LittleEndianOutput out) {
			out.writeShort(_verAndInstance);
			out.writeShort(_type);
			out.writeInt(_length);
		}

		public String debugFormatAsString() {
			StringBuffer sb = new StringBuffer(32);
			sb.append(""ver+inst="").append(HexDump.shortToHex(_verAndInstance));
			sb.append("" type="").append(HexDump.shortToHex(_type));
			sb.append("" len="").append(HexDump.intToHex(_length));
			return sb.toString();
		}
	}

	
	
	private OfficeArtRecordHeader _header;
	private int _cpsp;
	
	private int _dgslk;
	private int _spidFocus;
	
	private int[] _shapeIds;

	public DrawingSelectionRecord(RecordInputStream in) {
		_header = new OfficeArtRecordHeader(in);
		_cpsp = in.readInt();
		_dgslk = in.readInt();
		_spidFocus = in.readInt();
		int nShapes = in.available() / 4;
		int[] shapeIds = new int[nShapes];
		for (int i = 0; i < nShapes; i++) {
			shapeIds[i] = in.readInt();
		}
		_shapeIds = shapeIds;
	}

	public short getSid() {
		return sid;
	}

	protected int getDataSize() {
		return OfficeArtRecordHeader.ENCODED_SIZE 
			+ 12 
			+ _shapeIds.length * 4;
	}

	public void serialize(LittleEndianOutput out) {
		_header.serialize(out);
		out.writeInt(_cpsp);
		out.writeInt(_dgslk);
		out.writeInt(_spidFocus);
		for (int i = 0; i < _shapeIds.length; i++) {
			out.writeInt(_shapeIds[i]);
		}
	}

	public Object clone() {
		
		return this;
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();

		sb.append(""[MSODRAWINGSELECTION]
"");
		sb.append(""    .rh       =("").append(_header.debugFormatAsString()).append("")
"");
		sb.append(""    .cpsp     ="").append(HexDump.intToHex(_cpsp)).append('
');
		sb.append(""    .dgslk    ="").append(HexDump.intToHex(_dgslk)).append('
');
		sb.append(""    .spidFocus="").append(HexDump.intToHex(_spidFocus)).append('
');
		sb.append(""    .shapeIds =("");
		for (int i = 0; i < _shapeIds.length; i++) {
			if (i > 0) {
				sb.append("", "");
			}
			sb.append(HexDump.intToHex(_shapeIds[i]));
		}
		sb.append("")
"");

		sb.append(""[/MSODRAWINGSELECTION]
"");
		return sb.toString();
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFFooter,20,1,0,2,34,158,1,1,18,0.75,262,0.0,1,0.0,0.175,0,0,11.9,4,1.1,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.FooterRecord;
import org.apache.poi.hssf.record.aggregates.PageSettingsBlock;
import org.apache.poi.ss.usermodel.Footer;


public final class HSSFFooter extends HeaderFooter implements Footer {
	private final PageSettingsBlock _psb;

	protected HSSFFooter(PageSettingsBlock psb) {
		_psb = psb;
	}

	protected String getRawText() {
		FooterRecord hf = _psb.getFooter();
		if (hf == null) {
			return """";
		}
		return hf.getText();
	}

	@Override
	protected void setHeaderFooterText(String text) {
		FooterRecord hfr = _psb.getFooter();
		if (hfr == null) {
			hfr = new FooterRecord(text);
			_psb.setFooter(hfr);
		} else {
			hfr.setText(text);
		}
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.DummyGraphics2d,85,3,0,0,182,0,0,0,85,0.5,2891,0.5,0,0.514450867,0.075456389,2,20,32.98823529,1,0.9882,0,"


package org.apache.poi.hssf.usermodel;

import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ImageObserver;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.RenderableImage;
import java.text.AttributedCharacterIterator;
import java.util.Map;

public class DummyGraphics2d
        extends Graphics2D
{
    BufferedImage img;
    private Graphics2D g2D;

    public DummyGraphics2d()
    {
        img = new BufferedImage(1000, 1000, 2);
        g2D = (Graphics2D)img.getGraphics();
    }

    public void addRenderingHints(Map<?,?> hints)
    {
        System.out.println( ""addRenderingHinds(Map):"" );
        System.out.println( ""  hints = "" + hints );
        g2D.addRenderingHints( hints );
    }

    public void clip(Shape s)
    {
        System.out.println( ""clip(Shape):"" );
        System.out.println( ""  s = "" + s );
        g2D.clip( s );
    }

    public void draw(Shape s)
    {
        System.out.println( ""draw(Shape):"" );
        System.out.println( ""s = "" + s );
        g2D.draw( s );
    }

    public void drawGlyphVector(GlyphVector g, float x, float y)
    {
        System.out.println( ""drawGlyphVector(GlyphVector, float, float):"" );
        System.out.println( ""g = "" + g );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawGlyphVector( g, x, y );
    }

    public void drawImage(BufferedImage img,
				   BufferedImageOp op,
				   int x,
				   int y)
    {
        System.out.println( ""drawImage(BufferedImage, BufferedImageOp, x, y):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""op = "" + op );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawImage( img, op, x, y );
    }

    public boolean drawImage(Image img,
                                      AffineTransform xform,
                                      ImageObserver obs)
    {
        System.out.println( ""drawImage(Image,AfflineTransform,ImageObserver):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""xform = "" + xform );
        System.out.println( ""obs = "" + obs );
        return g2D.drawImage( img, xform, obs );
    }

    public void drawRenderableImage(RenderableImage img,
                                             AffineTransform xform)
    {
        System.out.println( ""drawRenderableImage(RenderableImage, AfflineTransform):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""xform = "" + xform );
        g2D.drawRenderableImage( img, xform );
    }

    public void drawRenderedImage(RenderedImage img,
                                           AffineTransform xform)
    {
        System.out.println( ""drawRenderedImage(RenderedImage, AffineTransform):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""xform = "" + xform );
        g2D.drawRenderedImage( img, xform );
    }

    public void drawString(AttributedCharacterIterator iterator,
                                    float x, float y)
    {
        System.out.println( ""drawString(AttributedCharacterIterator):"" );
        System.out.println( ""iterator = "" + iterator );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawString( iterator, x, y );
    }







    public void drawString(String s, float x, float y)
    {
        System.out.println( ""drawString(s,x,y):"" );
        System.out.println( ""s = "" + s );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawString( s, x, y );
    }






    public void fill(Shape s)
    {
        System.out.println( ""fill(Shape):"" );
        System.out.println( ""s = "" + s );
        g2D.fill( s );
    }






    public Color getBackground()
    {
        System.out.println( ""getBackground():"" );
        return g2D.getBackground();
    }

    public Composite getComposite()
    {
        System.out.println( ""getComposite():"" );
        return g2D.getComposite();
    }

    public GraphicsConfiguration getDeviceConfiguration()
    {
        System.out.println( ""getDeviceConfiguration():"" );
        return g2D.getDeviceConfiguration();
    }

    public FontRenderContext getFontRenderContext()
    {
        System.out.println( ""getFontRenderContext():"" );
        return g2D.getFontRenderContext();
    }

    public Paint getPaint()
    {
        System.out.println( ""getPaint():"" );
        return g2D.getPaint();
    }

    public Object getRenderingHint(RenderingHints.Key hintKey)
    {
        System.out.println( ""getRenderingHint(RenderingHints.Key):"" );
        System.out.println( ""hintKey = "" + hintKey );
        return g2D.getRenderingHint( hintKey );
    }

    public RenderingHints getRenderingHints()
    {
        System.out.println( ""getRenderingHints():"" );
        return g2D.getRenderingHints();
    }

    public Stroke getStroke()
    {
        System.out.println( ""getStroke():"" );
        return g2D.getStroke();
    }

    public AffineTransform getTransform()
    {
        System.out.println( ""getTransform():"" );
        return g2D.getTransform();
    }

    public boolean hit(Rectangle rect,
				Shape s,
				boolean onStroke)
    {
        System.out.println( ""hit(Rectangle, Shape, onStroke):"" );
        System.out.println( ""rect = "" + rect );
        System.out.println( ""s = "" + s );
        System.out.println( ""onStroke = "" + onStroke );
        return g2D.hit( rect, s, onStroke );
    }

    public void rotate(double theta)
    {
        System.out.println( ""rotate(theta):"" );
        System.out.println( ""theta = "" + theta );
        g2D.rotate( theta );
    }

    public void rotate(double theta, double x, double y)
    {
        System.out.println( ""rotate(double,double,double):"" );
        System.out.println( ""theta = "" + theta );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.rotate( theta, x, y );
    }

    public void scale(double sx, double sy)
    {
        System.out.println( ""scale(double,double):"" );
        System.out.println( ""sx = "" + sx );
        System.out.println( ""sy"" );
        g2D.scale( sx, sy );
    }

    public void setBackground(Color color)
    {
        System.out.println( ""setBackground(Color):"" );
        System.out.println( ""color = "" + color );
        g2D.setBackground( color );
    }

    public void setComposite(Composite comp)
    {
        System.out.println( ""setComposite(Composite):"" );
        System.out.println( ""comp = "" + comp );
        g2D.setComposite( comp );
    }

    public void setPaint( Paint paint )
    {
        System.out.println( ""setPain(Paint):"" );
        System.out.println( ""paint = "" + paint );
        g2D.setPaint( paint );
    }

    public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue)
    {
        System.out.println( ""setRenderingHint(RenderingHints.Key, Object):"" );
        System.out.println( ""hintKey = "" + hintKey );
        System.out.println( ""hintValue = "" + hintValue );
        g2D.setRenderingHint( hintKey, hintValue );
    }

    public void setRenderingHints(Map<?,?> hints)
    {
        System.out.println( ""setRenderingHints(Map):"" );
        System.out.println( ""hints = "" + hints );
        g2D.setRenderingHints( hints );
    }

    public void setStroke(Stroke s)
    {
        System.out.println( ""setStroke(Stoke):"" );
        System.out.println( ""s = "" + s );
        g2D.setStroke( s );
    }

    public void setTransform(AffineTransform Tx)
    {
        System.out.println( ""setTransform():"" );
        System.out.println( ""Tx = "" + Tx );
        g2D.setTransform( Tx );
    }

    public void shear(double shx, double shy)
    {
        System.out.println( ""shear(shx, dhy):"" );
        System.out.println( ""shx = "" + shx );
        System.out.println( ""shy = "" + shy );
        g2D.shear( shx, shy );
    }

    public void transform(AffineTransform Tx)
    {
        System.out.println( ""transform(AffineTransform):"" );
        System.out.println( ""Tx = "" + Tx );
        g2D.transform( Tx );
    }

    public void translate(double tx, double ty)
    {
        System.out.println( ""translate(double, double):"" );
        System.out.println( ""tx = "" + tx );
        System.out.println( ""ty = "" + ty );
        g2D.translate( tx, ty );
    }






    public void clearRect(int x, int y, int width, int height)
    {
        System.out.println( ""clearRect(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.clearRect( x, y, width, height );
    }

    public void clipRect(int x, int y, int width, int height)
    {
        System.out.println( ""clipRect(int, int, int, int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.clipRect( x, y, width, height );
    }

    public void copyArea(int x, int y, int width, int height,
				  int dx, int dy)
    {
        System.out.println( ""copyArea(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.copyArea( x, y, width, height, dx, dy );
    }

    public Graphics create()
    {
        System.out.println( ""create():"" );
        return g2D.create();
    }

    public Graphics create(int x, int y, int width, int height) {
        System.out.println( ""create(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        return g2D.create( x, y, width, height );
    }

    public void dispose()
    {
        System.out.println( ""dispose():"" );
        g2D.dispose();
    }

    public void draw3DRect(int x, int y, int width, int height,
			   boolean raised) {
        System.out.println( ""draw3DRect(int,int,int,int,boolean):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""raised = "" + raised );
        g2D.draw3DRect( x, y, width, height, raised );
    }

    public void drawArc(int x, int y, int width, int height,
				 int startAngle, int arcAngle)
    {
        System.out.println( ""drawArc(int,int,int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""startAngle = "" + startAngle );
        System.out.println( ""arcAngle = "" + arcAngle );
        g2D.drawArc( x, y, width, height, startAngle, arcAngle );
    }

    public void drawBytes(byte data[], int offset, int length, int x, int y) {
        System.out.println( ""drawBytes(byte[],int,int,int,int):"" );
        System.out.println( ""data = "" + data );
        System.out.println( ""offset = "" + offset );
        System.out.println( ""length = "" + length );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawBytes( data, offset, length, x, y );
    }

    public void drawChars(char data[], int offset, int length, int x, int y) {
        System.out.println( ""drawChars(data,int,int,int,int):"" );
        System.out.println( ""data = "" + data.toString() );
        System.out.println( ""offset = "" + offset );
        System.out.println( ""length = "" + length );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawChars( data, offset, length, x, y );
    }

    public boolean drawImage(Image img,
				      int dx1, int dy1, int dx2, int dy2,
				      int sx1, int sy1, int sx2, int sy2,
				      ImageObserver observer)
    {
        System.out.println( ""drawImage(Image,int,int,int,int,int,int,int,int,ImageObserver):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""dx1 = "" + dx1 );
        System.out.println( ""dy1 = "" + dy1 );
        System.out.println( ""dx2 = "" + dx2 );
        System.out.println( ""dy2 = "" + dy2 );
        System.out.println( ""sx1 = "" + sx1 );
        System.out.println( ""sy1 = "" + sy1 );
        System.out.println( ""sx2 = "" + sx2 );
        System.out.println( ""sy2 = "" + sy2 );
        System.out.println( ""observer = "" + observer );
        return g2D.drawImage( img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer );
    }

    public boolean drawImage(Image img,
				      int dx1, int dy1, int dx2, int dy2,
				      int sx1, int sy1, int sx2, int sy2,
				      Color bgcolor,
				      ImageObserver observer)
    {
        System.out.println( ""drawImage(Image,int,int,int,int,int,int,int,int,Color,ImageObserver):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""dx1 = "" + dx1 );
        System.out.println( ""dy1 = "" + dy1 );
        System.out.println( ""dx2 = "" + dx2 );
        System.out.println( ""dy2 = "" + dy2 );
        System.out.println( ""sx1 = "" + sx1 );
        System.out.println( ""sy1 = "" + sy1 );
        System.out.println( ""sx2 = "" + sx2 );
        System.out.println( ""sy2 = "" + sy2 );
        System.out.println( ""bgcolor = "" + bgcolor );
        System.out.println( ""observer = "" + observer );
        return g2D.drawImage( img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer );
    }

    public boolean drawImage(Image img, int x, int y,
				      Color bgcolor,
				      ImageObserver observer)
    {
        System.out.println( ""drawImage(Image,int,int,Color,ImageObserver):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""bgcolor = "" + bgcolor );
        System.out.println( ""observer = "" + observer );
        return g2D.drawImage( img, x, y, bgcolor, observer );
    }

    public boolean drawImage(Image img, int x, int y,
				      ImageObserver observer)
    {
        System.out.println( ""drawImage(Image,int,int,observer):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""observer = "" + observer );
        return g2D.drawImage( img, x, y, observer );
    }

    public boolean drawImage(Image img, int x, int y,
				      int width, int height,
				      Color bgcolor,
				      ImageObserver observer)
    {
        System.out.println( ""drawImage(Image,int,int,int,int,Color,ImageObserver):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""bgcolor = "" + bgcolor );
        System.out.println( ""observer = "" + observer );
        return g2D.drawImage( img, x, y, width, height, bgcolor, observer );
    }

    public boolean drawImage(Image img, int x, int y,
				      int width, int height,
				      ImageObserver observer)
    {
        System.out.println( ""drawImage(Image,int,int,width,height,observer):"" );
        System.out.println( ""img = "" + img );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""observer = "" + observer );
        return g2D.drawImage( img, x, y, width, height, observer );
    }

    public void drawLine(int x1, int y1, int x2, int y2)
    {
        System.out.println( ""drawLine(int,int,int,int):"" );
        System.out.println( ""x1 = "" + x1 );
        System.out.println( ""y1 = "" + y1 );
        System.out.println( ""x2 = "" + x2 );
        System.out.println( ""y2 = "" + y2 );
        g2D.drawLine( x1, y1, x2, y2 );
    }

    public void drawOval(int x, int y, int width, int height)
    {
        System.out.println( ""drawOval(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.drawOval( x, y, width, height );
    }

    public void drawPolygon(Polygon p) {
        System.out.println( ""drawPolygon(Polygon):"" );
        System.out.println( ""p = "" + p );
        g2D.drawPolygon( p );
    }

    public void drawPolygon(int xPoints[], int yPoints[],
				     int nPoints)
    {
        System.out.println( ""drawPolygon(int[],int[],int):"" );
        System.out.println( ""xPoints = "" + xPoints );
        System.out.println( ""yPoints = "" + yPoints );
        System.out.println( ""nPoints = "" + nPoints );
        g2D.drawPolygon( xPoints, yPoints, nPoints );
    }

    public void drawPolyline(int xPoints[], int yPoints[],
				      int nPoints)
    {
        System.out.println( ""drawPolyline(int[],int[],int):"" );
        System.out.println( ""xPoints = "" + xPoints );
        System.out.println( ""yPoints = "" + yPoints );
        System.out.println( ""nPoints = "" + nPoints );
        g2D.drawPolyline( xPoints, yPoints, nPoints );
    }

    public void drawRect(int x, int y, int width, int height) {
        System.out.println( ""drawRect(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.drawRect( x, y, width, height );
    }

    public void drawRoundRect(int x, int y, int width, int height,
				       int arcWidth, int arcHeight)
    {
        System.out.println( ""drawRoundRect(int,int,int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""arcWidth = "" + arcWidth );
        System.out.println( ""arcHeight = "" + arcHeight );
        g2D.drawRoundRect( x, y, width, height, arcWidth, arcHeight );
    }

    public void drawString(AttributedCharacterIterator iterator,
                                    int x, int y)
    {
        System.out.println( ""drawString(AttributedCharacterIterator,int,int):"" );
        System.out.println( ""iterator = "" + iterator );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawString( iterator, x, y );
    }

    public void drawString(String str, int x, int y)
    {
        System.out.println( ""drawString(str,int,int):"" );
        System.out.println( ""str = "" + str );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.drawString( str, x, y );
    }

    public void fill3DRect(int x, int y, int width, int height,
			   boolean raised) {
        System.out.println( ""fill3DRect(int,int,int,int,boolean):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""raised = "" + raised );
        g2D.fill3DRect( x, y, width, height, raised );
    }

    public void fillArc(int x, int y, int width, int height,
				 int startAngle, int arcAngle)
    {
        System.out.println( ""fillArc(int,int,int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        System.out.println( ""startAngle = "" + startAngle );
        System.out.println( ""arcAngle = "" + arcAngle );
        g2D.fillArc( x, y, width, height, startAngle, arcAngle );
    }

    public void fillOval(int x, int y, int width, int height)
    {
        System.out.println( ""fillOval(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.fillOval( x, y, width, height );
    }

    public void fillPolygon(Polygon p) {
        System.out.println( ""fillPolygon(Polygon):"" );
        System.out.println( ""p = "" + p );
        g2D.fillPolygon( p );
    }

    public void fillPolygon(int xPoints[], int yPoints[],
				     int nPoints)
    {
        System.out.println( ""fillPolygon(int[],int[],int):"" );
        System.out.println( ""xPoints = "" + xPoints );
        System.out.println( ""yPoints = "" + yPoints );
        System.out.println( ""nPoints = "" + nPoints );
        g2D.fillPolygon( xPoints, yPoints, nPoints );
    }

    public void fillRect(int x, int y, int width, int height)
    {
        System.out.println( ""fillRect(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.fillRect( x, y, width, height );
    }

    public void fillRoundRect(int x, int y, int width, int height,
				       int arcWidth, int arcHeight)
    {
        System.out.println( ""fillRoundRect(int,int,int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.fillRoundRect( x, y, width, height, arcWidth, arcHeight );
    }

    public void finalize() {
        System.out.println( ""finalize():"" );
        g2D.finalize();

        super.finalize();
    }

    public Shape getClip()
    {
        System.out.println( ""getClip():"" );
        return g2D.getClip();
    }

    public Rectangle getClipBounds()
    {
        System.out.println( ""getClipBounds():"" );
        return g2D.getClipBounds();
    }

    public Rectangle getClipBounds(Rectangle r) {
        System.out.println( ""getClipBounds(Rectangle):"" );
        System.out.println( ""r = "" + r );
        return g2D.getClipBounds( r );
    }

    @SuppressWarnings(""deprecation"")
    public Rectangle getClipRect() {
        System.out.println( ""getClipRect():"" );
        return g2D.getClipRect();
    }

    public Color getColor()
    {
        System.out.println( ""getColor():"" );
        return g2D.getColor();
    }

    public Font getFont()
    {
        System.out.println( ""getFont():"" );
        return g2D.getFont();
    }

    public FontMetrics getFontMetrics() {
        System.out.println( ""getFontMetrics():"" );
        return g2D.getFontMetrics();
    }

    public FontMetrics getFontMetrics(Font f)
    {
        System.out.println( ""getFontMetrics():"" );
        return g2D.getFontMetrics( f );
    }

    public boolean hitClip(int x, int y, int width, int height) {
        System.out.println( ""hitClip(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        return g2D.hitClip( x, y, width, height );
    }

    public void setClip(Shape clip)
    {
        System.out.println( ""setClip(Shape):"" );
        System.out.println( ""clip = "" + clip );
        g2D.setClip( clip );
    }

    public void setClip(int x, int y, int width, int height)
    {
        System.out.println( ""setClip(int,int,int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        System.out.println( ""width = "" + width );
        System.out.println( ""height = "" + height );
        g2D.setClip( x, y, width, height );
    }

    public void setColor(Color c)
    {
        System.out.println( ""setColor():"" );
        System.out.println( ""c = "" + c );
        g2D.setColor( c );
    }

    public void setFont(Font font)
    {
        System.out.println( ""setFont(Font):"" );
        System.out.println( ""font = "" + font );
        g2D.setFont( font );
    }

    public void setPaintMode()
    {
        System.out.println( ""setPaintMode():"" );
        g2D.setPaintMode();
    }

    public void setXORMode(Color c1)
    {
        System.out.println( ""setXORMode(Color):"" );
        System.out.println( ""c1 = "" + c1 );
        g2D.setXORMode( c1 );
    }

    public String toString() {
        System.out.println( ""toString():"" );
        return g2D.toString();
    }

    public void translate(int x, int y)
    {
        System.out.println( ""translate(int,int):"" );
        System.out.println( ""x = "" + x );
        System.out.println( ""y = "" + y );
        g2D.translate( x, y );
    }
}
"
poi,3,org.apache.poi.ddf.EscherProperty,10,1,2,14,12,3,13,1,10,0.333333333,69,1.0,0,0.0,0.34,0,0,5.8,2,1.0,1,"

package org.apache.poi.ddf;


public abstract class EscherProperty {
    private short  _id;

    
    public EscherProperty(short id) {
        _id   = id;
    }

    
    public EscherProperty(short propertyNumber, boolean isComplex, boolean isBlipId) {
        _id   = (short)(propertyNumber +
                (isComplex ? 0x8000 : 0x0) +
                (isBlipId ? 0x4000 : 0x0));
    }

    public short getId() {
        return _id;
    }

    public short getPropertyNumber() {
        return (short) (_id & (short) 0x3FFF);
    }

    public boolean isComplex() {
        return (_id & (short) 0x8000) != 0;
    }

    public boolean isBlipId() {
        return (_id & (short) 0x4000) != 0;
    }

    public String getName() {
        return EscherProperties.getPropertyName(getPropertyNumber());
    }

    
    public int getPropertySize() {
        return 6;
    }
    
    public String toXml(String tab){
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("" id="""").append(getId()).append("""" name="""").append(getName()).append("""" blipId="""")
                .append(isBlipId()).append(""""/>
"");
        return builder.toString();
    }

    
    abstract public int serializeSimplePart( byte[] data, int pos );
    
    abstract public int serializeComplexPart( byte[] data, int pos );
}
"
poi,3,org.apache.poi.hssf.record.GutsRecord,17,2,0,6,26,94,2,4,15,0.7625,207,0.8,0,0.423076923,0.305882353,1,4,10.88235294,2,0.9412,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class GutsRecord
    extends StandardRecord
{
    public final static short sid = 0x80;
    private short             field_1_left_row_gutter;   
    private short             field_2_top_col_gutter;    
    private short             field_3_row_level_max;     
    private short             field_4_col_level_max;     

    public GutsRecord()
    {
    }

    public GutsRecord(RecordInputStream in)
    {
        field_1_left_row_gutter = in.readShort();
        field_2_top_col_gutter  = in.readShort();
        field_3_row_level_max   = in.readShort();
        field_4_col_level_max   = in.readShort();
    }

    

    public void setLeftRowGutter(short gut)
    {
        field_1_left_row_gutter = gut;
    }

    

    public void setTopColGutter(short gut)
    {
        field_2_top_col_gutter = gut;
    }

    

    public void setRowLevelMax(short max)
    {
        field_3_row_level_max = max;
    }

    

    public void setColLevelMax(short max)
    {
        field_4_col_level_max = max;
    }

    

    public short getLeftRowGutter()
    {
        return field_1_left_row_gutter;
    }

    

    public short getTopColGutter()
    {
        return field_2_top_col_gutter;
    }

    

    public short getRowLevelMax()
    {
        return field_3_row_level_max;
    }

    

    public short getColLevelMax()
    {
        return field_4_col_level_max;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[GUTS]
"");
        buffer.append(""    .leftgutter     = "")
            .append(Integer.toHexString(getLeftRowGutter())).append(""
"");
        buffer.append(""    .topgutter      = "")
            .append(Integer.toHexString(getTopColGutter())).append(""
"");
        buffer.append(""    .rowlevelmax    = "")
            .append(Integer.toHexString(getRowLevelMax())).append(""
"");
        buffer.append(""    .collevelmax    = "")
            .append(Integer.toHexString(getColLevelMax())).append(""
"");
        buffer.append(""[/GUTS]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getLeftRowGutter());
        out.writeShort(getTopColGutter());
        out.writeShort(getRowLevelMax());
        out.writeShort(getColLevelMax());
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      GutsRecord rec = new GutsRecord();
      rec.field_1_left_row_gutter = field_1_left_row_gutter;
      rec.field_2_top_col_gutter = field_2_top_col_gutter;
      rec.field_3_row_level_max = field_3_row_level_max;
      rec.field_4_col_level_max = field_4_col_level_max;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.util.Region,16,1,0,3,17,78,2,1,16,0.533333333,172,1.0,0,0.0,0.291666667,0,0,9.5,9,1.625,0,"


package org.apache.poi.hssf.util;



public class Region extends org.apache.poi.ss.util.Region
{
    
    public Region()
    {
		super();
    }

    public Region(int rowFrom, short colFrom, int rowTo, short colTo)
    {
		super(rowFrom, colFrom, rowTo, colTo);
    }

    public Region(String ref) {
		super(ref);
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFWorkbook,65,1,0,44,248,100,4,41,52,0.926470588,2273,0.470588235,4,0.0,0.129166667,0,0,33.70769231,32,2.3077,14,"

package org.apache.poi.hssf.usermodel;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.POIDocument;
import org.apache.poi.ddf.EscherBSERecord;
import org.apache.poi.ddf.EscherBitmapBlip;
import org.apache.poi.ddf.EscherBlipRecord;
import org.apache.poi.ddf.EscherMetafileBlip;
import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.hpsf.ClassID;
import org.apache.poi.hssf.OldExcelFormatException;
import org.apache.poi.hssf.model.DrawingManager2;
import org.apache.poi.hssf.model.HSSFFormulaParser;
import org.apache.poi.hssf.model.InternalSheet;
import org.apache.poi.hssf.model.InternalSheet.UnsupportedBOFType;
import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.model.RecordStream;
import org.apache.poi.hssf.record.AbstractEscherHolderRecord;
import org.apache.poi.hssf.record.BackupRecord;
import org.apache.poi.hssf.record.DrawingGroupRecord;
import org.apache.poi.hssf.record.ExtendedFormatRecord;
import org.apache.poi.hssf.record.FontRecord;
import org.apache.poi.hssf.record.LabelRecord;
import org.apache.poi.hssf.record.LabelSSTRecord;
import org.apache.poi.hssf.record.NameRecord;
import org.apache.poi.hssf.record.RecalcIdRecord;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RecordFactory;
import org.apache.poi.hssf.record.SSTRecord;
import org.apache.poi.hssf.record.UnknownRecord;
import org.apache.poi.hssf.record.aggregates.RecordAggregate.RecordVisitor;
import org.apache.poi.hssf.record.common.UnicodeString;
import org.apache.poi.hssf.util.CellReference;
import org.apache.poi.poifs.crypt.Decryptor;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.EntryUtils;
import org.apache.poi.poifs.filesystem.FilteringDirectoryNode;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.Ole10Native;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.ss.formula.FormulaShifter;
import org.apache.poi.ss.formula.FormulaType;
import org.apache.poi.ss.formula.SheetNameFormatter;
import org.apache.poi.ss.formula.udf.AggregatingUDFFinder;
import org.apache.poi.ss.formula.udf.IndexedUDFFinder;
import org.apache.poi.ss.formula.udf.UDFFinder;
import org.apache.poi.ss.usermodel.Row.MissingCellPolicy;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.WorkbookUtil;
import org.apache.poi.util.Configurator;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;



public final class HSSFWorkbook extends POIDocument implements org.apache.poi.ss.usermodel.Workbook {
    private static final Pattern COMMA_PATTERN = Pattern.compile("","");

    
    private static final int MAX_STYLES = 4030;

    private static final int DEBUG = POILogger.DEBUG;

    

    public final static int INITIAL_CAPACITY = Configurator.getIntValue(""HSSFWorkbook.SheetInitialCapacity"",3);

    

    private InternalWorkbook workbook;

    

    protected List<HSSFSheet> _sheets;

    

    private ArrayList<HSSFName> names;

    
    private Hashtable<Short,HSSFFont> fonts;

    
    private boolean   preserveNodes;

    
    private HSSFDataFormat formatter;

    
    private MissingCellPolicy missingCellPolicy = HSSFRow.RETURN_NULL_AND_BLANK;

    private static POILogger log = POILogFactory.getLogger(HSSFWorkbook.class);

    
    private UDFFinder _udfFinder = new IndexedUDFFinder(UDFFinder.DEFAULT);

    public static HSSFWorkbook create(InternalWorkbook book) {
    	return new HSSFWorkbook(book);
    }
    
    public HSSFWorkbook() {
        this(InternalWorkbook.createWorkbook());
    }

    private HSSFWorkbook(InternalWorkbook book) {
        super((DirectoryNode)null);
        workbook = book;
        _sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);
        names = new ArrayList<HSSFName>(INITIAL_CAPACITY);
    }

    
    public HSSFWorkbook(POIFSFileSystem fs) throws IOException {
        this(fs,true);
    }
    
    public HSSFWorkbook(NPOIFSFileSystem fs) throws IOException {
        this(fs.getRoot(),true);
    }

    
    public HSSFWorkbook(POIFSFileSystem fs, boolean preserveNodes)
            throws IOException {
        this(fs.getRoot(), fs, preserveNodes);
    }

    
    private static final String[] WORKBOOK_DIR_ENTRY_NAMES = {
        ""Workbook"", 
        ""WORKBOOK"", 
        ""BOOK"",     
    };


    public static String getWorkbookDirEntryName(DirectoryNode directory) {

        for (int i = 0; i < WORKBOOK_DIR_ENTRY_NAMES.length; i++) {
            String wbName = WORKBOOK_DIR_ENTRY_NAMES[i];
            try {
                directory.getEntry(wbName);
                return wbName;
            } catch (FileNotFoundException e) {
                
            }
        }
        
        
        try {
        	directory.getEntry(Decryptor.DEFAULT_POIFS_ENTRY);
        	throw new EncryptedDocumentException(""The supplied spreadsheet seems to be an Encrypted .xlsx file. "" +
        			""It must be decrypted before use by XSSF, it cannot be used by HSSF"");
        } catch (FileNotFoundException e) {
            
        }

        
        try {
            directory.getEntry(""Book"");
            throw new OldExcelFormatException(""The supplied spreadsheet seems to be Excel 5.0/7.0 (BIFF5) format. ""
                    + ""POI only supports BIFF8 format (from Excel versions 97/2000/XP/2003)"");
        } catch (FileNotFoundException e) {
            
        }

        throw new IllegalArgumentException(""The supplied POIFSFileSystem does not contain a BIFF8 'Workbook' entry. ""
            + ""Is it really an excel file?"");
    }

    
    public HSSFWorkbook(DirectoryNode directory, POIFSFileSystem fs, boolean preserveNodes)
            throws IOException
    {
       this(directory, preserveNodes);
    }

    
    public HSSFWorkbook(DirectoryNode directory, boolean preserveNodes)
            throws IOException
    {
        super(directory);
        String workbookName = getWorkbookDirEntryName(directory);

        this.preserveNodes = preserveNodes;

        
        
        if(! preserveNodes) {
           this.directory = null;
        }

        _sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);
        names  = new ArrayList<HSSFName>(INITIAL_CAPACITY);

        
        
        InputStream stream = directory.createDocumentInputStream(workbookName);

        List<Record> records = RecordFactory.createRecords(stream);

        workbook = InternalWorkbook.createWorkbook(records);
        setPropertiesFromWorkbook(workbook);
        int recOffset = workbook.getNumRecords();

        
        convertLabelRecords(records, recOffset);
        RecordStream rs = new RecordStream(records, recOffset);
        while (rs.hasNext()) {
            try {
                InternalSheet sheet = InternalSheet.createSheet(rs);
                _sheets.add(new HSSFSheet(this, sheet));
            } catch (UnsupportedBOFType eb) {
                
                log.log(POILogger.WARN, ""Unsupported BOF found of type "" + eb.getType());
            }
        }

        for (int i = 0 ; i < workbook.getNumNames() ; ++i){
            NameRecord nameRecord = workbook.getNameRecord(i);
            HSSFName name = new HSSFName(this, nameRecord, workbook.getNameCommentRecord(nameRecord));
            names.add(name);
        }
    }

    
    public HSSFWorkbook(InputStream s) throws IOException {
        this(s,true);
    }

    
    public HSSFWorkbook(InputStream s, boolean preserveNodes)
            throws IOException
    {
        this(new NPOIFSFileSystem(s).getRoot(), preserveNodes);
    }

    

    private void setPropertiesFromWorkbook(InternalWorkbook book)
    {
        this.workbook = book;

        
    }

    

     private void convertLabelRecords(List<Record> records, int offset)
     {
         if (log.check( POILogger.DEBUG ))
             log.log(POILogger.DEBUG, ""convertLabelRecords called"");
         for (int k = offset; k < records.size(); k++)
         {
             Record rec = records.get(k);

             if (rec.getSid() == LabelRecord.sid)
             {
                 LabelRecord oldrec = ( LabelRecord ) rec;

                 records.remove(k);
                 LabelSSTRecord newrec   = new LabelSSTRecord();
                 int            stringid =
                     workbook.addSSTString(new UnicodeString(oldrec.getValue()));

                 newrec.setRow(oldrec.getRow());
                 newrec.setColumn(oldrec.getColumn());
                 newrec.setXFIndex(oldrec.getXFIndex());
                 newrec.setSSTIndex(stringid);
                       records.add(k, newrec);
             }
         }
         if (log.check( POILogger.DEBUG ))
             log.log(POILogger.DEBUG, ""convertLabelRecords exit"");
     }

    
    public MissingCellPolicy getMissingCellPolicy() {
        return missingCellPolicy;
    }

    
    public void setMissingCellPolicy(MissingCellPolicy missingCellPolicy) {
        this.missingCellPolicy = missingCellPolicy;
    }

    

    public void setSheetOrder(String sheetname, int pos ) {
        int oldSheetIndex = getSheetIndex(sheetname);
        _sheets.add(pos,_sheets.remove(oldSheetIndex));
        workbook.setSheetOrder(sheetname, pos);

        FormulaShifter shifter = FormulaShifter.createForSheetShift(oldSheetIndex, pos);
        for (HSSFSheet sheet : _sheets) {
            sheet.getSheet().updateFormulasAfterCellShift(shifter,  -1 );
        }

        workbook.updateNamesAfterCellShift(shifter);

        
        int active = getActiveSheetIndex();
        if(active == oldSheetIndex) {
            
            setActiveSheet(pos);
        } else if ((active < oldSheetIndex && active < pos) ||
                (active > oldSheetIndex && active > pos)) {
            
        } else if (pos > oldSheetIndex) {
            
            setActiveSheet(active-1);
        } else {
            
            setActiveSheet(active+1);
        }
    }

    private void validateSheetIndex(int index) {
        int lastSheetIx = _sheets.size() - 1;
        if (index < 0 || index > lastSheetIx) {
            String range = ""(0.."" +    lastSheetIx + "")"";
            if (lastSheetIx == -1) {
                range = ""(no sheets)"";
            }
            throw new IllegalArgumentException(""Sheet index (""
                    + index +"") is out of range "" + range);
        }
    }

    
    public void setSelectedTab(int index) {

        validateSheetIndex(index);
        int nSheets = _sheets.size();
        for (int i=0; i<nSheets; i++) {
               getSheetAt(i).setSelected(i == index);
        }
        workbook.getWindowOne().setNumSelectedTabs((short)1);
    }
    
    @Deprecated
	public void setSelectedTab(short index) {
        setSelectedTab((int)index);
    }
    public void setSelectedTabs(int[] indexes) {

        for (int i = 0; i < indexes.length; i++) {
            validateSheetIndex(indexes[i]);
        }
        int nSheets = _sheets.size();
        for (int i=0; i<nSheets; i++) {
            boolean bSelect = false;
            for (int j = 0; j < indexes.length; j++) {
                if (indexes[j] == i) {
                    bSelect = true;
                    break;
                }

            }
               getSheetAt(i).setSelected(bSelect);
        }
        workbook.getWindowOne().setNumSelectedTabs((short)indexes.length);
    }
    
    public void setActiveSheet(int index) {

        validateSheetIndex(index);
        int nSheets = _sheets.size();
        for (int i=0; i<nSheets; i++) {
             getSheetAt(i).setActive(i == index);
        }
        workbook.getWindowOne().setActiveSheetIndex(index);
    }

    
    public int getActiveSheetIndex() {
        return workbook.getWindowOne().getActiveSheetIndex();
    }
    
    @Deprecated
	public short getSelectedTab() {
        return (short) getActiveSheetIndex();
    }


    
    public void setFirstVisibleTab(int index) {
        workbook.getWindowOne().setFirstVisibleTab(index);
    }
    
    @Deprecated
	public void setDisplayedTab(short index) {
       setFirstVisibleTab(index);
    }

    
    public int getFirstVisibleTab() {
        return workbook.getWindowOne().getFirstVisibleTab();
    }
    
    @Deprecated
	public short getDisplayedTab() {
        return (short) getFirstVisibleTab();
    }

    
    public void setSheetName(int sheetIx, String name) {
        if (name == null) {
            throw new IllegalArgumentException(""sheetName must not be null"");
        }

        if (workbook.doesContainsSheetName(name, sheetIx)) {
            throw new IllegalArgumentException(""The workbook already contains a sheet with this name"");
        }
        validateSheetIndex(sheetIx);
        workbook.setSheetName(sheetIx, name);
    }

    
    public String getSheetName(int sheetIndex) {
        validateSheetIndex(sheetIndex);
        return workbook.getSheetName(sheetIndex);
    }

    public boolean isHidden() {
        return workbook.getWindowOne().getHidden();
    }

    public void setHidden(boolean hiddenFlag) {
        workbook.getWindowOne().setHidden(hiddenFlag);
    }

    public boolean isSheetHidden(int sheetIx) {
        validateSheetIndex(sheetIx);
        return workbook.isSheetHidden(sheetIx);
    }

    public boolean isSheetVeryHidden(int sheetIx) {
        validateSheetIndex(sheetIx);
        return workbook.isSheetVeryHidden(sheetIx);
    }


    public void setSheetHidden(int sheetIx, boolean hidden) {
        validateSheetIndex(sheetIx);
        workbook.setSheetHidden(sheetIx, hidden);
    }

    public void setSheetHidden(int sheetIx, int hidden) {
        validateSheetIndex(sheetIx);
        WorkbookUtil.validateSheetState(hidden);
        workbook.setSheetHidden(sheetIx, hidden);
    }

    
    public int getSheetIndex(String name){
        return workbook.getSheetIndex(name);
    }

    
    public int getSheetIndex(org.apache.poi.ss.usermodel.Sheet sheet) {
        for(int i=0; i<_sheets.size(); i++) {
            if(_sheets.get(i) == sheet) {
                return i;
            }
        }
        return -1;
    }

    
    @Deprecated
	public int getExternalSheetIndex(int internalSheetIndex) {
        return workbook.checkExternSheet(internalSheetIndex);
    }
    
    @Deprecated
	public String findSheetNameFromExternSheet(int externSheetIndex){
        
        return workbook.findSheetFirstNameFromExternSheet(externSheetIndex);
    }
    
    @Deprecated
	public String resolveNameXText(int refIndex, int definedNameIndex) {
        
        return workbook.resolveNameXText(refIndex, definedNameIndex);
    }

    

    public HSSFSheet createSheet()
    {
        HSSFSheet sheet = new HSSFSheet(this);

        _sheets.add(sheet);
        workbook.setSheetName(_sheets.size() - 1, ""Sheet"" + (_sheets.size() - 1));
        boolean isOnlySheet = _sheets.size() == 1;
        sheet.setSelected(isOnlySheet);
        sheet.setActive(isOnlySheet);
        return sheet;
    }

    

    public HSSFSheet cloneSheet(int sheetIndex) {
        validateSheetIndex(sheetIndex);
        HSSFSheet srcSheet = _sheets.get(sheetIndex);
        String srcName = workbook.getSheetName(sheetIndex);
        HSSFSheet clonedSheet = srcSheet.cloneSheet(this);
        clonedSheet.setSelected(false);
        clonedSheet.setActive(false);

        String name = getUniqueSheetName(srcName);
        int newSheetIndex = _sheets.size();
        _sheets.add(clonedSheet);
        workbook.setSheetName(newSheetIndex, name);

        
        int filterDbNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_FILTER_DB);
        if (filterDbNameIndex != -1) {
            NameRecord newNameRecord = workbook.cloneFilter(filterDbNameIndex, newSheetIndex);
            HSSFName newName = new HSSFName(this, newNameRecord);
            names.add(newName);
        }
        


        return clonedSheet;
    }

    private String getUniqueSheetName(String srcName) {
        int uniqueIndex = 2;
        String baseName = srcName;
        int bracketPos = srcName.lastIndexOf('(');
        if (bracketPos > 0 && srcName.endsWith("")"")) {
            String suffix = srcName.substring(bracketPos + 1, srcName.length() - "")"".length());
            try {
                uniqueIndex = Integer.parseInt(suffix.trim());
                uniqueIndex++;
                baseName=srcName.substring(0, bracketPos).trim();
            } catch (NumberFormatException e) {
                
            }
        }
        while (true) {
            
            String index = Integer.toString(uniqueIndex++);
            String name;
            if (baseName.length() + index.length() + 2 < 31) {
                name = baseName + "" ("" + index + "")"";
            } else {
                name = baseName.substring(0, 31 - index.length() - 2) + ""("" + index + "")"";
            }

            
            if (workbook.getSheetIndex(name) == -1) {
              return name;
            }
        }
    }

    
    public HSSFSheet createSheet(String sheetname)
    {
        if (sheetname == null) {
            throw new IllegalArgumentException(""sheetName must not be null"");
        }

        if (workbook.doesContainsSheetName( sheetname, _sheets.size() ))
            throw new IllegalArgumentException( ""The workbook already contains a sheet of this name"" );

        HSSFSheet sheet = new HSSFSheet(this);

        workbook.setSheetName(_sheets.size(), sheetname);
        _sheets.add(sheet);
        boolean isOnlySheet = _sheets.size() == 1;
        sheet.setSelected(isOnlySheet);
        sheet.setActive(isOnlySheet);
        return sheet;
    }

    

    public int getNumberOfSheets()
    {
        return _sheets.size();
    }

    
    @Deprecated
    public int getSheetIndexFromExternSheetIndex(int externSheetNumber) {
        
        return workbook.getFirstSheetIndexFromExternSheetIndex(externSheetNumber);
    }

    private HSSFSheet[] getSheets() {
        HSSFSheet[] result = new HSSFSheet[_sheets.size()];
        _sheets.toArray(result);
        return result;
    }

    

    public HSSFSheet getSheetAt(int index)
    {
        validateSheetIndex(index);
        return _sheets.get(index);
    }

    

    public HSSFSheet getSheet(String name)
    {
        HSSFSheet retval = null;

        for (int k = 0; k < _sheets.size(); k++)
        {
            String sheetname = workbook.getSheetName(k);

            if (sheetname.equalsIgnoreCase(name))
            {
                retval = _sheets.get(k);
            }
        }
        return retval;
    }

    
    public void removeSheetAt(int index) {
        validateSheetIndex(index);
        boolean wasSelected = getSheetAt(index).isSelected();

        _sheets.remove(index);
        workbook.removeSheet(index);

        
        int nSheets = _sheets.size();
        if (nSheets < 1) {
            
            return;
        }
        
        int newSheetIndex = index;
        if (newSheetIndex >= nSheets) {
            newSheetIndex = nSheets-1;
        }

        if (wasSelected) {
            boolean someOtherSheetIsStillSelected = false;
            for (int i =0; i < nSheets; i++) {
                if (getSheetAt(i).isSelected()) {
                    someOtherSheetIsStillSelected = true;
                    break;
                }
            }
            if (!someOtherSheetIsStillSelected) {
                setSelectedTab(newSheetIndex);
            }
        }

        
        int active = getActiveSheetIndex();
        if(active == index) {
            
            setActiveSheet(newSheetIndex);
        } else if (active > index) {
            
            setActiveSheet(active-1);
        }
    }

    

    public void setBackupFlag(boolean backupValue)
    {
        BackupRecord backupRecord = workbook.getBackupRecord();

        backupRecord.setBackup(backupValue ? (short) 1
                : (short) 0);
    }

    

    public boolean getBackupFlag()
    {
        BackupRecord backupRecord = workbook.getBackupRecord();

        return (backupRecord.getBackup() == 0) ? false
                : true;
    }

    
    @Deprecated
	public void setRepeatingRowsAndColumns(int sheetIndex,
                                           int startColumn, int endColumn,
                                           int startRow, int endRow) {
      HSSFSheet sheet = getSheetAt(sheetIndex);

      CellRangeAddress rows = null;
      CellRangeAddress cols = null;

      if (startRow != -1) {
        rows = new CellRangeAddress(startRow, endRow, -1, -1);
      }
      if (startColumn != -1) {
        cols = new CellRangeAddress(-1, -1, startColumn, endColumn);
      }

      sheet.setRepeatingRows(rows);
      sheet.setRepeatingColumns(cols);
    }


    int findExistingBuiltinNameRecordIdx(int sheetIndex, byte builtinCode) {
        for(int defNameIndex =0; defNameIndex<names.size(); defNameIndex++) {
            NameRecord r = workbook.getNameRecord(defNameIndex);
            if (r == null) {
                throw new RuntimeException(""Unable to find all defined names to iterate over"");
            }
            if (!r.isBuiltInName() || r.getBuiltInName() != builtinCode) {
                continue;
            }
            if (r.getSheetNumber() -1 == sheetIndex) {
                return defNameIndex;
            }
        }
        return -1;
    }


    HSSFName createBuiltInName(byte builtinCode, int sheetIndex) {
      NameRecord nameRecord =
        workbook.createBuiltInName(builtinCode, sheetIndex + 1);
      HSSFName newName = new HSSFName(this, nameRecord, null);
      names.add(newName);
      return newName;
    }


    HSSFName getBuiltInName(byte builtinCode, int sheetIndex) {
      int index = findExistingBuiltinNameRecordIdx(sheetIndex, builtinCode);
      if (index < 0) {
        return null;
      } else {
        return names.get(index);
      }
    }


    

    public HSSFFont createFont()
    {
         workbook.createNewFont();
        short fontindex = (short) (getNumberOfFonts() - 1);

        if (fontindex > 3)
        {
            fontindex++;   
        }
        if(fontindex == Short.MAX_VALUE){
            throw new IllegalArgumentException(""Maximum number of fonts was exceeded"");
        }

        
        
        return getFontAt(fontindex);
    }

    
    public HSSFFont findFont(short boldWeight, short color, short fontHeight,
                             String name, boolean italic, boolean strikeout,
                             short typeOffset, byte underline)
    {
        for (short i=0; i<=getNumberOfFonts(); i++) {
            
            if(i == 4) continue;

            HSSFFont hssfFont = getFontAt(i);
            if (hssfFont.getBoldweight() == boldWeight
                    && hssfFont.getColor() == color
                    && hssfFont.getFontHeight() == fontHeight
                    && hssfFont.getFontName().equals(name)
                    && hssfFont.getItalic() == italic
                    && hssfFont.getStrikeout() == strikeout
                    && hssfFont.getTypeOffset() == typeOffset
                    && hssfFont.getUnderline() == underline)
            {
                return hssfFont;
            }
        }

        return null;
    }

    

    public short getNumberOfFonts()
    {
        return (short) workbook.getNumberOfFontRecords();
    }

    
    public HSSFFont getFontAt(short idx) {
        if(fonts == null) fonts = new Hashtable<Short, HSSFFont>();

        
        
        
        Short sIdx = Short.valueOf(idx);
        if(fonts.containsKey(sIdx)) {
            return fonts.get(sIdx);
        }

        FontRecord font = workbook.getFontRecordAt(idx);
        HSSFFont retval = new HSSFFont(idx, font);
        fonts.put(sIdx, retval);

        return retval;
    }

    
    protected void resetFontCache() {
        fonts = new Hashtable<Short, HSSFFont>();
    }

    

    public HSSFCellStyle createCellStyle()
    {
        if(workbook.getNumExFormats() == MAX_STYLES) {
            throw new IllegalStateException(""The maximum number of cell styles was exceeded. "" +
                    ""You can define up to 4000 styles in a .xls workbook"");
        }
        ExtendedFormatRecord xfr = workbook.createCellXF();
        short index = (short) (getNumCellStyles() - 1);
        HSSFCellStyle style = new HSSFCellStyle(index, xfr, this);

        return style;
    }

    

    public short getNumCellStyles()
    {
        return (short) workbook.getNumExFormats();
    }

    
    public HSSFCellStyle getCellStyleAt(short idx)
    {
        ExtendedFormatRecord xfr = workbook.getExFormatAt(idx);
        HSSFCellStyle style = new HSSFCellStyle(idx, xfr, this);

        return style;
    }
    
    
    @Override
    public void close() throws IOException
    {
        if (directory != null) {
            if (directory.getNFileSystem() != null) {
                directory.getNFileSystem().close();
                directory = null;
            }
        }
    }

    
    @Override
	public void write(OutputStream stream)
            throws IOException
    {
        byte[] bytes = getBytes();
        NPOIFSFileSystem fs = new NPOIFSFileSystem();

        
        
        List<String> excepts = new ArrayList<String>(1);

        
        fs.createDocument(new ByteArrayInputStream(bytes), ""Workbook"");

        
        writeProperties(fs, excepts);

        if (preserveNodes) {
            
            
            
        	excepts.addAll(Arrays.asList(WORKBOOK_DIR_ENTRY_NAMES));

            
            EntryUtils.copyNodes(
                    new FilteringDirectoryNode(this.directory, excepts)
                    , new FilteringDirectoryNode(fs.getRoot(), excepts)
            );

            
            
            fs.getRoot().setStorageClsid(this.directory.getStorageClsid());
        }
        fs.writeFilesystem(stream);
    }

    
    private static final class SheetRecordCollector implements RecordVisitor {

        private List<Record> _list;
        private int _totalSize;

        public SheetRecordCollector() {
            _totalSize = 0;
            _list = new ArrayList<Record>(128);
        }
        public int getTotalSize() {
            return _totalSize;
        }
        public void visitRecord(Record r) {
            _list.add(r);
            _totalSize+=r.getRecordSize();
            
        }
        public int serialize(int offset, byte[] data) {
            int result = 0;
            int nRecs = _list.size();
            for(int i=0; i<nRecs; i++) {
                Record rec = _list.get(i);
                result += rec.serialize(offset + result, data);
            }
            return result;
        }
    }


    
    public byte[] getBytes() {
        if (log.check( POILogger.DEBUG )) {
            log.log(DEBUG, ""HSSFWorkbook.getBytes()"");
        }

        HSSFSheet[] sheets = getSheets();
        int nSheets = sheets.length;


        
        
        workbook.preSerialize();
        for (int i = 0; i < nSheets; i++) {
            sheets[i].getSheet().preSerialize();
            sheets[i].preSerialize();
        }

        int totalsize = workbook.getSize();

        
        SheetRecordCollector[] srCollectors = new SheetRecordCollector[nSheets];
        for (int k = 0; k < nSheets; k++) {
            workbook.setSheetBof(k, totalsize);
            SheetRecordCollector src = new SheetRecordCollector();
            sheets[k].getSheet().visitContainedRecords(src, totalsize);
            totalsize += src.getTotalSize();
            srCollectors[k] = src;
        }

        byte[] retval = new byte[totalsize];
        int pos = workbook.serialize(0, retval);

        for (int k = 0; k < nSheets; k++) {
            SheetRecordCollector src = srCollectors[k];
            int serializedSize = src.serialize(pos, retval);
            if (serializedSize != src.getTotalSize()) {
                
                
                
                throw new IllegalStateException(""Actual serialized sheet size ("" + serializedSize
                        + "") differs from pre-calculated size ("" + src.getTotalSize()
                        + "") for sheet ("" + k + "")"");
                
            }
            pos += serializedSize;
        }
        return retval;
    }

    
    @Deprecated
	public int addSSTString(String string)
    {
        return workbook.addSSTString(new UnicodeString(string));
    }

    
    @Deprecated
	public String getSSTString(int index)
    {
        return workbook.getSSTString(index).getString();
    }

    InternalWorkbook getWorkbook() {
        return workbook;
    }

    public int getNumberOfNames(){
        int result = names.size();
        return result;
    }

    public HSSFName getName(String name) {
        int nameIndex = getNameIndex(name);
        if (nameIndex < 0) {
            return null;
        }
        return names.get(nameIndex);
    }

    public HSSFName getNameAt(int nameIndex) {
        int nNames = names.size();
        if (nNames < 1) {
            throw new IllegalStateException(""There are no defined names in this workbook"");
        }
        if (nameIndex < 0 || nameIndex > nNames) {
            throw new IllegalArgumentException(""Specified name index "" + nameIndex
                    + "" is outside the allowable range (0.."" + (nNames-1) + "")."");
        }
        return names.get(nameIndex);
    }

    public NameRecord getNameRecord(int nameIndex) {
        return getWorkbook().getNameRecord(nameIndex);
    }

    
    public String getNameName(int index){
        String result = getNameAt(index).getNameName();

        return result;
    }

    
    public void setPrintArea(int sheetIndex, String reference)
    {
        NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);


        if (name == null) {
            name = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);
            
        }
        String[] parts = COMMA_PATTERN.split(reference);
        StringBuffer sb = new StringBuffer(32);
        for (int i = 0; i < parts.length; i++) {
            if(i>0) {
                sb.append("","");
            }
            SheetNameFormatter.appendFormat(sb, getSheetName(sheetIndex));
            sb.append(""!"");
            sb.append(parts[i]);
        }
        name.setNameDefinition(HSSFFormulaParser.parse(sb.toString(), this, FormulaType.NAMEDRANGE, sheetIndex));
    }

    
    public void setPrintArea(int sheetIndex, int startColumn, int endColumn,
                              int startRow, int endRow) {

        
        CellReference cell = new CellReference(startRow, startColumn, true, true);
        String reference = cell.formatAsString();

        cell = new CellReference(endRow, endColumn, true, true);
        reference = reference+"":""+cell.formatAsString();

        setPrintArea(sheetIndex, reference);
    }


    
    public String getPrintArea(int sheetIndex) {
        NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);
        
        if (name == null) {
            return null;
        }

        return HSSFFormulaParser.toFormulaString(this, name.getNameDefinition());
    }

    
    public void removePrintArea(int sheetIndex) {
        getWorkbook().removeBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);
    }

    
    public HSSFName createName(){
        NameRecord nameRecord = workbook.createName();

        HSSFName newName = new HSSFName(this, nameRecord);

        names.add(newName);

        return newName;
    }

    public int getNameIndex(String name) {

        for (int k = 0; k < names.size(); k++) {
            String nameName = getNameName(k);

            if (nameName.equalsIgnoreCase(name)) {
                return k;
            }
        }
        return -1;
    }


    
    int getNameIndex(HSSFName name) {
      for (int k = 0; k < names.size(); k++) {
        if (name == names.get(k)) {
            return k;
        }
      }
      return -1;
    }


    public void removeName(int index){
        names.remove(index);
        workbook.removeName(index);
    }

    
    public HSSFDataFormat createDataFormat() {
    if (formatter == null)
        formatter = new HSSFDataFormat(workbook);
    return formatter;
    }


    public void removeName(String name) {
        int index = getNameIndex(name);
        removeName(index);
    }


    
    void removeName(HSSFName name) {
      int index = getNameIndex(name);
      removeName(index);
    }

    public HSSFPalette getCustomPalette()
    {
        return new HSSFPalette(workbook.getCustomPalette());
    }

    
    public void insertChartRecord()
    {
        int loc = workbook.findFirstRecordLocBySid(SSTRecord.sid);
        byte[] data = {
           (byte)0x0F, (byte)0x00, (byte)0x00, (byte)0xF0, (byte)0x52,
           (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00,
           (byte)0x06, (byte)0xF0, (byte)0x18, (byte)0x00, (byte)0x00,
           (byte)0x00, (byte)0x01, (byte)0x08, (byte)0x00, (byte)0x00,
           (byte)0x02, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x02,
           (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00,
           (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x00,
           (byte)0x00, (byte)0x03, (byte)0x00, (byte)0x00, (byte)0x00,
           (byte)0x33, (byte)0x00, (byte)0x0B, (byte)0xF0, (byte)0x12,
           (byte)0x00, (byte)0x00, (byte)0x00, (byte)0xBF, (byte)0x00,
           (byte)0x08, (byte)0x00, (byte)0x08, (byte)0x00, (byte)0x81,
           (byte)0x01, (byte)0x09, (byte)0x00, (byte)0x00, (byte)0x08,
           (byte)0xC0, (byte)0x01, (byte)0x40, (byte)0x00, (byte)0x00,
           (byte)0x08, (byte)0x40, (byte)0x00, (byte)0x1E, (byte)0xF1,
           (byte)0x10, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x0D,
           (byte)0x00, (byte)0x00, (byte)0x08, (byte)0x0C, (byte)0x00,
           (byte)0x00, (byte)0x08, (byte)0x17, (byte)0x00, (byte)0x00,
           (byte)0x08, (byte)0xF7, (byte)0x00, (byte)0x00, (byte)0x10,
        };
        UnknownRecord r = new UnknownRecord((short)0x00EB, data);
        workbook.getRecords().add(loc, r);
    }

    
    public void dumpDrawingGroupRecords(boolean fat)
    {
        DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );
        r.decode();
        List<EscherRecord> escherRecords = r.getEscherRecords();
        PrintWriter w = new PrintWriter(System.out);
        for ( Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext(); )
        {
            EscherRecord escherRecord = iterator.next();
            if (fat)
                System.out.println(escherRecord.toString());
            else
                escherRecord.display(w, 0);
        }
        w.flush();
    }

    void initDrawings(){
        DrawingManager2 mgr = workbook.findDrawingGroup();
        if(mgr != null) {
            for(int i=0; i < getNumberOfSheets(); i++)  {
                getSheetAt(i).getDrawingPatriarch();
            }
        } else {
            workbook.createDrawingGroup();
        }
    }

    
    public int addPicture(byte[] pictureData, int format)
    {
        initDrawings();

        byte[] uid = DigestUtils.md5(pictureData);
        EscherBlipRecord blipRecord;
        int blipSize;
        short escherTag;
        switch (format) {
            case PICTURE_TYPE_WMF:
                
                
                if (LittleEndian.getInt(pictureData) == 0x9AC6CDD7) {
                    byte picDataNoHeader[] = new byte[pictureData.length-22];
                    System.arraycopy(pictureData, 22, picDataNoHeader, 0, pictureData.length-22);
                    pictureData = picDataNoHeader;
                }
                
            case PICTURE_TYPE_EMF:
                EscherMetafileBlip blipRecordMeta = new EscherMetafileBlip();
                blipRecord = blipRecordMeta;
                blipRecordMeta.setUID(uid);
                blipRecordMeta.setPictureData(pictureData);
                
                blipRecordMeta.setFilter((byte)-2);
                blipSize = blipRecordMeta.getCompressedSize() + 58;
                escherTag = 0;
                break;
            default:
                EscherBitmapBlip blipRecordBitmap = new EscherBitmapBlip();
                blipRecord = blipRecordBitmap;
                blipRecordBitmap.setUID( uid );
                blipRecordBitmap.setMarker( (byte) 0xFF );
                blipRecordBitmap.setPictureData( pictureData );
                blipSize = pictureData.length + 25;
                escherTag = (short) 0xFF;
    	        break;
        }

        blipRecord.setRecordId((short) (EscherBitmapBlip.RECORD_ID_START + format));
        switch (format)
        {
            case PICTURE_TYPE_EMF:
                blipRecord.setOptions(HSSFPictureData.MSOBI_EMF);
                break;
            case PICTURE_TYPE_WMF:
                blipRecord.setOptions(HSSFPictureData.MSOBI_WMF);
                break;
            case PICTURE_TYPE_PICT:
                blipRecord.setOptions(HSSFPictureData.MSOBI_PICT);
                break;
            case PICTURE_TYPE_PNG:
                blipRecord.setOptions(HSSFPictureData.MSOBI_PNG);
                break;
            case HSSFWorkbook.PICTURE_TYPE_JPEG:
                blipRecord.setOptions(HSSFPictureData.MSOBI_JPEG);
                break;
            case HSSFWorkbook.PICTURE_TYPE_DIB:
                blipRecord.setOptions(HSSFPictureData.MSOBI_DIB);
                break;
        }
        
        EscherBSERecord r = new EscherBSERecord();
        r.setRecordId( EscherBSERecord.RECORD_ID );
        r.setOptions( (short) ( 0x0002 | ( format << 4 ) ) );
        r.setBlipTypeMacOS( (byte) format );
        r.setBlipTypeWin32( (byte) format );
        r.setUid( uid );
        r.setTag( escherTag );
        r.setSize( blipSize );
        r.setRef( 0 );
        r.setOffset( 0 );
        r.setBlipRecord( blipRecord );
        
        return workbook.addBSERecord( r );
    }

    
    public List<HSSFPictureData> getAllPictures()
    {
        
        List<HSSFPictureData> pictures = new ArrayList<HSSFPictureData>();
        Iterator<Record> recordIter = workbook.getRecords().iterator();
        while (recordIter.hasNext())
        {
            Record r = recordIter.next();
            if (r instanceof AbstractEscherHolderRecord)
            {
                ((AbstractEscherHolderRecord) r).decode();
                List<EscherRecord> escherRecords = ((AbstractEscherHolderRecord) r).getEscherRecords();
                searchForPictures(escherRecords, pictures);
            }
        }
        return pictures;
    }

    
    private void searchForPictures(List<EscherRecord> escherRecords, List<HSSFPictureData> pictures)
    {
        for(EscherRecord escherRecord : escherRecords) {

            if (escherRecord instanceof EscherBSERecord)
            {
                EscherBlipRecord blip = ((EscherBSERecord) escherRecord).getBlipRecord();
                if (blip != null)
                {
                    
                    HSSFPictureData picture = new HSSFPictureData(blip);
					pictures.add(picture);
                }


            }

            
            searchForPictures(escherRecord.getChildRecords(), pictures);
        }

    }

    protected static Map<String,ClassID> getOleMap() {
    	Map<String,ClassID> olemap = new HashMap<String,ClassID>();
    	olemap.put(""PowerPoint Document"", ClassID.PPT_SHOW);
    	for (String str : WORKBOOK_DIR_ENTRY_NAMES) {
    		olemap.put(str, ClassID.XLS_WORKBOOK);
    	}
    	
    	return olemap;
    }
    
    public int addOlePackage(POIFSFileSystem poiData, String label, String fileName, String command)
    throws IOException {
    	DirectoryNode root = poiData.getRoot();
    	Map<String,ClassID> olemap = getOleMap();
    	for (Map.Entry<String,ClassID> entry : olemap.entrySet()) {
    		if (root.hasEntry(entry.getKey())) {
    			root.setStorageClsid(entry.getValue());
    			break;
    		}
    	}
    	
    	ByteArrayOutputStream bos = new ByteArrayOutputStream();
    	poiData.writeFilesystem(bos);
        return addOlePackage(bos.toByteArray(), label, fileName, command);
    }
    
    public int addOlePackage(byte[] oleData, String label, String fileName, String command)
    throws IOException {
    	
    	if (directory == null) {
    		directory = new NPOIFSFileSystem().getRoot();
    		preserveNodes = true;
    	}
    	
        
        int storageId = 0;
        DirectoryEntry oleDir = null;
        do {
            String storageStr = ""MBD""+ HexDump.toHex(++storageId);
            if (!directory.hasEntry(storageStr)) {
                oleDir = directory.createDirectory(storageStr);
                oleDir.setStorageClsid(ClassID.OLE10_PACKAGE);
            }
        } while (oleDir == null);
    	
        
        
        
        byte oleBytes[] = { 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        oleDir.createDocument(""Ole"", new ByteArrayInputStream(oleBytes));
        
        Ole10Native oleNative = new Ole10Native(label, fileName, command, oleData);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        oleNative.writeOut(bos);
        oleDir.createDocument(Ole10Native.OLE10_NATIVE, new ByteArrayInputStream(bos.toByteArray()));
        
    	return storageId;
    }
    
    
    public int linkExternalWorkbook(String name, Workbook workbook) {
        return this.workbook.linkExternalWorkbook(name, workbook);
    }
    
    
    public boolean isWriteProtected() {
        return this.workbook.isWriteProtected();
    }

    
    public void writeProtectWorkbook( String password, String username ) {
       this.workbook.writeProtectWorkbook(password, username);
    }

    
    public void unwriteProtectWorkbook() {
       this.workbook.unwriteProtectWorkbook();
    }

    
    public List<HSSFObjectData> getAllEmbeddedObjects()
    {
        List<HSSFObjectData> objects = new ArrayList<HSSFObjectData>();
        for (int i = 0; i < getNumberOfSheets(); i++)
        {
            getAllEmbeddedObjects(getSheetAt(i), objects);
        }
        return objects;
    }

    
    private void getAllEmbeddedObjects(HSSFSheet sheet, List<HSSFObjectData> objects)
    {
        HSSFPatriarch patriarch = sheet.getDrawingPatriarch();
        if (null == patriarch){
            return;
        }
        getAllEmbeddedObjects(patriarch, objects);
    }
    
    private void getAllEmbeddedObjects(HSSFShapeContainer parent, List<HSSFObjectData> objects)
    {
        for (HSSFShape shape : parent.getChildren()) {
            if (shape instanceof HSSFObjectData) {
                objects.add((HSSFObjectData) shape);
            } else if (shape instanceof HSSFShapeContainer) {
                getAllEmbeddedObjects((HSSFShapeContainer) shape, objects);
            }
        }
    }
    public HSSFCreationHelper getCreationHelper() {
        return new HSSFCreationHelper(this);
    }

    
     UDFFinder getUDFFinder(){
        return _udfFinder;
    }

    
    public void addToolPack(UDFFinder toopack){
        AggregatingUDFFinder udfs = (AggregatingUDFFinder)_udfFinder;
        udfs.add(toopack);
    }

    
    public void setForceFormulaRecalculation(boolean value){
        InternalWorkbook iwb = getWorkbook();
        RecalcIdRecord recalc = iwb.getRecalcId();
        recalc.setEngineId(0);
    }

    
    public boolean getForceFormulaRecalculation(){
        InternalWorkbook iwb = getWorkbook();
        RecalcIdRecord recalc = (RecalcIdRecord)iwb.findFirstRecordBySid(RecalcIdRecord.sid);
        return recalc != null && recalc.getEngineId() != 0;
    }

	
    public boolean changeExternalReference(String oldUrl, String newUrl) {
    	return workbook.changeExternalReference(oldUrl, newUrl);
    }

    public DirectoryNode getRootDirectory(){
        return directory;
    }
}
"
poi,3,org.apache.poi.hssf.record.WindowOneRecord,37,2,0,9,50,442,3,6,34,0.895833333,485,0.9375,6,0.244444444,0.25462963,1,4,11.67567568,2,0.9459,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.LittleEndianOutput;


public final class WindowOneRecord extends StandardRecord {
    public final static short     sid = 0x3d;

    
    private short                 field_1_h_hold;                  
    private short                 field_2_v_hold;                  
    private short                 field_3_width;
    private short                 field_4_height;
    private short                 field_5_options;
    static final private BitField hidden   =
        BitFieldFactory.getInstance(0x01);                                        
    static final private BitField iconic   =
        BitFieldFactory.getInstance(0x02);                                        
    static final private BitField reserved = BitFieldFactory.getInstance(0x04);   
    static final private BitField hscroll  =
        BitFieldFactory.getInstance(0x08);                                        
    static final private BitField vscroll  =
        BitFieldFactory.getInstance(0x10);                                        
    static final private BitField tabs     =
        BitFieldFactory.getInstance(0x20);                                        

    
    private int                   field_6_active_sheet;
    private int                   field_7_first_visible_tab;
    private short                 field_8_num_selected_tabs;
    private short                 field_9_tab_width_ratio;

    public WindowOneRecord()
    {
    }

    public WindowOneRecord(RecordInputStream in)
    {
        field_1_h_hold            = in.readShort();
        field_2_v_hold            = in.readShort();
        field_3_width             = in.readShort();
        field_4_height            = in.readShort();
        field_5_options           = in.readShort();
        field_6_active_sheet      = in.readShort();
        field_7_first_visible_tab     = in.readShort();
        field_8_num_selected_tabs = in.readShort();
        field_9_tab_width_ratio   = in.readShort();
    }

    

    public void setHorizontalHold(short h)
    {
        field_1_h_hold = h;
    }

    

    public void setVerticalHold(short v)
    {
        field_2_v_hold = v;
    }

    

    public void setWidth(short w)
    {
        field_3_width = w;
    }

    

    public void setHeight(short h)
    {
        field_4_height = h;
    }

    

    public void setOptions(short o)
    {
        field_5_options = o;
    }

    

    

    public void setHidden(boolean ishidden)
    {
        field_5_options = hidden.setShortBoolean(field_5_options, ishidden);
    }

    

    public void setIconic(boolean isiconic)
    {
        field_5_options = iconic.setShortBoolean(field_5_options, isiconic);
    }

    

    public void setDisplayHorizonalScrollbar(boolean scroll)
    {
        field_5_options = hscroll.setShortBoolean(field_5_options, scroll);
    }

    

    public void setDisplayVerticalScrollbar(boolean scroll)
    {
        field_5_options = vscroll.setShortBoolean(field_5_options, scroll);
    }

    

    public void setDisplayTabs(boolean disptabs)
    {
        field_5_options = tabs.setShortBoolean(field_5_options, disptabs);
    }

    

    public void setActiveSheetIndex(int index) {
    	field_6_active_sheet = index;
	}
    
    public void setSelectedTab(short s)
    {
        setActiveSheetIndex(s);
    }

    
    public void setFirstVisibleTab(int t) {
        field_7_first_visible_tab = t;
    }

    
    public void setDisplayedTab(short t) {
        setFirstVisibleTab(t);
    }

    

    public void setNumSelectedTabs(short n)
    {
        field_8_num_selected_tabs = n;
    }

    

    public void setTabWidthRatio(short r)
    {
        field_9_tab_width_ratio = r;
    }

    

    public short getHorizontalHold()
    {
        return field_1_h_hold;
    }

    

    public short getVerticalHold()
    {
        return field_2_v_hold;
    }

    

    public short getWidth()
    {
        return field_3_width;
    }

    

    public short getHeight()
    {
        return field_4_height;
    }

    

    public short getOptions()
    {
        return field_5_options;
    }

    

    

    public boolean getHidden()
    {
        return hidden.isSet(field_5_options);
    }

    

    public boolean getIconic()
    {
        return iconic.isSet(field_5_options);
    }

    

    public boolean getDisplayHorizontalScrollbar()
    {
        return hscroll.isSet(field_5_options);
    }

    

    public boolean getDisplayVerticalScrollbar()
    {
        return vscroll.isSet(field_5_options);
    }

    

    public boolean getDisplayTabs()
    {
        return tabs.isSet(field_5_options);
    }

    

    
    
    public int getActiveSheetIndex() {
    	return field_6_active_sheet;
    }
    
    public short getSelectedTab()
    {
        return (short) getActiveSheetIndex();
    }

    
    public int getFirstVisibleTab() {
        return field_7_first_visible_tab;
    }
    
    public short getDisplayedTab()
    {
        return (short) getFirstVisibleTab();
    }

    

    public short getNumSelectedTabs()
    {
        return field_8_num_selected_tabs;
    }

    

    public short getTabWidthRatio()
    {
        return field_9_tab_width_ratio;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WINDOW1]
"");
        buffer.append(""    .h_hold          = "")
            .append(Integer.toHexString(getHorizontalHold())).append(""
"");
        buffer.append(""    .v_hold          = "")
            .append(Integer.toHexString(getVerticalHold())).append(""
"");
        buffer.append(""    .width           = "")
            .append(Integer.toHexString(getWidth())).append(""
"");
        buffer.append(""    .height          = "")
            .append(Integer.toHexString(getHeight())).append(""
"");
        buffer.append(""    .options         = "")
            .append(Integer.toHexString(getOptions())).append(""
"");
        buffer.append(""        .hidden      = "").append(getHidden())
            .append(""
"");
        buffer.append(""        .iconic      = "").append(getIconic())
            .append(""
"");
        buffer.append(""        .hscroll     = "")
            .append(getDisplayHorizontalScrollbar()).append(""
"");
        buffer.append(""        .vscroll     = "")
            .append(getDisplayVerticalScrollbar()).append(""
"");
        buffer.append(""        .tabs        = "").append(getDisplayTabs())
            .append(""
"");
        buffer.append(""    .activeSheet     = "")
            .append(Integer.toHexString(getActiveSheetIndex())).append(""
"");
        buffer.append(""    .firstVisibleTab    = "")
            .append(Integer.toHexString(getFirstVisibleTab())).append(""
"");
        buffer.append(""    .numselectedtabs = "")
            .append(Integer.toHexString(getNumSelectedTabs())).append(""
"");
        buffer.append(""    .tabwidthratio   = "")
            .append(Integer.toHexString(getTabWidthRatio())).append(""
"");
        buffer.append(""[/WINDOW1]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getHorizontalHold());
        out.writeShort(getVerticalHold());
        out.writeShort(getWidth());
        out.writeShort(getHeight());
        out.writeShort(getOptions());
        out.writeShort(getActiveSheetIndex());
        out.writeShort(getFirstVisibleTab());
        out.writeShort(getNumSelectedTabs());
        out.writeShort(getTabWidthRatio());
    }

    protected int getDataSize() {
        return 18;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.ColumnInfoRecord,26,2,0,9,41,179,3,6,23,0.836,339,0.9,3,0.323529412,0.253333333,1,4,11.65384615,2,0.9231,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;


public final class ColumnInfoRecord extends StandardRecord {
    public static final short sid = 0x007D;

    private int _firstCol;
    private int _lastCol;
    private int _colWidth;
    private int _xfIndex;
    private int _options;
    private static final BitField hidden    = BitFieldFactory.getInstance(0x01);
    private static final BitField outlevel  = BitFieldFactory.getInstance(0x0700);
    private static final BitField collapsed = BitFieldFactory.getInstance(0x1000);
    
    private int field_6_reserved;

    
    public ColumnInfoRecord() {
        setColumnWidth(2275);
        _options = 2;
        _xfIndex = 0x0f;
        field_6_reserved = 2; 
    }

    public ColumnInfoRecord(RecordInputStream in) {
        _firstCol = in.readUShort();
        _lastCol  = in.readUShort();
        _colWidth = in.readUShort();
        _xfIndex  = in.readUShort();
        _options   = in.readUShort();
        switch(in.remaining()) {
            case 2: 
                field_6_reserved  = in.readUShort();
                break;
            case 1:
                
                
                field_6_reserved  = in.readByte();
                break;
            case 0:
                
                
                
                field_6_reserved  = 0;
                break;
            default:
                throw new RuntimeException(""Unusual record size remaining=("" + in.remaining() + "")"");
        }
    }

    
    public void setFirstColumn(int fc) {
        _firstCol = fc;
    }

    
    public void setLastColumn(int lc) {
        _lastCol = lc;
    }

    
    public void setColumnWidth(int cw) {
        _colWidth = cw;
    }

    
    public void setXFIndex(int xfi) {
        _xfIndex = xfi;
    }

    
    public void setHidden(boolean ishidden) {
        _options = hidden.setBoolean(_options, ishidden);
    }

    
    public void setOutlineLevel(int olevel) {
        _options = outlevel.setValue(_options, olevel);
    }

    
    public void setCollapsed(boolean isCollapsed) {
        _options = collapsed.setBoolean(_options, isCollapsed);
    }

    
    public int getFirstColumn() {
        return _firstCol;
    }

    
    public int getLastColumn() {
        return _lastCol;
    }

    
    public int getColumnWidth() {
        return _colWidth;
    }

    
    public int getXFIndex() {
        return _xfIndex;
    }

    
    public boolean getHidden() {
        return hidden.isSet(_options);
    }

    
    public int getOutlineLevel() {
        return outlevel.getValue(_options);
    }

    
    public boolean getCollapsed() {
        return collapsed.isSet(_options);
    }

    public boolean containsColumn(int columnIndex) {
        return _firstCol <= columnIndex && columnIndex <= _lastCol;
    }
    public boolean isAdjacentBefore(ColumnInfoRecord other) {
        return _lastCol == other._firstCol - 1;
    }

    
    public boolean formatMatches(ColumnInfoRecord other) {
        if (_xfIndex != other._xfIndex) {
            return false;
        }
        if (_options != other._options) {
            return false;
        }
        if (_colWidth != other._colWidth) {
            return false;
        }
        return true;
    }

    public short getSid() {
        return sid;
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getFirstColumn());
        out.writeShort(getLastColumn());
        out.writeShort(getColumnWidth());
        out.writeShort(getXFIndex());
        out.writeShort(_options);
        out.writeShort(field_6_reserved);
    }

    protected int getDataSize() {
        return 12;
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();

        sb.append(""[COLINFO]
"");
        sb.append(""  colfirst = "").append(getFirstColumn()).append(""
"");
        sb.append(""  collast  = "").append(getLastColumn()).append(""
"");
        sb.append(""  colwidth = "").append(getColumnWidth()).append(""
"");
        sb.append(""  xfindex  = "").append(getXFIndex()).append(""
"");
        sb.append(""  options  = "").append(HexDump.shortToHex(_options)).append(""
"");
        sb.append(""    hidden   = "").append(getHidden()).append(""
"");
        sb.append(""    olevel   = "").append(getOutlineLevel()).append(""
"");
        sb.append(""    collapsed= "").append(getCollapsed()).append(""
"");
        sb.append(""[/COLINFO]
"");
        return sb.toString();
    }

    public Object clone() {
        ColumnInfoRecord rec = new ColumnInfoRecord();
        rec._firstCol = _firstCol;
        rec._lastCol = _lastCol;
        rec._colWidth = _colWidth;
        rec._xfIndex = _xfIndex;
        rec._options = _options;
        rec.field_6_reserved = field_6_reserved;
        return rec;
    }
}
"
poi,3,org.apache.poi.poifs.storage.HeaderBlockWriter,8,2,0,8,19,0,2,6,6,0.821428571,324,1.0,6,0.3,0.583333333,1,2,38.5,4,1.375,0,"

        

package org.apache.poi.poifs.storage;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;


public class HeaderBlockWriter implements HeaderBlockConstants, BlockWritable
{
   private final HeaderBlock _header_block;

    
    public HeaderBlockWriter(POIFSBigBlockSize bigBlockSize)
    {
       _header_block = new HeaderBlock(bigBlockSize);
    }

    
    public HeaderBlockWriter(HeaderBlock headerBlock)
    {
       _header_block = headerBlock;
    }

    

    public BATBlock [] setBATBlocks(final int blockCount,
                                    final int startBlock)
    {
        BATBlock[] rvalue;
        POIFSBigBlockSize bigBlockSize = _header_block.getBigBlockSize();

        _header_block.setBATCount(blockCount);

        
        int limit  = Math.min(blockCount, _max_bats_in_header);
        int[] bat_blocks = new int[limit];
        for (int j = 0; j < limit; j++) {
           bat_blocks[j] = startBlock + j;
        }
        _header_block.setBATArray(bat_blocks);
        
        
        if (blockCount > _max_bats_in_header)
        {
            int   excess_blocks      = blockCount - _max_bats_in_header;
            int[] excess_block_array = new int[ excess_blocks ];

            for (int j = 0; j < excess_blocks; j++)
            {
                excess_block_array[ j ] = startBlock + j
                                          + _max_bats_in_header;
            }
            rvalue = BATBlock.createXBATBlocks(bigBlockSize, excess_block_array,
                                               startBlock + blockCount);
            _header_block.setXBATStart(startBlock + blockCount);
        }
        else
        {
            rvalue = BATBlock.createXBATBlocks(bigBlockSize, new int[ 0 ], 0);
            _header_block.setXBATStart(POIFSConstants.END_OF_CHAIN);
        }
        _header_block.setXBATCount(rvalue.length);
        return rvalue;
    }

    
    public void setPropertyStart(final int startBlock)
    {
       _header_block.setPropertyStart(startBlock);
    }

    
    public void setSBATStart(final int startBlock)
    {
        _header_block.setSBATStart(startBlock);
    }

    
    public void setSBATBlockCount(final int count)
    {
       _header_block.setSBATBlockCount(count);
    }

    

    static int calculateXBATStorageRequirements(POIFSBigBlockSize bigBlockSize, final int blockCount)
    {
        return (blockCount > _max_bats_in_header)
               ? BATBlock.calculateXBATStorageRequirements(
                     bigBlockSize, blockCount - _max_bats_in_header)
               : 0;
    }

    

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        _header_block.writeData(stream);
    }
    
    
    public void writeBlock(ByteBuffer block)
        throws IOException
    {
       ByteArrayOutputStream baos = new ByteArrayOutputStream(
             _header_block.getBigBlockSize().getBigBlockSize()
       );
       _header_block.writeData(baos);
       
       block.put(baos.toByteArray());
    }

    
}   

"
poi,3,org.apache.poi.hssf.record.FormulaRecord,37,2,0,16,79,436,7,9,34,0.857142857,810,0.928571429,3,0.239130435,0.137592138,1,4,20.51351351,7,1.8649,4,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.ss.formula.Formula;
import org.apache.poi.ss.formula.eval.ErrorEval;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;


public final class FormulaRecord extends CellRecord {

	public static final short sid = 0x0006;   
	private static int FIXED_SIZE = 14; 

	private static final BitField alwaysCalc = BitFieldFactory.getInstance(0x0001);
	private static final BitField calcOnLoad = BitFieldFactory.getInstance(0x0002);
	private static final BitField sharedFormula = BitFieldFactory.getInstance(0x0008);

	
	static final class SpecialCachedValue {
		
		private static final long BIT_MARKER = 0xFFFF000000000000L;
		private static final int VARIABLE_DATA_LENGTH = 6;
		private static final int DATA_INDEX = 2;

		public static final int STRING = 0;
		public static final int BOOLEAN = 1;
		public static final int ERROR_CODE = 2;
		public static final int EMPTY = 3;

		private final byte[] _variableData;

		private SpecialCachedValue(byte[] data) {
			_variableData = data;
		}
		public int getTypeCode() {
			return _variableData[0];
		}

		
		public static SpecialCachedValue create(long valueLongBits) {
			if ((BIT_MARKER & valueLongBits) != BIT_MARKER) {
				return null;
			}

			byte[] result = new byte[VARIABLE_DATA_LENGTH];
			long x = valueLongBits;
			for (int i=0; i<VARIABLE_DATA_LENGTH; i++) {
				result[i] = (byte) x;
				x >>= 8;
			}
			switch (result[0]) {
				case STRING:
				case BOOLEAN:
				case ERROR_CODE:
				case EMPTY:
					break;
				default:
					throw new RecordFormatException(""Bad special value code ("" + result[0] + "")"");
			}
			return new SpecialCachedValue(result);
		}
		public void serialize(LittleEndianOutput out) {
			out.write(_variableData);
			out.writeShort(0xFFFF);
		}
		public String formatDebugString() {
			return formatValue() + ' ' + HexDump.toHex(_variableData);
		}
		private String formatValue() {
			int typeCode = getTypeCode();
			switch (typeCode) {
				case STRING:	 return ""<string>"";
				case BOOLEAN:	return getDataValue() == 0 ? ""FALSE"" : ""TRUE"";
				case ERROR_CODE: return ErrorEval.getText(getDataValue());
				case EMPTY:	  return ""<empty>"";
			}
			return ""#error(type="" + typeCode + "")#"";
		}
		private int getDataValue() {
			return _variableData[DATA_INDEX];
		}
		public static SpecialCachedValue createCachedEmptyValue() {
			return create(EMPTY, 0);
		}
		public static SpecialCachedValue createForString() {
			return create(STRING, 0);
		}
		public static SpecialCachedValue createCachedBoolean(boolean b) {
			return create(BOOLEAN, b ? 1 : 0);
		}
		public static SpecialCachedValue createCachedErrorCode(int errorCode) {
			return create(ERROR_CODE, errorCode);
		}
		private static SpecialCachedValue create(int code, int data) {
			byte[] vd = {
					(byte) code,
					0,
					(byte) data,
					0,
					0,
					0,
			};
			return new SpecialCachedValue(vd);
		}
		@Override
        public String toString() {
			StringBuffer sb = new StringBuffer(64);
			sb.append(getClass().getName());
			sb.append('[').append(formatValue()).append(']');
			return sb.toString();
		}
		public int getValueType() {
			int typeCode = getTypeCode();
			switch (typeCode) {
				case STRING:	 return HSSFCell.CELL_TYPE_STRING;
				case BOOLEAN:	return HSSFCell.CELL_TYPE_BOOLEAN;
				case ERROR_CODE: return HSSFCell.CELL_TYPE_ERROR;
				case EMPTY:	  return HSSFCell.CELL_TYPE_STRING; 
			}
			throw new IllegalStateException(""Unexpected type id ("" + typeCode + "")"");
		}
		public boolean getBooleanValue() {
			if (getTypeCode() != BOOLEAN) {
				throw new IllegalStateException(""Not a boolean cached value - "" + formatValue());
			}
			return getDataValue() != 0;
		}
		public int getErrorValue() {
			if (getTypeCode() != ERROR_CODE) {
				throw new IllegalStateException(""Not an error cached value - "" + formatValue());
			}
			return getDataValue();
		}
	}

	private double field_4_value;
	private short  field_5_options;
	
	private int field_6_zero;
	private Formula field_8_parsed_expr;

	
	private SpecialCachedValue specialCachedValue;

	

	public FormulaRecord() {
		field_8_parsed_expr = Formula.create(Ptg.EMPTY_PTG_ARRAY);
	}

	public FormulaRecord(RecordInputStream ris) {
		super(ris);
		LittleEndianInput in = ris;
		long valueLongBits  = in.readLong();
		field_5_options = in.readShort();
		specialCachedValue = SpecialCachedValue.create(valueLongBits);
		if (specialCachedValue == null) {
			field_4_value = Double.longBitsToDouble(valueLongBits);
		}

		field_6_zero = in.readInt();

		int field_7_expression_len = in.readShort(); 
		int nBytesAvailable = in.available();
		field_8_parsed_expr = Formula.read(field_7_expression_len, in, nBytesAvailable);
	}

	
	public void setValue(double value) {
		field_4_value = value;
		specialCachedValue = null;
	}

	public void setCachedResultTypeEmptyString() {
		specialCachedValue = SpecialCachedValue.createCachedEmptyValue();
	}
	public void setCachedResultTypeString() {
		specialCachedValue = SpecialCachedValue.createForString();
	}
	public void setCachedResultErrorCode(int errorCode) {
		specialCachedValue = SpecialCachedValue.createCachedErrorCode(errorCode);
	}
	public void setCachedResultBoolean(boolean value) {
		specialCachedValue = SpecialCachedValue.createCachedBoolean(value);
	}
	
	public boolean hasCachedResultString() {
		if (specialCachedValue == null) {
			return false;
		}
		return specialCachedValue.getTypeCode() == SpecialCachedValue.STRING;
	}

	public int getCachedResultType() {
		if (specialCachedValue == null) {
			return HSSFCell.CELL_TYPE_NUMERIC;
		}
		return specialCachedValue.getValueType();
	}

	public boolean getCachedBooleanValue() {
		return specialCachedValue.getBooleanValue();
	}
	public int getCachedErrorValue() {
		return specialCachedValue.getErrorValue();
	}


	
	public void setOptions(short options) {
		field_5_options = options;
	}

	
	public double getValue() {
		return field_4_value;
	}

	
	public short getOptions() {
		return field_5_options;
	}

	public boolean isSharedFormula() {
		return sharedFormula.isSet(field_5_options);
	}
	public void setSharedFormula(boolean flag) {
		field_5_options =
			sharedFormula.setShortBoolean(field_5_options, flag);
	}

	public boolean isAlwaysCalc() {
		return alwaysCalc.isSet(field_5_options);
	}
	public void setAlwaysCalc(boolean flag) {
		field_5_options =
			alwaysCalc.setShortBoolean(field_5_options, flag);
	}

	public boolean isCalcOnLoad() {
		return calcOnLoad.isSet(field_5_options);
	}
	public void setCalcOnLoad(boolean flag) {
		field_5_options =
			calcOnLoad.setShortBoolean(field_5_options, flag);
	}

	
	public Ptg[] getParsedExpression() {
		return field_8_parsed_expr.getTokens();
	}

	public Formula getFormula() {
		return field_8_parsed_expr;
	}

	public void setParsedExpression(Ptg[] ptgs) {
		field_8_parsed_expr = Formula.create(ptgs);
	}

	@Override
    public short getSid() {
		return sid;
	}

	@Override
	protected int getValueDataSize() {
		return FIXED_SIZE + field_8_parsed_expr.getEncodedSize();
	}
	@Override
	protected void serializeValue(LittleEndianOutput out) {

		if (specialCachedValue == null) {
			out.writeDouble(field_4_value);
		} else {
			specialCachedValue.serialize(out);
		}

		out.writeShort(getOptions());

		out.writeInt(field_6_zero); 
		field_8_parsed_expr.serialize(out);
	}
	
	@Override
	protected String getRecordName() {
		return ""FORMULA"";
	}
	
	@Override
	protected void appendValueText(StringBuilder sb) {
		sb.append(""  .value	 = "");
		if (specialCachedValue == null) {
			sb.append(field_4_value).append(""
"");
		} else {
			sb.append(specialCachedValue.formatDebugString()).append(""
"");
		}
		sb.append(""  .options   = "").append(HexDump.shortToHex(getOptions())).append(""
"");
		sb.append(""    .alwaysCalc= "").append(isAlwaysCalc()).append(""
"");
		sb.append(""    .calcOnLoad= "").append(isCalcOnLoad()).append(""
"");
		sb.append(""    .shared    = "").append(isSharedFormula()).append(""
"");
		sb.append(""  .zero      = "").append(HexDump.intToHex(field_6_zero)).append(""
"");

		Ptg[] ptgs = field_8_parsed_expr.getTokens();
		for (int k = 0; k < ptgs.length; k++ ) {
			if (k>0) {
				sb.append(""
"");
			}
			sb.append(""    Ptg["").append(k).append(""]="");
			Ptg ptg = ptgs[k];
			sb.append(ptg.toString()).append(ptg.getRVAType());
		}
	}

	@Override
    public Object clone() {
		FormulaRecord rec = new FormulaRecord();
		copyBaseFields(rec);
		rec.field_4_value = field_4_value;
		rec.field_5_options = field_5_options;
		rec.field_6_zero = field_6_zero;
		rec.field_8_parsed_expr = field_8_parsed_expr;
		rec.specialCachedValue = specialCachedValue;
		return rec;
	}
}

"
poi,3,org.apache.poi.util.ByteField,11,1,0,4,15,21,1,3,11,0.533333333,90,1.0,0,0.0,0.454545455,0,0,6.909090909,1,0.6364,0,"

        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;
import java.nio.BufferUnderflowException;



public class ByteField
    implements FixedField
{
    private static final byte _default_value = 0;
    private byte              _value;
    private final int         _offset;

    

    public ByteField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, _default_value);
    }

    

    public ByteField(final int offset, final byte value)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(
                ""offset cannot be negative"");
        }
        _offset = offset;
        set(value);
    }

    

    public ByteField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ByteField(final int offset, final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, value);
        writeToBytes(data);
    }

    

    public byte get()
    {
        return _value;
    }

    

    public void set(final byte value)
    {
        _value = value;
    }

    

    public void set(final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        set(value);
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = data[ _offset ];
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
    	
    	int ib = stream.read();
    	if (ib < 0) {
    		throw new BufferUnderflowException();
    	}
        _value = (byte) ib;
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        data[ _offset ] = _value;
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   

"
poi,3,org.apache.poi.hssf.usermodel.EscherGraphics2d,81,3,0,3,159,3130,0,3,73,0.830357143,905,1.0,2,0.526627219,0.079561043,2,20,10.08641975,5,1.1975,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;

import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ImageObserver;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.RenderableImage;
import java.text.AttributedCharacterIterator;
import java.util.Map;


public final class EscherGraphics2d extends Graphics2D {
    private EscherGraphics _escherGraphics;
    private BufferedImage _img;
    private AffineTransform _trans;
    private Stroke _stroke;
    private Paint _paint;
    private Shape _deviceclip;
    private POILogger logger = POILogFactory.getLogger(getClass());

    
    public EscherGraphics2d(EscherGraphics escherGraphics)
    {
        this._escherGraphics = escherGraphics;
        setImg( new BufferedImage(1, 1, 2) );
        setColor(Color.black);
    }

    public void addRenderingHints(Map<?, ?> map)
    {
        getG2D().addRenderingHints(map);
    }

    public void clearRect(int i, int j, int k, int l)
    {
        Paint paint1 = getPaint();
        setColor(getBackground());
        fillRect(i, j, k, l);
        setPaint(paint1);
    }

    public void clip(Shape shape)
    {
        if(getDeviceclip() != null)
        {
            Area area = new Area(getClip());
            if(shape != null)
                area.intersect(new Area(shape));
            shape = area;
        }
        setClip(shape);
    }

    public void clipRect(int x, int y, int width, int height)
    {
        clip(new Rectangle(x,y,width,height));
    }

    public void copyArea(int x, int y, int width, int height,
				  int dx, int dy)
    {
        getG2D().copyArea(x,y,width,height,dx,dy);
    }

    public Graphics create()
    {
        EscherGraphics2d g2d = new EscherGraphics2d(_escherGraphics);
        return g2d;
    }

    public void dispose()
    {
        getEscherGraphics().dispose();
        getG2D().dispose();
        getImg().flush();
    }

    public void draw(Shape shape)
    {
        if (shape instanceof Line2D)
        {
            Line2D shape2d = (Line2D) shape;

            int width = 0;
            if (_stroke != null && _stroke instanceof BasicStroke) {
                width = (int) ((BasicStroke)_stroke).getLineWidth() * 12700;
            }

            drawLine((int)shape2d.getX1(), (int)shape2d.getY1(), (int)shape2d.getX2(), (int)shape2d.getY2(), width);
        }
        else
        {
            if (logger.check(POILogger.WARN))
                logger.log(POILogger.WARN, ""draw not fully supported"");
        }
    }

    public void drawArc(int x, int y, int width, int height,
				 int startAngle, int arcAngle)
    {
        draw(new java.awt.geom.Arc2D.Float(x, y, width, height, startAngle, arcAngle, 0));
    }

    public void drawGlyphVector(GlyphVector g, float x, float y)
    {
        fill(g.getOutline(x, y));
    }

    public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1,
            int sx2, int sy2, Color bgColor, ImageObserver imageobserver)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawImage() not supported"");
        return true;
    }

    public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1,
            int sx2, int sy2, ImageObserver imageobserver)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawImage() not supported"");
        return drawImage(image, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null, imageobserver);
    }
    public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2, Color bgColor, ImageObserver imageobserver)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawImage() not supported"");
        return true;
    }

    public boolean drawImage(Image img, int x, int y,
				      int width, int height,
				      ImageObserver observer)
    {
        return drawImage(img, x,y,width,height, null, observer);
    }

    public boolean drawImage(Image image, int x, int y, Color bgColor, ImageObserver imageobserver)
    {
        return drawImage(image, x, y, image.getWidth(imageobserver), image.getHeight(imageobserver), bgColor, imageobserver);
    }

    public boolean drawImage(Image image, int x, int y, ImageObserver imageobserver)
    {
        return drawImage(image, x, y, image.getWidth(imageobserver), image.getHeight(imageobserver), imageobserver);
    }

    public boolean drawImage(Image image, AffineTransform affinetransform, ImageObserver imageobserver)
    {
        AffineTransform affinetransform1 = (AffineTransform)getTrans().clone();
        getTrans().concatenate(affinetransform);
        drawImage(image, 0, 0, imageobserver);
        setTrans( affinetransform1 );
        return true;
    }

    public void drawImage(BufferedImage bufferedimage, BufferedImageOp op, int x, int y)
    {
        BufferedImage img = op.filter(bufferedimage, null);
        drawImage(img, new AffineTransform(1.0F, 0.0F, 0.0F, 1.0F, x, y), null);
    }

    public void drawLine(int x1, int y1, int x2, int y2, int width)
    {
        getEscherGraphics().drawLine(x1,y1,x2,y2, width);
    }

    public void drawLine(int x1, int y1, int x2, int y2)
    {
        int width = 0;
        if (_stroke != null && _stroke instanceof BasicStroke) {
            width = (int) ((BasicStroke)_stroke).getLineWidth() * 12700;
        }
        getEscherGraphics().drawLine(x1,y1,x2,y2, width);

    }

    public void drawOval(int x, int y, int width, int height)
    {
        getEscherGraphics().drawOval(x,y,width,height);

    }

    public void drawPolygon(int xPoints[], int yPoints[],
				     int nPoints)
    {
        getEscherGraphics().drawPolygon(xPoints, yPoints, nPoints);
    }

    public void drawPolyline(int xPoints[], int yPoints[], int nPoints)
    {
        if(nPoints > 0)
        {
            GeneralPath generalpath = new GeneralPath();
            generalpath.moveTo(xPoints[0], yPoints[0]);
            for(int j = 1; j < nPoints; j++)
                generalpath.lineTo(xPoints[j], yPoints[j]);

            draw(generalpath);
        }
    }

    public void drawRect(int x, int y, int width, int height)
    {
        _escherGraphics.drawRect(x,y,width,height);
    }

    public void drawRenderableImage(RenderableImage renderableimage, AffineTransform affinetransform)
    {
        drawRenderedImage(renderableimage.createDefaultRendering(), affinetransform);
    }

    public void drawRenderedImage(RenderedImage renderedimage, AffineTransform affinetransform)
    {
        BufferedImage bufferedimage = new BufferedImage(renderedimage.getColorModel(), renderedimage.getData().createCompatibleWritableRaster(), false, null);
        bufferedimage.setData(renderedimage.getData());
        drawImage(bufferedimage, affinetransform, null);
    }

    public void drawRoundRect(int i, int j, int k, int l, int i1, int j1)
    {
        draw(new java.awt.geom.RoundRectangle2D.Float(i, j, k, l, i1, j1));
    }

    public void drawString(String string, float x, float y)
    {
        getEscherGraphics().drawString(string, (int)x, (int)y);
    }

    public void drawString(String string, int x, int y)
    {
        getEscherGraphics().drawString(string, x, y);
    }

    public void drawString(AttributedCharacterIterator attributedcharacteriterator, float x, float y)
    {
        TextLayout textlayout = new TextLayout(attributedcharacteriterator, getFontRenderContext());
        Paint paint1 = getPaint();
        setColor(getColor());
        fill(textlayout.getOutline(AffineTransform.getTranslateInstance(x, y)));
        setPaint(paint1);
    }

    public void drawString(AttributedCharacterIterator attributedcharacteriterator, int x, int y)
    {
        getEscherGraphics().drawString(attributedcharacteriterator, x, y);
    }

    public void fill(Shape shape)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""fill(Shape) not supported"");
    }

    public void fillArc(int i, int j, int k, int l, int i1, int j1)
    {
        fill(new java.awt.geom.Arc2D.Float(i, j, k, l, i1, j1, 2));
    }

    public void fillOval(int x, int y, int width, int height)
    {
        _escherGraphics.fillOval(x,y,width,height);
    }

    
    public void fillPolygon(int xPoints[], int yPoints[], int nPoints)
    {
        _escherGraphics.fillPolygon(xPoints, yPoints, nPoints);
    }

    public void fillRect(int x, int y, int width, int height)
    {
        getEscherGraphics().fillRect(x,y,width,height);
    }

    public void fillRoundRect(int x, int y, int width, int height,
				       int arcWidth, int arcHeight)
    {
        fill(new java.awt.geom.RoundRectangle2D.Float(x, y, width, height, arcWidth, arcHeight));
    }

    public Color getBackground()
    {
        return getEscherGraphics().getBackground();
    }

    public Shape getClip()
    {
        try
        {
            return getTrans().createInverse().createTransformedShape(getDeviceclip());
        }
        catch(Exception _ex)
        {
            return null;
        }
    }

    public Rectangle getClipBounds()
    {
        if(getDeviceclip() != null) {
            return getClip().getBounds();
        }
        return null;
    }

    public Color getColor()
    {
        return _escherGraphics.getColor();
    }

    public Composite getComposite()
    {
        return getG2D().getComposite();
    }

    public GraphicsConfiguration getDeviceConfiguration()
    {
        return getG2D().getDeviceConfiguration();
    }

    public Font getFont()
    {
        return getEscherGraphics().getFont();
    }

    public FontMetrics getFontMetrics(Font font)
    {
        return getEscherGraphics().getFontMetrics(font);
    }

    public FontRenderContext getFontRenderContext()
    {
        getG2D().setTransform(getTrans());
        return getG2D().getFontRenderContext();
    }

    public Paint getPaint()
    {
        return _paint;
    }

    public Object getRenderingHint(java.awt.RenderingHints.Key key)
    {
        return getG2D().getRenderingHint(key);
    }

    public RenderingHints getRenderingHints()
    {
        return getG2D().getRenderingHints();
    }

    public Stroke getStroke()
    {
        return _stroke;
    }

    public AffineTransform getTransform()
    {
        return (AffineTransform)getTrans().clone();
    }

    public boolean hit(Rectangle rectangle, Shape shape, boolean flag)
    {
        getG2D().setTransform(getTrans());
        getG2D().setStroke(getStroke());
        getG2D().setClip(getClip());
        return getG2D().hit(rectangle, shape, flag);
    }

    public void rotate(double d)
    {
        getTrans().rotate(d);
    }

    public void rotate(double d, double d1, double d2)
    {
        getTrans().rotate(d, d1, d2);
    }

    public void scale(double d, double d1)
    {
        getTrans().scale(d, d1);
    }

    public void setBackground(Color c)
    {
        getEscherGraphics().setBackground(c);
    }

    public void setClip(int i, int j, int k, int l)
    {
        setClip(new Rectangle(i, j, k, l));
    }

    public void setClip(Shape shape)
    {
        setDeviceclip( getTrans().createTransformedShape(shape) );
    }

    public void setColor(Color c)
    {
        _escherGraphics.setColor(c);
    }

    public void setComposite(Composite composite)
    {
        getG2D().setComposite(composite);
    }

    public void setFont(Font font)
    {
        getEscherGraphics().setFont(font);
    }

    public void setPaint(Paint paint1)
    {
        if(paint1 != null)
        {
            _paint = paint1;
            if(paint1 instanceof Color)
                setColor( (Color)paint1 );
        }
    }

    public void setPaintMode()
    {
        getEscherGraphics().setPaintMode();
    }

    public void setRenderingHint(java.awt.RenderingHints.Key key, Object obj)
    {
        getG2D().setRenderingHint(key, obj);
    }

    public void setRenderingHints(Map<?, ?> map)
    {
        getG2D().setRenderingHints(map);
    }

    public void setStroke(Stroke s)
    {
        _stroke = s;
    }

    public void setTransform(AffineTransform affinetransform)
    {
        setTrans( (AffineTransform)affinetransform.clone() );
    }

    public void setXORMode(Color color1)
    {
        getEscherGraphics().setXORMode(color1);
    }

    public void shear(double d, double d1)
    {
        getTrans().shear(d, d1);
    }

    public void transform(AffineTransform affinetransform)
    {
        getTrans().concatenate(affinetransform);
    }













    public void translate(double d, double d1)
    {
        getTrans().translate(d, d1);
    }

    public void translate(int i, int j)
    {
        getTrans().translate(i, j);
    }

    private EscherGraphics getEscherGraphics()
    {
        return _escherGraphics;
    }

    private BufferedImage getImg()
    {
        return _img;
    }

    private void setImg( BufferedImage img )
    {
        this._img = img;
    }

    private Graphics2D getG2D()
    {
        return (Graphics2D) _img.getGraphics();
    }

    private AffineTransform getTrans()
    {
        return _trans;
    }

    private void setTrans( AffineTransform trans )
    {
        this._trans = trans;
    }

    private Shape getDeviceclip()
    {
        return _deviceclip;
    }

    private void setDeviceclip( Shape deviceclip )
    {
        this._deviceclip = deviceclip;
    }

}
"
poi,3,org.apache.poi.hssf.record.PasswordRecord,11,2,0,6,20,43,2,4,9,0.8,102,0.5,0,0.55,0.309090909,1,4,8.090909091,2,0.9091,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class PasswordRecord extends StandardRecord {
    public final static short sid = 0x0013;
    private int field_1_password;   

    public PasswordRecord(int password) {
        field_1_password = password;
    }

    public PasswordRecord(RecordInputStream in) {
        field_1_password = in.readShort();
    }

    
    public static short hashPassword(String password) {
        return (short)CryptoFunctions.createXorVerifier1(password);
    }

    

    public void setPassword(int password) {
        field_1_password = password;
    }

    
    public int getPassword() {
        return field_1_password;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PASSWORD]
"");
        buffer.append(""    .password = "").append(HexDump.shortToHex(field_1_password)).append(""
"");
        buffer.append(""[/PASSWORD]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_password);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }

    
    public Object clone() {
        return new PasswordRecord(field_1_password);
    }
}
"
poi,3,org.apache.poi.poifs.storage.BlockList,4,1,0,6,4,6,5,2,4,2.0,4,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,1,"

        

package org.apache.poi.poifs.storage;

import java.io.IOException;



public interface BlockList
{

    

    public void zap(final int index);

    

    public ListManagedBlock remove(final int index)
        throws IOException;

    

    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException;

    

    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException;
    
    public int blockCount();
}   

"
poi,3,org.apache.poi.hssf.record.Record,12,1,134,155,21,66,154,1,10,2.0,63,0.0,0,0.0,0.283333333,0,0,4.25,1,0.8333,3,"

package org.apache.poi.hssf.record;

import java.io.ByteArrayInputStream;


public abstract class Record extends RecordBase {

    protected Record() {
        
    }

    
    public final byte[] serialize() {
        byte[] retval = new byte[ getRecordSize() ];

        serialize(0, retval);
        return retval;
    }

    
    @Override
    public String toString() {
        return super.toString();
    }

    

    public abstract short getSid();

    @Override
    public Object clone() {
        if (false) {
            
            try {
                return super.clone();
            } catch (CloneNotSupportedException e) {
                throw new RuntimeException(e);
            }
        }
        throw new RuntimeException(""The class ""+getClass().getName()+"" needs to define a clone method"");
    }

    
    public Record cloneViaReserialise() {
        
        
        byte[] b = serialize();
        RecordInputStream rinp = new RecordInputStream(new ByteArrayInputStream(b));
        rinp.nextRecord();

        Record[] r = RecordFactory.createRecord(rinp);
        if(r.length != 1) {
            throw new IllegalStateException(""Re-serialised a record to clone it, but got "" + r.length + "" records back!"");
        }
        return r[0];
    }
}
"
poi,3,org.apache.poi.hssf.record.InterfaceHdrRecord,10,2,0,6,19,39,2,4,8,0.925925926,92,0.333333333,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class InterfaceHdrRecord extends StandardRecord {
    public final static short sid = 0x00E1;
    private final int _codepage;

    
    public final static int CODEPAGE = 0x04B0;

    public InterfaceHdrRecord(int codePage) {
        _codepage = codePage;
    }

    public InterfaceHdrRecord(RecordInputStream in) {
        _codepage = in.readShort();
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[INTERFACEHDR]
"");
        buffer.append(""    .codepage = "").append(HexDump.shortToHex(_codepage)).append(""
"");
        buffer.append(""[/INTERFACEHDR]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_codepage);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.poifs.property.Child,4,1,0,3,4,6,3,0,4,2.0,4,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.property;



public interface Child
{

    

    public Child getNextChild();

    

    public Child getPreviousChild();

    

    public void setNextChild(final Child child);

    

    public void setPreviousChild(final Child child);
}   

"
poi,3,org.apache.poi.hssf.record.RecordFormatException,3,4,0,147,6,3,147,0,3,2.0,16,0.0,0,1.0,0.777777778,0,0,4.333333333,0,0.0,0,"

        

package org.apache.poi.hssf.record;



public class RecordFormatException
    extends org.apache.poi.util.RecordFormatException
{
    public RecordFormatException(String exception)
    {
        super(exception);
    }
    
    public RecordFormatException(String exception, Throwable thr) {
      super(exception, thr);
    }
    
    public RecordFormatException(Throwable thr) {
      super(thr);
    }
}
"
poi,3,org.apache.poi.hpsf.MutableProperty,6,2,1,7,14,15,3,4,6,2.0,67,0.0,0,0.555555556,0.333333333,1,2,10.16666667,1,0.6667,0,"

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.CodePageUtil;


public class MutableProperty extends Property
{

    
    public MutableProperty()
    { }



    
    public MutableProperty(final Property p)
    {
        setID(p.getID());
        setType(p.getType());
        setValue(p.getValue());
    }


    
    public void setID(final long id)
    {
        this.id = id;
    }



    
    public void setType(final long type)
    {
        this.type = type;
    }



    
    public void setValue(final Object value)
    {
        this.value = value;
    }



    
    public int write(final OutputStream out, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        long variantType = getType();

        
        if (codepage == CodePageUtil.CP_UNICODE && variantType == Variant.VT_LPSTR)
            variantType = Variant.VT_LPWSTR;

        length += TypeWriter.writeUIntToStream(out, variantType);
        length += VariantSupport.write(out, variantType, getValue(), codepage);
        return length;
    }

}
"
poi,3,org.apache.poi.hssf.record.InterfaceEndRecord,8,2,0,6,15,28,2,4,6,1.142857143,60,0.0,0,0.647058824,0.325,1,4,6.375,2,0.875,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class InterfaceEndRecord extends StandardRecord {

    public static final short sid = 0x00E2;
    public static final InterfaceEndRecord instance = new InterfaceEndRecord();

    private InterfaceEndRecord() {
        
    }

    public static Record create(RecordInputStream in) {
        switch (in.remaining()) {
            case 0:
                return instance;
            case 2:
                return new InterfaceHdrRecord(in);
        }
        throw new RecordFormatException(""Invalid record data size: "" + in.remaining());
    }

    public String toString() {
        return ""[INTERFACEEND/]
"";
    }

    public void serialize(LittleEndianOutput out) {
        
    }

    protected int getDataSize() {
        return 0;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.ddf.EscherDggRecord,17,2,0,11,48,38,4,8,17,0.822916667,421,0.666666667,1,0.542857143,0.274509804,1,5,23.41176471,3,1.1765,2,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.RecordFormatException;

import java.util.*;


public final class EscherDggRecord extends EscherRecord {
    public static final short RECORD_ID = (short) 0xF006;
    public static final String RECORD_DESCRIPTION = ""MsofbtDgg"";

    private int field_1_shapeIdMax;

    private int field_3_numShapesSaved;
    private int field_4_drawingsSaved;
    private FileIdCluster[] field_5_fileIdClusters;
    private int maxDgId;

    public static class FileIdCluster
    {
        public FileIdCluster( int drawingGroupId, int numShapeIdsUsed )
        {
            this.field_1_drawingGroupId = drawingGroupId;
            this.field_2_numShapeIdsUsed = numShapeIdsUsed;
        }

        private int field_1_drawingGroupId;
        private int field_2_numShapeIdsUsed;

        public int getDrawingGroupId()
        {
            return field_1_drawingGroupId;
        }

        public int getNumShapeIdsUsed()
        {
            return field_2_numShapeIdsUsed;
        }

        public void incrementShapeId( )
        {
            this.field_2_numShapeIdsUsed++;
        }
    }

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;
        field_1_shapeIdMax     =  LittleEndian.getInt( data, pos + size );size+=4;
        LittleEndian.getInt( data, pos + size );size+=4; 
        field_3_numShapesSaved =  LittleEndian.getInt( data, pos + size );size+=4;
        field_4_drawingsSaved  =  LittleEndian.getInt( data, pos + size );size+=4;
        field_5_fileIdClusters = new FileIdCluster[(bytesRemaining-size) / 8];  
        for (int i = 0; i < field_5_fileIdClusters.length; i++)
        {
            field_5_fileIdClusters[i] = new FileIdCluster(LittleEndian.getInt( data, pos + size ), LittleEndian.getInt( data, pos + size + 4 ));
            maxDgId = Math.max(maxDgId, field_5_fileIdClusters[i].getDrawingGroupId());
            size += 8;
        }
        bytesRemaining         -= size;
        if (bytesRemaining != 0)
            throw new RecordFormatException(""Expecting no remaining data but got "" + bytesRemaining + "" byte(s)."");
        return 8 + size + bytesRemaining;
    }

    public int serialize(int offset, byte[] data, EscherSerializationListener listener) {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        int pos = offset;
        LittleEndian.putShort( data, pos, getOptions() );     pos += 2;
        LittleEndian.putShort( data, pos, getRecordId() );    pos += 2;
        int remainingBytes = getRecordSize() - 8;
        LittleEndian.putInt( data, pos, remainingBytes );              pos += 4;

        LittleEndian.putInt( data, pos, field_1_shapeIdMax );          pos += 4;
        LittleEndian.putInt( data, pos, getNumIdClusters() );          pos += 4;
        LittleEndian.putInt( data, pos, field_3_numShapesSaved );      pos += 4;
        LittleEndian.putInt( data, pos, field_4_drawingsSaved );       pos += 4;
        for (int i = 0; i < field_5_fileIdClusters.length; i++) {
            LittleEndian.putInt( data, pos, field_5_fileIdClusters[i].field_1_drawingGroupId );   pos += 4;
            LittleEndian.putInt( data, pos, field_5_fileIdClusters[i].field_2_numShapeIdsUsed );  pos += 4;
        }

        listener.afterRecordSerialize( pos, getRecordId(), getRecordSize(), this );
        return getRecordSize();
    }

    public int getRecordSize() {
        return 8 + 16 + (8 * field_5_fileIdClusters.length);
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""Dgg"";
    }

    public String toString() {

        StringBuffer field_5_string = new StringBuffer();
        if(field_5_fileIdClusters != null) for (int i = 0; i < field_5_fileIdClusters.length; i++) {
            field_5_string.append(""  DrawingGroupId"").append(i+1).append("": "");
            field_5_string.append(field_5_fileIdClusters[i].field_1_drawingGroupId);
            field_5_string.append('
');
            field_5_string.append(""  NumShapeIdsUsed"").append(i+1).append("": "");
            field_5_string.append(field_5_fileIdClusters[i].field_2_numShapeIdsUsed);
            field_5_string.append('
');
        }
        return getClass().getName() + "":"" + '
' +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + '
' +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + '
' +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + '
' +
                ""  ShapeIdMax: "" + field_1_shapeIdMax + '
' +
                ""  NumIdClusters: "" + getNumIdClusters() + '
' +
                ""  NumShapesSaved: "" + field_3_numShapesSaved + '
' +
                ""  DrawingsSaved: "" + field_4_drawingsSaved + '
' +
                """" + field_5_string.toString();

    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<ShapeIdMax>"").append(field_1_shapeIdMax).append(""</ShapeIdMax>
"")
                .append(tab).append(""	"").append(""<NumIdClusters>"").append(getNumIdClusters()).append(""</NumIdClusters>
"")
                .append(tab).append(""	"").append(""<NumShapesSaved>"").append(field_3_numShapesSaved).append(""</NumShapesSaved>
"")
                .append(tab).append(""	"").append(""<DrawingsSaved>"").append(field_4_drawingsSaved).append(""</DrawingsSaved>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    public int getShapeIdMax() {
        return field_1_shapeIdMax;
    }

    
    public void setShapeIdMax(int shapeIdMax) {
        this.field_1_shapeIdMax = shapeIdMax;
    }

    
    public int getNumIdClusters() {
        return (field_5_fileIdClusters == null ? 0 : (field_5_fileIdClusters.length + 1));
    }

    public int getNumShapesSaved() {
        return field_3_numShapesSaved;
    }

    public void setNumShapesSaved(int numShapesSaved) {
        this.field_3_numShapesSaved = numShapesSaved;
    }

    public int getDrawingsSaved() {
        return field_4_drawingsSaved;
    }

    public void setDrawingsSaved(int drawingsSaved) {
        this.field_4_drawingsSaved = drawingsSaved;
    }

    
    public int getMaxDrawingGroupId() {
        return maxDgId;
    }

    public void setMaxDrawingGroupId(int id) {
        maxDgId = id;
    }

    public FileIdCluster[] getFileIdClusters() {
        return field_5_fileIdClusters;
    }

    public void setFileIdClusters(FileIdCluster[] fileIdClusters) {
        this.field_5_fileIdClusters = fileIdClusters;
    }

    public void addCluster(int dgId, int numShapedUsed) {
        addCluster(dgId, numShapedUsed, true);
    }

    
    public void addCluster( int dgId, int numShapedUsed, boolean sort ) {
        List<FileIdCluster> clusters = new ArrayList<FileIdCluster>(Arrays.asList(field_5_fileIdClusters));
        clusters.add(new FileIdCluster(dgId, numShapedUsed));
        if(sort) Collections.sort(clusters, MY_COMP );
        maxDgId = Math.min(maxDgId, dgId);
        field_5_fileIdClusters = clusters.toArray( new FileIdCluster[clusters.size()] );
    }

    private static final Comparator<FileIdCluster> MY_COMP = new Comparator<FileIdCluster>() {
        public int compare(FileIdCluster f1, FileIdCluster f2) {
            if (f1.getDrawingGroupId() == f2.getDrawingGroupId()) {
                return 0;
            }
            if (f1.getDrawingGroupId() < f2.getDrawingGroupId()) {
                return -1;
            }
            return +1;
        }
    };
}
"
poi,3,org.apache.poi.poifs.filesystem.POIFSDocumentPath,9,1,0,10,20,0,10,0,9,0.25,294,1.0,0,0.0,0.311111111,1,1,31.44444444,7,1.8889,0,"

        

package org.apache.poi.poifs.filesystem;

import java.io.File;

import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;



public class POIFSDocumentPath
{
    private static final POILogger log = POILogFactory.getLogger(POIFSDocumentPath.class);
          
    private String[] components;
    private int      hashcode = 0;

    

    public POIFSDocumentPath(final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ 0 ];
        }
        else
        {
            this.components = new String[ components.length ];
            for (int j = 0; j < components.length; j++)
            {
                if ((components[ j ] == null)
                        || (components[ j ].length() == 0))
                {
                    throw new IllegalArgumentException(
                        ""components cannot contain null or empty strings"");
                }
                this.components[ j ] = components[ j ];
            }
        }
    }

    

    public POIFSDocumentPath()
    {
        this.components = new String[ 0 ];
    }

    

    public POIFSDocumentPath(final POIFSDocumentPath path,
                             final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ path.components.length ];
        }
        else
        {
            this.components =
                new String[ path.components.length + components.length ];
        }
        for (int j = 0; j < path.components.length; j++)
        {
            this.components[ j ] = path.components[ j ];
        }
        if (components != null)
        {
            for (int j = 0; j < components.length; j++)
            {
                if (components[ j ] == null)
                {
                    throw new IllegalArgumentException(
                        ""components cannot contain null"");
                }
                if (components[ j ].length() == 0)
                {
                    log.log(POILogger.WARN, ""Directory under "" + path + "" has an empty name, "" +
                            ""not all OLE2 readers will handle this file correctly!"");
                }
                
                this.components[ j + path.components.length ] =
                    components[ j ];
            }
        }
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                POIFSDocumentPath path = ( POIFSDocumentPath ) o;

                if (path.components.length == this.components.length)
                {
                    rval = true;
                    for (int j = 0; j < this.components.length; j++)
                    {
                        if (!path.components[ j ]
                                .equals(this.components[ j ]))
                        {
                            rval = false;
                            break;
                        }
                    }
                }
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            for (int j = 0; j < components.length; j++)
            {
                hashcode += components[ j ].hashCode();
            }
        }
        return hashcode;
    }

    

    public int length()
    {
        return components.length;
    }

    

    public String getComponent(int n)
        throws ArrayIndexOutOfBoundsException
    {
        return components[ n ];
    }

    

    public POIFSDocumentPath getParent()
    {
        final int length = components.length - 1;

        if (length < 0)
        {
            return null;
        }
        POIFSDocumentPath parent = new POIFSDocumentPath(null);

        parent.components = new String[ length ];
        System.arraycopy(components, 0, parent.components, 0, length);
        return parent;
    }

    

    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int          l = length();

        b.append(File.separatorChar);
        for (int i = 0; i < l; i++)
        {
            b.append(getComponent(i));
            if (i < l - 1)
            {
                b.append(File.separatorChar);
            }
        }
        return b.toString();
    }
}   

"
poi,3,org.apache.poi.hssf.record.aggregates.RowRecordsAggregate,29,2,0,6,61,282,1,5,26,0.669642857,710,0.0,0,0.282051282,0.232758621,1,3,23.34482759,7,2.2069,5,"

package org.apache.poi.hssf.record.aggregates;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.poi.hssf.model.RecordStream;
import org.apache.poi.hssf.record.*;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.formula.FormulaShifter;


public final class RowRecordsAggregate extends RecordAggregate {
	private int _firstrow = -1;
	private int _lastrow  = -1;
	private final Map<Integer, RowRecord> _rowRecords;
	private final ValueRecordsAggregate _valuesAgg;
	private final List<Record> _unknownRecords;
	private final SharedValueManager _sharedValueManager;

	
    
    private RowRecord[] _rowRecordValues = null;

	
	public RowRecordsAggregate() {
		this(SharedValueManager.createEmpty());
	}
	private RowRecordsAggregate(SharedValueManager svm) {
		if (svm == null) {
			throw new IllegalArgumentException(""SharedValueManager must be provided."");
		}
		_rowRecords = new TreeMap<Integer, RowRecord>();
		_valuesAgg = new ValueRecordsAggregate();
		_unknownRecords = new ArrayList<Record>();
		_sharedValueManager = svm;
	}

	
	public RowRecordsAggregate(RecordStream rs, SharedValueManager svm) {
		this(svm);
		while(rs.hasNext()) {
			Record rec = rs.getNext();
			switch (rec.getSid()) {
				case RowRecord.sid:
					insertRow((RowRecord) rec);
					continue;
                case DConRefRecord.sid:
                    addUnknownRecord(rec);
                    continue;
                case DBCellRecord.sid:
					
					
					continue;
			}
			if (rec instanceof UnknownRecord) {
				
				addUnknownRecord(rec);
				while (rs.peekNextSid() == ContinueRecord.sid) {
					addUnknownRecord(rs.getNext());
				}
				continue;
			}
			if (rec instanceof MulBlankRecord) {
				_valuesAgg.addMultipleBlanks((MulBlankRecord) rec);
				continue;
			}
			if (!(rec instanceof CellValueRecordInterface)) {
				throw new RuntimeException(""Unexpected record type ("" + rec.getClass().getName() + "")"");
			}
			_valuesAgg.construct((CellValueRecordInterface)rec, rs, svm);
		}
	}
	
	private void addUnknownRecord(Record rec) {
		
		
		
		
		

		
		_unknownRecords.add(rec);
	}
	public void insertRow(RowRecord row) {
		
		_rowRecords.put(Integer.valueOf(row.getRowNumber()), row);
		
		_rowRecordValues = null; 
		if ((row.getRowNumber() < _firstrow) || (_firstrow == -1)) {
			_firstrow = row.getRowNumber();
		}
		if ((row.getRowNumber() > _lastrow) || (_lastrow == -1)) {
			_lastrow = row.getRowNumber();
		}
	}

	public void removeRow(RowRecord row) {
		int rowIndex = row.getRowNumber();
		_valuesAgg.removeAllCellsValuesForRow(rowIndex);
		Integer key = Integer.valueOf(rowIndex);
		RowRecord rr = _rowRecords.remove(key);
		if (rr == null) {
			throw new RuntimeException(""Invalid row index ("" + key.intValue() + "")"");
		}
		if (row != rr) {
			_rowRecords.put(key, rr);
			throw new RuntimeException(""Attempt to remove row that does not belong to this sheet"");
		}
		
		
		_rowRecordValues = null;
	}

	public RowRecord getRow(int rowIndex) {
        int maxrow = SpreadsheetVersion.EXCEL97.getLastRowIndex();
        if (rowIndex < 0 || rowIndex > maxrow) {
			throw new IllegalArgumentException(""The row number must be between 0 and "" + maxrow);
		}
		return _rowRecords.get(Integer.valueOf(rowIndex));
	}

	public int getPhysicalNumberOfRows()
	{
		return _rowRecords.size();
	}

	public int getFirstRowNum()
	{
		return _firstrow;
	}

	public int getLastRowNum()
	{
		return _lastrow;
	}

	
	public int getRowBlockCount() {
	  int size = _rowRecords.size()/DBCellRecord.BLOCK_SIZE;
	  if ((_rowRecords.size() % DBCellRecord.BLOCK_SIZE) != 0)
		  size++;
	  return size;
	}

	private int getRowBlockSize(int block) {
	  return RowRecord.ENCODED_SIZE * getRowCountForBlock(block);
	}

	
	public int getRowCountForBlock(int block) {
	  int startIndex = block * DBCellRecord.BLOCK_SIZE;
	  int endIndex = startIndex + DBCellRecord.BLOCK_SIZE - 1;
	  if (endIndex >= _rowRecords.size())
		endIndex = _rowRecords.size()-1;

	  return endIndex-startIndex+1;
	}

	
	private int getStartRowNumberForBlock(int block) {
	    int startIndex = block * DBCellRecord.BLOCK_SIZE;

        if(_rowRecordValues == null){
            _rowRecordValues = _rowRecords.values().toArray(new RowRecord[_rowRecords.size()]);
        }

        try {
            return _rowRecordValues[startIndex].getRowNumber();
        } catch(ArrayIndexOutOfBoundsException e) {
		  throw new RuntimeException(""Did not find start row for block "" + block);
	    }
	}

	
	private int getEndRowNumberForBlock(int block) {
	  int endIndex = ((block + 1)*DBCellRecord.BLOCK_SIZE)-1;
	  if (endIndex >= _rowRecords.size())
		endIndex = _rowRecords.size()-1;

        if(_rowRecordValues == null){
            _rowRecordValues = _rowRecords.values().toArray(new RowRecord[_rowRecords.size()]);
        }

        try {
            return _rowRecordValues[endIndex].getRowNumber();
        } catch(ArrayIndexOutOfBoundsException e) {
            throw new RuntimeException(""Did not find end row for block "" + block);
	  }
	}

	private int visitRowRecordsForBlock(int blockIndex, RecordVisitor rv) {
		final int startIndex = blockIndex*DBCellRecord.BLOCK_SIZE;
		final int endIndex = startIndex + DBCellRecord.BLOCK_SIZE;

		Iterator<RowRecord> rowIterator = _rowRecords.values().iterator();

		
		
		
		
		int i=0;
		for (;i<startIndex;i++)
		  rowIterator.next();
		int result = 0;
		while(rowIterator.hasNext() && (i++ < endIndex)) {
		  Record rec = rowIterator.next();
		  result += rec.getRecordSize();
		  rv.visitRecord(rec);
		}
		return result;
	}

    @Override
    public void visitContainedRecords(RecordVisitor rv) {

		PositionTrackingVisitor stv = new PositionTrackingVisitor(rv, 0);
		
		final int blockCount = getRowBlockCount();
		for (int blockIndex = 0; blockIndex < blockCount; blockIndex++) {
			
			
			int pos=0;
			
			final int rowBlockSize = visitRowRecordsForBlock(blockIndex, rv);
			pos += rowBlockSize;
			
			final int startRowNumber = getStartRowNumberForBlock(blockIndex);
			final int endRowNumber = getEndRowNumberForBlock(blockIndex);
			DBCellRecord.Builder dbcrBuilder = new DBCellRecord.Builder();
			
			int cellRefOffset = (rowBlockSize - RowRecord.ENCODED_SIZE);
			for (int row = startRowNumber; row <= endRowNumber; row++) {
				if (_valuesAgg.rowHasCells(row)) {
					stv.setPosition(0);
					_valuesAgg.visitCellsForRow(row, stv);
					int rowCellSize = stv.getPosition();
					pos += rowCellSize;
					
					
					dbcrBuilder.addCellOffset(cellRefOffset);
					cellRefOffset = rowCellSize;
				}
			}
			
			rv.visitRecord(dbcrBuilder.build(pos));
		}
		for (int i=0; i< _unknownRecords.size(); i++) {
			
			rv.visitRecord(_unknownRecords.get(i));
		}
	}

	public Iterator<RowRecord> getIterator() {
		return _rowRecords.values().iterator();
	}

	public int findStartOfRowOutlineGroup(int row) {
		
		RowRecord rowRecord = this.getRow( row );
		int level = rowRecord.getOutlineLevel();
		int currentRow = row;
		while (this.getRow( currentRow ) != null) {
			rowRecord = this.getRow( currentRow );
			if (rowRecord.getOutlineLevel() < level) {
				return currentRow + 1;
			}
			currentRow--;
		}

		return currentRow + 1;
	}

	public int findEndOfRowOutlineGroup(int row) {
		int level = getRow( row ).getOutlineLevel();
		int currentRow;
		for (currentRow = row; currentRow < getLastRowNum(); currentRow++) {
			if (getRow(currentRow) == null || getRow(currentRow).getOutlineLevel() < level) {
				break;
			}
		}

		return currentRow-1;
	}

	
	private int writeHidden(RowRecord pRowRecord, int row) {
		int rowIx = row;
		RowRecord rowRecord = pRowRecord;
		int level = rowRecord.getOutlineLevel();
		while (rowRecord != null && getRow(rowIx).getOutlineLevel() >= level) {
			rowRecord.setZeroHeight(true);
			rowIx++;
			rowRecord = getRow(rowIx);
		}
		return rowIx;
	}

	public void collapseRow(int rowNumber) {

		
		int startRow = findStartOfRowOutlineGroup(rowNumber);
		RowRecord rowRecord = getRow(startRow);

		
		int nextRowIx = writeHidden(rowRecord, startRow);

		RowRecord row = getRow(nextRowIx);
		if (row == null) {
			row = createRow(nextRowIx);
			insertRow(row);
		}
		
		row.setColapsed(true);
	}

	
	public static RowRecord createRow(int rowNumber) {
		return new RowRecord(rowNumber);
	}

	public boolean isRowGroupCollapsed(int row) {
		int collapseRow = findEndOfRowOutlineGroup(row) + 1;

		if (getRow(collapseRow) == null) {
			return false;
		}
		return getRow( collapseRow ).getColapsed();
	}

	public void expandRow(int rowNumber) {
		int idx = rowNumber;
		if (idx == -1)
			return;

		
		if (!isRowGroupCollapsed(idx)) {
			return;
		}

		
		int startIdx = findStartOfRowOutlineGroup(idx);
		RowRecord row = getRow(startIdx);

		
		int endIdx = findEndOfRowOutlineGroup(idx);

		
		
		
		
		
		
		
		if (!isRowGroupHiddenByParent(idx)) {
			for (int i = startIdx; i <= endIdx; i++) {
				RowRecord otherRow = getRow(i);
				if (row.getOutlineLevel() == otherRow.getOutlineLevel() || !isRowGroupCollapsed(i)) {
					otherRow.setZeroHeight(false);
				}
			}
		}

		
		getRow(endIdx + 1).setColapsed(false);
	}

	public boolean isRowGroupHiddenByParent(int row) {
		
		int endLevel;
		boolean endHidden;
		int endOfOutlineGroupIdx = findEndOfRowOutlineGroup(row);
		if (getRow(endOfOutlineGroupIdx + 1) == null) {
			endLevel = 0;
			endHidden = false;
		} else {
			endLevel = getRow(endOfOutlineGroupIdx + 1).getOutlineLevel();
			endHidden = getRow(endOfOutlineGroupIdx + 1).getZeroHeight();
		}

		
		int startLevel;
		boolean startHidden;
		int startOfOutlineGroupIdx = findStartOfRowOutlineGroup( row );
		if (startOfOutlineGroupIdx - 1 < 0 || getRow(startOfOutlineGroupIdx - 1) == null) {
			startLevel = 0;
			startHidden = false;
		} else {
			startLevel = getRow(startOfOutlineGroupIdx - 1).getOutlineLevel();
			startHidden = getRow(startOfOutlineGroupIdx - 1).getZeroHeight();
		}

		if (endLevel > startLevel) {
			return endHidden;
		}

		return startHidden;
	}
	
	
	public Iterator<CellValueRecordInterface> getCellValueIterator() {
		return _valuesAgg.iterator();
	}

	
	public CellValueRecordInterface[] getValueRecords() {
		return _valuesAgg.getValueRecords();
	}

	public IndexRecord createIndexRecord(int indexRecordOffset, int sizeOfInitialSheetRecords) {
		IndexRecord result = new IndexRecord();
		result.setFirstRow(_firstrow);
		result.setLastRowAdd1(_lastrow + 1);
		
		

		
		
		

		int blockCount = getRowBlockCount();
		
		int indexRecSize = IndexRecord.getRecordSizeForBlockCount(blockCount);

		int currentOffset = indexRecordOffset + indexRecSize + sizeOfInitialSheetRecords;

		for (int block = 0; block < blockCount; block++) {
			
			

			
			currentOffset += getRowBlockSize(block);
			
			currentOffset += _valuesAgg.getRowCellBlockSize(
					getStartRowNumberForBlock(block), getEndRowNumberForBlock(block));

			
			result.addDbcell(currentOffset);
			
			currentOffset += (8 + (getRowCountForBlock(block) * 2));
		}
		return result;
	}
	public void insertCell(CellValueRecordInterface cvRec) {
		_valuesAgg.insertCell(cvRec);
	}
	public void removeCell(CellValueRecordInterface cvRec) {
		if (cvRec instanceof FormulaRecordAggregate) {
			((FormulaRecordAggregate)cvRec).notifyFormulaChanging();
		}
		_valuesAgg.removeCell(cvRec);
	}
	public FormulaRecordAggregate createFormula(int row, int col) {
		FormulaRecord fr = new FormulaRecord();
		fr.setRow(row);
		fr.setColumn((short) col);
		return new FormulaRecordAggregate(fr, null, _sharedValueManager);
	}
	public void updateFormulasAfterRowShift(FormulaShifter formulaShifter, int currentExternSheetIndex) {
		_valuesAgg.updateFormulasAfterRowShift(formulaShifter, currentExternSheetIndex);
	}
	public DimensionsRecord createDimensions() {
		DimensionsRecord result = new DimensionsRecord();
		result.setFirstRow(_firstrow);
		result.setLastRow(_lastrow);
		result.setFirstCol((short) _valuesAgg.getFirstCellNum());
		result.setLastCol((short) _valuesAgg.getLastCellNum());
		return result;
	}
}
"
poi,3,org.apache.poi.poifs.property.Property,32,1,3,19,65,290,13,6,18,0.962648557,732,1.0,16,0.0,0.17578125,0,0,20.6875,3,1.1563,1,"



package org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;

import org.apache.poi.hpsf.ClassID;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.util.ByteField;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.ShortField;



public abstract class Property implements Child, POIFSViewable {
    static final private byte   _default_fill             = ( byte ) 0x00;
    static final private int    _name_size_offset         = 0x40;
    static final private int    _max_name_length          =
        (_name_size_offset / LittleEndianConsts.SHORT_SIZE) - 1;
    static final protected int  _NO_INDEX                 = -1;

    
    static final private int    _node_color_offset        = 0x43;
    static final private int    _previous_property_offset = 0x44;
    static final private int    _next_property_offset     = 0x48;
    static final private int    _child_property_offset    = 0x4C;
    static final private int    _storage_clsid_offset     = 0x50;
    static final private int    _user_flags_offset        = 0x60;
    static final private int    _seconds_1_offset         = 0x64;
    static final private int    _days_1_offset            = 0x68;
    static final private int    _seconds_2_offset         = 0x6C;
    static final private int    _days_2_offset            = 0x70;
    static final private int    _start_block_offset       = 0x74;
    static final private int    _size_offset              = 0x78;

    
    static final protected byte _NODE_BLACK               = 1;
    static final protected byte _NODE_RED                 = 0;

    
    static final private int    _big_block_minimum_bytes  = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
    private String              _name;
    private ShortField          _name_size;
    private ByteField           _property_type;
    private ByteField           _node_color;
    private IntegerField        _previous_property;
    private IntegerField        _next_property;
    private IntegerField        _child_property;
    private ClassID             _storage_clsid;
    private IntegerField        _user_flags;
    private IntegerField        _seconds_1;
    private IntegerField        _days_1;
    private IntegerField        _seconds_2;
    private IntegerField        _days_2;
    private IntegerField        _start_block;
    private IntegerField        _size;
    private byte[]              _raw_data;
    private int                 _index;
    private Child               _next_child;
    private Child               _previous_child;

    protected Property()
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        Arrays.fill(_raw_data, _default_fill);
        _name_size         = new ShortField(_name_size_offset);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET);
        _node_color        = new ByteField(_node_color_offset);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _NO_INDEX, _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _NO_INDEX, _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _NO_INDEX, _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, 0,
                                              _raw_data);
        _days_1            = new IntegerField(_days_1_offset, 0, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, 0,
                                              _raw_data);
        _days_2            = new IntegerField(_days_2_offset, 0, _raw_data);
        _start_block       = new IntegerField(_start_block_offset);
        _size              = new IntegerField(_size_offset, 0, _raw_data);
        _index             = _NO_INDEX;
        setName("""");
        setNextChild(null);
        setPreviousChild(null);
    }

    
    protected Property(int index, byte [] array, int offset)
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        System.arraycopy(array, offset, _raw_data, 0,
                         POIFSConstants.PROPERTY_SIZE);
        _name_size         = new ShortField(_name_size_offset, _raw_data);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET, _raw_data);
        _node_color        = new ByteField(_node_color_offset, _raw_data);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, _raw_data);
        _days_1            = new IntegerField(_days_1_offset, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, _raw_data);
        _days_2            = new IntegerField(_days_2_offset, _raw_data);
        _start_block       = new IntegerField(_start_block_offset, _raw_data);
        _size              = new IntegerField(_size_offset, _raw_data);
        _index             = index;
        int name_length = (_name_size.get() / LittleEndianConsts.SHORT_SIZE)
                          - 1;

        if (name_length < 1)
        {
            _name = """";
        }
        else
        {
            char[] char_array  = new char[ name_length ];
            int    name_offset = 0;

            for (int j = 0; j < name_length; j++)
            {
                char_array[ j ] = ( char ) new ShortField(name_offset,
                                                          _raw_data).get();
                name_offset     += LittleEndianConsts.SHORT_SIZE;
            }
            _name = new String(char_array, 0, name_length);
        }
        _next_child     = null;
        _previous_child = null;
    }

    
    public void writeData(OutputStream stream)
        throws IOException
    {
        stream.write(_raw_data);
    }

    
    public void setStartBlock(int startBlock)
    {
        _start_block.set(startBlock, _raw_data);
    }

    
    public int getStartBlock()
    {
        return _start_block.get();
    }

    
    public int getSize()
    {
        return _size.get();
    }

    
    public boolean shouldUseSmallBlocks()
    {
        return Property.isSmall(_size.get());
    }

    
    public static boolean isSmall(int length)
    {
        return length < _big_block_minimum_bytes;
    }

    
    public String getName()
    {
        return _name;
    }

    
    abstract public boolean isDirectory();

    
    public ClassID getStorageClsid()
    {
        return _storage_clsid;
    }

    
    protected void setName(String name)
    {
        char[] char_array = name.toCharArray();
        int    limit      = Math.min(char_array.length, _max_name_length);

        _name = new String(char_array, 0, limit);
        short offset = 0;
        int   j      = 0;

        for (; j < limit; j++)
        {
            new ShortField(offset, ( short ) char_array[ j ], _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }
        for (; j < _max_name_length + 1; j++)
        {
            new ShortField(offset, ( short ) 0, _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }

        
        _name_size
            .set(( short ) ((limit + 1)
                            * LittleEndianConsts.SHORT_SIZE), _raw_data);
    }

    
    public void setStorageClsid( ClassID clsidStorage)
    {
        _storage_clsid = clsidStorage;
        if( clsidStorage == null) {
            Arrays.fill( _raw_data, _storage_clsid_offset, _storage_clsid_offset + ClassID.LENGTH, (byte) 0);
        } else {
            clsidStorage.write( _raw_data, _storage_clsid_offset);
        }
    }
    
    protected void setPropertyType(byte propertyType)
    {
        _property_type.set(propertyType, _raw_data);
    }

    
    protected void setNodeColor(byte nodeColor)
    {
        _node_color.set(nodeColor, _raw_data);
    }

    
    protected void setChildProperty(int child)
    {
        _child_property.set(child, _raw_data);
    }

    
    protected int getChildIndex()
    {
        return _child_property.get();
    }

    
    protected void setSize(int size)
    {
        _size.set(size, _raw_data);
    }

    
    protected void setIndex(int index)
    {
        _index = index;
    }

    
    protected int getIndex()
    {
        return _index;
    }

    
    abstract protected void preWrite();

    
    int getNextChildIndex()
    {
        return _next_property.get();
    }

    
    int getPreviousChildIndex()
    {
        return _previous_property.get();
    }

    
    static boolean isValidIndex(int index)
    {
        return index != _NO_INDEX;
    }

    
    public Child getNextChild()
    {
        return _next_child;
    }

    
    public Child getPreviousChild()
    {
        return _previous_child;
    }

    
    public void setNextChild(Child child)
    {
        _next_child = child;
        _next_property.set((child == null) ? _NO_INDEX
                                           : (( Property ) child)
                                               .getIndex(), _raw_data);
    }

    
    public void setPreviousChild(Child child)
    {
        _previous_child = child;
        _previous_property.set((child == null) ? _NO_INDEX
                                               : (( Property ) child)
                                                   .getIndex(), _raw_data);
    }

    
    public Object [] getViewableArray()
    {
        Object[] results = new Object[ 5 ];

        results[ 0 ] = ""Name          = """" + getName() + """""";
        results[ 1 ] = ""Property Type = "" + _property_type.get();
        results[ 2 ] = ""Node Color    = "" + _node_color.get();
        long time = _days_1.get();

        time         <<= 32;
        time         += _seconds_1.get() & 0x0000FFFFL;
        results[ 3 ] = ""Time 1        = "" + time;
        time         = _days_2.get();
        time         <<= 32;
        time         += _seconds_2.get() & 0x0000FFFFL;
        results[ 4 ] = ""Time 2        = "" + time;
        return results;
    }

    
    public Iterator<Object> getViewableIterator()
    {
        return Collections.emptyList().iterator();
    }

    
    public boolean preferArray()
    {
        return true;
    }

    
    public String getShortDescription()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""Property: """").append(getName()).append("""""");
        return buffer.toString();
    }
}
"
poi,3,org.apache.poi.hssf.record.ContinueRecord,11,2,0,7,21,25,3,4,9,0.8,121,0.5,0,0.55,0.309090909,1,3,9.818181818,2,0.9091,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class ContinueRecord extends StandardRecord {
    public final static short sid = 0x003C;
    private byte[] _data;

    public ContinueRecord(byte[] data) {
        _data = data;
    }

    protected int getDataSize() {
        return _data.length;
    }

    public void serialize(LittleEndianOutput out) {
        out.write(_data);
    }

    
    public byte[] getData() {
        return _data;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CONTINUE RECORD]
"");
        buffer.append(""    .data = "").append(HexDump.toHex(_data)).append(""
"");
        buffer.append(""[/CONTINUE RECORD]
"");
        return buffer.toString();
    }

    public short getSid() {
        return sid;
    }

    public ContinueRecord(RecordInputStream in) {
        _data = in.readRemainder();
    }

    public Object clone() {
        return new ContinueRecord(_data);
    }
}
"
poi,3,org.apache.poi.ddf.UnknownEscherRecord,12,2,0,6,47,28,1,5,11,0.636363636,353,1.0,0,0.655172414,0.246753247,1,6,28.16666667,3,1.3333,1,"

package org.apache.poi.ddf;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public final class UnknownEscherRecord extends EscherRecord {
    private static final byte[] NO_BYTES = new byte[0];

    
    private byte[] thedata = NO_BYTES;
    private List<EscherRecord> _childRecords;

    public UnknownEscherRecord() {
        _childRecords = new ArrayList<EscherRecord>();
    }

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
		
		int avaliable = data.length - (offset + 8);
		if (bytesRemaining > avaliable) {
			bytesRemaining = avaliable;
		}

        if (isContainerRecord()) {
            int bytesWritten = 0;
            thedata = new byte[0];
            offset += 8;
            bytesWritten += 8;
            while ( bytesRemaining > 0 )
            {
                EscherRecord child = recordFactory.createRecord( data, offset );
                int childBytesWritten = child.fillFields( data, offset, recordFactory );
                bytesWritten += childBytesWritten;
                offset += childBytesWritten;
                bytesRemaining -= childBytesWritten;
                getChildRecords().add( child );
            }
            return bytesWritten;
        }

        thedata = new byte[bytesRemaining];
        System.arraycopy( data, offset + 8, thedata, 0, bytesRemaining );
        return bytesRemaining + 8;
    }

    public int serialize(int offset, byte[] data, EscherSerializationListener listener) {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        LittleEndian.putShort(data, offset, getOptions());
        LittleEndian.putShort(data, offset+2, getRecordId());
        int remainingBytes = thedata.length;
        for (EscherRecord r : _childRecords) {
            remainingBytes += r.getRecordSize();
        }
        LittleEndian.putInt(data, offset+4, remainingBytes);
        System.arraycopy(thedata, 0, data, offset+8, thedata.length);
        int pos = offset+8+thedata.length;
        for (EscherRecord r : _childRecords) {
            pos += r.serialize(pos, data, listener );
        }

        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        return pos - offset;
    }

    public byte[] getData() {
        return thedata;
    }

    public int getRecordSize() {
        return 8 + thedata.length;
    }

    public List<EscherRecord> getChildRecords() {
        return _childRecords;
    }

    public void setChildRecords(List<EscherRecord> childRecords) {
        _childRecords = childRecords;
    }

    public Object clone() {
        
        return super.clone();
    }

    public String getRecordName() {
        return ""Unknown 0x"" + HexDump.toHex(getRecordId());
    }

    public String toString() {
        StringBuffer children = new StringBuffer();
        if (getChildRecords().size() > 0) {
            children.append( ""  children: "" + '
' );
            for (EscherRecord record : _childRecords) {
                children.append( record.toString() );
                children.append( '
' );
            }
        }

        String theDumpHex = HexDump.toHex(thedata, 32);

        return getClass().getName() + "":"" + '
' +
                ""  isContainer: "" + isContainerRecord() + '
' +
                ""  version: 0x"" + HexDump.toHex( getVersion() ) + '
' +
                ""  instance: 0x"" + HexDump.toHex( getInstance() ) + '
' +
                ""  recordId: 0x"" + HexDump.toHex( getRecordId() ) + '
' +
                ""  numchildren: "" + getChildRecords().size() + '
' +
                theDumpHex +
                children.toString();
    }

    @Override
    public String toXml(String tab) {
        String theDumpHex = HexDump.toHex(thedata, 32);
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<IsContainer>"").append(isContainerRecord()).append(""</IsContainer>
"")
                .append(tab).append(""	"").append(""<Numchildren>"").append(HexDump.toHex(_childRecords.size())).append(""</Numchildren>
"");
        for ( Iterator<EscherRecord> iterator = _childRecords.iterator(); iterator
                .hasNext(); )
        {
            EscherRecord record = iterator.next();
            builder.append(record.toXml(tab+""	""));
        }
        builder.append(theDumpHex).append(""
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    public void addChildRecord(EscherRecord childRecord) {
        getChildRecords().add( childRecord );
    }
}
"
poi,3,org.apache.poi.ddf.EscherPropertyMetaData,4,1,0,1,5,0,1,0,4,1.125,33,0.25,0,0.0,0.583333333,0,0,5.25,1,0.5,1,"


package org.apache.poi.ddf;


public class EscherPropertyMetaData
{
    
    public final static byte TYPE_UNKNOWN = (byte) 0;
    public final static byte TYPE_BOOLEAN = (byte) 1;
    public final static byte TYPE_RGB = (byte) 2;
    public final static byte TYPE_SHAPEPATH = (byte) 3;
    public final static byte TYPE_SIMPLE = (byte)4;
    public final static byte TYPE_ARRAY = (byte)5;;

    private String description;
    private byte type;


    
    public EscherPropertyMetaData( String description )
    {
        this.description = description;
    }

    
    public EscherPropertyMetaData( String description, byte type )
    {
        this.description = description;
        this.type = type;
    }

    public String getDescription()
    {
        return description;
    }

    public byte getType()
    {
        return type;
    }

}
"
poi,3,org.apache.poi.hssf.record.RefModeRecord,11,2,0,6,20,43,2,4,9,0.95,104,0.25,0,0.55,0.309090909,1,4,8.090909091,2,0.9091,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class RefModeRecord
    extends StandardRecord
{
    public final static short sid           = 0xf;
    public final static short USE_A1_MODE   = 1;
    public final static short USE_R1C1_MODE = 0;
    private short             field_1_mode;

    public RefModeRecord()
    {
    }

    public RefModeRecord(RecordInputStream in)
    {
        field_1_mode = in.readShort();
    }

    

    public void setMode(short mode)
    {
        field_1_mode = mode;
    }

    

    public short getMode()
    {
        return field_1_mode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[REFMODE]
"");
        buffer.append(""    .mode           = "")
            .append(Integer.toHexString(getMode())).append(""
"");
        buffer.append(""[/REFMODE]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getMode());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      RefModeRecord rec = new RefModeRecord();
      rec.field_1_mode = field_1_mode;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.FormatRecord,15,2,0,8,31,55,3,5,13,0.757142857,240,0.8,0,0.458333333,0.2,1,4,14.66666667,4,1.3333,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;


public final class FormatRecord extends StandardRecord {
    public final static short sid = 0x041E;

    private final int field_1_index_code;
    private final boolean field_3_hasMultibyte;
    private final String field_4_formatstring;

    public FormatRecord(int indexCode, String fs) {
        field_1_index_code = indexCode;
        field_4_formatstring = fs;
        field_3_hasMultibyte = StringUtil.hasMultibyte(fs);
    }

    public FormatRecord(RecordInputStream in) {
        field_1_index_code = in.readShort();
        int field_3_unicode_len = in.readUShort();
        field_3_hasMultibyte = (in.readByte() & 0x01) != 0;

        if (field_3_hasMultibyte) {
            field_4_formatstring = in.readUnicodeLEString(field_3_unicode_len);
        } else {
            field_4_formatstring = in.readCompressedUnicode(field_3_unicode_len);
        }
    }

    
    public int getIndexCode() {
        return field_1_index_code;
    }

    
    public String getFormatString() {
        return field_4_formatstring;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FORMAT]
"");
        buffer.append(""    .indexcode       = "").append(HexDump.shortToHex(getIndexCode())).append(""
"");
        buffer.append(""    .isUnicode       = "").append(field_3_hasMultibyte ).append(""
"");
        buffer.append(""    .formatstring    = "").append(getFormatString()).append(""
"");
        buffer.append(""[/FORMAT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        String formatString = getFormatString();
        out.writeShort(getIndexCode());
        out.writeShort(formatString.length());
        out.writeByte(field_3_hasMultibyte ? 0x01 : 0x00);

      if ( field_3_hasMultibyte ) {
          StringUtil.putUnicodeLE( formatString, out);
      }  else {
          StringUtil.putCompressedUnicode( formatString, out);
      }
    }
    protected int getDataSize() {
        return 5 
            + getFormatString().length() * (field_3_hasMultibyte ? 2 : 1);
    }

    public short getSid() {
        return sid;
    }
    @Override
    public Object clone() {
        
        return this;
    }
}
"
poi,3,org.apache.poi.hssf.record.SaveRecalcRecord,11,2,0,6,20,35,2,4,9,0.8,112,0.5,0,0.55,0.257575758,1,4,9.0,2,1.0909,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class SaveRecalcRecord
    extends StandardRecord
{
    public final static short sid = 0x5f;
    private short             field_1_recalc;

    public SaveRecalcRecord()
    {
    }

    public SaveRecalcRecord(RecordInputStream in)
    {
        field_1_recalc = in.readShort();
    }

    

    public void setRecalc(boolean recalc)
    {
        field_1_recalc = ( short ) ((recalc == true) ? 1
                                                     : 0);
    }

    

    public boolean getRecalc()
    {
        return (field_1_recalc == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SAVERECALC]
"");
        buffer.append(""    .recalc         = "").append(getRecalc())
            .append(""
"");
        buffer.append(""[/SAVERECALC]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_recalc);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      SaveRecalcRecord rec = new SaveRecalcRecord();
      rec.field_1_recalc = field_1_recalc;
      return rec;
    }
}
"
poi,3,org.apache.poi.poifs.filesystem.Entry,6,1,0,7,6,15,7,1,6,2.0,6,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.filesystem;



public interface Entry
{

    

    public String getName();

    

    public boolean isDirectoryEntry();

    

    public boolean isDocumentEntry();

    

    public DirectoryEntry getParent();

    

    public boolean delete();

    

    public boolean renameTo(final String newName);
}   

"
poi,3,org.apache.poi.hssf.record.SSTDeserializer,3,1,0,4,6,1,1,3,3,0.5,32,1.0,1,0.0,0.466666667,0,0,9.333333333,2,1.0,0,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.common.UnicodeString;
import org.apache.poi.util.IntMapper;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


class SSTDeserializer
{
	private static POILogger logger = POILogFactory.getLogger(SSTDeserializer.class);
    private IntMapper<UnicodeString> strings;

    public SSTDeserializer( IntMapper<UnicodeString> strings )
    {
        this.strings = strings;
    }

    
    public void manufactureStrings( int stringCount, RecordInputStream in )
    {
      for (int i=0;i<stringCount;i++) {
         
         UnicodeString str;
         if(in.available() == 0 && ! in.hasNextRecord()) {
        	 logger.log( POILogger.ERROR, ""Ran out of data before creating all the strings! String at index "" + i + """");
            str = new UnicodeString("""");
         } else {
            str = new UnicodeString(in);
         }
         addToStringTable( strings, str );
      }
    }

    static public void addToStringTable( IntMapper<UnicodeString> strings, UnicodeString string )
    {
      strings.add(string);
    }
}
"
poi,3,org.apache.poi.ddf.EscherArrayProperty,15,3,0,6,37,5,2,4,14,0.904761905,434,1.0,0,0.535714286,0.4,1,4,27.73333333,3,1.5333,1,"

package org.apache.poi.ddf;

import java.util.Iterator;
import java.util.NoSuchElementException;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public final class EscherArrayProperty extends EscherComplexProperty implements Iterable<byte[]> {
    
    private static final int FIXED_SIZE = 3 * 2;
    
    private boolean sizeIncludesHeaderSize = true;

    
    private boolean emptyComplexPart = false;

    public EscherArrayProperty(short id, byte[] complexData) {
        super(id, checkComplexData(complexData));
        emptyComplexPart = complexData.length == 0;
    }

    public EscherArrayProperty(short propertyNumber, boolean isBlipId, byte[] complexData) {
        super(propertyNumber, isBlipId, checkComplexData(complexData));
    }

    private static byte[] checkComplexData(byte[] complexData) {
        if (complexData == null || complexData.length == 0) {
            return new byte[6];
        }

        return complexData;
    }

    public int getNumberOfElementsInArray() {
        if (emptyComplexPart){
            return 0;
        }
        return LittleEndian.getUShort(_complexData, 0);
    }

    public void setNumberOfElementsInArray(int numberOfElements) {
        int expectedArraySize = numberOfElements * getActualSizeOfElements(getSizeOfElements()) + FIXED_SIZE;
        if (expectedArraySize != _complexData.length) {
            byte[] newArray = new byte[expectedArraySize];
            System.arraycopy(_complexData, 0, newArray, 0, _complexData.length);
            _complexData = newArray;
        }
        LittleEndian.putShort(_complexData, 0, (short) numberOfElements);
    }

    public int getNumberOfElementsInMemory() {
        return LittleEndian.getUShort(_complexData, 2);
    }

    public void setNumberOfElementsInMemory(int numberOfElements) {
        int expectedArraySize = numberOfElements * getActualSizeOfElements(getSizeOfElements()) + FIXED_SIZE;
        if (expectedArraySize != _complexData.length) {
            byte[] newArray = new byte[expectedArraySize];
            System.arraycopy(_complexData, 0, newArray, 0, expectedArraySize);
            _complexData = newArray;
        }
        LittleEndian.putShort(_complexData, 2, (short) numberOfElements);
    }

    public short getSizeOfElements() {
        return LittleEndian.getShort( _complexData, 4 );
    }

    public void setSizeOfElements(int sizeOfElements) {
        LittleEndian.putShort( _complexData, 4, (short) sizeOfElements );

        int expectedArraySize = getNumberOfElementsInArray() * getActualSizeOfElements(getSizeOfElements()) + FIXED_SIZE;
        if (expectedArraySize != _complexData.length) {
            
            byte[] newArray = new byte[expectedArraySize];
            System.arraycopy( _complexData, 0, newArray, 0, 6 );
            _complexData = newArray;
        }
    }

    public byte[] getElement(int index) {
        int actualSize = getActualSizeOfElements(getSizeOfElements());
        byte[] result = new byte[actualSize];
        System.arraycopy(_complexData, FIXED_SIZE + index * actualSize, result, 0, result.length );
        return result;
    }

    public void setElement(int index, byte[] element) {
        int actualSize = getActualSizeOfElements(getSizeOfElements());
        System.arraycopy( element, 0, _complexData, FIXED_SIZE + index * actualSize, actualSize);
    }

    public String toString() {
        StringBuffer results = new StringBuffer();
        results.append(""    {EscherArrayProperty:"" + '
');
        results.append(""     Num Elements: "" + getNumberOfElementsInArray() + '
');
        results.append(""     Num Elements In Memory: "" + getNumberOfElementsInMemory() + '
');
        results.append(""     Size of elements: "" + getSizeOfElements() + '
');
        for (int i = 0; i < getNumberOfElementsInArray(); i++) {
            results.append(""     Element "" + i + "": "" + HexDump.toHex(getElement(i)) + '
');
        }
        results.append(""}"" + '
');

        return ""propNum: "" + getPropertyNumber()
                + "", propName: "" + EscherProperties.getPropertyName( getPropertyNumber() )
                + "", complex: "" + isComplex()
                + "", blipId: "" + isBlipId()
                + "", data: "" + '
' + results.toString();
    }

    public String toXml(String tab){
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("" id=""0x"").append(HexDump.toHex(getId()))
                .append("""" name="""").append(getName()).append("""" blipId="""")
                .append(isBlipId()).append("""">
"");
        for (int i = 0; i < getNumberOfElementsInArray(); i++) {
            builder.append(""	"").append(tab).append(""<Element>"").append(HexDump.toHex(getElement(i))).append(""</Element>
"");
        }
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public int setArrayData(byte[] data, int offset) {
        if (emptyComplexPart){
            _complexData = new byte[0];
        } else {
            short numElements = LittleEndian.getShort(data, offset);
            LittleEndian.getShort(data, offset + 2); 
            short sizeOfElements = LittleEndian.getShort(data, offset + 4);

            int arraySize = getActualSizeOfElements(sizeOfElements) * numElements;
            if (arraySize == _complexData.length) {
                
                _complexData = new byte[arraySize + 6];
                sizeIncludesHeaderSize = false;
            }
            System.arraycopy(data, offset, _complexData, 0, _complexData.length );
        }
        return _complexData.length;
    }

    
    public int serializeSimplePart(byte[] data, int pos) {
        LittleEndian.putShort(data, pos, getId());
        int recordSize = _complexData.length;
        if(!sizeIncludesHeaderSize) {
            recordSize -= 6;
        }
        LittleEndian.putInt(data, pos + 2, recordSize);
        return 6;
    }

    
    public static int getActualSizeOfElements(short sizeOfElements) {
        if (sizeOfElements < 0) {
            return (short) ( ( -sizeOfElements ) >> 2 );
        }
        return sizeOfElements;
    }

    public Iterator<byte[]> iterator() {
        return new Iterator<byte[]>(){
            int idx = 0;
            public boolean hasNext() {
                return (idx < getNumberOfElementsInArray());
            }
            
            public byte[] next() {
                if (!hasNext()) throw new NoSuchElementException();
                return getElement(idx++);
            }
            
            public void remove() {
                throw new UnsupportedOperationException(""not yet implemented"");
            }
        };
    }
    
    
}
"
poi,3,org.apache.poi.hpsf.ReadingNotSupportedException,1,6,0,2,2,0,1,1,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class ReadingNotSupportedException
    extends UnsupportedVariantTypeException
{

    
    public ReadingNotSupportedException(final long variantType,
                                        final Object value)
    {
        super(variantType, value);
    }

}
"
poi,3,org.apache.poi.hssf.record.BottomMarginRecord,11,2,0,7,21,35,2,5,9,0.8,107,0.5,0,0.55,0.257575758,1,4,8.545454545,2,0.9091,1,"


package org.apache.poi.hssf.record;


import org.apache.poi.util.*;



public final class BottomMarginRecord extends StandardRecord implements Margin {
    public final static short sid = 0x29;
    private double field_1_margin;

    public BottomMarginRecord()
    {

    }

    public BottomMarginRecord( RecordInputStream in )
    {
        field_1_margin = in.readDouble();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();
        buffer.append( ""[BottomMargin]
"" );
        buffer.append( ""    .margin               = "" )
                .append( "" ("" ).append( getMargin() ).append( "" )
"" );
        buffer.append( ""[/BottomMargin]
"" );
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeDouble(field_1_margin);
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid()
    {
        return sid;
    }

    
    public double getMargin()
    {
        return field_1_margin;
    }

    
    public void setMargin( double field_1_margin )
    {
        this.field_1_margin = field_1_margin;
    }

    public Object clone()
    {
        BottomMarginRecord rec = new BottomMarginRecord();
        rec.field_1_margin = this.field_1_margin;
        return rec;
    }

}  "
poi,3,org.apache.poi.hssf.record.MergeCellsRecord,14,2,0,7,37,35,3,5,12,0.730769231,335,0.5,0,0.47826087,0.342857143,1,4,22.78571429,2,1.3571,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellRangeAddressList;
import org.apache.poi.util.LittleEndianOutput;


public final class MergeCellsRecord extends StandardRecord {
    public final static short sid = 0x00E5;
     
    private CellRangeAddress[] _regions;
    private final int _startIndex;
    private final int _numberOfRegions;

    public MergeCellsRecord(CellRangeAddress[] regions, int startIndex, int numberOfRegions) {
		_regions = regions;
		_startIndex = startIndex;
		_numberOfRegions = numberOfRegions;
    }
    
    public MergeCellsRecord(RecordInputStream in) {
     	int nRegions = in.readUShort();
    	CellRangeAddress[] cras = new CellRangeAddress[nRegions];
    	for (int i = 0; i < nRegions; i++) {
			cras[i] = new CellRangeAddress(in);
		}
    	_numberOfRegions = nRegions;
    	_startIndex = 0;
    	_regions = cras;
    }
    
    public short getNumAreas() {
        return (short)_numberOfRegions;
    }

    
    public CellRangeAddress getAreaAt(int index) {
        return _regions[_startIndex + index];
    }

    protected int getDataSize() {
		return CellRangeAddressList.getEncodedSize(_numberOfRegions);
	}

    public short getSid() {
        return sid;
    }

    public void serialize(LittleEndianOutput out) {
        int nItems = _numberOfRegions;
        out.writeShort(nItems);
        for (int i = 0; i < _numberOfRegions; i++) {
			_regions[_startIndex + i].serialize(out);
		}
    }

    public String toString() {
        StringBuffer retval = new StringBuffer();

        retval.append(""[MERGEDCELLS]"").append(""
"");
        retval.append(""     .numregions ="").append(getNumAreas()).append(""
"");
        for (int k = 0; k < _numberOfRegions; k++) {
            CellRangeAddress r = _regions[_startIndex + k];

            retval.append(""     .rowfrom ="").append(r.getFirstRow()).append(""
"");
            retval.append(""     .rowto   ="").append(r.getLastRow()).append(""
"");
            retval.append(""     .colfrom ="").append(r.getFirstColumn()).append(""
"");
            retval.append(""     .colto   ="").append(r.getLastColumn()).append(""
"");
        }
        retval.append(""[MERGEDCELLS]"").append(""
"");
        return retval.toString();
    }

    public Object clone() {
    	int nRegions = _numberOfRegions;
    	CellRangeAddress[] clonedRegions = new CellRangeAddress[nRegions];
		for (int i = 0; i < clonedRegions.length; i++) {
			clonedRegions[i] = _regions[_startIndex + i].copy();
		}
        return new MergeCellsRecord(clonedRegions, 0, nRegions);
    }
}
"
poi,3,org.apache.poi.hssf.record.WindowProtectRecord,10,2,0,6,19,33,2,4,8,0.833333333,102,0.5,0,0.578947368,0.266666667,1,4,9.0,2,1.1,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class WindowProtectRecord extends StandardRecord {
    public final static short sid = 0x0019;

    private static final BitField settingsProtectedFlag = BitFieldFactory.getInstance(0x0001);

    private int _options;

    public WindowProtectRecord(int options) {
        _options = options;
    }

    public WindowProtectRecord(RecordInputStream in) {
        this(in.readUShort());
    }

    public WindowProtectRecord(boolean protect) {
        this(0);
        setProtect(protect);
    }

    
    public void setProtect(boolean protect) {
        _options = settingsProtectedFlag.setBoolean(_options, protect);
    }

    
    public boolean getProtect() {
        return settingsProtectedFlag.isSet(_options);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WINDOWPROTECT]
"");
        buffer.append(""    .options = "").append(HexDump.shortToHex(_options)).append(""
"");
        buffer.append(""[/WINDOWPROTECT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_options);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
    @Override
    public Object clone() {
        return new WindowProtectRecord(_options);
    }
}
"
poi,3,org.apache.poi.hssf.model.SimpleFilledShape,6,2,0,12,36,11,1,12,2,0.8,173,1.0,2,0.5,0.541666667,1,1,27.5,3,1.1667,2,"

package org.apache.poi.hssf.model;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.hssf.record.EscherAggregate;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.EndSubRecord;
import org.apache.poi.hssf.usermodel.HSSFSimpleShape;
import org.apache.poi.hssf.usermodel.HSSFShape;

@Deprecated
public class SimpleFilledShape
        extends AbstractShape
{
    private EscherContainerRecord spContainer;
    private ObjRecord objRecord;

    
    SimpleFilledShape( HSSFSimpleShape hssfShape, int shapeId )
    {
        spContainer = createSpContainer( hssfShape, shapeId );
        objRecord = createObjRecord( hssfShape, shapeId );
    }

    
    private EscherContainerRecord createSpContainer( HSSFSimpleShape hssfShape, int shapeId )
    {
        HSSFShape shape = hssfShape;

        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherClientDataRecord clientData = new EscherClientDataRecord();

        spContainer.setRecordId( EscherContainerRecord.SP_CONTAINER );
        spContainer.setOptions( (short) 0x000F );
        sp.setRecordId( EscherSpRecord.RECORD_ID );
        short shapeType = objTypeToShapeType( hssfShape.getShapeType() );
        sp.setOptions( (short) ( ( shapeType << 4 ) | 0x2 ) );
        sp.setShapeId( shapeId );
        sp.setFlags( EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        opt.setRecordId( EscherOptRecord.RECORD_ID );
        addStandardOptions(shape, opt);
        EscherRecord anchor = createAnchor( shape.getAnchor() );
        clientData.setRecordId( EscherClientDataRecord.RECORD_ID );
        clientData.setOptions( (short) 0x0000 );

        spContainer.addChildRecord( sp );
        spContainer.addChildRecord( opt );
        spContainer.addChildRecord( anchor );
        spContainer.addChildRecord( clientData );

        return spContainer;
    }

    private short objTypeToShapeType( int objType )
    {
        short shapeType;
        if (objType == HSSFSimpleShape.OBJECT_TYPE_OVAL)
            shapeType = EscherAggregate.ST_ELLIPSE;
        else if (objType == HSSFSimpleShape.OBJECT_TYPE_RECTANGLE)
            shapeType = EscherAggregate.ST_RECTANGLE;
        else
            throw new IllegalArgumentException(""Unable to handle an object of this type"");
        return shapeType;
    }

    
    private ObjRecord createObjRecord( HSSFShape hssfShape, int shapeId )
    {
        HSSFShape shape = hssfShape;

        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType( (short) ( (HSSFSimpleShape) shape ).getShapeType() );
        c.setObjectId(  getCmoObjectId(shapeId) );
        c.setLocked( true );
        c.setPrintable( true );
        c.setAutofill( true );
        c.setAutoline( true );
        EndSubRecord e = new EndSubRecord();

        obj.addSubRecord( c );
        obj.addSubRecord( e );

        return obj;
    }

    public EscherContainerRecord getSpContainer()
    {
        return spContainer;
    }

    public ObjRecord getObjRecord()
    {
        return objRecord;
    }

}
"
poi,3,org.apache.poi.ddf.EscherDump,9,1,0,8,45,36,1,8,5,2.0,3581,0.0,0,0.0,0.296296296,0,0,396.8888889,3,1.3333,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.HexRead;
import org.apache.poi.util.LittleEndian;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.zip.InflaterInputStream;


public final class EscherDump {

    public EscherDump() {
        
    }

    
    public void dump(byte[] data, int offset, int size, PrintStream out) {
        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory();
        int pos = offset;
        while ( pos < offset + size )
        {
            EscherRecord r = recordFactory.createRecord(data, pos);
            int bytesRead = r.fillFields(data, pos, recordFactory );
            out.println( r.toString() );
            pos += bytesRead;
        }
    }

    
    public void dumpOld(long maxLength, InputStream in, PrintStream out)
            throws IOException, LittleEndian.BufferUnderrunException {
        long remainingBytes = maxLength;
        short options;      
        short recordId;
        int recordBytesRemaining;       
        StringBuffer stringBuf = new StringBuffer();
        short nDumpSize;
        String recordName;

        boolean atEOF = false;

        while (!atEOF && (remainingBytes > 0)) {
            stringBuf = new StringBuffer();
            options = LittleEndian.readShort( in );
            recordId = LittleEndian.readShort( in );
            recordBytesRemaining = LittleEndian.readInt( in );

            remainingBytes -= 2 + 2 + 4;

            switch ( recordId )
            {
                case (short) 0xF000:
                    recordName = ""MsofbtDggContainer"";
                    break;
                case (short) 0xF006:
                    recordName = ""MsofbtDgg"";
                    break;
                case (short) 0xF016:
                    recordName = ""MsofbtCLSID"";
                    break;
                case (short) 0xF00B:
                    recordName = ""MsofbtOPT"";
                    break;
                case (short) 0xF11A:
                    recordName = ""MsofbtColorMRU"";
                    break;
                case (short) 0xF11E:
                    recordName = ""MsofbtSplitMenuColors"";
                    break;
                case (short) 0xF001:
                    recordName = ""MsofbtBstoreContainer"";
                    break;
                case (short) 0xF007:
                    recordName = ""MsofbtBSE"";
                    break;
                case (short) 0xF002:
                    recordName = ""MsofbtDgContainer"";
                    break;
                case (short) 0xF008:
                    recordName = ""MsofbtDg"";
                    break;
                case (short) 0xF118:
                    recordName = ""MsofbtRegroupItem"";
                    break;
                case (short) 0xF120:
                    recordName = ""MsofbtColorScheme"";
                    break;
                case (short) 0xF003:
                    recordName = ""MsofbtSpgrContainer"";
                    break;
                case (short) 0xF004:
                    recordName = ""MsofbtSpContainer"";
                    break;
                case (short) 0xF009:
                    recordName = ""MsofbtSpgr"";
                    break;
                case (short) 0xF00A:
                    recordName = ""MsofbtSp"";
                    break;
                case (short) 0xF00C:
                    recordName = ""MsofbtTextbox"";
                    break;
                case (short) 0xF00D:
                    recordName = ""MsofbtClientTextbox"";
                    break;
                case (short) 0xF00E:
                    recordName = ""MsofbtAnchor"";
                    break;
                case (short) 0xF00F:
                    recordName = ""MsofbtChildAnchor"";
                    break;
                case (short) 0xF010:
                    recordName = ""MsofbtClientAnchor"";
                    break;
                case (short) 0xF011:
                    recordName = ""MsofbtClientData"";
                    break;
                case (short) 0xF11F:
                    recordName = ""MsofbtOleObject"";
                    break;
                case (short) 0xF11D:
                    recordName = ""MsofbtDeletedPspl"";
                    break;
                case (short) 0xF005:
                    recordName = ""MsofbtSolverContainer"";
                    break;
                case (short) 0xF012:
                    recordName = ""MsofbtConnectorRule"";
                    break;
                case (short) 0xF013:
                    recordName = ""MsofbtAlignRule"";
                    break;
                case (short) 0xF014:
                    recordName = ""MsofbtArcRule"";
                    break;
                case (short) 0xF015:
                    recordName = ""MsofbtClientRule"";
                    break;
                case (short) 0xF017:
                    recordName = ""MsofbtCalloutRule"";
                    break;
                case (short) 0xF119:
                    recordName = ""MsofbtSelection"";
                    break;
                case (short) 0xF122:
                    recordName = ""MsofbtUDefProp"";
                    break;
                default:
                    if ( recordId >= (short) 0xF018 && recordId <= (short) 0xF117 )
                        recordName = ""MsofbtBLIP"";
                    else if ( ( options & (short) 0x000F ) == (short) 0x000F )
                        recordName = ""UNKNOWN container"";
                    else
                        recordName = ""UNKNOWN ID"";
            }

            stringBuf.append( ""  "" );
            stringBuf.append( HexDump.toHex( recordId ) );
            stringBuf.append( ""  "" ).append( recordName ).append( "" ["" );
            stringBuf.append( HexDump.toHex( options ) );
            stringBuf.append( ',' );
            stringBuf.append( HexDump.toHex( recordBytesRemaining ) );
            stringBuf.append( ""]  instance: "" );
            stringBuf.append( HexDump.toHex( ( (short) ( options >> 4 ) ) ) );
            out.println( stringBuf.toString() );


            if ( recordId == (short) 0xF007 && 36 <= remainingBytes && 36 <= recordBytesRemaining )
            {	
                

                byte n8;
                
                

                stringBuf = new StringBuffer( ""    btWin32: "" );
                n8 = (byte) in.read();
                stringBuf.append( HexDump.toHex( n8 ) );
                stringBuf.append( getBlipType( n8 ) );
                stringBuf.append( ""  btMacOS: "" );
                n8 = (byte) in.read();
                stringBuf.append( HexDump.toHex( n8 ) );
                stringBuf.append( getBlipType( n8 ) );
                out.println( stringBuf.toString() );

                out.println( ""    rgbUid:"" );
                HexDump.dump( in, out, 0, 16 );

                out.print( ""    tag: "" );
                outHex( 2, in, out );
                out.println();
                out.print( ""    size: "" );
                outHex( 4, in, out );
                out.println();
                out.print( ""    cRef: "" );
                outHex( 4, in, out );
                out.println();
                out.print( ""    offs: "" );
                outHex( 4, in, out );
                out.println();
                out.print( ""    usage: "" );
                outHex( 1, in, out );
                out.println();
                out.print( ""    cbName: "" );
                outHex( 1, in, out );
                out.println();
                out.print( ""    unused2: "" );
                outHex( 1, in, out );
                out.println();
                out.print( ""    unused3: "" );
                outHex( 1, in, out );
                out.println();

                
                remainingBytes -= 36;
                
                recordBytesRemaining = 0;		
            }
            else if ( recordId == (short) 0xF010 && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining )
            {	
                
                

                out.print( ""    Flag: "" );
                outHex( 2, in, out );
                out.println();
                out.print( ""    Col1: "" );
                outHex( 2, in, out );
                out.print( ""    dX1: "" );
                outHex( 2, in, out );
                out.print( ""    Row1: "" );
                outHex( 2, in, out );
                out.print( ""    dY1: "" );
                outHex( 2, in, out );
                out.println();
                out.print( ""    Col2: "" );
                outHex( 2, in, out );
                out.print( ""    dX2: "" );
                outHex( 2, in, out );
                out.print( ""    Row2: "" );
                outHex( 2, in, out );
                out.print( ""    dY2: "" );
                outHex( 2, in, out );
                out.println();

                remainingBytes -= 18;
                recordBytesRemaining -= 18;

            }
            else if ( recordId == (short) 0xF00B || recordId == (short) 0xF122 )
            {	
                int nComplex = 0;
                out.println( ""    PROPID        VALUE"" );
                while ( recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex )
                {
                    short n16;
                    int n32;
                    n16 = LittleEndian.readShort( in );
                    n32 = LittleEndian.readInt( in );

                    recordBytesRemaining -= 6;
                    remainingBytes -= 6;
                    out.print( ""    "" );
                    out.print( HexDump.toHex( n16 ) );
                    out.print( "" ("" );
                    int propertyId = n16 & (short) 0x3FFF;
                    out.print( "" "" + propertyId  );
                    if ( ( n16 & (short) 0x8000 ) == 0 )
                    {
                        if ( ( n16 & (short) 0x4000 ) != 0 )
                            out.print( "", fBlipID"" );
                        out.print( "")  "" );

                        out.print( HexDump.toHex( n32 ) );

                        if ( ( n16 & (short) 0x4000 ) == 0 )
                        {
                            out.print( "" ("" );
                            out.print( dec1616( n32 ) );
                            out.print( ')' );
                            out.print( "" {"" + propName( (short)propertyId ) + ""}"" );
                        }
                        out.println();
                    }
                    else
                    {
                        out.print( "", fComplex)  "" );
                        out.print( HexDump.toHex( n32 ) );
                        out.print( "" - Complex prop len"" );
                        out.println( "" {"" + propName( (short)propertyId ) + ""}"" );

                        nComplex += n32;
                    }

                }
                
                while ( ( nComplex & remainingBytes ) > 0 )
                {
                    nDumpSize = ( nComplex > (int) remainingBytes ) ? (short) remainingBytes : (short) nComplex;
                    HexDump.dump( in, out, 0, nDumpSize );
                    nComplex -= nDumpSize;
                    recordBytesRemaining -= nDumpSize;
                    remainingBytes -= nDumpSize;
                }
            }
            else if ( recordId == (short) 0xF012 )
            {
                out.print( ""    Connector rule: "" );
                out.print( LittleEndian.readInt( in ) );
                out.print( ""    ShapeID A: "" );
                out.print( LittleEndian.readInt( in ) );
                out.print( ""   ShapeID B: "" );
                out.print( LittleEndian.readInt( in ) );
                out.print( ""    ShapeID connector: "" );
                out.print( LittleEndian.readInt( in ) );
                out.print( ""   Connect pt A: "" );
                out.print( LittleEndian.readInt( in ) );
                out.print( ""   Connect pt B: "" );
                out.println( LittleEndian.readInt( in ) );

                recordBytesRemaining -= 24;
                remainingBytes -= 24;
            }
            else if ( recordId >= (short) 0xF018 && recordId < (short) 0xF117 )
            {
                out.println( ""    Secondary UID: "" );
                HexDump.dump( in, out, 0, 16 );
                out.println( ""    Cache of size: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Boundary top: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Boundary left: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Boundary width: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Boundary height: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    X: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Y: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Cache of saved size: "" + HexDump.toHex( LittleEndian.readInt( in ) ) );
                out.println( ""    Compression Flag: "" + HexDump.toHex( (byte) in.read() ) );
                out.println( ""    Filter: "" + HexDump.toHex( (byte) in.read() ) );
                out.println( ""    Data (after decompression): "" );

                recordBytesRemaining -= 34 + 16;
                remainingBytes -= 34 + 16;

                nDumpSize = ( recordBytesRemaining > (int) remainingBytes ) ? (short) remainingBytes : (short) recordBytesRemaining;


                byte[] buf = new byte[nDumpSize];
                int read = in.read( buf );
                while ( read != -1 && read < nDumpSize )
                    read += in.read( buf, read, buf.length );
                ByteArrayInputStream bin = new ByteArrayInputStream( buf );

                InputStream in1 = new InflaterInputStream( bin );
                int bytesToDump = -1;
                HexDump.dump( in1, out, 0, bytesToDump );

                recordBytesRemaining -= nDumpSize;
                remainingBytes -= nDumpSize;

            }

            boolean isContainer = ( options & (short) 0x000F ) == (short) 0x000F;
            if ( isContainer && remainingBytes >= 0 )
            {	
                if ( recordBytesRemaining <= (int) remainingBytes )
                    out.println( ""            completed within"" );
                else
                    out.println( ""            continued elsewhere"" );
            }
            else if ( remainingBytes >= 0 )
            
            {
                nDumpSize = ( recordBytesRemaining > (int) remainingBytes ) ? (short) remainingBytes : (short) recordBytesRemaining;

                if ( nDumpSize != 0 )
                {
                    HexDump.dump( in, out, 0, nDumpSize );
                    remainingBytes -= nDumpSize;
                }
            }
            else
                out.println( "" >> OVERRUN <<"" );
        }

    }

    
    private String propName(short propertyId) {
        final class PropName {
            final int _id;
            final String _name;
            public PropName(int id, String name) {
                _id = id;
                _name = name;
            }
        }

        final PropName[] props = new PropName[] {
            new PropName(4, ""transform.rotation""),
            new PropName(119, ""protection.lockrotation""),
            new PropName(120, ""protection.lockaspectratio""),
            new PropName(121, ""protection.lockposition""),
            new PropName(122, ""protection.lockagainstselect""),
            new PropName(123, ""protection.lockcropping""),
            new PropName(124, ""protection.lockvertices""),
            new PropName(125, ""protection.locktext""),
            new PropName(126, ""protection.lockadjusthandles""),
            new PropName(127, ""protection.lockagainstgrouping""),
            new PropName(128, ""text.textid""),
            new PropName(129, ""text.textleft""),
            new PropName(130, ""text.texttop""),
            new PropName(131, ""text.textright""),
            new PropName(132, ""text.textbottom""),
            new PropName(133, ""text.wraptext""),
            new PropName(134, ""text.scaletext""),
            new PropName(135, ""text.anchortext""),
            new PropName(136, ""text.textflow""),
            new PropName(137, ""text.fontrotation""),
            new PropName(138, ""text.idofnextshape""),
            new PropName(139, ""text.bidir""),
            new PropName(187, ""text.singleclickselects""),
            new PropName(188, ""text.usehostmargins""),
            new PropName(189, ""text.rotatetextwithshape""),
            new PropName(190, ""text.sizeshapetofittext""),
            new PropName(191, ""text.sizetexttofitshape""),
            new PropName(192, ""geotext.unicode""),
            new PropName(193, ""geotext.rtftext""),
            new PropName(194, ""geotext.alignmentoncurve""),
            new PropName(195, ""geotext.defaultpointsize""),
            new PropName(196, ""geotext.textspacing""),
            new PropName(197, ""geotext.fontfamilyname""),
            new PropName(240, ""geotext.reverseroworder""),
            new PropName(241, ""geotext.hastexteffect""),
            new PropName(242, ""geotext.rotatecharacters""),
            new PropName(243, ""geotext.kerncharacters""),
            new PropName(244, ""geotext.tightortrack""),
            new PropName(245, ""geotext.stretchtofitshape""),
            new PropName(246, ""geotext.charboundingbox""),
            new PropName(247, ""geotext.scaletextonpath""),
            new PropName(248, ""geotext.stretchcharheight""),
            new PropName(249, ""geotext.nomeasurealongpath""),
            new PropName(250, ""geotext.boldfont""),
            new PropName(251, ""geotext.italicfont""),
            new PropName(252, ""geotext.underlinefont""),
            new PropName(253, ""geotext.shadowfont""),
            new PropName(254, ""geotext.smallcapsfont""),
            new PropName(255, ""geotext.strikethroughfont""),
            new PropName(256, ""blip.cropfromtop""),
            new PropName(257, ""blip.cropfrombottom""),
            new PropName(258, ""blip.cropfromleft""),
            new PropName(259, ""blip.cropfromright""),
            new PropName(260, ""blip.bliptodisplay""),
            new PropName(261, ""blip.blipfilename""),
            new PropName(262, ""blip.blipflags""),
            new PropName(263, ""blip.transparentcolor""),
            new PropName(264, ""blip.contrastsetting""),
            new PropName(265, ""blip.brightnesssetting""),
            new PropName(266, ""blip.gamma""),
            new PropName(267, ""blip.pictureid""),
            new PropName(268, ""blip.doublemod""),
            new PropName(269, ""blip.picturefillmod""),
            new PropName(270, ""blip.pictureline""),
            new PropName(271, ""blip.printblip""),
            new PropName(272, ""blip.printblipfilename""),
            new PropName(273, ""blip.printflags""),
            new PropName(316, ""blip.nohittestpicture""),
            new PropName(317, ""blip.picturegray""),
            new PropName(318, ""blip.picturebilevel""),
            new PropName(319, ""blip.pictureactive""),
            new PropName(320, ""geometry.left""),
            new PropName(321, ""geometry.top""),
            new PropName(322, ""geometry.right""),
            new PropName(323, ""geometry.bottom""),
            new PropName(324, ""geometry.shapepath""),
            new PropName(325, ""geometry.vertices""),
            new PropName(326, ""geometry.segmentinfo""),
            new PropName(327, ""geometry.adjustvalue""),
            new PropName(328, ""geometry.adjust2value""),
            new PropName(329, ""geometry.adjust3value""),
            new PropName(330, ""geometry.adjust4value""),
            new PropName(331, ""geometry.adjust5value""),
            new PropName(332, ""geometry.adjust6value""),
            new PropName(333, ""geometry.adjust7value""),
            new PropName(334, ""geometry.adjust8value""),
            new PropName(335, ""geometry.adjust9value""),
            new PropName(336, ""geometry.adjust10value""),
            new PropName(378, ""geometry.shadowOK""),
            new PropName(379, ""geometry.3dok""),
            new PropName(380, ""geometry.lineok""),
            new PropName(381, ""geometry.geotextok""),
            new PropName(382, ""geometry.fillshadeshapeok""),
            new PropName(383, ""geometry.fillok""),
            new PropName(384, ""fill.filltype""),
            new PropName(385, ""fill.fillcolor""),
            new PropName(386, ""fill.fillopacity""),
            new PropName(387, ""fill.fillbackcolor""),
            new PropName(388, ""fill.backopacity""),
            new PropName(389, ""fill.crmod""),
            new PropName(390, ""fill.patterntexture""),
            new PropName(391, ""fill.blipfilename""),
            new PropName(392, ""fill.blipflags""),
            new PropName(393, ""fill.width""),
            new PropName(394, ""fill.height""),
            new PropName(395, ""fill.angle""),
            new PropName(396, ""fill.focus""),
            new PropName(397, ""fill.toleft""),
            new PropName(398, ""fill.totop""),
            new PropName(399, ""fill.toright""),
            new PropName(400, ""fill.tobottom""),
            new PropName(401, ""fill.rectleft""),
            new PropName(402, ""fill.recttop""),
            new PropName(403, ""fill.rectright""),
            new PropName(404, ""fill.rectbottom""),
            new PropName(405, ""fill.dztype""),
            new PropName(406, ""fill.shadepreset""),
            new PropName(407, ""fill.shadecolors""),
            new PropName(408, ""fill.originx""),
            new PropName(409, ""fill.originy""),
            new PropName(410, ""fill.shapeoriginx""),
            new PropName(411, ""fill.shapeoriginy""),
            new PropName(412, ""fill.shadetype""),
            new PropName(443, ""fill.filled""),
            new PropName(444, ""fill.hittestfill""),
            new PropName(445, ""fill.shape""),
            new PropName(446, ""fill.userect""),
            new PropName(447, ""fill.nofillhittest""),
            new PropName(448, ""linestyle.color""),
            new PropName(449, ""linestyle.opacity""),
            new PropName(450, ""linestyle.backcolor""),
            new PropName(451, ""linestyle.crmod""),
            new PropName(452, ""linestyle.linetype""),
            new PropName(453, ""linestyle.fillblip""),
            new PropName(454, ""linestyle.fillblipname""),
            new PropName(455, ""linestyle.fillblipflags""),
            new PropName(456, ""linestyle.fillwidth""),
            new PropName(457, ""linestyle.fillheight""),
            new PropName(458, ""linestyle.filldztype""),
            new PropName(459, ""linestyle.linewidth""),
            new PropName(460, ""linestyle.linemiterlimit""),
            new PropName(461, ""linestyle.linestyle""),
            new PropName(462, ""linestyle.linedashing""),
            new PropName(463, ""linestyle.linedashstyle""),
            new PropName(464, ""linestyle.linestartarrowhead""),
            new PropName(465, ""linestyle.lineendarrowhead""),
            new PropName(466, ""linestyle.linestartarrowwidth""),
            new PropName(467, ""linestyle.lineestartarrowlength""),
            new PropName(468, ""linestyle.lineendarrowwidth""),
            new PropName(469, ""linestyle.lineendarrowlength""),
            new PropName(470, ""linestyle.linejoinstyle""),
            new PropName(471, ""linestyle.lineendcapstyle""),
            new PropName(507, ""linestyle.arrowheadsok""),
            new PropName(508, ""linestyle.anyline""),
            new PropName(509, ""linestyle.hitlinetest""),
            new PropName(510, ""linestyle.linefillshape""),
            new PropName(511, ""linestyle.nolinedrawdash""),
            new PropName(512, ""shadowstyle.type""),
            new PropName(513, ""shadowstyle.color""),
            new PropName(514, ""shadowstyle.highlight""),
            new PropName(515, ""shadowstyle.crmod""),
            new PropName(516, ""shadowstyle.opacity""),
            new PropName(517, ""shadowstyle.offsetx""),
            new PropName(518, ""shadowstyle.offsety""),
            new PropName(519, ""shadowstyle.secondoffsetx""),
            new PropName(520, ""shadowstyle.secondoffsety""),
            new PropName(521, ""shadowstyle.scalextox""),
            new PropName(522, ""shadowstyle.scaleytox""),
            new PropName(523, ""shadowstyle.scalextoy""),
            new PropName(524, ""shadowstyle.scaleytoy""),
            new PropName(525, ""shadowstyle.perspectivex""),
            new PropName(526, ""shadowstyle.perspectivey""),
            new PropName(527, ""shadowstyle.weight""),
            new PropName(528, ""shadowstyle.originx""),
            new PropName(529, ""shadowstyle.originy""),
            new PropName(574, ""shadowstyle.shadow""),
            new PropName(575, ""shadowstyle.shadowobsured""),
            new PropName(576, ""perspective.type""),
            new PropName(577, ""perspective.offsetx""),
            new PropName(578, ""perspective.offsety""),
            new PropName(579, ""perspective.scalextox""),
            new PropName(580, ""perspective.scaleytox""),
            new PropName(581, ""perspective.scalextoy""),
            new PropName(582, ""perspective.scaleytox""),
            new PropName(583, ""perspective.perspectivex""),
            new PropName(584, ""perspective.perspectivey""),
            new PropName(585, ""perspective.weight""),
            new PropName(586, ""perspective.originx""),
            new PropName(587, ""perspective.originy""),
            new PropName(639, ""perspective.perspectiveon""),
            new PropName(640, ""3d.specularamount""),
            new PropName(661, ""3d.diffuseamount""),
            new PropName(662, ""3d.shininess""),
            new PropName(663, ""3d.edgethickness""),
            new PropName(664, ""3d.extrudeforward""),
            new PropName(665, ""3d.extrudebackward""),
            new PropName(666, ""3d.extrudeplane""),
            new PropName(667, ""3d.extrusioncolor""),
            new PropName(648, ""3d.crmod""),
            new PropName(700, ""3d.3deffect""),
            new PropName(701, ""3d.metallic""),
            new PropName(702, ""3d.useextrusioncolor""),
            new PropName(703, ""3d.lightface""),
            new PropName(704, ""3dstyle.yrotationangle""),
            new PropName(705, ""3dstyle.xrotationangle""),
            new PropName(706, ""3dstyle.rotationaxisx""),
            new PropName(707, ""3dstyle.rotationaxisy""),
            new PropName(708, ""3dstyle.rotationaxisz""),
            new PropName(709, ""3dstyle.rotationangle""),
            new PropName(710, ""3dstyle.rotationcenterx""),
            new PropName(711, ""3dstyle.rotationcentery""),
            new PropName(712, ""3dstyle.rotationcenterz""),
            new PropName(713, ""3dstyle.rendermode""),
            new PropName(714, ""3dstyle.tolerance""),
            new PropName(715, ""3dstyle.xviewpoint""),
            new PropName(716, ""3dstyle.yviewpoint""),
            new PropName(717, ""3dstyle.zviewpoint""),
            new PropName(718, ""3dstyle.originx""),
            new PropName(719, ""3dstyle.originy""),
            new PropName(720, ""3dstyle.skewangle""),
            new PropName(721, ""3dstyle.skewamount""),
            new PropName(722, ""3dstyle.ambientintensity""),
            new PropName(723, ""3dstyle.keyx""),
            new PropName(724, ""3dstyle.keyy""),
            new PropName(725, ""3dstyle.keyz""),
            new PropName(726, ""3dstyle.keyintensity""),
            new PropName(727, ""3dstyle.fillx""),
            new PropName(728, ""3dstyle.filly""),
            new PropName(729, ""3dstyle.fillz""),
            new PropName(730, ""3dstyle.fillintensity""),
            new PropName(763, ""3dstyle.constrainrotation""),
            new PropName(764, ""3dstyle.rotationcenterauto""),
            new PropName(765, ""3dstyle.parallel""),
            new PropName(766, ""3dstyle.keyharsh""),
            new PropName(767, ""3dstyle.fillharsh""),
            new PropName(769, ""shape.master""),
            new PropName(771, ""shape.connectorstyle""),
            new PropName(772, ""shape.blackandwhitesettings""),
            new PropName(773, ""shape.wmodepurebw""),
            new PropName(774, ""shape.wmodebw""),
            new PropName(826, ""shape.oleicon""),
            new PropName(827, ""shape.preferrelativeresize""),
            new PropName(828, ""shape.lockshapetype""),
            new PropName(830, ""shape.deleteattachedobject""),
            new PropName(831, ""shape.backgroundshape""),
            new PropName(832, ""callout.callouttype""),
            new PropName(833, ""callout.xycalloutgap""),
            new PropName(834, ""callout.calloutangle""),
            new PropName(835, ""callout.calloutdroptype""),
            new PropName(836, ""callout.calloutdropspecified""),
            new PropName(837, ""callout.calloutlengthspecified""),
            new PropName(889, ""callout.iscallout""),
            new PropName(890, ""callout.calloutaccentbar""),
            new PropName(891, ""callout.callouttextborder""),
            new PropName(892, ""callout.calloutminusx""),
            new PropName(893, ""callout.calloutminusy""),
            new PropName(894, ""callout.dropauto""),
            new PropName(895, ""callout.lengthspecified""),
            new PropName(896, ""groupshape.shapename""),
            new PropName(897, ""groupshape.description""),
            new PropName(898, ""groupshape.hyperlink""),
            new PropName(899, ""groupshape.wrappolygonvertices""),
            new PropName(900, ""groupshape.wrapdistleft""),
            new PropName(901, ""groupshape.wrapdisttop""),
            new PropName(902, ""groupshape.wrapdistright""),
            new PropName(903, ""groupshape.wrapdistbottom""),
            new PropName(904, ""groupshape.regroupid""),
            new PropName(953, ""groupshape.editedwrap""),
            new PropName(954, ""groupshape.behinddocument""),
            new PropName(955, ""groupshape.ondblclicknotify""),
            new PropName(956, ""groupshape.isbutton""),
            new PropName(957, ""groupshape.1dadjustment""),
            new PropName(958, ""groupshape.hidden""),
            new PropName(959, ""groupshape.print""),
        };

        for (int i = 0; i < props.length; i++) {
            if (props[i]._id == propertyId) {
                return props[i]._name;
            }
        }

        return ""unknown property"";
    }

    
    private static String getBlipType(byte b) {
        return EscherBSERecord.getBlipType(b);
    }

    
    private String dec1616( int n32 )
    {
        String result = """";
        result += (short) ( n32 >> 16 );
        result += '.';
        result += (short) ( n32 & (short) 0xFFFF );
        return result;
    }

    
    private void outHex( int bytes, InputStream in, PrintStream out ) throws IOException, LittleEndian.BufferUnderrunException
    {
        switch ( bytes )
        {
            case 1:
                out.print( HexDump.toHex( (byte) in.read() ) );
                break;
            case 2:
                out.print( HexDump.toHex( LittleEndian.readShort( in ) ) );
                break;
            case 4:
                out.print( HexDump.toHex( LittleEndian.readInt( in ) ) );
                break;
            default:
                throw new IOException( ""Unable to output variable of that width"" );
        }
    }

    
    public static void main( String[] args ) {
        String dump =
                ""0F 00 00 F0 89 07 00 00 00 00 06 F0 18 00 00 00 "" +
                ""05 04 00 00 02 00 00 00 05 00 00 00 01 00 00 00 "" +
                ""01 00 00 00 05 00 00 00 4F 00 01 F0 2F 07 00 00 "" +
                ""42 00 07 F0 B7 01 00 00 03 04 3F 14 AE 6B 0F 65 "" +
                ""B0 48 BF 5E 94 63 80 E8 91 73 FF 00 93 01 00 00 "" +
                ""01 00 00 00 00 00 00 00 00 00 FF FF 20 54 1C F0 "" +
                ""8B 01 00 00 3F 14 AE 6B 0F 65 B0 48 BF 5E 94 63 "" +
                ""80 E8 91 73 92 0E 00 00 00 00 00 00 00 00 00 00 "" +
                ""D1 07 00 00 DD 05 00 00 4A AD 6F 00 8A C5 53 00 "" +
                ""59 01 00 00 00 FE 78 9C E3 9B C4 00 04 AC 77 D9 "" +
                ""2F 32 08 32 FD E7 61 F8 FF 0F C8 FD 05 C5 30 19 "" +
                ""10 90 63 90 FA 0F 06 0C 8C 0C 5C 70 19 43 30 EB "" +
                ""0E FB 05 86 85 0C DB 18 58 80 72 8C 70 16 0B 83 "" +
                ""05 56 51 29 88 C9 60 D9 69 0C 6C 20 26 23 03 C8 "" +
                ""74 B0 A8 0E 03 07 FB 45 56 C7 A2 CC C4 1C 06 66 "" +
                ""A0 0D 2C 40 39 5E 86 4C 06 3D A0 4E 10 D0 60 D9 "" +
                ""C8 58 CC E8 CF B0 80 61 3A 8A 7E 0D C6 23 AC 4F "" +
                ""E0 E2 98 B6 12 2B 06 73 9D 12 E3 52 56 59 F6 08 "" +
                ""8A CC 52 66 A3 50 FF 96 2B 94 E9 DF 4C A1 FE 2D "" +
                ""3A 03 AB 9F 81 C2 F0 A3 54 BF 0F 85 EE A7 54 FF "" +
                ""40 FB 7F A0 E3 9F D2 F4 4F 71 FE 19 58 FF 2B 31 "" +
                ""7F 67 36 3B 25 4F 99 1B 4E 53 A6 5F 89 25 95 E9 "" +
                ""C4 00 C7 83 12 F3 1F 26 35 4A D3 D2 47 0E 0A C3 "" +
                ""41 8E C9 8A 52 37 DC 15 A1 D0 0D BC 4C 06 0C 2B "" +
                ""28 2C 13 28 D4 EF 43 61 5A A0 58 3F 85 71 E0 4B "" +
                ""69 9E 64 65 FE 39 C0 E5 22 30 1D 30 27 0E 74 3A "" +
                ""18 60 FD 4A CC B1 2C 13 7D 07 36 2D 2A 31 85 B2 "" +
                ""6A 0D 74 1D 1D 22 4D 99 FE 60 0A F5 9B EC 1C 58 "" +
                ""FD 67 06 56 3F 38 0D 84 3C A5 30 0E 28 D3 AF C4 "" +
                ""A4 CA FA 44 7A 0D 65 6E 60 7F 4D A1 1B 24 58 F7 "" +
                ""49 AF A5 CC 0D CC DF 19 FE 03 00 F0 B1 25 4D 42 "" +
                ""00 07 F0 E1 01 00 00 03 04 39 50 BE 98 B0 6F 57 "" +
                ""24 31 70 5D 23 2F 9F 10 66 FF 00 BD 01 00 00 01 "" +
                ""00 00 00 00 00 00 00 00 00 FF FF 20 54 1C F0 B5 "" +
                ""01 00 00 39 50 BE 98 B0 6F 57 24 31 70 5D 23 2F "" +
                ""9F 10 66 DA 03 00 00 00 00 00 00 00 00 00 00 D1 "" +
                ""07 00 00 DD 05 00 00 4A AD 6F 00 8A C5 53 00 83 "" +
                ""01 00 00 00 FE 78 9C A5 52 BF 4B 42 51 14 3E F7 "" +
                ""DC 77 7A 16 45 48 8B 3C 48 A8 16 15 0D 6C 88 D0 "" +
                ""04 C3 40 A3 32 1C 84 96 08 21 04 A1 C5 5C A2 35 "" +
                ""82 C0 35 6A AB 1C 6A 6B A8 24 5A 83 68 08 84 84 "" +
                ""96 A2 86 A0 7F C2 86 5E E7 5E F5 41 E4 10 BC 03 "" +
                ""1F E7 FB F1 CE B9 F7 F1 9E 7C 05 2E 7A 37 9B E0 "" +
                ""45 7B 10 EC 6F 96 5F 1D 74 13 55 7E B0 6C 5D 20 "" +
                ""60 C0 49 A2 9A BD 99 4F 50 83 1B 30 38 13 0E 33 "" +
                ""60 A6 A7 6B B5 37 EB F4 10 FA 14 15 A0 B6 6B 37 "" +
                ""0C 1E B3 49 73 5B A5 C2 26 48 3E C1 E0 6C 08 4A "" +
                ""30 C9 93 AA 02 B8 20 13 62 05 4E E1 E8 D7 7C C0 "" +
                ""B8 14 95 5E BE B8 A7 CF 1E BE 55 2C 56 B9 78 DF "" +
                ""08 7E 88 4C 27 FF 7B DB FF 7A DD B7 1A 17 67 34 "" +
                ""6A AE BA DA 35 D1 E7 72 BE FE EC 6E FE DA E5 7C "" +
                ""3D EC 7A DE 03 FD 50 06 0B 23 F2 0E F3 B2 A5 11 "" +
                ""91 0D 4C B5 B5 F3 BF 94 C1 8F 24 F7 D9 6F 60 94 "" +
                ""3B C9 9A F3 1C 6B E7 BB F0 2E 49 B2 25 2B C6 B1 "" +
                ""EE 69 EE 15 63 4F 71 7D CE 85 CC C8 35 B9 C3 28 "" +
                ""28 CE D0 5C 67 79 F2 4A A2 14 23 A4 38 43 73 9D "" +
                ""2D 69 2F C1 08 31 9F C5 5C 9B EB 7B C5 69 19 B3 "" +
                ""B4 81 F3 DC E3 B4 8E 8B CC B3 94 53 5A E7 41 2A "" +
                ""63 9A AA 38 C5 3D 48 BB EC 57 59 6F 2B AD 73 1F "" +
                ""1D 60 92 AE 70 8C BB 8F CE 31 C1 3C 49 27 4A EB "" +
                ""DC A4 5B 8C D1 0B 0E 73 37 E9 11 A7 99 C7 E8 41 "" +
                ""69 B0 7F 00 96 F2 A7 E8 42 00 07 F0 B4 01 00 00 "" +
                ""03 04 1A BA F9 D6 A9 B9 3A 03 08 61 E9 90 FF 7B "" +
                ""9E E6 FF 00 90 01 00 00 01 00 00 00 00 00 00 00 "" +
                ""00 00 FF FF 20 54 1C F0 88 01 00 00 1A BA F9 D6 "" +
                ""A9 B9 3A 03 08 61 E9 90 FF 7B 9E E6 12 0E 00 00 "" +
                ""00 00 00 00 00 00 00 00 D1 07 00 00 DD 05 00 00 "" +
                ""4A AD 6F 00 8A C5 53 00 56 01 00 00 00 FE 78 9C "" +
                ""E3 13 62 00 02 D6 BB EC 17 19 04 99 FE F3 30 FC "" +
                ""FF 07 E4 FE 82 62 98 0C 08 C8 31 48 FD 07 03 06 "" +
                ""46 06 2E B8 8C 21 98 75 87 FD 02 C3 42 86 6D 0C "" +
                ""2C 40 39 46 38 8B 85 C1 02 AB A8 14 C4 64 B0 EC "" +
                ""34 06 36 10 93 91 01 64 3A 58 54 87 81 83 FD 22 "" +
                ""AB 63 51 66 62 0E 03 33 D0 06 16 A0 1C 2F 43 26 "" +
                ""83 1E 50 27 08 68 B0 6C 64 2C 66 F4 67 58 C0 30 "" +
                ""1D 45 BF 06 E3 11 D6 27 70 71 4C 5B 89 15 83 B9 "" +
                ""4E 89 71 29 AB 2C 7B 04 45 66 29 B3 51 A8 7F CB "" +
                ""15 CA F4 6F A6 50 FF 16 9D 81 D5 CF 40 61 F8 51 "" +
                ""AA DF 87 42 F7 53 AA 7F A0 FD 3F D0 F1 4F 69 FA "" +
                ""A7 38 FF 0C AC FF 95 98 BF 33 9B 9D 92 A7 CC 0D "" +
                ""A7 29 D3 AF C4 92 CA 74 62 80 E3 41 89 F9 0F 93 "" +
                ""1A A5 69 E9 23 07 85 E1 20 C7 64 45 A9 1B EE 8A "" +
                ""50 E8 06 5E 26 03 86 15 14 96 09 14 EA F7 A1 30 "" +
                ""2D 50 AC 9F C2 38 F0 A5 34 4F B2 32 FF 1C E0 72 "" +
                ""11 98 0E 98 13 07 38 1D 28 31 C7 B2 4C F4 1D D8 "" +
                ""B4 A0 C4 14 CA AA 35 D0 75 64 88 34 65 FA 83 29 "" +
                ""D4 6F B2 73 60 F5 9F A1 54 FF 0E CA D3 40 C8 53 "" +
                ""0A E3 E0 09 85 6E 50 65 7D 22 BD 86 32 37 B0 BF "" +
                ""A6 D0 0D 12 AC FB A4 D7 52 E6 06 E6 EF 0C FF 01 "" +
                ""97 1D 12 C7 42 00 07 F0 C3 01 00 00 03 04 BA 4C "" +
                ""B6 23 BA 8B 27 BE C8 55 59 86 24 9F 89 D4 FF 00 "" +
                ""9F 01 00 00 01 00 00 00 00 00 00 00 00 00 FF FF "" +
                ""20 54 1C F0 97 01 00 00 BA 4C B6 23 BA 8B 27 BE "" +
                ""C8 55 59 86 24 9F 89 D4 AE 0E 00 00 00 00 00 00 "" +
                ""00 00 00 00 D1 07 00 00 DD 05 00 00 4A AD 6F 00 "" +
                ""8A C5 53 00 65 01 00 00 00 FE 78 9C E3 5B C7 00 "" +
                ""04 AC 77 D9 2F 32 08 32 FD E7 61 F8 FF 0F C8 FD "" +
                ""05 C5 30 19 10 90 63 90 FA 0F 06 0C 8C 0C 5C 70 "" +
                ""19 43 30 EB 0E FB 05 86 85 0C DB 18 58 80 72 8C "" +
                ""70 16 0B 83 05 56 51 29 88 C9 60 D9 69 0C 6C 20 "" +
                ""26 23 03 C8 74 B0 A8 0E 03 07 FB 45 56 C7 A2 CC "" +
                ""C4 1C 06 66 A0 0D 2C 40 39 5E 86 4C 06 3D A0 4E "" +
                ""10 D0 60 99 C6 B8 98 D1 9F 61 01 C3 74 14 FD 1A "" +
                ""8C 2B D8 84 B1 88 4B A5 A5 75 03 01 50 DF 59 46 "" +
                ""77 46 0F A8 3C A6 AB 88 15 83 B9 5E 89 B1 8B D5 "" +
                ""97 2D 82 22 B3 94 29 D5 BF E5 CA C0 EA DF AC 43 "" +
                ""A1 FD 14 EA 67 A0 30 FC 28 D5 EF 43 A1 FB 7D 87 "" +
                ""B8 FF 07 3A FE 07 3A FD 53 EA 7E 0A C3 4F 89 F9 "" +
                ""0E 73 EA 69 79 CA DC 70 8A 32 FD 4A 2C 5E 4C DF "" +
                ""87 7A 3C BC E0 A5 30 1E 3E 31 C5 33 AC A0 30 2F "" +
                ""52 A8 DF 87 C2 30 A4 54 3F A5 65 19 85 65 A9 12 "" +
                ""D3 2B 16 0D 8A CB 13 4A F3 E3 27 E6 09 03 9D 0E "" +
                ""06 58 BF 12 B3 13 CB C1 01 4E 8B 4A 4C 56 AC 91 "" +
                ""03 5D 37 86 48 53 A6 3F 98 42 FD 26 3B 07 56 FF "" +
                ""99 1D 14 EA A7 CC 7E 70 1A 08 79 42 61 1C 3C A5 "" +
                ""D0 0D 9C 6C C2 32 6B 29 73 03 DB 6B CA DC C0 F8 "" +
                ""97 F5 AD CC 1A CA DC C0 F4 83 32 37 B0 A4 30 CE "" +
                ""FC C7 48 99 1B FE 33 32 FC 07 00 6C CC 2E 23 33 "" +
                ""00 0B F0 12 00 00 00 BF 00 08 00 08 00 81 01 09 "" +
                ""00 00 08 C0 01 40 00 00 08 40 00 1E F1 10 00 00 "" +
                ""00 0D 00 00 08 0C 00 00 08 17 00 00 08 F7 00 00 "" +
                ""10                                              "";

        
        byte[] bytes = HexRead.readFromString(dump);
        
        EscherDump dumper = new EscherDump();
        

        dumper.dump(bytes, 0, bytes.length, System.out);

    }

    public void dump( int recordSize, byte[] data, PrintStream out ) {
        dump( data, 0, recordSize, out );
    }
}
"
poi,3,org.apache.poi.hssf.record.WriteProtectRecord,8,2,0,5,15,28,1,4,6,1.142857143,60,0.0,0,0.647058824,0.325,1,4,6.375,2,0.875,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class WriteProtectRecord extends StandardRecord {
    public final static short sid = 0x86;

    public WriteProtectRecord()
    {
    }

    
    public WriteProtectRecord(RecordInputStream in)
    {
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WRITEPROTECT]
"");
        buffer.append(""[/WRITEPROTECT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
    }

    protected int getDataSize() {
        return 0;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.poifs.storage.SmallDocumentBlock,12,1,0,8,25,24,6,2,8,0.863636364,319,1.0,0,0.0,0.214285714,0,0,25.25,3,1.25,1,"

package org.apache.poi.poifs.storage;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;


public final class SmallDocumentBlock implements BlockWritable, ListManagedBlock {
    private static final int BLOCK_SHIFT = 6;

    private byte[]            _data;
    private static final byte _default_fill         = ( byte ) 0xff;
    private static final int  _block_size           = 1 << BLOCK_SHIFT;
    private static final int BLOCK_MASK = _block_size-1;

    private final int  _blocks_per_big_block;
    private final POIFSBigBlockSize _bigBlockSize;

    private SmallDocumentBlock(final POIFSBigBlockSize bigBlockSize, final byte [] data, final int index)
    {
        this(bigBlockSize);
        System.arraycopy(data, index * _block_size, _data, 0, _block_size);
    }

    protected SmallDocumentBlock(final POIFSBigBlockSize bigBlockSize)
    {
        _bigBlockSize = bigBlockSize;
        _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        _data = new byte[ _block_size ];
    }
    
    private static int getBlocksPerBigBlock(final POIFSBigBlockSize bigBlockSize)
    {
       return bigBlockSize.getBigBlockSize() / _block_size;
    }

    
    public static SmallDocumentBlock [] convert(POIFSBigBlockSize bigBlockSize,
                                                byte [] array,
                                                int size)
    {
        SmallDocumentBlock[] rval   =
            new SmallDocumentBlock[ (size + _block_size - 1) / _block_size ];
        int                  offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new SmallDocumentBlock(bigBlockSize);
            if (offset < array.length)
            {
                int length = Math.min(_block_size, array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != _block_size)
                {
                    Arrays.fill(rval[ k ]._data, length, _block_size,
                                _default_fill);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_fill);
            }
            offset += _block_size;
        }
        return rval;
    }

    
    public static int fill(POIFSBigBlockSize bigBlockSize, List<SmallDocumentBlock> blocks)
    {
        int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        
        int count           = blocks.size();
        int big_block_count = (count + _blocks_per_big_block - 1)
                              / _blocks_per_big_block;
        int full_count      = big_block_count * _blocks_per_big_block;

        for (; count < full_count; count++)
        {
            blocks.add(makeEmptySmallDocumentBlock(bigBlockSize));
        }
        return big_block_count;
    }

    
    public static SmallDocumentBlock [] convert(POIFSBigBlockSize bigBlockSize,
                                                BlockWritable [] store,
                                                int size)
        throws IOException, ArrayIndexOutOfBoundsException
    {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();

        for (int j = 0; j < store.length; j++)
        {
            store[ j ].writeBlocks(stream);
        }
        byte[]               data = stream.toByteArray();
        SmallDocumentBlock[] rval =
            new SmallDocumentBlock[ convertToBlockCount(size) ];

        for (int index = 0; index < rval.length; index++)
        {
            rval[ index ] = new SmallDocumentBlock(bigBlockSize, data, index);
        }
        return rval;
    }

    
    public static List<SmallDocumentBlock> extract(POIFSBigBlockSize bigBlockSize, ListManagedBlock [] blocks)
        throws IOException
    {
        int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        
        List<SmallDocumentBlock> sdbs = new ArrayList<SmallDocumentBlock>();

        for (int j = 0; j < blocks.length; j++)
        {
            byte[] data = blocks[ j ].getData();

            for (int k = 0; k < _blocks_per_big_block; k++)
            {
                sdbs.add(new SmallDocumentBlock(bigBlockSize, data, k));
            }
        }
        return sdbs;
    }

    public static DataInputBlock getDataInputBlock(SmallDocumentBlock[] blocks, int offset) {
        int firstBlockIndex = offset >> BLOCK_SHIFT;
        int firstBlockOffset= offset & BLOCK_MASK;
        return new DataInputBlock(blocks[firstBlockIndex]._data, firstBlockOffset);
    }

    
    public static int calcSize(int size)
    {
        return size * _block_size;
    }
    
    protected int getSmallBlocksPerBigBlock()
    {
        return _blocks_per_big_block;
    }

    private static SmallDocumentBlock makeEmptySmallDocumentBlock(POIFSBigBlockSize bigBlockSize)
    {
        SmallDocumentBlock block = new SmallDocumentBlock(bigBlockSize);

        Arrays.fill(block._data, _default_fill);
        return block;
    }

    private static int convertToBlockCount(int size)
    {
        return (size + _block_size - 1) / _block_size;
    }

    
    public void writeBlocks(OutputStream stream)
        throws IOException
    {
        stream.write(_data);
    }

    
    public byte [] getData() {
        return _data;
    }
    
    public POIFSBigBlockSize getBigBlockSize() {
       return _bigBlockSize;
    }
}
"
poi,3,org.apache.poi.hssf.record.AbstractEscherHolderRecord,22,2,4,15,54,69,6,9,17,0.698412698,434,1.0,0,0.366666667,0.238095238,1,4,18.59090909,4,1.3636,6,"

package org.apache.poi.hssf.record;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.ddf.DefaultEscherRecordFactory;
import org.apache.poi.ddf.EscherContainerRecord;
import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.ddf.EscherRecordFactory;
import org.apache.poi.ddf.NullEscherSerializationListener;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.hssf.util.LazilyConcatenatedByteArray;


public abstract class AbstractEscherHolderRecord extends Record {
    private static boolean DESERIALISE;
    static {
    try {
            DESERIALISE = (System.getProperty(""poi.deserialize.escher"") != null);
        } catch (SecurityException e) {
            DESERIALISE = false;
        }
    }

    private List<EscherRecord> escherRecords;
    private LazilyConcatenatedByteArray rawDataContainer = new LazilyConcatenatedByteArray();

    public AbstractEscherHolderRecord()
    {
        escherRecords = new ArrayList<EscherRecord>();
    }

    public AbstractEscherHolderRecord(RecordInputStream in)
    {
        escherRecords = new ArrayList<EscherRecord>();
        if (! DESERIALISE ) {
            rawDataContainer.concatenate(in.readRemainder());
        } else {
            byte[] data = in.readAllContinuedRemainder();
            convertToEscherRecords( 0, data.length, data );
        }
    }

    protected void convertRawBytesToEscherRecords() {
        if (! DESERIALISE ) {
            byte[] rawData = getRawData();
        	convertToEscherRecords(0, rawData.length, rawData);
        }
    }
    private void convertToEscherRecords( int offset, int size, byte[] data )
    {
         escherRecords.clear();
        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory();
        int pos = offset;
        while ( pos < offset + size )
        {
            EscherRecord r = recordFactory.createRecord(data, pos);
            int bytesRead = r.fillFields(data, pos, recordFactory );
            escherRecords.add(r);
            pos += bytesRead;
        }
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        final String nl = System.getProperty(""line.separator"");
        buffer.append('[' + getRecordName() + ']' + nl);
        if (escherRecords.size() == 0)
            buffer.append(""No Escher Records Decoded"" + nl);
        for ( Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext(); )
        {
            EscherRecord r = iterator.next();
            buffer.append(r.toString());
        }
        buffer.append(""[/"" + getRecordName() + ']' + nl);

        return buffer.toString();
    }

    protected abstract String getRecordName();

    public int serialize(int offset, byte[] data)
    {
        LittleEndian.putShort( data, 0 + offset, getSid() );
        LittleEndian.putShort( data, 2 + offset, (short) ( getRecordSize() - 4 ) );
        byte[] rawData = getRawData();
        if ( escherRecords.size() == 0 && rawData != null )
        {
            LittleEndian.putShort(data, 0 + offset, getSid());
            LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));
            System.arraycopy( rawData, 0, data, 4 + offset, rawData.length);
            return rawData.length + 4;
        }
        LittleEndian.putShort(data, 0 + offset, getSid());
        LittleEndian.putShort(data, 2 + offset, (short)(getRecordSize() - 4));

        int pos = offset + 4;
        for ( Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext(); )
        {
            EscherRecord r = iterator.next();
            pos += r.serialize( pos, data, new NullEscherSerializationListener() );
        }
        return getRecordSize();
    }

    public int getRecordSize() {
        byte[] rawData = getRawData();
        if (escherRecords.size() == 0 && rawData != null) {
            
            return rawData.length;
        }
        int size = 0;
        for ( Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext(); )
        {
            EscherRecord r = iterator.next();
            size += r.getRecordSize();
        }
        return size;
    }



    public abstract short getSid();

    public Object clone()
    {
    	return cloneViaReserialise();
    }

    public void addEscherRecord(int index, EscherRecord element)
    {
        escherRecords.add( index, element );
    }

    public boolean addEscherRecord(EscherRecord element)
    {
        return escherRecords.add( element );
    }

    public List<EscherRecord> getEscherRecords()
    {
        return escherRecords;
    }

    public void clearEscherRecords()
    {
        escherRecords.clear();
    }

    
    public EscherContainerRecord getEscherContainer() {
    	for(Iterator<EscherRecord> it = escherRecords.iterator(); it.hasNext();) {
    		EscherRecord er = it.next();
    		if(er instanceof EscherContainerRecord) {
    			return (EscherContainerRecord)er;
    		}
    	}
    	return null;
    }

    
    public EscherRecord findFirstWithId(short id) {
    	return findFirstWithId(id, getEscherRecords());
    }
    private EscherRecord findFirstWithId(short id, List<EscherRecord> records) {
    	
    	for(Iterator<EscherRecord> it = records.iterator(); it.hasNext();) {
    		EscherRecord r = it.next();
    		if(r.getRecordId() == id) {
    			return r;
    		}
    	}

    	
    	for(Iterator<EscherRecord> it = records.iterator(); it.hasNext();) {
    		EscherRecord r = it.next();
    		if(r.isContainerRecord()) {
    			EscherRecord found = findFirstWithId(id, r.getChildRecords());
    			if(found != null) {
    				return found;
    			}
    		}
    	}

    	
    	return null;
    }


    public EscherRecord getEscherRecord(int index)
    {
        return escherRecords.get(index);
    }

    
    public void join( AbstractEscherHolderRecord record )
    {
        rawDataContainer.concatenate(record.getRawData());
    }

    public void processContinueRecord( byte[] record )
    {
        rawDataContainer.concatenate(record);
    }

    public byte[] getRawData()
    {
        return rawDataContainer.toArray();
    }

    public void setRawData( byte[] rawData )
    {
        rawDataContainer.clear();
        rawDataContainer.concatenate(rawData);
    }

    
    public void decode()
    {
        if (null == escherRecords || 0 == escherRecords.size()){
            byte[] rawData = getRawData();
            convertToEscherRecords(0, rawData.length, rawData );
        }
    }
}
"
poi,3,org.apache.poi.ddf.EscherBitmapBlip,11,3,0,9,33,0,3,6,11,0.916666667,241,0.5,0,0.833333333,0.303030303,1,4,20.36363636,1,0.9091,2,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;

import java.io.ByteArrayOutputStream;


public class EscherBitmapBlip extends EscherBlipRecord {
    public static final short RECORD_ID_JPEG = (short) 0xF018 + 5;
    public static final short RECORD_ID_PNG = (short) 0xF018 + 6;
    public static final short RECORD_ID_DIB = (short) 0xF018 + 7;

    private static final int HEADER_SIZE = 8;

    private byte[] field_1_UID;
    private byte field_2_marker = (byte) 0xFF;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesAfterHeader = readHeader( data, offset );
        int pos = offset + HEADER_SIZE;

        field_1_UID = new byte[16];
        System.arraycopy( data, pos, field_1_UID, 0, 16 ); pos += 16;
        field_2_marker = data[pos]; pos++;

        field_pictureData = new byte[bytesAfterHeader - 17];
        System.arraycopy( data, pos, field_pictureData, 0, field_pictureData.length );

        return bytesAfterHeader + HEADER_SIZE;
    }

     public int serialize( int offset, byte[] data, EscherSerializationListener listener )
     {
         listener.beforeRecordSerialize(offset, getRecordId(), this);

         LittleEndian.putShort( data, offset, getOptions() );
         LittleEndian.putShort( data, offset + 2, getRecordId() );
         LittleEndian.putInt( data, offset + 4, getRecordSize() - HEADER_SIZE );
         int pos = offset + HEADER_SIZE;

         System.arraycopy( field_1_UID, 0, data, pos, 16 );
         data[pos + 16] = field_2_marker;
         System.arraycopy( field_pictureData, 0, data, pos + 17, field_pictureData.length );

         listener.afterRecordSerialize(offset + getRecordSize(), getRecordId(), getRecordSize(), this);
         return HEADER_SIZE + 16 + 1 + field_pictureData.length;
     }

     public int getRecordSize()
     {
         return 8 + 16 + 1 + field_pictureData.length;
     }

    public byte[] getUID()
    {
        return field_1_UID;
    }

    public void setUID( byte[] field_1_UID )
    {
        this.field_1_UID = field_1_UID;
    }

    public byte getMarker()
    {
        return field_2_marker;
    }

    public void setMarker( byte field_2_marker )
    {
        this.field_2_marker = field_2_marker;
    }

    public String toString()
    {
        String nl = System.getProperty( ""line.separator"" );

        String extraData;
        ByteArrayOutputStream b = new ByteArrayOutputStream();
        try
        {
            HexDump.dump( this.field_pictureData, 0, b, 0 );
            extraData = b.toString();
        }
        catch ( Exception e )
        {
            extraData = e.toString();
        }
        return getClass().getName() + "":"" + nl +
                ""  RecordId: 0x"" + HexDump.toHex( getRecordId() ) + nl +
                ""  Version: 0x"" + HexDump.toHex( getVersion() ) + nl +
                ""  Instance: 0x"" + HexDump.toHex( getInstance() ) + nl +
                ""  UID: 0x"" + HexDump.toHex( field_1_UID ) + nl +
                ""  Marker: 0x"" + HexDump.toHex( field_2_marker ) + nl +
                ""  Extra Data:"" + nl + extraData;
    }

    @Override
    public String toXml(String tab) {
        String extraData;
        ByteArrayOutputStream b = new ByteArrayOutputStream();
        try
        {
            HexDump.dump( this.field_pictureData, 0, b, 0 );
            extraData = b.toString();
        }
        catch ( Exception e )
        {
            extraData = e.toString();
        }
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<UID>0x"").append(HexDump.toHex(field_1_UID)).append(""</UID>
"")
                .append(tab).append(""	"").append(""<Marker>0x"").append(HexDump.toHex(field_2_marker)).append(""</Marker>
"")
                .append(tab).append(""	"").append(""<ExtraData>"").append(extraData).append(""</ExtraData>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.hssf.record.ExternSheetRecord,13,2,0,7,31,52,2,5,11,0.722222222,206,0.666666667,0,0.5,0.269230769,1,4,14.61538462,2,1.1538,2,"

package org.apache.poi.hssf.record;

import java.util.ArrayList;
import java.util.List;

import org.apache.poi.util.LittleEndianOutput;


public class ExternSheetRecord extends StandardRecord {

    public final static short sid = 0x0017;
	private List<RefSubRecord> _list;
	
	private static final class RefSubRecord {
		public static final int ENCODED_SIZE = 6;

		
		private int _extBookIndex;
		private int _firstSheetIndex; 
		private int _lastSheetIndex;  
		
		public void adjustIndex(int offset) {
			_firstSheetIndex += offset;
			_lastSheetIndex += offset;
		}
		
		
		public RefSubRecord(int extBookIndex, int firstSheetIndex, int lastSheetIndex) {
			_extBookIndex = extBookIndex;
			_firstSheetIndex = firstSheetIndex;
			_lastSheetIndex = lastSheetIndex;
		}
		
		
		public RefSubRecord(RecordInputStream in) {
			this(in.readShort(), in.readShort(), in.readShort());
		}
		public int getExtBookIndex(){
			return _extBookIndex;
		}
		public int getFirstSheetIndex(){
			return _firstSheetIndex;
		}
		public int getLastSheetIndex(){
			return _lastSheetIndex;
		}
		
		@Override
		public String toString() {
			StringBuffer buffer = new StringBuffer();
			buffer.append(""extBook="").append(_extBookIndex);
			buffer.append("" firstSheet="").append(_firstSheetIndex);
			buffer.append("" lastSheet="").append(_lastSheetIndex);
			return buffer.toString();
		}
		
		public void serialize(LittleEndianOutput out) {
			out.writeShort(_extBookIndex);
			out.writeShort(_firstSheetIndex);
			out.writeShort(_lastSheetIndex);
		}
	}	
	
	
	
	public ExternSheetRecord() {
		_list = new ArrayList<RefSubRecord>();
	}

	public ExternSheetRecord(RecordInputStream in) {
		_list = new ArrayList<RefSubRecord>();
		
		int nItems  = in.readShort();
		
		for (int i = 0 ; i < nItems ; ++i) {
			RefSubRecord rec = new RefSubRecord(in);
			_list.add(rec);
		}
	}
	

	
	public int getNumOfRefs() {
		return _list.size();
	}
	
	
	public void addREFRecord(RefSubRecord rec) {
		_list.add(rec);
	}
	
	
	public int getNumOfREFRecords() {
		return _list.size();
	}
	
	
	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();
		int nItems = _list.size();
		sb.append(""[EXTERNSHEET]
"");
		sb.append(""   numOfRefs     = "").append(nItems).append(""
"");
		for (int i=0; i < nItems; i++) {
			sb.append(""refrec         #"").append(i).append("": "");
			sb.append(getRef(i).toString());
			sb.append('
');
		}
		sb.append(""[/EXTERNSHEET]
"");
		
		
		return sb.toString();
	}
	
	@Override
	protected int getDataSize() {
		return 2 + _list.size() * RefSubRecord.ENCODED_SIZE;
	}
	
	@Override
	public void serialize(LittleEndianOutput out) {
		int nItems = _list.size();

		out.writeShort(nItems);
		
		for (int i = 0; i < nItems; i++) {
			getRef(i).serialize(out);
		}
	}

	private RefSubRecord getRef(int i) {
		return _list.get(i);
	}
	
    
    @Deprecated
    public void adjustIndex(int extRefIndex, int offset) {
        getRef(extRefIndex).adjustIndex(offset);
    }
	
	public void removeSheet(int sheetIdx) {
        int nItems = _list.size();
        int toRemove = -1;
        for (int i = 0; i < nItems; i++) {
            RefSubRecord refSubRecord = _list.get(i);
            if(refSubRecord.getFirstSheetIndex() == sheetIdx && 
                    refSubRecord.getLastSheetIndex() == sheetIdx) {
                toRemove = i;
            } else if (refSubRecord.getFirstSheetIndex() > sheetIdx && 
                    refSubRecord.getLastSheetIndex() > sheetIdx) {
                _list.set(i, new RefSubRecord(refSubRecord.getExtBookIndex(), refSubRecord.getFirstSheetIndex()-1, refSubRecord.getLastSheetIndex()-1));
            }
        }
        
        
        if(toRemove != -1) {
            _list.remove(toRemove);
        }
	}
	
	
	@Override
	public short getSid() {
		return sid;
	}

    
    public int getExtbookIndexFromRefIndex(int refIndex) {
        RefSubRecord refRec = getRef(refIndex);
        return refRec.getExtBookIndex();
    }

	
	public int findRefIndexFromExtBookIndex(int extBookIndex) {
		int nItems = _list.size();
		for (int i = 0; i < nItems; i++) {
			if (getRef(i).getExtBookIndex() == extBookIndex) {
				return i;
			}
		}
		return -1;
	}

    
	public int getFirstSheetIndexFromRefIndex(int extRefIndex) {
		return getRef(extRefIndex).getFirstSheetIndex();
	}

    
    public int getLastSheetIndexFromRefIndex(int extRefIndex) {
        return getRef(extRefIndex).getLastSheetIndex();
    }

	
	public int addRef(int extBookIndex, int firstSheetIndex, int lastSheetIndex) {
		_list.add(new RefSubRecord(extBookIndex, firstSheetIndex, lastSheetIndex));
		return _list.size() - 1;
	}

	public int getRefIxForSheet(int externalBookIndex, int firstSheetIndex, int lastSheetIndex) {
		int nItems = _list.size();
		for (int i = 0; i < nItems; i++) {
			RefSubRecord ref = getRef(i);
			if (ref.getExtBookIndex() != externalBookIndex) {
				continue;
			}
			if (ref.getFirstSheetIndex() == firstSheetIndex && 
			        ref.getLastSheetIndex() == lastSheetIndex) {
				return i;
			}
		}
		return -1;
	}

	public static ExternSheetRecord combine(ExternSheetRecord[] esrs) {
		ExternSheetRecord result = new ExternSheetRecord();
		for (int i = 0; i < esrs.length; i++) {
			ExternSheetRecord esr = esrs[i];
			int nRefs = esr.getNumOfREFRecords();
			for (int j=0; j<nRefs; j++) {
				result.addREFRecord(esr.getRef(j));
			}
		}
		return result;
	}
}
"
poi,3,org.apache.poi.util.HexDump,16,1,0,71,49,102,71,0,11,0.355555556,794,0.666666667,0,0.0,0.18,0,0,48.4375,10,1.875,2,"

package org.apache.poi.util;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.text.DecimalFormat;


public class HexDump {
    public static final String EOL = System.getProperty(""line.separator"");
    private static final char _hexcodes[] = ""0123456789ABCDEF"".toCharArray();
    private static final int _shifts[]   =
    {
        60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0
    };

    private HexDump() {
        
    }

    
    public static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index, final int length)
            throws IOException, ArrayIndexOutOfBoundsException,
                    IllegalArgumentException
    {
        if (data.length == 0)
        {
            stream.write( (""No Data"" + EOL).getBytes() );
            stream.flush();
            return;
        }
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                ""illegal index: "" + index + "" into array of length ""
                + data.length);
        }
        if (stream == null)
        {
            throw new IllegalArgumentException(""cannot write to nullstream"");
        }

        long         display_offset = offset + index;
        StringBuffer buffer         = new StringBuffer(74);


        int data_length = Math.min(data.length,index+length);
        for (int j = index; j < data_length; j += 16)
        {
            int chars_read = data_length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(
                        dump(display_offset)
                         ).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append(""  "");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            stream.write(buffer.toString().getBytes());
            stream.flush();
            buffer.setLength(0);
            display_offset += chars_read;
        }

    }

    

    public synchronized static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index)
        throws IOException, ArrayIndexOutOfBoundsException,
                IllegalArgumentException
    {
        dump(data, offset, stream, index, data.length-index);
    }

    

    public static String dump(final byte [] data, final long offset,
                            final int index) {
        StringBuffer buffer;
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                ""illegal index: "" + index + "" into array of length ""
                + data.length);
        }
        long         display_offset = offset + index;
        buffer         = new StringBuffer(74);

        for (int j = index; j < data.length; j += 16)
        {
            int chars_read = data.length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(dump(display_offset)).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append(""  "");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            display_offset += chars_read;
        }
        return buffer.toString();
    }


    private static String dump(final long value)
    {
        StringBuffer buf = new StringBuffer();
        buf.setLength(0);
        for (int j = 0; j < 8; j++)
        {
            buf.append( _hexcodes[ (( int ) (value >> _shifts[ j + _shifts.length - 8 ])) & 15 ]);
        }
        return buf.toString();
    }

    private static String dump(final byte value)
    {
        StringBuffer buf = new StringBuffer();
        buf.setLength(0);
        for (int j = 0; j < 2; j++)
        {
            buf.append(_hexcodes[ (value >> _shifts[ j + 6 ]) & 15 ]);
        }
        return buf.toString();
    }

    
    public static String toHex(final byte[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        if (value != null && value.length > 0)
        {
            for(int x = 0; x < value.length; x++)
            {
                if (x>0) {
                    retVal.append("", "");
                }
                retVal.append(toHex(value[x]));
            }
        }
        retVal.append(']');
        return retVal.toString();
    }

    
    public static String toHex(final short[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        for(int x = 0; x < value.length; x++)
        {
            if (x>0) {
                retVal.append("", "");
            }
            retVal.append(toHex(value[x]));
        }
        retVal.append(']');
        return retVal.toString();
    }

    
    public static String toHex(final byte[] value, final int bytesPerLine)
    {
        final int digits =
            (int) Math.round(Math.log(value.length) / Math.log(10) + 0.5);
        final StringBuffer formatString = new StringBuffer();
        for (int i = 0; i < digits; i++)
            formatString.append('0');
        formatString.append("": "");
        final DecimalFormat format = new DecimalFormat(formatString.toString());
        StringBuffer retVal = new StringBuffer();
        retVal.append(format.format(0));
        int i = -1;
        for(int x = 0; x < value.length; x++)
        {
            if (++i == bytesPerLine)
            {
                retVal.append('
');
                retVal.append(format.format(x));
                i = 0;
            } else if (x>0) {
                retVal.append("", "");
            }
            retVal.append(toHex(value[x]));
        }
        return retVal.toString();
    }

    
    public static String toHex(final short value)
    {
        return toHex(value, 4);
    }

    
    public static String toHex(final byte value)
    {
        return toHex(value, 2);
    }

    
    public static String toHex(final int value)
    {
        return toHex(value, 8);
    }

    
    public static String toHex(final long value)
    {
        return toHex(value, 16);
    }


    private static String toHex(final long value, final int digits)
    {
        StringBuffer result = new StringBuffer(digits);
        for (int j = 0; j < digits; j++)
        {
            result.append( _hexcodes[ (int) ((value >> _shifts[ j + (16 - digits) ]) & 15)]);
        }
        return result.toString();
    }

    
    public static void dump( InputStream in, PrintStream out, int start, int bytesToDump ) throws IOException
    {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        if (bytesToDump == -1)
        {
            int c = in.read();
            while (c != -1)
            {
                buf.write(c);
                c = in.read();
            }
        }
        else
        {
            int bytesRemaining = bytesToDump;
            while (bytesRemaining-- > 0)
            {
                int c = in.read();
                if (c == -1) {
                    break;
                }
                buf.write(c);
            }
        }

        byte[] data = buf.toByteArray();
        dump(data, 0, out, start, data.length);
    }
    
    private static char[] toHexChars(long pValue, int nBytes) {
        int charPos = 2 + nBytes*2;
        
        
        char[] result = new char[charPos];

        long value = pValue;
        do {
            result[--charPos] = _hexcodes[(int) (value & 0x0F)];
            value >>>= 4;
        } while (charPos > 1);

        
        result[0] = '0';
        result[1] = 'x';
        return result;
    }
    
    public static char[] longToHex(long value) {
        return toHexChars(value, 8);
    }
    
    public static char[] intToHex(int value) {
        return toHexChars(value, 4);
    }
    
    public static char[] shortToHex(int value) {
        return toHexChars(value, 2);
    }
    
    public static char[] byteToHex(int value) {
        return toHexChars(value, 1);
    }

    public static void main(String[] args) throws Exception {
        File file = new File(args[0]);
        InputStream in = new BufferedInputStream(new FileInputStream(file));
        byte[] b = new byte[(int)file.length()];
        in.read(b);
        System.out.println(HexDump.dump(b, 0, 0));
        in.close();
    }
}
"
poi,3,org.apache.poi.hssf.record.DrawingRecord,10,2,0,7,16,15,3,4,8,0.777777778,125,0.5,0,0.578947368,0.34,1,3,11.3,3,1.2,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;

public final class DrawingRecord extends StandardRecord {
    public static final short sid = 0x00EC;

    private static final byte[] EMPTY_BYTE_ARRAY = {};

    private byte[] recordData;
    private byte[] contd;

    public DrawingRecord() {
        recordData = EMPTY_BYTE_ARRAY;
    }

    public DrawingRecord(RecordInputStream in) {
        recordData = in.readRemainder();
    }

    @Deprecated
    public void processContinueRecord(byte[] record) {
        
        contd = record;
    }

    public void serialize(LittleEndianOutput out) {
        out.write(recordData);
    }

    protected int getDataSize() {
        return recordData.length;
    }

    public short getSid() {
        return sid;
    }

    @Deprecated
    public byte[] getData() {
        return recordData;
    }

    public byte[] getRecordData(){
        return recordData;
    }

    public void setData(byte[] thedata) {
        if (thedata == null) {
            throw new IllegalArgumentException(""data must not be null"");
        }
        recordData = thedata;
    }

    
    public Object clone() {
        DrawingRecord rec = new DrawingRecord();
        rec.recordData = recordData.clone();
        if (contd != null) {
            
            rec.contd = contd.clone();
        }

        return rec;
    }

    @Override
    public String toString() {
        return ""DrawingRecord[""+recordData.length+""]"";
    }
}
"
poi,3,org.apache.poi.hssf.record.MulBlankRecord,13,2,0,6,24,64,3,3,10,0.85,172,0.8,0,0.5,0.307692308,1,3,11.84615385,2,1.0769,4,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class MulBlankRecord extends StandardRecord {
	public final static short sid = 0x00BE;

	private final int _row;
	private final int _firstCol;
	private final short[] _xfs;
	private final int _lastCol;

	public MulBlankRecord(int row, int firstCol, short[] xfs) {
		_row = row;
		_firstCol = firstCol;
		_xfs = xfs;
		_lastCol = firstCol + xfs.length - 1;
	}

	
	public int getRow() {
		return _row;
	}

	
	public int getFirstColumn() {
		return _firstCol;
	}
	
	
	public int getLastColumn() {
		return _lastCol;
	}

	
	public int getNumColumns() {
		return _lastCol - _firstCol + 1;
	}

	
	public short getXFAt(int coffset) {
		return _xfs[coffset];
	}

	
	public MulBlankRecord(RecordInputStream in) {
		_row	   = in.readUShort();
		_firstCol = in.readShort();
		_xfs	   = parseXFs(in);
		_lastCol  = in.readShort();
	}

	private static short [] parseXFs(RecordInputStream in) {
		short[] retval = new short[(in.remaining() - 2) / 2];

		for (int idx = 0; idx < retval.length;idx++) {
		  retval[idx] = in.readShort();
		}
		return retval;
	}

	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[MULBLANK]
"");
		buffer.append(""row  = "").append(Integer.toHexString(getRow())).append(""
"");
		buffer.append(""firstcol  = "").append(Integer.toHexString(getFirstColumn())).append(""
"");
		buffer.append("" lastcol  = "").append(Integer.toHexString(_lastCol)).append(""
"");
		for (int k = 0; k < getNumColumns(); k++) {
			buffer.append(""xf"").append(k).append(""		= "").append(
					Integer.toHexString(getXFAt(k))).append(""
"");
		}
		buffer.append(""[/MULBLANK]
"");
		return buffer.toString();
	}

	public short getSid() {
		return sid;
	}

	public void serialize(LittleEndianOutput out) {
		out.writeShort(_row);
		out.writeShort(_firstCol);
		int nItems = _xfs.length;
		for (int i = 0; i < nItems; i++) {
			out.writeShort(_xfs[i]);
		}
		out.writeShort(_lastCol);
	}

	protected int getDataSize() {
		
		return 6 + _xfs.length * 2;
	}

	@Override
	public Object clone() {
		
		return this;
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.StaticFontMetrics,3,1,0,2,24,1,1,1,1,0.75,121,1.0,0,0.0,0.5,0,0,38.66666667,8,2.6667,2,"

package org.apache.poi.hssf.usermodel;

import java.awt.Font;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;


final class StaticFontMetrics {
	
	private static Properties fontMetricsProps;
	
	private static Map<String, FontDetails> fontDetailsMap = new HashMap<String, FontDetails>();

	
	public static FontDetails getFontDetails(Font font) {
		
		
		if (fontMetricsProps == null) {
			InputStream metricsIn = null;
			try {
				fontMetricsProps = new Properties();

				
				
				String propFileName = null;
				try {
					propFileName = System.getProperty(""font.metrics.filename"");
				} catch (SecurityException e) {
				}

				if (propFileName != null) {
					File file = new File(propFileName);
					if (!file.exists())
						throw new FileNotFoundException(
								""font_metrics.properties not found at path ""
										+ file.getAbsolutePath());
					metricsIn = new FileInputStream(file);
				} else {
					
					metricsIn = FontDetails.class.getResourceAsStream(""/font_metrics.properties"");
					if (metricsIn == null)
						throw new FileNotFoundException(
								""font_metrics.properties not found in classpath"");
				}
				fontMetricsProps.load(metricsIn);
			} catch (IOException e) {
				throw new RuntimeException(""Could not load font metrics: "" + e.getMessage());
			} finally {
				if (metricsIn != null) {
					try {
						metricsIn.close();
					} catch (IOException ignore) {
					}
				}
			}
		}

		
		String fontName = font.getName();

		
		
		
		String fontStyle = """";
		if (font.isPlain())
			fontStyle += ""plain"";
		if (font.isBold())
			fontStyle += ""bold"";
		if (font.isItalic())
			fontStyle += ""italic"";

		
		
		if (fontMetricsProps.get(FontDetails.buildFontHeightProperty(fontName)) == null
				&& fontMetricsProps.get(FontDetails.buildFontHeightProperty(fontName + "".""
						+ fontStyle)) != null) {
			
			fontName += ""."" + fontStyle;
		}

		
		if (fontDetailsMap.get(fontName) == null) {
			FontDetails fontDetails = FontDetails.create(fontName, fontMetricsProps);
			fontDetailsMap.put(fontName, fontDetails);
			return fontDetails;
		}
		return fontDetailsMap.get(fontName);
	}
}
"
poi,3,org.apache.poi.ddf.EscherClientAnchorRecord,27,2,0,8,47,149,3,5,27,0.860946746,538,0.846153846,0,0.422222222,0.265432099,1,5,18.44444444,6,1.2593,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;

import java.io.ByteArrayOutputStream;


public class EscherClientAnchorRecord
        extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF010;
    public static final String RECORD_DESCRIPTION = ""MsofbtClientAnchor"";

    
    private short field_1_flag;
    private short field_2_col1;
    private short field_3_dx1;
    private short field_4_row1;
    private short field_5_dy1;
    private short field_6_col2;
    private short field_7_dx2;
    private short field_8_row2;
    private short field_9_dy2;
    private byte[] remainingData;
    private boolean shortRecord = false;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;

        
        if (bytesRemaining == 4) 
        {
            
        }
        else
        {
            field_1_flag   =  LittleEndian.getShort( data, pos + size );     size += 2;
            field_2_col1   =  LittleEndian.getShort( data, pos + size );     size += 2;
            field_3_dx1    =  LittleEndian.getShort( data, pos + size );     size += 2;
            field_4_row1   =  LittleEndian.getShort( data, pos + size );     size += 2;
            if(bytesRemaining >= 18) {
                field_5_dy1    =  LittleEndian.getShort( data, pos + size );     size += 2;
                field_6_col2   =  LittleEndian.getShort( data, pos + size );     size += 2;
                field_7_dx2    =  LittleEndian.getShort( data, pos + size );     size += 2;
                field_8_row2   =  LittleEndian.getShort( data, pos + size );     size += 2;
                field_9_dy2    =  LittleEndian.getShort( data, pos + size );     size += 2;
                shortRecord = false;
            } else {
                shortRecord = true;
            }
        }
        bytesRemaining -= size;
        remainingData  =  new byte[bytesRemaining];
        System.arraycopy( data, pos + size, remainingData, 0, bytesRemaining );
        return 8 + size + bytesRemaining;
    }

    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        if (remainingData == null) remainingData = new byte[0];
        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );
        int remainingBytes = remainingData.length + (shortRecord ? 8 : 18);
        LittleEndian.putInt( data, offset + 4, remainingBytes );
        LittleEndian.putShort( data, offset + 8, field_1_flag );
        LittleEndian.putShort( data, offset + 10, field_2_col1 );
        LittleEndian.putShort( data, offset + 12, field_3_dx1 );
        LittleEndian.putShort( data, offset + 14, field_4_row1 );
        if(!shortRecord) {
            LittleEndian.putShort( data, offset + 16, field_5_dy1 );
            LittleEndian.putShort( data, offset + 18, field_6_col2 );
            LittleEndian.putShort( data, offset + 20, field_7_dx2 );
            LittleEndian.putShort( data, offset + 22, field_8_row2 );
            LittleEndian.putShort( data, offset + 24, field_9_dy2 );
        }
        System.arraycopy( remainingData, 0, data, offset + (shortRecord ? 16 : 26), remainingData.length );
        int pos = offset + 8 + (shortRecord ? 8 : 18) + remainingData.length;

        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        return pos - offset;
    }

    public int getRecordSize()
    {
        return 8 + (shortRecord ? 8 : 18) + (remainingData == null ? 0 : remainingData.length);
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""ClientAnchor"";
    }

    
    public String toString()
    {
        String nl = System.getProperty(""line.separator"");

        String extraData;
        ByteArrayOutputStream b = new ByteArrayOutputStream();
        try
        {
            HexDump.dump(this.remainingData, 0, b, 0);
            extraData = b.toString();
        }
        catch ( Exception e )
        {
            extraData = ""error
"";
        }
        return getClass().getName() + "":"" + nl +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + nl +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + nl +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + nl +
                ""  Flag: "" + field_1_flag + nl +
                ""  Col1: "" + field_2_col1 + nl +
                ""  DX1: "" + field_3_dx1 + nl +
                ""  Row1: "" + field_4_row1 + nl +
                ""  DY1: "" + field_5_dy1 + nl +
                ""  Col2: "" + field_6_col2 + nl +
                ""  DX2: "" + field_7_dx2 + nl +
                ""  Row2: "" + field_8_row2 + nl +
                ""  DY2: "" + field_9_dy2 + nl +
                ""  Extra Data:"" + nl + extraData;

    }

    @Override
    public String toXml(String tab) {
        String extraData;
        ByteArrayOutputStream b = new ByteArrayOutputStream();
        try
        {
            HexDump.dump(this.remainingData, 0, b, 0);
            extraData = b.toString();
        }
        catch ( Exception e )
        {
            extraData = ""error
"";
        }
        if (extraData.contains(""No Data"")){
            extraData = ""No Data"";
        }
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<Flag>"").append(field_1_flag).append(""</Flag>
"")
                .append(tab).append(""	"").append(""<Col1>"").append(field_2_col1).append(""</Col1>
"")
                .append(tab).append(""	"").append(""<DX1>"").append(field_3_dx1).append(""</DX1>
"")
                .append(tab).append(""	"").append(""<Row1>"").append(field_4_row1).append(""</Row1>
"")
                .append(tab).append(""	"").append(""<DY1>"").append(field_5_dy1).append(""</DY1>
"")
                .append(tab).append(""	"").append(""<Col2>"").append(field_6_col2).append(""</Col2>
"")
                .append(tab).append(""	"").append(""<DX2>"").append(field_7_dx2).append(""</DX2>
"")
                .append(tab).append(""	"").append(""<Row2>"").append(field_8_row2).append(""</Row2>
"")
                .append(tab).append(""	"").append(""<DY2>"").append(field_9_dy2).append(""</DY2>
"")
                .append(tab).append(""	"").append(""<ExtraData>"").append(extraData).append(""</ExtraData>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public short getFlag()
    {
        return field_1_flag;
    }

    
    public void setFlag( short field_1_flag )
    {
        this.field_1_flag = field_1_flag;
    }

    
    public short getCol1()
    {
        return field_2_col1;
    }

    
    public void setCol1( short field_2_col1 )
    {
        this.field_2_col1 = field_2_col1;
    }

    
    public short getDx1()
    {
        return field_3_dx1;
    }

    
    public void setDx1( short field_3_dx1 )
    {
        this.field_3_dx1 = field_3_dx1;
    }

    
    public short getRow1()
    {
        return field_4_row1;
    }

    
    public void setRow1( short field_4_row1 )
    {
        this.field_4_row1 = field_4_row1;
    }

    
    public short getDy1()
    {
        return field_5_dy1;
    }

    
    public void setDy1( short field_5_dy1 )
    {
        shortRecord = false;
        this.field_5_dy1 = field_5_dy1;
    }

    
    public short getCol2()
    {
        return field_6_col2;
    }

    
    public void setCol2( short field_6_col2 )
    {
        shortRecord = false;
        this.field_6_col2 = field_6_col2;
    }

    
    public short getDx2()
    {
        return field_7_dx2;
    }

    
    public void setDx2( short field_7_dx2 )
    {
        shortRecord = false;
        this.field_7_dx2 = field_7_dx2;
    }

    
    public short getRow2()
    {
        return field_8_row2;
    }

    
    public void setRow2( short field_8_row2 )
    {
        shortRecord = false;
        this.field_8_row2 = field_8_row2;
    }

    
    public short getDy2()
    {
        return field_9_dy2;
    }

    
    public void setDy2( short field_9_dy2 )
    {
        shortRecord = false;
        this.field_9_dy2 = field_9_dy2;
    }

    
    public byte[] getRemainingData()
    {
        return remainingData;
    }

    
    public void setRemainingData( byte[] remainingData )
    {
        this.remainingData = remainingData;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFComment,11,4,0,11,24,9,5,6,10,0.75,150,1.0,2,0.756756757,0.181818182,1,1,12.09090909,3,1.4545,2,"
package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.DefaultEscherRecordFactory;
import org.apache.poi.ddf.EscherBSERecord;
import org.apache.poi.ddf.EscherContainerRecord;
import org.apache.poi.ddf.EscherOptRecord;
import org.apache.poi.ddf.EscherProperties;
import org.apache.poi.ddf.EscherSimpleProperty;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.EndSubRecord;
import org.apache.poi.hssf.record.NoteRecord;
import org.apache.poi.hssf.record.NoteStructureSubRecord;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.hssf.record.TextObjectRecord;
import org.apache.poi.ss.usermodel.ClientAnchor;
import org.apache.poi.ss.usermodel.Comment;


public class HSSFComment extends HSSFTextbox implements Comment {

    private final static int FILL_TYPE_SOLID = 0;
    private final static int FILL_TYPE_PICTURE = 3;

    private final static int GROUP_SHAPE_PROPERTY_DEFAULT_VALUE = 655362;
    private final static int GROUP_SHAPE_HIDDEN_MASK = 0x1000002;
    private final static int GROUP_SHAPE_NOT_HIDDEN_MASK = 0xFEFFFFFD;

    

    private NoteRecord _note;

    public HSSFComment(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord textObjectRecord, NoteRecord _note) {
        super(spContainer, objRecord, textObjectRecord);
        this._note = _note;
    }

    
    public HSSFComment(HSSFShape parent, HSSFAnchor anchor) {
        super(parent, anchor);
        _note = createNoteRecord();
        
        setFillColor(0x08000050);

        
        setVisible(false);
        setAuthor("""");
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) getObjRecord().getSubRecords().get(0);
        cod.setObjectType(CommonObjectDataSubRecord.OBJECT_TYPE_COMMENT);
    }

    protected HSSFComment(NoteRecord note, TextObjectRecord txo) {
        this(null, new HSSFClientAnchor());
        _note = note;
    }

    @Override
    void afterInsert(HSSFPatriarch patriarch) {
        super.afterInsert(patriarch);
        patriarch._getBoundAggregate().addTailRecord(getNoteRecord());
    }

    @Override
    protected EscherContainerRecord createSpContainer() {
        EscherContainerRecord spContainer = super.createSpContainer();
        EscherOptRecord opt = spContainer.getChildById(EscherOptRecord.RECORD_ID);
        opt.removeEscherProperty(EscherProperties.TEXT__TEXTLEFT);
        opt.removeEscherProperty(EscherProperties.TEXT__TEXTRIGHT);
        opt.removeEscherProperty(EscherProperties.TEXT__TEXTTOP);
        opt.removeEscherProperty(EscherProperties.TEXT__TEXTBOTTOM);
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GROUPSHAPE__PRINT, false, false, GROUP_SHAPE_PROPERTY_DEFAULT_VALUE));
        return spContainer;
    }

    @Override
    protected ObjRecord createObjRecord() {
        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType(OBJECT_TYPE_COMMENT);
        c.setLocked(true);
        c.setPrintable(true);
        c.setAutofill(false);
        c.setAutoline(true);

        NoteStructureSubRecord u = new NoteStructureSubRecord();
        EndSubRecord e = new EndSubRecord();
        obj.addSubRecord(c);
        obj.addSubRecord(u);
        obj.addSubRecord(e);
        return obj;
    }

    private NoteRecord createNoteRecord(){
        NoteRecord note = new NoteRecord();
        note.setFlags(NoteRecord.NOTE_HIDDEN);
        note.setAuthor("""");
        return note;
    }

    @Override
    void setShapeId(int shapeId) {
    	if(shapeId > 65535) {
    		throw new IllegalArgumentException(""Cannot add more than "" + 65535 + "" shapes"");
    	}
        super.setShapeId(shapeId);
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) getObjRecord().getSubRecords().get(0);
        cod.setObjectId(shapeId);
        _note.setShapeId(shapeId);
    }

    
    public void setVisible(boolean visible) {
        _note.setFlags(visible ? NoteRecord.NOTE_VISIBLE : NoteRecord.NOTE_HIDDEN);
        setHidden(!visible);
    }

    
    public boolean isVisible() {
        return _note.getFlags() == NoteRecord.NOTE_VISIBLE;
    }

    
    public int getRow() {
        return _note.getRow();
    }

    
    public void setRow(int row) {
        _note.setRow(row);
    }

    
    public int getColumn() {
        return _note.getColumn();
    }

    
    public void setColumn(int col) {
        _note.setColumn(col);
    }

    
    @Deprecated
    public void setColumn(short col) {
        setColumn((int) col);
    }

    
    public String getAuthor() {
        return _note.getAuthor();
    }

    
    public void setAuthor(String author) {
        if (_note != null) _note.setAuthor(author);
    }

    
    protected NoteRecord getNoteRecord() {
        return _note;
    }
    
    
    public boolean hasPosition() {
        if (_note == null) return false;
        if (getColumn() < 0 || getRow() < 0) return false;
        return true;
    }

    @Override
    public ClientAnchor getClientAnchor() {
        HSSFAnchor ha = super.getAnchor();
        if (ha instanceof ClientAnchor) {
            return (ClientAnchor) ha;
        }

        throw new IllegalStateException(""Anchor can not be changed in ""
                + ClientAnchor.class.getSimpleName());
    }

    @Override
    public void setShapeType(int shapeType) {
        throw new IllegalStateException(""Shape type can not be changed in ""+this.getClass().getSimpleName());
    }

    public void afterRemove(HSSFPatriarch patriarch){
        super.afterRemove(patriarch);
        patriarch._getBoundAggregate().removeTailRecord(getNoteRecord());
    }

    @Override
    protected HSSFShape cloneShape() {
        TextObjectRecord txo = (TextObjectRecord) getTextObjectRecord().cloneViaReserialise();
        EscherContainerRecord spContainer = new EscherContainerRecord();
        byte [] inSp = getEscherContainer().serialize();
        spContainer.fillFields(inSp, 0, new DefaultEscherRecordFactory());
        ObjRecord obj = (ObjRecord) getObjRecord().cloneViaReserialise();
        NoteRecord note = (NoteRecord) getNoteRecord().cloneViaReserialise();
        return new HSSFComment(spContainer, obj, txo, note);
    }
    
    public void setBackgroundImage(int pictureIndex){
        setPropertyValue(new EscherSimpleProperty( EscherProperties.FILL__PATTERNTEXTURE, false, true, pictureIndex));
        setPropertyValue(new EscherSimpleProperty( EscherProperties.FILL__FILLTYPE, false, false, FILL_TYPE_PICTURE));
        EscherBSERecord bse = getPatriarch().getSheet().getWorkbook().getWorkbook().getBSERecord(pictureIndex);
        bse.setRef(bse.getRef() + 1);
    }
    
    public void resetBackgroundImage(){
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.FILL__PATTERNTEXTURE);
        if (null != property){
            EscherBSERecord bse = getPatriarch().getSheet().getWorkbook().getWorkbook().getBSERecord(property.getPropertyValue());
            bse.setRef(bse.getRef() - 1);
            getOptRecord().removeEscherProperty(EscherProperties.FILL__PATTERNTEXTURE);
        }
        setPropertyValue(new EscherSimpleProperty( EscherProperties.FILL__FILLTYPE, false, false, FILL_TYPE_SOLID));
    }
    
    public int getBackgroundImageId(){
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.FILL__PATTERNTEXTURE);
        return property == null ? 0 : property.getPropertyValue();
    }

    private void setHidden(boolean value){
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.GROUPSHAPE__PRINT);
        
        if (value){
            setPropertyValue(new EscherSimpleProperty(EscherProperties.GROUPSHAPE__PRINT, false, false, property.getPropertyValue() | GROUP_SHAPE_HIDDEN_MASK));
        } else {
            setPropertyValue(new EscherSimpleProperty(EscherProperties.GROUPSHAPE__PRINT, false, false, property.getPropertyValue() & GROUP_SHAPE_NOT_HIDDEN_MASK));
        }
    }
}
"
poi,3,org.apache.poi.hssf.record.RKRecord,23,2,0,9,48,221,3,6,21,0.904040404,378,0.444444444,0,0.34375,0.211180124,1,3,15.04347826,6,1.5217,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.util.RKUtil;
import org.apache.poi.util.LittleEndianOutput;


public final class RKRecord extends CellRecord {
    public final static short sid                      = 0x027E;
    public final static short RK_IEEE_NUMBER           = 0;
    public final static short RK_IEEE_NUMBER_TIMES_100 = 1;
    public final static short RK_INTEGER               = 2;
    public final static short RK_INTEGER_TIMES_100     = 3;
    private int field_4_rk_number;

    private RKRecord() {
    	
    }

    public RKRecord(RecordInputStream in) {
        super(in);
        field_4_rk_number = in.readInt();
    }

    
    public double getRKNumber() {
        return RKUtil.decodeNumber(field_4_rk_number);
    }

    @Override
    protected String getRecordName() {
    	return ""RK"";
    }

    @Override
    protected void appendValueText(StringBuilder sb) {
    	sb.append(""  .value= "").append(getRKNumber());
    }

    @Override
    protected void serializeValue(LittleEndianOutput out) {
    	out.writeInt(field_4_rk_number);
    }

    @Override
    protected int getValueDataSize() {
    	return 4;
    }

    @Override
    public short getSid() {
        return sid;
    }

    @Override
    public Object clone() {
      RKRecord rec = new RKRecord();
      copyBaseFields(rec);
      rec.field_4_rk_number = field_4_rk_number;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.EndSubRecord,9,3,0,11,16,36,8,4,7,1.125,70,0.0,0,0.631578947,0.311111111,1,4,6.666666667,2,0.8889,1,"
        
package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;


public final class EndSubRecord extends SubRecord {
    public final static short sid = 0x0000; 
    private static final int ENCODED_SIZE = 0;

    public EndSubRecord()
    {

    }

    
    public EndSubRecord(LittleEndianInput in, int size) {
        if ((size & 0xFF) != ENCODED_SIZE) { 
            throw new RecordFormatException(""Unexpected size ("" + size + "")"");
        }
    }

    @Override
    public boolean isTerminating(){
        return true;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[ftEnd]
"");

        buffer.append(""[/ftEnd]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(sid);
        out.writeShort(ENCODED_SIZE);
    }

	protected int getDataSize() {
        return ENCODED_SIZE;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
        EndSubRecord rec = new EndSubRecord();
    
        return rec;
    }
}
"
poi,3,org.apache.poi.ddf.EscherTextboxRecord,11,2,0,7,35,11,1,6,10,0.85,242,0.5,0,0.678571429,0.38,1,5,20.63636364,2,0.9091,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.RecordFormatException;


public class EscherTextboxRecord extends EscherRecord
{
    public static final short RECORD_ID = (short)0xF00D;
    public static final String RECORD_DESCRIPTION = ""msofbtClientTextbox"";

    private static final byte[] NO_BYTES = new byte[0];

    
    private byte[] thedata = NO_BYTES;

    public EscherTextboxRecord()
    {
    }

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );

        
        
        thedata = new byte[bytesRemaining];
        System.arraycopy( data, offset + 8, thedata, 0, bytesRemaining );
        return bytesRemaining + 8;
    }

    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        LittleEndian.putShort(data, offset, getOptions());
        LittleEndian.putShort(data, offset+2, getRecordId());
        int remainingBytes = thedata.length;
        LittleEndian.putInt(data, offset+4, remainingBytes);
        System.arraycopy(thedata, 0, data, offset+8, thedata.length);
        int pos = offset+8+thedata.length;

        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        int size = pos - offset;
        if (size != getRecordSize())
            throw new RecordFormatException(size + "" bytes written but getRecordSize() reports "" + getRecordSize());
        return size;
    }

    
    public byte[] getData()
    {
        return thedata;
    }

    
    public void setData(byte[] b, int start, int length)
    {
        thedata = new byte[length];
        System.arraycopy(b,start,thedata,0,length);
    }
    public void setData(byte[] b) {
        setData(b,0,b.length);
    }

    public int getRecordSize()
    {
        return 8 + thedata.length;
    }

    public Object clone()
    {
        
        return super.clone();
    }

    public String getRecordName() {
        return ""ClientTextbox"";
    }

    public String toString()
    {
        String nl = System.getProperty( ""line.separator"" );

        String theDumpHex = """";
        try
        {
            if (thedata.length != 0)
            {
                theDumpHex = ""  Extra Data:"" + nl;
                theDumpHex += HexDump.dump(thedata, 0, 0);
            }
        }
        catch ( Exception e )
        {
            theDumpHex = ""Error!!"";
        }

        return getClass().getName() + "":"" + nl +
                ""  isContainer: "" + isContainerRecord() + nl +
                ""  version: 0x"" + HexDump.toHex( getVersion() ) + nl +
                ""  instance: 0x"" + HexDump.toHex( getInstance() ) + nl +
                ""  recordId: 0x"" + HexDump.toHex( getRecordId() ) + nl +
                ""  numchildren: "" + getChildRecords().size() + nl +
                theDumpHex;
    }

    @Override
    public String toXml(String tab) {
        String theDumpHex = """";
        try
        {
            if (thedata.length != 0)
            {
                theDumpHex += HexDump.dump(thedata, 0, 0);
            }
        }
        catch ( Exception e )
        {
            theDumpHex = ""Error!!"";
        }
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<ExtraData>"").append(theDumpHex).append(""</ExtraData>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }
}



"
poi,3,org.apache.poi.hssf.model.DrawingManager2,8,1,0,7,29,0,4,3,4,0.357142857,242,0.0,1,0.0,0.375,0,0,29.0,6,1.875,0,"

package org.apache.poi.hssf.model;

import org.apache.poi.ddf.EscherDgRecord;
import org.apache.poi.ddf.EscherDggRecord;

import java.util.List;
import java.util.ArrayList;



public class DrawingManager2
{
    EscherDggRecord dgg;
    List<EscherDgRecord> drawingGroups = new ArrayList<EscherDgRecord>();


    public DrawingManager2( EscherDggRecord dgg )
    {
        this.dgg = dgg;
    }
    
    
    public void clearDrawingGroups() {
    	drawingGroups.clear(); 
    }

    public EscherDgRecord createDgRecord()
    {
        EscherDgRecord dg = new EscherDgRecord();
        dg.setRecordId( EscherDgRecord.RECORD_ID );
        short dgId = findNewDrawingGroupId();
        dg.setOptions( (short) ( dgId << 4 ) );
        dg.setNumShapes( 0 );
        dg.setLastMSOSPID( -1 );
        drawingGroups.add(dg);
        dgg.addCluster( dgId, 0 );
        dgg.setDrawingsSaved( dgg.getDrawingsSaved() + 1 );
        return dg;
    }

    
    public int allocateShapeId(short drawingGroupId)
    {
        EscherDgRecord dg = getDrawingGroup(drawingGroupId);
        return allocateShapeId(drawingGroupId, dg);
    }

    
    public int allocateShapeId(short drawingGroupId, EscherDgRecord dg)
    {
        dgg.setNumShapesSaved( dgg.getNumShapesSaved() + 1 );

        
        for (int i = 0; i < dgg.getFileIdClusters().length; i++)
        {
            EscherDggRecord.FileIdCluster c = dgg.getFileIdClusters()[i];
            if (c.getDrawingGroupId() == drawingGroupId && c.getNumShapeIdsUsed() != 1024)
            {
                int result = c.getNumShapeIdsUsed() + (1024 * (i+1));
                c.incrementShapeId();
                dg.setNumShapes( dg.getNumShapes() + 1 );
                dg.setLastMSOSPID( result );
                if (result >= dgg.getShapeIdMax())
                    dgg.setShapeIdMax( result + 1 );
                return result;
            }
        }

        
        dgg.addCluster( drawingGroupId, 0 );
        dgg.getFileIdClusters()[dgg.getFileIdClusters().length-1].incrementShapeId();
        dg.setNumShapes( dg.getNumShapes() + 1 );
        int result = (1024 * dgg.getFileIdClusters().length);
        dg.setLastMSOSPID( result );
        if (result >= dgg.getShapeIdMax())
            dgg.setShapeIdMax( result + 1 );
        return result;
    }
    
    
    
    public short findNewDrawingGroupId()
    {
        short dgId = 1; 
        while ( drawingGroupExists( dgId ) )
            dgId++;
        return dgId;
    }

    EscherDgRecord getDrawingGroup(int drawingGroupId)
    {
        return drawingGroups.get(drawingGroupId-1);
    }

    boolean drawingGroupExists( short dgId )
    {
        for ( int i = 0; i < dgg.getFileIdClusters().length; i++ )
        {
            if ( dgg.getFileIdClusters()[i].getDrawingGroupId() == dgId )
                return true;
        }
        return false;
    }

    int findFreeSPIDBlock()
    {
        int max = dgg.getShapeIdMax();
        int next = ( ( max / 1024 ) + 1 ) * 1024;
        return next;
    }

    public EscherDggRecord getDgg()
    {
        return dgg;
    }

    public void incrementDrawingsSaved(){
        dgg.setDrawingsSaved(dgg.getDrawingsSaved()+1);
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.FontDetails,9,1,0,2,32,20,2,0,8,0.625,291,1.0,0,0.0,0.301587302,0,0,31.0,8,2.4444,2,"

package org.apache.poi.hssf.usermodel;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;


public class FontDetails
{
    private String _fontName;
    private int _height;
    private final Map<Character, Integer> charWidths = new HashMap<Character, Integer>();

    
    public FontDetails( String fontName, int height )
    {
        _fontName = fontName;
        _height = height;
    }

    public String getFontName()
    {
        return _fontName;
    }

    public int getHeight()
    {
        return _height;
    }

    public void addChar( char c, int width )
    {
        charWidths.put(Character.valueOf(c), Integer.valueOf(width));
    }

    
    public int getCharWidth( char c )
    {
        Integer widthInteger = charWidths.get(Character.valueOf(c));
        if (widthInteger == null) {
            return 'W' == c ? 0 : getCharWidth('W');
        }
        return widthInteger;
    }

    public void addChars( char[] characters, int[] widths )
    {
        for ( int i = 0; i < characters.length; i++ )
        {
            charWidths.put( Character.valueOf(characters[i]), Integer.valueOf(widths[i]));
        }
    }

    protected static String buildFontHeightProperty(String fontName) {
        return ""font."" + fontName + "".height"";
    }
    protected static String buildFontWidthsProperty(String fontName) {
        return ""font."" + fontName + "".widths"";
    }
    protected static String buildFontCharactersProperty(String fontName) {
        return ""font."" + fontName + "".characters"";
    }

    
    public static FontDetails create( String fontName, Properties fontMetricsProps )
    {
        String heightStr = fontMetricsProps.getProperty( buildFontHeightProperty(fontName) );
        String widthsStr = fontMetricsProps.getProperty( buildFontWidthsProperty(fontName) );
        String charactersStr = fontMetricsProps.getProperty( buildFontCharactersProperty(fontName) );

        
        if(heightStr == null || widthsStr == null || charactersStr == null) {
            
            
            throw new IllegalArgumentException(""The supplied FontMetrics doesn't know about the font '"" + fontName + ""', so we can't use it. Please add it to your font metrics file (see StaticFontMetrics.getFontDetails"");
        }

        int height = Integer.parseInt(heightStr);
        FontDetails d = new FontDetails(fontName, height);
        String[] charactersStrArray = split(charactersStr, "","", -1);
        String[] widthsStrArray = split(widthsStr, "","", -1);
        if (charactersStrArray.length != widthsStrArray.length)
            throw new RuntimeException(""Number of characters does not number of widths for font "" + fontName);
        for ( int i = 0; i < widthsStrArray.length; i++ )
        {
            if (charactersStrArray[i].length() != 0)
                d.addChar(charactersStrArray[i].charAt(0), Integer.parseInt(widthsStrArray[i]));
        }
        return d;
    }

    
    public int getStringWidth(String str)
    {
        int width = 0;
        for (int i = 0; i < str.length(); i++)
        {
            width += getCharWidth(str.charAt(i));
        }
        return width;
    }

    
    private static String[] split(String text, String separator, int max)
    {
        StringTokenizer tok = new StringTokenizer(text, separator);
        int listSize = tok.countTokens();
        if(max != -1 && listSize > max)
            listSize = max;
        String list[] = new String[listSize];
        for(int i = 0; tok.hasMoreTokens(); i++)
        {
            if(max != -1 && i == listSize - 1)
            {
                StringBuffer buf = new StringBuffer((text.length() * (listSize - i)) / listSize);
                while(tok.hasMoreTokens())
                {
                    buf.append(tok.nextToken());
                    if(tok.hasMoreTokens())
                        buf.append(separator);
                }
                list[i] = buf.toString().trim();
                break;
            }
            list[i] = tok.nextToken().trim();
        }

        return list;
    }
}
"
poi,3,org.apache.poi.hssf.record.MulRKRecord,14,2,0,8,32,73,3,5,11,0.861538462,192,0.8,0,0.47826087,0.314285714,1,3,12.35714286,2,1.0714,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.util.RKUtil;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class MulRKRecord extends StandardRecord {
	public final static short sid = 0x00BD;

	private int	 field_1_row;
	private short   field_2_first_col;
	private RkRec[] field_3_rks;
	private short   field_4_last_col;

	public int getRow() {
		return field_1_row;
	}

	
	public short getFirstColumn() {
		return field_2_first_col;
	}

	
	public short getLastColumn() {
		return field_4_last_col;
	}

	
	public int getNumColumns() {
		return field_4_last_col - field_2_first_col + 1;
	}

	
	public short getXFAt(int coffset) {
		return field_3_rks[coffset].xf;
	}

	
	public double getRKNumberAt(int coffset) {
		return RKUtil.decodeNumber(field_3_rks[coffset].rk);
	}

	
	public MulRKRecord(RecordInputStream in) {
		field_1_row = in.readUShort();
		field_2_first_col = in.readShort();
		field_3_rks = RkRec.parseRKs(in);
		field_4_last_col = in.readShort();
	}


	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[MULRK]
"");
		buffer.append(""	.row	 = "").append(HexDump.shortToHex(getRow())).append(""
"");
		buffer.append(""	.firstcol= "").append(HexDump.shortToHex(getFirstColumn())).append(""
"");
		buffer.append(""	.lastcol = "").append(HexDump.shortToHex(getLastColumn())).append(""
"");

		for (int k = 0; k < getNumColumns(); k++) {
			buffer.append(""	xf["").append(k).append(""] = "").append(HexDump.shortToHex(getXFAt(k))).append(""
"");
			buffer.append(""	rk["").append(k).append(""] = "").append(getRKNumberAt(k)).append(""
"");
		}
		buffer.append(""[/MULRK]
"");
		return buffer.toString();
	}

	public short getSid()
	{
		return sid;
	}

	public void serialize(LittleEndianOutput out) {
		throw new RecordFormatException( ""Sorry, you can't serialize MulRK in this release"");
	}
	protected int getDataSize() {
		throw new RecordFormatException( ""Sorry, you can't serialize MulRK in this release"");
	}

	private static final class RkRec {
		public static final int ENCODED_SIZE = 6;
		public final short xf;
		public final int   rk;

		private RkRec(RecordInputStream in) {
			xf = in.readShort();
			rk = in.readInt();
		}

		public static RkRec[] parseRKs(RecordInputStream in) {
			int nItems = (in.remaining()-2) / ENCODED_SIZE;
			RkRec[] retval = new RkRec[nItems];
			for (int i=0; i<nItems; i++) {
				retval[i] = new RkRec(in);
			}
			return retval;
		}
	}
}
"
poi,3,org.apache.poi.poifs.filesystem.OfficeXmlFileException,1,5,0,1,2,0,1,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
        
package org.apache.poi.poifs.filesystem;


public class OfficeXmlFileException extends IllegalArgumentException {
	public OfficeXmlFileException(String s) {
		super(s);
	}
}
"
poi,3,org.apache.poi.ddf.EscherOptRecord,12,2,0,17,49,0,10,8,11,0.757575758,269,0.333333333,0,0.633333333,0.277777778,1,5,21.16666667,3,1.25,1,"
package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.Internal;


public class EscherOptRecord extends AbstractEscherOptRecord
{
    public static final String RECORD_DESCRIPTION = ""msofbtOPT"";
    public static final short RECORD_ID = (short) 0xF00B;

    @Override
    public short getInstance()
    {
        setInstance( (short) properties.size() );
        return super.getInstance();
    }

    
    @Internal
    public short getOptions()
    {
        
        getInstance();
        getVersion();
        return super.getOptions();
    }

    public String getRecordName()
    {
        return ""Opt"";
    }

    @Override
    public short getVersion()
    {
        setVersion( (short) 0x3 );
        return super.getVersion();
    }

    @Override
    public void setVersion( short value )
    {
        if ( value != 0x3 )
            throw new IllegalArgumentException( RECORD_DESCRIPTION
                    + "" can have only '0x3' version"" );

        super.setVersion( value );
    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())));
        for (EscherProperty property: getEscherProperties()){
            builder.append(property.toXml(tab+""	""));
        }
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.hssf.record.PageBreakRecord,16,2,2,8,43,96,4,5,14,0.755555556,457,0.5,0,0.458333333,0.325,1,4,27.1875,5,1.6875,1,"

package org.apache.poi.hssf.record;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.poi.util.LittleEndianOutput;


public abstract class PageBreakRecord extends StandardRecord {
    private static final int[] EMPTY_INT_ARRAY = { };

    private List<Break> _breaks;
    private Map<Integer, Break> _breakMap;

    
    public static final class Break {

        public static final int ENCODED_SIZE = 6;
        public int main;
        public int subFrom;
        public int subTo;

        public Break(int main, int subFrom, int subTo)
        {
            this.main = main;
            this.subFrom = subFrom;
            this.subTo = subTo;
        }

        public Break(RecordInputStream in) {
            main = in.readUShort() - 1;
            subFrom = in.readUShort();
            subTo = in.readUShort();
        }

        public void serialize(LittleEndianOutput out) {
            out.writeShort(main + 1);
            out.writeShort(subFrom);
            out.writeShort(subTo);
        }
    }

    protected PageBreakRecord() {
        _breaks = new ArrayList<Break>();
        _breakMap = new HashMap<Integer, Break>();
    }

    public PageBreakRecord(RecordInputStream in)
    {
        int nBreaks = in.readShort();
        _breaks = new ArrayList<Break>(nBreaks + 2);
        _breakMap = new HashMap<Integer, Break>();

        for(int k = 0; k < nBreaks; k++) {
            Break br = new Break(in);
            _breaks.add(br);
            _breakMap.put(Integer.valueOf(br.main), br);
        }

    }

    public boolean isEmpty() {
    	return _breaks.isEmpty();
    }
    protected int getDataSize() {
        return 2 + _breaks.size() * Break.ENCODED_SIZE;
    }

    public final void serialize(LittleEndianOutput out) {
        int nBreaks = _breaks.size();
        out.writeShort(nBreaks);
        for (int i=0; i<nBreaks; i++) {
            _breaks.get(i).serialize(out);
        }
    }

    public int getNumBreaks() {
        return _breaks.size();
    }

    public final Iterator<Break> getBreaksIterator() {
        return _breaks.iterator();
    }

    public String toString() {
        StringBuffer retval = new StringBuffer();

        String label;
        String mainLabel;
        String subLabel;

        if (getSid() == HorizontalPageBreakRecord.sid) {
           label = ""HORIZONTALPAGEBREAK"";
           mainLabel = ""row"";
           subLabel = ""col"";
        } else {
           label = ""VERTICALPAGEBREAK"";
           mainLabel = ""column"";
           subLabel = ""row"";
        }

        retval.append(""[""+label+""]"").append(""
"");
        retval.append(""     .sid        ="").append(getSid()).append(""
"");
        retval.append(""     .numbreaks ="").append(getNumBreaks()).append(""
"");
        Iterator<Break> iterator = getBreaksIterator();
        for(int k = 0; k < getNumBreaks(); k++)
        {
            Break region = iterator.next();

            retval.append(""     ."").append(mainLabel).append("" (zero-based) ="").append(region.main).append(""
"");
            retval.append(""     ."").append(subLabel).append(""From    ="").append(region.subFrom).append(""
"");
            retval.append(""     ."").append(subLabel).append(""To      ="").append(region.subTo).append(""
"");
        }

        retval.append(""[""+label+""]"").append(""
"");
        return retval.toString();
    }

   
    public void addBreak(int main, int subFrom, int subTo) {

        Integer key = Integer.valueOf(main);
        Break region = _breakMap.get(key);
        if(region == null) {
            region = new Break(main, subFrom, subTo);
            _breakMap.put(key, region);
            _breaks.add(region);
        } else {
            region.main = main;
            region.subFrom = subFrom;
            region.subTo = subTo;
        }
    }

    
    public final void removeBreak(int main) {
        Integer rowKey = Integer.valueOf(main);
        Break region = _breakMap.get(rowKey);
        _breaks.remove(region);
        _breakMap.remove(rowKey);
    }

    
    public final Break getBreak(int main) {
        Integer rowKey = Integer.valueOf(main);
        return _breakMap.get(rowKey);
    }

    public final int[] getBreaks() {
        int count = getNumBreaks();
        if (count < 1) {
            return EMPTY_INT_ARRAY;
        }
        int[] result = new int[count];
        for (int i=0; i<count; i++) {
            Break breakItem = _breaks.get(i);
            result[i] = breakItem.main;
        }
        return result;
    }
}
"
poi,3,org.apache.poi.hpsf.Constants,1,1,0,0,2,0,0,0,1,2.0,58,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.poi.hpsf;

import org.apache.poi.util.CodePageUtil;


public class Constants
{
    
    public static final int CP_037 = 37;

    
    public static final int CP_SJIS = 932;

    
    public static final int CP_GBK = 936;

    
    public static final int CP_MS949 = 949;

    
    public static final int CP_UTF16 = 1200;

    
    public static final int CP_UTF16_BE = 1201;

    
    public static final int CP_WINDOWS_1250 = 1250;

    
    public static final int CP_WINDOWS_1251 = 1251;

    
    public static final int CP_WINDOWS_1252 = 1252;

    
    public static final int CP_WINDOWS_1253 = 1253;

    
    public static final int CP_WINDOWS_1254 = 1254;

    
    public static final int CP_WINDOWS_1255 = 1255;

    
    public static final int CP_WINDOWS_1256 = 1256;

    
    public static final int CP_WINDOWS_1257 = 1257;

    
    public static final int CP_WINDOWS_1258 = 1258;

    
    public static final int CP_JOHAB = 1361;

    
    public static final int CP_MAC_ROMAN = 10000;

    
    public static final int CP_MAC_JAPAN = 10001;

    
    public static final int CP_MAC_CHINESE_TRADITIONAL = 10002;

    
    public static final int CP_MAC_KOREAN = 10003;

    
    public static final int CP_MAC_ARABIC = 10004;

    
    public static final int CP_MAC_HEBREW = 10005;

    
    public static final int CP_MAC_GREEK = 10006;

    
    public static final int CP_MAC_CYRILLIC = 10007;

    
    public static final int CP_MAC_CHINESE_SIMPLE = 10008;

    
    public static final int CP_MAC_ROMANIA = 10010;

    
    public static final int CP_MAC_UKRAINE = 10017;

    
    public static final int CP_MAC_THAI = 10021;

    
    public static final int CP_MAC_CENTRAL_EUROPE = 10029;

    
    public static final int CP_MAC_ICELAND = 10079;

    
    public static final int CP_MAC_TURKISH = 10081;

    
    public static final int CP_MAC_CROATIAN = 10082;

    
    public static final int CP_US_ACSII = 20127;

    
    public static final int CP_KOI8_R = 20866;

    
    public static final int CP_ISO_8859_1 = 28591;

    
    public static final int CP_ISO_8859_2 = 28592;

    
    public static final int CP_ISO_8859_3 = 28593;

    
    public static final int CP_ISO_8859_4 = 28594;

    
    public static final int CP_ISO_8859_5 = 28595;

    
    public static final int CP_ISO_8859_6 = 28596;

    
    public static final int CP_ISO_8859_7 = 28597;

    
    public static final int CP_ISO_8859_8 = 28598;

    
    public static final int CP_ISO_8859_9 = 28599;

    
    public static final int CP_ISO_2022_JP1 = 50220;

    
    public static final int CP_ISO_2022_JP2 = 50221;

    
    public static final int CP_ISO_2022_JP3 = 50222;

    
    public static final int CP_ISO_2022_KR = 50225;

    
    public static final int CP_EUC_JP = 51932;

    
    public static final int CP_EUC_KR = 51949;

    
    public static final int CP_GB2312 = 52936;

    
    public static final int CP_GB18030 = 54936;

    
    public static final int CP_US_ASCII2 = 65000;

    
    public static final int CP_UTF8 = 65001;

    
    public static final int CP_UNICODE = CP_UTF16;
}
"
poi,3,org.apache.poi.poifs.storage.DocumentBlock,10,2,0,5,19,5,2,3,8,0.740740741,223,1.0,0,0.3,0.228571429,1,2,21.0,3,1.2,0,"

package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IOUtils;


public final class DocumentBlock extends BigBlock {
    private static final byte _default_value = ( byte ) 0xFF;
    private byte[]            _data;
    private int               _bytes_read;

    

    public DocumentBlock(final RawDataBlock block)
        throws IOException
    {
        super(
              block.getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?
                    POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS :
                    POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS
        );
        _data       = block.getData();
        _bytes_read = _data.length;
    }

    

    public DocumentBlock(final InputStream stream, POIFSBigBlockSize bigBlockSize)
        throws IOException
    {
        this(bigBlockSize);
        int count = IOUtils.readFully(stream, _data);

        _bytes_read = (count == -1) ? 0
                                    : count;
    }

    

    private DocumentBlock(POIFSBigBlockSize bigBlockSize)
    {
        super(bigBlockSize);
        _data = new byte[ bigBlockSize.getBigBlockSize() ];
        Arrays.fill(_data, _default_value);
    }

    

    public int size()
    {
        return _bytes_read;
    }

    

    public boolean partiallyRead()
    {
        return _bytes_read != bigBlockSize.getBigBlockSize();
    }

    

    public static byte getFillByte()
    {
        return _default_value;
    }

    

    public static DocumentBlock [] convert(final POIFSBigBlockSize bigBlockSize,
                                           final byte [] array,
                                           final int size)
    {
        DocumentBlock[] rval   =
            new DocumentBlock[ (size + bigBlockSize.getBigBlockSize() - 1) / bigBlockSize.getBigBlockSize() ];
        int             offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new DocumentBlock(bigBlockSize);
            if (offset < array.length)
            {
                int length = Math.min(bigBlockSize.getBigBlockSize(),
                                      array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != bigBlockSize.getBigBlockSize())
                {
                    Arrays.fill(rval[ k ]._data, length,
                          bigBlockSize.getBigBlockSize(),
                                _default_value);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_value);
            }
            offset += bigBlockSize.getBigBlockSize();
        }
        return rval;
    }

    public static DataInputBlock getDataInputBlock(DocumentBlock[] blocks, int offset) {
        if(blocks == null || blocks.length == 0) {
           return null;
        }
        
        
        POIFSBigBlockSize bigBlockSize = blocks[0].bigBlockSize;
        int BLOCK_SHIFT = bigBlockSize.getHeaderValue();
        int BLOCK_SIZE = bigBlockSize.getBigBlockSize();
        int BLOCK_MASK = BLOCK_SIZE - 1;

        
        int firstBlockIndex = offset >> BLOCK_SHIFT;
        int firstBlockOffset= offset & BLOCK_MASK;
        return new DataInputBlock(blocks[firstBlockIndex]._data, firstBlockOffset);
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        doWriteData(stream, _data);
    }

    
}   

"
poi,3,org.apache.poi.ddf.EscherPropertyFactory,2,1,0,10,20,1,1,9,2,2.0,166,0.0,0,0.0,0.625,0,0,82.0,11,5.5,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.LittleEndian;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public final class EscherPropertyFactory {
    
    public List<EscherProperty> createProperties(byte[] data, int offset, short numProperties) {
        List<EscherProperty> results = new ArrayList<EscherProperty>();

        int pos = offset;


        for (int i = 0; i < numProperties; i++) {
            short propId;
            int propData;
            propId = LittleEndian.getShort( data, pos );
            propData = LittleEndian.getInt( data, pos + 2 );
            short propNumber = (short) ( propId & (short) 0x3FFF );
            boolean isComplex = ( propId & (short) 0x8000 ) != 0;
            boolean isBlipId = ( propId & (short) 0x4000 ) != 0;

            byte propertyType = EscherProperties.getPropertyType(propNumber);
            if ( propertyType == EscherPropertyMetaData.TYPE_BOOLEAN )
                results.add( new EscherBoolProperty( propId, propData ) );
            else if ( propertyType == EscherPropertyMetaData.TYPE_RGB )
                results.add( new EscherRGBProperty( propId, propData ) );
            else if ( propertyType == EscherPropertyMetaData.TYPE_SHAPEPATH )
                results.add( new EscherShapePathProperty( propId, propData ) );
            else
            {
                if ( !isComplex )
                    results.add( new EscherSimpleProperty( propId, propData ) );
                else
                {
                    if ( propertyType == EscherPropertyMetaData.TYPE_ARRAY)
                        results.add( new EscherArrayProperty( propId, new byte[propData]) );
                    else
                        results.add( new EscherComplexProperty( propId, new byte[propData]) );
                }
            }
            pos += 6;

        }

        
        for (Iterator<EscherProperty> iterator = results.iterator(); iterator.hasNext();) {
            EscherProperty p = iterator.next();
            if (p instanceof EscherComplexProperty) {
                if (p instanceof EscherArrayProperty) {
                    pos += ((EscherArrayProperty)p).setArrayData(data, pos);
                } else {
                    byte[] complexData = ((EscherComplexProperty)p).getComplexData();

                    int leftover = data.length-pos;
                    if(leftover < complexData.length){
                        throw new IllegalStateException(""Could not read complex escher property, lenght was "" + complexData.length + "", but had only "" +
                                leftover + "" bytes left"");
                    }

                    System.arraycopy(data, pos, complexData, 0, complexData.length);
                    pos += complexData.length;
                }
            }
        }
        return results;
    }
}
"
poi,3,org.apache.poi.poifs.dev.POIFSViewEngine,4,1,0,2,24,4,1,1,2,0.333333333,146,1.0,0,0.0,0.466666667,0,0,35.25,3,1.25,0,"

        

package org.apache.poi.poifs.dev;

import java.io.IOException;
import java.io.LineNumberReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;



public class POIFSViewEngine
{
    private static final String _EOL = System.getProperty(""line.separator"");

    

    public static List<String> inspectViewable(final Object viewable,
                                       final boolean drilldown,
                                       final int indentLevel,
                                       final String indentString)
    {
        List<String> objects = new ArrayList<String>();

        if (viewable instanceof POIFSViewable)
        {
            POIFSViewable inspected = ( POIFSViewable ) viewable;

            objects.add(indent(indentLevel, indentString,
                               inspected.getShortDescription()));
            if (drilldown)
            {
                if (inspected.preferArray())
                {
                    Object[] data = inspected.getViewableArray();

                    for (int j = 0; j < data.length; j++)
                    {
                        objects.addAll(inspectViewable(data[ j ], drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
                else
                {
                    Iterator<Object> iter = inspected.getViewableIterator();

                    while (iter.hasNext())
                    {
                        objects.addAll(inspectViewable(iter.next(),
                                                       drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
            }
        }
        else
        {
            objects.add(indent(indentLevel, indentString,
                               viewable.toString()));
        }
        return objects;
    }

    private static String indent(final int indentLevel,
                                 final String indentString, final String data)
    {
        StringBuffer finalBuffer  = new StringBuffer();
        StringBuffer indentPrefix = new StringBuffer();

        for (int j = 0; j < indentLevel; j++)
        {
            indentPrefix.append(indentString);
        }
        LineNumberReader reader =
            new LineNumberReader(new StringReader(data));

        try
        {
            String line = reader.readLine();

            while (line != null)
            {
                finalBuffer.append(indentPrefix).append(line).append(_EOL);
                line = reader.readLine();
            }
        }
        catch (IOException e)
        {
            finalBuffer.append(indentPrefix).append(e.getMessage())
                .append(_EOL);
        }
        return finalBuffer.toString();
    }
}   

"
poi,3,org.apache.poi.hssf.record.RightMarginRecord,11,2,0,7,21,35,2,5,9,0.8,107,0.5,0,0.55,0.257575758,1,4,8.545454545,2,0.9091,0,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class RightMarginRecord extends StandardRecord implements Margin {
    public final static short sid = 0x27;
    private double field_1_margin;

    public RightMarginRecord()    {    }

    public RightMarginRecord( RecordInputStream in )
    {
        field_1_margin = in.readDouble();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();
        buffer.append( ""[RightMargin]
"" );
        buffer.append( ""    .margin               = "" ).append( "" ("" ).append( getMargin() ).append( "" )
"" );
        buffer.append( ""[/RightMargin]
"" );
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeDouble(field_1_margin);
    }

    protected int getDataSize() {
        return 8;
    }

    public short getSid()    {        return sid;    }

    
    public double getMargin()    {        return field_1_margin;    }

    
    public void setMargin( double field_1_margin )
    {        this.field_1_margin = field_1_margin;    }

    public Object clone()
    {
        RightMarginRecord rec = new RightMarginRecord();
        rec.field_1_margin = this.field_1_margin;
        return rec;
    }
}  "
poi,3,org.apache.poi.hssf.record.SSTRecord,23,2,0,12,60,65,2,10,17,0.912587413,386,0.384615385,3,0.35483871,0.220779221,2,5,15.2173913,6,1.3913,3,"

package org.apache.poi.hssf.record;

import java.util.Iterator;

import org.apache.poi.hssf.record.common.UnicodeString;
import org.apache.poi.hssf.record.cont.ContinuableRecord;
import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;
import org.apache.poi.util.IntMapper;
import org.apache.poi.util.LittleEndianConsts;


public final class SSTRecord extends ContinuableRecord {
    public static final short sid = 0x00FC;

    private static final UnicodeString EMPTY_STRING = new UnicodeString("""");

    
    
    static final int STD_RECORD_OVERHEAD = 2 * LittleEndianConsts.SHORT_SIZE;

    
    static final int SST_RECORD_OVERHEAD = STD_RECORD_OVERHEAD + 2 * LittleEndianConsts.INT_SIZE;

    
    static final int MAX_DATA_SPACE = RecordInputStream.MAX_RECORD_DATA_SIZE - 8;

    
    private int field_1_num_strings;

    
    private int field_2_num_unique_strings;
    private IntMapper<UnicodeString> field_3_strings;

    private SSTDeserializer deserializer;

    
    int[] bucketAbsoluteOffsets;
    
    int[] bucketRelativeOffsets;

    public SSTRecord()
    {
        field_1_num_strings = 0;
        field_2_num_unique_strings = 0;
        field_3_strings = new IntMapper<UnicodeString>();
        deserializer = new SSTDeserializer(field_3_strings);
    }

    
    public int addString(UnicodeString string)
    {
        field_1_num_strings++;
        UnicodeString ucs = ( string == null ) ? EMPTY_STRING
                : string;
        int rval;
        int index = field_3_strings.getIndex(ucs);

        if ( index != -1 ) {
            rval = index;
        } else {
            
            
            rval = field_3_strings.size();
            field_2_num_unique_strings++;
            SSTDeserializer.addToStringTable( field_3_strings, ucs );
        }
        return rval;
    }

    
    public int getNumStrings()
    {
        return field_1_num_strings;
    }

    
    public int getNumUniqueStrings()
    {
        return field_2_num_unique_strings;
    }


    
    public UnicodeString getString(int id )
    {
        return field_3_strings.get( id );
    }


    
    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append( ""[SST]
"" );
        buffer.append( ""    .numstrings     = "" )
                .append( Integer.toHexString( getNumStrings() ) ).append( ""
"" );
        buffer.append( ""    .uniquestrings  = "" )
                .append( Integer.toHexString( getNumUniqueStrings() ) ).append( ""
"" );
        for ( int k = 0; k < field_3_strings.size(); k++ )
        {
          UnicodeString s = field_3_strings.get( k );
            buffer.append( ""    .string_"" + k + ""      = "" )
                    .append( s.getDebugInfo() ).append( ""
"" );
        }
        buffer.append( ""[/SST]
"" );
        return buffer.toString();
    }

    public short getSid() {
        return sid;
    }

    
    public SSTRecord(RecordInputStream in) {
        
        
        
        field_1_num_strings = in.readInt();
        field_2_num_unique_strings = in.readInt();
        field_3_strings = new IntMapper<UnicodeString>();
        
        deserializer = new SSTDeserializer(field_3_strings);
        
        
        if(field_1_num_strings == 0) {
            field_2_num_unique_strings = 0;
            return;
        }
        deserializer.manufactureStrings( field_2_num_unique_strings, in );
    }


    
    Iterator<UnicodeString> getStrings()
    {
        return field_3_strings.iterator();
    }

    
    int countStrings() {
        return field_3_strings.size();
    }

    protected void serialize(ContinuableRecordOutput out) {
        SSTSerializer serializer = new SSTSerializer(field_3_strings, getNumStrings(), getNumUniqueStrings() );
        serializer.serialize(out);
        bucketAbsoluteOffsets = serializer.getBucketAbsoluteOffsets();
        bucketRelativeOffsets = serializer.getBucketRelativeOffsets();
    }

    SSTDeserializer getDeserializer() {
        return deserializer;
    }

    
    public ExtSSTRecord createExtSSTRecord(int sstOffset) {
        if (bucketAbsoluteOffsets == null || bucketAbsoluteOffsets == null)
            throw new IllegalStateException(""SST record has not yet been serialized."");

        ExtSSTRecord extSST = new ExtSSTRecord();
        extSST.setNumStringsPerBucket((short)8);
        int[] absoluteOffsets = bucketAbsoluteOffsets.clone();
        int[] relativeOffsets = bucketRelativeOffsets.clone();
        for ( int i = 0; i < absoluteOffsets.length; i++ )
            absoluteOffsets[i] += sstOffset;
        extSST.setBucketOffsets(absoluteOffsets, relativeOffsets);
        return extSST;
    }

    
    public int calcExtSSTRecordSize() {
      return ExtSSTRecord.getRecordSizeForStrings(field_3_strings.size());
    }
}
"
poi,3,org.apache.poi.poifs.property.DocumentProperty,7,2,0,6,14,9,5,2,5,0.5,48,1.0,1,0.848484848,0.342857143,0,0,5.714285714,1,0.7143,0,"

        

package org.apache.poi.poifs.property;

import org.apache.poi.poifs.filesystem.OPOIFSDocument;



public class DocumentProperty
    extends Property
{

    
    private OPOIFSDocument _document;

    

    public DocumentProperty(final String name, final int size)
    {
        super();
        _document = null;
        setName(name);
        setSize(size);
        setNodeColor(_NODE_BLACK);   
        setPropertyType(PropertyConstants.DOCUMENT_TYPE);
    }

    

    protected DocumentProperty(final int index, final byte [] array,
                               final int offset)
    {
        super(index, array, offset);
        _document = null;
    }

    

    public void setDocument(OPOIFSDocument doc)
    {
        _document = doc;
    }

    

    public OPOIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public boolean shouldUseSmallBlocks()
    {
        return super.shouldUseSmallBlocks();
    }

    

    public boolean isDirectory()
    {
        return false;
    }

    

    protected void preWrite()
    {

        
    }
    
    
    public void updateSize(int size)
    {
        setSize(size);
    }

    
}   

"
poi,3,org.apache.poi.hssf.usermodel.HSSFPrintSetup,39,1,0,3,78,0,2,1,38,0.923684211,234,0.0,1,0.0,0.302564103,0,0,4.743589744,2,1.0256,0,"


package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.PrintSetupRecord;
import org.apache.poi.ss.usermodel.PrintSetup;


public class HSSFPrintSetup implements PrintSetup {    
    PrintSetupRecord printSetupRecord;
    
    
    protected HSSFPrintSetup(PrintSetupRecord printSetupRecord) {
	this.printSetupRecord = printSetupRecord;
    }    
    
    
    public void setPaperSize(short size)    {
	printSetupRecord.setPaperSize(size);
    }    
    
    
    public void setScale(short scale)    {
	printSetupRecord.setScale(scale);
    }    
    
    
    public void setPageStart(short start)    {
	printSetupRecord.setPageStart(start);
    }    
    
    
    public void setFitWidth(short width)    {
	printSetupRecord.setFitWidth(width);
    }    
    
    
    public void setFitHeight(short height)    {
	printSetupRecord.setFitHeight(height);
    }    
    
    
    public void setOptions(short options)    {
	printSetupRecord.setOptions(options);
    }    
    
    
    public void setLeftToRight(boolean ltor)    {
	printSetupRecord.setLeftToRight(ltor);
    }    
    
    
    public void setLandscape(boolean ls)    {
	printSetupRecord.setLandscape(!ls);
    }    
    
    
    public void setValidSettings(boolean valid)    {
	printSetupRecord.setValidSettings(valid);
    }    
    
    
    public void setNoColor(boolean mono)    {
	printSetupRecord.setNoColor(mono);
    }    
    
    
    public void setDraft(boolean d)    {
	printSetupRecord.setDraft(d);
    }    
    
    
    public void setNotes(boolean printnotes)    {
	printSetupRecord.setNotes(printnotes);
    }    
    
    
    public void setNoOrientation(boolean orientation)    {
	printSetupRecord.setNoOrientation(orientation);
    }    
    
    
    public void setUsePage(boolean page)    {
	printSetupRecord.setUsePage(page);
    }    
    
    
    public void setHResolution(short resolution)    {
	printSetupRecord.setHResolution(resolution);
    }    
    
    
    public void setVResolution(short resolution)    {
	printSetupRecord.setVResolution(resolution);
    }    
    
    
    public void setHeaderMargin(double headermargin)    {
	printSetupRecord.setHeaderMargin(headermargin);
    }    
    
    
    public void setFooterMargin(double footermargin)    {
	printSetupRecord.setFooterMargin(footermargin);
    }    
    
    
    public void setCopies(short copies)    {
	printSetupRecord.setCopies(copies);
    }    
    
    
    public short getPaperSize()    {
        return printSetupRecord.getPaperSize();
    }    
    
    
    public short getScale()    {
        return printSetupRecord.getScale();
    }    
    
    
    public short getPageStart()    {
        return printSetupRecord.getPageStart();
    }    
    
    
    public short getFitWidth()    {
        return printSetupRecord.getFitWidth();
    }    
    
    
    public short getFitHeight()    {
        return printSetupRecord.getFitHeight();
    }    
    
    
    public short getOptions()    {
        return printSetupRecord.getOptions();
    }    
    
    
    public boolean getLeftToRight()    {
        return printSetupRecord.getLeftToRight();
    }    
    
    
    public boolean getLandscape()    {
        return !printSetupRecord.getLandscape();
    }    
    
    
    public boolean getValidSettings()    {
        return printSetupRecord.getValidSettings();
    }    
    
    
    public boolean getNoColor()    {
        return printSetupRecord.getNoColor();
    }    
    
    
    public boolean getDraft()    {
        return printSetupRecord.getDraft();
    }    
    
    
    public boolean getNotes()    {
        return printSetupRecord.getNotes();
    }    
    
    
    public boolean getNoOrientation()    {
        return printSetupRecord.getNoOrientation();
    }    
    
    
    public boolean getUsePage()    {
        return printSetupRecord.getUsePage();
    }    
    
    
    public short getHResolution()    {
        return printSetupRecord.getHResolution();
    }    
    
    
    public short getVResolution()    {
        return printSetupRecord.getVResolution();
    }    
    
    
    public double getHeaderMargin()    {
        return printSetupRecord.getHeaderMargin();
    }    
    
    
    public double getFooterMargin()    {
        return printSetupRecord.getFooterMargin();
    }    
    
    
    public short getCopies()    {
        return printSetupRecord.getCopies();
    }
}
"
poi,3,org.apache.poi.util.SystemOutLogger,4,2,0,1,12,4,0,1,4,0.666666667,44,1.0,0,0.888888889,0.5,1,1,9.75,2,1.25,2,"

package org.apache.poi.util;




public class SystemOutLogger extends POILogger
{
    private String _cat;

    public void initialize(final String cat)
    {
       this._cat=cat;
    }

    

    public void log(final int level, final Object obj1)
    {
    	log(level, obj1, null);
    }

    
    public void log(final int level, final Object obj1,
                    final Throwable exception) {
        if (check(level)) {
            System.out.println(""["" + _cat + ""]"" + LEVEL_STRINGS_SHORT[Math.min(LEVEL_STRINGS_SHORT.length-1, level)] + "" "" + obj1);
            if (exception != null) {
            	exception.printStackTrace(System.out);
            }
        }
    }

    
    public boolean check(final int level)
    {
        int currentLevel;
        try {
            currentLevel = Integer.parseInt(System.getProperty(""poi.log.level"", WARN + """"));
        } catch (SecurityException e) {
            currentLevel = POILogger.DEBUG;
        }

        if (level >= currentLevel) {
            return true;
        }
        return false;
    }


}   

"
poi,3,org.apache.poi.poifs.filesystem.DocumentOutputStream,8,2,0,3,15,4,3,0,5,0.428571429,90,1.0,0,0.416666667,0.425,1,1,9.875,1,0.875,1,"

package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;



public final class DocumentOutputStream extends OutputStream {
    private final OutputStream _stream;
    private final int          _limit;
    private int          _written;

    
    DocumentOutputStream(OutputStream stream, int limit) {
        _stream  = stream;
        _limit   = limit;
        _written = 0;
    }

    
    public void write(int b)
        throws IOException
    {
        limitCheck(1);
        _stream.write(b);
    }

    
    public void write(byte b[])
        throws IOException
    {
        write(b, 0, b.length);
    }

    
    public void write(byte b[], int off, int len)
        throws IOException
    {
        limitCheck(len);
        _stream.write(b, off, len);
    }

    
    public void flush()
        throws IOException
    {
        _stream.flush();
    }

    
    public void close() {

        
    }

    
    void writeFiller(int totalLimit, byte fill)
        throws IOException
    {
        if (totalLimit > _written)
        {
            byte[] filler = new byte[ totalLimit - _written ];

            Arrays.fill(filler, fill);
            _stream.write(filler);
        }
    }

    private void limitCheck(int toBeWritten)
        throws IOException
    {
        if ((_written + toBeWritten) > _limit)
        {
            throw new IOException(""tried to write too much data"");
        }
        _written += toBeWritten;
    }
}
"
poi,3,org.apache.poi.poifs.storage.BATBlock,12,2,0,6,18,54,4,2,8,0.924242424,222,1.0,1,0.230769231,0.3125,1,2,17.0,5,1.3333,1,"

package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.LittleEndian;


public final class BATBlock extends BigBlock {
    
    private int[] _values;
    
    
    private boolean _has_free_sectors;
    
    
    private int ourBlockIndex;
    
    
    private BATBlock(POIFSBigBlockSize bigBlockSize)
    {
        super(bigBlockSize);
        
        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        _values = new int[_entries_per_block];
        _has_free_sectors = true;

        Arrays.fill(_values, POIFSConstants.UNUSED_BLOCK);
    }

    

    private BATBlock(POIFSBigBlockSize bigBlockSize, final int [] entries,
                     final int start_index, final int end_index)
    {
        this(bigBlockSize);
        for (int k = start_index; k < end_index; k++) {
           _values[k - start_index] = entries[k];
        }
        
        
        if(end_index - start_index == _values.length) {
           recomputeFree();
        }
    }
    
    private void recomputeFree() {
       boolean hasFree = false;
       for(int k=0; k<_values.length; k++) {
          if(_values[k] == POIFSConstants.UNUSED_BLOCK) {
             hasFree = true;
             break;
          }
       }
       _has_free_sectors = hasFree;
    }

    
    public static BATBlock createBATBlock(final POIFSBigBlockSize bigBlockSize, ByteBuffer data)
    {
       
       BATBlock block = new BATBlock(bigBlockSize);
       
       
       byte[] buffer = new byte[LittleEndian.INT_SIZE];
       for(int i=0; i<block._values.length; i++) {
          data.get(buffer);
          block._values[i] = LittleEndian.getInt(buffer);
       }
       block.recomputeFree();
       
       
       return block;
    }
    
    
    public static BATBlock createEmptyBATBlock(final POIFSBigBlockSize bigBlockSize, boolean isXBAT) {
       BATBlock block = new BATBlock(bigBlockSize);
       if(isXBAT) {
          block.setXBATChain(bigBlockSize, POIFSConstants.END_OF_CHAIN);
       }
       return block;
    }

    
    public static BATBlock [] createBATBlocks(final POIFSBigBlockSize bigBlockSize, final int [] entries)
    {
        int        block_count = calculateStorageRequirements(bigBlockSize, entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        for (int j = 0; j < entries.length; j += _entries_per_block)
        {
            blocks[ index++ ] = new BATBlock(bigBlockSize, entries, j,
                                             (remaining > _entries_per_block)
                                             ? j + _entries_per_block
                                             : entries.length);
            remaining         -= _entries_per_block;
        }
        return blocks;
    }
    
    

    public static BATBlock [] createXBATBlocks(final POIFSBigBlockSize bigBlockSize,
                                               final int [] entries,
                                               final int startBlock)
    {
        int        block_count =
            calculateXBATStorageRequirements(bigBlockSize, entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        if (block_count != 0)
        {
            for (int j = 0; j < entries.length; j += _entries_per_xbat_block)
            {
                blocks[ index++ ] =
                    new BATBlock(bigBlockSize, entries, j,
                                 (remaining > _entries_per_xbat_block)
                                 ? j + _entries_per_xbat_block
                                 : entries.length);
                remaining         -= _entries_per_xbat_block;
            }
            for (index = 0; index < blocks.length - 1; index++)
            {
                blocks[ index ].setXBATChain(bigBlockSize, startBlock + index + 1);
            }
            blocks[ index ].setXBATChain(bigBlockSize, POIFSConstants.END_OF_CHAIN);
        }
        return blocks;
    }

    
    public static int calculateStorageRequirements(final POIFSBigBlockSize bigBlockSize, final int entryCount)
    {
        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        return (entryCount + _entries_per_block - 1) / _entries_per_block;
    }

    
    public static int calculateXBATStorageRequirements(final POIFSBigBlockSize bigBlockSize, final int entryCount)
    {
        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        return (entryCount + _entries_per_xbat_block - 1)
               / _entries_per_xbat_block;
    }
    
    
    public static long calculateMaximumSize(final POIFSBigBlockSize bigBlockSize,
          final int numBATs) {
       long size = 1; 
       
       
       
       
       size += (numBATs * bigBlockSize.getBATEntriesPerBlock());
       
       
       return size * bigBlockSize.getBigBlockSize();
    }
    public static long calculateMaximumSize(final HeaderBlock header)
    {
       return calculateMaximumSize(header.getBigBlockSize(), header.getBATCount());
    }

    
    public static BATBlockAndIndex getBATBlockAndIndex(final int offset, 
                final HeaderBlock header, final List<BATBlock> bats) {
       POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();
       
       int whichBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());
       int index = offset % bigBlockSize.getBATEntriesPerBlock();
       return new BATBlockAndIndex( index, bats.get(whichBAT) );
    }
    
    
    public static BATBlockAndIndex getSBATBlockAndIndex(final int offset, 
          final HeaderBlock header, final List<BATBlock> sbats) {
       POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();
       
       
       int whichSBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());
       int index = offset % bigBlockSize.getBATEntriesPerBlock();
       return new BATBlockAndIndex( index, sbats.get(whichSBAT) );
    }
    
    private void setXBATChain(final POIFSBigBlockSize bigBlockSize, int chainIndex)
    {
        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        _values[ _entries_per_xbat_block ] = chainIndex;
    }
    
    
    public boolean hasFreeSectors() {
       return _has_free_sectors;
    }
    
    public int getUsedSectors(boolean isAnXBAT) {
        int usedSectors = 0;
        int toCheck = _values.length;
        if (isAnXBAT) toCheck--; 
        for(int k=0; k<toCheck; k++) {
            if(_values[k] != POIFSConstants.UNUSED_BLOCK) {
                usedSectors ++;
            }
        }
        return usedSectors;
    }
    
    public int getValueAt(int relativeOffset) {
       if(relativeOffset >= _values.length) {
          throw new ArrayIndexOutOfBoundsException(
                ""Unable to fetch offset "" + relativeOffset + "" as the "" + 
                ""BAT only contains "" + _values.length + "" entries""
          ); 
       }
       return _values[relativeOffset];
    }
    public void setValueAt(int relativeOffset, int value) {
       int oldValue = _values[relativeOffset];
       _values[relativeOffset] = value;
       
       
       if(value == POIFSConstants.UNUSED_BLOCK) {
          _has_free_sectors = true;
          return;
       }
       if(oldValue == POIFSConstants.UNUSED_BLOCK) {
          recomputeFree();
       }
    }
    
    
    public void setOurBlockIndex(int index) {
       this.ourBlockIndex = index;
    }
    
    public int getOurBlockIndex() {
       return ourBlockIndex;
    }


    

   
    void writeData(final OutputStream stream)
        throws IOException
    {
       
       stream.write( serialize() );
    }
    
    void writeData(final ByteBuffer block)
        throws IOException
    {
       
       block.put( serialize() );
    }
    
    private byte[] serialize() {
       
       byte[] data = new byte[ bigBlockSize.getBigBlockSize() ];
       
       
       int offset = 0;
       for(int i=0; i<_values.length; i++) {
          LittleEndian.putInt(data, offset, _values[i]);
          offset += LittleEndian.INT_SIZE;
       }
       
       
       return data;
    }

    
    
    
    public static class BATBlockAndIndex {
       private final int index;
       private final BATBlock block;
       private BATBlockAndIndex(int index, BATBlock block) {
          this.index = index;
          this.block = block;
       }
       public int getIndex() {
          return index;
       }
       public BATBlock getBlock() {
          return block;
       }
    }
}

"
poi,3,org.apache.poi.ddf.EscherBSERecord,33,2,0,9,63,326,2,7,33,0.940217391,684,0.565217391,1,0.37254902,0.200757576,1,5,19.03030303,7,1.303,2,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public final class EscherBSERecord extends EscherRecord {
    public static final short RECORD_ID = (short) 0xF007;
    public static final String RECORD_DESCRIPTION = ""MsofbtBSE"";

    public static final byte BT_ERROR = 0;
    public static final byte BT_UNKNOWN = 1;
    public static final byte BT_EMF = 2;
    public static final byte BT_WMF = 3;
    public static final byte BT_PICT = 4;
    public static final byte BT_JPEG = 5;
    public static final byte BT_PNG = 6;
    public static final byte BT_DIB = 7;

    private byte field_1_blipTypeWin32;
    private byte field_2_blipTypeMacOS;
    private byte[] field_3_uid;  
    private short field_4_tag;
    private int field_5_size;
    private int field_6_ref;
    private int field_7_offset;
    private byte field_8_usage;
    private byte field_9_name;
    private byte field_10_unused2;
    private byte field_11_unused3;
    private EscherBlipRecord field_12_blipRecord;

    private byte[] _remainingData;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
        int pos = offset + 8;
        field_1_blipTypeWin32 = data[pos];
        field_2_blipTypeMacOS = data[pos + 1];
        System.arraycopy( data, pos + 2, field_3_uid = new byte[16], 0, 16 );
        field_4_tag = LittleEndian.getShort( data, pos + 18 );
        field_5_size = LittleEndian.getInt( data, pos + 20 );
        field_6_ref = LittleEndian.getInt( data, pos + 24 );
        field_7_offset = LittleEndian.getInt( data, pos + 28 );
        field_8_usage = data[pos + 32];
        field_9_name = data[pos + 33];
        field_10_unused2 = data[pos + 34];
        field_11_unused3 = data[pos + 35];
        bytesRemaining -= 36;

        int bytesRead = 0;
        if (bytesRemaining > 0) {
            
            field_12_blipRecord = (EscherBlipRecord) recordFactory.createRecord( data, pos + 36 );
            bytesRead = field_12_blipRecord.fillFields( data, pos + 36, recordFactory );
        }
        pos += 36 + bytesRead;
        bytesRemaining -= bytesRead;

        _remainingData = new byte[bytesRemaining];
        System.arraycopy( data, pos, _remainingData, 0, bytesRemaining );
        return bytesRemaining + 8 + 36 + (field_12_blipRecord == null ? 0 : field_12_blipRecord.getRecordSize()) ;

    }

    public int serialize(int offset, byte[] data, EscherSerializationListener listener) {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        if (_remainingData == null)
            _remainingData = new byte[0];

        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );
        if (_remainingData == null) _remainingData = new byte[0];
        int blipSize = field_12_blipRecord == null ? 0 : field_12_blipRecord.getRecordSize();
        int remainingBytes = _remainingData.length + 36 + blipSize;
        LittleEndian.putInt( data, offset + 4, remainingBytes );

        data[offset + 8] = field_1_blipTypeWin32;
        data[offset + 9] = field_2_blipTypeMacOS;
        for ( int i = 0; i < 16; i++ )
            data[offset + 10 + i] = field_3_uid[i];
        LittleEndian.putShort( data, offset + 26, field_4_tag );
        LittleEndian.putInt( data, offset + 28, field_5_size );
        LittleEndian.putInt( data, offset + 32, field_6_ref );
        LittleEndian.putInt( data, offset + 36, field_7_offset );
        data[offset + 40] = field_8_usage;
        data[offset + 41] = field_9_name;
        data[offset + 42] = field_10_unused2;
        data[offset + 43] = field_11_unused3;
        int bytesWritten = 0;
        if (field_12_blipRecord != null)
        {
            bytesWritten = field_12_blipRecord.serialize( offset + 44, data, new NullEscherSerializationListener() );
        }
        if (_remainingData == null)
            _remainingData = new byte[0];
        System.arraycopy( _remainingData, 0, data, offset + 44 + bytesWritten, _remainingData.length );
        int pos = offset + 8 + 36 + _remainingData.length + bytesWritten;

        listener.afterRecordSerialize(pos, getRecordId(), pos - offset, this);
        return pos - offset;
    }

    public int getRecordSize() {
        int field_12_size = 0;
        if(field_12_blipRecord != null) {
            field_12_size = field_12_blipRecord.getRecordSize();
        }
        int remaining_size = 0;
        if(_remainingData != null) {
            remaining_size = _remainingData.length;
        }
        return 8 + 1 + 1 + 16 + 2 + 4 + 4 + 4 + 1 + 1 +
            1 + 1 + field_12_size + remaining_size;
    }

    public String getRecordName() {
        return ""BSE"";
    }

    
    public byte getBlipTypeWin32() {
        return field_1_blipTypeWin32;
    }

    
    public void setBlipTypeWin32(byte blipTypeWin32) {
        field_1_blipTypeWin32 = blipTypeWin32;
    }

    
    public byte getBlipTypeMacOS() {
        return field_2_blipTypeMacOS;
    }

    
    public void setBlipTypeMacOS(byte blipTypeMacOS) {
        field_2_blipTypeMacOS = blipTypeMacOS;
    }

    
    public byte[] getUid() {
        return field_3_uid;
    }

    
    public void setUid(byte[] uid) {
        field_3_uid = uid;
    }

    
    public short getTag() {
        return field_4_tag;
    }

    
    public void setTag(short tag) {
        field_4_tag = tag;
    }

    
    public int getSize() {
        return field_5_size;
    }

    
    public void setSize(int size) {
        field_5_size = size;
    }

    
    public int getRef() {
        return field_6_ref;
    }

    
    public void setRef(int ref) {
        field_6_ref = ref;
    }

    
    public int getOffset() {
        return field_7_offset;
    }

    
    public void setOffset(int offset) {
        field_7_offset = offset;
    }

    
    public byte getUsage() {
        return field_8_usage;
    }

    
    public void setUsage(byte usage) {
        field_8_usage = usage;
    }

    
    public byte getName() {
        return field_9_name;
    }

    
    public void setName(byte name) {
        field_9_name = name;
    }

    public byte getUnused2() {
        return field_10_unused2;
    }

    public void setUnused2(byte unused2) {
        field_10_unused2 = unused2;
    }

    public byte getUnused3() {
        return field_11_unused3;
    }

    public void setUnused3(byte unused3) {
        field_11_unused3 = unused3;
    }

    public EscherBlipRecord getBlipRecord() {
        return field_12_blipRecord;
    }

    public void setBlipRecord(EscherBlipRecord blipRecord) {
        field_12_blipRecord = blipRecord;
    }

    
    public byte[] getRemainingData() {
        return _remainingData;
    }

    
    public void setRemainingData(byte[] remainingData) {
        _remainingData = remainingData;
    }

    public String toString() {
        String extraData = _remainingData == null ? null : HexDump.toHex(_remainingData, 32);
        return getClass().getName() + "":"" + '
' +
                ""  RecordId: 0x"" + HexDump.toHex( RECORD_ID ) + '
' +
                ""  Version: 0x"" + HexDump.toHex( getVersion() ) + '
' +
                ""  Instance: 0x"" + HexDump.toHex( getInstance() ) + '
' +
                ""  BlipTypeWin32: "" + field_1_blipTypeWin32 + '
' +
                ""  BlipTypeMacOS: "" + field_2_blipTypeMacOS + '
' +
                ""  SUID: "" + (field_3_uid == null ? """" : HexDump.toHex(field_3_uid)) + '
' +
                ""  Tag: "" + field_4_tag + '
' +
                ""  Size: "" + field_5_size + '
' +
                ""  Ref: "" + field_6_ref + '
' +
                ""  Offset: "" + field_7_offset + '
' +
                ""  Usage: "" + field_8_usage + '
' +
                ""  Name: "" + field_9_name + '
' +
                ""  Unused2: "" + field_10_unused2 + '
' +
                ""  Unused3: "" + field_11_unused3 + '
' +
                ""  blipRecord: "" + field_12_blipRecord + '
' +
                ""  Extra Data:"" + '
' + extraData;
    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<BlipTypeWin32>"").append(field_1_blipTypeWin32).append(""</BlipTypeWin32>
"")
                .append(tab).append(""	"").append(""<BlipTypeMacOS>"").append(field_2_blipTypeMacOS).append(""</BlipTypeMacOS>
"")
                .append(tab).append(""	"").append(""<SUID>"").append(field_3_uid == null ? """" : HexDump.toHex(field_3_uid)).append(""</SUID>
"")
                .append(tab).append(""	"").append(""<Tag>"").append(field_4_tag).append(""</Tag>
"")
                .append(tab).append(""	"").append(""<Size>"").append(field_5_size).append(""</Size>
"")
                .append(tab).append(""	"").append(""<Ref>"").append(field_6_ref).append(""</Ref>
"")
                .append(tab).append(""	"").append(""<Offset>"").append(field_7_offset).append(""</Offset>
"")
                .append(tab).append(""	"").append(""<Usage>"").append(field_8_usage).append(""</Usage>
"")
                .append(tab).append(""	"").append(""<Name>"").append(field_9_name).append(""</Name>
"")
                .append(tab).append(""	"").append(""<Unused2>"").append(field_10_unused2).append(""</Unused2>
"")
                .append(tab).append(""	"").append(""<Unused3>"").append(field_11_unused3).append(""</Unused3>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public static String getBlipType(byte b) {
        switch (b) {
            case BT_ERROR:   return "" ERROR"";
            case BT_UNKNOWN: return "" UNKNOWN"";
            case BT_EMF:     return "" EMF"";
            case BT_WMF:     return "" WMF"";
            case BT_PICT:    return "" PICT"";
            case BT_JPEG:    return "" JPEG"";
            case BT_PNG:     return "" PNG"";
            case BT_DIB:     return "" DIB"";
        }
        if ( b < 32 ) {
            return "" NotKnown"";
        }
        return "" Client"";
    }
}
"
poi,3,org.apache.poi.util.LittleEndianConsts,0,1,0,1,0,0,1,0,0,2.0,5,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

        

package org.apache.poi.util;



public interface LittleEndianConsts
{

    
    public static final int BYTE_SIZE   = 1;
    public static final int SHORT_SIZE  = 2;
    public static final int INT_SIZE    = 4;
    public static final int LONG_SIZE   = 8;
    public static final int DOUBLE_SIZE = 8;
}   

"
poi,3,org.apache.poi.hssf.record.MMSRecord,12,2,0,6,21,54,2,4,10,0.787878788,122,0.666666667,0,0.523809524,0.263888889,1,4,8.916666667,2,0.9167,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class MMSRecord
    extends StandardRecord
{
    public final static short sid = 0xC1;
    private byte              field_1_addMenuCount;   
    private byte              field_2_delMenuCount;   

    public MMSRecord()
    {
    }

    public MMSRecord(RecordInputStream in)
    {
        if (in.remaining()==0) {
            return;
        }
        
        field_1_addMenuCount = in.readByte();
        field_2_delMenuCount = in.readByte();
    }

    

    public void setAddMenuCount(byte am)
    {
        field_1_addMenuCount = am;
    }

    

    public void setDelMenuCount(byte dm)
    {
        field_2_delMenuCount = dm;
    }

    

    public byte getAddMenuCount()
    {
        return field_1_addMenuCount;
    }

    

    public byte getDelMenuCount()
    {
        return field_2_delMenuCount;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[MMS]
"");
        buffer.append(""    .addMenu        = "")
            .append(Integer.toHexString(getAddMenuCount())).append(""
"");
        buffer.append(""    .delMenu        = "")
            .append(Integer.toHexString(getDelMenuCount())).append(""
"");
        buffer.append(""[/MMS]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeByte(getAddMenuCount());
        out.writeByte(getDelMenuCount());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.HeaderRecord,14,2,0,9,30,55,4,5,12,0.753846154,258,0.8,0,0.47826087,0.214285714,1,4,17.07142857,5,1.6429,2,"

package org.apache.poi.hssf.record;


public final class HeaderRecord extends HeaderFooterBase {
	public final static short sid = 0x0014;

	public HeaderRecord(String text) {
		super(text);
	}

	public HeaderRecord(RecordInputStream in) {
		super(in);
	}

	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[HEADER]
"");
		buffer.append(""    .header = "").append(getText()).append(""
"");
		buffer.append(""[/HEADER]
"");
		return buffer.toString();
	}

	public short getSid() {
		return sid;
	}

	public Object clone() {
		return new HeaderRecord(getText());
	}
}
"
poi,3,org.apache.poi.hssf.record.StringRecord,15,2,0,10,32,53,5,5,12,0.714285714,209,0.75,0,0.458333333,0.20952381,1,4,12.66666667,2,1.2667,3,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.cont.ContinuableRecord;
import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;
import org.apache.poi.util.StringUtil;


public final class StringRecord extends ContinuableRecord {

	public final static short sid = 0x0207;

	private boolean _is16bitUnicode;
	private String _text;


    public StringRecord()
    {
    }

    
    public StringRecord( RecordInputStream in) {
        int field_1_string_length           = in.readUShort();
        _is16bitUnicode            = in.readByte() != 0x00;
        
        if (_is16bitUnicode){
            _text = in.readUnicodeLEString(field_1_string_length);
        } else {
            _text = in.readCompressedUnicode(field_1_string_length);
        }
    }


    protected void serialize(ContinuableRecordOutput out) {
        out.writeShort(_text.length());
        out.writeStringData(_text);
    }


    public short getSid()
    {
        return sid;
    }

    
    public String getString()
    {
        return _text;
    }


    
    public void setString(String string) {
        _text = string;
        _is16bitUnicode = StringUtil.hasMultibyte(string);        
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[STRING]
"");
        buffer.append(""    .string            = "")
            .append(_text).append(""
"");
        buffer.append(""[/STRING]
"");
        return buffer.toString();
    }
    
    public Object clone() {
        StringRecord rec = new StringRecord();
        rec._is16bitUnicode= _is16bitUnicode;
        rec._text = _text;
        return rec;
    }
}
"
poi,3,org.apache.poi.hssf.eventusermodel.HSSFEventFactory,6,1,0,9,15,15,1,8,5,2.0,128,0.0,0,0.0,0.533333333,0,0,20.33333333,1,0.8333,4,"

package org.apache.poi.hssf.eventusermodel;

import java.io.InputStream;
import java.io.IOException;
import java.util.Set;

import org.apache.poi.hssf.eventusermodel.HSSFUserException;
import org.apache.poi.hssf.record.*;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;


public class HSSFEventFactory {
	
	public HSSFEventFactory() {
		
	}

	
	public void processWorkbookEvents(HSSFRequest req, POIFSFileSystem fs) throws IOException {
	   processWorkbookEvents(req, fs.getRoot());
	}

   
    public void processWorkbookEvents(HSSFRequest req, DirectoryNode dir) throws IOException {
        
        final String name;
        Set<String> entryNames = dir.getEntryNames();
        if (entryNames.contains(""Workbook"")) {
            name = ""Workbook"";
        } else if (entryNames.contains(""WORKBOOK"")) {
            name = ""WORKBOOK"";
        } else if (entryNames.contains(""BOOK"")) {
            name = ""BOOK"";
        } else {
            name = ""Workbook"";
        }

        InputStream in = dir.createDocumentInputStream(name);

        processEvents(req, in);
    }

   
   public short abortableProcessWorkbookEvents(HSSFRequest req, POIFSFileSystem fs)
      throws IOException, HSSFUserException {
      return abortableProcessWorkbookEvents(req, fs.getRoot());
   }

	
	public short abortableProcessWorkbookEvents(HSSFRequest req, DirectoryNode dir)
		throws IOException, HSSFUserException {
		InputStream in = dir.createDocumentInputStream(""Workbook"");
		return abortableProcessEvents(req, in);
	}

	
	public void processEvents(HSSFRequest req, InputStream in) {
		try {
			genericProcessEvents(req, in);
		} catch (HSSFUserException hue) {
			
		}
	}


	
	public short abortableProcessEvents(HSSFRequest req, InputStream in)
		throws HSSFUserException {
		return genericProcessEvents(req, in);
	}

	
	private short genericProcessEvents(HSSFRequest req, InputStream in)
		throws HSSFUserException {
		short userCode = 0;

		
		RecordFactoryInputStream recordStream = new RecordFactoryInputStream(in, false);

		
		while(true) {
			Record r = recordStream.nextRecord();
			if(r == null) {
				break;
			}
			userCode = req.processRecord(r);
			if (userCode != 0) {
				break;
			}
		}

		
		return userCode;
	}
}
"
poi,3,org.apache.poi.hssf.model.WorkbookRecordList,28,1,0,2,35,198,1,1,28,0.841750842,388,1.0,0,0.0,0.383928571,0,0,12.46428571,12,1.75,1,"

package org.apache.poi.hssf.model;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.hssf.record.Record;

public final class WorkbookRecordList implements Iterable<Record> {
    private List<Record> records = new ArrayList<Record>();

	private int  protpos	 = 0;   
	private int  bspos	   = 0;   
	private int  tabpos	  = 0;   
	private int  fontpos	 = 0;   
	private int  xfpos	   = 0;   
	private int  backuppos   = 0;   
	private int  namepos	 = 0;   
	private int  supbookpos  = 0;   
	private int  externsheetPos = 0;
	private int  palettepos  = -1;   


	public void setRecords(List<Record> records) {
		this.records = records;
	}

	public int size() {
		return records.size();
	}

	public Record get(int i) {
		return records.get(i);
	}

	public void add(int pos, Record r) {
		records.add(pos, r);
		if (getProtpos() >= pos) setProtpos( protpos + 1 );
		if (getBspos() >= pos) setBspos( bspos + 1 );
		if (getTabpos() >= pos) setTabpos( tabpos + 1 );
		if (getFontpos() >= pos) setFontpos( fontpos + 1 );
		if (getXfpos() >= pos) setXfpos( xfpos + 1 );
		if (getBackuppos() >= pos) setBackuppos( backuppos + 1 );
		if (getNamepos() >= pos) setNamepos(namepos+1);
		if (getSupbookpos() >= pos) setSupbookpos(supbookpos+1);
		if ((getPalettepos() != -1) && (getPalettepos() >= pos)) setPalettepos( palettepos + 1 );
		if (getExternsheetPos() >= pos) setExternsheetPos(getExternsheetPos() + 1);
	}

	public List<Record> getRecords() {
		return records;
	}

	public Iterator<Record> iterator() {
		return records.iterator();
	}

	
	public void remove( Object record ) {
	   
	   int i = 0;
	   for (Record r : records) {
	       if (r == record) {
	           remove(i);
	           break;
	       }
	       i++;
	   }
	}

	public void remove( int pos )
	{
		records.remove(pos);
		if (getProtpos() >= pos) setProtpos( protpos - 1 );
		if (getBspos() >= pos) setBspos( bspos - 1 );
		if (getTabpos() >= pos) setTabpos( tabpos - 1 );
		if (getFontpos() >= pos) setFontpos( fontpos - 1 );
		if (getXfpos() >= pos) setXfpos( xfpos - 1 );
		if (getBackuppos() >= pos) setBackuppos( backuppos - 1 );
		if (getNamepos() >= pos) setNamepos(getNamepos()-1);
		if (getSupbookpos() >= pos) setSupbookpos(getSupbookpos()-1);
		if ((getPalettepos() != -1) && (getPalettepos() >= pos)) setPalettepos( palettepos - 1 );
		if (getExternsheetPos() >= pos) setExternsheetPos( getExternsheetPos() -1);
	}

	public int getProtpos() {
		return protpos;
	}

	public void setProtpos(int protpos) {
		this.protpos = protpos;
	}

	public int getBspos() {
		return bspos;
	}

	public void setBspos(int bspos) {
		this.bspos = bspos;
	}

	public int getTabpos() {
		return tabpos;
	}

	public void setTabpos(int tabpos) {
		this.tabpos = tabpos;
	}

	public int getFontpos() {
		return fontpos;
	}

	public void setFontpos(int fontpos) {
		this.fontpos = fontpos;
	}

	public int getXfpos() {
		return xfpos;
	}

	public void setXfpos(int xfpos) {
		this.xfpos = xfpos;
	}

	public int getBackuppos() {
		return backuppos;
	}

	public void setBackuppos(int backuppos) {
		this.backuppos = backuppos;
	}

	public int getPalettepos() {
		return palettepos;
	}

	public void setPalettepos(int palettepos) {
		this.palettepos = palettepos;
	}

	
	
	public int getNamepos() {
		return namepos;
	}

	
	public int getSupbookpos() {
		return supbookpos;
	}

	
	public void setNamepos(int namepos) {
		this.namepos = namepos;
	}

	
	public void setSupbookpos(int supbookpos) {
		this.supbookpos = supbookpos;
	}

	
	public int getExternsheetPos() {
		return externsheetPos;
	}

	
	public void setExternsheetPos(int externsheetPos) {
		this.externsheetPos = externsheetPos;
	}
}
"
poi,3,org.apache.poi.hssf.record.BOFRecord,21,2,0,8,33,148,4,4,19,0.944117647,286,0.352941176,0,0.366666667,0.304761905,1,4,11.80952381,2,0.9524,3,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class BOFRecord extends StandardRecord {
    
    public final static short sid = 0x809;
    
    public final static short biff2_sid = 0x009;
    public final static short biff3_sid = 0x209;
    public final static short biff4_sid = 0x409;
    public final static short biff5_sid = 0x809;

    
    public final static int VERSION             = 0x0600;
    
    public final static int BUILD               = 0x10d3;
    
    public final static int BUILD_YEAR          = 0x07CC;   
    
    public final static int HISTORY_MASK        = 0x41;

    public final static int TYPE_WORKBOOK       = 0x05;
    public final static int TYPE_VB_MODULE      = 0x06;
    public final static int TYPE_WORKSHEET      = 0x10;
    public final static int TYPE_CHART          = 0x20;
    public final static int TYPE_EXCEL_4_MACRO  = 0x40;
    public final static int TYPE_WORKSPACE_FILE = 0x100;

    private int field_1_version;
    private int field_2_type;
    private int field_3_build;
    private int field_4_year;
    private int field_5_history;
    private int field_6_rversion;

    
    public BOFRecord() {
    }
    
    private BOFRecord(int type) {
        field_1_version = VERSION;
        field_2_type = type;
        field_3_build = BUILD;
        field_4_year = BUILD_YEAR;
        field_5_history = 0x01;
        field_6_rversion = VERSION;
    }
    
    public static BOFRecord createSheetBOF() {
        return new BOFRecord(TYPE_WORKSHEET);
    }

    public BOFRecord(RecordInputStream in) {
        field_1_version  = in.readShort();
        field_2_type     = in.readShort();

        
        
        if (in.remaining() >= 2) {
            field_3_build = in.readShort();
        }
        if (in.remaining() >= 2) {
            field_4_year = in.readShort();
        }
        if (in.remaining() >= 4) {
            field_5_history  = in.readInt();
        }
        if (in.remaining() >= 4) {
            field_6_rversion = in.readInt();
        }
    }

    
    public void setVersion(int version) {
        field_1_version = version;
    }

    
    public void setType(int type) {
        field_2_type = type;
    }

    
    public void setBuild(int build) {
        field_3_build = build;
    }

    
    public void setBuildYear(int year) {
        field_4_year = year;
    }

    
    public void setHistoryBitMask(int bitmask) {
        field_5_history = bitmask;
    }

    
    public void setRequiredVersion(int version) {
        field_6_rversion = version;
    }

    
    public int getVersion() {
        return field_1_version;
    }

    
    public int getType() {
        return field_2_type;
    }

    
    public int getBuild() {
        return field_3_build;
    }

    
    public int getBuildYear() {
        return field_4_year;
    }

    
    public int getHistoryBitMask() {
        return field_5_history;
    }

    
    public int getRequiredVersion() {
        return field_6_rversion;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BOF RECORD]
"");
        buffer.append(""    .version  = "").append(HexDump.shortToHex(getVersion())).append(""
"");
        buffer.append(""    .type     = "").append(HexDump.shortToHex(getType()));
        buffer.append("" ("").append(getTypeName()).append("")"").append(""
"");
        buffer.append(""    .build    = "").append(HexDump.shortToHex(getBuild())).append(""
"");
        buffer.append(""    .buildyear= "").append(getBuildYear()).append(""
"");
        buffer.append(""    .history  = "").append(HexDump.intToHex(getHistoryBitMask())).append(""
"");
        buffer.append(""    .reqver   = "").append(HexDump.intToHex(getRequiredVersion())).append(""
"");
        buffer.append(""[/BOF RECORD]
"");
        return buffer.toString();
    }

    private String getTypeName() {
        switch(field_2_type) {
            case TYPE_CHART: return ""chart"";
            case TYPE_EXCEL_4_MACRO: return ""excel 4 macro"";
            case TYPE_VB_MODULE: return ""vb module"";
            case TYPE_WORKBOOK: return ""workbook"";
            case TYPE_WORKSHEET: return ""worksheet"";
            case TYPE_WORKSPACE_FILE: return ""workspace file"";
        }
        return ""#error unknown type#"";
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getVersion());
        out.writeShort(getType());
        out.writeShort(getBuild());
        out.writeShort(getBuildYear());
        out.writeInt(getHistoryBitMask());
        out.writeInt(getRequiredVersion());
    }

    protected int getDataSize() {
        return 16;
    }

    public short getSid(){
        return sid;
    }

    public Object clone() {
      BOFRecord rec = new BOFRecord();
      rec.field_1_version = field_1_version;
      rec.field_2_type = field_2_type;
      rec.field_3_build = field_3_build;
      rec.field_4_year = field_4_year;
      rec.field_5_history = field_5_history;
      rec.field_6_rversion = field_6_rversion;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.PrintSetupRecord,48,2,0,10,64,616,4,6,45,0.9,667,0.95,8,0.196428571,0.215805471,1,4,12.47916667,2,0.9583,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.ss.usermodel.PrintSetup;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;


public final class PrintSetupRecord extends StandardRecord {
    public final static short     sid = 0x00A1;
    
    private short                 field_1_paper_size;
    private short                 field_2_scale;
    private short                 field_3_page_start;
    private short                 field_4_fit_width;
    private short                 field_5_fit_height;
    private short                 field_6_options;
    static final private BitField lefttoright   =
        BitFieldFactory.getInstance(0x01);   
    static final private BitField landscape     =
        BitFieldFactory.getInstance(0x02);   
    static final private BitField validsettings = BitFieldFactory.getInstance(
        0x04);                

    
    
    static final private BitField nocolor       =
        BitFieldFactory.getInstance(0x08);   
    static final private BitField draft         =
        BitFieldFactory.getInstance(0x10);   
    static final private BitField notes         =
        BitFieldFactory.getInstance(0x20);   
    static final private BitField noOrientation =
        BitFieldFactory.getInstance(0x40);   
    static final private BitField usepage       =
        BitFieldFactory.getInstance(0x80);   
    private short                 field_7_hresolution;
    private short                 field_8_vresolution;
    private double                field_9_headermargin;
    private double                field_10_footermargin;
    private short                 field_11_copies;

    public PrintSetupRecord()
    {
    }

    public PrintSetupRecord(RecordInputStream in)
    {
        field_1_paper_size    = in.readShort();
        field_2_scale         = in.readShort();
        field_3_page_start    = in.readShort();
        field_4_fit_width     = in.readShort();
        field_5_fit_height    = in.readShort();
        field_6_options       = in.readShort();
        field_7_hresolution   = in.readShort();
        field_8_vresolution   = in.readShort();
        field_9_headermargin  = in.readDouble();
        field_10_footermargin = in.readDouble();
        field_11_copies       = in.readShort();
    }

    public void setPaperSize(short size)
    {
        field_1_paper_size = size;
    }

    public void setScale(short scale)
    {
        field_2_scale = scale;
    }

    public void setPageStart(short start)
    {
        field_3_page_start = start;
    }

    public void setFitWidth(short width)
    {
        field_4_fit_width = width;
    }

    public void setFitHeight(short height)
    {
        field_5_fit_height = height;
    }

    public void setOptions(short options)
    {
        field_6_options = options;
    }

    
    public void setLeftToRight(boolean ltor)
    {
        field_6_options = lefttoright.setShortBoolean(field_6_options, ltor);
    }

    public void setLandscape(boolean ls)
    {
        field_6_options = landscape.setShortBoolean(field_6_options, ls);
    }

    public void setValidSettings(boolean valid)
    {
        field_6_options = validsettings.setShortBoolean(field_6_options, valid);
    }

    public void setNoColor(boolean mono)
    {
        field_6_options = nocolor.setShortBoolean(field_6_options, mono);
    }

    public void setDraft(boolean d)
    {
        field_6_options = draft.setShortBoolean(field_6_options, d);
    }

    public void setNotes(boolean printnotes)
    {
        field_6_options = notes.setShortBoolean(field_6_options, printnotes);
    }

    public void setNoOrientation(boolean orientation)
    {
        field_6_options = noOrientation.setShortBoolean(field_6_options, orientation);
    }

    public void setUsePage(boolean page)
    {
        field_6_options = usepage.setShortBoolean(field_6_options, page);
    }

    
    public void setHResolution(short resolution)
    {
        field_7_hresolution = resolution;
    }

    public void setVResolution(short resolution)
    {
        field_8_vresolution = resolution;
    }

    public void setHeaderMargin(double headermargin)
    {
        field_9_headermargin = headermargin;
    }

    public void setFooterMargin(double footermargin)
    {
        field_10_footermargin = footermargin;
    }

    public void setCopies(short copies)
    {
        field_11_copies = copies;
    }

    public short getPaperSize()
    {
        return field_1_paper_size;
    }

    public short getScale()
    {
        return field_2_scale;
    }

    public short getPageStart()
    {
        return field_3_page_start;
    }

    public short getFitWidth()
    {
        return field_4_fit_width;
    }

    public short getFitHeight()
    {
        return field_5_fit_height;
    }

    public short getOptions()
    {
        return field_6_options;
    }

    
    public boolean getLeftToRight()
    {
        return lefttoright.isSet(field_6_options);
    }

    public boolean getLandscape()
    {
        return landscape.isSet(field_6_options);
    }

    public boolean getValidSettings()
    {
        return validsettings.isSet(field_6_options);
    }

    public boolean getNoColor()
    {
        return nocolor.isSet(field_6_options);
    }

    public boolean getDraft()
    {
        return draft.isSet(field_6_options);
    }

    public boolean getNotes()
    {
        return notes.isSet(field_6_options);
    }

    public boolean getNoOrientation()
    {
        return noOrientation.isSet(field_6_options);
    }

    public boolean getUsePage()
    {
        return usepage.isSet(field_6_options);
    }

    
    public short getHResolution()
    {
        return field_7_hresolution;
    }

    public short getVResolution()
    {
        return field_8_vresolution;
    }

    public double getHeaderMargin()
    {
        return field_9_headermargin;
    }

    public double getFooterMargin()
    {
        return field_10_footermargin;
    }

    public short getCopies()
    {
        return field_11_copies;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRINTSETUP]
"");
        buffer.append(""    .papersize      = "").append(getPaperSize())
            .append(""
"");
        buffer.append(""    .scale          = "").append(getScale())
            .append(""
"");
        buffer.append(""    .pagestart      = "").append(getPageStart())
            .append(""
"");
        buffer.append(""    .fitwidth       = "").append(getFitWidth())
            .append(""
"");
        buffer.append(""    .fitheight      = "").append(getFitHeight())
            .append(""
"");
        buffer.append(""    .options        = "").append(getOptions())
            .append(""
"");
        buffer.append(""        .ltor       = "").append(getLeftToRight())
            .append(""
"");
        buffer.append(""        .landscape  = "").append(getLandscape())
            .append(""
"");
        buffer.append(""        .valid      = "").append(getValidSettings())
            .append(""
"");
        buffer.append(""        .mono       = "").append(getNoColor())
            .append(""
"");
        buffer.append(""        .draft      = "").append(getDraft())
            .append(""
"");
        buffer.append(""        .notes      = "").append(getNotes())
            .append(""
"");
        buffer.append(""        .noOrientat = "").append(getNoOrientation())
            .append(""
"");
        buffer.append(""        .usepage    = "").append(getUsePage())
            .append(""
"");
        buffer.append(""    .hresolution    = "").append(getHResolution())
            .append(""
"");
        buffer.append(""    .vresolution    = "").append(getVResolution())
            .append(""
"");
        buffer.append(""    .headermargin   = "").append(getHeaderMargin())
            .append(""
"");
        buffer.append(""    .footermargin   = "").append(getFooterMargin())
            .append(""
"");
        buffer.append(""    .copies         = "").append(getCopies())
            .append(""
"");
        buffer.append(""[/PRINTSETUP]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getPaperSize());
        out.writeShort(getScale());
        out.writeShort(getPageStart());
        out.writeShort(getFitWidth());
        out.writeShort(getFitHeight());
        out.writeShort(getOptions());
        out.writeShort(getHResolution());
        out.writeShort(getVResolution());
        out.writeDouble(getHeaderMargin());
        out.writeDouble(getFooterMargin());
        out.writeShort(getCopies());
    }

    protected int getDataSize() {
        return 34;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      PrintSetupRecord rec = new PrintSetupRecord();
      rec.field_1_paper_size = field_1_paper_size;
      rec.field_2_scale = field_2_scale;
      rec.field_3_page_start = field_3_page_start;
      rec.field_4_fit_width = field_4_fit_width;
      rec.field_5_fit_height = field_5_fit_height;
      rec.field_6_options = field_6_options;
      rec.field_7_hresolution = field_7_hresolution;
      rec.field_8_vresolution = field_8_vresolution;
      rec.field_9_headermargin = field_9_headermargin;
      rec.field_10_footermargin = field_10_footermargin;
      rec.field_11_copies = field_11_copies;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFPicture,3,3,0,6,5,1,3,3,2,1.357142857,25,0.0,0,0.9,0.5,0,0,5.0,1,0.6667,3,"

package org.apache.poi.hssf.usermodel;

import java.awt.Dimension;
import java.io.ByteArrayInputStream;

import org.apache.poi.ddf.DefaultEscherRecordFactory;
import org.apache.poi.ddf.EscherBSERecord;
import org.apache.poi.ddf.EscherBlipRecord;
import org.apache.poi.ddf.EscherClientDataRecord;
import org.apache.poi.ddf.EscherComplexProperty;
import org.apache.poi.ddf.EscherContainerRecord;
import org.apache.poi.ddf.EscherOptRecord;
import org.apache.poi.ddf.EscherProperties;
import org.apache.poi.ddf.EscherSimpleProperty;
import org.apache.poi.ddf.EscherTextboxRecord;
import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.EscherAggregate;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.ss.usermodel.Picture;
import org.apache.poi.ss.util.ImageUtils;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;
import org.apache.poi.util.StringUtil;


public class HSSFPicture extends HSSFSimpleShape implements Picture {
	@SuppressWarnings(""unused"")
    private static POILogger logger = POILogFactory.getLogger(HSSFPicture.class);
	
    public static final int PICTURE_TYPE_EMF = HSSFWorkbook.PICTURE_TYPE_EMF;                
    public static final int PICTURE_TYPE_WMF = HSSFWorkbook.PICTURE_TYPE_WMF;                
    public static final int PICTURE_TYPE_PICT = HSSFWorkbook.PICTURE_TYPE_PICT;              
    public static final int PICTURE_TYPE_JPEG = HSSFWorkbook.PICTURE_TYPE_JPEG;              
    public static final int PICTURE_TYPE_PNG = HSSFWorkbook.PICTURE_TYPE_PNG;                
    public static final int PICTURE_TYPE_DIB = HSSFWorkbook.PICTURE_TYPE_DIB;                

    public HSSFPicture(EscherContainerRecord spContainer, ObjRecord objRecord) {
        super(spContainer, objRecord);
    }

    
    public HSSFPicture( HSSFShape parent, HSSFAnchor anchor )
    {
        super( parent, anchor );
        super.setShapeType(OBJECT_TYPE_PICTURE);
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) getObjRecord().getSubRecords().get(0);
        cod.setObjectType(CommonObjectDataSubRecord.OBJECT_TYPE_PICTURE);
    }

    public int getPictureIndex()
    {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.BLIP__BLIPTODISPLAY);
        if (null == property){
            return -1;
        }
        return property.getPropertyValue();
    }

    public void setPictureIndex( int pictureIndex )
    {
        setPropertyValue(new EscherSimpleProperty( EscherProperties.BLIP__BLIPTODISPLAY, false, true, pictureIndex));
    }

    @Override
    protected EscherContainerRecord createSpContainer() {
        EscherContainerRecord spContainer = super.createSpContainer();
        EscherOptRecord opt = spContainer.getChildById(EscherOptRecord.RECORD_ID);
        opt.removeEscherProperty(EscherProperties.LINESTYLE__LINEDASHING);
        opt.removeEscherProperty(EscherProperties.LINESTYLE__NOLINEDRAWDASH);
        spContainer.removeChildRecord(spContainer.getChildById(EscherTextboxRecord.RECORD_ID));
        return spContainer;
    }

    
    public void resize(){
        resize(Double.MAX_VALUE);
    }

    
    public void resize(double scale) {
        resize(scale,scale);
    }
    
    
    public void resize(double scaleX, double scaleY) {
        HSSFClientAnchor anchor = getClientAnchor();
        anchor.setAnchorType(2);

        HSSFClientAnchor pref = getPreferredSize(scaleX,scaleY);

        int row2 = anchor.getRow1() + (pref.getRow2() - pref.getRow1());
        int col2 = anchor.getCol1() + (pref.getCol2() - pref.getCol1());

        anchor.setCol2((short)col2);
        
        anchor.setDx2(pref.getDx2());

        anchor.setRow2(row2);
        
        anchor.setDy2(pref.getDy2());
    }

    
    public HSSFClientAnchor getPreferredSize(){
        return getPreferredSize(1.0);
    }

    
    public HSSFClientAnchor getPreferredSize(double scale){
        return getPreferredSize(scale, scale);
    }
    
    
    public HSSFClientAnchor getPreferredSize(double scaleX, double scaleY){
        ImageUtils.setPreferredSize(this, scaleX, scaleY);
        return getClientAnchor();
    }

    
    public Dimension getImageDimension(){
        InternalWorkbook iwb = getPatriarch().getSheet().getWorkbook().getWorkbook();
        EscherBSERecord bse = iwb.getBSERecord(getPictureIndex());
        byte[] data = bse.getBlipRecord().getPicturedata();
        int type = bse.getBlipTypeWin32();
        return ImageUtils.getImageDimension(new ByteArrayInputStream(data), type);
    }
    
    
    public HSSFPictureData getPictureData(){
        InternalWorkbook iwb = getPatriarch().getSheet().getWorkbook().getWorkbook();
        EscherBSERecord bse = iwb.getBSERecord(getPictureIndex());
    	EscherBlipRecord blipRecord = bse.getBlipRecord();
    	return new HSSFPictureData(blipRecord);
    }

    @Override
    void afterInsert(HSSFPatriarch patriarch) {
        EscherAggregate agg = patriarch._getBoundAggregate();
        agg.associateShapeToObjRecord(getEscherContainer().getChildById(EscherClientDataRecord.RECORD_ID), getObjRecord());
        EscherBSERecord bse =
                patriarch.getSheet().getWorkbook().getWorkbook().getBSERecord(getPictureIndex());
        bse.setRef(bse.getRef() + 1);
    }

    
    public String getFileName() {
        EscherComplexProperty propFile = (EscherComplexProperty) getOptRecord().lookup(
                      EscherProperties.BLIP__BLIPFILENAME);
        return (null == propFile)
            ? """"
            : StringUtil.getFromUnicodeLE(propFile.getComplexData()).trim();
    }
    
    public void setFileName(String data){
        
        byte bytes[] = StringUtil.getToUnicodeLE(data);
        EscherComplexProperty prop = new EscherComplexProperty(EscherProperties.BLIP__BLIPFILENAME, true, bytes);
        setPropertyValue(prop);
    }

    @Override
    public void setShapeType(int shapeType) {
        throw new IllegalStateException(""Shape type can not be changed in ""+this.getClass().getSimpleName());
    }

    @Override
    protected HSSFShape cloneShape() {
        EscherContainerRecord spContainer = new EscherContainerRecord();
        byte [] inSp = getEscherContainer().serialize();
        spContainer.fillFields(inSp, 0, new DefaultEscherRecordFactory());
        ObjRecord obj = (ObjRecord) getObjRecord().cloneViaReserialise();
        return new HSSFPicture(spContainer, obj);
    }
    
    
    @Override
    public HSSFClientAnchor getClientAnchor() {
        HSSFAnchor a = getAnchor();
        return (a instanceof HSSFClientAnchor) ? (HSSFClientAnchor)a : null;
    }

    
    
    @Override
    public HSSFSheet getSheet() {
        return getPatriarch().getSheet();
    }
}
"
poi,3,org.apache.poi.hssf.record.CalcModeRecord,11,2,0,6,20,43,2,4,9,0.98,105,0.2,0,0.55,0.309090909,1,4,8.090909091,2,0.9091,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class CalcModeRecord
    extends StandardRecord
{
    public final static short sid                     = 0xD;

    

    public final static short MANUAL                  = 0;

    

    public final static short AUTOMATIC               = 1;

    

    public final static short AUTOMATIC_EXCEPT_TABLES = -1;
    private short             field_1_calcmode;

    public CalcModeRecord()
    {
    }

    public CalcModeRecord(RecordInputStream in)
    {
        field_1_calcmode = in.readShort();
    }

    

    public void setCalcMode(short calcmode)
    {
        field_1_calcmode = calcmode;
    }

    

    public short getCalcMode()
    {
        return field_1_calcmode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[CALCMODE]
"");
        buffer.append(""    .calcmode       = "")
            .append(Integer.toHexString(getCalcMode())).append(""
"");
        buffer.append(""[/CALCMODE]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getCalcMode());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      CalcModeRecord rec = new CalcModeRecord();
      rec.field_1_calcmode = field_1_calcmode;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.PrintGridlinesRecord,11,2,0,7,20,35,3,4,9,0.8,113,0.5,0,0.55,0.257575758,1,4,9.090909091,2,1.0909,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class PrintGridlinesRecord
    extends StandardRecord
{
    public final static short sid = 0x2b;
    private short             field_1_print_gridlines;

    public PrintGridlinesRecord()
    {
    }

    public PrintGridlinesRecord(RecordInputStream in)
    {
        field_1_print_gridlines = in.readShort();
    }

    

    public void setPrintGridlines(boolean pg)
    {
        if (pg == true)
        {
            field_1_print_gridlines = 1;
        }
        else
        {
            field_1_print_gridlines = 0;
        }
    }

    

    public boolean getPrintGridlines()
    {
        return (field_1_print_gridlines == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PRINTGRIDLINES]
"");
        buffer.append(""    .printgridlines = "").append(getPrintGridlines())
            .append(""
"");
        buffer.append(""[/PRINTGRIDLINES]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_print_gridlines);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      PrintGridlinesRecord rec = new PrintGridlinesRecord();
      rec.field_1_print_gridlines = field_1_print_gridlines;
      return rec;
    }
}
"
poi,3,org.apache.poi.poifs.property.Parent,4,1,0,3,4,6,1,2,4,2.0,4,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.property;

import java.util.Iterator;

import java.io.IOException;



public interface Parent
    extends Child
{

    

    public Iterator getChildren();

    

    public void addChild(final Property property)
        throws IOException;

    

    public void setPreviousChild(final Child child);

    

    public void setNextChild(final Child child);

    

}   

"
poi,3,org.apache.poi.poifs.eventfilesystem.POIFSReaderEvent,4,1,0,5,5,0,3,2,3,0.666666667,28,1.0,2,0.0,0.4375,0,0,5.25,1,0.75,0,"

        

package org.apache.poi.poifs.eventfilesystem;

import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;



public class POIFSReaderEvent
{
    private DocumentInputStream stream;
    private POIFSDocumentPath   path;
    private String              documentName;

    

    POIFSReaderEvent(final DocumentInputStream stream,
                     final POIFSDocumentPath path, final String documentName)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
    }

    

    public DocumentInputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }
}   

"
poi,3,org.apache.poi.hpsf.MutableSection,24,2,0,15,86,116,5,11,21,0.507246377,781,1.0,0,0.290322581,0.16025641,1,7,31.41666667,7,1.4167,0,"

package org.apache.poi.hpsf;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.LittleEndian;


public class MutableSection extends Section
{
    
    private boolean dirty = true;



    
    private List<Property> preprops;



    
    private byte[] sectionBytes;



    
    public MutableSection()
    {
        dirty = true;
        formatID = null;
        offset = -1;
        preprops = new LinkedList<Property>();
    }



    
    public MutableSection(final Section s)
    {
        setFormatID(s.getFormatID());
        final Property[] pa = s.getProperties();
        final MutableProperty[] mpa = new MutableProperty[pa.length];
        for (int i = 0; i < pa.length; i++)
            mpa[i] = new MutableProperty(pa[i]);
        setProperties(mpa);
        setDictionary(s.getDictionary());
    }



    
    public void setFormatID(final ClassID formatID)
    {
        this.formatID = formatID;
    }



    
    public void setFormatID(final byte[] formatID)
    {
        ClassID fid = getFormatID();
        if (fid == null)
        {
            fid = new ClassID();
            setFormatID(fid);
        }
        fid.setBytes(formatID);
    }



    
    public void setProperties(final Property[] properties)
    {
        this.properties = properties;
        preprops = new LinkedList<Property>();
        for (int i = 0; i < properties.length; i++)
            preprops.add(properties[i]);
        dirty = true;
    }



    
    public void setProperty(final int id, final String value)
    {
        setProperty(id, Variant.VT_LPWSTR, value);
        dirty = true;
    }



    
    public void setProperty(final int id, final int value)
    {
        setProperty(id, Variant.VT_I4, Integer.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final long value)
    {
        setProperty(id, Variant.VT_I8, Long.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final boolean value)
    {
        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final long variantType,
                            final Object value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(id);
        p.setType(variantType);
        p.setValue(value);
        setProperty(p);
        dirty = true;
    }



    
    public void setProperty(final Property p)
    {
        final long id = p.getID();
        removeProperty(id);
        preprops.add(p);
        dirty = true;
    }



    
    public void removeProperty(final long id)
    {
        for (final Iterator<Property> i = preprops.iterator(); i.hasNext();)
            if (i.next().getID() == id)
            {
                i.remove();
                break;
            }
        dirty = true;
    }



    
    protected void setPropertyBooleanValue(final int id, final boolean value)
    {
        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));
    }



    
    public int getSize()
    {
        if (dirty)
        {
            try
            {
                size = calcSize();
                dirty = false;
            }
            catch (HPSFRuntimeException ex)
            {
                throw ex;
            }
            catch (Exception ex)
            {
                throw new HPSFRuntimeException(ex);
            }
        }
        return size;
    }



    
    private int calcSize() throws WritingNotSupportedException, IOException
    {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        write(out);
        out.close();
        
        sectionBytes = Util.pad4(out.toByteArray());
        return sectionBytes.length;
    }



    
    public int write(final OutputStream out)
        throws WritingNotSupportedException, IOException
    {
        
        if (!dirty && sectionBytes != null)
        {
            out.write(sectionBytes);
            return sectionBytes.length;
        }

        
        final ByteArrayOutputStream propertyStream =
            new ByteArrayOutputStream();

        
        final ByteArrayOutputStream propertyListStream =
            new ByteArrayOutputStream();

        
        int position = 0;

        
        position += 2 * LittleEndian.INT_SIZE +
                    getPropertyCount() * 2 * LittleEndian.INT_SIZE;

        
        int codepage = -1;
        if (getProperty(PropertyIDMap.PID_DICTIONARY) != null)
        {
            final Object p1 = getProperty(PropertyIDMap.PID_CODEPAGE);
            if (p1 != null)
            {
                if (!(p1 instanceof Integer))
                    throw new IllegalPropertySetDataException
                        (""The codepage property (ID = 1) must be an "" +
                         ""Integer object."");
            }
            else
                
                setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                            Integer.valueOf(CodePageUtil.CP_UNICODE));
            codepage = getCodepage();
        }

        
        Collections.sort(preprops, new Comparator<Property>()
            {
                public int compare(final Property p1, final Property p2)
                {
                    if (p1.getID() < p2.getID())
                        return -1;
                    else if (p1.getID() == p2.getID())
                        return 0;
                    else
                        return 1;
                }
            });

        
        for (final ListIterator<Property> i = preprops.listIterator(); i.hasNext();)
        {
            final MutableProperty p = (MutableProperty) i.next();
            final long id = p.getID();

            
            TypeWriter.writeUIntToStream(propertyListStream, p.getID());
            TypeWriter.writeUIntToStream(propertyListStream, position);

            
            if (id != 0)
                
                position += p.write(propertyStream, getCodepage());
            else
            {
                if (codepage == -1)
                    throw new IllegalPropertySetDataException
                        (""Codepage (property 1) is undefined."");
                position += writeDictionary(propertyStream, dictionary,
                                            codepage);
            }
        }
        propertyStream.close();
        propertyListStream.close();

        
        byte[] pb1 = propertyListStream.toByteArray();
        byte[] pb2 = propertyStream.toByteArray();

        
        TypeWriter.writeToStream(out, LittleEndian.INT_SIZE * 2 +
                                      pb1.length + pb2.length);

        
        TypeWriter.writeToStream(out, getPropertyCount());

        
        out.write(pb1);

        
        out.write(pb2);

        int streamLength = LittleEndian.INT_SIZE * 2 + pb1.length + pb2.length;
        return streamLength;
    }



    
    private static int writeDictionary(final OutputStream out,
                                       final Map<Long,String> dictionary, final int codepage)
        throws IOException
    {
        int length = TypeWriter.writeUIntToStream(out, dictionary.size());
        for (final Iterator<Long> i = dictionary.keySet().iterator(); i.hasNext();)
        {
            final Long key = i.next();
            final String value = dictionary.get(key);

            if (codepage == CodePageUtil.CP_UNICODE)
            {
                
                int sLength = value.length() + 1;
                if (sLength % 2 == 1)
                    sLength++;
                length += TypeWriter.writeUIntToStream(out, key.longValue());
                length += TypeWriter.writeUIntToStream(out, sLength);
                final byte[] ca = CodePageUtil.getBytesInCodePage(value, codepage);
                for (int j = 2; j < ca.length; j += 2)
                {
                    out.write(ca[j+1]);
                    out.write(ca[j]);
                    length += 2;
                }
                sLength -= value.length();
                while (sLength > 0)
                {
                    out.write(0x00);
                    out.write(0x00);
                    length += 2;
                    sLength--;
                }
            }
            else
            {
                
                length += TypeWriter.writeUIntToStream(out, key.longValue());
                length += TypeWriter.writeUIntToStream(out, value.length() + 1);
                final byte[] ba = CodePageUtil.getBytesInCodePage(value, codepage);
                for (int j = 0; j < ba.length; j++)
                {
                    out.write(ba[j]);
                    length++;
                }
                out.write(0x00);
                length++;
            }
        }
        return length;
    }



    
    public int getPropertyCount()
    {
        return preprops.size();
    }



    
    public Property[] getProperties()
    {
        properties = preprops.toArray(new Property[0]);
        return properties;
    }



    
    public Object getProperty(final long id)
    {
        
        getProperties();
        return super.getProperty(id);
    }



    
    public void setDictionary(final Map<Long,String> dictionary)
        throws IllegalPropertySetDataException
    {
        if (dictionary != null)
        {
            this.dictionary = dictionary;

            
            setProperty(PropertyIDMap.PID_DICTIONARY, -1, dictionary);

            
            final Integer codepage =
                (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);
            if (codepage == null)
                setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                            Integer.valueOf(CodePageUtil.CP_UNICODE));
        }
        else
            
            removeProperty(PropertyIDMap.PID_DICTIONARY);
    }



    
    public void setProperty(final int id, final Object value)
    {
        if (value instanceof String)
            setProperty(id, (String) value);
        else if (value instanceof Long)
            setProperty(id, ((Long) value).longValue());
        else if (value instanceof Integer)
            setProperty(id, ((Integer) value).intValue());
        else if (value instanceof Short)
            setProperty(id, ((Short) value).intValue());
        else if (value instanceof Boolean)
            setProperty(id, ((Boolean) value).booleanValue());
        else if (value instanceof Date)
            setProperty(id, Variant.VT_FILETIME, value);
        else
            throw new HPSFRuntimeException(
                    ""HPSF does not support properties of type "" +
                    value.getClass().getName() + ""."");
    }



    
    public void clear()
    {
        final Property[] properties = getProperties();
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            removeProperty(p.getID());
        }
    }

    
    public void setCodepage(final int codepage)
    {
        setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                Integer.valueOf(codepage));
    }
}
"
poi,3,org.apache.poi.hssf.record.FooterRecord,14,2,0,9,30,55,4,5,12,0.753846154,259,0.8,0,0.47826087,0.214285714,1,4,17.14285714,5,1.6429,2,"

package org.apache.poi.hssf.record;


public final class FooterRecord extends HeaderFooterBase {
	public final static short sid = 0x0015;

	public FooterRecord(String text) {
		super(text);
	}

	public FooterRecord(RecordInputStream in) {
		super(in);
	}

	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[FOOTER]
"");
		buffer.append(""    .footer = "").append(getText()).append(""
"");
		buffer.append(""[/FOOTER]
"");
		return buffer.toString();
	}

	public short getSid() {
		return sid;
	}

	public Object clone() {
		return new FooterRecord(getText());
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFPalette,6,1,0,7,12,0,2,5,5,0.0,175,1.0,1,0.0,0.541666667,0,0,28.0,5,2.5,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.PaletteRecord;
import org.apache.poi.hssf.util.HSSFColor;


public final class HSSFPalette {
    private PaletteRecord _palette;

    protected HSSFPalette(PaletteRecord palette)
    {
        _palette = palette;
    }

    
    public HSSFColor getColor(short index)
    {
        
        if (index == HSSFColor.AUTOMATIC.index) {
            return HSSFColor.AUTOMATIC.getInstance();
        }
        byte[] b = _palette.getColor(index);
          if (b != null)
          {
             return new CustomColor(index, b);
          }
        return null;
    }
    
    public HSSFColor getColor(int index) {
    	return getColor((short)index);
    }

    
    public HSSFColor findColor(byte red, byte green, byte blue)
    {
        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);
        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;
            b = _palette.getColor(++i))
        {
            if (b[0] == red && b[1] == green && b[2] == blue)
            {
                return new CustomColor(i, b);
            }
        }
        return null;
    }

    
    public HSSFColor findSimilarColor(byte red, byte green, byte blue) {
    	return findSimilarColor(unsignedInt(red), unsignedInt(green), unsignedInt(blue));
    }
    
    public HSSFColor findSimilarColor(int red, int green, int blue) {
        HSSFColor result = null;
        int minColorDistance = Integer.MAX_VALUE;
        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);
        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;
            b = _palette.getColor(++i))
        {
            int colorDistance = Math.abs(red - unsignedInt(b[0])) +
            	Math.abs(green - unsignedInt(b[1])) +
            	Math.abs(blue - unsignedInt(b[2]));
            if (colorDistance < minColorDistance)
            {
                minColorDistance = colorDistance;
                result = getColor(i);
            }
        }
        return result;
    }
    
    
    private int unsignedInt(byte b) {
    	return 0xFF & b;
    }

    
    public void setColorAtIndex(short index, byte red, byte green, byte blue)
    {
        _palette.setColor(index, red, green, blue);
    }

    
    public HSSFColor addColor( byte red, byte green, byte blue )
    {
        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);
        short i;
        for (i = PaletteRecord.FIRST_COLOR_INDEX; i < PaletteRecord.STANDARD_PALETTE_SIZE + PaletteRecord.FIRST_COLOR_INDEX; b = _palette.getColor(++i))
        {
            if (b == null)
            {
                setColorAtIndex( i, red, green, blue );
                return getColor(i);
            }
        }
        throw new RuntimeException(""Could not find free color index"");
    }

    private static final class CustomColor extends HSSFColor {
        private short _byteOffset;
        private byte _red;
        private byte _green;
        private byte _blue;

        public CustomColor(short byteOffset, byte[] colors)
        {
            this(byteOffset, colors[0], colors[1], colors[2]);
        }

        private CustomColor(short byteOffset, byte red, byte green, byte blue)
        {
            _byteOffset = byteOffset;
            _red = red;
            _green = green;
            _blue = blue;
        }

        @Override
        public short getIndex()
        {
            return _byteOffset;
        }

        @Override
        public short[] getTriplet()
        {
            return new short[]
            {
                (short) (_red   & 0xff),
                (short) (_green & 0xff),
                (short) (_blue  & 0xff)
            };
        }

        @Override
        public String getHexString()
        {
            StringBuffer sb = new StringBuffer();
            sb.append(getGnumericPart(_red));
            sb.append(':');
            sb.append(getGnumericPart(_green));
            sb.append(':');
            sb.append(getGnumericPart(_blue));
            return sb.toString();
        }

        private String getGnumericPart(byte color)
        {
            String s;
            if (color == 0)
            {
                s = ""0"";
            }
            else
            {
                int c = color & 0xff; 
                c = (c << 8) | c; 
                s = Integer.toHexString(c).toUpperCase();
                while (s.length() < 4)
                {
                    s = ""0"" + s;
                }
            }
            return s;
        }
    }
}
"
poi,3,org.apache.poi.poifs.property.PropertyTable,11,1,0,11,34,0,2,9,10,0.566666667,210,1.0,1,0.0,0.272727273,0,0,17.81818182,3,1.0909,2,"

package org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.PropertyBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;


public final class PropertyTable extends PropertyTableBase implements BlockWritable {
    private POIFSBigBlockSize _bigBigBlockSize;
    private BlockWritable[]   _blocks;

    public PropertyTable(HeaderBlock headerBlock)
    {
        super(headerBlock);
        _bigBigBlockSize = headerBlock.getBigBlockSize();
        _blocks = null;
    }

    
    public PropertyTable(final HeaderBlock headerBlock,
                         final RawDataBlockList blockList)
        throws IOException
    {
        super(
              headerBlock,
              PropertyFactory.convertToProperties(
                    blockList.fetchBlocks(headerBlock.getPropertyStart(), -1)
              )
        );
        _bigBigBlockSize = headerBlock.getBigBlockSize();
        _blocks      = null;
    }

    
    public void preWrite()
    {
        Property[] properties = _properties.toArray(new Property[_properties.size()]);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].setIndex(k);
        }

        
        _blocks = PropertyBlock.createPropertyBlockArray(_bigBigBlockSize, _properties);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].preWrite();
        }
    }
    
    
    public int countBlocks()
    {
        return (_blocks == null) ? 0
                                 : _blocks.length;
    }

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        if (_blocks != null)
        {
            for (int j = 0; j < _blocks.length; j++)
            {
                _blocks[ j ].writeBlocks(stream);
            }
        }
    }
}
"
poi,3,org.apache.poi.hssf.record.BookBoolRecord,10,2,0,6,19,33,2,4,8,0.833333333,91,0.5,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class BookBoolRecord
    extends StandardRecord
{
    public final static short sid = 0xDA;
    private short             field_1_save_link_values;

    public BookBoolRecord()
    {
    }

    public BookBoolRecord(RecordInputStream in)
    {
        field_1_save_link_values = in.readShort();
    }

    

    public void setSaveLinkValues(short flag)
    {
        field_1_save_link_values = flag;
    }

    

    public short getSaveLinkValues()
    {
        return field_1_save_link_values;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BOOKBOOL]
"");
        buffer.append(""    .savelinkvalues  = "")
            .append(Integer.toHexString(getSaveLinkValues())).append(""
"");
        buffer.append(""[/BOOKBOOL]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_save_link_values);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.SCLRecord,13,2,0,8,24,44,3,5,11,0.75,171,0.666666667,0,0.5,0.307692308,1,4,11.92307692,2,0.9231,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class SCLRecord extends StandardRecord {
    public final static short      sid                             = 0x00A0;
    private  short      field_1_numerator;
    private  short      field_2_denominator;


    public SCLRecord()
    {

    }

    public SCLRecord(RecordInputStream in)
    {
        field_1_numerator              = in.readShort();
        field_2_denominator            = in.readShort();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SCL]
"");
        buffer.append(""    .numerator            = "")
            .append(""0x"").append(HexDump.toHex(  getNumerator ()))
            .append("" ("").append( getNumerator() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .denominator          = "")
            .append(""0x"").append(HexDump.toHex(  getDenominator ()))
            .append("" ("").append( getDenominator() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 

        buffer.append(""[/SCL]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_numerator);
        out.writeShort(field_2_denominator);
    }

    protected int getDataSize() {
        return 2 + 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
        SCLRecord rec = new SCLRecord();
    
        rec.field_1_numerator = field_1_numerator;
        rec.field_2_denominator = field_2_denominator;
        return rec;
    }




    
    public short getNumerator()
    {
        return field_1_numerator;
    }

    
    public void setNumerator(short field_1_numerator)
    {
        this.field_1_numerator = field_1_numerator;
    }

    
    public short getDenominator()
    {
        return field_2_denominator;
    }

    
    public void setDenominator(short field_2_denominator)
    {
        this.field_2_denominator = field_2_denominator;
    }
}
"
poi,3,org.apache.poi.hssf.record.NumberRecord,24,2,0,11,39,234,6,5,22,0.747826087,365,0.8,0,0.333333333,0.197916667,1,4,14.0,7,1.8333,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.ss.util.NumberToTextConverter;
import org.apache.poi.util.LittleEndianOutput;


public final class NumberRecord extends CellRecord {
    public static final short sid = 0x0203;
    private double field_4_value;

    
    public NumberRecord() {
    	
    }

    
    public NumberRecord(RecordInputStream in) {
        super(in);
        field_4_value = in.readDouble();
    }

    
    public void setValue(double value){
        field_4_value = value;
    }

    
    public double getValue(){
        return field_4_value;
    }

    @Override
    protected String getRecordName() {
    	return ""NUMBER"";
    }

    @Override
    protected void appendValueText(StringBuilder sb) {
    	sb.append(""  .value= "").append(NumberToTextConverter.toText(field_4_value));
    }

    @Override
    protected void serializeValue(LittleEndianOutput out) {
        out.writeDouble(getValue());
    }

    @Override
    protected int getValueDataSize() {
    	return 8;
    }

    @Override
    public short getSid() {
        return sid;
    }

    @Override
    public Object clone() {
      NumberRecord rec = new NumberRecord();
      copyBaseFields(rec);
      rec.field_4_value = field_4_value;
      return rec;
    }
}
"
poi,3,org.apache.poi.ddf.DefaultEscherRecordFactory,4,1,1,11,27,4,3,8,2,0.833333333,214,1.0,0,0.0,0.416666667,0,0,52.0,10,3.0,2,"

package org.apache.poi.ddf;

import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

import org.apache.poi.util.LittleEndian;


public class DefaultEscherRecordFactory implements EscherRecordFactory {
    private static Class<?>[] escherRecordClasses = { EscherBSERecord.class,
            EscherOptRecord.class, EscherTertiaryOptRecord.class,
            EscherClientAnchorRecord.class, EscherDgRecord.class,
            EscherSpgrRecord.class, EscherSpRecord.class,
            EscherClientDataRecord.class, EscherDggRecord.class,
            EscherSplitMenuColorsRecord.class, EscherChildAnchorRecord.class,
            EscherTextboxRecord.class };
    private static Map<Short, Constructor<? extends EscherRecord>> recordsMap = recordsToMap( escherRecordClasses );

    
    public DefaultEscherRecordFactory() {
        
    }

    
    public EscherRecord createRecord(byte[] data, int offset) {
        short options = LittleEndian.getShort( data, offset );
        short recordId = LittleEndian.getShort( data, offset + 2 );
        

        
        
        
        
        if (isContainer(options, recordId)) {
            EscherContainerRecord r = new EscherContainerRecord();
            r.setRecordId( recordId );
            r.setOptions( options );
            return r;
        }

        if (recordId >= EscherBlipRecord.RECORD_ID_START
                && recordId <= EscherBlipRecord.RECORD_ID_END) {
            EscherBlipRecord r;
            if (recordId == EscherBitmapBlip.RECORD_ID_DIB ||
                    recordId == EscherBitmapBlip.RECORD_ID_JPEG ||
                    recordId == EscherBitmapBlip.RECORD_ID_PNG)
            {
                r = new EscherBitmapBlip();
            }
            else if (recordId == EscherMetafileBlip.RECORD_ID_EMF ||
                    recordId == EscherMetafileBlip.RECORD_ID_WMF ||
                    recordId == EscherMetafileBlip.RECORD_ID_PICT)
            {
                r = new EscherMetafileBlip();
            } else {
                r = new EscherBlipRecord();
            }
            r.setRecordId( recordId );
            r.setOptions( options );
            return r;
        }

        Constructor<? extends EscherRecord> recordConstructor = recordsMap.get(Short.valueOf(recordId));
        EscherRecord escherRecord = null;
        if (recordConstructor == null) {
            return new UnknownEscherRecord();
        }
        try {
            escherRecord = recordConstructor.newInstance(new Object[] {});
        } catch (Exception e) {
            return new UnknownEscherRecord();
        }
        escherRecord.setRecordId(recordId);
        escherRecord.setOptions(options);
        return escherRecord;
    }

    
    private static Map<Short, Constructor<? extends EscherRecord>> recordsToMap(Class<?>[] recClasses) {
        Map<Short, Constructor<? extends EscherRecord>> result = new HashMap<Short, Constructor<? extends EscherRecord>>();
        final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];

        for (int i = 0; i < recClasses.length; i++) {
            @SuppressWarnings(""unchecked"")
            Class<? extends EscherRecord> recCls = (Class<? extends EscherRecord>) recClasses[i];
            short sid;
            try {
                sid = recCls.getField(""RECORD_ID"").getShort(null);
            } catch (IllegalArgumentException e) {
                throw new RuntimeException(e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (NoSuchFieldException e) {
                throw new RuntimeException(e);
            }
            Constructor<? extends EscherRecord> constructor;
            try {
                constructor = recCls.getConstructor( EMPTY_CLASS_ARRAY );
            } catch (NoSuchMethodException e) {
                throw new RuntimeException(e);
            }
            result.put(Short.valueOf(sid), constructor);
        }
        return result;
    }

    public static boolean isContainer(short options, short recordId){
        if(recordId >= EscherContainerRecord.DGG_CONTAINER &&  recordId
                <= EscherContainerRecord.SOLVER_CONTAINER){
            return true;
        } else {
            if (recordId == EscherTextboxRecord.RECORD_ID) {
                return false;
            } else {
                return ( options & (short) 0x000F ) == (short) 0x000F;
            }
        }
    }
}
"
poi,3,org.apache.poi.ddf.NullEscherSerializationListener,3,1,0,5,4,3,4,2,3,2.0,8,0.0,0,0.0,0.75,0,0,1.666666667,1,0.6667,1,"

package org.apache.poi.ddf;


public class NullEscherSerializationListener implements EscherSerializationListener {
    public void beforeRecordSerialize(int offset, short recordId, EscherRecord record) {
        
    }

    public void afterRecordSerialize(int offset, short recordId, int size, EscherRecord record) {
        
    }
}
"
poi,3,org.apache.poi.hpsf.CustomProperty,7,3,0,4,14,9,2,2,7,0.166666667,85,1.0,0,0.692307692,0.428571429,1,1,11.0,7,1.4286,0,"

package org.apache.poi.hpsf;


public class CustomProperty extends MutableProperty
{

    private String name;

    
    public CustomProperty()
    {
        this.name = null;
    }

    
    public CustomProperty(final Property property)
    {
        this(property, null);
    }

    
    public CustomProperty(final Property property, final String name)
    {
        super(property);
        this.name = name;
    }

    
    public String getName()
    {
        return name;
    }

    
    public void setName(final String name)
    {
        this.name = name;
    }


    
    public boolean equalsContents(final Object o)
    {
        final CustomProperty c = (CustomProperty) o;
        final String name1 = c.getName();
        final String name2 = this.getName();
        boolean equalNames = true;
        if (name1 == null)
            equalNames = name2 == null;
        else
            equalNames = name1.equals(name2);
        return equalNames && c.getID() == this.getID()
                && c.getType() == this.getType()
                && c.getValue().equals(this.getValue());
    }

    
    @Override
    public int hashCode()
    {
        return (int) this.getID();
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof CustomProperty) ? equalsContents(o) : false;
    }
}
"
poi,3,org.apache.poi.ddf.EscherSpgrRecord,15,2,0,7,32,43,1,6,15,0.833333333,253,0.666666667,0,0.575757576,0.333333333,1,5,15.46666667,2,1.0,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.RecordFormatException;


public class EscherSpgrRecord
    extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF009;
    public static final String RECORD_DESCRIPTION = ""MsofbtSpgr"";

    private int field_1_rectX1;
    private int field_2_rectY1;
    private int field_3_rectX2;
    private int field_4_rectY2;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;
        field_1_rectX1 =  LittleEndian.getInt( data, pos + size );size+=4;
        field_2_rectY1 =  LittleEndian.getInt( data, pos + size );size+=4;
        field_3_rectX2 =  LittleEndian.getInt( data, pos + size );size+=4;
        field_4_rectY2 =  LittleEndian.getInt( data, pos + size );size+=4;
        bytesRemaining -= size;
        if (bytesRemaining != 0) throw new RecordFormatException(""Expected no remaining bytes but got "" + bytesRemaining);


        return 8 + size + bytesRemaining;
    }

    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {
        listener.beforeRecordSerialize( offset, getRecordId(), this );
        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );
        int remainingBytes = 16;
        LittleEndian.putInt( data, offset + 4, remainingBytes );
        LittleEndian.putInt( data, offset + 8, field_1_rectX1 );
        LittleEndian.putInt( data, offset + 12, field_2_rectY1 );
        LittleEndian.putInt( data, offset + 16, field_3_rectX2 );
        LittleEndian.putInt( data, offset + 20, field_4_rectY2 );


        listener.afterRecordSerialize( offset + getRecordSize(), getRecordId(), offset + getRecordSize(), this );
        return 8 + 16;
    }

    public int getRecordSize()
    {
        return 8 + 16;
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""Spgr"";
    }

    
    public String toString() {
        return getClass().getName() + "":"" + '
' +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + '
' +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + '
' +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + '
' +
                ""  RectX: "" + field_1_rectX1 + '
' +
                ""  RectY: "" + field_2_rectY1 + '
' +
                ""  RectWidth: "" + field_3_rectX2 + '
' +
                ""  RectHeight: "" + field_4_rectY2 + '
';
    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<RectX>"").append(field_1_rectX1).append(""</RectX>
"")
                .append(tab).append(""	"").append(""<RectY>"").append(field_2_rectY1).append(""</RectY>
"")
                .append(tab).append(""	"").append(""<RectWidth>"").append(field_3_rectX2).append(""</RectWidth>
"")
                .append(tab).append(""	"").append(""<RectHeight>"").append(field_4_rectY2).append(""</RectHeight>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public int getRectX1()
    {
        return field_1_rectX1;
    }

    
    public void setRectX1( int x1 )
    {
        this.field_1_rectX1 = x1;
    }

    
    public int getRectY1()
    {
        return field_2_rectY1;
    }

    
    public void setRectY1( int y1 )
    {
        this.field_2_rectY1 = y1;
    }

    
    public int getRectX2()
    {
        return field_3_rectX2;
    }

    
    public void setRectX2( int x2 )
    {
        this.field_3_rectX2 = x2;
    }

    
    public int getRectY2()
    {
        return field_4_rectY2;
    }

    
    public void setRectY2(int rectY2) {
        this.field_4_rectY2 = rectY2;
    }
}
"
poi,3,org.apache.poi.hssf.record.DateWindow1904Record,10,2,0,6,19,39,2,4,8,0.833333333,91,0.5,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class DateWindow1904Record
    extends StandardRecord
{
    public final static short sid = 0x22;
    private short             field_1_window;

    public DateWindow1904Record()
    {
    }

    public DateWindow1904Record(RecordInputStream in)
    {
        field_1_window = in.readShort();
    }

    

    public void setWindowing(short window)
    {   
        field_1_window = window;
    }

    

    public short getWindowing()
    {
        return field_1_window;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[1904]
"");
        buffer.append(""    .is1904          = "")
            .append(Integer.toHexString(getWindowing())).append(""
"");
        buffer.append(""[/1904]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getWindowing());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.RefreshAllRecord,10,2,0,6,19,33,2,4,8,0.833333333,101,0.5,0,0.578947368,0.266666667,1,4,8.9,2,1.1,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class RefreshAllRecord extends StandardRecord {
    public final static short sid = 0x01B7;

    private static final BitField refreshFlag = BitFieldFactory.getInstance(0x0001);

    private int _options;

    private RefreshAllRecord(int options) {
        _options = options;
    }

    public RefreshAllRecord(RecordInputStream in) {
        this(in.readUShort());
    }

    public RefreshAllRecord(boolean refreshAll) {
        this(0);
        setRefreshAll(refreshAll);
    }

    
    public void setRefreshAll(boolean refreshAll) {
        _options = refreshFlag.setBoolean(_options, refreshAll);
    }

    
    public boolean getRefreshAll() {
        return refreshFlag.isSet(_options);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[REFRESHALL]
"");
        buffer.append(""    .options      = "").append(HexDump.shortToHex(_options)).append(""
"");
        buffer.append(""[/REFRESHALL]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_options);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }
    @Override
    public Object clone() {
        return new RefreshAllRecord(_options);
    }
}
"
poi,3,org.apache.poi.hssf.util.CellReference,12,1,0,6,32,34,6,0,9,0.690909091,346,1.0,0,0.0,0.375,0,0,27.41666667,6,1.5833,1,"

package org.apache.poi.hssf.util;


public final class CellReference extends org.apache.poi.ss.util.CellReference {
    
    public CellReference(String cellRef) {
    	super(cellRef);
    }

    public CellReference(int pRow, int pCol) {
    	super(pRow, pCol, true, true);
    }
    
    public CellReference(int pRow, int pCol, boolean pAbsRow, boolean pAbsCol) {
        super(null, pRow, pCol, pAbsRow, pAbsCol);
    }

    public CellReference(String pSheetName, int pRow, int pCol, boolean pAbsRow, boolean pAbsCol) {
    	super(pSheetName, pRow, pCol, pAbsRow, pAbsCol);
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFRichTextString,22,1,0,12,47,0,7,5,16,0.583333333,307,0.75,3,0.0,0.196969697,0,0,12.77272727,9,1.5,4,"

package org.apache.poi.hssf.usermodel;

import java.util.Iterator;

import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.LabelSSTRecord;
import org.apache.poi.hssf.record.common.UnicodeString;
import org.apache.poi.hssf.record.common.UnicodeString.FormatRun;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.RichTextString;

public final class HSSFRichTextString implements Comparable<HSSFRichTextString>, RichTextString {
    
    public static final short NO_FONT = 0;

    private UnicodeString _string;
    private InternalWorkbook _book;
    private LabelSSTRecord _record;

    public HSSFRichTextString()
    {
        this("""");
    }

    public HSSFRichTextString(String string) {
        if (string == null) {
            _string = new UnicodeString("""");
        } else {
            _string = new UnicodeString(string);
        }
    }

    HSSFRichTextString(InternalWorkbook book, LabelSSTRecord record) {
      setWorkbookReferences(book, record);

      _string = book.getSSTString(record.getSSTIndex());
    }

    
    void setWorkbookReferences(InternalWorkbook book, LabelSSTRecord record) {
      _book = book;
      _record = record;
    }

    
    private UnicodeString cloneStringIfRequired() {
      if (_book == null)
        return _string;
      UnicodeString s = (UnicodeString)_string.clone();
      return s;
    }

    private void addToSSTIfRequired() {
      if (_book != null) {
        int index = _book.addSSTString(_string);
        _record.setSSTIndex(index);
        
        
        _string = _book.getSSTString(index);
      }
    }


    
    public void applyFont(int startIndex, int endIndex, short fontIndex)
    {
        if (startIndex > endIndex)
            throw new IllegalArgumentException(""Start index must be less than end index."");
        if (startIndex < 0 || endIndex > length())
            throw new IllegalArgumentException(""Start and end index not in range."");
        if (startIndex == endIndex)
            return;

        
        
        short currentFont = NO_FONT;
        if (endIndex != length()) {
          currentFont = this.getFontAtIndex(endIndex);
        }

        
        _string = cloneStringIfRequired();
        Iterator<FormatRun> formatting = _string.formatIterator();
        if (formatting != null) {
          while (formatting.hasNext()) {
            UnicodeString.FormatRun r = formatting.next();
            if ((r.getCharacterPos() >= startIndex) && (r.getCharacterPos() < endIndex))
              formatting.remove();
          }
        }


        _string.addFormatRun(new UnicodeString.FormatRun((short)startIndex, fontIndex));
        if (endIndex != length())
          _string.addFormatRun(new UnicodeString.FormatRun((short)endIndex, currentFont));

        addToSSTIfRequired();
    }

    
    public void applyFont(int startIndex, int endIndex, Font font)
    {
        applyFont(startIndex, endIndex, ((HSSFFont) font).getIndex());
    }

    
    public void applyFont(Font font)
    {
        applyFont(0, _string.getCharCount(), font);
    }

    
    public void clearFormatting() {
      _string = cloneStringIfRequired();
      _string.clearFormatting();
      addToSSTIfRequired();
    }

    
    public String getString()
    {
        return _string.getString();
    }

    
    UnicodeString getUnicodeString() {
      return cloneStringIfRequired();
    }

    
    UnicodeString getRawUnicodeString() {
    	return _string;
    }

    
    void setUnicodeString(UnicodeString str) {
      this._string = str;
    }


    
    public int length() {
        return _string.getCharCount();
    }

    
    public short getFontAtIndex( int index )
    {
      int size = _string.getFormatRunCount();
      UnicodeString.FormatRun currentRun = null;
      for (int i=0;i<size;i++) {
        UnicodeString.FormatRun r = _string.getFormatRun(i);
        if (r.getCharacterPos() > index) {
            break;
        }
        currentRun = r;
      }
      if (currentRun == null) {
          return NO_FONT;
      }
      return currentRun.getFontIndex();
    }

    
    public int numFormattingRuns()
    {
        return _string.getFormatRunCount();
    }

    
    public int getIndexOfFormattingRun(int index)
    {
        UnicodeString.FormatRun r = _string.getFormatRun(index);
        return r.getCharacterPos();
    }

    
    public short getFontOfFormattingRun(int index)
    {
      UnicodeString.FormatRun r = _string.getFormatRun(index);
      return r.getFontIndex();
    }

    
    public int compareTo(HSSFRichTextString r) {
       return _string.compareTo(r._string);
    }

    @Override
    public boolean equals(Object o) {
      if (o instanceof HSSFRichTextString) {
        return _string.equals(((HSSFRichTextString)o)._string);
      }
      return false;

    }

    @Override
    public int hashCode() {
        assert false : ""hashCode not designed"";
        return 42; 
    }

    
    
    public String toString()
    {
        return _string.toString();
    }

    
    public void applyFont( short fontIndex )
    {
        applyFont(0, _string.getCharCount(), fontIndex);
    }
}
"
poi,3,org.apache.poi.hpsf.TypeWriter,9,1,0,9,27,36,4,6,9,2.0,204,0.0,0,0.0,0.25,0,0,21.66666667,1,0.8889,0,"

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.LittleEndian;


public class TypeWriter
{

    
    public static int writeToStream( final OutputStream out, final short n )
            throws IOException
    {
        LittleEndian.putShort( out, n ); 
        return LittleEndian.SHORT_SIZE;
    }

    
    public static int writeToStream( final OutputStream out, final int n )
            throws IOException
    {
        LittleEndian.putInt( n, out );
        return LittleEndian.INT_SIZE;
    }

    
    public static int writeToStream( final OutputStream out, final long n )
            throws IOException
    {
        LittleEndian.putLong( n, out );
        return LittleEndian.LONG_SIZE;
    }

    
    public static void writeUShortToStream( final OutputStream out, final int n )
            throws IOException
    {
        int high = n & 0xFFFF0000;
        if ( high != 0 )
            throw new IllegalPropertySetDataException( ""Value "" + n
                    + "" cannot be represented by 2 bytes."" );
        LittleEndian.putUShort( n, out );
    }

    
    public static int writeUIntToStream( final OutputStream out, final long n )
            throws IOException
    {
        long high = n & 0xFFFFFFFF00000000L;
        if ( high != 0 && high != 0xFFFFFFFF00000000L )
            throw new IllegalPropertySetDataException( ""Value "" + n
                    + "" cannot be represented by 4 bytes."" );
        LittleEndian.putUInt( n, out );
        return LittleEndian.INT_SIZE;
    }

    
    public static int writeToStream(final OutputStream out, final ClassID n)
        throws IOException
    {
        byte[] b = new byte[16];
        n.write(b, 0);
        out.write(b, 0, b.length);
        return b.length;
    }



    
    public static void writeToStream(final OutputStream out,
                                     final Property[] properties,
                                     final int codepage)
        throws IOException, UnsupportedVariantTypeException
    {
        
        if (properties == null)
            return;

        
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            writeUIntToStream(out, p.getID());
            writeUIntToStream(out, p.getSize());
        }

        
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            long type = p.getType();
            writeUIntToStream(out, type);
            VariantSupport.write(out, (int) type, p.getValue(), codepage);
        }
    }



    
    public static int writeToStream( final OutputStream out, final double n )
            throws IOException
    {
        LittleEndian.putDouble( n, out );
        return LittleEndian.DOUBLE_SIZE;
    }

}
"
poi,3,org.apache.poi.hssf.record.UnicodeString,36,1,0,18,90,252,11,8,29,0.742857143,1699,0.888888889,3,0.0,0.16,1,1,45.94444444,25,4.1667,3,"

package org.apache.poi.hssf.record;

public final class UnicodeString extends org.apache.poi.hssf.record.common.UnicodeString {
   
   public UnicodeString(RecordInputStream in) {
      super(in);
   }
   
   public UnicodeString(String str) {
      super(str);
   }
}
"
poi,3,org.apache.poi.poifs.common.POIFSConstants,0,1,0,0,0,0,0,0,0,2.0,4,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

        

package org.apache.poi.poifs.common;


public interface POIFSConstants
{
    
    public static final int SMALLER_BIG_BLOCK_SIZE = 0x0200;
    public static final POIFSBigBlockSize SMALLER_BIG_BLOCK_SIZE_DETAILS = 
       new POIFSBigBlockSize(SMALLER_BIG_BLOCK_SIZE, (short)9);
    
    public static final int LARGER_BIG_BLOCK_SIZE = 0x1000;
    public static final POIFSBigBlockSize LARGER_BIG_BLOCK_SIZE_DETAILS = 
       new POIFSBigBlockSize(LARGER_BIG_BLOCK_SIZE, (short)12);
    
    
    public static final int SMALL_BLOCK_SIZE = 0x0040; 
    
    
    public static final int PROPERTY_SIZE  = 0x0080;
    
    
    public static final int BIG_BLOCK_MINIMUM_DOCUMENT_SIZE = 0x1000;
    
    
    public static final int LARGEST_REGULAR_SECTOR_NUMBER = -5;
    
    
    public static final int DIFAT_SECTOR_BLOCK   = -4;
    
    public static final int FAT_SECTOR_BLOCK   = -3;
    
    public static final int END_OF_CHAIN   = -2;
    
    public static final int UNUSED_BLOCK   = -1;
    
    
    public static final byte[] OOXML_FILE_HEADER = 
    	new byte[] { 0x50, 0x4b, 0x03, 0x04 };
}   
"
poi,3,org.apache.poi.hssf.record.FilePassRecord,9,2,0,5,19,24,1,4,7,0.875,97,0.5,0,0.611111111,0.311111111,1,4,9.555555556,2,0.8889,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class FilePassRecord extends StandardRecord {
	public final static short sid = 0x002F;
	
	private int _encryptionType;
	private KeyData _keyData;

	private static interface KeyData {
	    void read(RecordInputStream in);
	    void serialize(LittleEndianOutput out);
	    int getDataSize();
	    void appendToString(StringBuffer buffer);
	} 
	
	public static class Rc4KeyData implements KeyData {
	    private static final int ENCRYPTION_OTHER_RC4 = 1;
	    private static final int ENCRYPTION_OTHER_CAPI_2 = 2;
	    private static final int ENCRYPTION_OTHER_CAPI_3 = 3;
        private static final int ENCRYPTION_OTHER_CAPI_4 = 4;
	    
	    private byte[] _salt;
	    private byte[] _encryptedVerifier;
	    private byte[] _encryptedVerifierHash;
	    private int _encryptionInfo;
	    private int _minorVersionNo;
	    
	    public void read(RecordInputStream in) {
	        _encryptionInfo = in.readUShort();
	        switch (_encryptionInfo) {
	            case ENCRYPTION_OTHER_RC4:
	                
	                break;
	            case ENCRYPTION_OTHER_CAPI_2:
	            case ENCRYPTION_OTHER_CAPI_3:
                case ENCRYPTION_OTHER_CAPI_4:
	                throw new EncryptedDocumentException(
	                        ""HSSF does not currently support CryptoAPI encryption"");
	            default:
	                throw new RecordFormatException(""Unknown encryption info "" + _encryptionInfo);
	        }
	        _minorVersionNo = in.readUShort();
	        if (_minorVersionNo!=1) {
	            throw new RecordFormatException(""Unexpected VersionInfo number for RC4Header "" + _minorVersionNo);
	        }
	        _salt = FilePassRecord.read(in, 16);
	        _encryptedVerifier = FilePassRecord.read(in, 16);
	        _encryptedVerifierHash = FilePassRecord.read(in, 16);
	    }
	    
	    public void serialize(LittleEndianOutput out) {
            out.writeShort(_encryptionInfo);
            out.writeShort(_minorVersionNo);
            out.write(_salt);
            out.write(_encryptedVerifier);
            out.write(_encryptedVerifierHash);
	    }
	    
	    public int getDataSize() {
	        return 54;
	    }

        public byte[] getSalt() {
            return _salt.clone();
        }

        public void setSalt(byte[] salt) {
            this._salt = salt.clone();
        }

        public byte[] getEncryptedVerifier() {
            return _encryptedVerifier.clone();
        }

        public void setEncryptedVerifier(byte[] encryptedVerifier) {
            this._encryptedVerifier = encryptedVerifier.clone();
        }

        public byte[] getEncryptedVerifierHash() {
            return _encryptedVerifierHash.clone();
        }

        public void setEncryptedVerifierHash(byte[] encryptedVerifierHash) {
            this._encryptedVerifierHash = encryptedVerifierHash.clone();
        }
        
        public void appendToString(StringBuffer buffer) {
            buffer.append(""    .rc4.info = "").append(HexDump.shortToHex(_encryptionInfo)).append(""
"");
            buffer.append(""    .rc4.ver  = "").append(HexDump.shortToHex(_minorVersionNo)).append(""
"");
            buffer.append(""    .rc4.salt = "").append(HexDump.toHex(_salt)).append(""
"");
            buffer.append(""    .rc4.verifier = "").append(HexDump.toHex(_encryptedVerifier)).append(""
"");
            buffer.append(""    .rc4.verifierHash = "").append(HexDump.toHex(_encryptedVerifierHash)).append(""
"");
        }
	}

	public static class XorKeyData implements KeyData {
	    
	    private int _key;

	    
	    private int _verifier;
	    
        public void read(RecordInputStream in) {
            _key = in.readUShort();
            _verifier = in.readUShort();
        }

        public void serialize(LittleEndianOutput out) {
            out.writeShort(_key);
            out.writeShort(_verifier);
        }

        public int getDataSize() {
            
            return 6;
        }

        public int getKey() {
            return _key;
        }
        
        public int getVerifier() {
            return _verifier;
        }
        
        public void setKey(int key) {
            this._key = key;
        }
        
        public void setVerifier(int verifier) {
            this._verifier = verifier;
        }
        
        public void appendToString(StringBuffer buffer) {
            buffer.append(""    .xor.key = "").append(HexDump.intToHex(_key)).append(""
"");
            buffer.append(""    .xor.verifier  = "").append(HexDump.intToHex(_verifier)).append(""
"");
        }
	}
	
	
	private static final int ENCRYPTION_XOR = 0;
	private static final int ENCRYPTION_OTHER = 1;

	public FilePassRecord(RecordInputStream in) {
		_encryptionType = in.readUShort();

		switch (_encryptionType) {
			case ENCRYPTION_XOR:
			    _keyData = new XorKeyData();
			    break;
			case ENCRYPTION_OTHER:
			    _keyData = new Rc4KeyData();
				break;
			default:
				throw new RecordFormatException(""Unknown encryption type "" + _encryptionType);
		}

		_keyData.read(in);
	}

	private static byte[] read(RecordInputStream in, int size) {
		byte[] result = new byte[size];
		in.readFully(result);
		return result;
	}

	public void serialize(LittleEndianOutput out) {
		out.writeShort(_encryptionType);
		assert(_keyData != null);
		_keyData.serialize(out);
	}

	protected int getDataSize() {
	    assert(_keyData != null);
	    return _keyData.getDataSize();
	}

	public Rc4KeyData getRc4KeyData() {
	    return (_keyData instanceof Rc4KeyData)
            ? (Rc4KeyData) _keyData
            : null;
	}
	
    public XorKeyData getXorKeyData() {
        return (_keyData instanceof XorKeyData)
            ? (XorKeyData) _keyData
            : null;
    }
    
    private Rc4KeyData checkRc4() {
        Rc4KeyData rc4 = getRc4KeyData();
        if (rc4 == null) {
            throw new RecordFormatException(""file pass record doesn't contain a rc4 key."");
        }
        return rc4;
    }
    
    
    public byte[] getDocId() {
		return checkRc4().getSalt();
	}

    
    public void setDocId(byte[] docId) {
        checkRc4().setSalt(docId);
	}

    
    public byte[] getSaltData() {
		return checkRc4().getEncryptedVerifier();
	}

    
	public void setSaltData(byte[] saltData) {
	    getRc4KeyData().setEncryptedVerifier(saltData);
	}

    
	public byte[] getSaltHash() {
		return getRc4KeyData().getEncryptedVerifierHash();
	}

    
	public void setSaltHash(byte[] saltHash) {
	    getRc4KeyData().setEncryptedVerifierHash(saltHash);
	}

	public short getSid() {
		return sid;
	}
	
    public Object clone() {
		
		return this;
	}

	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[FILEPASS]
"");
		buffer.append(""    .type = "").append(HexDump.shortToHex(_encryptionType)).append(""
"");
		_keyData.appendToString(buffer);
		buffer.append(""[/FILEPASS]
"");
		return buffer.toString();
	}
}
"
poi,3,org.apache.poi.hpsf.DocumentSummaryInformation,51,3,0,11,99,1275,1,10,49,1.02,564,0.0,0,0.333333333,0.193277311,0,0,10.03921569,6,1.1765,0,"

package org.apache.poi.hpsf;

import java.util.Iterator;
import java.util.Map;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.util.CodePageUtil;


public class DocumentSummaryInformation extends SpecialPropertySet
{
    
    public static final String DEFAULT_STREAM_NAME =
        ""DocumentSummaryInformation"";

    public PropertyIDMap getPropertySetIDMap() {
    	return PropertyIDMap.getDocumentSummaryInformationProperties();
    }


    
    public DocumentSummaryInformation(final PropertySet ps)
        throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isDocumentSummaryInformation())
            throw new UnexpectedPropertySetTypeException
                (""Not a "" + getClass().getName());
    }

    
    
    public String getCategory()
    {
        return getPropertyStringValue(PropertyIDMap.PID_CATEGORY);
    }

    
    public void setCategory(final String category)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CATEGORY, category);
    }

    
    public void removeCategory()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CATEGORY);
    }



    
    public String getPresentationFormat()
    {
        return getPropertyStringValue(PropertyIDMap.PID_PRESFORMAT);
    }

    
    public void setPresentationFormat(final String presentationFormat)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PRESFORMAT, presentationFormat);
    }

    
    public void removePresentationFormat()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PRESFORMAT);
    }



    
    public int getByteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_BYTECOUNT);
    }

    
    public void setByteCount(final int byteCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_BYTECOUNT, byteCount);
    }

    
    public void removeByteCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_BYTECOUNT);
    }



    
    public int getLineCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_LINECOUNT);
    }

    
    public void setLineCount(final int lineCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LINECOUNT, lineCount);
    }

    
    public void removeLineCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LINECOUNT);
    }



    
    public int getParCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PARCOUNT);
    }

    
    public void setParCount(final int parCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PARCOUNT, parCount);
    }

    
    public void removeParCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PARCOUNT);
    }



    
    public int getSlideCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SLIDECOUNT);
    }

    
    public void setSlideCount(final int slideCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SLIDECOUNT, slideCount);
    }

    
    public void removeSlideCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SLIDECOUNT);
    }



    
    public int getNoteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_NOTECOUNT);
    }

    
    public void setNoteCount(final int noteCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_NOTECOUNT, noteCount);
    }

    
    public void removeNoteCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_NOTECOUNT);
    }



    
    public int getHiddenCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_HIDDENCOUNT);
    }

    
    public void setHiddenCount(final int hiddenCount)
    {
        final MutableSection s = (MutableSection) getSections().get(0);
        s.setProperty(PropertyIDMap.PID_HIDDENCOUNT, hiddenCount);
    }

    
    public void removeHiddenCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_HIDDENCOUNT);
    }



    
    public int getMMClipCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_MMCLIPCOUNT);
    }

    
    public void setMMClipCount(final int mmClipCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_MMCLIPCOUNT, mmClipCount);
    }

    
    public void removeMMClipCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_MMCLIPCOUNT);
    }



    
    public boolean getScale()
    {
        return getPropertyBooleanValue(PropertyIDMap.PID_SCALE);
    }

    
    public void setScale(final boolean scale)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SCALE, scale);
    }

    
    public void removeScale()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SCALE);
    }



    
    public byte[] getHeadingPair()
    {
        notYetImplemented(""Reading byte arrays "");
        return (byte[]) getProperty(PropertyIDMap.PID_HEADINGPAIR);
    }

    
    public void setHeadingPair(final byte[] headingPair)
    {
        notYetImplemented(""Writing byte arrays "");
    }

    
    public void removeHeadingPair()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_HEADINGPAIR);
    }



    
    public byte[] getDocparts()
    {
        notYetImplemented(""Reading byte arrays"");
        return (byte[]) getProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public void setDocparts(final byte[] docparts)
    {
        notYetImplemented(""Writing byte arrays"");
    }

    
    public void removeDocparts()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public String getManager()
    {
        return getPropertyStringValue(PropertyIDMap.PID_MANAGER);
    }

    
    public void setManager(final String manager)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_MANAGER, manager);
    }

    
    public void removeManager()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_MANAGER);
    }



    
    public String getCompany()
    {
        return getPropertyStringValue(PropertyIDMap.PID_COMPANY);
    }

    
    public void setCompany(final String company)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_COMPANY, company);
    }

    
    public void removeCompany()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_COMPANY);
    }


    
    public boolean getLinksDirty()
    {
        return getPropertyBooleanValue(PropertyIDMap.PID_LINKSDIRTY);
    }

    
    public void setLinksDirty(final boolean linksDirty)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LINKSDIRTY, linksDirty);
    }

    
    public void removeLinksDirty()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LINKSDIRTY);
    }


    
    public CustomProperties getCustomProperties()
    {
        CustomProperties cps = null;
        if (getSectionCount() >= 2)
        {
            cps = new CustomProperties();
            final Section section = getSections().get(1);
            final Map<Long,String> dictionary = section.getDictionary();
            final Property[] properties = section.getProperties();
            int propertyCount = 0;
            for (int i = 0; i < properties.length; i++)
            {
                final Property p = properties[i];
                final long id = p.getID();
                if (id != 0 && id != 1)
                {
                    propertyCount++;
                    final CustomProperty cp = new CustomProperty(p,
                            dictionary.get(Long.valueOf(id)));
                    cps.put(cp.getName(), cp);
                }
            }
            if (cps.size() != propertyCount)
                cps.setPure(false);
        }
        return cps;
    }

    
    public void setCustomProperties(final CustomProperties customProperties)
    {
        ensureSection2();
        final MutableSection section = (MutableSection) getSections().get(1);
        final Map<Long,String> dictionary = customProperties.getDictionary();
        section.clear();

        
        int cpCodepage = customProperties.getCodepage();
        if (cpCodepage < 0)
            cpCodepage = section.getCodepage();
        if (cpCodepage < 0)
            cpCodepage = CodePageUtil.CP_UNICODE;
        customProperties.setCodepage(cpCodepage);
        section.setCodepage(cpCodepage);
        section.setDictionary(dictionary);
        for (final Iterator<CustomProperty> i = customProperties.values().iterator(); i.hasNext();)
        {
            final Property p = i.next();
            section.setProperty(p);
        }
    }

    
    private void ensureSection2()
    {
        if (getSectionCount() < 2)
        {
            MutableSection s2 = new MutableSection();
            s2.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[1]);
            addSection(s2);
        }
    }

    
    public void removeCustomProperties()
    {
        if (getSectionCount() >= 2)
            getSections().remove(1);
        else
            throw new HPSFRuntimeException(""Illegal internal format of Document SummaryInformation stream: second section is missing."");
    }


    
    private void notYetImplemented(final String msg)
    {
        throw new UnsupportedOperationException(msg + "" is not yet implemented."");
    }
}
"
poi,3,org.apache.poi.hpsf.Section,18,1,1,14,64,127,8,7,14,0.754901961,714,1.0,2,0.0,0.25,1,1,38.33333333,16,2.4444,2,"

package org.apache.poi.hpsf;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.util.LittleEndian;


public class Section
{

    
    protected Map<Long,String> dictionary;

    
    protected ClassID formatID;


    
    public ClassID getFormatID()
    {
        return formatID;
    }



    
    protected long offset;


    
    public long getOffset()
    {
        return offset;
    }



    
    protected int size;


    
    public int getSize()
    {
        return size;
    }



    
    public int getPropertyCount()
    {
        return properties.length;
    }



    
    protected Property[] properties;


    
    public Property[] getProperties()
    {
        return properties;
    }



    
    protected Section()
    { }



    
    public Section(final byte[] src, final int offset)
    throws UnsupportedEncodingException
    {
        int o1 = offset;

        
        formatID = new ClassID(src, o1);
        o1 += ClassID.LENGTH;

        
        this.offset = LittleEndian.getUInt(src, o1);
        o1 = (int) this.offset;

        
        size = (int) LittleEndian.getUInt(src, o1);
        o1 += LittleEndian.INT_SIZE;

        
        final int propertyCount = (int) LittleEndian.getUInt(src, o1);
        o1 += LittleEndian.INT_SIZE;

        
        properties = new Property[propertyCount];

        
        int pass1Offset = o1;
        final List<PropertyListEntry> propertyList = new ArrayList<PropertyListEntry>(propertyCount);
        PropertyListEntry ple;
        for (int i = 0; i < properties.length; i++)
        {
            ple = new PropertyListEntry();

            
            ple.id = (int) LittleEndian.getUInt(src, pass1Offset);
            pass1Offset += LittleEndian.INT_SIZE;

            
            ple.offset = (int) LittleEndian.getUInt(src, pass1Offset);
            pass1Offset += LittleEndian.INT_SIZE;

            
            propertyList.add(ple);
        }

        
        Collections.sort(propertyList);

        
        for (int i = 0; i < propertyCount - 1; i++)
        {
            PropertyListEntry ple1 = propertyList.get(i);
            PropertyListEntry ple2 = propertyList.get(i + 1);
            ple1.length = ple2.offset - ple1.offset;
        }
        if (propertyCount > 0)
        {
            ple = propertyList.get(propertyCount - 1);
            ple.length = size - ple.offset;
        }

        
        int codepage = -1;
        for (final Iterator<PropertyListEntry> i = propertyList.iterator();
             codepage == -1 && i.hasNext();)
        {
            ple = i.next();

            
            if (ple.id == PropertyIDMap.PID_CODEPAGE)
            {
                
                int o = (int) (this.offset + ple.offset);
                final long type = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;

                if (type != Variant.VT_I2)
                    throw new HPSFRuntimeException
                        (""Value type of property ID 1 is not VT_I2 but "" +
                         type + ""."");

                
                codepage = LittleEndian.getUShort(src, o);
            }
        }

        
        int i1 = 0;
        for (final Iterator<PropertyListEntry> i = propertyList.iterator(); i.hasNext();)
        {
            ple = i.next();
            Property p = new Property(ple.id, src,
                    this.offset + ple.offset,
                    ple.length, codepage);
            if (p.getID() == PropertyIDMap.PID_CODEPAGE)
                p = new Property(p.getID(), p.getType(), Integer.valueOf(codepage));
            properties[i1++] = p;
        }

        
        dictionary = (Map) getProperty(0);
    }



    
    static class PropertyListEntry implements Comparable<PropertyListEntry>
    {
        int id;
        int offset;
        int length;

        
        public int compareTo(final PropertyListEntry o)
        {
            final int otherOffset = o.offset;
            if (offset < otherOffset)
                return -1;
            else if (offset == otherOffset)
                return 0;
            else
                return 1;
        }

        public String toString()
        {
            final StringBuffer b = new StringBuffer();
            b.append(getClass().getName());
            b.append(""[id="");
            b.append(id);
            b.append("", offset="");
            b.append(offset);
            b.append("", length="");
            b.append(length);
            b.append(']');
            return b.toString();
        }
    }



    
    public Object getProperty(final long id)
    {
        wasNull = false;
        for (int i = 0; i < properties.length; i++)
            if (id == properties[i].getID())
                return properties[i].getValue();
        wasNull = true;
        return null;
    }



    
    protected int getPropertyIntValue(final long id)
    {
        final Number i;
        final Object o = getProperty(id);
        if (o == null)
            return 0;
        if (!(o instanceof Long || o instanceof Integer))
            throw new HPSFRuntimeException
                (""This property is not an integer type, but "" +
                 o.getClass().getName() + ""."");
        i = (Number) o;
        return i.intValue();
    }



    
    protected boolean getPropertyBooleanValue(final int id)
    {
        final Boolean b = (Boolean) getProperty(id);
        if (b == null) {
            return false;
        }
        return b.booleanValue();
        }



    
    private boolean wasNull;


    
    public boolean wasNull()
    {
        return wasNull;
    }



    
    public String getPIDString(final long pid)
    {
        String s = null;
        if (dictionary != null)
            s = dictionary.get(Long.valueOf(pid));
        if (s == null)
            s = SectionIDMap.getPIDString(getFormatID().getBytes(), pid);
        if (s == null)
            s = SectionIDMap.UNDEFINED;
        return s;
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof Section))
            return false;
        final Section s = (Section) o;
        if (!s.getFormatID().equals(getFormatID()))
            return false;

        
        Property[] pa1 = new Property[getProperties().length];
        Property[] pa2 = new Property[s.getProperties().length];
        System.arraycopy(getProperties(), 0, pa1, 0, pa1.length);
        System.arraycopy(s.getProperties(), 0, pa2, 0, pa2.length);

        
        Property p10 = null;
        Property p20 = null;
        for (int i = 0; i < pa1.length; i++)
        {
            final long id = pa1[i].getID();
            if (id == 0)
            {
                p10 = pa1[i];
                pa1 = remove(pa1, i);
                i--;
            }
            if (id == 1)
            {
                
                pa1 = remove(pa1, i);
                i--;
            }
        }
        for (int i = 0; i < pa2.length; i++)
        {
            final long id = pa2[i].getID();
            if (id == 0)
            {
                p20 = pa2[i];
                pa2 = remove(pa2, i);
                i--;
            }
            if (id == 1)
            {
                
                pa2 = remove(pa2, i);
                i--;
            }
        }

        
        if (pa1.length != pa2.length)
            return false;

        
        boolean dictionaryEqual = true;
        if (p10 != null && p20 != null)
            dictionaryEqual = p10.getValue().equals(p20.getValue());
        else if (p10 != null || p20 != null)
            dictionaryEqual = false;
        if (dictionaryEqual) {
            return Util.equals(pa1, pa2);
        }
        return false;
    }



    
    private Property[] remove(final Property[] pa, final int i)
    {
        final Property[] h = new Property[pa.length - 1];
        if (i > 0)
            System.arraycopy(pa, 0, h, 0, i);
        System.arraycopy(pa, i + 1, h, i, h.length - i);
        return h;
    }



    
    public int hashCode()
    {
        long hashCode = 0;
        hashCode += getFormatID().hashCode();
        final Property[] pa = getProperties();
        for (int i = 0; i < pa.length; i++)
            hashCode += pa[i].hashCode();
        final int returnHashCode = (int) (hashCode & 0x0ffffffffL);
        return returnHashCode;
    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final Property[] pa = getProperties();
        b.append(getClass().getName());
        b.append('[');
        b.append(""formatID: "");
        b.append(getFormatID());
        b.append("", offset: "");
        b.append(getOffset());
        b.append("", propertyCount: "");
        b.append(getPropertyCount());
        b.append("", size: "");
        b.append(getSize());
        b.append("", properties: [
"");
        for (int i = 0; i < pa.length; i++)
        {
            b.append(pa[i].toString());
            b.append("",
"");
        }
        b.append(']');
        b.append(']');
        return b.toString();
    }



    
    public Map<Long,String> getDictionary()
    {
        return dictionary;
    }



    
    public int getCodepage()
    {
        final Integer codepage =
            (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);
        if (codepage == null)
            return -1;
        int cp = codepage.intValue();
        return cp;
    }

}
"
poi,3,org.apache.poi.hssf.record.BoundSheetRecord,19,2,0,7,40,123,2,5,17,0.777777778,320,0.833333333,0,0.392857143,0.218045113,1,4,15.52631579,11,1.6316,2,"

package org.apache.poi.hssf.record;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;
import org.apache.poi.ss.util.WorkbookUtil;


public final class BoundSheetRecord extends StandardRecord {
	public final static short sid = 0x0085;

	private static final BitField hiddenFlag = BitFieldFactory.getInstance(0x01);
	private static final BitField veryHiddenFlag = BitFieldFactory.getInstance(0x02);
	private int field_1_position_of_BOF;
	private int field_2_option_flags;
	private int field_4_isMultibyteUnicode;
	private String field_5_sheetname;

	public BoundSheetRecord(String sheetname) {
		field_2_option_flags = 0;
		setSheetname(sheetname);
	}

	
	public BoundSheetRecord(RecordInputStream in) {
		field_1_position_of_BOF = in.readInt();
		field_2_option_flags = in.readUShort();
		int field_3_sheetname_length = in.readUByte();
		field_4_isMultibyteUnicode = in.readByte();

		if (isMultibyte()) {
			field_5_sheetname = in.readUnicodeLEString(field_3_sheetname_length);
		} else {
			field_5_sheetname = in.readCompressedUnicode(field_3_sheetname_length);
		}
	}

	
	public void setPositionOfBof(int pos) {
		field_1_position_of_BOF = pos;
	}

	
	public void setSheetname(String sheetName) {

		WorkbookUtil.validateSheetName(sheetName);
		field_5_sheetname = sheetName;
		field_4_isMultibyteUnicode = StringUtil.hasMultibyte(sheetName) ?  1 : 0;
	}

	
	public int getPositionOfBof() {
		return field_1_position_of_BOF;
	}

	private boolean isMultibyte() {
		return (field_4_isMultibyteUnicode & 0x01) != 0;
	}

	
	public String getSheetname() {
		return field_5_sheetname;
	}

	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[BOUNDSHEET]
"");
		buffer.append(""    .bof        = "").append(HexDump.intToHex(getPositionOfBof())).append(""
"");
		buffer.append(""    .options    = "").append(HexDump.shortToHex(field_2_option_flags)).append(""
"");
		buffer.append(""    .unicodeflag= "").append(HexDump.byteToHex(field_4_isMultibyteUnicode)).append(""
"");
		buffer.append(""    .sheetname  = "").append(field_5_sheetname).append(""
"");
		buffer.append(""[/BOUNDSHEET]
"");
		return buffer.toString();
	}

	protected int getDataSize() {
		return 8 + field_5_sheetname.length() * (isMultibyte() ? 2 : 1);
	}

	public void serialize(LittleEndianOutput out) {
		out.writeInt(getPositionOfBof());
		out.writeShort(field_2_option_flags);

		String name = field_5_sheetname;
		out.writeByte(name.length());
		out.writeByte(field_4_isMultibyteUnicode);

		if (isMultibyte()) {
			StringUtil.putUnicodeLE(name, out);
		} else {
			StringUtil.putCompressedUnicode(name, out);
		}
	}

	public short getSid() {
		return sid;
	}

	
	public boolean isHidden() {
		return hiddenFlag.isSet(field_2_option_flags);
	}

	
	public void setHidden(boolean hidden) {
		field_2_option_flags = hiddenFlag.setBoolean(field_2_option_flags, hidden);
	}

	
	public boolean isVeryHidden() {
		return veryHiddenFlag.isSet(field_2_option_flags);
	}

	
	public void setVeryHidden(boolean veryHidden) {
		field_2_option_flags = veryHiddenFlag.setBoolean(field_2_option_flags, veryHidden);
	}

	
	public static BoundSheetRecord[] orderByBofPosition(List<BoundSheetRecord> boundSheetRecords) {
		BoundSheetRecord[] bsrs = new BoundSheetRecord[boundSheetRecords.size()];
		boundSheetRecords.toArray(bsrs);
		Arrays.sort(bsrs, BOFComparator);
	 	return bsrs;
	}
	private static final Comparator<BoundSheetRecord> BOFComparator = new Comparator<BoundSheetRecord>() {

		public int compare(BoundSheetRecord bsr1, BoundSheetRecord bsr2) {
			return bsr1.getPositionOfBof() - bsr2.getPositionOfBof();
		}
	};
}
"
poi,3,org.apache.poi.ddf.EscherSimpleProperty,8,2,3,13,24,0,9,4,8,0.142857143,121,1.0,0,0.571428571,0.375,1,1,14.0,5,1.25,1,"

package org.apache.poi.ddf;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.HexDump;


public class EscherSimpleProperty extends EscherProperty
{
    protected int propertyValue;

    
    public EscherSimpleProperty( short id, int propertyValue )
    {
        super( id );
        this.propertyValue = propertyValue;
    }

    
    public EscherSimpleProperty( short propertyNumber, boolean isComplex, boolean isBlipId, int propertyValue )
    {
        super( propertyNumber, isComplex, isBlipId );
        this.propertyValue = propertyValue;
    }

    
    public int serializeSimplePart( byte[] data, int offset )
    {
        LittleEndian.putShort(data, offset, getId());
        LittleEndian.putInt(data, offset + 2, propertyValue);
        return 6;
    }

    
    public int serializeComplexPart( byte[] data, int pos )
    {
        return 0;
    }

    
    public int getPropertyValue()
    {
        return propertyValue;
    }

    
    public boolean equals( Object o )
    {
        if ( this == o ) return true;
        if ( !( o instanceof EscherSimpleProperty ) ) return false;

        final EscherSimpleProperty escherSimpleProperty = (EscherSimpleProperty) o;

        if ( propertyValue != escherSimpleProperty.propertyValue ) return false;
        if ( getId() != escherSimpleProperty.getId() ) return false;

        return true;
    }

    
    public int hashCode()
    {
        return propertyValue;
    }

    
    public String toString()
    {
        return ""propNum: "" + getPropertyNumber()
                + "", RAW: 0x"" + HexDump.toHex( getId() )
                + "", propName: "" + EscherProperties.getPropertyName( getPropertyNumber() )
                + "", complex: "" + isComplex()
                + "", blipId: "" + isBlipId()
                + "", value: "" + propertyValue + "" (0x"" + HexDump.toHex(propertyValue) + "")"";
    }

    public String toXml(String tab){
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("" id=""0x"").append(HexDump.toHex(getId()))
                .append("""" name="""").append(getName()).append("""" blipId="""")
                .append(isBlipId()).append("""" complex="""").append(isComplex()).append("""" value="""").append(""0x"")
                .append(HexDump.toHex(propertyValue)).append(""""/>
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.poifs.filesystem.POIFSWriterEvent,5,1,0,5,6,2,3,2,4,0.75,36,1.0,2,0.0,0.36,0,0,5.4,1,0.8,0,"

        

package org.apache.poi.poifs.filesystem;



public class POIFSWriterEvent
{
    private DocumentOutputStream stream;
    private POIFSDocumentPath    path;
    private String               documentName;
    private int                  limit;

    

    POIFSWriterEvent(final DocumentOutputStream stream,
                     final POIFSDocumentPath path, final String documentName,
                     final int limit)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
        this.limit        = limit;
    }

    

    public DocumentOutputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }

    

    public int getLimit()
    {
        return limit;
    }
}   

"
poi,3,org.apache.poi.hssf.record.GroupMarkerSubRecord,9,3,0,6,23,0,2,5,7,0.6875,150,0.5,0,0.631578947,0.311111111,1,4,15.44444444,2,1.0,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;


public final class GroupMarkerSubRecord extends SubRecord {
    public final static short sid = 0x0006;

    private static final byte[] EMPTY_BYTE_ARRAY = { };

    private byte[] reserved;    

    public GroupMarkerSubRecord() {
        reserved = EMPTY_BYTE_ARRAY;
    }

    public GroupMarkerSubRecord(LittleEndianInput in, int size) {
        byte[] buf = new byte[size];
        in.readFully(buf);
        reserved = buf;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        String nl = System.getProperty(""line.separator"");
        buffer.append(""[ftGmo]"" + nl);
        buffer.append(""  reserved = "").append(HexDump.toHex(reserved)).append(nl);
        buffer.append(""[/ftGmo]"" + nl);
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(sid);
        out.writeShort(reserved.length);
        out.write(reserved);
    }

	protected int getDataSize() {
        return reserved.length;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
        GroupMarkerSubRecord rec = new GroupMarkerSubRecord();
        rec.reserved = new byte[reserved.length];
        for ( int i = 0; i < reserved.length; i++ )
            rec.reserved[i] = reserved[i];
        return rec;
    }
}
"
poi,3,org.apache.poi.util.POILogFactory,4,1,0,8,15,4,6,2,2,0.333333333,55,1.0,0,0.0,0.333333333,0,0,12.5,2,0.75,0,"



package org.apache.poi.util;

import java.util.HashMap;
import java.util.Map;


@Internal
public final class POILogFactory {
    
    private static Map<String,POILogger> _loggers = new HashMap<String,POILogger>();

    
    private static final POILogger _nullLogger = new NullLogger();
    
    private static String _loggerClassName = null;

    
    private POILogFactory() {}

    
    public static POILogger getLogger(final Class<?> theclass) {
        return getLogger(theclass.getName());
    }

    
    public static POILogger getLogger(final String cat) {
        POILogger logger = null;

        
        
        
        
        
        if(_loggerClassName == null) {
        	try {
        		_loggerClassName = System.getProperty(""org.apache.poi.util.POILogger"");
        	} catch(Exception e) {}

        	
        	
        	if(_loggerClassName == null) {
                _loggerClassName = _nullLogger.getClass().getName();
        	}
        }

        
        
        if(_loggerClassName.equals(_nullLogger.getClass().getName())) {
        	return _nullLogger;
        }


        
        
        logger = _loggers.get(cat);
        if (logger == null) {
            try {
                @SuppressWarnings(""unchecked"")
                Class<? extends POILogger> loggerClass =
                    (Class<? extends POILogger>) Class.forName(_loggerClassName);
                logger = loggerClass.newInstance();
                logger.initialize(cat);
            } catch(Exception e) {
                
                logger = _nullLogger;
                _loggerClassName = _nullLogger.getClass().getName();
            }

            
            _loggers.put(cat, logger);
        }
        return logger;
    }
}"
poi,3,org.apache.poi.hssf.record.ExtendedFormatRecord,95,2,0,11,115,3119,5,6,92,0.980994502,1371,0.483146067,34,0.106796117,0.25177305,1,4,12.49473684,3,1.0,1,"
        

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.LittleEndianOutput;



public final class ExtendedFormatRecord
    extends StandardRecord
{
    public final static short     sid                 = 0xE0;

    
    public final static short     NULL                = (short)0xfff0;

    
    public final static short     XF_STYLE            = 1;
    public final static short     XF_CELL             = 0;

    
    public final static short     NONE                = 0x0;
    public final static short     THIN                = 0x1;
    public final static short     MEDIUM              = 0x2;
    public final static short     DASHED              = 0x3;
    public final static short     DOTTED              = 0x4;
    public final static short     THICK               = 0x5;
    public final static short     DOUBLE              = 0x6;
    public final static short     HAIR                = 0x7;
    public final static short     MEDIUM_DASHED       = 0x8;
    public final static short     DASH_DOT            = 0x9;
    public final static short     MEDIUM_DASH_DOT     = 0xA;
    public final static short     DASH_DOT_DOT        = 0xB;
    public final static short     MEDIUM_DASH_DOT_DOT = 0xC;
    public final static short     SLANTED_DASH_DOT    = 0xD;

    
    public final static short     GENERAL             = 0x0;
    public final static short     LEFT                = 0x1;
    public final static short     CENTER              = 0x2;
    public final static short     RIGHT               = 0x3;
    public final static short     FILL                = 0x4;
    public final static short     JUSTIFY             = 0x5;
    public final static short     CENTER_SELECTION    = 0x6;

    
    public final static short     VERTICAL_TOP        = 0x0;
    public final static short     VERTICAL_CENTER     = 0x1;
    public final static short     VERTICAL_BOTTOM     = 0x2;
    public final static short     VERTICAL_JUSTIFY    = 0x3;

    
    public final static short     NO_FILL             = 0  ;
    public final static short     SOLID_FILL          = 1  ;
    public final static short     FINE_DOTS           = 2  ;
    public final static short     ALT_BARS            = 3  ;
    public final static short     SPARSE_DOTS         = 4  ;
    public final static short     THICK_HORZ_BANDS    = 5  ;
    public final static short     THICK_VERT_BANDS    = 6  ;
    public final static short     THICK_BACKWARD_DIAG = 7  ;
    public final static short     THICK_FORWARD_DIAG  = 8  ;
    public final static short     BIG_SPOTS           = 9  ;
    public final static short     BRICKS              = 10 ;
    public final static short     THIN_HORZ_BANDS     = 11 ;
    public final static short     THIN_VERT_BANDS     = 12 ;
    public final static short     THIN_BACKWARD_DIAG  = 13 ;
    public final static short     THIN_FORWARD_DIAG   = 14 ;
    public final static short     SQUARES             = 15 ;
    public final static short     DIAMONDS            = 16 ;

    
    private short                 field_1_font_index;             
    private short                 field_2_format_index;           

    
    static final private BitField _locked       = BitFieldFactory.getInstance(0x0001);
    static final private BitField _hidden       = BitFieldFactory.getInstance(0x0002);
    static final private BitField _xf_type      = BitFieldFactory.getInstance(0x0004);
    static final private BitField _123_prefix   = BitFieldFactory.getInstance(0x0008);
    static final private BitField _parent_index = BitFieldFactory.getInstance(0xFFF0);
    private short                 field_3_cell_options;

    
    static final private BitField _alignment          = BitFieldFactory.getInstance(0x0007);
    static final private BitField _wrap_text          = BitFieldFactory.getInstance(0x0008);
    static final private BitField _vertical_alignment = BitFieldFactory.getInstance(0x0070);
    static final private BitField _justify_last       = BitFieldFactory.getInstance(0x0080);
    static final private BitField _rotation           = BitFieldFactory.getInstance(0xFF00);
    private short                 field_4_alignment_options;

    
    static final private BitField _indent                         =
        BitFieldFactory.getInstance(0x000F);
    static final private BitField _shrink_to_fit                  =
        BitFieldFactory.getInstance(0x0010);
    static final private BitField _merge_cells                    =
        BitFieldFactory.getInstance(0x0020);
    static final private BitField _reading_order                  =
        BitFieldFactory.getInstance(0x00C0);

    
    static final private BitField _indent_not_parent_format       =
        BitFieldFactory.getInstance(0x0400);
    static final private BitField _indent_not_parent_font         =
        BitFieldFactory.getInstance(0x0800);
    static final private BitField _indent_not_parent_alignment    =
        BitFieldFactory.getInstance(0x1000);
    static final private BitField _indent_not_parent_border       =
        BitFieldFactory.getInstance(0x2000);
    static final private BitField _indent_not_parent_pattern      =
        BitFieldFactory.getInstance(0x4000);
    static final private BitField _indent_not_parent_cell_options =
        BitFieldFactory.getInstance(0x8000);
    private short                 field_5_indention_options;

    
    static final private BitField _border_left   = BitFieldFactory.getInstance(0x000F);
    static final private BitField _border_right  = BitFieldFactory.getInstance(0x00F0);
    static final private BitField _border_top    = BitFieldFactory.getInstance(0x0F00);
    static final private BitField _border_bottom = BitFieldFactory.getInstance(0xF000);
    private short                 field_6_border_options;

    
    
    static final private BitField _left_border_palette_idx  =
        BitFieldFactory.getInstance(0x007F);
    static final private BitField _right_border_palette_idx =
        BitFieldFactory.getInstance(0x3F80);
    static final private BitField _diag                     =
        BitFieldFactory.getInstance(0xC000);
    private short                 field_7_palette_options;

    
    static final private BitField _top_border_palette_idx    =
        BitFieldFactory.getInstance(0x0000007F);
    static final private BitField _bottom_border_palette_idx =
        BitFieldFactory.getInstance(0x00003F80);
    static final private BitField _adtl_diag                 =
        BitFieldFactory.getInstance(0x001fc000);
    static final private BitField _adtl_diag_line_style      =
        BitFieldFactory.getInstance(0x01e00000);

    
    static final private BitField _adtl_fill_pattern         =
        BitFieldFactory.getInstance(0xfc000000);
    private int                   field_8_adtl_palette_options;   

    
    static final private BitField _fill_foreground = BitFieldFactory.getInstance(0x007F);
    static final private BitField _fill_background = BitFieldFactory.getInstance(0x3f80);

    
    private short                 field_9_fill_palette_options;

    

    public ExtendedFormatRecord()
    {
    }

    public ExtendedFormatRecord(RecordInputStream in)
    {
        field_1_font_index           = in.readShort();
        field_2_format_index         = in.readShort();
        field_3_cell_options         = in.readShort();
        field_4_alignment_options    = in.readShort();
        field_5_indention_options    = in.readShort();
        field_6_border_options       = in.readShort();
        field_7_palette_options      = in.readShort();
        field_8_adtl_palette_options = in.readInt();
        field_9_fill_palette_options = in.readShort();
    }

    

    public void setFontIndex(short index)
    {
        field_1_font_index = index;
    }

    

    public void setFormatIndex(short index)
    {
        field_2_format_index = index;
    }

    

    public void setCellOptions(short options)
    {
        field_3_cell_options = options;
    }

    

    

    public void setLocked(boolean locked)
    {
        field_3_cell_options = _locked.setShortBoolean(field_3_cell_options,
                locked);
    }

    

    public void setHidden(boolean hidden)
    {
        field_3_cell_options = _hidden.setShortBoolean(field_3_cell_options,
                hidden);
    }

    

    public void setXFType(short type)
    {
        field_3_cell_options = _xf_type.setShortValue(field_3_cell_options,
                type);
    }

    

    public void set123Prefix(boolean prefix)
    {
        field_3_cell_options =
            _123_prefix.setShortBoolean(field_3_cell_options, prefix);
    }

    

    

    public void setParentIndex(short parent)
    {
        field_3_cell_options =
            _parent_index.setShortValue(field_3_cell_options, parent);
    }

    

    

    public void setAlignmentOptions(short options)
    {
        field_4_alignment_options = options;
    }

    

    public void setAlignment(short align)
    {
        field_4_alignment_options =
            _alignment.setShortValue(field_4_alignment_options, align);
    }

    

    public void setWrapText(boolean wrapped)
    {
        field_4_alignment_options =
            _wrap_text.setShortBoolean(field_4_alignment_options, wrapped);
    }

    

    public void setVerticalAlignment(short align)
    {
        field_4_alignment_options =
            _vertical_alignment.setShortValue(field_4_alignment_options,
                                              align);
    }

    

    public void setJustifyLast(short justify)
    {   
        field_4_alignment_options =
            _justify_last.setShortValue(field_4_alignment_options, justify);
    }

    

    public void setRotation(short rotation)
    {
        field_4_alignment_options =
            _rotation.setShortValue(field_4_alignment_options, rotation);
    }

    

    public void setIndentionOptions(short options)
    {
        field_5_indention_options = options;
    }

    

    

    public void setIndent(short indent)
    {
        field_5_indention_options =
            _indent.setShortValue(field_5_indention_options, indent);
    }

    

    public void setShrinkToFit(boolean shrink)
    {
        field_5_indention_options =
            _shrink_to_fit.setShortBoolean(field_5_indention_options, shrink);
    }

    

    public void setMergeCells(boolean merge)
    {
        field_5_indention_options =
            _merge_cells.setShortBoolean(field_5_indention_options, merge);
    }

    

    public void setReadingOrder(short order)
    {   
        field_5_indention_options =
            _reading_order.setShortValue(field_5_indention_options, order);
    }

    

    public void setIndentNotParentFormat(boolean parent)
    {
        field_5_indention_options =
            _indent_not_parent_format
                .setShortBoolean(field_5_indention_options, parent);
    }

    

    public void setIndentNotParentFont(boolean font)
    {
        field_5_indention_options =
            _indent_not_parent_font.setShortBoolean(field_5_indention_options,
                                                    font);
    }

    

    public void setIndentNotParentAlignment(boolean alignment)
    {
        field_5_indention_options =
            _indent_not_parent_alignment
                .setShortBoolean(field_5_indention_options, alignment);
    }

    

    public void setIndentNotParentBorder(boolean border)
    {
        field_5_indention_options =
            _indent_not_parent_border
                .setShortBoolean(field_5_indention_options, border);
    }

    

    public void setIndentNotParentPattern(boolean pattern)
    {
        field_5_indention_options =
            _indent_not_parent_pattern
                .setShortBoolean(field_5_indention_options, pattern);
    }

    

    public void setIndentNotParentCellOptions(boolean options)
    {
        field_5_indention_options =
            _indent_not_parent_cell_options
                .setShortBoolean(field_5_indention_options, options);
    }

    

    

    public void setBorderOptions(short options)
    {
        field_6_border_options = options;
    }

    

    

    public void setBorderLeft(short border)
    {
        field_6_border_options =
            _border_left.setShortValue(field_6_border_options, border);
    }

    

    public void setBorderRight(short border)
    {
        field_6_border_options =
            _border_right.setShortValue(field_6_border_options, border);
    }

    

    public void setBorderTop(short border)
    {
        field_6_border_options =
            _border_top.setShortValue(field_6_border_options, border);
    }

    

    public void setBorderBottom(short border)
    {
        field_6_border_options =
            _border_bottom.setShortValue(field_6_border_options, border);
    }

    

    

    public void setPaletteOptions(short options)
    {
        field_7_palette_options = options;
    }

    

    

    public void setLeftBorderPaletteIdx(short border)
    {
        field_7_palette_options =
            _left_border_palette_idx.setShortValue(field_7_palette_options,
                                                   border);
    }

    

    public void setRightBorderPaletteIdx(short border)
    {
        field_7_palette_options =
            _right_border_palette_idx.setShortValue(field_7_palette_options,
                                                    border);
    }

    
    

    

    public void setDiag(short diag)
    {
        field_7_palette_options = _diag.setShortValue(field_7_palette_options,
                diag);
    }

    

    

    public void setAdtlPaletteOptions(short options)
    {
        field_8_adtl_palette_options = options;
    }

    

    

    public void setTopBorderPaletteIdx(short border)
    {
        field_8_adtl_palette_options =
            _top_border_palette_idx.setValue(field_8_adtl_palette_options,
                                             border);
    }

    

    public void setBottomBorderPaletteIdx(short border)
    {
        field_8_adtl_palette_options =
            _bottom_border_palette_idx.setValue(field_8_adtl_palette_options,
                                                border);
    }

    

    public void setAdtlDiag(short diag)
    {
        field_8_adtl_palette_options =
            _adtl_diag.setValue(field_8_adtl_palette_options, diag);
    }

    

    public void setAdtlDiagLineStyle(short diag)
    {
        field_8_adtl_palette_options =
            _adtl_diag_line_style.setValue(field_8_adtl_palette_options,
                                           diag);
    }

    

    public void setAdtlFillPattern(short fill)
    {
        field_8_adtl_palette_options =
            _adtl_fill_pattern.setValue(field_8_adtl_palette_options, fill);
    }

    

    

    public void setFillPaletteOptions(short options)
    {
        field_9_fill_palette_options = options;
    }

    

    public void setFillForeground(short color)
    {
        field_9_fill_palette_options =
            _fill_foreground.setShortValue(field_9_fill_palette_options,
                                           color);
    }

    

    public void setFillBackground(short color)
    {
        field_9_fill_palette_options =
            _fill_background.setShortValue(field_9_fill_palette_options,
                                           color);
    }

    

    public short getFontIndex()
    {
        return field_1_font_index;
    }

    

    public short getFormatIndex()
    {
        return field_2_format_index;
    }

    

    public short getCellOptions()
    {
        return field_3_cell_options;
    }

    

    

    public boolean isLocked()
    {
        return _locked.isSet(field_3_cell_options);
    }

    

    public boolean isHidden()
    {
        return _hidden.isSet(field_3_cell_options);
    }

    

    public short getXFType()
    {
        return _xf_type.getShortValue(field_3_cell_options);
    }

    

    public boolean get123Prefix()
    {
        return _123_prefix.isSet(field_3_cell_options);
    }

    

    public short getParentIndex()
    {
        return _parent_index.getShortValue(field_3_cell_options);
    }

    

    

    public short getAlignmentOptions()
    {
        return field_4_alignment_options;
    }

    

    

    public short getAlignment()
    {
        return _alignment.getShortValue(field_4_alignment_options);
    }

    

    public boolean getWrapText()
    {
        return _wrap_text.isSet(field_4_alignment_options);
    }

    

    public short getVerticalAlignment()
    {
        return _vertical_alignment.getShortValue(field_4_alignment_options);
    }

    

    public short getJustifyLast()
    {   
        return _justify_last.getShortValue(field_4_alignment_options);
    }

    

    public short getRotation()
    {
        return _rotation.getShortValue(field_4_alignment_options);
    }

    

    

    public short getIndentionOptions()
    {
        return field_5_indention_options;
    }

    

    

    public short getIndent()
    {
        return _indent.getShortValue(field_5_indention_options);
    }

    

    public boolean getShrinkToFit()
    {
        return _shrink_to_fit.isSet(field_5_indention_options);
    }

    

    public boolean getMergeCells()
    {
        return _merge_cells.isSet(field_5_indention_options);
    }

    

    public short getReadingOrder()
    {   
        return _reading_order.getShortValue(field_5_indention_options);
    }

    

    public boolean isIndentNotParentFormat()
    {
        return _indent_not_parent_format.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentFont()
    {
        return _indent_not_parent_font.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentAlignment()
    {
        return _indent_not_parent_alignment.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentBorder()
    {
        return _indent_not_parent_border.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentPattern()
    {
        return _indent_not_parent_pattern.isSet(field_5_indention_options);
    }

    

    public boolean isIndentNotParentCellOptions()
    {
        return _indent_not_parent_cell_options
            .isSet(field_5_indention_options);
    }

    
    

    

    public short getBorderOptions()
    {
        return field_6_border_options;
    }

    

    

    public short getBorderLeft()
    {
        return _border_left.getShortValue(field_6_border_options);
    }

    

    public short getBorderRight()
    {
        return _border_right.getShortValue(field_6_border_options);
    }

    

    public short getBorderTop()
    {
        return _border_top.getShortValue(field_6_border_options);
    }

    

    public short getBorderBottom()
    {
        return _border_bottom.getShortValue(field_6_border_options);
    }

    

    

    public short getPaletteOptions()
    {
        return field_7_palette_options;
    }

    

    

    public short getLeftBorderPaletteIdx()
    {
        return _left_border_palette_idx
            .getShortValue(field_7_palette_options);
    }

    

    public short getRightBorderPaletteIdx()
    {
        return _right_border_palette_idx
            .getShortValue(field_7_palette_options);
    }

    
    

    

    public short getDiag()
    {
        return _diag.getShortValue(field_7_palette_options);
    }

    
    

    

    public int getAdtlPaletteOptions()
    {
        return field_8_adtl_palette_options;
    }

    

    

    public short getTopBorderPaletteIdx()
    {
        return ( short ) _top_border_palette_idx
            .getValue(field_8_adtl_palette_options);
    }

    

    public short getBottomBorderPaletteIdx()
    {
        return ( short ) _bottom_border_palette_idx
            .getValue(field_8_adtl_palette_options);
    }

    

    public short getAdtlDiag()
    {
        return ( short ) _adtl_diag.getValue(field_8_adtl_palette_options);
    }

    

    public short getAdtlDiagLineStyle()
    {
        return ( short ) _adtl_diag_line_style
            .getValue(field_8_adtl_palette_options);
    }

    

    public short getAdtlFillPattern()
    {
        return ( short ) _adtl_fill_pattern
            .getValue(field_8_adtl_palette_options);
    }

    
    

    

    public short getFillPaletteOptions()
    {
        return field_9_fill_palette_options;
    }

    

    

    public short getFillForeground()
    {
        return _fill_foreground.getShortValue(field_9_fill_palette_options);
    }

    

    public short getFillBackground()
    {
        return _fill_background.getShortValue(field_9_fill_palette_options);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[EXTENDEDFORMAT]
"");
        if (getXFType() == XF_STYLE)
        {
            buffer.append("" STYLE_RECORD_TYPE
"");
        }
        else if (getXFType() == XF_CELL)
        {
            buffer.append("" CELL_RECORD_TYPE
"");
        }
        buffer.append(""    .fontindex       = "")
            .append(Integer.toHexString(getFontIndex())).append(""
"");
        buffer.append(""    .formatindex     = "")
            .append(Integer.toHexString(getFormatIndex())).append(""
"");
        buffer.append(""    .celloptions     = "")
            .append(Integer.toHexString(getCellOptions())).append(""
"");
        buffer.append(""          .islocked  = "").append(isLocked())
            .append(""
"");
        buffer.append(""          .ishidden  = "").append(isHidden())
            .append(""
"");
        buffer.append(""          .recordtype= "")
            .append(Integer.toHexString(getXFType())).append(""
"");
        buffer.append(""          .parentidx = "")
            .append(Integer.toHexString(getParentIndex())).append(""
"");
        buffer.append(""    .alignmentoptions= "")
            .append(Integer.toHexString(getAlignmentOptions())).append(""
"");
        buffer.append(""          .alignment = "").append(getAlignment())
            .append(""
"");
        buffer.append(""          .wraptext  = "").append(getWrapText())
            .append(""
"");
        buffer.append(""          .valignment= "")
            .append(Integer.toHexString(getVerticalAlignment())).append(""
"");
        buffer.append(""          .justlast  = "")
            .append(Integer.toHexString(getJustifyLast())).append(""
"");
        buffer.append(""          .rotation  = "")
            .append(Integer.toHexString(getRotation())).append(""
"");
        buffer.append(""    .indentionoptions= "")
            .append(Integer.toHexString(getIndentionOptions())).append(""
"");
        buffer.append(""          .indent    = "")
            .append(Integer.toHexString(getIndent())).append(""
"");
        buffer.append(""          .shrinktoft= "").append(getShrinkToFit())
            .append(""
"");
        buffer.append(""          .mergecells= "").append(getMergeCells())
            .append(""
"");
        buffer.append(""          .readngordr= "")
            .append(Integer.toHexString(getReadingOrder())).append(""
"");
        buffer.append(""          .formatflag= "")
            .append(isIndentNotParentFormat()).append(""
"");
        buffer.append(""          .fontflag  = "")
            .append(isIndentNotParentFont()).append(""
"");
        buffer.append(""          .prntalgnmt= "")
            .append(isIndentNotParentAlignment()).append(""
"");
        buffer.append(""          .borderflag= "")
            .append(isIndentNotParentBorder()).append(""
"");
        buffer.append(""          .paternflag= "")
            .append(isIndentNotParentPattern()).append(""
"");
        buffer.append(""          .celloption= "")
            .append(isIndentNotParentCellOptions()).append(""
"");
        buffer.append(""    .borderoptns     = "")
            .append(Integer.toHexString(getBorderOptions())).append(""
"");
        buffer.append(""          .lftln     = "")
            .append(Integer.toHexString(getBorderLeft())).append(""
"");
        buffer.append(""          .rgtln     = "")
            .append(Integer.toHexString(getBorderRight())).append(""
"");
        buffer.append(""          .topln     = "")
            .append(Integer.toHexString(getBorderTop())).append(""
"");
        buffer.append(""          .btmln     = "")
            .append(Integer.toHexString(getBorderBottom())).append(""
"");
        buffer.append(""    .paleteoptns     = "")
            .append(Integer.toHexString(getPaletteOptions())).append(""
"");
        buffer.append(""          .leftborder= "")
            .append(Integer.toHexString(getLeftBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .rghtborder= "")
            .append(Integer.toHexString(getRightBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .diag      = "")
            .append(Integer.toHexString(getDiag())).append(""
"");
        buffer.append(""    .paleteoptn2     = "")
            .append(Integer.toHexString(getAdtlPaletteOptions()))
            .append(""
"");
        buffer.append(""          .topborder = "")
            .append(Integer.toHexString(getTopBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .botmborder= "")
            .append(Integer.toHexString(getBottomBorderPaletteIdx()))
            .append(""
"");
        buffer.append(""          .adtldiag  = "")
            .append(Integer.toHexString(getAdtlDiag())).append(""
"");
        buffer.append(""          .diaglnstyl= "")
            .append(Integer.toHexString(getAdtlDiagLineStyle())).append(""
"");
        buffer.append(""          .fillpattrn= "")
            .append(Integer.toHexString(getAdtlFillPattern())).append(""
"");
        buffer.append(""    .fillpaloptn     = "")
            .append(Integer.toHexString(getFillPaletteOptions()))
            .append(""
"");
        buffer.append(""          .foreground= "")
            .append(Integer.toHexString(getFillForeground())).append(""
"");
        buffer.append(""          .background= "")
            .append(Integer.toHexString(getFillBackground())).append(""
"");
        buffer.append(""[/EXTENDEDFORMAT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getFontIndex());
        out.writeShort(getFormatIndex());
        out.writeShort(getCellOptions());
        out.writeShort(getAlignmentOptions());
        out.writeShort(getIndentionOptions());
        out.writeShort(getBorderOptions());
        out.writeShort(getPaletteOptions());
        out.writeInt(getAdtlPaletteOptions());
        out.writeShort(getFillPaletteOptions());
    }

    protected int getDataSize() {
        return 20;
    }

    public short getSid()
    {
        return sid;
    }
    
    
    public void cloneStyleFrom(ExtendedFormatRecord source) {
        field_1_font_index           = source.field_1_font_index;
        field_2_format_index         = source.field_2_format_index;
        field_3_cell_options         = source.field_3_cell_options;
        field_4_alignment_options    = source.field_4_alignment_options;
        field_5_indention_options    = source.field_5_indention_options;
        field_6_border_options       = source.field_6_border_options;
        field_7_palette_options      = source.field_7_palette_options;
        field_8_adtl_palette_options = source.field_8_adtl_palette_options;
        field_9_fill_palette_options = source.field_9_fill_palette_options;
    }

	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + field_1_font_index;
		result = prime * result + field_2_format_index;
		result = prime * result + field_3_cell_options;
		result = prime * result + field_4_alignment_options;
		result = prime * result + field_5_indention_options;
		result = prime * result + field_6_border_options;
		result = prime * result + field_7_palette_options;
		result = prime * result + field_8_adtl_palette_options;
		result = prime * result + field_9_fill_palette_options;
		return result;
	}

	
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (obj instanceof ExtendedFormatRecord) {
			final ExtendedFormatRecord other = (ExtendedFormatRecord) obj;
			if (field_1_font_index != other.field_1_font_index)
				return false;
			if (field_2_format_index != other.field_2_format_index)
				return false;
			if (field_3_cell_options != other.field_3_cell_options)
				return false;
			if (field_4_alignment_options != other.field_4_alignment_options)
				return false;
			if (field_5_indention_options != other.field_5_indention_options)
				return false;
			if (field_6_border_options != other.field_6_border_options)
				return false;
			if (field_7_palette_options != other.field_7_palette_options)
				return false;
			if (field_8_adtl_palette_options != other.field_8_adtl_palette_options)
				return false;
			if (field_9_fill_palette_options != other.field_9_fill_palette_options)
				return false;
			return true;
		}
		return false;
	}
	
	public int[] stateSummary() {
		return new int[] { field_1_font_index, field_2_format_index, field_3_cell_options, field_4_alignment_options,
				field_5_indention_options, field_6_border_options, field_7_palette_options, field_8_adtl_palette_options, field_9_fill_palette_options };
	}
    
    
}
"
poi,3,org.apache.poi.hpsf.NoSingleSectionException,4,5,0,3,8,6,2,1,4,2.0,20,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"

package org.apache.poi.hpsf;


public class NoSingleSectionException extends HPSFRuntimeException
{

    
    public NoSingleSectionException()
    {
        super();
    }


    
    public NoSingleSectionException(final String msg)
    {
        super(msg);
    }


    
    public NoSingleSectionException(final Throwable reason)
    {
        super(reason);
    }


    
    public NoSingleSectionException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFSimpleShape,3,2,2,12,4,0,10,2,2,1.25,24,0.0,0,0.888888889,0.5,0,0,5.0,1,0.6667,0,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;
import org.apache.poi.ss.usermodel.RichTextString;


public class HSSFSimpleShape extends HSSFShape
{
    
    

    public final static short       OBJECT_TYPE_LINE               = HSSFShapeTypes.Line;
    public final static short       OBJECT_TYPE_RECTANGLE          = HSSFShapeTypes.Rectangle;
    public final static short       OBJECT_TYPE_OVAL               = HSSFShapeTypes.Ellipse;
    public final static short       OBJECT_TYPE_ARC                = HSSFShapeTypes.Arc;
    


    public final static short       OBJECT_TYPE_PICTURE            = HSSFShapeTypes.PictureFrame;











    public final static short       OBJECT_TYPE_COMBO_BOX          = HSSFShapeTypes.HostControl;
    public final static short       OBJECT_TYPE_COMMENT            = HSSFShapeTypes.TextBox;
    public final static short       OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING = 30;

    public final static int WRAP_SQUARE = 0;
    public final static int WRAP_BY_POINTS = 1;
    public final static int WRAP_NONE = 2;

    private TextObjectRecord _textObjectRecord;

    public HSSFSimpleShape(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord textObjectRecord) {
        super(spContainer, objRecord);
        this._textObjectRecord = textObjectRecord;
    }

    public HSSFSimpleShape(EscherContainerRecord spContainer, ObjRecord objRecord) {
        super(spContainer, objRecord);
    }

    public HSSFSimpleShape( HSSFShape parent, HSSFAnchor anchor)
    {
        super( parent, anchor );
        _textObjectRecord = createTextObjRecord();
    }

    protected TextObjectRecord getTextObjectRecord() {
        return _textObjectRecord;
    }

    protected TextObjectRecord createTextObjRecord(){
        TextObjectRecord obj = new TextObjectRecord();
        obj.setHorizontalTextAlignment(2);
        obj.setVerticalTextAlignment(2);
        obj.setTextLocked(true);
        obj.setTextOrientation(TextObjectRecord.TEXT_ORIENTATION_NONE);
        obj.setStr(new HSSFRichTextString(""""));
        return obj;
    }

    @Override
    protected EscherContainerRecord createSpContainer() {
        EscherContainerRecord spContainer = new EscherContainerRecord();
        spContainer.setRecordId( EscherContainerRecord.SP_CONTAINER );
        spContainer.setOptions( (short) 0x000F );

        EscherSpRecord sp = new EscherSpRecord();
        sp.setRecordId( EscherSpRecord.RECORD_ID );
        sp.setFlags( EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        sp.setVersion((short) 0x2);

        EscherClientDataRecord clientData = new EscherClientDataRecord();
        clientData.setRecordId( EscherClientDataRecord.RECORD_ID );
        clientData.setOptions( (short) (0x0000) );

        EscherOptRecord optRecord = new EscherOptRecord();
        optRecord.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEDASHING, LINESTYLE_SOLID));
        optRecord.setEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));

        optRecord.setEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, FILL__FILLCOLOR_DEFAULT));
        optRecord.setEscherProperty(new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, LINESTYLE__COLOR_DEFAULT));
        optRecord.setEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, NO_FILLHITTEST_FALSE));
        optRecord.setEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));

        optRecord.setEscherProperty( new EscherShapePathProperty( EscherProperties.GEOMETRY__SHAPEPATH, EscherShapePathProperty.COMPLEX ) );
        optRecord.setEscherProperty(new EscherBoolProperty( EscherProperties.GROUPSHAPE__PRINT, 0x080000));
        optRecord.setRecordId( EscherOptRecord.RECORD_ID );

        EscherTextboxRecord escherTextbox = new EscherTextboxRecord();
        escherTextbox.setRecordId(EscherTextboxRecord.RECORD_ID);
        escherTextbox.setOptions((short) 0x0000);

        spContainer.addChildRecord(sp);
        spContainer.addChildRecord(optRecord);
        spContainer.addChildRecord(getAnchor().getEscherAnchor());
        spContainer.addChildRecord(clientData);
        spContainer.addChildRecord(escherTextbox);
        return spContainer;
    }

    @Override
    protected ObjRecord createObjRecord() {
        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setLocked(true);
        c.setPrintable(true);
        c.setAutofill(true);
        c.setAutoline(true);
        EndSubRecord e = new EndSubRecord();

        obj.addSubRecord(c);
        obj.addSubRecord(e);
        return obj;
    }

    @Override
    protected void afterRemove(HSSFPatriarch patriarch) {
        patriarch._getBoundAggregate().removeShapeToObjRecord(getEscherContainer().getChildById(EscherClientDataRecord.RECORD_ID));
        if (null != getEscherContainer().getChildById(EscherTextboxRecord.RECORD_ID)){
            patriarch._getBoundAggregate().removeShapeToObjRecord(getEscherContainer().getChildById(EscherTextboxRecord.RECORD_ID));
        }
    }

    
    public HSSFRichTextString getString() {
        return _textObjectRecord.getStr();
    }

    
    public void setString(RichTextString string) {
        
        if (getShapeType() == 0 || getShapeType() == OBJECT_TYPE_LINE){
            throw new IllegalStateException(""Cannot set text for shape type: ""+getShapeType());
        }
        HSSFRichTextString rtr = (HSSFRichTextString) string;
        
        if (rtr.numFormattingRuns() == 0) rtr.applyFont((short) 0);
        TextObjectRecord txo = getOrCreateTextObjRecord();
        txo.setStr(rtr);
        if (string.getString() != null){
            setPropertyValue(new EscherSimpleProperty(EscherProperties.TEXT__TEXTID, string.getString().hashCode()));
        }
    }

    @Override
    void afterInsert(HSSFPatriarch patriarch){
        EscherAggregate agg = patriarch._getBoundAggregate();
        agg.associateShapeToObjRecord(getEscherContainer().getChildById(EscherClientDataRecord.RECORD_ID), getObjRecord());

        if (null != getTextObjectRecord()){
            agg.associateShapeToObjRecord(getEscherContainer().getChildById(EscherTextboxRecord.RECORD_ID), getTextObjectRecord());
        }
    }

    @Override
    protected HSSFShape cloneShape() {
        TextObjectRecord txo = null;
        EscherContainerRecord spContainer = new EscherContainerRecord();
        byte [] inSp = getEscherContainer().serialize();
        spContainer.fillFields(inSp, 0, new DefaultEscherRecordFactory());
        ObjRecord obj = (ObjRecord) getObjRecord().cloneViaReserialise();
        if (getTextObjectRecord() != null && getString() != null && null != getString().getString()){
            txo = (TextObjectRecord) getTextObjectRecord().cloneViaReserialise();
        }
        return new HSSFSimpleShape(spContainer, obj, txo);
    }


    
    public int getShapeType() {
        EscherSpRecord spRecord = getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        return spRecord.getShapeType();
    }

    public int getWrapText(){
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.TEXT__WRAPTEXT);
        return null == property ? WRAP_SQUARE : property.getPropertyValue();
    }

    public void setWrapText(int value){
        setPropertyValue(new EscherSimpleProperty(EscherProperties.TEXT__WRAPTEXT, false, false, value));
    }

    
    public void setShapeType(int value){
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) getObjRecord().getSubRecords().get(0);
        cod.setObjectType(OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING);
        EscherSpRecord spRecord = getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        spRecord.setShapeType((short) value);
    }
    
    private TextObjectRecord getOrCreateTextObjRecord(){
        if (getTextObjectRecord() == null){
            _textObjectRecord = createTextObjRecord();
        }
        EscherTextboxRecord escherTextbox = getEscherContainer().getChildById(EscherTextboxRecord.RECORD_ID);
        if (null == escherTextbox){
            escherTextbox = new EscherTextboxRecord();
            escherTextbox.setRecordId(EscherTextboxRecord.RECORD_ID);
            escherTextbox.setOptions((short) 0x0000);
            getEscherContainer().addChildRecord(escherTextbox);
            getPatriarch()._getBoundAggregate().associateShapeToObjRecord(escherTextbox, _textObjectRecord);
        }
        return _textObjectRecord;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFShape,17,1,3,18,19,84,15,3,16,0.994047619,152,0.0,2,0.0,0.317647059,0,0,6.705882353,4,1.1176,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.util.LittleEndian;

import java.io.ByteArrayOutputStream;
import java.io.IOException;


public abstract class HSSFShape {
    public static final int LINEWIDTH_ONE_PT = 12700;
    public static final int LINEWIDTH_DEFAULT = 9525;
    public static final int LINESTYLE__COLOR_DEFAULT = 0x08000040;
    public static final int FILL__FILLCOLOR_DEFAULT = 0x08000009;
    public static final boolean NO_FILL_DEFAULT = true;

    public static final int LINESTYLE_SOLID = 0;              
    public static final int LINESTYLE_DASHSYS = 1;            
    public static final int LINESTYLE_DOTSYS = 2;             
    public static final int LINESTYLE_DASHDOTSYS = 3;         
    public static final int LINESTYLE_DASHDOTDOTSYS = 4;      
    public static final int LINESTYLE_DOTGEL = 5;             
    public static final int LINESTYLE_DASHGEL = 6;            
    public static final int LINESTYLE_LONGDASHGEL = 7;        
    public static final int LINESTYLE_DASHDOTGEL = 8;         
    public static final int LINESTYLE_LONGDASHDOTGEL = 9;     
    public static final int LINESTYLE_LONGDASHDOTDOTGEL = 10; 
    public static final int LINESTYLE_NONE = -1;

    public static final int LINESTYLE_DEFAULT = LINESTYLE_NONE;

    
    private HSSFShape parent;
    HSSFAnchor anchor;
    private HSSFPatriarch _patriarch;

    private final EscherContainerRecord _escherContainer;
    private final ObjRecord _objRecord;
    private final EscherOptRecord _optRecord;
    
    public final static int NO_FILLHITTEST_TRUE = 0x00110000;
    public final static int NO_FILLHITTEST_FALSE = 0x00010000;

    
    public HSSFShape(EscherContainerRecord spContainer, ObjRecord objRecord) {
        this._escherContainer = spContainer;
        this._objRecord = objRecord;
        this._optRecord = spContainer.getChildById(EscherOptRecord.RECORD_ID);
        this.anchor = HSSFAnchor.createAnchorFromEscher(spContainer);
    }

    
    public HSSFShape(HSSFShape parent, HSSFAnchor anchor) {
        this.parent = parent;
        this.anchor = anchor;
        this._escherContainer = createSpContainer();
        _optRecord = _escherContainer.getChildById(EscherOptRecord.RECORD_ID);
        _objRecord = createObjRecord();

    }

    protected abstract EscherContainerRecord createSpContainer();

    protected abstract ObjRecord createObjRecord();

    
    protected abstract void afterRemove(HSSFPatriarch patriarch);

    
    void setShapeId(int shapeId){
        EscherSpRecord spRecord = _escherContainer.getChildById(EscherSpRecord.RECORD_ID);
        spRecord.setShapeId(shapeId);
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) _objRecord.getSubRecords().get(0);
        cod.setObjectId((short) (shapeId%1024));
    }

    
    int getShapeId(){
        return ((EscherSpRecord)_escherContainer.getChildById(EscherSpRecord.RECORD_ID)).getShapeId();
    }

    abstract void afterInsert(HSSFPatriarch patriarch);

    protected EscherContainerRecord getEscherContainer() {
        return _escherContainer;
    }

    protected ObjRecord getObjRecord() {
        return _objRecord;
    }

    protected EscherOptRecord getOptRecord() {
        return _optRecord;
    }

    
    public HSSFShape getParent() {
        return parent;
    }

    
    public HSSFAnchor getAnchor() {
        return anchor;
    }

    
    public void setAnchor(HSSFAnchor anchor) {
        int i = 0;
        int recordId = -1;
        if (parent == null) {
            if (anchor instanceof HSSFChildAnchor)
                throw new IllegalArgumentException(""Must use client anchors for shapes directly attached to sheet."");
            EscherClientAnchorRecord anch = _escherContainer.getChildById(EscherClientAnchorRecord.RECORD_ID);
            if (null != anch) {
                for (i=0; i< _escherContainer.getChildRecords().size(); i++){
                    if (_escherContainer.getChild(i).getRecordId() == EscherClientAnchorRecord.RECORD_ID){
                        if (i != _escherContainer.getChildRecords().size() -1){
                            recordId = _escherContainer.getChild(i+1).getRecordId();
                        }
                    }
                }
                _escherContainer.removeChildRecord(anch);
            }
        } else {
            if (anchor instanceof HSSFClientAnchor)
                throw new IllegalArgumentException(""Must use child anchors for shapes attached to groups."");
            EscherChildAnchorRecord anch = _escherContainer.getChildById(EscherChildAnchorRecord.RECORD_ID);
            if (null != anch) {
                for (i=0; i< _escherContainer.getChildRecords().size(); i++){
                    if (_escherContainer.getChild(i).getRecordId() == EscherChildAnchorRecord.RECORD_ID){
                        if (i != _escherContainer.getChildRecords().size() -1){
                            recordId = _escherContainer.getChild(i+1).getRecordId();
                        }
                    }
                }
                _escherContainer.removeChildRecord(anch);
            }
        }
        if (-1 == recordId){
            _escherContainer.addChildRecord(anchor.getEscherAnchor());
        } else {
            _escherContainer.addChildBefore(anchor.getEscherAnchor(), recordId);
        }
        this.anchor = anchor;
    }

    
    public int getLineStyleColor() {
        EscherRGBProperty rgbProperty = _optRecord.lookup(EscherProperties.LINESTYLE__COLOR);
        return rgbProperty == null ? LINESTYLE__COLOR_DEFAULT : rgbProperty.getRgbColor();
    }

    
    public void setLineStyleColor(int lineStyleColor) {
        setPropertyValue(new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, lineStyleColor));
    }

    
    public void setLineStyleColor(int red, int green, int blue) {
        int lineStyleColor = ((blue) << 16) | ((green) << 8) | red;
        setPropertyValue(new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, lineStyleColor));
    }

    
    public int getFillColor() {
        EscherRGBProperty rgbProperty = _optRecord.lookup(EscherProperties.FILL__FILLCOLOR);
        return rgbProperty == null ? FILL__FILLCOLOR_DEFAULT : rgbProperty.getRgbColor();
    }

    
    public void setFillColor(int fillColor) {
        setPropertyValue(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, fillColor));
    }

    
    public void setFillColor(int red, int green, int blue) {
        int fillColor = ((blue) << 16) | ((green) << 8) | red;
        setPropertyValue(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, fillColor));
    }

    
    public int getLineWidth() {
        EscherSimpleProperty property = _optRecord.lookup(EscherProperties.LINESTYLE__LINEWIDTH);
        return property == null ? LINEWIDTH_DEFAULT: property.getPropertyValue();
    }

    
    public void setLineWidth(int lineWidth) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEWIDTH, lineWidth));
    }

    
    public int getLineStyle() {
        EscherSimpleProperty property = _optRecord.lookup(EscherProperties.LINESTYLE__LINEDASHING);
        if (null == property){
            return LINESTYLE_DEFAULT;
        }
        return property.getPropertyValue();
    }

    
    public void setLineStyle(int lineStyle) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEDASHING, lineStyle));
        if (getLineStyle() != HSSFShape.LINESTYLE_SOLID) {
            setPropertyValue(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDCAPSTYLE, 0));
            if (getLineStyle() == HSSFShape.LINESTYLE_NONE){
                setPropertyValue(new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080000));
            } else {
                setPropertyValue( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));
            }
        }
    }

    
    public boolean isNoFill() {
        EscherBoolProperty property = _optRecord.lookup(EscherProperties.FILL__NOFILLHITTEST);
        return property == null ? NO_FILL_DEFAULT : property.getPropertyValue() == NO_FILLHITTEST_TRUE;
    }

    
    public void setNoFill(boolean noFill) {
        setPropertyValue(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, noFill ? NO_FILLHITTEST_TRUE : NO_FILLHITTEST_FALSE));
    }

    protected void setPropertyValue(EscherProperty property){
        _optRecord.setEscherProperty(property);
    }

    
    public void setFlipVertical(boolean value){
        EscherSpRecord sp = getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        if (value){
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);
        } else {
            sp.setFlags(sp.getFlags() & (Integer.MAX_VALUE - EscherSpRecord.FLAG_FLIPVERT));
        }
    }

    
    public void setFlipHorizontal(boolean value){
        EscherSpRecord sp = getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        if (value){
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);
        } else {
            sp.setFlags(sp.getFlags() & (Integer.MAX_VALUE - EscherSpRecord.FLAG_FLIPHORIZ));
        }
    }

    
    public boolean isFlipVertical(){
        EscherSpRecord sp = getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        return (sp.getFlags() & EscherSpRecord.FLAG_FLIPVERT) != 0;
    }

    
    public boolean isFlipHorizontal(){
        EscherSpRecord sp = getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);
        return (sp.getFlags() & EscherSpRecord.FLAG_FLIPHORIZ) != 0;
    }

    
    public int getRotationDegree(){
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.TRANSFORM__ROTATION);
        if (null == property){
            return 0;
        }
        try {
            LittleEndian.putInt(property.getPropertyValue(), bos);
            return LittleEndian.getShort(bos.toByteArray(), 2);
        } catch (IOException e) {
            e.printStackTrace();
            return 0;
        }
    }

    
    public void setRotationDegree(short value){
        setPropertyValue(new EscherSimpleProperty(EscherProperties.TRANSFORM__ROTATION , (value << 16)));
    }

    
    public int countOfAllChildren() {
        return 1;
    }

    protected abstract HSSFShape cloneShape();

    protected void setPatriarch(HSSFPatriarch _patriarch) {
        this._patriarch = _patriarch;
    }

    public HSSFPatriarch getPatriarch() {
        return _patriarch;
    }

    protected void setParent(HSSFShape parent) {
        this.parent = parent;
    }
}
"
poi,3,org.apache.poi.hpsf.PropertySet,26,1,1,16,72,273,5,11,20,0.82,553,0.5,1,0.0,0.288,1,1,19.88461538,8,1.3077,0,"

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.util.LittleEndian;


public class PropertySet
{

    
    static final byte[] BYTE_ORDER_ASSERTION =
        new byte[] {(byte) 0xFE, (byte) 0xFF};

    
    protected int byteOrder;

    
    public int getByteOrder()
    {
        return byteOrder;
    }



    
    static final byte[] FORMAT_ASSERTION =
        new byte[]{(byte) 0x00, (byte) 0x00};

    
    protected int format;

    
    public int getFormat()
    {
        return format;
    }


 
    
    protected int osVersion;


    
    public static final int OS_WIN16     = 0x0000;

    
    public static final int OS_MACINTOSH = 0x0001;

    
    public static final int OS_WIN32     = 0x0002;

    
    public int getOSVersion()
    {
        return osVersion;
    }



    
    protected ClassID classID;

    
    public ClassID getClassID()
    {
        return classID;
    }



    
    public int getSectionCount()
    {
        return sections.size();
    }



    
    protected List<Section> sections;

    
    public List<Section> getSections()
    {
        return sections;
    }



    
    protected PropertySet()
    { }



    
    public PropertySet(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               IOException, UnsupportedEncodingException
    {
        if (isPropertySetStream(stream))
        {
            final int avail = stream.available();
            final byte[] buffer = new byte[avail];
            stream.read(buffer, 0, buffer.length);
            init(buffer, 0, buffer.length);
        }
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream, final int offset, final int length)
        throws NoPropertySetStreamException, UnsupportedEncodingException
    {
        if (isPropertySetStream(stream, offset, length))
            init(stream, offset, length);
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream)
    throws NoPropertySetStreamException, UnsupportedEncodingException
    {
        this(stream, 0, stream.length);
    }



    
    public static boolean isPropertySetStream(final InputStream stream)
        throws MarkUnsupportedException, IOException
    {
        
        final int BUFFER_SIZE = 50;

        
        if (!stream.markSupported())
            throw new MarkUnsupportedException(stream.getClass().getName());
        stream.mark(BUFFER_SIZE);

        
        final byte[] buffer = new byte[BUFFER_SIZE];
        final int bytes =
            stream.read(buffer, 0,
                        Math.min(buffer.length, stream.available()));
        final boolean isPropertySetStream =
            isPropertySetStream(buffer, 0, bytes);
        stream.reset();
        return isPropertySetStream;
    }



    
    public static boolean isPropertySetStream(final byte[] src,
                                              final int offset,
                                              final int length)
    {
        

        
        int o = offset;
        final int byteOrder = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        byte[] temp = new byte[LittleEndian.SHORT_SIZE];
        LittleEndian.putShort(temp, 0, (short) byteOrder);
        if (!Util.equal(temp, BYTE_ORDER_ASSERTION))
            return false;
        final int format = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        temp = new byte[LittleEndian.SHORT_SIZE];
        LittleEndian.putShort(temp, 0, (short) format);
        if (!Util.equal(temp, FORMAT_ASSERTION))
            return false;
        
        o += LittleEndian.INT_SIZE;
        
        o += ClassID.LENGTH;
        final long sectionCount = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;
        if (sectionCount < 0)
            return false;
        return true;
    }



    
    private void init(final byte[] src, final int offset, final int length)
    throws UnsupportedEncodingException
    {
        
        
        
        int o = offset;
        byteOrder = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        format = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        osVersion = (int) LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;
        classID = new ClassID(src, o);
        o += ClassID.LENGTH;
        final int sectionCount = LittleEndian.getInt(src, o);
        o += LittleEndian.INT_SIZE;
        if (sectionCount < 0)
            throw new HPSFRuntimeException(""Section count "" + sectionCount +
                                           "" is negative."");

        
        
        sections = new ArrayList<Section>( sectionCount );

        
        for (int i = 0; i < sectionCount; i++)
        {
            final Section s = new Section(src, o);
            o += ClassID.LENGTH + LittleEndian.INT_SIZE;
            sections.add(s);
        }
    }



    
    public boolean isSummaryInformation()
    {
        if (sections.size() <= 0)
            return false;
        return Util.equal(sections.get(0).getFormatID().getBytes(),
                          SectionIDMap.SUMMARY_INFORMATION_ID);
    }



    
    public boolean isDocumentSummaryInformation()
    {
        if (sections.size() <= 0)
            return false;
        return Util.equal(sections.get(0).getFormatID().getBytes(),
                          SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);
    }



    
    public Property[] getProperties()
        throws NoSingleSectionException
    {
        return getFirstSection().getProperties();
    }



    
    protected Object getProperty(final int id) throws NoSingleSectionException
    {
        return getFirstSection().getProperty(id);
    }



    
    protected boolean getPropertyBooleanValue(final int id)
        throws NoSingleSectionException
    {
        return getFirstSection().getPropertyBooleanValue(id);
    }



    
    protected int getPropertyIntValue(final int id)
        throws NoSingleSectionException
    {
        return getFirstSection().getPropertyIntValue(id);
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return getFirstSection().wasNull();
    }



    
    public Section getFirstSection()
    {
        if (getSectionCount() < 1)
            throw new MissingSectionException(""Property set does not contain any sections."");
        return sections.get(0);
    }



    
    public Section getSingleSection()
    {
        final int sectionCount = getSectionCount();
        if (sectionCount != 1)
            throw new NoSingleSectionException
                (""Property set contains "" + sectionCount + "" sections."");
        return sections.get(0);
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof PropertySet))
            return false;
        final PropertySet ps = (PropertySet) o;
        int byteOrder1 = ps.getByteOrder();
        int byteOrder2 = getByteOrder();
        ClassID classID1 = ps.getClassID();
        ClassID classID2 = getClassID();
        int format1 = ps.getFormat();
        int format2 = getFormat();
        int osVersion1 = ps.getOSVersion();
        int osVersion2 = getOSVersion();
        int sectionCount1 = ps.getSectionCount();
        int sectionCount2 = getSectionCount();
        if (byteOrder1 != byteOrder2      ||
            !classID1.equals(classID2)    ||
            format1 != format2            ||
            osVersion1 != osVersion2      ||
            sectionCount1 != sectionCount2)
            return false;

        
        return Util.equals(getSections(), ps.getSections());
    }



    
    public int hashCode()
    {
        throw new UnsupportedOperationException(""FIXME: Not yet implemented."");
    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int sectionCount = getSectionCount();
        b.append(getClass().getName());
        b.append('[');
        b.append(""byteOrder: "");
        b.append(getByteOrder());
        b.append("", classID: "");
        b.append(getClassID());
        b.append("", format: "");
        b.append(getFormat());
        b.append("", OSVersion: "");
        b.append(getOSVersion());
        b.append("", sectionCount: "");
        b.append(sectionCount);
        b.append("", sections: [
"");
        for (Section section: getSections())
            b.append(section);
        b.append(']');
        b.append(']');
        return b.toString();
    }
}
"
poi,3,org.apache.poi.hssf.record.PaneRecord,19,2,0,7,30,95,2,5,17,0.888888889,322,0.5,0,0.392857143,0.305263158,1,4,15.42105263,2,0.9474,1,"

package org.apache.poi.hssf.record;


import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class PaneRecord extends StandardRecord {
    public final static short      sid                             = 0x41;
    private  short      field_1_x;
    private  short      field_2_y;
    private  short      field_3_topRow;
    private  short      field_4_leftColumn;
    private  short      field_5_activePane;
    public final static short       ACTIVE_PANE_LOWER_RIGHT        = 0;
    public final static short       ACTIVE_PANE_UPPER_RIGHT        = 1;
    public final static short       ACTIVE_PANE_LOWER_LEFT         = 2;
    
    
    public final static short       ACTIVE_PANE_UPER_LEFT          = 3;
    public final static short       ACTIVE_PANE_UPPER_LEFT         = 3;


    public PaneRecord()
    {

    }

    public PaneRecord(RecordInputStream in)
    {
        field_1_x                      = in.readShort();
        field_2_y                      = in.readShort();
        field_3_topRow                 = in.readShort();
        field_4_leftColumn             = in.readShort();
        field_5_activePane             = in.readShort();
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PANE]
"");
        buffer.append(""    .x                    = "")
            .append(""0x"").append(HexDump.toHex(  getX ()))
            .append("" ("").append( getX() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .y                    = "")
            .append(""0x"").append(HexDump.toHex(  getY ()))
            .append("" ("").append( getY() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .topRow               = "")
            .append(""0x"").append(HexDump.toHex(  getTopRow ()))
            .append("" ("").append( getTopRow() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .leftColumn           = "")
            .append(""0x"").append(HexDump.toHex(  getLeftColumn ()))
            .append("" ("").append( getLeftColumn() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 
        buffer.append(""    .activePane           = "")
            .append(""0x"").append(HexDump.toHex(  getActivePane ()))
            .append("" ("").append( getActivePane() ).append("" )"");
        buffer.append(System.getProperty(""line.separator"")); 

        buffer.append(""[/PANE]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_x);
        out.writeShort(field_2_y);
        out.writeShort(field_3_topRow);
        out.writeShort(field_4_leftColumn);
        out.writeShort(field_5_activePane);
    }

    protected int getDataSize() {
        return 2 + 2 + 2 + 2 + 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
        PaneRecord rec = new PaneRecord();
    
        rec.field_1_x = field_1_x;
        rec.field_2_y = field_2_y;
        rec.field_3_topRow = field_3_topRow;
        rec.field_4_leftColumn = field_4_leftColumn;
        rec.field_5_activePane = field_5_activePane;
        return rec;
    }




    
    public short getX()
    {
        return field_1_x;
    }

    
    public void setX(short field_1_x)
    {
        this.field_1_x = field_1_x;
    }

    
    public short getY()
    {
        return field_2_y;
    }

    
    public void setY(short field_2_y)
    {
        this.field_2_y = field_2_y;
    }

    
    public short getTopRow()
    {
        return field_3_topRow;
    }

    
    public void setTopRow(short field_3_topRow)
    {
        this.field_3_topRow = field_3_topRow;
    }

    
    public short getLeftColumn()
    {
        return field_4_leftColumn;
    }

    
    public void setLeftColumn(short field_4_leftColumn)
    {
        this.field_4_leftColumn = field_4_leftColumn;
    }

    
    public short getActivePane()
    {
        return field_5_activePane;
    }

    
    public void setActivePane(short field_5_activePane)
    {
        this.field_5_activePane = field_5_activePane;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFTextbox,11,3,1,11,14,41,7,4,11,0.916666667,66,0.0,1,0.642857143,0.327272727,0,0,4.454545455,1,0.9091,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;


public class HSSFTextbox extends HSSFSimpleShape {
    public final static short OBJECT_TYPE_TEXT = 6;

    
    public final static short HORIZONTAL_ALIGNMENT_LEFT = 1;
    public final static short HORIZONTAL_ALIGNMENT_CENTERED = 2;
    public final static short HORIZONTAL_ALIGNMENT_RIGHT = 3;
    public final static short HORIZONTAL_ALIGNMENT_JUSTIFIED = 4;
    public final static short HORIZONTAL_ALIGNMENT_DISTRIBUTED = 7;

    
    public final static short VERTICAL_ALIGNMENT_TOP = 1;
    public final static short VERTICAL_ALIGNMENT_CENTER = 2;
    public final static short VERTICAL_ALIGNMENT_BOTTOM = 3;
    public final static short VERTICAL_ALIGNMENT_JUSTIFY = 4;
    public final static short VERTICAL_ALIGNMENT_DISTRIBUTED = 7;

    public HSSFTextbox(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord textObjectRecord) {
        super(spContainer, objRecord, textObjectRecord);
    }

    HSSFRichTextString string = new HSSFRichTextString("""");

    
    public HSSFTextbox(HSSFShape parent, HSSFAnchor anchor) {
        super(parent, anchor);
        setHorizontalAlignment(HORIZONTAL_ALIGNMENT_LEFT);
        setVerticalAlignment(VERTICAL_ALIGNMENT_TOP);
        setString(new HSSFRichTextString(""""));
    }

    @Override
    protected ObjRecord createObjRecord() {
        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType(HSSFTextbox.OBJECT_TYPE_TEXT);
        c.setLocked(true);
        c.setPrintable(true);
        c.setAutofill(true);
        c.setAutoline(true);
        EndSubRecord e = new EndSubRecord();
        obj.addSubRecord(c);
        obj.addSubRecord(e);
        return obj;
    }

    @Override
    protected EscherContainerRecord createSpContainer() {
        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherClientDataRecord clientData = new EscherClientDataRecord();
        EscherTextboxRecord escherTextbox = new EscherTextboxRecord();

        spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);
        spContainer.setOptions((short) 0x000F);
        sp.setRecordId(EscherSpRecord.RECORD_ID);
        sp.setOptions((short) ((EscherAggregate.ST_TEXTBOX << 4) | 0x2));

        sp.setFlags(EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE);
        opt.setRecordId(EscherOptRecord.RECORD_ID);
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__TEXTID, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__WRAPTEXT, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__ANCHORTEXT, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GROUPSHAPE__PRINT, 0x00080000));

        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__TEXTLEFT, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__TEXTRIGHT, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__TEXTTOP, 0));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.TEXT__TEXTBOTTOM, 0));

        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEDASHING, LINESTYLE_SOLID));
        opt.setEscherProperty(new EscherBoolProperty(EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));
        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEWIDTH, LINEWIDTH_DEFAULT));
        opt.setEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, FILL__FILLCOLOR_DEFAULT));
        opt.setEscherProperty(new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, LINESTYLE__COLOR_DEFAULT));
        opt.setEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, NO_FILLHITTEST_FALSE));
        opt.setEscherProperty(new EscherBoolProperty(EscherProperties.GROUPSHAPE__PRINT, 0x080000));

        EscherRecord anchor = getAnchor().getEscherAnchor();
        clientData.setRecordId(EscherClientDataRecord.RECORD_ID);
        clientData.setOptions((short) 0x0000);
        escherTextbox.setRecordId(EscherTextboxRecord.RECORD_ID);
        escherTextbox.setOptions((short) 0x0000);

        spContainer.addChildRecord(sp);
        spContainer.addChildRecord(opt);
        spContainer.addChildRecord(anchor);
        spContainer.addChildRecord(clientData);
        spContainer.addChildRecord(escherTextbox);

        return spContainer;
    }

    @Override
    void afterInsert(HSSFPatriarch patriarch) {
        EscherAggregate agg = patriarch._getBoundAggregate();
        agg.associateShapeToObjRecord(getEscherContainer().getChildById(EscherClientDataRecord.RECORD_ID), getObjRecord());
        if (getTextObjectRecord() != null){
            agg.associateShapeToObjRecord(getEscherContainer().getChildById(EscherTextboxRecord.RECORD_ID), getTextObjectRecord());
        }
    }

    
    public int getMarginLeft() {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.TEXT__TEXTLEFT);
        return property == null ? 0 : property.getPropertyValue();
    }

    
    public void setMarginLeft(int marginLeft) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.TEXT__TEXTLEFT, marginLeft));
    }

    
    public int getMarginRight() {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.TEXT__TEXTRIGHT);
        return property == null ? 0 : property.getPropertyValue();
    }

    
    public void setMarginRight(int marginRight) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.TEXT__TEXTRIGHT, marginRight));
    }

    
    public int getMarginTop() {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.TEXT__TEXTTOP);
        return property == null ? 0 : property.getPropertyValue();
    }

    
    public void setMarginTop(int marginTop) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.TEXT__TEXTTOP, marginTop));
    }

    
    public int getMarginBottom() {
        EscherSimpleProperty property = getOptRecord().lookup(EscherProperties.TEXT__TEXTBOTTOM);
        return property == null ? 0 : property.getPropertyValue();
    }

    
    public void setMarginBottom(int marginBottom) {
        setPropertyValue(new EscherSimpleProperty(EscherProperties.TEXT__TEXTBOTTOM, marginBottom));
    }

    
    public short getHorizontalAlignment() {
        return (short) getTextObjectRecord().getHorizontalTextAlignment();
    }

    
    public void setHorizontalAlignment(short align) {
        getTextObjectRecord().setHorizontalTextAlignment(align);
    }

    
    public short getVerticalAlignment() {
        return (short) getTextObjectRecord().getVerticalTextAlignment();
    }

    
    public void setVerticalAlignment(short align) {
        getTextObjectRecord().setVerticalTextAlignment(align);
    }

    @Override
    public void setShapeType(int shapeType) {
        throw new IllegalStateException(""Shape type can not be changed in "" + this.getClass().getSimpleName());
    }

    @Override
    protected HSSFShape cloneShape() {
        TextObjectRecord txo = getTextObjectRecord() == null ? null : (TextObjectRecord) getTextObjectRecord().cloneViaReserialise();
        EscherContainerRecord spContainer = new EscherContainerRecord();
        byte[] inSp = getEscherContainer().serialize();
        spContainer.fillFields(inSp, 0, new DefaultEscherRecordFactory());
        ObjRecord obj = (ObjRecord) getObjRecord().cloneViaReserialise();
        return new HSSFTextbox(spContainer, obj, txo);
    }

    @Override
    protected void afterRemove(HSSFPatriarch patriarch) {
        patriarch._getBoundAggregate().removeShapeToObjRecord(getEscherContainer().getChildById(EscherClientDataRecord.RECORD_ID));
        patriarch._getBoundAggregate().removeShapeToObjRecord(getEscherContainer().getChildById(EscherTextboxRecord.RECORD_ID));
    }
}
"
poi,3,org.apache.poi.hssf.record.ProtectionRev4Record,10,2,0,6,19,33,2,4,8,0.833333333,101,0.5,0,0.578947368,0.266666667,1,4,8.9,2,1.1,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class ProtectionRev4Record extends StandardRecord {
    public final static short sid = 0x01AF;

    private static final BitField protectedFlag = BitFieldFactory.getInstance(0x0001);

    private int _options;

    private ProtectionRev4Record(int options) {
        _options = options;
    }

    public ProtectionRev4Record(boolean protect) {
        this(0);
        setProtect(protect);
    }

    public ProtectionRev4Record(RecordInputStream in) {
        this(in.readUShort());
    }

    
    public void setProtect(boolean protect) {
        _options = protectedFlag.setBoolean(_options, protect);
    }

    
    public boolean getProtect() {
        return protectedFlag.isSet(_options);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PROT4REV]
"");
        buffer.append(""    .options = "").append(HexDump.shortToHex(_options)).append(""
"");
        buffer.append(""[/PROT4REV]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_options);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.StyleRecord,23,2,0,9,39,181,2,7,20,0.877272727,388,0.7,1,0.34375,0.223602484,1,4,15.43478261,4,1.3478,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;


public final class StyleRecord extends StandardRecord {
	public final static short sid = 0x0293;

	private static final BitField styleIndexMask = BitFieldFactory.getInstance(0x0FFF);
	private static final BitField isBuiltinFlag  = BitFieldFactory.getInstance(0x8000);

	
	private int field_1_xf_index;

	
	private int field_2_builtin_style;
	private int field_3_outline_style_level;

	
	private boolean field_3_stringHasMultibyte;
	private String field_4_name;

	
	public StyleRecord() {
		field_1_xf_index = isBuiltinFlag.set(field_1_xf_index);
	}

	public StyleRecord(RecordInputStream in) {
		field_1_xf_index = in.readShort();
		if (isBuiltin()) {
			field_2_builtin_style	   = in.readByte();
			field_3_outline_style_level = in.readByte();
		} else {
			int field_2_name_length = in.readShort();

			if(in.remaining() < 1) {
				
				
				if (field_2_name_length != 0) {
					throw new RecordFormatException(""Ran out of data reading style record"");
				}
				
				field_4_name = """";
			} else {

				field_3_stringHasMultibyte = in.readByte() != 0x00;
				if (field_3_stringHasMultibyte) {
					field_4_name = StringUtil.readUnicodeLE(in, field_2_name_length);
				} else {
					field_4_name = StringUtil.readCompressedUnicode(in, field_2_name_length);
				}
			}
		}
	}

	
	public void setXFIndex(int xfIndex) {
		field_1_xf_index = styleIndexMask.setValue(field_1_xf_index, xfIndex);
	}

	
	public int getXFIndex() {
		return styleIndexMask.getValue(field_1_xf_index);
	}

	
	public void setName(String name) {
		field_4_name = name;
		field_3_stringHasMultibyte = StringUtil.hasMultibyte(name);
		field_1_xf_index = isBuiltinFlag.clear(field_1_xf_index);
	}

	
	public void setBuiltinStyle(int builtinStyleId) {
		field_1_xf_index = isBuiltinFlag.set(field_1_xf_index);
		field_2_builtin_style = builtinStyleId;
	}

	
	public void setOutlineStyleLevel(int level) {
		field_3_outline_style_level = level & 0x00FF;
	}

	public boolean isBuiltin(){
		return isBuiltinFlag.isSet(field_1_xf_index);
	}

	
	public String getName() {
		return field_4_name;
	}

	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();

		sb.append(""[STYLE]
"");
		sb.append(""    .xf_index_raw ="").append(HexDump.shortToHex(field_1_xf_index)).append(""
"");
		sb.append(""        .type     ="").append(isBuiltin() ? ""built-in"" : ""user-defined"").append(""
"");
		sb.append(""        .xf_index ="").append(HexDump.shortToHex(getXFIndex())).append(""
"");
		if (isBuiltin()){
			sb.append(""    .builtin_style="").append(HexDump.byteToHex(field_2_builtin_style)).append(""
"");
			sb.append(""    .outline_level="").append(HexDump.byteToHex(field_3_outline_style_level)).append(""
"");
		} else {
			 sb.append(""    .name        ="").append(getName()).append(""
"");
		}
		sb.append(""[/STYLE]
"");
		return sb.toString();
	}


	@Override
	protected int getDataSize() {
		if (isBuiltin()) {
			return 4; 
		}
		return 2 
			+ 3 
			+ field_4_name.length() * (field_3_stringHasMultibyte ? 2 : 1);
	}

	@Override
	public void serialize(LittleEndianOutput out) {
		out.writeShort(field_1_xf_index);
		if (isBuiltin()) {
			out.writeByte(field_2_builtin_style);
			out.writeByte(field_3_outline_style_level);
		} else {
			out.writeShort(field_4_name.length());
			out.writeByte(field_3_stringHasMultibyte ? 0x01 : 0x00);
			if (field_3_stringHasMultibyte) {
				StringUtil.putUnicodeLE(getName(), out);
			} else {
				StringUtil.putCompressedUnicode(getName(), out);
			}
		}
	}

	@Override
	public short getSid() {
		return sid;
	}
}
"
poi,3,org.apache.poi.hssf.record.WSBoolRecord,30,2,0,9,43,141,3,6,27,0.859195402,372,0.916666667,9,0.289473684,0.216748768,1,4,11.0,2,0.9333,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.LittleEndianOutput;


public final class WSBoolRecord extends StandardRecord {
    public final static short     sid = 0x0081;
    private byte                  field_1_wsbool;         
    private byte                  field_2_wsbool;         

    
    private static final BitField autobreaks    = BitFieldFactory.getInstance(0x01); 

    
    private static final BitField dialog        = BitFieldFactory.getInstance(0x10); 
    private static final BitField applystyles   = BitFieldFactory.getInstance(0x20); 
    private static final BitField rowsumsbelow  = BitFieldFactory.getInstance(0x40); 
    private static final BitField rowsumsright  = BitFieldFactory.getInstance(0x80); 
    private static final BitField fittopage     = BitFieldFactory.getInstance(0x01); 

    
    private static final BitField displayguts   = BitFieldFactory.getInstance(0x06); 

    
    private static final BitField alternateexpression = BitFieldFactory.getInstance(0x40); 
    private static final BitField alternateformula    = BitFieldFactory.getInstance(0x80); 

    public WSBoolRecord()
    {
    }

    public WSBoolRecord(RecordInputStream in)
    {
       byte data[] = in.readRemainder();
        field_1_wsbool =
            data[ 1 ];   
        field_2_wsbool =
            data[ 0 ];   
    }                             

    
    
    
    
    

    

    public void setWSBool1(byte bool1)
    {
        field_1_wsbool = bool1;
    }

    

    

    public void setAutobreaks(boolean ab)
    {
        field_1_wsbool = autobreaks.setByteBoolean(field_1_wsbool, ab);
    }

    

    public void setDialog(boolean isDialog)
    {
        field_1_wsbool = dialog.setByteBoolean(field_1_wsbool, isDialog);
    }

    

    public void setRowSumsBelow(boolean below)
    {
        field_1_wsbool = rowsumsbelow.setByteBoolean(field_1_wsbool, below);
    }

    

    public void setRowSumsRight(boolean right)
    {
        field_1_wsbool = rowsumsright.setByteBoolean(field_1_wsbool, right);
    }

    

    

    public void setWSBool2(byte bool2)
    {
        field_2_wsbool = bool2;
    }

    

    

    public void setFitToPage(boolean fit2page)
    {
        field_2_wsbool = fittopage.setByteBoolean(field_2_wsbool, fit2page);
    }

    

    public void setDisplayGuts(boolean guts)
    {
        field_2_wsbool = displayguts.setByteBoolean(field_2_wsbool, guts);
    }

    

    public void setAlternateExpression(boolean altexp)
    {
        field_2_wsbool = alternateexpression.setByteBoolean(field_2_wsbool,
                altexp);
    }

    

    public void setAlternateFormula(boolean formula)
    {
        field_2_wsbool = alternateformula.setByteBoolean(field_2_wsbool,
                formula);
    }

    

    

    public byte getWSBool1()
    {
        return field_1_wsbool;
    }

    

    

    public boolean getAutobreaks()
    {
        return autobreaks.isSet(field_1_wsbool);
    }

    

    public boolean getDialog()
    {
        return dialog.isSet(field_1_wsbool);
    }

    

    public boolean getRowSumsBelow()
    {
        return rowsumsbelow.isSet(field_1_wsbool);
    }

    

    public boolean getRowSumsRight()
    {
        return rowsumsright.isSet(field_1_wsbool);
    }

    

    

    public byte getWSBool2()
    {
        return field_2_wsbool;
    }

    

    

    public boolean getFitToPage()
    {
        return fittopage.isSet(field_2_wsbool);
    }

    

    public boolean getDisplayGuts()
    {
        return displayguts.isSet(field_2_wsbool);
    }

    

    public boolean getAlternateExpression()
    {
        return alternateexpression.isSet(field_2_wsbool);
    }

    

    public boolean getAlternateFormula()
    {
        return alternateformula.isSet(field_2_wsbool);
    }

    
    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[WSBOOL]
"");
        buffer.append(""    .wsbool1        = "")
            .append(Integer.toHexString(getWSBool1())).append(""
"");
        buffer.append(""        .autobreaks = "").append(getAutobreaks())
            .append(""
"");
        buffer.append(""        .dialog     = "").append(getDialog())
            .append(""
"");
        buffer.append(""        .rowsumsbelw= "").append(getRowSumsBelow())
            .append(""
"");
        buffer.append(""        .rowsumsrigt= "").append(getRowSumsRight())
            .append(""
"");
        buffer.append(""    .wsbool2        = "")
            .append(Integer.toHexString(getWSBool2())).append(""
"");
        buffer.append(""        .fittopage  = "").append(getFitToPage())
            .append(""
"");
        buffer.append(""        .displayguts= "").append(getDisplayGuts())
            .append(""
"");
        buffer.append(""        .alternateex= "")
            .append(getAlternateExpression()).append(""
"");
        buffer.append(""        .alternatefo= "").append(getAlternateFormula())
            .append(""
"");
        buffer.append(""[/WSBOOL]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeByte(getWSBool2());
        out.writeByte(getWSBool1());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      WSBoolRecord rec = new WSBoolRecord();
      rec.field_1_wsbool = field_1_wsbool;
      rec.field_2_wsbool = field_2_wsbool;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.NoteRecord,18,2,0,9,36,51,5,4,16,0.852941176,300,0.625,0,0.407407407,0.259259259,1,4,15.22222222,2,0.9444,5,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;


public final class NoteRecord extends StandardRecord {
	public final static short sid = 0x001C;

	public static final NoteRecord[] EMPTY_ARRAY = { };

	
	public final static short NOTE_HIDDEN = 0x0;

	
	public final static short NOTE_VISIBLE = 0x2;

	private static final Byte DEFAULT_PADDING = Byte.valueOf((byte)0);

	private int field_1_row;
	private int field_2_col;
	private short field_3_flags;
	private int field_4_shapeid;
	private boolean field_5_hasMultibyte;
	private String field_6_author;
	
	private Byte field_7_padding;

	
	public NoteRecord() {
		field_6_author = """";
		field_3_flags = 0;
		field_7_padding = DEFAULT_PADDING; 
	}

	
	public short getSid() {
		return sid;
	}

	
	public NoteRecord(RecordInputStream in) {
		field_1_row = in.readUShort();
		field_2_col = in.readShort();
		field_3_flags = in.readShort();
		field_4_shapeid = in.readUShort();
		int length = in.readShort();
		field_5_hasMultibyte = in.readByte() != 0x00;
		if (field_5_hasMultibyte) {
			field_6_author = StringUtil.readUnicodeLE(in, length);
		} else {
			field_6_author = StringUtil.readCompressedUnicode(in, length);
		}
 		if (in.available() == 1) {
			field_7_padding = Byte.valueOf(in.readByte());
		} else if (in.available() == 2 && length == 0) {
		    
            field_7_padding = Byte.valueOf(in.readByte());
            in.readByte();
 		}
	}

	public void serialize(LittleEndianOutput out) {
		out.writeShort(field_1_row);
		out.writeShort(field_2_col);
		out.writeShort(field_3_flags);
		out.writeShort(field_4_shapeid);
		out.writeShort(field_6_author.length());
		out.writeByte(field_5_hasMultibyte ? 0x01 : 0x00);
		if (field_5_hasMultibyte) {
			StringUtil.putUnicodeLE(field_6_author, out);
		} else {
			StringUtil.putCompressedUnicode(field_6_author, out);
		}
		if (field_7_padding != null) {
			out.writeByte(field_7_padding.intValue());
		}
	}

	protected int getDataSize() {
		return 11 
			+ field_6_author.length() * (field_5_hasMultibyte ? 2 : 1)
			+ (field_7_padding == null ? 0 : 1);
	}

	
	public String toString() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""[NOTE]
"");
		buffer.append(""    .row    = "").append(field_1_row).append(""
"");
		buffer.append(""    .col    = "").append(field_2_col).append(""
"");
		buffer.append(""    .flags  = "").append(field_3_flags).append(""
"");
		buffer.append(""    .shapeid= "").append(field_4_shapeid).append(""
"");
		buffer.append(""    .author = "").append(field_6_author).append(""
"");
		buffer.append(""[/NOTE]
"");
		return buffer.toString();
	}

	
	public int getRow() {
		return field_1_row;
	}

	
	public void setRow(int row) {
		field_1_row = row;
	}

	
	public int getColumn() {
		return field_2_col;
	}

	
	public void setColumn(int col) {
		field_2_col = col;
	}

	
	public short getFlags() {
		return field_3_flags;
	}

	
	public void setFlags(short flags) {
		field_3_flags = flags;
	}
	
	
	protected boolean authorIsMultibyte() {
	   return field_5_hasMultibyte;
	}

	
	public int getShapeId() {
		return field_4_shapeid;
	}

	
	public void setShapeId(int id) {
		field_4_shapeid = id;
	}

	
	public String getAuthor() {
		return field_6_author;
	}

	
	public void setAuthor(String author) {
		field_6_author = author;
      field_5_hasMultibyte = StringUtil.hasMultibyte(author);
	}

	public Object clone() {
		NoteRecord rec = new NoteRecord();
		rec.field_1_row = field_1_row;
		rec.field_2_col = field_2_col;
		rec.field_3_flags = field_3_flags;
		rec.field_4_shapeid = field_4_shapeid;
		rec.field_6_author = field_6_author;
		return rec;
	}
}
"
poi,3,org.apache.poi.ddf.EscherRecordFactory,1,1,0,21,1,0,21,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"

package org.apache.poi.ddf;


public interface EscherRecordFactory {
    
    EscherRecord createRecord( byte[] data, int offset );
}
"
poi,3,org.apache.poi.poifs.filesystem.POIFSFileSystem,17,1,0,36,95,106,9,28,13,0.354166667,461,1.0,2,0.0,0.14479638,0,0,25.94117647,2,1.1176,3,"



package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.util.CloseIgnoringInputStream;



public class POIFSFileSystem
    extends NPOIFSFileSystem 
    implements POIFSViewable
{
    
    public static InputStream createNonClosingInputStream(InputStream is) {
        return new CloseIgnoringInputStream(is);
    }

    
    public POIFSFileSystem()
    {
        super();
    }

    

    public POIFSFileSystem(InputStream stream)
        throws IOException
    {
        super(stream);
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        return NPOIFSFileSystem.hasPOIFSHeader(inp);
    }
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        return NPOIFSFileSystem.hasPOIFSHeader(header8Bytes);
    }

    

    public static void main(String args[])
        throws IOException
    {
        OPOIFSFileSystem.main(args);
    }
}

"
poi,3,org.apache.poi.poifs.filesystem.DirectoryNode,20,2,0,14,65,94,3,14,15,0.649122807,327,1.0,2,0.321428571,0.154545455,1,1,15.2,3,1.15,0,"



package org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.poi.hpsf.ClassID;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;


public class DirectoryNode
    extends EntryNode
    implements DirectoryEntry, POIFSViewable, Iterable<Entry>
{

    
    private Map<String,Entry> _byname;
    
    private ArrayList<Entry> _entries;

    
    
    private OPOIFSFileSystem   _ofilesystem;
    
    private NPOIFSFileSystem  _nfilesystem;

    
    private POIFSDocumentPath _path;

    
    DirectoryNode(final DirectoryProperty property,
                  final OPOIFSFileSystem filesystem,
                  final DirectoryNode parent)
    {
       this(property, parent, filesystem, (NPOIFSFileSystem)null);
    }

    
    DirectoryNode(final DirectoryProperty property,
                  final NPOIFSFileSystem nfilesystem,
                  final DirectoryNode parent)
    {
       this(property, parent, (OPOIFSFileSystem)null, nfilesystem);
    }

    private DirectoryNode(final DirectoryProperty property,
                          final DirectoryNode parent,
                          final OPOIFSFileSystem ofilesystem,
                          final NPOIFSFileSystem nfilesystem)
    {
        super(property, parent);
        this._ofilesystem = ofilesystem;
        this._nfilesystem = nfilesystem;

        if (parent == null)
        {
            _path = new POIFSDocumentPath();
        }
        else
        {
            _path = new POIFSDocumentPath(parent._path, new String[]
            {
                property.getName()
            });
        }
        _byname     = new HashMap<String, Entry>();
        _entries    = new ArrayList<Entry>();
        Iterator<Property> iter = property.getChildren();

        while (iter.hasNext())
        {
            Property child     = iter.next();
            Entry    childNode = null;

            if (child.isDirectory())
            {
                DirectoryProperty childDir = (DirectoryProperty) child;
                if(_ofilesystem != null) {
                   childNode = new DirectoryNode(childDir, _ofilesystem, this);
                } else {
                   childNode = new DirectoryNode(childDir, _nfilesystem, this);
                }
            }
            else
            {
                childNode = new DocumentNode((DocumentProperty) child, this);
            }
            _entries.add(childNode);
            _byname.put(childNode.getName(), childNode);
        }
    }

    

    public POIFSDocumentPath getPath()
    {
        return _path;
    }

    
    public NPOIFSFileSystem getFileSystem()
    {
        return _nfilesystem;
    }

    
    public OPOIFSFileSystem getOFileSystem()
    {
        return _ofilesystem;
    }

    
    public NPOIFSFileSystem getNFileSystem()
    {
        return _nfilesystem;
    }

    
    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
        return createDocumentInputStream(getEntry(documentName));
    }

    
    public DocumentInputStream createDocumentInputStream(
            final Entry document)
        throws IOException
    {
        if (!document.isDocumentEntry()) {
            throw new IOException(""Entry '"" + document.getName()
                                  + ""' is not a DocumentEntry"");
        }

        DocumentEntry entry = (DocumentEntry)document;
        return new DocumentInputStream(entry);
    }

    
    DocumentEntry createDocument(final OPOIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _ofilesystem.addDocument(document);

        _entries.add(rval);
        _byname.put(property.getName(), rval);
        return rval;
    }

    
    DocumentEntry createDocument(final NPOIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _nfilesystem.addDocument(document);

        _entries.add(rval);
        _byname.put(property.getName(), rval);
        return rval;
    }

    
    boolean changeName(final String oldName, final String newName)
    {
        boolean   rval  = false;
        EntryNode child = ( EntryNode ) _byname.get(oldName);

        if (child != null)
        {
            rval = (( DirectoryProperty ) getProperty())
                .changeName(child.getProperty(), newName);
            if (rval)
            {
                _byname.remove(oldName);
                _byname.put(child.getProperty().getName(), child);
            }
        }
        return rval;
    }

    

    boolean deleteEntry(final EntryNode entry)
    {
        boolean rval =
            (( DirectoryProperty ) getProperty())
                .deleteChild(entry.getProperty());

        if (rval)
        {
            _entries.remove(entry);
            _byname.remove(entry.getName());

            if(_ofilesystem != null) {
                _ofilesystem.remove(entry);
            } else {
                try {
                    _nfilesystem.remove(entry);
                } catch (IOException e) {
                    
                }
            }
        }
        return rval;
    }

    

    

    public Iterator<Entry> getEntries()
    {
        return _entries.iterator();
    }
    
    
    public Set<String> getEntryNames()
    {
        return _byname.keySet();
    }

    

    public boolean isEmpty()
    {
        return _entries.isEmpty();
    }

    

    public int getEntryCount()
    {
        return _entries.size();
    }

    public boolean hasEntry( String name )
    {
        return name != null && _byname.containsKey( name );
    }

    

    public Entry getEntry(final String name) throws FileNotFoundException {
        Entry rval = null;

        if (name != null) {
            rval = _byname.get(name);
        }
        if (rval == null) {
            
            throw new FileNotFoundException(""no such entry: """" + name
                    + """", had: "" + _byname.keySet());
        }
        return rval;
    }

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException
    {
        if(_nfilesystem != null) {
           return createDocument(new NPOIFSDocument(name, _nfilesystem, stream));
        } else {
           return createDocument(new OPOIFSDocument(name, stream));
        }
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        if(_nfilesystem != null) {
            return createDocument(new NPOIFSDocument(name, size, _nfilesystem, writer));
         } else {
            return createDocument(new OPOIFSDocument(name, size, _path, writer));
         }
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        DirectoryNode rval;
        DirectoryProperty property = new DirectoryProperty(name);

        if(_ofilesystem != null) {
           rval = new DirectoryNode(property, _ofilesystem, this);
           _ofilesystem.addDirectory(property);
        } else {
           rval = new DirectoryNode(property, _nfilesystem, this);
           _nfilesystem.addDirectory(property);
        }

        (( DirectoryProperty ) getProperty()).addChild(property);
        _entries.add(rval);
        _byname.put(name, rval);
        return rval;
    }

    
    public ClassID getStorageClsid()
    {
        return getProperty().getStorageClsid();
    }

    
    public void setStorageClsid(ClassID clsidStorage)
    {
        getProperty().setStorageClsid(clsidStorage);
    }

    
    

    

    @Override
    public boolean isDirectoryEntry()
    {
        return true;
    }

    
    

    

    @Override
    protected boolean isDeleteOK()
    {

        
        return isEmpty();
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    
    public Iterator<Object> getViewableIterator()
    {
        List<Object> components = new ArrayList<Object>();

        components.add(getProperty());
        Iterator<Entry> iter = _entries.iterator();
        while (iter.hasNext())
        {
            components.add(iter.next());
        }
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
    public Iterator<Entry> iterator() {
        return getEntries();
    }

    
}   

"
poi,3,org.apache.poi.dev.RecordGenerator,4,1,0,0,40,6,0,0,2,2.0,323,0.0,0,0.0,0.25,0,0,79.75,1,0.75,0,"

        
package org.apache.poi.dev;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.Reader;
import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.poi.util.XMLHelper;
import org.w3c.dom.Document;
import org.w3c.dom.Element;


public class RecordGenerator {
    
    public static void main(String[] args)
             throws Exception {
        
        Class.forName(""org.apache.poi.generator.FieldIterator"");

        if (args.length != 4) {
            System.out.println(""Usage:"");
            System.out.println(""  java org.apache.poi.hssf.util.RecordGenerator RECORD_DEFINTIONS RECORD_STYLES DEST_SRC_PATH TEST_SRC_PATH"");
        } else {
            generateRecords(args[0], args[1], args[2], args[3]);
        }
    }


    private static void generateRecords(String defintionsDir, String recordStyleDir, String destSrcPathDir, String testSrcPathDir)
             throws Exception {
        File definitionsFile = new File(defintionsDir);

        for (int i = 0; i < definitionsFile.listFiles().length; i++) {
            File file = definitionsFile.listFiles()[i];
            if (file.isFile() &&
                    (file.getName().endsWith(""_record.xml"") ||
                    file.getName().endsWith(""_type.xml"")
                    )
                    ) {
                
                DocumentBuilderFactory factory = XMLHelper.getDocumentBuilderFactory();
                DocumentBuilder builder = factory.newDocumentBuilder();
                Document document = builder.parse(file);
                Element record = document.getDocumentElement();
                String extendstg = record.getElementsByTagName(""extends"").item(0).getFirstChild().getNodeValue();
                String suffix = record.getElementsByTagName(""suffix"").item(0).getFirstChild().getNodeValue();
                String recordName = record.getAttributes().getNamedItem(""name"").getNodeValue();
                String packageName = record.getAttributes().getNamedItem(""package"").getNodeValue();
                packageName = packageName.replace('.', '/');

                
                String destinationPath = destSrcPathDir + ""/"" + packageName;
                File destinationPathFile = new File(destinationPath);
                destinationPathFile.mkdirs();
                String destinationFilepath = destinationPath + ""/"" + recordName + suffix + "".java"";
                transform(file, new File(destinationFilepath), new File(recordStyleDir + ""/"" + extendstg.toLowerCase() + "".xsl""));
                System.out.println(""Generated "" + suffix + "": "" + destinationFilepath);

                
                destinationPath = testSrcPathDir + ""/"" + packageName;
                destinationPathFile = new File(destinationPath);
                destinationPathFile.mkdirs();
                destinationFilepath = destinationPath + ""/Test"" + recordName + suffix + "".java"";
                if (new File(destinationFilepath).exists() == false) {
                    String temp = (recordStyleDir + ""/"" + extendstg.toLowerCase() + ""_test.xsl"");
                    transform(file, new File(destinationFilepath), new File(temp));
                    System.out.println(""Generated test: "" + destinationFilepath);
                } else {
                    System.out.println(""Skipped test generation: "" + destinationFilepath);
                }
            }
        }
    }

    
    
    
    private static void transform(final File in, final File out, final File xslt)
    throws FileNotFoundException, TransformerException
    {
        final Reader r = new FileReader(xslt);
        final StreamSource ss = new StreamSource(r);
        final TransformerFactory tf = TransformerFactory.newInstance();
        final Transformer t;
        try
        {
            t = tf.newTransformer(ss);
        }
        catch (TransformerException ex)
        {
            System.err.println(""Error compiling XSL style sheet "" + xslt);
            throw ex;
        }
        final Properties p = new Properties();
        p.setProperty(OutputKeys.METHOD, ""text"");
        t.setOutputProperties(p);
        final Result result = new StreamResult(out);
        t.transform(new StreamSource(in), result);        
    }

}
"
poi,3,org.apache.poi.hpsf.ClassID,10,1,0,11,23,0,10,1,10,0.611111111,359,0.5,0,0.0,0.45,1,1,34.7,6,2.0,0,"

package org.apache.poi.hpsf;

import org.apache.poi.util.HexDump;


public class ClassID
{
    public static final ClassID OLE10_PACKAGE = new ClassID(""{0003000C-0000-0000-C000-000000000046}"");
    public static final ClassID PPT_SHOW = new ClassID(""{64818D10-4F9B-11CF-86EA-00AA00B929E8}"");
    public static final ClassID XLS_WORKBOOK = new ClassID(""{00020841-0000-0000-C000-000000000046}"");
    public static final ClassID TXT_ONLY = new ClassID(""{5e941d80-bf96-11cd-b579-08002b30bfeb}""); 
    public static final ClassID EXCEL97      = new ClassID(""{00020820-0000-0000-C000-000000000046}"");
    public static final ClassID EXCEL95      = new ClassID(""{00020810-0000-0000-C000-000000000046}"");
    public static final ClassID WORD97       = new ClassID(""{00020906-0000-0000-C000-000000000046}"");
    public static final ClassID WORD95       = new ClassID(""{00020900-0000-0000-C000-000000000046}"");
    public static final ClassID POWERPOINT97 = new ClassID(""{64818D10-4F9B-11CF-86EA-00AA00B929E8}"");
    public static final ClassID POWERPOINT95 = new ClassID(""{EA7BAE70-FB3B-11CD-A903-00AA00510EA3}"");
    public static final ClassID EQUATION30   = new ClassID(""{0002CE02-0000-0000-C000-000000000046}"");
	
	
    
    protected byte[] bytes;



    
    public ClassID(final byte[] src, final int offset)
    {
        read(src, offset);
    }


    
    public ClassID()
    {
        bytes = new byte[LENGTH];
        for (int i = 0; i < LENGTH; i++)
            bytes[i] = 0x00;
    }


    
    public ClassID(String externalForm) {
    	bytes = new byte[LENGTH];
        String clsStr = externalForm.replaceAll(""[{}-]"", """");
        for (int i=0; i<clsStr.length(); i+=2) {
        	bytes[i/2] = (byte)Integer.parseInt(clsStr.substring(i, i+2), 16);
        }
    }
    

    
    public static final int LENGTH = 16;

    
    public int length()
    {
        return LENGTH;
    }



    
    public byte[] getBytes()
    {
        return bytes;
    }



    
    public void setBytes(final byte[] bytes)
    {
        for (int i = 0; i < this.bytes.length; i++)
            this.bytes[i] = bytes[i];
    }



    
    public byte[] read(final byte[] src, final int offset)
    {
        bytes = new byte[16];

        
        bytes[0] = src[3 + offset];
        bytes[1] = src[2 + offset];
        bytes[2] = src[1 + offset];
        bytes[3] = src[0 + offset];

        
        bytes[4] = src[5 + offset];
        bytes[5] = src[4 + offset];

        
        bytes[6] = src[7 + offset];
        bytes[7] = src[6 + offset];

        
        for (int i = 8; i < 16; i++)
            bytes[i] = src[i + offset];

        return bytes;
    }



    
    public void write(final byte[] dst, final int offset)
    throws ArrayStoreException
    {
        
        if (dst.length < 16)
            throw new ArrayStoreException
                (""Destination byte[] must have room for at least 16 bytes, "" +
                 ""but has a length of only "" + dst.length + ""."");
        
        dst[0 + offset] = bytes[3];
        dst[1 + offset] = bytes[2];
        dst[2 + offset] = bytes[1];
        dst[3 + offset] = bytes[0];

        
        dst[4 + offset] = bytes[5];
        dst[5 + offset] = bytes[4];

        
        dst[6 + offset] = bytes[7];
        dst[7 + offset] = bytes[6];

        
        for (int i = 8; i < 16; i++)
            dst[i + offset] = bytes[i];
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof ClassID))
            return false;
        final ClassID cid = (ClassID) o;
        if (bytes.length != cid.bytes.length)
            return false;
        for (int i = 0; i < bytes.length; i++)
            if (bytes[i] != cid.bytes[i])
                return false;
        return true;
    }



    
    public int hashCode()
    {
        return new String(bytes).hashCode();
    }



    
    public String toString()
    {
        StringBuffer sbClassId = new StringBuffer(38);
        sbClassId.append('{');
        for (int i = 0; i < 16; i++)
        {
            sbClassId.append(HexDump.toHex(bytes[i]));
            if (i == 3 || i == 5 || i == 7 || i == 9)
                sbClassId.append('-');
        }
        sbClassId.append('}');
        return sbClassId.toString();
    }

}
"
poi,3,org.apache.poi.poifs.filesystem.POIFSWriterListener,1,1,0,7,1,0,6,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.filesystem;



public interface POIFSWriterListener
{

    

    public void processPOIFSWriterEvent(POIFSWriterEvent event);
}   

"
poi,3,org.apache.poi.poifs.filesystem.DocumentDescriptor,4,1,0,2,18,0,1,1,4,0.222222222,129,1.0,1,0.0,0.4375,1,1,30.5,6,2.5,0,"

        

package org.apache.poi.poifs.filesystem;



public class DocumentDescriptor
{
    private POIFSDocumentPath path;
    private String            name;
    private int               hashcode = 0;

    

    public DocumentDescriptor(final POIFSDocumentPath path, final String name)
    {
        if (path == null)
        {
            throw new NullPointerException(""path must not be null"");
        }
        if (name == null)
        {
            throw new NullPointerException(""name must not be null"");
        }
        if (name.length() == 0)
        {
            throw new IllegalArgumentException(""name cannot be empty"");
        }
        this.path = path;
        this.name = name;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                DocumentDescriptor descriptor = ( DocumentDescriptor ) o;

                rval = this.path.equals(descriptor.path)
                       && this.name.equals(descriptor.name);
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            hashcode = path.hashCode() ^ name.hashCode();
        }
        return hashcode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer(40 * (path.length() + 1));

        for (int j = 0; j < path.length(); j++)
        {
            buffer.append(path.getComponent(j)).append(""/"");
        }
        buffer.append(name);
        return buffer.toString();
    }
}   

"
poi,3,org.apache.poi.hssf.usermodel.HSSFPictureData,3,1,0,2,6,0,1,1,2,1.3125,41,0.125,1,0.0,0.666666667,0,0,10.0,8,3.0,2,"


package org.apache.poi.hssf.usermodel;

import org.apache.poi.ddf.EscherBitmapBlip;
import org.apache.poi.ddf.EscherBlipRecord;
import org.apache.poi.ddf.EscherMetafileBlip;
import org.apache.poi.ss.usermodel.PictureData;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.util.PngUtils;


public class HSSFPictureData implements PictureData
{
    
    public static final short MSOBI_WMF   = 0x2160;
    public static final short MSOBI_EMF   = 0x3D40;
    public static final short MSOBI_PICT  = 0x5420;
    public static final short MSOBI_PNG   = 0x6E00;
    public static final short MSOBI_JPEG  = 0x46A0;
    public static final short MSOBI_DIB   = 0x7A80;
    
    public static final short FORMAT_MASK = (short) 0xFFF0;

    
    private EscherBlipRecord blip;

    
    public HSSFPictureData( EscherBlipRecord blip )
    {
        this.blip = blip;
    }

    
    public byte[] getData()
    {
        byte[] pictureData = blip.getPicturedata();

        
        
        if (PngUtils.matchesPngHeader(pictureData, 16))
        {
            byte[] png = new byte[pictureData.length-16];
            System.arraycopy(pictureData, 16, png, 0, png.length);
            pictureData = png;
        }

        return pictureData;
    }

    
    public int getFormat(){
        return blip.getRecordId() - (short)0xF018;
    }

    
    public String suggestFileExtension() {
        switch (blip.getRecordId()) {
            case EscherMetafileBlip.RECORD_ID_WMF:
                return ""wmf"";
            case EscherMetafileBlip.RECORD_ID_EMF:
                return ""emf"";
            case EscherMetafileBlip.RECORD_ID_PICT:
                return ""pict"";
            case EscherBitmapBlip.RECORD_ID_PNG:
                return ""png"";
            case EscherBitmapBlip.RECORD_ID_JPEG:
                return ""jpeg"";
            case EscherBitmapBlip.RECORD_ID_DIB:
                return ""dib"";
            default:
                return """";
        }
    }
    
    
    public String getMimeType() {
       switch (blip.getRecordId()) {
           case EscherMetafileBlip.RECORD_ID_WMF:
               return ""image/x-wmf"";
           case EscherMetafileBlip.RECORD_ID_EMF:
               return ""image/x-emf"";
           case EscherMetafileBlip.RECORD_ID_PICT:
               return ""image/x-pict"";
           case EscherBitmapBlip.RECORD_ID_PNG:
               return ""image/png"";
           case EscherBitmapBlip.RECORD_ID_JPEG:
               return ""image/jpeg"";
           case EscherBitmapBlip.RECORD_ID_DIB:
               return ""image/bmp"";
           default:
               return ""image/unknown"";
       }
    }
    
    
    public int getPictureType() {
        switch (blip.getRecordId()) {
            case EscherMetafileBlip.RECORD_ID_WMF:
                return Workbook.PICTURE_TYPE_WMF;
            case EscherMetafileBlip.RECORD_ID_EMF:
                return Workbook.PICTURE_TYPE_EMF;
            case EscherMetafileBlip.RECORD_ID_PICT:
                return Workbook.PICTURE_TYPE_PICT;
            case EscherBitmapBlip.RECORD_ID_PNG:
                return Workbook.PICTURE_TYPE_PNG;
            case EscherBitmapBlip.RECORD_ID_JPEG:
                return Workbook.PICTURE_TYPE_JPEG;
            case EscherBitmapBlip.RECORD_ID_DIB:
                return Workbook.PICTURE_TYPE_DIB;
            default:
                return -1;
        }        
    }
}
"
poi,3,org.apache.poi.util.CommonsLogger,5,2,0,3,20,0,0,3,4,0.5,138,1.0,0,0.888888889,0.5,1,1,26.2,12,4.8,0,"

        

package org.apache.poi.util;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;



public class CommonsLogger extends POILogger
{

    private static LogFactory   _creator = LogFactory.getFactory();
    private Log             log   = null;

   
    public void initialize(final String cat)
    {
        this.log = _creator.getInstance(cat);
    }   
     
    
    public void log(final int level, final Object obj1)
    {
        if(level==FATAL)
        {
          if(log.isFatalEnabled())
          {
            log.fatal(obj1);
          }
        }
        else if(level==ERROR)
        {
          if(log.isErrorEnabled())
          {
            log.error(obj1);
          }
        }
        else if(level==WARN)
        {
          if(log.isWarnEnabled())
          {
            log.warn(obj1);
          }
        }
        else if(level==INFO)
        {
          if(log.isInfoEnabled())
          {
            log.info(obj1);
          }
        }
        else if(level==DEBUG)
        {
          if(log.isDebugEnabled())
          {
            log.debug(obj1);
          }
        }
        else
        {
          if(log.isTraceEnabled())
          {
            log.trace(obj1);
          }
        }
    }
    
    
    public void log(final int level, final Object obj1,
                    final Throwable exception) 
    {
        if(level==FATAL)
        {
          if(log.isFatalEnabled())
          {
            if(obj1 != null)
               log.fatal(obj1, exception);
            else
               log.fatal(exception);
          }
        }
        else if(level==ERROR)
        {
          if(log.isErrorEnabled())
          {
            if(obj1 != null)
               log.error(obj1, exception);
            else
               log.error(exception);
          }
        }
        else if(level==WARN)
        {
          if(log.isWarnEnabled())
          {
            if(obj1 != null)
               log.warn(obj1, exception);
            else
               log.warn(exception);
          }
        }
        else if(level==INFO)
        {
          if(log.isInfoEnabled())
          {
        	if(obj1 != null)
               log.info(obj1, exception);
        	else
        	   log.info(exception);
          }
        }
        else if(level==DEBUG)
        {
          if(log.isDebugEnabled())
          {
        	if(obj1 != null)
               log.debug(obj1, exception);
        	else
        	   log.debug(exception);
          }
        }
        else
        {
          if(log.isTraceEnabled())
          {
        	if(obj1 != null)
               log.trace(obj1, exception);
        	else
        	   log.trace(exception);
          }
        }

    }

    

    public boolean check(final int level)
    {
        if(level==FATAL)
        {
          if(log.isFatalEnabled())
          {
            return true;
          }
        }
        else if(level==ERROR)
        {
          if(log.isErrorEnabled())
          {
            return true;
          }
        }
        else if(level==WARN)
        {
          if(log.isWarnEnabled())
          {
            return true;
          }
        }
        else if(level==INFO)
        {
          if(log.isInfoEnabled())
          {
            return true;
          }
        }
        else if(level==DEBUG)
        {
          if(log.isDebugEnabled())
          {
            return true;
          }
        }

        return false;

    }

 
}   

"
poi,3,org.apache.poi.hssf.usermodel.EscherGraphics,49,2,0,15,103,740,1,14,42,0.8359375,1010,1.0,3,0.520833333,0.182692308,2,18,19.44897959,7,1.5102,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;

import java.awt.*;
import java.awt.image.ImageObserver;
import java.text.AttributedCharacterIterator;


public class EscherGraphics
        extends Graphics
{
    private HSSFShapeGroup escherGroup;
    private HSSFWorkbook workbook;
    private float verticalPointsPerPixel = 1.0f;
    private float verticalPixelsPerPoint;
    private Color foreground;
    private Color background = Color.white;
    private Font font;
    private static POILogger logger = POILogFactory.getLogger(EscherGraphics.class);

    
    public EscherGraphics(HSSFShapeGroup escherGroup, HSSFWorkbook workbook, Color forecolor, float verticalPointsPerPixel )
    {
        this.escherGroup = escherGroup;
        this.workbook = workbook;
        this.verticalPointsPerPixel = verticalPointsPerPixel;
        this.verticalPixelsPerPoint = 1 / verticalPointsPerPixel;
        this.font = new Font(""Arial"", 0, 10);
        this.foreground = forecolor;

    }

    
    EscherGraphics( HSSFShapeGroup escherGroup, HSSFWorkbook workbook, Color foreground, Font font, float verticalPointsPerPixel )
    {
        this.escherGroup = escherGroup;
        this.workbook = workbook;
        this.foreground = foreground;

        this.font = font;
        this.verticalPointsPerPixel = verticalPointsPerPixel;
        this.verticalPixelsPerPoint = 1 / verticalPointsPerPixel;
    }














    public void clearRect(int x, int y, int width, int height)
    {
        Color color = foreground;
        setColor(background);
        fillRect(x,y,width,height);
        setColor(color);
    }

    public void clipRect(int x, int y, int width, int height)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""clipRect not supported"");
    }

    public void copyArea(int x, int y, int width, int height, int dx, int dy)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""copyArea not supported"");
    }

    public Graphics create()
    {
        EscherGraphics g = new EscherGraphics(escherGroup, workbook,
                foreground, font, verticalPointsPerPixel );
        return g;
    }

    public void dispose()
    {
    }

    public void drawArc(int x, int y, int width, int height,
				 int startAngle, int arcAngle)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawArc not supported"");
    }

    public boolean drawImage(Image img,
				      int dx1, int dy1, int dx2, int dy2,
				      int sx1, int sy1, int sx2, int sy2,
				      Color bgcolor,
				      ImageObserver observer)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawImage not supported"");

        return true;
    }

    public boolean drawImage(Image img,
				      int dx1, int dy1, int dx2, int dy2,
				      int sx1, int sy1, int sx2, int sy2,
				      ImageObserver observer)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawImage not supported"");
        return true;
    }

    public boolean drawImage(Image image, int i, int j, int k, int l, Color color, ImageObserver imageobserver)
    {
        return drawImage(image, i, j, i + k, j + l, 0, 0, image.getWidth(imageobserver), image.getHeight(imageobserver), color, imageobserver);
    }

    public boolean drawImage(Image image, int i, int j, int k, int l, ImageObserver imageobserver)
    {
        return drawImage(image, i, j, i + k, j + l, 0, 0, image.getWidth(imageobserver), image.getHeight(imageobserver), imageobserver);
    }

    public boolean drawImage(Image image, int i, int j, Color color, ImageObserver imageobserver)
    {
        return drawImage(image, i, j, image.getWidth(imageobserver), image.getHeight(imageobserver), color, imageobserver);
    }

    public boolean drawImage(Image image, int i, int j, ImageObserver imageobserver)
    {
        return drawImage(image, i, j, image.getWidth(imageobserver), image.getHeight(imageobserver), imageobserver);
    }

    public void drawLine(int x1, int y1, int x2, int y2)
    {
        drawLine(x1,y1,x2,y2,0);
    }

    public void drawLine(int x1, int y1, int x2, int y2, int width)
    {
        HSSFSimpleShape shape = escherGroup.createShape(new HSSFChildAnchor(x1, y1, x2, y2) );
        shape.setShapeType(HSSFSimpleShape.OBJECT_TYPE_LINE);
        shape.setLineWidth(width);
        shape.setLineStyleColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
    }

    public void drawOval(int x, int y, int width, int height)
    {
        HSSFSimpleShape shape = escherGroup.createShape(new HSSFChildAnchor(x,y,x+width,y+height) );
        shape.setShapeType(HSSFSimpleShape.OBJECT_TYPE_OVAL);
        shape.setLineWidth(0);
        shape.setLineStyleColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
        shape.setNoFill(true);
    }

    public void drawPolygon(int xPoints[], int yPoints[],
				     int nPoints)
    {
        int right  = findBiggest(xPoints);
        int bottom = findBiggest(yPoints);
        int left   = findSmallest(xPoints);
        int top    = findSmallest(yPoints);
        HSSFPolygon shape = escherGroup.createPolygon(new HSSFChildAnchor(left,top,right,bottom) );
        shape.setPolygonDrawArea(right - left, bottom - top);
        shape.setPoints(addToAll(xPoints, -left), addToAll(yPoints, -top));
        shape.setLineStyleColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
        shape.setLineWidth(0);
        shape.setNoFill(true);
    }

    private int[] addToAll( int[] values, int amount )
    {
        int[] result = new int[values.length];
        for ( int i = 0; i < values.length; i++ )
            result[i] = values[i] + amount;
        return result;
    }

    public void drawPolyline(int xPoints[], int yPoints[],
				      int nPoints)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawPolyline not supported"");
    }

    public void drawRect(int x, int y, int width, int height)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawRect not supported"");
    }

    public void drawRoundRect(int x, int y, int width, int height,
				       int arcWidth, int arcHeight)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawRoundRect not supported"");
    }

    public void drawString(String str, int x, int y)
    {
        if (str == null || str.equals(""""))
            return;

        Font excelFont = font;
        if ( font.getName().equals( ""SansSerif"" ) )
        {
            excelFont = new Font( ""Arial"", font.getStyle(), (int) ( font.getSize() / verticalPixelsPerPoint ) );
        }
        else
        {
            excelFont = new Font( font.getName(), font.getStyle(), (int) ( font.getSize() / verticalPixelsPerPoint ));
        }
        FontDetails d = StaticFontMetrics.getFontDetails( excelFont );
        int width = d.getStringWidth( str ) * 8  + 12;
        int height = (int) ( ( font.getSize() / verticalPixelsPerPoint ) + 6 ) * 2;
        y -= ( font.getSize() / verticalPixelsPerPoint ) + 2 * verticalPixelsPerPoint;    
        HSSFTextbox textbox = escherGroup.createTextbox( new HSSFChildAnchor( x, y, x + width, y + height ) );
        textbox.setNoFill( true );
        textbox.setLineStyle( HSSFShape.LINESTYLE_NONE );
        HSSFRichTextString s = new HSSFRichTextString( str );
        HSSFFont hssfFont = matchFont( excelFont );
        s.applyFont( hssfFont );
        textbox.setString( s );
    }

    private HSSFFont matchFont( Font font )
    {
        HSSFColor hssfColor = workbook.getCustomPalette()
                .findColor((byte)foreground.getRed(), (byte)foreground.getGreen(), (byte)foreground.getBlue());
        if (hssfColor == null)
            hssfColor = workbook.getCustomPalette().findSimilarColor((byte)foreground.getRed(), (byte)foreground.getGreen(), (byte)foreground.getBlue());
        boolean bold = (font.getStyle() & Font.BOLD) != 0;
        boolean italic = (font.getStyle() & Font.ITALIC) != 0;
        HSSFFont hssfFont = workbook.findFont(bold ? HSSFFont.BOLDWEIGHT_BOLD : 0,
                    hssfColor.getIndex(),
                    (short)(font.getSize() * 20),
                    font.getName(),
                    italic,
                    false,
                    (short)0,
                    (byte)0);
        if (hssfFont == null)
        {
            hssfFont = workbook.createFont();
            hssfFont.setBoldweight(bold ? HSSFFont.BOLDWEIGHT_BOLD : 0);
            hssfFont.setColor(hssfColor.getIndex());
            hssfFont.setFontHeight((short)(font.getSize() * 20));
            hssfFont.setFontName(font.getName());
            hssfFont.setItalic(italic);
            hssfFont.setStrikeout(false);
            hssfFont.setTypeOffset((short) 0);
            hssfFont.setUnderline((byte) 0);
        }

        return hssfFont;
    }


    public void drawString(AttributedCharacterIterator iterator,
                                    int x, int y)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""drawString not supported"");
    }

    public void fillArc(int x, int y, int width, int height,
				 int startAngle, int arcAngle)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""fillArc not supported"");
    }

    public void fillOval(int x, int y, int width, int height)
    {
        HSSFSimpleShape shape = escherGroup.createShape(new HSSFChildAnchor( x, y, x + width, y + height ) );
        shape.setShapeType(HSSFSimpleShape.OBJECT_TYPE_OVAL);
        shape.setLineStyle(HSSFShape.LINESTYLE_NONE);
        shape.setFillColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
        shape.setLineStyleColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
        shape.setNoFill(false);
    }

    
    public void fillPolygon(int xPoints[], int yPoints[],
				     int nPoints)
    {
        int right  = findBiggest(xPoints);
        int bottom = findBiggest(yPoints);
        int left   = findSmallest(xPoints);
        int top    = findSmallest(yPoints);
        HSSFPolygon shape = escherGroup.createPolygon(new HSSFChildAnchor(left,top,right,bottom) );
        shape.setPolygonDrawArea(right - left, bottom - top);
        shape.setPoints(addToAll(xPoints, -left), addToAll(yPoints, -top));
        shape.setLineStyleColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
        shape.setFillColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
    }

    private int findBiggest( int[] values )
    {
        int result = Integer.MIN_VALUE;
        for ( int i = 0; i < values.length; i++ )
        {
            if (values[i] > result)
                result = values[i];
        }
        return result;
    }

    private int findSmallest( int[] values )
    {
        int result = Integer.MAX_VALUE;
        for ( int i = 0; i < values.length; i++ )
        {
            if (values[i] < result)
                result = values[i];
        }
        return result;
    }

    public void fillRect(int x, int y, int width, int height)
    {
        HSSFSimpleShape shape = escherGroup.createShape(new HSSFChildAnchor( x, y, x + width, y + height ) );
        shape.setShapeType(HSSFSimpleShape.OBJECT_TYPE_RECTANGLE);
        shape.setLineStyle(HSSFShape.LINESTYLE_NONE);
        shape.setFillColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
        shape.setLineStyleColor(foreground.getRed(), foreground.getGreen(), foreground.getBlue());
    }

    public void fillRoundRect(int x, int y, int width, int height,
				       int arcWidth, int arcHeight)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""fillRoundRect not supported"");
    }

    public Shape getClip()
    {
        return getClipBounds();
    }

    public Rectangle getClipBounds()
    {
        return null;
    }

    public Rectangle getClipRect()
    {
        return getClipBounds();
    }

    public Color getColor()
    {
        return foreground;
    }

    public Font getFont()
    {
        return font;
    }

    @SuppressWarnings(""deprecation"")
    public FontMetrics getFontMetrics(Font f)
    {
        return Toolkit.getDefaultToolkit().getFontMetrics(f);
    }

    public void setClip(int x, int y, int width, int height)
    {
        setClip(new Rectangle(x,y,width,height));
    }

    public void setClip(Shape shape)
    {
        
    }

    public void setColor(Color color)
    {
        foreground = color;
    }

    public void setFont(Font f)
    {
        font = f;
    }

    public void setPaintMode()
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""setPaintMode not supported"");
    }

    public void setXORMode(Color color)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""setXORMode not supported"");
    }

    public void translate(int x, int y)
    {
        if (logger.check( POILogger.WARN ))
            logger.log(POILogger.WARN,""translate not supported"");
    }

    public Color getBackground()
    {
        return background;
    }

    public void setBackground( Color background )
    {
        this.background = background;
    }

    HSSFShapeGroup getEscherGraphics()
    {
        return escherGroup;
    }
}

"
poi,3,org.apache.poi.poifs.storage.ListManagedBlock,1,1,0,13,1,0,13,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.poifs.storage;

import java.io.IOException;



public interface ListManagedBlock
{

    

    public byte [] getData()
        throws IOException;
}   

"
poi,3,org.apache.poi.hssf.record.UnknownRecord,11,2,0,10,24,0,6,4,8,0.35,174,1.0,0,0.578947368,0.363636364,1,5,14.63636364,3,1.0,9,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.aggregates.PageSettingsBlock;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class UnknownRecord extends StandardRecord {

    
    
    public static final int PRINTSIZE_0033       = 0x0033;
    
    public static final int PLS_004D             = 0x004D;
    public static final int SHEETPR_0081         = 0x0081;
    public static final int SORT_0090            = 0x0090;
    public static final int STANDARDWIDTH_0099   = 0x0099;
    public static final int SCL_00A0             = 0x00A0;
    public static final int BITMAP_00E9          = 0x00E9;
    public static final int PHONETICPR_00EF      = 0x00EF;
    public static final int LABELRANGES_015F     = 0x015F;
    public static final int QUICKTIP_0800        = 0x0800;
    public static final int SHEETEXT_0862        = 0x0862; 
    public static final int SHEETPROTECTION_0867 = 0x0867;
    public static final int HEADER_FOOTER_089C   = 0x089C;
    public static final int CODENAME_1BA         = 0x01BA;
    public static final int PLV_MAC              = 0x08C8;

    private int _sid;
    private byte[] _rawData;

    
    public UnknownRecord(int id, byte[] data) {
        _sid = id & 0xFFFF;
        _rawData = data;
    }


    
    public UnknownRecord(RecordInputStream in) {
        _sid = in.getSid();
        _rawData = in.readRemainder();
        if (false && getBiffName(_sid) == null) {
            
            
            
            System.out.println(""Unknown record 0x"" + Integer.toHexString(_sid).toUpperCase());
        }
    }

    
    @Override
    public void serialize(LittleEndianOutput out) {
        out.write(_rawData);
    }

    @Override
    protected int getDataSize() {
        return _rawData.length;
    }

    
    @Override
    public String toString() {
        String biffName = getBiffName(_sid);
        if (biffName == null) {
            biffName = ""UNKNOWNRECORD"";
        }
        StringBuffer sb = new StringBuffer();

        sb.append(""["").append(biffName).append(""] (0x"");
        sb.append(Integer.toHexString(_sid).toUpperCase() + "")
"");
        if (_rawData.length > 0) {
            sb.append(""  rawData="").append(HexDump.toHex(_rawData)).append(""
"");
        }
        sb.append(""[/"").append(biffName).append(""]
"");
        return sb.toString();
    }

    @Override
    public short getSid() {
        return (short) _sid;
    }

    
    public static String getBiffName(int sid) {
        
        
        
        switch (sid) {
            case PRINTSIZE_0033: return ""PRINTSIZE"";
            case PLS_004D: return ""PLS"";
            case 0x0050: return ""DCON""; 
            case 0x007F: return ""IMDATA"";
            case SHEETPR_0081: return ""SHEETPR"";
            case SORT_0090: return ""SORT""; 
            case 0x0094: return ""LHRECORD""; 
            case STANDARDWIDTH_0099: return ""STANDARDWIDTH""; 
            case SCL_00A0: return ""SCL""; 
            case 0x00AE: return ""SCENMAN""; 

            case 0x00B2: return ""SXVI"";        
            case 0x00B4: return ""SXIVD"";       
            case 0x00B5: return ""SXLI"";        

            case 0x00D3: return ""OBPROJ"";
            case 0x00DC: return ""PARAMQRY"";
            case 0x00DE: return ""OLESIZE"";
            case BITMAP_00E9: return ""BITMAP"";
            case PHONETICPR_00EF: return ""PHONETICPR"";
            case 0x00F1: return ""SXEX"";        

            case LABELRANGES_015F: return ""LABELRANGES"";
            case 0x01BA: return ""CODENAME"";
            case 0x01A9: return ""USERBVIEW"";
            case 0x01AD: return ""QSI"";

            case 0x01C0: return ""EXCEL9FILE"";

            case 0x0802: return ""QSISXTAG"";   
            case 0x0803: return ""DBQUERYEXT"";
            case 0x0805: return ""TXTQUERY"";
            case 0x0810: return ""SXVIEWEX9"";  

            case 0x0812: return ""CONTINUEFRT"";
            case QUICKTIP_0800: return ""QUICKTIP"";
            case SHEETEXT_0862: return ""SHEETEXT"";
            case 0x0863: return ""BOOKEXT"";
            case 0x0864: return ""SXADDL"";    
            case SHEETPROTECTION_0867: return ""SHEETPROTECTION"";
            case 0x086B: return ""DATALABEXTCONTENTS"";
            case 0x086C: return ""CELLWATCH"";
            case FeatRecord.v11_sid: return ""SHARED FEATURE v11"";
            case 0x0874: return ""DROPDOWNOBJIDS"";
            case 0x0876: return ""DCONN"";
            case FeatRecord.v12_sid: return ""SHARED FEATURE v12"";
            case 0x087B: return ""CFEX"";
            case 0x087C: return ""XFCRC"";
            case 0x087D: return ""XFEXT"";
            case 0x087F: return ""CONTINUEFRT12"";
            case 0x088B: return ""PLV"";
            case 0x088C: return ""COMPAT12"";
            case 0x088D: return ""DXF"";
            case 0x0892: return ""STYLEEXT"";
            case 0x0896: return ""THEME"";
            case 0x0897: return ""GUIDTYPELIB"";
            case 0x089A: return ""MTRSETTINGS"";
            case 0x089B: return ""COMPRESSPICTURES"";
            case HEADER_FOOTER_089C: return ""HEADERFOOTER"";
            case 0x089D: return ""CRTLAYOUT12"";
            case 0x089E: return ""CRTMLFRT"";
            case 0x089F: return ""CRTMLFRTCONTINUE"";
            case 0x08A1: return ""SHAPEPROPSSTREAM"";
            case 0x08A3: return ""FORCEFULLCALCULATION"";
            case 0x08A4: return ""SHAPEPROPSSTREAM"";
            case 0x08A5: return ""TEXTPROPSSTREAM"";
            case 0x08A6: return ""RICHTEXTSTREAM"";
            case 0x08A7: return ""CRTLAYOUT12A"";

            case 0x08C8: return ""PLV{Mac Excel}"";
            
            case 0x1001: return ""UNITS"";
            case 0x1006: return ""CHARTDATAFORMAT"";
            case 0x1007: return ""CHARTLINEFORMAT"";
        }
        if (isObservedButUnknown(sid)) {
            return ""UNKNOWN-"" + Integer.toHexString(sid).toUpperCase();
        }

        return null;
    }

    
    private static boolean isObservedButUnknown(int sid) {
        
        switch (sid) {
            case 0x0033:
                
            case 0x0034:
                
                
                
            case 0x01BD:
            case 0x01C2:
                
                
                

            case 0x1009:
            case 0x100A:
            case 0x100B:
            case 0x100C:
            case 0x1014:
            case 0x1017:
            case 0x1018:
            case 0x1019:
            case 0x101A:
            case 0x101B:
            case 0x101D:
            case 0x101E:
            case 0x101F:
            case 0x1020:
            case 0x1021:
            case 0x1022:
            case 0x1024:
            case 0x1025:
            case 0x1026:
            case 0x1027:
            case 0x1032:
            case 0x1033:
            case 0x1034:
            case 0x1035:
            case 0x103A:
            case 0x1041:
            case 0x1043:
            case 0x1044:
            case 0x1045:
            case 0x1046:
            case 0x104A:
            case 0x104B:
            case 0x104E:
            case 0x104F:
            case 0x1051:
            case 0x105C:
            case 0x105D:
            case 0x105F:
            case 0x1060:
            case 0x1062:
            case 0x1063:
            case 0x1064:
            case 0x1065:
            case 0x1066:
                return true;
        }
        return false;
    }

    @Override
    public Object clone() {
        
        return this;
    }
}
"
poi,3,org.apache.poi.ddf.EscherSerializationListener,2,1,0,22,2,1,22,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"

package org.apache.poi.ddf;


public interface EscherSerializationListener
{
    
    void beforeRecordSerialize(int offset, short recordId, EscherRecord record);

    
    void afterRecordSerialize(int offset, short recordId, int size, EscherRecord record);
}
"
poi,3,org.apache.poi.hpsf.SummaryInformation,55,3,0,7,72,1485,1,6,55,1.018518519,485,0.0,0,0.316455696,0.192207792,0,0,7.8,2,1.0,1,"

package org.apache.poi.hpsf;

import java.util.Date;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;


public final class SummaryInformation extends SpecialPropertySet {

    
    public static final String DEFAULT_STREAM_NAME = ""SummaryInformation"";

    public PropertyIDMap getPropertySetIDMap() {
    	return PropertyIDMap.getSummaryInformationProperties();
    }


    
    public SummaryInformation(final PropertySet ps)
            throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isSummaryInformation())
            throw new UnexpectedPropertySetTypeException(""Not a ""
                    + getClass().getName());
    }



    
    public String getTitle()
    {
        return getPropertyStringValue(PropertyIDMap.PID_TITLE);
    }



    
    public void setTitle(final String title)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_TITLE, title);
    }



    
    public void removeTitle()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_TITLE);
    }



    
    public String getSubject()
    {
        return getPropertyStringValue(PropertyIDMap.PID_SUBJECT);
    }



    
    public void setSubject(final String subject)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SUBJECT, subject);
    }



    
    public void removeSubject()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SUBJECT);
    }



    
    public String getAuthor()
    {
        return getPropertyStringValue(PropertyIDMap.PID_AUTHOR);
    }



    
    public void setAuthor(final String author)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_AUTHOR, author);
    }



    
    public void removeAuthor()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_AUTHOR);
    }



    
    public String getKeywords()
    {
        return getPropertyStringValue(PropertyIDMap.PID_KEYWORDS);
    }



    
    public void setKeywords(final String keywords)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_KEYWORDS, keywords);
    }



    
    public void removeKeywords()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_KEYWORDS);
    }



    
    public String getComments()
    {
        return getPropertyStringValue(PropertyIDMap.PID_COMMENTS);
    }



    
    public void setComments(final String comments)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_COMMENTS, comments);
    }



    
    public void removeComments()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_COMMENTS);
    }



    
    public String getTemplate()
    {
        return getPropertyStringValue(PropertyIDMap.PID_TEMPLATE);
    }



    
    public void setTemplate(final String template)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_TEMPLATE, template);
    }



    
    public void removeTemplate()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_TEMPLATE);
    }



    
    public String getLastAuthor()
    {
        return getPropertyStringValue(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public void setLastAuthor(final String lastAuthor)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LASTAUTHOR, lastAuthor);
    }



    
    public void removeLastAuthor()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public String getRevNumber()
    {
        return getPropertyStringValue(PropertyIDMap.PID_REVNUMBER);
    }



    
    public void setRevNumber(final String revNumber)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_REVNUMBER, revNumber);
    }



    
    public void removeRevNumber()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_REVNUMBER);
    }



    
    public long getEditTime()
    {
        final Date d = (Date) getProperty(PropertyIDMap.PID_EDITTIME);
        if (d == null) {
            return 0;
        }
        return Util.dateToFileTime(d);
    }



    
    public void setEditTime(final long time)
    {
        final Date d = Util.filetimeToDate(time);
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_EDITTIME, Variant.VT_FILETIME, d);
    }



    
    public void removeEditTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_EDITTIME);
    }



    
    public Date getLastPrinted()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public void setLastPrinted(final Date lastPrinted)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LASTPRINTED, Variant.VT_FILETIME,
                lastPrinted);
    }



    
    public void removeLastPrinted()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public Date getCreateDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public void setCreateDateTime(final Date createDateTime)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CREATE_DTM, Variant.VT_FILETIME,
                createDateTime);
    }



    
    public void removeCreateDateTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public Date getLastSaveDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public void setLastSaveDateTime(final Date time)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s
                .setProperty(PropertyIDMap.PID_LASTSAVE_DTM,
                        Variant.VT_FILETIME, time);
    }



    
    public void removeLastSaveDateTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public int getPageCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public void setPageCount(final int pageCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PAGECOUNT, pageCount);
    }



    
    public void removePageCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public int getWordCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public void setWordCount(final int wordCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_WORDCOUNT, wordCount);
    }



    
    public void removeWordCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public int getCharCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public void setCharCount(final int charCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CHARCOUNT, charCount);
    }



    
    public void removeCharCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public byte[] getThumbnail()
    {
        return (byte[]) getProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public void setThumbnail(final byte[] thumbnail)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_THUMBNAIL, 
                Variant.VT_LPSTR, thumbnail);
    }



    
    public void removeThumbnail()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public String getApplicationName()
    {
        return getPropertyStringValue(PropertyIDMap.PID_APPNAME);
    }



    
    public void setApplicationName(final String applicationName)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_APPNAME, applicationName);
    }



    
    public void removeApplicationName()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_APPNAME);
    }



    
    public int getSecurity()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SECURITY);
    }



    
    public void setSecurity(final int security)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SECURITY, security);
    }



    
    public void removeSecurity()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SECURITY);
    }

}
"
poi,3,org.apache.poi.hssf.record.PasswordRev4Record,10,2,0,6,19,39,2,4,8,0.833333333,91,0.5,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class PasswordRev4Record extends StandardRecord {
    public final static short sid = 0x01BC;
    private int field_1_password;

    public PasswordRev4Record(int pw) {
        field_1_password = pw;
    }

    public PasswordRev4Record(RecordInputStream in) {
        field_1_password = in.readShort();
    }

    
    public void setPassword(short pw) {
        field_1_password = pw;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PROT4REVPASSWORD]
"");
        buffer.append(""    .password = "").append(HexDump.shortToHex(field_1_password)).append(""
"");
        buffer.append(""[/PROT4REVPASSWORD]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_password);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.ddf.EscherBoolProperty,3,3,0,6,4,1,5,1,3,2.0,22,0.0,0,0.875,0.555555556,0,0,6.333333333,2,1.3333,1,"


package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;


public class EscherBoolProperty
        extends EscherSimpleProperty
{
    
    public EscherBoolProperty( short propertyNumber, int value )
    {
        super(propertyNumber, value);
    }

    
    public boolean isTrue()
    {
        return propertyValue != 0;
    }

    
    public boolean isFalse()
    {
        return propertyValue == 0;
    }









    public String toXml(String tab){
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getClass().getSimpleName()).append("" id=""0x"").append(HexDump.toHex(getId()))
                .append("""" name="""").append(getName()).append("""" simpleValue="""").append(getPropertyValue()).append("""" blipId="""")
                .append(isBlipId()).append("""" value="""").append(isTrue()).append("""""").append(""/>
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.hssf.record.VCenterRecord,11,2,0,7,20,35,3,4,9,0.8,113,0.5,0,0.55,0.257575758,1,4,9.090909091,2,1.0909,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class VCenterRecord extends StandardRecord {
    public final static short sid = 0x84;
    private int field_1_vcenter;

    public VCenterRecord()
    {
    }

    public VCenterRecord(RecordInputStream in)
    {
        field_1_vcenter = in.readShort();
    }

    

    public void setVCenter(boolean hc)
    {
    	field_1_vcenter = hc ? 1 : 0;
    }

    

    public boolean getVCenter()
    {
        return (field_1_vcenter == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[VCENTER]
"");
        buffer.append(""    .vcenter        = "").append(getVCenter())
            .append(""
"");
        buffer.append(""[/VCENTER]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_vcenter);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      VCenterRecord rec = new VCenterRecord();
      rec.field_1_vcenter = field_1_vcenter;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.util.RKUtil,2,1,0,2,4,1,2,0,1,2.0,39,0.0,0,0.0,0.5,0,0,18.5,3,1.5,1,"

package org.apache.poi.hssf.util;


public final class RKUtil {
    private RKUtil() {
        
    }

    
    public static double decodeNumber(int number) {
        long raw_number = number;

        
        
        raw_number = raw_number >> 2;
        double rvalue = 0;

        if ((number & 0x02) == 0x02)
        {
            
            
            rvalue = raw_number;
        }
        else
        {

            
            
            
            rvalue = Double.longBitsToDouble(raw_number << 34);
        }
        if ((number & 0x01) == 0x01)
        {

            
            
            
            rvalue /= 100;
        }

        return rvalue;
    }
}
"
poi,3,org.apache.poi.ddf.EscherContainerRecord,11,2,0,15,46,25,9,6,11,0.957142857,366,0.142857143,0,0.655172414,0.222222222,1,6,31.63636364,3,1.8182,3,"

package org.apache.poi.ddf;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public final class EscherContainerRecord extends EscherRecord {
    public static final short DGG_CONTAINER    = (short)0xF000;
    public static final short BSTORE_CONTAINER = (short)0xF001;
    public static final short DG_CONTAINER     = (short)0xF002;
    public static final short SPGR_CONTAINER   = (short)0xF003;
    public static final short SP_CONTAINER     = (short)0xF004;
    public static final short SOLVER_CONTAINER = (short)0xF005;

    private static POILogger log = POILogFactory.getLogger(EscherContainerRecord.class);

    
    private int _remainingLength;

    private final List<EscherRecord> _childRecords = new ArrayList<EscherRecord>();

    public int fillFields(byte[] data, int pOffset, EscherRecordFactory recordFactory) {
        int bytesRemaining = readHeader(data, pOffset);
        int bytesWritten = 8;
        int offset = pOffset + 8;
        while (bytesRemaining > 0 && offset < data.length) {
            EscherRecord child = recordFactory.createRecord(data, offset);
            int childBytesWritten = child.fillFields(data, offset, recordFactory);
            bytesWritten += childBytesWritten;
            offset += childBytesWritten;
            bytesRemaining -= childBytesWritten;
            addChildRecord(child);
            if (offset >= data.length && bytesRemaining > 0) {
                _remainingLength = bytesRemaining;
                if (log.check(POILogger.WARN)) {
                    log.log(POILogger.WARN, ""Not enough Escher data: "" + bytesRemaining + "" bytes remaining but no space left"");
                }
            }
        }
        return bytesWritten;
    }

    public int serialize( int offset, byte[] data, EscherSerializationListener listener )
    {
        listener.beforeRecordSerialize( offset, getRecordId(), this );

        LittleEndian.putShort(data, offset, getOptions());
        LittleEndian.putShort(data, offset+2, getRecordId());
        int remainingBytes = 0;
        Iterator<EscherRecord> iterator = _childRecords.iterator();
        while (iterator.hasNext()) {
            EscherRecord r = iterator.next();
            remainingBytes += r.getRecordSize();
        }
        remainingBytes += _remainingLength;
        LittleEndian.putInt(data, offset+4, remainingBytes);
        int pos = offset+8;
        iterator = _childRecords.iterator();
        while (iterator.hasNext()) {
            EscherRecord r = iterator.next();
            pos += r.serialize(pos, data, listener );
        }

        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        return pos - offset;
    }

    public int getRecordSize() {
        int childRecordsSize = 0;
        Iterator<EscherRecord> iterator = _childRecords.iterator();
        while (iterator.hasNext()) {
            EscherRecord r = iterator.next();
            childRecordsSize += r.getRecordSize();
        }
        return 8 + childRecordsSize;
    }

    
    public boolean hasChildOfType(short recordId) {
        Iterator<EscherRecord> iterator = _childRecords.iterator();
        while (iterator.hasNext()) {
            EscherRecord r = iterator.next();
            if(r.getRecordId() == recordId) {
                return true;
            }
        }
        return false;
    }
    public EscherRecord getChild( int index ) {
        return _childRecords.get(index);
    }

    
    public List<EscherRecord> getChildRecords() {
        return new ArrayList<EscherRecord>(_childRecords);
    }

    public Iterator<EscherRecord> getChildIterator() {
        return new ReadOnlyIterator(_childRecords);
    }
    private static final class ReadOnlyIterator implements Iterator<EscherRecord> {
        private final List<EscherRecord> _list;
        private int _index;

        public ReadOnlyIterator(List<EscherRecord> list) {
            _list = list;
            _index = 0;
        }

        public boolean hasNext() {
            return _index < _list.size();
        }
        public EscherRecord next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return _list.get(_index++);
        }
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
    
    public void setChildRecords(List<EscherRecord> childRecords) {
        if (childRecords == _childRecords) {
            throw new IllegalStateException(""Child records private data member has escaped"");
        }
        _childRecords.clear();
        _childRecords.addAll(childRecords);
    }

    public boolean removeChildRecord(EscherRecord toBeRemoved) {
        return _childRecords.remove(toBeRemoved);
    }



    
    public List<EscherContainerRecord> getChildContainers() {
        List<EscherContainerRecord> containers = new ArrayList<EscherContainerRecord>();
        Iterator<EscherRecord> iterator = _childRecords.iterator();
        while (iterator.hasNext()) {
            EscherRecord r = iterator.next();
            if(r instanceof EscherContainerRecord) {
                containers.add((EscherContainerRecord) r);
            }
        }
        return containers;
    }

    public String getRecordName() {
        switch (getRecordId()) {
            case DGG_CONTAINER:
                return ""DggContainer"";
            case BSTORE_CONTAINER:
                return ""BStoreContainer"";
            case DG_CONTAINER:
                return ""DgContainer"";
            case SPGR_CONTAINER:
                return ""SpgrContainer"";
            case SP_CONTAINER:
                return ""SpContainer"";
            case SOLVER_CONTAINER:
                return ""SolverContainer"";
            default:
                return ""Container 0x"" + HexDump.toHex(getRecordId());
        }
    }

    public void display(PrintWriter w, int indent) {
        super.display(w, indent);
        for (Iterator<EscherRecord> iterator = _childRecords.iterator(); iterator.hasNext();)
        {
            EscherRecord escherRecord = iterator.next();
            escherRecord.display(w, indent + 1);
        }
    }

    public void addChildRecord(EscherRecord record) {
        _childRecords.add(record);
    }

    public void addChildBefore(EscherRecord record, int insertBeforeRecordId) {
        for (int i = 0; i < _childRecords.size(); i++) {
            EscherRecord rec = _childRecords.get(i);
            if(rec.getRecordId() == insertBeforeRecordId){
                _childRecords.add(i++, record);
                
            }
        }
    }

    public String toString()
    {
        String nl = System.getProperty( ""line.separator"" );

        StringBuffer children = new StringBuffer();
        if ( _childRecords.size() > 0 )
        {
            children.append( ""  children: "" + nl );

            int count = 0;
            for ( Iterator<EscherRecord> iterator = _childRecords.iterator(); iterator
                    .hasNext(); )
            {
                EscherRecord record = iterator.next();
                children.append( ""   Child "" + count + "":"" + nl );
                String childResult = String.valueOf( record );
                childResult = childResult.replaceAll( ""
"", ""
    "" );
                children.append( ""    "" );
                children.append( childResult );
                children.append( nl );
                count++;
            }
        }

        return getClass().getName() + "" ("" + getRecordName() + ""):"" + nl
                + ""  isContainer: "" + isContainerRecord() + nl
                + ""  version: 0x"" + HexDump.toHex( getVersion() ) + nl
                + ""  instance: 0x"" + HexDump.toHex( getInstance() ) + nl
                + ""  recordId: 0x"" + HexDump.toHex( getRecordId() ) + nl
                + ""  numchildren: "" + _childRecords.size() + nl
                + children.toString();
    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getRecordName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())));
        for ( Iterator<EscherRecord> iterator = _childRecords.iterator(); iterator
                .hasNext(); )
        {
            EscherRecord record = iterator.next();
            builder.append(record.toXml(tab+""	""));
        }
        builder.append(tab).append(""</"").append(getRecordName()).append("">
"");
        return builder.toString();
    }

    public <T extends EscherRecord> T getChildById( short recordId )
    {
        for ( EscherRecord childRecord : _childRecords )
        {
            if ( childRecord.getRecordId() == recordId )
            {
                @SuppressWarnings( ""unchecked"" )
                final T result = (T) childRecord;
                return result;
            }
        }
        return null;
    }

    
    public void getRecordsById(short recordId, List<EscherRecord> out){
        Iterator<EscherRecord> iterator = _childRecords.iterator();
        while (iterator.hasNext()) {
            EscherRecord r = iterator.next();
            if(r instanceof EscherContainerRecord) {
                EscherContainerRecord c = (EscherContainerRecord)r;
                c.getRecordsById(recordId, out );
            } else if (r.getRecordId() == recordId){
                out.add(r);
            }
        }
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFHeader,20,1,0,2,34,158,1,1,18,0.75,262,0.0,1,0.0,0.175,0,0,11.9,4,1.1,1,"

package org.apache.poi.hssf.usermodel;

import org.apache.poi.hssf.record.HeaderRecord;
import org.apache.poi.hssf.record.aggregates.PageSettingsBlock;
import org.apache.poi.ss.usermodel.Header;


public final class HSSFHeader extends HeaderFooter implements Header {

	private final PageSettingsBlock _psb;

	protected HSSFHeader(PageSettingsBlock psb) {
		_psb = psb;
	}

	protected String getRawText() {
		HeaderRecord hf = _psb.getHeader();
		if (hf == null) {
			return """";
		}
		return hf.getText();
	}

	@Override
	protected void setHeaderFooterText(String text) {
		HeaderRecord hfr = _psb.getHeader();
		if (hfr == null) {
			hfr = new HeaderRecord(text);
			_psb.setHeader(hfr);
		} else {
			hfr.setText(text);
		}
	}
}
"
poi,3,org.apache.poi.hssf.model.PictureShape,5,2,0,15,41,6,1,15,2,0.75,177,1.0,2,0.555555556,0.55,1,1,34.0,3,1.2,1,"


package org.apache.poi.hssf.model;

import org.apache.poi.ddf.*;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.usermodel.*;


public class PictureShape
        extends AbstractShape
{
    private EscherContainerRecord spContainer;
    private ObjRecord objRecord;

    
    PictureShape( HSSFSimpleShape hssfShape, int shapeId )
    {
        spContainer = createSpContainer(hssfShape, shapeId);
        objRecord = createObjRecord(hssfShape, shapeId);
    }

    
    private EscherContainerRecord createSpContainer(HSSFSimpleShape hssfShape, int shapeId)
    {
        HSSFPicture shape = (HSSFPicture) hssfShape;

        EscherContainerRecord spContainer = new EscherContainerRecord();
        EscherSpRecord sp = new EscherSpRecord();
        EscherOptRecord opt = new EscherOptRecord();
        EscherRecord anchor;
        EscherClientDataRecord clientData = new EscherClientDataRecord();

        spContainer.setRecordId( EscherContainerRecord.SP_CONTAINER );
        spContainer.setOptions( (short) 0x000F );
        sp.setRecordId( EscherSpRecord.RECORD_ID );
        sp.setOptions( (short) ( (EscherAggregate.ST_PICTUREFRAME << 4) | 0x2 ) );

        sp.setShapeId( shapeId );
        sp.setFlags( EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE );
        opt.setRecordId( EscherOptRecord.RECORD_ID );

        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.BLIP__BLIPTODISPLAY, false, true, shape.getPictureIndex() ) );


        addStandardOptions(shape, opt);
        HSSFAnchor userAnchor = shape.getAnchor();
        if (userAnchor.isHorizontallyFlipped())
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);
        if (userAnchor.isVerticallyFlipped())
            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);
        anchor = createAnchor(userAnchor);
        clientData.setRecordId( EscherClientDataRecord.RECORD_ID );
        clientData.setOptions( (short) 0x0000 );

        spContainer.addChildRecord(sp);
        spContainer.addChildRecord(opt);
        spContainer.addChildRecord(anchor);
        spContainer.addChildRecord(clientData);

        return spContainer;
    }

    
    private ObjRecord createObjRecord(HSSFShape hssfShape, int shapeId)
    {
        HSSFShape shape = hssfShape;

        ObjRecord obj = new ObjRecord();
        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();
        c.setObjectType((short) ((HSSFSimpleShape)shape).getShapeType());
        c.setObjectId( getCmoObjectId(shapeId) );
        c.setLocked(true);
        c.setPrintable(true);
        c.setAutofill(true);
        c.setAutoline(true);
        c.setReserved2( 0x0 );
        EndSubRecord e = new EndSubRecord();

        obj.addSubRecord(c);
        obj.addSubRecord(e);

        return obj;
    }

    public EscherContainerRecord getSpContainer()
    {
        return spContainer;
    }

    public ObjRecord getObjRecord()
    {
        return objRecord;
    }

}
"
poi,3,org.apache.poi.hssf.record.UseSelFSRecord,10,2,0,6,19,39,2,4,8,0.972222222,93,0.25,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class UseSelFSRecord extends StandardRecord {
    public final static short sid   = 0x0160;

    private static final BitField useNaturalLanguageFormulasFlag = BitFieldFactory.getInstance(0x0001);

    private int _options;

    private UseSelFSRecord(int options) {
        _options = options;
    }

    public UseSelFSRecord(RecordInputStream in) {
        this(in.readUShort());
    }

    public UseSelFSRecord(boolean b) {
        this(0);
        _options = useNaturalLanguageFormulasFlag.setBoolean(_options, b);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[USESELFS]
"");
        buffer.append(""    .options = "").append(HexDump.shortToHex(_options)).append(""
"");
        buffer.append(""[/USESELFS]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_options);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }

    @Override
    public Object clone() {
        return new UseSelFSRecord(_options);
    }
}
"
poi,3,org.apache.poi.hpsf.SpecialPropertySet,28,3,2,10,56,0,2,8,25,0.0,160,1.0,1,0.490196078,0.15,2,7,4.678571429,1,0.9286,0,"

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.util.LittleEndian;


public abstract class SpecialPropertySet extends MutablePropertySet
{
    
    public abstract PropertyIDMap getPropertySetIDMap();

    
    private MutablePropertySet delegate;



    
    public SpecialPropertySet(final PropertySet ps)
    {
        delegate = new MutablePropertySet(ps);
    }



    
    public SpecialPropertySet(final MutablePropertySet ps)
    {
        delegate = ps;
    }



    
    public int getByteOrder()
    {
        return delegate.getByteOrder();
    }



    
    public int getFormat()
    {
        return delegate.getFormat();
    }



    
    public int getOSVersion()
    {
        return delegate.getOSVersion();
    }



    
    public ClassID getClassID()
    {
        return delegate.getClassID();
    }



    
    public int getSectionCount()
    {
        return delegate.getSectionCount();
    }



    
    public List<Section> getSections()
    {
        return delegate.getSections();
    }



    
    public boolean isSummaryInformation()
    {
        return delegate.isSummaryInformation();
    }



    
    public boolean isDocumentSummaryInformation()
    {
        return delegate.isDocumentSummaryInformation();
    }



    
    public Section getFirstSection()
    {
        return delegate.getFirstSection();
    }


    
    public void addSection(final Section section)
    {
        delegate.addSection(section);
    }



    
    public void clearSections()
    {
        delegate.clearSections();
    }



    
    public void setByteOrder(final int byteOrder)
    {
        delegate.setByteOrder(byteOrder);
    }



    
    public void setClassID(final ClassID classID)
    {
        delegate.setClassID(classID);
    }



    
    public void setFormat(final int format)
    {
        delegate.setFormat(format);
    }



    
    public void setOSVersion(final int osVersion)
    {
        delegate.setOSVersion(osVersion);
    }



    
    public InputStream toInputStream() throws IOException, WritingNotSupportedException
    {
        return delegate.toInputStream();
    }



    
    public void write(final DirectoryEntry dir, final String name) throws WritingNotSupportedException, IOException
    {
        delegate.write(dir, name);
    }

    
    public void write(final OutputStream out) throws WritingNotSupportedException, IOException
    {
        delegate.write(out);
    }

    
    public boolean equals(final Object o)
    {
        return delegate.equals(o);
    }

    
    public Property[] getProperties() throws NoSingleSectionException
    {
        return delegate.getProperties();
    }

    
    protected Object getProperty(final int id) throws NoSingleSectionException
    {
        return delegate.getProperty(id);
    }



    
    protected boolean getPropertyBooleanValue(final int id) throws NoSingleSectionException
    {
        return delegate.getPropertyBooleanValue(id);
    }



    
    protected int getPropertyIntValue(final int id) throws NoSingleSectionException
    {
        return delegate.getPropertyIntValue(id);
    }


    
    
    protected String getPropertyStringValue(final int propertyId) {
        Object propertyValue = getProperty(propertyId);
        return getPropertyStringValue(propertyValue);
    }
    protected static String getPropertyStringValue(final Object propertyValue) {
        
        if (propertyValue == null) return null;
        if (propertyValue instanceof String) return (String)propertyValue;
        
        
        if (propertyValue instanceof byte[]) {
            byte[] b = (byte[])propertyValue;
            if (b.length == 0) {
                return """";
            }
            if (b.length == 1) {
                return Byte.toString(b[0]);
            }
            if (b.length == 2) {
                return Integer.toString( LittleEndian.getUShort(b) );
            }
            if (b.length == 4) {
                return Long.toString( LittleEndian.getUInt(b) );
            }
            
            return new String(b);
        }
        return propertyValue.toString();
    }


    
    public int hashCode()
    {
        return delegate.hashCode();
    }



    
    public String toString()
    {
        return delegate.toString();
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return delegate.wasNull();
    }

}
"
poi,3,org.apache.poi.hssf.record.DefaultColWidthRecord,11,2,0,6,20,43,2,4,9,0.8,102,0.5,0,0.55,0.309090909,1,4,8.090909091,2,0.9091,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class DefaultColWidthRecord extends StandardRecord {
    public final static short sid = 0x0055;
    private int             field_1_col_width;

    
    public final static int DEFAULT_COLUMN_WIDTH = 0x0008;

    public DefaultColWidthRecord()
    {
        field_1_col_width = DEFAULT_COLUMN_WIDTH;
    }

    public DefaultColWidthRecord(RecordInputStream in)
    {
        field_1_col_width = in.readUShort();
    }

    

    public void setColWidth(int width)
    {
        field_1_col_width = width;
    }

    

    public int getColWidth()
    {
        return field_1_col_width;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DEFAULTCOLWIDTH]
"");
        buffer.append(""    .colwidth      = "")
            .append(Integer.toHexString(getColWidth())).append(""
"");
        buffer.append(""[/DEFAULTCOLWIDTH]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getColWidth());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      DefaultColWidthRecord rec = new DefaultColWidthRecord();
      rec.field_1_col_width = field_1_col_width;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFSheet,102,1,0,38,302,0,5,35,88,0.925742574,1843,0.4375,3,0.0,0.135567403,0,0,16.91176471,18,1.7353,19,"

package org.apache.poi.hssf.usermodel;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.TreeMap;

import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.hssf.model.DrawingManager2;
import org.apache.poi.hssf.model.HSSFFormulaParser;
import org.apache.poi.hssf.model.InternalSheet;
import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.AutoFilterInfoRecord;
import org.apache.poi.hssf.record.CellValueRecordInterface;
import org.apache.poi.hssf.record.DVRecord;
import org.apache.poi.hssf.record.DimensionsRecord;
import org.apache.poi.hssf.record.DrawingRecord;
import org.apache.poi.hssf.record.EscherAggregate;
import org.apache.poi.hssf.record.ExtendedFormatRecord;
import org.apache.poi.hssf.record.NameRecord;
import org.apache.poi.hssf.record.NoteRecord;
import org.apache.poi.hssf.record.Record;
import org.apache.poi.hssf.record.RowRecord;
import org.apache.poi.hssf.record.SCLRecord;
import org.apache.poi.hssf.record.WSBoolRecord;
import org.apache.poi.hssf.record.WindowTwoRecord;
import org.apache.poi.hssf.record.aggregates.DataValidityTable;
import org.apache.poi.hssf.record.aggregates.FormulaRecordAggregate;
import org.apache.poi.hssf.record.aggregates.RecordAggregate.RecordVisitor;
import org.apache.poi.hssf.record.aggregates.WorksheetProtectionBlock;
import org.apache.poi.hssf.util.PaneInformation;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.formula.FormulaShifter;
import org.apache.poi.ss.formula.FormulaType;
import org.apache.poi.ss.formula.ptg.Area3DPtg;
import org.apache.poi.ss.formula.ptg.MemFuncPtg;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.ss.formula.ptg.UnionPtg;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellRange;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.DataValidation;
import org.apache.poi.ss.usermodel.DataValidationHelper;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellRangeAddressList;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.ss.util.SSCellRange;
import org.apache.poi.ss.util.SheetUtil;
import org.apache.poi.util.Configurator;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;


public final class HSSFSheet implements org.apache.poi.ss.usermodel.Sheet {
    private static final POILogger log = POILogFactory.getLogger(HSSFSheet.class);
    private static final int DEBUG = POILogger.DEBUG;

    
    private static final float PX_DEFAULT = 32.00f;
    
    private static final float PX_MODIFIED = 36.56f;

    
    
    public final static int INITIAL_CAPACITY = Configurator.getIntValue(""HSSFSheet.RowInitialCapacity"", 20);

    
    private final InternalSheet _sheet;
    
    private final TreeMap<Integer, HSSFRow> _rows;
    protected final InternalWorkbook _book;
    protected final HSSFWorkbook _workbook;
    private HSSFPatriarch _patriarch;
    private int _firstrow;
    private int _lastrow;

    
    protected HSSFSheet(HSSFWorkbook workbook) {
        _sheet = InternalSheet.createSheet();
        _rows = new TreeMap<Integer, HSSFRow>();
        this._workbook = workbook;
        this._book = workbook.getWorkbook();
    }

    
    protected HSSFSheet(HSSFWorkbook workbook, InternalSheet sheet) {
        this._sheet = sheet;
        _rows = new TreeMap<Integer, HSSFRow>();
        this._workbook = workbook;
        this._book = workbook.getWorkbook();
        setPropertiesFromSheet(sheet);
    }

    HSSFSheet cloneSheet(HSSFWorkbook workbook) {
        this.getDrawingPatriarch();
        HSSFSheet sheet = new HSSFSheet(workbook, _sheet.cloneSheet());
        int pos = sheet._sheet.findFirstRecordLocBySid(DrawingRecord.sid);
        DrawingRecord dr = (DrawingRecord) sheet._sheet.findFirstRecordBySid(DrawingRecord.sid);
        if (null != dr) {
            sheet._sheet.getRecords().remove(dr);
        }
        if (getDrawingPatriarch() != null) {
            HSSFPatriarch patr = HSSFPatriarch.createPatriarch(this.getDrawingPatriarch(), sheet);
            sheet._sheet.getRecords().add(pos, patr._getBoundAggregate());
            sheet._patriarch = patr;
        }
        return sheet;
    }

    
    protected void preSerialize(){
        if (_patriarch != null){
            _patriarch.preSerialize();
        }
    }

    
    public HSSFWorkbook getWorkbook() {
        return _workbook;
    }

    
    private void setPropertiesFromSheet(InternalSheet sheet) {

        RowRecord row = sheet.getNextRow();
        boolean rowRecordsAlreadyPresent = row != null;

        while (row != null) {
            createRowFromRecord(row);

            row = sheet.getNextRow();
        }

        Iterator<CellValueRecordInterface> iter = sheet.getCellValueIterator();
        long timestart = System.currentTimeMillis();

        if (log.check( POILogger.DEBUG )) {
            log.log(DEBUG, ""Time at start of cell creating in HSSF sheet = "",
                    Long.valueOf(timestart));
        }
        HSSFRow lastrow = null;

        
        while (iter.hasNext()) {
            CellValueRecordInterface cval = iter.next();

            long cellstart = System.currentTimeMillis();
            HSSFRow hrow = lastrow;

            if (hrow == null || hrow.getRowNum() != cval.getRow()) {
                hrow = getRow(cval.getRow());
                lastrow = hrow;
                if (hrow == null) {
                    
                    
                    if (rowRecordsAlreadyPresent) {
                        
                        throw new RuntimeException(""Unexpected missing row when some rows already present"");
                    }
                    
                    RowRecord rowRec = new RowRecord(cval.getRow());
                    sheet.addRow(rowRec);
                    hrow = createRowFromRecord(rowRec);
                }
            }
            if (log.check( POILogger.DEBUG )) {
            	if (cval instanceof Record) {
                log.log( DEBUG, ""record id = "" + Integer.toHexString( ( (Record) cval ).getSid() ) );
				} else {
					log.log( DEBUG, ""record = "" + cval );
				}
            }
            hrow.createCellFromRecord( cval );
            if (log.check( POILogger.DEBUG )) {
                log.log( DEBUG, ""record took "",
                    Long.valueOf( System.currentTimeMillis() - cellstart ) );
			}

        }
        if (log.check( POILogger.DEBUG )) {
            log.log(DEBUG, ""total sheet cell creation took "",
                Long.valueOf(System.currentTimeMillis() - timestart));
    }
    }

    
    public HSSFRow createRow(int rownum) {
        HSSFRow row = new HSSFRow(_workbook, this, rownum);
        
        row.setHeight(getDefaultRowHeight());
        row.getRowRecord().setBadFontHeight(false);

        addRow(row, true);
        return row;
    }

    

    private HSSFRow createRowFromRecord(RowRecord row) {
        HSSFRow hrow = new HSSFRow(_workbook, this, row);

        addRow(hrow, false);
        return hrow;
    }

    
    public void removeRow(Row row) {
        HSSFRow hrow = (HSSFRow) row;
        if (row.getSheet() != this) {
            throw new IllegalArgumentException(""Specified row does not belong to this sheet"");
        }
        for (Cell cell : row) {
            HSSFCell xcell = (HSSFCell) cell;
            if (xcell.isPartOfArrayFormulaGroup()) {
                String msg = ""Row[rownum="" + row.getRowNum() + ""] contains cell(s) included in a multi-cell array formula. You cannot change part of an array."";
                xcell.notifyArrayFormulaChanging(msg);
            }
        }

        if (_rows.size() > 0) {
            Integer key = Integer.valueOf(row.getRowNum());
            HSSFRow removedRow = _rows.remove(key);
            if (removedRow != row) {
                
                throw new IllegalArgumentException(""Specified row does not belong to this sheet"");
            }
            if (hrow.getRowNum() == getLastRowNum()) {
                _lastrow = findLastRow(_lastrow);
            }
            if (hrow.getRowNum() == getFirstRowNum()) {
                _firstrow = findFirstRow(_firstrow);
            }
            _sheet.removeRow(hrow.getRowRecord());
        }
    }

    
    private int findLastRow(int lastrow) {
        if (lastrow < 1) {
            return 0;
        }
        int rownum = lastrow - 1;
        HSSFRow r = getRow(rownum);

        while (r == null && rownum > 0) {
            r = getRow(--rownum);
        }
        if (r == null) {
            return 0;
        }
        return rownum;
    }

    

    private int findFirstRow(int firstrow) {
        int rownum = firstrow + 1;
        HSSFRow r = getRow(rownum);

        while (r == null && rownum <= getLastRowNum()) {
            r = getRow(++rownum);
        }

        if (rownum > getLastRowNum())
            return 0;

        return rownum;
    }

    

    private void addRow(HSSFRow row, boolean addLow) {
        _rows.put(Integer.valueOf(row.getRowNum()), row);
        if (addLow) {
            _sheet.addRow(row.getRowRecord());
        }
        boolean firstRow = _rows.size() == 1;
        if (row.getRowNum() > getLastRowNum() || firstRow) {
            _lastrow = row.getRowNum();
        }
        if (row.getRowNum() < getFirstRowNum() || firstRow) {
            _firstrow = row.getRowNum();
        }
    }

    
    public HSSFRow getRow(int rowIndex) {
        return _rows.get(Integer.valueOf(rowIndex));
    }

    
    public int getPhysicalNumberOfRows() {
        return _rows.size();
    }

    
    public int getFirstRowNum() {
        return _firstrow;
    }

    
    public int getLastRowNum() {
        return _lastrow;
    }

    public List<HSSFDataValidation> getDataValidations() {
        DataValidityTable dvt = _sheet.getOrCreateDataValidityTable();
        final List<HSSFDataValidation> hssfValidations = new ArrayList<HSSFDataValidation>();
        RecordVisitor visitor = new RecordVisitor() {
            private HSSFEvaluationWorkbook book = HSSFEvaluationWorkbook.create(getWorkbook());

            @Override
            public void visitRecord(Record r) {
                if (!(r instanceof DVRecord)) {
                    return;
                }
                DVRecord dvRecord = (DVRecord) r;
                CellRangeAddressList regions = dvRecord.getCellRangeAddress().copy();
                DVConstraint constraint = DVConstraint.createDVConstraint(dvRecord, book);
                HSSFDataValidation hssfDataValidation = new HSSFDataValidation(regions, constraint);
                hssfDataValidation.setErrorStyle(dvRecord.getErrorStyle());
                hssfDataValidation.setEmptyCellAllowed(dvRecord.getEmptyCellAllowed());
                hssfDataValidation.setSuppressDropDownArrow(dvRecord.getSuppressDropdownArrow());
                hssfDataValidation.createPromptBox(dvRecord.getPromptTitle(), dvRecord.getPromptText());
                hssfDataValidation.setShowPromptBox(dvRecord.getShowPromptOnCellSelected());
                hssfDataValidation.createErrorBox(dvRecord.getErrorTitle(), dvRecord.getErrorText());
                hssfDataValidation.setShowErrorBox(dvRecord.getShowErrorOnInvalidValue());
                hssfValidations.add(hssfDataValidation);
            }
        };
        dvt.visitContainedRecords(visitor);
        return hssfValidations;
    }

    
    public void addValidationData(DataValidation dataValidation) {
        if (dataValidation == null) {
            throw new IllegalArgumentException(""objValidation must not be null"");
        }
        HSSFDataValidation hssfDataValidation = (HSSFDataValidation) dataValidation;
        DataValidityTable dvt = _sheet.getOrCreateDataValidityTable();

        DVRecord dvRecord = hssfDataValidation.createDVRecord(this);
        dvt.addDataValidation(dvRecord);
    }


    
    public void setColumnHidden(short columnIndex, boolean hidden) {
        setColumnHidden(columnIndex & 0xFFFF, hidden);
    }

    
    public boolean isColumnHidden(short columnIndex) {
        return isColumnHidden(columnIndex & 0xFFFF);
    }

    
    public void setColumnWidth(short columnIndex, short width) {
        setColumnWidth(columnIndex & 0xFFFF, width & 0xFFFF);
    }

    
    public short getColumnWidth(short columnIndex) {
        return (short) getColumnWidth(columnIndex & 0xFFFF);
    }

    
    public void setDefaultColumnWidth(short width) {
        setDefaultColumnWidth(width & 0xFFFF);
    }

    
    public void setColumnHidden(int columnIndex, boolean hidden) {
        _sheet.setColumnHidden(columnIndex, hidden);
    }

    
    public boolean isColumnHidden(int columnIndex) {
        return _sheet.isColumnHidden(columnIndex);
    }

    
    public void setColumnWidth(int columnIndex, int width) {
        _sheet.setColumnWidth(columnIndex, width);
    }

    
    public int getColumnWidth(int columnIndex) {
        return _sheet.getColumnWidth(columnIndex);
    }

    public float getColumnWidthInPixels(int column){
        int cw = getColumnWidth(column);
        int def = getDefaultColumnWidth()*256;
        float px = (cw == def ? PX_DEFAULT : PX_MODIFIED);

        return cw/px;
    }
    
    
    public int getDefaultColumnWidth() {
        return _sheet.getDefaultColumnWidth();
    }

    
    public void setDefaultColumnWidth(int width) {
        _sheet.setDefaultColumnWidth(width);
    }


    
    public short getDefaultRowHeight() {
        return _sheet.getDefaultRowHeight();
    }

    

    public float getDefaultRowHeightInPoints() {
        return ((float) _sheet.getDefaultRowHeight() / 20);
    }

    

    public void setDefaultRowHeight(short height) {
        _sheet.setDefaultRowHeight(height);
    }

    

    public void setDefaultRowHeightInPoints(float height) {
        _sheet.setDefaultRowHeight((short) (height * 20));
    }

    
    public HSSFCellStyle getColumnStyle(int column) {
        short styleIndex = _sheet.getXFIndexForColAt((short) column);

        if (styleIndex == 0xf) {
            
            return null;
        }

        ExtendedFormatRecord xf = _book.getExFormatAt(styleIndex);
        return new HSSFCellStyle(styleIndex, xf, _book);
    }

    

    public boolean isGridsPrinted() {
        return _sheet.isGridsPrinted();
    }

    

    public void setGridsPrinted(boolean value) {
        _sheet.setGridsPrinted(value);
    }

    
    public int addMergedRegion(org.apache.poi.ss.util.Region region) {
        return _sheet.addMergedRegion(region.getRowFrom(),
                region.getColumnFrom(),
                
                region.getRowTo(),
                region.getColumnTo());
    }

    
    public int addMergedRegion(CellRangeAddress region) {
        region.validate(SpreadsheetVersion.EXCEL97);

        
        
        validateArrayFormulas(region);

        return _sheet.addMergedRegion(region.getFirstRow(),
                region.getFirstColumn(),
                region.getLastRow(),
                region.getLastColumn());
    }

    private void validateArrayFormulas(CellRangeAddress region) {
        int firstRow = region.getFirstRow();
        int firstColumn = region.getFirstColumn();
        int lastRow = region.getLastRow();
        int lastColumn = region.getLastColumn();
        for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {
            for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {
                HSSFRow row = getRow(rowIn);
                if (row == null) continue;

                HSSFCell cell = row.getCell(colIn);
                if (cell == null) continue;

                if (cell.isPartOfArrayFormulaGroup()) {
                    CellRangeAddress arrayRange = cell.getArrayFormulaRange();
                    if (arrayRange.getNumberOfCells() > 1 &&
                            (arrayRange.isInRange(region.getFirstRow(), region.getFirstColumn()) ||
                                    arrayRange.isInRange(region.getFirstRow(), region.getFirstColumn()))) {
                        String msg = ""The range "" + region.formatAsString() + "" intersects with a multi-cell array formula. "" +
                                ""You cannot merge cells of an array."";
                        throw new IllegalStateException(msg);
                    }
                }
            }
        }

    }

    
    public void setForceFormulaRecalculation(boolean value) {
        _sheet.setUncalced(value);
    }

    
    public boolean getForceFormulaRecalculation() {
        return _sheet.getUncalced();
    }


    

    public void setVerticallyCenter(boolean value) {
        _sheet.getPageSettings().getVCenter().setVCenter(value);
    }

    
    public boolean getVerticallyCenter(boolean value) {
        return getVerticallyCenter();
    }

    
    public boolean getVerticallyCenter() {
        return _sheet.getPageSettings().getVCenter().getVCenter();
    }

    

    public void setHorizontallyCenter(boolean value) {
        _sheet.getPageSettings().getHCenter().setHCenter(value);
    }

    

    public boolean getHorizontallyCenter() {

        return _sheet.getPageSettings().getHCenter().getHCenter();
    }

    
    public void setRightToLeft(boolean value) {
        _sheet.getWindowTwo().setArabic(value);
    }

    
    public boolean isRightToLeft() {
        return _sheet.getWindowTwo().getArabic();
    }

    

    public void removeMergedRegion(int index) {
        _sheet.removeMergedRegion(index);
    }

    

    public int getNumMergedRegions() {
        return _sheet.getNumMergedRegions();
    }

    
    public org.apache.poi.hssf.util.Region getMergedRegionAt(int index) {
        CellRangeAddress cra = getMergedRegion(index);

        return new org.apache.poi.hssf.util.Region(cra.getFirstRow(), (short) cra.getFirstColumn(),
                cra.getLastRow(), (short) cra.getLastColumn());
    }

    
    public CellRangeAddress getMergedRegion(int index) {
        return _sheet.getMergedRegionAt(index);
    }

    
    public List<CellRangeAddress> getMergedRegions() {
        List<CellRangeAddress> addresses = new ArrayList<CellRangeAddress>();
        for (int i=0; i < _sheet.getNumMergedRegions(); i++) {
            addresses.add(_sheet.getMergedRegionAt(i));
        }
        return addresses;
    }

    
    public Iterator<Row> rowIterator() {
        @SuppressWarnings(""unchecked"") 
                Iterator<Row> result = (Iterator<Row>) (Iterator<? extends Row>) _rows.values().iterator();
        return result;
    }

    
    public Iterator<Row> iterator() {
        return rowIterator();
    }


    
    InternalSheet getSheet() {
        return _sheet;
    }

    
    public void setAlternativeExpression(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setAlternateExpression(b);
    }

    
    public void setAlternativeFormula(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setAlternateFormula(b);
    }

    
    public void setAutobreaks(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setAutobreaks(b);
    }

    
    public void setDialog(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setDialog(b);
    }

    
    public void setDisplayGuts(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setDisplayGuts(b);
    }

    
    public void setFitToPage(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setFitToPage(b);
    }

    
    public void setRowSumsBelow(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setRowSumsBelow(b);
        
        record.setAlternateExpression(b);
    }

    
    public void setRowSumsRight(boolean b) {
        WSBoolRecord record =
                (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);

        record.setRowSumsRight(b);
    }

    
    public boolean getAlternateExpression() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getAlternateExpression();
    }

    
    public boolean getAlternateFormula() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getAlternateFormula();
    }

    
    public boolean getAutobreaks() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getAutobreaks();
    }

    
    public boolean getDialog() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getDialog();
    }

    
    public boolean getDisplayGuts() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getDisplayGuts();
    }


    
    public boolean isDisplayZeros() {
        return _sheet.getWindowTwo().getDisplayZeros();
    }

    
    public void setDisplayZeros(boolean value) {
        _sheet.getWindowTwo().setDisplayZeros(value);
    }

    
    public boolean getFitToPage() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getFitToPage();
    }

    
    public boolean getRowSumsBelow() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getRowSumsBelow();
    }

    
    public boolean getRowSumsRight() {
        return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid))
                .getRowSumsRight();
    }

    
    public boolean isPrintGridlines() {
        return getSheet().getPrintGridlines().getPrintGridlines();
    }

    
    public void setPrintGridlines(boolean newPrintGridlines) {
        getSheet().getPrintGridlines().setPrintGridlines(newPrintGridlines);
    }

    
    public HSSFPrintSetup getPrintSetup() {
        return new HSSFPrintSetup(_sheet.getPageSettings().getPrintSetup());
    }

    public HSSFHeader getHeader() {
        return new HSSFHeader(_sheet.getPageSettings());
    }

    public HSSFFooter getFooter() {
        return new HSSFFooter(_sheet.getPageSettings());
    }

    
    public boolean isSelected() {
        return getSheet().getWindowTwo().getSelected();
    }

    
    public void setSelected(boolean sel) {
        getSheet().getWindowTwo().setSelected(sel);
    }

    
    public boolean isActive() {
        return getSheet().getWindowTwo().isActive();
    }

    
    public void setActive(boolean sel) {
        getSheet().getWindowTwo().setActive(sel);
    }

    
    public double getMargin(short margin) {
        switch (margin) {
            case FooterMargin:
                return _sheet.getPageSettings().getPrintSetup().getFooterMargin();
            case HeaderMargin:
                return _sheet.getPageSettings().getPrintSetup().getHeaderMargin();
            default:
                return _sheet.getPageSettings().getMargin(margin);
        }
    }

    
    public void setMargin(short margin, double size) {
        switch (margin) {
            case FooterMargin:
                _sheet.getPageSettings().getPrintSetup().setFooterMargin(size);
                break;
            case HeaderMargin:
                _sheet.getPageSettings().getPrintSetup().setHeaderMargin(size);
                break;
            default:
                _sheet.getPageSettings().setMargin(margin, size);
        }
    }

    private WorksheetProtectionBlock getProtectionBlock() {
        return _sheet.getProtectionBlock();
    }

    
    public boolean getProtect() {
        return getProtectionBlock().isSheetProtected();
    }

    
    public short getPassword() {
        return (short) getProtectionBlock().getPasswordHash();
    }

    
    public boolean getObjectProtect() {
        return getProtectionBlock().isObjectProtected();
    }

    
    public boolean getScenarioProtect() {
        return getProtectionBlock().isScenarioProtected();
    }

    
    public void protectSheet(String password) {
        getProtectionBlock().protectSheet(password, true, true); 
    }

    
    public void setZoom(int numerator, int denominator) {
        if (numerator < 1 || numerator > 65535)
            throw new IllegalArgumentException(""Numerator must be greater than 0 and less than 65536"");
        if (denominator < 1 || denominator > 65535)
            throw new IllegalArgumentException(""Denominator must be greater than 0 and less than 65536"");

        SCLRecord sclRecord = new SCLRecord();
        sclRecord.setNumerator((short) numerator);
        sclRecord.setDenominator((short) denominator);
        getSheet().setSCLRecord(sclRecord);
    }

    
    public short getTopRow() {
        return _sheet.getTopRow();
    }

    
    public short getLeftCol() {
        return _sheet.getLeftCol();
    }

    
    public void showInPane(int toprow, int leftcol) {
        int maxrow = SpreadsheetVersion.EXCEL97.getLastRowIndex();
        if (toprow > maxrow) throw new IllegalArgumentException(""Maximum row number is "" + maxrow);
        
        showInPane((short)toprow, (short)leftcol);
    }
    
    public void showInPane(short toprow, short leftcol) {
        _sheet.setTopRow(toprow);
        _sheet.setLeftCol(leftcol);
    }

    
    protected void shiftMerged(int startRow, int endRow, int n, boolean isRow) {
        List<CellRangeAddress> shiftedRegions = new ArrayList<CellRangeAddress>();
        
        for (int i = 0; i < getNumMergedRegions(); i++) {
            CellRangeAddress merged = getMergedRegion(i);

            boolean inStart = (merged.getFirstRow() >= startRow || merged.getLastRow() >= startRow);
            boolean inEnd = (merged.getFirstRow() <= endRow || merged.getLastRow() <= endRow);

            
            if (!inStart || !inEnd) {
                continue;
            }

            
            if (!SheetUtil.containsCell(merged, startRow - 1, 0) &&
                    !SheetUtil.containsCell(merged, endRow + 1, 0)) {
                merged.setFirstRow(merged.getFirstRow() + n);
                merged.setLastRow(merged.getLastRow() + n);
                
                shiftedRegions.add(merged);
                removeMergedRegion(i);
                i = i - 1; 
            }
        }

        
        Iterator<CellRangeAddress> iterator = shiftedRegions.iterator();
        while (iterator.hasNext()) {
            CellRangeAddress region = iterator.next();

            this.addMergedRegion(region);
        }
    }

    
    public void shiftRows(int startRow, int endRow, int n) {
        shiftRows(startRow, endRow, n, false, false);
    }

    
    public void shiftRows(int startRow, int endRow, int n, boolean copyRowHeight, boolean resetOriginalRowHeight) {
        shiftRows(startRow, endRow, n, copyRowHeight, resetOriginalRowHeight, true);
    }

    
    public void shiftRows(int startRow, int endRow, int n,
                          boolean copyRowHeight, boolean resetOriginalRowHeight, boolean moveComments) {
        int s, inc;
        if (n < 0) {
            s = startRow;
            inc = 1;
        } else if (n > 0) {
            s = endRow;
            inc = -1;
        } else {
            
            return;
        }

        NoteRecord[] noteRecs;
        if (moveComments) {
            noteRecs = _sheet.getNoteRecords();
        } else {
            noteRecs = NoteRecord.EMPTY_ARRAY;
        }

        shiftMerged(startRow, endRow, n, true);
        _sheet.getPageSettings().shiftRowBreaks(startRow, endRow, n);

        for (int rowNum = s; rowNum >= startRow && rowNum <= endRow && rowNum >= 0 && rowNum < 65536; rowNum += inc) {
            HSSFRow row = getRow(rowNum);
            
            
            
            if (row != null) notifyRowShifting(row);

            HSSFRow row2Replace = getRow(rowNum + n);
            if (row2Replace == null)
                row2Replace = createRow(rowNum + n);


            
            
            
            
            
            row2Replace.removeAllCells();

            
            
            if (row == null) continue; 

            
            if (copyRowHeight) {
                row2Replace.setHeight(row.getHeight());
            }
            if (resetOriginalRowHeight) {
                row.setHeight((short) 0xff);
            }

            
            
            for (Iterator<Cell> cells = row.cellIterator(); cells.hasNext(); ) {
                HSSFCell cell = (HSSFCell) cells.next();
                row.removeCell(cell);
                CellValueRecordInterface cellRecord = cell.getCellValueRecord();
                cellRecord.setRow(rowNum + n);
                row2Replace.createCellFromRecord(cellRecord);
                _sheet.addValueRecord(rowNum + n, cellRecord);

                HSSFHyperlink link = cell.getHyperlink();
                if (link != null) {
                    link.setFirstRow(link.getFirstRow() + n);
                    link.setLastRow(link.getLastRow() + n);
                }
            }
            
            row.removeAllCells();

            
            
            
            if (moveComments) {
                
                HSSFPatriarch patriarch = createDrawingPatriarch();
                for (int i = patriarch.getChildren().size() - 1; i >= 0; i--) {
                    HSSFShape shape = patriarch.getChildren().get(i);
                    if (!(shape instanceof HSSFComment)) {
                        continue;
                    }
                    HSSFComment comment = (HSSFComment) shape;
                    if (comment.getRow() != rowNum) {
                        continue;
                    }
                    comment.setRow(rowNum + n);
                }
            }
        }

        
        if (n > 0) {
            
            if (startRow == _firstrow) {
                
                _firstrow = Math.max(startRow + n, 0);
                for (int i = startRow + 1; i < startRow + n; i++) {
                    if (getRow(i) != null) {
                        _firstrow = i;
                        break;
                    }
                }
            }
            if (endRow + n > _lastrow) {
                _lastrow = Math.min(endRow + n, SpreadsheetVersion.EXCEL97.getLastRowIndex());
            }
        } else {
            
            if (startRow + n < _firstrow) {
                _firstrow = Math.max(startRow + n, 0);
            }
            if (endRow == _lastrow) {
                
                _lastrow = Math.min(endRow + n, SpreadsheetVersion.EXCEL97.getLastRowIndex());
                for (int i = endRow - 1; i > endRow + n; i++) {
                    if (getRow(i) != null) {
                        _lastrow = i;
                        break;
                    }
                }
            }
        }

        
        
        int sheetIndex = _workbook.getSheetIndex(this);
        String sheetName = _workbook.getSheetName(sheetIndex);
        short externSheetIndex = _book.checkExternSheet(sheetIndex);
        FormulaShifter shifter = FormulaShifter.createForRowShift(
                         externSheetIndex, sheetName, startRow, endRow, n);
        _sheet.updateFormulasAfterCellShift(shifter, externSheetIndex);

        int nSheets = _workbook.getNumberOfSheets();
        for (int i = 0; i < nSheets; i++) {
            InternalSheet otherSheet = _workbook.getSheetAt(i).getSheet();
            if (otherSheet == this._sheet) {
                continue;
            }
            short otherExtSheetIx = _book.checkExternSheet(i);
            otherSheet.updateFormulasAfterCellShift(shifter, otherExtSheetIx);
        }
        _workbook.getWorkbook().updateNamesAfterCellShift(shifter);
    }

    protected void insertChartRecords(List<Record> records) {
        int window2Loc = _sheet.findFirstRecordLocBySid(WindowTwoRecord.sid);
        _sheet.getRecords().addAll(window2Loc, records);
    }

    private void notifyRowShifting(HSSFRow row) {
        String msg = ""Row[rownum="" + row.getRowNum() + ""] contains cell(s) included in a multi-cell array formula. "" +
                ""You cannot change part of an array."";
        for (Cell cell : row) {
            HSSFCell hcell = (HSSFCell) cell;
            if (hcell.isPartOfArrayFormulaGroup()) {
                hcell.notifyArrayFormulaChanging(msg);
            }
        }
    }

    
    public void createFreezePane(int colSplit, int rowSplit, int leftmostColumn, int topRow) {
        validateColumn(colSplit);
        validateRow(rowSplit);
        if (leftmostColumn < colSplit)
            throw new IllegalArgumentException(""leftmostColumn parameter must not be less than colSplit parameter"");
        if (topRow < rowSplit)
            throw new IllegalArgumentException(""topRow parameter must not be less than leftmostColumn parameter"");
        getSheet().createFreezePane(colSplit, rowSplit, topRow, leftmostColumn);
    }

    
    public void createFreezePane(int colSplit, int rowSplit) {
        createFreezePane(colSplit, rowSplit, colSplit, rowSplit);
    }

    
    public void createSplitPane(int xSplitPos, int ySplitPos, int leftmostColumn, int topRow, int activePane) {
        getSheet().createSplitPane(xSplitPos, ySplitPos, topRow, leftmostColumn, activePane);
    }

    
    public PaneInformation getPaneInformation() {
        return getSheet().getPaneInformation();
    }

    
    public void setDisplayGridlines(boolean show) {
        _sheet.setDisplayGridlines(show);
    }

    
    public boolean isDisplayGridlines() {
        return _sheet.isDisplayGridlines();
    }

    
    public void setDisplayFormulas(boolean show) {
        _sheet.setDisplayFormulas(show);
    }

    
    public boolean isDisplayFormulas() {
        return _sheet.isDisplayFormulas();
    }

    
    public void setDisplayRowColHeadings(boolean show) {
        _sheet.setDisplayRowColHeadings(show);
    }

    
    public boolean isDisplayRowColHeadings() {
        return _sheet.isDisplayRowColHeadings();
    }

    
    public void setRowBreak(int row) {
        validateRow(row);
        _sheet.getPageSettings().setRowBreak(row, (short) 0, (short) 255);
    }

    
    public boolean isRowBroken(int row) {
        return _sheet.getPageSettings().isRowBroken(row);
    }

    
    public void removeRowBreak(int row) {
        _sheet.getPageSettings().removeRowBreak(row);
    }

    
    public int[] getRowBreaks() {
        
        return _sheet.getPageSettings().getRowBreaks();
    }

    
    public int[] getColumnBreaks() {
        
        return _sheet.getPageSettings().getColumnBreaks();
    }


    
    public void setColumnBreak(int column) {
        validateColumn((short) column);
        _sheet.getPageSettings().setColumnBreak((short) column, (short) 0, (short) SpreadsheetVersion.EXCEL97.getLastRowIndex());
    }

    
    public boolean isColumnBroken(int column) {
        return _sheet.getPageSettings().isColumnBroken(column);
    }

    
    public void removeColumnBreak(int column) {
        _sheet.getPageSettings().removeColumnBreak(column);
    }

    
    protected void validateRow(int row) {
        int maxrow = SpreadsheetVersion.EXCEL97.getLastRowIndex();
        if (row > maxrow) throw new IllegalArgumentException(""Maximum row number is "" + maxrow);
        if (row < 0) throw new IllegalArgumentException(""Minumum row number is 0"");
    }

    
    protected void validateColumn(int column) {
        int maxcol = SpreadsheetVersion.EXCEL97.getLastColumnIndex();
        if (column > maxcol) throw new IllegalArgumentException(""Maximum column number is "" + maxcol);
        if (column < 0) throw new IllegalArgumentException(""Minimum column number is 0"");
    }

    
    public void dumpDrawingRecords(boolean fat) {
        _sheet.aggregateDrawingRecords(_book.getDrawingManager(), false);

        EscherAggregate r = (EscherAggregate) getSheet().findFirstRecordBySid(EscherAggregate.sid);
        List<EscherRecord> escherRecords = r.getEscherRecords();
        PrintWriter w = new PrintWriter(System.out);
        for (Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext(); ) {
            EscherRecord escherRecord = iterator.next();
            if (fat) {
                System.out.println(escherRecord.toString());
            } else {
                escherRecord.display(w, 0);
            }
        }
        w.flush();
    }

    
    public EscherAggregate getDrawingEscherAggregate() {
        _book.findDrawingGroup();

        
        
        if (_book.getDrawingManager() == null) {
            return null;
        }

        int found = _sheet.aggregateDrawingRecords(
                _book.getDrawingManager(), false
        );
        if (found == -1) {
            
            return null;
        }

        
        EscherAggregate agg = (EscherAggregate) _sheet.findFirstRecordBySid(EscherAggregate.sid);
        return agg;
    }

    
    public HSSFPatriarch getDrawingPatriarch() {
        _patriarch = getPatriarch(false);
        return _patriarch;
    }

    
    public HSSFPatriarch createDrawingPatriarch() {
        _patriarch = getPatriarch(true);
        return _patriarch;
    }

    private HSSFPatriarch getPatriarch(boolean createIfMissing) {
        HSSFPatriarch patriarch = null;
        if (_patriarch != null) {
            return _patriarch;
        }
        DrawingManager2 dm = _book.findDrawingGroup();
        if (null == dm) {
            if (!createIfMissing) {
                return null;
            } else {
                _book.createDrawingGroup();
                dm = _book.getDrawingManager();
            }
        }
        EscherAggregate agg = (EscherAggregate) _sheet.findFirstRecordBySid(EscherAggregate.sid);
        if (null == agg) {
            int pos = _sheet.aggregateDrawingRecords(dm, false);
            if (-1 == pos) {
                if (createIfMissing) {
                    pos = _sheet.aggregateDrawingRecords(dm, true);
                    agg = (EscherAggregate) _sheet.getRecords().get(pos);
                    patriarch = new HSSFPatriarch(this, agg);
                    patriarch.afterCreate();
                    return patriarch;
                } else {
                    return null;
                }
            }
            agg = (EscherAggregate) _sheet.getRecords().get(pos);
        }
        return new HSSFPatriarch(this, agg);
    }

    
    public void setColumnGroupCollapsed(short columnNumber, boolean collapsed) {
        setColumnGroupCollapsed(columnNumber & 0xFFFF, collapsed);
    }

    
    public void groupColumn(short fromColumn, short toColumn) {
        groupColumn(fromColumn & 0xFFFF, toColumn & 0xFFFF);
    }

    
    public void ungroupColumn(short fromColumn, short toColumn) {
        ungroupColumn(fromColumn & 0xFFFF, toColumn & 0xFFFF);
    }

    
    public void setColumnGroupCollapsed(int columnNumber, boolean collapsed) {
        _sheet.setColumnGroupCollapsed(columnNumber, collapsed);
    }

    
    public void groupColumn(int fromColumn, int toColumn) {
        _sheet.groupColumnRange(fromColumn, toColumn, true);
    }

    public void ungroupColumn(int fromColumn, int toColumn) {
        _sheet.groupColumnRange(fromColumn, toColumn, false);
    }

    
    public void groupRow(int fromRow, int toRow) {
        _sheet.groupRowRange(fromRow, toRow, true);
    }

    public void ungroupRow(int fromRow, int toRow) {
        _sheet.groupRowRange(fromRow, toRow, false);
    }

    public void setRowGroupCollapsed(int rowIndex, boolean collapse) {
        if (collapse) {
            _sheet.getRowsAggregate().collapseRow(rowIndex);
        } else {
            _sheet.getRowsAggregate().expandRow(rowIndex);
        }
    }

    
    public void setDefaultColumnStyle(int column, CellStyle style) {
        _sheet.setDefaultColumnStyle(column, ((HSSFCellStyle) style).getIndex());
    }

    
    public void autoSizeColumn(int column) {
        autoSizeColumn(column, false);
    }

    
    public void autoSizeColumn(int column, boolean useMergedCells) {
        double width = SheetUtil.getColumnWidth(this, column, useMergedCells);

        if (width != -1) {
            width *= 256;
            int maxColumnWidth = 255 * 256; 
            if (width > maxColumnWidth) {
                width = maxColumnWidth;
            }
            setColumnWidth(column, (int) (width));
        }

    }

    
    public HSSFComment getCellComment(int row, int column) {
        return findCellComment(row, column);
    }

    public HSSFSheetConditionalFormatting getSheetConditionalFormatting() {
        return new HSSFSheetConditionalFormatting(this);
    }

    
    public String getSheetName() {
        HSSFWorkbook wb = getWorkbook();
        int idx = wb.getSheetIndex(this);
        return wb.getSheetName(idx);
    }

    
    private CellRange<HSSFCell> getCellRange(CellRangeAddress range) {
        int firstRow = range.getFirstRow();
        int firstColumn = range.getFirstColumn();
        int lastRow = range.getLastRow();
        int lastColumn = range.getLastColumn();
        int height = lastRow - firstRow + 1;
        int width = lastColumn - firstColumn + 1;
        List<HSSFCell> temp = new ArrayList<HSSFCell>(height * width);
        for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {
            for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {
                HSSFRow row = getRow(rowIn);
                if (row == null) {
                    row = createRow(rowIn);
                }
                HSSFCell cell = row.getCell(colIn);
                if (cell == null) {
                    cell = row.createCell(colIn);
                }
                temp.add(cell);
            }
        }
        return SSCellRange.create(firstRow, firstColumn, height, width, temp, HSSFCell.class);
    }

    public CellRange<HSSFCell> setArrayFormula(String formula, CellRangeAddress range) {
        
        int sheetIndex = _workbook.getSheetIndex(this);
        Ptg[] ptgs = HSSFFormulaParser.parse(formula, _workbook, FormulaType.ARRAY, sheetIndex);
        CellRange<HSSFCell> cells = getCellRange(range);

        for (HSSFCell c : cells) {
            c.setCellArrayFormula(range);
        }
        HSSFCell mainArrayFormulaCell = cells.getTopLeftCell();
        FormulaRecordAggregate agg = (FormulaRecordAggregate) mainArrayFormulaCell.getCellValueRecord();
        agg.setArrayFormula(range, ptgs);
        return cells;
    }


    public CellRange<HSSFCell> removeArrayFormula(Cell cell) {
        if (cell.getSheet() != this) {
            throw new IllegalArgumentException(""Specified cell does not belong to this sheet."");
        }
        CellValueRecordInterface rec = ((HSSFCell) cell).getCellValueRecord();
        if (!(rec instanceof FormulaRecordAggregate)) {
            String ref = new CellReference(cell).formatAsString();
            throw new IllegalArgumentException(""Cell "" + ref + "" is not part of an array formula."");
        }
        FormulaRecordAggregate fra = (FormulaRecordAggregate) rec;
        CellRangeAddress range = fra.removeArrayFormula(cell.getRowIndex(), cell.getColumnIndex());

        CellRange<HSSFCell> result = getCellRange(range);
        
        for (Cell c : result) {
            c.setCellType(Cell.CELL_TYPE_BLANK);
        }
        return result;
    }

    public DataValidationHelper getDataValidationHelper() {
        return new HSSFDataValidationHelper(this);
    }

    public HSSFAutoFilter setAutoFilter(CellRangeAddress range) {
        InternalWorkbook workbook = _workbook.getWorkbook();
        int sheetIndex = _workbook.getSheetIndex(this);

        NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_FILTER_DB, sheetIndex + 1);

        if (name == null) {
            name = workbook.createBuiltInName(NameRecord.BUILTIN_FILTER_DB, sheetIndex + 1);
        }

        int firstRow = range.getFirstRow();
        
        
        if(firstRow == -1) {
            firstRow = 0;
        }

        
        Area3DPtg ptg = new Area3DPtg(firstRow, range.getLastRow(),
                range.getFirstColumn(), range.getLastColumn(),
                false, false, false, false, sheetIndex);
        name.setNameDefinition(new Ptg[]{ptg});

        AutoFilterInfoRecord r = new AutoFilterInfoRecord();
        
        int numcols = 1 + range.getLastColumn() - range.getFirstColumn();
        r.setNumEntries((short) numcols);
        int idx = _sheet.findFirstRecordLocBySid(DimensionsRecord.sid);
        _sheet.getRecords().add(idx, r);

        
        HSSFPatriarch p = createDrawingPatriarch();
        for (int col = range.getFirstColumn(); col <= range.getLastColumn(); col++) {
            p.createComboBox(new HSSFClientAnchor(0, 0, 0, 0,
                    (short) col, firstRow, (short) (col + 1), firstRow + 1));
        }

        return new HSSFAutoFilter(this);
    }

    protected HSSFComment findCellComment(int row, int column) {
        HSSFPatriarch patriarch = getDrawingPatriarch();
        if (null == patriarch) {
            patriarch = createDrawingPatriarch();
        }
        return lookForComment(patriarch, row, column);
    }

    private HSSFComment lookForComment(HSSFShapeContainer container, int row, int column) {
        for (Object object : container.getChildren()) {
            HSSFShape shape = (HSSFShape) object;
            if (shape instanceof HSSFShapeGroup) {
                HSSFShape res = lookForComment((HSSFShapeContainer) shape, row, column);
                if (null != res) {
                    return (HSSFComment) res;
                }
                continue;
            }
            if (shape instanceof HSSFComment) {
                HSSFComment comment = (HSSFComment) shape;
                if (comment.hasPosition() && comment.getColumn() == column && comment.getRow() == row) {
                    return comment;
                }
            }
        }
        return null;
    }


    public CellRangeAddress getRepeatingRows() {
        return getRepeatingRowsOrColums(true);
    }


    public CellRangeAddress getRepeatingColumns() {
        return getRepeatingRowsOrColums(false);
    }


    public void setRepeatingRows(CellRangeAddress rowRangeRef) {
        CellRangeAddress columnRangeRef = getRepeatingColumns();
        setRepeatingRowsAndColumns(rowRangeRef, columnRangeRef);
    }


    public void setRepeatingColumns(CellRangeAddress columnRangeRef) {
        CellRangeAddress rowRangeRef = getRepeatingRows();
        setRepeatingRowsAndColumns(rowRangeRef, columnRangeRef);
    }


    private void setRepeatingRowsAndColumns(
            CellRangeAddress rowDef, CellRangeAddress colDef) {
        int sheetIndex = _workbook.getSheetIndex(this);
        int maxRowIndex = SpreadsheetVersion.EXCEL97.getLastRowIndex();
        int maxColIndex = SpreadsheetVersion.EXCEL97.getLastColumnIndex();

        int col1 = -1;
        int col2 = -1;
        int row1 = -1;
        int row2 = -1;

        if (rowDef != null) {
            row1 = rowDef.getFirstRow();
            row2 = rowDef.getLastRow();
            if ((row1 == -1 && row2 != -1) || (row1 > row2)
                    || (row1 < 0 || row1 > maxRowIndex)
                    || (row2 < 0 || row2 > maxRowIndex)) {
                throw new IllegalArgumentException(""Invalid row range specification"");
            }
        }
        if (colDef != null) {
            col1 = colDef.getFirstColumn();
            col2 = colDef.getLastColumn();
            if ((col1 == -1 && col2 != -1) || (col1 > col2)
                    || (col1 < 0 || col1 > maxColIndex)
                    || (col2 < 0 || col2 > maxColIndex)) {
                throw new IllegalArgumentException(""Invalid column range specification"");
            }
        }

        short externSheetIndex =
                _workbook.getWorkbook().checkExternSheet(sheetIndex);

        boolean setBoth = rowDef != null && colDef != null;
        boolean removeAll = rowDef == null && colDef == null;

        HSSFName name = _workbook.getBuiltInName(
                NameRecord.BUILTIN_PRINT_TITLE, sheetIndex);
        if (removeAll) {
            if (name != null) {
                _workbook.removeName(name);
            }
            return;
        }
        if (name == null) {
            name = _workbook.createBuiltInName(
                    NameRecord.BUILTIN_PRINT_TITLE, sheetIndex);
        }

        List<Ptg> ptgList = new ArrayList<Ptg>();
        if (setBoth) {
            final int exprsSize = 2 * 11 + 1; 
            ptgList.add(new MemFuncPtg(exprsSize));
        }
        if (colDef != null) {
            Area3DPtg colArea = new Area3DPtg(0, maxRowIndex, col1, col2,
                    false, false, false, false, externSheetIndex);
            ptgList.add(colArea);
        }
        if (rowDef != null) {
            Area3DPtg rowArea = new Area3DPtg(row1, row2, 0, maxColIndex,
                    false, false, false, false, externSheetIndex);
            ptgList.add(rowArea);
        }
        if (setBoth) {
            ptgList.add(UnionPtg.instance);
        }

        Ptg[] ptgs = new Ptg[ptgList.size()];
        ptgList.toArray(ptgs);
        name.setNameDefinition(ptgs);

        HSSFPrintSetup printSetup = getPrintSetup();
        printSetup.setValidSettings(false);
        setActive(true);
    }


    private CellRangeAddress getRepeatingRowsOrColums(boolean rows) {
        NameRecord rec = getBuiltinNameRecord(NameRecord.BUILTIN_PRINT_TITLE);
        if (rec == null) {
            return null;
        }

        Ptg[] nameDefinition = rec.getNameDefinition();
        if (nameDefinition == null) {
            return null;
        }

        int maxRowIndex = SpreadsheetVersion.EXCEL97.getLastRowIndex();
        int maxColIndex = SpreadsheetVersion.EXCEL97.getLastColumnIndex();

        for (Ptg ptg : nameDefinition) {

            if (ptg instanceof Area3DPtg) {
                Area3DPtg areaPtg = (Area3DPtg) ptg;

                if (areaPtg.getFirstColumn() == 0
                        && areaPtg.getLastColumn() == maxColIndex) {
                    if (rows) {
                        CellRangeAddress rowRange = new CellRangeAddress(
                                areaPtg.getFirstRow(), areaPtg.getLastRow(), -1, -1);
                        return rowRange;
                    }
                } else if (areaPtg.getFirstRow() == 0
                        && areaPtg.getLastRow() == maxRowIndex) {
                    if (!rows) {
                        CellRangeAddress columnRange = new CellRangeAddress(-1, -1,
                                areaPtg.getFirstColumn(), areaPtg.getLastColumn());
                        return columnRange;
                    }
                }

            }

        }

        return null;
    }


    private NameRecord getBuiltinNameRecord(byte builtinCode) {
        int sheetIndex = _workbook.getSheetIndex(this);
        int recIndex =
                _workbook.findExistingBuiltinNameRecordIdx(sheetIndex, builtinCode);
        if (recIndex == -1) {
            return null;
        }
        return _workbook.getNameRecord(recIndex);
    }
    
    
    public int getColumnOutlineLevel(int columnIndex) {
        return _sheet.getColumnOutlineLevel(columnIndex);
    }
}
"
poi,3,org.apache.poi.hssf.eventusermodel.HSSFListener,1,1,0,5,1,0,4,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"


package org.apache.poi.hssf.eventusermodel;

import org.apache.poi.hssf.record.Record;



public interface HSSFListener
{

    

    public void processRecord(Record record);
}
"
poi,3,org.apache.poi.hssf.record.PaletteRecord,11,2,0,9,30,17,4,5,8,0.84,1209,0.4,0,0.55,0.287878788,1,4,108.4545455,4,1.7273,1,"

package org.apache.poi.hssf.record;

import java.util.ArrayList;
import java.util.List;

import org.apache.poi.util.LittleEndianOutput;


public final class PaletteRecord extends StandardRecord {
    public final static short sid = 0x0092;
    
    public final static byte STANDARD_PALETTE_SIZE = (byte) 56;
    
    public final static short FIRST_COLOR_INDEX = (short) 0x8;

    private final List<PColor>  _colors;

    public PaletteRecord() {
      PColor[] defaultPalette = createDefaultPalette();
      _colors    = new ArrayList<PColor>(defaultPalette.length);
      for (int i = 0; i < defaultPalette.length; i++) {
        _colors.add(defaultPalette[i]);
      }
    }

    public PaletteRecord(RecordInputStream in) {
       int field_1_numcolors = in.readShort();
       _colors    = new ArrayList<PColor>(field_1_numcolors);
       for (int k = 0; k < field_1_numcolors; k++) {
           _colors.add(new PColor(in));
       }
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PALETTE]
"");
        buffer.append(""  numcolors     = "").append(_colors.size()).append('
');
        for (int i = 0; i < _colors.size(); i++) {
            PColor c = _colors.get(i);
            buffer.append(""* colornum      = "").append(i).append('
');
            buffer.append(c.toString());
            buffer.append(""
    public byte[] getColor(int byteIndex) {
        int i = byteIndex - FIRST_COLOR_INDEX;
        if (i < 0 || i >= _colors.size()) {
            return null;
        }
        return _colors.get(i).getTriplet();
    }

    
    public void setColor(short byteIndex, byte red, byte green, byte blue)
    {
        int i = byteIndex - FIRST_COLOR_INDEX;
        if (i < 0 || i >= STANDARD_PALETTE_SIZE)
        {
            return;
        }
        
        while (_colors.size() <= i) {
            _colors.add(new PColor(0, 0, 0));
        }
        PColor custColor = new PColor(red, green, blue);
        _colors.set(i, custColor);
    }

    
    private static PColor[] createDefaultPalette()
    {
        return new PColor[] {
                pc(0, 0, 0),
                pc(255, 255, 255),
                pc(255, 0, 0),
                pc(0, 255, 0),
                pc(0, 0, 255),
                pc(255, 255, 0),
                pc(255, 0, 255),
                pc(0, 255, 255),
                pc(128, 0, 0),
                pc(0, 128, 0),
                pc(0, 0, 128),
                pc(128, 128, 0),
                pc(128, 0, 128),
                pc(0, 128, 128),
                pc(192, 192, 192),
                pc(128, 128, 128),
                pc(153, 153, 255),
                pc(153, 51, 102),
                pc(255, 255, 204),
                pc(204, 255, 255),
                pc(102, 0, 102),
                pc(255, 128, 128),
                pc(0, 102, 204),
                pc(204, 204, 255),
                pc(0, 0, 128),
                pc(255, 0, 255),
                pc(255, 255, 0),
                pc(0, 255, 255),
                pc(128, 0, 128),
                pc(128, 0, 0),
                pc(0, 128, 128),
                pc(0, 0, 255),
                pc(0, 204, 255),
                pc(204, 255, 255),
                pc(204, 255, 204),
                pc(255, 255, 153),
                pc(153, 204, 255),
                pc(255, 153, 204),
                pc(204, 153, 255),
                pc(255, 204, 153),
                pc(51, 102, 255),
                pc(51, 204, 204),
                pc(153, 204, 0),
                pc(255, 204, 0),
                pc(255, 153, 0),
                pc(255, 102, 0),
                pc(102, 102, 153),
                pc(150, 150, 150),
                pc(0, 51, 102),
                pc(51, 153, 102),
                pc(0, 51, 0),
                pc(51, 51, 0),
                pc(153, 51, 0),
                pc(153, 51, 102),
                pc(51, 51, 153),
                pc(51, 51, 51),
        };
    }

    private static PColor pc(int r, int g, int b) {
        return new PColor(r, g, b);
    }

    
    private static final class PColor {
        public static final short ENCODED_SIZE = 4;
        private int _red;
        private int _green;
        private int _blue;

        public PColor(int red, int green, int blue) {
            _red = red;
            _green = green;
            _blue = blue;
        }

        public byte[] getTriplet() {
            return new byte[] { (byte) _red, (byte) _green, (byte) _blue };
        }

        public PColor(RecordInputStream in) {
            _red = in.readByte();
            _green = in.readByte();
            _blue = in.readByte();
            in.readByte(); 
        }

        public void serialize(LittleEndianOutput out) {
            out.writeByte(_red);
            out.writeByte(_green);
            out.writeByte(_blue);
            out.writeByte(0);
        }

        public String toString() {
            StringBuffer buffer = new StringBuffer();
            buffer.append(""  red   = "").append(_red & 0xff).append('
');
            buffer.append(""  green = "").append(_green & 0xff).append('
');
            buffer.append(""  blue  = "").append(_blue & 0xff).append('
');
            return buffer.toString();
        }
    }
}
"
poi,3,org.apache.poi.hssf.record.SharedFormulaRecord,19,2,0,19,89,155,2,17,16,0.854166667,531,0.875,0,0.392857143,0.236842105,1,4,26.52631579,10,1.7368,5,"

package org.apache.poi.hssf.record;

import org.apache.poi.ss.formula.ptg.*;
import org.apache.poi.hssf.util.CellRangeAddress8Bit;
import org.apache.poi.ss.formula.Formula;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.formula.SharedFormula;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class SharedFormulaRecord extends SharedValueRecordBase {
    public final static short   sid = 0x04BC;

    private int field_5_reserved;
    private Formula field_7_parsed_expr;

    
    public SharedFormulaRecord() {
        this(new CellRangeAddress8Bit(0,0,0,0));
    }
    private SharedFormulaRecord(CellRangeAddress8Bit range) {
        super(range);
        field_7_parsed_expr = Formula.create(Ptg.EMPTY_PTG_ARRAY);
    }

    
    public SharedFormulaRecord(RecordInputStream in) {
        super(in);
        field_5_reserved        = in.readShort();
        int field_6_expression_len = in.readShort();
        int nAvailableBytes = in.available();
        field_7_parsed_expr = Formula.read(field_6_expression_len, in, nAvailableBytes);
    }

    protected void serializeExtraData(LittleEndianOutput out) {
        out.writeShort(field_5_reserved);
        field_7_parsed_expr.serialize(out);
    }

    protected int getExtraDataSize() {
        return 2 + field_7_parsed_expr.getEncodedSize();
    }

    

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[SHARED FORMULA ("").append(HexDump.intToHex(sid)).append(""]
"");
        buffer.append(""    .range      = "").append(getRange().toString()).append(""
"");
        buffer.append(""    .reserved    = "").append(HexDump.shortToHex(field_5_reserved)).append(""
"");

        Ptg[] ptgs = field_7_parsed_expr.getTokens();
        for (int k = 0; k < ptgs.length; k++ ) {
           buffer.append(""Formula["").append(k).append(""]"");
           Ptg ptg = ptgs[k];
           buffer.append(ptg.toString()).append(ptg.getRVAType()).append(""
"");
        }

        buffer.append(""[/SHARED FORMULA]
"");
        return buffer.toString();
    }

    public short getSid() {
        return sid;
    }

    
    public Ptg[] getFormulaTokens(FormulaRecord formula) {
        int formulaRow = formula.getRow();
        int formulaColumn = formula.getColumn();
        
        if (!isInRange(formulaRow, formulaColumn)) {
            throw new RuntimeException(""Shared Formula Conversion: Coding Error"");
        }

        SharedFormula sf = new SharedFormula(SpreadsheetVersion.EXCEL97);
        return sf.convertSharedFormulas(field_7_parsed_expr.getTokens(), formulaRow, formulaColumn);
    }

    public Object clone() {
        SharedFormulaRecord result = new SharedFormulaRecord(getRange());
        result.field_5_reserved = field_5_reserved;
        result.field_7_parsed_expr = field_7_parsed_expr.copy();
        return result;
    }
	public boolean isFormulaSame(SharedFormulaRecord other) {
		return field_7_parsed_expr.isSame(other.field_7_parsed_expr);
	}
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFDataFormat,9,1,0,5,32,0,3,2,7,0.65625,431,1.0,1,0.0,0.25,0,0,46.44444444,8,2.3333,0,"



package org.apache.poi.hssf.usermodel;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import org.apache.poi.hssf.model.InternalWorkbook;
import org.apache.poi.hssf.record.FormatRecord;
import org.apache.poi.ss.usermodel.BuiltinFormats;
import org.apache.poi.ss.usermodel.DataFormat;


public final class HSSFDataFormat implements DataFormat {
	private static final String[] _builtinFormats = BuiltinFormats.getAll();

	private final Vector<String> _formats = new Vector<String>();
	private final InternalWorkbook _workbook;
	private boolean _movedBuiltins = false;  
	
	
	

	
	HSSFDataFormat(InternalWorkbook workbook) {
		_workbook = workbook;

		Iterator<FormatRecord> i = workbook.getFormats().iterator();
		while (i.hasNext()) {
			FormatRecord r = i.next();
			ensureFormatsSize(r.getIndexCode());
			_formats.set(r.getIndexCode(), r.getFormatString());
		}
	}

	public static List<String> getBuiltinFormats() {
		return Arrays.asList(_builtinFormats);
	}

	
	public static short getBuiltinFormat(String format) {
		return (short) BuiltinFormats.getBuiltinFormat(format);
	}

	
	public short getFormat(String pFormat) {
	   
		String format;
		if (pFormat.toUpperCase().equals(""TEXT"")) {
			format = ""@"";
		} else {
			format = pFormat;
		}

		
		if (!_movedBuiltins) {
			for (int i=0; i<_builtinFormats.length; i++) {
			   ensureFormatsSize(i);
				if (_formats.get(i) == null) {
				   _formats.set(i, _builtinFormats[i]);
				} else {
				   
				}
			}
			_movedBuiltins = true;
		}
		
		
		for(int i=0; i<_formats.size(); i++) {
		   if(format.equals(_formats.get(i))) {
		      return (short)i;
		   }
		}

		
		short index = _workbook.getFormat(format, true);
		ensureFormatsSize(index);
		_formats.set(index, format);
		return index;
	}

	
	public String getFormat(short index) {
		if (_movedBuiltins) {
			return _formats.get(index);
		}

        if(index == -1) {
            
            
            return null;
        }

		String fmt = _formats.size() > index ? _formats.get(index) : null;
		if (_builtinFormats.length > index && _builtinFormats[index] != null) {
		   
		   if (fmt != null) {
		      
		      return fmt;
		   } else {
		      
	         return _builtinFormats[index];
		   }
		}
		return fmt;
	}

	
	public static String getBuiltinFormat(short index) {
		return BuiltinFormats.getBuiltinFormat(index);
	}

	
	public static int getNumberOfBuiltinBuiltinFormats() {
		return _builtinFormats.length;
	}
	
	
	private void ensureFormatsSize(int index) {
	   if(_formats.size() <= index) {
	      _formats.setSize(index+1);
	   }
	}
}
"
poi,3,org.apache.poi.util.LittleEndian,36,1,0,188,44,630,186,2,33,2.0,398,0.0,0,0.0,0.200617284,0,0,10.05555556,2,1.2222,1,"

package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;


public class LittleEndian implements LittleEndianConsts
{

    
    public static final class BufferUnderrunException extends IOException
    {
        
        private static final long serialVersionUID = 8736973884877006145L;

        BufferUnderrunException()
        {
            super( ""buffer underrun"" );
        }
    }

    
    public static byte[] getByteArray( byte[] data, int offset, int size )
    {
        byte[] copy = new byte[size];
        System.arraycopy( data, offset, copy, 0, size );

        return copy;
    }

    
    public static double getDouble( byte[] data )
    {
        return Double.longBitsToDouble( getLong( data, 0 ) );
    }

    
    public static double getDouble( byte[] data, int offset )
    {
        return Double.longBitsToDouble( getLong( data, offset ) );
    }

    
    public static float getFloat( byte[] data )
    {
        return getFloat( data, 0 );
    }

    
    public static float getFloat( byte[] data, int offset )
    {
        return Float.intBitsToFloat( getInt( data, offset ) );
    }

    
    public static int getInt( byte[] data )
    {
        return getInt( data, 0 );
    }

    
    public static int getInt( byte[] data, int offset )
    {
        int i = offset;
        int b0 = data[i++] & 0xFF;
        int b1 = data[i++] & 0xFF;
        int b2 = data[i++] & 0xFF;
        int b3 = data[i++] & 0xFF;
        return ( b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + ( b0 << 0 );
    }

    
    public static long getLong( byte[] data )
    {
        return getLong( data, 0 );
    }

    
    public static long getLong( byte[] data, int offset )
    {
        long result = 0xff & data[offset + 7];

        for ( int j = offset + LONG_SIZE - 1; j >= offset; j-- )
        {
            result <<= 8;
            result |= 0xff & data[j];
        }
        return result;
    }

    
    public static short getShort( byte[] data )
    {
        return getShort( data, 0 );
    }

    
    public static short getShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return (short) ( ( b1 << 8 ) + ( b0 << 0 ) );
    }

    
    public static short[] getShortArray( byte[] data, int offset, int size )
    {
        short[] result = new short[size / SHORT_SIZE];
        for ( int i = 0; i < result.length; i++ )
        {
            result[i] = getShort( data, offset + i * SHORT_SIZE );
        }
        return result;
    }

    
    public static short getUByte( byte[] data )
    {
        return (short) ( data[0] & 0xFF );
    }

    
    public static short getUByte( byte[] data, int offset )
    {
        return (short) ( data[offset] & 0xFF );
    }

    
    public static long getUInt( byte[] data )
    {
        return getUInt( data, 0 );
    }

    
    public static long getUInt( byte[] data, int offset )
    {
        long retNum = getInt( data, offset );
        return retNum & 0x00FFFFFFFFl;
    }

    
    @Deprecated
    public static int getUnsignedByte( byte[] data, int offset )
    {
        return data[offset] & 0xFF;
    }

    
    public static int getUShort( byte[] data )
    {
        return getUShort( data, 0 );
    }

    
    public static int getUShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return ( b1 << 8 ) + ( b0 << 0 );
    }

    
    public static void putByte( byte[] data, int offset, int value )
    {
        data[offset] = (byte) value;
    }

    
    public static void putDouble( byte[] data, int offset, double value )
    {
        putLong( data, offset, Double.doubleToLongBits( value ) );
    }

    
    public static void putDouble( double value, OutputStream outputStream )
            throws IOException
    {
        putLong( Double.doubleToLongBits( value ), outputStream );
    }

    
    public static void putFloat( byte[] data, int offset, float value )
    {
        putInt( data, offset, Float.floatToIntBits( value ) );
    }

    
    public static void putFloat( float value, OutputStream outputStream )
            throws IOException
    {
        putInt( Float.floatToIntBits( value ), outputStream );
    }

    
    @Deprecated
    public static void putInt( byte[] data, int value )
    {
        putInt( data, 0, value );
    }

    
    public static void putInt( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    
    public static void putInt( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    
    public static void putLong( byte[] data, int offset, long value )
    {
        data[offset + 0] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[offset + 1] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[offset + 2] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[offset + 3] = (byte) ( ( value >>> 24 ) & 0xFF );
        data[offset + 4] = (byte) ( ( value >>> 32 ) & 0xFF );
        data[offset + 5] = (byte) ( ( value >>> 40 ) & 0xFF );
        data[offset + 6] = (byte) ( ( value >>> 48 ) & 0xFF );
        data[offset + 7] = (byte) ( ( value >>> 56 ) & 0xFF );
    }

    
    public static void putLong( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 32 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 40 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 48 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 56 ) & 0xFF ) );
    }

    
    public static void putShort( byte[] data, int offset, short value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    
    @Deprecated
    public static void putShort( byte[] data, short value )
    {
        putShort( data, 0, value );
    }

    
    public static void putShort( OutputStream outputStream, short value )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    
    public static void putShortArray( byte[] data, int startOffset,
            short[] value )
    {
        int offset = startOffset;
        for ( short s : value )
        {
            putShort( data, offset, s );
            offset += SHORT_SIZE;
        }
    }

    
    public static void putUByte( byte[] data, int offset, short value )
    {
        data[offset] = (byte) ( value & 0xFF );
    }

    
    public static void putUInt( byte[] data, int offset, long value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    
    @Deprecated
    public static void putUInt( byte[] data, long value )
    {
        putUInt( data, 0, value );
    }

    
    public static void putUInt( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    
    public static void putUShort( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    
    public static void putUShort( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    
    public static int readInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }
    
    
    public static long readUInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
       long retNum = readInt(stream);
       return retNum & 0x00FFFFFFFFl;
    }

    
    public static long readLong( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        int ch5 = stream.read();
        int ch6 = stream.read();
        int ch7 = stream.read();
        int ch8 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 | ch5 | ch6 | ch7 | ch8 ) < 0 )
        {
            throw new BufferUnderrunException();
        }

        return ( (long) ch8 << 56 ) + ( (long) ch7 << 48 )
                + ( (long) ch6 << 40 ) + ( (long) ch5 << 32 )
                + ( (long) ch4 << 24 ) + 
                                         
                ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }

    
    public static short readShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        return (short) readUShort( stream );
    }

    public static int readUShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        if ( ( ch1 | ch2 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch2 << 8 ) + ( ch1 << 0 );
    }

    
    public static int ubyteToInt( byte b )
    {
        return b & 0xFF;
    }

    private LittleEndian()
    {
        
    }
}
"
poi,3,org.apache.poi.hssf.record.Margin,2,1,0,5,2,1,5,0,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.apache.poi.hssf.record;


public interface Margin {
	
	
	public double getMargin();

	
	public void setMargin(double field_1_margin);
}
"
poi,3,org.apache.poi.hssf.record.FnGroupCountRecord,10,2,0,6,19,39,2,4,8,0.925925926,91,0.333333333,0,0.578947368,0.32,1,4,7.8,2,0.9,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class FnGroupCountRecord
    extends StandardRecord
{
    public final static short sid   = 0x9c;

    

    public final static short COUNT = 14;
    private short             field_1_count;

    public FnGroupCountRecord()
    {
    }

    public FnGroupCountRecord(RecordInputStream in)
    {
        field_1_count = in.readShort();
    }

    

    public void setCount(short count)
    {
        field_1_count = count;
    }

    

    public short getCount()
    {
        return field_1_count;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[FNGROUPCOUNT]
"");
        buffer.append(""    .count            = "").append(getCount())
            .append(""
"");
        buffer.append(""[/FNGROUPCOUNT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getCount());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.ddf.EscherChildAnchorRecord,15,2,0,6,31,43,1,5,15,0.833333333,229,0.666666667,0,0.575757576,0.333333333,1,5,13.86666667,1,0.9333,1,"


package org.apache.poi.ddf;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


public class EscherChildAnchorRecord
        extends EscherRecord
{
    public static final short RECORD_ID = (short) 0xF00F;
    public static final String RECORD_DESCRIPTION = ""MsofbtChildAnchor"";

    private int field_1_dx1;
    private int field_2_dy1;
    private int field_3_dx2;
    private int field_4_dy2;

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
         readHeader( data, offset );
        int pos            = offset + 8;
        int size           = 0;
        field_1_dx1    =  LittleEndian.getInt( data, pos + size );size+=4;
        field_2_dy1    =  LittleEndian.getInt( data, pos + size );size+=4;
        field_3_dx2  =  LittleEndian.getInt( data, pos + size );size+=4;
        field_4_dy2 =  LittleEndian.getInt( data, pos + size );size+=4;
        return 8 + size;
    }

    public int serialize(int offset, byte[] data, EscherSerializationListener listener) {
        listener.beforeRecordSerialize( offset, getRecordId(), this );
        int pos = offset;
        LittleEndian.putShort( data, pos, getOptions() );          pos += 2;
        LittleEndian.putShort( data, pos, getRecordId() );         pos += 2;
        LittleEndian.putInt( data, pos, getRecordSize()-8 );       pos += 4;
        LittleEndian.putInt( data, pos, field_1_dx1 );             pos += 4;
        LittleEndian.putInt( data, pos, field_2_dy1 );             pos += 4;
        LittleEndian.putInt( data, pos, field_3_dx2 );           pos += 4;
        LittleEndian.putInt( data, pos, field_4_dy2 );          pos += 4;

        listener.afterRecordSerialize( pos, getRecordId(), pos - offset, this );
        return pos - offset;
    }

    public int getRecordSize()
    {
        return 8 + 4 * 4;
    }

    public short getRecordId() {
        return RECORD_ID;
    }

    public String getRecordName() {
        return ""ChildAnchor"";
    }


    
    public String toString()
    {
        String nl = System.getProperty(""line.separator"");

        return getClass().getName() + "":"" + nl +
                ""  RecordId: 0x"" + HexDump.toHex(RECORD_ID) + nl +
                ""  Version: 0x"" + HexDump.toHex(getVersion()) + nl +
                ""  Instance: 0x"" + HexDump.toHex(getInstance()) + nl +
                ""  X1: "" + field_1_dx1 + nl +
                ""  Y1: "" + field_2_dy1 + nl +
                ""  X2: "" + field_3_dx2 + nl +
                ""  Y2: "" + field_4_dy2 + nl ;

    }

    @Override
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<X1>"").append(field_1_dx1).append(""</X1>
"")
                .append(tab).append(""	"").append(""<Y1>"").append(field_2_dy1).append(""</Y1>
"")
                .append(tab).append(""	"").append(""<X2>"").append(field_3_dx2).append(""</X2>
"")
                .append(tab).append(""	"").append(""<Y2>"").append(field_4_dy2).append(""</Y2>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }

    
    public int getDx1()
    {
        return field_1_dx1;
    }

    
    public void setDx1( int field_1_dx1 )
    {
        this.field_1_dx1 = field_1_dx1;
    }

    
    public int getDy1()
    {
        return field_2_dy1;
    }

    
    public void setDy1( int field_2_dy1 )
    {
        this.field_2_dy1 = field_2_dy1;
    }

    
    public int getDx2()
    {
        return field_3_dx2;
    }

    
    public void setDx2( int field_3_dx2 )
    {
        this.field_3_dx2 = field_3_dx2;
    }

    
    public int getDy2()
    {
        return field_4_dy2;
    }

    
    public void setDy2( int field_4_dy2 )
    {
        this.field_4_dy2 = field_4_dy2;
    }

}
"
poi,3,org.apache.poi.hssf.util.AreaReference,5,1,0,3,21,0,2,1,4,0.5,149,1.0,1,0.0,0.7,0,0,28.4,2,1.2,1,"

package org.apache.poi.hssf.util;


public final class AreaReference extends org.apache.poi.ss.util.AreaReference {
    
    public AreaReference(String reference) {
		super(reference);
    }
    
    
    public AreaReference(CellReference topLeft, CellReference botRight) {
		super(topLeft, botRight);
    }
}
"
poi,3,org.apache.poi.hssf.record.BackupRecord,10,2,0,7,19,39,3,4,8,0.833333333,91,0.5,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class BackupRecord
    extends StandardRecord
{
    public final static short sid = 0x40;
    private short             field_1_backup;   

    public BackupRecord()
    {
    }

    public BackupRecord(RecordInputStream in)
    {
        field_1_backup = in.readShort();
    }

    

    public void setBackup(short backup)
    {
        field_1_backup = backup;
    }

    

    public short getBackup()
    {
        return field_1_backup;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[BACKUP]
"");
        buffer.append(""    .backup          = "")
            .append(Integer.toHexString(getBackup())).append(""
"");
        buffer.append(""[/BACKUP]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getBackup());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.usermodel.HSSFShapeContainer,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.poi.hssf.usermodel;

import java.util.List;


public interface HSSFShapeContainer extends Iterable<HSSFShape>
{
    
    List<HSSFShape> getChildren();

    
    public void addShape(HSSFShape shape);

    
    void setCoordinates( int x1, int y1, int x2, int y2 );

    void clear();

    
    public int getX1();

    
    public int getY1();

    
    public int getX2();

    
    public int getY2();

    
    public boolean removeShape(HSSFShape shape);
}
"
poi,3,org.apache.poi.hssf.model.CommentShape,4,3,0,13,32,4,2,11,2,0.666666667,155,1.0,1,0.8,0.5,1,1,37.5,11,3.75,2,"

package org.apache.poi.hssf.model;

import java.util.Iterator;
import java.util.List;

import org.apache.poi.ddf.EscherOptRecord;
import org.apache.poi.ddf.EscherProperties;
import org.apache.poi.ddf.EscherProperty;
import org.apache.poi.ddf.EscherSimpleProperty;
import org.apache.poi.hssf.record.CommonObjectDataSubRecord;
import org.apache.poi.hssf.record.NoteRecord;
import org.apache.poi.hssf.record.NoteStructureSubRecord;
import org.apache.poi.hssf.record.ObjRecord;
import org.apache.poi.hssf.record.SubRecord;
import org.apache.poi.hssf.usermodel.HSSFComment;
import org.apache.poi.hssf.usermodel.HSSFShape;


@Deprecated
public final class CommentShape extends TextboxShape {

    private NoteRecord _note;

    
     public CommentShape( HSSFComment hssfShape, int shapeId )
    {
        super(hssfShape, shapeId);

        _note = createNoteRecord(hssfShape, shapeId);

        ObjRecord obj = getObjRecord();
        List<SubRecord> records = obj.getSubRecords();
        int cmoIdx = 0;
        for (int i = 0; i < records.size(); i++) {
            Object r = records.get(i);

            if (r instanceof CommonObjectDataSubRecord){
                
                CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord)r;
                cmo.setAutofill(false);
                cmoIdx = i;
            }
        }
        
        
        NoteStructureSubRecord u = new NoteStructureSubRecord();
        obj.addSubRecord(cmoIdx+1, u);
    }

    
     private NoteRecord createNoteRecord( HSSFComment shape, int shapeId )
    {
        NoteRecord note = new NoteRecord();
        note.setColumn(shape.getColumn());
        note.setRow(shape.getRow());
        note.setFlags(shape.isVisible() ? NoteRecord.NOTE_VISIBLE : NoteRecord.NOTE_HIDDEN);
        note.setShapeId(shapeId);
        note.setAuthor(shape.getAuthor() == null ? """" : shape.getAuthor());
        return note;
    }

    
    @Override
	protected int addStandardOptions( HSSFShape shape, EscherOptRecord opt )
    {
        super.addStandardOptions(shape, opt);

        
        List<EscherProperty> props = opt.getEscherProperties();
        for (Iterator<EscherProperty> iterator = props.iterator(); iterator.hasNext(); ) {
            EscherProperty prop = iterator.next();
            switch (prop.getId()){
                case EscherProperties.TEXT__TEXTLEFT:
                case EscherProperties.TEXT__TEXTRIGHT:
                case EscherProperties.TEXT__TEXTTOP:
                case EscherProperties.TEXT__TEXTBOTTOM:
                case EscherProperties.GROUPSHAPE__PRINT:
                case EscherProperties.FILL__FILLBACKCOLOR:
                case EscherProperties.LINESTYLE__COLOR:
                    iterator.remove();
                    break;
            }
        }

        HSSFComment comment = (HSSFComment)shape;
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.GROUPSHAPE__PRINT, comment.isVisible() ? 0x000A0000 : 0x000A0002) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.SHADOWSTYLE__SHADOWOBSURED, 0x00030003 ) );
        opt.addEscherProperty( new EscherSimpleProperty( EscherProperties.SHADOWSTYLE__COLOR, 0x00000000 ) );
        opt.sortProperties();
        return opt.getEscherProperties().size();   
    }

    
    public NoteRecord getNoteRecord()
    {
        return _note;
    }

    @Override
    int getCmoObjectId(int shapeId){
        return shapeId;
    }

}
"
poi,3,org.apache.poi.poifs.property.PropertyFactory,2,1,0,5,10,1,1,4,0,2.0,82,0.0,0,0.0,0.5,0,0,40.0,1,0.5,0,"

        

package org.apache.poi.poifs.property;

import java.io.IOException;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.storage.ListManagedBlock;



class PropertyFactory
{
    
    private PropertyFactory()
    {
    }

    
    static List<Property> convertToProperties(ListManagedBlock [] blocks)
        throws IOException
    {
        List<Property> properties = new ArrayList<Property>();

        for (int j = 0; j < blocks.length; j++) {
            byte[] data = blocks[ j ].getData();
            convertToProperties(data, properties);
        }
        return properties;
    }
    
    static void convertToProperties(byte[] data, List<Property> properties)
        throws IOException
    {
       int property_count = data.length / POIFSConstants.PROPERTY_SIZE;
       int offset         = 0;

       for (int k = 0; k < property_count; k++) {
          switch (data[ offset + PropertyConstants.PROPERTY_TYPE_OFFSET ]) {
          case PropertyConstants.DIRECTORY_TYPE :
             properties.add(
                   new DirectoryProperty(properties.size(), data, offset)
             );
             break;

          case PropertyConstants.DOCUMENT_TYPE :
             properties.add(
                   new DocumentProperty(properties.size(), data, offset)
             );
             break;

          case PropertyConstants.ROOT_TYPE :
             properties.add(
                   new RootProperty(properties.size(), data, offset)
             );
             break;

          default :
             properties.add(null);
             break;
          }
          
          offset += POIFSConstants.PROPERTY_SIZE;
       }
    }
    
}   

"
poi,3,org.apache.poi.util.IntMapper,7,1,0,4,18,0,4,0,7,0.611111111,75,1.0,0,0.0,0.523809524,0,0,9.285714286,2,0.8571,1,"



package org.apache.poi.util;

import java.util.*;



public class IntMapper<T>
{
  private List<T> elements;
  private Map<T,Integer> valueKeyMap;

  private static final int _default_size = 10;

    

    public IntMapper()
    {
        this(_default_size);
    }

    public IntMapper(final int initialCapacity)
    {
        elements = new ArrayList<T>(initialCapacity);
        valueKeyMap = new HashMap<T,Integer>(initialCapacity);
    }

    
    public boolean add(final T value)
    {
      int index = elements.size();
      elements.add(value);
      valueKeyMap.put(value, index);
      return true;
    }

    public int size() {
      return elements.size();
    }

    public T get(int index) {
      return elements.get(index);
    }

    public int getIndex(T o) {
      Integer i = valueKeyMap.get(o);
      if (i == null)
        return -1;
      return i.intValue();
    }

    public Iterator<T> iterator() {
      return elements.iterator();
    }
}   

"
poi,3,org.apache.poi.hssf.usermodel.HSSFAnchor,12,1,2,18,13,42,18,0,12,0.818181818,62,0.0,0,0.0,0.708333333,0,0,3.833333333,1,0.8333,0,"

package org.apache.poi.hssf.usermodel;


import org.apache.poi.ddf.EscherChildAnchorRecord;
import org.apache.poi.ddf.EscherClientAnchorRecord;
import org.apache.poi.ddf.EscherContainerRecord;
import org.apache.poi.ddf.EscherRecord;


public abstract class HSSFAnchor {

    protected boolean _isHorizontallyFlipped = false;
    protected boolean _isVerticallyFlipped = false;

    public HSSFAnchor() {
        createEscherAnchor();
    }

    public HSSFAnchor(int dx1, int dy1, int dx2, int dy2) {
        createEscherAnchor();
        setDx1(dx1);
        setDy1(dy1);
        setDx2(dx2);
        setDy2(dy2);
    }

    public static HSSFAnchor createAnchorFromEscher(EscherContainerRecord container){
        if (null != container.getChildById(EscherChildAnchorRecord.RECORD_ID)){
            return new HSSFChildAnchor((EscherChildAnchorRecord) container.getChildById(EscherChildAnchorRecord.RECORD_ID));
        } else {
            if (null != container.getChildById(EscherClientAnchorRecord.RECORD_ID)){
                return new HSSFClientAnchor((EscherClientAnchorRecord) container.getChildById(EscherClientAnchorRecord.RECORD_ID));
            }
            return null;
        }
    }

    
    public abstract int getDx1();

    
    public abstract void setDx1(int dx1);

    
    public abstract int getDy1();

    
    public abstract void setDy1(int dy1);

    
    public abstract int getDy2();

    
    public abstract void setDy2(int dy2);

    
    public abstract int getDx2();

    
    public abstract void setDx2(int dx2);

    
    public abstract boolean isHorizontallyFlipped();

    
    public abstract boolean isVerticallyFlipped();

    protected abstract EscherRecord getEscherAnchor();

    protected abstract void createEscherAnchor();
}
"
poi,3,org.apache.poi.hssf.model.DrawingManager,7,1,0,3,30,0,0,3,4,0.333333333,212,0.0,1,0.0,0.476190476,0,0,29.0,7,2.1429,0,"

package org.apache.poi.hssf.model;

import org.apache.poi.ddf.EscherDggRecord;
import org.apache.poi.ddf.EscherDgRecord;

import java.util.Map;
import java.util.HashMap;


public class DrawingManager
{
    EscherDggRecord dgg;
    Map<Short, EscherDgRecord> dgMap = new HashMap<Short, EscherDgRecord>(); 

    public DrawingManager( EscherDggRecord dgg )
    {
        this.dgg = dgg;
    }

    public EscherDgRecord createDgRecord()
    {
        EscherDgRecord dg = new EscherDgRecord();
        dg.setRecordId( EscherDgRecord.RECORD_ID );
        short dgId = findNewDrawingGroupId();
        dg.setOptions( (short) ( dgId << 4 ) );
        dg.setNumShapes( 0 );
        dg.setLastMSOSPID( -1 );
        dgg.addCluster( dgId, 0 );
        dgg.setDrawingsSaved( dgg.getDrawingsSaved() + 1 );
        dgMap.put( dgId, dg );
        return dg;
    }

    
    public int allocateShapeId(short drawingGroupId)
    {
        
        EscherDgRecord dg = dgMap.get(drawingGroupId);
        int lastShapeId = dg.getLastMSOSPID();


        
        int newShapeId = 0;
        if (lastShapeId % 1024 == 1023)
        {
            
                
            newShapeId = findFreeSPIDBlock();
                
            dgg.addCluster(drawingGroupId, 1);
        }
        else
        {
            
                
            for (int i = 0; i < dgg.getFileIdClusters().length; i++)
            {
                EscherDggRecord.FileIdCluster c = dgg.getFileIdClusters()[i];
                if (c.getDrawingGroupId() == drawingGroupId)
                {
                    if (c.getNumShapeIdsUsed() != 1024)
                    {
                        
                        c.incrementShapeId();
                    }
                }
                
                if (dg.getLastMSOSPID() == -1)
                {
                    newShapeId = findFreeSPIDBlock();
                }
                else
                {
                    
                    newShapeId = dg.getLastMSOSPID() + 1;
                }
            }
        }
        
        dgg.setNumShapesSaved(dgg.getNumShapesSaved() + 1);
        
        if (newShapeId >= dgg.getShapeIdMax())
        {
            
                
            dgg.setShapeIdMax(newShapeId + 1);
        }
        
        dg.setLastMSOSPID(newShapeId);
        
        dg.incrementShapeCount();


        return newShapeId;
    }

    
    short findNewDrawingGroupId()
    {
        short dgId = 1;
        while ( drawingGroupExists( dgId ) )
            dgId++;
        return dgId;
    }

    boolean drawingGroupExists( short dgId )
    {
        for ( int i = 0; i < dgg.getFileIdClusters().length; i++ )
        {
            if ( dgg.getFileIdClusters()[i].getDrawingGroupId() == dgId )
                return true;
        }
        return false;
    }

    int findFreeSPIDBlock()
    {
        int max = dgg.getShapeIdMax();
        int next = ( ( max / 1024 ) + 1 ) * 1024;
        return next;
    }

    public EscherDggRecord getDgg()
    {
        return dgg;
    }

}
"
poi,3,org.apache.poi.util.ShortList,25,1,0,0,29,0,0,0,24,0.388888889,629,1.0,0,0.0,0.313333333,1,1,24.04,9,2.6,1,"

package org.apache.poi.util;



public class ShortList
{
    private short[]          _array;
    private int              _limit;
    private static final int _default_size = 128;

    

    public ShortList()
    {
        this(_default_size);
    }

    

    public ShortList(final ShortList list)
    {
        this(list._array.length);
        System.arraycopy(list._array, 0, _array, 0, _array.length);
        _limit = list._limit;
    }

    

    public ShortList(final int initialCapacity)
    {
        _array = new short[ initialCapacity ];
        _limit = 0;
    }

    

    public void add(final int index, final short value)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (index == _limit)
        {
            add(value);
        }
        else
        {

            
            if (_limit == _array.length)
            {
                growArray(_limit * 2);
            }
            System.arraycopy(_array, index, _array, index + 1,
                             _limit - index);
            _array[ index ] = value;
            _limit++;
        }
    }

    

    public boolean add(final short value)
    {
        if (_limit == _array.length)
        {
            growArray(_limit * 2);
        }
        _array[ _limit++ ] = value;
        return true;
    }

    

    public boolean addAll(final ShortList c)
    {
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }
            System.arraycopy(c._array, 0, _array, _limit, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public boolean addAll(final int index, final ShortList c)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }

            
            System.arraycopy(_array, index, _array, index + c._limit,
                             _limit - index);

            
            System.arraycopy(c._array, 0, _array, index, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public void clear()
    {
        _limit = 0;
    }

    

    public boolean contains(final short o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (_array[ j ] == o)
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean containsAll(final ShortList c)
    {
        boolean rval = true;

        if (this != c)
        {
            for (int j = 0; rval && (j < c._limit); j++)
            {
                if (!contains(c._array[ j ]))
                {
                    rval = false;
                }
            }
        }
        return rval;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = this == o;

        if (!rval && (o != null) && (o.getClass() == this.getClass()))
        {
            ShortList other = ( ShortList ) o;

            if (other._limit == _limit)
            {

                
                rval = true;
                for (int j = 0; rval && (j < _limit); j++)
                {
                    rval = _array[ j ] == other._array[ j ];
                }
            }
        }
        return rval;
    }

    

    public short get(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        return _array[ index ];
    }

    

    public int hashCode()
    {
        int hash = 0;

        for (int j = 0; j < _limit; j++)
        {
            hash = (31 * hash) + _array[ j ];
        }
        return hash;
    }

    

    public int indexOf(final short o)
    {
        int rval = 0;

        for (; rval < _limit; rval++)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        if (rval == _limit)
        {
            rval = -1;   
        }
        return rval;
    }

    

    public boolean isEmpty()
    {
        return _limit == 0;
    }

    

    public int lastIndexOf(final short o)
    {
        int rval = _limit - 1;

        for (; rval >= 0; rval--)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        return rval;
    }

    

    public short remove(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        short rval = _array[ index ];

        System.arraycopy(_array, index + 1, _array, index, _limit - index);
        _limit--;
        return rval;
    }

    

    public boolean removeValue(final short o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (o == _array[ j ])
            {
                System.arraycopy(_array, j + 1, _array, j, _limit - j);
                _limit--;
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean removeAll(final ShortList c)
    {
        boolean rval = false;

        for (int j = 0; j < c._limit; j++)
        {
            if (removeValue(c._array[ j ]))
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean retainAll(final ShortList c)
    {
        boolean rval = false;

        for (int j = 0; j < _limit; )
        {
            if (!c.contains(_array[ j ]))
            {
                remove(j);
                rval = true;
            }
            else
            {
                j++;
            }
        }
        return rval;
    }

    

    public short set(final int index, final short element)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        short rval = _array[ index ];

        _array[ index ] = element;
        return rval;
    }

    

    public int size()
    {
        return _limit;
    }

    

    public short [] toArray()
    {
        short[] rval = new short[ _limit ];

        System.arraycopy(_array, 0, rval, 0, _limit);
        return rval;
    }

    

    public short [] toArray(final short [] a)
    {
        short[] rval;

        if (a.length == _limit)
        {
            System.arraycopy(_array, 0, a, 0, _limit);
            rval = a;
        }
        else
        {
            rval = toArray();
        }
        return rval;
    }

    private void growArray(final int new_size)
    {
        int     size      = (new_size == _array.length) ? new_size + 1
                                                        : new_size;
        short[] new_array = new short[ size ];

        System.arraycopy(_array, 0, new_array, 0, _limit);
        _array = new_array;
    }
}   

"
poi,3,org.apache.poi.poifs.storage.SmallBlockTableReader,2,1,0,9,8,1,2,7,2,2.0,24,0.0,0,0.0,0.5,0,0,11.0,1,0.5,2,"

package org.apache.poi.poifs.storage;

import java.io.IOException;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.property.RootProperty;


public final class SmallBlockTableReader {
    private static BlockList prepareSmallDocumentBlocks(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
        
        ListManagedBlock [] smallBlockBlocks = 
                blockList.fetchBlocks(root.getStartBlock(), -1);
        
       
        BlockList list =new SmallDocumentBlockList(
                SmallDocumentBlock.extract(bigBlockSize, smallBlockBlocks));

        return list;
    }
    private static BlockAllocationTableReader prepareReader(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final BlockList list, 
            final RootProperty root, final int sbatStart)
        throws IOException
    {
        
        return new BlockAllocationTableReader(bigBlockSize,
                blockList.fetchBlocks(sbatStart, -1),
                list);
    }
            
    
    public static BlockAllocationTableReader _getSmallDocumentBlockReader(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
       BlockList list = prepareSmallDocumentBlocks(
                bigBlockSize, blockList, root, sbatStart);
        return prepareReader(
                bigBlockSize, blockList, list, root, sbatStart);
    }

    
    public static BlockList getSmallDocumentBlocks(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
        BlockList list = prepareSmallDocumentBlocks(
                bigBlockSize, blockList, root, sbatStart);
        prepareReader(bigBlockSize, blockList, list, root, sbatStart);
        return list;
    }
}
"
poi,3,org.apache.poi.hssf.record.HCenterRecord,11,2,0,7,20,35,3,4,9,0.8,113,0.5,0,0.55,0.257575758,1,4,9.090909091,2,1.0909,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class HCenterRecord extends StandardRecord {
    public final static short sid = 0x0083;
    private short             field_1_hcenter;

    public HCenterRecord()
    {
    }

    public HCenterRecord(RecordInputStream in)
    {
        field_1_hcenter = in.readShort();
    }

    

    public void setHCenter(boolean hc)
    {
        if (hc == true)
        {
            field_1_hcenter = 1;
        }
        else
        {
            field_1_hcenter = 0;
        }
    }

    

    public boolean getHCenter()
    {
        return (field_1_hcenter == 1);
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[HCENTER]
"");
        buffer.append(""    .hcenter        = "").append(getHCenter())
            .append(""
"");
        buffer.append(""[/HCENTER]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(field_1_hcenter);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      HCenterRecord rec = new HCenterRecord();
      rec.field_1_hcenter = field_1_hcenter;
      return rec;
    }
}
"
poi,3,org.apache.poi.hssf.record.TextObjectRecord,12,3,0,13,70,0,6,7,7,0.090909091,613,0.0,1,0.821428571,0.316666667,3,5,50.0,7,2.0833,3,"

package org.apache.poi.hssf.record;

import org.apache.poi.hssf.record.cont.ContinuableRecord;
import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;
import org.apache.poi.ss.formula.ptg.OperandPtg;
import org.apache.poi.ss.formula.ptg.Ptg;
import org.apache.poi.hssf.usermodel.HSSFRichTextString;
import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;


public final class TextObjectRecord extends ContinuableRecord {
	public final static short sid = 0x01B6;

	private static final int FORMAT_RUN_ENCODED_SIZE = 8; 

	private static final BitField HorizontalTextAlignment = BitFieldFactory.getInstance(0x000E);
	private static final BitField VerticalTextAlignment = BitFieldFactory.getInstance(0x0070);
	private static final BitField textLocked = BitFieldFactory.getInstance(0x0200);

	public final static short HORIZONTAL_TEXT_ALIGNMENT_LEFT_ALIGNED = 1;
	public final static short HORIZONTAL_TEXT_ALIGNMENT_CENTERED = 2;
	public final static short HORIZONTAL_TEXT_ALIGNMENT_RIGHT_ALIGNED = 3;
	public final static short HORIZONTAL_TEXT_ALIGNMENT_JUSTIFIED = 4;
	public final static short VERTICAL_TEXT_ALIGNMENT_TOP = 1;
	public final static short VERTICAL_TEXT_ALIGNMENT_CENTER = 2;
	public final static short VERTICAL_TEXT_ALIGNMENT_BOTTOM = 3;
	public final static short VERTICAL_TEXT_ALIGNMENT_JUSTIFY = 4;

	public final static short TEXT_ORIENTATION_NONE = 0;
	public final static short TEXT_ORIENTATION_TOP_TO_BOTTOM = 1;
	public final static short TEXT_ORIENTATION_ROT_RIGHT = 2;
	public final static short TEXT_ORIENTATION_ROT_LEFT = 3;

	private int field_1_options;
	private int field_2_textOrientation;
	private int field_3_reserved4;
	private int field_4_reserved5;
	private int field_5_reserved6;
	private int field_8_reserved7;

	private HSSFRichTextString _text;

	
	private int _unknownPreFormulaInt;
	
	private OperandPtg _linkRefPtg;
	
	private Byte _unknownPostFormulaByte;

	public TextObjectRecord() {
		
	}

	public TextObjectRecord(RecordInputStream in) {
		field_1_options = in.readUShort();
		field_2_textOrientation = in.readUShort();
		field_3_reserved4 = in.readUShort();
		field_4_reserved5 = in.readUShort();
		field_5_reserved6 = in.readUShort();
		int field_6_textLength = in.readUShort();
		int field_7_formattingDataLength = in.readUShort();
		field_8_reserved7 = in.readInt();

		if (in.remaining() > 0) {
			
			
			if (in.remaining() < 11) {
				throw new RecordFormatException(""Not enough remaining data for a link formula"");
			}
			int formulaSize = in.readUShort();
			_unknownPreFormulaInt = in.readInt();
			Ptg[] ptgs = Ptg.readTokens(formulaSize, in);
			if (ptgs.length != 1) {
				throw new RecordFormatException(""Read "" + ptgs.length
						+ "" tokens but expected exactly 1"");
			}
			_linkRefPtg = (OperandPtg) ptgs[0];
			if (in.remaining() > 0) {
				_unknownPostFormulaByte = Byte.valueOf(in.readByte());
			} else {
				_unknownPostFormulaByte = null;
			}
		} else {
			_linkRefPtg = null;
		}
		if (in.remaining() > 0) {
			throw new RecordFormatException(""Unused "" + in.remaining() + "" bytes at end of record"");
		}

		String text;
		if (field_6_textLength > 0) {
			text = readRawString(in, field_6_textLength);
		} else {
			text = """";
		}
		_text = new HSSFRichTextString(text);

		if (field_7_formattingDataLength > 0) {
			processFontRuns(in, _text, field_7_formattingDataLength);
		}
	}

	private static String readRawString(RecordInputStream in, int textLength) {
		byte compressByte = in.readByte();
		boolean isCompressed = (compressByte & 0x01) == 0;
		if (isCompressed) {
			return in.readCompressedUnicode(textLength);
		}
		return in.readUnicodeLEString(textLength);
	}

	private static void processFontRuns(RecordInputStream in, HSSFRichTextString str,
			int formattingRunDataLength) {
		if (formattingRunDataLength % FORMAT_RUN_ENCODED_SIZE != 0) {
			throw new RecordFormatException(""Bad format run data length "" + formattingRunDataLength
					+ "")"");
		}
		int nRuns = formattingRunDataLength / FORMAT_RUN_ENCODED_SIZE;
		for (int i = 0; i < nRuns; i++) {
			short index = in.readShort();
			short iFont = in.readShort();
			in.readInt(); 
			str.applyFont(index, str.length(), iFont);
		}
	}

	public short getSid() {
		return sid;
	}

	private void serializeTXORecord(ContinuableRecordOutput out) {

		out.writeShort(field_1_options);
		out.writeShort(field_2_textOrientation);
		out.writeShort(field_3_reserved4);
		out.writeShort(field_4_reserved5);
		out.writeShort(field_5_reserved6);
		out.writeShort(_text.length());
		out.writeShort(getFormattingDataLength());
		out.writeInt(field_8_reserved7);

		if (_linkRefPtg != null) {
			int formulaSize = _linkRefPtg.getSize();
			out.writeShort(formulaSize);
			out.writeInt(_unknownPreFormulaInt);
			_linkRefPtg.write(out);
			if (_unknownPostFormulaByte != null) {
				out.writeByte(_unknownPostFormulaByte.byteValue());
			}
		}
	}

	private void serializeTrailingRecords(ContinuableRecordOutput out) {
		out.writeContinue();
		out.writeStringData(_text.getString());
		out.writeContinue();
		writeFormatData(out, _text);
	}

	protected void serialize(ContinuableRecordOutput out) {

		serializeTXORecord(out);
		if (_text.getString().length() > 0) {
			serializeTrailingRecords(out);
		}
	}

	private int getFormattingDataLength() {
		if (_text.length() < 1) {
			
			return 0;
		}
		return (_text.numFormattingRuns() + 1) * FORMAT_RUN_ENCODED_SIZE;
	}

	private static void writeFormatData(ContinuableRecordOutput out , HSSFRichTextString str) {
		int nRuns = str.numFormattingRuns();
		for (int i = 0; i < nRuns; i++) {
			out.writeShort(str.getIndexOfFormattingRun(i));
			int fontIndex = str.getFontOfFormattingRun(i);
			out.writeShort(fontIndex == HSSFRichTextString.NO_FONT ? 0 : fontIndex);
			out.writeInt(0); 
		}
		out.writeShort(str.length());
		out.writeShort(0);
		out.writeInt(0); 
	}

	
	public void setHorizontalTextAlignment(int value) {
		field_1_options = HorizontalTextAlignment.setValue(field_1_options, value);
	}

	
	public int getHorizontalTextAlignment() {
		return HorizontalTextAlignment.getValue(field_1_options);
	}

	
	public void setVerticalTextAlignment(int value) {
		field_1_options = VerticalTextAlignment.setValue(field_1_options, value);
	}

	
	public int getVerticalTextAlignment() {
		return VerticalTextAlignment.getValue(field_1_options);
	}

	
	public void setTextLocked(boolean value) {
		field_1_options = textLocked.setBoolean(field_1_options, value);
	}

	
	public boolean isTextLocked() {
		return textLocked.isSet(field_1_options);
	}

	
	public int getTextOrientation() {
		return field_2_textOrientation;
	}

	
	public void setTextOrientation(int textOrientation) {
		this.field_2_textOrientation = textOrientation;
	}

	public HSSFRichTextString getStr() {
		return _text;
	}

	public void setStr(HSSFRichTextString str) {
		_text = str;
	}

	public Ptg getLinkRefPtg() {
		return _linkRefPtg;
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();

		sb.append(""[TXO]
"");
		sb.append(""    .options        = "").append(HexDump.shortToHex(field_1_options)).append(""
"");
		sb.append(""         .isHorizontal = "").append(getHorizontalTextAlignment()).append('
');
		sb.append(""         .isVertical   = "").append(getVerticalTextAlignment()).append('
');
		sb.append(""         .textLocked   = "").append(isTextLocked()).append('
');
		sb.append(""    .textOrientation= "").append(HexDump.shortToHex(getTextOrientation())).append(""
"");
		sb.append(""    .reserved4      = "").append(HexDump.shortToHex(field_3_reserved4)).append(""
"");
		sb.append(""    .reserved5      = "").append(HexDump.shortToHex(field_4_reserved5)).append(""
"");
		sb.append(""    .reserved6      = "").append(HexDump.shortToHex(field_5_reserved6)).append(""
"");
		sb.append(""    .textLength     = "").append(HexDump.shortToHex(_text.length())).append(""
"");
		sb.append(""    .reserved7      = "").append(HexDump.intToHex(field_8_reserved7)).append(""
"");

		sb.append(""    .string = "").append(_text).append('
');

		for (int i = 0; i < _text.numFormattingRuns(); i++) {
			sb.append(""    .textrun = "").append(_text.getFontOfFormattingRun(i)).append('
');

		}
		sb.append(""[/TXO]
"");
		return sb.toString();
	}

	public Object clone() {

		TextObjectRecord rec = new TextObjectRecord();
		rec._text = _text;

		rec.field_1_options = field_1_options;
		rec.field_2_textOrientation = field_2_textOrientation;
		rec.field_3_reserved4 = field_3_reserved4;
		rec.field_4_reserved5 = field_4_reserved5;
		rec.field_5_reserved6 = field_5_reserved6;
		rec.field_8_reserved7 = field_8_reserved7;

		rec._text = _text; 

		if (_linkRefPtg != null) {
			rec._unknownPreFormulaInt = _unknownPreFormulaInt;
			rec._linkRefPtg = _linkRefPtg.copy();
			rec._unknownPostFormulaByte = _unknownPostFormulaByte;
		}
		return rec;
	}
}
"
poi,3,org.apache.poi.util.IntList,27,1,0,4,31,0,4,0,25,0.509615385,683,1.0,0,0.0,0.37037037,1,1,24.14814815,9,2.5556,1,"

package org.apache.poi.util;


public class IntList
{
    private int[]            _array;
    private int              _limit;
    private int              fillval = 0;
    private static final int _default_size = 128;

    

    public IntList()
    {
        this(_default_size);
    }

    public IntList(final int initialCapacity)
    {
        this(initialCapacity,0);
    }


    

    public IntList(final IntList list)
    {
        this(list._array.length);
        System.arraycopy(list._array, 0, _array, 0, _array.length);
        _limit = list._limit;
    }

    

    public IntList(final int initialCapacity, int fillvalue)
    {
        _array = new int[ initialCapacity ];
        if (fillval != 0) {
            fillval = fillvalue;
            fillArray(fillval, _array, 0);
        }
        _limit = 0;
    }

    private void fillArray(int val, int[] array, int index) {
      for (int k = index; k < array.length; k++) {
        array[k] = val;
      }
    }

    

    public void add(final int index, final int value)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (index == _limit)
        {
            add(value);
        }
        else
        {

            
            if (_limit == _array.length)
            {
                growArray(_limit * 2);
            }
            System.arraycopy(_array, index, _array, index + 1,
                             _limit - index);
            _array[ index ] = value;
            _limit++;
        }
    }

    

    public boolean add(final int value)
    {
        if (_limit == _array.length)
        {
            growArray(_limit * 2);
        }
        _array[ _limit++ ] = value;
        return true;
    }

    

    public boolean addAll(final IntList c)
    {
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }
            System.arraycopy(c._array, 0, _array, _limit, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public boolean addAll(final int index, final IntList c)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }

            
            System.arraycopy(_array, index, _array, index + c._limit,
                             _limit - index);

            
            System.arraycopy(c._array, 0, _array, index, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public void clear()
    {
        _limit = 0;
    }

    

    public boolean contains(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (_array[ j ] == o)
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean containsAll(final IntList c)
    {
        boolean rval = true;

        if (this != c)
        {
            for (int j = 0; rval && (j < c._limit); j++)
            {
                if (!contains(c._array[ j ]))
                {
                    rval = false;
                }
            }
        }
        return rval;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = this == o;

        if (!rval && (o != null) && (o.getClass() == this.getClass()))
        {
            IntList other = ( IntList ) o;

            if (other._limit == _limit)
            {

                
                rval = true;
                for (int j = 0; rval && (j < _limit); j++)
                {
                    rval = _array[ j ] == other._array[ j ];
                }
            }
        }
        return rval;
    }

    

    public int get(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException(
                  index + "" not accessible in a list of length "" + _limit
            );
        }
        return _array[ index ];
    }

    

    public int hashCode()
    {
        int hash = 0;

        for (int j = 0; j < _limit; j++)
        {
            hash = (31 * hash) + _array[ j ];
        }
        return hash;
    }

    

    public int indexOf(final int o)
    {
        int rval = 0;

        for (; rval < _limit; rval++)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        if (rval == _limit)
        {
            rval = -1;   
        }
        return rval;
    }

    

    public boolean isEmpty()
    {
        return _limit == 0;
    }

    

    public int lastIndexOf(final int o)
    {
        int rval = _limit - 1;

        for (; rval >= 0; rval--)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        return rval;
    }

    

    public int remove(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        System.arraycopy(_array, index + 1, _array, index, _limit - index);
        _limit--;
        return rval;
    }

    

    public boolean removeValue(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (o == _array[ j ])
            {
                if (j+1 < _limit) {
                    System.arraycopy(_array, j + 1, _array, j, _limit - j);
                }
                _limit--;
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean removeAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < c._limit; j++)
        {
            if (removeValue(c._array[ j ]))
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean retainAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < _limit; )
        {
            if (!c.contains(_array[ j ]))
            {
                remove(j);
                rval = true;
            }
            else
            {
                j++;
            }
        }
        return rval;
    }

    

    public int set(final int index, final int element)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        _array[ index ] = element;
        return rval;
    }

    

    public int size()
    {
        return _limit;
    }

    

    public int [] toArray()
    {
        int[] rval = new int[ _limit ];

        System.arraycopy(_array, 0, rval, 0, _limit);
        return rval;
    }

    

    public int [] toArray(final int [] a)
    {
        int[] rval;

        if (a.length == _limit)
        {
            System.arraycopy(_array, 0, a, 0, _limit);
            rval = a;
        }
        else
        {
            rval = toArray();
        }
        return rval;
    }

    private void growArray(final int new_size)
    {
        int   size      = (new_size == _array.length) ? new_size + 1
                                                      : new_size;
        int[] new_array = new int[ size ];

        if (fillval != 0) {
          fillArray(fillval, new_array, _array.length);
        }

        System.arraycopy(_array, 0, new_array, 0, _limit);
        _array = new_array;
    }
}   

"
poi,3,org.apache.poi.hssf.record.EscherAggregate,20,3,0,36,129,124,3,34,10,1.045397855,1234,0.023696682,2,0.558139535,0.161538462,2,7,50.15,11,2.55,4,"

package org.apache.poi.hssf.record;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.poi.ddf.DefaultEscherRecordFactory;
import org.apache.poi.ddf.EscherClientDataRecord;
import org.apache.poi.ddf.EscherContainerRecord;
import org.apache.poi.ddf.EscherDgRecord;
import org.apache.poi.ddf.EscherRecord;
import org.apache.poi.ddf.EscherRecordFactory;
import org.apache.poi.ddf.EscherSerializationListener;
import org.apache.poi.ddf.EscherSpRecord;
import org.apache.poi.ddf.EscherSpgrRecord;
import org.apache.poi.ddf.EscherTextboxRecord;
import org.apache.poi.util.POILogFactory;
import org.apache.poi.util.POILogger;



public final class EscherAggregate extends AbstractEscherHolderRecord {
    public static final short sid = 9876; 
    private static POILogger log = POILogFactory.getLogger(EscherAggregate.class);

    public static final short ST_MIN = (short) 0;
    public static final short ST_NOT_PRIMATIVE = ST_MIN;
    public static final short ST_RECTANGLE = (short) 1;
    public static final short ST_ROUNDRECTANGLE = (short) 2;
    public static final short ST_ELLIPSE = (short) 3;
    public static final short ST_DIAMOND = (short) 4;
    public static final short ST_ISOCELESTRIANGLE = (short) 5;
    public static final short ST_RIGHTTRIANGLE = (short) 6;
    public static final short ST_PARALLELOGRAM = (short) 7;
    public static final short ST_TRAPEZOID = (short) 8;
    public static final short ST_HEXAGON = (short) 9;
    public static final short ST_OCTAGON = (short) 10;
    public static final short ST_PLUS = (short) 11;
    public static final short ST_STAR = (short) 12;
    public static final short ST_ARROW = (short) 13;
    public static final short ST_THICKARROW = (short) 14;
    public static final short ST_HOMEPLATE = (short) 15;
    public static final short ST_CUBE = (short) 16;
    public static final short ST_BALLOON = (short) 17;
    public static final short ST_SEAL = (short) 18;
    public static final short ST_ARC = (short) 19;
    public static final short ST_LINE = (short) 20;
    public static final short ST_PLAQUE = (short) 21;
    public static final short ST_CAN = (short) 22;
    public static final short ST_DONUT = (short) 23;
    public static final short ST_TEXTSIMPLE = (short) 24;
    public static final short ST_TEXTOCTAGON = (short) 25;
    public static final short ST_TEXTHEXAGON = (short) 26;
    public static final short ST_TEXTCURVE = (short) 27;
    public static final short ST_TEXTWAVE = (short) 28;
    public static final short ST_TEXTRING = (short) 29;
    public static final short ST_TEXTONCURVE = (short) 30;
    public static final short ST_TEXTONRING = (short) 31;
    public static final short ST_STRAIGHTCONNECTOR1 = (short) 32;
    public static final short ST_BENTCONNECTOR2 = (short) 33;
    public static final short ST_BENTCONNECTOR3 = (short) 34;
    public static final short ST_BENTCONNECTOR4 = (short) 35;
    public static final short ST_BENTCONNECTOR5 = (short) 36;
    public static final short ST_CURVEDCONNECTOR2 = (short) 37;
    public static final short ST_CURVEDCONNECTOR3 = (short) 38;
    public static final short ST_CURVEDCONNECTOR4 = (short) 39;
    public static final short ST_CURVEDCONNECTOR5 = (short) 40;
    public static final short ST_CALLOUT1 = (short) 41;
    public static final short ST_CALLOUT2 = (short) 42;
    public static final short ST_CALLOUT3 = (short) 43;
    public static final short ST_ACCENTCALLOUT1 = (short) 44;
    public static final short ST_ACCENTCALLOUT2 = (short) 45;
    public static final short ST_ACCENTCALLOUT3 = (short) 46;
    public static final short ST_BORDERCALLOUT1 = (short) 47;
    public static final short ST_BORDERCALLOUT2 = (short) 48;
    public static final short ST_BORDERCALLOUT3 = (short) 49;
    public static final short ST_ACCENTBORDERCALLOUT1 = (short) 50;
    public static final short ST_ACCENTBORDERCALLOUT2 = (short) 51;
    public static final short ST_ACCENTBORDERCALLOUT3 = (short) 52;
    public static final short ST_RIBBON = (short) 53;
    public static final short ST_RIBBON2 = (short) 54;
    public static final short ST_CHEVRON = (short) 55;
    public static final short ST_PENTAGON = (short) 56;
    public static final short ST_NOSMOKING = (short) 57;
    public static final short ST_SEAL8 = (short) 58;
    public static final short ST_SEAL16 = (short) 59;
    public static final short ST_SEAL32 = (short) 60;
    public static final short ST_WEDGERECTCALLOUT = (short) 61;
    public static final short ST_WEDGERRECTCALLOUT = (short) 62;
    public static final short ST_WEDGEELLIPSECALLOUT = (short) 63;
    public static final short ST_WAVE = (short) 64;
    public static final short ST_FOLDEDCORNER = (short) 65;
    public static final short ST_LEFTARROW = (short) 66;
    public static final short ST_DOWNARROW = (short) 67;
    public static final short ST_UPARROW = (short) 68;
    public static final short ST_LEFTRIGHTARROW = (short) 69;
    public static final short ST_UPDOWNARROW = (short) 70;
    public static final short ST_IRREGULARSEAL1 = (short) 71;
    public static final short ST_IRREGULARSEAL2 = (short) 72;
    public static final short ST_LIGHTNINGBOLT = (short) 73;
    public static final short ST_HEART = (short) 74;
    public static final short ST_PICTUREFRAME = (short) 75;
    public static final short ST_QUADARROW = (short) 76;
    public static final short ST_LEFTARROWCALLOUT = (short) 77;
    public static final short ST_RIGHTARROWCALLOUT = (short) 78;
    public static final short ST_UPARROWCALLOUT = (short) 79;
    public static final short ST_DOWNARROWCALLOUT = (short) 80;
    public static final short ST_LEFTRIGHTARROWCALLOUT = (short) 81;
    public static final short ST_UPDOWNARROWCALLOUT = (short) 82;
    public static final short ST_QUADARROWCALLOUT = (short) 83;
    public static final short ST_BEVEL = (short) 84;
    public static final short ST_LEFTBRACKET = (short) 85;
    public static final short ST_RIGHTBRACKET = (short) 86;
    public static final short ST_LEFTBRACE = (short) 87;
    public static final short ST_RIGHTBRACE = (short) 88;
    public static final short ST_LEFTUPARROW = (short) 89;
    public static final short ST_BENTUPARROW = (short) 90;
    public static final short ST_BENTARROW = (short) 91;
    public static final short ST_SEAL24 = (short) 92;
    public static final short ST_STRIPEDRIGHTARROW = (short) 93;
    public static final short ST_NOTCHEDRIGHTARROW = (short) 94;
    public static final short ST_BLOCKARC = (short) 95;
    public static final short ST_SMILEYFACE = (short) 96;
    public static final short ST_VERTICALSCROLL = (short) 97;
    public static final short ST_HORIZONTALSCROLL = (short) 98;
    public static final short ST_CIRCULARARROW = (short) 99;
    public static final short ST_NOTCHEDCIRCULARARROW = (short) 100;
    public static final short ST_UTURNARROW = (short) 101;
    public static final short ST_CURVEDRIGHTARROW = (short) 102;
    public static final short ST_CURVEDLEFTARROW = (short) 103;
    public static final short ST_CURVEDUPARROW = (short) 104;
    public static final short ST_CURVEDDOWNARROW = (short) 105;
    public static final short ST_CLOUDCALLOUT = (short) 106;
    public static final short ST_ELLIPSERIBBON = (short) 107;
    public static final short ST_ELLIPSERIBBON2 = (short) 108;
    public static final short ST_FLOWCHARTPROCESS = (short) 109;
    public static final short ST_FLOWCHARTDECISION = (short) 110;
    public static final short ST_FLOWCHARTINPUTOUTPUT = (short) 111;
    public static final short ST_FLOWCHARTPREDEFINEDPROCESS = (short) 112;
    public static final short ST_FLOWCHARTINTERNALSTORAGE = (short) 113;
    public static final short ST_FLOWCHARTDOCUMENT = (short) 114;
    public static final short ST_FLOWCHARTMULTIDOCUMENT = (short) 115;
    public static final short ST_FLOWCHARTTERMINATOR = (short) 116;
    public static final short ST_FLOWCHARTPREPARATION = (short) 117;
    public static final short ST_FLOWCHARTMANUALINPUT = (short) 118;
    public static final short ST_FLOWCHARTMANUALOPERATION = (short) 119;
    public static final short ST_FLOWCHARTCONNECTOR = (short) 120;
    public static final short ST_FLOWCHARTPUNCHEDCARD = (short) 121;
    public static final short ST_FLOWCHARTPUNCHEDTAPE = (short) 122;
    public static final short ST_FLOWCHARTSUMMINGJUNCTION = (short) 123;
    public static final short ST_FLOWCHARTOR = (short) 124;
    public static final short ST_FLOWCHARTCOLLATE = (short) 125;
    public static final short ST_FLOWCHARTSORT = (short) 126;
    public static final short ST_FLOWCHARTEXTRACT = (short) 127;
    public static final short ST_FLOWCHARTMERGE = (short) 128;
    public static final short ST_FLOWCHARTOFFLINESTORAGE = (short) 129;
    public static final short ST_FLOWCHARTONLINESTORAGE = (short) 130;
    public static final short ST_FLOWCHARTMAGNETICTAPE = (short) 131;
    public static final short ST_FLOWCHARTMAGNETICDISK = (short) 132;
    public static final short ST_FLOWCHARTMAGNETICDRUM = (short) 133;
    public static final short ST_FLOWCHARTDISPLAY = (short) 134;
    public static final short ST_FLOWCHARTDELAY = (short) 135;
    public static final short ST_TEXTPLAINTEXT = (short) 136;
    public static final short ST_TEXTSTOP = (short) 137;
    public static final short ST_TEXTTRIANGLE = (short) 138;
    public static final short ST_TEXTTRIANGLEINVERTED = (short) 139;
    public static final short ST_TEXTCHEVRON = (short) 140;
    public static final short ST_TEXTCHEVRONINVERTED = (short) 141;
    public static final short ST_TEXTRINGINSIDE = (short) 142;
    public static final short ST_TEXTRINGOUTSIDE = (short) 143;
    public static final short ST_TEXTARCHUPCURVE = (short) 144;
    public static final short ST_TEXTARCHDOWNCURVE = (short) 145;
    public static final short ST_TEXTCIRCLECURVE = (short) 146;
    public static final short ST_TEXTBUTTONCURVE = (short) 147;
    public static final short ST_TEXTARCHUPPOUR = (short) 148;
    public static final short ST_TEXTARCHDOWNPOUR = (short) 149;
    public static final short ST_TEXTCIRCLEPOUR = (short) 150;
    public static final short ST_TEXTBUTTONPOUR = (short) 151;
    public static final short ST_TEXTCURVEUP = (short) 152;
    public static final short ST_TEXTCURVEDOWN = (short) 153;
    public static final short ST_TEXTCASCADEUP = (short) 154;
    public static final short ST_TEXTCASCADEDOWN = (short) 155;
    public static final short ST_TEXTWAVE1 = (short) 156;
    public static final short ST_TEXTWAVE2 = (short) 157;
    public static final short ST_TEXTWAVE3 = (short) 158;
    public static final short ST_TEXTWAVE4 = (short) 159;
    public static final short ST_TEXTINFLATE = (short) 160;
    public static final short ST_TEXTDEFLATE = (short) 161;
    public static final short ST_TEXTINFLATEBOTTOM = (short) 162;
    public static final short ST_TEXTDEFLATEBOTTOM = (short) 163;
    public static final short ST_TEXTINFLATETOP = (short) 164;
    public static final short ST_TEXTDEFLATETOP = (short) 165;
    public static final short ST_TEXTDEFLATEINFLATE = (short) 166;
    public static final short ST_TEXTDEFLATEINFLATEDEFLATE = (short) 167;
    public static final short ST_TEXTFADERIGHT = (short) 168;
    public static final short ST_TEXTFADELEFT = (short) 169;
    public static final short ST_TEXTFADEUP = (short) 170;
    public static final short ST_TEXTFADEDOWN = (short) 171;
    public static final short ST_TEXTSLANTUP = (short) 172;
    public static final short ST_TEXTSLANTDOWN = (short) 173;
    public static final short ST_TEXTCANUP = (short) 174;
    public static final short ST_TEXTCANDOWN = (short) 175;
    public static final short ST_FLOWCHARTALTERNATEPROCESS = (short) 176;
    public static final short ST_FLOWCHARTOFFPAGECONNECTOR = (short) 177;
    public static final short ST_CALLOUT90 = (short) 178;
    public static final short ST_ACCENTCALLOUT90 = (short) 179;
    public static final short ST_BORDERCALLOUT90 = (short) 180;
    public static final short ST_ACCENTBORDERCALLOUT90 = (short) 181;
    public static final short ST_LEFTRIGHTUPARROW = (short) 182;
    public static final short ST_SUN = (short) 183;
    public static final short ST_MOON = (short) 184;
    public static final short ST_BRACKETPAIR = (short) 185;
    public static final short ST_BRACEPAIR = (short) 186;
    public static final short ST_SEAL4 = (short) 187;
    public static final short ST_DOUBLEWAVE = (short) 188;
    public static final short ST_ACTIONBUTTONBLANK = (short) 189;
    public static final short ST_ACTIONBUTTONHOME = (short) 190;
    public static final short ST_ACTIONBUTTONHELP = (short) 191;
    public static final short ST_ACTIONBUTTONINFORMATION = (short) 192;
    public static final short ST_ACTIONBUTTONFORWARDNEXT = (short) 193;
    public static final short ST_ACTIONBUTTONBACKPREVIOUS = (short) 194;
    public static final short ST_ACTIONBUTTONEND = (short) 195;
    public static final short ST_ACTIONBUTTONBEGINNING = (short) 196;
    public static final short ST_ACTIONBUTTONRETURN = (short) 197;
    public static final short ST_ACTIONBUTTONDOCUMENT = (short) 198;
    public static final short ST_ACTIONBUTTONSOUND = (short) 199;
    public static final short ST_ACTIONBUTTONMOVIE = (short) 200;
    public static final short ST_HOSTCONTROL = (short) 201;
    public static final short ST_TEXTBOX = (short) 202;
    public static final short ST_NIL = (short) 0x0FFF;

    
    private final Map<EscherRecord, Record> shapeToObj = new HashMap<EscherRecord, Record>();

    
    private Map<Integer, NoteRecord> tailRec = new LinkedHashMap<Integer, NoteRecord>();

    
    public EscherAggregate(boolean createDefaultTree) {
        if (createDefaultTree){
            buildBaseTree();
        }
    }

    
    public short getSid() {
        return sid;
    }

    
    public String toString() {
        String nl = System.getProperty(""line.separtor"");

        StringBuilder result = new StringBuilder();
        result.append('[').append(getRecordName()).append(']').append(nl);
        for (EscherRecord escherRecord : getEscherRecords()) {
            result.append(escherRecord.toString());
        }
        result.append(""[/"").append(getRecordName()).append(']').append(nl);

        return result.toString();
    }

    
    public String toXml(String tab) {
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(""<"").append(getRecordName()).append("">
"");
        for (EscherRecord escherRecord : getEscherRecords()) {
            builder.append(escherRecord.toXml(tab + ""	""));
        }
        builder.append(tab).append(""</"").append(getRecordName()).append("">
"");
        return builder.toString();
    }

    
    private static boolean isDrawingLayerRecord(final short sid) {
        return sid == DrawingRecord.sid ||
                sid == ContinueRecord.sid ||
                sid == ObjRecord.sid ||
                sid == TextObjectRecord.sid;
    }

    
    public static EscherAggregate createAggregate(List<RecordBase> records, int locFirstDrawingRecord) {
        
        
        final List<EscherRecord> shapeRecords = new ArrayList<EscherRecord>();
        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory() {
            public EscherRecord createRecord(byte[] data, int offset) {
                EscherRecord r = super.createRecord(data, offset);
                if (r.getRecordId() == EscherClientDataRecord.RECORD_ID || r.getRecordId() == EscherTextboxRecord.RECORD_ID) {
                    shapeRecords.add(r);
                }
                return r;
            }
        };

        
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        EscherAggregate agg = new EscherAggregate(false);
        int loc = locFirstDrawingRecord;
        while (loc + 1 < records.size()
                && (isDrawingLayerRecord(sid(records, loc)))) {
            try {
                if (!(sid(records, loc) == DrawingRecord.sid || sid(records, loc) == ContinueRecord.sid)) {
                    loc++;
                    continue;
                }
                if (sid(records, loc) == DrawingRecord.sid) {
                    buffer.write(((DrawingRecord) records.get(loc)).getRecordData());
                } else {
                    buffer.write(((ContinueRecord) records.get(loc)).getData());
                }
            } catch (IOException e) {
                throw new RuntimeException(""Couldn't get data from drawing/continue records"", e);
            }
            loc++;
        }

        
        
        int pos = 0;
        while (pos < buffer.size()) {
            EscherRecord r = recordFactory.createRecord(buffer.toByteArray(), pos);
            int bytesRead = r.fillFields(buffer.toByteArray(), pos, recordFactory);
            agg.addEscherRecord(r);
            pos += bytesRead;
        }

        
        loc = locFirstDrawingRecord + 1;
        int shapeIndex = 0;
        while (loc < records.size()
                && (isDrawingLayerRecord(sid(records, loc)))) {
            if (!isObjectRecord(records, loc)) {
                loc++;
                continue;
            }
            Record objRecord = (Record) records.get(loc);
            agg.shapeToObj.put(shapeRecords.get(shapeIndex++), objRecord);
            loc++;
        }

        
        while (loc < records.size()) {
            if (sid(records, loc) == NoteRecord.sid) {
                NoteRecord r = (NoteRecord) records.get(loc);
                agg.tailRec.put(r.getShapeId(), r);
            } else {
                break;
            }
            loc++;
        }

        int locLastDrawingRecord = loc;
        
        records.subList(locFirstDrawingRecord, locLastDrawingRecord).clear();
        records.add(locFirstDrawingRecord, agg);
        return agg;
    }

    
    public int serialize(int offset, byte[] data) {
        
        List <EscherRecord>records = getEscherRecords();
        int size = getEscherRecordSize(records);
        byte[] buffer = new byte[size];

        
        final List <Integer>spEndingOffsets = new ArrayList<Integer>();
        final List <EscherRecord> shapes = new ArrayList<EscherRecord>();
        int pos = 0;
        for (Object record : records) {
            EscherRecord e = (EscherRecord) record;
            pos += e.serialize(pos, buffer, new EscherSerializationListener() {
                public void beforeRecordSerialize(int offset, short recordId, EscherRecord record) {
                }

                public void afterRecordSerialize(int offset, short recordId, int size, EscherRecord record) {
                    if (recordId == EscherClientDataRecord.RECORD_ID || recordId == EscherTextboxRecord.RECORD_ID) {
                        spEndingOffsets.add(offset);
                        shapes.add(record);
                    }
                }
            });
        }
        shapes.add(0, null);
        spEndingOffsets.add(0, 0);

        
        
        pos = offset;
        int writtenEscherBytes = 0;
        int i;
        for (i = 1; i < shapes.size(); i++) {
            int endOffset = spEndingOffsets.get(i) - 1;
            int startOffset;
            if (i == 1)
                startOffset = 0;
            else
                startOffset = spEndingOffsets.get(i - 1);

            byte[] drawingData = new byte[endOffset - startOffset + 1];
            System.arraycopy(buffer, startOffset, drawingData, 0, drawingData.length);
            pos += writeDataIntoDrawingRecord(drawingData, writtenEscherBytes, pos, data, i);

            writtenEscherBytes += drawingData.length;

            
            Record obj = shapeToObj.get(shapes.get(i));
            pos += obj.serialize(pos, data);

            if (i == shapes.size() - 1 && endOffset < buffer.length - 1) {
                drawingData = new byte[buffer.length - endOffset - 1];
                System.arraycopy(buffer, endOffset + 1, drawingData, 0, drawingData.length);
                pos += writeDataIntoDrawingRecord(drawingData, writtenEscherBytes, pos, data, i);
            }
        }
        if ((pos - offset) < buffer.length - 1) {
            byte[] drawingData = new byte[buffer.length - (pos - offset)];
            System.arraycopy(buffer, (pos - offset), drawingData, 0, drawingData.length);
            pos += writeDataIntoDrawingRecord(drawingData, writtenEscherBytes, pos, data, i);
        }

        for (i = 0; i < tailRec.size(); i++) {
            Record rec = (Record) tailRec.values().toArray()[i];
            pos += rec.serialize(pos, data);
        }
        int bytesWritten = pos - offset;
        if (bytesWritten != getRecordSize())
            throw new RecordFormatException(bytesWritten + "" bytes written but getRecordSize() reports "" + getRecordSize());
        return bytesWritten;
    }

    
    private int writeDataIntoDrawingRecord(byte[] drawingData, int writtenEscherBytes, int pos, byte[] data, int i) {
        int temp = 0;
        
        if (writtenEscherBytes + drawingData.length > RecordInputStream.MAX_RECORD_DATA_SIZE && i != 1) {
            for (int j = 0; j < drawingData.length; j += RecordInputStream.MAX_RECORD_DATA_SIZE) {
                byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];
                System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));
                ContinueRecord drawing = new ContinueRecord(buf);
                temp += drawing.serialize(pos + temp, data);
            }
        } else {
            for (int j = 0; j < drawingData.length; j += RecordInputStream.MAX_RECORD_DATA_SIZE) {
                if (j == 0) {
                    DrawingRecord drawing = new DrawingRecord();
                    byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];
                    System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));
                    drawing.setData(buf);
                    temp += drawing.serialize(pos + temp, data);
                } else {
                    byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];
                    System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));
                    ContinueRecord drawing = new ContinueRecord(buf);
                    temp += drawing.serialize(pos + temp, data);
                }
            }
        }
        return temp;
    }

    
    private int getEscherRecordSize(List<EscherRecord> records) {
        int size = 0;
        for (EscherRecord record : records){
            size += record.getRecordSize();
        }
        return size;
    }

    
    public int getRecordSize() {
        
        
        int continueRecordsHeadersSize = 0;
        
        List<EscherRecord> records = getEscherRecords();
        int rawEscherSize = getEscherRecordSize(records);
        byte[] buffer = new byte[rawEscherSize];
        final List<Integer> spEndingOffsets = new ArrayList<Integer>();
        int pos = 0;
        for (EscherRecord e : records) {
            pos += e.serialize(pos, buffer, new EscherSerializationListener() {
                public void beforeRecordSerialize(int offset, short recordId, EscherRecord record) {
                }

                public void afterRecordSerialize(int offset, short recordId, int size, EscherRecord record) {
                    if (recordId == EscherClientDataRecord.RECORD_ID || recordId == EscherTextboxRecord.RECORD_ID) {
                        spEndingOffsets.add(offset);
                    }
                }
            });
        }
        spEndingOffsets.add(0, 0);

        for (int i = 1; i < spEndingOffsets.size(); i++) {
            if (i == spEndingOffsets.size() - 1 && spEndingOffsets.get(i) < pos) {
                continueRecordsHeadersSize += 4;
            }
            if (spEndingOffsets.get(i) - spEndingOffsets.get(i - 1) <= RecordInputStream.MAX_RECORD_DATA_SIZE) {
                continue;
            }
            continueRecordsHeadersSize += ((spEndingOffsets.get(i) - spEndingOffsets.get(i - 1)) / RecordInputStream.MAX_RECORD_DATA_SIZE) * 4;
        }

        int drawingRecordSize = rawEscherSize + (shapeToObj.size()) * 4;
        if (rawEscherSize != 0 && spEndingOffsets.size() == 1) {
            continueRecordsHeadersSize += 4;
        }
        int objRecordSize = 0;
        for (Record r : shapeToObj.values()) {
            objRecordSize += r.getRecordSize();
        }
        int tailRecordSize = 0;
        for (NoteRecord noteRecord : tailRec.values()) {
            tailRecordSize += noteRecord.getRecordSize();
        }
        return drawingRecordSize + objRecordSize + tailRecordSize + continueRecordsHeadersSize;
    }

    
    public void associateShapeToObjRecord(EscherRecord r, Record objRecord) {
        shapeToObj.put(r, objRecord);
    }

    
    public void removeShapeToObjRecord(EscherRecord rec) {
        shapeToObj.remove(rec);
    }

    
    protected String getRecordName() {
        return ""ESCHERAGGREGATE"";
    }

    

    
    private static boolean isObjectRecord(List <RecordBase>records, int loc) {
        return sid(records, loc) == ObjRecord.sid || sid(records, loc) == TextObjectRecord.sid;
    }

    
    private void buildBaseTree() {
        EscherContainerRecord dgContainer = new EscherContainerRecord();
        EscherContainerRecord spgrContainer = new EscherContainerRecord();
        EscherContainerRecord spContainer1 = new EscherContainerRecord();
        EscherSpgrRecord spgr = new EscherSpgrRecord();
        EscherSpRecord sp1 = new EscherSpRecord();
        dgContainer.setRecordId(EscherContainerRecord.DG_CONTAINER);
        dgContainer.setOptions((short) 0x000F);
        EscherDgRecord dg = new EscherDgRecord();
        dg.setRecordId(EscherDgRecord.RECORD_ID);
        short dgId = 1;
        dg.setOptions((short) (dgId << 4));
        dg.setNumShapes(0);
        dg.setLastMSOSPID(1024);
        spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);
        spgrContainer.setOptions((short) 0x000F);
        spContainer1.setRecordId(EscherContainerRecord.SP_CONTAINER);
        spContainer1.setOptions((short) 0x000F);
        spgr.setRecordId(EscherSpgrRecord.RECORD_ID);
        spgr.setOptions((short) 0x0001);    
        spgr.setRectX1(0);
        spgr.setRectY1(0);
        spgr.setRectX2(1023);
        spgr.setRectY2(255);
        sp1.setRecordId(EscherSpRecord.RECORD_ID);

        sp1.setOptions((short) 0x0002);
        sp1.setVersion((short) 0x2);
        sp1.setShapeId(-1);
        sp1.setFlags(EscherSpRecord.FLAG_GROUP | EscherSpRecord.FLAG_PATRIARCH);
        dgContainer.addChildRecord(dg);
        dgContainer.addChildRecord(spgrContainer);
        spgrContainer.addChildRecord(spContainer1);
        spContainer1.addChildRecord(spgr);
        spContainer1.addChildRecord(sp1);
        addEscherRecord(dgContainer);
    }

    
    public void setDgId(short dgId) {
        EscherContainerRecord dgContainer = getEscherContainer();
        EscherDgRecord dg = dgContainer.getChildById(EscherDgRecord.RECORD_ID);
        dg.setOptions((short) (dgId << 4));
    }

    
    public void setMainSpRecordId(int shapeId) {
        EscherContainerRecord dgContainer = getEscherContainer();
        EscherContainerRecord spgrConatiner = (EscherContainerRecord) dgContainer.getChildById(EscherContainerRecord.SPGR_CONTAINER);
        EscherContainerRecord spContainer = (EscherContainerRecord) spgrConatiner.getChild(0);
        EscherSpRecord sp = (EscherSpRecord) spContainer.getChildById(EscherSpRecord.RECORD_ID);
        sp.setShapeId(shapeId);
    }

    
    private static short sid(List<RecordBase> records, int loc) {
        RecordBase record = records.get(loc);
        if (record instanceof Record) {
            return ((Record)record).getSid();
        } else {
            
            
            return -1;
        }
    }

    
    public Map<EscherRecord, Record> getShapeToObjMapping() {
        return Collections.unmodifiableMap(shapeToObj);
    }

    
    public Map<Integer, NoteRecord> getTailRecords() {
        return Collections.unmodifiableMap(tailRec);
    }

    
    public NoteRecord getNoteRecordByObj(ObjRecord obj) {
        CommonObjectDataSubRecord cod = (CommonObjectDataSubRecord) obj.getSubRecords().get(0);
        return tailRec.get(cod.getObjectId());
    }

    
    public void addTailRecord(NoteRecord note) {
        tailRec.put(note.getShapeId(), note);
    }

    
    public void removeTailRecord(NoteRecord note) {
        tailRec.remove(note.getShapeId());
    }
}
"
poi,3,org.apache.poi.ddf.EscherBlipRecord,6,2,2,10,25,3,5,5,6,1.04,154,0.4,0,0.791666667,0.4,1,5,23.83333333,1,0.8333,3,"

package org.apache.poi.ddf;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.HexDump;


public class EscherBlipRecord extends EscherRecord { 
    public static final short  RECORD_ID_START    = (short) 0xF018;
    public static final short  RECORD_ID_END      = (short) 0xF117;
    public static final String RECORD_DESCRIPTION = ""msofbtBlip"";

    private static final int   HEADER_SIZE               = 8;

    protected              byte[] field_pictureData;

    public EscherBlipRecord() {
    }

    public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory) {
        int bytesAfterHeader = readHeader( data, offset );
        int pos              = offset + HEADER_SIZE;

        field_pictureData = new byte[bytesAfterHeader];
        System.arraycopy(data, pos, field_pictureData, 0, bytesAfterHeader);

        return bytesAfterHeader + 8;
    }

    public int serialize(int offset, byte[] data, EscherSerializationListener listener) {
        listener.beforeRecordSerialize(offset, getRecordId(), this);

        LittleEndian.putShort( data, offset, getOptions() );
        LittleEndian.putShort( data, offset + 2, getRecordId() );

        System.arraycopy( field_pictureData, 0, data, offset + 4, field_pictureData.length );

        listener.afterRecordSerialize(offset + 4 + field_pictureData.length, getRecordId(), field_pictureData.length + 4, this);
        return field_pictureData.length + 4;
    }

    public int getRecordSize() {
        return field_pictureData.length + HEADER_SIZE;
    }

    public String getRecordName() {
        return ""Blip"";
    }

    public byte[] getPicturedata() {
        return field_pictureData;
    }

    public void setPictureData(byte[] pictureData) {
        field_pictureData = pictureData;
    }

    public String toString() {
        String extraData = HexDump.toHex(field_pictureData, 32);
        return getClass().getName() + "":"" + '
' +
                ""  RecordId: 0x"" + HexDump.toHex( getRecordId() ) + '
' +
                ""  Version: 0x"" + HexDump.toHex( getVersion() ) + '
' +
                ""  Instance: 0x"" + HexDump.toHex( getInstance() ) + '
' +
                ""  Extra Data:"" + '
' + extraData;
    }

    @Override
    public String toXml(String tab) {
        String extraData = HexDump.toHex(field_pictureData, 32);
        StringBuilder builder = new StringBuilder();
        builder.append(tab).append(formatXmlRecordHeader(getClass().getSimpleName(), HexDump.toHex(getRecordId()), HexDump.toHex(getVersion()), HexDump.toHex(getInstance())))
                .append(tab).append(""	"").append(""<ExtraData>"").append(extraData).append(""</ExtraData>
"");
        builder.append(tab).append(""</"").append(getClass().getSimpleName()).append("">
"");
        return builder.toString();
    }
}
"
poi,3,org.apache.poi.hssf.record.HideObjRecord,10,2,0,6,19,39,2,4,8,1.0,94,0.2,0,0.578947368,0.32,1,4,7.9,2,0.9,1,"

        

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class HideObjRecord
    extends StandardRecord
{
    public final static short sid               = 0x8d;
    public final static short HIDE_ALL          = 2;
    public final static short SHOW_PLACEHOLDERS = 1;
    public final static short SHOW_ALL          = 0;
    private short             field_1_hide_obj;

    public HideObjRecord()
    {
    }

    public HideObjRecord(RecordInputStream in)
    {
        field_1_hide_obj = in.readShort();
    }

    

    public void setHideObj(short hide)
    {
        field_1_hide_obj = hide;
    }

    

    public short getHideObj()
    {
        return field_1_hide_obj;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[HIDEOBJ]
"");
        buffer.append(""    .hideobj         = "")
            .append(Integer.toHexString(getHideObj())).append(""
"");
        buffer.append(""[/HIDEOBJ]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getHideObj());
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid()
    {
        return sid;
    }
}
"
poi,3,org.apache.poi.hssf.record.DefaultRowHeightRecord,13,2,0,6,22,56,2,4,11,0.75,137,0.666666667,0,0.5,0.307692308,1,4,9.307692308,2,0.9231,1,"



package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;



public final class DefaultRowHeightRecord
    extends StandardRecord
{
    public final static short sid = 0x225;
    private short             field_1_option_flags;
    private short             field_2_row_height;

    
    public static final short DEFAULT_ROW_HEIGHT = 0xFF;

    public DefaultRowHeightRecord()
    {
        field_1_option_flags = 0x0000;
        field_2_row_height = DEFAULT_ROW_HEIGHT;
    }

    public DefaultRowHeightRecord(RecordInputStream in)
    {
        field_1_option_flags = in.readShort();
        field_2_row_height   = in.readShort();
    }

    

    public void setOptionFlags(short flags)
    {
        field_1_option_flags = flags;
    }

    

    public void setRowHeight(short height)
    {
        field_2_row_height = height;
    }

    

    public short getOptionFlags()
    {
        return field_1_option_flags;
    }

    

    public short getRowHeight()
    {
        return field_2_row_height;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[DEFAULTROWHEIGHT]
"");
        buffer.append(""    .optionflags    = "")
            .append(Integer.toHexString(getOptionFlags())).append(""
"");
        buffer.append(""    .rowheight      = "")
            .append(Integer.toHexString(getRowHeight())).append(""
"");
        buffer.append(""[/DEFAULTROWHEIGHT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(getOptionFlags());
        out.writeShort(getRowHeight());
    }

    protected int getDataSize() {
        return 4;
    }

    public short getSid()
    {
        return sid;
    }

    public Object clone() {
      DefaultRowHeightRecord rec = new DefaultRowHeightRecord();
      rec.field_1_option_flags = field_1_option_flags;
      rec.field_2_row_height = field_2_row_height;
      return rec;
    }
}
"
poi,3,org.apache.poi.poifs.filesystem.EntryNode,10,1,2,6,14,19,3,4,6,0.611111111,71,1.0,2,0.0,0.325,0,0,5.9,3,1.3,0,"

        

package org.apache.poi.poifs.filesystem;

import org.apache.poi.poifs.property.Property;



public abstract class EntryNode
    implements Entry
{

    
    private Property      _property;

    
    private DirectoryNode _parent;

    

    protected EntryNode(final Property property, final DirectoryNode parent)
    {
        _property = property;
        _parent   = parent;
    }

    

    protected Property getProperty()
    {
        return _property;
    }

    

    protected boolean isRoot()
    {

        
        return (_parent == null);
    }

    

    protected abstract boolean isDeleteOK();

    

    

    public String getName()
    {
        return _property.getName();
    }

    

    public boolean isDirectoryEntry()
    {
        return false;
    }

    

    public boolean isDocumentEntry()
    {
        return false;
    }

    

    public DirectoryEntry getParent()
    {
        return _parent;
    }

    

    public boolean delete()
    {
        boolean rval = false;

        if ((!isRoot()) && isDeleteOK())
        {
            rval = _parent.deleteEntry(this);
        }
        return rval;
    }

    

    public boolean renameTo(final String newName)
    {
        boolean rval = false;

        if (!isRoot())
        {
            rval = _parent.changeName(getName(), newName);
        }
        return rval;
    }

    
}   

"
poi,3,org.apache.poi.util.FixedField,4,1,0,5,4,6,4,1,4,2.0,4,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"

        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public interface FixedField
{

    

    public void readFromBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public void readFromStream(InputStream stream)
        throws IOException, BufferUnderrunException;

    

    public void writeToBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public String toString();
}   

"
poi,3,org.apache.poi.hssf.record.ProtectRecord,11,2,0,8,20,35,4,4,9,0.8,112,0.5,0,0.55,0.257575758,1,4,9.0,2,1.0909,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianOutput;


public final class ProtectRecord extends StandardRecord {
    public final static short sid = 0x0012;

    private static final BitField protectFlag = BitFieldFactory.getInstance(0x0001);

    private int _options;

    private ProtectRecord(int options) {
        _options = options;
    }

    public ProtectRecord(boolean isProtected) {
        this(0);
        setProtect(isProtected);
    }

    public ProtectRecord(RecordInputStream in) {
        this(in.readShort());
    }

    
    public void setProtect(boolean protect) {
        _options = protectFlag.setBoolean(_options, protect);
    }

    
    public boolean getProtect() {
        return protectFlag.isSet(_options);
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[PROTECT]
"");
        buffer.append(""    .options = "").append(HexDump.shortToHex(_options)).append(""
"");
        buffer.append(""[/PROTECT]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        out.writeShort(_options);
    }

    protected int getDataSize() {
        return 2;
    }

    public short getSid() {
        return sid;
    }

    public Object clone() {
        return new ProtectRecord(_options);
    }
}
"
poi,3,org.apache.poi.hssf.record.SubRecord,3,2,4,9,11,3,6,7,3,2.0,46,0.0,0,0.916666667,0.666666667,0,0,14.33333333,6,2.0,2,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.LittleEndianOutputStream;

import java.io.ByteArrayOutputStream;


public abstract class SubRecord {
	protected SubRecord() {
		
	}

    
    public static SubRecord createSubRecord(LittleEndianInput in, int cmoOt) {
		int sid = in.readUShort();
		int secondUShort = in.readUShort(); 

		switch (sid) {
			case CommonObjectDataSubRecord.sid:
				return new CommonObjectDataSubRecord(in, secondUShort);
			case EmbeddedObjectRefSubRecord.sid:
				return new EmbeddedObjectRefSubRecord(in, secondUShort);
			case GroupMarkerSubRecord.sid:
				return new GroupMarkerSubRecord(in, secondUShort);
			case EndSubRecord.sid:
				return new EndSubRecord(in, secondUShort);
			case NoteStructureSubRecord.sid:
				return new NoteStructureSubRecord(in, secondUShort);
			case LbsDataSubRecord.sid:
				return new LbsDataSubRecord(in, secondUShort, cmoOt);
            case FtCblsSubRecord.sid:
                return new FtCblsSubRecord(in, secondUShort);
            case FtPioGrbitSubRecord.sid:
            	return new FtPioGrbitSubRecord(in, secondUShort);
            case FtCfSubRecord.sid:
            	return new FtCfSubRecord(in, secondUShort);
		}
		return new UnknownSubRecord(in, sid, secondUShort);
	}

	
	protected abstract int getDataSize();
	public byte[] serialize() {
		int size = getDataSize() + 4;
		ByteArrayOutputStream baos = new ByteArrayOutputStream(size);
		serialize(new LittleEndianOutputStream(baos));
		if (baos.size() != size) {
			throw new RuntimeException(""write size mismatch"");
		}
		return baos.toByteArray();
	}

	public abstract void serialize(LittleEndianOutput out);
	public abstract Object clone();

    
    public boolean isTerminating(){
        return false;
    }

    private static final class UnknownSubRecord extends SubRecord {

		private final int _sid;
		private final byte[] _data;

		public UnknownSubRecord(LittleEndianInput in, int sid, int size) {
			_sid = sid;
	    	byte[] buf = new byte[size];
	    	in.readFully(buf);
	        _data = buf;
		}
		protected int getDataSize() {
			return _data.length;
		}
		public void serialize(LittleEndianOutput out) {
			out.writeShort(_sid);
			out.writeShort(_data.length);
			out.write(_data);
		}
		public Object clone() {
			return this;
		}
		public String toString() {
			StringBuffer sb = new StringBuffer(64);
			sb.append(getClass().getName()).append("" ["");
			sb.append(""sid="").append(HexDump.shortToHex(_sid));
			sb.append("" size="").append(_data.length);
			sb.append("" : "").append(HexDump.toHex(_data));
			sb.append(""]
"");
			return sb.toString();
		}
	}
}
"
poi,3,org.apache.poi.poifs.storage.BlockListImpl,6,1,2,5,13,0,2,3,4,0.5,107,1.0,2,0.0,0.458333333,0,0,16.5,3,1.1667,3,"

package org.apache.poi.poifs.storage;

import java.io.IOException;


abstract class BlockListImpl implements BlockList {
    private ListManagedBlock[]         _blocks;
    private BlockAllocationTableReader _bat;

    protected BlockListImpl()
    {
        _blocks = new ListManagedBlock[ 0 ];
        _bat    = null;
    }

    
    protected void setBlocks(final ListManagedBlock [] blocks)
    {
        _blocks = blocks;
    }

    
    public void zap(final int index)
    {
        if ((index >= 0) && (index < _blocks.length))
        {
            _blocks[ index ] = null;
        }
    }

    
    protected ListManagedBlock get(final int index) {
        return _blocks[index];
    }

    
    public ListManagedBlock remove(final int index)
        throws IOException
    {
        ListManagedBlock result = null;

        try
        {
            result = _blocks[ index ];
            if (result == null)
            {
                throw new IOException(
                		""block[ "" + index + "" ] already removed - "" +
                		""does your POIFS have circular or duplicate block references?""
                );
            }
            _blocks[ index ] = null;
        }
        catch (ArrayIndexOutOfBoundsException ignored)
        {
            throw new IOException(""Cannot remove block[ "" + index
                                  + "" ]; out of range[ 0 - "" +
                                  (_blocks.length-1) + "" ]"");
        }
        return result;
    }

    
    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException
    {
        if (_bat == null)
        {
            throw new IOException(
                ""Improperly initialized list: no block allocation table provided"");
        }
        return _bat.fetchBlocks(startBlock, headerPropertiesStartBlock, this);
    }

    
    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException
    {
        if (_bat != null)
        {
            throw new IOException(
                ""Attempt to replace existing BlockAllocationTable"");
        }
        _bat = bat;
    }
    
    
    public int blockCount() {
       return _blocks.length;
    }
    
    protected int remainingBlocks() {
       int c = 0;
       for(int i=0; i<_blocks.length; i++) {
          if(_blocks[i] != null) c++;
       }
       return c;
    }
}
"
poi,3,org.apache.poi.hpsf.wellknown.PropertyIDMap,7,3,0,1,18,21,1,0,7,1.149122807,301,0.052631579,2,0.915254237,0.224489796,1,2,36.57142857,2,1.0,0,"

package org.apache.poi.hpsf.wellknown;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class PropertyIDMap extends HashMap<Long,String> {

    

    
    public static final int PID_TITLE = 2;

    
    public static final int PID_SUBJECT = 3;

    
    public static final int PID_AUTHOR = 4;

    
    public static final int PID_KEYWORDS = 5;

    
    public static final int PID_COMMENTS = 6;

    
    public static final int PID_TEMPLATE = 7;

    
    public static final int PID_LASTAUTHOR = 8;

    
    public static final int PID_REVNUMBER = 9;

    
    public static final int PID_EDITTIME = 10;

    
    public static final int PID_LASTPRINTED = 11;

    
    public static final int PID_CREATE_DTM = 12;

    
    public static final int PID_LASTSAVE_DTM = 13;

    
    public static final int PID_PAGECOUNT = 14;

    
    public static final int PID_WORDCOUNT = 15;

    
    public static final int PID_CHARCOUNT = 16;

    
    public static final int PID_THUMBNAIL = 17;

    
    public static final int PID_APPNAME = 18;

    
    public static final int PID_SECURITY = 19;



    

    
    public static final int PID_DICTIONARY = 0;

    
    public static final int PID_CODEPAGE = 1;

    
    public static final int PID_CATEGORY = 2;

    
    public static final int PID_PRESFORMAT = 3;

    
    public static final int PID_BYTECOUNT = 4;

    
    public static final int PID_LINECOUNT = 5;

    
    public static final int PID_PARCOUNT = 6;

    
    public static final int PID_SLIDECOUNT = 7;

    
    public static final int PID_NOTECOUNT = 8;

    
    public static final int PID_HIDDENCOUNT = 9;

    
    public static final int PID_MMCLIPCOUNT = 10;

    
    public static final int PID_SCALE = 11;

    
    public static final int PID_HEADINGPAIR = 12;

    
    public static final int PID_DOCPARTS = 13;

    
    public static final int PID_MANAGER = 14;

    
    public static final int PID_COMPANY = 15;

    
    public static final int PID_LINKSDIRTY = 16;

    
    public static final int PID_MAX = PID_LINKSDIRTY;



    
    private static PropertyIDMap summaryInformationProperties;

    
    private static PropertyIDMap documentSummaryInformationProperties;



    
    public PropertyIDMap(final int initialCapacity, final float loadFactor)
    {
        super(initialCapacity, loadFactor);
    }



    
    public PropertyIDMap(final Map<Long,String> map)
    {
        super(map);
    }



    
    public Object put(final long id, final String idString)
    {
        return put(Long.valueOf(id), idString);
    }



    
    public Object get(final long id)
    {
        return get(Long.valueOf(id));
    }



    
    public static PropertyIDMap getSummaryInformationProperties()
    {
        if (summaryInformationProperties == null)
        {
            PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);
            m.put(PID_TITLE, ""PID_TITLE"");
            m.put(PID_SUBJECT, ""PID_SUBJECT"");
            m.put(PID_AUTHOR, ""PID_AUTHOR"");
            m.put(PID_KEYWORDS, ""PID_KEYWORDS"");
            m.put(PID_COMMENTS, ""PID_COMMENTS"");
            m.put(PID_TEMPLATE, ""PID_TEMPLATE"");
            m.put(PID_LASTAUTHOR, ""PID_LASTAUTHOR"");
            m.put(PID_REVNUMBER, ""PID_REVNUMBER"");
            m.put(PID_EDITTIME, ""PID_EDITTIME"");
            m.put(PID_LASTPRINTED, ""PID_LASTPRINTED"");
            m.put(PID_CREATE_DTM, ""PID_CREATE_DTM"");
            m.put(PID_LASTSAVE_DTM, ""PID_LASTSAVE_DTM"");
            m.put(PID_PAGECOUNT, ""PID_PAGECOUNT"");
            m.put(PID_WORDCOUNT, ""PID_WORDCOUNT"");
            m.put(PID_CHARCOUNT, ""PID_CHARCOUNT"");
            m.put(PID_THUMBNAIL, ""PID_THUMBNAIL"");
            m.put(PID_APPNAME, ""PID_APPNAME"");
            m.put(PID_SECURITY, ""PID_SECURITY"");
            summaryInformationProperties =
                new PropertyIDMap(Collections.unmodifiableMap(m));
        }
        return summaryInformationProperties;
    }



    
    public static PropertyIDMap getDocumentSummaryInformationProperties()
    {
        if (documentSummaryInformationProperties == null)
        {
            PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);
            m.put(PID_DICTIONARY, ""PID_DICTIONARY"");
            m.put(PID_CODEPAGE, ""PID_CODEPAGE"");
            m.put(PID_CATEGORY, ""PID_CATEGORY"");
            m.put(PID_PRESFORMAT, ""PID_PRESFORMAT"");
            m.put(PID_BYTECOUNT, ""PID_BYTECOUNT"");
            m.put(PID_LINECOUNT, ""PID_LINECOUNT"");
            m.put(PID_PARCOUNT, ""PID_PARCOUNT"");
            m.put(PID_SLIDECOUNT, ""PID_SLIDECOUNT"");
            m.put(PID_NOTECOUNT, ""PID_NOTECOUNT"");
            m.put(PID_HIDDENCOUNT, ""PID_HIDDENCOUNT"");
            m.put(PID_MMCLIPCOUNT, ""PID_MMCLIPCOUNT"");
            m.put(PID_SCALE, ""PID_SCALE"");
            m.put(PID_HEADINGPAIR, ""PID_HEADINGPAIR"");
            m.put(PID_DOCPARTS, ""PID_DOCPARTS"");
            m.put(PID_MANAGER, ""PID_MANAGER"");
            m.put(PID_COMPANY, ""PID_COMPANY"");
            m.put(PID_LINKSDIRTY, ""PID_LINKSDIRTY"");
            documentSummaryInformationProperties =
                new PropertyIDMap(Collections.unmodifiableMap(m));
        }
        return documentSummaryInformationProperties;
    }



    
    public static void main(final String[] args)
    {
        PropertyIDMap s1 = getSummaryInformationProperties();
        PropertyIDMap s2 = getDocumentSummaryInformationProperties();
        System.out.println(""s1: "" + s1);
        System.out.println(""s2: "" + s2);
    }
}
"
poi,3,org.apache.poi.hssf.record.TabIdRecord,10,2,0,6,24,33,2,4,8,0.777777778,166,0.0,0,0.578947368,0.266666667,1,4,15.4,2,1.2,1,"

package org.apache.poi.hssf.record;

import org.apache.poi.util.LittleEndianOutput;


public final class TabIdRecord extends StandardRecord {
    public final static short sid = 0x013D;
    private static final short[] EMPTY_SHORT_ARRAY = { };

    public short[] _tabids;

    public TabIdRecord() {
        _tabids = EMPTY_SHORT_ARRAY;
    }

    public TabIdRecord(RecordInputStream in) {
        int nTabs = in.remaining() / 2;
        _tabids = new short[nTabs];
        for (int i = 0; i < _tabids.length; i++) {
            _tabids[i] = in.readShort();
        }
    }

    
    public void setTabIdArray(short[] array) {
        _tabids = array;
    }

    public String toString() {
        StringBuffer buffer = new StringBuffer();

        buffer.append(""[TABID]
"");
        buffer.append(""    .elements        = "").append(_tabids.length).append(""
"");
        for (int i = 0; i < _tabids.length; i++) {
            buffer.append(""    .element_"").append(i).append("" = "").append(_tabids[i]).append(""
"");
        }
        buffer.append(""[/TABID]
"");
        return buffer.toString();
    }

    public void serialize(LittleEndianOutput out) {
        short[] tabids = _tabids;

        for (int i = 0; i < tabids.length; i++) {
            out.writeShort(tabids[i]);
        }
    }

    protected int getDataSize() {
        return _tabids.length * 2;
    }

    public short getSid() {
        return sid;
    }
}
"
poi,3,org.apache.poi.hpsf.VariantTypeException,3,4,2,3,4,0,2,1,3,0.5,21,1.0,0,0.9,0.5,0,0,5.333333333,1,0.6667,0,"

package org.apache.poi.hpsf;


public abstract class VariantTypeException extends HPSFException
{

    private Object value;

    private long variantType;



    
    public VariantTypeException(final long variantType, final Object value,
                                final String msg)
    {
        super(msg);
        this.variantType = variantType;
        this.value = value;
    }



    
    public long getVariantType()
    {
        return variantType;
    }



    
    public Object getValue()
    {
        return value;
    }

}
"
