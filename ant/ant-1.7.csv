name,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
org.apache.tools.ant.taskdefs.rmic.RmicAdapterFactory,3,1,0,10,18,3,1,9,1,1.1,106,0.0,0,0.0,0.444444444,0,0,32.66666667,1,0.6667,0,"

package org.apache.tools.ant.taskdefs.rmic;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.ClasspathUtils;

import java.util.Locale;



public final class RmicAdapterFactory {
    
    public static final String ERROR_UNKNOWN_COMPILER = ""Class not found: "";

    
    public static final String ERROR_NOT_RMIC_ADAPTER = ""Class of unexpected Type: "";

    
    public static final String DEFAULT_COMPILER = ""default"";

    
    private RmicAdapterFactory() {
    }

    
    public static RmicAdapter getRmic(String rmicType, Task task)
        throws BuildException {
        
        String compiler = rmicType.toLowerCase(Locale.ENGLISH);

        
        if (DEFAULT_COMPILER.equals(compiler) || compiler.length() == 0) {
            compiler = KaffeRmic.isAvailable()
                ? KaffeRmic.COMPILER_NAME
                : SunRmic.COMPILER_NAME;
        }
        if (SunRmic.COMPILER_NAME.equals(compiler)) {
            return new SunRmic();
        } else if (KaffeRmic.COMPILER_NAME.equals(compiler)) {
            return new KaffeRmic();
        } else if (WLRmic.COMPILER_NAME.equals(compiler)) {
            return new WLRmic();
        } else if (ForkingSunRmic.COMPILER_NAME.equals(compiler)) {
            return new ForkingSunRmic();
        } else if (XNewRmic.COMPILER_NAME.equals(compiler)) {
            return new XNewRmic();
        }
        
        return resolveClassName(rmicType);
    }

    
    private static RmicAdapter resolveClassName(String className)
            throws BuildException {
        return (RmicAdapter) ClasspathUtils.newInstance(className,
                RmicAdapterFactory.class.getClassLoader(), RmicAdapter.class);
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.FStatP4OutputHandler,5,2,0,4,13,0,1,4,4,0.625,76,1.0,1,0.7,0.5,0,0,13.4,1,0.6,0,"
package org.apache.tools.ant.taskdefs.optional.perforce;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.oro.text.perl.Perl5Util;

import java.util.ArrayList;


class FStatP4OutputHandler extends P4HandlerAdapter {
    private P4Fstat parent;
    private ArrayList existing = new ArrayList();
    private ArrayList nonExisting = new ArrayList();
    private static Perl5Util util = new Perl5Util();

    public FStatP4OutputHandler(P4Fstat parent) {
        this.parent = parent;
    }

    public void process(String line) throws BuildException {
        if (util.match(""/^... clientFile (.+)$/"", line)) {
            String f = util.group(1);
            existing.add(f);
        } else if (util.match(""/^(.+) - no such file/"", line)) {
            String f = util.group(1);
            nonExisting.add(f);
        }
        parent.log(parent.util.substitute(""s/^.*: 
                   Project.MSG_VERBOSE);
    }

    public ArrayList getExisting() {
        return existing;
    }

    public ArrayList getNonExisting() {
        return nonExisting;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.OutErrSummaryJUnitResultFormatter,1,2,0,1,3,0,0,1,1,2.0,7,0.0,0,1.0,1.0,0,0,6.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs.optional.junit;



public class OutErrSummaryJUnitResultFormatter
    extends SummaryJUnitResultFormatter {

    
    public OutErrSummaryJUnitResultFormatter() {
        super();
        setWithOutAndErr(true);
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4HandlerAdapter,8,1,9,13,20,12,9,4,8,0.8,101,0.2,1,0.0,0.40625,0,0,11.0,1,0.875,0,"

package org.apache.tools.ant.taskdefs.optional.perforce;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.PumpStreamHandler;

public abstract class P4HandlerAdapter  implements P4Handler {
    
    String p4input = """";
    private PumpStreamHandler myHandler = null;
    
    
    public void setOutput(String p4Input) {
        this.p4input = p4Input;
    }
    
    public abstract void process(String line);

    
    public void start() throws BuildException {
        if (p4input != null && p4input.length() > 0) {
            myHandler = new PumpStreamHandler(new P4OutputStream(this), new P4OutputStream(this),
                new ByteArrayInputStream(p4input.getBytes()));
        } else {
            myHandler = new PumpStreamHandler(new P4OutputStream(this), new P4OutputStream(this));
        }
        myHandler.setProcessInputStream(os);
        myHandler.setProcessErrorStream(es);
        myHandler.setProcessOutputStream(is);
        myHandler.start();
    }

    
    public void stop() {
        myHandler.stop();
    }

    
    OutputStream os;    
    InputStream is;     
    InputStream es;     
    

    
    public void setProcessInputStream(OutputStream os) throws IOException {
        this.os = os;
    }

    
    public void setProcessErrorStream(InputStream is) throws IOException {
        this.es = is;
    }

    
    public void setProcessOutputStream(InputStream is) throws IOException {
        this.is = is;
    }
}
"
org.apache.tools.ant.taskdefs.WaitFor,9,3,0,5,26,16,0,5,7,0.75,185,1.0,0,0.8,0.388888889,0,0,19.0,2,1.0,1,"

package org.apache.tools.ant.taskdefs;

import java.util.HashMap;
import java.util.Map;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.taskdefs.condition.ConditionBase;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class WaitFor extends ConditionBase {
    
    private long maxWaitMillis = 1000L * 60L * 3L;
    private long maxWaitMultiplier = 1L;
    private long checkEveryMillis = 500L;
    private long checkEveryMultiplier = 1L;
    private String timeoutProperty;

    
    public WaitFor() {
        super(""waitfor"");
    }

    
    public void setMaxWait(long time) {
        maxWaitMillis = time;
    }

    
    public void setMaxWaitUnit(Unit unit) {
        maxWaitMultiplier = unit.getMultiplier();
    }

    
    public void setCheckEvery(long time) {
        checkEveryMillis = time;
    }

    
    public void setCheckEveryUnit(Unit unit) {
        checkEveryMultiplier = unit.getMultiplier();
    }

    
    public void setTimeoutProperty(String p) {
        timeoutProperty = p;
    }

    
    public void execute() throws BuildException {
        if (countConditions() > 1) {
            throw new BuildException(""You must not nest more than one ""
                                     + ""condition into ""
                                     + getTaskName());
        }
        if (countConditions() < 1) {
            throw new BuildException(""You must nest a condition into ""
                                     + getTaskName());
        }
        Condition c = (Condition) getConditions().nextElement();

        long savedMaxWaitMillis = maxWaitMillis;
        long savedCheckEveryMillis = checkEveryMillis;
        try {
            maxWaitMillis *= maxWaitMultiplier;
            checkEveryMillis *= checkEveryMultiplier;
            long start = System.currentTimeMillis();
            long end = start + maxWaitMillis;

            while (System.currentTimeMillis() < end) {
                if (c.eval()) {
                    processSuccess();
                    return;
                }
                try {
                    Thread.sleep(checkEveryMillis);
                } catch (InterruptedException e) {
                    
                }
            }
            processTimeout();
        } finally {
            maxWaitMillis = savedMaxWaitMillis;
            checkEveryMillis = savedCheckEveryMillis;
        }
    }

    
    protected void processSuccess() {
        log(getTaskName() + "": condition was met"", Project.MSG_VERBOSE);
    }

    
    protected void processTimeout() {
        log(getTaskName() + "": timeout"", Project.MSG_VERBOSE);
        if (timeoutProperty != null) {
            getProject().setNewProperty(timeoutProperty, ""true"");
        }
    }

    
    public static class Unit extends EnumeratedAttribute {

        
        public static final String MILLISECOND = ""millisecond"";
        
        public static final String SECOND = ""second"";
        
        public static final String MINUTE = ""minute"";
        
        public static final String HOUR = ""hour"";
        
        public static final String DAY = ""day"";
        
        public static final String WEEK = ""week"";

        private static final String[] UNITS = {
            MILLISECOND, SECOND, MINUTE, HOUR, DAY, WEEK
        };

        private Map timeTable = new HashMap();

        
        public Unit() {
            timeTable.put(MILLISECOND, new Long(1L));
            timeTable.put(SECOND,      new Long(1000L));
            timeTable.put(MINUTE,      new Long(1000L * 60L));
            timeTable.put(HOUR,        new Long(1000L * 60L * 60L));
            timeTable.put(DAY,         new Long(1000L * 60L * 60L * 24L));
            timeTable.put(WEEK,        new Long(1000L * 60L * 60L * 24L * 7L));
        }

        
        public long getMultiplier() {
            String key = getValue().toLowerCase();
            Long l = (Long) timeTable.get(key);
            return l.longValue();
        }

        
        
        public String[] getValues() {
            return UNITS;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantCPInfo,3,2,5,7,4,1,6,1,2,0.5,16,1.0,0,0.75,0.555555556,0,0,4.0,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;


public abstract class ConstantCPInfo extends ConstantPoolEntry {

    
    private Object value;

    
    protected ConstantCPInfo(int tagValue, int entries) {
        super(tagValue, entries);
    }

    
    public Object getValue() {
        return value;
    }

    
    public void setValue(Object newValue) {
        value = newValue;
    }

}

"
org.apache.tools.zip.AsiExtraField,20,1,0,4,40,130,0,4,18,0.736842105,345,1.0,1,0.0,0.284210526,0,0,15.9,3,1.15,1,"

package org.apache.tools.zip;

import java.util.zip.CRC32;
import java.util.zip.ZipException;


public class AsiExtraField implements ZipExtraField, UnixStat, Cloneable {

    private static final ZipShort HEADER_ID = new ZipShort(0x756E);

    
    private int mode = 0;
    
    private int uid = 0;
    
    private int gid = 0;
    
    private String link = """";
    
    private boolean dirFlag = false;

    
    private CRC32 crc = new CRC32();

    
    public AsiExtraField() {
    }

    
    public ZipShort getHeaderId() {
        return HEADER_ID;
    }

    
    public ZipShort getLocalFileDataLength() {
        return new ZipShort(4         
                          + 2         
                          + 4         
                          + 2         
                          + 2         
                          + getLinkedFile().getBytes().length);
    }

    
    public ZipShort getCentralDirectoryLength() {
        return getLocalFileDataLength();
    }

    
    public byte[] getLocalFileDataData() {
        
        byte[] data = new byte[getLocalFileDataLength().getValue() - 4];
        System.arraycopy(ZipShort.getBytes(getMode()), 0, data, 0, 2);

        byte[] linkArray = getLinkedFile().getBytes();
        System.arraycopy(ZipLong.getBytes(linkArray.length),
                         0, data, 2, 4);

        System.arraycopy(ZipShort.getBytes(getUserId()),
                         0, data, 6, 2);
        System.arraycopy(ZipShort.getBytes(getGroupId()),
                         0, data, 8, 2);

        System.arraycopy(linkArray, 0, data, 10, linkArray.length);

        crc.reset();
        crc.update(data);
        long checksum = crc.getValue();

        byte[] result = new byte[data.length + 4];
        System.arraycopy(ZipLong.getBytes(checksum), 0, result, 0, 4);
        System.arraycopy(data, 0, result, 4, data.length);
        return result;
    }

    
    public byte[] getCentralDirectoryData() {
        return getLocalFileDataData();
    }

    
    public void setUserId(int uid) {
        this.uid = uid;
    }

    
    public int getUserId() {
        return uid;
    }

    
    public void setGroupId(int gid) {
        this.gid = gid;
    }

    
    public int getGroupId() {
        return gid;
    }

    
    public void setLinkedFile(String name) {
        link = name;
        mode = getMode(mode);
    }

    
    public String getLinkedFile() {
        return link;
    }

    
    public boolean isLink() {
        return getLinkedFile().length() != 0;
    }

    
    public void setMode(int mode) {
        this.mode = getMode(mode);
    }

    
    public int getMode() {
        return mode;
    }

    
    public void setDirectory(boolean dirFlag) {
        this.dirFlag = dirFlag;
        mode = getMode(mode);
    }

    
    public boolean isDirectory() {
        return dirFlag && !isLink();
    }

    
    public void parseFromLocalFileData(byte[] data, int offset, int length)
        throws ZipException {

        long givenChecksum = ZipLong.getValue(data, offset);
        byte[] tmp = new byte[length - 4];
        System.arraycopy(data, offset + 4, tmp, 0, length - 4);
        crc.reset();
        crc.update(tmp);
        long realChecksum = crc.getValue();
        if (givenChecksum != realChecksum) {
            throw new ZipException(""bad CRC checksum ""
                                   + Long.toHexString(givenChecksum)
                                   + "" instead of ""
                                   + Long.toHexString(realChecksum));
        }

        int newMode = ZipShort.getValue(tmp, 0);
        byte[] linkArray = new byte[(int) ZipLong.getValue(tmp, 2)];
        uid = ZipShort.getValue(tmp, 6);
        gid = ZipShort.getValue(tmp, 8);

        if (linkArray.length == 0) {
            link = """";
        } else {
            System.arraycopy(tmp, 10, linkArray, 0, linkArray.length);
            link = new String(linkArray);
        }
        setDirectory((newMode & DIR_FLAG) != 0);
        setMode(newMode);
    }

    
    protected int getMode(int mode) {
        int type = FILE_FLAG;
        if (isLink()) {
            type = LINK_FLAG;
        } else if (isDirectory()) {
            type = DIR_FLAG;
        }
        return type | (mode & PERM_MASK);
    }

}
"
org.apache.tools.ant.types.resources.selectors.Date,13,1,0,7,28,20,2,5,12,0.80952381,183,1.0,2,0.0,0.3,0,0,12.53846154,7,1.3846,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.Locale;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.TimeComparison;
import org.apache.tools.ant.util.FileUtils;


public class Date implements ResourceSelector {
    private static final String MILLIS_OR_DATETIME
        = ""Either the millis or the datetime attribute must be set."";
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private Long millis = null;
    private String dateTime = null;
    private String pattern = null;
    private TimeComparison when = TimeComparison.EQUAL;
    private long granularity = FILE_UTILS.getFileTimestampGranularity();

    
    public synchronized void setMillis(long m) {
        millis = new Long(m);
    }

    
    public synchronized long getMillis() {
        return millis == null ? -1L : millis.longValue();
    }

    
    public synchronized void setDateTime(String s) {
        dateTime = s;
        millis = null;
    }

    
    public synchronized String getDatetime() {
        return dateTime;
    }

    
    public synchronized void setGranularity(long g) {
        granularity = g;
    }

    
    public synchronized long getGranularity() {
        return granularity;
    }

    
    public synchronized void setPattern(String p) {
        pattern = p;
    }

    
    public synchronized String getPattern() {
        return pattern;
    }

    
    public synchronized void setWhen(TimeComparison c) {
        when = c;
    }

    
    public synchronized TimeComparison getWhen() {
        return when;
    }

    
    public synchronized boolean isSelected(Resource r) {
        if (dateTime == null && millis == null) {
            throw new BuildException(MILLIS_OR_DATETIME);
        }
        if (millis == null) {
            DateFormat df = ((pattern == null)
                ? DateFormat.getDateTimeInstance(
                    DateFormat.SHORT, DateFormat.SHORT, Locale.US)
                : new SimpleDateFormat(pattern));
            try {
                long m = df.parse(dateTime).getTime();
                if (m < 0) {
                    throw new BuildException(""Date of "" + dateTime
                        + "" results in negative milliseconds value""
                        + "" relative to epoch (January 1, 1970, 00:00:00 GMT)."");
                }
                setMillis(m);
            } catch (ParseException pe) {
                throw new BuildException(""Date of "" + dateTime
                        + "" Cannot be parsed correctly. It should be in""
                        + (pattern == null
                        ? "" MM/DD/YYYY HH:MM AM_PM"" : pattern) + "" format."");
            }
        }
        return when.evaluate(r.getLastModified(), millis.longValue(), granularity);
    }

}
"
org.apache.tools.ant.util.facade.FacadeTaskHelper,9,1,0,5,19,8,4,1,9,0.53125,119,1.0,0,0.0,0.518518519,0,0,11.77777778,3,1.4444,0,"

package org.apache.tools.ant.util.facade;

import java.util.Enumeration;
import java.util.Vector;


public class FacadeTaskHelper {

    
    private Vector args = new Vector();

    
    private String userChoice;

    
    private String magicValue;

    
    private String defaultValue;

    
    public FacadeTaskHelper(String defaultValue) {
        this(defaultValue, null);
    }

    
    public FacadeTaskHelper(String defaultValue, String magicValue) {
        this.defaultValue = defaultValue;
        this.magicValue = magicValue;
    }

    
    public void setMagicValue(String magicValue) {
        this.magicValue = magicValue;
    }

    
    public void setImplementation(String userChoice) {
        this.userChoice = userChoice;
    }

    
    public String getImplementation() {
        return userChoice != null ? userChoice
                                  : (magicValue != null ? magicValue
                                                        : defaultValue);
    }

    
    public String getExplicitChoice() {
        return userChoice;
    }

    
    public void addImplementationArgument(ImplementationSpecificArgument arg) {
        args.addElement(arg);
    }

    
    public String[] getArgs() {
        Vector tmp = new Vector(args.size());
        for (Enumeration e = args.elements(); e.hasMoreElements();) {
            ImplementationSpecificArgument arg =
                ((ImplementationSpecificArgument) e.nextElement());
            String[] curr = arg.getParts(getImplementation());
            for (int i = 0; i < curr.length; i++) {
                tmp.addElement(curr[i]);
            }
        }
        String[] res = new String[tmp.size()];
        tmp.copyInto(res);
        return res;
    }

    
    public boolean hasBeenSet() {
        return userChoice != null || magicValue != null;
    }
}
"
org.apache.tools.ant.types.selectors.DepthSelector,7,5,0,9,25,0,6,3,7,0.666666667,255,0.0,0,0.863636364,0.342857143,2,5,34.85714286,9,3.1429,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.StringTokenizer;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Parameter;


public class DepthSelector extends BaseExtendSelector {

    

    
    public int min = -1;
    
    public int max = -1;

    

    
    public static final String MIN_KEY = ""min"";
    
    public static final String MAX_KEY = ""max"";

    
    public DepthSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{depthselector min: "");
        buf.append(min);
        buf.append("" max: "");
        buf.append(max);
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setMin(int min) {
        this.min = min;
    }

    
    public void setMax(int max) {
        this.max = max;
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (MIN_KEY.equalsIgnoreCase(paramname)) {
                    try {
                        setMin(Integer.parseInt(parameters[i].getValue()));
                    } catch (NumberFormatException nfe1) {
                        setError(""Invalid minimum value ""
                                + parameters[i].getValue());
                    }
                } else if (MAX_KEY.equalsIgnoreCase(paramname)) {
                    try {
                        setMax(Integer.parseInt(parameters[i].getValue()));
                    } catch (NumberFormatException nfe1) {
                        setError(""Invalid maximum value ""
                                + parameters[i].getValue());
                    }
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (min < 0 && max < 0) {
            setError(""You must set at least one of the min or the ""
                    + ""max levels."");
        }
        if (max < min && max > -1) {
            setError(""The maximum depth is lower than the minimum."");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {

        
        validate();

        int depth = -1;
        
        String absBase = basedir.getAbsolutePath();
        String absFile = file.getAbsolutePath();
        StringTokenizer tokBase = new StringTokenizer(absBase,
                File.separator);
        StringTokenizer tokFile = new StringTokenizer(absFile,
                File.separator);
        while (tokFile.hasMoreTokens()) {
            String filetoken = tokFile.nextToken();
            if (tokBase.hasMoreTokens()) {
                String basetoken = tokBase.nextToken();
                
                if (!basetoken.equals(filetoken)) {
                    throw new BuildException(""File "" + filename
                            + "" does not appear within "" + absBase
                            + ""directory"");
                }
            } else {
                depth += 1;
                if (max > -1 && depth > max) {
                    return false;
                }
            }
        }
        if (tokBase.hasMoreTokens()) {
            throw new BuildException(""File "" + filename
                + "" is outside of "" + absBase + ""directory tree"");
        }
        if (min > -1 && depth < min) {
            return false;
        }
        return true;
    }

}

"
org.apache.tools.ant.taskdefs.optional.dotnet.JSharp,9,6,0,5,17,26,0,5,6,0.833333333,71,0.0,0,0.949367089,0.333333333,1,4,6.555555556,3,1.1111,0,"
package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.BuildException;



public class JSharp extends DotnetCompile {
    
    
    String baseAddress;

    
    boolean pureJava = true;

    
    boolean secureScoping = false;

    

    
    public JSharp() {
        setExecutable(""vjc"");
    }


    
    public void setBaseAddress(String baseAddress) {
        this.baseAddress = baseAddress;
    }

    
    public void setPureJava(boolean pureJava) {
        this.pureJava = pureJava;
    }

    
    public void setSecureScoping(boolean secureScoping) {
        this.secureScoping = secureScoping;
    }

    
    public String getReferenceDelimiter() {
        return "";"";
    }

    
    public String getFileExtension() {
        return "".java"";
    }

    
    protected void addCompilerSpecificOptions(NetCommand command) {
        if (pureJava) {
            command.addArgument(""/x:all"");
        }
        if (secureScoping) {
            command.addArgument(""/securescoping"");
        }
    }

    
    protected void createResourceParameter(NetCommand command, DotnetResource resource) {
        resource.getParameters(getProject(), command, true);
    }

    
    protected void validate()
            throws BuildException {
        super.validate();
        if (getDestFile() == null) {
            throw new BuildException(""DestFile was not specified"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.LogStreamHandler,3,2,0,19,10,3,14,5,3,2.0,38,0.0,0,0.923076923,0.583333333,0,0,11.66666667,1,0.3333,0,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;


public class LogStreamHandler extends PumpStreamHandler {

    
    public LogStreamHandler(Task task, int outlevel, int errlevel) {
        this((ProjectComponent) task, outlevel, errlevel);
    }

    
    public LogStreamHandler(ProjectComponent pc, int outlevel, int errlevel) {
        super(new LogOutputStream(pc, outlevel),
              new LogOutputStream(pc, errlevel));
    }

    
    public void stop() {
        super.stop();
        try {
            getErr().close();
            getOut().close();
        } catch (IOException e) {
            
            throw new BuildException(e);
        }
    }
}
"
org.apache.tools.ant.input.InputHandler,1,1,0,10,1,0,8,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.input;


public interface InputHandler {

    
    void handleInput(InputRequest request)
        throws org.apache.tools.ant.BuildException;
}
"
org.apache.tools.zip.JarMarker,9,1,0,3,12,20,1,2,8,0.8125,54,1.0,3,0.0,0.375,0,0,4.555555556,1,0.7778,0,"

package org.apache.tools.zip;

import java.util.zip.ZipException;


public final class JarMarker implements ZipExtraField {

    private static final ZipShort ID = new ZipShort(0xCAFE);
    private static final ZipShort NULL = new ZipShort(0);
    private static final byte[] NO_BYTES = new byte[0];
    private static final JarMarker DEFAULT = new JarMarker();

    
    public JarMarker() {
        
    }

    
    public static JarMarker getInstance() {
        return DEFAULT;
    }

    
    public ZipShort getHeaderId() {
        return ID;
    }

    
    public ZipShort getLocalFileDataLength() {
        return NULL;
    }

    
    public ZipShort getCentralDirectoryLength() {
        return NULL;
    }

    
    public byte[] getLocalFileDataData() {
        return NO_BYTES;
    }

    
    public byte[] getCentralDirectoryData() {
        return NO_BYTES;
    }

    
    public void parseFromLocalFileData(byte[] data, int offset, int length)
        throws ZipException {
        if (length != 0) {
            throw new ZipException(""JarMarker doesn't expect any data"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCMkbl,19,4,0,7,40,129,0,7,16,0.936507937,252,0.5,0,0.727272727,0.381578947,2,3,11.52631579,6,1.3158,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCMkbl extends ClearCase {
    private String mComment = null;
    private String mCfile = null;
    private String mBaselineRootName = null;
    private boolean mNwarn = false;
    private boolean mIdentical = true;
    private boolean mFull = false;
    private boolean mNlabel = false;


    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_MKBL);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getBaselineRootName(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        if (getIdentical()) {
            
            cmd.createArgument().setValue(FLAG_IDENTICAL);
        }

       if (getFull()) {
           
           cmd.createArgument().setValue(FLAG_FULL);
       } else {
           
           cmd.createArgument().setValue(FLAG_INCREMENTAL);
       }

       if (getNlabel()) {
           
           cmd.createArgument().setValue(FLAG_NLABEL);
       }

       
        cmd.createArgument().setValue(getBaselineRootName());

    }


    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setBaselineRootName(String baselineRootName) {
        mBaselineRootName = baselineRootName;
    }

    
    public String getBaselineRootName() {
        return mBaselineRootName;
    }

    
    public void setNoWarn(boolean nwarn) {
        mNwarn = nwarn;
    }

    
    public boolean getNoWarn() {
        return mNwarn;
    }

    
    public void setIdentical(boolean identical) {
        mIdentical = identical;
    }

    
    public boolean getIdentical() {
        return mIdentical;
    }

    
    public void setFull(boolean full) {
        mFull = full;
    }

    
    public boolean getFull() {
        return mFull;
    }

    
    public void setNlabel(boolean nlabel) {
        mNlabel = nlabel;
    }

    
    public boolean getNlabel() {
        return mNlabel;
    }


    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }


        
    public static final String FLAG_COMMENT = ""-c"";
        
    public static final String FLAG_COMMENTFILE = ""-cfile"";
        
    public static final String FLAG_NOCOMMENT = ""-nc"";
        
    public static final String FLAG_IDENTICAL = ""-identical"";
       
    public static final String FLAG_INCREMENTAL = ""-incremental"";
       
    public static final String FLAG_FULL = ""-full"";
       
    public static final String FLAG_NLABEL = ""-nlabel"";


}
"
org.apache.tools.ant.types.resources.Restrict,10,4,2,13,26,0,7,7,9,0.111111111,110,1.0,1,0.795454545,0.26,1,1,9.9,3,1.6,0,"
package org.apache.tools.ant.types.resources;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collection;

import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.types.resources.selectors.ResourceSelectorContainer;


public class Restrict
    extends ResourceSelectorContainer implements ResourceCollection {

    private BaseResourceCollectionWrapper w = new BaseResourceCollectionWrapper() {
        
        protected Collection getCollection() {
            ArrayList result = new ArrayList();
outer:      for (Iterator ri = w.getResourceCollection().iterator(); ri.hasNext();) {
                Resource r = (Resource) ri.next();
                for (Iterator i = getSelectors(); i.hasNext();) {
                    if (!((ResourceSelector) (i.next())).isSelected(r)) {
                        continue outer;
                    }
                }
                result.add(r);
            }
            return result;
        }
    };

    
    public synchronized void add(ResourceCollection c) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (c == null) {
            return;
        }
        w.add(c);
    }

    
    public synchronized void setCache(boolean b) {
        w.setCache(b);
    }

    
    public synchronized boolean isCache() {
        return w.isCache();
    }

    
    public synchronized void add(ResourceSelector s) {
        if (s == null) {
            return;
        }
        super.add(s);
        FailFast.invalidate(this);
    }

    
    public final synchronized Iterator iterator() {
        if (isReference()) {
            return ((Restrict) getCheckedRef()).iterator();
        }
        dieOnCircularReference();
        return w.iterator();
    }

    
    public synchronized int size() {
        if (isReference()) {
            return ((Restrict) getCheckedRef()).size();
        }
        dieOnCircularReference();
        return w.size();
    }

    
    public synchronized boolean isFilesystemOnly() {
        if (isReference()) {
            return ((Restrict) getCheckedRef()).isFilesystemOnly();
        }
        dieOnCircularReference();
        return w.isFilesystemOnly();
    }

    
    public synchronized String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        dieOnCircularReference();
        return w.toString();
    }

}
"
org.apache.tools.ant.DemuxInputStream,3,2,0,2,5,0,1,1,3,0.0,34,1.0,1,0.818181818,0.5,1,2,10.0,1,0.6667,0,"

package org.apache.tools.ant;

import java.io.IOException;
import java.io.InputStream;


public class DemuxInputStream extends InputStream {

    
    private Project project;

    
    public DemuxInputStream(Project project) {
        this.project = project;
    }

    
    public int read() throws IOException {
        byte[] buffer = new byte[1];
        if (project.demuxInput(buffer, 0, 1) == -1) {
            return -1;
        }
        return buffer[0];
    }


    
    public int read(byte[] buffer, int offset, int length) throws IOException {
        return project.demuxInput(buffer, offset, length);
    }

}
"
org.apache.tools.ant.taskdefs.optional.ejb.IPlanetEjbc,20,1,0,7,79,136,5,5,10,0.897506925,835,1.0,1,0.0,0.19375,0,0,39.8,10,1.95,0,"

package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.AttributeList;
import org.xml.sax.HandlerBase;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;


public class IPlanetEjbc {

    private static final int MIN_NUM_ARGS = 2;
    private static final int MAX_NUM_ARGS = 8;
    private static final int NUM_CLASSES_WITH_IIOP = 15;
    private static final int NUM_CLASSES_WITHOUT_IIOP = 9;

    
    private static final String ENTITY_BEAN       = ""entity"";
    private static final String STATELESS_SESSION = ""stateless"";
    private static final String STATEFUL_SESSION  = ""stateful"";

    
    private File        stdDescriptor;
    private File        iasDescriptor;

    
    private File        destDirectory;

    
    private String      classpath;
    private String[]    classpathElements;

    
    private boolean     retainSource = false;
    private boolean     debugOutput  = false;

    
    private File        iasHomeDir;

    
    private SAXParser   parser;
    private EjbcHandler handler = new EjbcHandler();

    
    private Hashtable   ejbFiles     = new Hashtable();

    
    private String      displayName;

    
    public IPlanetEjbc(File stdDescriptor,
                       File iasDescriptor,
                       File destDirectory,
                       String classpath,
                       SAXParser parser) {
        this.stdDescriptor = stdDescriptor;
        this.iasDescriptor      = iasDescriptor;
        this.destDirectory      = destDirectory;
        this.classpath          = classpath;
        this.parser             = parser;

        
        List elements = new ArrayList();
        if (classpath != null) {
            StringTokenizer st = new StringTokenizer(classpath,
                                                        File.pathSeparator);
            while (st.hasMoreTokens()) {
                elements.add(st.nextToken());
            }
            classpathElements
                    = (String[]) elements.toArray(new String[elements.size()]);
        }
    }

    
    public void setRetainSource(boolean retainSource) {
        this.retainSource = retainSource;
    }

    
    public void setDebugOutput(boolean debugOutput) {
        this.debugOutput = debugOutput;
    }

    
    public void registerDTD(String publicID, String location) {
        handler.registerDTD(publicID, location);
    }

    
    public void setIasHomeDir(File iasHomeDir) {
        this.iasHomeDir = iasHomeDir;
    }

    
    public Hashtable getEjbFiles() {
        return ejbFiles;
    }

    
    public String getDisplayName() {
        return displayName;
    }

    
    public String[] getCmpDescriptors() {
        List returnList = new ArrayList();

        EjbInfo[] ejbs = handler.getEjbs();

        for (int i = 0; i < ejbs.length; i++) {
            List descriptors = (List) ejbs[i].getCmpDescriptors();
            returnList.addAll(descriptors);
        }

        return (String[]) returnList.toArray(new String[returnList.size()]);
    }

    
    public static void main(String[] args) {
        File        stdDescriptor;
        File        iasDescriptor;
        File        destDirectory = null;
        String      classpath     = null;
        SAXParser   parser        = null;
        boolean     debug         = false;
        boolean     retainSource  = false;
        IPlanetEjbc ejbc;

        if ((args.length < MIN_NUM_ARGS) || (args.length > MAX_NUM_ARGS)) {
            usage();
            return;
        }

        stdDescriptor = new File(args[args.length - 2]);
        iasDescriptor = new File(args[args.length - 1]);

        for (int i = 0; i < args.length - 2; i++) {
            if (args[i].equals(""-classpath"")) {
                classpath = args[++i];
            } else if (args[i].equals(""-d"")) {
                destDirectory = new File(args[++i]);
            } else if (args[i].equals(""-debug"")) {
                debug = true;
            } else if (args[i].equals(""-keepsource"")) {
                retainSource = true;
            } else {
                usage();
                return;
            }
        }

        
        if (classpath == null) {
            Properties props = System.getProperties();
            classpath = props.getProperty(""java.class.path"");
        }

        
        if (destDirectory == null) {
            Properties props = System.getProperties();
            destDirectory = new File(props.getProperty(""user.dir""));
        }

        
        SAXParserFactory parserFactory = SAXParserFactory.newInstance();
        parserFactory.setValidating(true);
        try {
            parser = parserFactory.newSAXParser();
        } catch (Exception e) {
            
            System.out.println(""An exception was generated while trying to "");
            System.out.println(""create a new SAXParser."");
            e.printStackTrace();
            return;
        }

        
        ejbc = new IPlanetEjbc(stdDescriptor, iasDescriptor, destDirectory,
                                classpath, parser);
        ejbc.setDebugOutput(debug);
        ejbc.setRetainSource(retainSource);

        
        try {
            ejbc.execute();
        } catch (IOException e) {
            System.out.println(""An IOException has occurred while reading the ""
                    + ""XML descriptors ("" + e.getMessage() + "")."");
            return;
        } catch (SAXException e) {
            System.out.println(""A SAXException has occurred while reading the ""
                    + ""XML descriptors ("" + e.getMessage() + "")."");
            return;
        } catch (IPlanetEjbc.EjbcException e) {
            System.out.println(""An error has occurred while executing the ejbc ""
                    + ""utility ("" + e.getMessage() + "")."");
            return;
        }
    }

    
    private static void usage() {
        System.out.println(""java org.apache.tools.ant.taskdefs.optional.ejb.IPlanetEjbc \\"");
        System.out.println(""  [OPTIONS] [EJB 1.1 descriptor] [iAS EJB descriptor]"");
        System.out.println("""");
        System.out.println(""Where OPTIONS are:"");
        System.out.println(""  -debug -- for additional debugging output"");
        System.out.println(""  -keepsource -- to retain Java source files generated"");
        System.out.println(""  -classpath [classpath] -- classpath used for compilation"");
        System.out.println(""  -d [destination directory] -- directory for compiled classes"");
        System.out.println("""");
        System.out.println(""If a classpath is not specified, the system classpath"");
        System.out.println(""will be used.  If a destination directory is not specified,"");
        System.out.println(""the current working directory will be used (classes will"");
        System.out.println(""still be placed in subfolders which correspond to their"");
        System.out.println(""package name)."");
        System.out.println("""");
        System.out.println(""The EJB home interface, remote interface, and implementation"");
        System.out.println(""class must be found in the destination directory.  In"");
        System.out.println(""addition, the destination will look for the stubs and skeletons"");
        System.out.println(""in the destination directory to ensure they are up to date."");
    }

    
    public void execute() throws EjbcException, IOException, SAXException {

        checkConfiguration();   

        EjbInfo[] ejbs = getEjbs(); 

        for (int i = 0; i < ejbs.length; i++) {
            log(""EJBInfo..."");
            log(ejbs[i].toString());
        }

        for (int i = 0; i < ejbs.length; i++) {
            EjbInfo ejb = ejbs[i];

            ejb.checkConfiguration(destDirectory);  

            if (ejb.mustBeRecompiled(destDirectory)) {
                log(ejb.getName() + "" must be recompiled using ejbc."");

                String[] arguments = buildArgumentList(ejb);
                callEjbc(arguments);

            } else {
                log(ejb.getName() + "" is up to date."");
            }
        }
    }

    
    private void callEjbc(String[] arguments) {

        
        StringBuffer args = new StringBuffer();
        for (int i = 0; i < arguments.length; i++) {
            args.append(arguments[i]).append("" "");
        }

        
        String command;
        if (iasHomeDir == null) {
            command = """";
        } else {
            command = iasHomeDir.toString() + File.separator + ""bin""
                                                        + File.separator;
        }
        command += ""ejbc "";

        log(command + args);

        
        try {
            Process p = Runtime.getRuntime().exec(command + args);
            RedirectOutput output = new RedirectOutput(p.getInputStream());
            RedirectOutput error  = new RedirectOutput(p.getErrorStream());
            output.start();
            error.start();
            p.waitFor();
            p.destroy();
        } catch (IOException e) {
            log(""An IOException has occurred while trying to execute ejbc."");
            e.printStackTrace();
        } catch (InterruptedException e) {
            
        }
    }

    
    protected void checkConfiguration() throws EjbcException {

        String msg = """";

        if (stdDescriptor == null) {
            msg += ""A standard XML descriptor file must be specified.  "";
        }
        if (iasDescriptor == null) {
            msg += ""An iAS-specific XML descriptor file must be specified.  "";
        }
        if (classpath == null) {
            msg += ""A classpath must be specified.    "";
        }
        if (parser == null) {
            msg += ""An XML parser must be specified.    "";
        }

        if (destDirectory == null) {
            msg += ""A destination directory must be specified.  "";
        } else if (!destDirectory.exists()) {
            msg += ""The destination directory specified does not exist.  "";
        } else if (!destDirectory.isDirectory()) {
            msg += ""The destination specified is not a directory.  "";
        }

        if (msg.length() > 0) {
            throw new EjbcException(msg);
        }
    }

    
    private EjbInfo[] getEjbs() throws IOException, SAXException {
        EjbInfo[] ejbs = null;

        

        parser.parse(stdDescriptor, handler);
        parser.parse(iasDescriptor, handler);
        ejbs = handler.getEjbs();

        return ejbs;
    }

    
    private String[] buildArgumentList(EjbInfo ejb) {

        List arguments = new ArrayList();

        

        if (debugOutput) {
            arguments.add(""-debug"");
        }

        
        if (ejb.getBeantype().equals(STATELESS_SESSION)) {
            arguments.add(""-sl"");
        } else if (ejb.getBeantype().equals(STATEFUL_SESSION)) {
            arguments.add(""-sf"");
        }

        if (ejb.getIiop()) {
            arguments.add(""-iiop"");
        }

        if (ejb.getCmp()) {
            arguments.add(""-cmp"");
        }

        if (retainSource) {
            arguments.add(""-gs"");
        }

        if (ejb.getHasession()) {
            arguments.add(""-fo"");
        }

        

        arguments.add(""-classpath"");
        arguments.add(classpath);

        arguments.add(""-d"");
        arguments.add(destDirectory.toString());

        arguments.add(ejb.getHome().getQualifiedClassName());
        arguments.add(ejb.getRemote().getQualifiedClassName());
        arguments.add(ejb.getImplementation().getQualifiedClassName());

        
        return (String[]) arguments.toArray(new String[arguments.size()]);
    }

    
    private void log(String msg) {
        if (debugOutput) {
            System.out.println(msg);
        }
    }


    


    
    public class EjbcException extends Exception {

        
        public EjbcException(String msg) {
            super(msg);
        }
    }  


    
    private class EjbcHandler extends HandlerBase {
        
        private static final String PUBLICID_EJB11 =
            ""-
        
        private static final String PUBLICID_IPLANET_EJB_60 =
            ""-
        
        private static final String DEFAULT_IAS60_EJB11_DTD_LOCATION =
            ""ejb-jar_1_1.dtd"";
        
        private static final String DEFAULT_IAS60_DTD_LOCATION =
            ""IASEjb_jar_1_0.dtd"";

        
        private Map       resourceDtds = new HashMap();
        private Map       fileDtds = new HashMap();

        private Map       ejbs = new HashMap();      
        private EjbInfo   currentEjb;             
        private boolean   iasDescriptor = false;  

        private String    currentLoc = """";        
        private String    currentText;            
        private String    ejbType;                

        
        public EjbcHandler() {
            registerDTD(PUBLICID_EJB11, DEFAULT_IAS60_EJB11_DTD_LOCATION);
            registerDTD(PUBLICID_IPLANET_EJB_60, DEFAULT_IAS60_DTD_LOCATION);
        }

        
        public EjbInfo[] getEjbs() {
            return (EjbInfo[]) ejbs.values().toArray(new EjbInfo[ejbs.size()]);
        }

        
        public String getDisplayName() {
            return displayName;
        }

        
        public void registerDTD(String publicID, String location) {
            log(""Registering: "" + location);
            if ((publicID == null) || (location == null)) {
                return;
            }

            if (ClassLoader.getSystemResource(location) != null) {
                log(""Found resource: "" + location);
                resourceDtds.put(publicID, location);
            } else {
                File dtdFile = new File(location);
                if (dtdFile.exists() && dtdFile.isFile()) {
                    log(""Found file: "" + location);
                    fileDtds.put(publicID, location);
                }
            }
        }

        
        public InputSource resolveEntity(String publicId, String systemId)
                throws SAXException {
            InputStream inputStream = null;


            try {

                

                String location = (String) resourceDtds.get(publicId);
                if (location != null) {
                    inputStream
                        = ClassLoader.getSystemResource(location).openStream();
                } else {
                    location = (String) fileDtds.get(publicId);
                    if (location != null) {
                        inputStream = new FileInputStream(location);
                    }
                }
            } catch (IOException e) {
                return super.resolveEntity(publicId, systemId);
            }

            if (inputStream == null) {
                return super.resolveEntity(publicId, systemId);
            } else {
                return new InputSource(inputStream);
            }
        }

        
        public void startElement(String name, AttributeList atts)
                throws SAXException {

            
            currentLoc += ""\\"" + name;

            
            currentText = """";

            if (currentLoc.equals(""\\ejb-jar"")) {
                iasDescriptor = false;
            } else if (currentLoc.equals(""\\ias-ejb-jar"")) {
                iasDescriptor = true;
            }

            if ((name.equals(""session"")) || (name.equals(""entity""))) {
                ejbType = name;
            }
        }

        
        public void characters(char[] ch, int start, int len)
                throws SAXException {

            currentText += new String(ch).substring(start, start + len);
        }

        
        public void endElement(String name) throws SAXException {

            
            if (iasDescriptor) {
                iasCharacters(currentText);
            } else {
                stdCharacters(currentText);
            }

            

            int nameLength = name.length() + 1; 
            int locLength  = currentLoc.length();

            currentLoc = currentLoc.substring(0, locLength - nameLength);
        }

        
        private void stdCharacters(String value) {

            if (currentLoc.equals(""\\ejb-jar\\display-name"")) {
                displayName = value;
                return;
            }

            String base = ""\\ejb-jar\\enterprise-beans\\"" + ejbType;

            if (currentLoc.equals(base + ""\\ejb-name"")) {
                currentEjb = (EjbInfo) ejbs.get(value);
                if (currentEjb == null) {
                    currentEjb = new EjbInfo(value);
                    ejbs.put(value, currentEjb);
                }
            } else if (currentLoc.equals(base + ""\\home"")) {
                currentEjb.setHome(value);
            } else if (currentLoc.equals(base + ""\\remote"")) {
                currentEjb.setRemote(value);
            } else if (currentLoc.equals(base + ""\\ejb-class"")) {
                currentEjb.setImplementation(value);
            } else if (currentLoc.equals(base + ""\\prim-key-class"")) {
                currentEjb.setPrimaryKey(value);
            } else if (currentLoc.equals(base + ""\\session-type"")) {
                currentEjb.setBeantype(value);
            } else if (currentLoc.equals(base + ""\\persistence-type"")) {
                currentEjb.setCmp(value);
            }
        }

        
        private void iasCharacters(String value) {
            String base = ""\\ias-ejb-jar\\enterprise-beans\\"" + ejbType;

            if (currentLoc.equals(base + ""\\ejb-name"")) {
                currentEjb = (EjbInfo) ejbs.get(value);
                if (currentEjb == null) {
                    currentEjb = new EjbInfo(value);
                    ejbs.put(value, currentEjb);
                }
            } else if (currentLoc.equals(base + ""\\iiop"")) {
                currentEjb.setIiop(value);
            } else if (currentLoc.equals(base + ""\\failover-required"")) {
                currentEjb.setHasession(value);
            } else if (currentLoc.equals(base + ""\\persistence-manager""
                                              + ""\\properties-file-location"")) {
                currentEjb.addCmpDescriptor(value);
            }
        }
    }  


    
    private class EjbInfo {
        private String     name;              
        private Classname  home;              
        private Classname  remote;            
        private Classname  implementation;      
        private Classname  primaryKey;        
        private String  beantype = ""entity"";  
        private boolean cmp       = false;      
        private boolean iiop      = false;      
        private boolean hasession = false;      
        private List cmpDescriptors = new ArrayList();  

        
        public EjbInfo(String name) {
            this.name = name;
        }

        
        public String getName() {
            if (name == null) {
                if (implementation == null) {
                    return ""[unnamed]"";
                } else {
                    return implementation.getClassName();
                }
            }
            return name;
        }

        

        public void setHome(String home) {
            setHome(new Classname(home));
        }

        public void setHome(Classname home) {
            this.home = home;
        }

        public Classname getHome() {
            return home;
        }

        public void setRemote(String remote) {
            setRemote(new Classname(remote));
        }

        public void setRemote(Classname remote) {
            this.remote = remote;
        }

        public Classname getRemote() {
            return remote;
        }

        public void setImplementation(String implementation) {
            setImplementation(new Classname(implementation));
        }

        public void setImplementation(Classname implementation) {
            this.implementation = implementation;
        }

        public Classname getImplementation() {
            return implementation;
        }

        public void setPrimaryKey(String primaryKey) {
            setPrimaryKey(new Classname(primaryKey));
        }

        public void setPrimaryKey(Classname primaryKey) {
            this.primaryKey = primaryKey;
        }

        public Classname getPrimaryKey() {
            return primaryKey;
        }

        public void setBeantype(String beantype) {
            this.beantype = beantype.toLowerCase();
        }

        public String getBeantype() {
            return beantype;
        }

        public void setCmp(boolean cmp) {
            this.cmp = cmp;
        }

        public void setCmp(String cmp) {
            setCmp(cmp.equals(""Container""));
        }

        public boolean getCmp() {
            return cmp;
        }

        public void setIiop(boolean iiop) {
            this.iiop = iiop;
        }

        public void setIiop(String iiop) {
            setIiop(iiop.equals(""true""));
        }

        public boolean getIiop() {
            return iiop;
        }

        public void setHasession(boolean hasession) {
            this.hasession = hasession;
        }

        public void setHasession(String hasession) {
            setHasession(hasession.equals(""true""));
        }

        public boolean getHasession() {
            return hasession;
        }

        public void addCmpDescriptor(String descriptor) {
            cmpDescriptors.add(descriptor);
        }

        public List getCmpDescriptors() {
            return cmpDescriptors;
        }

        
        private void checkConfiguration(File buildDir) throws EjbcException  {

            
            if (home == null) {
                throw new EjbcException(""A home interface was not found ""
                            + ""for the "" + name + "" EJB."");
            }
            if (remote == null) {
                throw new EjbcException(""A remote interface was not found ""
                            + ""for the "" + name + "" EJB."");
            }
            if (implementation == null) {
                throw new EjbcException(""An EJB implementation class was not ""
                            + ""found for the "" + name + "" EJB."");
            }

            if ((!beantype.equals(ENTITY_BEAN))
                        && (!beantype.equals(STATELESS_SESSION))
                        && (!beantype.equals(STATEFUL_SESSION))) {
                throw new EjbcException(""The beantype found ("" + beantype + "") ""
                            + ""isn't valid in the "" + name + "" EJB."");
            }

            if (cmp && (!beantype.equals(ENTITY_BEAN))) {
                System.out.println(""CMP stubs and skeletons may not be generated""
                    + "" for a Session Bean -- the \""cmp\"" attribute will be""
                    + "" ignoredfor the "" + name + "" EJB."");
            }

            if (hasession && (!beantype.equals(STATEFUL_SESSION))) {
                System.out.println(""Highly available stubs and skeletons may ""
                    + ""only be generated for a Stateful Session Bean -- the ""
                    + ""\""hasession\"" attribute will be ignored for the ""
                    + name + "" EJB."");
            }

            
            if (!remote.getClassFile(buildDir).exists()) {
                throw new EjbcException(""The remote interface ""
                            + remote.getQualifiedClassName() + "" could not be ""
                            + ""found."");
            }
            if (!home.getClassFile(buildDir).exists()) {
                throw new EjbcException(""The home interface ""
                            + home.getQualifiedClassName() + "" could not be ""
                            + ""found."");
            }
            if (!implementation.getClassFile(buildDir).exists()) {
                throw new EjbcException(""The EJB implementation class ""
                            + implementation.getQualifiedClassName() + "" could ""
                            + ""not be found."");
            }
        }

        
        public boolean mustBeRecompiled(File destDir) {

            long sourceModified = sourceClassesModified(destDir);

            long destModified = destClassesModified(destDir);

            return (destModified < sourceModified);
        }

        
        private long sourceClassesModified(File buildDir) {
            long latestModified; 
            long modified;       
            File remoteFile;     
            File homeFile;       
            File implFile;       
            File pkFile;         

            
            remoteFile = remote.getClassFile(buildDir);
            modified = remoteFile.lastModified();
            if (modified == -1) {
                System.out.println(""The class ""
                                + remote.getQualifiedClassName() + "" couldn't ""
                                + ""be found on the classpath"");
                return -1;
            }
            latestModified = modified;

            
            homeFile = home.getClassFile(buildDir);
            modified = homeFile.lastModified();
            if (modified == -1) {
                System.out.println(""The class ""
                                + home.getQualifiedClassName() + "" couldn't be ""
                                + ""found on the classpath"");
                return -1;
            }
            latestModified = Math.max(latestModified, modified);

            
            if (primaryKey != null) {
                pkFile = primaryKey.getClassFile(buildDir);
                modified = pkFile.lastModified();
                if (modified == -1) {
                    System.out.println(""The class ""
                                    + primaryKey.getQualifiedClassName() + ""couldn't be ""
                                    + ""found on the classpath"");
                    return -1;
                }
                latestModified = Math.max(latestModified, modified);
            } else {
                pkFile = null;
            }

            
            implFile = implementation.getClassFile(buildDir);
            modified = implFile.lastModified();
            if (modified == -1) {
                System.out.println(""The class ""
                                + implementation.getQualifiedClassName()
                                + "" couldn't be found on the classpath"");
                return -1;
            }

            String pathToFile = remote.getQualifiedClassName();
            pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
            ejbFiles.put(pathToFile, remoteFile);

            pathToFile = home.getQualifiedClassName();
            pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
            ejbFiles.put(pathToFile, homeFile);

            pathToFile = implementation.getQualifiedClassName();
            pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
            ejbFiles.put(pathToFile, implFile);

            if (pkFile != null) {
                pathToFile = primaryKey.getQualifiedClassName();
                pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
                ejbFiles.put(pathToFile, pkFile);
            }

            return latestModified;
        }

        
        private long destClassesModified(File destDir) {
            String[] classnames = classesToGenerate(); 
            long destClassesModified = new Date().getTime(); 
            boolean allClassesFound  = true;           

            
            for (int i = 0; i < classnames.length; i++) {

                String pathToClass =
                        classnames[i].replace('.', File.separatorChar) + "".class"";
                File classFile = new File(destDir, pathToClass);

                
                ejbFiles.put(pathToClass, classFile);

                allClassesFound = allClassesFound && classFile.exists();

                if (allClassesFound) {
                    long fileMod = classFile.lastModified();

                    
                    destClassesModified = Math.min(destClassesModified, fileMod);
                }
            }

            return (allClassesFound) ? destClassesModified : -1;
        }

        
        private String[] classesToGenerate() {
            String[] classnames = (iiop)
                ? new String[NUM_CLASSES_WITH_IIOP]
                : new String[NUM_CLASSES_WITHOUT_IIOP];

            final String remotePkg     = remote.getPackageName() + ""."";
            final String remoteClass   = remote.getClassName();
            final String homePkg       = home.getPackageName() + ""."";
            final String homeClass     = home.getClassName();
            final String implPkg       = implementation.getPackageName() + ""."";
            final String implFullClass = implementation.getQualifiedWithUnderscores();
            int index = 0;

            classnames[index++] = implPkg + ""ejb_fac_"" + implFullClass;
            classnames[index++] = implPkg + ""ejb_home_"" + implFullClass;
            classnames[index++] = implPkg + ""ejb_skel_"" + implFullClass;
            classnames[index++] = remotePkg + ""ejb_kcp_skel_"" + remoteClass;
            classnames[index++] = homePkg + ""ejb_kcp_skel_"" + homeClass;
            classnames[index++] = remotePkg + ""ejb_kcp_stub_"" + remoteClass;
            classnames[index++] = homePkg + ""ejb_kcp_stub_"" + homeClass;
            classnames[index++] = remotePkg + ""ejb_stub_"" + remoteClass;
            classnames[index++] = homePkg + ""ejb_stub_"" + homeClass;

            if (!iiop) {
                return classnames;
            }

            classnames[index++] = ""org.omg.stub."" + remotePkg + ""_""
                                    + remoteClass + ""_Stub"";
            classnames[index++] = ""org.omg.stub."" + homePkg + ""_""
                                    + homeClass + ""_Stub"";
            classnames[index++] = ""org.omg.stub."" + remotePkg
                                    + ""_ejb_RmiCorbaBridge_""
                                    + remoteClass + ""_Tie"";
            classnames[index++] = ""org.omg.stub."" + homePkg
                                    + ""_ejb_RmiCorbaBridge_""
                                    + homeClass + ""_Tie"";

            classnames[index++] = remotePkg + ""ejb_RmiCorbaBridge_""
                                                        + remoteClass;
            classnames[index++] = homePkg + ""ejb_RmiCorbaBridge_"" + homeClass;

            return classnames;
        }

        
        public String toString() {
            String s = ""EJB name: "" + name
                        + ""\n\r              home:      "" + home
                        + ""\n\r              remote:    "" + remote
                        + ""\n\r              impl:      "" + implementation
                        + ""\n\r              primaryKey: "" + primaryKey
                        + ""\n\r              beantype:  "" + beantype
                        + ""\n\r              cmp:       "" + cmp
                        + ""\n\r              iiop:      "" + iiop
                        + ""\n\r              hasession: "" + hasession;

            Iterator i = cmpDescriptors.iterator();
            while (i.hasNext()) {
                s += ""\n\r              CMP Descriptor: "" + i.next();
            }

            return s;
        }

    } 

    
    private static class Classname {
        private String qualifiedName;  
        private String packageName;    
        private String className;      

        
        public Classname(String qualifiedName) {
            if (qualifiedName == null) {
                return;
            }

            this.qualifiedName = qualifiedName;

            int index = qualifiedName.lastIndexOf('.');
            if (index == -1) {
                className = qualifiedName;
                packageName = """";
            } else {
                packageName = qualifiedName.substring(0, index);
                className   = qualifiedName.substring(index + 1);
            }
        }

        
        public String getQualifiedClassName() {
            return qualifiedName;
        }

        
        public String getPackageName() {
            return packageName;
        }

        
        public String getClassName() {
            return className;
        }

        
        public String getQualifiedWithUnderscores() {
            return qualifiedName.replace('.', '_');
        }

        
        public File getClassFile(File directory) {
            String pathToFile = qualifiedName.replace('.', File.separatorChar)
                                            + "".class"";
            return new File(directory, pathToFile);
        }

        
        public String toString() {
            return getQualifiedClassName();
        }
    }  


    
    private static class RedirectOutput extends Thread {

        private InputStream stream;  

        
        public RedirectOutput(InputStream stream) {
            this.stream = stream;
        }

        
        public void run() {
            BufferedReader reader = new BufferedReader(
                                            new InputStreamReader(stream));
            String text;
            try {
                while ((text = reader.readLine()) != null) {
                    System.out.println(text);
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    reader.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }  

}
"
org.apache.tools.zip.ZipExtraField,6,1,0,8,6,15,7,1,6,2.0,6,0.0,0,0.0,0.444444444,0,0,0.0,1,1.0,0,"

package org.apache.tools.zip;

import java.util.zip.ZipException;


public interface ZipExtraField {

    
    ZipShort getHeaderId();

    
    ZipShort getLocalFileDataLength();

    
    ZipShort getCentralDirectoryLength();

    
    byte[] getLocalFileDataData();

    
    byte[] getCentralDirectoryData();

    
    void parseFromLocalFileData(byte[] data, int offset, int length)
        throws ZipException;
}
"
org.apache.tools.ant.types.resources.comparators.FileSystem,3,4,0,5,11,1,1,4,1,0.5,41,1.0,1,0.971428571,0.75,1,2,12.33333333,3,1.0,1,"
package org.apache.tools.ant.types.resources.comparators;

import java.io.File;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileUtils;


public class FileSystem extends ResourceComparator {
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    protected int resourceCompare(Resource foo, Resource bar) {
        File foofile = ((FileResource) foo).getFile();
        File barfile = ((FileResource) bar).getFile();
        return foofile.equals(barfile) ? 0
            : FILE_UTILS.isLeadingPath(foofile, barfile) ? -1
            : FILE_UTILS.normalize(foofile.getAbsolutePath()).compareTo(
                FILE_UTILS.normalize(barfile.getAbsolutePath()));
    }

}
"
org.apache.tools.ant.taskdefs.condition.TypeFound,5,2,0,7,14,6,0,7,4,0.625,70,1.0,0,0.692307692,0.8,0,0,12.6,4,1.4,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.AntTypeDefinition;
import org.apache.tools.ant.Project;


public class TypeFound extends ProjectComponent implements Condition {

    private String name;
    private String uri;

    
    public void setName(String name) {
        this.name = name;
    }

    
    public void setURI(String uri) {
        this.uri = uri;
    }

    
    protected boolean doesTypeExist(String typename) {

        ComponentHelper helper =
            ComponentHelper.getComponentHelper(getProject());
        String componentName = ProjectHelper.genComponentName(uri, typename);
        AntTypeDefinition def = helper.getDefinition(componentName);
        if (def == null) {
            return false;
        }
        
        boolean found = def.getExposedClass(getProject()) != null;
        if (!found) {
            String text = helper.diagnoseCreationFailure(componentName, ""type"");
            log(text, Project.MSG_VERBOSE);
        }
        return found;
    }


    
    public boolean eval() throws BuildException {
        if (name == null) {
            throw new BuildException(""No type specified"");
        }
        return doesTypeExist(name);
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4OutputHandler,1,1,0,1,1,0,0,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;


public interface P4OutputHandler {
    
    void process(String line) throws BuildException;
}
"
org.apache.tools.ant.taskdefs.email.Message,11,2,0,7,26,0,5,2,11,0.58,181,1.0,0,0.529411765,0.409090909,0,0,15.0,1,0.7273,0,"
package org.apache.tools.ant.taskdefs.email;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.PrintWriter;

import org.apache.tools.ant.ProjectComponent;


public class Message extends ProjectComponent {
    private File messageSource = null;
    private StringBuffer buffer = new StringBuffer();
    private String mimeType = ""text/plain"";
    private boolean specified = false;
    private String charset = null;

    
    public Message() {
    }


    
    public Message(String text) {
        addText(text);
    }


    
    public Message(File file) {
        messageSource = file;
    }


    
    public void addText(String text) {
        buffer.append(text);
    }


    
    public void setSrc(File src) {
        this.messageSource = src;
    }


    
    public void setMimeType(String mimeType) {
        this.mimeType = mimeType;
        specified = true;
    }


    
    public String getMimeType() {
        return mimeType;
    }


    
    public void print(PrintStream ps)
         throws IOException {
        
        
        PrintWriter out
            = charset != null ? new PrintWriter(new OutputStreamWriter(ps, charset))
                              : new PrintWriter(ps);
        if (messageSource != null) {
            
            FileReader freader = new FileReader(messageSource);

            try {
                BufferedReader in = new BufferedReader(freader);
                String line = null;
                while ((line = in.readLine()) != null) {
                    out.println(getProject().replaceProperties(line));
                }
            } finally {
                freader.close();
            }
        } else {
            out.println(getProject().replaceProperties(buffer.substring(0)));
        }
        out.flush();
    }


    
    public boolean isMimeTypeSpecified() {
        return specified;
    }

    
    public void setCharset(String charset) {
      this.charset = charset;
    }
    
    public String getCharset() {
      return charset;
    }
}

"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSCP,3,4,0,5,15,3,0,5,2,2.0,51,0.0,0,0.978494624,0.666666667,1,1,16.0,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;


public class MSVSSCP extends MSVSS {

    
    protected Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_CP);

        
        commandLine.createArgument().setValue(getVsspath());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(getLogin());

        return commandLine;
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }
}
"
org.apache.tools.ant.taskdefs.condition.IsSet,3,2,0,5,7,1,1,4,3,0.5,29,1.0,0,0.818181818,0.666666667,0,0,8.333333333,1,0.6667,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;


public class IsSet extends ProjectComponent implements Condition {
    private String property;

    
    public void setProperty(String p) {
        property = p;
    }

    
    public boolean eval() throws BuildException {
        if (property == null) {
            throw new BuildException(""No property specified for isset ""
                                     + ""condition"");
        }

        return getProject().getProperty(property) != null;
    }

}
"
org.apache.tools.ant.taskdefs.optional.Rpm,16,3,0,15,65,76,0,15,13,0.92,483,1.0,0,0.725490196,0.311111111,0,0,28.25,9,1.5625,1,"
package org.apache.tools.ant.taskdefs.optional;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.taskdefs.PumpStreamHandler;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class Rpm extends Task {

    private static final String PATH1 = ""PATH="";
    private static final String PATH2 = ""Path="";
    private static final String PATH3 = ""path="";
    private static final int PATH_LEN = PATH1.length();

    
    private String specFile;

    
    private File topDir;

    
    private String command = ""-bb"";

    
    private String rpmBuildCommand = null;

    
    private boolean cleanBuildDir = false;

    
    private boolean removeSpec = false;

    
    private boolean removeSource = false;

    
    private File output;

    
    private File error;

    
    private boolean failOnError = false;

    
    private boolean quiet = false;

    
    public void execute() throws BuildException {

        Commandline toExecute = new Commandline();

        toExecute.setExecutable(rpmBuildCommand == null
                                ? guessRpmBuildCommand()
                                : rpmBuildCommand);
        if (topDir != null) {
            toExecute.createArgument().setValue(""--define"");
            toExecute.createArgument().setValue(""_topdir"" + topDir);
        }

        toExecute.createArgument().setLine(command);

        if (cleanBuildDir) {
            toExecute.createArgument().setValue(""--clean"");
        }
        if (removeSpec) {
            toExecute.createArgument().setValue(""--rmspec"");
        }
        if (removeSource) {
            toExecute.createArgument().setValue(""--rmsource"");
        }

        toExecute.createArgument().setValue(""SPECS/"" + specFile);

        ExecuteStreamHandler streamhandler = null;
        OutputStream outputstream = null;
        OutputStream errorstream = null;
        if (error == null && output == null) {
            if (!quiet) {
                streamhandler = new LogStreamHandler(this, Project.MSG_INFO,
                                                     Project.MSG_WARN);
            } else {
                streamhandler = new LogStreamHandler(this, Project.MSG_DEBUG,
                                                     Project.MSG_DEBUG);
            }
        } else {
            if (output != null) {
                try {
                    BufferedOutputStream bos
                        = new BufferedOutputStream(new FileOutputStream(output));
                    outputstream = new PrintStream(bos);
                } catch (IOException e) {
                    throw new BuildException(e, getLocation());
                }
            } else if (!quiet) {
                outputstream = new LogOutputStream(this, Project.MSG_INFO);
            } else {
                outputstream = new LogOutputStream(this, Project.MSG_DEBUG);
            }
            if (error != null) {
                try {
                    BufferedOutputStream bos
                        = new BufferedOutputStream(new FileOutputStream(error));
                    errorstream = new PrintStream(bos);
                }  catch (IOException e) {
                    throw new BuildException(e, getLocation());
                }
            } else if (!quiet) {
                errorstream = new LogOutputStream(this, Project.MSG_WARN);
            } else {
                errorstream = new LogOutputStream(this, Project.MSG_DEBUG);
            }
            streamhandler = new PumpStreamHandler(outputstream, errorstream);
        }

        Execute exe = getExecute(toExecute, streamhandler);
        try {
            log(""Building the RPM based on the "" + specFile + "" file"");
            int returncode = exe.execute();
            if (Execute.isFailure(returncode)) {
                String msg = ""'"" + toExecute.getExecutable()
                    + ""' failed with exit code "" + returncode;
                if (failOnError) {
                    throw new BuildException(msg);
                } else {
                    log(msg, Project.MSG_ERR);
                }
            }
        } catch (IOException e) {
            throw new BuildException(e, getLocation());
        } finally {
            FileUtils.close(outputstream);
            FileUtils.close(errorstream);
        }
    }

    
    public void setTopDir(File td) {
        this.topDir = td;
    }

    
    public void setCommand(String c) {
        this.command = c;
    }

    
    public void setSpecFile(String sf) {
        if ((sf == null) || (sf.trim().equals(""""))) {
            throw new BuildException(""You must specify a spec file"", getLocation());
        }
        this.specFile = sf;
    }

    
    public void setCleanBuildDir(boolean cbd) {
        cleanBuildDir = cbd;
    }

    
    public void setRemoveSpec(boolean rs) {
        removeSpec = rs;
    }

    
    public void setRemoveSource(boolean rs) {
        removeSource = rs;
    }

    
    public void setOutput(File output) {
        this.output = output;
    }

    
    public void setError(File error) {
        this.error = error;
    }

    
    public void setRpmBuildCommand(String c) {
        this.rpmBuildCommand = c;
    }

    
    public void setFailOnError(boolean value) {
        failOnError = value;
    }

    
    public void setQuiet(boolean value) {
        quiet = value;
    }

    
    protected String guessRpmBuildCommand() {
        Vector env = Execute.getProcEnvironment();
        String path = null;
        for (Enumeration e = env.elements(); e.hasMoreElements();) {
            String var = (String) e.nextElement();
            if (var.startsWith(PATH1) || var.startsWith(PATH2) || var.startsWith(PATH3)) {
                path = var.substring(PATH_LEN);
                break;
            }
        }

        if (path != null) {
            Path p = new Path(getProject(), path);
            String[] pElements = p.list();
            for (int i = 0; i < pElements.length; i++) {
                File f = new File(pElements[i],
                                  ""rpmbuild""
                                  + (Os.isFamily(""dos"") ? "".exe"" : """"));
                if (f.canRead()) {
                    return f.getAbsolutePath();
                }
            }
        }

        return ""rpm"";
    }

    
    protected Execute getExecute(Commandline toExecute,
                                 ExecuteStreamHandler streamhandler) {
        Execute exe = new Execute(streamhandler, null);

        exe.setAntRun(getProject());
        if (topDir == null) {
            topDir = getProject().getBaseDir();
        }
        exe.setWorkingDirectory(topDir);

        exe.setCommandline(toExecute.getCommandline());
        return exe;
    }
}
"
org.apache.tools.ant.types.selectors.BaseExtendSelector,4,4,8,12,5,0,8,4,3,0.333333333,18,1.0,1,0.921052632,0.4375,0,0,3.25,1,0.75,0,"
package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Parameter;


public abstract class BaseExtendSelector
        extends BaseSelector
        implements ExtendFileSelector {

    

    
    protected Parameter[] parameters = null;

    

    
    public BaseExtendSelector() {
    }

    
    public void setParameters(Parameter[] parameters) {
        this.parameters = parameters;
    }

    
    protected Parameter[] getParameters() {
        return parameters;
    }

    
    public abstract boolean isSelected(File basedir, String filename,
                                       File file)
            throws BuildException;

}

"
org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,15,1,0,11,65,75,0,11,11,0.693877551,443,1.0,0,0.0,0.295238095,0,0,28.06666667,5,1.6,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Date;
import java.net.InetAddress;
import java.net.UnknownHostException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import junit.framework.AssertionFailedError;
import junit.framework.Test;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.DateUtils;
import org.apache.tools.ant.util.FileUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;




public class XMLJUnitResultFormatter implements JUnitResultFormatter, XMLConstants {

    
    private static final String UNKNOWN = ""unknown"";

    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (Exception exc) {
            throw new ExceptionInInitializerError(exc);
        }
    }

    
    private Document doc;
    
    private Element rootElement;
    
    private Hashtable testElements = new Hashtable();
    
    private Hashtable failedTests = new Hashtable();
    
    private Hashtable testStarts = new Hashtable();
    
    private OutputStream out;

    
    public XMLJUnitResultFormatter() {
    }

    
    public void setOutput(OutputStream out) {
        this.out = out;
    }

    
    public void setSystemOutput(String out) {
        formatOutput(SYSTEM_OUT, out);
    }

    
    public void setSystemError(String out) {
        formatOutput(SYSTEM_ERR, out);
    }

    
    public void startTestSuite(JUnitTest suite) {
        doc = getDocumentBuilder().newDocument();
        rootElement = doc.createElement(TESTSUITE);
        String n = suite.getName();
        rootElement.setAttribute(ATTR_NAME, n == null ? UNKNOWN : n);

        
        final String timestamp = DateUtils.format(new Date(),
                DateUtils.ISO8601_DATETIME_PATTERN);
        rootElement.setAttribute(TIMESTAMP, timestamp);
        
        rootElement.setAttribute(HOSTNAME, getHostname());

        
        Element propsElement = doc.createElement(PROPERTIES);
        rootElement.appendChild(propsElement);
        Properties props = suite.getProperties();
        if (props != null) {
            Enumeration e = props.propertyNames();
            while (e.hasMoreElements()) {
                String name = (String) e.nextElement();
                Element propElement = doc.createElement(PROPERTY);
                propElement.setAttribute(ATTR_NAME, name);
                propElement.setAttribute(ATTR_VALUE, props.getProperty(name));
                propsElement.appendChild(propElement);
            }
        }
    }

    
    private String getHostname()  {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            return ""localhost"";
        }
    }

    
    public void endTestSuite(JUnitTest suite) throws BuildException {
        rootElement.setAttribute(ATTR_TESTS, """" + suite.runCount());
        rootElement.setAttribute(ATTR_FAILURES, """" + suite.failureCount());
        rootElement.setAttribute(ATTR_ERRORS, """" + suite.errorCount());
        rootElement.setAttribute(ATTR_TIME, """" + (suite.getRunTime() / 1000.0));
        if (out != null) {
            Writer wri = null;
            try {
                wri = new BufferedWriter(new OutputStreamWriter(out, ""UTF8""));
                wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n"");
                (new DOMElementWriter()).write(rootElement, wri, 0, ""  "");
                wri.flush();
            } catch (IOException exc) {
                throw new BuildException(""Unable to write log file"", exc);
            } finally {
                if (out != System.out && out != System.err) {
                    FileUtils.close(wri);
                }
            }
        }
    }

    
    public void startTest(Test t) {
        testStarts.put(t, new Long(System.currentTimeMillis()));
    }

    
    public void endTest(Test test) {
        
        
        
        if (!testStarts.containsKey(test)) {
            startTest(test);
        }

        Element currentTest = null;
        if (!failedTests.containsKey(test)) {
            currentTest = doc.createElement(TESTCASE);
            String n = JUnitVersionHelper.getTestCaseName(test);
            currentTest.setAttribute(ATTR_NAME,
                                     n == null ? UNKNOWN : n);
            
            
            currentTest.setAttribute(ATTR_CLASSNAME,
                    JUnitVersionHelper.getTestCaseClassName(test));
            rootElement.appendChild(currentTest);
            testElements.put(test, currentTest);
        } else {
            currentTest = (Element) testElements.get(test);
        }

        Long l = (Long) testStarts.get(test);
        currentTest.setAttribute(ATTR_TIME,
            """" + ((System.currentTimeMillis() - l.longValue()) / 1000.0));
    }

    
    public void addFailure(Test test, Throwable t) {
        formatError(FAILURE, test, t);
    }

    
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }

    
    public void addError(Test test, Throwable t) {
        formatError(ERROR, test, t);
    }

    private void formatError(String type, Test test, Throwable t) {
        if (test != null) {
            endTest(test);
            failedTests.put(test, test);
        }

        Element nested = doc.createElement(type);
        Element currentTest = null;
        if (test != null) {
            currentTest = (Element) testElements.get(test);
        } else {
            currentTest = rootElement;
        }

        currentTest.appendChild(nested);

        String message = t.getMessage();
        if (message != null && message.length() > 0) {
            nested.setAttribute(ATTR_MESSAGE, t.getMessage());
        }
        nested.setAttribute(ATTR_TYPE, t.getClass().getName());

        String strace = JUnitTestRunner.getFilteredTrace(t);
        Text trace = doc.createTextNode(strace);
        nested.appendChild(trace);
    }

    private void formatOutput(String type, String output) {
        Element nested = doc.createElement(type);
        rootElement.appendChild(nested);
        nested.appendChild(doc.createCDATASection(output));
    }

} 
"
org.apache.tools.ant.taskdefs.optional.net.SetProxy,11,3,0,3,24,17,0,3,10,0.671428571,309,1.0,0,0.787234043,0.545454545,0,0,26.45454545,11,1.9091,0,"
package org.apache.tools.ant.taskdefs.optional.net;

import java.net.Authenticator;
import java.net.PasswordAuthentication;
import java.util.Properties;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.ProxySetup;


public class SetProxy extends Task {

    
    
    protected String proxyHost = null;

    
    protected int proxyPort = 80;

    

    
    private String socksProxyHost = null;

    
    private int socksProxyPort = 1080;


    
    private String nonProxyHosts = null;

    
    private String proxyUser = null;

    
    private String proxyPassword = null;

    
    public void setProxyHost(String hostname) {
        proxyHost = hostname;
    }


    
    public void setProxyPort(int port) {
        proxyPort = port;
    }

    
    public void setSocksProxyHost(String host) {
        this.socksProxyHost = host;
    }


    
    public void setSocksProxyPort(int port) {
        this.socksProxyPort = port;
    }


    
    public void setNonProxyHosts(String nonProxyHosts) {
        this.nonProxyHosts = nonProxyHosts;
    }

    
    public void setProxyUser(String proxyUser) {
        this.proxyUser = proxyUser;
    }

    
    public void setProxyPassword(String proxyPassword) {
        this.proxyPassword = proxyPassword;
    }

    

    public void applyWebProxySettings() {
        boolean settingsChanged = false;
        boolean enablingProxy = false;
        Properties sysprops = System.getProperties();
        if (proxyHost != null) {
            settingsChanged = true;
            if (proxyHost.length() != 0) {
                traceSettingInfo();
                enablingProxy = true;
                sysprops.put(ProxySetup.HTTP_PROXY_HOST, proxyHost);
                String portString = Integer.toString(proxyPort);
                sysprops.put(ProxySetup.HTTP_PROXY_PORT, portString);
                sysprops.put(ProxySetup.HTTPS_PROXY_HOST, proxyHost);
                sysprops.put(ProxySetup.HTTPS_PROXY_PORT, portString);
                sysprops.put(ProxySetup.FTP_PROXY_HOST, proxyHost);
                sysprops.put(ProxySetup.FTP_PROXY_PORT, portString);
                if (nonProxyHosts != null) {
                    sysprops.put(ProxySetup.HTTP_NON_PROXY_HOSTS, nonProxyHosts);
                    sysprops.put(ProxySetup.HTTPS_NON_PROXY_HOSTS, nonProxyHosts);
                    sysprops.put(ProxySetup.FTP_NON_PROXY_HOSTS, nonProxyHosts);
                }
                if (proxyUser != null) {
                    sysprops.put(ProxySetup.HTTP_PROXY_USERNAME, proxyUser);
                    sysprops.put(ProxySetup.HTTP_PROXY_PASSWORD, proxyPassword);
                }
            } else {
                log(""resetting http proxy"", Project.MSG_VERBOSE);
                sysprops.remove(ProxySetup.HTTP_PROXY_HOST);
                sysprops.remove(ProxySetup.HTTP_PROXY_PORT);
                sysprops.remove(ProxySetup.HTTP_PROXY_USERNAME);
                sysprops.remove(ProxySetup.HTTP_PROXY_PASSWORD);
                sysprops.remove(ProxySetup.HTTPS_PROXY_HOST);
                sysprops.remove(ProxySetup.HTTPS_PROXY_PORT);
                sysprops.remove(ProxySetup.FTP_PROXY_HOST);
                sysprops.remove(ProxySetup.FTP_PROXY_PORT);
            }
        }

        
        if (socksProxyHost != null) {
            settingsChanged = true;
            if (socksProxyHost.length() != 0) {
                enablingProxy = true;
                sysprops.put(ProxySetup.SOCKS_PROXY_HOST, socksProxyHost);
                sysprops.put(ProxySetup.SOCKS_PROXY_PORT, Integer.toString(socksProxyPort));
                if (proxyUser != null) {
                    
                    sysprops.put(ProxySetup.SOCKS_PROXY_USERNAME, proxyUser);
                    sysprops.put(ProxySetup.SOCKS_PROXY_PASSWORD, proxyPassword);
                }

            } else {
                log(""resetting socks proxy"", Project.MSG_VERBOSE);
                sysprops.remove(ProxySetup.SOCKS_PROXY_HOST);
                sysprops.remove(ProxySetup.SOCKS_PROXY_PORT);
                sysprops.remove(ProxySetup.SOCKS_PROXY_USERNAME);
                sysprops.remove(ProxySetup.SOCKS_PROXY_PASSWORD);
            }
        }

        if (proxyUser != null) {
            if (enablingProxy) {
                Authenticator.setDefault(new ProxyAuth(proxyUser,
                                                       proxyPassword));
            } else if (settingsChanged) {
                Authenticator.setDefault(new ProxyAuth("""", """"));
            }
        }
    }

    
    private void traceSettingInfo() {
        log(""Setting proxy to ""
                + (proxyHost != null ? proxyHost : ""''"")
                + "":"" + proxyPort,
                Project.MSG_VERBOSE);
    }

    
    public void execute() throws BuildException {
        applyWebProxySettings();
    }

    
    private static final class ProxyAuth extends Authenticator {
        private PasswordAuthentication auth;

        private ProxyAuth(String user, String pass) {
            auth = new PasswordAuthentication(user, pass.toCharArray());
        }

        protected PasswordAuthentication getPasswordAuthentication() {
            return auth;
        }
    }
}

"
org.apache.tools.ant.util.KeepAliveInputStream,2,3,0,1,3,1,1,0,2,2.0,7,0.0,0,0.947368421,0.75,1,1,2.5,1,0.5,0,"
package org.apache.tools.ant.util;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;


public class KeepAliveInputStream extends FilterInputStream {

    
    public KeepAliveInputStream(InputStream in) {
        super(in);
    }

    
    public void close() throws IOException {
        
    }
}
"
org.apache.tools.ant.taskdefs.CallTarget,15,3,0,9,41,0,0,9,15,0.678571429,204,1.0,1,0.725490196,0.225,1,2,12.33333333,2,1.5333,0,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.PropertySet;


public class CallTarget extends Task {

    private Ant callee;
    
    private boolean inheritAll = true;
    
    private boolean inheritRefs = false;

    private boolean targetSet = false;

    
    public void setInheritAll(boolean inherit) {
       inheritAll = inherit;
    }

    
    public void setInheritRefs(boolean inheritRefs) {
        this.inheritRefs = inheritRefs;
    }

    
    public void init() {
        callee = new Ant(this);
        callee.init();
    }

    
    public void execute() throws BuildException {
        if (callee == null) {
            init();
        }
        if (!targetSet) {
            throw new BuildException(
                ""Attribute target or at least one nested target is required."",
                 getLocation());
        }
        callee.setAntfile(getProject().getProperty(""ant.file""));
        callee.setInheritAll(inheritAll);
        callee.setInheritRefs(inheritRefs);
        callee.execute();
    }

    
    public Property createParam() {
        if (callee == null) {
            init();
        }
        return callee.createProperty();
    }

    
    public void addReference(Ant.Reference r) {
        if (callee == null) {
            init();
        }
        callee.addReference(r);
    }

    
    public void addPropertyset(PropertySet ps) {
        if (callee == null) {
            init();
        }
        callee.addPropertyset(ps);
    }

    
    public void setTarget(String target) {
        if (callee == null) {
            init();
        }
        callee.setTarget(target);
        targetSet = true;
    }

    
    public void addConfiguredTarget(Ant.TargetElement t) {
        if (callee == null) {
            init();
        }
        callee.addConfiguredTarget(t);
        targetSet = true;
    }

    
    public void handleOutput(String output) {
        if (callee != null) {
            callee.handleOutput(output);
        } else {
            super.handleOutput(output);
        }
    }

    
    public int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        if (callee != null) {
            return callee.handleInput(buffer, offset, length);
        }
        return super.handleInput(buffer, offset, length);
    }

    
    public void handleFlush(String output) {
        if (callee != null) {
            callee.handleFlush(output);
        } else {
            super.handleFlush(output);
        }
    }

    
    public void handleErrorOutput(String output) {
        if (callee != null) {
            callee.handleErrorOutput(output);
        } else {
            super.handleErrorOutput(output);
        }
    }

    
    public void handleErrorFlush(String output) {
        if (callee != null) {
            callee.handleErrorFlush(output);
        } else {
            super.handleErrorFlush(output);
        }
    }
}
"
org.apache.tools.ant.taskdefs.DefBase,14,4,3,11,29,85,3,8,11,0.576923077,108,1.0,1,0.759259259,0.321428571,0,0,6.571428571,4,1.2857,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.ClasspathUtils;


public abstract class DefBase extends AntlibDefinition {
    private ClassLoader createdLoader;
    private ClasspathUtils.Delegate cpDelegate;

    
    protected boolean hasCpDelegate() {
        return cpDelegate != null;
    }

    
    public void setReverseLoader(boolean reverseLoader) {
        getDelegate().setReverseLoader(reverseLoader);
        log(""The reverseloader attribute is DEPRECATED. It will be removed"",
            Project.MSG_WARN);
    }

    
    public Path getClasspath() {
        return getDelegate().getClasspath();
    }

    
    public boolean isReverseLoader() {
        return getDelegate().isReverseLoader();
    }

    
    public String getLoaderId() {
        return getDelegate().getClassLoadId();
    }

    
    public String getClasspathId() {
        return getDelegate().getClassLoadId();
    }

    
    public void setClasspath(Path classpath) {
        getDelegate().setClasspath(classpath);
    }

    
    public Path createClasspath() {
        return getDelegate().createClasspath();
    }

    
    public void setClasspathRef(Reference r) {
        getDelegate().setClasspathref(r);
    }

    
    public void setLoaderRef(Reference r) {
        getDelegate().setLoaderRef(r);
    }

    
    protected ClassLoader createLoader() {
        if (getAntlibClassLoader() != null && cpDelegate == null) {
            return getAntlibClassLoader();
        }
        if (createdLoader == null) {
            createdLoader = getDelegate().getClassLoader();
            
            
            
            ((AntClassLoader) createdLoader)
                .addSystemPackageRoot(""org.apache.tools.ant"");
        }
        return createdLoader;
    }

    
    public void init() throws BuildException {
        super.init();
    }

    private ClasspathUtils.Delegate getDelegate() {
        if (cpDelegate == null) {
            cpDelegate = ClasspathUtils.getDelegate(this);
        }
        return cpDelegate;
    }
}
"
org.apache.tools.zip.ZipOutputStream,27,3,0,8,101,157,5,3,15,0.824786325,1286,0.888888889,1,0.294117647,0.183760684,1,7,45.62962963,4,1.1111,1,"

package org.apache.tools.zip;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.Hashtable;
import java.util.Vector;
import java.util.zip.CRC32;
import java.util.zip.Deflater;
import java.util.zip.ZipException;


public class ZipOutputStream extends FilterOutputStream {

    
    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;

    
    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;

    
    public static final int STORED = java.util.zip.ZipEntry.STORED;

    
    private ZipEntry entry;

    
    private String comment = """";

    
    private int level = DEFAULT_COMPRESSION;

    
    private boolean hasCompressionLevelChanged = false;

    
    private int method = java.util.zip.ZipEntry.DEFLATED;

    
    private Vector entries = new Vector();

    
    private CRC32 crc = new CRC32();

    
    private long written = 0;

    
    private long dataStart = 0;

    
    private long localDataStart = 0;

    
    private long cdOffset = 0;

    
    private long cdLength = 0;

    
    private static final byte[] ZERO = {0, 0};

    
    private static final byte[] LZERO = {0, 0, 0, 0};

    
    private Hashtable offsets = new Hashtable();

    
    private String encoding = null;

    

    
    protected Deflater def = new Deflater(level, true);

    
    protected byte[] buf = new byte[512];

    

    
    private RandomAccessFile raf = null;

    
    public ZipOutputStream(OutputStream out) {
        super(out);
    }

    
    public ZipOutputStream(File file) throws IOException {
        super(null);

        try {
            raf = new RandomAccessFile(file, ""rw"");
            raf.setLength(0);
        } catch (IOException e) {
            if (raf != null) {
                try {
                    raf.close();
                } catch (IOException inner) {
                    
                }
                raf = null;
            }
            out = new FileOutputStream(file);
        }
    }

    
    public boolean isSeekable() {
        return raf != null;
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public String getEncoding() {
        return encoding;
    }

    
    public void finish() throws IOException {
        closeEntry();
        cdOffset = written;
        for (int i = 0, entriesSize = entries.size(); i < entriesSize; i++) {
            writeCentralFileHeader((ZipEntry) entries.elementAt(i));
        }
        cdLength = written - cdOffset;
        writeCentralDirectoryEnd();
        offsets.clear();
        entries.removeAllElements();
    }

    
    public void closeEntry() throws IOException {
        if (entry == null) {
            return;
        }

        long realCrc = crc.getValue();
        crc.reset();

        if (entry.getMethod() == DEFLATED) {
            def.finish();
            while (!def.finished()) {
                deflate();
            }

            entry.setSize(adjustToLong(def.getTotalIn()));
            entry.setCompressedSize(adjustToLong(def.getTotalOut()));
            entry.setCrc(realCrc);

            def.reset();

            written += entry.getCompressedSize();
        } else if (raf == null) {
            if (entry.getCrc() != realCrc) {
                throw new ZipException(""bad CRC checksum for entry ""
                                       + entry.getName() + "": ""
                                       + Long.toHexString(entry.getCrc())
                                       + "" instead of ""
                                       + Long.toHexString(realCrc));
            }

            if (entry.getSize() != written - dataStart) {
                throw new ZipException(""bad size for entry ""
                                       + entry.getName() + "": ""
                                       + entry.getSize()
                                       + "" instead of ""
                                       + (written - dataStart));
            }
        } else { 
            long size = written - dataStart;

            entry.setSize(size);
            entry.setCompressedSize(size);
            entry.setCrc(realCrc);
        }

        
        
        if (raf != null) {
            long save = raf.getFilePointer();

            raf.seek(localDataStart);
            writeOut(ZipLong.getBytes(entry.getCrc()));
            writeOut(ZipLong.getBytes(entry.getCompressedSize()));
            writeOut(ZipLong.getBytes(entry.getSize()));
            raf.seek(save);
        }

        writeDataDescriptor(entry);
        entry = null;
    }

    
    public void putNextEntry(ZipEntry ze) throws IOException {
        closeEntry();

        entry = ze;
        entries.addElement(entry);

        if (entry.getMethod() == -1) { 
            entry.setMethod(method);
        }

        if (entry.getTime() == -1) { 
            entry.setTime(System.currentTimeMillis());
        }

        
        if (entry.getMethod() == STORED && raf == null) {
            if (entry.getSize() == -1) {
                throw new ZipException(""uncompressed size is required for""
                                       + "" STORED method when not writing to a""
                                       + "" file"");
            }
            if (entry.getCrc() == -1) {
                throw new ZipException(""crc checksum is required for STORED""
                                       + "" method when not writing to a file"");
            }
            entry.setCompressedSize(entry.getSize());
        }

        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {
            def.setLevel(level);
            hasCompressionLevelChanged = false;
        }
        writeLocalFileHeader(entry);
    }

    
    public void setComment(String comment) {
        this.comment = comment;
    }

    
    public void setLevel(int level) {
        if (level < Deflater.DEFAULT_COMPRESSION
            || level > Deflater.BEST_COMPRESSION) {
            throw new IllegalArgumentException(
                ""Invalid compression level: "" + level);
        }
        hasCompressionLevelChanged = (this.level != level);
        this.level = level;
    }

    
    public void setMethod(int method) {
        this.method = method;
    }

    
    public void write(byte[] b, int offset, int length) throws IOException {
        if (entry.getMethod() == DEFLATED) {
            if (length > 0) {
                if (!def.finished()) {
                    def.setInput(b, offset, length);
                    while (!def.needsInput()) {
                        deflate();
                    }
                }
            }
        } else {
            writeOut(b, offset, length);
            written += length;
        }
        crc.update(b, offset, length);
    }

    
    public void write(int b) throws IOException {
        byte[] buff = new byte[1];
        buff[0] = (byte) (b & 0xff);
        write(buff, 0, 1);
    }

    
    public void close() throws IOException {
        finish();

        if (raf != null) {
            raf.close();
        }
        if (out != null) {
            out.close();
        }
    }

    
    public void flush() throws IOException {
        if (out != null) {
            out.flush();
        }
    }

    
    
    protected static final byte[] LFH_SIG = ZipLong.getBytes(0X04034B50L);
    
    protected static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);
    
    protected static final byte[] CFH_SIG = ZipLong.getBytes(0X02014B50L);
    
    protected static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);

    
    protected final void deflate() throws IOException {
        int len = def.deflate(buf, 0, buf.length);
        if (len > 0) {
            writeOut(buf, 0, len);
        }
    }

    
    protected void writeLocalFileHeader(ZipEntry ze) throws IOException {
        offsets.put(ze, ZipLong.getBytes(written));

        writeOut(LFH_SIG);
        written += 4;

        
        final int zipMethod = ze.getMethod();

        
        
        if (zipMethod == DEFLATED && raf == null) {
            
            
            writeOut(ZipShort.getBytes(20));

            
            writeOut(ZipShort.getBytes(8));
        } else {
            writeOut(ZipShort.getBytes(10));
            writeOut(ZERO);
        }
        written += 4;

        
        writeOut(ZipShort.getBytes(zipMethod));
        written += 2;

        
        writeOut(toDosTime(ze.getTime()));
        written += 4;

        
        
        
        localDataStart = written;
        if (zipMethod == DEFLATED || raf != null) {
            writeOut(LZERO);
            writeOut(LZERO);
            writeOut(LZERO);
        } else {
            writeOut(ZipLong.getBytes(ze.getCrc()));
            writeOut(ZipLong.getBytes(ze.getSize()));
            writeOut(ZipLong.getBytes(ze.getSize()));
        }
        written += 12;

        
        byte[] name = getBytes(ze.getName());
        writeOut(ZipShort.getBytes(name.length));
        written += 2;

        
        byte[] extra = ze.getLocalFileDataExtra();
        writeOut(ZipShort.getBytes(extra.length));
        written += 2;

        
        writeOut(name);
        written += name.length;

        
        writeOut(extra);
        written += extra.length;

        dataStart = written;
    }

    
    protected void writeDataDescriptor(ZipEntry ze) throws IOException {
        if (ze.getMethod() != DEFLATED || raf != null) {
            return;
        }
        writeOut(DD_SIG);
        writeOut(ZipLong.getBytes(entry.getCrc()));
        writeOut(ZipLong.getBytes(entry.getCompressedSize()));
        writeOut(ZipLong.getBytes(entry.getSize()));
        written += 16;
    }

    
    protected void writeCentralFileHeader(ZipEntry ze) throws IOException {
        writeOut(CFH_SIG);
        written += 4;

        
        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));
        written += 2;

        
        
        if (ze.getMethod() == DEFLATED && raf == null) {
            
            
            writeOut(ZipShort.getBytes(20));

            
            writeOut(ZipShort.getBytes(8));
        } else {
            writeOut(ZipShort.getBytes(10));
            writeOut(ZERO);
        }
        written += 4;

        
        writeOut(ZipShort.getBytes(ze.getMethod()));
        written += 2;

        
        writeOut(toDosTime(ze.getTime()));
        written += 4;

        
        
        
        writeOut(ZipLong.getBytes(ze.getCrc()));
        writeOut(ZipLong.getBytes(ze.getCompressedSize()));
        writeOut(ZipLong.getBytes(ze.getSize()));
        written += 12;

        
        byte[] name = getBytes(ze.getName());
        writeOut(ZipShort.getBytes(name.length));
        written += 2;

        
        byte[] extra = ze.getCentralDirectoryExtra();
        writeOut(ZipShort.getBytes(extra.length));
        written += 2;

        
        String comm = ze.getComment();
        if (comm == null) {
            comm = """";
        }
        byte[] commentB = getBytes(comm);
        writeOut(ZipShort.getBytes(commentB.length));
        written += 2;

        
        writeOut(ZERO);
        written += 2;

        
        writeOut(ZipShort.getBytes(ze.getInternalAttributes()));
        written += 2;

        
        writeOut(ZipLong.getBytes(ze.getExternalAttributes()));
        written += 4;

        
        writeOut((byte[]) offsets.get(ze));
        written += 4;

        
        writeOut(name);
        written += name.length;

        
        writeOut(extra);
        written += extra.length;

        
        writeOut(commentB);
        written += commentB.length;
    }

    
    protected void writeCentralDirectoryEnd() throws IOException {
        writeOut(EOCD_SIG);

        
        writeOut(ZERO);
        writeOut(ZERO);

        
        byte[] num = ZipShort.getBytes(entries.size());
        writeOut(num);
        writeOut(num);

        
        writeOut(ZipLong.getBytes(cdLength));
        writeOut(ZipLong.getBytes(cdOffset));

        
        byte[] data = getBytes(comment);
        writeOut(ZipShort.getBytes(data.length));
        writeOut(data);
    }

    
    private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);

    
    protected static ZipLong toDosTime(Date time) {
        return new ZipLong(toDosTime(time.getTime()));
    }

    
    protected static byte[] toDosTime(long t) {
        Date time = new Date(t);
        int year = time.getYear() + 1900;
        if (year < 1980) {
            return DOS_TIME_MIN;
        }
        int month = time.getMonth() + 1;
        long value =  ((year - 1980) << 25)
            |         (month << 21)
            |         (time.getDate() << 16)
            |         (time.getHours() << 11)
            |         (time.getMinutes() << 5)
            |         (time.getSeconds() >> 1);
        return ZipLong.getBytes(value);
    }

    
    protected byte[] getBytes(String name) throws ZipException {
        if (encoding == null) {
            return name.getBytes();
        } else {
            try {
                return name.getBytes(encoding);
            } catch (UnsupportedEncodingException uee) {
                throw new ZipException(uee.getMessage());
            }
        }
    }

    
    protected final void writeOut(byte[] data) throws IOException {
        writeOut(data, 0, data.length);
    }

    
    protected final void writeOut(byte[] data, int offset, int length)
        throws IOException {
        if (raf != null) {
            raf.write(data, offset, length);
        } else {
            out.write(data, offset, length);
        }
    }

    
    protected static long adjustToLong(int i) {
        if (i < 0) {
            return 2 * ((long) Integer.MAX_VALUE) + 2 + i;
        } else {
            return i;
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Label,5,4,0,8,23,4,4,8,5,0.75,249,1.0,0,0.927272727,0.8,2,2,48.2,1,0.8,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.StringUtils;


public class P4Label extends P4Base {

    
    protected String name;
    protected String desc;
    protected String lock;
    

    
    public void setName(String name) {
        this.name = name;
    }

    
    public void setDesc(String desc) {
        this.desc = desc;
    }

    
    public void setLock(String lock) {
        this.lock = lock;
    }

    
    public void execute() throws BuildException {
        log(""P4Label exec:"", Project.MSG_INFO);

        if (P4View == null || P4View.length() < 1) {
            log(""View not set, assuming 
            P4View = ""
        } else {
            P4View = StringUtils.replace(P4View, "":"", ""\n\t"");
            P4View = StringUtils.replace(P4View, "";"", ""\n\t"");
        }

        if (desc == null || desc.length() < 1) {
            log(""Label Description not set, assuming 'AntLabel'"",
                Project.MSG_WARN);
            desc = ""AntLabel"";
        }

        if (lock != null && !lock.equalsIgnoreCase(""locked"")) {
            log(""lock attribute invalid - ignoring"", Project.MSG_WARN);
        }

        if (name == null || name.length() < 1) {
            SimpleDateFormat formatter
                = new SimpleDateFormat(""yyyy.MM.dd-hh:mm"");
            Date now = new Date();
            name = ""AntLabel-"" + formatter.format(now);
            log(""name not set, assuming '"" + name + ""'"", Project.MSG_WARN);
        }


        
        String newLabel =
                ""Label: "" + name
                + ""\nDescription: "" + desc
                + ""\nOptions: unlocked""
                + ""\nView: \n\t"" + P4View;

        P4Handler handler = new P4HandlerAdapter() {
            public void process(String line) {
                log(line, Project.MSG_VERBOSE);
            }
        };

        handler.setOutput(newLabel);

        execP4Command(""label -i"", handler);

        execP4Command(""labelsync -l "" + name, new P4HandlerAdapter() {
            public void process(String line) {
                log(line, Project.MSG_VERBOSE);
            }
        });


        log(""Created Label "" + name + "" ("" + desc + "") with view:\n"" + P4View,
            Project.MSG_INFO);

        
        if (lock != null && lock.equalsIgnoreCase(""locked"")) {

            log(""Modifying lock status to 'locked'"", Project.MSG_INFO);

            final StringBuffer labelSpec = new StringBuffer();

            
            
            

            handler = new P4HandlerAdapter() {
                public void process(String line) {
                    log(line, Project.MSG_VERBOSE);

                    if (util.match(""/^Options:/"", line)) {
                        line = ""Options: "" + lock;
                    }

                    labelSpec.append(line + ""\n"");
                }
            };


            execP4Command(""label -o "" + name, handler);
            log(labelSpec.toString(), Project.MSG_DEBUG);

            log(""Now locking label..."", Project.MSG_VERBOSE);
            handler = new P4HandlerAdapter() {
                public void process(String line) {
                    log(line, Project.MSG_VERBOSE);
                }
            };

            handler.setOutput(labelSpec.toString());
            execP4Command(""label -i"", handler);
        }
    }
}
"
org.apache.tools.ant.taskdefs.XSLTLiaison,3,1,0,2,3,3,2,0,3,1.5,4,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;


public interface XSLTLiaison {

    
    String FILE_PROTOCOL_PREFIX = ""file:

    
    void setStylesheet(File stylesheet) throws Exception;

    
    void addParam(String name, String expression) throws Exception;

    
    void transform(File infile, File outfile) throws Exception;

} 
"
org.apache.tools.ant.types.resources.BCFileSet,4,5,0,5,19,6,0,5,4,2.0,57,0.0,0,0.978494624,0.625,2,4,13.25,2,1.0,0,"
package org.apache.tools.ant.types.resources;

import java.util.Iterator;

import org.apache.tools.ant.types.FileSet;


public class BCFileSet extends FileSet {
    
    public BCFileSet() {
    }

    
    public BCFileSet(FileSet fs) {
        super(fs);
    }

    
    public Iterator iterator() {
        if (isReference()) {
            return ((FileSet) getRef(getProject())).iterator();
        }
        FileResourceIterator result = new FileResourceIterator(getDir());
        result.addFiles(getDirectoryScanner().getIncludedFiles());
        result.addFiles(getDirectoryScanner().getIncludedDirectories());
        return result;
    }

    
    public int size() {
        if (isReference()) {
            return ((FileSet) getRef(getProject())).size();
        }
        return getDirectoryScanner().getIncludedFilesCount()
            + getDirectoryScanner().getIncludedDirsCount();
    }

}
"
org.apache.tools.ant.taskdefs.optional.extension.ExtraAttribute,6,1,0,2,11,3,1,1,4,0.6,53,1.0,0,0.0,0.666666667,0,0,7.5,1,0.8333,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import org.apache.tools.ant.BuildException;


public class ExtraAttribute {
    private String name;
    private String value;

    
    public void setName(final String name) {
        this.name = name;
    }

    
    public void setValue(final String value) {
        this.value = value;
    }

    
    String getName() {
        return name;
    }

    
    String getValue() {
        return value;
    }

    
    public void validate() throws BuildException {
        if (null == name) {
            final String message = ""Missing name from parameter."";
            throw new BuildException(message);
        } else if (null == value) {
            final String message = ""Missing value from parameter "" + name + ""."";
            throw new BuildException(message);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSS,55,3,8,20,106,1313,8,12,9,0.956552707,1133,1.0,2,0.406593407,0.195454545,0,0,19.12727273,10,1.8545,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.types.EnumeratedAttribute;
import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.util.FileUtils;


public abstract class MSVSS extends Task implements MSVSSConstants {

    private String ssDir = null;
    private String vssLogin = null;
    private String vssPath = null;
    private String serverPath = null;

    
    private String version = null;
    
    private String date = null;
    
    private String label = null;
    
    private String autoResponse = null;
    
    private String localPath = null;
    
    private String comment = null;
    
    private String fromLabel = null;
    
    private String toLabel = null;
    
    private String outputFileName = null;
    
    private String user = null;
    
    private String fromDate = null;
    
    private String toDate = null;
    
    private String style = null;
    
    private boolean quiet = false;
    
    private boolean recursive = false;
    
    private boolean writable = false;
    
    private boolean failOnError = true;
    
    private boolean getLocalCopy = true;
    
    private int numDays = Integer.MIN_VALUE;
    
    private DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT);
    
    private CurrentModUpdated timestamp = null;
    
    private WritableFiles writableFiles = null;

    
    abstract Commandline buildCmdLine();

    
    public final void setSsdir(String dir) {
        this.ssDir = FileUtils.translatePath(dir);
    }

    
    public final void setLogin(final String vssLogin) {
        this.vssLogin = vssLogin;
    }

    
    public final void setVsspath(final String vssPath) {
        String projectPath;
        if (vssPath.startsWith(""vss:
            projectPath = vssPath.substring(5);
        } else {
            projectPath = vssPath;
        }

        if (projectPath.startsWith(PROJECT_PREFIX)) {
            this.vssPath = projectPath;
        } else {
            this.vssPath = PROJECT_PREFIX + projectPath;
        }
    }

    
    public final void setServerpath(final String serverPath) {
        this.serverPath = serverPath;
    }

    
    public final void setFailOnError(final boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    public void execute() throws BuildException {
        int result = 0;
        Commandline commandLine = buildCmdLine();
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnError()) {
            String msg = ""Failed executing: "" + formatCommandLine(commandLine)
                     + "" With a return code of "" + result;
            throw new BuildException(msg, getLocation());
        }
    }

    

    
    protected void setInternalComment(final String comment) {
        this.comment = comment;
    }

    
    protected void setInternalAutoResponse(final String autoResponse) {
        this.autoResponse = autoResponse;
    }

    
    protected void setInternalDate(final String date) {
        this.date = date;
    }

    
    protected void setInternalDateFormat(final DateFormat dateFormat) {
        this.dateFormat = dateFormat;
    }

    
    protected void setInternalFailOnError(final boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    protected void setInternalFromDate(final String fromDate) {
        this.fromDate = fromDate;
    }

    
    protected void setInternalFromLabel(final String fromLabel) {
        this.fromLabel = fromLabel;
    }

    
    protected void setInternalLabel(final String label) {
        this.label = label;
    }

    
    protected void setInternalLocalPath(final String localPath) {
        this.localPath = localPath;
    }

    
    protected void setInternalNumDays(final int numDays) {
        this.numDays = numDays;
    }

    
    protected void setInternalOutputFilename(final String outputFileName) {
        this.outputFileName = outputFileName;
    }

    
    protected void setInternalQuiet(final boolean quiet) {
        this.quiet = quiet;
    }

    
    protected void setInternalRecursive(final boolean recursive) {
        this.recursive = recursive;
    }

    
    protected void setInternalStyle(final String style) {
        this.style = style;
    }

    
    protected void setInternalToDate(final String toDate) {
        this.toDate = toDate;
    }

    
    protected void setInternalToLabel(final String toLabel) {
        this.toLabel = toLabel;
    }

    
    protected void setInternalUser(final String user) {
        this.user = user;
    }

    
    protected void setInternalVersion(final String version) {
        this.version = version;
    }

    
    protected void setInternalWritable(final boolean writable) {
        this.writable = writable;
    }

    
    protected void setInternalFileTimeStamp(final CurrentModUpdated timestamp) {
        this.timestamp = timestamp;
    }

    
    protected void setInternalWritableFiles(final WritableFiles writableFiles) {
        this.writableFiles = writableFiles;
    }

    
    protected void setInternalGetLocalCopy(final boolean getLocalCopy) {
        this.getLocalCopy = getLocalCopy;
    }

    
    protected String getSSCommand() {
        if (ssDir == null) {
            return SS_EXE;
        }
        return ssDir.endsWith(File.separator) ? ssDir + SS_EXE : ssDir
                 + File.separator + SS_EXE;
    }

    
    protected String getVsspath() {
        return vssPath;
    }

    
    protected String getQuiet() {
        return quiet ? FLAG_QUIET : """";
    }

    
    protected String getRecursive() {
        return recursive ? FLAG_RECURSION : """";
    }

    
    protected String getWritable() {
        return writable ? FLAG_WRITABLE : """";
    }

    
    protected String getLabel() {
        String shortLabel = """";
        if (label != null && label.length() > 0) {
                shortLabel = FLAG_LABEL + getShortLabel();
        }
        return shortLabel;
    }
    
    private String getShortLabel() {
        String shortLabel;
        if (label !=  null && label.length() > 31) {
            shortLabel = this.label.substring(0, 30);
            log(""Label is longer than 31 characters, truncated to: "" + shortLabel,
                Project.MSG_WARN);
        } else {
            shortLabel = label;
        }
        return shortLabel;
    }
    
    protected String getStyle() {
        return style != null ? style : """";
    }

    
    protected String getVersionDateLabel() {
        String versionDateLabel = """";
        if (version != null) {
            versionDateLabel = FLAG_VERSION + version;
        } else if (date != null) {
            versionDateLabel = FLAG_VERSION_DATE + date;
        } else {
            
            
            String shortLabel = getShortLabel();
            if (shortLabel != null && !shortLabel.equals("""")) {
                versionDateLabel = FLAG_VERSION_LABEL + shortLabel;
            }
        }
        return versionDateLabel;
    }

    
    protected String getVersion() {
        return version != null ? FLAG_VERSION + version : """";
    }

    
    protected String getLocalpath() {
        String lclPath = """"; 
        if (localPath != null) {
            
            File dir = getProject().resolveFile(localPath);
            if (!dir.exists()) {
                boolean done = dir.mkdirs();
                if (!done) {
                    String msg = ""Directory "" + localPath + "" creation was not ""
                            + ""successful for an unknown reason"";
                    throw new BuildException(msg, getLocation());
                }
                getProject().log(""Created dir: "" + dir.getAbsolutePath());
            }
            lclPath = FLAG_OVERRIDE_WORKING_DIR + localPath;
        }
        return lclPath;
    }

    
    protected String getComment() {
        return comment != null ? FLAG_COMMENT + comment : FLAG_COMMENT + ""-"";
    }

    
    protected String getAutoresponse() {
        if (autoResponse == null) {
            return FLAG_AUTORESPONSE_DEF;
        } else if (autoResponse.equalsIgnoreCase(""Y"")) {
            return FLAG_AUTORESPONSE_YES;
        } else if (autoResponse.equalsIgnoreCase(""N"")) {
            return FLAG_AUTORESPONSE_NO;
        } else {
            return FLAG_AUTORESPONSE_DEF;
        }
    }

    
    protected String getLogin() {
        return vssLogin != null ? FLAG_LOGIN + vssLogin : """";
    }

    
    protected String getOutput() {
        return outputFileName != null ? FLAG_OUTPUT + outputFileName : """";
    }

    
    protected String getUser() {
        return user != null ? FLAG_USER + user : """";
    }

    
    protected String getVersionLabel() {
        if (fromLabel == null && toLabel == null) {
            return """";
        }
        if (fromLabel != null && toLabel != null) {
            if (fromLabel.length() > 31) {
                fromLabel = fromLabel.substring(0, 30);
                log(""FromLabel is longer than 31 characters, truncated to: ""
                    + fromLabel, Project.MSG_WARN);
            }
            if (toLabel.length() > 31) {
                toLabel = toLabel.substring(0, 30);
                log(""ToLabel is longer than 31 characters, truncated to: ""
                    + toLabel, Project.MSG_WARN);
            }
            return FLAG_VERSION_LABEL + toLabel + VALUE_FROMLABEL + fromLabel;
        } else if (fromLabel != null) {
            if (fromLabel.length() > 31) {
                fromLabel = fromLabel.substring(0, 30);
                log(""FromLabel is longer than 31 characters, truncated to: ""
                    + fromLabel, Project.MSG_WARN);
            }
            return FLAG_VERSION + VALUE_FROMLABEL + fromLabel;
        } else {
            if (toLabel.length() > 31) {
                toLabel = toLabel.substring(0, 30);
                log(""ToLabel is longer than 31 characters, truncated to: ""
                    + toLabel, Project.MSG_WARN);
            }
            return FLAG_VERSION_LABEL + toLabel;
        }
    }

    
    protected String getVersionDate() throws BuildException {
        if (fromDate == null && toDate == null
            && numDays == Integer.MIN_VALUE) {
            return """";
        }
        if (fromDate != null && toDate != null) {
            return FLAG_VERSION_DATE + toDate + VALUE_FROMDATE + fromDate;
        } else if (toDate != null && numDays != Integer.MIN_VALUE) {
            try {
                return FLAG_VERSION_DATE + toDate + VALUE_FROMDATE
                        + calcDate(toDate, numDays);
            } catch (ParseException ex) {
                String msg = ""Error parsing date: "" + toDate;
                throw new BuildException(msg, getLocation());
            }
        } else if (fromDate != null && numDays != Integer.MIN_VALUE) {
            try {
                return FLAG_VERSION_DATE + calcDate(fromDate, numDays)
                        + VALUE_FROMDATE + fromDate;
            } catch (ParseException ex) {
                String msg = ""Error parsing date: "" + fromDate;
                throw new BuildException(msg, getLocation());
            }
        } else {
            return fromDate != null ? FLAG_VERSION + VALUE_FROMDATE
                    + fromDate : FLAG_VERSION_DATE + toDate;
        }
    }

    
    protected String getGetLocalCopy() {
        return (!getLocalCopy) ? FLAG_NO_GET : """";
    }

    
    private boolean getFailOnError() {
        return getWritableFiles().equals(WRITABLE_SKIP) ? false : failOnError;
    }


    
    public String getFileTimeStamp() {
        if (timestamp == null) {
            return """";
        } else if (timestamp.getValue().equals(TIME_MODIFIED)) {
            return FLAG_FILETIME_MODIFIED;
        } else if (timestamp.getValue().equals(TIME_UPDATED)) {
            return FLAG_FILETIME_UPDATED;
        } else {
            return FLAG_FILETIME_DEF;
        }
    }


    
    public String getWritableFiles() {
        if (writableFiles == null) {
            return """";
        } else if (writableFiles.getValue().equals(WRITABLE_REPLACE)) {
            return FLAG_REPLACE_WRITABLE;
        } else if (writableFiles.getValue().equals(WRITABLE_SKIP)) {
            
            
            failOnError = false;
            return FLAG_SKIP_WRITABLE;
        } else {
            return """";
        }
    }

    
    private int run(Commandline cmd) {
        try {
            Execute exe = new Execute(new LogStreamHandler(this,
                    Project.MSG_INFO,
                    Project.MSG_WARN));

            
            
            if (serverPath != null) {
                String[] env = exe.getEnvironment();
                if (env == null) {
                    env = new String[0];
                }
                String[] newEnv = new String[env.length + 1];
                System.arraycopy(env, 0, newEnv, 0, env.length);
                newEnv[env.length] = ""SSDIR="" + serverPath;

                exe.setEnvironment(newEnv);
            }

            exe.setAntRun(getProject());
            exe.setWorkingDirectory(getProject().getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            
            exe.setVMLauncher(false);
            return exe.execute();
        } catch (IOException e) {
            throw new BuildException(e, getLocation());
        }
    }

     
    private String calcDate(String startDate, int daysToAdd) throws ParseException {
        Calendar calendar = new GregorianCalendar();
        Date currentDate = dateFormat.parse(startDate);
        calendar.setTime(currentDate);
        calendar.add(Calendar.DATE, daysToAdd);
        return dateFormat.format(calendar.getTime());
    }

    
    private String formatCommandLine(Commandline cmd) {
        StringBuffer sBuff = new StringBuffer(cmd.toString());
        int indexUser = sBuff.substring(0).indexOf(FLAG_LOGIN);
        if (indexUser > 0) {
            int indexPass = sBuff.substring(0).indexOf("","", indexUser);
            int indexAfterPass = sBuff.substring(0).indexOf("" "", indexPass);

            for (int i = indexPass + 1; i < indexAfterPass; i++) {
                sBuff.setCharAt(i, '*');
            }
        }
        return sBuff.toString();
    }

    
    public static class CurrentModUpdated extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {TIME_CURRENT, TIME_MODIFIED, TIME_UPDATED};
        }
    }

    
    public static class WritableFiles extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {WRITABLE_REPLACE, WRITABLE_SKIP, WRITABLE_FAIL};
        }
    }
}
"
org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp,3,2,0,4,19,3,0,4,2,2.0,136,0.0,0,0.8,0.666666667,0,0,44.33333333,2,1.0,0,"
package org.apache.tools.ant.util.regexp;


import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.tools.ant.BuildException;



public class Jdk14RegexpRegexp extends Jdk14RegexpMatcher implements Regexp {

    
    public Jdk14RegexpRegexp() {
        super();
    }

    
    protected int getSubsOptions(int options) {
        int subsOptions = REPLACE_FIRST;
        if (RegexpUtil.hasFlag(options, REPLACE_ALL)) {
            subsOptions = REPLACE_ALL;
        }
        return subsOptions;
    }

    
    public String substitute(String input, String argument, int options)
        throws BuildException {
        
        StringBuffer subst = new StringBuffer();
        for (int i = 0; i < argument.length(); i++) {
            char c = argument.charAt(i);
            if (c == '$') {
                subst.append('\\');
                subst.append('$');
            } else if (c == '\\') {
                if (++i < argument.length()) {
                    c = argument.charAt(i);
                    int value = Character.digit(c, 10);
                    if (value > -1) {
                        subst.append(""$"").append(value);
                    } else {
                        subst.append(c);
                    }
                } else {
                    
                    subst.append('\\');
                }
            } else {
                subst.append(c);
            }
        }
        argument = subst.toString();

        int sOptions = getSubsOptions(options);
        Pattern p = getCompiledPattern(options);
        StringBuffer sb = new StringBuffer();

        Matcher m = p.matcher(input);
        if (RegexpUtil.hasFlag(sOptions, REPLACE_ALL)) {
            sb.append(m.replaceAll(argument));
        } else {
            boolean res = m.find();
            if (res) {
                m.appendReplacement(sb, argument);
                m.appendTail(sb);
            } else {
                sb.append(input);
            }
        }

        return sb.toString();
    }
}
"
org.apache.tools.ant.taskdefs.condition.AntVersion,8,1,0,4,22,0,0,4,6,0.428571429,169,1.0,0,0.0,0.625,0,0,19.875,7,1.625,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.DeweyDecimal;


public class AntVersion implements Condition {

    private String atLeast = null;
    private String exactly = null;

    
    public boolean eval() throws BuildException {
        validate();
        DeweyDecimal actual = getVersion();
        if (null != atLeast) {
            return actual.isGreaterThanOrEqual(new DeweyDecimal(atLeast));
        }
        if (null != exactly) {
            return actual.isEqual(new DeweyDecimal(exactly));
        }
        
        return false;
    }

    private void validate() throws BuildException {
        if (atLeast != null && exactly != null) {
            throw new BuildException(""Only one of atleast or exactly may be set."");
        }
        if (null == atLeast && null == exactly) {
            throw new BuildException(""One of atleast or exactly must be set."");
        }
        try {
            if (atLeast != null) {
                new DeweyDecimal(atLeast);
            } else {
                new DeweyDecimal(exactly);
            }
        } catch (NumberFormatException e) {
            throw new BuildException(""The argument is not a Dewey Decimal eg 1.1.0"");
        }
    }

    private DeweyDecimal getVersion() {
        Project p = new Project();
        p.init();
        char[] versionString = p.getProperty(""ant.version"").toCharArray();
        StringBuffer sb = new StringBuffer();
        boolean foundFirstDigit = false;
        for (int i = 0; i < versionString.length; i++) {
            if (Character.isDigit(versionString[i])) {
                sb.append(versionString[i]);
                foundFirstDigit = true;
            }
            if (versionString[i] == '.' && foundFirstDigit) {
                sb.append(versionString[i]);
            }
            if (Character.isLetter(versionString[i]) && foundFirstDigit) {
                break;
            }
        }
        return new DeweyDecimal(sb.toString());
    }

    
    public String getAtLeast() {
        return atLeast;
    }

    
    public void setAtLeast(String atLeast) {
        this.atLeast = atLeast;
    }

    
    public String getExactly() {
        return exactly;
    }

    
    public void setExactly(String exactly) {
        this.exactly = exactly;
    }
}
"
org.apache.tools.ant.util.LazyFileOutputStream,11,2,0,1,23,39,1,0,10,0.483333333,136,1.0,0,0.454545455,0.348484848,1,1,10.81818182,1,0.5455,0,"
package org.apache.tools.ant.util;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;


public class LazyFileOutputStream extends OutputStream {

    private FileOutputStream fos;
    private File file;
    private boolean append;
    private boolean alwaysCreate;
    private boolean opened = false;
    private boolean closed = false;

    
    public LazyFileOutputStream(String name) {
        this(name, false);
    }

    
    public LazyFileOutputStream(String name, boolean append) {
        this(new File(name), append);
    }

    
    public LazyFileOutputStream(File f) {
        this(f, false);
    }

    
    public LazyFileOutputStream(File file, boolean append) {
        this(file, append, false);
    }

    
    public LazyFileOutputStream(File file, boolean append,
                                boolean alwaysCreate) {
        this.file = file;
        this.append = append;
        this.alwaysCreate = alwaysCreate;
    }

    
    public void open() throws IOException {
        ensureOpened();
    }

    
    public synchronized void close() throws IOException {
        if (alwaysCreate && !closed) {
            ensureOpened();
        }
        if (opened) {
            fos.close();
        }
        closed = true;
    }

    
    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }

    
    public synchronized void write(byte[] b, int offset, int len)
        throws IOException {
        ensureOpened();
        fos.write(b, offset, len);
    }

    
    public synchronized void write(int b) throws IOException {
        ensureOpened();
        fos.write(b);
    }

    private synchronized void ensureOpened() throws IOException {
        if (closed) {
            throw new IOException(file + "" has already been closed."");
        }

        if (!opened) {
            fos = new FileOutputStream(file.getAbsolutePath(), append);
            opened = true;
        }
    }
}
"
org.apache.tools.ant.util.LoaderUtils,10,1,0,10,29,43,7,3,8,0.833333333,91,0.5,1,0.0,0.2,0,0,7.9,3,1.2,0,"
package org.apache.tools.ant.util;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.launch.Locator;




public class LoaderUtils {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public static void setContextClassLoader(ClassLoader loader) {
        Thread currentThread = Thread.currentThread();
        currentThread.setContextClassLoader(loader);
    }


    
    public static ClassLoader getContextClassLoader() {
        Thread currentThread = Thread.currentThread();
        return currentThread.getContextClassLoader();
    }

    
    public static boolean isContextLoaderAvailable() {
        return true;
    }

    
    private static File normalizeSource(File source) {
        if (source != null) {
            try {
                source = FILE_UTILS.normalize(source.getAbsolutePath());
            } catch (BuildException e) {
                
            }
        }

        return source;
    }

    
    public static File getClassSource(Class c) {
        return normalizeSource(Locator.getClassSource(c));
    }

    
    public static File getResourceSource(ClassLoader c, String resource) {
        if (c == null) {
            c = LoaderUtils.class.getClassLoader();
        }
        return normalizeSource(Locator.getResourceSource(c, resource));
    }

    
    public static String classNameToResource(String className) {
        return className.replace('.', '/') + "".class"";
    }

    
    public static boolean classExists(ClassLoader loader, String className) {
        return loader.getResource(classNameToResource(className)) != null;
    }
}

"
org.apache.tools.ant.loader.AntClassLoader2,1,3,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.tools.ant.loader;

import org.apache.tools.ant.AntClassLoader;


public class AntClassLoader2 extends AntClassLoader {
    
    public AntClassLoader2() {
    }
}
"
org.apache.tools.ant.taskdefs.rmic.ForkingSunRmic,3,2,1,12,22,3,2,10,2,1.5,72,0.0,0,0.866666667,1.0,0,0,22.66666667,1,0.6667,0,"


package org.apache.tools.ant.taskdefs.rmic;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.taskdefs.Rmic;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;

import java.io.IOException;


public class ForkingSunRmic extends DefaultRmicAdapter {

    
    public static final String COMPILER_NAME = ""forking"";

    
    public boolean execute() throws BuildException {
        Rmic owner = getRmic();
        Commandline cmd = setupRmicCommand();
        Project project = owner.getProject();
        
        cmd.setExecutable(JavaEnvUtils.getJdkExecutable(getExecutableName()));

        
        String[] args = cmd.getCommandline();

        try {
            Execute exe = new Execute(new LogStreamHandler(owner,
                    Project.MSG_INFO,
                    Project.MSG_WARN));
            exe.setAntRun(project);
            exe.setWorkingDirectory(project.getBaseDir());
            exe.setCommandline(args);
            exe.execute();
            return !exe.isFailure();
        } catch (IOException exception) {
            throw new BuildException(""Error running "" + getExecutableName()
                    + "" -maybe it is not on the path"", exception);
        }
    }

    
    protected String getExecutableName() {
        return SunRmic.RMIC_EXECUTABLE;
    }
}
"
org.apache.tools.ant.util.StringUtils,9,1,0,32,36,36,32,0,7,1.104166667,281,0.833333333,0,0.0,0.25,0,0,29.55555556,11,3.0,0,"
package org.apache.tools.ant.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Vector;


public final class StringUtils {

    
    private StringUtils() {
    }

    
    public static final String LINE_SEP = System.getProperty(""line.separator"");

    
    public static Vector lineSplit(String data) {
        return split(data, '\n');
    }

    
    public static Vector split(String data, int ch) {
        Vector elems = new Vector();
        int pos = -1;
        int i = 0;
        while ((pos = data.indexOf(ch, i)) != -1) {
            String elem = data.substring(i, pos);
            elems.addElement(elem);
            i = pos + 1;
        }
        elems.addElement(data.substring(i));
        return elems;
    }

    
    public static String replace(String data, String from, String to) {
        StringBuffer buf = new StringBuffer(data.length());
        int pos = -1;
        int i = 0;
        while ((pos = data.indexOf(from, i)) != -1) {
            buf.append(data.substring(i, pos)).append(to);
            i = pos + from.length();
        }
        buf.append(data.substring(i));
        return buf.toString();
    }

    
    public static String getStackTrace(Throwable t) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw, true);
        t.printStackTrace(pw);
        pw.flush();
        pw.close();
        return sw.toString();
    }

    
    public static boolean endsWith(StringBuffer buffer, String suffix) {
        if (suffix.length() > buffer.length()) {
            return false;
        }
        
        
        
        
        
        
        
        int endIndex = suffix.length() - 1;
        int bufferIndex = buffer.length() - 1;
        while (endIndex >= 0) {
            if (buffer.charAt(bufferIndex) != suffix.charAt(endIndex)) {
                return false;
            }
            bufferIndex--;
            endIndex--;
        }
        return true;
    }

    
    public static String resolveBackSlash(String input) {
        StringBuffer b = new StringBuffer();
        boolean backSlashSeen = false;
        for (int i = 0; i < input.length(); ++i) {
            char c = input.charAt(i);
            if (!backSlashSeen) {
                if (c == '\\') {
                    backSlashSeen = true;
                } else {
                    b.append(c);
                }
            } else {
                switch (c) {
                    case '\\':
                        b.append((char) '\\');
                        break;
                    case 'n':
                        b.append((char) '\n');
                        break;
                    case 'r':
                        b.append((char) '\r');
                        break;
                    case 't':
                        b.append((char) '\t');
                        break;
                    case 'f':
                        b.append((char) '\f');
                        break;
                    case 's':
                        b.append("" \t\n\r\f"");
                        break;
                    default:
                        b.append(c);
                }
                backSlashSeen = false;
            }
        }
        return b.toString();
    }
    
    
    public static long parseHumanSizes(String humanSize) throws Exception {
    	final long KILOBYTE = 1024;
    	final long MEGABYTE = KILOBYTE * 1024;
    	final long GIGABYTE = MEGABYTE * 1024;
    	final long TERABYTE = GIGABYTE * 1024;
    	final long PETABYTE = TERABYTE * 1024;
        
    	if(!Character.isDigit(humanSize.charAt(humanSize.length()-1))) {
    		char c = humanSize.charAt(humanSize.length()-1);
    		long value = Long.valueOf(humanSize.substring(0, humanSize.length()-1)).longValue();
    		switch (c) {
    			case 'K':
    				return value * KILOBYTE;
    			case 'M':
    				return value * MEGABYTE;
    			case 'G':
    				return value * GIGABYTE;
    			case 'T':
    				return value * TERABYTE;
    			case 'P':
    				return value * PETABYTE;
    			default:
    				return value;
    		}
    	} else {
    	    return Long.parseLong(humanSize);
    	}
    }
}
"
org.apache.tools.ant.types.Parameter,7,1,0,24,8,3,24,0,7,0.666666667,43,1.0,0,0.0,0.714285714,0,0,4.714285714,1,0.8571,0,"
package org.apache.tools.ant.types;


public final class Parameter {
    private String name = null;
    private String type = null;
    private String value = null;

    
    public void setName(final String name) {
        this.name = name;
    }

    
    public void setType(final String type) {
        this.type = type;
    }

    
    public void setValue(final String value) {
        this.value = value;
    }

    
    public String getName() {
        return name;
    }

    
    public String getType() {
        return type;
    }

    
    public String getValue() {
        return value;
    }
}
"
org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher,9,1,1,4,19,30,1,3,7,0.5,130,1.0,0,0.0,0.666666667,0,0,13.33333333,4,1.2222,0,"

package org.apache.tools.ant.util.regexp;

import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import org.apache.tools.ant.BuildException;


public class Jdk14RegexpMatcher implements RegexpMatcher {

    private String pattern;

    
    public Jdk14RegexpMatcher() {
    }

    
    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    
    public String getPattern() {
        return pattern;
    }

    
    protected Pattern getCompiledPattern(int options)
        throws BuildException {
        int cOptions = getCompilerOptions(options);
        try {
            Pattern p = Pattern.compile(this.pattern, cOptions);
            return p;
        } catch (PatternSyntaxException e) {
            throw new BuildException(e);
        }
    }

    
    public boolean matches(String argument) throws BuildException {
        return matches(argument, MATCH_DEFAULT);
    }

    
    public boolean matches(String input, int options)
        throws BuildException {
        try {
            Pattern p = getCompiledPattern(options);
            return p.matcher(input).find();
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }

    
    public Vector getGroups(String argument) throws BuildException {
        return getGroups(argument, MATCH_DEFAULT);
    }

    
    public Vector getGroups(String input, int options)
        throws BuildException {
        Pattern p = getCompiledPattern(options);
        Matcher matcher = p.matcher(input);
        if (!matcher.find()) {
            return null;
        }
        Vector v = new Vector();
        int cnt = matcher.groupCount();
        for (int i = 0; i <= cnt; i++) {
            String match = matcher.group(i);
            
            if (match == null) {
                match = """";
            }
            v.addElement(match);
        }
        return v;
    }

    
    protected int getCompilerOptions(int options) {
        
        int cOptions = Pattern.UNIX_LINES;

        if (RegexpUtil.hasFlag(options, MATCH_CASE_INSENSITIVE)) {
            cOptions |= Pattern.CASE_INSENSITIVE;
        }
        if (RegexpUtil.hasFlag(options, MATCH_MULTILINE)) {
            cOptions |= Pattern.MULTILINE;
        }
        if (RegexpUtil.hasFlag(options, MATCH_SINGLELINE)) {
            cOptions |= Pattern.DOTALL;
        }

        return cOptions;
    }

}
"
org.apache.tools.ant.DirectoryScanner,63,1,2,61,144,1603,51,10,31,0.874288425,2303,1.0,2,0.0,0.213709677,0,0,35.01587302,35,3.2381,3,"

package org.apache.tools.ant;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceFactory;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.SelectorScanner;
import org.apache.tools.ant.types.selectors.SelectorUtils;
import org.apache.tools.ant.util.FileUtils;


public class DirectoryScanner
       implements FileScanner, SelectorScanner, ResourceFactory {

    
    private static final boolean ON_VMS = Os.isFamily(""openvms"");

    
    protected static final String[] DEFAULTEXCLUDES = {
        
        ""**#*#"",
        ""**/.#*"",
        ""**/%*%"",
        ""**/._*"",

        
        ""**/CVS"",
        ""**/CVS.cvsignore"",

        
        ""**/SCCS"",
        ""**/SCCSvssver.scc"",

        
        ""**/.svn"",
        ""**/.svn.DS_Store""
    };

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private static final boolean[] CS_SCAN_ONLY = new boolean[] {true};

    
    private static final boolean[] CS_THEN_NON_CS = new boolean[] {true, false};

    
    private static Vector defaultExcludes = new Vector();
    static {
        resetDefaultExcludes();
    }

    

    
    protected File basedir;

    
    protected String[] includes;

    
    protected String[] excludes;

    
    protected FileSelector[] selectors = null;

    
    protected Vector filesIncluded;

    
    protected Vector filesNotIncluded;

    
    protected Vector filesExcluded;

    
    protected Vector dirsIncluded;

    
    protected Vector dirsNotIncluded;

    
    protected Vector dirsExcluded;

    
    protected Vector filesDeselected;

    
    protected Vector dirsDeselected;

    
    protected boolean haveSlowResults = false;

    
    protected boolean isCaseSensitive = true;

    
    private boolean followSymlinks = true;

    
    protected boolean everythingIncluded = true;

    

    
    private Map fileListMap = new HashMap();

    
    private Set scannedDirs = new HashSet();

    
    private Set includeNonPatterns = new HashSet();

    
    private Set excludeNonPatterns = new HashSet();

    
    private String[] includePatterns;

    
    private String[] excludePatterns;

    
    private boolean areNonPatternSetsReady = false;

    
    private boolean scanning = false;

    
    private Object scanLock = new Object();

    
    private boolean slowScanning = false;

    
    private Object slowScanLock = new Object();

    
    private IllegalStateException illegal = null;

    
    public DirectoryScanner() {
    }

    
    protected static boolean matchPatternStart(String pattern, String str) {
        return SelectorUtils.matchPatternStart(pattern, str);
    }

    
    protected static boolean matchPatternStart(String pattern, String str,
                                               boolean isCaseSensitive) {
        return SelectorUtils.matchPatternStart(pattern, str, isCaseSensitive);
    }

    
    protected static boolean matchPath(String pattern, String str) {
        return SelectorUtils.matchPath(pattern, str);
    }

    
    protected static boolean matchPath(String pattern, String str,
                                       boolean isCaseSensitive) {
        return SelectorUtils.matchPath(pattern, str, isCaseSensitive);
    }

    
    public static boolean match(String pattern, String str) {
        return SelectorUtils.match(pattern, str);
    }

    
    protected static boolean match(String pattern, String str,
                                   boolean isCaseSensitive) {
        return SelectorUtils.match(pattern, str, isCaseSensitive);
    }


    
    public static String[] getDefaultExcludes() {
        return (String[]) defaultExcludes.toArray(new String[defaultExcludes
                                                             .size()]);
    }

    
    public static boolean addDefaultExclude(String s) {
        if (defaultExcludes.indexOf(s) == -1) {
            defaultExcludes.add(s);
            return true;
        }
        return false;
    }

    
    public static boolean removeDefaultExclude(String s) {
        return defaultExcludes.remove(s);
    }

    
    public static void resetDefaultExcludes() {
        defaultExcludes = new Vector();
        for (int i = 0; i < DEFAULTEXCLUDES.length; i++) {
            defaultExcludes.add(DEFAULTEXCLUDES[i]);
        }
    }

    
    public void setBasedir(String basedir) {
        setBasedir(basedir == null ? (File) null
            : new File(basedir.replace('/', File.separatorChar).replace(
            '\\', File.separatorChar)));
    }

    
    public synchronized void setBasedir(File basedir) {
        this.basedir = basedir;
    }

    
    public synchronized File getBasedir() {
        return basedir;
    }

    
    public synchronized boolean isCaseSensitive() {
        return isCaseSensitive;
    }

    
    public synchronized void setCaseSensitive(boolean isCaseSensitive) {
        this.isCaseSensitive = isCaseSensitive;
    }

    
    public synchronized boolean isFollowSymlinks() {
        return followSymlinks;
    }

    
    public synchronized void setFollowSymlinks(boolean followSymlinks) {
        this.followSymlinks = followSymlinks;
    }

    
    public synchronized void setIncludes(String[] includes) {
        if (includes == null) {
            this.includes = null;
        } else {
            this.includes = new String[includes.length];
            for (int i = 0; i < includes.length; i++) {
                this.includes[i] = normalizePattern(includes[i]);
            }
        }
    }

    
    public synchronized void setExcludes(String[] excludes) {
        if (excludes == null) {
            this.excludes = null;
        } else {
            this.excludes = new String[excludes.length];
            for (int i = 0; i < excludes.length; i++) {
                this.excludes[i] = normalizePattern(excludes[i]);
            }
        }
    }

    
    public synchronized void addExcludes(String[] excludes) {
        if (excludes != null && excludes.length > 0) {
            if (this.excludes != null && this.excludes.length > 0) {
                String[] tmp = new String[excludes.length
                                          + this.excludes.length];
                System.arraycopy(this.excludes, 0, tmp, 0,
                                 this.excludes.length);
                for (int i = 0; i < excludes.length; i++) {
                    tmp[this.excludes.length + i] =
                        normalizePattern(excludes[i]);
                }
                this.excludes = tmp;
            } else {
                setExcludes(excludes);
            }
        }
    }

    
    private static String normalizePattern(String p) {
        String pattern = p.replace('/', File.separatorChar)
            .replace('\\', File.separatorChar);
        if (pattern.endsWith(File.separator)) {
            pattern += ""**"";
        }
        return pattern;
    }

    
    public synchronized void setSelectors(FileSelector[] selectors) {
        this.selectors = selectors;
    }

    
    public synchronized boolean isEverythingIncluded() {
        return everythingIncluded;
    }

    
    public void scan() throws IllegalStateException {
        synchronized (scanLock) {
            if (scanning) {
                while (scanning) {
                    try {
                        scanLock.wait();
                    } catch (InterruptedException e) {
                        continue;
                    }
                }
                if (illegal != null) {
                    throw illegal;
                }
                return;
            }
            scanning = true;
        }
        try {
            synchronized (this) {
                illegal = null;
                clearResults();

                
                boolean nullIncludes = (includes == null);
                includes = nullIncludes ? new String[] {""**""} : includes;
                boolean nullExcludes = (excludes == null);
                excludes = nullExcludes ? new String[0] : excludes;

                if (basedir == null) {
                    
                    if (nullIncludes) {
                        return;
                    }
                } else {
                    if (!basedir.exists()) {
                        illegal = new IllegalStateException(""basedir "" + basedir
                                                            + "" does not exist"");
                    }
                    if (!basedir.isDirectory()) {
                        illegal = new IllegalStateException(""basedir "" + basedir
                                                            + "" is not a directory"");
                    }
                    if (illegal != null) {
                        throw illegal;
                    }
                }
                if (isIncluded("""")) {
                    if (!isExcluded("""")) {
                        if (isSelected("""", basedir)) {
                            dirsIncluded.addElement("""");
                        } else {
                            dirsDeselected.addElement("""");
                        }
                    } else {
                        dirsExcluded.addElement("""");
                    }
                } else {
                    dirsNotIncluded.addElement("""");
                }
                checkIncludePatterns();
                clearCaches();
                includes = nullIncludes ? null : includes;
                excludes = nullExcludes ? null : excludes;
            }
        } finally {
            synchronized (scanLock) {
                scanning = false;
                scanLock.notifyAll();
            }
        }
    }

    
    private void checkIncludePatterns() {
        Map newroots = new HashMap();
        
        
        for (int i = 0; i < includes.length; i++) {
            if (FileUtils.isAbsolutePath(includes[i])) {
                
                if (basedir != null
                    && !SelectorUtils.matchPatternStart(includes[i],
                    basedir.getAbsolutePath(), isCaseSensitive())) {
                    continue;
                }
            } else if (basedir == null) {
                
                continue;
            }
            newroots.put(SelectorUtils.rtrimWildcardTokens(
                includes[i]), includes[i]);
        }
        if (newroots.containsKey("""") && basedir != null) {
            
            scandir(basedir, """", true);
        } else {
            
            
            Iterator it = newroots.entrySet().iterator();

            File canonBase = null;
            if (basedir != null) {
                try {
                    canonBase = basedir.getCanonicalFile();
                } catch (IOException ex) {
                    throw new BuildException(ex);
                }
            }
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                String currentelement = (String) entry.getKey();
                if (basedir == null && !FileUtils.isAbsolutePath(currentelement)) {
                    continue;
                }
                String originalpattern = (String) entry.getValue();
                File myfile = new File(basedir, currentelement);

                if (myfile.exists()) {
                    
                    
                    
                    try {
                        String path = (basedir == null)
                            ? myfile.getCanonicalPath()
                            : FILE_UTILS.removeLeadingPath(canonBase,
                            myfile.getCanonicalFile());
                        if (!path.equals(currentelement) || ON_VMS) {
                            myfile = findFile(basedir, currentelement, true);
                            if (myfile != null && basedir != null) {
                                currentelement = FILE_UTILS.removeLeadingPath(
                                    basedir, myfile);
                            }
                        }
                    } catch (IOException ex) {
                        throw new BuildException(ex);
                    }
                }
                if ((myfile == null || !myfile.exists()) && !isCaseSensitive()) {
                    File f = findFile(basedir, currentelement, false);
                    if (f != null && f.exists()) {
                        
                        
                        currentelement = (basedir == null)
                            ? f.getAbsolutePath()
                            : FILE_UTILS.removeLeadingPath(basedir, f);
                        myfile = f;
                    }
                }
                if (myfile != null && myfile.exists()) {
                    if (!followSymlinks
                        && isSymlink(basedir, currentelement)) {
                        continue;
                    }
                    if (myfile.isDirectory()) {
                        if (isIncluded(currentelement)
                            && currentelement.length() > 0) {
                            accountForIncludedDir(currentelement, myfile, true);
                        }  else {
                            if (currentelement.length() > 0) {
                                if (currentelement.charAt(currentelement
                                                          .length() - 1)
                                    != File.separatorChar) {
                                    currentelement =
                                        currentelement + File.separatorChar;
                                }
                            }
                            scandir(myfile, currentelement, true);
                        }
                    } else {
                        boolean included = isCaseSensitive()
                            ? originalpattern.equals(currentelement)
                            : originalpattern.equalsIgnoreCase(currentelement);
                        if (included) {
                            accountForIncludedFile(currentelement, myfile);
                        }
                    }
                }
            }
        }
    }

    
    protected synchronized void clearResults() {
        filesIncluded    = new Vector();
        filesNotIncluded = new Vector();
        filesExcluded    = new Vector();
        filesDeselected  = new Vector();
        dirsIncluded     = new Vector();
        dirsNotIncluded  = new Vector();
        dirsExcluded     = new Vector();
        dirsDeselected   = new Vector();
        everythingIncluded = (basedir != null);
        scannedDirs.clear();
    }

    
    protected void slowScan() {
        synchronized (slowScanLock) {
            if (haveSlowResults) {
                return;
            }
            if (slowScanning) {
                while (slowScanning) {
                    try {
                        slowScanLock.wait();
                    } catch (InterruptedException e) {
                        
                    }
                }
                return;
            }
            slowScanning = true;
        }
        try {
            synchronized (this) {

                
                boolean nullIncludes = (includes == null);
                includes = nullIncludes ? new String[] {""**""} : includes;
                boolean nullExcludes = (excludes == null);
                excludes = nullExcludes ? new String[0] : excludes;

                String[] excl = new String[dirsExcluded.size()];
                dirsExcluded.copyInto(excl);

                String[] notIncl = new String[dirsNotIncluded.size()];
                dirsNotIncluded.copyInto(notIncl);

                processSlowScan(excl);
                processSlowScan(notIncl);
                clearCaches();
                includes = nullIncludes ? null : includes;
                excludes = nullExcludes ? null : excludes;
            }
        } finally {
            synchronized (slowScanLock) {
                haveSlowResults = true;
                slowScanning = false;
                slowScanLock.notifyAll();
            }
        }
    }

    private void processSlowScan(String[] arr) {
        for (int i = 0; i < arr.length; i++) {
            if (!couldHoldIncluded(arr[i])) {
                scandir(new File(basedir, arr[i]),
                        arr[i] + File.separator, false);
            }
        }
    }

    
    protected void scandir(File dir, String vpath, boolean fast) {
        if (dir == null) {
            throw new BuildException(""dir must not be null."");
        } else if (!dir.exists()) {
            throw new BuildException(dir + "" doesn't exist."");
        } else if (!dir.isDirectory()) {
            throw new BuildException(dir + "" is not a directory."");
        }
        
        if (fast && hasBeenScanned(vpath)) {
            return;
        }
        String[] newfiles = dir.list();

        if (newfiles == null) {
            
            throw new BuildException(""IO error scanning directory '""
                                     + dir.getAbsolutePath() + ""'"");
        }
        if (!followSymlinks) {
            Vector noLinks = new Vector();
            for (int i = 0; i < newfiles.length; i++) {
                try {
                    if (FILE_UTILS.isSymbolicLink(dir, newfiles[i])) {
                        String name = vpath + newfiles[i];
                        File file = new File(dir, newfiles[i]);
                        (file.isDirectory()
                            ? dirsExcluded : filesExcluded).addElement(name);
                    } else {
                        noLinks.addElement(newfiles[i]);
                    }
                } catch (IOException ioe) {
                    String msg = ""IOException caught while checking ""
                        + ""for links, couldn't get canonical path!"";
                    
                    System.err.println(msg);
                    noLinks.addElement(newfiles[i]);
                }
            }
            newfiles = (String[]) (noLinks.toArray(new String[noLinks.size()]));
        }
        for (int i = 0; i < newfiles.length; i++) {
            String name = vpath + newfiles[i];
            File file = new File(dir, newfiles[i]);
            if (file.isDirectory()) {
                if (isIncluded(name)) {
                    accountForIncludedDir(name, file, fast);
                } else {
                    everythingIncluded = false;
                    dirsNotIncluded.addElement(name);
                    if (fast && couldHoldIncluded(name)) {
                        scandir(file, name + File.separator, fast);
                    }
                }
                if (!fast) {
                    scandir(file, name + File.separator, fast);
                }
            } else if (file.isFile()) {
                if (isIncluded(name)) {
                    accountForIncludedFile(name, file);
                } else {
                    everythingIncluded = false;
                    filesNotIncluded.addElement(name);
                }
            }
        }
    }

    
    private void accountForIncludedFile(String name, File file) {
        processIncluded(name, file, filesIncluded, filesExcluded, filesDeselected);
    }

    
    private void accountForIncludedDir(String name, File file, boolean fast) {
        processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);
        if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {
            scandir(file, name + File.separator, fast);
        }
    }

    private void processIncluded(String name, File file, Vector inc, Vector exc, Vector des) {

        if (inc.contains(name) || exc.contains(name) || des.contains(name)) { return; }

        boolean included = false;
        if (isExcluded(name)) {
            exc.add(name);
        } else if (isSelected(name, file)) {
            included = true;
            inc.add(name);
        } else {
            des.add(name);
        }
        everythingIncluded &= included;
    }

    
    protected boolean isIncluded(String name) {
        ensureNonPatternSetsReady();

        if (isCaseSensitive()
            ? includeNonPatterns.contains(name)
            : includeNonPatterns.contains(name.toUpperCase())) {
            return true;
        }
        for (int i = 0; i < includePatterns.length; i++) {
            if (matchPath(includePatterns[i], name, isCaseSensitive())) {
                return true;
            }
        }
        return false;
    }

    
    protected boolean couldHoldIncluded(String name) {
        for (int i = 0; i < includes.length; i++) {
            if (matchPatternStart(includes[i], name, isCaseSensitive())
                && isMorePowerfulThanExcludes(name, includes[i])
                && isDeeper(includes[i], name)) {
                return true;
            }
        }
        return false;
    }

    
    private boolean isDeeper(String pattern, String name) {
        Vector p = SelectorUtils.tokenizePath(pattern);
        Vector n = SelectorUtils.tokenizePath(name);
        return p.contains(""**"") || p.size() > n.size();
    }

    
    private boolean isMorePowerfulThanExcludes(String name, String includepattern) {
        String soughtexclude = name + File.separator + ""**"";
        for (int counter = 0; counter < excludes.length; counter++) {
            if (excludes[counter].equals(soughtexclude))  {
                return false;
            }
        }
        return true;
    }

    
    private boolean contentsExcluded(String name) {
        name = (name.endsWith(File.separator)) ? name : name + File.separator;
        for (int i = 0; i < excludes.length; i++) {
            String e = excludes[i];
            if (e.endsWith(""**"") && SelectorUtils.matchPath(
                e.substring(0, e.length() - 2), name, isCaseSensitive())) {
                return true;
            }
        }
        return false;
    }

    
    protected boolean isExcluded(String name) {
        ensureNonPatternSetsReady();

        if (isCaseSensitive()
            ? excludeNonPatterns.contains(name)
            : excludeNonPatterns.contains(name.toUpperCase())) {
            return true;
        }
        for (int i = 0; i < excludePatterns.length; i++) {
            if (matchPath(excludePatterns[i], name, isCaseSensitive())) {
                return true;
            }
        }
        return false;
    }

    
    protected boolean isSelected(String name, File file) {
        if (selectors != null) {
            for (int i = 0; i < selectors.length; i++) {
                if (!selectors[i].isSelected(basedir, name, file)) {
                    return false;
                }
            }
        }
        return true;
    }

    
    public synchronized String[] getIncludedFiles() {
        if (filesIncluded == null) {
            throw new IllegalStateException(""Must call scan() first"");
        }
        String[] files = new String[filesIncluded.size()];
        filesIncluded.copyInto(files);
        Arrays.sort(files);
        return files;
    }

    
    public synchronized int getIncludedFilesCount() {
        if (filesIncluded == null) {
            throw new IllegalStateException(""Must call scan() first"");
        }
        return filesIncluded.size();
    }

    
    public synchronized String[] getNotIncludedFiles() {
        slowScan();
        String[] files = new String[filesNotIncluded.size()];
        filesNotIncluded.copyInto(files);
        return files;
    }

    
    public synchronized String[] getExcludedFiles() {
        slowScan();
        String[] files = new String[filesExcluded.size()];
        filesExcluded.copyInto(files);
        return files;
    }

    
    public synchronized String[] getDeselectedFiles() {
        slowScan();
        String[] files = new String[filesDeselected.size()];
        filesDeselected.copyInto(files);
        return files;
    }

    
    public synchronized String[] getIncludedDirectories() {
        if (dirsIncluded == null) {
            throw new IllegalStateException(""Must call scan() first"");
        }
        String[] directories = new String[dirsIncluded.size()];
        dirsIncluded.copyInto(directories);
        Arrays.sort(directories);
        return directories;
    }

    
    public synchronized int getIncludedDirsCount() {
        if (dirsIncluded == null) {
            throw new IllegalStateException(""Must call scan() first"");
        }
        return dirsIncluded.size();
    }

    
    public synchronized String[] getNotIncludedDirectories() {
        slowScan();
        String[] directories = new String[dirsNotIncluded.size()];
        dirsNotIncluded.copyInto(directories);
        return directories;
    }

    
    public synchronized String[] getExcludedDirectories() {
        slowScan();
        String[] directories = new String[dirsExcluded.size()];
        dirsExcluded.copyInto(directories);
        return directories;
    }

    
    public synchronized String[] getDeselectedDirectories() {
        slowScan();
        String[] directories = new String[dirsDeselected.size()];
        dirsDeselected.copyInto(directories);
        return directories;
    }

    
    public synchronized void addDefaultExcludes() {
        int excludesLength = excludes == null ? 0 : excludes.length;
        String[] newExcludes;
        newExcludes = new String[excludesLength + defaultExcludes.size()];
        if (excludesLength > 0) {
            System.arraycopy(excludes, 0, newExcludes, 0, excludesLength);
        }
        String[] defaultExcludesTemp = getDefaultExcludes();
        for (int i = 0; i < defaultExcludesTemp.length; i++) {
            newExcludes[i + excludesLength] =
                defaultExcludesTemp[i].replace('/', File.separatorChar)
                .replace('\\', File.separatorChar);
        }
        excludes = newExcludes;
    }

    
    public synchronized Resource getResource(String name) {
        return new FileResource(basedir, name);
    }

    
    private String[] list(File file) {
        String[] files = (String[]) fileListMap.get(file);
        if (files == null) {
            files = file.list();
            if (files != null) {
                fileListMap.put(file, files);
            }
        }
        return files;
    }

    
    private File findFile(File base, String path, boolean cs) {
        if (FileUtils.isAbsolutePath(path)) {
            if (base == null) {
                String[] s = FILE_UTILS.dissect(path);
                base = new File(s[0]);
                path = s[1];
            } else {
                File f = FILE_UTILS.normalize(path);
                String s = FILE_UTILS.removeLeadingPath(base, f);
                if (s.equals(f.getAbsolutePath())) {
                    
                    return null;
                }
                path = s;
            }
        }
        return findFile(base, SelectorUtils.tokenizePath(path), cs);
    }

    
    private File findFile(File base, Vector pathElements, boolean cs) {
        if (pathElements.size() == 0) {
            return base;
        }
        String current = (String) pathElements.remove(0);
        if (base == null) {
            return findFile(new File(current), pathElements, cs);
        }
        if (!base.isDirectory()) {
            return null;
        }
        String[] files = list(base);
        if (files == null) {
            throw new BuildException(""IO error scanning directory ""
                                     + base.getAbsolutePath());
        }
        boolean[] matchCase = cs ? CS_SCAN_ONLY : CS_THEN_NON_CS;
        for (int i = 0; i < matchCase.length; i++) {
            for (int j = 0; j < files.length; j++) {
                if (matchCase[i] ? files[j].equals(current)
                                 : files[j].equalsIgnoreCase(current)) {
                    return findFile(new File(base, files[j]), pathElements, cs);
                }
            }
        }
        return null;
    }

    
    private boolean isSymlink(File base, String path) {
        return isSymlink(base, SelectorUtils.tokenizePath(path));
    }

    
    private boolean isSymlink(File base, Vector pathElements) {
        if (pathElements.size() > 0) {
            String current = (String) pathElements.remove(0);
            try {
                return FILE_UTILS.isSymbolicLink(base, current)
                    || isSymlink(new File(base, current), pathElements);
            } catch (IOException ioe) {
                String msg = ""IOException caught while checking ""
                    + ""for links, couldn't get canonical path!"";
                
                System.err.println(msg);
            }
        }
        return false;
    }

    
    private boolean hasBeenScanned(String vpath) {
        return !scannedDirs.add(vpath);
    }

    
     Set getScannedDirs() {
        return scannedDirs;
    }

    
    private synchronized void clearCaches() {
        fileListMap.clear();
        includeNonPatterns.clear();
        excludeNonPatterns.clear();
        includePatterns = null;
        excludePatterns = null;
        areNonPatternSetsReady = false;
    }

    
    private synchronized void ensureNonPatternSetsReady() {
        if (!areNonPatternSetsReady) {
            includePatterns = fillNonPatternSet(includeNonPatterns, includes);
            excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes);
            areNonPatternSetsReady = true;
        }
    }

    
    private String[] fillNonPatternSet(Set set, String[] patterns) {
        ArrayList al = new ArrayList(patterns.length);
        for (int i = 0; i < patterns.length; i++) {
            if (!SelectorUtils.hasWildcards(patterns[i])) {
                set.add(isCaseSensitive() ? patterns[i]
                    : patterns[i].toUpperCase());
            } else {
                al.add(patterns[i]);
            }
        }
        return set.size() == 0 ? patterns
            : (String[]) al.toArray(new String[al.size()]);
    }

}
"
org.apache.tools.ant.taskdefs.LogOutputStream,6,3,2,20,13,7,17,3,3,0.4,56,1.0,1,0.733333333,0.433333333,1,4,8.0,1,0.6667,0,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.LineOrientedOutputStream;


public class LogOutputStream extends LineOrientedOutputStream {

    private ProjectComponent pc;
    private int level = Project.MSG_INFO;

    
    public LogOutputStream(Task task, int level) {
        this((ProjectComponent) task, level);
    }

    
    public LogOutputStream(ProjectComponent pc, int level) {
        this.pc = pc;
        this.level = level;
    }

    
    protected void processBuffer() {
        try {
            super.processBuffer();
        } catch (IOException e) {
            
            throw new RuntimeException(""Impossible IOException caught: "" + e);
        }
    }

    
    protected void processLine(String line) {
        processLine(line, level);
    }

    
    protected void processLine(String line, int level) {
        pc.log(line, level);
    }

    
    public int getMessageLevel() {
        return level;
    }

}
"
org.apache.tools.ant.taskdefs.optional.jsp.JspMangler,2,1,0,6,2,1,6,0,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.jsp;

import java.io.File;


public interface JspMangler {


    
    String mapJspToJavaName(File jspFile);

    
    String mapPath(String path);

}
"
org.apache.tools.ant.taskdefs.optional.dotnet.Ildasm,22,3,0,5,47,159,0,5,19,0.904761905,365,1.0,1,0.649122807,0.361904762,2,2,14.81818182,9,1.3636,0,"
package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;

import java.io.File;


public class Ildasm extends Task {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private File sourceFile;

    
    private File destFile;
    
    private boolean progressBar = false;

    
    private String encoding;

    

    private boolean bytes = false;

    
    private boolean linenumbers = false;

    
    private boolean rawExceptionHandling = false;

    
    private boolean showSource = false;

    
    private boolean quoteallnames = false;

    
    private boolean header = false;

    
    private boolean assembler = true;

    

    private boolean metadata = false;

    
    private String visibility;

    

    private String item;

    
    private String executable = ""ildasm"";

    
    private File resourceDir;


    
    public void setResourceDir(File resourceDir) {
        this.resourceDir = resourceDir;
    }

    
    public void setExecutable(String executable) {
        this.executable = executable;
    }

    
    public void setEncoding(EncodingTypes encoding) {
        this.encoding = encoding.getValue();
    }

    
    public void setAssembler(boolean assembler) {
        this.assembler = assembler;
    }

    
    public void setBytes(boolean bytes) {
        this.bytes = bytes;
    }

    
    public void setDestFile(File destFile) {
        this.destFile = destFile;
    }

    
    public void setHeader(boolean header) {
        this.header = header;
    }

    
    public void setItem(String item) {
        this.item = item;
    }

    
    public void setLinenumbers(boolean linenumbers) {
        this.linenumbers = linenumbers;
    }

    
    public void setMetadata(boolean metadata) {
        this.metadata = metadata;
    }

    
    public void setProgressBar(boolean progressBar) {
        this.progressBar = progressBar;
    }

    
    public void setQuoteallnames(boolean quoteallnames) {
        this.quoteallnames = quoteallnames;
    }

    
    public void setRawExceptionHandling(boolean rawExceptionHandling) {
        this.rawExceptionHandling = rawExceptionHandling;
    }

    
    public void setShowSource(boolean showSource) {
        this.showSource = showSource;
    }

    
    public void setSourceFile(File sourceFile) {
        this.sourceFile = sourceFile;
    }

    
    public void setSrcFile(File sourceFile) {
        setSourceFile(sourceFile);
    }
    
    public void setVisibility(String visibility) {
        this.visibility = visibility;
    }

    
    private void validate() {
        if (sourceFile == null || !sourceFile.exists() || !sourceFile.isFile()) {
            throw new BuildException(""invalid source"");
        }
        if (destFile == null || destFile.isDirectory()) {
            throw new BuildException(""invalid dest"");
        }
        if (resourceDir != null
                && (!resourceDir.exists() || !resourceDir.isDirectory())) {
            throw new BuildException(""invalid resource directory"");
        }
    }

    
    private boolean isDisassemblyNeeded() {
        if (!destFile.exists()) {
            log(""Destination file does not exist: a build is required"",
                    Project.MSG_VERBOSE);
            return true;
        }
        long sourceTime = sourceFile.lastModified();
        long destTime = destFile.lastModified();
        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {
            log(""Source file is newer than the dest file: a rebuild is required"",
                    Project.MSG_VERBOSE);
            return true;
        } else {
            log(""The .il file is up to date"", Project.MSG_VERBOSE);
            return false;
        }

    }
    
    public void execute() throws BuildException {
        log(""This task is deprecated and will be removed in a future version\n""
            + ""of Ant.  It is now part of the .NET Antlib:\n""
            + ""http:
            Project.MSG_WARN);
        validate();
        if (!isDisassemblyNeeded()) {
            return;
        }
        NetCommand command = new NetCommand(this, ""ildasm"", executable);
        command.setFailOnError(true);
        
        command.addArgument(""/text"");
        command.addArgument(""/out="" + destFile.toString());
        if (!progressBar) {
            command.addArgument(""/nobar"");
        }
        if (linenumbers) {
            command.addArgument(""/linenum"");
        }
        if (showSource) {
            command.addArgument(""/source"");
        }
        if (quoteallnames) {
            command.addArgument(""/quoteallnames"");
        }
        if (header) {
            command.addArgument(""/header"");
        }
        if (!assembler) {
            command.addArgument(""/noil"");
        }
        if (metadata) {
            command.addArgument(""/tokens"");
        }
        command.addArgument(""/item:"", item);
        if (rawExceptionHandling) {
            command.addArgument(""/raweh"");
        }
        command.addArgument(EncodingTypes.getEncodingOption(encoding));
        if (bytes) {
            command.addArgument(""/bytes"");
        }
        command.addArgument(""/vis:"", visibility);

        
        command.addArgument(sourceFile.getAbsolutePath());

        
        
        File execDir = resourceDir;
        if (execDir == null) {
            execDir = destFile.getParentFile();
        }
        command.setDirectory(execDir);

        
        try {
            command.runCommand();
        } catch (BuildException e) {
            
            if (destFile.exists()) {
                log(""Deleting destination file as it may be corrupt"");
                destFile.delete();
            }
            
            throw e;
        }

    }

    
    public static class EncodingTypes extends EnumeratedAttribute {
        
        public static final String UNICODE = ""unicode"";
        
        public static final String UTF8 = ""utf8"";
        
        public static final String ASCII = ""ascii"";
        
        public String[] getValues() {
            return new String[]{
                ASCII,
                UTF8,
                UNICODE,
            };
        }

        
        public static String getEncodingOption(String enumValue) {
            if (UNICODE.equals(enumValue)) {
                return ""/unicode"";
            }
            if (UTF8.equals(enumValue)) {
                return ""/utf8"";
            }
            return null;
        }
    }

    
    public static class VisibilityOptions extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[]{
                ""pub"", 
                ""pri"", 
                ""fam"", 
                ""asm"", 
                ""faa"", 
                ""foa"", 
                ""psc"", 
            };
        }

    }
}
"
org.apache.tools.ant.taskdefs.Apt,17,5,0,9,34,118,2,7,17,0.975,137,0.5,1,0.905882353,0.270588235,3,5,6.470588235,2,1.0588,1,"
package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.compilers.AptExternalCompilerAdapter;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.JavaEnvUtils;

import java.util.Vector;
import java.io.File;




public class Apt
        extends Javac {
    private boolean compile = true;
    private String factory;
    private Path factoryPath;
    private Vector options = new Vector();
    private File preprocessDir;
    
    public static final String EXECUTABLE_NAME = ""apt"";
    
    public static final String ERROR_IGNORING_COMPILER_OPTION
        = ""Ignoring compiler attribute for the APT task, as it is fixed"";
    
    public static final String ERROR_WRONG_JAVA_VERSION
        = ""Apt task requires Java 1.5+"";

    
    public static final String WARNING_IGNORING_FORK =
        ""Apt only runs in its own JVM; fork=false option ignored"";

    
    public static final class Option {
        private String name;
        private String value;

        
        public Option() {
            
        }

        
        public String getName() {
            return name;
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getValue() {
            return value;
        }

        
        public void setValue(String value) {
            this.value = value;
        }
    }

    
    public Apt() {
        super();
        super.setCompiler(AptExternalCompilerAdapter.class.getName());
        setFork(true);
    }

    
    public String getAptExecutable() {
        return JavaEnvUtils.getJdkExecutable(EXECUTABLE_NAME);
    }

    
    public void setCompiler(String compiler) {
        log(ERROR_IGNORING_COMPILER_OPTION, Project.MSG_WARN);
    }

    
    public void setFork(boolean fork) {
        if (!fork) {
            log(WARNING_IGNORING_FORK, Project.MSG_WARN);
        }
    }

    
    public String getCompiler() {
        return super.getCompiler();
    }

    
    public boolean isCompile() {
        return compile;
    }

    
    public void setCompile(boolean compile) {
        this.compile = compile;
    }

    
    public String getFactory() {
        return factory;
    }

    
    public void setFactory(String factory) {
        this.factory = factory;
    }

    
    public void setFactoryPathRef(Reference ref) {
        createFactoryPath().setRefid(ref);
    }

    
    public Path createFactoryPath() {
        if (factoryPath == null) {
            factoryPath = new Path(getProject());
        }
        return factoryPath.createPath();
    }

    
    public Path getFactoryPath() {
        return factoryPath;
    }

    
    public Option createOption() {
        Option opt = new Option();
        options.add(opt);
        return opt;
    }

    
    public Vector getOptions() {
        return options;
    }

    
    public File getPreprocessDir() {
        return preprocessDir;
    }

    
    public void setPreprocessDir(File preprocessDir) {
        this.preprocessDir = preprocessDir;
    }

    
    public void execute()
            throws BuildException {
        super.execute();
    }
}
"
org.apache.tools.ant.taskdefs.MacroInstance,12,3,0,15,99,18,1,14,8,0.826446281,804,1.0,1,0.770833333,0.277777778,2,2,65.08333333,18,4.8333,2,"

package org.apache.tools.ant.taskdefs;

import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Enumeration;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DynamicAttribute;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.RuntimeConfigurable;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.UnknownElement;


public class MacroInstance extends Task implements DynamicAttribute, TaskContainer {
    private MacroDef macroDef;
    private Map      map = new HashMap();
    private Map      nsElements = null;
    private Map      presentElements;
    private Hashtable localAttributes;
    private String    text = null;
    private String    implicitTag =     null;
    private List      unknownElements = new ArrayList();

    
    public void setMacroDef(MacroDef macroDef) {
        this.macroDef = macroDef;
    }

    
    public MacroDef getMacroDef() {
        return macroDef;
    }

    
    public void setDynamicAttribute(String name, String value) {
        map.put(name, value);
    }

    
    public Object createDynamicElement(String name) throws BuildException {
        throw new BuildException(""Not implemented any more"");
    }

    private Map getNsElements() {
        if (nsElements == null) {
            nsElements = new HashMap();
            for (Iterator i = macroDef.getElements().entrySet().iterator();
                 i.hasNext();) {
                Map.Entry entry = (Map.Entry) i.next();
                nsElements.put((String) entry.getKey(),
                               entry.getValue());
                MacroDef.TemplateElement te = (MacroDef.TemplateElement)
                    entry.getValue();
                if (te.isImplicit()) {
                    implicitTag = te.getName();
                }
            }
        }
        return nsElements;
    }

    
    public void addTask(Task nestedTask) {
        unknownElements.add(nestedTask);
    }

    private void processTasks() {
        if (implicitTag != null) {
            return;
        }
        for (Iterator i = unknownElements.iterator(); i.hasNext();) {
            UnknownElement ue = (UnknownElement) i.next();
            String name = ProjectHelper.extractNameFromComponentName(
                ue.getTag()).toLowerCase(Locale.US);
            if (getNsElements().get(name) == null) {
                throw new BuildException(""unsupported element "" + name);
            }
            if (presentElements.get(name) != null) {
                throw new BuildException(""Element "" + name + "" already present"");
            }
            presentElements.put(name, ue);
        }
    }

    
    public static class Element implements TaskContainer {
        private List unknownElements = new ArrayList();

        
        public void addTask(Task nestedTask) {
            unknownElements.add(nestedTask);
        }

        
        public List getUnknownElements() {
            return unknownElements;
        }
    }

    private static final int STATE_NORMAL         = 0;
    private static final int STATE_EXPECT_BRACKET = 1;
    private static final int STATE_EXPECT_NAME    = 2;

    private String macroSubs(String s, Map macroMapping) {
        if (s == null) {
            return null;
        }
        StringBuffer ret = new StringBuffer();
        StringBuffer macroName = null;

        int state = STATE_NORMAL;
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            switch (state) {
                case STATE_NORMAL:
                    if (ch == '@') {
                        state = STATE_EXPECT_BRACKET;
                    } else {
                        ret.append(ch);
                    }
                    break;
                case STATE_EXPECT_BRACKET:
                    if (ch == '{') {
                        state = STATE_EXPECT_NAME;
                        macroName = new StringBuffer();
                    } else if (ch == '@') {
                        state = STATE_NORMAL;
                        ret.append('@');
                    } else {
                        state = STATE_NORMAL;
                        ret.append('@');
                        ret.append(ch);
                    }
                    break;
                case STATE_EXPECT_NAME:
                    if (ch == '}') {
                        state = STATE_NORMAL;
                        String name = macroName.toString().toLowerCase(Locale.US);
                        String value = (String) macroMapping.get(name);
                        if (value == null) {
                            ret.append(""@{"");
                            ret.append(name);
                            ret.append(""}"");
                        } else {
                            ret.append(value);
                        }
                        macroName = null;
                    } else {
                        macroName.append(ch);
                    }
                    break;
                default:
                    break;
            }
        }
        switch (state) {
            case STATE_NORMAL:
                break;
            case STATE_EXPECT_BRACKET:
                ret.append('@');
                break;
            case STATE_EXPECT_NAME:
                ret.append(""@{"");
                ret.append(macroName.toString());
                break;
            default:
                break;
        }

        return ret.toString();
    }

    

    public void addText(String text) {
        this.text = text;
    }

    private UnknownElement copy(UnknownElement ue) {
        UnknownElement ret = new UnknownElement(ue.getTag());
        ret.setNamespace(ue.getNamespace());
        ret.setProject(getProject());
        ret.setQName(ue.getQName());
        ret.setTaskType(ue.getTaskType());
        ret.setTaskName(ue.getTaskName());
        ret.setLocation(
            macroDef.getBackTrace() ? ue.getLocation() : getLocation());
        if (getOwningTarget() == null) {
            Target t = new Target();
            t.setProject(getProject());
            ret.setOwningTarget(t);
        } else {
            ret.setOwningTarget(getOwningTarget());
        }
        RuntimeConfigurable rc = new RuntimeConfigurable(
            ret, ue.getTaskName());
        rc.setPolyType(ue.getWrapper().getPolyType());
        Map m = ue.getWrapper().getAttributeMap();
        for (Iterator i = m.entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry) i.next();
            rc.setAttribute(
                (String) entry.getKey(),
                macroSubs((String) entry.getValue(), localAttributes));
        }
        rc.addText(macroSubs(ue.getWrapper().getText().toString(),
                             localAttributes));

        Enumeration e = ue.getWrapper().getChildren();
        while (e.hasMoreElements()) {
            RuntimeConfigurable r = (RuntimeConfigurable) e.nextElement();
            UnknownElement unknownElement = (UnknownElement) r.getProxy();
            String tag = unknownElement.getTaskType();
            if (tag != null) {
                tag = tag.toLowerCase(Locale.US);
            }
            MacroDef.TemplateElement templateElement =
                (MacroDef.TemplateElement) getNsElements().get(tag);
            if (templateElement == null) {
                UnknownElement child = copy(unknownElement);
                rc.addChild(child.getWrapper());
                ret.addChild(child);
            } else if (templateElement.isImplicit()) {
                if (unknownElements.size() == 0 && !templateElement.isOptional()) {
                    throw new BuildException(
                        ""Missing nested elements for implicit element ""
                        + templateElement.getName());
                }
                for (Iterator i = unknownElements.iterator();
                     i.hasNext();) {
                    UnknownElement child = copy((UnknownElement) i.next());
                    rc.addChild(child.getWrapper());
                    ret.addChild(child);
                }
            } else {
                UnknownElement presentElement =
                    (UnknownElement) presentElements.get(tag);
                if (presentElement == null) {
                    if (!templateElement.isOptional()) {
                        throw new BuildException(
                            ""Required nested element ""
                            + templateElement.getName() + "" missing"");
                    }
                    continue;
                }
                String presentText =
                    presentElement.getWrapper().getText().toString();
                if (!"""".equals(presentText)) {
                    rc.addText(macroSubs(presentText, localAttributes));
                }
                List list = presentElement.getChildren();
                if (list != null) {
                    for (Iterator i = list.iterator();
                         i.hasNext();) {
                        UnknownElement child = copy((UnknownElement) i.next());
                        rc.addChild(child.getWrapper());
                        ret.addChild(child);
                    }
                }
            }
        }
        return ret;
    }

    
    public void execute() {
        presentElements = new HashMap();
        getNsElements();
        processTasks();
        localAttributes = new Hashtable();
        Set copyKeys = new HashSet(map.keySet());
        for (Iterator i = macroDef.getAttributes().iterator(); i.hasNext();) {
            MacroDef.Attribute attribute = (MacroDef.Attribute) i.next();
            String value = (String) map.get(attribute.getName());
            if (value == null && ""description"".equals(attribute.getName())) {
                value = getDescription();
            }
            if (value == null) {
                value = attribute.getDefault();
                value = macroSubs(value, localAttributes);
            }
            if (value == null) {
                throw new BuildException(
                    ""required attribute "" + attribute.getName() + "" not set"");
            }
            localAttributes.put(attribute.getName(), value);
            copyKeys.remove(attribute.getName());
        }
        if (copyKeys.contains(""id"")) {
            copyKeys.remove(""id"");
        }
        if (macroDef.getText() != null) {
            if (text == null) {
                if (!macroDef.getText().getOptional()) {
                    throw new BuildException(
                        ""required text missing"");
                }
                text = """";
            }
            if (macroDef.getText().getTrim()) {
                text = text.trim();
            }
            localAttributes.put(macroDef.getText().getName(), text);
        } else {
            if (text != null && !text.trim().equals("""")) {
                throw new BuildException(
                    ""The \"""" + getTaskName() + ""\"" macro does not support""
                    + "" nested text data."");
            }
        }
        if (copyKeys.size() != 0) {
            throw new BuildException(
                ""Unknown attribute"" + (copyKeys.size() > 1 ? ""s "" : "" "")
                + copyKeys);
        }

        
        UnknownElement c = copy(macroDef.getNestedTask());
        c.init();
        try {
            c.perform();
        } catch (BuildException ex) {
            if (macroDef.getBackTrace()) {
                throw ProjectHelper.addLocationToBuildException(
                    ex, getLocation());
            } else {
                ex.setLocation(getLocation());
                throw ex;
            }
        } finally {
            presentElements = null;
            localAttributes = null;
        }
    }
}
"
org.apache.tools.ant.DemuxOutputStream,10,2,0,3,30,27,1,2,5,0.761904762,245,1.0,1,0.357142857,0.283333333,1,1,22.8,2,1.0,0,"

package org.apache.tools.ant;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.WeakHashMap;


public class DemuxOutputStream extends OutputStream {

    
    private static class BufferInfo {
        
        private ByteArrayOutputStream buffer;

        
         private boolean crSeen = false;
    }

    
    private static final int MAX_SIZE = 1024;

    
    private static final int INTIAL_SIZE = 132;

    
    private static final int CR = 0x0d;

    
    private static final int LF = 0x0a;

    
    private WeakHashMap buffers = new WeakHashMap();

    
    private Project project;

    
    private boolean isErrorStream;

    
    public DemuxOutputStream(Project project, boolean isErrorStream) {
        this.project = project;
        this.isErrorStream = isErrorStream;
    }

    
    private BufferInfo getBufferInfo() {
        Thread current = Thread.currentThread();
        BufferInfo bufferInfo = (BufferInfo) buffers.get(current);
        if (bufferInfo == null) {
            bufferInfo = new BufferInfo();
            bufferInfo.buffer = new ByteArrayOutputStream(INTIAL_SIZE);
            bufferInfo.crSeen = false;
            buffers.put(current, bufferInfo);
        }
        return bufferInfo;
    }

    
    private void resetBufferInfo() {
        Thread current = Thread.currentThread();
        BufferInfo bufferInfo = (BufferInfo) buffers.get(current);
        try {
            bufferInfo.buffer.close();
        } catch (IOException e) {
            
        }
        bufferInfo.buffer = new ByteArrayOutputStream();
        bufferInfo.crSeen = false;
    }

    
    private void removeBuffer() {
        Thread current = Thread.currentThread();
        buffers.remove (current);
    }

    
    public void write(int cc) throws IOException {
        final byte c = (byte) cc;

        BufferInfo bufferInfo = getBufferInfo();

        if (c == '\n') {
            
            bufferInfo.buffer.write(cc);
            processBuffer(bufferInfo.buffer);
        } else {
            if (bufferInfo.crSeen) {
                
                processBuffer(bufferInfo.buffer);
            }
            
            bufferInfo.buffer.write(cc);
        }
        bufferInfo.crSeen = (c == '\r');
        if (!bufferInfo.crSeen && bufferInfo.buffer.size() > MAX_SIZE) {
            processBuffer(bufferInfo.buffer);
        }
    }

    
    protected void processBuffer(ByteArrayOutputStream buffer) {
        String output = buffer.toString();
        project.demuxOutput(output, isErrorStream);
        resetBufferInfo();
    }

    
    protected void processFlush(ByteArrayOutputStream buffer) {
        String output = buffer.toString();
        project.demuxFlush(output, isErrorStream);
        resetBufferInfo();
    }

    
    public void close() throws IOException {
        flush();
        removeBuffer();
    }

    
    public void flush() throws IOException {
        BufferInfo bufferInfo = getBufferInfo();
        if (bufferInfo.buffer.size() > 0) {
            processFlush(bufferInfo.buffer);
        }
    }

    
    public void write(byte[] b, int off, int len) throws IOException {
        
        int offset = off;
        int blockStartOffset = offset;
        int remaining = len;
        BufferInfo bufferInfo = getBufferInfo();
        while (remaining > 0) {
            while (remaining > 0 && b[offset] != LF && b[offset] != CR) {
                offset++;
                remaining--;
            }
            
            int blockLength = offset - blockStartOffset;
            if (blockLength > 0) {
                bufferInfo.buffer.write(b, blockStartOffset, blockLength);
            }
            while (remaining > 0 && (b[offset] == LF || b[offset] == CR)) {
                write(b[offset]);
                offset++;
                remaining--;
            }
            blockStartOffset = offset;
        }
    }
}
"
org.apache.tools.ant.types.ZipScanner,2,3,0,9,20,1,2,7,1,2.0,128,0.0,0,0.987179487,0.625,1,3,63.0,9,4.5,1,"

package org.apache.tools.ant.types;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Map;
import java.util.zip.ZipException;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.ZipResource;
import org.apache.tools.zip.ZipEntry;
import org.apache.tools.zip.ZipFile;


public class ZipScanner extends ArchiveScanner {

    
    protected void fillMapsFromArchive(Resource src, String encoding,
                                       Map fileEntries, Map matchFileEntries,
                                       Map dirEntries, Map matchDirEntries) {
        ZipEntry entry = null;
        ZipFile zf = null;

        File srcFile = null;
        if (src instanceof FileResource) {
            srcFile = ((FileResource) src).getFile();
        } else {
            throw new BuildException(""only file resources are supported"");
        }

        try {
            try {
                zf = new ZipFile(srcFile, encoding);
            } catch (ZipException ex) {
                throw new BuildException(""problem reading "" + srcFile, ex);
            } catch (IOException ex) {
                throw new BuildException(""problem opening "" + srcFile, ex);
            }
            Enumeration e = zf.getEntries();
            while (e.hasMoreElements()) {
                entry = (ZipEntry) e.nextElement();
                Resource r = new ZipResource(srcFile, encoding, entry);
                String name = entry.getName();
                if (entry.isDirectory()) {
                    name = trimSeparator(name);
                    dirEntries.put(name, r);
                    if (match(name)) {
                        matchDirEntries.put(name, r);
                    }
                } else {
                    fileEntries.put(name, r);
                    if (match(name)) {
                        matchFileEntries.put(name, r);
                    }
                }
            }
        } finally {
            if (zf != null) {
                try {
                    zf.close();
                } catch (IOException ex) {
                    
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.ExecTask,43,3,1,25,120,451,9,16,30,0.893374741,920,1.0,5,0.480519481,0.146825397,0,0,19.86046512,15,1.5116,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;
import java.util.Locale;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.RedirectorElement;
import org.apache.tools.ant.util.FileUtils;


public class ExecTask extends Task {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private String os;
    private String osFamily;

    private File dir;
    protected boolean failOnError = false;
    protected boolean newEnvironment = false;
    private Long timeout = null;
    private Environment env = new Environment();
    protected Commandline cmdl = new Commandline();
    private String resultProperty;
    private boolean failIfExecFails = true;
    private String executable;
    private boolean resolveExecutable = false;
    private boolean searchPath = false;
    private boolean spawn = false;
    private boolean incompatibleWithSpawn = false;

    
    private String inputString;
    private File input;
    private File output;
    private File error;

    protected Redirector redirector = new Redirector(this);
    protected RedirectorElement redirectorElement;
    

    
    private boolean vmLauncher = true;


    
    public ExecTask() {
    }

    
    public ExecTask(Task owner) {
        bindToOwner(owner);
    }

    
    public void setSpawn(boolean spawn) {
        this.spawn = spawn;
    }

    
    public void setTimeout(Long value) {
        timeout = value;
        incompatibleWithSpawn = true;
    }

    
    public void setTimeout(Integer value) {
        setTimeout(
            (Long) ((value == null) ? null : new Long(value.intValue())));
    }

    
    public void setExecutable(String value) {
        this.executable = value;
        cmdl.setExecutable(value);
    }

    
    public void setDir(File d) {
        this.dir = d;
    }

    
    public void setOs(String os) {
        this.os = os;
    }

    
    public void setCommand(Commandline cmdl) {
        log(""The command attribute is deprecated.\n""
            + ""Please use the executable attribute and nested arg elements."",
            Project.MSG_WARN);
        this.cmdl = cmdl;
    }

    
    public void setOutput(File out) {
        this.output = out;
        incompatibleWithSpawn = true;
    }

    
    public void setInput(File input) {
        if (inputString != null) {
            throw new BuildException(""The \""input\"" and \""inputstring\"" ""
                + ""attributes cannot both be specified"");
        }
        this.input = input;
        incompatibleWithSpawn = true;
    }

    
    public void setInputString(String inputString) {
        if (input != null) {
            throw new BuildException(""The \""input\"" and \""inputstring\"" ""
                + ""attributes cannot both be specified"");
        }
        this.inputString = inputString;
        incompatibleWithSpawn = true;
    }

    
    public void setLogError(boolean logError) {
        redirector.setLogError(logError);
        incompatibleWithSpawn |= logError;
    }

    
    public void setError(File error) {
        this.error = error;
        incompatibleWithSpawn = true;
    }

    
    public void setOutputproperty(String outputProp) {
        redirector.setOutputProperty(outputProp);
        incompatibleWithSpawn = true;
    }

    
    public void setErrorProperty(String errorProperty) {
        redirector.setErrorProperty(errorProperty);
        incompatibleWithSpawn = true;
    }

    
    public void setFailonerror(boolean fail) {
        failOnError = fail;
        incompatibleWithSpawn |= fail;
    }

    
    public void setNewenvironment(boolean newenv) {
        newEnvironment = newenv;
    }

    
    public void setResolveExecutable(boolean resolveExecutable) {
        this.resolveExecutable = resolveExecutable;
    }

    
    public void setSearchPath(boolean searchPath) {
        this.searchPath = searchPath;
    }

    
    public boolean getResolveExecutable() {
        return resolveExecutable;
    }

    
    public void addEnv(Environment.Variable var) {
        env.addVariable(var);
    }

    
    public Commandline.Argument createArg() {
        return cmdl.createArgument();
    }

    
    public void setResultProperty(String resultProperty) {
        this.resultProperty = resultProperty;
        incompatibleWithSpawn = true;
    }

    
    protected void maybeSetResultPropertyValue(int result) {
        if (resultProperty != null) {
            String res = Integer.toString(result);
            getProject().setNewProperty(resultProperty, res);
        }
    }

    
    public void setFailIfExecutionFails(boolean flag) {
        failIfExecFails = flag;
        incompatibleWithSpawn = true;
    }

    
    public void setAppend(boolean append) {
        redirector.setAppend(append);
        incompatibleWithSpawn = true;
    }

    
    public void addConfiguredRedirector(RedirectorElement redirectorElement) {
        if (this.redirectorElement != null) {
            throw new BuildException(""cannot have > 1 nested <redirector>s"");
        }
        this.redirectorElement = redirectorElement;
        incompatibleWithSpawn = true;
    }


    
    public void setOsFamily(String osFamily) {
        this.osFamily = osFamily.toLowerCase(Locale.US);
    }


    
    protected String resolveExecutable(String exec, boolean mustSearchPath) {
        if (!resolveExecutable) {
            return exec;
        }
        
        File executableFile = getProject().resolveFile(exec);
        if (executableFile.exists()) {
            return executableFile.getAbsolutePath();
        }
        
        if (dir != null) {
            executableFile = FILE_UTILS.resolveFile(dir, exec);
            if (executableFile.exists()) {
                return executableFile.getAbsolutePath();
            }
        }
        
        if (mustSearchPath) {
            Path p = null;
            String[] environment = env.getVariables();
            if (environment != null) {
                for (int i = 0; i < environment.length; i++) {
                    if (isPath(environment[i])) {
                        p = new Path(getProject(), environment[i].substring(5));
                        break;
                    }
                }
            }
            if (p == null) {
                Vector envVars = Execute.getProcEnvironment();
                Enumeration e = envVars.elements();
                while (e.hasMoreElements()) {
                    String line = (String) e.nextElement();
                    if (isPath(line)) {
                        p = new Path(getProject(), line.substring(5));
                        break;
                    }
                }
            }
            if (p != null) {
                String[] dirs = p.list();
                for (int i = 0; i < dirs.length; i++) {
                    executableFile
                        = FILE_UTILS.resolveFile(new File(dirs[i]), exec);
                    if (executableFile.exists()) {
                        return executableFile.getAbsolutePath();
                    }
                }
            }
        }
        
        
        return exec;
    }

    
    public void execute() throws BuildException {
        
        if (!isValidOs()) {
            return;
        }
        File savedDir = dir; 
        cmdl.setExecutable(resolveExecutable(executable, searchPath));
        checkConfiguration();
        try {
            runExec(prepareExec());
        } finally {
            dir = savedDir;
        }
    }

    
    protected void checkConfiguration() throws BuildException {
        if (cmdl.getExecutable() == null) {
            throw new BuildException(""no executable specified"", getLocation());
        }
        if (dir != null && !dir.exists()) {
            throw new BuildException(""The directory "" + dir + "" does not exist"");
        }
        if (dir != null && !dir.isDirectory()) {
            throw new BuildException(dir + "" is not a directory"");
        }
        if (spawn && incompatibleWithSpawn) {
            getProject().log(""spawn does not allow attributes related to input, ""
            + ""output, error, result"", Project.MSG_ERR);
            getProject().log(""spawn also does not allow timeout"", Project.MSG_ERR);
            getProject().log(""finally, spawn is not compatible ""
                + ""with a nested I/O <redirector>"", Project.MSG_ERR);
            throw new BuildException(""You have used an attribute ""
                + ""or nested element which is not compatible with spawn"");
        }
        setupRedirector();
    }

    
    protected void setupRedirector() {
        redirector.setInput(input);
        redirector.setInputString(inputString);
        redirector.setOutput(output);
        redirector.setError(error);
    }

    
    protected boolean isValidOs() {
        
        if (osFamily != null && !Os.isOs(osFamily, null, null, null)) {
            return false;
        }
        
        
        
        String myos = System.getProperty(""os.name"");
        log(""Current OS is "" + myos, Project.MSG_VERBOSE);
        if ((os != null) && (os.indexOf(myos) < 0)) {
            
            log(""This OS, "" + myos
                    + "" was not found in the specified list of valid OSes: "" + os,
                    Project.MSG_VERBOSE);
            return false;
        }
        return true;
    }

    
    public void setVMLauncher(boolean vmLauncher) {
        this.vmLauncher = vmLauncher;
    }

    
    protected Execute prepareExec() throws BuildException {
        
        if (dir == null) {
            dir = getProject().getBaseDir();
        }
        if (redirectorElement != null) {
            redirectorElement.configure(redirector);
        }
        Execute exe = new Execute(createHandler(), createWatchdog());
        exe.setAntRun(getProject());
        exe.setWorkingDirectory(dir);
        exe.setVMLauncher(vmLauncher);
        exe.setSpawn(spawn);
        String[] environment = env.getVariables();
        if (environment != null) {
            for (int i = 0; i < environment.length; i++) {
                log(""Setting environment variable: "" + environment[i],
                    Project.MSG_VERBOSE);
            }
        }
        exe.setNewenvironment(newEnvironment);
        exe.setEnvironment(environment);
        return exe;
    }

    
    protected final void runExecute(Execute exe) throws IOException {
        int returnCode = -1; 

        if (!spawn) {
            returnCode = exe.execute();

            
            if (exe.killedProcess()) {
                String msg = ""Timeout: killed the sub-process"";
                if (failOnError) {
                    throw new BuildException(msg);
                } else {
                    log(msg, Project.MSG_WARN);
                }
            }
            maybeSetResultPropertyValue(returnCode);
            redirector.complete();
            if (Execute.isFailure(returnCode)) {
                if (failOnError) {
                    throw new BuildException(getTaskType() + "" returned: ""
                        + returnCode, getLocation());
                } else {
                    log(""Result: "" + returnCode, Project.MSG_ERR);
                }
            }
        } else {
            exe.spawn();
        }
    }

    
    protected void runExec(Execute exe) throws BuildException {
        
        log(cmdl.describeCommand(), Project.MSG_VERBOSE);

        exe.setCommandline(cmdl.getCommandline());
        try {
            runExecute(exe);
        } catch (IOException e) {
            if (failIfExecFails) {
                throw new BuildException(""Execute failed: "" + e.toString(), e,
                                         getLocation());
            } else {
                log(""Execute failed: "" + e.toString(), Project.MSG_ERR);
            }
        } finally {
            
            logFlush();
        }
    }

    
    protected ExecuteStreamHandler createHandler() throws BuildException {
        return redirector.createHandler();
    }

    
    protected ExecuteWatchdog createWatchdog() throws BuildException {
        return (timeout == null)
            ? null : new ExecuteWatchdog(timeout.longValue());
    }

    
    protected void logFlush() {
    }

    private boolean isPath(String line) {
        return line.startsWith(""PATH="") || line.startsWith(""Path="");
    }

}
"
org.apache.tools.ant.types.DataType,22,2,28,37,44,183,31,6,7,0.523809524,271,1.0,1,0.3,0.198863636,1,2,11.22727273,3,1.3182,0,"

package org.apache.tools.ant.types;

import java.util.Stack;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.util.IdentityStack;


public abstract class DataType extends ProjectComponent implements Cloneable {
    

    
    protected Reference ref;

    
    protected boolean checked = true;
    

    
    public boolean isReference() {
        return ref != null;
    }

    
    public void setRefid(final Reference ref) {
        this.ref = ref;
        checked = false;
    }

    
    protected String getDataTypeName() {
        return ComponentHelper.getElementName(getProject(), this, true);
    }

    
    protected void dieOnCircularReference() {
        dieOnCircularReference(getProject());
    }

    
    protected void dieOnCircularReference(Project p) {
        if (checked || !isReference()) {
            return;
        }
        dieOnCircularReference(new IdentityStack(this), p);
    }

    
    protected void dieOnCircularReference(final Stack stack,
                                          final Project project)
        throws BuildException {

        if (checked || !isReference()) {
            return;
        }
        Object o = ref.getReferencedObject(project);

        if (o instanceof DataType) {
            IdentityStack id = IdentityStack.getInstance(stack);

            if (id.contains(o)) {
                throw circularReference();
            } else {
                id.push(o);
                ((DataType) o).dieOnCircularReference(id, project);
                id.pop();
            }
        }
        checked = true;
    }

    
    public static void invokeCircularReferenceCheck(DataType dt, Stack stk,
                                                    Project p) {
        dt.dieOnCircularReference(stk, p);
    }

    
    protected Object getCheckedRef() {
        return getCheckedRef(getProject());
    }

    
    protected Object getCheckedRef(Project p) {
        return getCheckedRef(getClass(), getDataTypeName(), p);
    }

    
    protected Object getCheckedRef(final Class requiredClass,
                                   final String dataTypeName) {
        return getCheckedRef(requiredClass, dataTypeName, getProject());
    }

    
    protected Object getCheckedRef(final Class requiredClass,
                                   final String dataTypeName, final Project project) {
        if (project == null) {
            throw new BuildException(""No Project specified"");
        }
        dieOnCircularReference(project);
        Object o = ref.getReferencedObject(project);
        if (!(requiredClass.isAssignableFrom(o.getClass()))) {
            log(""Class "" + o.getClass() + "" is not a subclass of "" + requiredClass,
                    Project.MSG_VERBOSE);
            String msg = ref.getRefId() + "" doesn\'t denote a "" + dataTypeName;
            throw new BuildException(msg);
        }
        return o;
    }

    
    protected BuildException tooManyAttributes() {
        return new BuildException(""You must not specify more than one ""
            + ""attribute when using refid"");
    }

    
    protected BuildException noChildrenAllowed() {
        return new BuildException(""You must not specify nested elements ""
            + ""when using refid"");
    }

    
    protected BuildException circularReference() {
        return new BuildException(""This data type contains a circular ""
            + ""reference."");
    }

    
    protected boolean isChecked() {
        return checked;
    }

    
    protected void setChecked(final boolean checked) {
        this.checked = checked;
    }

    
    public Reference getRefid() {
        return ref;
    }

    
    protected void checkAttributesAllowed() {
        if (isReference()) {
            throw tooManyAttributes();
        }
    }

    
    protected void checkChildrenAllowed() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
    }

    
    public String toString() {
        String d = getDescription();
        return d == null ? getDataTypeName() : getDataTypeName() + "" "" + d;
    }

    
    public Object clone() throws CloneNotSupportedException {
        DataType dt = (DataType) super.clone();
        dt.setDescription(getDescription());
        if (getRefid() != null) {
            dt.setRefid(getRefid());
        }
        dt.setChecked(isChecked());
        return dt;
    }
}

"
org.apache.tools.ant.types.ArchiveFileSet,34,5,2,15,67,295,4,11,29,0.842975207,586,0.818181818,1,0.745901639,0.173202614,3,15,15.91176471,5,1.7941,3,"
package org.apache.tools.ant.types;

import java.io.File;
import java.util.Iterator;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.zip.UnixStat;


public abstract class ArchiveFileSet extends FileSet {

    private static final int BASE_OCTAL = 8;

    
    public static final int DEFAULT_DIR_MODE =
        UnixStat.DIR_FLAG  | UnixStat.DEFAULT_DIR_PERM;

    
    public static final int DEFAULT_FILE_MODE =
        UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM;

    private Resource src          = null;
    private String prefix         = """";
    private String fullpath       = """";
    private boolean hasDir        = false;
    private int fileMode          = DEFAULT_FILE_MODE;
    private int dirMode           = DEFAULT_DIR_MODE;

    private boolean fileModeHasBeenSet = false;
    private boolean dirModeHasBeenSet  = false;

    
    public ArchiveFileSet() {
        super();
    }

    
    protected ArchiveFileSet(FileSet fileset) {
        super(fileset);
    }

    
    protected ArchiveFileSet(ArchiveFileSet fileset) {
        super(fileset);
        src = fileset.src;
        prefix = fileset.prefix;
        fullpath = fileset.fullpath;
        hasDir = fileset.hasDir;
        fileMode = fileset.fileMode;
        dirMode = fileset.dirMode;
        fileModeHasBeenSet = fileset.fileModeHasBeenSet;
        dirModeHasBeenSet = fileset.dirModeHasBeenSet;
    }

    
    public void setDir(File dir) throws BuildException {
        checkAttributesAllowed();
        if (src != null) {
            throw new BuildException(""Cannot set both dir and src attributes"");
        } else {
            super.setDir(dir);
            hasDir = true;
        }
    }

    
    public void addConfigured(ResourceCollection a) {
        checkChildrenAllowed();
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported as archives"");
        }
        setSrcResource((Resource) a.iterator().next());
    }

    
    public void setSrc(File srcFile) {
        setSrcResource(new FileResource(srcFile));
    }

    
    public void setSrcResource(Resource src) {
        checkArchiveAttributesAllowed();
        if (hasDir) {
            throw new BuildException(""Cannot set both dir and src attributes"");
        }
        this.src = src;
    }

    
    public File getSrc(Project p) {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(p)).getSrc(p);
        }
        return getSrc();
    }

    
    public File getSrc() {
        if (src instanceof FileResource) {
            return ((FileResource) src).getFile();
        }
        return null;
    }

    
    public void setPrefix(String prefix) {
        checkArchiveAttributesAllowed();
        if (!prefix.equals("""") && !fullpath.equals("""")) {
            throw new BuildException(""Cannot set both fullpath and prefix attributes"");
        }
        this.prefix = prefix;
    }

    
    public String getPrefix(Project p) {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(p)).getPrefix(p);
        }
        return prefix;
    }

    
    public void setFullpath(String fullpath) {
        checkArchiveAttributesAllowed();
        if (!prefix.equals("""") && !fullpath.equals("""")) {
            throw new BuildException(""Cannot set both fullpath and prefix attributes"");
        }
        this.fullpath = fullpath;
    }

    
    public String getFullpath(Project p) {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(p)).getFullpath(p);
        }
        return fullpath;
    }

    
    protected abstract ArchiveScanner newArchiveScanner();

    
    public DirectoryScanner getDirectoryScanner(Project p) {
        if (isReference()) {
            return getRef(p).getDirectoryScanner(p);
        }
        if (src == null) {
            return super.getDirectoryScanner(p);
        }
        if (!src.isExists()) {
            throw new BuildException(""the archive doesn't exist"");
        }
        if (src.isDirectory()) {
            throw new BuildException(""the archive can't be a directory"");
        }
        ArchiveScanner as = newArchiveScanner();
        as.setSrc(src);
        super.setDir(p.getBaseDir());
        setupDirectoryScanner(as, p);
        as.init();
        return as;
    }

    
    public Iterator iterator() {
        if (isReference()) {
            return ((ResourceCollection) (getRef(getProject()))).iterator();
        }
        if (src == null) {
            return super.iterator();
        }
        ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());
        return as.getResourceFiles();
    }

    
    public int size() {
        if (isReference()) {
            return ((ResourceCollection) (getRef(getProject()))).size();
        }
        if (src == null) {
            return super.size();
        }
        ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());
        return as.getIncludedFilesCount();
    }

    
    public boolean isFilesystemOnly() {
        return src == null;
    }

    
    public void setFileMode(String octalString) {
        checkArchiveAttributesAllowed();
        integerSetFileMode(Integer.parseInt(octalString, BASE_OCTAL));
    }

    
    public void integerSetFileMode(int mode) {
        fileModeHasBeenSet = true;
        this.fileMode = UnixStat.FILE_FLAG | mode;
    }

    
    public int getFileMode(Project p) {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(p)).getFileMode(p);
        }
        return fileMode;
    }

    
    public boolean hasFileModeBeenSet() {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(getProject())).hasFileModeBeenSet();
        }
        return fileModeHasBeenSet;
    }

    
    public void setDirMode(String octalString) {
        checkArchiveAttributesAllowed();
        integerSetDirMode(Integer.parseInt(octalString, BASE_OCTAL));
    }

    
    public void integerSetDirMode(int mode) {
        dirModeHasBeenSet = true;
        this.dirMode = UnixStat.DIR_FLAG | mode;
    }

    
    public int getDirMode(Project p) {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(p)).getDirMode(p);
        }
        return dirMode;
    }

    
    public boolean hasDirModeBeenSet() {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(getProject())).hasDirModeBeenSet();
        }
        return dirModeHasBeenSet;
    }

    
    protected void configureFileSet(ArchiveFileSet zfs) {
        zfs.setPrefix(prefix);
        zfs.setFullpath(fullpath);
        zfs.fileModeHasBeenSet = fileModeHasBeenSet;
        zfs.fileMode = fileMode;
        zfs.dirModeHasBeenSet = dirModeHasBeenSet;
        zfs.dirMode = dirMode;
    }

    
    public Object clone() {
        if (isReference()) {
            return ((ArchiveFileSet) getRef(getProject())).clone();
        } else {
            return super.clone();
        }
    }

    
    public String toString() {
        if (hasDir && getProject() != null) {
            return super.toString();
        } else if (src != null) {
            return src.getName();
        } else {
            return null;
        }
    }

    
    public String getPrefix() {
        return prefix;
    }

    
    public String getFullpath() {
        return fullpath;
    }

    
    public int getFileMode() {
        return fileMode;
    }

    
    public int getDirMode() {
        return dirMode;
    }

    
    private void checkArchiveAttributesAllowed() {
        if (getProject() == null
            || (isReference()
                && (getRefid().getReferencedObject(
                        getProject())
                    instanceof ArchiveFileSet))) {
            checkAttributesAllowed();
        }
    }
}
"
org.apache.tools.ant.taskdefs.rmic.XNewRmic,2,3,0,3,4,1,1,2,1,2.0,19,0.0,0,0.9375,1.0,2,2,8.0,1,0.5,0,"
package org.apache.tools.ant.taskdefs.rmic;

import org.apache.tools.ant.types.Commandline;


public class XNewRmic extends ForkingSunRmic {

    
    public static final String COMPILER_NAME = ""xnew"";

    
    public XNewRmic() {
    }

    
    protected Commandline setupRmicCommand() {
        String[] options = new String[] {
                ""-Xnew""
        };
        Commandline commandline = super.setupRmicCommand(options);
        return commandline;
    }

}
"
org.apache.tools.ant.taskdefs.optional.junit.Enumerations,3,1,0,3,6,3,1,2,2,2.0,16,0.0,0,0.0,0.333333333,0,0,4.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.junit;

import java.util.Enumeration;
import java.util.NoSuchElementException;


public final class Enumerations {

        private Enumerations() {
        }

        
        public static Enumeration fromArray(Object[] array) {
                return new ArrayEnumeration(array);
        }

        
        public static Enumeration fromCompound(Enumeration[] enums) {
                return new CompoundEnumeration(enums);
        }

}



class ArrayEnumeration implements Enumeration {

        
        private Object[] array;

        
        private int pos;

        
        public ArrayEnumeration(Object[] array) {
                this.array = array;
                this.pos = 0;
        }
        
        public boolean hasMoreElements() {
                return (pos < array.length);
        }

        
        public Object nextElement() throws NoSuchElementException {
                if (hasMoreElements()) {
                        Object o = array[pos];
                        pos++;
                        return o;
                }
                throw new NoSuchElementException();
        }
}

 class CompoundEnumeration implements Enumeration {

        
        private Enumeration[] enumArray;

        
        private int index = 0;

    public CompoundEnumeration(Enumeration[] enumarray) {
                this.enumArray = enumarray;
    }

        
    public boolean hasMoreElements() {
                while (index < enumArray.length) {
                        if (enumArray[index] != null && enumArray[index].hasMoreElements()) {
                                return true;
                        }
                        index++;
                }
                return false;
    }

        
    public Object nextElement() throws NoSuchElementException {
                if (hasMoreElements()) {
                        return enumArray[index].nextElement();
                }
                throw new NoSuchElementException();
    }
}


"
org.apache.tools.ant.taskdefs.Nice,4,3,0,3,16,2,0,3,4,0.666666667,76,1.0,0,0.925,0.5,1,1,17.5,3,1.25,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class Nice extends Task {

    
    private Integer newPriority;

    
    private String currentPriority;



    
    public void execute() throws BuildException {

        Thread self = Thread.currentThread();
        int priority = self.getPriority();
        if (currentPriority != null) {
            String current = Integer.toString(priority);
            getProject().setNewProperty(currentPriority, current);
        }
        
        if (newPriority != null && priority != newPriority.intValue()) {
            try {
                self.setPriority(newPriority.intValue());
            } catch (SecurityException e) {
                
                log(""Unable to set new priority -a security manager is in the way"",
                        Project.MSG_WARN);
            } catch (IllegalArgumentException iae) {
                throw new BuildException(""Priority out of range"", iae);
            }
        }
    }

    
    public void setCurrentPriority(String currentPriority) {
        this.currentPriority = currentPriority;
    }

    
    public void setNewPriority(int newPriority) {
        if (newPriority < Thread.MIN_PRIORITY || newPriority > Thread.MAX_PRIORITY) {
            throw new BuildException(""The thread priority is out of the range 1-10"");
        }
        this.newPriority = new Integer(newPriority);
    }

}
"
org.apache.tools.ant.taskdefs.optional.Script,11,3,0,8,26,0,0,8,11,0.0,76,1.0,1,0.787234043,0.287878788,2,2,5.818181818,1,0.9091,0,"
package org.apache.tools.ant.taskdefs.optional;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.ScriptRunnerHelper;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;


public class Script extends Task {

    private ScriptRunnerHelper helper = new ScriptRunnerHelper();

    
    public void setProject(Project project) {
        super.setProject(project);
        helper.setProjectComponent(this);
    }

    
    public void execute() throws BuildException {
        helper.getScriptRunner().executeScript(""ANT"");
    }

    
    public void setManager(String manager) {
        helper.setManager(manager);
    }

    
    public void setLanguage(String language) {
        helper.setLanguage(language);
    }

    
    public void setSrc(String fileName) {
        helper.setSrc(new File(fileName));
    }

    
    public void addText(String text) {
        helper.addText(text);
    }

    
    public void setClasspath(Path classpath) {
        helper.setClasspath(classpath);
    }

    
    public Path createClasspath() {
        return helper.createClasspath();
    }

    
    public void setClasspathRef(Reference r) {
        helper.setClasspathRef(r);
    }

    
    public void setSetBeans(boolean setBeans) {
        helper.setSetBeans(setBeans);
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitVersionHelper,4,1,0,7,20,4,4,3,2,0.888888889,187,0.333333333,0,0.0,0.5,0,0,45.0,9,3.5,1,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.lang.reflect.Method;
import junit.framework.Test;
import junit.framework.TestCase;


public class JUnitVersionHelper {

    private static Method testCaseName = null;
    static {
        try {
            testCaseName = TestCase.class.getMethod(""getName"", new Class[0]);
        } catch (NoSuchMethodException e) {
            
            try {
                testCaseName = TestCase.class.getMethod(""name"", new Class[0]);
            } catch (NoSuchMethodException e2) {
                
            }
        }
    }

    
    public static String getTestCaseName(Test t) {
        if (t != null && t.getClass().getName().equals(""junit.framework.JUnit4TestCaseFacade"")) {
            
            String name = t.toString();
            if (name.endsWith("")"")) {
                int paren = name.lastIndexOf('(');
                return name.substring(0, paren);
            } else {
                return name;
            }
        }
        if (t instanceof TestCase && testCaseName != null) {
            try {
                return (String) testCaseName.invoke(t, new Object[0]);
            } catch (Throwable e) {
                
            }
        } else {
            try {
                Method getNameMethod = null;
                try {
                    getNameMethod =
                        t.getClass().getMethod(""getName"", new Class [0]);
                } catch (NoSuchMethodException e) {
                    getNameMethod = t.getClass().getMethod(""name"",
                                                           new Class [0]);
                }
                if (getNameMethod != null
                    && getNameMethod.getReturnType() == String.class) {
                    return (String) getNameMethod.invoke(t, new Object[0]);
                }
            } catch (Throwable e) {
                
            }
        }
        return ""unknown"";
    }

    
    static String getTestCaseClassName(Test test) {
        String className = test.getClass().getName();
        if (test instanceof JUnitTaskMirrorImpl.VmExitErrorTest) {
            className = ((JUnitTaskMirrorImpl.VmExitErrorTest) test).getClassName();
        } else
        if (className.equals(""junit.framework.JUnit4TestCaseFacade"")) {
            
            
            String name = test.toString();
            int paren = name.lastIndexOf('(');
            if (paren != -1 && name.endsWith("")"")) {
                className = name.substring(paren + 1, name.length() - 1);
            }
        }
        return className;
    }

}
"
org.apache.tools.ant.AntClassLoader,56,2,2,51,169,1200,37,16,35,0.848863636,1842,0.875,2,0.409638554,0.155844156,1,5,31.60714286,14,2.1964,6,"

package org.apache.tools.ant;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Constructor;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.jar.Attributes;
import java.util.jar.Attributes.Name;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.CollectionUtils;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.LoaderUtils;
import org.apache.tools.ant.launch.Locator;


public class AntClassLoader extends ClassLoader implements SubBuildListener {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private class ResourceEnumeration implements Enumeration {
        
        private String resourceName;

        
        private int pathElementsIndex;

        
        private URL nextResource;

        
        ResourceEnumeration(String name) {
            this.resourceName = name;
            this.pathElementsIndex = 0;
            findNextResource();
        }

        
        public boolean hasMoreElements() {
            return (this.nextResource != null);
        }

        
        public Object nextElement() {
            URL ret = this.nextResource;
            findNextResource();
            return ret;
        }

        
        private void findNextResource() {
            URL url = null;
            while ((pathElementsIndex < pathComponents.size())
                   && (url == null)) {
                try {
                    File pathComponent
                        = (File) pathComponents.elementAt(pathElementsIndex);
                    url = getResourceURL(pathComponent, this.resourceName);
                    pathElementsIndex++;
                } catch (BuildException e) {
                    
                    
                }
            }
            this.nextResource = url;
        }
    }

    
    private static final int BUFFER_SIZE = 8192;
    
    private static final int NUMBER_OF_STRINGS = 256;

    
    private Vector pathComponents  = new Vector();

    
    private Project project;

    
    private boolean parentFirst = true;

    
    private Vector systemPackages = new Vector();

    
    private Vector loaderPackages = new Vector();

    
    private boolean ignoreBase = false;

    
    private ClassLoader parent = null;

    
    private Hashtable zipFiles = new Hashtable();

    
    private static Map pathMap = Collections.synchronizedMap(new HashMap());

    
    private ClassLoader savedContextLoader = null;
    
    private boolean isContextLoaderSaved = false;

    
    public AntClassLoader(
        ClassLoader parent, Project project, Path classpath) {
        setParent(parent);
        setClassPath(classpath);
        setProject(project);
    }

    
    public AntClassLoader() {
        setParent(null);
    }

    
    public AntClassLoader(Project project, Path classpath) {
        setParent(null);
        setProject(project);
        setClassPath(classpath);
    }

    
    public AntClassLoader(ClassLoader parent, Project project, Path classpath,
                          boolean parentFirst) {
        this(project, classpath);
        if (parent != null) {
            setParent(parent);
        }
        setParentFirst(parentFirst);
        addJavaLibraries();
    }


    
    public AntClassLoader(Project project, Path classpath,
                          boolean parentFirst) {
        this(null, project, classpath, parentFirst);
    }

    
    public AntClassLoader(ClassLoader parent, boolean parentFirst) {
        setParent(parent);
        project = null;
        this.parentFirst = parentFirst;
    }

    
    public void setProject(Project project) {
        this.project = project;
        if (project != null) {
            project.addBuildListener(this);
        }
    }

    
    public void setClassPath(Path classpath) {
        pathComponents.removeAllElements();
        if (classpath != null) {
            Path actualClasspath = classpath.concatSystemClasspath(""ignore"");
            String[] pathElements = actualClasspath.list();
            for (int i = 0; i < pathElements.length; ++i) {
                try {
                    addPathElement(pathElements[i]);
                } catch (BuildException e) {
                    
                    
                }
            }
        }
    }

    
    public void setParent(ClassLoader parent) {
        if (parent == null) {
            this.parent = AntClassLoader.class.getClassLoader();
        } else {
            this.parent = parent;
        }
    }

    
    public void setParentFirst(boolean parentFirst) {
        this.parentFirst = parentFirst;
    }


    
    protected void log(String message, int priority) {
        if (project != null) {
            project.log(message, priority);
        }
        
        
        
    }

    
    public void setThreadContextLoader() {
        if (isContextLoaderSaved) {
            throw new BuildException(""Context loader has not been reset"");
        }
        if (LoaderUtils.isContextLoaderAvailable()) {
            savedContextLoader = LoaderUtils.getContextClassLoader();
            ClassLoader loader = this;
            if (project != null
                && ""only"".equals(project.getProperty(""build.sysclasspath""))) {
                loader = this.getClass().getClassLoader();
            }
            LoaderUtils.setContextClassLoader(loader);
            isContextLoaderSaved = true;
        }
    }

    
    public void resetThreadContextLoader() {
        if (LoaderUtils.isContextLoaderAvailable()
            && isContextLoaderSaved) {
            LoaderUtils.setContextClassLoader(savedContextLoader);
            savedContextLoader = null;
            isContextLoaderSaved = false;
        }
    }


    
    public void addPathElement(String pathElement) throws BuildException {
        File pathComponent
            = project != null ? project.resolveFile(pathElement)
            : new File(pathElement);
        try {
            addPathFile(pathComponent);
        } catch (IOException e) {
            throw new BuildException(e);
        }
    }

    
    protected void addPathFile(File pathComponent) throws IOException {
        pathComponents.addElement(pathComponent);
        if (pathComponent.isDirectory()) {
            return;
        }

        String absPathPlusTimeAndLength =
            pathComponent.getAbsolutePath() + pathComponent.lastModified() + ""-""
            + pathComponent.length();
        String classpath = (String) pathMap.get(absPathPlusTimeAndLength);
        if (classpath == null) {
            ZipFile jarFile = null;
            InputStream manifestStream = null;
            try {
                jarFile = new ZipFile(pathComponent);
                manifestStream
                    = jarFile.getInputStream(new ZipEntry(""META-INF/MANIFEST.MF""));

                if (manifestStream == null) {
                    return;
                }
                Reader manifestReader
                    = new InputStreamReader(manifestStream, ""UTF-8"");
                org.apache.tools.ant.taskdefs.Manifest manifest
                    = new org.apache.tools.ant.taskdefs.Manifest(manifestReader);
                classpath
                    = manifest.getMainSection().getAttributeValue(""Class-Path"");

            } catch (org.apache.tools.ant.taskdefs.ManifestException e) {
                
            } finally {
                if (manifestStream != null) {
                    manifestStream.close();
                }
                if (jarFile != null) {
                    jarFile.close();
                }
            }
            if (classpath == null) {
                classpath = """";
            }
            pathMap.put(absPathPlusTimeAndLength, classpath);
        }

        if (!"""".equals(classpath)) {
            URL baseURL = FILE_UTILS.getFileURL(pathComponent);
            StringTokenizer st = new StringTokenizer(classpath);
            while (st.hasMoreTokens()) {
                String classpathElement = st.nextToken();
                URL libraryURL = new URL(baseURL, classpathElement);
                if (!libraryURL.getProtocol().equals(""file"")) {
                    log(""Skipping jar library "" + classpathElement
                        + "" since only relative URLs are supported by this""
                        + "" loader"", Project.MSG_VERBOSE);
                    continue;
                }
                String decodedPath = Locator.decodeUri(libraryURL.getFile());
                File libraryFile = new File(decodedPath);
                if (libraryFile.exists() && !isInPath(libraryFile)) {
                    addPathFile(libraryFile);
                }
            }
        }
    }

    
    public String getClasspath() {
        StringBuffer sb = new StringBuffer();
        boolean firstPass = true;
        Enumeration componentEnum = pathComponents.elements();
        while (componentEnum.hasMoreElements()) {
            if (!firstPass) {
                sb.append(System.getProperty(""path.separator""));
            } else {
                firstPass = false;
            }
            sb.append(((File) componentEnum.nextElement()).getAbsolutePath());
        }
        return sb.toString();
    }

    
    public synchronized void setIsolated(boolean isolated) {
        ignoreBase = isolated;
    }

    
    public static void initializeClass(Class theClass) {
        
        
        
        

        final Constructor[] cons = theClass.getDeclaredConstructors();
        
        if (cons != null) {
            if (cons.length > 0 && cons[0] != null) {
                final String[] strs = new String[NUMBER_OF_STRINGS];
                try {
                    cons[0].newInstance((Object[]) strs);
                    
                    
                } catch (Exception e) {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                }
            }
        }
    }

    
    public void addSystemPackageRoot(String packageRoot) {
        systemPackages.addElement(packageRoot
                                  + (packageRoot.endsWith(""."") ? """" : "".""));
    }

    
    public void addLoaderPackageRoot(String packageRoot) {
        loaderPackages.addElement(packageRoot
                                  + (packageRoot.endsWith(""."") ? """" : "".""));
    }

    
    public Class forceLoadClass(String classname)
        throws ClassNotFoundException {
        log(""force loading "" + classname, Project.MSG_DEBUG);

        Class theClass = findLoadedClass(classname);

        if (theClass == null) {
            theClass = findClass(classname);
        }

        return theClass;
    }

    
    public Class forceLoadSystemClass(String classname)
        throws ClassNotFoundException {
        log(""force system loading "" + classname, Project.MSG_DEBUG);

        Class theClass = findLoadedClass(classname);

        if (theClass == null) {
            theClass = findBaseClass(classname);
        }

        return theClass;
    }

    
    public InputStream getResourceAsStream(String name) {

        InputStream resourceStream = null;
        if (isParentFirst(name)) {
            resourceStream = loadBaseResource(name);
            if (resourceStream != null) {
                log(""ResourceStream for "" + name
                    + "" loaded from parent loader"", Project.MSG_DEBUG);

            } else {
                resourceStream = loadResource(name);
                if (resourceStream != null) {
                    log(""ResourceStream for "" + name
                        + "" loaded from ant loader"", Project.MSG_DEBUG);
                }
            }
        } else {
            resourceStream = loadResource(name);
            if (resourceStream != null) {
                log(""ResourceStream for "" + name
                    + "" loaded from ant loader"", Project.MSG_DEBUG);

            } else {
                resourceStream = loadBaseResource(name);
                if (resourceStream != null) {
                    log(""ResourceStream for "" + name
                        + "" loaded from parent loader"", Project.MSG_DEBUG);
                }
            }
        }

        if (resourceStream == null) {
            log(""Couldn't load ResourceStream for "" + name,
                Project.MSG_DEBUG);
        }

        return resourceStream;
    }

    
    private InputStream loadResource(String name) {
        
        
        InputStream stream = null;

        Enumeration e = pathComponents.elements();
        while (e.hasMoreElements() && stream == null) {
            File pathComponent = (File) e.nextElement();
            stream = getResourceStream(pathComponent, name);
        }
        return stream;
    }

    
    private InputStream loadBaseResource(String name) {
        if (parent == null) {
            return getSystemResourceAsStream(name);
        } else {
            return parent.getResourceAsStream(name);
        }
    }

    
    private InputStream getResourceStream(File file, String resourceName) {
        try {
            if (!file.exists()) {
                return null;
            }

            if (file.isDirectory()) {
                File resource = new File(file, resourceName);

                if (resource.exists()) {
                    return new FileInputStream(resource);
                }
            } else {
                
                ZipFile zipFile = (ZipFile) zipFiles.get(file);
                if (zipFile == null) {
                    zipFile = new ZipFile(file);
                    zipFiles.put(file, zipFile);
                }
                ZipEntry entry = zipFile.getEntry(resourceName);
                if (entry != null) {
                    return zipFile.getInputStream(entry);
                }
            }
        } catch (Exception e) {
            log(""Ignoring Exception "" + e.getClass().getName()
                + "": "" + e.getMessage() + "" reading resource "" + resourceName
                + "" from "" + file, Project.MSG_VERBOSE);
        }

        return null;
    }

    
    private boolean isParentFirst(String resourceName) {
        
        
        
        

        

        boolean useParentFirst = parentFirst;

        for (Enumeration e = systemPackages.elements(); e.hasMoreElements();) {
            String packageName = (String) e.nextElement();
            if (resourceName.startsWith(packageName)) {
                useParentFirst = true;
                break;
            }
        }

        for (Enumeration e = loaderPackages.elements(); e.hasMoreElements();) {
            String packageName = (String) e.nextElement();
            if (resourceName.startsWith(packageName)) {
                useParentFirst = false;
                break;
            }
        }

        return useParentFirst;
    }

    
    private ClassLoader getRootLoader() {
        ClassLoader ret = getClass().getClassLoader();
        while (ret != null && ret.getParent() != null) {
            ret = ret.getParent();
        }
        return ret;
    }

    
    public URL getResource(String name) {
        
        
        URL url = null;
        if (isParentFirst(name)) {
            url = (parent == null) ? super.getResource(name)
                : parent.getResource(name);
        }

        if (url != null) {
            log(""Resource "" + name + "" loaded from parent loader"",
                Project.MSG_DEBUG);

        } else {
            
            
            Enumeration e = pathComponents.elements();
            while (e.hasMoreElements() && url == null) {
                File pathComponent = (File) e.nextElement();
                url = getResourceURL(pathComponent, name);
                if (url != null) {
                    log(""Resource "" + name
                        + "" loaded from ant loader"",
                        Project.MSG_DEBUG);
                }
            }
        }

        if (url == null && !isParentFirst(name)) {
            
            if (ignoreBase) {
                url = (getRootLoader() == null) ? null
                    : getRootLoader().getResource(name);
            } else {
                url = (parent == null) ? super.getResource(name)
                    : parent.getResource(name);
            }
            if (url != null) {
                log(""Resource "" + name + "" loaded from parent loader"",
                    Project.MSG_DEBUG);
            }
        }

        if (url == null) {
            log(""Couldn't load Resource "" + name, Project.MSG_DEBUG);
        }

        return url;
    }

    
    protected Enumeration findResources(String name) throws IOException {
        Enumeration mine = new ResourceEnumeration(name);
        Enumeration base;
        if (parent != null && parent != getParent()) {
            
            base = parent.getResources(name);
            
        } else {
            
            
            base = new CollectionUtils.EmptyEnumeration();
        }
        if (isParentFirst(name)) {
            
            return CollectionUtils.append(base, mine);
        } else if (ignoreBase) {
            return getRootLoader() == null
                ? mine
                : CollectionUtils.append(
                    mine, getRootLoader().getResources(name));
        } else {
            
            return CollectionUtils.append(mine, base);
        }
    }

    
    protected URL getResourceURL(File file, String resourceName) {
        try {
            if (!file.exists()) {
                return null;
            }

            if (file.isDirectory()) {
                File resource = new File(file, resourceName);

                if (resource.exists()) {
                    try {
                        return FILE_UTILS.getFileURL(resource);
                    } catch (MalformedURLException ex) {
                        return null;
                    }
                }
            } else {
                ZipFile zipFile = (ZipFile) zipFiles.get(file);
                if (zipFile == null) {
                    zipFile = new ZipFile(file);
                    zipFiles.put(file, zipFile);
                }

                ZipEntry entry = zipFile.getEntry(resourceName);
                if (entry != null) {
                    try {
                        return new URL(""jar:"" + FILE_UTILS.getFileURL(file)
                                       + ""!/"" + entry);
                    } catch (MalformedURLException ex) {
                        return null;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    
    protected synchronized Class loadClass(String classname, boolean resolve)
        throws ClassNotFoundException {
        
        
        

        Class theClass = findLoadedClass(classname);
        if (theClass != null) {
            return theClass;
        }

        if (isParentFirst(classname)) {
            try {
                theClass = findBaseClass(classname);
                log(""Class "" + classname + "" loaded from parent loader ""
                    + ""(parentFirst)"", Project.MSG_DEBUG);
            } catch (ClassNotFoundException cnfe) {
                theClass = findClass(classname);
                log(""Class "" + classname + "" loaded from ant loader ""
                    + ""(parentFirst)"", Project.MSG_DEBUG);
            }
        } else {
            try {
                theClass = findClass(classname);
                log(""Class "" + classname + "" loaded from ant loader"",
                    Project.MSG_DEBUG);
            } catch (ClassNotFoundException cnfe) {
                if (ignoreBase) {
                    throw cnfe;
                }
                theClass = findBaseClass(classname);
                log(""Class "" + classname + "" loaded from parent loader"",
                    Project.MSG_DEBUG);
            }
        }

        if (resolve) {
            resolveClass(theClass);
        }

        return theClass;
    }

    
    private String getClassFilename(String classname) {
        return classname.replace('.', '/') + "".class"";
    }

    
    protected Class defineClassFromData(File container, byte[] classData,
                                        String classname) throws IOException {
        definePackage(container, classname);
        
        
        
        return defineClass(classname, classData, 0, classData.length,
                           Project.class.getProtectionDomain());
    }

    
    protected void definePackage(File container, String className)
        throws IOException {
        int classIndex = className.lastIndexOf('.');
        if (classIndex == -1) {
            return;
        }

        String packageName = className.substring(0, classIndex);
        if (getPackage(packageName) != null) {
            
            return;
        }

        
        Manifest manifest = getJarManifest(container);

        if (manifest == null) {
            definePackage(packageName, null, null, null, null, null,
                          null, null);
        } else {
            definePackage(container, packageName, manifest);
        }
    }

    
    private Manifest getJarManifest(File container) throws IOException {
        if (container.isDirectory()) {
            return null;
        }
        JarFile jarFile = null;
        try {
            jarFile = new JarFile(container);
            return jarFile.getManifest();
        } finally {
            if (jarFile != null) {
                jarFile.close();
            }
        }
    }

    
    protected void definePackage(File container, String packageName,
                                 Manifest manifest) {
        String sectionName = packageName.replace('.', '/') + ""/"";

        String specificationTitle = null;
        String specificationVendor = null;
        String specificationVersion = null;
        String implementationTitle = null;
        String implementationVendor = null;
        String implementationVersion = null;
        String sealedString = null;
        URL sealBase = null;

        Attributes sectionAttributes = manifest.getAttributes(sectionName);
        if (sectionAttributes != null) {
            specificationTitle
                = sectionAttributes.getValue(Name.SPECIFICATION_TITLE);
            specificationVendor
                = sectionAttributes.getValue(Name.SPECIFICATION_VENDOR);
            specificationVersion
                = sectionAttributes.getValue(Name.SPECIFICATION_VERSION);
            implementationTitle
                = sectionAttributes.getValue(Name.IMPLEMENTATION_TITLE);
            implementationVendor
                = sectionAttributes.getValue(Name.IMPLEMENTATION_VENDOR);
            implementationVersion
                = sectionAttributes.getValue(Name.IMPLEMENTATION_VERSION);
            sealedString
                = sectionAttributes.getValue(Name.SEALED);
        }

        Attributes mainAttributes = manifest.getMainAttributes();
        if (mainAttributes != null) {
            if (specificationTitle == null) {
                specificationTitle
                    = mainAttributes.getValue(Name.SPECIFICATION_TITLE);
            }
            if (specificationVendor == null) {
                specificationVendor
                    = mainAttributes.getValue(Name.SPECIFICATION_VENDOR);
            }
            if (specificationVersion == null) {
                specificationVersion
                    = mainAttributes.getValue(Name.SPECIFICATION_VERSION);
            }
            if (implementationTitle == null) {
                implementationTitle
                    = mainAttributes.getValue(Name.IMPLEMENTATION_TITLE);
            }
            if (implementationVendor == null) {
                implementationVendor
                    = mainAttributes.getValue(Name.IMPLEMENTATION_VENDOR);
            }
            if (implementationVersion == null) {
                implementationVersion
                    = mainAttributes.getValue(Name.IMPLEMENTATION_VERSION);
            }
            if (sealedString == null) {
                sealedString
                    = mainAttributes.getValue(Name.SEALED);
            }
        }

        if (sealedString != null && sealedString.equalsIgnoreCase(""true"")) {
            try {
                sealBase = new URL(FileUtils.getFileUtils().toURI(container.getAbsolutePath()));
            } catch (MalformedURLException e) {
                
            }
        }

        definePackage(packageName, specificationTitle, specificationVersion,
                      specificationVendor, implementationTitle,
                      implementationVersion, implementationVendor, sealBase);
    }


    
    private Class getClassFromStream(InputStream stream, String classname,
                                     File container)
        throws IOException, SecurityException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        int bytesRead = -1;
        byte[] buffer = new byte[BUFFER_SIZE];

        while ((bytesRead = stream.read(buffer, 0, BUFFER_SIZE)) != -1) {
            baos.write(buffer, 0, bytesRead);
        }

        byte[] classData = baos.toByteArray();
        return defineClassFromData(container, classData, classname);
    }

    
    public Class findClass(String name) throws ClassNotFoundException {
        log(""Finding class "" + name, Project.MSG_DEBUG);

        return findClassInComponents(name);
    }

    
    protected boolean isInPath(File component) {
        for (Enumeration e = pathComponents.elements(); e.hasMoreElements();) {
            File pathComponent = (File) e.nextElement();
            if (pathComponent.equals(component)) {
                return true;
            }
        }
        return false;
    }


    
    private Class findClassInComponents(String name)
        throws ClassNotFoundException {
        
        
        InputStream stream = null;
        String classFilename = getClassFilename(name);
        try {
            Enumeration e = pathComponents.elements();
            while (e.hasMoreElements()) {
                File pathComponent = (File) e.nextElement();
                try {
                    stream = getResourceStream(pathComponent, classFilename);
                    if (stream != null) {
                        log(""Loaded from "" + pathComponent + "" ""
                            + classFilename, Project.MSG_DEBUG);
                        return getClassFromStream(stream, name, pathComponent);
                    }
                } catch (SecurityException se) {
                    throw se;
                } catch (IOException ioe) {
                    
                    log(""Exception reading component "" + pathComponent
                        + "" (reason: "" + ioe.getMessage() + "")"",
                        Project.MSG_VERBOSE);
                }
            }

            throw new ClassNotFoundException(name);
        } finally {
            try {
                if (stream != null) {
                    stream.close();
                }
            } catch (IOException e) {
                
            }
        }
    }

    
    private Class findBaseClass(String name) throws ClassNotFoundException {
        if (parent == null) {
            return findSystemClass(name);
        } else {
            return parent.loadClass(name);
        }
    }

    
    public synchronized void cleanup() {
        for (Enumeration e = zipFiles.elements(); e.hasMoreElements();) {
            ZipFile zipFile = (ZipFile) e.nextElement();
            try {
                zipFile.close();
            } catch (IOException ioe) {
                
            }
        }
        zipFiles = new Hashtable();
        if (project != null) {
            project.removeBuildListener(this);
        }
        project = null;
    }

    
    public void buildStarted(BuildEvent event) {
        
    }

    
    public void buildFinished(BuildEvent event) {
        cleanup();
    }

    
    public void subBuildFinished(BuildEvent event) {
        if (event.getProject() == project) {
            cleanup();
        }
    }

    
    public void subBuildStarted(BuildEvent event) {
        
    }

    
    public void targetStarted(BuildEvent event) {
        
    }

    
    public void targetFinished(BuildEvent event) {
        
    }

    
    public void taskStarted(BuildEvent event) {
        
    }

    
    public void taskFinished(BuildEvent event) {
        
    }

    
    public void messageLogged(BuildEvent event) {
        
    }

    
    public void addJavaLibraries() {
        Vector packages = JavaEnvUtils.getJrePackages();
        Enumeration e = packages.elements();
        while (e.hasMoreElements()) {
            String packageName = (String) e.nextElement();
            addSystemPackageRoot(packageName);
        }
    }

    
    public String toString() {
        return ""AntClassLoader["" + getClasspath() + ""]"";
    }

}
"
org.apache.tools.ant.types.selectors.DifferentSelector,5,5,0,8,16,0,5,3,3,0.583333333,105,1.0,1,0.931818182,0.583333333,1,1,19.4,9,2.2,0,"

package org.apache.tools.ant.types.selectors;

import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.BuildException;

import java.io.File;
import java.io.IOException;


public class DifferentSelector extends MappingSelector {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private boolean ignoreFileTimes = true;
    private boolean ignoreContents = false;


    
    public void setIgnoreFileTimes(boolean ignoreFileTimes) {
        this.ignoreFileTimes = ignoreFileTimes;
    }
    
    public void setIgnoreContents(boolean ignoreContents) {
        this.ignoreContents = ignoreContents;
    }
    
    protected boolean selectionTest(File srcfile, File destfile) {

        
        if (srcfile.exists() != destfile.exists()) {
            return true;
        }

        if (srcfile.length() != destfile.length()) {
            
            return true;
        }

        if (!ignoreFileTimes) {
            
            boolean sameDate;
            sameDate = destfile.lastModified() >= srcfile.lastModified() - granularity
                    && destfile.lastModified() <= srcfile.lastModified() + granularity;

            
            if (!sameDate) {
                return true;
            }
        }
        if (!ignoreContents) {
            
            try {
                return !FILE_UTILS.contentEquals(srcfile, destfile);
            } catch (IOException e) {
                throw new BuildException(""while comparing "" + srcfile + "" and ""
                        + destfile, e);
            }
        } else {
            return false;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.DOMUtil,5,1,0,3,41,10,1,2,4,2.0,241,0.0,0,0.0,0.36,0,0,47.2,7,4.2,0,"
package org.apache.tools.ant.taskdefs.optional.junit;

import java.util.Vector;
import org.w3c.dom.Attr;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;


public final class DOMUtil {

    
    private DOMUtil() {
    }

    
    public interface NodeFilter {
        
        boolean accept(Node node);
    }

    
    public static NodeList listChildNodes(Node parent, NodeFilter filter, boolean recurse) {
        NodeListImpl matches = new NodeListImpl();
        NodeList children = parent.getChildNodes();
        if (children != null) {
            final int len = children.getLength();
            for (int i = 0; i < len; i++) {
                Node child = children.item(i);
                if (filter.accept(child)) {
                    matches.addElement(child);
                }
                if (recurse) {
                    NodeList recmatches = listChildNodes(child, filter, recurse);
                    final int reclength = recmatches.getLength();
                    for (int j = 0; j < reclength; j++) {
                        matches.addElement(recmatches.item(i));
                    }
                }
            }
        }
        return matches;
    }

    
    public static class NodeListImpl extends Vector implements NodeList {
        
        public int getLength() {
            return size();
        }
        
        public Node item(int i) {
            try {
                return (Node) elementAt(i);
            } catch (ArrayIndexOutOfBoundsException e) {
                return null; 
            }
        }
    }

    
    public static String getNodeAttribute(Node node, String name) {
        if (node instanceof Element) {
            Element element = (Element) node;
            return element.getAttribute(name);
        }
        return null;
    }


    
    public static Element getChildByTagName (Node parent, String tagname) {
        if (parent == null) {
            return null;
        }
        NodeList childList = parent.getChildNodes();
        final int len = childList.getLength();
        for (int i = 0; i < len; i++) {
            Node child = childList.item(i);
            if (child != null && child.getNodeType() == Node.ELEMENT_NODE
                && child.getNodeName().equals(tagname)) {
                return (Element) child;
            }
        }
        return null;
    }

    
    public static Node importNode(Node parent, Node child) {
        Node copy = null;
        final Document doc = parent.getOwnerDocument();

        switch (child.getNodeType()) {
        case Node.CDATA_SECTION_NODE:
            copy = doc.createCDATASection(((CDATASection) child).getData());
            break;
        case Node.COMMENT_NODE:
            copy = doc.createComment(((Comment) child).getData());
            break;
        case Node.DOCUMENT_FRAGMENT_NODE:
            copy = doc.createDocumentFragment();
            break;
        case Node.ELEMENT_NODE:
            final Element elem = doc.createElement(((Element) child).getTagName());
            copy = elem;
            final NamedNodeMap attributes = child.getAttributes();
            if (attributes != null) {
                final int size = attributes.getLength();
                for (int i = 0; i < size; i++) {
                    final Attr attr = (Attr) attributes.item(i);
                    elem.setAttribute(attr.getName(), attr.getValue());
                }
            }
            break;
        case Node.ENTITY_REFERENCE_NODE:
            copy = doc.createEntityReference(child.getNodeName());
            break;
        case Node.PROCESSING_INSTRUCTION_NODE:
            final ProcessingInstruction pi = (ProcessingInstruction) child;
            copy = doc.createProcessingInstruction(pi.getTarget(), pi.getData());
            break;
        case Node.TEXT_NODE:
            copy = doc.createTextNode(((Text) child).getData());
            break;
        default:
            
            throw new IllegalStateException(""Invalid node type: "" + child.getNodeType());
        }

        
        
        try {
            final NodeList children = child.getChildNodes();
            if (children != null) {
                final int size = children.getLength();
                for (int i = 0; i < size; i++) {
                    final Node newChild = children.item(i);
                    if (newChild != null) {
                        importNode(copy, newChild);
                    }
                }
            }
        } catch (DOMException ignored) {
            
        }

        
        parent.appendChild(copy);
        return copy;
    }
}
"
org.apache.tools.ant.types.selectors.modifiedselector.DigestAlgorithm,7,1,0,3,26,0,1,2,7,0.5,218,1.0,0,0.0,0.476190476,0,0,29.57142857,5,2.2857,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.io.File;
import java.io.FileInputStream;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import org.apache.tools.ant.BuildException;



public class DigestAlgorithm implements Algorithm {


    


    
    private String algorithm = ""MD5"";

    
    private String provider = null;

    
    private MessageDigest messageDigest = null;

    
    private int readBufferSize = 8 * 1024;


    


    
    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }


    
    public void setProvider(String provider) {
        this.provider = provider;
    }


    
    public void initMessageDigest() {
        if (messageDigest != null) {
            return;
        }

        if ((provider != null) && !"""".equals(provider) && !""null"".equals(provider)) {
            try {
                messageDigest = MessageDigest.getInstance(algorithm, provider);
            } catch (NoSuchAlgorithmException noalgo) {
                throw new BuildException(noalgo);
            } catch (NoSuchProviderException noprovider) {
                throw new BuildException(noprovider);
            }
        } else {
            try {
                messageDigest = MessageDigest.getInstance(algorithm);
            } catch (NoSuchAlgorithmException noalgo) {
                throw new BuildException(noalgo);
            }
        }
    }


    


    
    public boolean isValid() {
        return ""SHA"".equalsIgnoreCase(algorithm) || ""MD5"".equalsIgnoreCase(algorithm);
    }


    
    
    public String getValue(File file) {
        initMessageDigest();
        String checksum = null;
        try {
            if (!file.canRead()) {
                return null;
            }
            FileInputStream fis = null;

            byte[] buf = new byte[readBufferSize];
            try {
                messageDigest.reset();
                fis = new FileInputStream(file);
                DigestInputStream dis = new DigestInputStream(fis,
                                                              messageDigest);
                while (dis.read(buf, 0, readBufferSize) != -1) {
                    
                }
                dis.close();
                fis.close();
                fis = null;
                byte[] fileDigest = messageDigest.digest();
                StringBuffer checksumSb = new StringBuffer();
                for (int i = 0; i < fileDigest.length; i++) {
                    String hexStr = Integer.toHexString(0x00ff & fileDigest[i]);
                    if (hexStr.length() < 2) {
                        checksumSb.append(""0"");
                    }
                    checksumSb.append(hexStr);
                }
                checksum = checksumSb.toString();
            } catch (Exception e) {
                return null;
            }
        } catch (Exception e) {
            return null;
        }
        return checksum;
    }


    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(""<DigestAlgorithm:"");
        buf.append(""algorithm="").append(algorithm);
        buf.append("";provider="").append(provider);
        buf.append("">"");
        return buf.toString();
    }
}
"
org.apache.tools.ant.taskdefs.optional.windows.Attrib,17,5,0,6,35,130,0,6,12,0.991071429,207,1.0,0,0.869918699,0.352941176,2,3,10.76470588,3,1.1765,1,"

package org.apache.tools.ant.taskdefs.optional.windows;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.ExecuteOn;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.FileSet;

import java.io.File;


public class Attrib extends ExecuteOn {

    private static final String ATTR_READONLY = ""R"";
    private static final String ATTR_ARCHIVE  = ""A"";
    private static final String ATTR_SYSTEM   = ""S"";
    private static final String ATTR_HIDDEN   = ""H"";
    private static final String SET    = ""+"";
    private static final String UNSET  = ""-"";

    private boolean haveAttr = false;

    
    public Attrib() {
        super.setExecutable(""attrib"");
        super.setParallel(false);
    }

    
    public void setFile(File src) {
        FileSet fs = new FileSet();
        fs.setFile(src);
        addFileset(fs);
    }

    
    public void setReadonly(boolean value) {
        addArg(value, ATTR_READONLY);
    }

    
    public void setArchive(boolean value) {
        addArg(value, ATTR_ARCHIVE);
    }

    
    public void setSystem(boolean value) {
        addArg(value, ATTR_SYSTEM);
    }

    
    public void setHidden(boolean value) {
        addArg(value, ATTR_HIDDEN);
    }

    
    protected void checkConfiguration() {
        if (!haveAttr()) {
            throw new BuildException(""Missing attribute parameter"",
                                     getLocation());
        }
        super.checkConfiguration();
    }

    
    public void setExecutable(String e) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the executable attribute"", getLocation());
    }

    
    public void setCommand(String e) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the command attribute"", getLocation());
    }

    
    public void setAddsourcefile(boolean b) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the addsourcefile attribute"", getLocation());
    }

    
    public void setSkipEmptyFilesets(boolean skip) {
        throw new BuildException(getTaskType() + "" doesn\'t support the ""
                                 + ""skipemptyfileset attribute"",
                                 getLocation());
    }

    
    public void setParallel(boolean parallel) {
        throw new BuildException(getTaskType()
                                 + "" doesn\'t support the parallel attribute"",
                                 getLocation());
    }

    
    public void setMaxParallel(int max) {
        throw new BuildException(getTaskType()
                                 + "" doesn\'t support the maxparallel attribute"",
                                 getLocation());
    }

    
    protected boolean isValidOs() {
        return Os.isFamily(""windows"") && super.isValidOs();
    }

    private static String getSignString(boolean attr) {
        return (attr ? SET : UNSET);
    }

    private void addArg(boolean sign, String attribute) {
        createArg().setValue(getSignString(sign) + attribute);
        haveAttr = true;
    }

    private boolean haveAttr() {
        return haveAttr;
    }

}
"
org.apache.tools.ant.taskdefs.cvslib.ChangeLogWriter,4,1,0,6,33,0,1,5,2,0.333333333,157,1.0,1,0.0,0.533333333,0,0,37.5,2,0.75,0,"
package org.apache.tools.ant.taskdefs.cvslib;

import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Enumeration;
import java.util.TimeZone;

import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.DOMUtils;

import org.w3c.dom.Document;
import org.w3c.dom.Element;


public class ChangeLogWriter {
    
    private static final SimpleDateFormat OUTPUT_DATE
        = new SimpleDateFormat(""yyyy-MM-dd"");
    
    private static final SimpleDateFormat OUTPUT_TIME
        = new SimpleDateFormat(""HH:mm"");
    
    private static final DOMElementWriter DOM_WRITER = new DOMElementWriter();

    static {
        TimeZone utc = TimeZone.getTimeZone(""UTC"");
        OUTPUT_DATE.setTimeZone(utc);
        OUTPUT_TIME.setTimeZone(utc);
    }

    
    public void printChangeLog(final PrintWriter output,
                               final CVSEntry[] entries) {
        try {
            output.println(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
            Document doc = DOMUtils.newDocument();
            Element root = doc.createElement(""changelog"");
            DOM_WRITER.openElement(root, output, 0, ""\t"");
            output.println();
            for (int i = 0; i < entries.length; i++) {
                final CVSEntry entry = entries[i];

                printEntry(doc, output, entry);
            }
            DOM_WRITER.closeElement(root, output, 0, ""\t"", true);
            output.flush();
            output.close();
        } catch (IOException e) {
            throw new org.apache.tools.ant.BuildException(e);
        }
    }


    
    private void printEntry(Document doc, final PrintWriter output,
                            final CVSEntry entry) throws IOException {
        Element ent = doc.createElement(""entry"");
        DOMUtils.appendTextElement(ent, ""date"",
                                   OUTPUT_DATE.format(entry.getDate()));
        DOMUtils.appendTextElement(ent, ""time"",
                                   OUTPUT_TIME.format(entry.getDate()));
        DOMUtils.appendCDATAElement(ent, ""author"", entry.getAuthor());

        final Enumeration enumeration = entry.getFiles().elements();

        while (enumeration.hasMoreElements()) {
            final RCSFile file = (RCSFile) enumeration.nextElement();

            Element f = DOMUtils.createChildElement(ent, ""file"");
            DOMUtils.appendCDATAElement(f, ""name"", file.getName());
            DOMUtils.appendTextElement(f, ""revision"", file.getRevision());

            final String previousRevision = file.getPreviousRevision();
            if (previousRevision != null) {
                DOMUtils.appendTextElement(f, ""prevrevision"",
                                           previousRevision);
            }
        }
        DOMUtils.appendCDATAElement(ent, ""msg"", entry.getComment());
        DOM_WRITER.write(ent, output, 1, ""\t"");
    }
}

"
org.apache.tools.ant.taskdefs.optional.extension.JarLibDisplayTask,5,3,0,6,26,0,0,6,4,0.375,141,1.0,0,0.902439024,0.466666667,0,0,26.8,1,0.8,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import java.util.Iterator;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;


public class JarLibDisplayTask extends Task {
    
    private File libraryFile;

    
    private final Vector libraryFileSets = new Vector();

    
    public void setFile(final File file) {
        this.libraryFile = file;
    }

    
    public void addFileset(final FileSet fileSet) {
        libraryFileSets.addElement(fileSet);
    }

    
    public void execute() throws BuildException {
        validate();

        final LibraryDisplayer displayer = new LibraryDisplayer();
        
        if (!libraryFileSets.isEmpty()) {
            final Iterator iterator = libraryFileSets.iterator();
            while (iterator.hasNext()) {
                final FileSet fileSet = (FileSet) iterator.next();
                final DirectoryScanner scanner
                    = fileSet.getDirectoryScanner(getProject());
                final File basedir = scanner.getBasedir();
                final String[] files = scanner.getIncludedFiles();
                for (int i = 0; i < files.length; i++) {
                    final File file = new File(basedir, files[ i ]);
                    displayer.displayLibrary(file);
                }
            }
        } else {
            displayer.displayLibrary(libraryFile);
        }
    }

    
    private void validate() throws BuildException {
        if (null == libraryFile && libraryFileSets.isEmpty()) {
            final String message = ""File attribute not specified."";
            throw new BuildException(message);
        }
        if (null != libraryFile && !libraryFile.exists()) {
            final String message = ""File '"" + libraryFile + ""' does not exist."";
            throw new BuildException(message);
        }
        if (null != libraryFile && !libraryFile.isFile()) {
            final String message = ""\'"" + libraryFile + ""\' is not a file."";
            throw new BuildException(message);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ssh.SSHExec,9,4,0,11,54,10,1,11,7,0.803571429,345,1.0,0,0.870967742,0.314814815,1,1,36.55555556,1,0.8889,4,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.TeeOutputStream;
import org.apache.tools.ant.util.KeepAliveOutputStream;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringReader;

import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;


public class SSHExec extends SSHBase {

    
    private String command = null;

    
    private long maxwait = 0;

    
    private Thread thread = null;

    private String outputProperty = null;   
    private File outputFile = null;   
    private boolean append = false;   

    private static final String TIMEOUT_MESSAGE =
        ""Timeout period exceeded, connection dropped."";

    
    public SSHExec() {
        super();
    }

    
    public void setCommand(String command) {
        this.command = command;
    }

    
    public void setTimeout(long timeout) {
        maxwait = timeout;
    }

    
    public void setOutput(File output) {
        outputFile = output;
    }

    
    public void setAppend(boolean append) {
        this.append = append;
    }

    
    public void setOutputproperty(String property) {
        outputProperty = property;
    }

    
    public void execute() throws BuildException {
        if (getHost() == null) {
            throw new BuildException(""Host is required."");
        }
        if (getUserInfo().getName() == null) {
            throw new BuildException(""Username is required."");
        }
        if (getUserInfo().getKeyfile() == null
            && getUserInfo().getPassword() == null) {
            throw new BuildException(""Password or Keyfile is required."");
        }
        if (command == null) {
            throw new BuildException(""Command is required."");
        }

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        TeeOutputStream tee = new TeeOutputStream(out, new KeepAliveOutputStream(System.out));

        Session session = null;
        try {
            
            session = openSession();
            session.setTimeout((int) maxwait);
            final ChannelExec channel = (ChannelExec) session.openChannel(""exec"");
            channel.setCommand(command);
            channel.setOutputStream(tee);
            channel.setExtOutputStream(tee);
            channel.connect();

            
            thread =
                new Thread() {
                    public void run() {
                        while (!channel.isEOF()) {
                            if (thread == null) {
                                return;
                            }
                            try {
                                sleep(500);
                            } catch (Exception e) {
                                
                            }
                        }
                    }
                };

            thread.start();
            thread.join(maxwait);

            if (thread.isAlive()) {
                
                thread = null;
                if (getFailonerror()) {
                    throw new BuildException(TIMEOUT_MESSAGE);
                } else {
                    log(TIMEOUT_MESSAGE, Project.MSG_ERR);
                }
            } else {
                
                if (outputProperty != null) {
                    getProject().setProperty(outputProperty, out.toString());
                }
                if (outputFile != null) {
                    writeToFile(out.toString(), append, outputFile);
                }

                
                
                int ec = channel.getExitStatus();
                if (ec != 0) {
                    String msg = ""Remote command failed with exit status "" + ec;
                    if (getFailonerror()) {
                        throw new BuildException(msg);
                    } else {
                        log(msg, Project.MSG_ERR);
                    }
                }
            }
        } catch (BuildException e) {
            throw e;
        } catch (JSchException e) {
            if (e.getMessage().indexOf(""session is down"") >= 0) {
                if (getFailonerror()) {
                    throw new BuildException(TIMEOUT_MESSAGE, e);
                } else {
                    log(TIMEOUT_MESSAGE, Project.MSG_ERR);
                }
            } else {
                if (getFailonerror()) {
                    throw new BuildException(e);
                } else {
                    log(""Caught exception: "" + e.getMessage(),
                        Project.MSG_ERR);
                }
            }
        } catch (Exception e) {
            if (getFailonerror()) {
                throw new BuildException(e);
            } else {
                log(""Caught exception: "" + e.getMessage(), Project.MSG_ERR);
            }
        } finally {
            if (session != null && session.isConnected()) {
                session.disconnect();
            }
        }
    }


    
    private void writeToFile(String from, boolean append, File to)
        throws IOException {
        FileWriter out = null;
        try {
            out = new FileWriter(to.getAbsolutePath(), append);
            StringReader in = new StringReader(from);
            char[] buffer = new char[8192];
            int bytesRead;
            while (true) {
                bytesRead = in.read(buffer);
                if (bytesRead == -1) {
                    break;
                }
                out.write(buffer, 0, bytesRead);
            }
            out.flush();
        } finally {
            if (out != null) {
                out.close();
            }
        }
    }

}
"
org.apache.tools.ant.taskdefs.TaskOutputStream,3,2,0,1,10,0,0,1,1,0.0,67,1.0,1,0.714285714,0.666666667,1,1,20.33333333,1,0.6667,0,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;
import java.io.OutputStream;
import org.apache.tools.ant.Task;



public class TaskOutputStream extends OutputStream {

    private Task task;
    private StringBuffer line;
    private int msgOutputLevel;

    

    TaskOutputStream(Task task, int msgOutputLevel) {
        System.err.println(""As of Ant 1.2 released in October 2000, the ""
            + ""TaskOutputStream class"");
        System.err.println(""is considered to be dead code by the Ant ""
            + ""developers and is unmaintained."");
        System.err.println(""Don\'t use it!"");

        this.task = task;
        this.msgOutputLevel = msgOutputLevel;

        line = new StringBuffer();
    }

    

    public void write(int c) throws IOException {
        char cc = (char) c;
        if (cc == '\r' || cc == '\n') {
            
            if (line.length() > 0) {
                processLine();
            }
        } else {
            line.append(cc);
        }
    }

    

    private void processLine() {
        String s = line.toString();
        task.log(s, msgOutputLevel);
        line = new StringBuffer();
    }
}

"
org.apache.tools.ant.types.resources.selectors.Size,6,1,0,3,10,0,0,3,6,0.4,52,1.0,1,0.0,0.375,0,0,7.333333333,2,1.0,0,"
package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Comparison;


public class Size implements ResourceSelector {
    private long size = -1;
    private Comparison when = Comparison.EQUAL;

    
    public void setSize(long l) {
        size = l;
    }

    
    public long getSize() {
        return size;
    }

    
    public void setWhen(Comparison c) {
        when = c;
    }

    
    public Comparison getWhen() {
        return when;
    }

    
    public boolean isSelected(Resource r) {
        long diff = r.getSize() - size;
        return when.evaluate(diff == 0 ? 0 : (int) (diff / Math.abs(diff)));
    }

}
"
org.apache.tools.ant.types.selectors.MajoritySelector,4,5,0,7,15,0,6,2,4,0.333333333,77,1.0,0,0.953846154,0.4375,1,1,18.0,5,2.0,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.Enumeration;


public class MajoritySelector extends BaseSelectorContainer {

    private boolean allowtie = true;

    
    public MajoritySelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (hasSelectors()) {
            buf.append(""{majorityselect: "");
            buf.append(super.toString());
            buf.append(""}"");
        }
        return buf.toString();
    }

    
    public void setAllowtie(boolean tiebreaker) {
        allowtie = tiebreaker;
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        validate();
        int yesvotes = 0;
        int novotes = 0;
        Enumeration e = selectorElements();
        boolean result;

        while (e.hasMoreElements()) {
            result = ((FileSelector) e.nextElement()).isSelected(basedir,
                    filename, file);
            if (result) {
                yesvotes = yesvotes + 1;
            } else {
                novotes = novotes + 1;
            }
        }
        if (yesvotes > novotes) {
            return true;
        } else if (novotes > yesvotes) {
            return false;
        }
        
        return allowtie;
    }
}

"
org.apache.tools.ant.taskdefs.condition.IsFailure,4,1,0,2,6,0,0,2,4,0.333333333,19,1.0,0,0.0,0.625,0,0,3.5,1,0.75,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.taskdefs.Execute;


public class IsFailure implements Condition {
    private int code;

    
    public void setCode(int c) {
        code = c;
    }

    
    public int getCode() {
        return code;
    }

    
    public boolean eval() {
        return Execute.isFailure(code);
    }

}
"
org.apache.tools.ant.taskdefs.optional.junit.XalanExecutor,9,1,1,4,32,34,1,3,0,0.9375,145,1.0,1,0.0,0.481481481,0,0,14.88888889,1,0.8889,0,"
package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


abstract class XalanExecutor {
    private static final String PACKAGE =
        ""org.apache.tools.ant.taskdefs.optional.junit."";

    
    
    protected AggregateTransformer caller;
    

    
    private void setCaller(AggregateTransformer caller) {
        this.caller = caller;
    }

    
    protected final OutputStream getOutputStream() throws IOException {
        if (AggregateTransformer.FRAMES.equals(caller.format)) {
            
            
            return new ByteArrayOutputStream();
        } else {
            return new BufferedOutputStream(
                new FileOutputStream(new File(caller.toDir, ""junit-noframes.html"")));
        }
    }

    
    abstract void execute() throws Exception;

    
    static XalanExecutor newInstance(AggregateTransformer caller)
        throws BuildException {
        XalanExecutor executor = null;
        try {
            Class clazz = Class.forName(PACKAGE + ""Xalan2Executor"");
            executor = (XalanExecutor) clazz.newInstance();
        } catch (Exception xsltcApacheMissing) {
            caller.task.log(xsltcApacheMissing.toString());
                throw new BuildException(""Could not find xstlc nor xalan2 ""
                                         + ""in the classpath. Check ""
                                         + ""http:
        }
        String classNameImpl = executor.getImplementation();
        String version = executor.getProcVersion(classNameImpl);
        caller.task.log(""Using "" + version, Project.MSG_VERBOSE);
        executor.setCaller(caller);
        return executor;
    }

    
    protected abstract String getImplementation();

    
    protected abstract String getProcVersion(String classNameImpl)
        throws BuildException;

    
    protected final String getXSLTCVersion(String procVersionClassName)
        throws ClassNotFoundException {
        
        
        Class procVersion = Class.forName(procVersionClassName);
        Package pkg = procVersion.getPackage();
        return pkg.getName() + "" "" + pkg.getImplementationTitle()
            + "" "" + pkg.getImplementationVersion();
    }

    
    protected final String getXalanVersion(String procVersionClassName)
        throws ClassNotFoundException {
        Class procVersion = Class.forName(procVersionClassName);
        String pkg = procVersion.getPackage().getName();
        try {
            Field f = procVersion.getField(""S_VERSION"");
            return pkg + "" "" + f.get(null).toString();
        } catch (Exception e) {
            return pkg + "" ?.?"";
        }
    }
}
"
org.apache.tools.ant.types.selectors.SizeSelector,8,5,0,11,31,0,6,5,8,0.693877551,329,0.571428571,1,0.844444444,0.25,1,4,39.25,19,4.625,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.types.Comparison;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Parameter;


public class SizeSelector extends BaseExtendSelector {

    
    public static final String SIZE_KEY = ""value"";
    
    public static final String UNITS_KEY = ""units"";
    
    public static final String WHEN_KEY = ""when"";

    private long size = -1;
    private long multiplier = 1;
    private long sizelimit = -1;
    private Comparison when = Comparison.EQUAL;

    
    public SizeSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{sizeselector value: "");
        buf.append(sizelimit);
        buf.append(""compare: "").append(when.getValue());
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setValue(long size) {
        this.size = size;
        if (multiplier != 0 && size > -1) {
            sizelimit = size * multiplier;
        }
    }

    
    public void setUnits(ByteUnits units) {
        int i = units.getIndex();
        multiplier = 0;
        if (i > -1 && i < 4) {
            multiplier = 1000;
        } else if (i > 3 && i < 9) {
            multiplier = 1024;
        } else if (i > 8 && i < 13) {
            multiplier = 1000000;
        } else if (i > 12 && i < 18) {
            multiplier = 1048576;
        } else if (i > 17 && i < 22) {
            multiplier = 1000000000L;
        } else if (i > 21 && i < 27) {
            multiplier = 1073741824L;
        } else if (i > 26 && i < 31) {
            multiplier = 1000000000000L;
        } else if (i > 30 && i < 36) {
            multiplier = 1099511627776L;
        }
        if (multiplier > 0 && size > -1) {
            sizelimit = size * multiplier;
        }
    }

    
    public void setWhen(SizeComparisons when) {
        this.when = when;
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (SIZE_KEY.equalsIgnoreCase(paramname)) {
                    try {
                        setValue(new Long(parameters[i].getValue()
                        ).longValue());
                    } catch (NumberFormatException nfe) {
                        setError(""Invalid size setting ""
                                + parameters[i].getValue());
                    }
                } else if (UNITS_KEY.equalsIgnoreCase(paramname)) {
                    ByteUnits units = new ByteUnits();
                    units.setValue(parameters[i].getValue());
                    setUnits(units);
                } else if (WHEN_KEY.equalsIgnoreCase(paramname)) {
                    SizeComparisons scmp = new SizeComparisons();
                    scmp.setValue(parameters[i].getValue());
                    setWhen(scmp);
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (size < 0) {
            setError(""The value attribute is required, and must be positive"");
        } else if (multiplier < 1) {
            setError(""Invalid Units supplied, must be K,Ki,M,Mi,G,Gi,T,or Ti"");
        } else if (sizelimit < 0) {
            setError(""Internal error: Code is not setting sizelimit correctly"");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {

        
        validate();

        
        if (file.isDirectory()) {
            return true;
        }
        long diff = file.length() - sizelimit;
        return when.evaluate(diff == 0 ? 0 : (int) (diff / Math.abs(diff)));
    }


    
    public static class ByteUnits extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[]{""K"", ""k"", ""kilo"", ""KILO"",
                                ""Ki"", ""KI"", ""ki"", ""kibi"", ""KIBI"",
                                ""M"", ""m"", ""mega"", ""MEGA"",
                                ""Mi"", ""MI"", ""mi"", ""mebi"", ""MEBI"",
                                ""G"", ""g"", ""giga"", ""GIGA"",
                                ""Gi"", ""GI"", ""gi"", ""gibi"", ""GIBI"",
                                ""T"", ""t"", ""tera"", ""TERA"",
                 ""Ti"", ""TI"", ""ti"", ""tebi"", ""TEBI""
            };
        }
    }

    
    public static class SizeComparisons extends Comparison {
    }

}

"
org.apache.tools.ant.taskdefs.optional.Cab,15,4,0,14,83,47,0,14,8,0.821428571,566,1.0,1,0.857142857,0.244897959,2,2,36.2,4,1.2,0,"

package org.apache.tools.ant.taskdefs.optional;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecTask;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.taskdefs.StreamPumper;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.util.FileUtils;




public class Cab extends MatchingTask {

    private File cabFile;
    private File baseDir;
    private Vector filesets = new Vector();
    private boolean doCompress = true;
    private boolean doVerbose = false;
    private String cmdOptions;

    
    protected String archiveType = ""cab"";
    

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public void setCabfile(File cabFile) {
        this.cabFile = cabFile;
    }

    
    public void setBasedir(File baseDir) {
        this.baseDir = baseDir;
    }

    
    public void setCompress(boolean compress) {
        doCompress = compress;
    }

    
    public void setVerbose(boolean verbose) {
        doVerbose = verbose;
    }

    
    public void setOptions(String options) {
        cmdOptions = options;
    }

    
    public void addFileset(FileSet set) {
        if (filesets.size() > 0) {
            throw new BuildException(""Only one nested fileset allowed"");
        }
        filesets.addElement(set);
    }

    
    
    protected void checkConfiguration() throws BuildException {
        if (baseDir == null && filesets.size() == 0) {
            throw new BuildException(""basedir attribute or one ""
                                     + ""nested fileset is required!"",
                                     getLocation());
        }
        if (baseDir != null && !baseDir.exists()) {
            throw new BuildException(""basedir does not exist!"", getLocation());
        }
        if (baseDir != null && filesets.size() > 0) {
            throw new BuildException(
                ""Both basedir attribute and a nested fileset is not allowed"");
        }
        if (cabFile == null) {
            throw new BuildException(""cabfile attribute must be set!"",
                                     getLocation());
        }
    }

    
    protected ExecTask createExec() throws BuildException {
        ExecTask exec = new ExecTask(this);
        return exec;
    }

    
    protected boolean isUpToDate(Vector files) {
        boolean upToDate = true;
        for (int i = 0; i < files.size() && upToDate; i++) {
            String file = files.elementAt(i).toString();
            if (FILE_UTILS.resolveFile(baseDir, file).lastModified()
                    > cabFile.lastModified()) {
                upToDate = false;
            }
        }
        return upToDate;
    }

    
    protected File createListFile(Vector files)
        throws IOException {
        File listFile = FILE_UTILS.createTempFile(""ant"", """", null);
        listFile.deleteOnExit();

        PrintWriter writer = new PrintWriter(new FileOutputStream(listFile));

        int size = files.size();
        for (int i = 0; i < size; i++) {
            writer.println('\""' + files.elementAt(i).toString() + '\""');
        }
        writer.close();

        return listFile;
    }

    
    protected void appendFiles(Vector files, DirectoryScanner ds) {
        String[] dsfiles = ds.getIncludedFiles();

        for (int i = 0; i < dsfiles.length; i++) {
            files.addElement(dsfiles[i]);
        }
    }

    
    protected Vector getFileList() throws BuildException {
        Vector files = new Vector();

        if (baseDir != null) {
            
            appendFiles(files, super.getDirectoryScanner(baseDir));
        } else {
            FileSet fs = (FileSet) filesets.elementAt(0);
            baseDir = fs.getDir();
            appendFiles(files, fs.getDirectoryScanner(getProject()));
        }

        return files;
    }

    
    public void execute() throws BuildException {

        checkConfiguration();

        Vector files = getFileList();

        
        if (isUpToDate(files)) {
            return;
        }

        log(""Building "" + archiveType + "": "" + cabFile.getAbsolutePath());

        if (!Os.isFamily(""windows"")) {
            log(""Using listcab/libcabinet"", Project.MSG_VERBOSE);

            StringBuffer sb = new StringBuffer();

            Enumeration fileEnum = files.elements();

            while (fileEnum.hasMoreElements()) {
                sb.append(fileEnum.nextElement()).append(""\n"");
            }
            sb.append(""\n"").append(cabFile.getAbsolutePath()).append(""\n"");

            try {
                Process p = Execute.launch(getProject(),
                                           new String[] {""listcab""}, null,
                                           baseDir != null ? baseDir
                                                   : getProject().getBaseDir(),
                                           true);
                OutputStream out = p.getOutputStream();

                
                
                
                LogOutputStream outLog = new LogOutputStream(this, Project.MSG_VERBOSE);
                LogOutputStream errLog = new LogOutputStream(this, Project.MSG_ERR);
                StreamPumper    outPump = new StreamPumper(p.getInputStream(), outLog);
                StreamPumper    errPump = new StreamPumper(p.getErrorStream(), errLog);

                
                (new Thread(outPump)).start();
                (new Thread(errPump)).start();

                out.write(sb.toString().getBytes());
                out.flush();
                out.close();

                int result = -99; 

                try {
                    
                    result = p.waitFor();

                    
                    outPump.waitFor();
                    outLog.close();
                    errPump.waitFor();
                    errLog.close();
                } catch (InterruptedException ie) {
                    log(""Thread interrupted: "" + ie);
                }

                
                if (Execute.isFailure(result)) {
                    log(""Error executing listcab; error code: "" + result);
                }
            } catch (IOException ex) {
                String msg = ""Problem creating "" + cabFile + "" "" + ex.getMessage();
                throw new BuildException(msg, getLocation());
            }
        } else {
            try {
                File listFile = createListFile(files);
                ExecTask exec = createExec();
                File outFile = null;

                
                exec.setFailonerror(true);
                exec.setDir(baseDir);

                if (!doVerbose) {
                    outFile = FILE_UTILS.createTempFile(""ant"", """", null);
                    outFile.deleteOnExit();
                    exec.setOutput(outFile);
                }

                exec.setExecutable(""cabarc"");
                exec.createArg().setValue(""-r"");
                exec.createArg().setValue(""-p"");

                if (!doCompress) {
                    exec.createArg().setValue(""-m"");
                    exec.createArg().setValue(""none"");
                }

                if (cmdOptions != null) {
                    exec.createArg().setLine(cmdOptions);
                }

                exec.createArg().setValue(""n"");
                exec.createArg().setFile(cabFile);
                exec.createArg().setValue(""@"" + listFile.getAbsolutePath());

                exec.execute();

                if (outFile != null) {
                    outFile.delete();
                }

                listFile.delete();
            } catch (IOException ioe) {
                String msg = ""Problem creating "" + cabFile + "" "" + ioe.getMessage();
                throw new BuildException(msg, getLocation());
            }
        }
    }
}
"
org.apache.tools.ant.util.TimeoutObserver,1,1,0,3,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.util;


public interface TimeoutObserver {

    
    void timeoutOccured(Watchdog w);
}
"
org.apache.tools.ant.util.DOMElementWriter,17,1,0,8,67,90,7,1,13,0.703125,878,1.0,1,0.0,0.29375,0,0,50.17647059,11,2.5294,0,"

package org.apache.tools.ant.util;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;


public class DOMElementWriter {

    
    private static final String NS = ""ns"";

    
    private boolean xmlDeclaration = true;

    
    private XmlNamespacePolicy namespacePolicy = XmlNamespacePolicy.IGNORE;

    
    private HashMap nsPrefixMap = new HashMap();

    
    private int nextPrefix = 0;

    
    private HashMap nsURIByElement = new HashMap();

    
    public static class XmlNamespacePolicy {
        private boolean qualifyElements;
        private boolean qualifyAttributes;

        
        public static final XmlNamespacePolicy IGNORE =
            new XmlNamespacePolicy(false, false);

        
        public static final XmlNamespacePolicy ONLY_QUALIFY_ELEMENTS =
            new XmlNamespacePolicy(true, false);

        
        public static final XmlNamespacePolicy QUALIFY_ALL =
            new XmlNamespacePolicy(true, true);

        
        public XmlNamespacePolicy(boolean qualifyElements,
                                  boolean qualifyAttributes) {
            this.qualifyElements = qualifyElements;
            this.qualifyAttributes = qualifyAttributes;
        }
    }

    
    public DOMElementWriter() {
    }

    
    public DOMElementWriter(boolean xmlDeclaration) {
        this(xmlDeclaration, XmlNamespacePolicy.IGNORE);
    }

    
    public DOMElementWriter(boolean xmlDeclaration,
                            XmlNamespacePolicy namespacePolicy) {
        this.xmlDeclaration = xmlDeclaration;
        this.namespacePolicy = namespacePolicy;
    }

    private static String lSep = System.getProperty(""line.separator"");

    
    
    protected String[] knownEntities = {""gt"", ""amp"", ""lt"", ""apos"", ""quot""};
    


    
    public void write(Element root, OutputStream out) throws IOException {
        Writer wri = new OutputStreamWriter(out, ""UTF8"");
        writeXMLDeclaration(wri);
        write(root, wri, 0, ""  "");
        wri.flush();
    }

    
    public void writeXMLDeclaration(Writer wri) throws IOException {
        if (xmlDeclaration) {
            wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
        }
    }

    
    public void write(Element element, Writer out, int indent,
                      String indentWith)
        throws IOException {

        
        NodeList children = element.getChildNodes();
        boolean hasChildren = (children.getLength() > 0);
        boolean hasChildElements = false;
        openElement(element, out, indent, indentWith, hasChildren);

        if (hasChildren) {
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);

                switch (child.getNodeType()) {

                case Node.ELEMENT_NODE:
                    hasChildElements = true;
                    if (i == 0) {
                        out.write(lSep);
                    }
                    write((Element) child, out, indent + 1, indentWith);
                    break;

                case Node.TEXT_NODE:
                    out.write(encode(child.getNodeValue()));
                    break;

                case Node.COMMENT_NODE:
                    out.write(""<!--"");
                    out.write(encode(child.getNodeValue()));
                    out.write(""-->"");
                    break;

                case Node.CDATA_SECTION_NODE:
                    out.write(""<![CDATA["");
                    out.write(encodedata(((Text) child).getData()));
                    out.write(""]]>"");
                    break;

                case Node.ENTITY_REFERENCE_NODE:
                    out.write('&');
                    out.write(child.getNodeName());
                    out.write(';');
                    break;

                case Node.PROCESSING_INSTRUCTION_NODE:
                    out.write(""<?"");
                    out.write(child.getNodeName());
                    String data = child.getNodeValue();
                    if (data != null && data.length() > 0) {
                        out.write(' ');
                        out.write(data);
                    }
                    out.write(""?>"");
                    break;
                default:
                    
                }
            }
            closeElement(element, out, indent, indentWith, hasChildElements);
        }
    }

    
    public void openElement(Element element, Writer out, int indent,
                            String indentWith)
        throws IOException {
        openElement(element, out, indent, indentWith, true);
    }

    
    public void openElement(Element element, Writer out, int indent,
                            String indentWith, boolean hasChildren)
        throws IOException {
        
        for (int i = 0; i < indent; i++) {
            out.write(indentWith);
        }

        
        out.write(""<"");
        if (namespacePolicy.qualifyElements) {
            String uri = getNamespaceURI(element);
            String prefix = (String) nsPrefixMap.get(uri);
            if (prefix == null) {
                if (nsPrefixMap.isEmpty()) {
                    
                    prefix = """";
                } else {
                    prefix = NS + (nextPrefix++);
                }
                nsPrefixMap.put(uri, prefix);
                addNSDefinition(element, uri);
            }
            if (!"""".equals(prefix)) {
                out.write(prefix);
                out.write("":"");
            }
        }
        out.write(element.getTagName());

        
        NamedNodeMap attrs = element.getAttributes();
        for (int i = 0; i < attrs.getLength(); i++) {
            Attr attr = (Attr) attrs.item(i);
            out.write("" "");
            if (namespacePolicy.qualifyAttributes) {
                String uri = getNamespaceURI(attr);
                String prefix = (String) nsPrefixMap.get(uri);
                if (prefix == null) {
                    prefix = NS + (nextPrefix++);
                    nsPrefixMap.put(uri, prefix);
                    addNSDefinition(element, uri);
                }
                out.write(prefix);
                out.write("":"");
            }
            out.write(attr.getName());
            out.write(""=\"""");
            out.write(encode(attr.getValue()));
            out.write(""\"""");
        }

        
        ArrayList al = (ArrayList) nsURIByElement.get(element);
        if (al != null) {
            Iterator iter = al.iterator();
            while (iter.hasNext()) {
                String uri = (String) iter.next();
                String prefix = (String) nsPrefixMap.get(uri);
                out.write("" xmlns"");
                if (!"""".equals(prefix)) {
                    out.write("":"");
                    out.write(prefix);
                }
                out.write(""=\"""");
                out.write(uri);
                out.write(""\"""");
            }
        }

        if (hasChildren) {
            out.write("">"");
        } else {
            removeNSDefinitions(element);
            out.write("" />"");
            out.write(lSep);
            out.flush();
        }
    }

    
    public void closeElement(Element element, Writer out, int indent,
                             String indentWith, boolean hasChildren)
        throws IOException {
        
        
        
        if (hasChildren) {
            for (int i = 0; i < indent; i++) {
                out.write(indentWith);
            }
        }

        
        out.write(""</"");
        if (namespacePolicy.qualifyElements) {
            String uri = getNamespaceURI(element);
            String prefix = (String) nsPrefixMap.get(uri);
            if (prefix != null && !"""".equals(prefix)) {
                out.write(prefix);
                out.write("":"");
            }
            removeNSDefinitions(element);
        }
        out.write(element.getTagName());
        out.write("">"");
        out.write(lSep);
        out.flush();
    }

    
    public String encode(String value) {
        StringBuffer sb = new StringBuffer();
        int len = value.length();
        for (int i = 0; i < len; i++) {
            char c = value.charAt(i);
            switch (c) {
            case '<':
                sb.append(""&lt;"");
                break;
            case '>':
                sb.append(""&gt;"");
                break;
            case '\'':
                sb.append(""&apos;"");
                break;
            case '\""':
                sb.append(""&quot;"");
                break;
            case '&':
                int nextSemi = value.indexOf("";"", i);
                if (nextSemi < 0
                    || !isReference(value.substring(i, nextSemi + 1))) {
                    sb.append(""&amp;"");
                } else {
                    sb.append('&');
                }
                break;
            default:
                if (isLegalCharacter(c)) {
                    sb.append(c);
                }
                break;
            }
        }
        return sb.substring(0);
    }

    
    public String encodedata(final String value) {
        StringBuffer sb = new StringBuffer();
        int len = value.length();
        for (int i = 0; i < len; ++i) {
            char c = value.charAt(i);
            if (isLegalCharacter(c)) {
                sb.append(c);
            }
        }

        String result = sb.substring(0);
        int cdEnd = result.indexOf(""]]>"");
        while (cdEnd != -1) {
            sb.setLength(cdEnd);
            sb.append(""&#x5d;&#x5d;&gt;"")
                .append(result.substring(cdEnd + 3));
            result = sb.substring(0);
            cdEnd = result.indexOf(""]]>"");
        }

        return result;
    }

    
    public boolean isReference(String ent) {
        if (!(ent.charAt(0) == '&') || !ent.endsWith("";"")) {
            return false;
        }

        if (ent.charAt(1) == '#') {
            if (ent.charAt(2) == 'x') {
                try {
                    Integer.parseInt(ent.substring(3, ent.length() - 1), 16);
                    return true;
                } catch (NumberFormatException nfe) {
                    return false;
                }
            } else {
                try {
                    Integer.parseInt(ent.substring(2, ent.length() - 1));
                    return true;
                } catch (NumberFormatException nfe) {
                    return false;
                }
            }
        }

        String name = ent.substring(1, ent.length() - 1);
        for (int i = 0; i < knownEntities.length; i++) {
            if (name.equals(knownEntities[i])) {
                return true;
            }
        }
        return false;
    }

    
    public boolean isLegalCharacter(char c) {
        if (c == 0x9 || c == 0xA || c == 0xD) {
            return true;
        } else if (c < 0x20) {
            return false;
        } else if (c <= 0xD7FF) {
            return true;
        } else if (c < 0xE000) {
            return false;
        } else if (c <= 0xFFFD) {
            return true;
        }
        return false;
    }

    private void removeNSDefinitions(Element element) {
        ArrayList al = (ArrayList) nsURIByElement.get(element);
        if (al != null) {
            Iterator iter = al.iterator();
            while (iter.hasNext()) {
                nsPrefixMap.remove(iter.next());
            }
            nsURIByElement.remove(element);
        }
    }

    private void addNSDefinition(Element element, String uri) {
        ArrayList al = (ArrayList) nsURIByElement.get(element);
        if (al == null) {
            al = new ArrayList();
            nsURIByElement.put(element, al);
        }
        al.add(uri);
    }

    private static String getNamespaceURI(Node n) {
        String uri = n.getNamespaceURI();
        if (uri == null) {
            
            uri = """";
        }
        return uri;
    }
}
"
org.apache.tools.ant.types.resources.CompressedResource,24,4,2,7,50,270,2,5,20,0.434782609,250,1.0,1,0.706666667,0.162037037,2,15,9.375,5,1.375,0,"
package org.apache.tools.ant.types.resources;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.util.FileUtils;


public abstract class CompressedResource extends Resource {

    private Resource resource;

    
    public CompressedResource() {
    }

    
    public CompressedResource(ResourceCollection other) {
        addConfigured(other);
    }

    
    public void addConfigured(ResourceCollection a) {
        checkChildrenAllowed();
        if (resource != null) {
            throw new BuildException(""you must not specify more than one""
                                     + "" resource"");
        }
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported"");
        }
        resource = (Resource) a.iterator().next();
    }

    
    public String getName() {
        return getResource().getName();
    }


    
    public void setName(String name) throws BuildException {
        throw new BuildException(""you can't change the name of a compressed""
                                 + "" resource"");
    }

    
    public boolean isExists() {
        return getResource().isExists();
    }

    
    public void setExists(boolean exists) {
        throw new BuildException(""you can't change the exists state of a ""
                                 + "" compressed resource"");
    }

    
    public long getLastModified() {
        return getResource().getLastModified();
    }

    
    public void setLastModified(long lastmodified) throws BuildException {
        throw new BuildException(""you can't change the timestamp of a ""
                                 + "" compressed resource"");
    }

    
    public boolean isDirectory() {
        return getResource().isDirectory();
    }

    
    public void setDirectory(boolean directory) throws BuildException {
        throw new BuildException(""you can't change the directory state of a ""
                                 + "" compressed resource"");
    }

    
    public long getSize() {
        if (isExists()) {
            InputStream in = null;
            try {
                in = getInputStream();
                byte[] buf = new byte[8192];
                int size = 0;
                int readNow;
                while ((readNow = in.read(buf, 0, buf.length)) > 0) {
                    size += readNow;
                }
                return size;
            } catch (IOException ex) {
                throw new BuildException(""caught exception while reading ""
                                         + getName(), ex);
            } finally {
                FileUtils.close(in);
            }
        } else {
            return 0;
        }
    }

    
    public void setSize(long size) throws BuildException {
        throw new BuildException(""you can't change the size of a ""
                                 + "" compressed resource"");
    }

    
    public int compareTo(Object other) {
        if (other == this) {
            return 0;
        }
        if (other instanceof CompressedResource) {
            return getResource().compareTo(
                ((CompressedResource) other).getResource());
        }
        return getResource().compareTo(other);
    }

    
    public int hashCode() {
        return getResource().hashCode();
    }

    
    public InputStream getInputStream() throws IOException {
        InputStream in = getResource().getInputStream();
        if (in != null) {
            in = wrapStream(in);
        }
        return in;
    }

    
    public OutputStream getOutputStream() throws IOException {
        OutputStream out = getResource().getOutputStream();
        if (out != null) {
            out = wrapStream(out);
        }
        return out;
    }

    
    public boolean isFilesystemOnly() {
        return false;
    }

    
    public String toString() {
        return getCompressionName() + "" compressed ""
            + getResource().toString();
    }

    
    public void setRefid(Reference r) {
        if (resource != null) {
            throw noChildrenAllowed();
        }
        super.setRefid(r);
    }

    
    protected abstract InputStream wrapStream(InputStream in)
        throws IOException;

    
    protected abstract OutputStream wrapStream(OutputStream out)
        throws IOException;

    
    protected abstract String getCompressionName();

    private Resource getResource() {
        if (isReference()) {
            return (Resource) getCheckedRef();
        } else if (resource == null) {
            throw new BuildException(""no resource specified"");
        }
        return resource;
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.ClassFile,4,1,0,8,20,0,4,4,4,0.777777778,106,1.0,1,0.0,0.625,0,0,24.75,5,1.75,0,"
package org.apache.tools.ant.taskdefs.optional.depend;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Vector;
import org.apache.tools.ant.taskdefs.optional.depend.constantpool.ClassCPInfo;
import org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPool;
import org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPoolEntry;


public class ClassFile {

    
    private static final int CLASS_MAGIC = 0xCAFEBABE;

    
    private ConstantPool constantPool;

    
    private String className;

    
    public void read(InputStream stream) throws IOException, ClassFormatError {
        DataInputStream classStream = new DataInputStream(stream);

        if (classStream.readInt() != CLASS_MAGIC) {
            throw new ClassFormatError(""No Magic Code Found ""
                + ""- probably not a Java class file."");
        }

        
         classStream.readUnsignedShort();
         classStream.readUnsignedShort();

        
        constantPool = new ConstantPool();

        constantPool.read(classStream);
        constantPool.resolve();

         classStream.readUnsignedShort();
        int thisClassIndex = classStream.readUnsignedShort();
         classStream.readUnsignedShort();
        ClassCPInfo classInfo
            = (ClassCPInfo) constantPool.getEntry(thisClassIndex);
        className  = classInfo.getClassName();
    }


    
    public Vector getClassRefs() {

        Vector classRefs = new Vector();

        for (int i = 0; i < constantPool.size(); ++i) {
            ConstantPoolEntry entry = constantPool.getEntry(i);

            if (entry != null
                && entry.getTag() == ConstantPoolEntry.CONSTANT_CLASS) {
                ClassCPInfo classEntry = (ClassCPInfo) entry;

                if (!classEntry.getClassName().equals(className)) {
                    classRefs.addElement(
                        ClassFileUtils.convertSlashName(classEntry.getClassName()));
                }
            }
        }

        return classRefs;
    }

    
    public String getFullClassName() {
        return ClassFileUtils.convertSlashName(className);
    }
}

"
org.apache.tools.zip.ZipEntry,27,2,0,11,53,229,8,3,23,0.802197802,405,1.0,0,0.5,0.138047138,1,1,13.74074074,6,1.5185,1,"

package org.apache.tools.zip;

import java.util.Vector;
import java.util.zip.ZipException;


public class ZipEntry extends java.util.zip.ZipEntry implements Cloneable {

    private static final int PLATFORM_UNIX = 3;
    private static final int PLATFORM_FAT  = 0;

    private int internalAttributes = 0;
    private int platform = PLATFORM_FAT;
    private long externalAttributes = 0;
    private Vector extraFields = null;
    private String name = null;

    
    public ZipEntry(String name) {
        super(name);
    }

    
    public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {
        super(entry);
        byte[] extra = entry.getExtra();
        if (extra != null) {
            setExtraFields(ExtraFieldUtils.parse(extra));
        } else {
            
            setExtra();
        }
    }

    
    public ZipEntry(ZipEntry entry) throws ZipException {
        this((java.util.zip.ZipEntry) entry);
        setInternalAttributes(entry.getInternalAttributes());
        setExternalAttributes(entry.getExternalAttributes());
        setExtraFields(entry.getExtraFields());
    }

    
    protected ZipEntry() {
        super("""");
    }

    
    public Object clone() {
        ZipEntry e = (ZipEntry) super.clone();

        e.extraFields = extraFields != null ? (Vector) extraFields.clone() : null;
        e.setInternalAttributes(getInternalAttributes());
        e.setExternalAttributes(getExternalAttributes());
        e.setExtraFields(getExtraFields());
        return e;
    }

    
    public int getInternalAttributes() {
        return internalAttributes;
    }

    
    public void setInternalAttributes(int value) {
        internalAttributes = value;
    }

    
    public long getExternalAttributes() {
        return externalAttributes;
    }

    
    public void setExternalAttributes(long value) {
        externalAttributes = value;
    }

    
    public void setUnixMode(int mode) {
        setExternalAttributes((mode << 16)
                              
                              | ((mode & 0200) == 0 ? 1 : 0)
                              
                              | (isDirectory() ? 0x10 : 0));
        platform = PLATFORM_UNIX;
    }

    
    public int getUnixMode() {
        return (int) ((getExternalAttributes() >> 16) & 0xFFFF);
    }

    
    public int getPlatform() {
        return platform;
    }

    
    protected void setPlatform(int platform) {
        this.platform = platform;
    }

    
    public void setExtraFields(ZipExtraField[] fields) {
        extraFields = new Vector();
        for (int i = 0; i < fields.length; i++) {
            extraFields.addElement(fields[i]);
        }
        setExtra();
    }

    
    public ZipExtraField[] getExtraFields() {
        if (extraFields == null) {
            return new ZipExtraField[0];
        }
        ZipExtraField[] result = new ZipExtraField[extraFields.size()];
        extraFields.copyInto(result);
        return result;
    }

    
    public void addExtraField(ZipExtraField ze) {
        if (extraFields == null) {
            extraFields = new Vector();
        }
        ZipShort type = ze.getHeaderId();
        boolean done = false;
        for (int i = 0, fieldsSize = extraFields.size(); !done && i < fieldsSize; i++) {
            if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {
                extraFields.setElementAt(ze, i);
                done = true;
            }
        }
        if (!done) {
            extraFields.addElement(ze);
        }
        setExtra();
    }

    
    public void removeExtraField(ZipShort type) {
        if (extraFields == null) {
            extraFields = new Vector();
        }
        boolean done = false;
        for (int i = 0, fieldsSize = extraFields.size(); !done && i < fieldsSize; i++) {
            if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {
                extraFields.removeElementAt(i);
                done = true;
            }
        }
        if (!done) {
            throw new java.util.NoSuchElementException();
        }
        setExtra();
    }

    
    public void setExtra(byte[] extra) throws RuntimeException {
        try {
            setExtraFields(ExtraFieldUtils.parse(extra));
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage());
        }
    }

    
    protected void setExtra() {
        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));
    }

    
    public byte[] getLocalFileDataExtra() {
        byte[] extra = getExtra();
        return extra != null ? extra : new byte[0];
    }

    
    public byte[] getCentralDirectoryExtra() {
        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());
    }

    
    public void setComprSize(long size) {
        setCompressedSize(size);
    }

    
    public String getName() {
        return name == null ? super.getName() : name;
    }

    
    public boolean isDirectory() {
        return getName().endsWith(""/"");
    }

    
    protected void setName(String name) {
        this.name = name;
    }

    
    public int hashCode() {
        
        
        
        
        return getName().hashCode();
    }

    
    public boolean equals(Object o) {
        return (this == o);
    }

}
"
org.apache.tools.ant.types.AntFilterReader,10,3,0,8,32,15,2,6,10,0.666666667,166,1.0,1,0.769230769,0.3,1,1,15.3,3,1.4,0,"
package org.apache.tools.ant.types;

import java.util.Vector;
import org.apache.tools.ant.BuildException;


public final class AntFilterReader
    extends DataType implements Cloneable {

    private String className;

    private final Vector parameters = new Vector();

    private Path classpath;

    
    public void setClassName(final String className) {
        this.className = className;
    }

    
    public String getClassName() {
        return className;
    }

    
    public void addParam(final Parameter param) {
        parameters.addElement(param);
    }

    
    public void setClasspath(Path classpath) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public void setClasspathRef(Reference r) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createClasspath().setRefid(r);
    }

    
    public Parameter[] getParams() {
        Parameter[] params = new Parameter[parameters.size()];
        parameters.copyInto(params);
        return params;
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (!parameters.isEmpty() || className != null
                || classpath != null) {
            throw tooManyAttributes();
        }
        
        Object o = r.getReferencedObject(getProject());
        if (o instanceof AntFilterReader) {
            AntFilterReader afr = (AntFilterReader) o;
            setClassName(afr.getClassName());
            setClasspath(afr.getClasspath());
            Parameter[] p = afr.getParams();
            if (p != null) {
                for (int i = 0; i < p.length; i++) {
                    addParam(p[i]);
                }
            }
        } else {
            String msg = r.getRefId() + "" doesn\'t refer to a FilterReader"";
            throw new BuildException(msg);
        }

        super.setRefid(r);
    }
}
"
org.apache.tools.ant.DynamicAttribute,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;


public interface DynamicAttribute {

    
    void setDynamicAttribute(String name, String value)
            throws BuildException;

}
"
org.apache.tools.ant.types.selectors.ExtendSelector,10,4,0,15,36,3,6,9,10,0.583333333,249,1.0,2,0.795454545,0.266666667,1,3,23.5,7,2.4,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.Vector;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;


public class ExtendSelector extends BaseSelector {

    private String classname = null;
    private FileSelector dynselector = null;
    private Vector paramVec = new Vector();
    private Path classpath = null;

    
    public ExtendSelector() {
    }

    
    public void setClassname(String classname) {
        this.classname = classname;
    }

    
    public void selectorCreate() {
        if (classname != null && classname.length() > 0) {
            try {
                Class c = null;
                if (classpath == null) {
                    c = Class.forName(classname);
                } else {
                    AntClassLoader al
                            = getProject().createClassLoader(classpath);
                    c = Class.forName(classname, true, al);
                }
                dynselector = (FileSelector) c.newInstance();
                final Project p = getProject();
                if (p != null) {
                    p.setProjectReference(dynselector);
                }
            } catch (ClassNotFoundException cnfexcept) {
                setError(""Selector "" + classname
                    + "" not initialized, no such class"");
            } catch (InstantiationException iexcept) {
                setError(""Selector "" + classname
                    + "" not initialized, could not create class"");
            } catch (IllegalAccessException iaexcept) {
                setError(""Selector "" + classname
                    + "" not initialized, class not accessible"");
            }
        } else {
            setError(""There is no classname specified"");
        }
    }

    
    public void addParam(Parameter p) {
        paramVec.addElement(p);
    }


    
    public final void setClasspath(Path classpath) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public final Path createClasspath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public final Path getClasspath() {
        return classpath;
    }

    
    public void setClasspathref(Reference r) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createClasspath().setRefid(r);
    }

    
    public void verifySettings() {
        
        
        
        if (dynselector == null) {
            selectorCreate();
        }
        if (classname == null || classname.length() < 1) {
            setError(""The classname attribute is required"");
        } else if (dynselector == null) {
            setError(""Internal Error: The custom selector was not created"");
        } else if (!(dynselector instanceof ExtendFileSelector)
                    && (paramVec.size() > 0)) {
            setError(""Cannot set parameters on custom selector that does not ""
                    + ""implement ExtendFileSelector"");
        }
    }


    
    public boolean isSelected(File basedir, String filename, File file)
            throws BuildException {
        validate();
        if (paramVec.size() > 0 && dynselector instanceof ExtendFileSelector) {
            Parameter[] paramArray = new Parameter[paramVec.size()];
            paramVec.copyInto(paramArray);
            
            ((ExtendFileSelector) dynselector).setParameters(paramArray);
        }
        return dynselector.isSelected(basedir, filename, file);
    }

}

"
org.apache.tools.ant.taskdefs.optional.ccm.CCMCheck,11,4,3,12,41,19,3,9,9,0.816666667,240,0.666666667,0,0.811320755,0.290909091,0,0,20.27272727,4,1.2727,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;


import java.io.File;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.FileSet;



public class CCMCheck extends Continuus {

    private File file = null;
    private String comment = null;
    private String task = null;

    

    protected Vector filesets = new Vector();

    

    
    public CCMCheck() {
        super();
    }

    
    public File getFile() {
        return file;
    }

    
    public void setFile(File v) {
        log(""working file "" + v, Project.MSG_VERBOSE);
        this.file = v;
    }

    
    public String getComment() {
        return comment;
    }

    
    public void setComment(String v) {
        this.comment = v;
    }


    
    public String getTask() {
        return task;
    }

    
    public void setTask(String v) {
        this.task = v;
    }


    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }


    
    public void execute() throws BuildException {

        if (file == null && filesets.size() == 0) {
            throw new BuildException(
                ""Specify at least one source - a file or a fileset."");
        }

        if (file != null && file.exists() && file.isDirectory()) {
            throw new BuildException(""CCMCheck cannot be generated for directories"");
        }

        if (file != null  && filesets.size() > 0) {
            throw new BuildException(""Choose between file and fileset !"");
        }

        if (getFile() != null) {
            doit();
            return;
        }

        int sizeofFileSet = filesets.size();
        for (int i = 0; i < sizeofFileSet; i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            String[] srcFiles = ds.getIncludedFiles();
            for (int j = 0; j < srcFiles.length; j++) {
                File src = new File(fs.getDir(getProject()), srcFiles[j]);
                setFile(src);
                doit();
            }
        }
    }

    
    private void doit() {
        Commandline commandLine = new Commandline();

        
        
        

        commandLine.setExecutable(getCcmCommand());
        commandLine.createArgument().setValue(getCcmAction());

        checkOptions(commandLine);

        int result = run(commandLine);
        if (Execute.isFailure(result)) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }

        if (getTask() != null) {
            cmd.createArgument().setValue(FLAG_TASK);
            cmd.createArgument().setValue(getTask());
        }

        if (getFile() != null) {
            cmd.createArgument().setValue(file.getAbsolutePath());
        }
    }

    
    public static final String FLAG_COMMENT = ""/comment"";

    
    public static final String FLAG_TASK = ""/task"";
}

"
org.apache.tools.ant.taskdefs.JikesOutputParser,12,1,0,3,22,44,1,2,5,0.805194805,156,1.0,1,0.0,0.261904762,0,0,11.41666667,4,1.25,0,"
package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;


public class JikesOutputParser implements ExecuteStreamHandler {
    
    protected Task task;
    protected boolean errorFlag = false; 
    protected int errors;
    protected int warnings;
    protected boolean error = false;
    protected boolean emacsMode;

    protected BufferedReader br;
    

    
    public void setProcessInputStream(OutputStream os) {
    }

    
    public void setProcessErrorStream(InputStream is) {
    }

    
    public void setProcessOutputStream(InputStream is) throws IOException {
        br = new BufferedReader(new InputStreamReader(is));
    }

    
    public void start() throws IOException {
        parseOutput(br);
    }

    
    public void stop() {
    }

    
    protected JikesOutputParser(Task task, boolean emacsMode) {
        super();

        System.err.println(""As of Ant 1.2 released in October 2000, the ""
            + ""JikesOutputParser class"");
        System.err.println(""is considered to be dead code by the Ant ""
            + ""developers and is unmaintained."");
        System.err.println(""Don\'t use it!"");

        this.task = task;
        this.emacsMode = emacsMode;
    }

    
    protected void parseOutput(BufferedReader reader) throws IOException {
       if (emacsMode) {
           parseEmacsOutput(reader);
       } else {
           parseStandardOutput(reader);
       }
    }

    private void parseStandardOutput(BufferedReader reader) throws IOException {
        String line;
        String lower;
        
        
        

        
        
        
        

        while ((line = reader.readLine()) != null) {
            lower = line.toLowerCase();
            if (line.trim().equals("""")) {
                continue;
            }
            if (lower.indexOf(""error"") != -1) {
                setError(true);
            } else if (lower.indexOf(""warning"") != -1) {
                setError(false);
                   } else {
                
                
                
                
                
                
                if (emacsMode) {
                    setError(true);
                }
            }
            log(line);
        }
    }

    private void parseEmacsOutput(BufferedReader reader) throws IOException {
       
       parseStandardOutput(reader);
    }

    private void setError(boolean err) {
        error = err;
        if (error) {
            errorFlag = true;
        }
    }

    private void log(String line) {
       if (!emacsMode) {
           task.log("""", (error ? Project.MSG_ERR : Project.MSG_WARN));
       }
       task.log(line, (error ? Project.MSG_ERR : Project.MSG_WARN));
    }

    
    protected boolean getErrorFlag() {
        return errorFlag;
    }
}
"
org.apache.tools.ant.taskdefs.LoadProperties,12,3,0,14,58,0,0,14,11,0.606060606,303,1.0,1,0.770833333,0.226190476,2,3,24.0,3,1.25,1,"
package org.apache.tools.ant.taskdefs;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Properties;
import java.util.Vector;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.filters.util.ChainReaderHelper;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.JavaResource;
import org.apache.tools.ant.util.FileUtils;


public class LoadProperties extends Task {

    
    private Resource src = null;

    
    private final Vector filterChains = new Vector();

    
    private String encoding = null;

    
    public final void setSrcFile(final File srcFile) {
        addConfigured(new FileResource(srcFile));
    }

    
    public void setResource(String resource) {
        assertSrcIsJavaResource();
        ((JavaResource) src).setName(resource);
    }

    
    public final void setEncoding(final String encoding) {
        this.encoding = encoding;
    }

    
    public void setClasspath(Path classpath) {
        assertSrcIsJavaResource();
        ((JavaResource) src).setClasspath(classpath);
    }

    
    public Path createClasspath() {
        assertSrcIsJavaResource();
        return ((JavaResource) src).createClasspath();
    }

    
    public void setClasspathRef(Reference r) {
        assertSrcIsJavaResource();
        ((JavaResource) src).setClasspathRef(r);
    }

    
    public Path getClasspath() {
        assertSrcIsJavaResource();
        return ((JavaResource) src).getClasspath();
    }

    
    public final void execute() throws BuildException {
        
        if (src == null) {
            throw new BuildException(""A source resource is required."");
        }
        if (!src.isExists()) {
            if (src instanceof JavaResource) {
                
                log(""Unable to find resource "" + src, Project.MSG_WARN);
                return;
            }
            throw new BuildException(""Source resource does not exist: "" + src);
        }

        BufferedInputStream bis = null;
        Reader instream = null;
        ByteArrayInputStream tis = null;

        try {
            bis = new BufferedInputStream(src.getInputStream());
            if (encoding == null) {
                instream = new InputStreamReader(bis);
            } else {
                instream = new InputStreamReader(bis, encoding);
            }

            ChainReaderHelper crh = new ChainReaderHelper();
            crh.setPrimaryReader(instream);
            crh.setFilterChains(filterChains);
            crh.setProject(getProject());
            instream = crh.getAssembledReader();

            String text = crh.readFully(instream);

            if (text != null) {
                if (!text.endsWith(""\n"")) {
                    text = text + ""\n"";
                }

                if (encoding == null) {
                    tis = new ByteArrayInputStream(text.getBytes());
                } else {
                    tis = new ByteArrayInputStream(text.getBytes(encoding));
                }
                final Properties props = new Properties();
                props.load(tis);

                Property propertyTask = new Property();
                propertyTask.bindToOwner(this);
                propertyTask.addProperties(props);
            }

        } catch (final IOException ioe) {
            final String message = ""Unable to load file: "" + ioe.toString();
            throw new BuildException(message, ioe, getLocation());
        } finally {
            FileUtils.close(bis);
            FileUtils.close(tis);
        }
    }

    
    public final void addFilterChain(FilterChain filter) {
        filterChains.addElement(filter);
    }

    
    public void addConfigured(ResourceCollection a) {
        if (src != null) {
            throw new BuildException(""only a single source is supported"");
        }
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported"");
        }
        src = (Resource) a.iterator().next();
    }

    private void assertSrcIsJavaResource() {
        if (src == null) {
            src = new JavaResource();
            src.setProject(getProject());
        } else if (!(src instanceof JavaResource)) {
            throw new BuildException(""expected a java resource as source"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.condition.Not,2,3,0,3,8,1,1,3,2,2.0,33,0.0,0,0.96969697,1.0,0,0,15.5,1,0.5,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;


public class Not extends ConditionBase implements Condition {

    
    public boolean eval() throws BuildException {
        if (countConditions() > 1) {
            throw new BuildException(""You must not nest more than one ""
                + ""condition into <not>"");
        }
        if (countConditions() < 1) {
            throw new BuildException(""You must nest a condition into <not>"");
        }
        return !((Condition) getConditions().nextElement()).eval();
    }

}
"
org.apache.tools.ant.taskdefs.optional.ReplaceRegExp,15,3,0,10,77,41,0,10,12,0.785714286,725,1.0,3,0.74,0.25,1,1,46.8,2,1.2667,3,"
package org.apache.tools.ant.taskdefs.optional;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.RegularExpression;
import org.apache.tools.ant.types.Substitution;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.regexp.Regexp;


public class ReplaceRegExp extends Task {

    private File file;
    private String flags;
    private boolean byline;
    private Vector filesets; 
    private RegularExpression regex;
    private Substitution subs;

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private String encoding = null;

    
    public ReplaceRegExp() {
        super();
        this.file = null;
        this.filesets = new Vector();
        this.flags = """";
        this.byline = false;

        this.regex = null;
        this.subs = null;
    }


    
    public void setFile(File file) {
        this.file = file;
    }


    
    public void setMatch(String match) {
        if (regex != null) {
            throw new BuildException(""Only one regular expression is allowed"");
        }

        regex = new RegularExpression();
        regex.setPattern(match);
    }


    

    public void setReplace(String replace) {
        if (subs != null) {
            throw new BuildException(""Only one substitution expression is ""
                                     + ""allowed"");
        }

        subs = new Substitution();
        subs.setExpression(replace);
    }

    
    public void setFlags(String flags) {
        this.flags = flags;
    }


    
    public void setByLine(String byline) {
        Boolean res = Boolean.valueOf(byline);

        if (res == null) {
            res = Boolean.FALSE;
        }
        this.byline = res.booleanValue();
    }

    
    public void setByLine(boolean byline) {
        this.byline = byline;
    }


    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }


    
    public RegularExpression createRegexp() {
        if (regex != null) {
            throw new BuildException(""Only one regular expression is allowed."");
        }

        regex = new RegularExpression();
        return regex;
    }


    
    public Substitution createSubstitution() {
        if (subs != null) {
            throw new BuildException(""Only one substitution expression is ""
                                     + ""allowed"");
        }

        subs = new Substitution();
        return subs;
    }


    
    protected String doReplace(RegularExpression r,
                               Substitution s,
                               String input,
                               int options) {
        String res = input;
        Regexp regexp = r.getRegexp(getProject());

        if (regexp.matches(input, options)) {
            log(""Found match; substituting"", Project.MSG_DEBUG);
            res = regexp.substitute(input, s.getExpression(getProject()),
                                    options);
        }

        return res;
    }


    
    protected void doReplace(File f, int options)
         throws IOException {
        File temp = FILE_UTILS.createTempFile(""replace"", "".txt"", null);
        temp.deleteOnExit();

        Reader r = null;
        Writer w = null;

        try {
            if (encoding == null) {
                r = new FileReader(f);
                w = new FileWriter(temp);
            } else {
                r = new InputStreamReader(new FileInputStream(f), encoding);
                w = new OutputStreamWriter(new FileOutputStream(temp),
                                           encoding);
            }

            BufferedReader br = new BufferedReader(r);
            BufferedWriter bw = new BufferedWriter(w);
            PrintWriter pw = new PrintWriter(bw);

            boolean changes = false;

            log(""Replacing pattern '"" + regex.getPattern(getProject())
                + ""' with '"" + subs.getExpression(getProject())
                + ""' in '"" + f.getPath() + ""'"" + (byline ? "" by line"" : """")
                + (flags.length() > 0 ? "" with flags: '"" + flags + ""'"" : """")
                + ""."", Project.MSG_VERBOSE);

            if (byline) {
                StringBuffer linebuf = new StringBuffer();
                String line = null;
                String res = null;
                int c;
                boolean hasCR = false;

                do {
                    c = br.read();

                    if (c == '\r') {
                        if (hasCR) {
                            
                            line = linebuf.toString();
                            res  = doReplace(regex, subs, line, options);

                            if (!res.equals(line)) {
                                changes = true;
                            }

                            pw.print(res);
                            pw.print('\r');

                            linebuf = new StringBuffer();
                            
                        } else {
                            
                            hasCR = true;
                        }
                    } else if (c == '\n') {
                        
                        line = linebuf.toString();
                        res  = doReplace(regex, subs, line, options);

                        if (!res.equals(line)) {
                            changes = true;
                        }

                        pw.print(res);
                        if (hasCR) {
                            pw.print('\r');
                            hasCR = false;
                        }
                        pw.print('\n');

                        linebuf = new StringBuffer();
                    } else { 
                        if ((hasCR) || (c < 0)) {
                            
                            line = linebuf.toString();
                            res  = doReplace(regex, subs, line, options);

                            if (!res.equals(line)) {
                                changes = true;
                            }

                            pw.print(res);
                            if (hasCR) {
                                pw.print('\r');
                                hasCR = false;
                            }

                            linebuf = new StringBuffer();
                        }

                        if (c >= 0) {
                            linebuf.append((char) c);
                        }
                    }
                } while (c >= 0);

                pw.flush();
            } else {
                String buf = FileUtils.readFully(br);
                if (buf == null) {
                    buf = """";
                }

                String res = doReplace(regex, subs, buf, options);

                if (!res.equals(buf)) {
                    changes = true;
                }

                pw.print(res);
                pw.flush();
            }

            r.close();
            r = null;
            w.close();
            w = null;

            if (changes) {
                log(""File has changed; saving the updated file"", Project.MSG_VERBOSE);
                try {
                    FILE_UTILS.rename(temp, f);
                    temp = null;
                } catch (IOException e) {
                    throw new BuildException(""Couldn't rename temporary file ""
                                             + temp, getLocation());
                }
            } else {
                log(""No change made"", Project.MSG_DEBUG);
            }
        } finally {
            FileUtils.close(r);
            FileUtils.close(w);
            if (temp != null) {
                temp.delete();
            }
        }
    }


    
    public void execute() throws BuildException {
        if (regex == null) {
            throw new BuildException(""No expression to match."");
        }
        if (subs == null) {
            throw new BuildException(""Nothing to replace expression with."");
        }

        if (file != null && filesets.size() > 0) {
            throw new BuildException(""You cannot supply the 'file' attribute ""
                                     + ""and filesets at the same time."");
        }

        int options = 0;

        if (flags.indexOf('g') != -1) {
            options |= Regexp.REPLACE_ALL;
        }

        if (flags.indexOf('i') != -1) {
            options |= Regexp.MATCH_CASE_INSENSITIVE;
        }

        if (flags.indexOf('m') != -1) {
            options |= Regexp.MATCH_MULTILINE;
        }

        if (flags.indexOf('s') != -1) {
            options |= Regexp.MATCH_SINGLELINE;
        }

        if (file != null && file.exists()) {
            try {
                doReplace(file, options);
            } catch (IOException e) {
                log(""An error occurred processing file: '""
                    + file.getAbsolutePath() + ""': "" + e.toString(),
                    Project.MSG_ERR);
            }
        } else if (file != null) {
            log(""The following file is missing: '""
                + file.getAbsolutePath() + ""'"", Project.MSG_ERR);
        }

        int sz = filesets.size();

        for (int i = 0; i < sz; i++) {
            FileSet fs = (FileSet) (filesets.elementAt(i));
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());

            String[] files = ds.getIncludedFiles();

            for (int j = 0; j < files.length; j++) {
                File f = new File(fs.getDir(getProject()), files[j]);

                if (f.exists()) {
                    try {
                        doReplace(f, options);
                    } catch (Exception e) {
                        log(""An error occurred processing file: '""
                            + f.getAbsolutePath() + ""': "" + e.toString(),
                            Project.MSG_ERR);
                    }
                } else {
                    log(""The following file is missing: '""
                        + f.getAbsolutePath() + ""'"", Project.MSG_ERR);
                }
            }
        }
    }

}


"
org.apache.tools.ant.taskdefs.BuildNumber,7,3,0,4,38,0,0,4,3,0.833333333,258,1.0,1,0.880952381,0.444444444,1,1,35.28571429,1,0.7143,0,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;


public class BuildNumber
     extends Task {
    
    private static final String DEFAULT_PROPERTY_NAME = ""build.number"";

    
    private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME;

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private File myFile;


    
    public void setFile(final File file) {
        myFile = file;
    }


    
    public void execute()
         throws BuildException {
        File savedFile = myFile; 

        validate();

        final Properties properties = loadProperties();
        final int buildNumber = getBuildNumber(properties);

        properties.put(DEFAULT_PROPERTY_NAME,
            String.valueOf(buildNumber + 1));

        
        FileOutputStream output = null;

        try {
            output = new FileOutputStream(myFile);

            final String header = ""Build Number for ANT. Do not edit!"";

            properties.store(output, header);
        } catch (final IOException ioe) {
            final String message = ""Error while writing "" + myFile;

            throw new BuildException(message, ioe);
        } finally {
            if (null != output) {
                try {
                    output.close();
                } catch (final IOException ioe) {
                    log(""error closing output stream "" + ioe, Project.MSG_ERR);
                }
            }
            myFile = savedFile;
        }

        
        getProject().setNewProperty(DEFAULT_PROPERTY_NAME,
            String.valueOf(buildNumber));
    }


    
    private int getBuildNumber(final Properties properties)
         throws BuildException {
        final String buildNumber =
            properties.getProperty(DEFAULT_PROPERTY_NAME, ""0"").trim();

        
        try {
            return Integer.parseInt(buildNumber);
        } catch (final NumberFormatException nfe) {
            final String message =
                myFile + "" contains a non integer build number: "" + buildNumber;
            throw new BuildException(message, nfe);
        }
    }


    
    private Properties loadProperties()
         throws BuildException {
        FileInputStream input = null;

        try {
            final Properties properties = new Properties();

            input = new FileInputStream(myFile);
            properties.load(input);
            return properties;
        } catch (final IOException ioe) {
            throw new BuildException(ioe);
        } finally {
            if (null != input) {
                try {
                    input.close();
                } catch (final IOException ioe) {
                    log(""error closing input stream "" + ioe, Project.MSG_ERR);
                }
            }
        }
    }


    
    private void validate()
         throws BuildException {
        if (null == myFile) {
            myFile = FILE_UTILS.resolveFile(getProject().getBaseDir(), DEFAULT_FILENAME);
        }

        if (!myFile.exists()) {
            try {
                FILE_UTILS.createNewFile(myFile);
            } catch (final IOException ioe) {
                final String message =
                    myFile + "" doesn't exist and new file can't be created."";
                throw new BuildException(message, ioe);
            }
        }

        if (!myFile.canRead()) {
            final String message = ""Unable to read from "" + myFile + ""."";
            throw new BuildException(message);
        }

        if (!myFile.canWrite()) {
            final String message = ""Unable to write to "" + myFile + ""."";
            throw new BuildException(message);
        }
    }
}

"
org.apache.tools.ant.BuildLogger,4,1,0,6,4,6,5,1,4,2.0,4,0.0,0,0.0,0.5,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;

import java.io.PrintStream;


public interface BuildLogger extends BuildListener {

    
    void setMessageOutputLevel(int level);

    
    void setOutputPrintStream(PrintStream output);

    
    void setEmacsMode(boolean emacsMode);

    
    void setErrorPrintStream(PrintStream err);
}
"
org.apache.tools.ant.types.resources.comparators.Reverse,4,4,0,5,8,4,2,3,3,0.833333333,42,1.0,1,0.944444444,0.583333333,1,1,9.0,2,1.0,0,"
package org.apache.tools.ant.types.resources.comparators;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;


public class Reverse extends ResourceComparator {
    private static final String ONE_NESTED
        = ""You must not nest more than one ResourceComparator for reversal."";

    private ResourceComparator nested;

    
    public Reverse() {
    }

    
    public Reverse(ResourceComparator c) {
        add(c);
    }

    
    public void add(ResourceComparator c) {
        if (nested != null) {
            throw new BuildException(ONE_NESTED);
        }
        nested = c;
    }

    
    protected int resourceCompare(Resource foo, Resource bar) {
        return -1 * (nested == null
            ? foo.compareTo(bar) : nested.compare(foo, bar));
    }

}
"
org.apache.tools.ant.types.resources.ArchiveResource,21,4,2,9,55,162,4,5,18,0.71,361,1.0,1,0.768115942,0.19375,2,9,15.95238095,6,1.619,0,"
package org.apache.tools.ant.types.resources;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.Reference;


public abstract class ArchiveResource extends Resource {
    private static final int NULL_ARCHIVE
        = Resource.getMagicNumber(""null archive"".getBytes());

    private Resource archive;
    private boolean haveEntry = false;
    private boolean modeSet = false;
    private int mode = 0;

    
    public ArchiveResource() {
    }

    
    public ArchiveResource(File a) {
        this(a, false);
    }

    
    public ArchiveResource(File a, boolean withEntry) {
        setArchive(a);
        haveEntry = withEntry;
    }

    
    public ArchiveResource(Resource a, boolean withEntry) {
        addConfigured(a);
        haveEntry = withEntry;
    }

    
    public void setArchive(File a) {
        checkAttributesAllowed();
        archive = new FileResource(a);
    }

    
    public void setMode(int mode) {
        checkAttributesAllowed();
        this.mode = mode;
        modeSet = true;
    }

    
    public void addConfigured(ResourceCollection a) {
        checkChildrenAllowed();
        if (archive != null) {
            throw new BuildException(""you must not specify more than one""
                                     + "" archive"");
        }
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported as archives"");
        }
        archive = (Resource) a.iterator().next();
    }

    
    public Resource getArchive() {
        return isReference()
            ? ((ArchiveResource) getCheckedRef()).getArchive() : archive;
    }

    
    public long getLastModified() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getLastModified();
        }
        checkEntry();
        return super.getLastModified();
    }

    
    public long getSize() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getSize();
        }
        checkEntry();
        return super.getSize();
    }

    
    public boolean isDirectory() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).isDirectory();
        }
        checkEntry();
        return super.isDirectory();
    }

    
    public boolean isExists() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).isExists();
        }
        checkEntry();
        return super.isExists();
    }

    
    public int getMode() {
        if (isReference()) {
            return ((ArchiveResource) getCheckedRef()).getMode();
        }
        checkEntry();
        return mode;
    }

    
    public void setRefid(Reference r) {
        if (archive != null || modeSet) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public int compareTo(Object another) {
        return this.equals(another) ? 0 : super.compareTo(another);
    }

    
    public boolean equals(Object another) {
        if (this == another) {
            return true;
        }
        if (isReference()) {
            return getCheckedRef().equals(another);
        }
        if (!(another.getClass().equals(getClass()))) {
            return false;
        }
        ArchiveResource r = (ArchiveResource) another;
        return getArchive().equals(r.getArchive())
            && getName().equals(r.getName());
    }

    
    public int hashCode() {
        return super.hashCode()
            * (getArchive() == null ? NULL_ARCHIVE : getArchive().hashCode());
    }

    
    public String toString() {
        return isReference() ? getCheckedRef().toString()
            : getArchive().toString() + ':' + getName();
    }

    private synchronized void checkEntry() throws BuildException {
        if (haveEntry) {
            return;
        }
        String name = getName();
        if (name == null) {
            throw new BuildException(""entry name not set"");
        }
        Resource r = getArchive();
        if (r == null) {
            throw new BuildException(""archive attribute not set"");
        }
        if (!r.isExists()) {
            throw new BuildException(r.toString() + "" does not exist."");
        }
        if (r.isDirectory()) {
            throw new BuildException(r + "" denotes a directory."");
        }
        fetchEntry();
        haveEntry = true;
    }

    
    protected abstract void fetchEntry();
}
"
org.apache.tools.ant.types.resources.First,4,4,0,3,12,0,0,3,3,0.666666667,55,1.0,0,0.933333333,0.625,1,1,12.25,4,1.5,0,"
package org.apache.tools.ant.types.resources;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collection;

import org.apache.tools.ant.BuildException;


public class First extends BaseResourceCollectionWrapper {
    private static final String BAD_COUNT
        = ""count of first resources should be set to an int >= 0"";

    private int count = 1;

    
    public synchronized void setCount(int i) {
        count = i;
    }

    
    public synchronized int getCount() {
        return count;
    }

    
    protected Collection getCollection() {
        int ct = getCount();
        if (ct < 0) {
            throw new BuildException(BAD_COUNT);
        }
        Iterator iter = getResourceCollection().iterator();
        ArrayList al = new ArrayList(ct);
        for (int i = 0; i < ct && iter.hasNext(); i++) {
            al.add(iter.next());
        }
        return al;
    }

}
"
org.apache.tools.ant.taskdefs.email.Mailer,19,1,2,9,21,145,4,5,18,0.954861111,143,1.0,3,0.0,0.230263158,0,0,5.684210526,1,0.9474,1,"
package org.apache.tools.ant.taskdefs.email;

import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.DateUtils;


public abstract class Mailer {
    
    protected String host = null;
    protected int port = -1;
    protected String user = null;
    protected String password = null;
    
    protected boolean SSL = false;
    
    protected Message message;
    protected EmailAddress from;
    protected Vector replyToList = null;
    protected Vector toList = null;
    protected Vector ccList = null;
    protected Vector bccList = null;
    protected Vector files = null;
    protected String subject = null;
    protected Task task;
    protected boolean includeFileNames = false;
    protected Vector headers = null;
    

    
    public void setHost(String host) {
        this.host = host;
    }

    
    public void setPort(int port) {
        this.port = port;
    }

    
    public void setUser(String user) {
        this.user = user;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

    
    public void setSSL(boolean ssl) {
        this.SSL = ssl;
    }

    
    public void setMessage(Message m) {
        this.message = m;
    }

    
    public void setFrom(EmailAddress from) {
        this.from = from;
    }

    
    public void setReplyToList(Vector list) {
        this.replyToList = list;
    }

    
    public void setToList(Vector list) {
        this.toList = list;
    }

    
    public void setCcList(Vector list) {
        this.ccList = list;
    }

    
    public void setBccList(Vector list) {
        this.bccList = list;
    }

    
    public void setFiles(Vector files) {
        this.files = files;
    }

    
    public void setSubject(String subject) {
        this.subject = subject;
    }

    
    public void setTask(Task task) {
        this.task = task;
    }

    
    public void setIncludeFileNames(boolean b) {
        this.includeFileNames = b;
    }

    
    public void setHeaders(Vector v) {
        this.headers = v;
    }

    
    public abstract void send()
         throws BuildException;

    
    protected final String getDate() {
        return DateUtils.getDateForHeader();
    }
}

"
org.apache.tools.ant.taskdefs.optional.junit.XMLResultAggregator,12,3,0,11,75,44,1,11,7,0.936363636,455,0.5,0,0.770833333,0.236111111,0,0,36.08333333,4,1.75,0,"
package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.SAXException;



public class XMLResultAggregator extends Task implements XMLConstants {

    
    
    protected Vector filesets = new Vector();

    
    protected String toFile;

    
    protected File toDir;

    protected Vector transformers = new Vector();

    
    public static final String DEFAULT_DIR = ""."";

    
    public static final String DEFAULT_FILENAME = ""TESTS-TestSuites.xml"";

    
    protected int generatedId = 0;

    
    static final String WARNING_IS_POSSIBLY_CORRUPTED
        = "" is not a valid XML document. It is possibly corrupted."";
    
    static final String WARNING_INVALID_ROOT_ELEMENT
        = "" is not a valid testsuite XML document"";
    
    static final String WARNING_EMPTY_FILE
        = "" is empty.\nThis can be caused by the test JVM exiting unexpectedly"";
    

    
    public AggregateTransformer createReport() {
        AggregateTransformer transformer = new AggregateTransformer(this);
        transformers.addElement(transformer);
        return transformer;
    }

    
    public void setTofile(String value) {
        toFile = value;
    }

    
    public void setTodir(File value) {
        toDir = value;
    }

    
    public void addFileSet(FileSet fs) {
        filesets.addElement(fs);
    }

    
    public void execute() throws BuildException {
        Element rootElement = createDocument();
        File destFile = getDestinationFile();
        
        try {
            writeDOMTree(rootElement.getOwnerDocument(), destFile);
        } catch (IOException e) {
            throw new BuildException(""Unable to write test aggregate to '"" + destFile + ""'"", e);
        }
        
        Enumeration e = transformers.elements();
        while (e.hasMoreElements()) {
            AggregateTransformer transformer =
                (AggregateTransformer) e.nextElement();
            transformer.setXmlDocument(rootElement.getOwnerDocument());
            transformer.transform();
        }
    }

    
    public File getDestinationFile() {
        if (toFile == null) {
            toFile = DEFAULT_FILENAME;
        }
        if (toDir == null) {
            toDir = getProject().resolveFile(DEFAULT_DIR);
        }
        return new File(toDir, toFile);
    }

    
    protected File[] getFiles() {
        Vector v = new Vector();
        final int size = filesets.size();
        for (int i = 0; i < size; i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            ds.scan();
            String[] f = ds.getIncludedFiles();
            for (int j = 0; j < f.length; j++) {
                String pathname = f[j];
                if (pathname.endsWith("".xml"")) {
                    File file = new File(ds.getBasedir(), pathname);
                    file = getProject().resolveFile(file.getPath());
                    v.addElement(file);
                }
            }
        }

        File[] files = new File[v.size()];
        v.copyInto(files);
        return files;
    }

    

    
    protected void writeDOMTree(Document doc, File file) throws IOException {
        OutputStream out = null;
        PrintWriter wri = null;
        try {
            out = new BufferedOutputStream(new FileOutputStream(file));
            wri = new PrintWriter(new OutputStreamWriter(out, ""UTF8""));
            wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n"");
            (new DOMElementWriter()).write(doc.getDocumentElement(), wri, 0, ""  "");
            wri.flush();
            
            if (wri.checkError()) {
                throw new IOException(""Error while writing DOM content"");
            }
        } finally {
            FileUtils.close(wri);
            FileUtils.close(out);
        }
    }

    
    protected Element createDocument() {
        
        DocumentBuilder builder = getDocumentBuilder();
        Document doc = builder.newDocument();
        Element rootElement = doc.createElement(TESTSUITES);
        doc.appendChild(rootElement);

        generatedId = 0;

        
        File[] files = getFiles();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            try {
                log(""Parsing file: '"" + file + ""'"", Project.MSG_VERBOSE);
                if (file.length() > 0) {
                    Document testsuiteDoc
                            = builder.parse(
                                FileUtils.getFileUtils().toURI(files[i].getAbsolutePath()));
                    Element elem = testsuiteDoc.getDocumentElement();
                    
                    if (TESTSUITE.equals(elem.getNodeName())) {
                        addTestSuite(rootElement, elem);
                        generatedId++;
                    } else {
                        
                        
                        log(""the file "" + file
                                + WARNING_INVALID_ROOT_ELEMENT,
                                Project.MSG_WARN);
                    }
                } else {
                    log(""the file "" + file
                            + WARNING_EMPTY_FILE,
                            Project.MSG_WARN);
                }
            } catch (SAXException e) {
                
                
                log(""The file "" + file + WARNING_IS_POSSIBLY_CORRUPTED, Project.MSG_WARN);
                log(StringUtils.getStackTrace(e), Project.MSG_DEBUG);
            } catch (IOException e) {
                log(""Error while accessing file "" + file + "": ""
                    + e.getMessage(), Project.MSG_ERR);
            }
        }
        return rootElement;
    }

    
    protected void addTestSuite(Element root, Element testsuite) {
        String fullclassname = testsuite.getAttribute(ATTR_NAME);
        int pos = fullclassname.lastIndexOf('.');

        
        String pkgName = (pos == -1) ? """" : fullclassname.substring(0, pos);
        String classname = (pos == -1) ? fullclassname : fullclassname.substring(pos + 1);
        Element copy = (Element) DOMUtil.importNode(root, testsuite);

        
        copy.setAttribute(ATTR_NAME, classname);
        copy.setAttribute(ATTR_PACKAGE, pkgName);
        copy.setAttribute(ATTR_ID, Integer.toString(generatedId));
    }

    
    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (Exception exc) {
            throw new ExceptionInInitializerError(exc);
        }
    }

}
"
org.apache.tools.ant.util.regexp.RegexpMatcher,6,1,0,9,6,15,8,1,6,1.2,10,0.0,0,0.0,0.722222222,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.util.regexp;

import java.util.Vector;
import org.apache.tools.ant.BuildException;


public interface RegexpMatcher {

    
    int MATCH_DEFAULT          = 0x00000000;

    
    int MATCH_CASE_INSENSITIVE = 0x00000100;

    
    int MATCH_MULTILINE        = 0x00001000;

    
    int MATCH_SINGLELINE       = 0x00010000;


    
    void setPattern(String pattern) throws BuildException;

    
    String getPattern() throws BuildException;

    
    boolean matches(String argument) throws BuildException;

    
    Vector getGroups(String argument) throws BuildException;

    
    boolean matches(String input, int options) throws BuildException;

    
    Vector getGroups(String input, int options) throws BuildException;

}
"
org.apache.tools.ant.types.selectors.OrSelector,3,5,0,7,14,3,6,2,3,2.0,52,0.0,0,0.96875,0.555555556,1,1,16.33333333,3,1.6667,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.Enumeration;


public class OrSelector extends BaseSelectorContainer {

    
    public OrSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (hasSelectors()) {
            buf.append(""{orselect: "");
            buf.append(super.toString());
            buf.append(""}"");
        }
        return buf.toString();
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        validate();
        Enumeration e = selectorElements();
        boolean result;

        
        while (e.hasMoreElements()) {
            result = ((FileSelector) e.nextElement()).isSelected(basedir,
                    filename, file);
            if (result) {
                return true;
            }
        }
        return false;
    }

}

"
org.apache.tools.ant.types.spi.Service,7,2,0,5,27,0,1,4,7,0.5,115,1.0,0,0.6,0.476190476,0,0,15.14285714,4,1.2857,0,"
package org.apache.tools.ant.types.spi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.BuildException;


public class Service extends ProjectComponent {
    private List providerList = new ArrayList();
    private String type;

    
    public void setProvider(String className) {
        Provider provider = new Provider();
        provider.setClassName(className);
        providerList.add(provider);
    }

    
    public void addConfiguredProvider(Provider provider) {
        provider.check();
        providerList.add(provider);
    }

    
    public String getType() {
        return type;
    }

    
    public void setType(String type) {
        this.type = type;
    }

    
    public InputStream getAsStream() throws IOException {
        ByteArrayOutputStream arrayOut;
        Writer writer;
        Iterator providerIterator;
        Provider provider;

        arrayOut = new ByteArrayOutputStream();
        writer = new OutputStreamWriter(arrayOut, ""UTF-8"");
        providerIterator = providerList.iterator();
        while (providerIterator.hasNext()) {
            provider = (Provider) providerIterator.next();
            writer.write(provider.getClassName());
            writer.write(""\n"");
        }
        writer.close();
        return new ByteArrayInputStream(arrayOut.toByteArray());
    }

    
    public void check() {
        if (type == null) {
            throw new BuildException(
                ""type attribute must be set for service element"",
                getLocation());
        }
        if (type.length() == 0) {
            throw new BuildException(
                ""Invalid empty type classname"", getLocation());
        }
        if (providerList.size() == 0) {
            throw new BuildException(
                ""provider attribute or nested provider element must be set!"",
                getLocation());
        }
    }
}
"
org.apache.tools.ant.taskdefs.Pack,14,3,2,8,38,83,2,6,8,0.743589744,220,1.0,1,0.74,0.297619048,1,1,14.5,4,1.2143,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;



public abstract class Pack extends Task {

    
    protected File zipFile;
    protected File source;
    
    private Resource src;

    
    public void setZipfile(File zipFile) {
        this.zipFile = zipFile;
    }

    
    public void setDestfile(File zipFile) {
        setZipfile(zipFile);
    }

    
    public void setSrc(File src) {
        setSrcResource(new FileResource(src));
    }

    
    public void setSrcResource(Resource src) {
        if (src.isDirectory()) {
            throw new BuildException(""the source can't be a directory"");
        }
        if (src instanceof FileResource) {
            source = ((FileResource) src).getFile();
        } else if (!supportsNonFileResources()) {
            throw new BuildException(""Only FileSystem resources are""
                                     + "" supported."");
        }
        this.src = src;
    }

    
    public void addConfigured(ResourceCollection a) {
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported as archives"");
        }
        setSrcResource((Resource) a.iterator().next());
    }

    
    private void validate() throws BuildException {
        if (zipFile == null) {
            throw new BuildException(""zipfile attribute is required"", getLocation());
        }

        if (zipFile.isDirectory()) {
            throw new BuildException(""zipfile attribute must not ""
                                    + ""represent a directory!"", getLocation());
        }

        if (getSrcResource() == null) {
            throw new BuildException(""src attribute or nested resource is""
                                     + "" required"", getLocation());
        }
    }

    
    public void execute() throws BuildException {
        validate();

        Resource s = getSrcResource();
        if (!s.isExists()) {
            log(""Nothing to do: "" + s.toString()
                + "" doesn't exist."");
        } else if (zipFile.lastModified() < s.getLastModified()) {
            log(""Building: "" + zipFile.getAbsolutePath());
            pack();
        } else {
            log(""Nothing to do: "" + zipFile.getAbsolutePath()
                + "" is up to date."");
        }
    }

    
    private void zipFile(InputStream in, OutputStream zOut)
        throws IOException {
        byte[] buffer = new byte[8 * 1024];
        int count = 0;
        do {
            zOut.write(buffer, 0, count);
            count = in.read(buffer, 0, buffer.length);
        } while (count != -1);
    }

    
    protected void zipFile(File file, OutputStream zOut)
        throws IOException {
        zipResource(new FileResource(file), zOut);
    }

    
    protected void zipResource(Resource resource, OutputStream zOut)
        throws IOException {
        InputStream rIn = resource.getInputStream();
        try {
            zipFile(rIn, zOut);
        } finally {
            rIn.close();
        }
    }

    
    protected abstract void pack();

    
    public Resource getSrcResource() {
        return src;
    }

    
    protected boolean supportsNonFileResources() {
        return false;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.DescriptorHandler,11,2,3,11,39,7,9,2,10,0.960606061,605,1.0,1,0.583333333,0.25974026,0,0,51.0,15,2.9091,0,"

package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Hashtable;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.xml.sax.AttributeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;


public class DescriptorHandler extends org.xml.sax.HandlerBase {
    private static final int DEFAULT_HASH_TABLE_SIZE = 10;
    private static final int STATE_LOOKING_EJBJAR = 1;
    private static final int STATE_IN_EJBJAR = 2;
    private static final int STATE_IN_BEANS = 3;
    private static final int STATE_IN_SESSION = 4;
    private static final int STATE_IN_ENTITY = 5;
    private static final int STATE_IN_MESSAGE = 6;

    private Task owningTask;

    private String publicId = null;

    
    private static final String EJB_REF               = ""ejb-ref"";
    private static final String EJB_LOCAL_REF         = ""ejb-local-ref"";
    private static final String HOME_INTERFACE        = ""home"";
    private static final String REMOTE_INTERFACE      = ""remote"";
    private static final String LOCAL_HOME_INTERFACE  = ""local-home"";
    private static final String LOCAL_INTERFACE       = ""local"";
    private static final String BEAN_CLASS            = ""ejb-class"";
    private static final String PK_CLASS              = ""prim-key-class"";
    private static final String EJB_NAME              = ""ejb-name"";
    private static final String EJB_JAR               = ""ejb-jar"";
    private static final String ENTERPRISE_BEANS      = ""enterprise-beans"";
    private static final String ENTITY_BEAN           = ""entity"";
    private static final String SESSION_BEAN          = ""session"";
    private static final String MESSAGE_BEAN          = ""message-driven"";

    
    private int parseState = STATE_LOOKING_EJBJAR;

    
    
    protected String currentElement = null;

    
    protected String currentText = null;

    
    protected Hashtable ejbFiles = null;

    
    protected String ejbName = null;

    private Hashtable fileDTDs = new Hashtable();

    private Hashtable resourceDTDs = new Hashtable();

    private boolean inEJBRef = false;

    private Hashtable urlDTDs = new Hashtable();
    

    
    private File srcDir;

    
    public DescriptorHandler(Task task, File srcDir) {
        this.owningTask = task;
        this.srcDir = srcDir;
    }

    
    public void registerDTD(String publicId, String location) {
        if (location == null) {
            return;
        }

        File fileDTD = new File(location);
        if (!fileDTD.exists()) {
            
            fileDTD = owningTask.getProject().resolveFile(location);
        }

        if (fileDTD.exists()) {
            if (publicId != null) {
                fileDTDs.put(publicId, fileDTD);
                owningTask.log(""Mapped publicId "" + publicId + "" to file ""
                    + fileDTD, Project.MSG_VERBOSE);
            }
            return;
        }

        if (getClass().getResource(location) != null) {
            if (publicId != null) {
                resourceDTDs.put(publicId, location);
                owningTask.log(""Mapped publicId "" + publicId + "" to resource ""
                    + location, Project.MSG_VERBOSE);
            }
        }

        try {
            if (publicId != null) {
                URL urldtd = new URL(location);
                urlDTDs.put(publicId, urldtd);
            }
        } catch (java.net.MalformedURLException e) {
            
        }

    }

    
    public InputSource resolveEntity(String publicId, String systemId)
        throws SAXException {
        this.publicId = publicId;

        File dtdFile = (File) fileDTDs.get(publicId);
        if (dtdFile != null) {
            try {
                owningTask.log(""Resolved "" + publicId + "" to local file ""
                    + dtdFile, Project.MSG_VERBOSE);
                return new InputSource(new FileInputStream(dtdFile));
            } catch (FileNotFoundException ex) {
                
            }
        }

        String dtdResourceName = (String) resourceDTDs.get(publicId);
        if (dtdResourceName != null) {
            InputStream is = this.getClass().getResourceAsStream(dtdResourceName);
            if (is != null) {
                owningTask.log(""Resolved "" + publicId + "" to local resource ""
                    + dtdResourceName, Project.MSG_VERBOSE);
                return new InputSource(is);
            }
        }

        URL dtdUrl = (URL) urlDTDs.get(publicId);
        if (dtdUrl != null) {
            try {
                InputStream is = dtdUrl.openStream();
                owningTask.log(""Resolved "" + publicId + "" to url ""
                    + dtdUrl, Project.MSG_VERBOSE);
                return new InputSource(is);
            } catch (IOException ioe) {
                
            }
        }

        owningTask.log(""Could not resolve ( publicId: "" + publicId
            + "", systemId: "" + systemId + "") to a local entity"", Project.MSG_INFO);

        return null;
    }

    
    public Hashtable getFiles() {
        return (ejbFiles == null) ? new Hashtable() : ejbFiles;
    }

    
    public String getPublicId() {
        return publicId;
    }

     
    public String getEjbName() {
        return ejbName;
    }

    
    public void startDocument() throws SAXException {
        this.ejbFiles = new Hashtable(DEFAULT_HASH_TABLE_SIZE, 1);
        this.currentElement = null;
        inEJBRef = false;
    }


    
    public void startElement(String name, AttributeList attrs)
        throws SAXException {
        this.currentElement = name;
        currentText = """";
        if (name.equals(EJB_REF) || name.equals(EJB_LOCAL_REF)) {
            inEJBRef = true;
        } else if (parseState == STATE_LOOKING_EJBJAR && name.equals(EJB_JAR)) {
            parseState = STATE_IN_EJBJAR;
        } else if (parseState == STATE_IN_EJBJAR && name.equals(ENTERPRISE_BEANS)) {
            parseState = STATE_IN_BEANS;
        } else if (parseState == STATE_IN_BEANS && name.equals(SESSION_BEAN)) {
            parseState = STATE_IN_SESSION;
        } else if (parseState == STATE_IN_BEANS && name.equals(ENTITY_BEAN)) {
            parseState = STATE_IN_ENTITY;
        } else if (parseState == STATE_IN_BEANS && name.equals(MESSAGE_BEAN)) {
            parseState = STATE_IN_MESSAGE;
        }
    }


    
    public void endElement(String name) throws SAXException {
        processElement();
        currentText = """";
        this.currentElement = """";
        if (name.equals(EJB_REF) || name.equals(EJB_LOCAL_REF)) {
            inEJBRef = false;
        } else if (parseState == STATE_IN_ENTITY && name.equals(ENTITY_BEAN)) {
            parseState = STATE_IN_BEANS;
        } else if (parseState == STATE_IN_SESSION && name.equals(SESSION_BEAN)) {
            parseState = STATE_IN_BEANS;
        } else if (parseState == STATE_IN_MESSAGE && name.equals(MESSAGE_BEAN)) {
            parseState = STATE_IN_BEANS;
        } else if (parseState == STATE_IN_BEANS && name.equals(ENTERPRISE_BEANS)) {
            parseState = STATE_IN_EJBJAR;
        } else if (parseState == STATE_IN_EJBJAR && name.equals(EJB_JAR)) {
            parseState = STATE_LOOKING_EJBJAR;
        }
    }

    
    public void characters(char[] ch, int start, int length)
        throws SAXException {

        currentText += new String(ch, start, length);
    }


    
    protected void processElement() {
        if (inEJBRef
            || (parseState != STATE_IN_ENTITY
                && parseState != STATE_IN_SESSION
                && parseState != STATE_IN_MESSAGE)) {
            return;
        }

        if (currentElement.equals(HOME_INTERFACE)
            || currentElement.equals(REMOTE_INTERFACE)
            || currentElement.equals(LOCAL_INTERFACE)
            || currentElement.equals(LOCAL_HOME_INTERFACE)
            || currentElement.equals(BEAN_CLASS)
            || currentElement.equals(PK_CLASS)) {

            
            File classFile = null;
            String className = currentText.trim();

            
            
            if (!className.startsWith(""java."")
                && !className.startsWith(""javax."")) {
                
                
                className = className.replace('.', File.separatorChar);
                className += "".class"";
                classFile = new File(srcDir, className);
                ejbFiles.put(className, classFile);
            }
        }

        
        if (currentElement.equals(EJB_NAME)) {
            if (ejbName == null) {
                ejbName = currentText.trim();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.jlink.jlink,17,1,0,2,81,100,1,1,9,0.7125,654,0.8,0,0.0,0.274509804,0,0,37.17647059,7,2.0588,0,"

package org.apache.tools.ant.taskdefs.optional.jlink;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Vector;
import java.util.zip.CRC32;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;



public class jlink {


    private String outfile = null;

    private Vector mergefiles = new Vector(10);

    private Vector addfiles = new Vector(10);

    private boolean compression = false;

    

    byte[] buffer = new byte[8192];

    

    
    public void setOutfile(String outfile) {
        if (outfile == null) {
            return;
        }
        this.outfile = outfile;
    }


    
    public void addMergeFile(String fileToMerge) {
        if (fileToMerge == null) {
            return;
        }
        mergefiles.addElement(fileToMerge);
    }


    
    public void addAddFile(String fileToAdd) {
        if (fileToAdd == null) {
            return;
        }
        addfiles.addElement(fileToAdd);
    }


    
    public void addMergeFiles(String[] filesToMerge) {
        if (filesToMerge == null) {
            return;
        }
        for (int i = 0; i < filesToMerge.length; i++) {
            addMergeFile(filesToMerge[i]);
        }
    }


    
    public void addAddFiles(String[] filesToAdd) {
        if (filesToAdd == null) {
            return;
        }
        for (int i = 0; i < filesToAdd.length; i++) {
            addAddFile(filesToAdd[i]);
        }
    }


    
    public void setCompression(boolean compress) {
        this.compression = compress;
    }


    
    public void link() throws Exception {
        ZipOutputStream output = new ZipOutputStream(new FileOutputStream(outfile));

        if (compression) {
            output.setMethod(ZipOutputStream.DEFLATED);
            output.setLevel(Deflater.DEFAULT_COMPRESSION);
        } else {
            output.setMethod(ZipOutputStream.STORED);
        }

        Enumeration merges = mergefiles.elements();

        while (merges.hasMoreElements()) {
            String path = (String) merges.nextElement();
            File f = new File(path);

            if (f.getName().endsWith("".jar"") || f.getName().endsWith("".zip"")) {
                
                mergeZipJarContents(output, f);
            } else {
                
                
                addAddFile(path);
            }
        }

        Enumeration adds = addfiles.elements();

        while (adds.hasMoreElements()) {
            String name = (String) adds.nextElement();
            File f = new File(name);

            if (f.isDirectory()) {
                
                addDirContents(output, f, f.getName() + '/', compression);
            } else {
                addFile(output, f, """", compression);
            }
        }
        if (output != null) {
            try {
                output.close();
            } catch (IOException ioe) {
                
            }
        }
    }


    
    public static void main(String[] args) {
        
        if (args.length < 2) {
            System.out.println(""usage: jlink output input1 ... inputN"");
            System.exit(1);
        }
        jlink linker = new jlink();

        linker.setOutfile(args[0]);
        
        
        for (int i = 1; i < args.length; i++) {
            linker.addMergeFile(args[i]);
        }
        try {
            linker.link();
        } catch (Exception ex) {
            System.err.print(ex.getMessage());
        }
    }


    
    private void mergeZipJarContents(ZipOutputStream output, File f) throws IOException {
        
        if (!f.exists()) {
            return;
        }
        ZipFile zipf = new ZipFile(f);
        Enumeration entries = zipf.entries();

        while (entries.hasMoreElements()) {
            ZipEntry inputEntry = (ZipEntry) entries.nextElement();
            
            
            
            String inputEntryName = inputEntry.getName();
            int index = inputEntryName.indexOf(""META-INF"");

            if (index < 0) {
                
                try {
                    output.putNextEntry(processEntry(zipf, inputEntry));
                } catch (ZipException ex) {
                    
                    
                    
                    
                    
                    
                    String mess = ex.getMessage();

                    if (mess.indexOf(""duplicate"") >= 0) {
                        
                        continue;
                    } else {
                        
                        
                        throw ex;
                    }
                }

                InputStream in = zipf.getInputStream(inputEntry);
                int len = buffer.length;
                int count = -1;

                while ((count = in.read(buffer, 0, len)) > 0) {
                    output.write(buffer, 0, count);
                }
                in.close();
                output.closeEntry();
            }
        }
        zipf.close();
    }


    
    private void addDirContents(ZipOutputStream output, File dir, String prefix,
                                boolean compress) throws IOException {
        String[] contents = dir.list();

        for (int i = 0; i < contents.length; ++i) {
            String name = contents[i];
            File file = new File(dir, name);

            if (file.isDirectory()) {
                addDirContents(output, file, prefix + name + '/', compress);
            } else {
                addFile(output, file, prefix, compress);
            }
        }
    }


    
    private String getEntryName(File file, String prefix) {
        String name = file.getName();

        if (!name.endsWith("".class"")) {
            
            InputStream input = null;
            try {
                input = new FileInputStream(file);
                String className = ClassNameReader.getClassName(input);

                if (className != null) {
                    return className.replace('.', '/') + "".class"";
                }
            } catch (IOException ioe) {
                
            } finally {
                if (input != null) {
                    try {
                        input.close();
                    } catch (IOException e) {
                        
                    }
                }
            }
        }
        System.out.println(""From "" + file.getPath() + "" and prefix "" + prefix
                           + "", creating entry "" + prefix + name);
        return (prefix + name);
    }


    
    private void addFile(ZipOutputStream output, File file, String prefix,
                         boolean compress) throws IOException {
        
        if (!file.exists()) {
            return;
        }
        ZipEntry entry = new ZipEntry(getEntryName(file, prefix));

        entry.setTime(file.lastModified());
        entry.setSize(file.length());
        if (!compress) {
            entry.setCrc(calcChecksum(file));
        }
        FileInputStream input = new FileInputStream(file);

        addToOutputStream(output, input, entry);
    }


    
    private void addToOutputStream(ZipOutputStream output, InputStream input,
                                   ZipEntry ze) throws IOException {
        try {
            output.putNextEntry(ze);
        } catch (ZipException zipEx) {
            
            input.close();
            return;
        }

        int numBytes = -1;

        while ((numBytes = input.read(buffer)) > 0) {
            output.write(buffer, 0, numBytes);
        }
        output.closeEntry();
        input.close();
    }


    
    private ZipEntry processEntry(ZipFile zip, ZipEntry inputEntry) {
        
        String name = inputEntry.getName();

        if (!(inputEntry.isDirectory() || name.endsWith("".class""))) {
            try {
                InputStream input = zip.getInputStream(zip.getEntry(name));
                String className = ClassNameReader.getClassName(input);

                input.close();
                if (className != null) {
                    name = className.replace('.', '/') + "".class"";
                }
            } catch (IOException ioe) {
                
            }
        }
        ZipEntry outputEntry = new ZipEntry(name);

        outputEntry.setTime(inputEntry.getTime());
        outputEntry.setExtra(inputEntry.getExtra());
        outputEntry.setComment(inputEntry.getComment());
        outputEntry.setTime(inputEntry.getTime());
        if (compression) {
            outputEntry.setMethod(ZipEntry.DEFLATED);
            
        } else {
            outputEntry.setMethod(ZipEntry.STORED);
            outputEntry.setCrc(inputEntry.getCrc());
            outputEntry.setSize(inputEntry.getSize());
        }
        return outputEntry;
    }


    
    private long calcChecksum(File f) throws IOException {
        BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));

        return calcChecksum(in);
    }


    
    private long calcChecksum(InputStream in) throws IOException {
        CRC32 crc = new CRC32();
        int len = buffer.length;
        int count = -1;
        int haveRead = 0;

        while ((count = in.read(buffer, 0, len)) > 0) {
            haveRead += count;
            crc.update(buffer, 0, count);
        }
        in.close();
        return crc.getValue();
    }


}


"
org.apache.tools.ant.taskdefs.optional.perforce.SimpleP4OutputHandler,2,2,1,17,14,0,13,5,2,0.0,103,0.0,1,0.875,0.666666667,0,0,50.0,1,0.5,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.StringUtils;


public class SimpleP4OutputHandler extends P4HandlerAdapter {

    
    P4Base parent;
    

    
    public SimpleP4OutputHandler(P4Base parent) {
        this.parent = parent;
    }

    
    public void process(String line) throws BuildException {
        if (parent.util.match(""/^exit/"", line)) {
            return;
        }

        
        
        
        
        
        
        
        
        
        
        
        

        if (parent.util.match(""/^error:/"", line)
            || parent.util.match(""/^Perforce client error:/"", line)) {
            
            
            
            
            if (!parent.util.match(""/label in sync/"", line)
                && !parent.util.match(""/up-to-date/"", line)) {
                parent.setInError(true);
            } else {
                
                line = parent.util.substitute(""s/^[^:]*: 
            }
        } else if (parent.util.match(""/^info.*?:/"", line)) {
            
            line = parent.util.substitute(""s/^[^:]*: 
        }
        parent.log(line, parent.getInError() ? Project.MSG_ERR : Project.MSG_INFO);

        if (parent.getInError()) {
            parent.setErrorMessage(parent.getErrorMessage() + line + StringUtils.LINE_SEP);
        }
    }
}
"
org.apache.tools.ant.types.Mapper,15,3,0,25,44,45,16,10,13,0.619047619,311,1.0,3,0.681818182,0.216666667,1,1,19.33333333,6,1.8667,0,"

package org.apache.tools.ant.types;

import java.util.Properties;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.CompositeMapper;
import org.apache.tools.ant.util.ContainerMapper;


public class Mapper extends DataType implements Cloneable {
    

    protected MapperType type = null;
    protected String classname = null;
    protected Path classpath = null;
    protected String from = null;
    protected String to = null;

    

    private ContainerMapper container = null;

    
    public Mapper(Project p) {
        setProject(p);
    }

    
    public void setType(MapperType type) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.type = type;
    }

    
    public void addConfigured(FileNameMapper fileNameMapper) {
        add(fileNameMapper);
    }

    
    public void add(FileNameMapper fileNameMapper) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (container == null) {
            if (type == null && classname == null) {
                container = new CompositeMapper();
            } else {
                FileNameMapper m = getImplementation();
                if (m instanceof ContainerMapper) {
                    container = (ContainerMapper) m;
                } else {
                    throw new BuildException(String.valueOf(m)
                        + "" mapper implementation does not support nested mappers!"");
                }
            }
        }
        container.add(fileNameMapper);
    }

    
    public void addConfiguredMapper(Mapper mapper) {
        add(mapper.getImplementation());
    }

    
    public void setClassname(String classname) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.classname = classname;
    }

    
    public void setClasspath(Path classpath) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference ref) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createClasspath().setRefid(ref);
    }

    
    public void setFrom(String from) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.from = from;
    }

    
    public void setTo(String to) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.to = to;
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (type != null || from != null || to != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public FileNameMapper getImplementation() throws BuildException {
        if (isReference()) {
            return getRef().getImplementation();
        }

        if (type == null && classname == null && container == null) {
            throw new BuildException(
                ""nested mapper or ""
                + ""one of the attributes type or classname is required"");
        }

        if (container != null) {
            return container;
        }

        if (type != null && classname != null) {
            throw new BuildException(
                ""must not specify both type and classname attribute"");
        }

        try {
            FileNameMapper m
                = (FileNameMapper) (getImplementationClass().newInstance());
            final Project p = getProject();
            if (p != null) {
                p.setProjectReference(m);
            }
            m.setFrom(from);
            m.setTo(to);

            return m;
        } catch (BuildException be) {
            throw be;
        } catch (Throwable t) {
            throw new BuildException(t);
        }
    }

     
    protected Class getImplementationClass() throws ClassNotFoundException {

        String cName = this.classname;
        if (type != null) {
            cName = type.getImplementation();
        }

        ClassLoader loader = (classpath == null)
            ? getClass().getClassLoader()
            : getProject().createClassLoader(classpath);

        return Class.forName(cName, true, loader);
    }

    
    protected Mapper getRef() {
        return (Mapper) getCheckedRef();
    }

    
    public static class MapperType extends EnumeratedAttribute {
        private Properties implementations;

        
        public MapperType() {
            implementations = new Properties();
            implementations.put(""identity"",
                                ""org.apache.tools.ant.util.IdentityMapper"");
            implementations.put(""flatten"",
                                ""org.apache.tools.ant.util.FlatFileNameMapper"");
            implementations.put(""glob"",
                                ""org.apache.tools.ant.util.GlobPatternMapper"");
            implementations.put(""merge"",
                                ""org.apache.tools.ant.util.MergingMapper"");
            implementations.put(""regexp"",
                                ""org.apache.tools.ant.util.RegexpPatternMapper"");
            implementations.put(""package"",
                                ""org.apache.tools.ant.util.PackageNameMapper"");
            implementations.put(""unpackage"",
                                ""org.apache.tools.ant.util.UnPackageNameMapper"");
        }

        
        public String[] getValues() {
            return new String[] {""identity"", ""flatten"", ""glob"",
                                 ""merge"", ""regexp"", ""package"", ""unpackage""};
        }

        
        public String getImplementation() {
            return implementations.getProperty(getValue());
        }
    }

}
"
org.apache.tools.ant.Task,29,2,102,184,66,346,181,8,19,0.839285714,375,1.0,3,0.243243243,0.191570881,1,1,11.72413793,5,1.3448,0,"

package org.apache.tools.ant;

import org.apache.tools.ant.dispatch.DispatchUtils;

import java.util.Enumeration;
import java.io.IOException;


public abstract class Task extends ProjectComponent {
    
    
    protected Target target;

    
    protected String taskName;

    
    protected String taskType;

    
    protected RuntimeConfigurable wrapper;

    

    
    private boolean invalid;

    
    public Task() {
    }

    
    public void setOwningTarget(Target target) {
        this.target = target;
    }

    
    public Target getOwningTarget() {
        return target;
    }

    
    public void setTaskName(String name) {
        this.taskName = name;
    }

    
    public String getTaskName() {
        return taskName;
    }

    
    public void setTaskType(String type) {
        this.taskType = type;
    }

    
    public void init() throws BuildException {
    }

    
    public void execute() throws BuildException {
    }

    
    public RuntimeConfigurable getRuntimeConfigurableWrapper() {
        if (wrapper == null) {
            wrapper = new RuntimeConfigurable(this, getTaskName());
        }
        return wrapper;
    }

    
    public void setRuntimeConfigurableWrapper(RuntimeConfigurable wrapper) {
        this.wrapper = wrapper;
    }

    
    
    
    
    
    public void maybeConfigure() throws BuildException {
        if (!invalid) {
            if (wrapper != null) {
                wrapper.maybeConfigure(getProject());
            }
        } else {
            getReplacement();
        }
    }

    
    public void reconfigure() {
        if (wrapper != null) {
            wrapper.reconfigure(getProject());
        }
    }

    
    protected void handleOutput(String output) {
        log(output, Project.MSG_INFO);
    }

    
    protected void handleFlush(String output) {
        handleOutput(output);
    }

    
    protected int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        return getProject().defaultInput(buffer, offset, length);
    }

    
    protected void handleErrorOutput(String output) {
        log(output, Project.MSG_WARN);
    }

    
    protected void handleErrorFlush(String output) {
        handleErrorOutput(output);
    }

    
    public void log(String msg) {
        log(msg, Project.MSG_INFO);
    }

    
    public void log(String msg, int msgLevel) {
        if (getProject() != null) {
            getProject().log(this, msg, msgLevel);
        } else {
            super.log(msg, msgLevel);
        }
    }

    
    public void log(Throwable t, int msgLevel) {
        if (t != null) {
            log(t.getMessage(), t, msgLevel);
        }
    }

    
    public void log(String msg, Throwable t, int msgLevel) {
        if (getProject() != null) {
            getProject().log(this, msg, t, msgLevel);
        } else {
            super.log(msg, msgLevel);
        }
    }

    
    public final void perform() {
        if (!invalid) {
            getProject().fireTaskStarted(this);
            Throwable reason = null;
            try {
                maybeConfigure();
                DispatchUtils.execute(this);
            } catch (BuildException ex) {
                if (ex.getLocation() == Location.UNKNOWN_LOCATION) {
                    ex.setLocation(getLocation());
                }
                reason = ex;
                throw ex;
            } catch (Exception ex) {
                reason = ex;
                BuildException be = new BuildException(ex);
                be.setLocation(getLocation());
                throw be;
            } catch (Error ex) {
                reason = ex;
                throw ex;
            } finally {
                getProject().fireTaskFinished(this, reason);
            }
        } else {
            UnknownElement ue = getReplacement();
            Task task = ue.getTask();
            task.perform();
        }
    }

    
    final void markInvalid() {
        invalid = true;
    }

    
    protected final boolean isInvalid() {
        return invalid;
    }

    
    private UnknownElement replacement;

    
    private UnknownElement getReplacement() {
        if (replacement == null) {
            replacement = new UnknownElement(taskType);
            replacement.setProject(getProject());
            replacement.setTaskType(taskType);
            replacement.setTaskName(taskName);
            replacement.setLocation(location);
            replacement.setOwningTarget(target);
            replacement.setRuntimeConfigurableWrapper(wrapper);
            wrapper.setProxy(replacement);
            replaceChildren(wrapper, replacement);
            target.replaceChild(this, replacement);
            replacement.maybeConfigure();
        }
        return replacement;
    }

    
    private void replaceChildren(RuntimeConfigurable wrapper,
                                 UnknownElement parentElement) {
        Enumeration e = wrapper.getChildren();
        while (e.hasMoreElements()) {
            RuntimeConfigurable childWrapper =
                (RuntimeConfigurable) e.nextElement();
            UnknownElement childElement =
                new UnknownElement(childWrapper.getElementTag());
            parentElement.addChild(childElement);
            childElement.setProject(getProject());
            childElement.setRuntimeConfigurableWrapper(childWrapper);
            childWrapper.setProxy(childElement);
            replaceChildren(childWrapper, childElement);
        }
    }

    
    public String getTaskType() {
        return taskType;
    }

    
    protected RuntimeConfigurable getWrapper() {
        return wrapper;
    }

    
    public final void bindToOwner(Task owner) {
        setProject(owner.getProject());
        setOwningTarget(owner.getOwningTarget());
        setTaskName(owner.getTaskName());
        setDescription(owner.getDescription());
        setLocation(owner.getLocation());
        setTaskType(owner.getTaskType());
    }
}
"
org.apache.tools.ant.types.resources.Files,34,4,0,10,92,39,0,10,29,0.723484848,710,1.0,2,0.643678161,0.148484848,3,4,19.64705882,5,1.9118,1,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.util.Vector;
import java.util.Iterator;
import java.util.Collections;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.AbstractSelectorContainer;


public class Files extends AbstractSelectorContainer
    implements Cloneable, ResourceCollection {

    private static final Iterator EMPTY_ITERATOR
        = Collections.EMPTY_SET.iterator();

    private PatternSet defaultPatterns = new PatternSet();
    private Vector additionalPatterns = new Vector();
    private Vector selectors = new Vector();

    private boolean useDefaultExcludes = true;
    private boolean caseSensitive = true;
    private boolean followSymlinks = true;

    
    private DirectoryScanner ds = null;

    
    public Files() {
        super();
    }

    
    protected Files(Files f) {
        this.defaultPatterns = f.defaultPatterns;
        this.additionalPatterns = f.additionalPatterns;
        this.selectors = f.selectors;
        this.useDefaultExcludes = f.useDefaultExcludes;
        this.caseSensitive = f.caseSensitive;
        this.followSymlinks = f.followSymlinks;
        this.ds = f.ds;
        setProject(f.getProject());
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (hasPatterns(defaultPatterns)) {
            throw tooManyAttributes();
        }
        if (!additionalPatterns.isEmpty()) {
            throw noChildrenAllowed();
        }
        if (!selectors.isEmpty()) {
            throw noChildrenAllowed();
        }
        super.setRefid(r);
    }

    
    public synchronized PatternSet createPatternSet() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        PatternSet patterns = new PatternSet();
        additionalPatterns.addElement(patterns);
        ds = null;
        return patterns;
    }

    
    public synchronized PatternSet.NameEntry createInclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        ds = null;
        return defaultPatterns.createInclude();
    }

    
    public synchronized PatternSet.NameEntry createIncludesFile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        ds = null;
        return defaultPatterns.createIncludesFile();
    }

    
    public synchronized PatternSet.NameEntry createExclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        ds = null;
        return defaultPatterns.createExclude();
    }

    
    public synchronized PatternSet.NameEntry createExcludesFile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        ds = null;
        return defaultPatterns.createExcludesFile();
    }

    
    public synchronized void setIncludes(String includes) {
        checkAttributesAllowed();
        defaultPatterns.setIncludes(includes);
        ds = null;
    }

    
    public synchronized void appendIncludes(String[] includes) {
        checkAttributesAllowed();
        if (includes != null) {
            for (int i = 0; i < includes.length; i++) {
                defaultPatterns.createInclude().setName(includes[i]);
            }
            ds = null;
        }
    }

    
    public synchronized void setExcludes(String excludes) {
        checkAttributesAllowed();
        defaultPatterns.setExcludes(excludes);
        ds = null;
    }

    
    public synchronized void appendExcludes(String[] excludes) {
        checkAttributesAllowed();
        if (excludes != null) {
            for (int i = 0; i < excludes.length; i++) {
                defaultPatterns.createExclude().setName(excludes[i]);
            }
            ds = null;
        }
    }

    
    public synchronized void setIncludesfile(File incl) throws BuildException {
        checkAttributesAllowed();
        defaultPatterns.setIncludesfile(incl);
        ds = null;
    }

    
    public synchronized void setExcludesfile(File excl) throws BuildException {
        checkAttributesAllowed();
        defaultPatterns.setExcludesfile(excl);
        ds = null;
    }

    
    public synchronized void setDefaultexcludes(boolean useDefaultExcludes) {
        checkAttributesAllowed();
        this.useDefaultExcludes = useDefaultExcludes;
        ds = null;
    }

    
    public synchronized boolean getDefaultexcludes() {
        return (isReference())
            ? getRef().getDefaultexcludes() : useDefaultExcludes;
    }

    
    public synchronized void setCaseSensitive(boolean caseSensitive) {
        checkAttributesAllowed();
        this.caseSensitive = caseSensitive;
        ds = null;
    }

    
    public synchronized boolean isCaseSensitive() {
        return (isReference())
            ? getRef().isCaseSensitive() : caseSensitive;
    }

    
    public synchronized void setFollowSymlinks(boolean followSymlinks) {
        checkAttributesAllowed();
        this.followSymlinks = followSymlinks;
        ds = null;
    }

    
    public synchronized boolean isFollowSymlinks() {
        return (isReference())
            ? getRef().isFollowSymlinks() : followSymlinks;
    }

    
    public synchronized Iterator iterator() {
        if (isReference()) {
            return getRef().iterator();
        }
        ensureDirectoryScannerSetup();
        ds.scan();
        int fct = ds.getIncludedFilesCount();
        int dct = ds.getIncludedDirsCount();
        if (fct + dct == 0) {
            return EMPTY_ITERATOR;
        }
        FileResourceIterator result = new FileResourceIterator();
        if (fct > 0) {
            result.addFiles(ds.getIncludedFiles());
        }
        if (dct > 0) {
            result.addFiles(ds.getIncludedDirectories());
        }
        return result;
    }

    
    public synchronized int size() {
        if (isReference()) {
            return getRef().size();
        }
        ensureDirectoryScannerSetup();
        ds.scan();
        return ds.getIncludedFilesCount() + ds.getIncludedDirsCount();
    }

    
    public synchronized boolean hasPatterns() {
        if (isReference()) {
            return getRef().hasPatterns();
        }
        if (hasPatterns(defaultPatterns)) {
            return true;
        }
        for (Iterator i = additionalPatterns.iterator(); i.hasNext();) {
            if (hasPatterns((PatternSet) i.next())) {
                return true;
            }
        }
        return false;
    }

    
    public synchronized void appendSelector(FileSelector selector) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        super.appendSelector(selector);
        ds = null;
    }

    
    public String toString() {
        if (isReference()) {
            return getRef().toString();
        }
        Iterator i = iterator();
        if (!i.hasNext()) {
            return """";
        }
        StringBuffer sb = new StringBuffer();
        while (i.hasNext()) {
            if (sb.length() > 0) {
                sb.append(File.pathSeparatorChar);
            }
            sb.append(i.next());
        }
        return sb.toString();
    }

    
    public synchronized Object clone() {
        if (isReference()) {
            return getRef().clone();
        }
        try {
            Files f = (Files) super.clone();
            f.defaultPatterns = (PatternSet) defaultPatterns.clone();
            f.additionalPatterns = new Vector(additionalPatterns.size());
            for (Iterator iter = additionalPatterns.iterator(); iter.hasNext();) {
                PatternSet ps = (PatternSet) iter.next();
                f.additionalPatterns.add(ps.clone());
            }
            f.selectors = new Vector(selectors);
            return f;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
    }

    
    public String[] mergeIncludes(Project p) {
        return mergePatterns(p).getIncludePatterns(p);
    }

    
    public String[] mergeExcludes(Project p) {
        return mergePatterns(p).getExcludePatterns(p);
    }

    
    public synchronized PatternSet mergePatterns(Project p) {
        if (isReference()) {
            return getRef().mergePatterns(p);
        }
        PatternSet ps = new PatternSet();
        ps.append(defaultPatterns, p);
        final int count = additionalPatterns.size();
        for (int i = 0; i < count; i++) {
            Object o = additionalPatterns.elementAt(i);
            ps.append((PatternSet) o, p);
        }
        return ps;
    }

    
    public boolean isFilesystemOnly() {
        return true;
    }

    
    protected Files getRef() {
        return (Files) getCheckedRef();
    }

    private synchronized void ensureDirectoryScannerSetup() {
        if (ds == null) {
            ds = new DirectoryScanner();
            PatternSet ps = mergePatterns(getProject());
            ds.setIncludes(ps.getIncludePatterns(getProject()));
            ds.setExcludes(ps.getExcludePatterns(getProject()));
            ds.setSelectors(getSelectors(getProject()));
            if (useDefaultExcludes) {
                ds.addDefaultExcludes();
            }
            ds.setCaseSensitive(caseSensitive);
            ds.setFollowSymlinks(followSymlinks);
        }
    }

    private boolean hasPatterns(PatternSet ps) {
        return ps.getIncludePatterns(getProject()).length > 0
            || ps.getExcludePatterns(getProject()).length > 0;
    }

}
"
org.apache.tools.ant.types.selectors.modifiedselector.HashvalueAlgorithm,4,1,0,2,13,6,1,1,4,2.0,45,0.0,0,0.0,0.625,0,0,10.25,2,1.0,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.io.File;



public class HashvalueAlgorithm implements Algorithm {

    
    public boolean isValid() {
        return true;
    }

    
     
     
    public String getValue(File file) {
        try {
            if (!file.canRead()) {
                return null;
            }
            java.io.FileInputStream fis = new java.io.FileInputStream(file);
            byte[] content = new byte[fis.available()];
            fis.read(content);
            fis.close();
            String s = new String(content);
            int hash = s.hashCode();
            return Integer.toString(hash);
        } catch (Exception e) {
            return null;
        }
    }


    
    public String toString() {
        return ""HashvalueAlgorithm"";
    }

}
"
org.apache.tools.ant.util.SourceFileScanner,7,1,0,15,23,5,7,8,6,0.444444444,148,1.0,2,0.0,0.523809524,0,0,19.71428571,3,1.1429,0,"

package org.apache.tools.ant.util;

import java.io.File;
import java.util.Vector;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceFactory;
import org.apache.tools.ant.types.resources.FileResource;


public class SourceFileScanner implements ResourceFactory {

    
    protected Task task;
    

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
    private File destDir;     

    
    public SourceFileScanner(Task task) {
        this.task = task;
    }

    
    public String[] restrict(String[] files, File srcDir, File destDir,
                             FileNameMapper mapper) {
        return restrict(files, srcDir, destDir, mapper,
                        FILE_UTILS.getFileTimestampGranularity());
    }

    
    public String[] restrict(String[] files, File srcDir, File destDir,
                             FileNameMapper mapper, long granularity) {
        
        this.destDir = destDir;
        Vector v = new Vector();
        for (int i = 0; i < files.length; i++) {
            File src = FILE_UTILS.resolveFile(srcDir, files[i]);
            v.addElement(new Resource(files[i], src.exists(),
                                      src.lastModified(), src.isDirectory()));
        }
        Resource[] sourceresources = new Resource[v.size()];
        v.copyInto(sourceresources);

        
        
        Resource[] outofdate =
            ResourceUtils.selectOutOfDateSources(task, sourceresources,
                                                 mapper, this, granularity);
        String[] result = new String[outofdate.length];
        for (int counter = 0; counter < outofdate.length; counter++) {
            result[counter] = outofdate[counter].getName();
        }
        return result;
    }

    
    public File[] restrictAsFiles(String[] files, File srcDir, File destDir,
                                  FileNameMapper mapper) {
        return restrictAsFiles(files, srcDir, destDir, mapper,
                               FILE_UTILS.getFileTimestampGranularity());
    }

    
    public File[] restrictAsFiles(String[] files, File srcDir, File destDir,
                                  FileNameMapper mapper, long granularity) {
        String[] res = restrict(files, srcDir, destDir, mapper, granularity);
        File[] result = new File[res.length];
        for (int i = 0; i < res.length; i++) {
            result[i] = new File(srcDir, res[i]);
        }
        return result;
    }

    
    public Resource getResource(String name) {
        return new FileResource(destDir, name);
    }

}

"
org.apache.tools.ant.taskdefs.optional.i18n.Translate,19,4,0,8,84,103,0,8,14,0.929487179,1034,1.0,1,0.821052632,0.26984127,0,0,52.05263158,1,0.8947,0,"
package org.apache.tools.ant.taskdefs.optional.i18n;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.LineTokenizer;


public class Translate extends MatchingTask {
    
    private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT = 0;
    
    private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY = 1;
    
    private static final int BUNDLE_SPECIFIED_LANGUAGE = 2;
    
    private static final int BUNDLE_NOMATCH = 3;
    
    private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT = 4;
    
    private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY = 5;
    
    private static final int BUNDLE_DEFAULT_LANGUAGE = 6;
    
     private static final int BUNDLE_MAX_ALTERNATIVES = BUNDLE_DEFAULT_LANGUAGE + 1;
    
    private String bundle;

    
    private String bundleLanguage;

    
    private String bundleCountry;

    
    private String bundleVariant;

    
    private File toDir;

    
    private String srcEncoding;

    
    private String destEncoding;

    
    private String bundleEncoding;

    
    private String startToken;

    
    private String endToken;

    
    private boolean forceOverwrite;

    
    private Vector filesets = new Vector();

    
    private Hashtable resourceMap = new Hashtable();
    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private long[] bundleLastModified = new long[BUNDLE_MAX_ALTERNATIVES];

    
    private long srcLastModified;

    
    private long destLastModified;

    
    private boolean loaded = false;

    
    public void setBundle(String bundle) {
        this.bundle = bundle;
    }

    
    public void setBundleLanguage(String bundleLanguage) {
        this.bundleLanguage = bundleLanguage;
    }

    
    public void setBundleCountry(String bundleCountry) {
        this.bundleCountry = bundleCountry;
    }

    
    public void setBundleVariant(String bundleVariant) {
        this.bundleVariant = bundleVariant;
    }

    
    public void setToDir(File toDir) {
        this.toDir = toDir;
    }

    
    public void setStartToken(String startToken) {
        this.startToken = startToken;
    }

    
    public void setEndToken(String endToken) {
        this.endToken = endToken;
    }

    
    public void setSrcEncoding(String srcEncoding) {
        this.srcEncoding = srcEncoding;
    }

    
    public void setDestEncoding(String destEncoding) {
        this.destEncoding = destEncoding;
    }

    
    public void setBundleEncoding(String bundleEncoding) {
        this.bundleEncoding = bundleEncoding;
    }

    
    public void setForceOverwrite(boolean forceOverwrite) {
        this.forceOverwrite = forceOverwrite;
    }

    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }

    
    public void execute() throws BuildException {
        if (bundle == null) {
            throw new BuildException(""The bundle attribute must be set."",
                                     getLocation());
        }

        if (startToken == null) {
            throw new BuildException(""The starttoken attribute must be set."",
                                     getLocation());
        }

        if (endToken == null) {
            throw new BuildException(""The endtoken attribute must be set."",
                                     getLocation());
        }

        if (bundleLanguage == null) {
            Locale l = Locale.getDefault();
            bundleLanguage  = l.getLanguage();
        }

        if (bundleCountry == null) {
            bundleCountry = Locale.getDefault().getCountry();
        }

        if (bundleVariant == null) {
            Locale l = new Locale(bundleLanguage, bundleCountry);
            bundleVariant = l.getVariant();
        }

        if (toDir == null) {
            throw new BuildException(""The todir attribute must be set."",
                                     getLocation());
        }

        if (!toDir.exists()) {
            toDir.mkdirs();
        } else if (toDir.isFile()) {
            throw new BuildException(toDir + "" is not a directory"");
        }

        if (srcEncoding == null) {
            srcEncoding = System.getProperty(""file.encoding"");
        }

        if (destEncoding == null) {
            destEncoding = srcEncoding;
        }

        if (bundleEncoding == null) {
            bundleEncoding = srcEncoding;
        }

        loadResourceMaps();

        translate();
    }

    
    private void loadResourceMaps() throws BuildException {
        Locale locale = new Locale(bundleLanguage,
                                   bundleCountry,
                                   bundleVariant);
        String language = locale.getLanguage().length() > 0
            ? ""_"" + locale.getLanguage() : """";
        String country = locale.getCountry().length() > 0
            ? ""_"" + locale.getCountry() : """";
        String variant = locale.getVariant().length() > 0
            ? ""_"" + locale.getVariant() : """";
        String bundleFile = bundle + language + country + variant;
        processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT, false);

        bundleFile = bundle + language + country;
        processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY, false);

        bundleFile = bundle + language;
        processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE, false);

        bundleFile = bundle;
        processBundle(bundleFile, BUNDLE_NOMATCH, false);

        
        
        locale = Locale.getDefault();

        language = locale.getLanguage().length() > 0
            ? ""_"" + locale.getLanguage() : """";
        country = locale.getCountry().length() > 0
            ? ""_"" + locale.getCountry() : """";
        variant = locale.getVariant().length() > 0
            ? ""_"" + locale.getVariant() : """";
        bundleEncoding = System.getProperty(""file.encoding"");

        bundleFile = bundle + language + country + variant;
        processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT, false);

        bundleFile = bundle + language + country;
        processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY, false);

        bundleFile = bundle + language;
        processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE, true);
    }

    
    private void processBundle(final String bundleFile, final int i,
                               final boolean checkLoaded) throws BuildException {
        final File propsFile = getProject().resolveFile(bundleFile + "".properties"");
        FileInputStream ins = null;
        try {
            ins = new FileInputStream(propsFile);
            loaded = true;
            bundleLastModified[i] = propsFile.lastModified();
            log(""Using "" + propsFile, Project.MSG_DEBUG);
            loadResourceMap(ins);
        } catch (IOException ioe) {
            log(propsFile + "" not found."", Project.MSG_DEBUG);
            
            
            
            if (!loaded && checkLoaded) {
                throw new BuildException(ioe.getMessage(), getLocation());
            }
        }
    }

    
    private void loadResourceMap(FileInputStream ins) throws BuildException {
        try {
            BufferedReader in = null;
            InputStreamReader isr = new InputStreamReader(ins, bundleEncoding);
            in = new BufferedReader(isr);
            String line = null;
            while ((line = in.readLine()) != null) {
                
                if (line.trim().length() > 1 && '#' != line.charAt(0) && '!' != line.charAt(0)) {
                    
                    int sepIndex = line.indexOf('=');
                    if (-1 == sepIndex) {
                        sepIndex = line.indexOf(':');
                    }
                    if (-1 == sepIndex) {
                        for (int k = 0; k < line.length(); k++) {
                            if (Character.isSpaceChar(line.charAt(k))) {
                                sepIndex = k;
                                break;
                            }
                        }
                    }
                    
                    if (-1 != sepIndex) {
                        String key = line.substring(0, sepIndex).trim();
                        String value = line.substring(sepIndex + 1).trim();
                        
                        while (value.endsWith(""\\"")) {
                            value = value.substring(0, value.length() - 1);
                            if ((line = in.readLine()) != null) {
                                value = value + line.trim();
                            } else {
                                break;
                            }
                        }
                        if (key.length() > 0) {
                            
                            if (resourceMap.get(key) == null) {
                                resourceMap.put(key, value);
                            }
                        }
                    }
                }
            }
            if (in != null) {
                in.close();
            }
        } catch (IOException ioe) {
            throw new BuildException(ioe.getMessage(), getLocation());
        }
    }

    
    private void translate() throws BuildException {
        int filesProcessed = 0;
        for (int i = 0; i < filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            String[] srcFiles = ds.getIncludedFiles();
            for (int j = 0; j < srcFiles.length; j++) {
                try {
                    File dest = FILE_UTILS.resolveFile(toDir, srcFiles[j]);
                    
                    try {
                        File destDir = new File(dest.getParent());
                        if (!destDir.exists()) {
                            destDir.mkdirs();
                        }
                    } catch (Exception e) {
                        log(""Exception occurred while trying to check/create ""
                            + "" parent directory.  "" + e.getMessage(),
                            Project.MSG_DEBUG);
                    }
                    destLastModified = dest.lastModified();
                    File src = FILE_UTILS.resolveFile(ds.getBasedir(), srcFiles[j]);
                    srcLastModified = src.lastModified();
                    
                    boolean needsWork = forceOverwrite
                        || destLastModified < srcLastModified;
                    if (!needsWork) {
                        for (int icounter = 0; icounter < BUNDLE_MAX_ALTERNATIVES; icounter++) {
                            needsWork = (destLastModified < bundleLastModified[icounter]);
                            if (needsWork) {
                                break;
                            }
                        }
                    }
                    if (needsWork) {
                        log(""Processing "" + srcFiles[j],
                            Project.MSG_DEBUG);
                        FileOutputStream fos = new FileOutputStream(dest);
                        BufferedWriter out
                            = new BufferedWriter(new OutputStreamWriter(fos, destEncoding));
                        FileInputStream fis = new FileInputStream(src);
                        BufferedReader in
                            = new BufferedReader(new InputStreamReader(fis, srcEncoding));
                        String line;
                        LineTokenizer lineTokenizer = new LineTokenizer();
                        lineTokenizer.setIncludeDelims(true);
                        line = lineTokenizer.getToken(in);
                        while ((line) != null) {
                            
                            

                            
                            
                            int startIndex = line.indexOf(startToken);
                            while (startIndex >= 0
                                && (startIndex + startToken.length()) <= line.length()) {
                                
                                
                                
                                String replace = null;

                                
                                
                                
                                int endIndex = line.indexOf(
                                    endToken, startIndex + startToken.length());
                                if (endIndex < 0) {
                                    startIndex += 1;
                                } else {
                                    
                                    String token = line.substring(
                                        startIndex + startToken.length(), endIndex);

                                    
                                    
                                    boolean validToken = true;
                                    for (int k = 0; k < token.length() && validToken; k++) {
                                        char c = token.charAt(k);
                                        if (c == ':' || c == '='
                                            || Character.isSpaceChar(c)) {
                                            validToken = false;
                                        }
                                    }
                                    if (!validToken) {
                                        startIndex += 1;
                                    } else {
                                        
                                        if (resourceMap.containsKey(token)) {
                                            replace = (String) resourceMap.get(token);
                                        } else {
                                            log(""Replacement string missing for: ""
                                                + token, Project.MSG_VERBOSE);
                                            replace = startToken + token + endToken;
                                        }


                                        
                                        line = line.substring(0, startIndex)
                                             + replace
                                             + line.substring(endIndex + endToken.length());

                                        
                                        startIndex += replace.length();
                                    }
                                }

                                
                                startIndex = line.indexOf(startToken, startIndex);
                            }
                            out.write(line);
                            line = lineTokenizer.getToken(in);
                        }
                        if (in != null) {
                            in.close();
                        }
                        if (out != null) {
                            out.close();
                        }
                        ++filesProcessed;
                    } else {
                        log(""Skipping "" + srcFiles[j]
                            + "" as destination file is up to date"",
                            Project.MSG_VERBOSE);
                    }
                } catch (IOException ioe) {
                    throw new BuildException(ioe.getMessage(), getLocation());
                }
            }
        }
        log(""Translation performed on "" + filesProcessed + "" file(s)."", Project.MSG_DEBUG);
    }
}
"
org.apache.tools.ant.util.optional.WeakishReference12,1,3,0,1,2,0,0,1,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.tools.ant.util.optional;

import org.apache.tools.ant.util.WeakishReference;


public class WeakishReference12 extends WeakishReference.HardReference  {


    
    public WeakishReference12(Object reference) {
        super(reference);
    }
}
"
org.apache.tools.ant.types.selectors.FilenameSelector,8,5,0,10,23,0,6,4,8,0.761904762,197,0.5,0,0.844444444,0.35,1,4,22.875,6,2.25,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Parameter;


public class FilenameSelector extends BaseExtendSelector {

    private String pattern = null;
    private boolean casesensitive = true;

    private boolean negated = false;
    
    public static final String NAME_KEY = ""name"";
    
    public static final String CASE_KEY = ""casesensitive"";
    
    public static final String NEGATE_KEY = ""negate"";

    
    public FilenameSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{filenameselector name: "");
        buf.append(pattern);
        buf.append("" negate: "");
        if (negated) {
            buf.append(""true"");
        } else {
            buf.append(""false"");
        }
        buf.append("" casesensitive: "");
        if (casesensitive) {
            buf.append(""true"");
        } else {
            buf.append(""false"");
        }
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setName(String pattern) {
        pattern = pattern.replace('/', File.separatorChar).replace('\\',
                File.separatorChar);
        if (pattern.endsWith(File.separator)) {
            pattern += ""**"";
        }
        this.pattern = pattern;
    }

    
    public void setCasesensitive(boolean casesensitive) {
        this.casesensitive = casesensitive;
    }

    
    public void setNegate(boolean negated) {
        this.negated = negated;
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (NAME_KEY.equalsIgnoreCase(paramname)) {
                    setName(parameters[i].getValue());
                } else if (CASE_KEY.equalsIgnoreCase(paramname)) {
                    setCasesensitive(Project.toBoolean(
                            parameters[i].getValue()));
                } else if (NEGATE_KEY.equalsIgnoreCase(paramname)) {
                    setNegate(Project.toBoolean(parameters[i].getValue()));
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (pattern == null) {
            setError(""The name attribute is required"");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        validate();

        return (SelectorUtils.matchPath(pattern, filename,
                casesensitive) == !(negated));
    }

}

"
org.apache.tools.ant.taskdefs.optional.junit.FormatterElement,15,1,0,7,34,75,2,5,11,0.9,286,0.7,0,0.0,0.208333333,0,0,17.4,5,1.5333,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.BufferedOutputStream;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class FormatterElement {

    private String classname;
    private String extension;
    private OutputStream out = System.out;
    private File outFile;
    private boolean useFile = true;
    private String ifProperty;
    private String unlessProperty;

    
    public static final String XML_FORMATTER_CLASS_NAME =
        ""org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter"";
    
    public static final String BRIEF_FORMATTER_CLASS_NAME =
        ""org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter"";
    
    public static final String PLAIN_FORMATTER_CLASS_NAME =
        ""org.apache.tools.ant.taskdefs.optional.junit.PlainJUnitResultFormatter"";

    
    public void setType(TypeAttribute type) {
        if (""xml"".equals(type.getValue())) {
            setClassname(XML_FORMATTER_CLASS_NAME);
        } else {
            if (""brief"".equals(type.getValue())) {
                setClassname(BRIEF_FORMATTER_CLASS_NAME);
            } else { 
                setClassname(PLAIN_FORMATTER_CLASS_NAME);
            }
        }
    }

    
    public void setClassname(String classname) {
        this.classname = classname;
        if (XML_FORMATTER_CLASS_NAME.equals(classname)) {
           setExtension("".xml"");
        } else if (PLAIN_FORMATTER_CLASS_NAME.equals(classname)) {
           setExtension("".txt"");
        } else if (BRIEF_FORMATTER_CLASS_NAME.equals(classname)) {
           setExtension("".txt"");
        }
    }

    
    public String getClassname() {
        return classname;
    }

    
    public void setExtension(String ext) {
        this.extension = ext;
    }

    
    public String getExtension() {
        return extension;
    }

    
    void setOutfile(File out) {
        this.outFile = out;
    }

    
    public void setOutput(OutputStream out) {
        this.out = out;
    }

    
    public void setUseFile(boolean useFile) {
        this.useFile = useFile;
    }

    
    boolean getUseFile() {
        return useFile;
    }

    
    public void setIf(String ifProperty) {
        this.ifProperty = ifProperty;
    }

    
    public void setUnless(String unlessProperty) {
        this.unlessProperty = unlessProperty;
    }

    
    public boolean shouldUse(Task t) {
        if (ifProperty != null && t.getProject().getProperty(ifProperty) == null) {
            return false;
        } else if (unlessProperty != null
                    && t.getProject().getProperty(unlessProperty) != null) {
            return false;
        }

        return true;
    }

    
    JUnitTaskMirror.JUnitResultFormatterMirror createFormatter() throws BuildException {
        return createFormatter(null);
    }

    
    JUnitTaskMirror.JUnitResultFormatterMirror createFormatter(ClassLoader loader)
        throws BuildException {

        if (classname == null) {
            throw new BuildException(""you must specify type or classname"");
        }
        
        
        
        Class f = null;
        try {
            if (loader == null) {
                f = Class.forName(classname);
            } else {
                f = Class.forName(classname, true, loader);
            }
        } catch (ClassNotFoundException e) {
            throw new BuildException(
                ""Using loader "" + loader + "" on class "" + classname
                + "": "" + e, e);
        } catch (NoClassDefFoundError e) {
            throw new BuildException(
                ""Using loader "" + loader + "" on class "" + classname
                + "": "" + e, e);
        }

        Object o = null;
        try {
            o = f.newInstance();
        } catch (InstantiationException e) {
            throw new BuildException(e);
        } catch (IllegalAccessException e) {
            throw new BuildException(e);
        }

        if (!(o instanceof JUnitTaskMirror.JUnitResultFormatterMirror)) {
            throw new BuildException(classname
                + "" is not a JUnitResultFormatter"");
        }
        JUnitTaskMirror.JUnitResultFormatterMirror r =
            (JUnitTaskMirror.JUnitResultFormatterMirror) o;
        if (useFile && outFile != null) {
            try {
                out = new BufferedOutputStream(new FileOutputStream(outFile));
            } catch (java.io.IOException e) {
                throw new BuildException(""Unable to open file "" + outFile, e);
            }
        }
        r.setOutput(out);
        return r;
    }

    
    public static class TypeAttribute extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""plain"", ""xml"", ""brief""};
        }
    }
}
"
org.apache.tools.ant.util.regexp.RegexpMatcherFactory,6,1,1,8,22,15,3,5,3,0.8,163,0.0,0,0.0,0.305555556,0,0,25.83333333,4,1.3333,0,"

package org.apache.tools.ant.util.regexp;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.JavaEnvUtils;


public class RegexpMatcherFactory {

    
    public RegexpMatcherFactory() {
    }

    
    public RegexpMatcher newRegexpMatcher() throws BuildException {
        return newRegexpMatcher(null);
    }

    
    public RegexpMatcher newRegexpMatcher(Project p)
        throws BuildException {
        String systemDefault = null;
        if (p == null) {
            systemDefault = System.getProperty(MagicNames.REGEXP_IMPL);
        } else {
            systemDefault = p.getProperty(MagicNames.REGEXP_IMPL);
        }

        if (systemDefault != null) {
            return createInstance(systemDefault);
            
            
        }

        Throwable cause = null;

        try {
            testAvailability(""java.util.regex.Matcher"");
            return createInstance(""org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher"");
        } catch (BuildException be) {
            cause = orCause(cause, be, JavaEnvUtils.getJavaVersionNumber() < 14);
        }

        try {
            testAvailability(""org.apache.oro.text.regex.Pattern"");
            return createInstance(""org.apache.tools.ant.util.regexp.JakartaOroMatcher"");
        } catch (BuildException be) {
            cause = orCause(cause, be, true);
        }

        try {
            testAvailability(""org.apache.regexp.RE"");
            return createInstance(""org.apache.tools.ant.util.regexp.JakartaRegexpMatcher"");
        } catch (BuildException be) {
            cause = orCause(cause, be, true);
        }

        throw new BuildException(
            ""No supported regular expression matcher found""
            + (cause != null ? "": "" + cause : """"), cause);
   }

    static Throwable orCause(Throwable deflt, BuildException be, boolean ignoreCnfe) {
        if (deflt != null) {
            return deflt;
        }
        Throwable t = be.getException();
        return ignoreCnfe && t instanceof ClassNotFoundException ? null : t;
    }

    
    protected RegexpMatcher createInstance(String className)
        throws BuildException {
        return (RegexpMatcher) ClasspathUtils.newInstance(className,
                RegexpMatcherFactory.class.getClassLoader(), RegexpMatcher.class);
    }

    
    protected void testAvailability(String className) throws BuildException {
        try {
            Class.forName(className);
        } catch (Throwable t) {
            throw new BuildException(t);
        }
    }
}
"
org.apache.tools.ant.taskdefs.Mkdir,4,3,0,3,18,4,0,3,3,1.0,111,1.0,0,0.925,0.75,2,2,26.25,2,1.0,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;



public class Mkdir extends Task {

    private static final int MKDIR_RETRY_SLEEP_MILLIS = 10;
    
    private File dir;

    
    public void execute() throws BuildException {
        if (dir == null) {
            throw new BuildException(""dir attribute is required"", getLocation());
        }

        if (dir.isFile()) {
            throw new BuildException(""Unable to create directory as a file ""
                                     + ""already exists with that name: ""
                                     + dir.getAbsolutePath());
        }

        if (!dir.exists()) {
            boolean result = mkdirs(dir);
            if (!result) {
                String msg = ""Directory "" + dir.getAbsolutePath()
                    + "" creation was not successful for an unknown reason"";
                throw new BuildException(msg, getLocation());
            }
            log(""Created dir: "" + dir.getAbsolutePath());
        } else {
            log(""Skipping "" + dir.getAbsolutePath()
                + "" because it already exists."", Project.MSG_VERBOSE);
        }
    }

    
    public void setDir(File dir) {
        this.dir = dir;
    }
    
    private boolean mkdirs(File f) {
        if (!f.mkdirs()) {
            try {
                Thread.sleep(MKDIR_RETRY_SLEEP_MILLIS);
                return f.mkdirs();
            } catch (InterruptedException ex) {
                return f.mkdirs();
            }
        }
        return true;
    }
}

"
org.apache.tools.ant.BuildListener,7,1,0,16,7,21,15,1,7,2.0,7,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"

package org.apache.tools.ant;

import java.util.EventListener;


public interface BuildListener extends EventListener {

    
    void buildStarted(BuildEvent event);

    
    void buildFinished(BuildEvent event);

    
    void targetStarted(BuildEvent event);

    
    void targetFinished(BuildEvent event);

    
    void taskStarted(BuildEvent event);

    
    void taskFinished(BuildEvent event);

    
    void messageLogged(BuildEvent event);
}
"
org.apache.tools.ant.taskdefs.optional.jlink.ClassNameReader,2,1,0,2,8,1,1,1,2,2.0,48,0.0,0,0.0,0.5,0,0,23.0,1,0.5,0,"
package org.apache.tools.ant.taskdefs.optional.jlink;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;


class ConstantPool {
    
    static final
        byte UTF8 = 1, UNUSED = 2, INTEGER = 3, FLOAT = 4, LONG = 5, DOUBLE = 6,
        CLASS = 7, STRING = 8, FIELDREF = 9, METHODREF = 10,
        INTERFACEMETHODREF = 11, NAMEANDTYPE = 12;

    byte[] types;

    Object[] values;
    

    
    ConstantPool(DataInput data) throws IOException {
        super();

        int count = data.readUnsignedShort();
        types = new byte [ count ];
        values = new Object [ count ];
        
        for (int i = 1; i < count; i++) {
            byte type = data.readByte();
            types[i] = type;
            switch (type) {
            case UTF8 :
                values[i] = data.readUTF();
                break;

            case UNUSED :
                break;

            case INTEGER :
                values[i] = new Integer(data.readInt());
                break;

            case FLOAT :
                values[i] = new Float(data.readFloat());
                break;

            case LONG :
                values[i] = new Long(data.readLong());
                ++i;
                break;

            case DOUBLE :
                values[i] = new Double(data.readDouble());
                ++i;
                break;

            case CLASS :
            case STRING :
                values[i] = new Integer(data.readUnsignedShort());
                break;

            case FIELDREF :
            case METHODREF :
            case INTERFACEMETHODREF :
            case NAMEANDTYPE :
                values[i] = new Integer(data.readInt());
                break;
            default:
                
            }
        }
    }
}


public class ClassNameReader extends Object {

    
    public static String getClassName(InputStream input) throws IOException {
        DataInputStream data = new DataInputStream(input);
        
        int cookie = data.readInt();
        if (cookie != 0xCAFEBABE) {
            return null;
        }
         data.readInt();
        
        ConstantPool constants = new ConstantPool(data);
        Object[] values = constants.values;
        
         data.readUnsignedShort();
        int classIndex = data.readUnsignedShort();
        Integer stringIndex = (Integer) values[classIndex];
        String className = (String) values[stringIndex.intValue()];
        return className;
    }


}


"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSConstants,0,1,0,1,0,0,1,0,0,2.0,48,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.tools.ant.taskdefs.optional.vss;


public interface MSVSSConstants {
    
    String SS_EXE = ""ss"";
    
    String PROJECT_PREFIX = ""$"";

    
    String COMMAND_CP = ""CP"";
    
    String COMMAND_ADD = ""Add"";
    
    String COMMAND_GET = ""Get"";
    
    String COMMAND_CHECKOUT = ""Checkout"";
    
    String COMMAND_CHECKIN = ""Checkin"";
    
    String COMMAND_LABEL = ""Label"";
    
    String COMMAND_HISTORY = ""History"";
    
    String COMMAND_CREATE = ""Create"";

    
    String STYLE_BRIEF = ""brief"";
    
    String STYLE_CODEDIFF = ""codediff"";
    
    String STYLE_NOFILE = ""nofile"";
    
    String STYLE_DEFAULT = ""default"";

    
    String TIME_CURRENT = ""current"";
    
    String TIME_MODIFIED = ""modified"";
    
    String TIME_UPDATED = ""updated"";

    
    String WRITABLE_REPLACE = ""replace"";
    
    String WRITABLE_SKIP = ""skip"";
    
    String WRITABLE_FAIL = ""fail"";

    
    String FLAG_LOGIN = ""-Y"";
    
    String FLAG_OVERRIDE_WORKING_DIR = ""-GL"";
    
    String FLAG_AUTORESPONSE_DEF = ""-I-"";
    
    String FLAG_AUTORESPONSE_YES = ""-I-Y"";
    
    String FLAG_AUTORESPONSE_NO = ""-I-N"";
    
    String FLAG_RECURSION = ""-R"";
    
    String FLAG_VERSION = ""-V"";
    
    String FLAG_VERSION_DATE = ""-Vd"";
    
    String FLAG_VERSION_LABEL = ""-VL"";
    
    String FLAG_WRITABLE = ""-W"";
    
    String VALUE_NO = ""-N"";
    
    String VALUE_YES = ""-Y"";
    
    String FLAG_QUIET = ""-O-"";
    
    String FLAG_COMMENT = ""-C"";
    
    String FLAG_LABEL = ""-L"";
    
    String VALUE_FROMDATE = ""~d"";
    
    String VALUE_FROMLABEL = ""~L"";
    
    String FLAG_OUTPUT = ""-O"";
    
    String FLAG_USER = ""-U"";
    
    String FLAG_NO_FILE = ""-F-"";
    
    String FLAG_BRIEF = ""-B"";
    
    String FLAG_CODEDIFF = ""-D"";
    
    String FLAG_FILETIME_DEF = ""-GTC"";
    
    String FLAG_FILETIME_MODIFIED = ""-GTM"";
    
    String FLAG_FILETIME_UPDATED = ""-GTU"";
    
    String FLAG_REPLACE_WRITABLE = ""-GWR"";
    
    String FLAG_SKIP_WRITABLE = ""-GWS"";
    
    String FLAG_NO_GET = ""-G-"";
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCMklbtype,24,4,0,7,43,222,0,7,20,0.943734015,309,0.529411765,0,0.676056338,0.375,2,2,11.16666667,8,1.375,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCMklbtype extends ClearCase {
    private String mTypeName = null;
    private String mVOB = null;
    private String mComment = null;
    private String mCfile = null;
    private boolean mReplace = false;
    private boolean mGlobal = false;
    private boolean mOrdinary = true;
    private boolean mPbranch = false;
    private boolean mShared = false;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        int result = 0;

        
        if (getTypeName() == null) {
            throw new BuildException(""Required attribute TypeName not specified"");
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_MKLBTYPE);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getTypeSpecifier(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getReplace()) {
            
            cmd.createArgument().setValue(FLAG_REPLACE);
        }

        if (getOrdinary()) {
            
            cmd.createArgument().setValue(FLAG_ORDINARY);
        } else {
            if (getGlobal()) {
                
                cmd.createArgument().setValue(FLAG_GLOBAL);
            }
        }

        if (getPbranch()) {
            
            cmd.createArgument().setValue(FLAG_PBRANCH);
        }

        if (getShared()) {
            
            cmd.createArgument().setValue(FLAG_SHARED);
        }

        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        
        cmd.createArgument().setValue(getTypeSpecifier());
    }


    
    public void setTypeName(String tn) {
        mTypeName = tn;
    }

    
    public String getTypeName() {
        return mTypeName;
    }

    
    public void setVOB(String vob) {
        mVOB = vob;
    }

    
    public String getVOB() {
        return mVOB;
    }

    
    public void setReplace(boolean repl) {
        mReplace = repl;
    }

    
    public boolean getReplace() {
        return mReplace;
    }

    
    public void setGlobal(boolean glob) {
        mGlobal = glob;
    }

    
    public boolean getGlobal() {
        return mGlobal;
    }

    
    public void setOrdinary(boolean ordinary) {
        mOrdinary = ordinary;
    }

    
    public boolean getOrdinary() {
        return mOrdinary;
    }

    
    public void setPbranch(boolean pbranch) {
        mPbranch = pbranch;
    }

    
    public boolean getPbranch() {
        return mPbranch;
    }

    
    public void setShared(boolean shared) {
        mShared = shared;
    }

    
    public boolean getShared() {
        return mShared;
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }


    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }

    
    private String getTypeSpecifier() {
        String typenm = null;

        typenm = getTypeName();
        if (getVOB() != null) {
            typenm += ""@"" + getVOB();
        }

        return typenm;
    }


    
    public static final String FLAG_REPLACE = ""-replace"";
    
    public static final String FLAG_GLOBAL = ""-global"";
    
    public static final String FLAG_ORDINARY = ""-ordinary"";
    
    public static final String FLAG_PBRANCH = ""-pbranch"";
    
    public static final String FLAG_SHARED = ""-shared"";
    
    public static final String FLAG_COMMENT = ""-c"";
    
    public static final String FLAG_COMMENTFILE = ""-cfile"";
    
    public static final String FLAG_NOCOMMENT = ""-nc"";

}

"
org.apache.tools.ant.taskdefs.optional.pvcs.PvcsProject,3,1,0,1,4,1,1,0,3,0.5,14,1.0,0,0.0,0.666666667,0,0,3.333333333,1,0.6667,0,"

package org.apache.tools.ant.taskdefs.optional.pvcs;




public class PvcsProject {
    private String name;

    
    public PvcsProject() {
        super();
    }

    
    public void setName(String name) {
        PvcsProject.this.name = name;
    }

    
    public String getName() {
        return name;
    }
}
"
org.apache.tools.ant.filters.StripJavaComments,4,4,0,3,7,0,1,2,4,0.0,161,1.0,0,0.928571429,0.75,2,4,38.5,1,0.5,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;


public final class StripJavaComments
    extends BaseFilterReader
    implements ChainableReader {

    
    private int readAheadCh = -1;

    
    private boolean inString = false;

    
    private boolean quoted = false;

    
    public StripJavaComments() {
        super();
    }

    
    public StripJavaComments(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        int ch = -1;
        if (readAheadCh != -1) {
            ch = readAheadCh;
            readAheadCh = -1;
        } else {
            ch = in.read();
            if (ch == '""' && !quoted) {
                inString = !inString;
                quoted = false;
            } else if (ch == '\\') {
                quoted = !quoted;
            } else {
                quoted = false;
                if (!inString) {
                    if (ch == '/') {
                        ch = in.read();
                        if (ch == '/') {
                            while (ch != '\n' && ch != -1 && ch != '\r') {
                                ch = in.read();
                            }
                        } else if (ch == '*') {
                            while (ch != -1) {
                                ch = in.read();
                                if (ch == '*') {
                                    ch = in.read();
                                    while (ch == '*' && ch != -1) {
                                        ch = in.read();
                                    }

                                    if (ch == '/') {
                                        ch = read();
                                        break;
                                    }
                                }
                            }
                        } else {
                            readAheadCh = ch;
                            ch = '/';
                        }
                    }
                }
            }
        }

        return ch;
    }

    

    public Reader chain(final Reader rdr) {
        StripJavaComments newFilter = new StripJavaComments(rdr);
        return newFilter;
    }
}
"
org.apache.tools.ant.taskdefs.Taskdef,1,7,0,1,7,0,0,1,1,2.0,40,0.0,0,1.0,1.0,0,0,37.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskAdapter;


public class Taskdef extends Typedef {

    

    public Taskdef() {
        setAdapterClass(TaskAdapter.class);
        setAdaptToClass(Task.class);
    }
}
"
org.apache.tools.ant.util.LineTokenizer,4,2,0,8,10,0,6,2,4,0.333333333,125,1.0,0,0.75,0.5,0,0,29.5,2,1.0,0,"
package org.apache.tools.ant.util;

import java.io.Reader;
import java.io.IOException;

import org.apache.tools.ant.ProjectComponent;


public class LineTokenizer extends ProjectComponent
    implements Tokenizer {
    private String  lineEnd = """";
    private int     pushed = -2;
    private boolean includeDelims = false;

    

    public void setIncludeDelims(boolean includeDelims) {
        this.includeDelims = includeDelims;
    }

    
    public String getToken(Reader in) throws IOException {
        int ch = -1;
        if (pushed != -2) {
            ch = pushed;
            pushed = -2;
        } else {
            ch = in.read();
        }
        if (ch == -1) {
            return null;
        }

        lineEnd = """";
        StringBuffer line = new StringBuffer();

        int state = 0;
        while (ch != -1) {
            if (state == 0) {
                if (ch == '\r') {
                    state = 1;
                } else if (ch == '\n') {
                    lineEnd = ""\n"";
                    break;
                } else {
                    line.append((char) ch);
                }
            } else {
                state = 0;
                if (ch == '\n') {
                    lineEnd = ""\r\n"";
                } else {
                    pushed = ch;
                    lineEnd = ""\r"";
                }
                break;
            }
            ch = in.read();
        }
        if (ch == -1 && state == 1) {
            lineEnd = ""\r"";
        }

        if (includeDelims) {
            line.append(lineEnd);
        }
        return line.toString();
    }

    
    public String getPostToken() {
        if (includeDelims) {
            return """";
        }
        return lineEnd;
    }

}

"
org.apache.tools.ant.filters.ReplaceTokens,14,5,0,7,49,7,1,6,7,0.735042735,488,1.0,0,0.7,0.25,2,5,33.21428571,12,1.7857,1,"
package org.apache.tools.ant.filters;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.Reader;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.util.FileUtils;


public final class ReplaceTokens
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final char DEFAULT_BEGIN_TOKEN = '@';

    
    private static final char DEFAULT_END_TOKEN = '@';

    
    private String queuedData = null;

    
    private String replaceData = null;

    
    private int replaceIndex = -1;

    
    private int queueIndex = -1;

    
    private Hashtable hash = new Hashtable();

    
    private char beginToken = DEFAULT_BEGIN_TOKEN;

    
    private char endToken = DEFAULT_END_TOKEN;

    
    public ReplaceTokens() {
        super();
    }

    
    public ReplaceTokens(final Reader in) {
        super(in);
    }

    private int getNextChar() throws IOException {
        if (queueIndex != -1) {
            final int ch = queuedData.charAt(queueIndex++);
            if (queueIndex >= queuedData.length()) {
                queueIndex = -1;
            }
            return ch;
        }

        return in.read();
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        if (replaceIndex != -1) {
            final int ch = replaceData.charAt(replaceIndex++);
            if (replaceIndex >= replaceData.length()) {
                replaceIndex = -1;
            }
            return ch;
        }

        int ch = getNextChar();

        if (ch == beginToken) {
            final StringBuffer key = new StringBuffer("""");
            do  {
                ch = getNextChar();
                if (ch != -1) {
                    key.append((char) ch);
                } else {
                    break;
                }
            } while (ch != endToken);

            if (ch == -1) {
                if (queuedData == null || queueIndex == -1) {
                    queuedData = key.toString();
                } else {
                    queuedData
                        = key.toString() + queuedData.substring(queueIndex);
                }
                queueIndex = 0;
                return beginToken;
            } else {
                key.setLength(key.length() - 1);

                final String replaceWith = (String) hash.get(key.toString());
                if (replaceWith != null) {
                    if (replaceWith.length() > 0) {
                        replaceData = replaceWith;
                        replaceIndex = 0;
                    }
                    return read();
                } else {
                    String newData = key.toString() + endToken;
                    if (queuedData == null || queueIndex == -1) {
                        queuedData = newData;
                    } else {
                        queuedData = newData + queuedData.substring(queueIndex);
                    }
                    queueIndex = 0;
                    return beginToken;
                }
            }
        }
        return ch;
    }

    
    public void setBeginToken(final char beginToken) {
        this.beginToken = beginToken;
    }

    
    private char getBeginToken() {
        return beginToken;
    }

    
    public void setEndToken(final char endToken) {
        this.endToken = endToken;
    }

    
    private char getEndToken() {
        return endToken;
    }

    
    public void addConfiguredToken(final Token token) {
        hash.put(token.getKey(), token.getValue());
    }

    
    private Properties getPropertiesFromFile (String fileName) {
        FileInputStream in = null;
        Properties props = new Properties();
        try {
            in = new FileInputStream(fileName);
            props.load(in);
        } catch (IOException ioe) {
            ioe.printStackTrace();
        } finally {
            FileUtils.close(in);
        }

        return props;
    }

    
    private void setTokens(final Hashtable hash) {
        this.hash = hash;
    }

    
    private Hashtable getTokens() {
        return hash;
    }

    
    public Reader chain(final Reader rdr) {
        ReplaceTokens newFilter = new ReplaceTokens(rdr);
        newFilter.setBeginToken(getBeginToken());
        newFilter.setEndToken(getEndToken());
        newFilter.setTokens(getTokens());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (params[i] != null) {
                    final String type = params[i].getType();
                    if (""tokenchar"".equals(type)) {
                        final String name = params[i].getName();
                        String value = params[i].getValue();
                        if (""begintoken"".equals(name)) {
                            if (value.length() == 0) {
                                throw new BuildException(""Begin token cannot ""
                                    + ""be empty"");
                            }
                            beginToken = params[i].getValue().charAt(0);
                        } else if (""endtoken"".equals(name)) {
                            if (value.length() == 0) {
                                throw new BuildException(""End token cannot ""
                                    + ""be empty"");
                            }
                            endToken = params[i].getValue().charAt(0);
                        }
                    } else if (""token"".equals(type)) {
                        final String name = params[i].getName();
                        final String value = params[i].getValue();
                        hash.put(name, value);
                    } else if (""propertiesfile"".equals(type)) {
                        Properties props = getPropertiesFromFile(params[i].getValue());
                        for (Enumeration e = props.keys(); e.hasMoreElements();) {
                            String key = (String) e.nextElement();
                            String value = props.getProperty(key);
                            hash.put(key, value);
                        }
                    }
                }
            }
        }
    }

    
    public static class Token {

        
        private String key;

        
        private String value;

        
        public final void setKey(String key) {
            this.key = key;
        }

        
        public final void setValue(String value) {
            this.value = value;
        }

        
        public final String getKey() {
            return key;
        }

        
        public final String getValue() {
            return value;
        }
    }
}
"
org.apache.tools.ant.PathTokenizer,3,1,0,3,18,0,2,1,3,0.25,204,1.0,0,0.0,0.666666667,0,0,65.66666667,2,1.0,0,"
package org.apache.tools.ant;

import java.io.File;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import org.apache.tools.ant.taskdefs.condition.Os;


public class PathTokenizer {
    
    private StringTokenizer tokenizer;

    
    private String lookahead = null;

    
    private boolean onNetWare = Os.isFamily(""netware"");

    
    private boolean dosStyleFilesystem;

    
    public PathTokenizer(String path) {
        if (onNetWare) {
            
            
            tokenizer = new StringTokenizer(path, "":;"", true);
        } else {
            
            
            tokenizer = new StringTokenizer(path, "":;"", false);
        }
        dosStyleFilesystem = File.pathSeparatorChar == ';';
    }

    
    public boolean hasMoreTokens() {
        if (lookahead != null) {
            return true;
        }

        return tokenizer.hasMoreTokens();
    }

    
    public String nextToken() throws NoSuchElementException {
        String token = null;
        if (lookahead != null) {
            token = lookahead;
            lookahead = null;
        } else {
            token = tokenizer.nextToken().trim();
        }

        if (!onNetWare) {
            if (token.length() == 1 && Character.isLetter(token.charAt(0))
                                    && dosStyleFilesystem
                                    && tokenizer.hasMoreTokens()) {
                
                
                String nextToken = tokenizer.nextToken().trim();
                if (nextToken.startsWith(""\\"") || nextToken.startsWith(""/"")) {
                    
                    
                    
                    token += "":"" + nextToken;
                } else {
                    
                    lookahead = nextToken;
                }
            }
        } else {
            
            
            if (token.equals(File.pathSeparator) || token.equals("":"")) {
                
                token = tokenizer.nextToken().trim();
            }

            if (tokenizer.hasMoreTokens()) {
                
                String nextToken = tokenizer.nextToken().trim();

                
                if (!nextToken.equals(File.pathSeparator)) {
                    if (nextToken.equals("":"")) {
                        if (!token.startsWith(""/"") && !token.startsWith(""\\"")
                            && !token.startsWith(""."")
                            && !token.startsWith("".."")) {
                            
                            String oneMore = tokenizer.nextToken().trim();
                            if (!oneMore.equals(File.pathSeparator)) {
                                token += "":"" + oneMore;
                            } else {
                                token += "":"";
                                lookahead = oneMore;
                            }
                        }
                        
                        
                    } else {
                        
                        lookahead = nextToken;
                    }
                }
            }
        }
        return token;
    }
}

"
org.apache.tools.ant.filters.BaseParamFilterReader,4,4,12,15,7,4,12,3,3,0.666666667,22,1.0,1,0.928571429,0.5,0,0,4.25,1,0.5,0,"
package org.apache.tools.ant.filters;

import java.io.Reader;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.Parameterizable;


public abstract class BaseParamFilterReader
    extends BaseFilterReader
    implements Parameterizable {
    
    private Parameter[] parameters;

    
    public BaseParamFilterReader() {
        super();
    }

    
    public BaseParamFilterReader(final Reader in) {
        super(in);
    }

    
    public final void setParameters(final Parameter[] parameters) {
        this.parameters = parameters;
        setInitialized(false);
    }

    
    protected final Parameter[] getParameters() {
        return parameters;
    }
}
"
org.apache.tools.ant.types.selectors.MappingSelector,8,4,2,9,24,8,2,7,6,0.742857143,143,1.0,3,0.853658537,0.428571429,1,3,16.25,4,1.5,0,"

package org.apache.tools.ant.types.selectors;

import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;

import java.io.File;


public abstract class MappingSelector extends BaseSelector {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    

    protected File targetdir = null;
    protected Mapper mapperElement = null;
    protected FileNameMapper map = null;
    protected int granularity = 0;

    

    
    public MappingSelector() {
        granularity = (int) FILE_UTILS.getFileTimestampGranularity();
    }


    
    public void setTargetdir(File targetdir) {
        this.targetdir = targetdir;
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"");
        }
        mapperElement = new Mapper(getProject());
        return mapperElement;
    }

    
    public void verifySettings() {
        if (targetdir == null) {
            setError(""The targetdir attribute is required."");
        }
        if (mapperElement == null) {
            map = new IdentityMapper();
        } else {
            map = mapperElement.getImplementation();
        }
        if (map == null) {
            setError(""Could not set <mapper> element."");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {

        
        validate();

        
        String[] destfiles = map.mapFileName(filename);
        
        
        if (destfiles == null) {
            return false;
        }
        
        if (destfiles.length != 1 || destfiles[0] == null) {
            throw new BuildException(""Invalid destination file results for ""
                    + targetdir.getName() + "" with filename "" + filename);
        }
        String destname = destfiles[0];
        File destfile = new File(targetdir, destname);

        boolean selected = selectionTest(file, destfile);
        return selected;
    }

    
    protected abstract boolean selectionTest(File srcfile, File destfile);

    
    public void setGranularity(int granularity) {
        this.granularity = granularity;
    }

}
"
org.apache.tools.ant.util.ConcatFileInputStream,9,2,0,4,19,10,1,3,6,0.729166667,159,1.0,1,0.529411765,0.277777778,1,1,16.0,3,1.1111,0,"

package org.apache.tools.ant.util;

import java.io.File;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.FileInputStream;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;


public class ConcatFileInputStream extends InputStream {

    private static final int EOF = -1;
    private int currentIndex = -1;
    private boolean eof = false;
    private File[] file;
    private InputStream currentStream;
    private ProjectComponent managingPc;

  
    public ConcatFileInputStream(File[] file) throws IOException {
        this.file = file;
    }

    
    public void close() throws IOException {
        closeCurrent();
        eof = true;
    }

    
    public int read() throws IOException {
        int result = readCurrent();
        if (result == EOF && !eof) {
            openFile(++currentIndex);
            result = readCurrent();
        }
        return result;
    }

    
    public void setManagingTask(Task task) {
        setManagingComponent(task);
    }

    
    public void setManagingComponent(ProjectComponent pc) {
        this.managingPc = pc;
    }

    
    public void log(String message, int loglevel) {
        if (managingPc != null) {
            managingPc.log(message, loglevel);
        } else {
            if (loglevel > Project.MSG_WARN) {
                System.out.println(message);
            } else {
                System.err.println(message);
            }
        }
    }

    private int readCurrent() throws IOException {
        return (eof || currentStream == null) ? EOF : currentStream.read();
    }

    private void openFile(int index) throws IOException {
        closeCurrent();
        if (file != null && index < file.length) {
            log(""Opening "" + file[index], Project.MSG_VERBOSE);
            try {
                currentStream = new BufferedInputStream(
                    new FileInputStream(file[index]));
            } catch (IOException eyeOhEx) {
                log(""Failed to open "" + file[index], Project.MSG_ERR);
                throw eyeOhEx;
            }
        } else {
            eof = true;
        }
    }

    private void closeCurrent() {
        FileUtils.close(currentStream);
        currentStream = null;
    }
}
"
org.apache.tools.ant.types.resources.selectors.And,3,4,0,4,9,3,1,3,3,2.0,27,0.0,0,0.972222222,0.555555556,0,0,8.0,3,1.0,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.util.Iterator;

import org.apache.tools.ant.types.Resource;


public class And extends ResourceSelectorContainer implements ResourceSelector {

    
    public And() {
    }

    
    public And(ResourceSelector[] r) {
        super(r);
    }

    
    public boolean isSelected(Resource r) {
        for (Iterator i = getSelectors(); i.hasNext();) {
            if (!((ResourceSelector) i.next()).isSelected(r)) {
                return false;
            }
        }
        return true;
    }

}
"
org.apache.tools.ant.taskdefs.optional.javacc.JJTree,22,3,0,13,80,59,0,13,17,0.977443609,678,1.0,1,0.637931034,0.477272727,1,1,28.95454545,8,1.8182,0,"

package org.apache.tools.ant.taskdefs.optional.javacc;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.JavaEnvUtils;


public class JJTree extends Task {

    
    private static final String OUTPUT_FILE       = ""OUTPUT_FILE"";
    private static final String BUILD_NODE_FILES  = ""BUILD_NODE_FILES"";
    private static final String MULTI             = ""MULTI"";
    private static final String NODE_DEFAULT_VOID = ""NODE_DEFAULT_VOID"";
    private static final String NODE_FACTORY      = ""NODE_FACTORY"";
    private static final String NODE_SCOPE_HOOK   = ""NODE_SCOPE_HOOK"";
    private static final String NODE_USES_PARSER  = ""NODE_USES_PARSER"";
    private static final String STATIC            = ""STATIC"";
    private static final String VISITOR           = ""VISITOR"";

    private static final String NODE_PACKAGE      = ""NODE_PACKAGE"";
    private static final String VISITOR_EXCEPTION = ""VISITOR_EXCEPTION"";
    private static final String NODE_PREFIX       = ""NODE_PREFIX"";

    private final Hashtable optionalAttrs = new Hashtable();

    private String outputFile = null;

    private static final String DEFAULT_SUFFIX = "".jj"";

    
    private File outputDirectory = null;
    private File targetFile      = null;
    private File javaccHome      = null;

    private CommandlineJava cmdl = new CommandlineJava();


    
    public void setBuildnodefiles(boolean buildNodeFiles) {
        optionalAttrs.put(BUILD_NODE_FILES, buildNodeFiles ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setMulti(boolean multi) {
        optionalAttrs.put(MULTI, multi ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setNodedefaultvoid(boolean nodeDefaultVoid) {
        optionalAttrs.put(NODE_DEFAULT_VOID, nodeDefaultVoid ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setNodefactory(boolean nodeFactory) {
        optionalAttrs.put(NODE_FACTORY, nodeFactory ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setNodescopehook(boolean nodeScopeHook) {
        optionalAttrs.put(NODE_SCOPE_HOOK, nodeScopeHook ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setNodeusesparser(boolean nodeUsesParser) {
        optionalAttrs.put(NODE_USES_PARSER, nodeUsesParser ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setStatic(boolean staticParser) {
        optionalAttrs.put(STATIC, staticParser ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setVisitor(boolean visitor) {
        optionalAttrs.put(VISITOR, visitor ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setNodepackage(String nodePackage) {
        optionalAttrs.put(NODE_PACKAGE, nodePackage);
    }

    
    public void setVisitorException(String visitorException) {
        optionalAttrs.put(VISITOR_EXCEPTION, visitorException);
    }

    
    public void setNodeprefix(String nodePrefix) {
        optionalAttrs.put(NODE_PREFIX, nodePrefix);
    }

    
    public void setOutputdirectory(File outputDirectory) {
        this.outputDirectory = outputDirectory;
    }

    
    public void setOutputfile(String outputFile) {
        this.outputFile = outputFile;
    }

    
    public void setTarget(File targetFile) {
        this.targetFile = targetFile;
    }

    
    public void setJavacchome(File javaccHome) {
        this.javaccHome = javaccHome;
    }

    
    public JJTree() {
        cmdl.setVm(JavaEnvUtils.getJreExecutable(""java""));
    }

    
    public void execute() throws BuildException {

        
        Enumeration iter = optionalAttrs.keys();
        while (iter.hasMoreElements()) {
            String name  = (String) iter.nextElement();
            Object value = optionalAttrs.get(name);
            cmdl.createArgument().setValue(""-"" + name + "":"" + value.toString());
        }

        if (targetFile == null || !targetFile.isFile()) {
            throw new BuildException(""Invalid target: "" + targetFile);
        }

        File javaFile = null;

        
        if (outputDirectory == null) {
            
            
            cmdl.createArgument().setValue(""-OUTPUT_DIRECTORY:""
                                           + getDefaultOutputDirectory());

            javaFile = new File(createOutputFileName(targetFile, outputFile,
                                                     null));
        } else {
            if (!outputDirectory.isDirectory()) {
                throw new BuildException(""'outputdirectory' "" + outputDirectory
                                         + "" is not a directory."");
            }

            
            
            cmdl.createArgument().setValue(""-OUTPUT_DIRECTORY:""
                                           + outputDirectory.getAbsolutePath()
                                             .replace('\\', '/'));

            javaFile = new File(createOutputFileName(targetFile, outputFile,
                                                     outputDirectory
                                                     .getPath()));
        }

        if (javaFile.exists()
            && targetFile.lastModified() < javaFile.lastModified()) {
            log(""Target is already built - skipping ("" + targetFile + "")"",
                Project.MSG_VERBOSE);
            return;
        }

        if (outputFile != null) {
            cmdl.createArgument().setValue(""-"" + OUTPUT_FILE + "":""
                                           + outputFile.replace('\\', '/'));
        }

        cmdl.createArgument().setValue(targetFile.getAbsolutePath());

        final Path classpath = cmdl.createClasspath(getProject());
        final File javaccJar = JavaCC.getArchiveFile(javaccHome);
        classpath.createPathElement().setPath(javaccJar.getAbsolutePath());
        classpath.addJavaRuntime();

        cmdl.setClassname(JavaCC.getMainClass(classpath,
                                              JavaCC.TASKDEF_TYPE_JJTREE));

        final Commandline.Argument arg = cmdl.createVmArgument();
        arg.setValue(""-mx140M"");
        arg.setValue(""-Dinstall.root="" + javaccHome.getAbsolutePath());

        final Execute process =
            new Execute(new LogStreamHandler(this,
                                             Project.MSG_INFO,
                                             Project.MSG_INFO),
                        null);
        log(cmdl.describeCommand(), Project.MSG_VERBOSE);
        process.setCommandline(cmdl.getCommandline());

        try {
            if (process.execute() != 0) {
                throw new BuildException(""JJTree failed."");
            }
        } catch (IOException e) {
            throw new BuildException(""Failed to launch JJTree"", e);
        }
    }

    private String createOutputFileName(File destFile, String optionalOutputFile,
                                        String outputDir) {
        optionalOutputFile = validateOutputFile(optionalOutputFile,
                                                outputDir);
        String jjtreeFile = destFile.getAbsolutePath().replace('\\', '/');

        if ((optionalOutputFile == null) || optionalOutputFile.equals("""")) {
            int filePos = jjtreeFile.lastIndexOf(""/"");

            if (filePos >= 0) {
                jjtreeFile = jjtreeFile.substring(filePos + 1);
            }

            int suffixPos = jjtreeFile.lastIndexOf('.');

            if (suffixPos == -1) {
                optionalOutputFile = jjtreeFile + DEFAULT_SUFFIX;
            } else {
                String currentSuffix = jjtreeFile.substring(suffixPos);

                if (currentSuffix.equals(DEFAULT_SUFFIX)) {
                    optionalOutputFile = jjtreeFile + DEFAULT_SUFFIX;
                } else {
                    optionalOutputFile = jjtreeFile.substring(0, suffixPos)
                        + DEFAULT_SUFFIX;
                }
            }
        }

        if ((outputDir == null) || outputDir.equals("""")) {
            outputDir = getDefaultOutputDirectory();
        }

        return (outputDir + ""/"" + optionalOutputFile).replace('\\', '/');
    }

    
    private String validateOutputFile(String destFile,
                                      String outputDir)
        throws BuildException {
        if (destFile == null) {
            return null;
        }

        if ((outputDir == null)
            && (destFile.startsWith(""/"") || destFile.startsWith(""\\""))) {
            String relativeOutputFile = makeOutputFileRelative(destFile);
            setOutputfile(relativeOutputFile);

            return relativeOutputFile;
        }

        String root = getRoot(new File(destFile)).getAbsolutePath();

        if ((root.length() > 1)
            && destFile.startsWith(root.substring(0, root.length() - 1))) {
            throw new BuildException(""Drive letter in 'outputfile' not ""
                                     + ""supported: "" + destFile);
        }

        return destFile;
    }

    private String makeOutputFileRelative(String destFile) {
        StringBuffer relativePath = new StringBuffer();
        String defaultOutputDirectory = getDefaultOutputDirectory();
        int nextPos = defaultOutputDirectory.indexOf('/');
        int startPos = nextPos + 1;

        while (startPos > -1 && startPos < defaultOutputDirectory.length()) {
            relativePath.append(""/.."");
            nextPos = defaultOutputDirectory.indexOf('/', startPos);

            if (nextPos == -1) {
                startPos = nextPos;
            } else {
                startPos = nextPos + 1;
            }
        }

        relativePath.append(destFile);

        return relativePath.toString();
    }

    private String getDefaultOutputDirectory() {
        return getProject().getBaseDir().getAbsolutePath().replace('\\', '/');
    }

    
    private File getRoot(File file) {
        File root = file.getAbsoluteFile();

        while (root.getParent() != null) {
            root = root.getParentFile();
        }

        return root;
    }
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.DotnetBaseMatchingTask,11,4,2,8,38,45,2,6,6,0.775,202,1.0,0,0.896551724,0.285714286,0,0,17.0,6,1.7273,0,"

package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.DirectoryScanner;

import java.io.File;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;


public class DotnetBaseMatchingTask extends MatchingTask {
    
    
    protected File outputFile;
    
    protected Vector filesets = new Vector();

    
    protected File srcDir;

    
    
    protected static final boolean isWindows = Os.isFamily(""windows"");

    
    

    
    public File getSrcDir() {
        return this.srcDir;
    }

    
    public void setSrcDir(File srcDirName) {
        this.srcDir = srcDirName;
    }

    
    public void setDestFile(File file) {
        outputFile = file;
    }

    
    public void addSrc(FileSet src) {
        filesets.add(src);
    }

    
    public File getDestFile() {
        return outputFile;
    }

    
    protected int buildFileList(NetCommand command, Hashtable filesToBuild, long outputTimestamp) {
        int filesOutOfDate = 0;
        boolean scanImplicitFileset
            = getSrcDir() != null || filesets.size() == 0;
        if (scanImplicitFileset) {
            
            
            if (getSrcDir() == null) {
                
                setSrcDir(getProject().resolveFile("".""));
            }
            log(""working from source directory "" + getSrcDir(),
                    Project.MSG_VERBOSE);
            
            DirectoryScanner scanner = getDirectoryScanner(getSrcDir());
            filesOutOfDate = command.scanOneFileset(scanner,
                    filesToBuild, outputTimestamp);
        }
        
        for (int i = 0; i < filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            filesOutOfDate += command.scanOneFileset(
                    fs.getDirectoryScanner(getProject()),
                    filesToBuild,
                    outputTimestamp);
        }

        return filesOutOfDate;
    }

    
    protected void addFilesToCommand(Hashtable filesToBuild, NetCommand command) {
        int count = filesToBuild.size();
        log(""compiling "" + count + "" file"" + ((count == 1) ? """" : ""s""),
                Project.MSG_VERBOSE);
        Enumeration files = filesToBuild.elements();
        while (files.hasMoreElements()) {
            File file = (File) files.nextElement();
            command.addArgument(file.toString());
        }
    }

    
    protected long getOutputFileTimestamp() {
        long outputTimestamp;
        if (getDestFile() != null && getDestFile().exists()) {
            outputTimestamp = getDestFile().lastModified();
        } else {
            outputTimestamp = 0;
        }
        return outputTimestamp;
    }

    
    protected void addFilesAndExecute(NetCommand command, boolean ignoreTimestamps) {
        long outputTimestamp = getOutputFileTimestamp();
        Hashtable filesToBuild = new Hashtable();
        int filesOutOfDate = buildFileList(command, filesToBuild, outputTimestamp);

        
        if (filesOutOfDate > 0) {
            
            addFilesToCommand(filesToBuild, command);
            command.runCommand();
        } else {
            log(""output file is up to date"", Project.MSG_VERBOSE);
        }
    }



}
"
org.apache.tools.ant.filters.ExpandProperties,4,4,0,4,13,0,1,3,4,0.0,87,1.0,0,0.928571429,0.75,2,4,20.5,1,0.5,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.Project;


public final class ExpandProperties
    extends BaseFilterReader
    implements ChainableReader {
    
    private String queuedData = null;

    
    public ExpandProperties() {
        super();
    }

    
    public ExpandProperties(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {

        int ch = -1;

        if (queuedData != null && queuedData.length() == 0) {
            queuedData = null;
        }

        if (queuedData != null) {
            ch = queuedData.charAt(0);
            queuedData = queuedData.substring(1);
            if (queuedData.length() == 0) {
                queuedData = null;
            }
        } else {
            queuedData = readFully();
            if (queuedData == null) {
                ch = -1;
            } else {
                Project project = getProject();
                queuedData = project.replaceProperties(queuedData);
                return read();
            }
        }
        return ch;
    }

    
    public Reader chain(final Reader rdr) {
        ExpandProperties newFilter = new ExpandProperties(rdr);
        newFilter.setProject(getProject());
        return newFilter;
    }
}
"
org.apache.tools.ant.types.selectors.modifiedselector.PropertiesfileCache,12,1,0,2,42,0,1,1,12,0.386363636,234,1.0,0,0.0,0.444444444,0,0,18.16666667,4,1.5833,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.util.Iterator;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Properties;
import java.io.File;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;



public class PropertiesfileCache implements Cache {


    


    
    private File cachefile = null;

    
    private Properties cache = new Properties();


    


    
    private boolean cacheLoaded = false;

    
    private boolean cacheDirty  = true;


    


    
    public PropertiesfileCache() {
    }

    
    public PropertiesfileCache(File cachefile) {
        this.cachefile = cachefile;
    }


    


    
    public void setCachefile(File file) {
        cachefile = file;
    }


    
    public File getCachefile() {
        return cachefile;
    }

    
    public boolean isValid() {
        return (cachefile != null);
    }


    


    
    public void load() {
        if ((cachefile != null) && cachefile.isFile() && cachefile.canRead()) {
            try {
                BufferedInputStream bis = new BufferedInputStream(
                    new FileInputStream(cachefile));
                cache.load(bis);
                bis.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        cacheLoaded = true;
        cacheDirty  = false;
    }

    
    public void save() {
        if (!cacheDirty) {
            return;
        }
        if ((cachefile != null) && cache.propertyNames().hasMoreElements()) {
            try {
                BufferedOutputStream bos = new BufferedOutputStream(
                      new FileOutputStream(cachefile));
                cache.store(bos, null);
                bos.flush();
                bos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        cacheDirty = false;
    }

    
    public void delete() {
        cache = new Properties();
        cachefile.delete();
        cacheLoaded = true;
        cacheDirty = false;
    }

    
    public Object get(Object key) {
        if (!cacheLoaded) {
            load();
        }
        try {
            return cache.getProperty(String.valueOf(key));
        } catch (ClassCastException e) {
            return null;
        }
    }

    
    public void put(Object key, Object value) {
        cache.put(String.valueOf(key), String.valueOf(value));
        cacheDirty = true;
    }

    
    public Iterator iterator() {
        Vector v = new java.util.Vector();
        Enumeration en = cache.propertyNames();
        while (en.hasMoreElements()) {
            v.add(en.nextElement());
        }
        return v.iterator();
    }


    


    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(""<PropertiesfileCache:"");
        buf.append(""cachefile="").append(cachefile);
        buf.append("";noOfEntries="").append(cache.size());
        buf.append("">"");
        return buf.toString();
    }
}
"
org.apache.tools.ant.taskdefs.cvslib.RCSFile,5,1,0,2,7,4,2,0,0,0.5,39,1.0,0,0.0,0.7,0,0,6.2,1,0.6,0,"
package org.apache.tools.ant.taskdefs.cvslib;


class RCSFile {
    private String name;
    private String revision;
    private String previousRevision;


    RCSFile(final String name, final String rev) {
        this(name, rev, null);
    }


    RCSFile(final String name,
                  final String revision,
                  final String previousRevision) {
        this.name = name;
        this.revision = revision;
        if (!revision.equals(previousRevision)) {
            this.previousRevision = previousRevision;
        }
    }

    
    String getName() {
        return name;
    }

    
    String getRevision() {
        return revision;
    }

    
    String getPreviousRevision() {
        return previousRevision;
    }
}

"
org.apache.tools.ant.types.resources.ZipResource,12,5,0,10,52,60,2,9,10,0.545454545,213,1.0,0,0.873417722,0.277777778,3,6,16.66666667,4,1.4167,0,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.FilterInputStream;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.zip.ZipFile;
import org.apache.tools.zip.ZipEntry;


public class ZipResource extends ArchiveResource {

    private String encoding;

    
    public ZipResource() {
    }

    
    public ZipResource(File z, String enc, ZipEntry e) {
        super(z, true);
        setEncoding(enc);
        setEntry(e);
    }

    
    public void setZipfile(File z) {
        setArchive(z);
    }

    
    public File getZipfile() {
        FileResource r = (FileResource) getArchive();
        return r.getFile();
    }

    
    public void addConfigured(ResourceCollection a) {
        super.addConfigured(a);
        if (!a.isFilesystemOnly()) {
            throw new BuildException(""only filesystem resources are supported"");
        }
    }

    
    public void setEncoding(String enc) {
        checkAttributesAllowed();
        encoding = enc;
    }

    
    public String getEncoding() {
        return isReference()
            ? ((ZipResource) getCheckedRef()).getEncoding() : encoding;
    }

    
    public void setRefid(Reference r) {
        if (encoding != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        final ZipFile z = new ZipFile(getZipfile(), getEncoding());
        ZipEntry ze = z.getEntry(getName());
        if (ze == null) {
            z.close();
            throw new BuildException(""no entry "" + getName() + "" in ""
                                     + getArchive());
        }
        return new FilterInputStream(z.getInputStream(ze)) {
            public void close() throws IOException {
                FileUtils.close(in);
                z.close();
            }
            protected void finalize() throws Throwable {
                try {
                    close();
                } finally {
                    super.finalize();
                }
            }
        };
    }

    
    public OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        throw new UnsupportedOperationException(
            ""Use the zip task for zip output."");
    }

    
    protected void fetchEntry() {
        ZipFile z = null;
        try {
            z = new ZipFile(getZipfile(), getEncoding());
            setEntry(z.getEntry(getName()));
        } catch (IOException e) {
            log(e.getMessage(), Project.MSG_DEBUG);
            throw new BuildException(e);
        } finally {
            if (z != null) {
                try {
                    z.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }

    private void setEntry(ZipEntry e) {
        if (e == null) {
            setExists(false);
            return;
        }
        setName(e.getName());
        setExists(true);
        setLastModified(e.getTime());
        setDirectory(e.isDirectory());
        setSize(e.getSize());
        setMode(e.getUnixMode());
    }

}
"
org.apache.tools.ant.taskdefs.ExecuteStreamHandler,5,1,0,31,5,10,31,0,5,2.0,5,0.0,0,0.0,0.533333333,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;


public interface ExecuteStreamHandler {

    
    void setProcessInputStream(OutputStream os) throws IOException;

    
    void setProcessErrorStream(InputStream is) throws IOException;

    
    void setProcessOutputStream(InputStream is) throws IOException;

    
    void start() throws IOException;

    
    void stop();
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.NetCommand,19,1,0,23,69,81,11,12,14,0.856481481,517,1.0,4,0.0,0.183333333,0,0,25.57894737,6,1.8421,0,"



package org.apache.tools.ant.taskdefs.optional.dotnet;



import java.io.File;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.BufferedOutputStream;
import java.util.Hashtable;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;



public class NetCommand {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
    

    
    protected Task owner;

    
    protected Execute executable;

    
    protected Commandline commandLine;

    
    protected String title;

    
    protected String program;

    
    protected boolean traceCommandLine = false;

    
    protected boolean failOnError;

    

    
    private File directory;

    
    private boolean useResponseFile = false;

    
    private File temporaryCommandFile;

    
    private int automaticResponseFileThreshold = 64;

    

    public NetCommand(Task owner, String title, String program) {
        this.owner = owner;
        this.title = title;
        this.program = program;
        commandLine = new Commandline();
        commandLine.setExecutable(program);
    }


    
    public void setTraceCommandLine(boolean b) {
        traceCommandLine = b;
    }


    
    public void setFailOnError(boolean b) {
        failOnError = b;
    }


    
    public boolean getFailFailOnError() {
        return failOnError;
    }


    
    public void setDirectory(File directory) {
        this.directory = directory;
    }

    
    protected void logVerbose(String msg) {
        owner.getProject().log(msg, Project.MSG_VERBOSE);
    }


    
    protected void logError(String msg) {
        owner.getProject().log(msg, Project.MSG_ERR);
    }


    
    public void addArgument(String argument) {
        if (argument != null && argument.length() != 0) {
            commandLine.createArgument().setValue(argument);
        }
    }

    
    public void addArguments(String[] arguments) {
        if (arguments != null && arguments.length != 0) {
            for (int i = 0; i < arguments.length; i++) {
                addArgument(arguments[i]);
            }
        }
    }

    
    public void addArgument(String argument1, String argument2) {
        if (argument2 != null && argument2.length() != 0) {
            commandLine.createArgument().setValue(argument1 + argument2);
        }
    }

    
    public boolean isUseResponseFile() {
        return useResponseFile;
    }

    
    public void setUseResponseFile(boolean useResponseFile) {
        this.useResponseFile = useResponseFile;
    }

    
    public int getAutomaticResponseFileThreshold() {
        return automaticResponseFileThreshold;
    }

    
    public void setAutomaticResponseFileThreshold(int automaticResponseFileThreshold) {
        this.automaticResponseFileThreshold = automaticResponseFileThreshold;
    }

    
    protected void prepareExecutor() {
        
        if (owner == null) {
            throw new RuntimeException(""no owner"");
        }
        if (owner.getProject() == null) {
            throw new RuntimeException(""Owner has no project"");
        }
        File dir = owner.getProject().getBaseDir();
        if (directory != null) {
            dir = directory;
        }

        ExecuteStreamHandler handler = new LogStreamHandler(owner,
                Project.MSG_INFO, Project.MSG_WARN);
        executable = new Execute(handler, null);
        executable.setAntRun(owner.getProject());
        executable.setWorkingDirectory(dir);
    }


    
    public void runCommand()
             throws BuildException {
        prepareExecutor();
        int err = -1;
        
        try {
            if (traceCommandLine) {
                owner.log(""In directory "" + executable.getWorkingDirectory());
                owner.log(commandLine.describeCommand());
            } else {
                
                logVerbose(""In directory "" + executable.getWorkingDirectory());
                logVerbose(commandLine.describeCommand());
            }
            setExecutableCommandLine();
            err = executable.execute();
            if (Execute.isFailure(err)) {
                if (failOnError) {
                    throw new BuildException(title + "" returned: "" + err, owner.getLocation());
                } else {
                    owner.log(title + ""  Result: "" + err, Project.MSG_ERR);
                }
            }
        } catch (IOException e) {
            throw new BuildException(title + "" failed: "" + e, e, owner.getLocation());
        } finally {
            if (temporaryCommandFile != null) {
                temporaryCommandFile.delete();
            }
        }
    }

    
    private void setExecutableCommandLine() {

        String[] commands = commandLine.getCommandline();
        
        if (automaticResponseFileThreshold > 0
            && commands.length > automaticResponseFileThreshold) {
            useResponseFile = true;
        }
        if (!useResponseFile || commands.length <= 1) {
            
            executable.setCommandline(commands);
        } else {
            
            
            
            FileOutputStream fos = null;

            temporaryCommandFile = FILE_UTILS.createTempFile(""cmd"", "".txt"", null);
            owner.log(""Using response file "" + temporaryCommandFile, Project.MSG_VERBOSE);

            try {
                fos = new FileOutputStream(temporaryCommandFile);
                PrintWriter out = new PrintWriter(new BufferedOutputStream(fos));
                
                for (int i = 1; i < commands.length; ++i) {
                    out.println(commands[i]);
                }
                out.flush();
                out.close();
            } catch (IOException ex) {
                throw new BuildException(""saving command stream to "" + temporaryCommandFile, ex);
            }

            String[] newCommandLine = new String[2];
            newCommandLine[0] = commands[0];
            newCommandLine[1] = ""@"" + temporaryCommandFile.getAbsolutePath();
            logVerbose(Commandline.describeCommand(newCommandLine));
            executable.setCommandline(newCommandLine);
        }
    }


    
    public int scanOneFileset(DirectoryScanner scanner, Hashtable filesToBuild,
                                        long outputTimestamp) {
        int filesOutOfDate = 0;
        String[] dependencies = scanner.getIncludedFiles();
        File base = scanner.getBasedir();
        
        for (int i = 0; i < dependencies.length; i++) {
            File targetFile = new File(base, dependencies[i]);
            if (filesToBuild.get(targetFile) == null) {
                filesToBuild.put(targetFile, targetFile);
                if (targetFile.lastModified() > outputTimestamp) {
                    filesOutOfDate++;
                    owner.log(targetFile.toString() + "" is out of date"",
                              Project.MSG_VERBOSE);
                } else {
                    owner.log(targetFile.toString(),
                              Project.MSG_VERBOSE);
                }
            }
        }
        return filesOutOfDate;
    }
}
"
org.apache.tools.ant.listener.TimestampedLogger,4,2,0,1,15,6,0,1,1,1.333333333,49,1.0,0,0.842105263,1.0,1,1,11.0,1,0.75,0,"

package org.apache.tools.ant.listener;

import org.apache.tools.ant.DefaultLogger;

import java.util.Date;
import java.text.DateFormat;


public class TimestampedLogger extends DefaultLogger {

    
    private static final String SPACER = "" - at "";


    
    protected String getBuildFailedMessage() {
        return super.getBuildFailedMessage() + SPACER + getTimestamp();
    }

    
    protected String getBuildSuccessfulMessage() {
        return super.getBuildSuccessfulMessage() + SPACER + getTimestamp();
    }

    
    protected String getTimestamp() {
        Date date = new Date(System.currentTimeMillis());
        DateFormat formatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
        String finishTime = formatter.format(date);
        return finishTime;
    }
}
"
org.apache.tools.mail.ErrorInQuitException,1,4,0,1,3,0,1,0,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.tools.mail;

import java.io.IOException;


public class ErrorInQuitException extends IOException {

    
    public ErrorInQuitException(IOException e) {
        super(e.getMessage());
    }

}
"
org.apache.tools.ant.taskdefs.UpToDate,14,3,0,17,48,41,1,16,11,0.769230769,384,1.0,2,0.74,0.261904762,1,1,25.92857143,26,3.0,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.MergingMapper;
import org.apache.tools.ant.util.ResourceUtils;
import org.apache.tools.ant.util.SourceFileScanner;



public class UpToDate extends Task implements Condition {

    private String property;
    private String value;
    private File sourceFile;
    private File targetFile;
    private Vector sourceFileSets = new Vector();
    private Union sourceResources = new Union();

    
    protected Mapper mapperElement = null;
    

    
    public void setProperty(final String property) {
        this.property = property;
    }

    
    public void setValue(final String value) {
        this.value = value;
    }

    
    private String getValue() {
        return (value != null) ? value : ""true"";
    }

    
    public void setTargetFile(final File file) {
        this.targetFile = file;
    }

    
    public void setSrcfile(final File file) {
        this.sourceFile = file;
    }

    
    public void addSrcfiles(final FileSet fs) {
        sourceFileSets.addElement(fs);
    }

    
    public Union createSrcResources() {
        return sourceResources;
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     getLocation());
        }
        mapperElement = new Mapper(getProject());
        return mapperElement;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        createMapper().add(fileNameMapper);
    }

    
    public boolean eval() {
        if (sourceFileSets.size() == 0 && sourceResources.size() == 0
            && sourceFile == null) {
            throw new BuildException(""At least one srcfile or a nested ""
                                     + ""<srcfiles> or <srcresources> element ""
                                     + ""must be set."");
        }

        if ((sourceFileSets.size() > 0 || sourceResources.size() > 0)
            && sourceFile != null) {
            throw new BuildException(""Cannot specify both the srcfile ""
                                     + ""attribute and a nested <srcfiles> ""
                                     + ""or <srcresources> element."");
        }

        if (targetFile == null && mapperElement == null) {
            throw new BuildException(""The targetfile attribute or a nested ""
                                     + ""mapper element must be set."");
        }

        
        if (targetFile != null && !targetFile.exists()) {
            log(""The targetfile \"""" + targetFile.getAbsolutePath()
                    + ""\"" does not exist."", Project.MSG_VERBOSE);
            return false;
        }

        
        if (sourceFile != null && !sourceFile.exists()) {
            throw new BuildException(sourceFile.getAbsolutePath()
                                     + "" not found."");
        }

        boolean upToDate = true;
        if (sourceFile != null) {
            if (mapperElement == null) {
                upToDate = upToDate
                    && (targetFile.lastModified() >= sourceFile.lastModified());
            } else {
                SourceFileScanner sfs = new SourceFileScanner(this);
                upToDate = upToDate
                    && (sfs.restrict(new String[] {sourceFile.getAbsolutePath()},
                                  null, null,
                                  mapperElement.getImplementation()).length == 0);
            }
        }

        
        
        
        
        Enumeration e = sourceFileSets.elements();
        while (upToDate && e.hasMoreElements()) {
            FileSet fs = (FileSet) e.nextElement();
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            upToDate = upToDate && scanDir(fs.getDir(getProject()),
                                           ds.getIncludedFiles());
        }

        if (upToDate) {
            Resource[] r = sourceResources.listResources();
            upToDate = upToDate
                && (ResourceUtils.selectOutOfDateSources(
                        this, r, getMapper(), getProject()).length == 0);
        }

        return upToDate;
    }


    
    public void execute() throws BuildException {
        if (property == null) {
            throw new BuildException(""property attribute is required."",
                                     getLocation());
        }
        boolean upToDate = eval();
        if (upToDate) {
            getProject().setNewProperty(property, getValue());
            if (mapperElement == null) {
                log(""File \"""" + targetFile.getAbsolutePath()
                    + ""\"" is up-to-date."", Project.MSG_VERBOSE);
            } else {
                log(""All target files are up-to-date."",
                    Project.MSG_VERBOSE);
            }
        }
    }

    
    protected boolean scanDir(File srcDir, String[] files) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        FileNameMapper mapper = getMapper();
        File dir = srcDir;
        if (mapperElement == null) {
            dir = null;
        }
        return sfs.restrict(files, srcDir, dir, mapper).length == 0;
    }

    private FileNameMapper getMapper() {
        FileNameMapper mapper = null;
        if (mapperElement == null) {
            MergingMapper mm = new MergingMapper();
            mm.setTo(targetFile.getAbsolutePath());
            mapper = mm;
        } else {
            mapper = mapperElement.getImplementation();
        }
        return mapper;
    }
}
"
org.apache.tools.ant.types.resources.comparators.Exists,2,4,0,2,4,1,0,2,1,2.0,20,0.0,0,0.971428571,0.75,1,1,9.0,3,1.5,0,"
package org.apache.tools.ant.types.resources.comparators;

import org.apache.tools.ant.types.Resource;


public class Exists extends ResourceComparator {

    
    protected int resourceCompare(Resource foo, Resource bar) {
        boolean f = foo.isExists();
        if (f == bar.isExists()) {
            return 0;
        }
        return f ? 1 : -1;
    }

}
"
org.apache.tools.ant.util.ProxySetup,3,1,0,2,13,1,1,1,3,1.441176471,76,0.058823529,1,0.0,0.5,0,0,18.66666667,4,1.6667,0,"

package org.apache.tools.ant.util;

import org.apache.tools.ant.Project;



public class ProxySetup {

    
    private Project owner;

    
    public static final String USE_SYSTEM_PROXIES = ""java.net.useSystemProxies"";
    
    public static final String HTTP_PROXY_HOST = ""http.proxyHost"";
    
    public static final String HTTP_PROXY_PORT = ""http.proxyPort"";
    
    public static final String HTTPS_PROXY_HOST = ""https.proxyHost"";
    
    public static final String HTTPS_PROXY_PORT = ""https.proxyPort"";
    
    public static final String FTP_PROXY_HOST = ""ftp.proxyHost"";
    
    public static final String FTP_PROXY_PORT = ""ftp.proxyPort"";
    
    public static final String HTTP_NON_PROXY_HOSTS = ""http.nonProxyHosts"";
    
    public static final String HTTPS_NON_PROXY_HOSTS = ""https.nonProxyHosts"";
    
    public static final String FTP_NON_PROXY_HOSTS = ""ftp.nonProxyHosts"";
    
    public static final String HTTP_PROXY_USERNAME = ""http.proxyUser"";
    
    public static final String HTTP_PROXY_PASSWORD = ""http.proxyPassword"";
    
    public static final String SOCKS_PROXY_HOST = ""socksProxyHost"";
    
    public static final String SOCKS_PROXY_PORT = ""socksProxyPort"";
    
    public static final String SOCKS_PROXY_USERNAME = ""java.net.socks.username"";
    
    public static final String SOCKS_PROXY_PASSWORD = ""java.net.socks.password"";


    
    public ProxySetup(Project owner) {
        this.owner = owner;
    }

    
    public static String getSystemProxySetting() {
        try {
            return System.getProperty(USE_SYSTEM_PROXIES);
        } catch (SecurityException e) {
            
            return null;
        }
    }

    
    public void enableProxies() {
        if (!(getSystemProxySetting() != null)) {
            String proxies = owner.getProperty(USE_SYSTEM_PROXIES);
            if (proxies == null || Project.toBoolean(proxies)) {
                proxies = ""true"";
            }
            String message = ""setting "" + USE_SYSTEM_PROXIES + "" to "" + proxies;
            try {
                owner.log(message, Project.MSG_DEBUG);
                System.setProperty(USE_SYSTEM_PROXIES, proxies);
            } catch (SecurityException e) {
                
                
                owner.log(""Security Exception when "" + message);
            }
        }
    }

}
"
org.apache.tools.ant.taskdefs.ManifestTask,7,3,0,9,39,1,0,9,7,0.708333333,260,1.0,2,0.860465116,0.285714286,2,2,35.57142857,1,0.8571,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class ManifestTask extends Task {

    
    private Manifest nestedManifest = new Manifest();

    
    private File manifestFile;

    
    private Mode mode;

    
    private String encoding;

    
    public static class Mode extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""update"", ""replace""};
        }
    }

    
    public ManifestTask() {
        mode = new Mode();
        mode.setValue(""replace"");
    }

    
    public void addConfiguredSection(Manifest.Section section)
         throws ManifestException {
        nestedManifest.addConfiguredSection(section);
    }

    
    public void addConfiguredAttribute(Manifest.Attribute attribute)
         throws ManifestException {
        nestedManifest.addConfiguredAttribute(attribute);
    }

    
    public void setFile(File f) {
        manifestFile = f;
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public void setMode(Mode m) {
        mode = m;
    }

    
    public void execute() throws BuildException {
        if (manifestFile == null) {
            throw new BuildException(""the file attribute is required"");
        }

        Manifest toWrite = Manifest.getDefaultManifest();
        Manifest current = null;
        BuildException error = null;

        if (manifestFile.exists()) {
            FileInputStream fis = null;
            InputStreamReader isr = null;
            try {
                fis = new FileInputStream(manifestFile);
                if (encoding == null) {
                    isr = new InputStreamReader(fis, ""UTF-8"");
                } else {
                    isr = new InputStreamReader(fis, encoding);
                }
                current = new Manifest(isr);
            } catch (ManifestException m) {
                error = new BuildException(""Existing manifest "" + manifestFile
                                           + "" is invalid"", m, getLocation());
            } catch (IOException e) {
                error = new BuildException(""Failed to read "" + manifestFile,
                                           e, getLocation());
            } finally {
                FileUtils.close(isr);
            }
        }

        
        for (Enumeration e = nestedManifest.getWarnings();
                e.hasMoreElements();) {
            log(""Manifest warning: "" + (String) e.nextElement(),
                    Project.MSG_WARN);
        }
        try {
            if (mode.getValue().equals(""update"") && manifestFile.exists()) {
                if (current != null) {
                    toWrite.merge(current);
                } else if (error != null) {
                    throw error;
                }
            }

            toWrite.merge(nestedManifest);
        } catch (ManifestException m) {
            throw new BuildException(""Manifest is invalid"", m, getLocation());
        }

        if (toWrite.equals(current)) {
            log(""Manifest has not changed, do not recreate"",
                Project.MSG_VERBOSE);
            return;
        }

        PrintWriter w = null;
        try {
            FileOutputStream fos = new FileOutputStream(manifestFile);
            OutputStreamWriter osw = new OutputStreamWriter(fos, Manifest.JAR_ENCODING);
            w = new PrintWriter(osw);
            toWrite.write(w);
        } catch (IOException e) {
            throw new BuildException(""Failed to write "" + manifestFile,
                                     e, getLocation());
        } finally {
            if (w != null) {
                w.close();
            }
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.ccm.Continuus,7,3,3,12,26,9,3,9,4,1.041666667,106,0.375,0,0.860465116,0.428571429,0,0,13.0,3,1.1429,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.util.FileUtils;



public abstract class Continuus extends Task {

    private String ccmDir = """";
    private String ccmAction = """";

    
    public String getCcmAction() {
        return ccmAction;
    }

    
    public void setCcmAction(String v) {
        this.ccmAction = v;
    }


    
    public final void setCcmDir(String dir) {
        ccmDir = FileUtils.translatePath(dir);
    }

    
    protected final String getCcmCommand() {
        String toReturn = ccmDir;
        if (!toReturn.equals("""") && !toReturn.endsWith(""/"")) {
            toReturn += ""/"";
        }

        toReturn += CCM_EXE;

        return toReturn;
    }


    
    protected int run(Commandline cmd, ExecuteStreamHandler handler) {
        try {
            Execute exe = new Execute(handler);
            exe.setAntRun(getProject());
            exe.setWorkingDirectory(getProject().getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            return exe.execute();
        } catch (java.io.IOException e) {
            throw new BuildException(e, getLocation());
        }
    }

    
    protected int run(Commandline cmd) {
        return run(cmd, new LogStreamHandler(this, Project.MSG_VERBOSE, Project.MSG_WARN));
    }

    
    private static final String CCM_EXE = ""ccm"";

    
    public static final String COMMAND_CREATE_TASK = ""create_task"";
    
    public static final String COMMAND_CHECKOUT = ""co"";
    
    public static final String COMMAND_CHECKIN = ""ci"";
    
    public static final String COMMAND_RECONFIGURE = ""reconfigure"";

    
    public static final String COMMAND_DEFAULT_TASK = ""default_task"";


}
"
org.apache.tools.ant.util.Retryable,1,1,0,1,1,0,1,0,1,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.util;

import java.io.IOException;



public interface Retryable {
    
    int RETRY_FOREVER = -1;
    
    void execute() throws IOException;

}
"
org.apache.tools.ant.taskdefs.optional.RenameExtensions,6,4,0,9,33,0,0,9,6,0.68,205,1.0,1,0.939759036,0.416666667,2,4,32.33333333,1,0.8333,0,"


package org.apache.tools.ant.taskdefs.optional;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.taskdefs.Move;
import org.apache.tools.ant.types.Mapper;


public class RenameExtensions extends MatchingTask {

    private String fromExtension = """";
    private String toExtension = """";
    private boolean replace = false;
    private File srcDir;

    private Mapper.MapperType globType;


    
    public RenameExtensions() {
        super();
        globType = new Mapper.MapperType();
        globType.setValue(""glob"");
    }

    
    public void setFromExtension(String from) {
        fromExtension = from;
    }

    
    public void setToExtension(String to) {
        toExtension = to;
    }

    
    public void setReplace(boolean replace) {
        this.replace = replace;
    }

    
    public void setSrcDir(File srcDir) {
        this.srcDir = srcDir;
    }

    
    public void execute() throws BuildException {

        
        if (fromExtension == null || toExtension == null || srcDir == null) {
            throw new BuildException(""srcDir, fromExtension and toExtension ""
                + ""attributes must be set!"");
        }

        log(""DEPRECATED - The renameext task is deprecated.  Use move instead."",
            Project.MSG_WARN);
        log(""Replace this with:"", Project.MSG_INFO);
        log(""<move todir=\"""" + srcDir + ""\"" overwrite=\"""" + replace + ""\"">"",
            Project.MSG_INFO);
        log(""  <fileset dir=\"""" + srcDir + ""\"" />"", Project.MSG_INFO);
        log(""  <mapper type=\""glob\"""", Project.MSG_INFO);
        log(""          from=\""*"" + fromExtension + ""\"""", Project.MSG_INFO);
        log(""          to=\""*"" + toExtension + ""\"" />"", Project.MSG_INFO);
        log(""</move>"", Project.MSG_INFO);
        log(""using the same patterns on <fileset> as you\'ve used here"",
            Project.MSG_INFO);

        Move move = new Move();
        move.bindToOwner(this);
        move.setOwningTarget(getOwningTarget());
        move.setTaskName(getTaskName());
        move.setLocation(getLocation());
        move.setTodir(srcDir);
        move.setOverwrite(replace);

        fileset.setDir(srcDir);
        move.addFileset(fileset);

        Mapper me = move.createMapper();
        me.setType(globType);
        me.setFrom(""*"" + fromExtension);
        me.setTo(""*"" + toExtension);

        move.execute();
    }

}
"
org.apache.tools.ant.BuildEvent,11,2,0,17,15,13,15,3,11,0.75,97,1.0,3,0.2,0.220779221,0,0,7.272727273,1,0.7273,0,"
package org.apache.tools.ant;

import java.util.EventObject;


public class BuildEvent extends EventObject {

    
    private Project project;
    
    private Target target;
    
    private Task task;
    
    private String message;
    
    private int priority = Project.MSG_VERBOSE;
    
    private Throwable exception;

    
    public BuildEvent(Project project) {
        super(project);
        this.project = project;
        this.target = null;
        this.task = null;
    }

    
    public BuildEvent(Target target) {
        super(target);
        this.project = target.getProject();
        this.target = target;
        this.task = null;
    }

    
    public BuildEvent(Task task) {
        super(task);
        this.project = task.getProject();
        this.target = task.getOwningTarget();
        this.task = task;
    }

    
    public void setMessage(String message, int priority) {
        this.message = message;
        this.priority = priority;
    }

    
    public void setException(Throwable exception) {
        this.exception = exception;
    }

    
    public Project getProject() {
        return project;
    }

    
    public Target getTarget() {
        return target;
    }

    
    public Task getTask() {
        return task;
    }

    
    public String getMessage() {
        return message;
    }

    
    public int getPriority() {
        return priority;
    }

    
    public Throwable getException() {
        return exception;
    }
}
"
org.apache.tools.ant.util.CompositeMapper,2,2,0,3,13,1,1,2,2,2.0,48,0.0,0,0.875,0.75,0,0,23.0,5,2.5,0,"
package org.apache.tools.ant.util;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;


public class CompositeMapper extends ContainerMapper {

    
    public String[] mapFileName(String sourceFileName) {
        HashSet results = new HashSet();

        FileNameMapper mapper = null;
        for (Iterator mIter = getMappers().iterator(); mIter.hasNext();) {
            mapper = (FileNameMapper) (mIter.next());
            if (mapper != null) {
                String[] mapped = mapper.mapFileName(sourceFileName);
                if (mapped != null) {
                    results.addAll(Arrays.asList(mapped));
                }
            }
        }
        return (results.size() == 0) ? null
            : (String[]) results.toArray(new String[results.size()]);
    }

}

"
org.apache.tools.ant.types.resources.FileResource,24,4,0,45,68,244,41,6,22,0.804347826,397,1.0,1,0.736111111,0.211180124,2,14,15.375,6,1.9583,2,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Reference;


public class FileResource extends Resource implements Touchable {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
    private static final int NULL_FILE
        = Resource.getMagicNumber(""null file"".getBytes());

    private File file;
    private File baseDir;

    
    public FileResource() {
    }

    
    public FileResource(File b, String name) {
        setFile(FILE_UTILS.resolveFile(b, name));
        setBaseDir(b);
    }

    
    public FileResource(File f) {
        setFile(f);
    }

    
    public FileResource(Project p, String s) {
        this(p.resolveFile(s));
        setProject(p);
    }

    
    public void setFile(File f) {
        checkAttributesAllowed();
        file = f;
    }

    
    public File getFile() {
        return isReference() ? ((FileResource) getCheckedRef()).getFile() : file;
    }

    
    public void setBaseDir(File b) {
        checkAttributesAllowed();
        baseDir = b;
    }

    
    public File getBaseDir() {
        return isReference()
            ? ((FileResource) getCheckedRef()).getBaseDir() : baseDir;
    }

    
    public void setRefid(Reference r) {
        if (file != null || baseDir != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public String getName() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getName();
        }
        File b = getBaseDir();
        return b == null ? getNotNullFile().getName()
            : FILE_UTILS.removeLeadingPath(b, getNotNullFile());
    }

    
    public boolean isExists() {
        return isReference() ? ((Resource) getCheckedRef()).isExists()
            : getNotNullFile().exists();
    }

    
    public long getLastModified() {
        return isReference()
            ? ((Resource) getCheckedRef()).getLastModified()
            : getNotNullFile().lastModified();
    }

    
    public boolean isDirectory() {
        return isReference() ? ((Resource) getCheckedRef()).isDirectory()
            : getNotNullFile().isDirectory();
    }

    
    public long getSize() {
        return isReference() ? ((Resource) getCheckedRef()).getSize()
            : getNotNullFile().length();
    }

    
    public InputStream getInputStream() throws IOException {
        return isReference()
            ? ((Resource) getCheckedRef()).getInputStream()
            : new FileInputStream(getNotNullFile());
    }

    
    public OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        File f = getNotNullFile();
        if (f.exists()) {
            if (f.isFile()) {
                f.delete();
            }
        } else {
            File p = f.getParentFile();
            if (p != null && !(p.exists())) {
                p.mkdirs();
            }
        }
        return new FileOutputStream(f);
    }

    
    public int compareTo(Object another) {
        if (isReference()) {
            return ((Comparable) getCheckedRef()).compareTo(another);
        }
        if (this.equals(another)) {
            return 0;
        }
        if (another.getClass().equals(getClass())) {
            FileResource otherfr = (FileResource) another;
            File f = getFile();
            if (f == null) {
                return -1;
            }
            File of = otherfr.getFile();
            if (of == null) {
                return 1;
            }
            return f.compareTo(of);
        }
        return super.compareTo(another);
    }

    
    public boolean equals(Object another) {
        if (this == another) {
            return true;
        }
        if (isReference()) {
            return getCheckedRef().equals(another);
        }
        if (!(another.getClass().equals(getClass()))) {
            return false;
        }
        FileResource otherfr = (FileResource) another;
        return getFile() == null
            ? otherfr.getFile() == null
            : getFile().equals(otherfr.getFile());
    }

    
    public int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        return MAGIC * (getFile() == null ? NULL_FILE : getFile().hashCode());
    }

    
    public String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        if (file == null) {
            return ""(unbound file resource)"";
        }
        String absolutePath = file.getAbsolutePath();
        return FILE_UTILS.normalize(absolutePath).getAbsolutePath();
    }

    
    public boolean isFilesystemOnly() {
        return !isReference()
            || ((FileResource) getCheckedRef()).isFilesystemOnly();
    }

    
    public void touch(long modTime) {
        if (isReference()) {
            ((FileResource) getCheckedRef()).touch(modTime);
            return;
        }
        getNotNullFile().setLastModified(modTime);
    }

    
    protected File getNotNullFile() {
        if (getFile() == null) {
            throw new BuildException(""file attribute is null!"");
        }
        return getFile();
    }

}
"
org.apache.tools.ant.util.ScriptRunnerBase,25,1,1,13,59,248,9,4,20,0.875,290,1.0,1,0.0,0.173333333,0,0,10.36,6,1.4,0,"
package org.apache.tools.ant.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Project;

import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;


public abstract class ScriptRunnerBase {
    
    private boolean keepEngine = false;

    
    private String language;

    
    private String script = """";

    
    private Project project;

    
    private ClassLoader scriptLoader;

    
    private Map beans = new HashMap();

    
    public void addBeans(Map dictionary) {
        for (Iterator i = dictionary.keySet().iterator(); i.hasNext();) {
            String key = (String) i.next();
            try {
                Object val = dictionary.get(key);
                addBean(key, val);
            } catch (BuildException ex) {
                
                
                
                
            }
        }
    }

    
    public void addBean(String key, Object bean) {
        boolean isValid = key.length() > 0
            && Character.isJavaIdentifierStart(key.charAt(0));

        for (int i = 1; isValid && i < key.length(); i++) {
            isValid = Character.isJavaIdentifierPart(key.charAt(i));
        }

        if (isValid) {
            beans.put(key, bean);
        }
    }

    
    protected Map getBeans() {
        return beans;
    }

    
    public abstract void executeScript(String execName);

    
    public abstract Object evaluateScript(String execName);

    
    public abstract boolean supportsLanguage();

    
    public abstract String getManagerName();

    
    public void setLanguage(String language) {
        this.language = language;
    }

    
    public String getLanguage() {
        return language;
    }

    
    public void setScriptClassLoader(ClassLoader classLoader) {
        this.scriptLoader = classLoader;
    }

    
    protected ClassLoader getScriptClassLoader() {
        return scriptLoader;
    }

    
    public void setKeepEngine(boolean keepEngine) {
        this.keepEngine = keepEngine;
    }

    
    public boolean getKeepEngine() {
        return keepEngine;
    }

    
    public void setSrc(File file) {
        if (!file.exists()) {
            throw new BuildException(""file "" + file.getPath() + "" not found."");
        }
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(file));
            script += FileUtils.readFully(in);
        } catch (IOException ex) {
            throw new BuildException(ex);
        } finally {
            FileUtils.close(in);
        }
    }

    
    public void addText(String text) {
        this.script += text;
    }

    
    public String getScript() {
        return script;
    }

    
    public void clearScript() {
        this.script = """";
    }

    
    public void setProject(Project project) {
        this.project = project;
    }

    
    public Project getProject() {
        return project;
    }

    
    public void bindToComponent(ProjectComponent component) {
        project = component.getProject();
        addBeans(project.getProperties());
        addBeans(project.getUserProperties());
        addBeans(project.getTargets());
        addBeans(project.getReferences());
        addBean(""project"", project);
        addBean(""self"", component);
    }

    
    public void bindToComponentMinimum(ProjectComponent component) {
        project = component.getProject();
        addBean(""project"", project);
        addBean(""self"", component);
    }

    
    protected void checkLanguage() {
        if (language == null) {
            throw new BuildException(
                ""script language must be specified"");
        }
    }

    
    protected ClassLoader replaceContextLoader() {
        ClassLoader origContextClassLoader =
            Thread.currentThread().getContextClassLoader();
        if (getScriptClassLoader() == null) {
            setScriptClassLoader(getClass().getClassLoader());
        }
        Thread.currentThread().setContextClassLoader(getScriptClassLoader());
        return origContextClassLoader;
    }

    
    protected void restoreContextLoader(ClassLoader origLoader) {
        Thread.currentThread().setContextClassLoader(
                 origLoader);
    }

}
"
org.apache.tools.ant.taskdefs.cvslib.RedirectingStreamHandler,3,2,0,5,12,3,1,4,1,2.0,40,0.0,0,0.857142857,0.666666667,0,0,12.33333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.cvslib;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.PumpStreamHandler;


class RedirectingStreamHandler
     extends PumpStreamHandler {
    RedirectingStreamHandler(final ChangeLogParser parser) {
        super(new RedirectingOutputStream(parser),
            new ByteArrayOutputStream());
    }


    String getErrors() {
        try {
            final ByteArrayOutputStream error
                = (ByteArrayOutputStream) getErr();

            return error.toString(""ASCII"");
        } catch (final Exception e) {
            return null;
        }
    }


    public void stop() {
        super.stop();
        try {
            getErr().close();
            getOut().close();
        } catch (final IOException e) {
            
            throw new BuildException(e);
        }
    }
}

"
org.apache.tools.ant.launch.Launcher,9,1,0,5,57,34,2,3,2,1.083333333,566,0.222222222,0,0.0,0.303571429,0,0,60.88888889,2,0.8889,1,"
package org.apache.tools.ant.launch;

import java.net.URL;
import java.net.URLClassLoader;
import java.net.MalformedURLException;
import java.io.File;
import java.util.StringTokenizer;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;




public class Launcher {

    
    public static final String ANTHOME_PROPERTY = ""ant.home"";

    
    public static final String ANTLIBDIR_PROPERTY = ""ant.library.dir"";

    
    public static final String ANT_PRIVATEDIR = "".ant"";

    
    public static final String ANT_PRIVATELIB = ""lib"";

    
    public static final String USER_LIBDIR =
        ANT_PRIVATEDIR + File.separatorChar + ANT_PRIVATELIB;

    
    public static final String MAIN_CLASS = ""org.apache.tools.ant.Main"";

    
    public static final String USER_HOMEDIR = ""user.home"";

    
    private static final String JAVA_CLASS_PATH = ""java.class.path"";

    
    protected static final int EXIT_CODE_ERROR = 2;

    
    public static void main(String[] args) {
        int exitCode;
        try {
            Launcher launcher = new Launcher();
            exitCode = launcher.run(args);
        } catch (LaunchException e) {
            exitCode = EXIT_CODE_ERROR;
            System.err.println(e.getMessage());
        } catch (Throwable t) {
            exitCode = EXIT_CODE_ERROR;
            t.printStackTrace(System.err);
        }
        if (exitCode != 0) {
            System.exit(exitCode);
        }
    }


    
    private void addPath(String path, boolean getJars, List libPathURLs)
            throws MalformedURLException {
        StringTokenizer tokenizer = new StringTokenizer(path, File.pathSeparator);
        while (tokenizer.hasMoreElements()) {
            String elementName = tokenizer.nextToken();
            File element = new File(elementName);
            if (elementName.indexOf(""%"") != -1 && !element.exists()) {
                continue;
            }
            if (getJars && element.isDirectory()) {
                
                URL[] dirURLs = Locator.getLocationURLs(element);
                for (int j = 0; j < dirURLs.length; ++j) {
                    libPathURLs.add(dirURLs[j]);
                }
            }

            libPathURLs.add(Locator.fileToURL(element));
        }
    }

    
    private int run(String[] args)
            throws LaunchException, MalformedURLException {
        String antHomeProperty = System.getProperty(ANTHOME_PROPERTY);
        File antHome = null;

        File sourceJar = Locator.getClassSource(getClass());
        File jarDir = sourceJar.getParentFile();
        String mainClassname = MAIN_CLASS;

        if (antHomeProperty != null) {
            antHome = new File(antHomeProperty);
        }

        if (antHome == null || !antHome.exists()) {
            antHome = jarDir.getParentFile();
            System.setProperty(ANTHOME_PROPERTY, antHome.getAbsolutePath());
        }

        if (!antHome.exists()) {
            throw new LaunchException(""Ant home is set incorrectly or ""
                + ""ant could not be located"");
        }

        List libPaths = new ArrayList();
        String cpString = null;
        List argList = new ArrayList();
        String[] newArgs;
        boolean  noUserLib = false;
        boolean  noClassPath = false;

        for (int i = 0; i < args.length; ++i) {
            if (args[i].equals(""-lib"")) {
                if (i == args.length - 1) {
                    throw new LaunchException(""The -lib argument must ""
                        + ""be followed by a library location"");
                }
                libPaths.add(args[++i]);
            } else if (args[i].equals(""-cp"")) {
                if (i == args.length - 1) {
                    throw new LaunchException(""The -cp argument must ""
                        + ""be followed by a classpath expression"");
                }
                if (cpString != null) {
                    throw new LaunchException(""The -cp argument must ""
                        + ""not be repeated"");
                }
                cpString = args[++i];
            } else if (args[i].equals(""--nouserlib"") || args[i].equals(""-nouserlib"")) {
                noUserLib = true;
            } else if (args[i].equals(""--noclasspath"") || args[i].equals(""-noclasspath"")) {
                noClassPath = true;
            } else if (args[i].equals(""-main"")) {
                if (i == args.length - 1) {
                    throw new LaunchException(""The -main argument must ""
                            + ""be followed by a library location"");
                }
                mainClassname = args[++i];
            } else {
                argList.add(args[i]);
            }
        }

        
        
        
        if (argList.size() == args.length) {
            newArgs = args;
        } else {
            newArgs = (String[]) argList.toArray(new String[argList.size()]);
        }

        URL[] libURLs    = getLibPathURLs(
            noClassPath ? null : cpString, libPaths);
        URL[] systemURLs = getSystemURLs(jarDir);
        URL[] userURLs   = noUserLib ? new URL[0] : getUserURLs();

        URL[] jars = getJarArray(
            libURLs, userURLs, systemURLs, Locator.getToolsJar());

        
        StringBuffer baseClassPath
            = new StringBuffer(System.getProperty(JAVA_CLASS_PATH));
        if (baseClassPath.charAt(baseClassPath.length() - 1)
                == File.pathSeparatorChar) {
            baseClassPath.setLength(baseClassPath.length() - 1);
        }

        for (int i = 0; i < jars.length; ++i) {
            baseClassPath.append(File.pathSeparatorChar);
            baseClassPath.append(Locator.fromURI(jars[i].toString()));
        }

        System.setProperty(JAVA_CLASS_PATH, baseClassPath.toString());

        URLClassLoader loader = new URLClassLoader(jars);
        Thread.currentThread().setContextClassLoader(loader);
        Class mainClass = null;
        int exitCode = 0;
        try {
            mainClass = loader.loadClass(mainClassname);
            AntMain main = (AntMain) mainClass.newInstance();
            main.startAnt(newArgs, null, null);
        } catch (InstantiationException ex) {
            System.err.println(
                ""Incompatible version of "" + mainClassname + "" detected"");
            File mainJar = Locator.getClassSource(mainClass);
            System.err.println(
                ""Location of this class "" + mainJar);
            exitCode = EXIT_CODE_ERROR;
        } catch (Throwable t) {
            t.printStackTrace(System.err);
            exitCode = EXIT_CODE_ERROR;
        }
        return exitCode;
    }

    
    private URL[] getLibPathURLs(String cpString, List libPaths)
        throws MalformedURLException {
        List libPathURLs = new ArrayList();

        if (cpString != null) {
            addPath(cpString, false, libPathURLs);
        }

        for (Iterator i = libPaths.iterator(); i.hasNext();) {
            String libPath = (String) i.next();
            addPath(libPath, true, libPathURLs);
        }

        return  (URL[]) libPathURLs.toArray(new URL[libPathURLs.size()]);
    }

    
    private URL[] getSystemURLs(File antLauncherDir) throws MalformedURLException {
        File antLibDir = null;
        String antLibDirProperty = System.getProperty(ANTLIBDIR_PROPERTY);
        if (antLibDirProperty != null) {
            antLibDir = new File(antLibDirProperty);
        }
        if ((antLibDir == null) || !antLibDir.exists()) {
            antLibDir = antLauncherDir;
            System.setProperty(ANTLIBDIR_PROPERTY, antLibDir.getAbsolutePath());
        }
        return Locator.getLocationURLs(antLibDir);
    }

    
    private URL[] getUserURLs() throws MalformedURLException {
        File userLibDir
            = new File(System.getProperty(USER_HOMEDIR), USER_LIBDIR);

        return Locator.getLocationURLs(userLibDir);
    }

    
    private URL[] getJarArray (
        URL[] libJars, URL[] userJars, URL[] systemJars, File toolsJar)
        throws MalformedURLException {
        int numJars = libJars.length + userJars.length + systemJars.length;
        if (toolsJar != null) {
            numJars++;
        }
        URL[] jars = new URL[numJars];
        System.arraycopy(libJars, 0, jars, 0, libJars.length);
        System.arraycopy(userJars, 0, jars, libJars.length, userJars.length);
        System.arraycopy(systemJars, 0, jars, userJars.length + libJars.length,
            systemJars.length);

        if (toolsJar != null) {
            jars[jars.length - 1] = Locator.fileToURL(toolsJar);
        }
        return jars;
    }
}
"
org.apache.tools.ant.taskdefs.condition.IsTrue,3,2,0,4,6,0,1,3,3,0.0,30,1.0,0,0.818181818,0.666666667,0,0,8.666666667,2,1.0,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;


public class IsTrue extends ProjectComponent implements Condition {
    
    private Boolean value = null;

    
    public void setValue(boolean value) {
        this.value = value ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public boolean eval() throws BuildException {
        if (value == null) {
            throw new BuildException(""Nothing to test for truth"");
        }
        return value.booleanValue();
    }

}

"
org.apache.tools.ant.taskdefs.Zip,49,4,1,31,210,844,1,30,28,0.877403846,2937,1.0,2,0.624,0.127314815,0,0,58.40816327,13,1.449,8,"
package org.apache.tools.ant.taskdefs;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Stack;
import java.util.Vector;
import java.util.zip.CRC32;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.FileScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.ArchiveFileSet;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.ZipFileSet;
import org.apache.tools.ant.types.ZipScanner;
import org.apache.tools.ant.types.resources.ArchiveResource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.GlobPatternMapper;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.ant.util.MergingMapper;
import org.apache.tools.ant.util.ResourceUtils;
import org.apache.tools.zip.ZipEntry;
import org.apache.tools.zip.ZipExtraField;
import org.apache.tools.zip.ZipFile;
import org.apache.tools.zip.ZipOutputStream;


public class Zip extends MatchingTask {
    

    protected File zipFile;
    
    private ZipScanner zs;
    private File baseDir;
    protected Hashtable entries = new Hashtable();
    private Vector groupfilesets = new Vector();
    private Vector filesetsFromGroupfilesets = new Vector();
    protected String duplicate = ""add"";
    private boolean doCompress = true;
    private boolean doUpdate = false;
    
    private boolean savedDoUpdate = false;
    private boolean doFilesonly = false;
    protected String archiveType = ""zip"";

    
    private static final long EMPTY_CRC = new CRC32 ().getValue ();
    protected String emptyBehavior = ""skip"";
    private Vector resources = new Vector();
    protected Hashtable addedDirs = new Hashtable();
    private Vector addedFiles = new Vector();

    protected boolean doubleFilePass = false;
    protected boolean skipWriting = false;

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    

    
    private boolean addingNewFiles = false;

    
    private String encoding;

    
    private boolean keepCompression = false;

    
    private boolean roundUp = true;

    
    private String comment = """";

    private int level = ZipOutputStream.DEFAULT_COMPRESSION;

    
    public void setZipfile(File zipFile) {
        setDestFile(zipFile);
    }

    
    public void setFile(File file) {
        setDestFile(file);
    }


    
    public void setDestFile(File destFile) {
       this.zipFile = destFile;
    }

    
    public File getDestFile() {
        return zipFile;
    }


    
    public void setBasedir(File baseDir) {
        this.baseDir = baseDir;
    }

    
    public void setCompress(boolean c) {
        doCompress = c;
    }

    
    public boolean isCompress() {
        return doCompress;
    }

    
    public void setFilesonly(boolean f) {
        doFilesonly = f;
    }

    
    public void setUpdate(boolean c) {
        doUpdate = c;
        savedDoUpdate = c;
    }

    
    public boolean isInUpdateMode() {
        return doUpdate;
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void addZipfileset(ZipFileSet set) {
        add(set);
    }

    
    public void add(ResourceCollection a) {
        resources.add(a);
    }

    
    public void addZipGroupFileset(FileSet set) {
        groupfilesets.addElement(set);
    }

    
    public void setDuplicate(Duplicate df) {
        duplicate = df.getValue();
    }

    
    public static class WhenEmpty extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""fail"", ""skip"", ""create""};
        }
    }

    
    public void setWhenempty(WhenEmpty we) {
        emptyBehavior = we.getValue();
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public String getEncoding() {
        return encoding;
    }

    
    public void setKeepCompression(boolean keep) {
        keepCompression = keep;
    }

    
    public void setComment(String comment) {
        this.comment = comment;
    }

    
    public String getComment() {
        return comment;
    }

    
    public void setLevel(int level) {
        this.level = level;
    }

    
    public int getLevel() {
        return level;
    }

    
    public void setRoundUp(boolean r) {
        roundUp = r;
    }

    
    public void execute() throws BuildException {

        if (doubleFilePass) {
            skipWriting = true;
            executeMain();
            skipWriting = false;
            executeMain();
        } else {
            executeMain();
        }
    }

    
    public void executeMain() throws BuildException {

        if (baseDir == null && resources.size() == 0
            && groupfilesets.size() == 0 && ""zip"".equals(archiveType)) {
            throw new BuildException(""basedir attribute must be set, ""
                                     + ""or at least one ""
                                     + ""resource collection must be given!"");
        }

        if (zipFile == null) {
            throw new BuildException(""You must specify the ""
                                     + archiveType + "" file to create!"");
        }

        if (zipFile.exists() && !zipFile.isFile()) {
            throw new BuildException(zipFile + "" is not a file."");
        }

        if (zipFile.exists() && !zipFile.canWrite()) {
            throw new BuildException(zipFile + "" is read-only."");
        }

        
        File renamedFile = null;
        addingNewFiles = true;

        
        
        if (doUpdate && !zipFile.exists()) {
            doUpdate = false;
            log(""ignoring update attribute as "" + archiveType
                + "" doesn't exist."", Project.MSG_DEBUG);
        }

        
        for (int i = 0; i < groupfilesets.size(); i++) {

            log(""Processing groupfileset "", Project.MSG_VERBOSE);
            FileSet fs = (FileSet) groupfilesets.elementAt(i);
            FileScanner scanner = fs.getDirectoryScanner(getProject());
            String[] files = scanner.getIncludedFiles();
            File basedir = scanner.getBasedir();
            for (int j = 0; j < files.length; j++) {

                log(""Adding file "" + files[j] + "" to fileset"",
                    Project.MSG_VERBOSE);
                ZipFileSet zf = new ZipFileSet();
                zf.setProject(getProject());
                zf.setSrc(new File(basedir, files[j]));
                add(zf);
                filesetsFromGroupfilesets.addElement(zf);
            }
        }

        
        Vector vfss = new Vector();
        if (baseDir != null) {
            FileSet fs = (FileSet) getImplicitFileSet().clone();
            fs.setDir(baseDir);
            vfss.addElement(fs);
        }
        for (int i = 0; i < resources.size(); i++) {
            ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
            vfss.addElement(rc);
        }

        ResourceCollection[] fss = new ResourceCollection[vfss.size()];
        vfss.copyInto(fss);
        boolean success = false;
        try {
            
            ArchiveState state = getResourcesToAdd(fss, zipFile, false);

            
            if (!state.isOutOfDate()) {
                return;
            }

            if (!zipFile.exists() && state.isWithoutAnyResources()) {
                createEmptyZip(zipFile);
                return;
            }
            Resource[][] addThem = state.getResourcesToAdd();

            if (doUpdate) {
                renamedFile =
                    FILE_UTILS.createTempFile(""zip"", "".tmp"",
                                              zipFile.getParentFile());
                renamedFile.deleteOnExit();

                try {
                    FILE_UTILS.rename(zipFile, renamedFile);
                } catch (SecurityException e) {
                    throw new BuildException(
                        ""Not allowed to rename old file (""
                        + zipFile.getAbsolutePath()
                        + "") to temporary file"");
                } catch (IOException e) {
                    throw new BuildException(
                        ""Unable to rename old file (""
                        + zipFile.getAbsolutePath()
                        + "") to temporary file"");
                }
            }

            String action = doUpdate ? ""Updating "" : ""Building "";

            log(action + archiveType + "": "" + zipFile.getAbsolutePath());

            ZipOutputStream zOut = null;
            try {
                if (!skipWriting) {
                    zOut = new ZipOutputStream(zipFile);

                    zOut.setEncoding(encoding);
                    zOut.setMethod(doCompress
                        ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
                    zOut.setLevel(level);
                }
                initZipOutputStream(zOut);

                
                for (int i = 0; i < fss.length; i++) {
                    if (addThem[i].length != 0) {
                        addResources(fss[i], addThem[i], zOut);
                    }
                }

                if (doUpdate) {
                    addingNewFiles = false;
                    ZipFileSet oldFiles = new ZipFileSet();
                    oldFiles.setProject(getProject());
                    oldFiles.setSrc(renamedFile);
                    oldFiles.setDefaultexcludes(false);

                    for (int i = 0; i < addedFiles.size(); i++) {
                        PatternSet.NameEntry ne = oldFiles.createExclude();
                        ne.setName((String) addedFiles.elementAt(i));
                    }
                    DirectoryScanner ds =
                        oldFiles.getDirectoryScanner(getProject());
                    ((ZipScanner) ds).setEncoding(encoding);

                    String[] f = ds.getIncludedFiles();
                    Resource[] r = new Resource[f.length];
                    for (int i = 0; i < f.length; i++) {
                        r[i] = ds.getResource(f[i]);
                    }

                    if (!doFilesonly) {
                        String[] d = ds.getIncludedDirectories();
                        Resource[] dr = new Resource[d.length];
                        for (int i = 0; i < d.length; i++) {
                            dr[i] = ds.getResource(d[i]);
                        }
                        Resource[] tmp = r;
                        r = new Resource[tmp.length + dr.length];
                        System.arraycopy(dr, 0, r, 0, dr.length);
                        System.arraycopy(tmp, 0, r, dr.length, tmp.length);
                    }
                    addResources(oldFiles, r, zOut);
                }
                if (zOut != null) {
                    zOut.setComment(comment);
                }
                finalizeZipOutputStream(zOut);

                
                
                if (doUpdate) {
                    if (!renamedFile.delete()) {
                        log (""Warning: unable to delete temporary file ""
                            + renamedFile.getName(), Project.MSG_WARN);
                    }
                }
                success = true;
            } finally {
                
                try {
                    if (zOut != null) {
                        zOut.close();
                    }
                } catch (IOException ex) {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    if (success) {
                        throw ex;
                    }
                }
            }
        } catch (IOException ioe) {
            String msg = ""Problem creating "" + archiveType + "": ""
                + ioe.getMessage();

            
            if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
                msg += "" (and the archive is probably corrupt but I could not ""
                    + ""delete it)"";
            }

            if (doUpdate && renamedFile != null) {
                try {
                    FILE_UTILS.rename(renamedFile, zipFile);
                } catch (IOException e) {
                    msg += "" (and I couldn't rename the temporary file ""
                            + renamedFile.getName() + "" back)"";
                }
            }

            throw new BuildException(msg, ioe, getLocation());
        } finally {
            cleanUp();
        }
    }

    
    protected final boolean isAddingNewFiles() {
        return addingNewFiles;
    }

    
    protected final void addResources(FileSet fileset, Resource[] resources,
                                      ZipOutputStream zOut)
        throws IOException {

        String prefix = """";
        String fullpath = """";
        int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
        int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;

        ArchiveFileSet zfs = null;
        if (fileset instanceof ArchiveFileSet) {
            zfs = (ArchiveFileSet) fileset;
            prefix = zfs.getPrefix(getProject());
            fullpath = zfs.getFullpath(getProject());
            dirMode = zfs.getDirMode(getProject());
            fileMode = zfs.getFileMode(getProject());
        }

        if (prefix.length() > 0 && fullpath.length() > 0) {
            throw new BuildException(""Both prefix and fullpath attributes must""
                                     + "" not be set on the same fileset."");
        }

        if (resources.length != 1 && fullpath.length() > 0) {
            throw new BuildException(""fullpath attribute may only be specified""
                                     + "" for filesets that specify a single""
                                     + "" file."");
        }

        if (prefix.length() > 0) {
            if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
                prefix += ""/"";
            }
            addParentDirs(null, prefix, zOut, """", dirMode);
        }

        ZipFile zf = null;
        try {
            boolean dealingWithFiles = false;
            File base = null;

            if (zfs == null || zfs.getSrc(getProject()) == null) {
                dealingWithFiles = true;
                base = fileset.getDir(getProject());
            } else if (zfs instanceof ZipFileSet) {
                zf = new ZipFile(zfs.getSrc(getProject()), encoding);
            }

            for (int i = 0; i < resources.length; i++) {
                String name = null;
                if (fullpath.length() > 0) {
                    name = fullpath;
                } else {
                    name = resources[i].getName();
                }
                name = name.replace(File.separatorChar, '/');

                if ("""".equals(name)) {
                    continue;
                }
                if (resources[i].isDirectory() && !name.endsWith(""/"")) {
                    name = name + ""/"";
                }

                if (!doFilesonly && !dealingWithFiles
                    && resources[i].isDirectory()
                    && !zfs.hasDirModeBeenSet()) {
                    int nextToLastSlash = name.lastIndexOf(""/"",
                                                           name.length() - 2);
                    if (nextToLastSlash != -1) {
                        addParentDirs(base, name.substring(0,
                                                           nextToLastSlash + 1),
                                      zOut, prefix, dirMode);
                    }
                    if (zf != null) {
                        ZipEntry ze = zf.getEntry(resources[i].getName());
                        addParentDirs(base, name, zOut, prefix,
                                      ze.getUnixMode());
                    } else {
                        ArchiveResource tr = (ArchiveResource) resources[i];
                        addParentDirs(base, name, zOut, prefix,
                                      tr.getMode());
                    }

                } else {
                    addParentDirs(base, name, zOut, prefix, dirMode);
                }

                if (!resources[i].isDirectory() && dealingWithFiles) {
                    File f = FILE_UTILS.resolveFile(base,
                                                   resources[i].getName());
                    zipFile(f, zOut, prefix + name, fileMode);
                } else if (!resources[i].isDirectory()) {
                    if (zf != null) {
                    ZipEntry ze = zf.getEntry(resources[i].getName());

                    if (ze != null) {
                        boolean oldCompress = doCompress;
                        if (keepCompression) {
                            doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
                        }
                        try {
                            zipFile(zf.getInputStream(ze), zOut, prefix + name,
                                    ze.getTime(), zfs.getSrc(getProject()),
                                    zfs.hasFileModeBeenSet() ? fileMode
                                    : ze.getUnixMode());
                        } finally {
                            doCompress = oldCompress;
                        }
                    }
                    } else {
                        ArchiveResource tr = (ArchiveResource) resources[i];
                        InputStream is = null;
                        try {
                            is = tr.getInputStream();
                            zipFile(is, zOut, prefix + name,
                                    resources[i].getLastModified(),
                                    zfs.getSrc(getProject()),
                                    zfs.hasFileModeBeenSet() ? fileMode
                                    : tr.getMode());
                        } finally {
                            FileUtils.close(is);
                        }
                    }
                }
            }
        } finally {
            if (zf != null) {
                zf.close();
            }
        }
    }

    
    protected final void addResources(ResourceCollection rc,
                                      Resource[] resources,
                                      ZipOutputStream zOut)
        throws IOException {
        if (rc instanceof FileSet) {
            addResources((FileSet) rc, resources, zOut);
            return;
        }
        for (int i = 0; i < resources.length; i++) {
            String name = resources[i].getName().replace(File.separatorChar,
                                                         '/');
            if ("""".equals(name)) {
                continue;
            }
            if (resources[i].isDirectory() && doFilesonly) {
                continue;
            }
            File base = null;
            if (resources[i] instanceof FileResource) {
                base = ((FileResource) resources[i]).getBaseDir();
            }
            if (resources[i].isDirectory()) {
                if (!name.endsWith(""/"")) {
                    name = name + ""/"";
                }
            }

            addParentDirs(base, name, zOut, """",
                          ArchiveFileSet.DEFAULT_DIR_MODE);

            if (!resources[i].isDirectory()) {
                if (resources[i] instanceof FileResource) {
                    File f = ((FileResource) resources[i]).getFile();
                    zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
                } else {
                    InputStream is = null;
                    try {
                        is = resources[i].getInputStream();
                        zipFile(is, zOut, name,
                                resources[i].getLastModified(),
                                null, ArchiveFileSet.DEFAULT_FILE_MODE);
                    } finally {
                        FileUtils.close(is);
                    }
                }
            }
        }
    }

    
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException {
    }

    
    protected void finalizeZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException {
    }

    
    protected boolean createEmptyZip(File zipFile) throws BuildException {
        
        
        
        log(""Note: creating empty "" + archiveType + "" archive "" + zipFile,
            Project.MSG_INFO);
        OutputStream os = null;
        try {
            os = new FileOutputStream(zipFile);
            
            byte[] empty = new byte[22];
            empty[0] = 80; 
            empty[1] = 75; 
            empty[2] = 5;
            empty[3] = 6;
            
            os.write(empty);
        } catch (IOException ioe) {
            throw new BuildException(""Could not create empty ZIP archive ""
                                     + ""("" + ioe.getMessage() + "")"", ioe,
                                     getLocation());
        } finally {
            if (os != null) {
                try {
                    os.close();
                } catch (IOException e) {
                    
                }
            }
        }
        return true;
    }

    
    private synchronized ZipScanner getZipScanner() {
        if (zs == null) {
            zs = new ZipScanner();
            zs.setEncoding(encoding);
            zs.setSrc(zipFile);
        }
        return zs;
    }

    
    protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs,
                                             File zipFile,
                                             boolean needsUpdate)
        throws BuildException {
        ArrayList filesets = new ArrayList();
        ArrayList rest = new ArrayList();
        for (int i = 0; i < rcs.length; i++) {
            if (rcs[i] instanceof FileSet) {
                filesets.add(rcs[i]);
            } else {
                rest.add(rcs[i]);
            }
        }
        ResourceCollection[] rc = (ResourceCollection[])
            rest.toArray(new ResourceCollection[rest.size()]);
        ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile,
                                                      needsUpdate);

        FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets
                                                                .size()]);
        ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
        if (!as.isOutOfDate() && as2.isOutOfDate()) {
            
            as = getNonFileSetResourcesToAdd(rc, zipFile, true);
        }

        Resource[][] toAdd = new Resource[rcs.length][];
        int fsIndex = 0;
        int restIndex = 0;
        for (int i = 0; i < rcs.length; i++) {
            if (rcs[i] instanceof FileSet) {
                toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
            } else {
                toAdd[i] = as.getResourcesToAdd()[restIndex++];
            }
        }
        return new ArchiveState(as2.isOutOfDate(), toAdd);
    }

    
    protected ArchiveState getResourcesToAdd(FileSet[] filesets,
                                             File zipFile,
                                             boolean needsUpdate)
        throws BuildException {

        Resource[][] initialResources = grabResources(filesets);
        if (isEmpty(initialResources)) {
            if (needsUpdate && doUpdate) {
                
                return new ArchiveState(true, initialResources);
            }

            if (emptyBehavior.equals(""skip"")) {
                if (doUpdate) {
                    log(archiveType + "" archive "" + zipFile
                        + "" not updated because no new files were included."",
                        Project.MSG_VERBOSE);
                } else {
                    log(""Warning: skipping "" + archiveType + "" archive ""
                        + zipFile + "" because no files were included."",
                        Project.MSG_WARN);
                }
            } else if (emptyBehavior.equals(""fail"")) {
                throw new BuildException(""Cannot create "" + archiveType
                                         + "" archive "" + zipFile
                                         + "": no files were included."",
                                         getLocation());
            } else {
                
                if (!zipFile.exists())  {
                    needsUpdate = true;
                }
            }
            return new ArchiveState(needsUpdate, initialResources);
        }

        

        if (!zipFile.exists()) {
            return new ArchiveState(true, initialResources);
        }

        if (needsUpdate && !doUpdate) {
            
            return new ArchiveState(true, initialResources);
        }

        Resource[][] newerResources = new Resource[filesets.length][];

        for (int i = 0; i < filesets.length; i++) {
            if (!(fileset instanceof ZipFileSet)
                || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
                File base = filesets[i].getDir(getProject());

                for (int j = 0; j < initialResources[i].length; j++) {
                    File resourceAsFile =
                        FILE_UTILS.resolveFile(base,
                                              initialResources[i][j].getName());
                    if (resourceAsFile.equals(zipFile)) {
                        throw new BuildException(""A zip file cannot include ""
                                                 + ""itself"", getLocation());
                    }
                }
            }
        }

        for (int i = 0; i < filesets.length; i++) {
            if (initialResources[i].length == 0) {
                newerResources[i] = new Resource[] {};
                continue;
            }

            FileNameMapper myMapper = new IdentityMapper();
            if (filesets[i] instanceof ZipFileSet) {
                ZipFileSet zfs = (ZipFileSet) filesets[i];
                if (zfs.getFullpath(getProject()) != null
                    && !zfs.getFullpath(getProject()).equals("""")) {
                    
                    
                    
                    MergingMapper fm = new MergingMapper();
                    fm.setTo(zfs.getFullpath(getProject()));
                    myMapper = fm;

                } else if (zfs.getPrefix(getProject()) != null
                           && !zfs.getPrefix(getProject()).equals("""")) {
                    GlobPatternMapper gm = new GlobPatternMapper();
                    gm.setFrom(""*"");
                    String prefix = zfs.getPrefix(getProject());
                    if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
                        prefix += ""/"";
                    }
                    gm.setTo(prefix + ""*"");
                    myMapper = gm;
                }
            }

            Resource[] resources = initialResources[i];
            if (doFilesonly) {
                resources = selectFileResources(resources);
            }

            newerResources[i] =
                ResourceUtils.selectOutOfDateSources(this,
                                                     resources,
                                                     myMapper,
                                                     getZipScanner());
            needsUpdate = needsUpdate || (newerResources[i].length > 0);

            if (needsUpdate && !doUpdate) {
                
                
                break;
            }
        }

        if (needsUpdate && !doUpdate) {
            
            return new ArchiveState(true, initialResources);
        }

        return new ArchiveState(needsUpdate, newerResources);
    }

    
    protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs,
                                                       File zipFile,
                                                       boolean needsUpdate)
        throws BuildException {
        

        Resource[][] initialResources = grabNonFileSetResources(rcs);
        if (isEmpty(initialResources)) {
            
            
            return new ArchiveState(needsUpdate, initialResources);
        }

        

        if (!zipFile.exists()) {
            return new ArchiveState(true, initialResources);
        }

        if (needsUpdate && !doUpdate) {
            
            return new ArchiveState(true, initialResources);
        }

        Resource[][] newerResources = new Resource[rcs.length][];

        for (int i = 0; i < rcs.length; i++) {
            if (initialResources[i].length == 0) {
                newerResources[i] = new Resource[] {};
                continue;
            }

            for (int j = 0; j < initialResources[i].length; j++) {
                if (initialResources[i][j] instanceof FileResource
                    && zipFile.equals(((FileResource)
                                       initialResources[i][j]).getFile())) {
                    throw new BuildException(""A zip file cannot include ""
                                             + ""itself"", getLocation());
                }
            }

            Resource[] rs = initialResources[i];
            if (doFilesonly) {
                rs = selectFileResources(rs);
            }

            newerResources[i] =
                ResourceUtils.selectOutOfDateSources(this,
                                                     rs,
                                                     new IdentityMapper(),
                                                     getZipScanner());
            needsUpdate = needsUpdate || (newerResources[i].length > 0);

            if (needsUpdate && !doUpdate) {
                
                
                break;
            }
        }

        if (needsUpdate && !doUpdate) {
            
            return new ArchiveState(true, initialResources);
        }

        return new ArchiveState(needsUpdate, newerResources);
    }

    
    protected Resource[][] grabResources(FileSet[] filesets) {
        Resource[][] result = new Resource[filesets.length][];
        for (int i = 0; i < filesets.length; i++) {
            boolean skipEmptyNames = true;
            if (filesets[i] instanceof ZipFileSet) {
                ZipFileSet zfs = (ZipFileSet) filesets[i];
                skipEmptyNames = zfs.getPrefix(getProject()).equals("""")
                    && zfs.getFullpath(getProject()).equals("""");
            }
            DirectoryScanner rs =
                filesets[i].getDirectoryScanner(getProject());
            if (rs instanceof ZipScanner) {
                ((ZipScanner) rs).setEncoding(encoding);
            }
            Vector resources = new Vector();
            if (!doFilesonly) {
                String[] directories = rs.getIncludedDirectories();
                for (int j = 0; j < directories.length; j++) {
                    if (!"""".equals(directories[j]) || !skipEmptyNames) {
                        resources.addElement(rs.getResource(directories[j]));
                    }
                }
            }
            String[] files = rs.getIncludedFiles();
            for (int j = 0; j < files.length; j++) {
                if (!"""".equals(files[j]) || !skipEmptyNames) {
                    resources.addElement(rs.getResource(files[j]));
                }
            }

            result[i] = new Resource[resources.size()];
            resources.copyInto(result[i]);
        }
        return result;
    }

    
    protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
        Resource[][] result = new Resource[rcs.length][];
        for (int i = 0; i < rcs.length; i++) {
            Iterator iter = rcs[i].iterator();
            ArrayList rs = new ArrayList();
            int lastDir = 0;
            while (iter.hasNext()) {
                Resource r = (Resource) iter.next();
                if (r.isExists()) {
                    if (r.isDirectory()) {
                        rs.add(lastDir++, r);
                    } else {
                        rs.add(r);
                    }
                }
            }
            result[i] = (Resource[]) rs.toArray(new Resource[rs.size()]);
        }
        return result;
    }

    
    protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                          int mode)
        throws IOException {
        zipDir(dir, zOut, vPath, mode, null);
    }

    
    protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                          int mode, ZipExtraField[] extra)
        throws IOException {
        if (doFilesonly) {
            log(""skipping directory "" + vPath + "" for file-only archive"",
                    Project.MSG_VERBOSE);
            return;
        }
        if (addedDirs.get(vPath) != null) {
            
            
            return;
        }

        log(""adding directory "" + vPath, Project.MSG_VERBOSE);
        addedDirs.put(vPath, vPath);

        if (!skipWriting) {
            ZipEntry ze = new ZipEntry (vPath);
            if (dir != null && dir.exists()) {
                
                ze.setTime(dir.lastModified() + (roundUp ? 1999 : 0));
            } else {
                
                ze.setTime(System.currentTimeMillis() + (roundUp ? 1999 : 0));
            }
            ze.setSize (0);
            ze.setMethod (ZipEntry.STORED);
            
            ze.setCrc (EMPTY_CRC);
            ze.setUnixMode(mode);

            if (extra != null) {
                ze.setExtraFields(extra);
            }

            zOut.putNextEntry(ze);
        }
    }

    
    protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath,
                           long lastModified, File fromArchive, int mode)
        throws IOException {
        if (entries.contains(vPath)) {

            if (duplicate.equals(""preserve"")) {
                log(vPath + "" already added, skipping"", Project.MSG_INFO);
                return;
            } else if (duplicate.equals(""fail"")) {
                throw new BuildException(""Duplicate file "" + vPath
                                         + "" was found and the duplicate ""
                                         + ""attribute is 'fail'."");
            } else {
                
                log(""duplicate file "" + vPath
                    + "" found, adding."", Project.MSG_VERBOSE);
            }
        } else {
            log(""adding entry "" + vPath, Project.MSG_VERBOSE);
        }

        entries.put(vPath, vPath);

        if (!skipWriting) {
            ZipEntry ze = new ZipEntry(vPath);
            ze.setTime(lastModified);
            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);

            
            if (!zOut.isSeekable() && !doCompress) {
                long size = 0;
                CRC32 cal = new CRC32();
                if (!in.markSupported()) {
                    
                    ByteArrayOutputStream bos = new ByteArrayOutputStream();

                    byte[] buffer = new byte[8 * 1024];
                    int count = 0;
                    do {
                        size += count;
                        cal.update(buffer, 0, count);
                        bos.write(buffer, 0, count);
                        count = in.read(buffer, 0, buffer.length);
                    } while (count != -1);
                    in = new ByteArrayInputStream(bos.toByteArray());

                } else {
                    in.mark(Integer.MAX_VALUE);
                    byte[] buffer = new byte[8 * 1024];
                    int count = 0;
                    do {
                        size += count;
                        cal.update(buffer, 0, count);
                        count = in.read(buffer, 0, buffer.length);
                    } while (count != -1);
                    in.reset();
                }
                ze.setSize(size);
                ze.setCrc(cal.getValue());
            }

            ze.setUnixMode(mode);
            zOut.putNextEntry(ze);

            byte[] buffer = new byte[8 * 1024];
            int count = 0;
            do {
                if (count != 0) {
                    zOut.write(buffer, 0, count);
                }
                count = in.read(buffer, 0, buffer.length);
            } while (count != -1);
        }
        addedFiles.addElement(vPath);
    }

    
    protected void zipFile(File file, ZipOutputStream zOut, String vPath,
                           int mode)
        throws IOException {
        if (file.equals(zipFile)) {
            throw new BuildException(""A zip file cannot include itself"",
                                     getLocation());
        }

        FileInputStream fIn = new FileInputStream(file);
        try {
            
            zipFile(fIn, zOut, vPath,
                    file.lastModified() + (roundUp ? 1999 : 0),
                    null, mode);
        } finally {
            fIn.close();
        }
    }

    
    protected final void addParentDirs(File baseDir, String entry,
                                       ZipOutputStream zOut, String prefix,
                                       int dirMode)
        throws IOException {
        if (!doFilesonly) {
            Stack directories = new Stack();
            int slashPos = entry.length();

            while ((slashPos = entry.lastIndexOf('/', slashPos - 1)) != -1) {
                String dir = entry.substring(0, slashPos + 1);
                if (addedDirs.get(prefix + dir) != null) {
                    break;
                }
                directories.push(dir);
            }

            while (!directories.isEmpty()) {
                String dir = (String) directories.pop();
                File f = null;
                if (baseDir != null) {
                    f = new File(baseDir, dir);
                } else {
                    f = new File(dir);
                }
                zipDir(f, zOut, prefix + dir, dirMode);
            }
        }
    }

    
    protected void cleanUp() {
        addedDirs.clear();
        addedFiles.removeAllElements();
        entries.clear();
        addingNewFiles = false;
        doUpdate = savedDoUpdate;
        Enumeration e = filesetsFromGroupfilesets.elements();
        while (e.hasMoreElements()) {
            ZipFileSet zf = (ZipFileSet) e.nextElement();
            resources.removeElement(zf);
        }
        filesetsFromGroupfilesets.removeAllElements();
    }

    
    public void reset() {
        resources.removeAllElements();
        zipFile = null;
        baseDir = null;
        groupfilesets.removeAllElements();
        duplicate = ""add"";
        archiveType = ""zip"";
        doCompress = true;
        emptyBehavior = ""skip"";
        doUpdate = false;
        doFilesonly = false;
        encoding = null;
    }

    
    protected static final boolean isEmpty(Resource[][] r) {
        for (int i = 0; i < r.length; i++) {
            if (r[i].length > 0) {
                return false;
            }
        }
        return true;
    }

    
    protected Resource[] selectFileResources(Resource[] orig) {
        if (orig.length == 0) {
            return orig;
        }

        Vector v = new Vector(orig.length);
        for (int i = 0; i < orig.length; i++) {
            if (!orig[i].isDirectory()) {
                v.addElement(orig[i]);
            } else {
                log(""Ignoring directory "" + orig[i].getName()
                    + "" as only files will be added."", Project.MSG_VERBOSE);
            }
        }

        if (v.size() != orig.length) {
            Resource[] r = new Resource[v.size()];
            v.copyInto(r);
            return r;
        }
        return orig;
    }

    
    public static class Duplicate extends EnumeratedAttribute {
        
        
        public String[] getValues() {
            return new String[] {""add"", ""preserve"", ""fail""};
        }
    }

    
    public static class ArchiveState {
        private boolean outOfDate;
        private Resource[][] resourcesToAdd;

        ArchiveState(boolean state, Resource[][] r) {
            outOfDate = state;
            resourcesToAdd = r;
        }

        
        public boolean isOutOfDate() {
            return outOfDate;
        }

        
        public Resource[][] getResourcesToAdd() {
            return resourcesToAdd;
        }
        
        public boolean isWithoutAnyResources() {
            if (resourcesToAdd == null)  {
                return true;
            }
            for (int counter = 0; counter < resourcesToAdd.length; counter++) {
                if (resourcesToAdd[counter] != null) {
                    if (resourcesToAdd[counter].length > 0) {
                        return false;
                    }
                }
            }
            return true;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.unix.AbstractAccessTask,6,5,2,8,21,15,2,6,5,2.0,83,0.0,0,0.955357143,0.416666667,1,1,12.83333333,3,1.1667,1,"



package org.apache.tools.ant.taskdefs.optional.unix;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.FileSet;



public abstract class AbstractAccessTask
    extends org.apache.tools.ant.taskdefs.ExecuteOn {

    
    public AbstractAccessTask() {
        super.setParallel(true);
        super.setSkipEmptyFilesets(true);
    }

    
    public void setFile(File src) {
        FileSet fs = new FileSet();
        fs.setFile(src);
        addFileset(fs);
    }

    
    public void setCommand(Commandline cmdl) {
        throw new BuildException(getTaskType()
                                 + "" doesn\'t support the command attribute"",
                                 getLocation());
    }

    
    public void setSkipEmptyFilesets(boolean skip) {
        throw new BuildException(getTaskType() + "" doesn\'t support the ""
                                 + ""skipemptyfileset attribute"",
                                 getLocation());
    }

    
    public void setAddsourcefile(boolean b) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the addsourcefile attribute"", getLocation());
    }

    
    protected boolean isValidOs() {
        return Os.isFamily(""unix"") && super.isValidOs();
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.ExtensionSet,7,3,0,11,28,0,2,9,7,0.25,122,1.0,0,0.833333333,0.285714286,1,1,16.14285714,1,0.8571,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.util.ArrayList;
import java.util.Arrays;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Reference;


public class ExtensionSet
    extends DataType {
    
    private final ArrayList extensions = new ArrayList();

    
    private final ArrayList extensionsFilesets = new ArrayList();

    
    public void addExtension(final ExtensionAdapter extensionAdapter) {
        extensions.add(extensionAdapter);
    }

    
    public void addLibfileset(final LibFileSet fileSet) {
        extensionsFilesets.add(fileSet);
    }

    
    public void addFileset(final FileSet fileSet) {
        extensionsFilesets.add(fileSet);
    }

    
    public Extension[] toExtensions(final Project proj)
        throws BuildException {
        final ArrayList extensionsList = ExtensionUtil.toExtensions(extensions);
        ExtensionUtil.extractExtensions(proj, extensionsList, extensionsFilesets);
        return (Extension[]) extensionsList.toArray(new Extension[extensionsList.size()]);
    }

    
    public void setRefid(final Reference reference)
        throws BuildException {
        if (!extensions.isEmpty() || !extensionsFilesets.isEmpty()) {
            throw tooManyAttributes();
        }
        
        final Object object =
            reference.getReferencedObject(getProject());
        if (object instanceof ExtensionSet) {
            final ExtensionSet other = (ExtensionSet) object;
            extensions.addAll(other.extensions);
            extensionsFilesets.addAll(other.extensionsFilesets);
        } else {
            final String message =
                reference.getRefId() + "" doesn\'t refer to a ExtensionSet"";
            throw new BuildException(message);
        }

        super.setRefid(reference);
    }

    
    public String toString() {
        return ""ExtensionSet"" + Arrays.asList(toExtensions(getProject()));
    }
}
"
org.apache.tools.ant.types.resources.selectors.Or,3,4,0,4,9,3,1,3,3,2.0,27,0.0,0,0.972222222,0.555555556,0,0,8.0,3,1.0,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.util.Iterator;

import org.apache.tools.ant.types.Resource;


public class Or extends ResourceSelectorContainer implements ResourceSelector {

    
    public Or() {
    }

    
    public Or(ResourceSelector[] r) {
        super(r);
    }

    
    public boolean isSelected(Resource r) {
        for (Iterator i = getSelectors(); i.hasNext();) {
            if (((ResourceSelector) i.next()).isSelected(r)) {
                return true;
            }
        }
        return false;
    }

}
"
org.apache.tools.bzip2.BZip2Constants,1,1,0,2,1,0,2,0,0,2.0,2064,0.0,0,0.0,0.0,0,0,2052.0,0,0.0,0,"



package org.apache.tools.bzip2;


public interface BZip2Constants {

    int baseBlockSize = 100000;
    int MAX_ALPHA_SIZE = 258;
    int MAX_CODE_LEN = 23;
    int RUNA = 0;
    int RUNB = 1;
    int N_GROUPS = 6;
    int G_SIZE = 50;
    int N_ITERS = 4;
    int MAX_SELECTORS = (2 + (900000 / G_SIZE));
    int NUM_OVERSHOOT_BYTES = 20;

    
    int[] rNums = {
        619, 720, 127, 481, 931, 816, 813, 233, 566, 247,
        985, 724, 205, 454, 863, 491, 741, 242, 949, 214,
        733, 859, 335, 708, 621, 574, 73, 654, 730, 472,
        419, 436, 278, 496, 867, 210, 399, 680, 480, 51,
        878, 465, 811, 169, 869, 675, 611, 697, 867, 561,
        862, 687, 507, 283, 482, 129, 807, 591, 733, 623,
        150, 238, 59, 379, 684, 877, 625, 169, 643, 105,
        170, 607, 520, 932, 727, 476, 693, 425, 174, 647,
        73, 122, 335, 530, 442, 853, 695, 249, 445, 515,
        909, 545, 703, 919, 874, 474, 882, 500, 594, 612,
        641, 801, 220, 162, 819, 984, 589, 513, 495, 799,
        161, 604, 958, 533, 221, 400, 386, 867, 600, 782,
        382, 596, 414, 171, 516, 375, 682, 485, 911, 276,
        98, 553, 163, 354, 666, 933, 424, 341, 533, 870,
        227, 730, 475, 186, 263, 647, 537, 686, 600, 224,
        469, 68, 770, 919, 190, 373, 294, 822, 808, 206,
        184, 943, 795, 384, 383, 461, 404, 758, 839, 887,
        715, 67, 618, 276, 204, 918, 873, 777, 604, 560,
        951, 160, 578, 722, 79, 804, 96, 409, 713, 940,
        652, 934, 970, 447, 318, 353, 859, 672, 112, 785,
        645, 863, 803, 350, 139, 93, 354, 99, 820, 908,
        609, 772, 154, 274, 580, 184, 79, 626, 630, 742,
        653, 282, 762, 623, 680, 81, 927, 626, 789, 125,
        411, 521, 938, 300, 821, 78, 343, 175, 128, 250,
        170, 774, 972, 275, 999, 639, 495, 78, 352, 126,
        857, 956, 358, 619, 580, 124, 737, 594, 701, 612,
        669, 112, 134, 694, 363, 992, 809, 743, 168, 974,
        944, 375, 748, 52, 600, 747, 642, 182, 862, 81,
        344, 805, 988, 739, 511, 655, 814, 334, 249, 515,
        897, 955, 664, 981, 649, 113, 974, 459, 893, 228,
        433, 837, 553, 268, 926, 240, 102, 654, 459, 51,
        686, 754, 806, 760, 493, 403, 415, 394, 687, 700,
        946, 670, 656, 610, 738, 392, 760, 799, 887, 653,
        978, 321, 576, 617, 626, 502, 894, 679, 243, 440,
        680, 879, 194, 572, 640, 724, 926, 56, 204, 700,
        707, 151, 457, 449, 797, 195, 791, 558, 945, 679,
        297, 59, 87, 824, 713, 663, 412, 693, 342, 606,
        134, 108, 571, 364, 631, 212, 174, 643, 304, 329,
        343, 97, 430, 751, 497, 314, 983, 374, 822, 928,
        140, 206, 73, 263, 980, 736, 876, 478, 430, 305,
        170, 514, 364, 692, 829, 82, 855, 953, 676, 246,
        369, 970, 294, 750, 807, 827, 150, 790, 288, 923,
        804, 378, 215, 828, 592, 281, 565, 555, 710, 82,
        896, 831, 547, 261, 524, 462, 293, 465, 502, 56,
        661, 821, 976, 991, 658, 869, 905, 758, 745, 193,
        768, 550, 608, 933, 378, 286, 215, 979, 792, 961,
        61, 688, 793, 644, 986, 403, 106, 366, 905, 644,
        372, 567, 466, 434, 645, 210, 389, 550, 919, 135,
        780, 773, 635, 389, 707, 100, 626, 958, 165, 504,
        920, 176, 193, 713, 857, 265, 203, 50, 668, 108,
        645, 990, 626, 197, 510, 357, 358, 850, 858, 364,
        936, 638
    };
}
"
org.apache.tools.ant.util.GlobPatternMapper,8,1,2,5,22,6,4,1,6,0.678571429,185,1.0,0,0.0,0.625,0,0,21.125,4,1.875,3,"

package org.apache.tools.ant.util;


public class GlobPatternMapper implements FileNameMapper {

    
    
    protected String fromPrefix = null;

    
    protected String fromPostfix = null;

    
    protected int prefixLength;

    
    protected int postfixLength;

    
    protected String toPrefix = null;

    
    protected String toPostfix = null;

    

    private boolean handleDirSep = false;
    private boolean caseSensitive = true;

    
    public void setHandleDirSep(boolean handleDirSep) {
        this.handleDirSep = handleDirSep;
    }

    
    public void setCaseSensitive(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
    }

    
    public void setFrom(String from) {
        int index = from.lastIndexOf(""*"");
        if (index == -1) {
            fromPrefix = from;
            fromPostfix = """";
        } else {
            fromPrefix = from.substring(0, index);
            fromPostfix = from.substring(index + 1);
        }
        prefixLength = fromPrefix.length();
        postfixLength = fromPostfix.length();
    }

    
    public void setTo(String to) {
        int index = to.lastIndexOf(""*"");
        if (index == -1) {
            toPrefix = to;
            toPostfix = """";
        } else {
            toPrefix = to.substring(0, index);
            toPostfix = to.substring(index + 1);
        }
    }

    
    public String[] mapFileName(String sourceFileName) {
        if (fromPrefix == null
            || !modifyName(sourceFileName).startsWith(modifyName(fromPrefix))
            || !modifyName(sourceFileName).endsWith(modifyName(fromPostfix))) {
            return null;
        }
        return new String[] {toPrefix
                                 + extractVariablePart(sourceFileName)
                                 + toPostfix};
    }

    
    protected String extractVariablePart(String name) {
        return name.substring(prefixLength,
                              name.length() - postfixLength);
    }

    
    private String modifyName(String name) {
        if (!caseSensitive) {
            name = name.toLowerCase();
        }
        if (handleDirSep) {
            if (name.indexOf('\\') != -1) {
                name = name.replace('\\', '/');
            }
        }
        return name;
    }
}
"
org.apache.tools.ant.taskdefs.War,11,6,0,6,34,39,0,6,7,0.9,195,1.0,1,0.944785276,0.3,4,10,16.18181818,5,1.2727,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Locale;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.ZipFileSet;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.zip.ZipOutputStream;



public class War extends Jar {

    
    private File deploymentDescriptor;

    
    private boolean needxmlfile = true;
    private File addedWebXmlFile;

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
    
    private static final String XML_DESCRIPTOR_PATH = ""WEB-INF/web.xml"";
    
    private static final String XML_DESCRIPTOR_PATH_LC =
            XML_DESCRIPTOR_PATH.toLowerCase(Locale.ENGLISH);

    
    public War() {
        super();
        archiveType = ""war"";
        emptyBehavior = ""create"";
    }

    
    public void setWarfile(File warFile) {
        setDestFile(warFile);
    }

    
    public void setWebxml(File descr) {
        deploymentDescriptor = descr;
        if (!deploymentDescriptor.exists()) {
            throw new BuildException(""Deployment descriptor: ""
                                     + deploymentDescriptor
                                     + "" does not exist."");
        }

        
        ZipFileSet fs = new ZipFileSet();
        fs.setFile(deploymentDescriptor);
        fs.setFullpath(XML_DESCRIPTOR_PATH);
        super.addFileset(fs);
    }


    
    public void setNeedxmlfile(boolean needxmlfile) {
        this.needxmlfile = needxmlfile;
    }

    

    public void addLib(ZipFileSet fs) {
        
        fs.setPrefix(""WEB-INF/lib/"");
        super.addFileset(fs);
    }

    
    public void addClasses(ZipFileSet fs) {
        
        fs.setPrefix(""WEB-INF/classes/"");
        super.addFileset(fs);
    }

    
    public void addWebinf(ZipFileSet fs) {
        
        fs.setPrefix(""WEB-INF/"");
        super.addFileset(fs);
    }

    
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException {
        super.initZipOutputStream(zOut);
    }

    
    protected void zipFile(File file, ZipOutputStream zOut, String vPath,
                           int mode)
        throws IOException {
        
        
        
        
        String vPathLowerCase = vPath.toLowerCase(Locale.ENGLISH);
        
        boolean addFile = true;
        if (XML_DESCRIPTOR_PATH_LC.equals(vPathLowerCase)) {
            
            if (addedWebXmlFile != null) {
                
                addFile = false;
                
                if (!FILE_UTILS.fileNameEquals(addedWebXmlFile, file)) {
                    log(""Warning: selected "" + archiveType
                            + "" files include a second "" + XML_DESCRIPTOR_PATH
                            + "" which will be ignored.\n""
                            + ""The duplicate entry is at "" + file + '\n'
                            + ""The file that will be used is ""
                            + addedWebXmlFile,
                            Project.MSG_WARN);
                }
            } else {
                
                addedWebXmlFile = file;
                
                addFile = true;
                
                deploymentDescriptor = file;
            }
        }
        if (addFile) {
            super.zipFile(file, zOut, vPath, mode);
        }
    }


    
    protected void cleanUp() {
        if (addedWebXmlFile == null
            && deploymentDescriptor == null
            && needxmlfile
            && !isInUpdateMode()) {
            throw new BuildException(""No WEB-INF/web.xml file was added.\n""
                    + ""If this is your intent, set needxml='false' "");
        }
        addedWebXmlFile = null;
        super.cleanUp();
    }
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSADD,8,4,0,6,26,22,0,6,6,0.571428571,95,1.0,0,0.928571429,0.40625,1,1,10.75,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class MSVSSADD extends MSVSS {

    private String localPath = null;

    
    protected Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getLocalpath() == null) {
            String msg = ""localPath attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_ADD);

        
        commandLine.createArgument().setValue(getLocalpath());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(getRecursive());
        
        commandLine.createArgument().setValue(getWritable());
        
        commandLine.createArgument().setValue(getLogin());
        
        commandLine.createArgument().setValue(getComment());

        return commandLine;
    }

    
    protected String getLocalpath() {
        return localPath;
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public final void setWritable(boolean writable) {
        super.setInternalWritable(writable);
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }

    
    public void setComment(String comment) {
        super.setInternalComment(comment);
    }

    
    public void setLocalpath(Path localPath) {
        this.localPath = localPath.toString();
    }
}
"
org.apache.tools.ant.types.Permissions,12,1,0,8,34,26,6,3,6,0.651515152,341,1.0,0,0.0,0.3125,0,0,26.91666667,1,0.8333,0,"

package org.apache.tools.ant.types;

import java.security.UnresolvedPermission;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ExitException;


public class Permissions {

    private List grantedPermissions = new LinkedList();
    private List revokedPermissions = new LinkedList();
    private java.security.Permissions granted = null;
    private SecurityManager origSm = null;
    private boolean active = false;
    private boolean delegateToOldSM;

    
    public Permissions() {
        this(false);
    }

    
    public Permissions(boolean delegateToOldSM) {
        this.delegateToOldSM = delegateToOldSM;
    }

    
    public void addConfiguredGrant(Permissions.Permission perm) {
        grantedPermissions.add(perm);
    }

    
    public void addConfiguredRevoke(Permissions.Permission perm) {
        revokedPermissions.add(perm);
    }

    
    public synchronized void setSecurityManager() throws BuildException {
        origSm = System.getSecurityManager();
        init();
        System.setSecurityManager(new MySM());
        active = true;
    }

    
    private void init() throws BuildException {
        granted = new java.security.Permissions();
        for (Iterator i = revokedPermissions.listIterator(); i.hasNext();) {
            Permissions.Permission p = (Permissions.Permission) i.next();
            if (p.getClassName() == null) {
                throw new BuildException(""Revoked permission "" + p + "" does not contain a class."");
            }
        }
        for (Iterator i = grantedPermissions.listIterator(); i.hasNext();) {
            Permissions.Permission p = (Permissions.Permission) i.next();
            if (p.getClassName() == null) {
                throw new BuildException(""Granted permission "" + p + "" does not contain a class."");
            } else {
                java.security.Permission perm =
                    new UnresolvedPermission(p.getClassName(), p.getName(), p.getActions(), null);
                granted.add(perm);
            }
        }
        
        granted.add(new java.net.SocketPermission(""localhost:1024-"", ""listen""));
        granted.add(new java.util.PropertyPermission(""java.version"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vendor"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vendor.url"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.class.version"", ""read""));
        granted.add(new java.util.PropertyPermission(""os.name"", ""read""));
        granted.add(new java.util.PropertyPermission(""os.version"", ""read""));
        granted.add(new java.util.PropertyPermission(""os.arch"", ""read""));
        granted.add(new java.util.PropertyPermission(""file.encoding"", ""read""));
        granted.add(new java.util.PropertyPermission(""file.separator"", ""read""));
        granted.add(new java.util.PropertyPermission(""path.separator"", ""read""));
        granted.add(new java.util.PropertyPermission(""line.separator"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.specification.version"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.specification.vendor"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.specification.name"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vm.specification.version"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vm.specification.vendor"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vm.specification.name"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vm.version"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vm.vendor"", ""read""));
        granted.add(new java.util.PropertyPermission(""java.vm.name"", ""read""));
    }

    
    public synchronized void restoreSecurityManager() {
        active = false;
        System.setSecurityManager(origSm);
    }

    
    private class MySM extends SecurityManager {

        
        public void checkExit(int status) {
            java.security.Permission perm = new java.lang.RuntimePermission(""exitVM"", null);
            try {
                checkPermission(perm);
            } catch (SecurityException e) {
                throw new ExitException(e.getMessage(), status);
            }
        }

        
        public void checkPermission(java.security.Permission perm) {
            if (active) {
                if (delegateToOldSM && !perm.getName().equals(""exitVM"")) {
                    boolean permOK = false;
                    if (granted.implies(perm)) {
                        permOK = true;
                    }
                    checkRevoked(perm);
                    
                    if (!permOK && origSm != null) {
                        origSm.checkPermission(perm);
                    }
                }  else {
                    if (!granted.implies(perm)) {
                        throw new SecurityException(""Permission "" + perm + "" was not granted."");
                    }
                    checkRevoked(perm);
                }
            }
        }

        
        private void checkRevoked(java.security.Permission perm) {
            for (Iterator i = revokedPermissions.listIterator(); i.hasNext();) {
                if (((Permissions.Permission) i.next()).matches(perm)) {
                    throw new SecurityException(""Permission "" + perm + "" was revoked."");
                }
            }

        }
    }

    
    public static class Permission {
        private String className;
        private String name;
        private String actionString;
        private Set actions;

        
        public void setClass(String aClass) {
                className = aClass.trim();
        }

        
        public String getClassName() {
            return className;
        }

        
        public void setName(String aName) {
            name = aName.trim();
        }

        
        public String getName() {
            return name;
        }

        
        public void setActions(String actions) {
            actionString = actions;
            if (actions.length() > 0) {
                this.actions = parseActions(actions);
            }
        }

        
        public String getActions() {
            return actionString;
        }

        
        boolean matches(java.security.Permission perm) {
            if (!className.equals(perm.getClass().getName())) {
                return false;
            }
            if (name != null) {
                if (name.endsWith(""*"")) {
                    if (!perm.getName().startsWith(name.substring(0, name.length() - 1))) {
                        return false;
                    }
                } else {
                    if (!name.equals(perm.getName())) {
                        return false;
                    }
                }
            }
            if (actions != null) {
                Set as = parseActions(perm.getActions());
                int size = as.size();
                as.removeAll(actions);
                if (as.size() == size) {
                    
                    return false;
                }
            }
            return true;
        }

        
        private Set parseActions(String actions) {
            Set result = new HashSet();
            StringTokenizer tk = new StringTokenizer(actions, "","");
            while (tk.hasMoreTokens()) {
                String item = tk.nextToken().trim();
                if (!item.equals("""")) {
                    result.add(item);
                }
            }
            return result;
        }

        
        public String toString() {
            return (""Permission: "" + className + "" (\"""" + name + ""\"", \"""" + actions + ""\"")"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.condition.HasFreeSpace,7,1,0,5,16,0,0,5,6,0.5,86,1.0,0,0.0,0.642857143,0,0,11.0,1,0.8571,0,"

package org.apache.tools.ant.taskdefs.condition;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.ReflectWrapper;
import org.apache.tools.ant.util.StringUtils;


public class HasFreeSpace implements Condition {

    private String partition;
    private String needed;

    public boolean eval() throws BuildException {
        validate();
        try {
            if (JavaEnvUtils.isAtLeastJavaVersion(""1.6"")) {
                
                File fs = new File(partition);
                ReflectWrapper w = new ReflectWrapper(fs);
                long free = ((Long)w.invoke(""getFreeSpace"")).longValue();
                return free >= StringUtils.parseHumanSizes(needed);
            } else {
                throw new BuildException(""HasFreeSpace condition not supported on Java5 or less."");
            }
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }

    private void validate() throws BuildException {
        if(null == partition) {
            throw new BuildException(""Please set the partition attribute."");
        }
        if(null == needed) {
            throw new BuildException(""Please set the needed attribute."");
        }
    }
    
    
    public String getPartition() {
        return partition;
    }

    public void setPartition(String partition) {
        this.partition = partition;
    }

    
    public String getNeeded() {
        return needed;
    }

    public void setNeeded(String needed) {
        this.needed = needed;
    }
}
"
org.apache.tools.ant.taskdefs.email.UUMailer,2,3,0,3,15,1,0,3,0,2.0,58,0.0,0,0.952380952,0.666666667,1,1,28.0,1,0.5,0,"
package org.apache.tools.ant.taskdefs.email;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.UUEncoder;


class UUMailer extends PlainMailer {
    protected void attach(File file, PrintStream out)
         throws IOException {
        if (!file.exists() || !file.canRead()) {
            throw new BuildException(""File \"""" + file.getName()
                 + ""\"" does not exist or is not ""
                 + ""readable."");
        }

        FileInputStream finstr = new FileInputStream(file);

        try {
            BufferedInputStream in = new BufferedInputStream(finstr);
            UUEncoder encoder = new UUEncoder(file.getName());

            encoder.encode(in, out);

        } finally {
            finstr.close();
        }
    }
}

"
org.apache.tools.ant.types.resources.selectors.ResourceSelector,1,1,0,26,1,0,25,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.types.Resource;


public interface ResourceSelector {

    
    boolean isSelected(Resource r);

}
"
org.apache.tools.ant.util.ResourceUtils,14,1,0,30,96,87,8,23,10,0.884615385,905,1.0,2,0.0,0.192307692,0,0,63.5,10,1.7143,1,"
package org.apache.tools.ant.util;

import java.io.File;
import java.io.Reader;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.BufferedInputStream;
import java.util.Arrays;
import java.util.Vector;
import java.util.Iterator;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.filters.util.ChainReaderHelper;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.TimeComparison;
import org.apache.tools.ant.types.ResourceFactory;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.FilterSetCollection;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.resources.Restrict;
import org.apache.tools.ant.types.resources.Resources;
import org.apache.tools.ant.types.resources.Touchable;
import org.apache.tools.ant.types.resources.selectors.Or;
import org.apache.tools.ant.types.resources.selectors.And;
import org.apache.tools.ant.types.resources.selectors.Not;
import org.apache.tools.ant.types.resources.selectors.Date;
import org.apache.tools.ant.types.resources.selectors.Type;
import org.apache.tools.ant.types.resources.selectors.Exists;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.types.selectors.SelectorUtils;




public class ResourceUtils {

    private static final class Outdated implements ResourceSelector {
        private Resource control;
        private long granularity;
        private Outdated(Resource control, long granularity) {
            this.control = control;
            this.granularity = granularity;
        }
        public boolean isSelected(Resource r) {
            return SelectorUtils.isOutOfDate(control, r, granularity);
        }
    }
    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private static final ResourceSelector NOT_EXISTS = new Not(new Exists());

    
    public static Resource[] selectOutOfDateSources(ProjectComponent logTo,
                                                    Resource[] source,
                                                    FileNameMapper mapper,
                                                    ResourceFactory targets) {
        return selectOutOfDateSources(logTo, source, mapper, targets,
                                      FILE_UTILS.getFileTimestampGranularity());
    }

    
    public static Resource[] selectOutOfDateSources(ProjectComponent logTo,
                                                    Resource[] source,
                                                    FileNameMapper mapper,
                                                    ResourceFactory targets,
                                                    long granularity) {
        Union u = new Union();
        u.addAll(Arrays.asList(source));
        ResourceCollection rc
            = selectOutOfDateSources(logTo, u, mapper, targets, granularity);
        return rc.size() == 0 ? new Resource[0] : ((Union) rc).listResources();
    }

    
    public static ResourceCollection selectOutOfDateSources(ProjectComponent logTo,
                                                            ResourceCollection source,
                                                            FileNameMapper mapper,
                                                            ResourceFactory targets,
                                                            long granularity) {
        if (source.size() == 0) {
            logTo.log(""No sources found."", Project.MSG_VERBOSE);
            return Resources.NONE;
        }
        source = Union.getInstance(source);
        logFuture(logTo, source, granularity);

        Union result = new Union();
        for (Iterator iter = source.iterator(); iter.hasNext();) {
            Resource sr = (Resource) iter.next();
            String srName = sr.getName();
            srName = srName == null
                ? srName : srName.replace('/', File.separatorChar);

            String[] targetnames = null;
            try {
                targetnames = mapper.mapFileName(srName);
            } catch (Exception e) {
		logTo.log(""Caught "" + e + "" mapping resource "" + sr,
                    Project.MSG_VERBOSE);
            }
            if (targetnames == null || targetnames.length == 0) {
                logTo.log(sr + "" skipped - don\'t know how to handle it"",
                      Project.MSG_VERBOSE);
                continue;
            }
            Union targetColl = new Union();
            for (int i = 0; i < targetnames.length; i++) {
                targetColl.add(targets.getResource(
                    targetnames[i].replace(File.separatorChar, '/')));
            }
            
            Restrict r = new Restrict();
            r.add(new And(new ResourceSelector[] {Type.FILE, new Or(
                new ResourceSelector[] {NOT_EXISTS, new Outdated(sr, granularity)})}));
            r.add(targetColl);
            if (r.size() > 0) {
                result.add(sr);
                Resource t = (Resource) (r.iterator().next());
                logTo.log(sr.getName() + "" added as "" + t.getName()
                    + (t.isExists() ? "" is outdated."" : "" doesn\'t exist.""),
                    Project.MSG_VERBOSE);
                continue;
            }
            
            logTo.log(sr.getName()
                  + "" omitted as "" + targetColl.toString()
                  + (targetColl.size() == 1 ? "" is"" : "" are "")
                  + "" up to date."", Project.MSG_VERBOSE);
        }
        return result;
    }

    
    public static void copyResource(Resource source, Resource dest) throws IOException {
        copyResource(source, dest, null);
    }

    
    public static void copyResource(Resource source, Resource dest, Project project)
        throws IOException {
        copyResource(source, dest, null, null, false,
                     false, null, null, project);
    }

    
    
    public static void copyResource(Resource source, Resource dest,
                             FilterSetCollection filters, Vector filterChains,
                             boolean overwrite, boolean preserveLastModified,
                             String inputEncoding, String outputEncoding,
                             Project project)
        throws IOException {
        if (!overwrite) {
            long slm = source.getLastModified();
            if (dest.isExists() && slm != 0
                && dest.getLastModified() > slm) {
                return;
            }
        }
        final boolean filterSetsAvailable = (filters != null
                                             && filters.hasFilters());
        final boolean filterChainsAvailable = (filterChains != null
                                               && filterChains.size() > 0);
        if (filterSetsAvailable) {
            BufferedReader in = null;
            BufferedWriter out = null;
            try {
                InputStreamReader isr = null;
                if (inputEncoding == null) {
                    isr = new InputStreamReader(source.getInputStream());
                } else {
                    isr = new InputStreamReader(source.getInputStream(),
                                                inputEncoding);
                }
                in = new BufferedReader(isr);
                OutputStreamWriter osw = null;
                if (outputEncoding == null) {
                    osw = new OutputStreamWriter(dest.getOutputStream());
                } else {
                    osw = new OutputStreamWriter(dest.getOutputStream(),
                                                 outputEncoding);
                }
                out = new BufferedWriter(osw);
                if (filterChainsAvailable) {
                    ChainReaderHelper crh = new ChainReaderHelper();
                    crh.setBufferSize(FileUtils.BUF_SIZE);
                    crh.setPrimaryReader(in);
                    crh.setFilterChains(filterChains);
                    crh.setProject(project);
                    Reader rdr = crh.getAssembledReader();
                    in = new BufferedReader(rdr);
                }
                LineTokenizer lineTokenizer = new LineTokenizer();
                lineTokenizer.setIncludeDelims(true);
                String newline = null;
                String line = lineTokenizer.getToken(in);
                while (line != null) {
                    if (line.length() == 0) {
                        
                        
                        out.newLine();
                    } else {
                        newline = filters.replaceTokens(line);
                        out.write(newline);
                    }
                    line = lineTokenizer.getToken(in);
                }
            } finally {
                FileUtils.close(out);
                FileUtils.close(in);
            }
        } else if (filterChainsAvailable
                   || (inputEncoding != null
                       && !inputEncoding.equals(outputEncoding))
                   || (inputEncoding == null && outputEncoding != null)) {
            BufferedReader in = null;
            BufferedWriter out = null;
            try {
                InputStreamReader isr = null;
                if (inputEncoding == null) {
                    isr = new InputStreamReader(source.getInputStream());
                } else {
                    isr = new InputStreamReader(source.getInputStream(),
                                                inputEncoding);
                }
                in = new BufferedReader(isr);
                OutputStreamWriter osw = null;
                if (outputEncoding == null) {
                    osw = new OutputStreamWriter(dest.getOutputStream());
                } else {
                    osw = new OutputStreamWriter(dest.getOutputStream(),
                                                 outputEncoding);
                }
                out = new BufferedWriter(osw);
                if (filterChainsAvailable) {
                    ChainReaderHelper crh = new ChainReaderHelper();
                    crh.setBufferSize(FileUtils.BUF_SIZE);
                    crh.setPrimaryReader(in);
                    crh.setFilterChains(filterChains);
                    crh.setProject(project);
                    Reader rdr = crh.getAssembledReader();
                    in = new BufferedReader(rdr);
                }
                char[] buffer = new char[FileUtils.BUF_SIZE];
                while (true) {
                    int nRead = in.read(buffer, 0, buffer.length);
                    if (nRead == -1) {
                        break;
                    }
                    out.write(buffer, 0, nRead);
                }
            } finally {
                FileUtils.close(out);
                FileUtils.close(in);
            }
        } else {
            InputStream in = null;
            OutputStream out = null;
            try {
                in = source.getInputStream();
                out = dest.getOutputStream();

                byte[] buffer = new byte[FileUtils.BUF_SIZE];
                int count = 0;
                do {
                    out.write(buffer, 0, count);
                    count = in.read(buffer, 0, buffer.length);
                } while (count != -1);
            } finally {
                FileUtils.close(out);
                FileUtils.close(in);
            }
        }
        if (preserveLastModified && dest instanceof Touchable) {
            setLastModified((Touchable) dest, source.getLastModified());
        }
    }
    

    
    public static void setLastModified(Touchable t, long time) {
        t.touch((time < 0) ? System.currentTimeMillis() : time);
    }

    
    public static boolean contentEquals(Resource r1, Resource r2, boolean text) throws IOException {
        if (r1.isExists() != r2.isExists()) {
            return false;
        }
        if (!r1.isExists()) {
            
            return true;
        }
        
        
        if (r1.isDirectory() || r2.isDirectory()) {
            
            return false;
        }
        if (r1.equals(r2)) {
            return true;
        }
        if (!text && r1.getSize() != r2.getSize()) {
            return false;
        }
        return compareContent(r1, r2, text) == 0;
    }

    
    public static int compareContent(Resource r1, Resource r2, boolean text) throws IOException {
        if (r1.equals(r2)) {
            return 0;
        }
        boolean e1 = r1.isExists();
        boolean e2 = r2.isExists();
        if (!(e1 || e2)) {
            return 0;
        }
        if (e1 != e2) {
            return e1 ? 1 : -1;
        }
        boolean d1 = r1.isDirectory();
        boolean d2 = r2.isDirectory();
        if (d1 && d2) {
            return 0;
        }
        if (d1 || d2) {
            return d1 ? -1 : 1;
        }
        return text ? textCompare(r1, r2) : binaryCompare(r1, r2);
    }

    
    private static int binaryCompare(Resource r1, Resource r2) throws IOException {
        InputStream in1 = null;
        InputStream in2 = null;
        try {
            in1 = new BufferedInputStream(r1.getInputStream());
            in2 = new BufferedInputStream(r2.getInputStream());

            for (int b1 = in1.read(); b1 != -1; b1 = in1.read()) {
                int b2 = in2.read();
                if (b1 != b2) {
                    return b1 > b2 ? 1 : -1;
                }
            }
            return in2.read() == -1 ? 0 : -1;
        } finally {
            FileUtils.close(in1);
            FileUtils.close(in2);
        }
    }

    
    private static int textCompare(Resource r1, Resource r2) throws IOException {
        BufferedReader in1 = null;
        BufferedReader in2 = null;
        try {
            in1 = new BufferedReader(new InputStreamReader(r1.getInputStream()));
            in2 = new BufferedReader(new InputStreamReader(r2.getInputStream()));

            String expected = in1.readLine();
            while (expected != null) {
                String actual = in2.readLine();
                if (!expected.equals(actual)) {
                    return expected.compareTo(actual);
                }
                expected = in1.readLine();
            }
            return in2.readLine() == null ? 0 : -1;
        } finally {
            FileUtils.close(in1);
            FileUtils.close(in2);
        }
    }

    
    private static void logFuture(ProjectComponent logTo,
                                  ResourceCollection rc, long granularity) {
        long now = System.currentTimeMillis() + granularity;
        Date sel = new Date();
        sel.setMillis(now);
        sel.setWhen(TimeComparison.AFTER);
        Restrict future = new Restrict();
        future.add(sel);
        future.add(rc);
        for (Iterator iter = future.iterator(); iter.hasNext();) {
            logTo.log(""Warning: "" + ((Resource) iter.next()).getName()
                     + "" modified in the future."", Project.MSG_WARN);
        }
    }

}
"
org.apache.tools.ant.AntTypeDefinition,21,1,2,14,47,124,10,4,18,0.7,575,0.857142857,0,0.0,0.325396825,0,0,26.04761905,10,2.619,0,"

package org.apache.tools.ant;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Constructor;



public class AntTypeDefinition {
    private String      name;
    private Class       clazz;
    private Class       adapterClass;
    private Class       adaptToClass;
    private String      className;
    private ClassLoader classLoader;

    
    public void setName(String name) {
        this.name = name;
    }

    
    public String getName() {
        return name;
    }

    
    public void setClass(Class clazz) {
        this.clazz = clazz;
        if (clazz == null) {
            return;
        }
        this.classLoader = (classLoader == null)
            ? clazz.getClassLoader() : classLoader;
        this.className = (className == null) ? clazz.getName() : className;
    }

    
    public void setClassName(String className) {
        this.className = className;
    }

    
    public String getClassName() {
        return className;
    }

    
    public void setAdapterClass(Class adapterClass) {
        this.adapterClass = adapterClass;
    }

    

    public void setAdaptToClass(Class adaptToClass) {
        this.adaptToClass = adaptToClass;
    }

    
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    
    public Class getExposedClass(Project project) {
        if (adaptToClass != null) {
            Class z = getTypeClass(project);
            if (z == null || adaptToClass.isAssignableFrom(z)) {
                return z;
            }
        }
        return (adapterClass == null) ? getTypeClass(project) :  adapterClass;
    }

    
    public Class getTypeClass(Project project) {
        try {
            return innerGetTypeClass();
        } catch (NoClassDefFoundError ncdfe) {
            project.log(""Could not load a dependent class (""
                        + ncdfe.getMessage() + "") for type ""
                        + name, Project.MSG_DEBUG);
        } catch (ClassNotFoundException cnfe) {
            project.log(""Could not load class ("" + className
                        + "") for type "" + name, Project.MSG_DEBUG);
        }
        return null;
    }

    
    public Class innerGetTypeClass() throws ClassNotFoundException {
        if (clazz != null) {
            return clazz;
        }
        if (classLoader == null) {
            clazz = Class.forName(className);
        } else {
            clazz = classLoader.loadClass(className);
        }
        return clazz;
    }

    
    public Object create(Project project) {
        return icreate(project);
    }

    
    private Object icreate(Project project) {
        Class c = getTypeClass(project);
        if (c == null) {
            return null;
        }
        Object o = createAndSet(project, c);
        if (o == null || adapterClass == null) {
            return o;
        }
        if (adaptToClass != null) {
            if (adaptToClass.isAssignableFrom(o.getClass())) {
                return o;
            }
        }
        TypeAdapter adapterObject = (TypeAdapter) createAndSet(
            project, adapterClass);
        if (adapterObject == null) {
            return null;
        }
        adapterObject.setProxy(o);
        return adapterObject;
    }

    
    public void checkClass(Project project) {
        if (clazz == null) {
            clazz = getTypeClass(project);
            if (clazz == null) {
                throw new BuildException(
                    ""Unable to create class for "" + getName());
            }
        }
        
        if (adapterClass != null && (adaptToClass == null
            || !adaptToClass.isAssignableFrom(clazz))) {
            TypeAdapter adapter = (TypeAdapter) createAndSet(
                project, adapterClass);
            if (adapter == null) {
                throw new BuildException(""Unable to create adapter object"");
            }
            adapter.checkProxyClass(clazz);
        }
    }

    
    private Object createAndSet(Project project, Class c) {
        try {
            Object o = innerCreateAndSet(c, project);
            return o;
        } catch (InvocationTargetException ex) {
            Throwable t = ex.getTargetException();
            throw new BuildException(
                ""Could not create type "" + name + "" due to "" + t, t);
        } catch (NoClassDefFoundError ncdfe) {
            String msg = ""Type "" + name + "": A class needed by class ""
                + c + "" cannot be found: "" + ncdfe.getMessage();
            throw new BuildException(msg, ncdfe);
        } catch (NoSuchMethodException nsme) {
            throw new BuildException(""Could not create type "" + name
                    + "" as the class "" + c + "" has no compatible constructor"");
        } catch (InstantiationException nsme) {
            throw new BuildException(""Could not create type ""
                    + name + "" as the class "" + c + "" is abstract"");
        } catch (IllegalAccessException e) {
            throw new BuildException(""Could not create type ""
                    + name + "" as the constructor "" + c + "" is not accessible"");
        } catch (Throwable t) {
            throw new BuildException(
                ""Could not create type "" + name + "" due to "" + t, t);
        }
    }

    
    public Object innerCreateAndSet(Class newclass, Project project)
            throws NoSuchMethodException,
            InstantiationException,
            IllegalAccessException,
            InvocationTargetException {
        Constructor ctor = null;
        boolean noArg = false;
        
        
        try {
            ctor = newclass.getConstructor(new Class[0]);
            noArg = true;
        } catch (NoSuchMethodException nse) {
            
            ctor = newclass.getConstructor(new Class[] {Project.class});
            noArg = false;
        }
        
        Object o = ctor.newInstance(
            ((noArg) ? new Object[0] : new Object[] {project}));

        
        project.setProjectReference(o);
        return o;
    }

    
    public boolean sameDefinition(AntTypeDefinition other, Project project) {
        return (other != null && other.getClass() == getClass()
            && other.getTypeClass(project).equals(getTypeClass(project))
            && other.getExposedClass(project).equals(getExposedClass(project))
            && other.adapterClass == adapterClass
            && other.adaptToClass == adaptToClass);
    }

    
    public boolean similarDefinition(AntTypeDefinition other, Project project) {
        if (other == null
            || getClass() != other.getClass()
            || !getClassName().equals(other.getClassName())
            || !extractClassname(adapterClass).equals(
            extractClassname(other.adapterClass))
            || !extractClassname(adaptToClass).equals(
            extractClassname(other.adaptToClass))) {
            return false;
        }
        
        
        ClassLoader oldLoader = other.getClassLoader();
        ClassLoader newLoader = getClassLoader();
        return oldLoader == newLoader
            || (oldLoader instanceof AntClassLoader
            && newLoader instanceof AntClassLoader
            && ((AntClassLoader) oldLoader).getClasspath()
            .equals(((AntClassLoader) newLoader).getClasspath()));
    }

    private String extractClassname(Class c) {
        return (c == null) ? ""<null>"" : c.getClass().getName();
    }
}
"
org.apache.tools.ant.taskdefs.AntlibDefinition,5,3,3,6,12,2,4,2,5,0.625,48,1.0,0,0.902439024,0.466666667,0,0,8.2,1,0.8,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.Task;


public class AntlibDefinition extends Task {

    private String uri = """";
    private ClassLoader antlibClassLoader;

    
    public void setURI(String uri) throws BuildException {
        if (uri.equals(ProjectHelper.ANT_CORE_URI)) {
            uri = """";
        }
        if (uri.startsWith(""ant:"")) {
            throw new BuildException(""Attempt to use a reserved URI "" + uri);
        }
        this.uri = uri;
    }

    
    public String getURI() {
        return uri;
    }

    
    public void setAntlibClassLoader(ClassLoader classLoader) {
        this.antlibClassLoader = classLoader;
    }

    
    public ClassLoader getAntlibClassLoader() {
        return antlibClassLoader;
    }
}
"
org.apache.tools.ant.taskdefs.optional.j2ee.WebLogicHotDeploymentTool,13,2,0,8,37,60,1,8,7,0.833333333,331,1.0,0,0.56,0.416666667,2,3,24.07692308,4,1.3077,0,"

package org.apache.tools.ant.taskdefs.optional.j2ee;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Java;


public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool
                                       implements HotDeploymentTool {
    
    private static final String WEBLOGIC_DEPLOY_CLASS_NAME = ""weblogic.deploy"";

    
    private static final String[] VALID_ACTIONS
        = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};

    
    private boolean debug;

    
    private String application;

    
    private String component;

    
    public void deploy() {
        Java java = new Java(getTask());
        java.setFork(true);
        java.setFailonerror(true);
        java.setClasspath(getClasspath());

        java.setClassname(WEBLOGIC_DEPLOY_CLASS_NAME);
        java.createArg().setLine(getArguments());
        java.execute();
    }

    
    public void validateAttributes() throws BuildException {
        super.validateAttributes();

        String action = getTask().getAction();

        
        if ((getPassword() == null)) {
            throw new BuildException(""The password attribute must be set."");
        }

        
        if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE))
            && application == null) {
            throw new BuildException(""The application attribute must be set ""
                + ""if action = "" + action);
        }

        
        if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE))
            && getTask().getSource() == null) {
            throw new BuildException(""The source attribute must be set if ""
                + ""action = "" + action);
        }

        
        if ((action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY))
            && application == null) {
            throw new BuildException(""The application attribute must be set if ""
                + ""action = "" + action);
        }
    }

    
    public String getArguments() throws BuildException {
        String action = getTask().getAction();
        String args = null;

        if (action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)) {
            args = buildDeployArgs();
        } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {
            args = buildUndeployArgs();
        } else if (action.equals(ACTION_LIST)) {
            args = buildListArgs();
        }

        return args;
    }

    
    protected boolean isActionValid() {
        boolean valid = false;

        String action = getTask().getAction();

        for (int i = 0; i < VALID_ACTIONS.length; i++) {
            if (action.equals(VALID_ACTIONS[i])) {
                valid = true;
                break;
            }
        }

        return valid;
    }

    
    protected StringBuffer buildArgsPrefix() {
        ServerDeploy task = getTask();
        
        
        return new StringBuffer(1024)
                .append((getServer() != null)
                    ? ""-url "" + getServer()
                    : """")
                .append("" "")
                .append(debug ? ""-debug "" : """")
                .append((getUserName() != null)
                    ? ""-username "" + getUserName()
                    : """")
                .append("" "")
                .append(task.getAction()).append("" "")
                .append(getPassword()).append("" "");
    }

    
    protected String buildDeployArgs() {
        String args = buildArgsPrefix()
                .append(application).append("" "")
                .append(getTask().getSource())
                .toString();

        if (component != null) {
            args = ""-component "" + component + "" "" + args;
        }

        return args;
    }

    
    protected String buildUndeployArgs() {
        return buildArgsPrefix()
                .append(application).append("" "")
                .toString();
    }

    
    protected String buildListArgs() {
        return buildArgsPrefix()
                .toString();
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public void setApplication(String application) {
        this.application = application;
    }

    
    public void setComponent(String component) {
        this.component = component;
    }
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSLABEL,6,4,0,5,25,15,0,5,5,2.0,94,0.0,0,0.947916667,0.833333333,1,1,14.66666667,3,1.1667,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;


public class MSVSSLABEL extends MSVSS {

    
    Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getVsspath() == null) {
            throw new BuildException(""vsspath attribute must be set!"", getLocation());
        }

        String label = getLabel();
        if (label.equals("""")) {
            String msg = ""label attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_LABEL);

        
        commandLine.createArgument().setValue(getVsspath());
        
        commandLine.createArgument().setValue(getComment());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(label);
        
        commandLine.createArgument().setValue(getVersion());
        
        commandLine.createArgument().setValue(getLogin());

        return commandLine;
    }

    
    public void setLabel(String label) {
        super.setInternalLabel(label);
    }

    
    public void setVersion(String version) {
        super.setInternalVersion(version);
    }

    
    public void setComment(String comment) {
        super.setInternalComment(comment);
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }
}
"
org.apache.tools.ant.types.selectors.ExtendFileSelector,0,1,0,4,0,0,2,2,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.tools.ant.types.selectors;

import org.apache.tools.ant.types.Parameterizable;


public interface ExtendFileSelector extends FileSelector, Parameterizable {

    
    
}

"
org.apache.tools.ant.util.optional.JavaxScriptRunner,6,2,0,4,34,11,0,4,5,0.6,236,0.333333333,1,0.827586207,0.666666667,1,2,37.83333333,6,1.6667,1,"

package org.apache.tools.ant.util.optional;

import org.apache.tools.ant.BuildException;


import java.util.Iterator;
import org.apache.tools.ant.util.ScriptRunnerBase;
import org.apache.tools.ant.util.ReflectUtil;
import org.apache.tools.ant.util.ReflectWrapper;


public class JavaxScriptRunner extends ScriptRunnerBase {
    private ReflectWrapper engine;

    
    public String getManagerName() {
        return ""javax"";
    }

    
    public boolean supportsLanguage() {
        if (engine != null) {
            return true;
        }
        checkLanguage();
        ClassLoader origLoader = replaceContextLoader();
        try {
            return createEngine() != null;
        } catch (Exception ex) {
            return false;
        } finally {
            restoreContextLoader(origLoader);
        }
    }

    
    public void executeScript(String execName) throws BuildException {
        evaluateScript(execName);
    }

    
    public Object evaluateScript(String execName) throws BuildException {
        checkLanguage();
        ClassLoader origLoader = replaceContextLoader();
        try {
            ReflectWrapper engine = createEngine();
            if (engine == null) {
                throw new BuildException(
                    ""Unable to create javax script engine for ""
                    + getLanguage());
            }
            for (Iterator i = getBeans().keySet().iterator(); i.hasNext();) {
                String key = (String) i.next();
                Object value = getBeans().get(key);
                engine.invoke(
                    ""put"", String.class, key, Object.class, value);
            }
            
            return engine.invoke(""eval"", String.class, getScript());
        } catch (Exception be) {
            Throwable t = be;
            Throwable te = (Throwable) ReflectUtil.invoke(be, ""getCause"");
            if (te != null) {
                if  (te instanceof BuildException) {
                    throw (BuildException) te;
                } else {
                    t = te;
                }
            }
            throw new BuildException(t);
        } finally {
            restoreContextLoader(origLoader);
        }
    }

    private ReflectWrapper createEngine() throws Exception {
        if (engine != null) {
            return engine;
        }
        ReflectWrapper manager = new ReflectWrapper(
            getClass().getClassLoader(), ""javax.script.ScriptEngineManager"");
        Object e = manager.invoke(
            ""getEngineByName"", String.class, getLanguage());
        if (e == null) {
            return null;
        }
        ReflectWrapper ret = new ReflectWrapper(e);
        if (getKeepEngine()) {
            this.engine = ret;
        }
        return ret;
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Change,5,4,0,6,17,6,2,6,5,0.75,94,1.0,0,0.927272727,0.6,2,2,17.4,3,1.2,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class P4Change extends P4Base {
    

    protected String emptyChangeList = null;
    protected String description = ""AutoSubmit By Ant"";
    

    
    public void execute() throws BuildException {

        if (emptyChangeList == null) {
            emptyChangeList = getEmptyChangeList();
        }
        final Project myProj = getProject();

        P4Handler handler = new P4HandlerAdapter() {
            public void process(String line) {
                if (util.match(""/Change/"", line)) {

                    
                    line = util.substitute(""s/[^0-9]

                    int changenumber = Integer.parseInt(line);
                    log(""Change Number is "" + changenumber, Project.MSG_INFO);
                    myProj.setProperty(""p4.change"", """" + changenumber);

                } else if (util.match(""/error/"", line)) {
                    throw new BuildException(""Perforce Error, check client settings and/or server"");
                }

            }
        };

        handler.setOutput(emptyChangeList);

        execP4Command(""change -i"", handler);
    }

    
    public String getEmptyChangeList() throws BuildException {
        final StringBuffer stringbuf = new StringBuffer();

        execP4Command(""change -o"", new P4HandlerAdapter() {
            public void process(String line) {
                if (!util.match(""/^#/"", line)) {
                    if (util.match(""/error/"", line)) {
                        log(""Client Error"", Project.MSG_VERBOSE);
                        throw new BuildException(""Perforce Error, ""
                        + ""check client settings and/or server"");
                    } else if (util.match(""/<enter description here>/"", line)) {
                        
                        description = backslash(description);
                        line = util.substitute(""s/<enter description here>/""
                            + description + ""/"", line);
                    } else if (util.match(""/\\/\\
                        
                        return;
                    }
                    stringbuf.append(line);
                    stringbuf.append(""\n"");
                }
            }
        });
        return stringbuf.toString();
    }

    
    public static final String backslash(String value) {
        final StringBuffer buf = new StringBuffer(value.length());
        final int len = value.length();
        for (int i = 0; i < len; i++) {
            char c = value.charAt(i);
            if (c == '/') {
                buf.append('\\');
            }
            buf.append(c);
        }
        return buf.toString();
    }

    
    public void setDescription(String desc) {
        this.description = desc;
    }

} 
"
org.apache.tools.ant.taskdefs.optional.ssh.Scp,24,4,0,14,85,180,0,14,13,0.782608696,741,1.0,0,0.710526316,0.326086957,2,2,29.54166667,7,1.625,4,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;

import java.io.IOException;
import java.io.File;

import java.util.List;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.ArrayList;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.FileSet;


public class Scp extends SSHBase {

    private static final String[] FROM_ATTRS = {
        ""file"", ""localfile"", ""remotefile"" };

    private static final String[] TO_ATTRS = {
        ""todir"", ""localtodir"", ""remotetodir"", ""localtofile"", ""remotetofile"" };

    private String fromUri;
    private String toUri;
    private List fileSets = null;
    private boolean isFromRemote, isToRemote;
    private boolean isSftp = false;

    
    public void setFile(String aFromUri) {
        setFromUri(aFromUri);
        this.isFromRemote = isRemoteUri(this.fromUri);
    }

    
    public void setTodir(String aToUri) {
        setToUri(aToUri);
        this.isToRemote = isRemoteUri(this.toUri);
    }

    
    public void setLocalFile(String aFromUri) {
        setFromUri(aFromUri);
        this.isFromRemote = false;
    }

    
    public void setRemoteFile(String aFromUri) {
        setFromUri(aFromUri);
        this.isFromRemote = true;
     }

    
    public void setLocalTodir(String aToUri) {
        setToUri(aToUri);
        this.isToRemote = false;
    }

    
    public void setRemoteTodir(String aToUri) {
        setToUri(aToUri);
        this.isToRemote = true;
    }

    
    public void setLocalTofile(String aToUri) {
        setToUri(aToUri);
        this.isToRemote = false;
    }

    
    public void setRemoteTofile(String aToUri) {
        setToUri(aToUri);
        this.isToRemote = true;
    }

    
    public void setSftp(boolean yesOrNo) {
        isSftp = yesOrNo;
    }

    
    public void addFileset(FileSet set) {
        if (fileSets == null) {
            fileSets = new LinkedList();
        }
        fileSets.add(set);
    }

    
    public void init() throws BuildException {
        super.init();
        this.toUri = null;
        this.fromUri = null;
        this.fileSets = null;
    }

    
    public void execute() throws BuildException {
        if (toUri == null) {
            throw exactlyOne(TO_ATTRS);
        }
        if (fromUri == null && fileSets == null) {
            throw exactlyOne(FROM_ATTRS, ""one or more nested filesets"");
        }
        try {
            if (isFromRemote && !isToRemote) {
                download(fromUri, toUri);
            } else if (!isFromRemote && isToRemote) {
                if (fileSets != null) {
                    upload(fileSets, toUri);
                } else {
                    upload(fromUri, toUri);
                }
            } else if (isFromRemote && isToRemote) {
                throw new BuildException(
                    ""Copying from a remote server to a remote server is not supported."");
            } else {
                throw new BuildException(""'todir' and 'file' attributes ""
                    + ""must have syntax like the following: ""
                    + ""user:password@host:/path"");
            }
        } catch (Exception e) {
            if (getFailonerror()) {
                throw new BuildException(e);
            } else {
                log(""Caught exception: "" + e.getMessage(), Project.MSG_ERR);
            }
        }
    }

    private void download(String fromSshUri, String toPath)
        throws JSchException, IOException {
        String file = parseUri(fromSshUri);

        Session session = null;
        try {
            session = openSession();
            ScpFromMessage message = null;
            if (!isSftp) {
                message =
                    new ScpFromMessage(getVerbose(), session, file,
                                       getProject().resolveFile(toPath),
                                       fromSshUri.endsWith(""*""));
            } else {
                message =
                    new ScpFromMessageBySftp(getVerbose(), session, file,
                                             getProject().resolveFile(toPath),
                                             fromSshUri.endsWith(""*""));
            }
            log(""Receiving file: "" + file);
            message.setLogListener(this);
            message.execute();
        } finally {
            if (session != null) {
                session.disconnect();
            }
        }
    }

    private void upload(List fileSet, String toSshUri)
        throws IOException, JSchException {
        String file = parseUri(toSshUri);

        Session session = null;
        try {
            List list = new ArrayList(fileSet.size());
            for (Iterator i = fileSet.iterator(); i.hasNext();) {
                FileSet set = (FileSet) i.next();
                Directory d = createDirectory(set);
                if (d != null) {
                    list.add(d);
                }
            }
            if (!list.isEmpty()) {
                session = openSession();
                ScpToMessage message = null;
                if (!isSftp) {
                    message = new ScpToMessage(getVerbose(), session,
                                               list, file);
                } else {
                    message = new ScpToMessageBySftp(getVerbose(), session,
                                                     list, file);
                }
                message.setLogListener(this);
                message.execute();
            }
        } finally {
            if (session != null) {
                session.disconnect();
            }
        }
    }

    private void upload(String fromPath, String toSshUri)
        throws IOException, JSchException {
        String file = parseUri(toSshUri);

        Session session = null;
        try {
            session = openSession();
            ScpToMessage message = null;
            if (!isSftp) {
                message =
                    new ScpToMessage(getVerbose(), session,
                                     getProject().resolveFile(fromPath), file);
            } else {
                message =
                    new ScpToMessageBySftp(getVerbose(), session,
                                           getProject().resolveFile(fromPath),
                                           file);
            }
            message.setLogListener(this);
            message.execute();
        } finally {
            if (session != null) {
                session.disconnect();
            }
        }
    }

    private String parseUri(String uri) {
        int indexOfAt = uri.lastIndexOf('@');
        int indexOfColon = uri.indexOf(':');
        if (indexOfColon > -1 && indexOfColon < indexOfAt) {
            
            setUsername(uri.substring(0, indexOfColon));
            setPassword(uri.substring(indexOfColon + 1, indexOfAt));
        } else {
            
            setUsername(uri.substring(0, indexOfAt));
        }

        if (getUserInfo().getPassword() == null
            && getUserInfo().getPassphrase() == null) {
            throw new BuildException(""neither password nor passphrase for user ""
                                     + getUserInfo().getName() + "" has been ""
                                     + ""given.  Can't authenticate."");
        }

        int indexOfPath = uri.indexOf(':', indexOfAt + 1);
        if (indexOfPath == -1) {
            throw new BuildException(""no remote path in "" + uri);
        }

        setHost(uri.substring(indexOfAt + 1, indexOfPath));
        String remotePath = uri.substring(indexOfPath + 1);
        if (remotePath.equals("""")) {
            remotePath = ""."";
        }
        return remotePath;
    }

    private boolean isRemoteUri(String uri) {
        boolean isRemote = true;
        int indexOfAt = uri.indexOf('@');
        if (indexOfAt < 0) {
            isRemote = false;
        }
        return isRemote;
    }

    private Directory createDirectory(FileSet set) {
        DirectoryScanner scanner = set.getDirectoryScanner(getProject());
        Directory root = new Directory(scanner.getBasedir());
        String[] files = scanner.getIncludedFiles();
        if (files.length != 0) {
            for (int j = 0; j < files.length; j++) {
                String[] path = Directory.getPath(files[j]);
                Directory current = root;
                File currentParent = scanner.getBasedir();
                for (int i = 0; i < path.length; i++) {
                    File file = new File(currentParent, path[i]);
                    if (file.isDirectory()) {
                        current.addDirectory(new Directory(file));
                        current = current.getChild(file);
                        currentParent = current.getDirectory();
                    } else if (file.isFile()) {
                        current.addFile(file);
                    }
                }
            }
        } else {
            
            root = null;
        }
        return root;
    }

    private void setFromUri(String fromUri) {
        if (this.fromUri != null) {
            throw exactlyOne(FROM_ATTRS);
        }
        this.fromUri = fromUri;
    }

    private void setToUri(String toUri) {
        if (this.toUri != null) {
            throw exactlyOne(TO_ATTRS);
        }
        this.toUri = toUri;
    }

    private BuildException exactlyOne(String[] attrs) {
        return exactlyOne(attrs, null);
    }

    private BuildException exactlyOne(String[] attrs, String alt) {
        StringBuffer buf = new StringBuffer(""Exactly one of "").append(
                '[').append(attrs[0]);
        for (int i = 1; i < attrs.length; i++) {
            buf.append('|').append(attrs[i]);
        }
        buf.append(']');
        if (alt != null) {
            buf.append("" or "").append(alt);
        }
        return new BuildException(buf.append("" is required."").toString());
    }
}
"
org.apache.tools.ant.taskdefs.optional.javah.SunJavah,3,1,0,12,38,3,1,11,2,1.5,182,0.0,0,0.0,0.833333333,0,0,59.33333333,12,4.3333,0,"
package org.apache.tools.ant.taskdefs.optional.javah;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.launch.Locator;
import org.apache.tools.ant.taskdefs.ExecuteJava;
import org.apache.tools.ant.taskdefs.optional.Javah;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;



public class SunJavah implements JavahAdapter {

    
    public static final String IMPLEMENTATION_NAME = ""sun"";

    
    public boolean compile(Javah javah) throws BuildException {
        Commandline cmd = setupJavahCommand(javah);
        ExecuteJava ej = new ExecuteJava();
        Class c = null;
        try {
            try {
                
                c = Class.forName(""com.sun.tools.javah.oldjavah.Main"");
            } catch (ClassNotFoundException cnfe) {
                
                c = Class.forName(""com.sun.tools.javah.Main"");
            }
        } catch (ClassNotFoundException ex) {
            throw new BuildException(
                ""Can't load javah"", ex, javah.getLocation());
        }
        cmd.setExecutable(c.getName());
        ej.setJavaCommand(cmd);
        File f = Locator.getClassSource(c);
        if (f != null) {
            ej.setClasspath(new Path(javah.getProject(), f.getPath()));
        }
        return ej.fork(javah) == 0;
    }

    private Commandline setupJavahCommand(Javah javah) {
        Commandline cmd = new Commandline();

        if (javah.getDestdir() != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(javah.getDestdir());
        }

        if (javah.getOutputfile() != null) {
            cmd.createArgument().setValue(""-o"");
            cmd.createArgument().setFile(javah.getOutputfile());
        }

        if (javah.getClasspath() != null) {
            cmd.createArgument().setValue(""-classpath"");
            cmd.createArgument().setPath(javah.getClasspath());
        }

        if (javah.getVerbose()) {
            cmd.createArgument().setValue(""-verbose"");
        }
        if (javah.getOld()) {
            cmd.createArgument().setValue(""-old"");
        }
        if (javah.getForce()) {
            cmd.createArgument().setValue(""-force"");
        }
        if (javah.getStubs() && !javah.getOld()) {
            throw new BuildException(
                ""stubs only available in old mode."", javah.getLocation());
        }

        if (javah.getStubs()) {
            cmd.createArgument().setValue(""-stubs"");
        }
        Path bcp = new Path(javah.getProject());
        if (javah.getBootclasspath() != null) {
            bcp.append(javah.getBootclasspath());
        }
        bcp = bcp.concatSystemBootClasspath(""ignore"");
        if (bcp.size() > 0) {
            cmd.createArgument().setValue(""-bootclasspath"");
            cmd.createArgument().setPath(bcp);
        }

        cmd.addArguments(javah.getCurrentArgs());

        javah.logAndAddFiles(cmd);
        return cmd;
    }

}
"
org.apache.tools.ant.types.CommandlineJava,39,1,0,21,94,461,11,11,33,0.786842105,559,1.0,6,0.0,0.153846154,0,0,13.07692308,7,1.6923,0,"

package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.JavaEnvUtils;

import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Properties;
import java.util.Vector;


public class CommandlineJava implements Cloneable {

    
    private Commandline vmCommand = new Commandline();
    
    private Commandline javaCommand = new Commandline();
    
    private SysProperties sysProperties = new SysProperties();
    private Path classpath = null;
    private Path bootclasspath = null;
    private String vmVersion;
    private String maxMemory = null;
    
    private Assertions assertions = null;

    
     private boolean executeJar = false;

    
    private boolean cloneVm = false;

    
    public static class SysProperties extends Environment implements Cloneable {
        
        
        Properties sys = null;
        
        private Vector propertySets = new Vector();

        
        public String[] getVariables() throws BuildException {

            List definitions = new LinkedList();
            ListIterator list = definitions.listIterator();
            addDefinitionsToList(list);
            if (definitions.size() == 0) {
                return null;
            } else {
                return (String[]) definitions.toArray(new String[definitions.size()]);
            }
        }

        
        public void addDefinitionsToList(ListIterator listIt) {
            String[] props = super.getVariables();
            if (props != null) {
                for (int i = 0; i < props.length; i++) {
                    listIt.add(""-D"" + props[i]);
                }
            }
            Properties propertySetProperties = mergePropertySets();
            for (Enumeration e = propertySetProperties.keys();
                 e.hasMoreElements();) {
                String key = (String) e.nextElement();
                String value = propertySetProperties.getProperty(key);
                listIt.add(""-D"" + key + ""="" + value);
            }
        }

        
        public int size() {
            Properties p = mergePropertySets();
            return variables.size() + p.size();
        }

        
        public void setSystem() throws BuildException {
            try {
                sys = System.getProperties();
                Properties p = new Properties();
                for (Enumeration e = sys.propertyNames(); e.hasMoreElements();) {
                    String name = (String) e.nextElement();
                    p.put(name, sys.getProperty(name));
                }
                p.putAll(mergePropertySets());
                for (Enumeration e = variables.elements(); e.hasMoreElements();) {
                    Environment.Variable v = (Environment.Variable) e.nextElement();
                    v.validate();
                    p.put(v.getKey(), v.getValue());
                }
                System.setProperties(p);
            } catch (SecurityException e) {
                throw new BuildException(""Cannot modify system properties"", e);
            }
        }

        
        public void restoreSystem() throws BuildException {
            if (sys == null) {
                throw new BuildException(""Unbalanced nesting of SysProperties"");
            }

            try {
                System.setProperties(sys);
                sys = null;
            } catch (SecurityException e) {
                throw new BuildException(""Cannot modify system properties"", e);
            }
        }

        
        public Object clone() throws CloneNotSupportedException {
            try {
                SysProperties c = (SysProperties) super.clone();
                c.variables = (Vector) variables.clone();
                c.propertySets = (Vector) propertySets.clone();
                return c;
            } catch (CloneNotSupportedException e) {
                return null;
            }
        }

        
        public void addSyspropertyset(PropertySet ps) {
            propertySets.addElement(ps);
        }

        
        public void addSysproperties(SysProperties ps) {
            variables.addAll(ps.variables);
            propertySets.addAll(ps.propertySets);
        }

        
        private Properties mergePropertySets() {
            Properties p = new Properties();
            for (Enumeration e = propertySets.elements();
                 e.hasMoreElements();) {
                PropertySet ps = (PropertySet) e.nextElement();
                p.putAll(ps.getProperties());
            }
            return p;
        }

    }

    
    public CommandlineJava() {
        setVm(JavaEnvUtils.getJreExecutable(""java""));
        setVmversion(JavaEnvUtils.getJavaVersion());
    }

    
    public Commandline.Argument createArgument() {
        return javaCommand.createArgument();
    }

    
    public Commandline.Argument createVmArgument() {
        return vmCommand.createArgument();
    }

    
    public void addSysproperty(Environment.Variable sysp) {
        sysProperties.addVariable(sysp);
    }

    
    public void addSyspropertyset(PropertySet sysp) {
        sysProperties.addSyspropertyset(sysp);
    }

    
    public void addSysproperties(SysProperties sysp) {
        sysProperties.addSysproperties(sysp);
    }

    
    public void setVm(String vm) {
        vmCommand.setExecutable(vm);
    }

    
    public void setVmversion(String value) {
        vmVersion = value;
    }

    
    public void setCloneVm(boolean cloneVm) {
        this.cloneVm = cloneVm;
    }

    
    public Assertions getAssertions() {
        return assertions;
    }

    
    public void setAssertions(Assertions assertions) {
        this.assertions = assertions;
    }

    
    public void setJar(String jarpathname) {
        javaCommand.setExecutable(jarpathname);
        executeJar = true;
    }

    
    public String getJar() {
        if (executeJar) {
            return javaCommand.getExecutable();
        }
        return null;
    }

    
    public void setClassname(String classname) {
        javaCommand.setExecutable(classname);
        executeJar = false;
    }

    
    public String getClassname() {
        if (!executeJar) {
            return javaCommand.getExecutable();
        }
        return null;
    }

    
    public Path createClasspath(Project p) {
        if (classpath == null) {
            classpath = new Path(p);
        }
        return classpath;
    }

    
    public Path createBootclasspath(Project p) {
        if (bootclasspath == null) {
            bootclasspath = new Path(p);
        }
        return bootclasspath;
    }

    
    public String getVmversion() {
        return vmVersion;
    }

    
    public String[] getCommandline() {
        
        List commands = new LinkedList();
        final ListIterator listIterator = commands.listIterator();
        
        addCommandsToList(listIterator);
        
        return (String[]) commands.toArray(new String[commands.size()]);
    }

    
    private void addCommandsToList(final ListIterator listIterator) {
        
        getActualVMCommand().addCommandToList(listIterator);
        
        sysProperties.addDefinitionsToList(listIterator);

        if (isCloneVm()) {
            SysProperties clonedSysProperties = new SysProperties();
            PropertySet ps = new PropertySet();
            PropertySet.BuiltinPropertySetName sys =
                new PropertySet.BuiltinPropertySetName();
            sys.setValue(""system"");
            ps.appendBuiltin(sys);
            clonedSysProperties.addSyspropertyset(ps);
            clonedSysProperties.addDefinitionsToList(listIterator);
        }
        
        Path bcp = calculateBootclasspath(true);
        if (bcp.size() > 0) {
            listIterator.add(""-Xbootclasspath:"" + bcp.toString());
        }
        
        if (haveClasspath()) {
            listIterator.add(""-classpath"");
            listIterator.add(
                    classpath.concatSystemClasspath(""ignore"").toString());
        }
        
        if (getAssertions() != null) {
            getAssertions().applyAssertions(listIterator);
        }
        
        
        
        
        if (executeJar) {
            listIterator.add(""-jar"");
        }
        
        
        javaCommand.addCommandToList(listIterator);
    }

    
    public void setMaxmemory(String max) {
        this.maxMemory = max;
    }

    
    public String toString() {
        return Commandline.toString(getCommandline());
    }

    
    public String describeCommand() {
        return Commandline.describeCommand(getCommandline());
    }

    
    public String describeJavaCommand() {
        return Commandline.describeCommand(getJavaCommand());
    }

    
    protected Commandline getActualVMCommand() {
        Commandline actualVMCommand = (Commandline) vmCommand.clone();
        if (maxMemory != null) {
            if (vmVersion.startsWith(""1.1"")) {
                actualVMCommand.createArgument().setValue(""-mx"" + maxMemory);
            } else {
                actualVMCommand.createArgument().setValue(""-Xmx"" + maxMemory);
            }
        }
        return actualVMCommand;
    }

    
    public int size() {
        int size = getActualVMCommand().size() + javaCommand.size()
            + sysProperties.size();
        
        if (isCloneVm()) {
            size += System.getProperties().size();
        }
        
        if (haveClasspath()) {
            size += 2;
        }
        
        if (calculateBootclasspath(true).size() > 0) {
            size++;
        }
        
        if (executeJar) {
            size++;
        }
        
        if (getAssertions() != null) {
            size += getAssertions().size();
        }
        return size;
    }

    
    public Commandline getJavaCommand() {
        return javaCommand;
    }

    
    public Commandline getVmCommand() {
        return getActualVMCommand();
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public Path getBootclasspath() {
        return bootclasspath;
    }

    
    public void setSystemProperties() throws BuildException {
        sysProperties.setSystem();
    }

    
    public void restoreSystemProperties() throws BuildException {
        sysProperties.restoreSystem();
    }

    
    public SysProperties getSystemProperties() {
        return sysProperties;
    }

    
    public Object clone() throws CloneNotSupportedException {
        try {
            CommandlineJava c = (CommandlineJava) super.clone();
            c.vmCommand = (Commandline) vmCommand.clone();
            c.javaCommand = (Commandline) javaCommand.clone();
            c.sysProperties = (SysProperties) sysProperties.clone();
            if (classpath != null) {
                c.classpath = (Path) classpath.clone();
            }
            if (bootclasspath != null) {
                c.bootclasspath = (Path) bootclasspath.clone();
            }
            if (assertions != null) {
                c.assertions = (Assertions) assertions.clone();
            }
            return c;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
    }

    
    public void clearJavaArgs() {
        javaCommand.clearArgs();
    }

    
    protected boolean haveClasspath() {
        Path fullClasspath = classpath != null
            ? classpath.concatSystemClasspath(""ignore"") : null;
        return fullClasspath != null
            && fullClasspath.toString().trim().length() > 0;
    }

    
    protected boolean haveBootclasspath(boolean log) {
        return calculateBootclasspath(log).size() > 0;
    }

    
    private Path calculateBootclasspath(boolean log) {
        if (vmVersion.startsWith(""1.1"")) {
            if (bootclasspath != null && log) {
                bootclasspath.log(""Ignoring bootclasspath as ""
                                  + ""the target VM doesn't support it."");
            }
        } else {
            if (bootclasspath != null) {
                return bootclasspath.concatSystemBootClasspath(isCloneVm()
                                                               ? ""last""
                                                               : ""ignore"");
            } else if (isCloneVm()) {
                return Path.systemBootClasspath;
            }
        }
        return new Path(null);
    }

    
    private boolean isCloneVm() {
        return cloneVm
            || ""true"".equals(System.getProperty(""ant.build.clonevm""));
    }
}
"
org.apache.tools.ant.filters.ClassConstants,4,4,0,4,20,0,1,3,4,0.777777778,162,0.666666667,0,0.928571429,0.75,2,4,38.75,1,0.5,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.tools.ant.BuildException;



public final class ClassConstants
    extends BaseFilterReader
    implements ChainableReader {
    
    private String queuedData = null;

    
    private static final String JAVA_CLASS_HELPER =
        ""org.apache.tools.ant.filters.util.JavaClassHelper"";

    
    public ClassConstants() {
        super();
    }

    
    public ClassConstants(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {

        int ch = -1;

        if (queuedData != null && queuedData.length() == 0) {
            queuedData = null;
        }

        if (queuedData != null) {
            ch = queuedData.charAt(0);
            queuedData = queuedData.substring(1);
            if (queuedData.length() == 0) {
                queuedData = null;
            }
        } else {
            final String clazz = readFully();
            if (clazz == null) {
                ch = -1;
            } else {
                final byte[] bytes = clazz.getBytes(""ISO-8859-1"");
                try {
                    final Class javaClassHelper =
                        Class.forName(JAVA_CLASS_HELPER);
                    if (javaClassHelper != null) {
                        final Class[] params = {
                            byte[].class
                        };
                        final Method getConstants =
                            javaClassHelper.getMethod(""getConstants"", params);
                        final Object[] args = {
                            bytes
                        };
                        
                        
                        final StringBuffer sb = (StringBuffer)
                                getConstants.invoke(null, args);
                        if (sb.length() > 0) {
                            queuedData = sb.toString();
                            return read();
                        }
                    }
                } catch (NoClassDefFoundError ex) {
                    throw ex;
                } catch (RuntimeException ex) {
                    throw ex;
                } catch (InvocationTargetException ex) {
                    Throwable t = ex.getTargetException();
                    if (t instanceof NoClassDefFoundError) {
                        throw (NoClassDefFoundError) t;
                    }
                    if (t instanceof RuntimeException) {
                        throw (RuntimeException) t;
                    }
                    throw new BuildException(t);
                } catch (Exception ex) {
                    throw new BuildException(ex);
                }
            }
        }
        return ch;
    }

    
    public Reader chain(final Reader rdr) {
        ClassConstants newFilter = new ClassConstants(rdr);
        return newFilter;
    }
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCLock,20,4,0,7,42,148,0,7,15,0.918660287,263,0.545454545,0,0.71641791,0.3875,2,3,11.6,6,1.4,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;







public class CCLock extends ClearCase {
    private boolean mReplace = false;
    private boolean mObsolete = false;
    private String mComment = null;
    private String mNusers = null;
    private String mPname = null;
    private String mObjselect = null;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_LOCK);

        
        checkOptions(commandLine);

        
        

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getOpType(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }

    
private void checkOptions(Commandline cmd) {
        
        if (getReplace()) {
            
            cmd.createArgument().setValue(FLAG_REPLACE);
        }
        if (getObsolete()) {
            
            cmd.createArgument().setValue(FLAG_OBSOLETE);
        } else {
            getNusersCommand(cmd);
        }
        getCommentCommand(cmd);

        if (getObjselect() == null && getPname() == null) {
            throw new BuildException(""Should select either an element ""
            + ""(pname) or an object (objselect)"");
        }
        getPnameCommand(cmd);
        
        if (getObjselect() != null) {
            cmd.createArgument().setValue(getObjselect());
        }
}

    
    public void setReplace(boolean replace) {
        mReplace = replace;
    }

    
    public boolean getReplace() {
        return mReplace;
    }

    
    public void setObsolete(boolean obsolete) {
        mObsolete = obsolete;
    }

    
    public boolean getObsolete() {
        return mObsolete;
    }

    
    public void setNusers(String nusers) {
        mNusers = nusers;
    }

    
    public String getNusers() {
        return mNusers;
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setPname(String pname) {
        mPname = pname;
    }

    
    public String getPname() {
        return mPname;
    }

    
    public void setObjSel(String objsel) {
        mObjselect = objsel;
    }

    
    public void setObjselect(String objselect) {
        mObjselect = objselect;
    }

    
    public String getObjselect() {
        return mObjselect;
    }

    
    private void getNusersCommand(Commandline cmd) {
        if (getNusers() == null) {
            return;
        } else {
            
            cmd.createArgument().setValue(FLAG_NUSERS);
            cmd.createArgument().setValue(getNusers());
        }
    }

    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() == null) {
            return;
        } else {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getPnameCommand(Commandline cmd) {
        if (getPname() == null) {
            return;
        } else {
            
            cmd.createArgument().setValue(FLAG_PNAME);
            cmd.createArgument().setValue(getPname());
        }
    }

    
    private String getOpType() {

        if (getPname() != null) {
            return getPname();
        } else {
            return getObjselect();
        }
    }

    
    public static final String FLAG_REPLACE = ""-replace"";
    
    public static final String FLAG_NUSERS = ""-nusers"";
    
    public static final String FLAG_OBSOLETE = ""-obsolete"";
    
    public static final String FLAG_COMMENT = ""-comment"";
    
    public static final String FLAG_PNAME = ""-pname"";
}

"
org.apache.tools.ant.taskdefs.Cvs,1,4,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs;


public class Cvs extends AbstractCvsTask {

    
    public Cvs() {
    }
}
"
org.apache.tools.ant.types.Reference,9,1,1,63,15,14,61,2,9,0.4375,103,1.0,1,0.0,0.555555556,0,0,10.22222222,1,0.6667,0,"

package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class Reference {

    private String refid;
    private Project project;

    
    public Reference() {
    }

    
    public Reference(String id) {
        setRefId(id);
    }

    
    public Reference(Project p, String id) {
        setRefId(id);
        setProject(p);
    }

    
    public void setRefId(String id) {
        refid = id;
    }

    
    public String getRefId() {
        return refid;
    }

    
    public void setProject(Project p) {
        this.project = p;
    }

    
    public Project getProject() {
        return project;
    }

    
    public Object getReferencedObject(Project fallback) throws BuildException {
        if (refid == null) {
            throw new BuildException(""No reference specified"");
        }

        Object o = project == null ? fallback.getReference(refid) : project.getReference(refid);
        if (o == null) {
            throw new BuildException(""Reference "" + refid + "" not found."");
        }
        return o;
    }

    
    public Object getReferencedObject() throws BuildException {
        if (project == null) {
            throw new BuildException(""No project set on reference to "" + refid);
        }
        return getReferencedObject(project);
    }

}
"
org.apache.tools.ant.filters.LineContains,10,5,0,6,29,0,1,5,7,0.688888889,212,1.0,0,0.777777778,0.3,2,5,19.7,5,1.2,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.util.Vector;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Parameter;


public final class LineContains
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String CONTAINS_KEY = ""contains"";

    
    private static final String NEGATE_KEY = ""negate"";

    
    private Vector contains = new Vector();

    
    private String line = null;

    private boolean negate = false;

    
    public LineContains() {
        super();
    }

    
    public LineContains(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;

        if (line != null) {
            ch = line.charAt(0);
            if (line.length() == 1) {
                line = null;
            } else {
                line = line.substring(1);
            }
        } else {
            final int containsSize = contains.size();

            for (line = readLine(); line != null; line = readLine()) {
                boolean matches = true;
                for (int i = 0; matches && i < containsSize; i++) {
                    String containsStr = (String) contains.elementAt(i);
                    matches = line.indexOf(containsStr) >= 0;
                }
                if (matches ^ isNegated()) {
                    break;
                }
            }
            if (line != null) {
                return read();
            }
        }
        return ch;
    }

    
    public void addConfiguredContains(final Contains contains) {
        this.contains.addElement(contains.getValue());
    }

    
    public void setNegate(boolean b) {
        negate = b;
    }

    
    public boolean isNegated() {
        return negate;
    }

    
    private void setContains(final Vector contains) {
        this.contains = contains;
    }

    
    private Vector getContains() {
        return contains;
    }

    
    public Reader chain(final Reader rdr) {
        LineContains newFilter = new LineContains(rdr);
        newFilter.setContains(getContains());
        newFilter.setNegate(isNegated());
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (CONTAINS_KEY.equals(params[i].getType())) {
                    contains.addElement(params[i].getValue());
                } else if (NEGATE_KEY.equals(params[i].getType())) {
                    setNegate(Project.toBoolean(params[i].getValue()));
                }
            }
        }
    }

    
    public static class Contains {

        
        private String value;

        
        public final void setValue(String contains) {
            value = contains;
        }

        
        public final String getValue() {
            return value;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.Constants,1,1,0,0,2,0,0,0,1,2.0,16,0.0,0,0.0,1.0,0,0,3.0,0,0.0,1,"

package org.apache.tools.ant.taskdefs.optional.junit;


public class Constants {

    static final String HALT_ON_ERROR = ""haltOnError="";
    static final String HALT_ON_FAILURE = ""haltOnFailure="";
    static final String FILTERTRACE = ""filtertrace="";
    static final String CRASHFILE = ""crashfile="";
    static final String BEFORE_FIRST_TEST = ""BeforeFirstTest"";
    static final String PROPSFILE = ""propsfile="";
    static final String SHOWOUTPUT = ""showoutput="";
    static final String OUTPUT_TO_FORMATTERS = ""outputtoformatters="";
    static final String FORMATTER = ""formatter="";
    static final String LOGTESTLISTENEREVENTS = ""logtestlistenerevents="";
    static final String TESTSFILE = ""testsfile="";
    static final String TERMINATED_SUCCESSFULLY = ""terminated successfully"";
}
"
org.apache.tools.ant.taskdefs.Available,22,3,0,12,71,163,1,11,17,0.867346939,783,1.0,5,0.649122807,0.25170068,2,2,33.95454545,22,2.6818,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;


public class Available extends Task implements Condition {
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private String property;
    private String classname;
    private String filename;
    private File file;
    private Path filepath;
    private String resource;
    private FileDir type;
    private Path classpath;
    private AntClassLoader loader;
    private String value = ""true"";
    private boolean isTask = false;
    private boolean ignoreSystemclasses = false;
    private boolean searchParents   = false;

    
    public void setSearchParents(boolean  searchParents) {
        this.searchParents = searchParents;
    }

    
    public void setClasspath(Path classpath) {
        createClasspath().append(classpath);
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setFilepath(Path filepath) {
        createFilepath().append(filepath);
    }

    
    public Path createFilepath() {
        if (this.filepath == null) {
            this.filepath = new Path(getProject());
        }
        return this.filepath.createPath();
    }

    
    public void setProperty(String property) {
        this.property = property;
    }

    
    public void setValue(String value) {
        this.value = value;
    }

    
    public void setClassname(String classname) {
        if (!"""".equals(classname)) {
            this.classname = classname;
        }
    }

    
    public void setFile(File file) {
        this.file = file;
        this.filename = FILE_UTILS.removeLeadingPath(getProject().getBaseDir(), file);
    }

    
    public void setResource(String resource) {
        this.resource = resource;
    }

    
    public void setType(String type) {
        log(""DEPRECATED - The setType(String) method has been deprecated.""
            + "" Use setType(Available.FileDir) instead."",
            Project.MSG_WARN);
        this.type = new FileDir();
        this.type.setValue(type);
    }

    
    public void setType(FileDir type) {
        this.type = type;
    }

    
    public void setIgnoresystemclasses(boolean ignore) {
        this.ignoreSystemclasses = ignore;
    }

    
    public void execute() throws BuildException {
        if (property == null) {
            throw new BuildException(""property attribute is required"",
                                     getLocation());
        }

        isTask = true;
        try {
            if (eval()) {
                String oldvalue = getProject().getProperty(property);
                if (null != oldvalue && !oldvalue.equals(value)) {
                    log(""DEPRECATED - <available> used to override an existing""
                        + "" property.""
                        + StringUtils.LINE_SEP
                        + ""  Build file should not reuse the same property""
                        + "" name for different values."",
                        Project.MSG_WARN);
                }
                
                
                getProject().setProperty(property, value);
            }
        } finally {
            isTask = false;
        }
    }

    
    public boolean eval() throws BuildException {
        try {
            if (classname == null && file == null && resource == null) {
                throw new BuildException(""At least one of (classname|file|""
                                         + ""resource) is required"", getLocation());
            }
            if (type != null) {
                if (file == null) {
                    throw new BuildException(""The type attribute is only valid ""
                                             + ""when specifying the file ""
                                             + ""attribute."", getLocation());
                }
            }
            if (classpath != null) {
                classpath.setProject(getProject());
                this.loader = getProject().createClassLoader(classpath);
            }
            String appendix = """";
            if (isTask) {
                appendix = "" to set property "" + property;
            } else {
                setTaskName(""available"");
            }
            if ((classname != null) && !checkClass(classname)) {
                log(""Unable to load class "" + classname + appendix,
                    Project.MSG_VERBOSE);
                return false;
            }
            if ((file != null) && !checkFile()) {
                StringBuffer buf = new StringBuffer(""Unable to find "");
                if (type != null) {
                    buf.append(type).append(' ');
                }
                buf.append(filename).append(appendix);
                log(buf.toString(), Project.MSG_VERBOSE);
                return false;
            }
            if ((resource != null) && !checkResource(resource)) {
                log(""Unable to load resource "" + resource + appendix,
                    Project.MSG_VERBOSE);
                return false;
            }
        } finally {
            if (loader != null) {
                loader.cleanup();
                loader = null;
            }
            if (!isTask) {
                setTaskName(null);
            }
        }
        return true;
    }

    
    private boolean checkFile() {
        if (filepath == null) {
            return checkFile(file, filename);
        } else {
            String[] paths = filepath.list();
            for (int i = 0; i < paths.length; ++i) {
                log(""Searching "" + paths[i], Project.MSG_DEBUG);
                File path = new File(paths[i]);

                
                
                if (path.exists() && filename.equals(paths[i])) {
                    if (type == null) {
                        log(""Found: "" + path, Project.MSG_VERBOSE);
                        return true;
                    } else if (type.isDir()
                               && path.isDirectory()) {
                        log(""Found directory: "" + path, Project.MSG_VERBOSE);
                        return true;
                    } else if (type.isFile()
                               && path.isFile()) {
                        log(""Found file: "" + path, Project.MSG_VERBOSE);
                        return true;
                    }
                    
                    return false;
                }
                File parent = path.getParentFile();
                
                if (parent != null && parent.exists()
                    && filename.equals(parent.getAbsolutePath())) {
                    if (type == null) {
                        log(""Found: "" + parent, Project.MSG_VERBOSE);
                        return true;
                    } else if (type.isDir()) {
                        log(""Found directory: "" + parent, Project.MSG_VERBOSE);
                        return true;
                    }
                    
                    return false;
                }
                
                if (path.exists() && path.isDirectory()) {
                    if (checkFile(new File(path, filename),
                                  filename + "" in "" + path)) {
                        return true;
                    }
                }
                
                while (searchParents && parent != null && parent.exists()) {
                    if (checkFile(new File(parent, filename),
                                  filename + "" in "" + parent)) {
                        return true;
                    }
                    parent = parent.getParentFile();
                }
            }
        }
        return false;
    }

    
    private boolean checkFile(File f, String text) {
        if (type != null) {
            if (type.isDir()) {
                if (f.isDirectory()) {
                    log(""Found directory: "" + text, Project.MSG_VERBOSE);
                }
                return f.isDirectory();
            } else if (type.isFile()) {
                if (f.isFile()) {
                    log(""Found file: "" + text, Project.MSG_VERBOSE);
                }
                return f.isFile();
            }
        }
        if (f.exists()) {
            log(""Found: "" + text, Project.MSG_VERBOSE);
        }
        return f.exists();
    }

    
    private boolean checkResource(String resource) {
        if (loader != null) {
            return (loader.getResourceAsStream(resource) != null);
        } else {
            ClassLoader cL = this.getClass().getClassLoader();
            if (cL != null) {
                return (cL.getResourceAsStream(resource) != null);
            } else {
                return
                    (ClassLoader.getSystemResourceAsStream(resource) != null);
            }
        }
    }

    
    private boolean checkClass(String classname) {
        try {
            if (ignoreSystemclasses) {
                loader = getProject().createClassLoader(classpath);
                loader.setParentFirst(false);
                loader.addJavaLibraries();
                if (loader != null) {
                    try {
                        loader.findClass(classname);
                    } catch (SecurityException se) {
                        
                        
                        
                        return true;
                    }
                } else {
                    return false;
                }
            } else if (loader != null) {
                loader.loadClass(classname);
            } else {
                ClassLoader l = this.getClass().getClassLoader();
                
                
                if (l != null) {
                    Class.forName(classname, true, l);
                } else {
                    Class.forName(classname);
                }
            }
            return true;
        } catch (ClassNotFoundException e) {
            log(""class \"""" + classname + ""\"" was not found"",
                Project.MSG_DEBUG);
            return false;
        } catch (NoClassDefFoundError e) {
            log(""Could not load dependent class \"""" + e.getMessage()
                + ""\"" for class \"""" + classname + ""\"""",
                Project.MSG_DEBUG);
            return false;
        }
    }

    
    public static class FileDir extends EnumeratedAttribute {

        private static final String[] VALUES = {""file"", ""dir""};

        
        
        public String[] getValues() {
            return VALUES;
        }

        
        public boolean isDir() {
            return ""dir"".equalsIgnoreCase(getValue());
        }

        
        public boolean isFile() {
            return ""file"".equalsIgnoreCase(getValue());
        }

    }
}
"
org.apache.tools.ant.types.selectors.TypeSelector,6,5,0,8,21,0,5,3,6,0.6,104,0.5,0,0.88372093,0.333333333,2,5,16.0,4,1.6667,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Parameter;


public class TypeSelector extends BaseExtendSelector {

    private String type = null;

    
    public static final String TYPE_KEY = ""type"";

    
    public TypeSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{typeselector type: "");
        buf.append(type);
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setType(FileType fileTypes) {
        this.type = fileTypes.getValue();
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (TYPE_KEY.equalsIgnoreCase(paramname)) {
                    FileType t = new FileType();
                    t.setValue(parameters[i].getValue());
                    setType(t);
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (type == null) {
            setError(""The type attribute is required"");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {

        
        validate();

        if (file.isDirectory()) {
            return type.equals(FileType.DIR);
        } else {
            return type.equals(FileType.FILE);
        }
    }

    
    public static class FileType extends EnumeratedAttribute {
        
        public static final String FILE = ""file"";
        
        public static final String DIR = ""dir"";

        
        public String[] getValues() {
            return new String[]{FILE, DIR};
        }
    }


}
"
org.apache.tools.ant.taskdefs.Sleep,10,3,0,2,20,21,0,2,9,0.6,129,1.0,0,0.804347826,0.4,1,1,11.4,1,0.9,0,"
package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;



public class Sleep extends Task {
    
    private boolean failOnError = true;

    
    private int seconds = 0;

    
    private int hours = 0;
    
    private int minutes = 0;

    
    private int milliseconds = 0;



    
    public Sleep() {
    }


    
    public void setSeconds(int seconds) {
        this.seconds = seconds;
    }


    
    public void setHours(int hours) {
        this.hours = hours;
    }


    
    public void setMinutes(int minutes) {
        this.minutes = minutes;
    }


    
    public void setMilliseconds(int milliseconds) {
        this.milliseconds = milliseconds;
    }


    
    public void doSleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ie) {
            
        }
    }


    
    public void setFailOnError(boolean failOnError) {
        this.failOnError = failOnError;
    }


    

    private long getSleepTime() {
        return ((((long) hours * 60) + minutes) * 60 + seconds) * 1000
            + milliseconds;
    }


    
    public void validate()
        throws BuildException {
        if (getSleepTime() < 0) {
            throw new BuildException(""Negative sleep periods are not ""
                                     + ""supported"");
        }
    }


    
    public void execute()
        throws BuildException {
        try {
            validate();
            long sleepTime = getSleepTime();
            log(""sleeping for "" + sleepTime + "" milliseconds"",
                Project.MSG_VERBOSE);
            doSleep(sleepTime);
        } catch (Exception e) {
            if (failOnError) {
                throw new BuildException(e);
            } else {
                String text = e.toString();
                log(text, Project.MSG_ERR);
            }
        }
    }

}

"
org.apache.tools.ant.types.resources.comparators.ResourceComparator,5,3,9,18,12,10,16,2,4,2.0,62,0.0,0,0.882352941,0.533333333,1,1,11.4,5,2.0,0,"
package org.apache.tools.ant.types.resources.comparators;

import java.util.Comparator;

import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.Resource;


public abstract class ResourceComparator extends DataType implements Comparator {

    
    public final int compare(Object foo, Object bar) {
        dieOnCircularReference();
        ResourceComparator c =
            isReference() ? (ResourceComparator) getCheckedRef() : this;
        return c.resourceCompare((Resource) foo, (Resource) bar);
    }

    
    public boolean equals(Object o) {
        if (isReference()) {
            return getCheckedRef().equals(o);
        }
        if (o == null) {
            return false;
        }
        return o == this || o.getClass().equals(getClass());
    }

    
    public synchronized int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        return getClass().hashCode();
    }

    
    protected abstract int resourceCompare(Resource foo, Resource bar);

}
"
org.apache.tools.ant.types.resources.comparators.Type,2,4,0,2,4,1,0,2,1,2.0,20,0.0,0,0.971428571,0.75,1,1,9.0,3,1.5,0,"
package org.apache.tools.ant.types.resources.comparators;

import org.apache.tools.ant.types.Resource;


public class Type extends ResourceComparator {

    
    protected int resourceCompare(Resource foo, Resource bar) {
        boolean f = foo.isDirectory();
        if (f == bar.isDirectory()) {
            return 0;
        }
        return f ? 1 : -1;
    }

}
"
org.apache.tools.ant.filters.TabsToSpaces,7,5,0,4,18,0,1,3,5,0.708333333,126,1.0,0,0.848484848,0.476190476,2,5,16.42857143,5,1.2857,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.types.Parameter;


public final class TabsToSpaces
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final int DEFAULT_TAB_LENGTH = 8;

    
    private static final String TAB_LENGTH_KEY = ""tablength"";

    
    private int tabLength = DEFAULT_TAB_LENGTH;

    
    private int spacesRemaining = 0;

    
    public TabsToSpaces() {
        super();
    }

    
    public TabsToSpaces(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;

        if (spacesRemaining > 0) {
            spacesRemaining--;
            ch = ' ';
        } else {
            ch = in.read();
            if (ch == '\t') {
                spacesRemaining = tabLength - 1;
                ch = ' ';
            }
        }
        return ch;
    }

    
    public void setTablength(final int tabLength) {
        this.tabLength = tabLength;
    }

    
    private int getTablength() {
        return tabLength;
    }

    
    public Reader chain(final Reader rdr) {
        TabsToSpaces newFilter = new TabsToSpaces(rdr);
        newFilter.setTablength(getTablength());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (params[i] != null) {
                    if (TAB_LENGTH_KEY.equals(params[i].getName())) {
                        tabLength =
                            new Integer(params[i].getValue()).intValue();
                        break;
                    }
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Jikes,2,2,0,8,34,1,1,7,2,2.0,346,0.0,0,0.958333333,1.0,1,1,172.0,1,0.5,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class Jikes extends DefaultCompilerAdapter {

    
    public boolean execute() throws BuildException {
        attributes.log(""Using jikes compiler"", Project.MSG_VERBOSE);

        Commandline cmd = new Commandline();

        
        
        Path sourcepath = null;
        if (compileSourcepath != null) {
            sourcepath = compileSourcepath;
        } else {
            sourcepath = src;
        }
        
        
        if (sourcepath.size() > 0) {
            cmd.createArgument().setValue(""-sourcepath"");
            cmd.createArgument().setPath(sourcepath);
        }

        Path classpath = new Path(project);

        if (bootclasspath == null || bootclasspath.size() == 0) {
            
            includeJavaRuntime = true;
        } else {
            
            
            
            
        }
        classpath.append(getCompileClasspath());

        
        String jikesPath = System.getProperty(""jikes.class.path"");
        if (jikesPath != null) {
            classpath.append(new Path(project, jikesPath));
        }

        if (extdirs != null && extdirs.size() > 0) {
            cmd.createArgument().setValue(""-extdirs"");
            cmd.createArgument().setPath(extdirs);
        }

        String exec = getJavac().getExecutable();
        cmd.setExecutable(exec == null ? ""jikes"" : exec);

        if (deprecation) {
            cmd.createArgument().setValue(""-deprecation"");
        }

        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);
        }

        cmd.createArgument().setValue(""-classpath"");
        cmd.createArgument().setPath(classpath);

        if (encoding != null) {
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(encoding);
        }
        if (debug) {
            String debugLevel = attributes.getDebugLevel();
            if (debugLevel != null) {
                cmd.createArgument().setValue(""-g:"" + debugLevel);
            } else {
                cmd.createArgument().setValue(""-g"");
            }
        } else {
            cmd.createArgument().setValue(""-g:none"");
        }
        if (optimize) {
            cmd.createArgument().setValue(""-O"");
        }
        if (verbose) {
            cmd.createArgument().setValue(""-verbose"");
        }
        if (depend) {
            cmd.createArgument().setValue(""-depend"");
        }

        if (target != null) {
            cmd.createArgument().setValue(""-target"");
            cmd.createArgument().setValue(target);
        }

        

        
        String emacsProperty = project.getProperty(""build.compiler.emacs"");
        if (emacsProperty != null && Project.toBoolean(emacsProperty)) {
            cmd.createArgument().setValue(""+E"");
        }

        
        String warningsProperty =
            project.getProperty(""build.compiler.warnings"");
        if (warningsProperty != null) {
            attributes.log(""!! the build.compiler.warnings property is ""
                           + ""deprecated. !!"", Project.MSG_WARN);
            attributes.log(""!! Use the nowarn attribute instead. !!"",
                           Project.MSG_WARN);
            if (!Project.toBoolean(warningsProperty)) {
                cmd.createArgument().setValue(""-nowarn"");
            }
        }
        if (attributes.getNowarn()) {
            cmd.createArgument().setValue(""-nowarn"");
        }

        
        String pedanticProperty =
            project.getProperty(""build.compiler.pedantic"");
        if (pedanticProperty != null && Project.toBoolean(pedanticProperty)) {
            cmd.createArgument().setValue(""+P"");
        }

        
        String fullDependProperty =
            project.getProperty(""build.compiler.fulldepend"");
        if (fullDependProperty != null
            && Project.toBoolean(fullDependProperty)) {
            cmd.createArgument().setValue(""+F"");
        }

        if (attributes.getSource() != null) {
            cmd.createArgument().setValue(""-source"");
            String source = attributes.getSource();
            if (source.equals(""1.1"") || source.equals(""1.2"")) {
                
                
                attributes.log(""Jikes doesn't support '-source ""
                               + source + ""', will use '-source 1.3' instead"");
                cmd.createArgument().setValue(""1.3"");
            } else {
                cmd.createArgument().setValue(source);
            }
        }

        addCurrentCompilerArgs(cmd);

        int firstFileName = cmd.size();

        Path boot = getBootClassPath();
        if (boot.size() > 0) {
            cmd.createArgument().setValue(""-bootclasspath"");
            cmd.createArgument().setPath(boot);
        }

        logAndAddFilesToCompile(cmd);

        return
            executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
    }


}
"
org.apache.tools.ant.types.ResourceCollection,3,1,0,69,3,3,69,0,3,2.0,3,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.types;

import java.util.Iterator;


public interface ResourceCollection {

    
    Iterator iterator();

    
    int size();

    
    boolean isFilesystemOnly();

}
"
org.apache.tools.ant.util.IdentityStack,6,5,0,1,12,15,1,0,6,2.0,74,0.0,0,0.954545455,0.5,2,7,11.33333333,3,1.8333,0,"
package org.apache.tools.ant.util;

import java.util.Stack;


public class IdentityStack extends Stack {

    
    public static IdentityStack getInstance(Stack s) {
        if (s instanceof IdentityStack) {
            return (IdentityStack) s;
        }
        IdentityStack result = new IdentityStack();
        if (s != null) {
            result.addAll(s);
        }
        return result;
    }

    
    public IdentityStack() {
    }

    
    public IdentityStack(Object o) {
        super();
        push(o);
    }

    
    public synchronized boolean contains(Object o) {
        return indexOf(o) >= 0;
    }

    
    public synchronized int indexOf(Object o, int pos) {
        for (int i = pos; i < size(); i++) {
            if (get(i) == o) {
                return i;
            }
        }
        return -1;
    }

    
    public synchronized int lastIndexOf(Object o, int pos) {
        for (int i = pos; i >= 0; i--) {
            if (get(i) == o) {
                return i;
            }
        }
        return -1;
    }

}
"
org.apache.tools.ant.UnknownElement,31,3,0,29,119,277,19,15,19,0.744444444,900,1.0,0,0.552238806,0.207885305,1,5,27.83870968,16,2.5806,3,"

package org.apache.tools.ant;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.io.IOException;
import org.apache.tools.ant.taskdefs.PreSetDef;


public class UnknownElement extends Task {

    
    private String elementName;

    
    private String namespace = """";

    
    private String qname;

    
    private Object realThing;

    
    private List children = null;

    
    private boolean presetDefed = false;

    
    public UnknownElement (String elementName) {
        this.elementName = elementName;
    }

    
    public List getChildren() {
        return children;
    }

    
    public String getTag() {
        return elementName;
    }

    
    public String getNamespace() {
        return namespace;
    }

    
    public void setNamespace(String namespace) {
        if (namespace.equals(ProjectHelper.ANT_CURRENT_URI)) {
            ComponentHelper helper = ComponentHelper.getComponentHelper(
                getProject());
            namespace = helper.getCurrentAntlibUri();
        }
        this.namespace = namespace == null ? """" : namespace;
    }

    
    public String getQName() {
        return qname;
    }

    
    public void setQName(String qname) {
        this.qname = qname;
    }


    
    public RuntimeConfigurable getWrapper() {
        return super.getWrapper();
    }

    
    public void maybeConfigure() throws BuildException {
        if (realThing != null) {
            return;
        }
        configure(makeObject(this, getWrapper()));
    }

    
    public void configure(Object realObject) {
        realThing = realObject;

        getWrapper().setProxy(realThing);
        Task task = null;
        if (realThing instanceof Task) {
            task = (Task) realThing;

            task.setRuntimeConfigurableWrapper(getWrapper());

            
            
            
            if (getWrapper().getId() != null) {
                this.getOwningTarget().replaceChild(this, (Task) realThing);
            }
       }


        
        
        

        if (task != null) {
            task.maybeConfigure();
        } else {
            getWrapper().maybeConfigure(getProject());
        }

        handleChildren(realThing, getWrapper());
    }

    
    protected void handleOutput(String output) {
        if (realThing instanceof Task) {
            ((Task) realThing).handleOutput(output);
        } else {
            super.handleOutput(output);
        }
    }

    
    protected int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        if (realThing instanceof Task) {
            return ((Task) realThing).handleInput(buffer, offset, length);
        } else {
            return super.handleInput(buffer, offset, length);
        }

    }
    
    protected void handleFlush(String output) {
        if (realThing instanceof Task) {
            ((Task) realThing).handleFlush(output);
        } else {
            super.handleFlush(output);
        }
    }

    
    protected void handleErrorOutput(String output) {
        if (realThing instanceof Task) {
            ((Task) realThing).handleErrorOutput(output);
        } else {
            super.handleErrorOutput(output);
        }
    }


    
    protected void handleErrorFlush(String output) {
        if (realThing instanceof Task) {
            ((Task) realThing).handleErrorOutput(output);
        } else {
            super.handleErrorOutput(output);
        }
    }

    
    public void execute() {
        if (realThing == null) {
            
            
            throw new BuildException(""Could not create task of type: ""
                                     + elementName, getLocation());
        }

        if (realThing instanceof Task) {
            ((Task) realThing).execute();
        }

        
        
        
        realThing = null;
        getWrapper().setProxy(null);

    }

    
    public void addChild(UnknownElement child) {
        if (children == null) {
            children = new ArrayList();
        }
        children.add(child);
    }

    
    protected void handleChildren(
        Object parent,
        RuntimeConfigurable parentWrapper)
        throws BuildException {
        if (parent instanceof TypeAdapter) {
            parent = ((TypeAdapter) parent).getProxy();
        }

        String parentUri = getNamespace();
        Class parentClass = parent.getClass();
        IntrospectionHelper ih = IntrospectionHelper.getHelper(getProject(), parentClass);


        if (children != null) {
            Iterator it = children.iterator();
            for (int i = 0; it.hasNext(); i++) {
                RuntimeConfigurable childWrapper = parentWrapper.getChild(i);
                UnknownElement child = (UnknownElement) it.next();
                try {
                    if (!handleChild(
                            parentUri, ih, parent, child, childWrapper)) {
                        if (!(parent instanceof TaskContainer)) {
                            ih.throwNotSupported(getProject(), parent,
                                                 child.getTag());
                        } else {
                            
                            
                            TaskContainer container = (TaskContainer) parent;
                            container.addTask(child);
                        }
                    }
                } catch (UnsupportedElementException ex) {
                    throw new BuildException(
                        parentWrapper.getElementTag()
                        + "" doesn't support the nested \"""" + ex.getElement()
                        + ""\"" element."", ex);
                }
            }
        }
    }

    
    protected String getComponentName() {
        return ProjectHelper.genComponentName(getNamespace(), getTag());
    }

    
    public void applyPreSet(UnknownElement u) {
        if (presetDefed) {
            return;
        }
        
        getWrapper().applyPreSet(u.getWrapper());
        if (u.children != null) {
            List newChildren = new ArrayList();
            newChildren.addAll(u.children);
            if (children != null) {
                newChildren.addAll(children);
            }
            children = newChildren;
        }
        presetDefed = true;
    }

    
    protected Object makeObject(UnknownElement ue, RuntimeConfigurable w) {
        ComponentHelper helper = ComponentHelper.getComponentHelper(
            getProject());
        String name = ue.getComponentName();
        Object o = helper.createComponent(ue, ue.getNamespace(), name);
        if (o == null) {
            throw getNotFoundException(""task or type"", name);
        }
        if (o instanceof PreSetDef.PreSetDefinition) {
            PreSetDef.PreSetDefinition def = (PreSetDef.PreSetDefinition) o;
            o = def.createObject(ue.getProject());
            if (o == null) {
                throw getNotFoundException(
                    ""preset "" + name,
                    def.getPreSets().getComponentName());
            }
            ue.applyPreSet(def.getPreSets());
            if (o instanceof Task) {
                Task task = (Task) o;
                task.setTaskType(ue.getTaskType());
                task.setTaskName(ue.getTaskName());
                task.init();
            }
        }
        if (o instanceof UnknownElement) {
            o = ((UnknownElement) o).makeObject((UnknownElement) o, w);
        }
        if (o instanceof Task) {
            ((Task) o).setOwningTarget(getOwningTarget());
        }
        if (o instanceof ProjectComponent) {
            ((ProjectComponent) o).setLocation(getLocation());
        }
        return o;
    }

    
    protected Task makeTask(UnknownElement ue, RuntimeConfigurable w) {
        Task task = getProject().createTask(ue.getTag());

        if (task != null) {
            task.setLocation(getLocation());
            
            task.setOwningTarget(getOwningTarget());
            task.init();
        }
        return task;
    }

    
    protected BuildException getNotFoundException(String what,
                                                  String name) {
        ComponentHelper helper = ComponentHelper.getComponentHelper(getProject());
        String msg = helper.diagnoseCreationFailure(name, what);
        return new BuildException(msg, getLocation());
    }

    
    public String getTaskName() {
        
        return realThing == null
            || !(realThing instanceof Task) ? super.getTaskName()
                                            : ((Task) realThing).getTaskName();
    }

    
    public Task getTask() {
        if (realThing instanceof Task) {
            return (Task) realThing;
        }
        return null;
    }

    
    public Object getRealThing() {
        return realThing;
    }

    
    public void setRealThing(Object realThing) {
        this.realThing = realThing;
    }

    
    private boolean handleChild(
        String parentUri,
        IntrospectionHelper ih,
        Object parent, UnknownElement child,
        RuntimeConfigurable childWrapper) {
        String childName = ProjectHelper.genComponentName(
            child.getNamespace(), child.getTag());
        if (ih.supportsNestedElement(parentUri, childName)) {
            IntrospectionHelper.Creator creator =
                ih.getElementCreator(
                    getProject(), parentUri, parent, childName, child);
            creator.setPolyType(childWrapper.getPolyType());
            Object realChild = creator.create();
            if (realChild instanceof PreSetDef.PreSetDefinition) {
                PreSetDef.PreSetDefinition def =
                    (PreSetDef.PreSetDefinition) realChild;
                realChild = creator.getRealObject();
                child.applyPreSet(def.getPreSets());
            }
            childWrapper.setCreator(creator);
            childWrapper.setProxy(realChild);
            if (realChild instanceof Task) {
                Task childTask = (Task) realChild;
                childTask.setRuntimeConfigurableWrapper(childWrapper);
                childTask.setTaskName(childName);
                childTask.setTaskType(childName);
            }
            if (realChild instanceof ProjectComponent) {
                ((ProjectComponent) realChild).setLocation(child.getLocation());
            }
            childWrapper.maybeConfigure(getProject());
            child.handleChildren(realChild, childWrapper);
            creator.store();
            return true;
        }
        return false;
    }

    
    public boolean similar(Object obj) {
        if (obj == null) {
            return false;
        }
        if (!getClass().getName().equals(obj.getClass().getName())) {
            return false;
        }
        UnknownElement other = (UnknownElement) obj;
        
        if (!equalsString(elementName, other.elementName)) {
            return false;
        }
        if (!namespace.equals(other.namespace)) {
            return false;
        }
        if (!qname.equals(other.qname)) {
            return false;
        }
        
        if (!getWrapper().getAttributeMap().equals(
                other.getWrapper().getAttributeMap())) {
            return false;
        }
        
        
        
        
        if (!getWrapper().getText().toString().equals(
                other.getWrapper().getText().toString())) {
            return false;
        }
        
        if (children == null || children.size() == 0) {
            return other.children == null || other.children.size() == 0;
        }
        if (other.children == null) {
            return false;
        }
        if (children.size() != other.children.size()) {
            return false;
        }
        for (int i = 0; i < children.size(); ++i) {
            UnknownElement child = (UnknownElement) children.get(i);
            if (!child.similar(other.children.get(i))) {
                return false;
            }
        }
        return true;
    }

    private static boolean equalsString(String a, String b) {
        return (a == null) ? (b == null) : a.equals(b);
    }

    
    public UnknownElement copy(Project newProject) {
        UnknownElement ret = new UnknownElement(getTag());
        ret.setNamespace(getNamespace());
        ret.setProject(newProject);
        ret.setQName(getQName());
        ret.setTaskType(getTaskType());
        ret.setTaskName(getTaskName());
        ret.setLocation(getLocation());
        if (getOwningTarget() == null) {
            Target t = new Target();
            t.setProject(getProject());
            ret.setOwningTarget(t);
        } else {
            ret.setOwningTarget(getOwningTarget());
        }
        RuntimeConfigurable copyRC = new RuntimeConfigurable(
            ret, getTaskName());
        copyRC.setPolyType(getWrapper().getPolyType());
        Map m = getWrapper().getAttributeMap();
        for (Iterator i = m.entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry) i.next();
            copyRC.setAttribute(
                (String) entry.getKey(), (String) entry.getValue());
        }
        copyRC.addText(getWrapper().getText().toString());

        for (Enumeration e = getWrapper().getChildren(); e.hasMoreElements();) {
            RuntimeConfigurable r = (RuntimeConfigurable) e.nextElement();
            UnknownElement ueChild = (UnknownElement) r.getProxy();
            UnknownElement copyChild = ueChild.copy(newProject);
            copyRC.addChild(copyChild.getWrapper());
            ret.addChild(copyChild);
        }
        return ret;
    }
}
"
org.apache.tools.ant.taskdefs.Checksum,24,4,0,13,103,176,1,12,18,0.808184143,1046,1.0,1,0.772277228,0.175,0,0,41.875,6,1.4167,2,"
package org.apache.tools.ant.taskdefs;

import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Set;
import java.util.Arrays;
import java.text.MessageFormat;
import java.text.ParseException;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.resources.Restrict;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.selectors.Type;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;


public class Checksum extends MatchingTask implements Condition {
    private static class FileUnion extends Restrict {
        private Union u;
        FileUnion() {
            u = new Union();
            super.add(u);
            super.add(Type.FILE);
        }
        public void add(ResourceCollection rc) {
            u.add(rc);
        }
    }

    
    private File file = null;

    
    private File todir;

    
    private String algorithm = ""MD5"";
    
    private String provider = null;
    
    private String fileext;
    
    private String property;
    
    private Map allDigests = new HashMap();
    
    private Map relativeFilePaths = new HashMap();
    
    private String totalproperty;
    
    private boolean forceOverwrite;
    
    private String verifyProperty;
    
    private FileUnion resources = null;
    
    private Hashtable includeFileMap = new Hashtable();
    
    private MessageDigest messageDigest;
    
    private boolean isCondition;
    
    private int readBufferSize = 8 * 1024;

    
    private MessageFormat format = FormatElement.getDefault().getFormat();

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setTodir(File todir) {
        this.todir = todir;
    }

    
    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    
    public void setProvider(String provider) {
        this.provider = provider;
    }

    
    public void setFileext(String fileext) {
        this.fileext = fileext;
    }

    
    public void setProperty(String property) {
        this.property = property;
    }

    
    public void setTotalproperty(String totalproperty) {
        this.totalproperty = totalproperty;
    }

    
    public void setVerifyproperty(String verifyProperty) {
        this.verifyProperty = verifyProperty;
    }

    
    public void setForceOverwrite(boolean forceOverwrite) {
        this.forceOverwrite = forceOverwrite;
    }

    
    public void setReadBufferSize(int size) {
        this.readBufferSize = size;
    }

    
    public void setFormat(FormatElement e) {
        format = e.getFormat();
    }

    
    public void setPattern(String p) {
        format = new MessageFormat(p);
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void add(ResourceCollection rc) {
        if (rc == null) {
            return;
        }
        resources = (resources == null) ? new FileUnion() : resources;
        resources.add(rc);
    }

    
    public void execute() throws BuildException {
        isCondition = false;
        boolean value = validateAndExecute();
        if (verifyProperty != null) {
            getProject().setNewProperty(
                verifyProperty,
                (value ? Boolean.TRUE.toString() : Boolean.FALSE.toString()));
        }
    }

    
    public boolean eval() throws BuildException {
        isCondition = true;
        return validateAndExecute();
    }

    
    private boolean validateAndExecute() throws BuildException {
        String savedFileExt = fileext;

        if (file == null && (resources == null || resources.size() == 0)) {
            throw new BuildException(
                ""Specify at least one source - a file or a resource collection."");
        }
        if (!(resources == null || resources.isFilesystemOnly())) {
            throw new BuildException(""Can only calculate checksums for file-based resources."");
        }
        if (file != null && file.exists() && file.isDirectory()) {
            throw new BuildException(""Checksum cannot be generated for directories"");
        }
        if (file != null && totalproperty != null) {
            throw new BuildException(""File and Totalproperty cannot co-exist."");
        }
        if (property != null && fileext != null) {
            throw new BuildException(""Property and FileExt cannot co-exist."");
        }
        if (property != null) {
            if (forceOverwrite) {
                throw new BuildException(
                    ""ForceOverwrite cannot be used when Property is specified"");
            }
            int ct = 0;
            if (resources != null) {
                ct += resources.size();
            }
            if (file != null) {
                ct++;
            }
            if (ct > 1) {
                throw new BuildException(
                    ""Multiple files cannot be used when Property is specified"");
            }
        }
        if (verifyProperty != null) {
            isCondition = true;
        }
        if (verifyProperty != null && forceOverwrite) {
            throw new BuildException(""VerifyProperty and ForceOverwrite cannot co-exist."");
        }
        if (isCondition && forceOverwrite) {
            throw new BuildException(
                ""ForceOverwrite cannot be used when conditions are being used."");
        }
        messageDigest = null;
        if (provider != null) {
            try {
                messageDigest = MessageDigest.getInstance(algorithm, provider);
            } catch (NoSuchAlgorithmException noalgo) {
                throw new BuildException(noalgo, getLocation());
            } catch (NoSuchProviderException noprovider) {
                throw new BuildException(noprovider, getLocation());
            }
        } else {
            try {
                messageDigest = MessageDigest.getInstance(algorithm);
            } catch (NoSuchAlgorithmException noalgo) {
                throw new BuildException(noalgo, getLocation());
            }
        }
        if (messageDigest == null) {
            throw new BuildException(""Unable to create Message Digest"", getLocation());
        }
        if (fileext == null) {
            fileext = ""."" + algorithm;
        } else if (fileext.trim().length() == 0) {
            throw new BuildException(""File extension when specified must not be an empty string"");
        }
        try {
            if (resources != null) {
                for (Iterator i = resources.iterator(); i.hasNext();) {
                    FileResource fr = (FileResource) i.next();
                    File src = fr.getFile();
                    if (totalproperty != null || todir != null) {
                        
                        
                        
                        relativeFilePaths.put(src, fr.getName().replace(File.separatorChar, '/'));
                    }
                    addToIncludeFileMap(src);
                }
            }
            if (file != null) {
                if (totalproperty != null || todir != null) {
                    relativeFilePaths.put(
                        file, file.getName().replace(File.separatorChar, '/'));
                }
                addToIncludeFileMap(file);
            }
            return generateChecksums();
        } finally {
            fileext = savedFileExt;
            includeFileMap.clear();
        }
    }

    
    private void addToIncludeFileMap(File file) throws BuildException {
        if (file.exists()) {
            if (property == null) {
                File checksumFile = getChecksumFile(file);
                if (forceOverwrite || isCondition
                    || (file.lastModified() > checksumFile.lastModified())) {
                    includeFileMap.put(file, checksumFile);
                } else {
                    log(file + "" omitted as "" + checksumFile + "" is up to date."",
                        Project.MSG_VERBOSE);
                    if (totalproperty != null) {
                        
                        String checksum = readChecksum(checksumFile);
                        byte[] digest = decodeHex(checksum.toCharArray());
                        allDigests.put(file, digest);
                    }
                }
            } else {
                includeFileMap.put(file, property);
            }
        } else {
            String message = ""Could not find file ""
                + file.getAbsolutePath()
                + "" to generate checksum for."";
            log(message);
            throw new BuildException(message, getLocation());
        }
    }

    private File getChecksumFile(File file) {
        File directory;
        if (todir != null) {
            
            String path = (String) relativeFilePaths.get(file);
            if (path == null) {
                
                throw new BuildException(
                    ""Internal error: ""
                    + ""relativeFilePaths could not match file""
                    + file + ""\n""
                    + ""please file a bug report on this"");
            }
            directory = new File(todir, path).getParentFile();
            
            directory.mkdirs();
        } else {
            
            
            directory = file.getParentFile();
        }
        File checksumFile = new File(directory, file.getName() + fileext);
        return checksumFile;
    }

    
    private boolean generateChecksums() throws BuildException {
        boolean checksumMatches = true;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        byte[] buf = new byte[readBufferSize];
        try {
            for (Enumeration e = includeFileMap.keys(); e.hasMoreElements();) {
                messageDigest.reset();
                File src = (File) e.nextElement();
                if (!isCondition) {
                    log(""Calculating "" + algorithm + "" checksum for "" + src, Project.MSG_VERBOSE);
                }
                fis = new FileInputStream(src);
                DigestInputStream dis = new DigestInputStream(fis,
                                                              messageDigest);
                while (dis.read(buf, 0, readBufferSize) != -1) {
                    
                }
                dis.close();
                fis.close();
                fis = null;
                byte[] fileDigest = messageDigest.digest ();
                if (totalproperty != null) {
                    allDigests.put(src, fileDigest);
                }
                String checksum = createDigestString(fileDigest);
                
                Object destination = includeFileMap.get(src);
                if (destination instanceof java.lang.String) {
                    String prop = (String) destination;
                    if (isCondition) {
                        checksumMatches
                            = checksumMatches && checksum.equals(property);
                    } else {
                        getProject().setNewProperty(prop, checksum);
                    }
                } else if (destination instanceof java.io.File) {
                    if (isCondition) {
                        File existingFile = (File) destination;
                        if (existingFile.exists()) {
                            try {
                                String suppliedChecksum =
                                    readChecksum(existingFile);
                                checksumMatches = checksumMatches
                                    && checksum.equals(suppliedChecksum);
                            } catch (BuildException be) {
                                
                                checksumMatches = false;
                            }
                        } else {
                            checksumMatches = false;
                        }
                    } else {
                        File dest = (File) destination;
                        fos = new FileOutputStream(dest);
                        fos.write(format.format(new Object[] {
                                                    checksum,
                                                    src.getName(),
                                                }).getBytes());
                        fos.write(StringUtils.LINE_SEP.getBytes());
                        fos.close();
                        fos = null;
                    }
                }
            }
            if (totalproperty != null) {
                
                
                Set keys = allDigests.keySet();
                Object[] keyArray = keys.toArray();
                
                Arrays.sort(keyArray);
                
                messageDigest.reset();
                for (int i = 0; i < keyArray.length; i++) {
                    File src = (File) keyArray[i];

                    
                    byte[] digest = (byte[]) allDigests.get(src);
                    messageDigest.update(digest);

                    
                    String fileName = (String) relativeFilePaths.get(src);
                    messageDigest.update(fileName.getBytes());
                }
                String totalChecksum = createDigestString(messageDigest.digest());
                getProject().setNewProperty(totalproperty, totalChecksum);
            }
        } catch (Exception e) {
            throw new BuildException(e, getLocation());
        } finally {
            FileUtils.close(fis);
            FileUtils.close(fos);
        }
        return checksumMatches;
    }

    private String createDigestString(byte[] fileDigest) {
        StringBuffer checksumSb = new StringBuffer();
        for (int i = 0; i < fileDigest.length; i++) {
            String hexStr = Integer.toHexString(0x00ff & fileDigest[i]);
            if (hexStr.length() < 2) {
                checksumSb.append(""0"");
            }
            checksumSb.append(hexStr);
        }
        return checksumSb.toString();
    }

    
    public static byte[] decodeHex(char[] data) throws BuildException {
        int l = data.length;

        if ((l & 0x01) != 0) {
            throw new BuildException(""odd number of characters."");
        }

        byte[] out = new byte[l >> 1];

        
        for (int i = 0, j = 0; j < l; i++) {
            int f = Character.digit(data[j++], 16) << 4;
            f = f | Character.digit(data[j++], 16);
            out[i] = (byte) (f & 0xFF);
        }

        return out;
    }

    
    private String readChecksum(File f) {
        BufferedReader diskChecksumReader = null;
        try {
            diskChecksumReader = new BufferedReader(new FileReader(f));
            Object[] result = format.parse(diskChecksumReader.readLine());
            if (result == null || result.length == 0 || result[0] == null) {
                throw new BuildException(""failed to find a checksum"");
            }
            return (String) result[0];
        } catch (IOException e) {
            throw new BuildException(""Couldn't read checksum file "" + f, e);
        } catch (ParseException e) {
            throw new BuildException(""Couldn't read checksum file "" + f, e);
        } finally {
            FileUtils.close(diskChecksumReader);
        }
    }

    
    public static class FormatElement extends EnumeratedAttribute {
        private static HashMap formatMap = new HashMap();
        private static final String CHECKSUM = ""CHECKSUM"";
        private static final String MD5SUM = ""MD5SUM"";
        private static final String SVF = ""SVF"";

        static {
            formatMap.put(CHECKSUM, new MessageFormat(""{0}""));
            formatMap.put(MD5SUM, new MessageFormat(""{0} *{1}""));
            formatMap.put(SVF, new MessageFormat(""MD5 ({1}) = {0}""));
        }

        
        public FormatElement() {
            super();
        }

        
        public static FormatElement getDefault() {
            FormatElement e = new FormatElement();
            e.setValue(CHECKSUM);
            return e;
        }

        
        public MessageFormat getFormat() {
            return (MessageFormat) formatMap.get(getValue());
        }

        
        public String[] getValues() {
            return new String[] {CHECKSUM, MD5SUM, SVF};
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WebsphereDeploymentTool,33,2,0,15,130,434,2,14,23,0.940848214,1220,0.928571429,2,0.507936508,0.328125,1,5,35.12121212,26,2.5152,0,"
package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileUtils;


public class WebsphereDeploymentTool extends GenericDeploymentTool {

    
    public static final String PUBLICID_EJB11
         = ""-
    
    public static final String PUBLICID_EJB20
         = ""-
    
    protected static final String SCHEMA_DIR = ""Schema/"";

    protected static final String WAS_EXT = ""ibm-ejb-jar-ext.xmi"";
    protected static final String WAS_BND = ""ibm-ejb-jar-bnd.xmi"";
    protected static final String WAS_CMP_MAP = ""Map.mapxmi"";
    protected static final String WAS_CMP_SCHEMA = ""Schema.dbxmi"";

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private String jarSuffix = "".jar"";

    
    private String ejb11DTD;

    

    private boolean keepGeneric = false;

    private boolean alwaysRebuild = true;

    private boolean ejbdeploy = true;

    
    private boolean newCMP = false;

    
    private Path wasClasspath = null;

    
    private String dbVendor;

    
    private String dbName;

    
    private String dbSchema;

    
    private boolean codegen;

    
    private boolean quiet = true;

    
    private boolean novalidate;

    
    private boolean nowarn;

    
    private boolean noinform;

    
    private boolean trace;

    
    private String rmicOptions;

    
    private boolean use35MappingRules;

    
    private String tempdir = ""_ejbdeploy_temp"";

    
    private File websphereHome;

    
    public Path createWASClasspath() {
        if (wasClasspath == null) {
            wasClasspath = new Path(getTask().getProject());
        }
        return wasClasspath.createPath();
    }


    
    public void setWASClasspath(Path wasClasspath) {
        this.wasClasspath = wasClasspath;
    }


    
    public void setDbvendor(String dbvendor) {
        this.dbVendor = dbvendor;
    }


    
    public void setDbname(String dbName) {
        this.dbName = dbName;
    }


    
    public void setDbschema(String dbSchema) {
        this.dbSchema = dbSchema;
    }


    
    public void setCodegen(boolean codegen) {
        this.codegen = codegen;
    }


    
    public void setQuiet(boolean quiet) {
        this.quiet = quiet;
    }


    
    public void setNovalidate(boolean novalidate) {
        this.novalidate = novalidate;
    }


    
    public void setNowarn(boolean nowarn) {
        this.nowarn = nowarn;
    }


    
    public void setNoinform(boolean noinform) {
        this.noinform = noinform;
    }


    
    public void setTrace(boolean trace) {
        this.trace = trace;
    }

    
    public void setRmicoptions(String options) {
        this.rmicOptions = options;
    }

    
    public void setUse35(boolean attr) {
        use35MappingRules = attr;
    }


    
    public void setRebuild(boolean rebuild) {
        this.alwaysRebuild = rebuild;
    }


    
    public void setSuffix(String inString) {
        this.jarSuffix = inString;
    }


    
    public void setKeepgeneric(boolean inValue) {
        this.keepGeneric = inValue;
    }


    
    public void setEjbdeploy(boolean ejbdeploy) {
        this.ejbdeploy = ejbdeploy;
    }


    
    public void setEJBdtd(String inString) {
        this.ejb11DTD = inString;
    }


    
    public void setOldCMP(boolean oldCMP) {
        this.newCMP = !oldCMP;
    }


    
    public void setNewCMP(boolean newCMP) {
        this.newCMP = newCMP;
    }


    
    public void setTempdir(String tempdir) {
        this.tempdir = tempdir;
    }


    
    protected DescriptorHandler getDescriptorHandler(File srcDir) {
        DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir);
        
        
        handler.registerDTD(PUBLICID_EJB11, ejb11DTD);

        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();

            handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }

        return handler;
    }


    
    protected DescriptorHandler getWebsphereDescriptorHandler(final File srcDir) {
        DescriptorHandler handler =
            new DescriptorHandler(getTask(), srcDir) {
                protected void processElement() {
                }
            };

        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();

            handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }
        return handler;
    }


    
    protected void addVendorFiles(Hashtable ejbFiles, String baseName) {

        String ddPrefix = (usingBaseJarName() ? """" : baseName);
        String dbPrefix = (dbVendor == null) ? """" : dbVendor + ""-"";

        
        File websphereEXT = new File(getConfig().descriptorDir, ddPrefix + WAS_EXT);

        if (websphereEXT.exists()) {
            ejbFiles.put(META_DIR + WAS_EXT,
                websphereEXT);
        } else {
            log(""Unable to locate websphere extensions. ""
                + ""It was expected to be in ""
                + websphereEXT.getPath(), Project.MSG_VERBOSE);
        }

        File websphereBND = new File(getConfig().descriptorDir, ddPrefix + WAS_BND);

        if (websphereBND.exists()) {
            ejbFiles.put(META_DIR + WAS_BND,
                websphereBND);
        } else {
            log(""Unable to locate websphere bindings. ""
                + ""It was expected to be in ""
                + websphereBND.getPath(), Project.MSG_VERBOSE);
        }

        if (!newCMP) {
            log(""The old method for locating CMP files has been DEPRECATED."",
                Project.MSG_VERBOSE);
            log(""Please adjust your websphere descriptor and set ""
                + ""newCMP=\""true\"" to use the new CMP descriptor ""
                + ""inclusion mechanism. "", Project.MSG_VERBOSE);
        } else {
            
            try {
                
                File websphereMAP = new File(getConfig().descriptorDir,
                    ddPrefix + dbPrefix + WAS_CMP_MAP);

                if (websphereMAP.exists()) {
                    ejbFiles.put(META_DIR + WAS_CMP_MAP,
                        websphereMAP);
                } else {
                    log(""Unable to locate the websphere Map: ""
                        + websphereMAP.getPath(), Project.MSG_VERBOSE);
                }

                File websphereSchema = new File(getConfig().descriptorDir,
                    ddPrefix + dbPrefix + WAS_CMP_SCHEMA);

                if (websphereSchema.exists()) {
                    ejbFiles.put(META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA,
                        websphereSchema);
                } else {
                    log(""Unable to locate the websphere Schema: ""
                        + websphereSchema.getPath(), Project.MSG_VERBOSE);
                }
                
            } catch (Exception e) {
                String msg = ""Exception while adding Vendor specific files: ""
                    + e.toString();

                throw new BuildException(msg, e);
            }
        }
    }


    
    File getVendorOutputJarFile(String baseName) {
        return new File(getDestDir(), baseName + jarSuffix);
    }


    
    protected String getOptions() {
        
        StringBuffer options = new StringBuffer();

        if (dbVendor != null) {
            options.append("" -dbvendor "").append(dbVendor);
        }
        if (dbName != null) {
            options.append("" -dbname \"""").append(dbName).append(""\"""");
        }

        if (dbSchema != null) {
            options.append("" -dbschema \"""").append(dbSchema).append(""\"""");
        }

        if (codegen) {
            options.append("" -codegen"");
        }

        if (quiet) {
            options.append("" -quiet"");
        }

        if (novalidate) {
            options.append("" -novalidate"");
        }

        if (nowarn) {
            options.append("" -nowarn"");
        }

        if (noinform) {
            options.append("" -noinform"");
        }

        if (trace) {
            options.append("" -trace"");
        }

        if (use35MappingRules) {
            options.append("" -35"");
        }

        if (rmicOptions != null) {
            options.append("" -rmic \"""").append(rmicOptions).append(""\"""");
        }

        return options.toString();
    }


    
    private void buildWebsphereJar(File sourceJar, File destJar) {
        try {
            if (ejbdeploy) {
                Java javaTask = new Java(getTask());
                
                javaTask.createJvmarg().setValue(""-Xms64m"");
                javaTask.createJvmarg().setValue(""-Xmx128m"");

                
                Environment.Variable var = new Environment.Variable();

                var.setKey(""websphere.lib.dir"");
                File libdir = new File(websphereHome, ""lib"");
                var.setValue(libdir.getAbsolutePath());
                javaTask.addSysproperty(var);

                
                javaTask.setDir(websphereHome);

                
                javaTask.setTaskName(""ejbdeploy"");
                javaTask.setClassname(""com.ibm.etools.ejbdeploy.EJBDeploy"");

                javaTask.createArg().setValue(sourceJar.getPath());
                javaTask.createArg().setValue(tempdir);
                javaTask.createArg().setValue(destJar.getPath());
                javaTask.createArg().setLine(getOptions());
                if (getCombinedClasspath() != null
                    && getCombinedClasspath().toString().length() > 0) {
                    javaTask.createArg().setValue(""-cp"");
                    javaTask.createArg().setValue(getCombinedClasspath().toString());
                }

                Path classpath = wasClasspath;

                if (classpath == null) {
                    classpath = getCombinedClasspath();
                }

                if (classpath != null) {
                    javaTask.setClasspath(classpath);
                    javaTask.setFork(true);
                } else {
                    javaTask.setFork(true);
                }

                log(""Calling websphere.ejbdeploy for "" + sourceJar.toString(),
                    Project.MSG_VERBOSE);

                javaTask.execute();
            }
        } catch (Exception e) {
            
            String msg = ""Exception while calling ejbdeploy. Details: "" + e.toString();

            throw new BuildException(msg, e);
        }
    }

    
    protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId)
         throws BuildException {
        if (ejbdeploy) {
            
            File genericJarFile = super.getVendorOutputJarFile(baseName);

            super.writeJar(baseName, genericJarFile, files, publicId);

            
            if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
                buildWebsphereJar(genericJarFile, jarFile);
            }
            if (!keepGeneric) {
                log(""deleting generic jar "" + genericJarFile.toString(),
                    Project.MSG_VERBOSE);
                genericJarFile.delete();
            }
        } else {
            
            super.writeJar(baseName, jarFile, files, publicId);
        }
    }


    
    public void validateConfigured() throws BuildException {
        super.validateConfigured();
        if (ejbdeploy) {
            String home = getTask().getProject().getProperty(""websphere.home"");
            if (home == null) {
                throw new BuildException(""The 'websphere.home' property must ""
                    + ""be set when 'ejbdeploy=true'"");
            }
            websphereHome = getTask().getProject().resolveFile(home);
        }
    }


    
    protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
        boolean rebuild = false;

        JarFile genericJar = null;
        JarFile wasJar = null;
        File newwasJarFile = null;
        JarOutputStream newJarStream = null;

        try {
            log(""Checking if websphere Jar needs to be rebuilt for jar ""
                + websphereJarFile.getName(), Project.MSG_VERBOSE);
            
            if (genericJarFile.exists() && genericJarFile.isFile()
                 && websphereJarFile.exists() && websphereJarFile.isFile()) {
                
                genericJar = new JarFile(genericJarFile);
                wasJar = new JarFile(websphereJarFile);

                Hashtable genericEntries = new Hashtable();
                Hashtable wasEntries = new Hashtable();
                Hashtable replaceEntries = new Hashtable();

                
                for (Enumeration e = genericJar.entries(); e.hasMoreElements();) {
                    JarEntry je = (JarEntry) e.nextElement();

                    genericEntries.put(je.getName().replace('\\', '/'), je);
                }
                
                for (Enumeration e = wasJar.entries(); e.hasMoreElements();) {
                    JarEntry je = (JarEntry) e.nextElement();

                    wasEntries.put(je.getName(), je);
                }

                
                ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);

                for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) {
                    String filepath = (String) e.nextElement();

                    if (wasEntries.containsKey(filepath)) {
                        
                        
                        JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
                        JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);

                        if ((genericEntry.getCrc() != wasEntry.getCrc())
                            || (genericEntry.getSize() != wasEntry.getSize())) {

                            if (genericEntry.getName().endsWith("".class"")) {
                                
                                String classname
                                    = genericEntry.getName().replace(File.separatorChar, '.');

                                classname = classname.substring(0, classname.lastIndexOf("".class""));

                                Class genclass = genericLoader.loadClass(classname);

                                if (genclass.isInterface()) {
                                    
                                    log(""Interface "" + genclass.getName()
                                        + "" has changed"", Project.MSG_VERBOSE);
                                    rebuild = true;
                                    break;
                                } else {
                                    
                                    replaceEntries.put(filepath, genericEntry);
                                }
                            } else {
                                
                                if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
                                    
                                    log(""Non class file "" + genericEntry.getName()
                                        + "" has changed"", Project.MSG_VERBOSE);
                                    rebuild = true;
                                }
                                break;
                            }
                        }
                    } else {
                        

                        log(""File "" + filepath + "" not present in websphere jar"",
                            Project.MSG_VERBOSE);
                        rebuild = true;
                        break;
                    }
                }

                if (!rebuild) {
                    log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
                    newwasJarFile = new File(websphereJarFile.getAbsolutePath() + "".temp"");
                    if (newwasJarFile.exists()) {
                        newwasJarFile.delete();
                    }

                    newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
                    newJarStream.setLevel(0);

                    
                    for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) {
                        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                        int bytesRead;
                        InputStream is;
                        JarEntry je = (JarEntry) e.nextElement();

                        if (je.getCompressedSize() == -1
                            || je.getCompressedSize() == je.getSize()) {
                            newJarStream.setLevel(0);
                        } else {
                            newJarStream.setLevel(JAR_COMPRESS_LEVEL);
                        }

                        
                        if (replaceEntries.containsKey(je.getName())) {
                            log(""Updating Bean class from generic Jar "" + je.getName(),
                                Project.MSG_VERBOSE);
                            
                            je = (JarEntry) replaceEntries.get(je.getName());
                            is = genericJar.getInputStream(je);
                        } else {
                            

                            is = wasJar.getInputStream(je);
                        }
                        newJarStream.putNextEntry(new JarEntry(je.getName()));

                        while ((bytesRead = is.read(buffer)) != -1) {
                            newJarStream.write(buffer, 0, bytesRead);
                        }
                        is.close();
                    }
                } else {
                    log(""websphere Jar rebuild needed due to changed ""
                        + ""interface or XML"", Project.MSG_VERBOSE);
                }
            } else {
                rebuild = true;
            }
        } catch (ClassNotFoundException cnfe) {
            String cnfmsg = ""ClassNotFoundException while processing ejb-jar file""
                 + "". Details: ""
                 + cnfe.getMessage();

            throw new BuildException(cnfmsg, cnfe);
        } catch (IOException ioe) {
            String msg = ""IOException while processing ejb-jar file ""
                 + "". Details: ""
                 + ioe.getMessage();

            throw new BuildException(msg, ioe);
        } finally {
            
            if (genericJar != null) {
                try {
                    genericJar.close();
                } catch (IOException closeException) {
                    
                }
            }

            if (wasJar != null) {
                try {
                    wasJar.close();
                } catch (IOException closeException) {
                    
                }
            }

            if (newJarStream != null) {
                try {
                    newJarStream.close();
                } catch (IOException closeException) {
                    
                }

                try {
                    FILE_UTILS.rename(newwasJarFile, websphereJarFile);
                } catch (IOException renameException) {
                    log(renameException.getMessage(), Project.MSG_WARN);
                    rebuild = true;
                }
            }
        }

        return rebuild;
    }


    
    protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
        Path lookupPath = new Path(getTask().getProject());

        lookupPath.setLocation(classjar);

        Path classpath = getCombinedClasspath();

        if (classpath != null) {
            lookupPath.append(classpath);
        }

        return getTask().getProject().createClassLoader(lookupPath);
    }
}

"
org.apache.tools.ant.taskdefs.Basename,5,3,0,4,15,4,0,4,5,0.75,90,1.0,0,0.902439024,0.533333333,0,0,16.4,1,0.8,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;



public class Basename extends Task {
    private File file;
    private String property;
    private String suffix;

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setProperty(String property) {
        this.property  = property;
    }

    
    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }

    
    public void execute() throws BuildException {
        if (property == null) {
            throw new BuildException(""property attribute required"", getLocation());
        }
        if (file == null) {
            throw new BuildException(""file attribute required"", getLocation());
        }
        String value = file.getName();
        if (suffix != null && value.endsWith(suffix)) {
            
            
            
            int pos = value.length() - suffix.length();
            if (pos > 0 && suffix.charAt(0) != '.'
                && value.charAt(pos - 1) == '.') {
                pos--;
            }
            value = value.substring(0, pos);
        }
        getProject().setNewProperty(property, value);
    }
}

"
org.apache.tools.ant.taskdefs.optional.javah.Kaffeh,3,1,0,11,28,3,1,10,2,1.5,111,0.0,0,0.0,0.833333333,0,0,35.66666667,7,2.6667,0,"
package org.apache.tools.ant.taskdefs.optional.javah;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.optional.Javah;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.JavaEnvUtils;


public class Kaffeh implements JavahAdapter {

    
    public static final String IMPLEMENTATION_NAME = ""kaffeh"";

    
    public boolean compile(Javah javah) throws BuildException {
        Commandline cmd = setupKaffehCommand(javah);
        try {
            Execute.runCommand(javah, cmd.getCommandline());
            return true;
        } catch (BuildException e) {
            if (e.getMessage().indexOf(""failed with return code"") == -1) {
                throw e;
            }
        }
        return false;
    }

    private Commandline setupKaffehCommand(Javah javah) {
        Commandline cmd = new Commandline();
        cmd.setExecutable(JavaEnvUtils.getJdkExecutable(""kaffeh""));

        if (javah.getDestdir() != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(javah.getDestdir());
        }

        if (javah.getOutputfile() != null) {
            cmd.createArgument().setValue(""-o"");
            cmd.createArgument().setFile(javah.getOutputfile());
        }

        Path cp = new Path(javah.getProject());
        if (javah.getBootclasspath() != null) {
            cp.append(javah.getBootclasspath());
        }
        cp = cp.concatSystemBootClasspath(""ignore"");
        if (javah.getClasspath() != null) {
            cp.append(javah.getClasspath());
        }
        if (cp.size() > 0) {
            cmd.createArgument().setValue(""-classpath"");
            cmd.createArgument().setPath(cp);
        }

        if (!javah.getOld()) {
            cmd.createArgument().setValue(""-jni"");
        }

        cmd.addArguments(javah.getCurrentArgs());

        javah.logAndAddFiles(cmd);
        return cmd;
    }

}
"
org.apache.tools.ant.util.ChainedMapper,2,2,0,2,15,1,0,2,2,2.0,73,0.0,0,0.875,0.75,0,0,35.5,6,3.0,0,"

package org.apache.tools.ant.util;

import java.util.List;
import java.util.Arrays;
import java.util.Iterator;
import java.util.ArrayList;


public class ChainedMapper extends ContainerMapper {

    
    public String[] mapFileName(String sourceFileName) {
        List inputs = new ArrayList();
        List results = new ArrayList();
        results.add(sourceFileName);
        FileNameMapper mapper = null;

        for (Iterator mIter = getMappers().iterator(); mIter.hasNext();) {
            mapper = (FileNameMapper) (mIter.next());
            if (mapper != null) {
                inputs.clear();
                inputs.addAll(results);
                results.clear();

                for (Iterator it = inputs.iterator(); it.hasNext();) {
                    String[] mapped = mapper.mapFileName((String) (it.next()));
                    if (mapped != null) {
                        results.addAll(Arrays.asList(mapped));
                    }
                }
            }
        }
        return (results.size() == 0) ? null
            : (String[]) results.toArray(new String[results.size()]);
    }
}

"
org.apache.tools.ant.taskdefs.optional.ccm.CCMCheckout,1,5,0,1,3,0,0,1,1,2.0,7,0.0,0,1.0,1.0,0,0,6.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;


public class CCMCheckout extends CCMCheck {

    
    public CCMCheckout() {
        super();
        setCcmAction(COMMAND_CHECKOUT);
    }
}

"
org.apache.tools.ant.types.resources.BaseResourceCollectionWrapper,13,3,4,12,42,54,5,7,8,0.791666667,233,1.0,1,0.714285714,0.261538462,1,3,16.61538462,6,2.0,1,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.util.Stack;
import java.util.Iterator;
import java.util.Collection;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.ResourceCollection;


public abstract class BaseResourceCollectionWrapper
    extends DataType implements ResourceCollection, Cloneable {
    private static final String ONE_NESTED_MESSAGE
        = "" expects exactly one nested resource collection."";

    private ResourceCollection rc;
    private Collection coll = null;
    private boolean cache = true;

    
    public synchronized void setCache(boolean b) {
        cache = b;
    }

    
    public synchronized boolean isCache() {
        return cache;
    }

    
    public synchronized void add(ResourceCollection c) throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (c == null) {
            return;
        }
        if (rc != null) {
            throw oneNested();
        }
        rc = c;
        setChecked(false);
    }

    
    public final synchronized Iterator iterator() {
        if (isReference()) {
            return ((BaseResourceCollectionWrapper) getCheckedRef()).iterator();
        }
        dieOnCircularReference();
        return new FailFast(this, cacheCollection().iterator());
    }

    
    public synchronized int size() {
        if (isReference()) {
            return ((BaseResourceCollectionWrapper) getCheckedRef()).size();
        }
        dieOnCircularReference();
        return cacheCollection().size();
    }

    
    public synchronized boolean isFilesystemOnly() {
        if (isReference()) {
            return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();
        }
        dieOnCircularReference();

        if (rc == null || rc.isFilesystemOnly()) {
            return true;
        }
        
        for (Iterator i = cacheCollection().iterator(); i.hasNext();) {
            if (!(i.next() instanceof FileResource)) {
                return false;
            }
        }
        return true;
    }

    
    protected synchronized void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            if (rc instanceof DataType) {
                stk.push(rc);
                invokeCircularReferenceCheck((DataType) rc, stk, p);
                stk.pop();
            }
            setChecked(true);
        }
    }

    
    protected final synchronized ResourceCollection getResourceCollection() {
        dieOnCircularReference();
        if (rc == null) {
            throw oneNested();
        }
        return rc;
    }

    
    protected abstract Collection getCollection();

    
    public synchronized String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        if (cacheCollection().size() == 0) {
            return """";
        }
        StringBuffer sb = new StringBuffer();
        for (Iterator i = coll.iterator(); i.hasNext();) {
            if (sb.length() > 0) {
                sb.append(File.pathSeparatorChar);
            }
            sb.append(i.next());
        }
        return sb.toString();
    }

    private synchronized Collection cacheCollection() {
        if (coll == null || !isCache()) {
            coll = getCollection();
        }
        return coll;
    }

    private BuildException oneNested() {
        return new BuildException(super.toString() + ONE_NESTED_MESSAGE);
    }

}
"
org.apache.tools.ant.taskdefs.BUnzip2,4,4,0,6,29,6,0,6,1,1.166666667,164,0.5,0,0.942307692,1.0,3,5,39.5,7,2.5,0,"

package org.apache.tools.ant.taskdefs;


import java.io.BufferedInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.bzip2.CBZip2InputStream;



public class BUnzip2 extends Unpack {

    private static final String DEFAULT_EXTENSION = "".bz2"";

    
    protected String getDefaultExtension() {
        return DEFAULT_EXTENSION;
    }

    
    protected void extract() {
        if (source.lastModified() > dest.lastModified()) {
            log(""Expanding "" + source.getAbsolutePath() + "" to ""
                + dest.getAbsolutePath());

            FileOutputStream out = null;
            CBZip2InputStream zIn = null;
            InputStream fis = null;
            BufferedInputStream bis = null;
            try {
                out = new FileOutputStream(dest);
                fis = srcResource.getInputStream();
                bis = new BufferedInputStream(fis);
                int b = bis.read();
                if (b != 'B') {
                    throw new BuildException(""Invalid bz2 file."", getLocation());
                }
                b = bis.read();
                if (b != 'Z') {
                    throw new BuildException(""Invalid bz2 file."", getLocation());
                }
                zIn = new CBZip2InputStream(bis);
                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    out.write(buffer, 0, count);
                    count = zIn.read(buffer, 0, buffer.length);
                } while (count != -1);
            } catch (IOException ioe) {
                String msg = ""Problem expanding bzip2 "" + ioe.getMessage();
                throw new BuildException(msg, ioe, getLocation());
            } finally {
                FileUtils.close(bis);
                FileUtils.close(fis);
                FileUtils.close(out);
                FileUtils.close(zIn);
            }
        }
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(BUnzip2.class);
    }
}
"
org.apache.tools.ant.util.Base64Converter,4,1,1,2,7,4,2,0,3,0.666666667,502,0.5,0,0.0,0.555555556,0,0,124.0,4,1.25,0,"
package org.apache.tools.ant.util;


public class Base64Converter {

    private static final char[] ALPHABET = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',  
        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',  
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',  
        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',  
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',  
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',  
        'w', 'x', 'y', 'z', '0', '1', '2', '3',  
        '4', '5', '6', '7', '8', '9', '+', '/'}; 

    
    
    public static final char[] alphabet = ALPHABET;
    


    
    public String encode(String s) {
        return encode(s.getBytes());
    }

    
    public String encode(byte[] octetString) {
        int bits24;
        int bits6;

        char[] out = new char[((octetString.length - 1) / 3 + 1) * 4];
        int outIndex = 0;
        int i = 0;

        while ((i + 3) <= octetString.length) {
            
            bits24 = (octetString[i++] & 0xFF) << 16;
            bits24 |= (octetString[i++] & 0xFF) << 8;
            bits24 |= octetString[i++];

            bits6 = (bits24 & 0x00FC0000) >> 18;
            out[outIndex++] = ALPHABET[bits6];
            bits6 = (bits24 & 0x0003F000) >> 12;
            out[outIndex++] = ALPHABET[bits6];
            bits6  = (bits24 & 0x00000FC0) >> 6;
            out[outIndex++] = ALPHABET[bits6];
            bits6 = (bits24 & 0x0000003F);
            out[outIndex++] = ALPHABET[bits6];
        }
        if (octetString.length - i == 2) {
            
            bits24 = (octetString[i] & 0xFF) << 16;
            bits24 |= (octetString[i + 1] & 0xFF) << 8;
            bits6 = (bits24 & 0x00FC0000) >> 18;
            out[outIndex++] = ALPHABET[bits6];
            bits6 = (bits24 & 0x0003F000) >> 12;
            out[outIndex++] = ALPHABET[bits6];
            bits6 = (bits24 & 0x00000FC0) >> 6;
            out[outIndex++] = ALPHABET[bits6];

            
            out[outIndex++] = '=';
        } else if (octetString.length - i == 1) {
            
            bits24 = (octetString[i] & 0xFF) << 16;
            bits6 = (bits24 & 0x00FC0000) >> 18;
            out[outIndex++] = ALPHABET[bits6];
            bits6 = (bits24 & 0x0003F000) >> 12;
            out[outIndex++] = ALPHABET[bits6];

            
            out[outIndex++] = '=';
            out[outIndex++] = '=';
        }
        return new String(out);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ssh.AbstractSshMessage,13,1,2,12,37,56,4,10,4,0.770833333,269,1.0,2,0.0,0.205128205,0,0,19.38461538,7,1.3846,0,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.SftpProgressMonitor;

import java.io.IOException;
import java.io.OutputStream;
import java.io.InputStream;
import java.text.NumberFormat;

import org.apache.tools.ant.BuildException;


public abstract class AbstractSshMessage {

    private Session session;
    private boolean verbose;
    private LogListener listener = new LogListener() {
        public void log(String message) {
            
        }
    };

    
    public AbstractSshMessage(Session session) {
        this(false, session);
    }

    
    public AbstractSshMessage(boolean verbose, Session session) {
        this.verbose = verbose;
        this.session = session;
    }

    
    protected Channel openExecChannel(String command) throws JSchException {
        ChannelExec channel = (ChannelExec) session.openChannel(""exec"");
        channel.setCommand(command);

        return channel;
    }

    
    protected ChannelSftp openSftpChannel() throws JSchException {
        ChannelSftp channel = (ChannelSftp) session.openChannel(""sftp"");

        return channel;
    }

    
    protected void sendAck(OutputStream out) throws IOException {
        byte[] buf = new byte[1];
        buf[0] = 0;
        out.write(buf);
        out.flush();
    }

    
    protected void waitForAck(InputStream in)
        throws IOException, BuildException {
        int b = in.read();

        
        
        

        if (b == -1) {
            
            throw new BuildException(""No response from server"");
        } else if (b != 0) {
            StringBuffer sb = new StringBuffer();

            int c = in.read();
            while (c > 0 && c != '\n') {
                sb.append((char) c);
                c = in.read();
            }

            if (b == 1) {
                throw new BuildException(""server indicated an error: ""
                                         + sb.toString());
            } else if (b == 2) {
                throw new BuildException(""server indicated a fatal error: ""
                                         + sb.toString());
            } else {
                throw new BuildException(""unknown response, code "" + b
                                         + "" message: "" + sb.toString());
            }
        }
    }

    
    public abstract void execute() throws IOException, JSchException;

    
    public void setLogListener(LogListener aListener) {
        listener = aListener;
    }

    
    protected void log(String message) {
        listener.log(message);
    }

    
    protected void logStats(long timeStarted,
                             long timeEnded,
                             long totalLength) {
        double duration = (timeEnded - timeStarted) / 1000.0;
        NumberFormat format = NumberFormat.getNumberInstance();
        format.setMaximumFractionDigits(2);
        format.setMinimumFractionDigits(1);
        listener.log(""File transfer time: "" + format.format(duration)
            + "" Average Rate: "" + format.format(totalLength / duration)
            + "" B/s"");
    }

    
    protected final boolean getVerbose() {
        return verbose;
    }

    
    protected final int trackProgress(long filesize, long totalLength,
                                      int percentTransmitted) {

        int percent = (int) Math.round(Math.floor((totalLength
                                                   / (double) filesize) * 100));

        if (percent > percentTransmitted) {
            if (filesize < 1048576) {
                if (percent % 10 == 0) {
                    if (percent == 100) {
                        System.out.println("" 100%"");
                    } else {
                        System.out.print(""*"");
                    }
                }
            } else {
                if (percent == 50) {
                    System.out.println("" 50%"");
                } else if (percent == 100) {
                    System.out.println("" 100%"");
                } else {
                    System.out.print(""."");
                }
            }
        }

        return percent;
    }

    private ProgressMonitor monitor = null;

    
    protected SftpProgressMonitor getProgressMonitor() {
        if (monitor == null) {
            monitor = new ProgressMonitor();
        }
        return monitor;
    }

    private class ProgressMonitor implements SftpProgressMonitor {
        private long initFileSize = 0;
        private long totalLength = 0;
        private int percentTransmitted = 0;

        public void init(int op, String src, String dest, long max) {
            initFileSize = max;
            totalLength = 0;
            percentTransmitted = 0;
        }

        public boolean count(long len) {
            totalLength += len;
            percentTransmitted = trackProgress(initFileSize,
                                               totalLength,
                                               percentTransmitted);
            return true;
        }

        public void end() {
        }

        public long getTotalLength() {
            return totalLength;
        }
    }
}
"
org.apache.tools.ant.types.resources.selectors.Majority,4,4,0,3,11,0,0,3,4,0.0,84,1.0,0,0.945945946,0.4375,0,0,19.75,12,3.25,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.util.Iterator;

import org.apache.tools.ant.types.Resource;


public class Majority
    extends ResourceSelectorContainer implements ResourceSelector {

    private boolean tie = true;

    
    public Majority() {
    }

    
    public Majority(ResourceSelector[] r) {
        super(r);
    }

    
    public synchronized void setAllowtie(boolean b) {
        tie = b;
    }

    
    public synchronized boolean isSelected(Resource r) {
        int passed = 0;
        int failed = 0;
        int count = selectorCount();
        boolean even = count % 2 == 0;
        int threshold = count / 2;

        for (Iterator i = getSelectors(); i.hasNext();) {
            if (((ResourceSelector) i.next()).isSelected(r)) {
                ++passed;
                if (passed > threshold || (even && tie && passed == threshold)) {
                    return true;
                }
            } else {
                ++failed;
                if (failed > threshold || (even && !tie && failed == threshold)) {
                    return false;
                }
            }
        }
        
        return false;
    }

}
"
org.apache.tools.ant.taskdefs.FixCRLF,21,4,0,15,72,54,1,14,16,0.835,457,0.9,2,0.804123711,0.194444444,2,2,20.28571429,3,1.0,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.Reader;
import java.io.FileReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.Vector;
import java.util.Enumeration;
import java.util.NoSuchElementException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.filters.FixCrLfFilter;
import org.apache.tools.ant.filters.ChainableReader;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.util.FileUtils;



public class FixCRLF extends MatchingTask implements ChainableReader {

    
    public static final String ERROR_FILE_AND_SRCDIR
        = ""srcdir and file are mutually exclusive"";

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private boolean preserveLastModified = false;
    private File srcDir;
    private File destDir = null;
    private File file;
    private FixCrLfFilter filter = new FixCrLfFilter();
    private Vector fcv = null;

    
    private String encoding = null;

    
    private String outputEncoding = null;

    
    public final Reader chain(final Reader rdr) {
        return filter.chain(rdr);
    }

    
    public void setSrcdir(File srcDir) {
        this.srcDir = srcDir;
    }

    
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }

    
    public void setJavafiles(boolean javafiles) {
        filter.setJavafiles(javafiles);
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setEol(CrLf attr) {
        filter.setEol(FixCrLfFilter.CrLf.newInstance(attr.getValue()));
    }

    
    public void setCr(AddAsisRemove attr) {
        log(""DEPRECATED: The cr attribute has been deprecated,"",
            Project.MSG_WARN);
        log(""Please use the eol attribute instead"", Project.MSG_WARN);
        String option = attr.getValue();
        CrLf c = new CrLf();
        if (option.equals(""remove"")) {
            c.setValue(""lf"");
        } else if (option.equals(""asis"")) {
            c.setValue(""asis"");
        } else {
            
            c.setValue(""crlf"");
        }
        setEol(c);
    }

    
    public void setTab(AddAsisRemove attr) {
        filter.setTab(FixCrLfFilter.AddAsisRemove.newInstance(attr.getValue()));
    }

    
    public void setTablength(int tlength) throws BuildException {
        try {
            filter.setTablength(tlength);
        } catch (IOException e) {
            throw new BuildException(e);
        }
    }

    
    public void setEof(AddAsisRemove attr) {
        filter.setEof(FixCrLfFilter.AddAsisRemove.newInstance(attr.getValue()));
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public void setOutputEncoding(String outputEncoding) {
        this.outputEncoding = outputEncoding;
    }

    
    public void setFixlast(boolean fixlast) {
        filter.setFixlast(fixlast);
    }

    
    public void setPreserveLastModified(boolean preserve) {
        preserveLastModified = preserve;
    }

    
    public void execute() throws BuildException {
        
        validate();

        
        String enc = encoding == null ? ""default"" : encoding;
        log(""options:""
            + "" eol="" + filter.getEol().getValue()
            + "" tab="" + filter.getTab().getValue()
            + "" eof="" + filter.getEof().getValue()
            + "" tablength="" + filter.getTablength()
            + "" encoding="" + enc
            + "" outputencoding=""
            + (outputEncoding == null ? enc : outputEncoding),
            Project.MSG_VERBOSE);

        DirectoryScanner ds = super.getDirectoryScanner(srcDir);
        String[] files = ds.getIncludedFiles();

        for (int i = 0; i < files.length; i++) {
            processFile(files[i]);
        }
    }

    private void validate() throws BuildException {
        if (file != null) {
            if (srcDir != null) {
                throw new BuildException(ERROR_FILE_AND_SRCDIR);
            }
            
            fileset.setFile(file);
            
            srcDir = file.getParentFile();
        }
        if (srcDir == null) {
            throw new BuildException(""srcdir attribute must be set!"");
        }
        if (!srcDir.exists()) {
            throw new BuildException(""srcdir does not exist!"");
        }
        if (!srcDir.isDirectory()) {
            throw new BuildException(""srcdir is not a directory!"");
        }
        if (destDir != null) {
            if (!destDir.exists()) {
                throw new BuildException(""destdir does not exist!"");
            }
            if (!destDir.isDirectory()) {
                throw new BuildException(""destdir is not a directory!"");
            }
        }
    }

    private void processFile(String file) throws BuildException {
        File srcFile = new File(srcDir, file);
        long lastModified = srcFile.lastModified();
        File destD = destDir == null ? srcDir : destDir;

        if (fcv == null) {
            FilterChain fc = new FilterChain();
            fc.add(filter);
            fcv = new Vector(1);
            fcv.add(fc);
        }
        File tmpFile = FILE_UTILS.createTempFile(""fixcrlf"", """", null);
        tmpFile.deleteOnExit();
        try {
            FILE_UTILS.copyFile(srcFile, tmpFile, null, fcv, false, false,
                encoding, outputEncoding == null ? encoding : outputEncoding,
                getProject());

            File destFile = new File(destD, file);

            boolean destIsWrong = true;
            if (destFile.exists()) {
                
                log(""destFile exists"", Project.MSG_DEBUG);
                destIsWrong = !FILE_UTILS.contentEquals(destFile, tmpFile);
                log(destFile + (destIsWrong ? "" is being written""
                    : "" is not written, as the contents are identical""),
                    Project.MSG_DEBUG);
            }
            if (destIsWrong) {
                FILE_UTILS.rename(tmpFile, destFile);
                if (preserveLastModified) {
                    log(""preserved lastModified"", Project.MSG_DEBUG);
                    FILE_UTILS.setFileLastModified(destFile, lastModified);
                }
                tmpFile = null;
            }
        } catch (IOException e) {
            throw new BuildException(e);
        }
    }

    
    protected class OneLiner implements Enumeration {
        private static final int UNDEF = -1;
        private static final int NOTJAVA = 0;
        private static final int LOOKING = 1;
        private static final int INBUFLEN = 8192;
        private static final int LINEBUFLEN = 200;
        private static final char CTRLZ = '\u001A';

        private int state = filter.getJavafiles() ? LOOKING : NOTJAVA;

        private StringBuffer eolStr = new StringBuffer(LINEBUFLEN);
        private StringBuffer eofStr = new StringBuffer();

        private BufferedReader reader;
        private StringBuffer line = new StringBuffer();
        private boolean reachedEof = false;
        private File srcFile;

        
        public OneLiner(File srcFile)
            throws BuildException {
            this.srcFile = srcFile;
            try {
                reader = new BufferedReader(
                    ((encoding == null) ? new FileReader(srcFile)
                    : new InputStreamReader(
                    new FileInputStream(srcFile), encoding)), INBUFLEN);

                nextLine();
            } catch (IOException e) {
                throw new BuildException(srcFile + "": "" + e.getMessage(),
                                         e, getLocation());
            }
        }

        
        protected void nextLine()
            throws BuildException {
            int ch = -1;
            int eolcount = 0;

            eolStr = new StringBuffer();
            line = new StringBuffer();

            try {
                ch = reader.read();
                while (ch != -1 && ch != '\r' && ch != '\n') {
                    line.append((char) ch);
                    ch = reader.read();
                }

                if (ch == -1 && line.length() == 0) {
                    
                    reachedEof = true;
                    return;
                }

                switch ((char) ch) {
                case '\r':
                    
                    
                    ++eolcount;
                    eolStr.append('\r');
                    reader.mark(2);
                    ch = reader.read();
                    switch (ch) {
                    case '\r':
                        ch = reader.read();
                        if ((char) (ch) == '\n') {
                            eolcount += 2;
                            eolStr.append(""\r\n"");
                        } else {
                            reader.reset();
                        }
                        break;
                    case '\n':
                        ++eolcount;
                        eolStr.append('\n');
                        break;
                    case -1:
                        
                        
                        break;
                    default:
                        reader.reset();
                        break;
                    } 
                    break;

                case '\n':
                    ++eolcount;
                    eolStr.append('\n');
                    break;
                default:
                    
                } 

                
                
                if (eolcount == 0) {
                    int i = line.length();
                    while (--i >= 0 && line.charAt(i) == CTRLZ) {
                        
                    }
                    if (i < line.length() - 1) {
                        
                        
                        eofStr.append(line.toString().substring(i + 1));
                        if (i < 0) {
                            line.setLength(0);
                            reachedEof = true;
                        } else {
                            line.setLength(i + 1);
                        }
                    }

                } 

            } catch (IOException e) {
                throw new BuildException(srcFile + "": "" + e.getMessage(),
                                         e, getLocation());
            }
        }

        
        public String getEofStr() {
            return eofStr.substring(0);
        }

        
        public int getState() {
            return state;
        }

        
        public void setState(int state) {
            this.state = state;
        }

        
        public boolean hasMoreElements() {
            return !reachedEof;
        }

        
        public Object nextElement()
            throws NoSuchElementException {
            if (!hasMoreElements()) {
                throw new NoSuchElementException(""OneLiner"");
            }
            BufferLine tmpLine =
                    new BufferLine(line.toString(), eolStr.substring(0));
            nextLine();
            return tmpLine;
        }

        
        public void close() throws IOException {
            if (reader != null) {
                reader.close();
            }
        }

        class BufferLine {
            private int next = 0;
            private int column = 0;
            private int lookahead = UNDEF;
            private String line;
            private String eolStr;

            public BufferLine(String line, String eolStr)
                throws BuildException {
                next = 0;
                column = 0;
                this.line = line;
                this.eolStr = eolStr;
            }

            public int getNext() {
                return next;
            }

            public void setNext(int next) {
                this.next = next;
            }

            public int getLookahead() {
                return lookahead;
            }

            public void setLookahead(int lookahead) {
                this.lookahead = lookahead;
            }

            public char getChar(int i) {
                return line.charAt(i);
            }

            public char getNextChar() {
                return getChar(next);
            }

            public char getNextCharInc() {
                return getChar(next++);
            }

            public int getColumn() {
                return column;
            }

            public void setColumn(int col) {
                column = col;
            }

            public int incColumn() {
                return column++;
            }

            public int length() {
                return line.length();
            }

            public int getEolLength() {
                return eolStr.length();
            }

            public String getLineString() {
                return line;
            }

            public String getEol() {
                return eolStr;
            }

            public String substring(int begin) {
                return line.substring(begin);
            }

            public String substring(int begin, int end) {
                return line.substring(begin, end);
            }

            public void setState(int state) {
                OneLiner.this.setState(state);
            }

            public int getState() {
                return OneLiner.this.getState();
            }
        }
    }

    
    public static class AddAsisRemove extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""add"", ""asis"", ""remove""};
        }
    }

    
    public static class CrLf extends EnumeratedAttribute {
        
        
        public String[] getValues() {
            return new String[] {""asis"", ""cr"", ""lf"", ""crlf"",
                                 ""mac"", ""unix"", ""dos""};
        }
    }

}

"
org.apache.tools.ant.taskdefs.optional.j2ee.HotDeploymentTool,3,1,0,5,3,3,4,2,3,1.5,8,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.j2ee;

import org.apache.tools.ant.BuildException;


public interface HotDeploymentTool {
    
    String ACTION_DELETE = ""delete"";

    
    String ACTION_DEPLOY = ""deploy"";

    
    String ACTION_LIST = ""list"";

    
    String ACTION_UNDEPLOY = ""undeploy"";

    
    String ACTION_UPDATE = ""update"";

    
    void validateAttributes() throws BuildException;

    
    void deploy() throws BuildException;

    
    void setTask(ServerDeploy task);
}
"
org.apache.tools.ant.types.resources.Intersect,3,4,0,3,19,3,0,3,1,2.0,83,0.0,0,0.956521739,0.666666667,1,1,26.66666667,4,2.0,0,"
package org.apache.tools.ant.types.resources;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collection;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.ResourceCollection;


public class Intersect extends BaseResourceCollectionContainer {

    
    protected Collection getCollection() {
        List rcs = getResourceCollections();
        int size = rcs.size();
        if (size < 2) {
            throw new BuildException(""The intersection of "" + size
                + "" resource collection"" + ((size == 1) ? """" : ""s"")
                + "" is undefined."");
        }
        ArrayList al = new ArrayList();
        Iterator rc = rcs.iterator();
        al.addAll(collect(rc.next()));
        while (rc.hasNext()) {
            al.retainAll(collect(rc.next()));
        }
        return al;
    }

    private ArrayList collect(Object o) {
        ArrayList result = new ArrayList();
        for (Iterator i = ((ResourceCollection) o).iterator(); i.hasNext();) {
            result.add(i.next());
        }
        return result;
    }
}
"
org.apache.tools.ant.taskdefs.Javac,77,4,1,29,123,2700,14,17,68,0.977951636,1021,1.0,6,0.506493506,0.20593692,1,1,11.77922078,14,1.7532,3,"

package org.apache.tools.ant.taskdefs;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.compilers.CompilerAdapter;
import org.apache.tools.ant.taskdefs.compilers.CompilerAdapterFactory;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.GlobPatternMapper;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.SourceFileScanner;
import org.apache.tools.ant.util.facade.FacadeTaskHelper;



public class Javac extends MatchingTask {

    private static final String FAIL_MSG
        = ""Compile failed; see the compiler error output for details."";

    private static final String JAVAC16 = ""javac1.6"";
    private static final String JAVAC15 = ""javac1.5"";
    private static final String JAVAC14 = ""javac1.4"";
    private static final String JAVAC13 = ""javac1.3"";
    private static final String JAVAC12 = ""javac1.2"";
    private static final String JAVAC11 = ""javac1.1"";
    private static final String MODERN = ""modern"";
    private static final String CLASSIC = ""classic"";
    private static final String EXTJAVAC = ""extJavac"";

    private Path src;
    private File destDir;
    private Path compileClasspath;
    private Path compileSourcepath;
    private String encoding;
    private boolean debug = false;
    private boolean optimize = false;
    private boolean deprecation = false;
    private boolean depend = false;
    private boolean verbose = false;
    private String targetAttribute;
    private Path bootclasspath;
    private Path extdirs;
    private boolean includeAntRuntime = true;
    private boolean includeJavaRuntime = false;
    private boolean fork = false;
    private String forkedExecutable = null;
    private boolean nowarn = false;
    private String memoryInitialSize;
    private String memoryMaximumSize;
    private FacadeTaskHelper facade = null;

    
    protected boolean failOnError = true;
    protected boolean listFiles = false;
    protected File[] compileList = new File[0];
    

    private String source;
    private String debugLevel;
    private File tmpDir;

    
    public Javac() {
        facade = new FacadeTaskHelper(assumedJavaVersion());
    }

    private String assumedJavaVersion() {
        if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2)) {
            return JAVAC12;
        } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3)) {
            return JAVAC13;
        } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4)) {
            return JAVAC14;
        } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_5)) {
            return JAVAC15;
        } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6)) {
            return JAVAC16;
        } else {
            return CLASSIC;
        }
    }

    
    public String getDebugLevel() {
        return debugLevel;
    }

    
    public void setDebugLevel(String  v) {
        this.debugLevel = v;
    }

    
    public String getSource() {
        return source != null
            ? source : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
    }

    
    public void setSource(String  v) {
        this.source = v;
    }

    
    public Path createSrc() {
        if (src == null) {
            src = new Path(getProject());
        }
        return src.createPath();
    }

    
    protected Path recreateSrc() {
        src = null;
        return createSrc();
    }

    
    public void setSrcdir(Path srcDir) {
        if (src == null) {
            src = srcDir;
        } else {
            src.append(srcDir);
        }
    }

    
    public Path getSrcdir() {
        return src;
    }

    
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }

    
    public File getDestdir() {
        return destDir;
    }

    
    public void setSourcepath(Path sourcepath) {
        if (compileSourcepath == null) {
            compileSourcepath = sourcepath;
        } else {
            compileSourcepath.append(sourcepath);
        }
    }

    
    public Path getSourcepath() {
        return compileSourcepath;
    }

    
    public Path createSourcepath() {
        if (compileSourcepath == null) {
            compileSourcepath = new Path(getProject());
        }
        return compileSourcepath.createPath();
    }

    
    public void setSourcepathRef(Reference r) {
        createSourcepath().setRefid(r);
    }

    
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }

    
    public Path getClasspath() {
        return compileClasspath;
    }

    
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(getProject());
        }
        return compileClasspath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setBootclasspath(Path bootclasspath) {
        if (this.bootclasspath == null) {
            this.bootclasspath = bootclasspath;
        } else {
            this.bootclasspath.append(bootclasspath);
        }
    }

    
    public Path getBootclasspath() {
        return bootclasspath;
    }

    
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(getProject());
        }
        return bootclasspath.createPath();
    }

    
    public void setBootClasspathRef(Reference r) {
        createBootclasspath().setRefid(r);
    }

    
    public void setExtdirs(Path extdirs) {
        if (this.extdirs == null) {
            this.extdirs = extdirs;
        } else {
            this.extdirs.append(extdirs);
        }
    }

    
    public Path getExtdirs() {
        return extdirs;
    }

    
    public Path createExtdirs() {
        if (extdirs == null) {
            extdirs = new Path(getProject());
        }
        return extdirs.createPath();
    }

    
    public void setListfiles(boolean list) {
        listFiles = list;
    }

    
    public boolean getListfiles() {
        return listFiles;
    }

    
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }

    
    public void setProceed(boolean proceed) {
        failOnError = !proceed;
    }

    
    public boolean getFailonerror() {
        return failOnError;
    }

    
    public void setDeprecation(boolean deprecation) {
        this.deprecation = deprecation;
    }

    
    public boolean getDeprecation() {
        return deprecation;
    }

    
    public void setMemoryInitialSize(String memoryInitialSize) {
        this.memoryInitialSize = memoryInitialSize;
    }

    
    public String getMemoryInitialSize() {
        return memoryInitialSize;
    }

    
    public void setMemoryMaximumSize(String memoryMaximumSize) {
        this.memoryMaximumSize = memoryMaximumSize;
    }

    
    public String getMemoryMaximumSize() {
        return memoryMaximumSize;
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public String getEncoding() {
        return encoding;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public boolean getDebug() {
        return debug;
    }

    
    public void setOptimize(boolean optimize) {
        this.optimize = optimize;
    }

    
    public boolean getOptimize() {
        return optimize;
    }

    
    public void setDepend(boolean depend) {
        this.depend = depend;
    }

    
    public boolean getDepend() {
        return depend;
    }

    
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    
    public boolean getVerbose() {
        return verbose;
    }

    
    public void setTarget(String target) {
        this.targetAttribute = target;
    }

    
    public String getTarget() {
        return targetAttribute != null
            ? targetAttribute
            : getProject().getProperty(MagicNames.BUILD_JAVAC_TARGET);
    }

    
    public void setIncludeantruntime(boolean include) {
        includeAntRuntime = include;
    }

    
    public boolean getIncludeantruntime() {
        return includeAntRuntime;
    }

    
    public void setIncludejavaruntime(boolean include) {
        includeJavaRuntime = include;
    }

    
    public boolean getIncludejavaruntime() {
        return includeJavaRuntime;
    }

    
    public void setFork(boolean f) {
        fork = f;
    }

    
    public void setExecutable(String forkExec) {
        forkedExecutable = forkExec;
    }

    
    public String getExecutable() {
        return forkedExecutable;
    }

    
    public boolean isForkedJavac() {
        return fork || ""extJavac"".equals(getCompiler());
    }

    
    public String getJavacExecutable() {
        if (forkedExecutable == null && isForkedJavac()) {
            forkedExecutable = getSystemJavac();
        } else if (forkedExecutable != null && !isForkedJavac()) {
            forkedExecutable = null;
        }
        return forkedExecutable;
    }

    
    public void setNowarn(boolean flag) {
        this.nowarn = flag;
    }

    
    public boolean getNowarn() {
        return nowarn;
    }

    
    public ImplementationSpecificArgument createCompilerArg() {
        ImplementationSpecificArgument arg =
            new ImplementationSpecificArgument();
        facade.addImplementationArgument(arg);
        return arg;
    }

    
    public String[] getCurrentCompilerArgs() {
        String chosen = facade.getExplicitChoice();
        try {
            
            String appliedCompiler = getCompiler();
            facade.setImplementation(appliedCompiler);

            String[] result = facade.getArgs();

            String altCompilerName = getAltCompilerName(facade.getImplementation());

            if (result.length == 0 && altCompilerName != null) {
                facade.setImplementation(altCompilerName);
                result = facade.getArgs();
            }

            return result;

        } finally {
            facade.setImplementation(chosen);
        }
    }

    private String getAltCompilerName(String anImplementation) {
        if (JAVAC16.equalsIgnoreCase(anImplementation)
                || JAVAC15.equalsIgnoreCase(anImplementation)
                || JAVAC14.equalsIgnoreCase(anImplementation)
                || JAVAC13.equalsIgnoreCase(anImplementation)) {
            return MODERN;
        }
        if (JAVAC12.equalsIgnoreCase(anImplementation)
                || JAVAC11.equalsIgnoreCase(anImplementation)) {
            return CLASSIC;
        }
        if (MODERN.equalsIgnoreCase(anImplementation)) {
            String nextSelected = assumedJavaVersion();
            if (JAVAC16.equalsIgnoreCase(nextSelected)
                    || JAVAC15.equalsIgnoreCase(nextSelected)
                    || JAVAC14.equalsIgnoreCase(nextSelected)
                    || JAVAC13.equalsIgnoreCase(nextSelected)) {
                return nextSelected;
            }
        }
        if (CLASSIC.equals(anImplementation)) {
            return assumedJavaVersion();
        }
        if (EXTJAVAC.equalsIgnoreCase(anImplementation)) {
            return assumedJavaVersion();
        }
        return null;
    }

    
    public void setTempdir(File tmpDir) {
        this.tmpDir = tmpDir;
    }

    
    public File getTempdir() {
        return tmpDir;
    }

    
    public void execute() throws BuildException {
        checkParameters();
        resetFileLists();

        
        
        String[] list = src.list();
        for (int i = 0; i < list.length; i++) {
            File srcDir = getProject().resolveFile(list[i]);
            if (!srcDir.exists()) {
                throw new BuildException(""srcdir \""""
                                         + srcDir.getPath()
                                         + ""\"" does not exist!"", getLocation());
            }

            DirectoryScanner ds = this.getDirectoryScanner(srcDir);
            String[] files = ds.getIncludedFiles();

            scanDir(srcDir, destDir != null ? destDir : srcDir, files);
        }

        compile();
    }

    
    protected void resetFileLists() {
        compileList = new File[0];
    }

    
    protected void scanDir(File srcDir, File destDir, String[] files) {
        GlobPatternMapper m = new GlobPatternMapper();
        m.setFrom(""*.java"");
        m.setTo(""*.class"");
        SourceFileScanner sfs = new SourceFileScanner(this);
        File[] newFiles = sfs.restrictAsFiles(files, srcDir, destDir, m);

        if (newFiles.length > 0) {
            File[] newCompileList
                = new File[compileList.length + newFiles.length];
            System.arraycopy(compileList, 0, newCompileList, 0,
                    compileList.length);
            System.arraycopy(newFiles, 0, newCompileList,
                    compileList.length, newFiles.length);
            compileList = newCompileList;
        }
    }

    
    public File[] getFileList() {
        return compileList;
    }

    
    protected boolean isJdkCompiler(String compilerImpl) {
        return MODERN.equals(compilerImpl)
            || CLASSIC.equals(compilerImpl)
            || JAVAC16.equals(compilerImpl)
            || JAVAC15.equals(compilerImpl)
            || JAVAC14.equals(compilerImpl)
            || JAVAC13.equals(compilerImpl)
            || JAVAC12.equals(compilerImpl)
            || JAVAC11.equals(compilerImpl);
    }

    
    protected String getSystemJavac() {
        return JavaEnvUtils.getJdkExecutable(""javac"");
    }

    
    public void setCompiler(String compiler) {
        facade.setImplementation(compiler);
    }

    
    public String getCompiler() {
        String compilerImpl = getCompilerVersion();
        if (fork) {
            if (isJdkCompiler(compilerImpl)) {
                compilerImpl = ""extJavac"";
            } else {
                log(""Since compiler setting isn't classic or modern,""
                    + ""ignoring fork setting."", Project.MSG_WARN);
            }
        }
        return compilerImpl;
    }

    
    public String getCompilerVersion() {
        facade.setMagicValue(getProject().getProperty(""build.compiler""));
        return facade.getImplementation();
    }

    
    protected void checkParameters() throws BuildException {
        if (src == null) {
            throw new BuildException(""srcdir attribute must be set!"",
                                     getLocation());
        }
        if (src.size() == 0) {
            throw new BuildException(""srcdir attribute must be set!"",
                                     getLocation());
        }

        if (destDir != null && !destDir.isDirectory()) {
            throw new BuildException(""destination directory \""""
                                     + destDir
                                     + ""\"" does not exist ""
                                     + ""or is not a directory"", getLocation());
        }
    }

    
    protected void compile() {
        String compilerImpl = getCompiler();

        if (compileList.length > 0) {
            log(""Compiling "" + compileList.length + "" source file""
                + (compileList.length == 1 ? """" : ""s"")
                + (destDir != null ? "" to "" + destDir : """"));

            if (listFiles) {
                for (int i = 0; i < compileList.length; i++) {
                  String filename = compileList[i].getAbsolutePath();
                  log(filename);
                }
            }

            CompilerAdapter adapter =
                CompilerAdapterFactory.getCompiler(compilerImpl, this);

            
            adapter.setJavac(this);

            
            if (!adapter.execute()) {
                if (failOnError) {
                    throw new BuildException(FAIL_MSG, getLocation());
                } else {
                    log(FAIL_MSG, Project.MSG_ERR);
                }
            }
        }
    }

    
    public class ImplementationSpecificArgument extends
        org.apache.tools.ant.util.facade.ImplementationSpecificArgument {

        
        public void setCompiler(String impl) {
            super.setImplementation(impl);
        }
    }

}
"
org.apache.tools.ant.types.resources.Touchable,1,1,0,4,1,0,4,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.types.resources;


public interface Touchable {
    
    void touch(long modTime);
}
"
org.apache.tools.ant.taskdefs.optional.extension.resolvers.LocationResolver,4,1,0,5,10,0,1,4,4,0.333333333,36,1.0,0,0.0,0.4375,0,0,7.75,1,0.75,0,"
package org.apache.tools.ant.taskdefs.optional.extension.resolvers;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.optional.extension.Extension;
import org.apache.tools.ant.taskdefs.optional.extension.ExtensionResolver;


public class LocationResolver implements ExtensionResolver {
    private String location;

    
    public void setLocation(final String location) {
        this.location = location;
    }

    
    public File resolve(final Extension extension,
                        final Project project) throws BuildException {
        if (null == location) {
            final String message = ""No location specified for resolver"";
            throw new BuildException(message);
        }

        return project.resolveFile(location);
    }
    
    public String toString() {
        return ""Location["" + location + ""]"";
    }
}
"
org.apache.tools.ant.taskdefs.optional.sos.SOSGet,6,4,0,3,20,15,0,3,5,2.0,106,0.0,0,0.936708861,0.555555556,1,2,16.66666667,4,1.3333,0,"
package org.apache.tools.ant.taskdefs.optional.sos;

import org.apache.tools.ant.types.Commandline;


public class SOSGet extends SOS {

    
    public final void setFile(String filename) {
        super.setInternalFilename(filename);
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public void setVersion(String version) {
        super.setInternalVersion(version);
    }

    
    public void setLabel(String label) {
        super.setInternalLabel(label);
    }

    
    protected Commandline buildCmdLine() {
        commandLine = new Commandline();

        
        if (getFilename() != null) {
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
            commandLine.createArgument().setValue(SOSCmd.COMMAND_GET_FILE);
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_FILE);
            commandLine.createArgument().setValue(getFilename());
            
            if (getVersion() != null) {
                
                commandLine.createArgument().setValue(SOSCmd.FLAG_VERSION);
                commandLine.createArgument().setValue(getVersion());
            }
        } else {
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
            commandLine.createArgument().setValue(SOSCmd.COMMAND_GET_PROJECT);
            
            commandLine.createArgument().setValue(getRecursive());
            
            if (getLabel() != null) {
                commandLine.createArgument().setValue(SOSCmd.FLAG_LABEL);
                commandLine.createArgument().setValue(getLabel());
            }
        }

        getRequiredAttributes();
        getOptionalAttributes();

        return commandLine;
    }
}
"
org.apache.tools.ant.types.ArchiveScanner,17,2,2,9,51,28,5,4,12,0.546875,344,1.0,2,0.792207792,0.294117647,2,4,18.76470588,5,2.1176,2,"

package org.apache.tools.ant.types;

import java.io.File;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Iterator;

import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.FileResourceIterator;


public abstract class ArchiveScanner extends DirectoryScanner {
    

    
    protected File srcFile;

    

    
    private Resource src;

    
    private Resource lastScannedResource;

    
    private TreeMap fileEntries = new TreeMap();

    
    private TreeMap dirEntries = new TreeMap();

    
    private TreeMap matchFileEntries = new TreeMap();

    
    private TreeMap matchDirEntries = new TreeMap();

    
    private String encoding;

    
    public void scan() {
        if (src == null) {
            return;
        }
        super.scan();
    }

    
    public void setSrc(File srcFile) {
        setSrc(new FileResource(srcFile));
    }

    
    public void setSrc(Resource src) {
        this.src = src;
        if (src instanceof FileResource) {
            srcFile = ((FileResource) src).getFile();
        }
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public String[] getIncludedFiles() {
        if (src == null) {
            return super.getIncludedFiles();
        }
        scanme();
        Set s = matchFileEntries.keySet();
        return (String[]) (s.toArray(new String[s.size()]));
    }

    
    public int getIncludedFilesCount() {
        if (src == null) {
            return super.getIncludedFilesCount();
        }
        scanme();
        return matchFileEntries.size();
    }

    
    public String[] getIncludedDirectories() {
        if (src == null) {
            return super.getIncludedDirectories();
        }
        scanme();
        Set s = matchDirEntries.keySet();
        return (String[]) (s.toArray(new String[s.size()]));
    }

    
    public int getIncludedDirsCount() {
        if (src == null) {
            return super.getIncludedDirsCount();
        }
        scanme();
        return matchDirEntries.size();
    }

    
     Iterator getResourceFiles() {
        if (src == null) {
            return new FileResourceIterator(getBasedir(), getIncludedFiles());
        }
        scanme();
        return matchFileEntries.values().iterator();
    }

    
      Iterator getResourceDirectories() {
        if (src == null) {
            return new FileResourceIterator(getBasedir(), getIncludedDirectories());
        }
        scanme();
        return matchDirEntries.values().iterator();
    }

    
    public void init() {
        if (includes == null) {
            
            includes = new String[1];
            includes[0] = ""**"";
        }
        if (excludes == null) {
            excludes = new String[0];
        }
    }

    
    public boolean match(String path) {
        String vpath = path.replace('/', File.separatorChar).
            replace('\\', File.separatorChar);
        return isIncluded(vpath) && !isExcluded(vpath);
    }

    
    public Resource getResource(String name) {
        if (src == null) {
            return super.getResource(name);
        }
        if (name.equals("""")) {
            
            return new Resource("""", true, Long.MAX_VALUE, true);
        }
        
        scanme();
        if (fileEntries.containsKey(name)) {
            return (Resource) fileEntries.get(name);
        }
        name = trimSeparator(name);

        if (dirEntries.containsKey(name)) {
            return (Resource) dirEntries.get(name);
        }
        return new Resource(name);
    }

    
    protected abstract void fillMapsFromArchive(Resource archive,
                                                String encoding,
                                                Map fileEntries,
                                                Map matchFileEntries,
                                                Map dirEntries,
                                                Map matchDirEntries);

    
    private void scanme() {
        
        Resource thisresource = new Resource(src.getName(),
                                             src.isExists(),
                                             src.getLastModified());
        
        if (lastScannedResource != null
            && lastScannedResource.getName().equals(thisresource.getName())
            && lastScannedResource.getLastModified()
            == thisresource.getLastModified()) {
            return;
        }
        init();

        fileEntries.clear();
        dirEntries.clear();
        matchFileEntries.clear();
        matchDirEntries.clear();
        fillMapsFromArchive(src, encoding, fileEntries, matchFileEntries,
                            dirEntries, matchDirEntries);

        
        lastScannedResource = thisresource;
    }

    
    protected static final String trimSeparator(String s) {
        return s.endsWith(""/"") ? s.substring(0, s.length() - 1) : s;
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.Utf8CPInfo,4,2,0,5,9,0,5,1,4,0.333333333,27,1.0,0,0.666666667,0.625,1,1,5.5,1,0.75,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class Utf8CPInfo extends ConstantPoolEntry {
    
    private String value;

    
    public Utf8CPInfo() {
        super(CONSTANT_UTF8, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        value = cpStream.readUTF();
    }

    
    public String toString() {
        return ""UTF8 Value = "" + value;
    }

    
    public String getValue() {
        return value;
    }

}

"
org.apache.tools.ant.types.resources.JavaResource,11,4,0,8,45,15,1,7,11,0.566666667,279,0.666666667,2,0.85483871,0.327272727,3,6,24.09090909,10,2.5455,1,"
package org.apache.tools.ant.types.resources;

import java.io.IOException;
import java.io.InputStream;

import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Reference;


public class JavaResource extends Resource {

    private Path classpath;
    private Reference loader;

    
    public JavaResource() {
    }

    
    public JavaResource(String name, Path path) {
        setName(name);
        classpath = path;
    }

    
    public void setClasspath(Path classpath) {
        checkAttributesAllowed();
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        checkChildrenAllowed();
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        checkAttributesAllowed();
        createClasspath().setRefid(r);
    }

    
    public Path getClasspath() {
        return isReference()
            ? ((JavaResource) getCheckedRef()).getClasspath() : classpath;
    }

    
    public void setLoaderRef(Reference r) {
        checkAttributesAllowed();
        loader = r;
    }

    
    public void setRefid(Reference r) {
        if (loader != null || classpath != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public boolean isExists() {
        InputStream is = null;
        try {
            return isReference() ? ((Resource) getCheckedRef()).isExists()
                : (is = getInputStream()) != null;
        } catch (IOException ex) {
            return false;
        } finally {
            FileUtils.close(is);
        }
    }

    
    public InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        ClassLoader cl = null;
        if (loader != null) {
            cl = (ClassLoader) loader.getReferencedObject();
        }
        if (cl == null) {
            if (getClasspath() != null) {
                cl = getProject().createClassLoader(classpath);
            } else {
                cl = JavaResource.class.getClassLoader();
            }
            if (loader != null && cl != null) {
                getProject().addReference(loader.getRefId(), cl);
            }
        }

        return cl == null ? ClassLoader.getSystemResourceAsStream(getName())
            : cl.getResourceAsStream(getName());
    }

    
    public int compareTo(Object another) {
        if (isReference()) {
            return ((Comparable) getCheckedRef()).compareTo(another);
        }
        if (another.getClass().equals(getClass())) {
            JavaResource otherjr = (JavaResource) another;
            if (!getName().equals(otherjr.getName())) {
                return getName().compareTo(otherjr.getName());
            }
            if (loader != otherjr.loader) {
                if (loader == null) {
                    return -1;
                }
                if (otherjr.loader == null) {
                    return 1;
                }
                return loader.getRefId().compareTo(otherjr.loader.getRefId());
            }
            Path p = getClasspath();
            Path op = otherjr.getClasspath();
            if (p != op) {
                if (p == null) {
                    return -1;
                }
                if (op == null) {
                    return 1;
                }
                return p.toString().compareTo(op.toString());
            }
            return 0;
        }
        return super.compareTo(another);
    }

}
"
org.apache.tools.ant.taskdefs.optional.ejb.IPlanetDeploymentTool,13,2,0,8,49,54,1,7,7,0.84375,450,1.0,0,0.727272727,0.346153846,2,6,33.0,6,1.3077,1,"

package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import javax.xml.parsers.SAXParser;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.xml.sax.SAXException;


public class IPlanetDeploymentTool extends GenericDeploymentTool {

    
    private File    iashome;
    private String  jarSuffix     = "".jar"";
    private boolean keepgenerated = false;
    private boolean debug         = false;

    
    private String  descriptorName;
    private String  iasDescriptorName;

    
    private String  displayName;

    
    private static final String IAS_DD = ""ias-ejb-jar.xml"";

    
    public void setIashome(File iashome) {
        this.iashome = iashome;
    }

    
    public void setKeepgenerated(boolean keepgenerated) {
        this.keepgenerated = keepgenerated;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public void setSuffix(String jarSuffix) {
        this.jarSuffix = jarSuffix;
    }

    
    public void setGenericJarSuffix(String inString) {
        log(""Since a generic JAR file is not created during processing, the ""
                + ""iPlanet Deployment Tool does not support the ""
                + ""\""genericjarsuffix\"" attribute.  It will be ignored."",
            Project.MSG_WARN);
    }

    
    public void processDescriptor(String descriptorName, SAXParser saxParser) {
        this.descriptorName = descriptorName;
        this.iasDescriptorName = null;

        log(""iPlanet Deployment Tool processing: "" + descriptorName + "" (and ""
                + getIasDescriptorName() + "")"", Project.MSG_VERBOSE);

        super.processDescriptor(descriptorName, saxParser);
    }

    
    protected void checkConfiguration(String descriptorFileName,
                                    SAXParser saxParser) throws BuildException {

        int startOfName = descriptorFileName.lastIndexOf(File.separatorChar) + 1;
        String stdXml = descriptorFileName.substring(startOfName);
        if (stdXml.equals(EJB_DD) && (getConfig().baseJarName == null)) {
            String msg = ""No name specified for the completed JAR file.  The EJB""
                            + "" descriptor should be prepended with the JAR ""
                            + ""name or it should be specified using the ""
                            + ""attribute \""basejarname\"" in the \""ejbjar\"" task."";
            throw new BuildException(msg, getLocation());
        }

        File iasDescriptor = new File(getConfig().descriptorDir,
                                        getIasDescriptorName());
        if ((!iasDescriptor.exists()) || (!iasDescriptor.isFile())) {
            String msg = ""The iAS-specific EJB descriptor (""
                            + iasDescriptor + "") was not found."";
            throw new BuildException(msg, getLocation());
        }

        if ((iashome != null) && (!iashome.isDirectory())) {
            String msg = ""If \""iashome\"" is specified, it must be a valid ""
                            + ""directory (it was set to "" + iashome + "")."";
            throw new BuildException(msg, getLocation());
        }
    }

    
    protected Hashtable parseEjbFiles(String descriptorFileName,
                         SAXParser saxParser) throws IOException, SAXException {

        Hashtable files;

        
        IPlanetEjbc ejbc = new IPlanetEjbc(
                                    new File(getConfig().descriptorDir,
                                                descriptorFileName),
                                    new File(getConfig().descriptorDir,
                                                getIasDescriptorName()),
                                    getConfig().srcDir,
                                    getCombinedClasspath().toString(),
                                    saxParser);
        ejbc.setRetainSource(keepgenerated);
        ejbc.setDebugOutput(debug);
        if (iashome != null) {
            ejbc.setIasHomeDir(iashome);
        }

        
        try {
            ejbc.execute();
        } catch (IPlanetEjbc.EjbcException e) {
            throw new BuildException(""An error has occurred while trying to ""
                        + ""execute the iAS ejbc utility"", e, getLocation());
        }

        displayName    = ejbc.getDisplayName();
        files          = ejbc.getEjbFiles();

        
        String[] cmpDescriptors = ejbc.getCmpDescriptors();
        if (cmpDescriptors.length > 0) {
            File baseDir = getConfig().descriptorDir;

            int endOfPath = descriptorFileName.lastIndexOf(File.separator);
            String relativePath = descriptorFileName.substring(0, endOfPath + 1);

            for (int i = 0; i < cmpDescriptors.length; i++) {
                int endOfCmp = cmpDescriptors[i].lastIndexOf('/');
                String cmpDescriptor = cmpDescriptors[i].substring(endOfCmp + 1);

                File   cmpFile = new File(baseDir, relativePath + cmpDescriptor);
                if (!cmpFile.exists()) {
                    throw new BuildException(""The CMP descriptor file (""
                            + cmpFile + "") could not be found."", getLocation());
                }
                files.put(cmpDescriptors[i], cmpFile);
            }
        }

        return files;
    }

    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
        ejbFiles.put(META_DIR + IAS_DD, new File(getConfig().descriptorDir,
                     getIasDescriptorName()));
    }

    
    File getVendorOutputJarFile(String baseName) {
        File jarFile = new File(getDestDir(), baseName + jarSuffix);
        log(""JAR file name: "" + jarFile.toString(), Project.MSG_VERBOSE);
        return jarFile;
    }

    
    protected String getPublicId() {
        return null;
    }

    
    private String getIasDescriptorName() {

        
        if (iasDescriptorName != null) {
            return iasDescriptorName;
        }

        String path = """";   
        String basename;    
        String remainder;   

        
        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);
        if (startOfFileName != -1) {
            path = descriptorName.substring(0, startOfFileName + 1);
        }

        
        if (descriptorName.substring(startOfFileName + 1).equals(EJB_DD)) {
            basename = """";
            remainder = EJB_DD;

        } else {
            int endOfBaseName = descriptorName.indexOf(
                                                getConfig().baseNameTerminator,
                                                startOfFileName);
            
            if (endOfBaseName < 0) {
                endOfBaseName = descriptorName.lastIndexOf('.') - 1;
                if (endOfBaseName < 0) {
                    endOfBaseName = descriptorName.length() - 1;
                }
            }

            basename = descriptorName.substring(startOfFileName + 1,
                                                endOfBaseName + 1);
            remainder = descriptorName.substring(endOfBaseName + 1);
        }

        iasDescriptorName = path + basename + ""ias-"" + remainder;
        return iasDescriptorName;
    }
}
"
org.apache.tools.ant.types.selectors.SelectorContainer,24,1,0,24,24,276,4,20,24,2.0,24,0.0,0,0.0,0.089285714,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.types.selectors;

import java.util.Enumeration;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;


public interface SelectorContainer {

    
    boolean hasSelectors();

    
    int selectorCount();

    
    FileSelector[] getSelectors(Project p);

    
    Enumeration selectorElements();

    
    void appendSelector(FileSelector selector);

    

    
    void addSelector(SelectSelector selector);

    
    void addAnd(AndSelector selector);

    
    void addOr(OrSelector selector);

    
    void addNot(NotSelector selector);

    
    void addNone(NoneSelector selector);

    
    void addMajority(MajoritySelector selector);

    
    void addDate(DateSelector selector);

    
    void addSize(SizeSelector selector);

    
    void addFilename(FilenameSelector selector);

    
    void addCustom(ExtendSelector selector);

    
    void addContains(ContainsSelector selector);

    
    void addPresent(PresentSelector selector);

    
    void addDepth(DepthSelector selector);

    
    void addDepend(DependSelector selector);

    
    void addContainsRegexp(ContainsRegexpSelector selector);

    
    void addType(TypeSelector selector);

    
    void addDifferent(DifferentSelector selector);

    
    void addModified(ModifiedSelector selector);

    
    void add(FileSelector selector);
}
"
org.apache.tools.ant.taskdefs.email.MimeMailer,5,2,0,7,69,8,1,7,2,1.0,379,1.0,0,0.857142857,0.416666667,0,0,74.4,12,3.2,4,"
package org.apache.tools.ant.taskdefs.email;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.io.OutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.UnsupportedEncodingException;

import java.util.Vector;
import java.util.Iterator;
import java.util.Properties;
import java.util.Enumeration;
import java.util.StringTokenizer;

import java.security.Provider;
import java.security.Security;

import javax.activation.DataHandler;
import javax.activation.FileDataSource;

import javax.mail.Message;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Authenticator;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.AddressException;

import org.apache.tools.ant.BuildException;


public class MimeMailer extends Mailer {
    private static final String SSL_FACTORY = ""javax.net.ssl.SSLSocketFactory"";

    
    private static final String DEFAULT_CHARSET
        = System.getProperty(""file.encoding"");

    
    
    
    class StringDataSource implements javax.activation.DataSource {
        private String data = null;
        private String type = null;
        private String charset = null;
        private ByteArrayOutputStream out;

        public InputStream getInputStream() throws IOException {
            if (data == null && out == null) {
                throw new IOException(""No data"");
            }
            if (out != null) {
                String encodedOut = out.toString(charset);
                data = (data != null) ? data.concat(encodedOut) : encodedOut;
                out = null;
            }
            return new ByteArrayInputStream(data.getBytes(charset));
        }

        public OutputStream getOutputStream() throws IOException {
            out = (out == null) ? new ByteArrayOutputStream() : out;
            return out;
        }

        public void setContentType(String type) {
            this.type = type.toLowerCase();
        }

        public String getContentType() {
            if (type != null && type.indexOf(""charset"") > 0
                && type.startsWith(""text/"")) {
                return type;
            }
            
            return new StringBuffer(type != null ? type : ""text/plain"").append(
                ""; charset="").append(charset).toString();
        }

        public String getName() {
            return ""StringDataSource"";
        }

        public void setCharset(String charset) {
            this.charset = charset;
        }

        public String getCharset() {
            return charset;
        }
    }

    
    public void send() {
        try {
            Properties props = new Properties();

            props.put(""mail.smtp.host"", host);
            props.put(""mail.smtp.port"", String.valueOf(port));

            
            
            
            Session sesh;
            Authenticator auth;
            if (SSL) {
                try {
                    Provider p = (Provider) Class.forName(
                        ""com.sun.net.ssl.internal.ssl.Provider"").newInstance();
                    Security.addProvider(p);
                } catch (Exception e) {
                    throw new BuildException(""could not instantiate ssl ""
                        + ""security provider, check that you have JSSE in ""
                        + ""your classpath"");
                }
                
                props.put(""mail.smtp.socketFactory.class"", SSL_FACTORY);
                props.put(""mail.smtp.socketFactory.fallback"", ""false"");
            }
            if (user == null && password == null) {
                sesh = Session.getDefaultInstance(props, null);
            } else {
                props.put(""mail.smtp.auth"", ""true"");
                auth = new SimpleAuthenticator(user, password);
                sesh = Session.getInstance(props, auth);
            }
            
            MimeMessage msg = new MimeMessage(sesh);
            MimeMultipart attachments = new MimeMultipart();

            
            if (from.getName() == null) {
                msg.setFrom(new InternetAddress(from.getAddress()));
            } else {
                msg.setFrom(new InternetAddress(from.getAddress(),
                    from.getName()));
            }
            
            msg.setReplyTo(internetAddresses(replyToList));
            msg.setRecipients(Message.RecipientType.TO,
                internetAddresses(toList));
            msg.setRecipients(Message.RecipientType.CC,
                internetAddresses(ccList));
            msg.setRecipients(Message.RecipientType.BCC,
                internetAddresses(bccList));

            
            
            String charset = parseCharSetFromMimeType(message.getMimeType());
            if (charset != null) {
                
                message.setCharset(charset);
            } else {
                
                charset = message.getCharset();
                if (charset == null) {
                    
                    charset = DEFAULT_CHARSET;
                    message.setCharset(charset);
                }
            }
            
            StringDataSource sds = new StringDataSource();
            sds.setContentType(message.getMimeType());
            sds.setCharset(charset);

            if (subject != null) {
                msg.setSubject(subject, charset);
            }
            msg.addHeader(""Date"", getDate());

            for (Iterator iter = headers.iterator(); iter.hasNext();) {
                Header h = (Header) iter.next();
                msg.addHeader(h.getName(), h.getValue());
            }
            PrintStream out = new PrintStream(sds.getOutputStream());
            message.print(out);
            out.close();

            MimeBodyPart textbody = new MimeBodyPart();
            textbody.setDataHandler(new DataHandler(sds));
            attachments.addBodyPart(textbody);

            Enumeration e = files.elements();

            while (e.hasMoreElements()) {
                File file = (File) e.nextElement();

                MimeBodyPart body;

                body = new MimeBodyPart();
                if (!file.exists() || !file.canRead()) {
                    throw new BuildException(""File \"""" + file.getAbsolutePath()
                         + ""\"" does not exist or is not ""
                         + ""readable."");
                }
                FileDataSource fileData = new FileDataSource(file);
                DataHandler fileDataHandler = new DataHandler(fileData);

                body.setDataHandler(fileDataHandler);
                body.setFileName(file.getName());
                attachments.addBodyPart(body);
            }
            msg.setContent(attachments);
            Transport.send(msg);
        } catch (MessagingException e) {
            throw new BuildException(""Problem while sending mime mail:"", e);
        } catch (IOException e) {
            throw new BuildException(""Problem while sending mime mail:"", e);
        }
    }

    private static InternetAddress[] internetAddresses(Vector list)
        throws AddressException, UnsupportedEncodingException {
        InternetAddress[] addrs = new InternetAddress[list.size()];

        for (int i = 0; i < list.size(); ++i) {
            EmailAddress addr = (EmailAddress) list.elementAt(i);

            String name = addr.getName();
            addrs[i] = (name == null)
                ? new InternetAddress(addr.getAddress())
                : new InternetAddress(addr.getAddress(), name);
        }
        return addrs;
    }

    private String parseCharSetFromMimeType(String type) {
        int pos;
        if (type == null || (pos = type.indexOf(""charset"")) < 0) {
          return null;
        }
        
        StringTokenizer token = new StringTokenizer(type.substring(pos), ""=; "");
        token.nextToken(); 
        return token.nextToken();
    }

    static class SimpleAuthenticator extends Authenticator {
        private String user = null;
        private String password = null;
        public SimpleAuthenticator(String user, String password) {
            this.user = user;
            this.password = password;
        }
        public PasswordAuthentication getPasswordAuthentication() {

            return new PasswordAuthentication(user, password);
        }
    }
}

"
org.apache.tools.ant.taskdefs.optional.ssh.Directory,15,1,0,3,29,55,3,0,15,0.696428571,161,1.0,1,0.0,0.293333333,1,1,9.466666667,3,1.3333,0,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.io.File;


public class Directory {

    private File directory;
    private ArrayList childDirectories;
    private ArrayList files;
    private Directory parent;

    
    public Directory(File directory) {
        this(directory,  null);
    }

    
    public Directory(File directory , Directory parent) {
        this.parent = parent;
        this.childDirectories = new ArrayList();
        this.files = new ArrayList();
        this.directory = directory;
    }

    
    public void addDirectory(Directory directory) {
        if (!childDirectories.contains(directory)) {
            childDirectories.add(directory);
        }
    }

    
    public void addFile(File file) {
        files.add(file);
    }

    
    public Iterator directoryIterator() {
        return childDirectories.iterator();
    }

    
    public Iterator filesIterator() {
        return files.iterator();
    }

    
    public Directory getParent() {
        return parent;
    }

    
    public boolean isRoot() {
        return parent == null;
    }

    
    public File getDirectory() {
        return directory;
    }

    
    public Directory getChild(File dir) {
        for (int i = 0; i < childDirectories.size(); i++) {
            Directory current = (Directory) childDirectories.get(i);
            if (current.getDirectory().equals(dir)) {
                return current;
            }
        }

        return null;
    }

    
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (!(obj instanceof Directory)) {
            return false;
        }

        Directory d = (Directory) obj;

        return this.directory.equals(d.directory);
    }

    
    public int hashCode() {
        return directory.hashCode();
    }

    
    public String[] getPath() {
        return getPath(directory.getAbsolutePath());
    }

    
    public static String[] getPath(String thePath) {
        StringTokenizer tokenizer = new StringTokenizer(thePath,
                File.separator);
        String[] path = new String[ tokenizer.countTokens() ];

        int i = 0;
        while (tokenizer.hasMoreTokens()) {
            path[i] = tokenizer.nextToken();
            i++;
        }

        return path;
    }

    
    public int fileSize() {
        return files.size();
    }
}
"
org.apache.tools.ant.types.FilterSetCollection,5,1,0,9,13,0,8,1,5,0.0,69,1.0,0,0.0,0.533333333,0,0,12.6,3,1.2,0,"
package org.apache.tools.ant.types;







import java.util.Enumeration;
import java.util.Vector;







public class FilterSetCollection {

    private Vector filterSets = new Vector();

    
    public FilterSetCollection() {
    }

    
    public FilterSetCollection(FilterSet filterSet) {
        addFilterSet(filterSet);
    }


    
    public void addFilterSet(FilterSet filterSet) {
        filterSets.addElement(filterSet);
    }

    
    public String replaceTokens(String line) {
        String replacedLine = line;
        for (Enumeration e = filterSets.elements(); e.hasMoreElements();) {
            FilterSet filterSet = (FilterSet) e.nextElement();
            replacedLine = filterSet.replaceTokens(replacedLine);
        }
        return replacedLine;
    }

    
    public boolean hasFilters() {
        for (Enumeration e = filterSets.elements(); e.hasMoreElements();) {
            FilterSet filterSet = (FilterSet) e.nextElement();
            if (filterSet.hasFilters()) {
                return true;
            }
        }
        return false;
    }
}



"
org.apache.tools.ant.taskdefs.optional.depend.DirectoryIterator,3,1,0,2,21,1,0,2,2,0.5,120,1.0,0,0.0,0.666666667,0,0,38.33333333,6,3.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Stack;
import java.util.Vector;


public class DirectoryIterator implements ClassFileIterator {

    
    private Stack enumStack;

    
    private Enumeration currentEnum;

    
    public DirectoryIterator(File rootDirectory, boolean changeInto)
         throws IOException {
        super();

        enumStack = new Stack();

        Vector filesInRoot = getDirectoryEntries(rootDirectory);

        currentEnum = filesInRoot.elements();
    }

    
    private Vector getDirectoryEntries(File directory) {
        Vector files = new Vector();

        
        String[] filesInDir = directory.list();

        if (filesInDir != null) {
            int length = filesInDir.length;

            for (int i = 0; i < length; ++i) {
                files.addElement(new File(directory, filesInDir[i]));
            }
        }

        return files;
    }

    
    public ClassFile getNextClassFile() {
        ClassFile nextElement = null;

        try {
            while (nextElement == null) {
                if (currentEnum.hasMoreElements()) {
                    File element = (File) currentEnum.nextElement();

                    if (element.isDirectory()) {

                        
                        
                        enumStack.push(currentEnum);

                        Vector files = getDirectoryEntries(element);

                        currentEnum = files.elements();
                    } else {

                        
                        FileInputStream inFileStream
                            = new FileInputStream(element);

                        if (element.getName().endsWith("".class"")) {

                            
                            
                            ClassFile javaClass = new ClassFile();

                            javaClass.read(inFileStream);

                            nextElement = javaClass;
                        }
                    }
                } else {
                    
                    if (enumStack.empty()) {
                        break;
                    } else {
                        currentEnum = (Enumeration) enumStack.pop();
                    }
                }
            }
        } catch (IOException e) {
            nextElement = null;
        }

        return nextElement;
    }

}

"
org.apache.tools.ant.taskdefs.condition.IsSigned,5,3,0,7,26,6,2,5,5,1.05,193,1.0,0,0.882352941,0.533333333,0,0,36.6,5,1.6,1,"
package org.apache.tools.ant.taskdefs.condition;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.zip.ZipEntry;
import org.apache.tools.zip.ZipFile;


public class IsSigned extends DataType implements Condition {

    private static final String SIG_START = ""META-INF/"";
    private static final String SIG_END = "".SF"";
    private static final int    SHORT_SIG_LIMIT = 8;

    private String name;
    private File file;

    
    public void setFile(File file) {
        this.file = file;
    }

   
    public void setName(String name) {
        this.name = name;
    }

    
    public static boolean isSigned(File zipFile, String name)
        throws IOException {
        ZipFile jarFile = null;
        try {
            jarFile = new ZipFile(zipFile);
            if (null == name) {
                Enumeration entries = jarFile.getEntries();
                while (entries.hasMoreElements()) {
                    String eName = ((ZipEntry) entries.nextElement()).getName();
                    if (eName.startsWith(SIG_START)
                        && eName.endsWith(SIG_END)) {
                        return true;
                    }
                }
                return false;
            }
            boolean shortSig = jarFile.getEntry(SIG_START
                        + name.toUpperCase()
                        + SIG_END) != null;
            boolean longSig = false;
            if (name.length() > SHORT_SIG_LIMIT) {
                longSig = jarFile.getEntry(
                    SIG_START
                    + name.substring(0, SHORT_SIG_LIMIT).toUpperCase()
                    + SIG_END) != null;
            }

            return shortSig || longSig;
        } finally {
            ZipFile.closeQuietly(jarFile);
        }
    }

    
    public boolean eval() {
        if (file == null) {
            throw new BuildException(""The file attribute must be set."");
        }
        if (file != null && !file.exists()) {
            log(""The file \"""" + file.getAbsolutePath()
                + ""\"" does not exist."", Project.MSG_VERBOSE);
            return false;
        }

        boolean r = false;
        try {
            r = isSigned(file, name);
        } catch (IOException e) {
            log(""Got IOException reading file \"""" + file.getAbsolutePath()
                + ""\"""" + e, Project.MSG_WARN);
        }

        if (r) {
            log(""File \"""" + file.getAbsolutePath() + ""\"" is signed."",
                Project.MSG_VERBOSE);
        }
        return r;
    }
}
"
org.apache.tools.ant.taskdefs.cvslib.CvsVersion,7,4,0,3,26,9,1,2,7,0.916666667,210,0.666666667,0,0.928571429,0.642857143,2,2,28.14285714,13,3.4286,1,"
package org.apache.tools.ant.taskdefs.cvslib;

import org.apache.tools.ant.taskdefs.AbstractCvsTask;

import java.io.ByteArrayOutputStream;
import java.util.StringTokenizer;


public class CvsVersion extends AbstractCvsTask {
    static final long VERSION_1_11_2 = 11102;
    static final long MULTIPLY = 100;
    private String clientVersion;
    private String serverVersion;
    private String clientVersionProperty;
    private String serverVersionProperty;

    
    public String getClientVersion() {
        return clientVersion;
    }
    
    public String getServerVersion() {
        return serverVersion;
    }
    
    public void setClientVersionProperty(String clientVersionProperty) {
        this.clientVersionProperty = clientVersionProperty;
    }

    
    public void setServerVersionProperty(String serverVersionProperty) {
        this.serverVersionProperty = serverVersionProperty;
    }
    
    public boolean supportsCvsLogWithSOption() {
        if (serverVersion == null) {
            return false;
        }
        StringTokenizer tokenizer = new StringTokenizer(serverVersion, ""."");
        long counter = MULTIPLY * MULTIPLY;
        long version = 0;
        while (tokenizer.hasMoreTokens()) {
            String s = tokenizer.nextToken();
            int i = 0;
            for (i = 0; i < s.length(); i++) {
                if (!Character.isDigit(s.charAt(i))) {
                    break;
                }
            }
            String s2 = s.substring(0, i);
            version = version + counter * Long.parseLong(s2);
            if (counter == 1) {
                break;
            }
            counter = counter / MULTIPLY;
        }
        return (version >= VERSION_1_11_2);
    }
    
    public void execute() {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        this.setOutputStream(bos);
        ByteArrayOutputStream berr = new ByteArrayOutputStream();
        this.setErrorStream(berr);
        setCommand(""version"");
        super.execute();
        String output = bos.toString();
        StringTokenizer st = new StringTokenizer(output);
        boolean client = false;
        boolean server = false;
        boolean cvs = false;
        while (st.hasMoreTokens()) {
            String currentToken = st.nextToken();
            if (currentToken.equals(""Client:"")) {
                client = true;
            } else if (currentToken.equals(""Server:"")) {
                server = true;
            } else if (currentToken.equals(""(CVS)"")) {
                cvs = true;
            }
            if (client && cvs) {
                if (st.hasMoreTokens()) {
                    clientVersion = st.nextToken();
                }
                client = false;
                cvs = false;
            } else if (server && cvs) {
                if (st.hasMoreTokens()) {
                    serverVersion = st.nextToken();
                }
                server = false;
                cvs = false;
            }

        }
        if (clientVersionProperty != null) {
            getProject().setNewProperty(clientVersionProperty, clientVersion);
        }
        if (serverVersionProperty != null) {
            getProject().setNewProperty(serverVersionProperty, serverVersion);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPool,14,1,0,10,53,0,8,8,14,0.423076923,419,1.0,0,0.0,0.285714286,0,0,28.78571429,7,3.6429,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;


public class ConstantPool {

    
    private Vector entries;

    
    private Hashtable utf8Indexes;

    
    public ConstantPool() {
        entries = new Vector();

        
        
        entries.addElement(null);

        utf8Indexes = new Hashtable();
    }

    
    public void read(DataInputStream classStream) throws IOException {
        int numEntries = classStream.readUnsignedShort();

        for (int i = 1; i < numEntries;) {
            ConstantPoolEntry nextEntry
                 = ConstantPoolEntry.readEntry(classStream);

            i += nextEntry.getNumEntries();

            addEntry(nextEntry);
        }
    }

    
    public int size() {
        return entries.size();
    }

    
    public int addEntry(ConstantPoolEntry entry) {
        int index = entries.size();

        entries.addElement(entry);

        int numSlots = entry.getNumEntries();

        
        for (int j = 0; j < numSlots - 1; ++j) {
            entries.addElement(null);
        }

        if (entry instanceof Utf8CPInfo) {
            Utf8CPInfo utf8Info = (Utf8CPInfo) entry;

            utf8Indexes.put(utf8Info.getValue(), new Integer(index));
        }

        return index;
    }

    
    public void resolve() {
        for (Enumeration i = entries.elements(); i.hasMoreElements();) {
            ConstantPoolEntry poolInfo = (ConstantPoolEntry) i.nextElement();

            if (poolInfo != null && !poolInfo.isResolved()) {
                poolInfo.resolve(this);
            }
        }
    }


    
    public ConstantPoolEntry getEntry(int index) {
        return (ConstantPoolEntry) entries.elementAt(index);
    }

    
    public int getUTF8Entry(String value) {
        int index = -1;
        Integer indexInteger = (Integer) utf8Indexes.get(value);

        if (indexInteger != null) {
            index = indexInteger.intValue();
        }

        return index;
    }

    
    public int getClassEntry(String className) {
        int index = -1;

        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);

            if (element instanceof ClassCPInfo) {
                ClassCPInfo classinfo = (ClassCPInfo) element;

                if (classinfo.getClassName().equals(className)) {
                    index = i;
                }
            }
        }

        return index;
    }

    
    public int getConstantEntry(Object constantValue) {
        int index = -1;

        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);

            if (element instanceof ConstantCPInfo) {
                ConstantCPInfo constantEntry = (ConstantCPInfo) element;

                if (constantEntry.getValue().equals(constantValue)) {
                    index = i;
                }
            }
        }

        return index;
    }

    
    public int getMethodRefEntry(String methodClassName, String methodName,
                                 String methodType) {
        int index = -1;

        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);

            if (element instanceof MethodRefCPInfo) {
                MethodRefCPInfo methodRefEntry = (MethodRefCPInfo) element;

                if (methodRefEntry.getMethodClassName().equals(methodClassName)
                     && methodRefEntry.getMethodName().equals(methodName)
                     && methodRefEntry.getMethodType().equals(methodType)) {
                    index = i;
                }
            }
        }

        return index;
    }

    
    public int getInterfaceMethodRefEntry(String interfaceMethodClassName,
                                          String interfaceMethodName,
                                          String interfaceMethodType) {
        int index = -1;

        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);

            if (element instanceof InterfaceMethodRefCPInfo) {
                InterfaceMethodRefCPInfo interfaceMethodRefEntry
                     = (InterfaceMethodRefCPInfo) element;

                if (interfaceMethodRefEntry.getInterfaceMethodClassName().equals(
                        interfaceMethodClassName)
                     && interfaceMethodRefEntry.getInterfaceMethodName().equals(
                         interfaceMethodName)
                     && interfaceMethodRefEntry.getInterfaceMethodType().equals(
                         interfaceMethodType)) {
                    index = i;
                }
            }
        }

        return index;
    }

    
    public int getFieldRefEntry(String fieldClassName, String fieldName,
                                String fieldType) {
        int index = -1;

        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);

            if (element instanceof FieldRefCPInfo) {
                FieldRefCPInfo fieldRefEntry = (FieldRefCPInfo) element;

                if (fieldRefEntry.getFieldClassName().equals(fieldClassName)
                     && fieldRefEntry.getFieldName().equals(fieldName)
                     && fieldRefEntry.getFieldType().equals(fieldType)) {
                    index = i;
                }
            }
        }

        return index;
    }

    
    public int getNameAndTypeEntry(String name, String type) {
        int index = -1;

        for (int i = 0; i < entries.size() && index == -1; ++i) {
            Object element = entries.elementAt(i);

            if (element instanceof NameAndTypeCPInfo) {
                NameAndTypeCPInfo nameAndTypeEntry
                    = (NameAndTypeCPInfo) element;

                if (nameAndTypeEntry.getName().equals(name)
                     && nameAndTypeEntry.getType().equals(type)) {
                    index = i;
                }
            }
        }

        return index;
    }

    
    public String toString() {
        StringBuffer sb = new StringBuffer(""\n"");
        int size = entries.size();

        for (int i = 0; i < size; ++i) {
            sb.append(""["" + i + ""] = "" + getEntry(i) + ""\n"");
        }

        return sb.toString();
    }

}

"
org.apache.tools.ant.taskdefs.optional.clearcase.CCCheckout,26,4,0,7,50,271,0,7,20,0.955789474,392,0.473684211,0,0.657534247,0.384615385,2,3,13.34615385,9,1.5,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;



public class CCCheckout extends ClearCase {
    private boolean mReserved = true;
    private String mOut = null;
    private boolean mNdata = false;
    private String mBranch = null;
    private boolean mVersion = false;
    private boolean mNwarn = false;
    private String mComment = null;
    private String mCfile = null;
    private boolean mNotco = true;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_CHECKOUT);

        checkOptions(commandLine);
        
        if (!getNotco() && lsCheckout()) {
            getProject().log(""Already checked out in this view: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
            return;
        }
        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }

    
    private boolean lsCheckout() {
        Commandline cmdl = new Commandline();
        String result;

        
        
        
        cmdl.setExecutable(getClearToolCommand());
        cmdl.createArgument().setValue(COMMAND_LSCO);
        cmdl.createArgument().setValue(""-cview"");
        cmdl.createArgument().setValue(""-short"");
        cmdl.createArgument().setValue(""-d"");
        
        cmdl.createArgument().setValue(getViewPath());

        result = runS(cmdl);

        

        return (result != null && result.length() > 0) ? true : false;
    }
    
    private void checkOptions(Commandline cmd) {
        
        if (getReserved()) {
            
            cmd.createArgument().setValue(FLAG_RESERVED);
        } else {
            
            cmd.createArgument().setValue(FLAG_UNRESERVED);
        }

        if (getOut() != null) {
            
            getOutCommand(cmd);
        } else {
            if (getNoData()) {
                
                cmd.createArgument().setValue(FLAG_NODATA);
            }

        }

        if (getBranch() != null) {
            
            getBranchCommand(cmd);
        } else {
            if (getVersion()) {
                
                cmd.createArgument().setValue(FLAG_VERSION);
            }

        }

        if (getNoWarn()) {
            
            cmd.createArgument().setValue(FLAG_NOWARN);
        }

        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        
        cmd.createArgument().setValue(getViewPath());

        
        
    }

    
    public void setReserved(boolean reserved) {
        mReserved = reserved;
    }

    
    public boolean getReserved() {
        return mReserved;
    }

    
    public void setNotco(boolean notco) {
        mNotco = notco;
    }

    
    public boolean getNotco() {
        return mNotco;
    }


    
    public void setOut(String outf) {
        mOut = outf;
    }

    
    public String getOut() {
        return mOut;
    }

    
    public void setNoData(boolean ndata) {
        mNdata = ndata;
    }

    
    public boolean getNoData() {
        return mNdata;
    }

    
    public void setBranch(String branch) {
        mBranch = branch;
    }

    
    public String getBranch() {
        return mBranch;
    }

    
    public void setVersion(boolean version) {
        mVersion = version;
    }

    
    public boolean getVersion() {
        return mVersion;
    }

    
    public void setNoWarn(boolean nwarn) {
        mNwarn = nwarn;
    }

    
    public boolean getNoWarn() {
        return mNwarn;
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    private void getOutCommand(Commandline cmd) {
        if (getOut() != null) {
            
            cmd.createArgument().setValue(FLAG_OUT);
            cmd.createArgument().setValue(getOut());
        }
    }

    
    private void getBranchCommand(Commandline cmd) {
        if (getBranch() != null) {
            
            cmd.createArgument().setValue(FLAG_BRANCH);
            cmd.createArgument().setValue(getBranch());
        }
    }


    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }

        
    public static final String FLAG_RESERVED = ""-reserved"";
        
    public static final String FLAG_UNRESERVED = ""-unreserved"";
        
    public static final String FLAG_OUT = ""-out"";
        
    public static final String FLAG_NODATA = ""-ndata"";
        
    public static final String FLAG_BRANCH = ""-branch"";
        
    public static final String FLAG_VERSION = ""-version"";
        
    public static final String FLAG_NOWARN = ""-nwarn"";
        
    public static final String FLAG_COMMENT = ""-c"";
        
    public static final String FLAG_COMMENTFILE = ""-cfile"";
        
    public static final String FLAG_NOCOMMENT = ""-nc"";

}

"
org.apache.tools.ant.taskdefs.XSLTProcess,44,4,0,28,137,774,4,26,31,0.923341947,1254,0.962962963,9,0.65,0.127906977,4,6,26.88636364,5,1.2045,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.DynamicConfigurator;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.XMLCatalog;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.Resources;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;



public class XSLTProcess extends MatchingTask implements XSLTLogger {
    
    private File destDir = null;

    
    private File baseDir = null;

    
    private String xslFile = null;

    
    private Resource xslResource = null;

    
    private String targetExtension = "".html"";

    
    private String fileNameParameter = null;

    
    private String fileDirParameter = null;

    
    private Vector params = new Vector();

    
    private File inFile = null;

    
    private File outFile = null;

    
    private String processor;

    
    private Path classpath = null;

    
    private XSLTLiaison liaison;

    
    private boolean stylesheetLoaded = false;

    
    private boolean force = false;

    
    private Vector outputProperties = new Vector();

    
    private XMLCatalog xmlCatalog = new XMLCatalog();

    
    private static final String TRAX_LIAISON_CLASS =
                        ""org.apache.tools.ant.taskdefs.optional.TraXLiaison"";

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private boolean performDirectoryScan = true;

    
    private Factory factory = null;

    
    private boolean reuseLoadedStylesheet = true;

    
    private AntClassLoader loader = null;

    
    private Mapper mapperElement = null;

    
    private Union resources = new Union();

    
    private boolean useImplicitFileset = true;

    
    public static final String PROCESSOR_TRAX = ""trax"";

    
    public XSLTProcess() {
    } 

    
    public void setScanIncludedDirectories(boolean b) {
        performDirectoryScan = b;
    }

    
    public void setReloadStylesheet(boolean b) {
        reuseLoadedStylesheet = !b;
    }

    
    public void addMapper(Mapper mapper) {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     getLocation());
        }
        mapperElement = mapper;
    }

    
    public void add(ResourceCollection rc) {
        resources.add(rc);
    }

    
    public void addConfiguredStyle(Resources rc) {
        if (rc.size() != 1) {
            throw new BuildException(""The style element must be specified""
                    + "" with exactly one nested resource."");
        }
        setXslResource((Resource) rc.iterator().next());
    }

    
    public void setXslResource(Resource xslResource) {
        this.xslResource = xslResource;
    }

    
    public void add(FileNameMapper fileNameMapper) throws BuildException {
       Mapper mapper = new Mapper(getProject());
       mapper.add(fileNameMapper);
       addMapper(mapper);
    }

    
    public void execute() throws BuildException {
        if (""style"".equals(getTaskType())) {
            log(""Warning: the task name <style> is deprecated. Use <xslt> instead."",
                    Project.MSG_WARN);
        }

        File savedBaseDir = baseDir;

        DirectoryScanner scanner;
        String[]         list;
        String[]         dirs;

        if (xslResource == null && xslFile == null) {
            throw new BuildException(""specify the ""
                + ""stylesheet either as a filename in style ""
                + ""attribute or as a nested resource"", getLocation());

        }
        if (xslResource != null && xslFile != null) {
            throw new BuildException(""specify the ""
                + ""stylesheet either as a filename in style ""
                + ""attribute or as a nested resource but not ""
                + ""as both"", getLocation());
        }

        if (inFile != null && !inFile.exists()) {
            throw new BuildException(
                ""input file "" + inFile.toString() + "" does not exist"", getLocation());
        }

        try {
            if (baseDir == null) {
                baseDir = getProject().resolveFile(""."");
            }

            liaison = getLiaison();

            
            if (liaison instanceof XSLTLoggerAware) {
                ((XSLTLoggerAware) liaison).setLogger(this);
            }

            log(""Using "" + liaison.getClass().toString(), Project.MSG_VERBOSE);

            if (xslFile != null) {
                
                
                File stylesheet = getProject().resolveFile(xslFile);
                if (!stylesheet.exists()) {
                    stylesheet = FILE_UTILS.resolveFile(baseDir, xslFile);
                    
                    if (stylesheet.exists()) {
                        log(""DEPRECATED - the 'style' attribute should be relative ""
                                + ""to the project's"");
                        log(""             basedir, not the tasks's basedir."");
                    }
                }
                FileResource fr = new FileResource();
                fr.setProject(getProject());
                fr.setFile(stylesheet);
                xslResource = fr;
            }

            
            if (inFile != null && outFile != null) {
                process(inFile, outFile, xslResource);
                return;
            }

            

            
            checkDest();

            if (useImplicitFileset) {
                scanner = getDirectoryScanner(baseDir);
                log(""Transforming into "" + destDir, Project.MSG_INFO);

                
                list = scanner.getIncludedFiles();
                for (int i = 0; i < list.length; ++i) {
                    process(baseDir, list[i], destDir, xslResource);
                }
                if (performDirectoryScan) {
                    
                    dirs = scanner.getIncludedDirectories();
                    for (int j = 0; j < dirs.length; ++j) {
                        list = new File(baseDir, dirs[j]).list();
                        for (int i = 0; i < list.length; ++i) {
                            process(baseDir, dirs[j] + File.separator + list[i],
                                    destDir, xslResource);
                        }
                    }
                }
            } else { 
                if (resources.size() == 0) {
                    throw new BuildException(""no resources specified"");
                }
            }
            processResources(xslResource);
        } finally {
            if (loader != null) {
                loader.resetThreadContextLoader();
                loader.cleanup();
                loader = null;
            }
            liaison = null;
            stylesheetLoaded = false;
            baseDir = savedBaseDir;
        }
    }

    
    public void setForce(boolean force) {
        this.force = force;
    }

    
    public void setBasedir(File dir) {
        baseDir = dir;
    }

    
    public void setDestdir(File dir) {
        destDir = dir;
    }

    
    public void setExtension(String name) {
        targetExtension = name;
    }

    
    public void setStyle(String xslFile) {
        this.xslFile = xslFile;
    }

    
    public void setClasspath(Path classpath) {
        createClasspath().append(classpath);
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(getProject());
        }
        return classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setProcessor(String processor) {
        this.processor = processor;
    }

    
    public void setUseImplicitFileset(boolean useimplicitfileset) {
        useImplicitFileset = useimplicitfileset;
    }

    
    public void addConfiguredXMLCatalog(XMLCatalog xmlCatalog) {
        this.xmlCatalog.addConfiguredXMLCatalog(xmlCatalog);
    }

    
    public void setFileNameParameter(String fileNameParameter) {
        this.fileNameParameter = fileNameParameter;
    }

    
    public void setFileDirParameter(String fileDirParameter) {
        this.fileDirParameter = fileDirParameter;
    }

    
    private void resolveProcessor(String proc) throws Exception {
        String classname;
        if (proc.equals(PROCESSOR_TRAX)) {
            classname = TRAX_LIAISON_CLASS;
        } else {
            
            classname = proc;
        }
        Class clazz = loadClass(classname);
        liaison = (XSLTLiaison) clazz.newInstance();
    }

    
    private Class loadClass(String classname) throws Exception {
        if (classpath == null) {
            return Class.forName(classname);
        } else {
            loader = getProject().createClassLoader(classpath);
            loader.setThreadContextLoader();
            Class c = Class.forName(classname, true, loader);
            return c;
        }
    }

    
    public void setOut(File outFile) {
        this.outFile = outFile;
    }

    
    public void setIn(File inFile) {
        this.inFile = inFile;
    }

    
    private void checkDest() {
        if (destDir == null) {
            String msg = ""destdir attributes must be set!"";
            throw new BuildException(msg);
        }
    }

    
    private void processResources(Resource stylesheet) {
        Iterator iter = resources.iterator();
        while (iter.hasNext()) {
            Resource r = (Resource) iter.next();
            if (!r.isExists()) {
                continue;
            }
            File base = baseDir;
            String name = r.getName();
            if (r instanceof FileResource) {
                FileResource f = (FileResource) r;
                base = f.getBaseDir();
                if (base == null) {
                    name = f.getFile().getAbsolutePath();
                }
            }
            process(base, name, destDir, stylesheet);
        }
    }

    
    private void process(File baseDir, String xmlFile, File destDir,
                         Resource stylesheet)
        throws BuildException {

        File   outF = null;
        File   inF = null;

        try {
            long styleSheetLastModified = stylesheet.getLastModified();
            inF = new File(baseDir, xmlFile);

            if (inF.isDirectory()) {
                log(""Skipping "" + inF + "" it is a directory."",
                    Project.MSG_VERBOSE);
                return;
            }

            FileNameMapper mapper = null;
            if (mapperElement != null) {
                mapper = mapperElement.getImplementation();
            } else {
                mapper = new StyleMapper();
            }

            String[] outFileName = mapper.mapFileName(xmlFile);
            if (outFileName == null || outFileName.length == 0) {
                log(""Skipping "" + inFile + "" it cannot get mapped to output."",
                    Project.MSG_VERBOSE);
                return;
            } else if (outFileName == null || outFileName.length > 1) {
                log(""Skipping "" + inFile + "" its mapping is ambiguos."",
                    Project.MSG_VERBOSE);
                return;
            }

            outF = new File(destDir, outFileName[0]);

            if (force
                || inF.lastModified() > outF.lastModified()
                || styleSheetLastModified > outF.lastModified()) {
                ensureDirectoryFor(outF);
                log(""Processing "" + inF + "" to "" + outF);

                configureLiaison(stylesheet);
                setLiaisonDynamicFileParameters(liaison, inF);
                liaison.transform(inF, outF);
            }
        } catch (Exception ex) {
            
            
            log(""Failed to process "" + inFile, Project.MSG_INFO);
            if (outF != null) {
                outF.delete();
            }

            throw new BuildException(ex);
        }

    } 

    
    private void process(File inFile, File outFile, Resource stylesheet)
         throws BuildException {
        try {
            long styleSheetLastModified = stylesheet.getLastModified();
            log(""In file "" + inFile + "" time: "" + inFile.lastModified(),
                Project.MSG_DEBUG);
            log(""Out file "" + outFile + "" time: "" + outFile.lastModified(),
                Project.MSG_DEBUG);
            log(""Style file "" + xslFile + "" time: "" + styleSheetLastModified,
                Project.MSG_DEBUG);
            if (force || inFile.lastModified() >= outFile.lastModified()
                || styleSheetLastModified >= outFile.lastModified()) {
                ensureDirectoryFor(outFile);
                log(""Processing "" + inFile + "" to "" + outFile,
                    Project.MSG_INFO);
                configureLiaison(stylesheet);
                setLiaisonDynamicFileParameters(liaison, inFile);
                liaison.transform(inFile, outFile);
            } else {
                log(""Skipping input file "" + inFile
                    + "" because it is older than output file "" + outFile
                    + "" and so is the stylesheet "" + stylesheet, Project.MSG_DEBUG);
            }
        } catch (Exception ex) {
            log(""Failed to process "" + inFile, Project.MSG_INFO);
            if (outFile != null) {
                outFile.delete();
            }
            throw new BuildException(ex);
        }
    }

    
    private void ensureDirectoryFor(File targetFile)
         throws BuildException {
        File directory = targetFile.getParentFile();
        if (!directory.exists()) {
            if (!directory.mkdirs()) {
                throw new BuildException(""Unable to create directory: ""
                                         + directory.getAbsolutePath());
            }
        }
    }

    
    public Factory getFactory() {
        return factory;
    }

    
    public XMLCatalog getXMLCatalog() {
        xmlCatalog.setProject(getProject());
        return xmlCatalog;
    }

    
    public Enumeration getOutputProperties() {
        return outputProperties.elements();
    }

    
    protected XSLTLiaison getLiaison() {
        
        
        if (liaison == null) {
            if (processor != null) {
                try {
                    resolveProcessor(processor);
                } catch (Exception e) {
                    throw new BuildException(e);
                }
            } else {
                try {
                    resolveProcessor(PROCESSOR_TRAX);
                } catch (Throwable e1) {
                    e1.printStackTrace();
                    throw new BuildException(e1);
                }
            }
        }
        return liaison;
    }

    
    public Param createParam() {
        Param p = new Param();
        params.addElement(p);
        return p;
    }

    
    public static class Param {
        
        private String name = null;

        
        private String expression = null;

        private String ifProperty;
        private String unlessProperty;
        private Project project;

        
        public void setProject(Project project) {
            this.project = project;
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public void setExpression(String expression) {
            this.expression = expression;
        }

        
        public String getName() throws BuildException {
            if (name == null) {
                throw new BuildException(""Name attribute is missing."");
            }
            return name;
        }

        
        public String getExpression() throws BuildException {
            if (expression == null) {
                throw new BuildException(""Expression attribute is missing."");
            }
            return expression;
        }

        
        public void setIf(String ifProperty) {
            this.ifProperty = ifProperty;
        }

        
        public void setUnless(String unlessProperty) {
            this.unlessProperty = unlessProperty;
        }
        
        public boolean shouldUse() {
            if (ifProperty != null && project.getProperty(ifProperty) == null) {
                return false;
            } else if (unlessProperty != null
                    && project.getProperty(unlessProperty) != null) {
                return false;
            }

            return true;
        }
    } 


    
    public OutputProperty createOutputProperty() {
        OutputProperty p = new OutputProperty();
        outputProperties.addElement(p);
        return p;
    }


    
    public static class OutputProperty {
        
        private String name;

        
        private String value;

        
        public String getName() {
            return name;
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getValue() {
            return value;
        }

        
        public void setValue(String value) {
            this.value = value;
        }
    }

    
    public void init() throws BuildException {
        super.init();
        xmlCatalog.setProject(getProject());
    }

    
    protected void configureLiaison(File stylesheet) throws BuildException {
        FileResource fr = new FileResource();
        fr.setProject(getProject());
        fr.setFile(stylesheet);
        configureLiaison(fr);
    }
    
    protected void configureLiaison(Resource stylesheet) throws BuildException {
        if (stylesheetLoaded && reuseLoadedStylesheet) {
            return;
        }
        stylesheetLoaded = true;

        try {
            log(""Loading stylesheet "" + stylesheet, Project.MSG_INFO);
            
            
            if (liaison instanceof XSLTLiaison2) {
                ((XSLTLiaison2) liaison).configure(this);
            }

            if (liaison instanceof XSLTLiaison3) {
                
                
                ((XSLTLiaison3) liaison).setStylesheet(stylesheet);
            } else {
                
                
                
                if (stylesheet instanceof FileResource) {
                    liaison.setStylesheet(
                            ((FileResource) stylesheet).getFile());
                } else {
                    throw new BuildException(liaison.getClass().toString()
                            + "" accepts the stylesheet only as a file"",
                            getLocation());
                }
            }
            for (Enumeration e = params.elements(); e.hasMoreElements();) {
                Param p = (Param) e.nextElement();
                if (p.shouldUse()) {
                    liaison.addParam(p.getName(), p.getExpression());
                }
            }
        } catch (Exception ex) {
            log(""Failed to transform using stylesheet "" + stylesheet,
                 Project.MSG_INFO);
            throw new BuildException(ex);
        }
    }

    
    private void setLiaisonDynamicFileParameters(
        XSLTLiaison liaison,
        File inFile
    ) throws Exception {
        if (fileNameParameter != null) {
            liaison.addParam(fileNameParameter, inFile.getName());
        }
        if (fileDirParameter != null) {
            String fileName = FileUtils.getRelativePath(baseDir, inFile);
            File file = new File(fileName);
            
            
            liaison.addParam(
                fileDirParameter,
                (file.getParent() != null)
                ? file.getParent().replace('\\', '/') : ""."");
        }
    }

    
    public Factory createFactory() throws BuildException {
        if (factory != null) {
            throw new BuildException(""'factory' element must be unique"");
        }
        factory = new Factory();
        return factory;
    }

    
    public static class Factory {

        
        private String name;

        
        private Vector attributes = new Vector();

        
        public String getName() {
            return name;
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public void addAttribute(Attribute attr) {
            attributes.addElement(attr);
        }

        
        public Enumeration getAttributes() {
            return attributes.elements();
        }

        
        public static class Attribute implements DynamicConfigurator {

            
            private String name;

            
            private Object value;

            
            public String getName() {
                return name;
            }

            
            public Object getValue() {
                return value;
            }

            
            public Object createDynamicElement(String name) throws BuildException {
                return null;
            }

            
            public void setDynamicAttribute(String name, String value)
                    throws BuildException {
                
                if (""name"".equalsIgnoreCase(name)) {
                    this.name = value;
                } else if (""value"".equalsIgnoreCase(name)) {
                    
                    
                    if (""true"".equalsIgnoreCase(value)) {
                        this.value = Boolean.TRUE;
                    } else if (""false"".equalsIgnoreCase(value)) {
                        this.value = Boolean.FALSE;
                    } else {
                        try {
                            this.value = new Integer(value);
                        } catch (NumberFormatException e) {
                            this.value = value;
                        }
                    }
                } else {
                    throw new BuildException(""Unsupported attribute: "" + name);
                }
            }
        } 

    } 

    
    private class StyleMapper implements FileNameMapper {
        public void setFrom(String from) {
        }
        public void setTo(String to) {
        }
        public String[] mapFileName(String xmlFile) {
            int dotPos = xmlFile.lastIndexOf('.');
            if (dotPos > 0) {
                xmlFile = xmlFile.substring(0, dotPos);
            }
            return new String[] {xmlFile + targetExtension};
        }
    }

}
"
org.apache.tools.ant.TypeAdapter,5,1,0,7,5,10,6,1,5,2.0,5,0.0,0,0.0,0.4,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;


public interface TypeAdapter {

    
    void setProject(Project p);

    
    Project getProject();

    
    void setProxy(Object o);

    
    Object getProxy();

    
    void checkProxyClass(Class proxyClass);
}
"
org.apache.tools.ant.taskdefs.SQLExec,26,4,0,12,109,233,1,12,20,0.892,881,1.0,1,0.709302326,0.157051282,2,2,32.11538462,4,1.0769,8,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.Union;

import java.io.File;
import java.io.PrintStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Vector;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;


public class SQLExec extends JDBCTask {

    
    public static class DelimiterType extends EnumeratedAttribute {
        
        public static final String NORMAL = ""normal"", ROW = ""row"";
        
        public String[] getValues() {
            return new String[] {NORMAL, ROW};
        }
    }

    private int goodSql = 0;

    private int totalSql = 0;

    
    private Connection conn = null;

    
    private Union resources = new Union();

    
    private Statement statement = null;

    
    private File srcFile = null;

    
    private String sqlCommand = """";

    
    private Vector transactions = new Vector();

    
    private String delimiter = "";"";

    
    private String delimiterType = DelimiterType.NORMAL;

    
    private boolean print = false;

    
    private boolean showheaders = true;

    
    private boolean showtrailers = true;

    
    private File output = null;


    
    private String onError = ""abort"";

    
    private String encoding = null;

    
    private boolean append = false;

    
    private boolean keepformat = false;

    
    private boolean escapeProcessing = true;

    
    private boolean expandProperties = false;

    
    public void setSrc(File srcFile) {
        this.srcFile = srcFile;
    }

    
    public void setExpandProperties(boolean expandProperties) {
        this.expandProperties = expandProperties;
    }

    
    public boolean getExpandProperties() {
        return expandProperties;
    }

    
    public void addText(String sql) {
        
        
        this.sqlCommand += sql;
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void add(ResourceCollection rc) {
        resources.add(rc);
    }

    
    public Transaction createTransaction() {
        Transaction t = new Transaction();
        transactions.addElement(t);
        return t;
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }

    
    public void setDelimiterType(DelimiterType delimiterType) {
        this.delimiterType = delimiterType.getValue();
    }

    
    public void setPrint(boolean print) {
        this.print = print;
    }

    
    public void setShowheaders(boolean showheaders) {
        this.showheaders = showheaders;
    }

    
    public void setShowtrailers(boolean showtrailers) {
        this.showtrailers = showtrailers;
    }

    
    public void setOutput(File output) {
        this.output = output;
    }

    
    public void setAppend(boolean append) {
        this.append = append;
    }


    
    public void setOnerror(OnError action) {
        this.onError = action.getValue();
    }

    
    public void setKeepformat(boolean keepformat) {
        this.keepformat = keepformat;
    }

    
    public void setEscapeProcessing(boolean enable) {
        escapeProcessing = enable;
    }

    
    public void execute() throws BuildException {
        Vector savedTransaction = (Vector) transactions.clone();
        String savedSqlCommand = sqlCommand;

        sqlCommand = sqlCommand.trim();

        try {
            if (srcFile == null && sqlCommand.length() == 0
                && resources.size() == 0) {
                if (transactions.size() == 0) {
                    throw new BuildException(""Source file or resource ""
                                             + ""collection, ""
                                             + ""transactions or sql statement ""
                                             + ""must be set!"", getLocation());
                }
            }

            if (srcFile != null && !srcFile.exists()) {
                throw new BuildException(""Source file does not exist!"", getLocation());
            }

            
            Iterator iter = resources.iterator();
            while (iter.hasNext()) {
                Resource r = (Resource) iter.next();
                
                Transaction t = createTransaction();
                t.setSrcResource(r);
            }

            
            Transaction t = createTransaction();
            t.setSrc(srcFile);
            t.addText(sqlCommand);
            conn = getConnection();
            if (!isValidRdbms(conn)) {
                return;
            }
            try {
                statement = conn.createStatement();
                statement.setEscapeProcessing(escapeProcessing);

                PrintStream out = System.out;
                try {
                    if (output != null) {
                        log(""Opening PrintStream to output file "" + output,
                            Project.MSG_VERBOSE);
                        out = new PrintStream(
                                  new BufferedOutputStream(
                                      new FileOutputStream(output
                                                           .getAbsolutePath(),
                                                           append)));
                    }

                    
                    for (Enumeration e = transactions.elements();
                         e.hasMoreElements();) {

                        ((Transaction) e.nextElement()).runTransaction(out);
                        if (!isAutocommit()) {
                            log(""Committing transaction"", Project.MSG_VERBOSE);
                            conn.commit();
                        }
                    }
                } finally {
                    if (out != null && out != System.out) {
                        out.close();
                    }
                }
            } catch (IOException e) {
                closeQuietly();
                throw new BuildException(e, getLocation());
            } catch (SQLException e) {
                closeQuietly();
                throw new BuildException(e, getLocation());
            } finally {
                try {
                    if (statement != null) {
                        statement.close();
                    }
                    if (conn != null) {
                        conn.close();
                    }
                } catch (SQLException ex) {
                    
                }
            }

            log(goodSql + "" of "" + totalSql
                + "" SQL statements executed successfully"");
        } finally {
            transactions = savedTransaction;
            sqlCommand = savedSqlCommand;
        }
    }

    
    protected void runStatements(Reader reader, PrintStream out)
        throws SQLException, IOException {
        StringBuffer sql = new StringBuffer();
        String line;

        BufferedReader in = new BufferedReader(reader);

        while ((line = in.readLine()) != null) {
            if (!keepformat) {
                line = line.trim();
            }
            line = getProject().replaceProperties(line);
            if (!keepformat) {
                if (line.startsWith(""
                    continue;
                }
                if (line.startsWith(""--"")) {
                    continue;
                }
                StringTokenizer st = new StringTokenizer(line);
                if (st.hasMoreTokens()) {
                    String token = st.nextToken();
                    if (""REM"".equalsIgnoreCase(token)) {
                        continue;
                    }
                }
            }

            if (!keepformat) {
                sql.append("" "");
                sql.append(line);
            } else {
                sql.append(""\n"");
                sql.append(line);
            }

            
            
            
            if (!keepformat) {
                if (line.indexOf(""--"") >= 0) {
                    sql.append(""\n"");
                }
            }
            if ((delimiterType.equals(DelimiterType.NORMAL)
                 && StringUtils.endsWith(sql, delimiter))
                ||
                (delimiterType.equals(DelimiterType.ROW)
                 && line.equals(delimiter))) {
                execSQL(sql.substring(0, sql.length() - delimiter.length()),
                        out);
                sql.replace(0, sql.length(), """");
            }
        }
        
        if (sql.length() > 0) {
            execSQL(sql.toString(), out);
        }
    }


    
    protected void execSQL(String sql, PrintStream out) throws SQLException {
        
        if ("""".equals(sql.trim())) {
            return;
        }

        ResultSet resultSet = null;
        try {
            totalSql++;
            log(""SQL: "" + sql, Project.MSG_VERBOSE);

            boolean ret;
            int updateCount = 0, updateCountTotal = 0;

            ret = statement.execute(sql);
            updateCount = statement.getUpdateCount();
            resultSet = statement.getResultSet();
            do {
                if (!ret) {
                    if (updateCount != -1) {
                        updateCountTotal += updateCount;
                    }
                } else {
                    if (print) {
                        printResults(resultSet, out);
                    }
                }
                ret = statement.getMoreResults();
                if (ret) {
                    updateCount = statement.getUpdateCount();
                    resultSet = statement.getResultSet();
                }
            } while (ret);

            log(updateCountTotal + "" rows affected"",
                Project.MSG_VERBOSE);

            if (print && showtrailers) {
                out.println(updateCountTotal + "" rows affected"");
            }

            SQLWarning warning = conn.getWarnings();
            while (warning != null) {
                log(warning + "" sql warning"", Project.MSG_VERBOSE);
                warning = warning.getNextWarning();
            }
            conn.clearWarnings();
            goodSql++;
        } catch (SQLException e) {
            log(""Failed to execute: "" + sql, Project.MSG_ERR);
            if (!onError.equals(""continue"")) {
                throw e;
            }
            log(e.toString(), Project.MSG_ERR);
        } finally {
            if (resultSet != null) {
                resultSet.close();
            }
        }
    }

    
    protected void printResults(PrintStream out) throws SQLException {
        ResultSet rs = statement.getResultSet();
        try {
            printResults(rs, out);
        } finally {
            if (rs != null) {
                rs.close();
            }
        }
    }

    
    protected void printResults(ResultSet rs, PrintStream out)
        throws SQLException {
        if (rs != null) {
            log(""Processing new result set."", Project.MSG_VERBOSE);
            ResultSetMetaData md = rs.getMetaData();
            int columnCount = md.getColumnCount();
            StringBuffer line = new StringBuffer();
            if (showheaders) {
                for (int col = 1; col < columnCount; col++) {
                     line.append(md.getColumnName(col));
                     line.append("","");
                }
                line.append(md.getColumnName(columnCount));
                out.println(line);
                line = new StringBuffer();
            }
            while (rs.next()) {
                boolean first = true;
                for (int col = 1; col <= columnCount; col++) {
                    String columnValue = rs.getString(col);
                    if (columnValue != null) {
                        columnValue = columnValue.trim();
                    }

                    if (first) {
                        first = false;
                    } else {
                        line.append("","");
                    }
                    line.append(columnValue);
                }
                out.println(line);
                line = new StringBuffer();
            }
        }
        out.println();
    }

    
    private void closeQuietly() {
        if (!isAutocommit() && conn != null && onError.equals(""abort"")) {
            try {
                conn.rollback();
            } catch (SQLException ex) {
                
            }
        }
    }

    
    public static class OnError extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""continue"", ""stop"", ""abort""};
        }
    }

    
    public class Transaction {
        private Resource tSrcResource = null;
        private String tSqlCommand = """";

        
        public void setSrc(File src) {
            
            
            if (src != null) {
                setSrcResource(new FileResource(src));
            }
        }

        
        public void setSrcResource(Resource src) {
            if (tSrcResource != null) {
                throw new BuildException(""only one resource per transaction"");
            }
            tSrcResource = src;
        }

        
        public void addText(String sql) {
            if (sql != null) {
                if (getExpandProperties()) {
                    sql = getProject().replaceProperties(sql);
                }
                this.tSqlCommand += sql;
            }
        }

        
        public void addConfigured(ResourceCollection a) {
            if (a.size() != 1) {
                throw new BuildException(""only single argument resource ""
                                         + ""collections are supported."");
            }
            setSrcResource((Resource) a.iterator().next());
        }

        
        private void runTransaction(PrintStream out)
            throws IOException, SQLException {
            if (tSqlCommand.length() != 0) {
                log(""Executing commands"", Project.MSG_INFO);
                runStatements(new StringReader(tSqlCommand), out);
            }

            if (tSrcResource != null) {
                log(""Executing resource: "" + tSrcResource.toString(),
                    Project.MSG_INFO);
                InputStream is = null;
                Reader reader = null;
                try {
                    is = tSrcResource.getInputStream();
                    reader =
                        (encoding == null) ? new InputStreamReader(is)
                        : new InputStreamReader(is, encoding);
                    runStatements(reader, out);
                } finally {
                    FileUtils.close(is);
                    FileUtils.close(reader);
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCCheckin,17,4,0,7,39,100,0,7,14,0.9375,241,0.461538462,0,0.75,0.382352941,2,3,12.41176471,7,1.4118,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCCheckin extends ClearCase {
    private String mComment = null;
    private String mCfile = null;
    private boolean mNwarn = false;
    private boolean mPtime = false;
    private boolean mKeep = false;
    private boolean mIdentical = true;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_CHECKIN);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        if (getNoWarn()) {
            
            cmd.createArgument().setValue(FLAG_NOWARN);
        }

        if (getPreserveTime()) {
            
            cmd.createArgument().setValue(FLAG_PRESERVETIME);
        }

        if (getKeepCopy()) {
            
            cmd.createArgument().setValue(FLAG_KEEPCOPY);
        }

        if (getIdentical()) {
            
            cmd.createArgument().setValue(FLAG_IDENTICAL);
        }

        
        cmd.createArgument().setValue(getViewPath());
    }


    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setNoWarn(boolean nwarn) {
        mNwarn = nwarn;
    }

    
    public boolean getNoWarn() {
        return mNwarn;
    }

    
    public void setPreserveTime(boolean ptime) {
        mPtime = ptime;
    }

    
    public boolean getPreserveTime() {
        return mPtime;
    }

    
    public void setKeepCopy(boolean keep) {
        mKeep = keep;
    }

    
    public boolean getKeepCopy() {
        return mKeep;
    }

    
    public void setIdentical(boolean identical) {
        mIdentical = identical;
    }

    
    public boolean getIdentical() {
        return mIdentical;
    }


    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }


        
    public static final String FLAG_COMMENT = ""-c"";
        
    public static final String FLAG_COMMENTFILE = ""-cfile"";
        
    public static final String FLAG_NOCOMMENT = ""-nc"";
        
    public static final String FLAG_NOWARN = ""-nwarn"";
        
    public static final String FLAG_PRESERVETIME = ""-ptime"";
        
    public static final String FLAG_KEEPCOPY = ""-keep"";
        
    public static final String FLAG_IDENTICAL = ""-identical"";

}

"
org.apache.tools.ant.util.FileUtils,58,1,0,142,158,1627,134,12,56,0.949874687,1752,0.642857143,1,0.0,0.160233918,0,0,28.96551724,17,2.6379,4,"

package org.apache.tools.ant.util;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.PathTokenizer;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.FilterSetCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.launch.Locator;


public class FileUtils {

    private static final FileUtils PRIMARY_INSTANCE = new FileUtils();

    
    private static Random rand = new Random(System.currentTimeMillis()
            + Runtime.getRuntime().freeMemory());

    private static boolean onNetWare = Os.isFamily(""netware"");
    private static boolean onDos = Os.isFamily(""dos"");
    private static boolean onWin9x = Os.isFamily(""win9x"");
    private static boolean onWindows = Os.isFamily(""windows"");

    static final int BUF_SIZE = 8192;


    
    public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000;

    
    public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000;

    
    public static final long NTFS_FILE_TIMESTAMP_GRANULARITY = 1;


    
    private Object cacheFromUriLock = new Object();
    private String cacheFromUriRequest = null;
    private String cacheFromUriResponse = null;

    
    public static FileUtils newFileUtils() {
        return new FileUtils();
    }

    
    public static FileUtils getFileUtils() {
        return PRIMARY_INSTANCE;
    }

    
    protected FileUtils() {
    }

    
    public URL getFileURL(File file) throws MalformedURLException {
        return new URL(toURI(file.getAbsolutePath()));
    }

    
    public void copyFile(String sourceFile, String destFile)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), null, false, false);
    }

    
    public void copyFile(String sourceFile, String destFile,
                         FilterSetCollection filters)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filters,
                 false, false);
    }

    
    public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
                         boolean overwrite) throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filters,
                 overwrite, false);
    }

    
    public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
                         boolean overwrite, boolean preserveLastModified)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filters,
                 overwrite, preserveLastModified);
    }

    
    public void copyFile(String sourceFile, String destFile,
                         FilterSetCollection filters, boolean overwrite,
                         boolean preserveLastModified, String encoding)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filters,
                 overwrite, preserveLastModified, encoding);
    }

    
    
    public void copyFile(String sourceFile, String destFile,
                         FilterSetCollection filters, Vector filterChains,
                         boolean overwrite, boolean preserveLastModified,
                         String encoding, Project project)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filters,
                 filterChains, overwrite, preserveLastModified,
                 encoding, project);
    }

    
    public void copyFile(String sourceFile, String destFile,
                         FilterSetCollection filters, Vector filterChains,
                         boolean overwrite, boolean preserveLastModified,
                         String inputEncoding, String outputEncoding,
                         Project project)
        throws IOException {
        copyFile(new File(sourceFile), new File(destFile), filters,
                 filterChains, overwrite, preserveLastModified,
                 inputEncoding, outputEncoding, project);
    }

    
    public void copyFile(File sourceFile, File destFile) throws IOException {
        copyFile(sourceFile, destFile, null, false, false);
    }

    
    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters)
        throws IOException {
        copyFile(sourceFile, destFile, filters, false, false);
    }

    
    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
                         boolean overwrite) throws IOException {
        copyFile(sourceFile, destFile, filters, overwrite, false);
    }

    
    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
                         boolean overwrite, boolean preserveLastModified)
        throws IOException {
        copyFile(sourceFile, destFile, filters, overwrite,
                 preserveLastModified, null);
    }

    
    public void copyFile(File sourceFile, File destFile,
                         FilterSetCollection filters, boolean overwrite,
                         boolean preserveLastModified, String encoding)
        throws IOException {
        copyFile(sourceFile, destFile, filters, null, overwrite,
                 preserveLastModified, encoding, null);
    }

    
    public void copyFile(File sourceFile, File destFile,
                         FilterSetCollection filters, Vector filterChains,
                         boolean overwrite, boolean preserveLastModified,
                         String encoding, Project project)
        throws IOException {
        copyFile(sourceFile, destFile, filters, filterChains,
                 overwrite, preserveLastModified, encoding, encoding, project);
    }

    
    public void copyFile(File sourceFile, File destFile,
                         FilterSetCollection filters, Vector filterChains,
                         boolean overwrite, boolean preserveLastModified,
                         String inputEncoding, String outputEncoding,
                         Project project)
        throws IOException {
        ResourceUtils.copyResource(
            new FileResource(sourceFile), new FileResource(destFile),
            filters, filterChains, overwrite, preserveLastModified,
            inputEncoding, outputEncoding, project);
    }

    

    
    public void setFileLastModified(File file, long time) {
        ResourceUtils.setLastModified(new FileResource(file), time);
    }

    
    public File resolveFile(File file, String filename) {
        if (!isAbsolutePath(filename)) {
            char sep = File.separatorChar;
            filename = filename.replace('/', sep).replace('\\', sep);
            if (isContextRelativePath(filename)) {
                file = null;
                
                
                String udir = System.getProperty(""user.dir"");
                if (filename.charAt(0) == sep && udir.charAt(0) == sep) {
                    filename = dissect(udir)[0] + filename.substring(1);
                }
            }
            filename = new File(file, filename).getAbsolutePath();
        }
        return normalize(filename);
    }

    
    public static boolean isContextRelativePath(String filename) {
        if (!(onDos || onNetWare) || filename.length() == 0) {
            return false;
        }
        char sep = File.separatorChar;
        filename = filename.replace('/', sep).replace('\\', sep);
        char c = filename.charAt(0);
        int len = filename.length();
        return (c == sep && (len == 1 || filename.charAt(1) != sep))
            || (Character.isLetter(c) && len > 1
            && filename.indexOf(':') == 1
            && (len == 2 || filename.charAt(2) != sep));
    }

    
    public static boolean isAbsolutePath(String filename) {
        int len = filename.length();
        if (len == 0) {
            return false;
        }
        char sep = File.separatorChar;
        filename = filename.replace('/', sep).replace('\\', sep);
        char c = filename.charAt(0);
        if (!(onDos || onNetWare)) {
            return (c == sep);
        }
        if (c == sep) {
            if (!(onDos && len > 4 && filename.charAt(1) == sep)) {
                return false;
            }
            int nextsep = filename.indexOf(sep, 2);
            return nextsep > 2 && nextsep + 1 < len;
        }
        int colon = filename.indexOf(':');
        return (Character.isLetter(c) && colon == 1
            && filename.length() > 2 && filename.charAt(2) == sep)
            || (onNetWare && colon > 0);
    }

    
    public static String translatePath(String toProcess) {
        if (toProcess == null || toProcess.length() == 0) {
            return """";
        }
        StringBuffer path = new StringBuffer(toProcess.length() + 50);
        PathTokenizer tokenizer = new PathTokenizer(toProcess);
        while (tokenizer.hasMoreTokens()) {
            String pathComponent = tokenizer.nextToken();
            pathComponent = pathComponent.replace('/', File.separatorChar);
            pathComponent = pathComponent.replace('\\', File.separatorChar);
            if (path.length() != 0) {
                path.append(File.pathSeparatorChar);
            }
            path.append(pathComponent);
        }
        return path.toString();
    }

    
    public File normalize(final String path) {
        Stack s = new Stack();
        String[] dissect = dissect(path);
        s.push(dissect[0]);

        StringTokenizer tok = new StringTokenizer(dissect[1], File.separator);
        while (tok.hasMoreTokens()) {
            String thisToken = tok.nextToken();
            if (""."".equals(thisToken)) {
                continue;
            } else if ("".."".equals(thisToken)) {
                if (s.size() < 2) {
                    
                    return new File(path);
                }
                s.pop();
            } else { 
                s.push(thisToken);
            }
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.size(); i++) {
            if (i > 1) {
                
                
                sb.append(File.separatorChar);
            }
            sb.append(s.elementAt(i));
        }
        return new File(sb.toString());
    }

    
    public String[] dissect(String path) {
        char sep = File.separatorChar;
        path = path.replace('/', sep).replace('\\', sep);

        
        if (!isAbsolutePath(path)) {
            throw new BuildException(path + "" is not an absolute path"");
        }
        String root = null;
        int colon = path.indexOf(':');
        if (colon > 0 && (onDos || onNetWare)) {

            int next = colon + 1;
            root = path.substring(0, next);
            char[] ca = path.toCharArray();
            root += sep;
            
            next = (ca[next] == sep) ? next + 1 : next;

            StringBuffer sbPath = new StringBuffer();
            
            for (int i = next; i < ca.length; i++) {
                if (ca[i] != sep || ca[i - 1] != sep) {
                    sbPath.append(ca[i]);
                }
            }
            path = sbPath.toString();
        } else if (path.length() > 1 && path.charAt(1) == sep) {
            
            int nextsep = path.indexOf(sep, 2);
            nextsep = path.indexOf(sep, nextsep + 1);
            root = (nextsep > 2) ? path.substring(0, nextsep + 1) : path;
            path = path.substring(root.length());
        } else {
            root = File.separator;
            path = path.substring(1);
        }
        return new String[] {root, path};
    }

    
    public String toVMSPath(File f) {
        
        String osPath;
        String path = normalize(f.getAbsolutePath()).getPath();
        String name = f.getName();
        boolean isAbsolute = path.charAt(0) == File.separatorChar;
        
        boolean isDirectory = f.isDirectory()
            && !name.regionMatches(true, name.length() - 4, "".DIR"", 0, 4);

        String device = null;
        StringBuffer directory = null;
        String file = null;

        int index = 0;

        if (isAbsolute) {
            index = path.indexOf(File.separatorChar, 1);
            if (index == -1) {
                return path.substring(1) + "":[000000]"";
            } else {
                device = path.substring(1, index++);
            }
        }
        if (isDirectory) {
            directory = new StringBuffer(path.substring(index).
                                         replace(File.separatorChar, '.'));
        } else {
            int dirEnd =
                path.lastIndexOf(File.separatorChar, path.length());
            if (dirEnd == -1 || dirEnd < index) {
                file = path.substring(index);
            } else {
                directory = new StringBuffer(path.substring(index, dirEnd).
                                             replace(File.separatorChar, '.'));
                index = dirEnd + 1;
                if (path.length() > index) {
                    file = path.substring(index);
                }
            }
        }
        if (!isAbsolute && directory != null) {
            directory.insert(0, '.');
        }
        osPath = ((device != null) ? device + "":"" : """")
            + ((directory != null) ? ""["" + directory + ""]"" : """")
            + ((file != null) ? file : """");
        return osPath;
    }

    
    public File createTempFile(String prefix, String suffix, File parentDir) {
        return createTempFile(prefix, suffix, parentDir, false);
    }

    
    public File createTempFile(String prefix, String suffix, File parentDir,
                               boolean deleteOnExit) {
        File result = null;
        String parent = (parentDir == null)
            ? System.getProperty(""java.io.tmpdir"")
            : parentDir.getPath();

        DecimalFormat fmt = new DecimalFormat(""#####"");
        synchronized (rand) {
            do {
                result = new File(parent,
                                  prefix + fmt.format(Math.abs(rand.nextInt()))
                                  + suffix);
            } while (result.exists());
        }
        if (deleteOnExit) {
            result.deleteOnExit();
        }
        return result;
    }

    
    public boolean contentEquals(File f1, File f2) throws IOException {
        return contentEquals(f1, f2, false);
    }

    
    public boolean contentEquals(File f1, File f2, boolean textfile) throws IOException {
        return ResourceUtils.contentEquals(
            new FileResource(f1), new FileResource(f2), textfile);
    }

    
    public File getParentFile(File f) {
        return (f == null) ? null : f.getParentFile();
    }

    
    public static final String readFully(Reader rdr) throws IOException {
        return readFully(rdr, BUF_SIZE);
    }

    
    public static final String readFully(Reader rdr, int bufferSize)
        throws IOException {
        if (bufferSize <= 0) {
            throw new IllegalArgumentException(""Buffer size must be greater ""
                                               + ""than 0"");
        }
        final char[] buffer = new char[bufferSize];
        int bufferLength = 0;
        StringBuffer textBuffer = null;
        while (bufferLength != -1) {
            bufferLength = rdr.read(buffer);
            if (bufferLength > 0) {
                textBuffer = (textBuffer == null) ? new StringBuffer() : textBuffer;
                textBuffer.append(new String(buffer, 0, bufferLength));
            }
        }
        return (textBuffer == null) ? null : textBuffer.toString();
    }

    
    public boolean createNewFile(File f) throws IOException {
        return f.createNewFile();
    }

    
    public boolean createNewFile(File f, boolean mkdirs) throws IOException {
        File parent = f.getParentFile();
        if (mkdirs && !(parent.exists())) {
            parent.mkdirs();
        }
        return f.createNewFile();
    }

    
    public boolean isSymbolicLink(File parent, String name)
        throws IOException {
        if (parent == null) {
            File f = new File(name);
            parent = f.getParentFile();
            name = f.getName();
        }
        File toTest = new File(parent.getCanonicalPath(), name);
        return !toTest.getAbsolutePath().equals(toTest.getCanonicalPath());
    }

    
    public String removeLeadingPath(File leading, File path) {
        String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
        String p = normalize(path.getAbsolutePath()).getAbsolutePath();
        if (l.equals(p)) {
            return """";
        }

        
        
        if (!l.endsWith(File.separator)) {
            l += File.separator;
        }
        return (p.startsWith(l)) ? p.substring(l.length()) : p;
    }

    
    public boolean isLeadingPath(File leading, File path) {
        String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
        String p = normalize(path.getAbsolutePath()).getAbsolutePath();
        if (l.equals(p)) {
            return true;
        }
        
        
        if (!l.endsWith(File.separator)) {
            l += File.separator;
        }
        return p.startsWith(l);
    }

    
    public String toURI(String path) {
        
        Class uriClazz = null;
        try {
            uriClazz = Class.forName(""java.net.URI"");
        } catch (ClassNotFoundException e) {
            
        }
        if (uriClazz != null) {
            try {
                File f = new File(path).getAbsoluteFile();
                java.lang.reflect.Method toURIMethod = File.class.getMethod(""toURI"", new Class[0]);
                Object uriObj = toURIMethod.invoke(f, new Object[] {});
                java.lang.reflect.Method toASCIIStringMethod
                    = uriClazz.getMethod(""toASCIIString"", new Class[0]);
                return (String) toASCIIStringMethod.invoke(uriObj, new Object[] {});
            } catch (Exception e) {
                
                e.printStackTrace();
            }
        }
        boolean isDir = new File(path).isDirectory();

        StringBuffer sb = new StringBuffer(""file:"");

        path = resolveFile(null, path).getPath();
        sb.append(""
        
        if (!path.startsWith(File.separator)) {
            sb.append(""/"");
        }
        path = path.replace('\\', '/');
        try {
            sb.append(Locator.encodeURI(path));
        } catch (UnsupportedEncodingException exc) {
            throw new BuildException(exc);
        }
        if (isDir && !path.endsWith(""/"")) {
            sb.append('/');
        }
        return sb.toString();
    }

    
    public String fromURI(String uri) {
        synchronized (cacheFromUriLock) {
            if (uri.equals(cacheFromUriRequest)) {
                return cacheFromUriResponse;
            }
            String path = Locator.fromURI(uri);
            String ret = isAbsolutePath(path)
                ? normalize(path).getAbsolutePath() : path;
            cacheFromUriRequest = uri;
            cacheFromUriResponse = ret;
            return ret;
        }
    }

    
    public boolean fileNameEquals(File f1, File f2) {
        return normalize(f1.getAbsolutePath())
            .equals(normalize(f2.getAbsolutePath()));
    }

    
    public void rename(File from, File to) throws IOException {
        if (to.exists() && !to.delete()) {
            throw new IOException(""Failed to delete "" + to
                                  + "" while trying to rename "" + from);
        }
        File parent = to.getParentFile();
        if (parent != null && !parent.exists() && !parent.mkdirs()) {
            throw new IOException(""Failed to create directory "" + parent
                                  + "" while trying to rename "" + from);
        }
        if (!from.renameTo(to)) {
            copyFile(from, to);
            if (!from.delete()) {
                throw new IOException(""Failed to delete "" + from
                                      + "" while trying to rename it."");
            }
        }
    }

    
    public long getFileTimestampGranularity() {
        if (onWin9x) {
            return FAT_FILE_TIMESTAMP_GRANULARITY;
        } else if (onWindows) {
            return NTFS_FILE_TIMESTAMP_GRANULARITY;
        } else if (onDos) {
            return FAT_FILE_TIMESTAMP_GRANULARITY;
        }
        return UNIX_FILE_TIMESTAMP_GRANULARITY;
    }

    
    public boolean isUpToDate(File source, File dest, long granularity) {
        
        if (!dest.exists()) {
            
            return false;
        }
        long sourceTime = source.lastModified();
        long destTime = dest.lastModified();
        return isUpToDate(sourceTime, destTime, granularity);
    }

    
    public boolean isUpToDate(File source, File dest) {
        return isUpToDate(source, dest, getFileTimestampGranularity());
    }

    
    public boolean isUpToDate(long sourceTime, long destTime, long granularity) {
        if (destTime == -1) {
            return false;
        }
        return destTime >= sourceTime + granularity;
    }

    
    public boolean isUpToDate(long sourceTime, long destTime) {
        return isUpToDate(sourceTime, destTime, getFileTimestampGranularity());
    }

    
    public static void close(Writer device) {
        if (device != null) {
            try {
                device.close();
            } catch (IOException ioex) {
                
            }
        }
    }

    
    public static void close(Reader device) {
        if (device != null) {
            try {
                device.close();
            } catch (IOException ioex) {
                
            }
        }
    }

    
    public static void close(OutputStream device) {
        if (device != null) {
            try {
                device.close();
            } catch (IOException ioex) {
                
            }
        }
    }

    
    public static void close(InputStream device) {
        if (device != null) {
            try {
                device.close();
            } catch (IOException ioex) {
                
            }
        }
    }

    
    public static void delete(File file) {
        if (file != null) {
            file.delete();
        }
    }

    
    public static String getRelativePath(
        File fromFile,
        File toFile
    ) throws Exception {
        String fromPath = fromFile.getCanonicalPath();
        String toPath = toFile.getCanonicalPath();

        
        String[] fromPathStack = getPathStack(fromPath);
        String[] toPathStack = getPathStack(toPath);

        if (0 < toPathStack.length && 0 < fromPathStack.length) {
            if (!fromPathStack[0].equals(toPathStack[0])) {
                

                return getPath(Arrays.asList(toPathStack));
            }
        } else {
            
            return getPath(Arrays.asList(toPathStack));
        }

        int minLength = Math
                .min(fromPathStack.length, toPathStack.length);

        int same = 1;

        
        for (; same < minLength; same++) {
            if (!fromPathStack[same].equals(toPathStack[same])) {
                break;
            }
        }

        List relativePathStack = new ArrayList();

        
        
        for (int i = same; i < fromPathStack.length; i++) {
            relativePathStack.add("".."");
        }

        
        for (int i = same; i < toPathStack.length; i++) {
            relativePathStack.add(toPathStack[i]);
        }

        return getPath(relativePathStack);
    }

    
    public static String[] getPathStack(String path) {
        String normalizedPath = path.replace(File.separatorChar, '/');

        
        
        
        Object[] tokens = StringUtils.split(normalizedPath, '/').toArray();
        String[] rv = new String[tokens.length];
        System.arraycopy(tokens, 0, rv, 0, tokens.length);

        return rv;
    }

    
    public static String getPath(List pathStack) {
        
        return getPath(pathStack, '/');
    }

    
    public static String getPath(final List pathStack, final char separatorChar) {
        final StringBuffer buffer = new StringBuffer();

        final Iterator iter = pathStack.iterator();
        if (iter.hasNext()) {
            buffer.append(iter.next());
        }

        while (iter.hasNext()) {
            buffer.append(separatorChar);
            buffer.append(iter.next());
        }

        return buffer.toString();
    }

    
    public String getDefaultEncoding() {
        InputStreamReader is = new InputStreamReader(
            new InputStream() {
                public int read() {
                    return -1;
                }
            });
        try {
            return is.getEncoding();
        } finally {
            close(is);
        }
    }
}
"
org.apache.tools.ant.PropertyHelper,23,1,0,4,56,107,3,2,18,0.636363636,689,1.0,2,0.0,0.260869565,0,0,28.73913043,7,2.1304,3,"

package org.apache.tools.ant;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;





public class PropertyHelper {

    private Project project;
    private PropertyHelper next;

    
    private Hashtable properties = new Hashtable();

    
    private Hashtable userProperties = new Hashtable();

    
    private Hashtable inheritedProperties = new Hashtable();

    
    protected PropertyHelper() {
    }

    


    

    
    public void setProject(Project p) {
        this.project = p;
    }

    
    public void setNext(PropertyHelper next) {
        this.next = next;
    }

    
    public PropertyHelper getNext() {
        return next;
    }

    
    public static synchronized
        PropertyHelper getPropertyHelper(Project project) {
        PropertyHelper helper
            = (PropertyHelper) project.getReference(MagicNames.REFID_PROPERTY_HELPER);
        if (helper != null) {
            return helper;
        }
        helper = new PropertyHelper();
        helper.setProject(project);

        project.addReference(MagicNames.REFID_PROPERTY_HELPER, helper);
        return helper;
    }

    

    
    public boolean setPropertyHook(String ns, String name,
                                   Object value,
                                   boolean inherited, boolean user,
                                   boolean isNew) {
        if (getNext() != null) {
            boolean subst = getNext().setPropertyHook(ns, name, value,
                    inherited, user, isNew);
            
            if (subst) {
                return true;
            }
        }
        return false;
    }

    
    public Object getPropertyHook(String ns, String name, boolean user) {
        if (getNext() != null) {
            Object o = getNext().getPropertyHook(ns, name, user);
            if (o != null) {
                return o;
            }
        }
        
        if (name.startsWith(""toString:"")) {
            name = name.substring(""toString:"".length());
            Object v = project.getReference(name);
            return (v == null) ? null : v.toString();
        }
        return null;
    }

    
    
    
    
    

    
    public void parsePropertyString(String value, Vector fragments,
                                    Vector propertyRefs)
        throws BuildException {
        parsePropertyStringDefault(value, fragments, propertyRefs);
    }

    
    public String replaceProperties(String ns, String value, Hashtable keys)
            throws BuildException {
        if (value == null || value.indexOf('$') == -1) {
            return value;
        }
        Vector fragments = new Vector();
        Vector propertyRefs = new Vector();
        parsePropertyString(value, fragments, propertyRefs);

        StringBuffer sb = new StringBuffer();
        Enumeration i = fragments.elements();
        Enumeration j = propertyRefs.elements();

        while (i.hasMoreElements()) {
            String fragment = (String) i.nextElement();
            if (fragment == null) {
                String propertyName = (String) j.nextElement();
                Object replacement = null;

                
                
                if (keys != null) {
                    replacement = keys.get(propertyName);
                }
                if (replacement == null) {
                    replacement = getProperty(ns, propertyName);
                }

                if (replacement == null) {
                    project.log(""Property \"""" + propertyName
                            + ""\"" has not been set"", Project.MSG_VERBOSE);
                }
                fragment = (replacement != null)
                        ? replacement.toString()
                        : ""${"" + propertyName + ""}"";
            }
            sb.append(fragment);
        }
        return sb.toString();
    }

    
    
    


    
    public synchronized boolean setProperty(String ns, String name,
                                            Object value, boolean verbose) {
        
        if (null != userProperties.get(name)) {
            if (verbose) {
                project.log(""Override ignored for user property \"""" + name
                    + ""\"""", Project.MSG_VERBOSE);
            }
            return false;
        }

        boolean done = setPropertyHook(ns, name, value, false, false, false);
        if (done) {
            return true;
        }

        if (null != properties.get(name) && verbose) {
            project.log(""Overriding previous definition of property \"""" + name
                + ""\"""", Project.MSG_VERBOSE);
        }

        if (verbose) {
            project.log(""Setting project property: "" + name + "" -> ""
                + value, Project.MSG_DEBUG);
        }
        properties.put(name, value);
        return true;
    }

    
    public synchronized void setNewProperty(String ns, String name,
                                            Object value) {
        if (null != properties.get(name)) {
            project.log(""Override ignored for property \"""" + name
                + ""\"""", Project.MSG_VERBOSE);
            return;
        }

        boolean done = setPropertyHook(ns, name, value, false, false, true);
        if (done) {
            return;
        }

        project.log(""Setting project property: "" + name + "" -> ""
            + value, Project.MSG_DEBUG);
        if (name != null && value != null) {
            properties.put(name, value);
        }
    }

    
    public synchronized void setUserProperty(String ns, String name,
                                             Object value) {
        project.log(""Setting ro project property: "" + name + "" -> ""
            + value, Project.MSG_DEBUG);
        userProperties.put(name, value);

        boolean done = setPropertyHook(ns, name, value, false, true, false);
        if (done) {
            return;
        }
        properties.put(name, value);
    }

    
    public synchronized void setInheritedProperty(String ns, String name,
                                                  Object value) {
        inheritedProperties.put(name, value);

        project.log(""Setting ro project property: "" + name + "" -> ""
            + value, Project.MSG_DEBUG);
        userProperties.put(name, value);

        boolean done = setPropertyHook(ns, name, value, true, false, false);
        if (done) {
            return;
        }
        properties.put(name, value);
    }

    

    
    public synchronized Object getProperty(String ns, String name) {
        if (name == null) {
            return null;
        }

        Object o = getPropertyHook(ns, name, false);
        if (o != null) {
            return o;
        }

        return properties.get(name);
    }
    
    public synchronized Object getUserProperty(String ns, String name) {
        if (name == null) {
            return null;
        }
        Object o = getPropertyHook(ns, name, true);
        if (o != null) {
            return o;
        }
        return  userProperties.get(name);
    }


    
    
    
    

    
    public Hashtable getProperties() {
        return new Hashtable(properties);
        
        
    }

    
    public Hashtable getUserProperties() {
        return new Hashtable(userProperties);
    }

    
    protected Hashtable getInternalProperties() {
        return properties;
    }

    
    protected Hashtable getInternalUserProperties() {
        return userProperties;
    }

    
    protected Hashtable getInternalInheritedProperties() {
        return inheritedProperties;
    }


    
    public void copyInheritedProperties(Project other) {
        Enumeration e = inheritedProperties.keys();
        while (e.hasMoreElements()) {
            String arg = e.nextElement().toString();
            if (other.getUserProperty(arg) != null) {
                continue;
            }
            Object value = inheritedProperties.get(arg);
            other.setInheritedProperty(arg, value.toString());
        }
    }

    
    public void copyUserProperties(Project other) {
        Enumeration e = userProperties.keys();
        while (e.hasMoreElements()) {
            Object arg = e.nextElement();
            if (inheritedProperties.containsKey(arg)) {
                continue;
            }
            Object value = userProperties.get(arg);
            other.setUserProperty(arg.toString(), value.toString());
        }
    }

    
    
    
    

    
    static void parsePropertyStringDefault(String value, Vector fragments,
                                    Vector propertyRefs)
        throws BuildException {
        int prev = 0;
        int pos;
        
        while ((pos = value.indexOf(""$"", prev)) >= 0) {

            
            
            
            
            if (pos > 0) {
                fragments.addElement(value.substring(prev, pos));
            }
            
            
            if (pos == (value.length() - 1)) {
                fragments.addElement(""$"");
                prev = pos + 1;
            } else if (value.charAt(pos + 1) != '{') {
                
                
                
                if (value.charAt(pos + 1) == '$') {
                    
                    fragments.addElement(""$"");
                    prev = pos + 2;
                } else {
                    
                    fragments.addElement(value.substring(pos, pos + 2));
                    prev = pos + 2;
                }

            } else {
                
                int endName = value.indexOf('}', pos);
                if (endName < 0) {
                    throw new BuildException(""Syntax error in property: ""
                                                 + value);
                }
                String propertyName = value.substring(pos + 2, endName);
                fragments.addElement(null);
                propertyRefs.addElement(propertyName);
                prev = endName + 1;
            }
        }
        
        
        if (prev < value.length()) {
            fragments.addElement(value.substring(prev));
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.dotnet.ImportTypelib,11,3,0,4,29,17,0,4,8,0.771428571,224,1.0,1,0.804347826,0.4,1,1,18.72727273,3,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;

import java.io.File;


public class ImportTypelib extends Task {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private File srcFile;

    
    private File destFile;

    
    private String namespace;

    
    private boolean useSysArray = false;

    
    private boolean unsafe = false;

    
    private String extraOptions = null;

    
    public void setDestFile(File destFile) {
        this.destFile = destFile;
    }

    
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    
    public void setSrcFile(File srcFile) {
        this.srcFile = srcFile;
    }

    
    public void setUnsafe(boolean unsafe) {
        this.unsafe = unsafe;
    }

    
    public void setUseSysArray(boolean useSysArray) {
        this.useSysArray = useSysArray;
    }

    
    public void setExtraOptions(String extraOptions) {
        this.extraOptions = extraOptions;
    }

    
    protected void validate()
            throws BuildException {
        if (destFile == null) {
            throw new BuildException(""destination file must be specified"");
        }
        if (destFile.isDirectory()) {
            throw new BuildException(
                    ""destination file is a directory"");
        }
        if (srcFile == null || !srcFile.exists()) {
            throw new BuildException(
                    ""source file does not exist"");
        }
        if (srcFile.isDirectory()) {
            throw new BuildException(
                    ""source file is a directory"");
        }
        if (namespace == null) {
            throw new BuildException(""No namespace"");
        }
    }

    
    private boolean isExecuteNeeded() {
        if (!destFile.exists()) {
            log(""Destination file does not exist: a build is required"",
                    Project.MSG_VERBOSE);
            return true;
        }
        long sourceTime = srcFile.lastModified();
        long destTime = destFile.lastModified();
        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {
            log(""Source file is newer than the dest file: a rebuild is required"",
                    Project.MSG_VERBOSE);
            return true;
        } else {
            log(""The output file is up to date"", Project.MSG_VERBOSE);
            return false;
        }

    }


    
    public void execute() throws BuildException {
        log(""This task is deprecated and will be removed in a future version\n""
            + ""of Ant.  It is now part of the .NET Antlib:\n""
            + ""http:
            Project.MSG_WARN);
        validate();
        log(""Importing typelib "" + srcFile
            + "" to assembly "" + destFile
            + "" in namespace "" + namespace, Project.MSG_VERBOSE);
        
        if (!isExecuteNeeded()) {
            return;
        }

        NetCommand command = new NetCommand(this, ""ImportTypelib"", ""tlbimp"");
        command.setFailOnError(true);
        command.addArgument(srcFile.toString());
        
        command.addArgument(""/nologo"");
        command.addArgument(""/out:"" + destFile);
        command.addArgument(""/namespace:"", namespace);
        if (useSysArray) {
            command.addArgument(""/sysarray"");
        }
        if (unsafe) {
            command.addArgument(""/unsafe"");
        }
        command.addArgument(extraOptions);
        command.runCommand();
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.resolvers.URLResolver,8,1,0,6,24,0,1,5,6,0.523809524,133,1.0,0,0.0,0.325,0,0,15.25,6,2.0,0,"
package org.apache.tools.ant.taskdefs.optional.extension.resolvers;

import java.io.File;
import java.net.URL;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Get;
import org.apache.tools.ant.taskdefs.optional.extension.Extension;
import org.apache.tools.ant.taskdefs.optional.extension.ExtensionResolver;


public class URLResolver implements ExtensionResolver {
    private File destfile;
    private File destdir;
    private URL url;

    
    public void setUrl(final URL url) {
        this.url = url;
    }

    
    public void setDestfile(final File destfile) {
        this.destfile = destfile;
    }

    
    public void setDestdir(final File destdir) {
        this.destdir = destdir;
    }

    
    public File resolve(final Extension extension,
                         final Project project) throws BuildException {
        validate();

        final File file = getDest();

        final Get get = new Get();
        get.setProject(project);
        get.setDest(file);
        get.setSrc(url);
        get.execute();

        return file;
    }

    
    private File getDest() {
        File result;
        if (null != destfile) {
            result = destfile;
        } else {
            final String file = url.getFile();
            String filename;
            if (null == file || file.length() <= 1) {
                filename = ""default.file"";
            } else {
                int index = file.lastIndexOf('/');
                if (-1 == index) {
                    index = 0;
                }
                filename = file.substring(index);
            }
            result = new File(destdir, filename);
        }
        return result;
    }

    
    private void validate() {
        if (null == url) {
            final String message = ""Must specify URL"";
            throw new BuildException(message);
        }

        if (null == destdir && null == destfile) {
            final String message = ""Must specify destination file or directory"";
            throw new BuildException(message);
        } else if (null != destdir && null != destfile) {
            final String message = ""Must not specify both destination file or directory"";
            throw new BuildException(message);
        }
    }

    
    public String toString() {
        return ""URL["" + url + ""]"";
    }
}
"
org.apache.tools.ant.taskdefs.optional.native2ascii.KaffeNative2Ascii,5,2,0,8,16,8,1,7,1,0.875,77,0.5,0,0.571428571,0.4375,1,2,14.0,2,0.8,0,"
package org.apache.tools.ant.taskdefs.optional.native2ascii;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.taskdefs.ExecuteJava;
import org.apache.tools.ant.taskdefs.optional.Native2Ascii;
import org.apache.tools.ant.types.Commandline;


public final class KaffeNative2Ascii extends DefaultNative2Ascii {

    
    private static final String[] N2A_CLASSNAMES = new String[] {
        ""gnu.classpath.tools.native2ascii.Native2Ascii"",
        
        ""kaffe.tools.native2ascii.Native2Ascii"",
    };

    
    public static final String IMPLEMENTATION_NAME = ""kaffe"";

    
    protected void setup(Commandline cmd, Native2Ascii args)
        throws BuildException {
        if (args.getReverse()) {
            throw new BuildException(""-reverse is not supported by Kaffe"");
        }
        super.setup(cmd, args);
    }

    
    protected boolean run(Commandline cmd, ProjectComponent log)
        throws BuildException {
        ExecuteJava ej = new ExecuteJava();
        Class c = getN2aClass();
        if (c == null) {
            throw new BuildException(""Couldn't load Kaffe's Native2Ascii""
                                     + "" class"");
        }

        cmd.setExecutable(c.getName());
        ej.setJavaCommand(cmd);
        ej.execute(log.getProject());
        
        return true;
    }

    
    private static Class getN2aClass() {
        for (int i = 0; i < N2A_CLASSNAMES.length; i++) {
            try {
                return Class.forName(N2A_CLASSNAMES[i]);
            } catch (ClassNotFoundException cnfe) {
                
            }
        }
        return null;
    }

}
"
org.apache.tools.ant.types.Substitution,4,3,0,5,7,0,3,2,4,0.833333333,33,0.5,0,0.909090909,0.583333333,0,0,6.75,2,1.0,1,"
package org.apache.tools.ant.types;


import org.apache.tools.ant.Project;


public class Substitution extends DataType {
    
    public static final String DATA_TYPE_NAME = ""substitition"";

    private String expression;

    
    public Substitution() {
        this.expression = null;
    }

    
    public void setExpression(String expression) {
        this.expression = expression;
    }

    
    public String getExpression(Project p) {
        if (isReference()) {
            return getRef(p).getExpression(p);
        }

        return expression;
    }

    
    public Substitution getRef(Project p) {
        return (Substitution) getCheckedRef(p);
    }
}
"
org.apache.tools.ant.taskdefs.cvslib.CvsUser,6,1,0,2,11,3,1,1,6,0.6,51,1.0,0,0.0,0.666666667,0,0,7.166666667,1,0.8333,0,"
package org.apache.tools.ant.taskdefs.cvslib;

import org.apache.tools.ant.BuildException;


public class CvsUser {
    
    private String userID;
    
    private String displayName;


    
    public void setDisplayname(final String displayName) {
        this.displayName = displayName;
    }


    
    public void setUserid(final String userID) {
        this.userID = userID;
    }


    
    public String getUserID() {
        return userID;
    }


    
    public String getDisplayname() {
        return displayName;
    }


    
    public void validate() throws BuildException {
        if (null == userID) {
            final String message = ""Username attribute must be set."";

            throw new BuildException(message);
        }
        if (null == displayName) {
            final String message =
                ""Displayname attribute must be set for userID "" + userID;

            throw new BuildException(message);
        }
    }
}

"
org.apache.tools.zip.ExtraFieldUtils,7,1,0,4,41,15,1,3,6,0.833333333,388,0.333333333,0,0.0,0.2,0,0,54.0,3,1.2857,2,"

package org.apache.tools.zip;

import java.util.Hashtable;
import java.util.Vector;
import java.util.zip.ZipException;


public class ExtraFieldUtils {

    
    private static Hashtable implementations;

    static {
        implementations = new Hashtable();
        register(AsiExtraField.class);
        register(JarMarker.class);
    }

    
    public static void register(Class c) {
        try {
            ZipExtraField ze = (ZipExtraField) c.newInstance();
            implementations.put(ze.getHeaderId(), c);
        } catch (ClassCastException cc) {
            throw new RuntimeException(c + "" doesn\'t implement ZipExtraField"");
        } catch (InstantiationException ie) {
            throw new RuntimeException(c + "" is not a concrete class"");
        } catch (IllegalAccessException ie) {
            throw new RuntimeException(c + ""\'s no-arg constructor is not public"");
        }
    }

    
    public static ZipExtraField createExtraField(ZipShort headerId)
        throws InstantiationException, IllegalAccessException {
        Class c = (Class) implementations.get(headerId);
        if (c != null) {
            return (ZipExtraField) c.newInstance();
        }
        UnrecognizedExtraField u = new UnrecognizedExtraField();
        u.setHeaderId(headerId);
        return u;
    }

    
    public static ZipExtraField[] parse(byte[] data) throws ZipException {
        Vector v = new Vector();
        int start = 0;
        while (start <= data.length - 4) {
            ZipShort headerId = new ZipShort(data, start);
            int length = (new ZipShort(data, start + 2)).getValue();
            if (start + 4 + length > data.length) {
                throw new ZipException(""data starting at "" + start
                    + "" is in unknown format"");
            }
            try {
                ZipExtraField ze = createExtraField(headerId);
                ze.parseFromLocalFileData(data, start + 4, length);
                v.addElement(ze);
            } catch (InstantiationException ie) {
                throw new ZipException(ie.getMessage());
            } catch (IllegalAccessException iae) {
                throw new ZipException(iae.getMessage());
            }
            start += (length + 4);
        }
        if (start != data.length) { 
            throw new ZipException(""data starting at "" + start
                + "" is in unknown format"");
        }

        ZipExtraField[] result = new ZipExtraField[v.size()];
        v.copyInto(result);
        return result;
    }

    
    public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {
        int sum = 4 * data.length;
        for (int i = 0; i < data.length; i++) {
            sum += data[i].getLocalFileDataLength().getValue();
        }
        byte[] result = new byte[sum];
        int start = 0;
        for (int i = 0; i < data.length; i++) {
            System.arraycopy(data[i].getHeaderId().getBytes(),
                             0, result, start, 2);
            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),
                             0, result, start + 2, 2);
            byte[] local = data[i].getLocalFileDataData();
            System.arraycopy(local, 0, result, start + 4, local.length);
            start += (local.length + 4);
        }
        return result;
    }

    
    public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {
        int sum = 4 * data.length;
        for (int i = 0; i < data.length; i++) {
            sum += data[i].getCentralDirectoryLength().getValue();
        }
        byte[] result = new byte[sum];
        int start = 0;
        for (int i = 0; i < data.length; i++) {
            System.arraycopy(data[i].getHeaderId().getBytes(),
                             0, result, start, 2);
            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),
                             0, result, start + 2, 2);
            byte[] local = data[i].getCentralDirectoryData();
            System.arraycopy(local, 0, result, start + 4, local.length);
            start += (local.length + 4);
        }
        return result;
    }
}
"
org.apache.tools.ant.filters.TailFilter,10,5,0,5,30,0,1,4,6,0.688888889,328,1.0,1,0.777777778,0.375,2,5,30.8,12,2.3,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.util.LinkedList;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.util.LineTokenizer;


public final class TailFilter extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String LINES_KEY = ""lines"";

    
    private static final String SKIP_KEY = ""skip"";

    
    private static final int DEFAULT_NUM_LINES = 10;

    
    private long lines = DEFAULT_NUM_LINES;

    
    private long skip = 0;

    
    private boolean completedReadAhead = false;

    
    private LineTokenizer lineTokenizer = null;

    
    private String    line      = null;
    
    private int       linePos   = 0;

    private LinkedList lineList = new LinkedList();

    
    public TailFilter() {
        super();
    }

    
    public TailFilter(final Reader in) {
        super(in);
        lineTokenizer = new LineTokenizer();
        lineTokenizer.setIncludeDelims(true);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        while (line == null || line.length() == 0) {
            line = lineTokenizer.getToken(in);
            line = tailFilter(line);
            if (line == null) {
                return -1;
            }
            linePos = 0;
        }

        int ch = line.charAt(linePos);
        linePos++;
        if (linePos == line.length()) {
            line = null;
        }
        return ch;
    }

    
    public void setLines(final long lines) {
        this.lines = lines;
    }

    
    private long getLines() {
        return lines;
    }

    
    public void setSkip(final long skip) {
        this.skip = skip;
    }

    
    private long getSkip() {
        return skip;
    }

    
    public Reader chain(final Reader rdr) {
        TailFilter newFilter = new TailFilter(rdr);
        newFilter.setLines(getLines());
        newFilter.setSkip(getSkip());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (LINES_KEY.equals(params[i].getName())) {
                    setLines(new Long(params[i].getValue()).longValue());
                    continue;
                }
                if (SKIP_KEY.equals(params[i].getName())) {
                    skip = new Long(params[i].getValue()).longValue();
                    continue;
                }
            }
        }
    }

    
    private String tailFilter(String line) {
        if (!completedReadAhead) {
            if (line != null) {
                lineList.add(line);
                if (lines == -1) {
                    if (lineList.size() > skip) {
                        return (String) lineList.removeFirst();
                    }
                } else {
                    long linesToKeep = lines + (skip > 0 ? skip : 0);
                    if (linesToKeep < lineList.size()) {
                        lineList.removeFirst();
                    }
                }
                return """";
            }
            completedReadAhead = true;
            if (skip > 0) {
                for (int i = 0; i < skip; ++i) {
                    lineList.removeLast();
                }
            }
            if (lines > -1) {
                while (lineList.size() > lines) {
                    lineList.removeFirst();
                }
            }
        }
        if (lineList.size() > 0) {
            return (String) lineList.removeFirst();
        }
        return null;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.Xalan2Executor,4,2,0,3,26,0,0,3,1,1.0,115,1.0,0,0.727272727,0.625,2,3,27.0,1,0.75,0,"
package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.OutputStream;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.tools.ant.BuildException;


public class Xalan2Executor extends XalanExecutor {

    private static final String APAC = ""org.apache.xalan."";
    private static final String SPAC = ""com.sun.org.apache.xalan."";

    private TransformerFactory tfactory = TransformerFactory.newInstance();

    
    protected String getImplementation() throws BuildException {
        return tfactory.getClass().getName();
    }

    
    protected String getProcVersion(String classNameImpl)
        throws BuildException {
        try {
            
            if (classNameImpl.equals(APAC + ""processor.TransformerFactoryImpl"")
                ||
                classNameImpl.equals(APAC + ""xslt.XSLTProcessorFactory"")) {
                return getXalanVersion(APAC + ""processor.XSLProcessorVersion"");
            }
            
            if (classNameImpl.equals(APAC
                                     + ""xsltc.trax.TransformerFactoryImpl"")) {
                return getXSLTCVersion(APAC + ""xsltc.ProcessorVersion"");
            }
            
            if (classNameImpl
                .equals(SPAC + ""internal.xsltc.trax.TransformerFactoryImpl"")) {
                return getXSLTCVersion(SPAC
                                       + ""internal.xsltc.ProcessorVersion"");
            }
            throw new BuildException(""Could not find a valid processor version""
                                     + "" implementation from ""
                                     + classNameImpl);
        } catch (ClassNotFoundException e) {
            throw new BuildException(""Could not find processor version ""
                                     + ""implementation"", e);
        }
    }

    
    void execute() throws Exception {
        String systemId = caller.getStylesheetSystemId();
        Source xslSrc = new StreamSource(systemId);
        Transformer tformer = tfactory.newTransformer(xslSrc);
        Source xmlSrc = new DOMSource(caller.document);
        OutputStream os = getOutputStream();
        try {
            tformer.setParameter(""output.dir"", caller.toDir.getAbsolutePath());
            Result result = new StreamResult(os);
            tformer.transform(xmlSrc, result);
        } finally {
            os.close();
        }
    }
}
"
org.apache.tools.ant.taskdefs.Length,17,3,0,18,53,86,4,18,14,0.892045455,348,1.0,2,0.698113208,0.155080214,1,1,18.82352941,8,2.2353,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.PrintStream;
import java.io.OutputStream;
import java.util.Iterator;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Comparison;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.resources.Resources;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.PropertyOutputStream;


public class Length extends Task implements Condition {

    private static final String ALL = ""all"";
    private static final String EACH = ""each"";
    private static final String STRING = ""string"";

    private static final String LENGTH_REQUIRED
        = ""Use of the Length condition requires that the length attribute be set."";

    private String property;
    private String string;
    private Boolean trim;
    private String mode = ALL;
    private Comparison when = Comparison.EQUAL;
    private Long length;
    private Resources resources;

    
    public synchronized void setProperty(String property) {
        this.property = property;
    }

    
    public synchronized void setFile(File file) {
        add(new FileResource(file));
    }

    
    public synchronized void add(FileSet fs) {
        add((ResourceCollection) fs);
    }

    
    public synchronized void add(ResourceCollection c) {
        if (c == null) {
            return;
        }
        resources = (resources == null) ? new Resources() : resources;
        resources.add(c);
    }

    
    public synchronized void setLength(long ell) {
        length = new Long(ell);
    }

    
    public synchronized void setWhen(When w) {
        setWhen((Comparison) w);
    }

    
    public synchronized void setWhen(Comparison c) {
        when = c;
    }

    
    public synchronized void setMode(FileMode m) {
        this.mode = m.getValue();
    }

    
    public synchronized void setString(String string) {
        this.string = string;
        this.mode = STRING;
    }

    
    public synchronized void setTrim(boolean trim) {
        this.trim = trim ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public boolean getTrim() {
        return trim != null && trim.booleanValue();
    }

    
    public void execute() {
        validate();
        PrintStream ps = new PrintStream((property != null)
            ? (OutputStream) new PropertyOutputStream(getProject(), property)
            : (OutputStream) new LogOutputStream(this, Project.MSG_INFO));

        if (STRING.equals(mode)) {
            ps.print(getLength(string, getTrim()));
            ps.close();
        } else if (EACH.equals(mode)) {
            handleResources(new EachHandler(ps));
        } else if (ALL.equals(mode)) {
            handleResources(new AllHandler(ps));
        }
    }

    
    public boolean eval() {
        validate();
        if (length == null) {
            throw new BuildException(LENGTH_REQUIRED);
        }
        Long ell = null;
        if (STRING.equals(mode)) {
            ell = new Long(getLength(string, getTrim()));
        } else {
            ConditionHandler h = new ConditionHandler();
            handleResources(h);
            ell = new Long(h.getLength());
        }
        return when.evaluate(ell.compareTo(length));
    }

    private void validate() {
        if (string != null) {
            if (resources != null) {
                throw new BuildException(""the string length function""
                    + "" is incompatible with the file/resource length function"");
            }
            if (!(STRING.equals(mode))) {
                throw new BuildException(""the mode attribute is for use""
                    + "" with the file/resource length function"");
            }
        } else if (resources != null) {
            if (!(EACH.equals(mode) || ALL.equals(mode))) {
                throw new BuildException(""invalid mode setting for""
                    + "" file/resource length function: \"""" + mode + ""\"""");
            } else if (trim != null) {
                throw new BuildException(""the trim attribute is""
                    + "" for use with the string length function only"");
            }
        } else {
            throw new BuildException(""you must set either the string attribute""
                + "" or specify one or more files using the file attribute or""
                + "" nested resource collections"");
        }
    }

    private void handleResources(Handler h) {
        for (Iterator i = resources.iterator(); i.hasNext();) {
            Resource r = (Resource) i.next();
            if (!r.isExists()) {
                log(r + "" does not exist"", Project.MSG_ERR);
            } else if (r.isDirectory()) {
                log(r + "" is a directory; length unspecified"",
                    Project.MSG_ERR);
            } else {
                h.handle(r);
            }
        }
        h.complete();
    }

    private static long getLength(String s, boolean t) {
        return (t ? s.trim() : s).length();
    }

    
    public static class FileMode extends EnumeratedAttribute {
        static final String[] MODES = new String[] {EACH, ALL};

        
        public String[] getValues() {
            return MODES;
        }

    }

    
    public static class When extends Comparison {
        
    }

    private abstract class Handler {
        private PrintStream ps;
        Handler(PrintStream ps) {
            this.ps = ps;
        }

        protected PrintStream getPs() {
            return ps;
        }

        protected abstract void handle(Resource r);

        void complete() {
            ps.close();
        }
    }

    private class EachHandler extends Handler {
        EachHandler(PrintStream ps) {
            super(ps);
        }
        protected void handle(Resource r) {
            getPs().print(r.toString());
            getPs().print("" : "");
            
            long size = r.getSize();
            if (size == Resource.UNKNOWN_SIZE) {
                getPs().println(""unknown"");
            } else {
                getPs().println(size);
            }
       }
    }

    private class AllHandler extends Handler {
        private long accum = 0L;
        AllHandler(PrintStream ps) {
            super(ps);
        }
        protected long getAccum() {
            return accum;
        }
        protected synchronized void handle(Resource r) {
            long size = r.getSize();
            if (size == Resource.UNKNOWN_SIZE) {
                log(""Size unknown for "" + r.toString(), Project.MSG_WARN);
            } else {
                accum += size;
            }
        }
        void complete() {
            getPs().print(accum);
            super.complete();
        }
    }

    private class ConditionHandler extends AllHandler {
        ConditionHandler() {
            super(null);
        }
        void complete() {
        }
        long getLength() {
            return getAccum();
        }
    }
}
"
org.apache.tools.ant.types.selectors.SelectSelector,13,5,0,9,34,68,6,4,12,0.75,199,1.0,0,0.837837838,0.292307692,2,8,14.15384615,5,2.1538,0,"

package org.apache.tools.ant.types.selectors;

import java.util.Enumeration;
import java.io.File;

import org.apache.tools.ant.Project;


public class SelectSelector extends BaseSelectorContainer {

    private String ifProperty;
    private String unlessProperty;

    
    public SelectSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (hasSelectors()) {
            buf.append(""{select"");
            if (ifProperty != null) {
                buf.append("" if: "");
                buf.append(ifProperty);
            }
            if (unlessProperty != null) {
                buf.append("" unless: "");
                buf.append(unlessProperty);
            }
            buf.append("" "");
            buf.append(super.toString());
            buf.append(""}"");
        }
        return buf.toString();
    }

    
    private SelectSelector getRef() {
        Object o = getCheckedRef(this.getClass(), ""SelectSelector"");
        return (SelectSelector) o;
    }

    
    public boolean hasSelectors() {
        if (isReference()) {
            return getRef().hasSelectors();
        }
        return super.hasSelectors();
    }

    
    public int selectorCount() {
        if (isReference()) {
            return getRef().selectorCount();
        }
        return super.selectorCount();
    }

    
    public FileSelector[] getSelectors(Project p) {
        if (isReference()) {
            return getRef().getSelectors(p);
        }
        return super.getSelectors(p);
    }

    
    public Enumeration selectorElements() {
        if (isReference()) {
            return getRef().selectorElements();
        }
        return super.selectorElements();
    }

    
    public void appendSelector(FileSelector selector) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        super.appendSelector(selector);
    }


    
    public void verifySettings() {
        int cnt = selectorCount();
        if (cnt < 0 || cnt > 1) {
            setError(""Only one selector is allowed within the ""
                + ""<selector> tag"");
        }
    }

    
    public boolean passesConditions() {
        if (ifProperty != null
            && getProject().getProperty(ifProperty) == null) {
            return false;
        } else if (unlessProperty != null
            && getProject().getProperty(unlessProperty) != null) {
            return false;
        }
        return true;
    }

    
    public void setIf(String ifProperty) {
        this.ifProperty = ifProperty;
    }

    
    public void setUnless(String unlessProperty) {
        this.unlessProperty = unlessProperty;
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        validate();

        
        if (!(passesConditions())) {
            return false;
        }

        Enumeration e = selectorElements();
        if (!(e.hasMoreElements())) {
            return true;
        }
        FileSelector f = (FileSelector) e.nextElement();
        return f.isSelected(basedir, filename, file);
    }
}

"
org.apache.tools.ant.listener.AnsiColorLogger,3,2,0,1,17,0,0,1,1,0.96875,251,1.0,0,0.888888889,0.5,1,3,77.33333333,11,5.3333,0,"
package org.apache.tools.ant.listener;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Properties;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;


public final class AnsiColorLogger extends DefaultLogger {
    
    
    private static final int ATTR_DIM = 2;
    
    
    
    

    
    private static final int FG_RED = 31;
    private static final int FG_GREEN = 32;
    
    private static final int FG_BLUE = 34;
    private static final int FG_MAGENTA = 35;
    private static final int FG_CYAN = 36;
    

    
    
    
    
    
    
    
    

    private static final String PREFIX = ""\u001b["";
    private static final String SUFFIX = ""m"";
    private static final char SEPARATOR = ';';
    private static final String END_COLOR = PREFIX + SUFFIX;

    private String errColor
        = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX;
    private String warnColor
        = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX;
    private String infoColor
        = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX;
    private String verboseColor
        = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX;
    private String debugColor
        = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX;

    private boolean colorsSet = false;

    
    private void setColors() {
        String userColorFile = System.getProperty(""ant.logger.defaults"");
        String systemColorFile =
            ""/org/apache/tools/ant/listener/defaults.properties"";

        InputStream in = null;

        try {
            Properties prop = new Properties();

            if (userColorFile != null) {
                in = new FileInputStream(userColorFile);
            } else {
                in = getClass().getResourceAsStream(systemColorFile);
            }

            if (in != null) {
                prop.load(in);
            }

            String errC = prop.getProperty(""AnsiColorLogger.ERROR_COLOR"");
            String warn = prop.getProperty(""AnsiColorLogger.WARNING_COLOR"");
            String info = prop.getProperty(""AnsiColorLogger.INFO_COLOR"");
            String verbose = prop.getProperty(""AnsiColorLogger.VERBOSE_COLOR"");
            String debug = prop.getProperty(""AnsiColorLogger.DEBUG_COLOR"");
            if (errC != null) {
                errColor = PREFIX + errC + SUFFIX;
            }
            if (warn != null) {
                warnColor = PREFIX + warn + SUFFIX;
            }
            if (info != null) {
                infoColor = PREFIX + info + SUFFIX;
            }
            if (verbose != null) {
                verboseColor = PREFIX + verbose + SUFFIX;
            }
            if (debug != null) {
                debugColor = PREFIX + debug + SUFFIX;
            }
        } catch (IOException ioe) {
            
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }

    
    
    protected void printMessage(final String message,
                                      final PrintStream stream,
                                      final int priority) {
        if (message != null && stream != null) {
            if (!colorsSet) {
                setColors();
                colorsSet = true;
            }

            final StringBuffer msg = new StringBuffer(message);
            switch (priority) {
                case Project.MSG_ERR:
                    msg.insert(0, errColor);
                    msg.append(END_COLOR);
                    break;
                case Project.MSG_WARN:
                    msg.insert(0, warnColor);
                    msg.append(END_COLOR);
                    break;
                case Project.MSG_INFO:
                    msg.insert(0, infoColor);
                    msg.append(END_COLOR);
                    break;
                case Project.MSG_VERBOSE:
                    msg.insert(0, verboseColor);
                    msg.append(END_COLOR);
                    break;
                case Project.MSG_DEBUG:
                    
                default:
                    msg.insert(0, debugColor);
                    msg.append(END_COLOR);
                    break;
            }
            final String strmessage = msg.toString();
            stream.println(strmessage);
        }
    }
}
"
org.apache.tools.ant.types.Quantifier,6,2,0,9,16,11,1,8,5,0.95,195,0.583333333,11,0.727272727,0.4,1,1,29.5,3,1.0,0,"
package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;


public class Quantifier extends EnumeratedAttribute {
    private static final String[] VALUES
        = new String[] {""all"", ""each"", ""every"", ""any"", ""some"", ""one"",
                        ""majority"", ""most"", ""none""};

    
    public static final Quantifier ALL = new Quantifier(""all"");
    
    public static final Quantifier ANY = new Quantifier(""any"");
    
    public static final Quantifier ONE = new Quantifier(""one"");
    
    public static final Quantifier MAJORITY = new Quantifier(""majority"");
    
    public static final Quantifier NONE = new Quantifier(""none"");

    private abstract static class Predicate {
        abstract boolean eval(int t, int f);
    }

    private static final Predicate ALL_PRED = new Predicate() {
        boolean eval(int t, int f) { return f == 0; }
    };

    private static final Predicate ANY_PRED = new Predicate() {
        boolean eval(int t, int f) { return t > 0; }
    };

    private static final Predicate ONE_PRED = new Predicate() {
        boolean eval(int t, int f) { return t == 1; }
    };

    private static final Predicate MAJORITY_PRED = new Predicate() {
        boolean eval(int t, int f) { return t > f; }
    };

    private static final Predicate NONE_PRED = new Predicate() {
        boolean eval(int t, int f) { return t == 0; }
    };

    private static final Predicate[] PREDS = new Predicate[VALUES.length];

    static {
        PREDS[0] = ALL_PRED;
        PREDS[1] = ALL_PRED;
        PREDS[2] = ALL_PRED;
        PREDS[3] = ANY_PRED;
        PREDS[4] = ANY_PRED;
        PREDS[5] = ONE_PRED;
        PREDS[6] = MAJORITY_PRED;
        PREDS[7] = MAJORITY_PRED;
        PREDS[8] = NONE_PRED;
    }

    
    public Quantifier() {
    }

    
    public Quantifier(String value) {
        setValue(value);
    }

    
    public String[] getValues() {
        return VALUES;
    }

    
    public boolean evaluate(boolean[] b) {
        int t = 0;
        for (int i = 0; i < b.length; i++) {
            if (b[i]) {
                t++;
            }
        }
        return evaluate(t, b.length - t);
    }

    
    public boolean evaluate(int t, int f) {
        int index = getIndex();
        if (index == -1) {
            throw new BuildException(""Quantifier value not set."");
        }
        return PREDS[index].eval(t, f);
    }

}

"
org.apache.tools.ant.taskdefs.optional.clearcase.ClearCase,13,3,13,24,45,46,13,11,9,1.020833333,189,0.3,0,0.770833333,0.375,0,0,12.0,3,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.ExecTask;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.util.FileUtils;




public abstract class ClearCase extends Task {
    private String mClearToolDir = """";
    private String mviewPath = null;
    private String mobjSelect = null;
    private static int pcnt = 0;
    private boolean mFailonerr = true;
    
    public final void setClearToolDir(String dir) {
        mClearToolDir = FileUtils.translatePath(dir);
    }

    
    protected final String getClearToolCommand() {
        String toReturn = mClearToolDir;
        if (!toReturn.equals("""") && !toReturn.endsWith(""/"")) {
            toReturn += ""/"";
        }

        toReturn += CLEARTOOL_EXE;

        return toReturn;
    }

    
    public final void setViewPath(String viewPath) {
        mviewPath = viewPath;
    }

    
    public String getViewPath() {
        return mviewPath;
    }

    
    public String getViewPathBasename() {
        return (new File(mviewPath)).getName();
    }

    
    public final void setObjSelect(String objSelect) {
        mobjSelect = objSelect;
    }

    
    public String getObjSelect() {
        return mobjSelect;
    }

    
    protected int run(Commandline cmd) {
        try {
            Project aProj = getProject();
            Execute exe
                = new Execute(new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
            exe.setAntRun(aProj);
            exe.setWorkingDirectory(aProj.getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            return exe.execute();
        } catch (java.io.IOException e) {
            throw new BuildException(e, getLocation());
        }
    }

    
    protected String runS(Commandline cmdline) {
        String   outV  = ""opts.cc.runS.output"" + pcnt++;
        ExecTask exe   = new ExecTask(this);
        Commandline.Argument arg = exe.createArg();

        exe.setExecutable(cmdline.getExecutable());
        arg.setLine(Commandline.toString(cmdline.getArguments()));
        exe.setOutputproperty(outV);
        exe.execute();

        return getProject().getProperty(outV);
    }
    
    public void setFailOnErr(boolean failonerr) {
        mFailonerr = failonerr;
    }

    
    public boolean getFailOnErr() {
        return mFailonerr;
    }

    
    private static final String CLEARTOOL_EXE = ""cleartool"";
    
    public static final String COMMAND_UPDATE = ""update"";
    
    public static final String COMMAND_CHECKOUT = ""checkout"";
    
    public static final String COMMAND_CHECKIN = ""checkin"";
    
    public static final String COMMAND_UNCHECKOUT = ""uncheckout"";
    
    public static final String COMMAND_LOCK = ""lock"";
    
    public static final String COMMAND_UNLOCK = ""unlock"";
    
    public static final String COMMAND_MKBL = ""mkbl"";
    
    public static final String COMMAND_MKLABEL = ""mklabel"";
    
    public static final String COMMAND_MKLBTYPE = ""mklbtype"";
    
    public static final String COMMAND_RMTYPE = ""rmtype"";
    
    public static final String COMMAND_LSCO = ""lsco"";
    
    public static final String COMMAND_MKELEM = ""mkelem"";
    
    public static final String COMMAND_MKATTR = ""mkattr"";
    
    public static final String COMMAND_MKDIR = ""mkdir"";

}

"
org.apache.tools.ant.taskdefs.optional.clearcase.CCUnlock,13,4,0,7,37,66,0,7,9,0.875,184,0.5,0,0.8,0.512820513,2,3,12.84615385,4,1.3846,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;




public class CCUnlock extends ClearCase {
    private String mComment = null;
    private String mPname = null;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_UNLOCK);

        
        checkOptions(commandLine);

        
        

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getOpType(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }

    
    private void checkOptions(Commandline cmd) {
        
        getCommentCommand(cmd);

        if (getObjSelect() == null && getPname() == null) {
            throw new BuildException(""Should select either an element ""
            + ""(pname) or an object (objselect)"");
        }
        getPnameCommand(cmd);
        
        if (getObjSelect() != null) {
            cmd.createArgument().setValue(getObjSelect());
        }
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setPname(String pname) {
        mPname = pname;
    }

    
    public String getPname() {
        return mPname;
    }

    
    public void setObjselect(String objselect) {
        setObjSelect(objselect);
    }

    
    public void setObjSel(String objsel) {
        setObjSelect(objsel);
    }

    
    public String getObjselect() {
        return getObjSelect();
    }

    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() == null) {
            return;
        } else {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getPnameCommand(Commandline cmd) {
        if (getPname() == null) {
            return;
        } else {
            
            cmd.createArgument().setValue(FLAG_PNAME);
            cmd.createArgument().setValue(getPname());
        }
    }

    
    private String getOpType() {

        if (getPname() != null) {
            return getPname();
        } else {
            return getObjSelect();
        }
    }

    
    public static final String FLAG_COMMENT = ""-comment"";
    
    public static final String FLAG_PNAME = ""-pname"";
}

"
org.apache.tools.ant.taskdefs.ResourceCount,8,3,0,7,25,12,0,7,8,0.880952381,133,1.0,2,0.840909091,0.270833333,1,1,14.875,3,1.625,0,"
package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.Comparison;
import org.apache.tools.ant.types.ResourceCollection;


public class ResourceCount extends Task implements Condition {

    private static final String ONE_NESTED_MESSAGE
        = ""ResourceCount can count resources from exactly one nested ResourceCollection."";

    private static final String COUNT_REQUIRED
        = ""Use of the ResourceCount condition requires that the count attribute be set."";

    private ResourceCollection rc;
    private Comparison when = Comparison.EQUAL;
    private Integer count;
    private String property;

    
    public void add(ResourceCollection r) {
        if (rc != null) {
            throw new BuildException(ONE_NESTED_MESSAGE);
        }
        rc = r;
    }

    
    public void setRefid(Reference r) {
        Object o = r.getReferencedObject();
        if (!(o instanceof ResourceCollection)) {
            throw new BuildException(r.getRefId()
                + "" doesn\'t denote a ResourceCollection"");
        }
        add((ResourceCollection) o);
    }

    
    public void execute() {
        if (rc == null) {
            throw new BuildException(ONE_NESTED_MESSAGE);
        }
        if (property == null) {
            log(""resource count = "" + rc.size());
        } else {
            getProject().setNewProperty(property, Integer.toString(rc.size()));
        }
    }

    
    public boolean eval() {
        if (rc == null) {
            throw new BuildException(ONE_NESTED_MESSAGE);
        }
        if (count == null) {
            throw new BuildException(COUNT_REQUIRED);
        }
        return when.evaluate(new Integer(rc.size()).compareTo(count));
    }

    
    public void setCount(int c) {
        count = new Integer(c);
    }

    
    public void setWhen(Comparison c) {
        when = c;
    }

    
    public void setProperty(String p) {
        property = p;
    }

}
"
org.apache.tools.ant.taskdefs.Concat,29,3,0,25,109,268,1,25,20,0.851190476,879,1.0,6,0.578125,0.125,1,1,28.68965517,29,3.0,4,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.Reader;
import java.io.Writer;
import java.io.FileReader;
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.io.StringReader;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Vector;
import java.util.Iterator;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.filters.util.ChainReaderHelper;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FileList;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.Restrict;
import org.apache.tools.ant.types.resources.Resources;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.StringResource;
import org.apache.tools.ant.types.resources.selectors.Not;
import org.apache.tools.ant.types.resources.selectors.Exists;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.ConcatResourceInputStream;


public class Concat extends Task {

    
    private static final int BUFFER_SIZE = 8192;

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private static final ResourceSelector EXISTS = new Exists();
    private static final ResourceSelector NOT_EXISTS = new Not(EXISTS);

    

    
    private File destinationFile;

    
    private boolean append;

    
    private String encoding;

    
    private String outputEncoding;

    
    private boolean binary;

    

    
    private StringBuffer textBuffer;

    
    private Resources rc;

    
    private Vector filterChains;
    
    private boolean forceOverwrite = true;
    
    private TextElement footer;
    
    private TextElement header;
    
    private boolean fixLastLine = false;
    
    private String eolString;
    
    private Writer outputWriter = null;

    
    public Concat() {
        reset();
    }

    
    public void reset() {
        append = false;
        forceOverwrite = true;
        destinationFile = null;
        encoding = null;
        outputEncoding = null;
        fixLastLine = false;
        filterChains = null;
        footer = null;
        header = null;
        binary = false;
        outputWriter = null;
        textBuffer = null;
        eolString = System.getProperty(""line.separator"");
        rc = null;
    }

    

    
    public void setDestfile(File destinationFile) {
        this.destinationFile = destinationFile;
    }

    
    public void setAppend(boolean append) {
        this.append = append;
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
        if (outputEncoding == null) {
            outputEncoding = encoding;
        }
    }

    
    public void setOutputEncoding(String outputEncoding) {
        this.outputEncoding = outputEncoding;
    }

    
    public void setForce(boolean force) {
        this.forceOverwrite = force;
    }

    

    
     public Path createPath() {
        Path path = new Path(getProject());
        add(path);
        return path;
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void addFilelist(FileList list) {
        add(list);
    }

    
    public void add(ResourceCollection c) {
        rc = rc == null ? new Resources() : rc;
        rc.add(c);
    }

    
    public void addFilterChain(FilterChain filterChain) {
        if (filterChains == null) {
            filterChains = new Vector();
        }
        filterChains.addElement(filterChain);
    }

    
    public void addText(String text) {
        if (textBuffer == null) {
            
            
            textBuffer = new StringBuffer(text.length());
        }

        
        
        textBuffer.append(text);
    }

    
    public void addHeader(TextElement headerToAdd) {
        this.header = headerToAdd;
    }

    
    public void addFooter(TextElement footerToAdd) {
        this.footer = footerToAdd;
    }

    
    public void setFixLastLine(boolean fixLastLine) {
        this.fixLastLine = fixLastLine;
    }

    
    public void setEol(FixCRLF.CrLf crlf) {
        String s = crlf.getValue();
        if (s.equals(""cr"") || s.equals(""mac"")) {
            eolString = ""\r"";
        } else if (s.equals(""lf"") || s.equals(""unix"")) {
            eolString = ""\n"";
        } else if (s.equals(""crlf"") || s.equals(""dos"")) {
            eolString = ""\r\n"";
        }
    }

    
    public void setWriter(Writer outputWriter) {
        this.outputWriter = outputWriter;
    }

    
    public void setBinary(boolean binary) {
        this.binary = binary;
    }

    
    private ResourceCollection validate() {

        
        sanitizeText();

        
        if (binary) {
            if (destinationFile == null) {
                throw new BuildException(
                    ""destfile attribute is required for binary concatenation"");
            }
            if (textBuffer != null) {
                throw new BuildException(
                    ""Nested text is incompatible with binary concatenation"");
            }
            if (encoding != null || outputEncoding != null) {
                throw new BuildException(
                    ""Seting input or output encoding is incompatible with binary""
                    + "" concatenation"");
            }
            if (filterChains != null) {
                throw new BuildException(
                    ""Setting filters is incompatible with binary concatenation"");
            }
            if (fixLastLine) {
                throw new BuildException(
                    ""Setting fixlastline is incompatible with binary concatenation"");
            }
            if (header != null || footer != null) {
                throw new BuildException(
                    ""Nested header or footer is incompatible with binary concatenation"");
            }
        }
        if (destinationFile != null && outputWriter != null) {
            throw new BuildException(
                ""Cannot specify both a destination file and an output writer"");
        }
        
        if (rc == null && textBuffer == null) {
            
            throw new BuildException(
                ""At least one resource must be provided, or some text."");
        }
        if (rc != null) {
            
            
            
            if (textBuffer != null) {
                throw new BuildException(
                    ""Cannot include inline text when using resources."");
            }
            Restrict noexistRc = new Restrict();
            noexistRc.add(NOT_EXISTS);
            noexistRc.add(rc);
            for (Iterator i = noexistRc.iterator(); i.hasNext();) {
                log(i.next() + "" does not exist."", Project.MSG_ERR);
            }
            if (destinationFile != null) {
                for (Iterator i = rc.iterator(); i.hasNext();) {
                    Object o = i.next();
                    if (o instanceof FileResource) {
                        File f = ((FileResource) o).getFile();
                        if (FILE_UTILS.fileNameEquals(f, destinationFile)) {
                            throw new BuildException(""Input file \""""
                                + f + ""\"" is the same as the output file."");
                        }
                    }
                }
            }
            Restrict existRc = new Restrict();
            existRc.add(EXISTS);
            existRc.add(rc);
            boolean outofdate = destinationFile == null || forceOverwrite;
            if (!outofdate) {
                for (Iterator i = existRc.iterator(); !outofdate && i.hasNext();) {
                    Resource r = (Resource) i.next();
                    outofdate =
                        (r.getLastModified() == 0L
                         || r.getLastModified() > destinationFile.lastModified());
                }
            }
            if (!outofdate) {
                log(destinationFile + "" is up-to-date."", Project.MSG_VERBOSE);
                return null; 
            }
            return existRc;
        } else {
            StringResource s = new StringResource();
            s.setProject(getProject());
            s.setValue(textBuffer.toString());
            return s;
        }
    }

    
    public void execute() {
        ResourceCollection c = validate();
        if (c == null) {
            return;
        }
        
        if (c.size() < 1 && header == null && footer == null) {
            log(""No existing resources and no nested text, doing nothing"",
                Project.MSG_INFO);
            return;
        }
        if (binary) {
            binaryCat(c);
        } else {
            cat(c);
        }
    }

    
    private void binaryCat(ResourceCollection c) {
        log(""Binary concatenation of "" + c.size()
            + "" resources to "" + destinationFile);
        FileOutputStream out = null;
        InputStream in = null;
        try {
            try {
                out = new FileOutputStream(destinationFile);
            } catch (Exception t) {
                throw new BuildException(""Unable to open ""
                    + destinationFile + "" for writing"", t);
            }
            in = new ConcatResourceInputStream(c);
            ((ConcatResourceInputStream) in).setManagingComponent(this);
            Thread t = new Thread(new StreamPumper(in, out));
            t.start();
            try {
                t.join();
            } catch (InterruptedException e) {
                try {
                    t.join();
                } catch (InterruptedException ee) {
                    
                }
            }
        } finally {
            FileUtils.close(in);
            if (out != null) {
                try {
                    out.close();
                } catch (Exception ex) {
                    throw new BuildException(
                        ""Unable to close "" + destinationFile, ex);
                }
            }
        }
    }

    
    private void cat(ResourceCollection c) {
        OutputStream os = null;
        char[] buffer = new char[BUFFER_SIZE];

        try {
            PrintWriter writer = null;

            if (outputWriter != null) {
                writer = new PrintWriter(outputWriter);
            } else {
                if (destinationFile == null) {
                    
                    os = new LogOutputStream(this, Project.MSG_WARN);
                } else {
                    
                    File parent = destinationFile.getParentFile();
                    if (!parent.exists()) {
                        parent.mkdirs();
                    }
                    os = new FileOutputStream(destinationFile.getAbsolutePath(),
                                              append);
                }
                if (outputEncoding == null) {
                    writer = new PrintWriter(
                        new BufferedWriter(
                            new OutputStreamWriter(os)));
                } else {
                    writer = new PrintWriter(
                        new BufferedWriter(
                            new OutputStreamWriter(os, outputEncoding)));
                }
            }
            if (header != null) {
                if (header.getFiltering()) {
                    concatenate(
                        buffer, writer, new StringReader(header.getValue()));
                } else {
                    writer.print(header.getValue());
                }
            }
            if (c.size() > 0) {
                concatenate(buffer, writer, new MultiReader(c));
            }
            if (footer != null) {
                if (footer.getFiltering()) {
                    concatenate(
                        buffer, writer, new StringReader(footer.getValue()));
                } else {
                    writer.print(footer.getValue());
                }
            }
            writer.flush();
            if (os != null) {
                os.flush();
            }
        } catch (IOException ioex) {
            throw new BuildException(""Error while concatenating: ""
                                     + ioex.getMessage(), ioex);
        } finally {
            FileUtils.close(os);
        }
    }

    
    private void concatenate(char[] buffer, Writer writer, Reader in)
        throws IOException {
        if (filterChains != null) {
            ChainReaderHelper helper = new ChainReaderHelper();
            helper.setBufferSize(BUFFER_SIZE);
            helper.setPrimaryReader(in);
            helper.setFilterChains(filterChains);
            helper.setProject(getProject());
            in = new BufferedReader(helper.getAssembledReader());
        }
        while (true) {
            int nRead = in.read(buffer, 0, buffer.length);
            if (nRead == -1) {
                break;
            }
            writer.write(buffer, 0, nRead);
        }
        writer.flush();
    }

    
    private void sanitizeText() {
        if (textBuffer != null) {
            if (textBuffer.substring(0).trim().length() == 0) {
                textBuffer = null;
            }
        }
    }

    
    public static class TextElement extends ProjectComponent {
        private String   value = """";
        private boolean  trimLeading = false;
        private boolean  trim = false;
        private boolean  filtering = true;
        private String   encoding = null;

        
        public void setFiltering(boolean filtering) {
            this.filtering = filtering;
        }

        
        private boolean getFiltering() {
            return filtering;
        }

        
        public void setEncoding(String encoding) {
            this.encoding = encoding;
        }

        
        public void setFile(File file) throws BuildException {
            
            if (!file.exists()) {
                throw new BuildException(""File "" + file + "" does not exist."");
            }

            BufferedReader reader = null;
            try {
                if (this.encoding == null) {
                    reader = new BufferedReader(new FileReader(file));
                } else {
                    reader = new BufferedReader(
                        new InputStreamReader(new FileInputStream(file),
                                              this.encoding));
                }
                value = FileUtils.readFully(reader);
            } catch (IOException ex) {
                throw new BuildException(ex);
            } finally {
                FileUtils.close(reader);
            }
        }

        
        public void addText(String value) {
            this.value += getProject().replaceProperties(value);
        }

        
        public void setTrimLeading(boolean strip) {
            this.trimLeading = strip;
        }

        
        public void setTrim(boolean trim) {
            this.trim = trim;
        }

        
        public String getValue() {
            if (value == null) {
                value = """";
            }
            if (value.trim().length() == 0) {
                value = """";
            }
            if (trimLeading) {
                char[] current = value.toCharArray();
                StringBuffer b = new StringBuffer(current.length);
                boolean startOfLine = true;
                int pos = 0;
                while (pos < current.length) {
                    char ch = current[pos++];
                    if (startOfLine) {
                        if (ch == ' ' || ch == '\t') {
                            continue;
                        }
                        startOfLine = false;
                    }
                    b.append(ch);
                    if (ch == '\n' || ch == '\r') {
                        startOfLine = true;
                    }
                }
                value = b.toString();
            }
            if (trim) {
                value = value.trim();
            }
            return value;
        }
    }

    
    private class MultiReader extends Reader {
        private Reader reader = null;
        private int    lastPos = 0;
        private char[] lastChars = new char[eolString.length()];
        private boolean needAddSeparator = false;
        private Iterator i;

        private MultiReader(ResourceCollection c) {
            i = c.iterator();
        }

        private Reader getReader() throws IOException {
            if (reader == null && i.hasNext()) {
                Resource r = (Resource) i.next();
                log(""Concating "" + r.toLongString(), Project.MSG_VERBOSE);
                InputStream is = r.getInputStream();
                reader = new BufferedReader(encoding == null
                    ? new InputStreamReader(is)
                    : new InputStreamReader(is, encoding));
                Arrays.fill(lastChars, (char) 0);
            }
            return reader;
        }

        private void nextReader() throws IOException {
            close();
            reader = null;
        }

        
        public int read() throws IOException {
            if (needAddSeparator) {
                int ret = eolString.charAt(lastPos++);
                if (lastPos >= eolString.length()) {
                    lastPos = 0;
                    needAddSeparator = false;
                }
                return ret;
            }
            while (getReader() != null) {
                int ch = getReader().read();
                if (ch == -1) {
                    nextReader();
                    if (fixLastLine && isMissingEndOfLine()) {
                        needAddSeparator = true;
                        lastPos = 0;
                    }
                } else {
                    addLastChar((char) ch);
                    return ch;
                }
            }
            return -1;
        }

        
        public int read(char[] cbuf, int off, int len)
            throws IOException {

            int amountRead = 0;
            while (getReader() != null || needAddSeparator) {
                if (needAddSeparator) {
                    cbuf[off] = eolString.charAt(lastPos++);
                    if (lastPos >= eolString.length()) {
                        lastPos = 0;
                        needAddSeparator = false;
                    }
                    len--;
                    off++;
                    amountRead++;
                    if (len == 0) {
                        return amountRead;
                    }
                    continue;
                }
                int nRead = getReader().read(cbuf, off, len);
                if (nRead == -1 || nRead == 0) {
                    nextReader();
                    if (fixLastLine && isMissingEndOfLine()) {
                        needAddSeparator = true;
                        lastPos = 0;
                    }
                } else {
                    if (fixLastLine) {
                        for (int i = nRead;
                                 i > (nRead - lastChars.length);
                                 --i) {
                            if (i <= 0) {
                                break;
                            }
                            addLastChar(cbuf[off + i - 1]);
                        }
                    }
                    len -= nRead;
                    off += nRead;
                    amountRead += nRead;
                    if (len == 0) {
                        return amountRead;
                    }
                }
            }
            if (amountRead == 0) {
                return -1;
            } else {
                return amountRead;
            }
        }

        
        public void close() throws IOException {
            if (reader != null) {
                reader.close();
            }
        }

        
        private void addLastChar(char ch) {
            for (int i = lastChars.length - 2; i >= 0; --i) {
                lastChars[i] = lastChars[i + 1];
            }
            lastChars[lastChars.length - 1] = ch;
        }

        
        private boolean isMissingEndOfLine() {
            for (int i = 0; i < lastChars.length; ++i) {
                if (lastChars[i] != eolString.charAt(i)) {
                    return true;
                }
            }
            return false;
        }
    }

}

"
org.apache.tools.ant.util.ScriptRunnerCreator,3,1,0,6,17,0,1,5,2,1.142857143,156,1.0,1,0.0,0.583333333,0,0,46.33333333,9,4.3333,0,"
package org.apache.tools.ant.util;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class ScriptRunnerCreator {
    private static final String AUTO = ""auto"";
    private static final String OATAU = ""org.apache.tools.ant.util"";
    private static final String UTIL_OPT = OATAU + "".optional"";

    private static final String BSF = ""bsf"";
    private static final String BSF_PACK = ""org.apache.bsf"";
    private static final String BSF_MANAGER = BSF_PACK + "".BSFManager"";
    private static final String BSF_RUNNER = UTIL_OPT + "".ScriptRunner"";

    private static final String JAVAX = ""javax"";
    private static final String JAVAX_MANAGER = ""javax.script.ScriptEngineManager"";
    private static final String JAVAX_RUNNER = UTIL_OPT + "".JavaxScriptRunner"";

    private Project     project;
    private String      manager;
    private String      language;
    private ClassLoader scriptLoader = null;

    
    public ScriptRunnerCreator(Project project) {
        this.project = project;
    }

    
    public ScriptRunnerBase createRunner(
        String manager, String language, ClassLoader classLoader) {
        this.manager      = manager;
        this.language     = language;
        this.scriptLoader = classLoader;

        if (language == null) {
            throw new BuildException(""script language must be specified"");
        }
        if (!manager.equals(AUTO) && !manager.equals(JAVAX) && !manager.equals(BSF)) {
                throw new BuildException(
                    ""Unsupported language prefix "" + manager);
        }

        
        
        

        ScriptRunnerBase ret = null;
        ret = createRunner(BSF, BSF_MANAGER, BSF_RUNNER);
        if (ret == null) {
            ret = createRunner(JAVAX, JAVAX_MANAGER, JAVAX_RUNNER);
        }
        if (ret != null) {
            return ret;
        }
        if (JAVAX.equals(manager)) {
            throw new BuildException(
                ""Unable to load the script engine manager ""
                + ""("" + JAVAX_MANAGER + "")"");
        } else if (BSF.equals(manager)) {
            throw new BuildException(
                ""Unable to load the BSF script engine manager ""
                + ""("" + BSF_MANAGER + "")"");
        } else {
            throw new BuildException(
                ""Unable to load a script engine manager ""
                + ""("" + BSF_MANAGER + "" or "" + JAVAX_MANAGER + "")"");
        }
    }

    
    private ScriptRunnerBase createRunner(
        String checkManager, String managerClass, String runnerClass) {
        ScriptRunnerBase runner = null;
        if (!manager.equals(AUTO) && !manager.equals(checkManager)) {
            return null;
        }
        if (scriptLoader.getResource(
                LoaderUtils.classNameToResource(managerClass)) == null) {
            return null;
        }
        try {
            runner = (ScriptRunnerBase) Class.forName(
                runnerClass, true, scriptLoader).newInstance();
            runner.setProject(project);
        } catch (Exception ex) {
            ReflectUtil.throwBuildException(ex);
            
        }

        runner.setLanguage(language);
        runner.setScriptClassLoader(scriptLoader);
        return runner;
    }
}
"
org.apache.tools.ant.types.resources.comparators.Content,4,4,0,4,7,0,0,4,3,0.0,34,1.0,0,0.918918919,0.5,1,1,7.25,2,1.0,0,"
package org.apache.tools.ant.types.resources.comparators;

import java.io.IOException;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.util.ResourceUtils;


public class Content extends ResourceComparator {

    private boolean binary = true;

    
    public void setBinary(boolean b) {
        binary = b;
    }

    
    public boolean isBinary() {
        return binary;
    }

    
    protected int resourceCompare(Resource foo, Resource bar) {
        try {
            return ResourceUtils.compareContent(foo, bar, !binary);
        } catch (IOException e) {
            throw new BuildException(e);
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.ssh.SSHUserInfo,20,1,0,5,21,130,3,2,20,0.852631579,125,1.0,0,0.0,0.36,0,0,5.0,4,1.05,0,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import com.jcraft.jsch.UserInfo;
import com.jcraft.jsch.UIKeyboardInteractive;


public class SSHUserInfo implements UserInfo, UIKeyboardInteractive {

    private String name;
    private String password = null;
    private String keyfile;
    private String passphrase = null;
    private boolean trustAllCertificates;

    
    public SSHUserInfo() {
        super();
        this.trustAllCertificates = false;
    }

    
    public SSHUserInfo(String password, boolean trustAllCertificates) {
        super();
        this.password = password;
        this.trustAllCertificates = trustAllCertificates;
    }

    
    public String getName() {
        return name;
    }

    
    public String getPassphrase(String message) {
        return passphrase;
    }

    
    public String getPassword() {
        return password;
    }

    
    public boolean prompt(String str) {
        return false;
    }

    
    public boolean retry() {
        return false;
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public void setPassphrase(String passphrase) {
        this.passphrase = passphrase;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

    
    public void setTrust(boolean trust) {
        this.trustAllCertificates = trust;
    }

    
    public boolean getTrust() {
        return this.trustAllCertificates;
    }

    
    public String getPassphrase() {
        return passphrase;
    }

    
    public String getKeyfile() {
        return keyfile;
    }

    
    public void setKeyfile(String keyfile) {
        this.keyfile = keyfile;
    }

    
    public boolean promptPassphrase(String message) {
        return true;
    }

    
    public boolean promptPassword(String passwordPrompt) {
        return true;
    }

    
    public boolean promptYesNo(String message) {
        return trustAllCertificates;
    }


    
    public void showMessage(String message) {
        
    }

    
    public String[] promptKeyboardInteractive(String destination,
                                              String name,
                                              String instruction,
                                              String[] prompt,
                                              boolean[] echo) {
        if (prompt.length != 1 || echo[0] || this.password == null) {
            return null;
        }
        String[] response = new String[1];
        response[0] = this.password;
        return response;
    }

}
"
org.apache.tools.ant.util.JavaEnvUtils,16,1,0,29,40,72,27,2,11,0.929166667,463,0.5625,1,0.0,0.177777778,0,0,26.9375,5,1.9375,0,"
package org.apache.tools.ant.util;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.util.Vector;
import org.apache.tools.ant.taskdefs.condition.Os;


public final class JavaEnvUtils {

    private JavaEnvUtils() {
    }

    
    private static final boolean IS_DOS = Os.isFamily(""dos"");
    
    private static final boolean IS_NETWARE = Os.isName(""netware"");
    
    private static final boolean IS_AIX = Os.isName(""aix"");

    
    private static final String JAVA_HOME = System.getProperty(""java.home"");

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private static String javaVersion;

    
    private static int javaVersionNumber;

    
    public static final String JAVA_1_0 = ""1.0"";
    
    public static final String JAVA_1_1 = ""1.1"";
    
    public static final String JAVA_1_2 = ""1.2"";
    
    public static final String JAVA_1_3 = ""1.3"";
    
    public static final String JAVA_1_4 = ""1.4"";
    
    public static final String JAVA_1_5 = ""1.5"";
    
    public static final String JAVA_1_6 = ""1.6"";

    
    private static boolean kaffeDetected;

    
    private static Vector jrePackages;


    static {

        
        
        
        
        
        
        

        try {
            javaVersion = JAVA_1_0;
            javaVersionNumber = 10;
            Class.forName(""java.lang.Void"");
            javaVersion = JAVA_1_1;
            javaVersionNumber++;
            Class.forName(""java.lang.ThreadLocal"");
            javaVersion = JAVA_1_2;
            javaVersionNumber++;
            Class.forName(""java.lang.StrictMath"");
            javaVersion = JAVA_1_3;
            javaVersionNumber++;
            Class.forName(""java.lang.CharSequence"");
            javaVersion = JAVA_1_4;
            javaVersionNumber++;
            Class.forName(""java.net.Proxy"");
            javaVersion = JAVA_1_5;
            javaVersionNumber++;
            Class.forName(""java.util.ServiceLoader"");
            javaVersion = JAVA_1_6;
            javaVersionNumber++;
        } catch (Throwable t) {
            
            
        }
        kaffeDetected = false;
        try {
            Class.forName(""kaffe.util.NotImplemented"");
            kaffeDetected = true;
        } catch (Throwable t) {
            
        }
    }

    
    public static String getJavaVersion() {
        return javaVersion;
    }


    
    public static int getJavaVersionNumber() {
        return javaVersionNumber;
    }

    
    public static boolean isJavaVersion(String version) {
        return javaVersion.equals(version);
    }

    
    public static boolean isAtLeastJavaVersion(String version) {
        return javaVersion.compareTo(version) >= 0;
    }

    
    public static boolean isKaffe() {
        return kaffeDetected;
    }

    
    public static String getJreExecutable(String command) {
        if (IS_NETWARE) {
            
            
            
            
            return command;
        }

        File jExecutable = null;

        if (IS_AIX) {
            
            
            jExecutable = findInDir(JAVA_HOME + ""/sh"", command);
        }

        if (jExecutable == null) {
            jExecutable = findInDir(JAVA_HOME + ""/bin"", command);
        }

        if (jExecutable != null) {
            return jExecutable.getAbsolutePath();
        } else {
            
            
            
            return addExtension(command);
        }
    }

    
    public static String getJdkExecutable(String command) {
        if (IS_NETWARE) {
            
            
            
            
            return command;
        }

        File jExecutable = null;

        if (IS_AIX) {
            
            
            jExecutable = findInDir(JAVA_HOME + ""/../sh"", command);
        }

        if (jExecutable == null) {
            jExecutable = findInDir(JAVA_HOME + ""/../bin"", command);
        }

        if (jExecutable != null) {
            return jExecutable.getAbsolutePath();
        } else {
            
            
            
            return getJreExecutable(command);
        }
    }

    
    private static String addExtension(String command) {
        
        
        return command + (IS_DOS ? "".exe"" : """");
    }

    
    private static File findInDir(String dirName, String commandName) {
        File dir = FILE_UTILS.normalize(dirName);
        File executable = null;
        if (dir.exists()) {
            executable = new File(dir, addExtension(commandName));
            if (!executable.exists()) {
                executable = null;
            }
        }
        return executable;
    }

    

    private static void buildJrePackages() {
        jrePackages = new Vector();
        switch(javaVersionNumber) {
            case 16:
            case 15:
                
                jrePackages.addElement(""com.sun.org.apache"");
                
            case 14:
                if (javaVersionNumber == 14) {
                    jrePackages.addElement(""org.apache.crimson"");
                    jrePackages.addElement(""org.apache.xalan"");
                    jrePackages.addElement(""org.apache.xml"");
                    jrePackages.addElement(""org.apache.xpath"");
                }
                jrePackages.addElement(""org.ietf.jgss"");
                jrePackages.addElement(""org.w3c.dom"");
                jrePackages.addElement(""org.xml.sax"");
                
            case 13:
                jrePackages.addElement(""org.omg"");
                jrePackages.addElement(""com.sun.corba"");
                jrePackages.addElement(""com.sun.jndi"");
                jrePackages.addElement(""com.sun.media"");
                jrePackages.addElement(""com.sun.naming"");
                jrePackages.addElement(""com.sun.org.omg"");
                jrePackages.addElement(""com.sun.rmi"");
                jrePackages.addElement(""sunw.io"");
                jrePackages.addElement(""sunw.util"");
                
            case 12:
                jrePackages.addElement(""com.sun.java"");
                jrePackages.addElement(""com.sun.image"");
                
                
            case 11:
            default:
                
                jrePackages.addElement(""sun"");
                jrePackages.addElement(""java"");
                jrePackages.addElement(""javax"");
                break;
        }
    }

    
    public static Vector getJrePackageTestCases() {
        Vector tests = new Vector();
        tests.addElement(""java.lang.Object"");
        switch(javaVersionNumber) {
            case 16:
            case 15:
                tests.addElement(
                    ""com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl "");
                
            case 14:
                tests.addElement(""sun.audio.AudioPlayer"");
                if (javaVersionNumber == 14) {
                    tests.addElement(""org.apache.crimson.parser.ContentModel"");
                    tests.addElement(""org.apache.xalan.processor.ProcessorImport"");
                    tests.addElement(""org.apache.xml.utils.URI"");
                    tests.addElement(""org.apache.xpath.XPathFactory"");
                }
                tests.addElement(""org.ietf.jgss.Oid"");
                tests.addElement(""org.w3c.dom.Attr"");
                tests.addElement(""org.xml.sax.XMLReader"");
                
            case 13:
                tests.addElement(""org.omg.CORBA.Any"");
                tests.addElement(""com.sun.corba.se.internal.corba.AnyImpl"");
                tests.addElement(""com.sun.jndi.ldap.LdapURL"");
                tests.addElement(""com.sun.media.sound.Printer"");
                tests.addElement(""com.sun.naming.internal.VersionHelper"");
                tests.addElement(""com.sun.org.omg.CORBA.Initializer"");
                tests.addElement(""sunw.io.Serializable"");
                tests.addElement(""sunw.util.EventListener"");
                
            case 12:
                tests.addElement(""javax.accessibility.Accessible"");
                tests.addElement(""sun.misc.BASE64Encoder"");
                tests.addElement(""com.sun.image.codec.jpeg.JPEGCodec"");
                
            case 11:
            default:
                
                tests.addElement(""sun.reflect.SerializationConstructorAccessorImpl"");
                tests.addElement(""sun.net.www.http.HttpClient"");
                tests.addElement(""sun.audio.AudioPlayer"");
                break;
        }
        return tests;
    }
    
    public static Vector getJrePackages() {
        if (jrePackages == null) {
            buildJrePackages();
        }
        return jrePackages;
    }

    
    public static File createVmsJavaOptionFile(String[] cmd)
            throws IOException {
        File script = FILE_UTILS.createTempFile(""ANT"", "".JAVA_OPTS"", null);
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(script)));
            for (int i = 0; i < cmd.length; i++) {
                out.println(cmd[i]);
            }
        } finally {
            FileUtils.close(out);
        }
        return script;
    }

    
    public static String getJavaHome() {
        return JAVA_HOME;
    }
}
"
org.apache.tools.ant.util.XmlConstants,1,1,0,0,2,0,0,0,1,2.0,15,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.tools.ant.util;



public class XmlConstants {
    
    public static final String PROPERTY_SCHEMA_LOCATION =
            ""http:
    
    public static final String PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION =
            ""http:
    
    public static final String FEATURE_XSD_FULL_VALIDATION =
            ""http:
    
    public static final String FEATURE_XSD = ""http:

    
    public static final String FEATURE_VALIDATION = ""http:
    
    public static final String FEATURE_NAMESPACES = ""http:
    
    public static final String FEATURE_JAXP12_SCHEMA_LANGUAGE =
            ""http:
    
    public static final String FEATURE_JAXP12_SCHEMA_SOURCE =
            ""http:
    
    public static final String URI_XSD =
            ""http:
    
    public static final String FEATURE_EXTERNAL_ENTITIES =
            ""http:
    
    public static final String FEATURE_DISALLOW_DTD =
            ""http:
}
"
org.apache.tools.ant.taskdefs.Unpack,13,3,2,9,36,62,2,7,8,0.638888889,202,1.0,1,0.755102041,0.307692308,0,0,14.30769231,5,1.5385,1,"

package org.apache.tools.ant.taskdefs;


import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;



public abstract class Unpack extends Task {
    
    protected File source;
    protected File dest;
    protected Resource srcResource;
    

    
    public void setSrc(String src) {
        log(""DEPRECATED - The setSrc(String) method has been deprecated.""
            + "" Use setSrc(File) instead."");
        setSrc(getProject().resolveFile(src));
    }

    
    public void setDest(String dest) {
        log(""DEPRECATED - The setDest(String) method has been deprecated.""
            + "" Use setDest(File) instead."");
        setDest(getProject().resolveFile(dest));
    }

    
    public void setSrc(File src) {
        setSrcResource(new FileResource(src));
    }

    
    public void setSrcResource(Resource src) {
        if (!src.isExists()) {
            throw new BuildException(""the archive doesn't exist"");
        }
        if (src.isDirectory()) {
            throw new BuildException(""the archive can't be a directory"");
        }
        if (src instanceof FileResource) {
            source = ((FileResource) src).getFile();
        } else if (!supportsNonFileResources()) {
            throw new BuildException(""Only FileSystem resources are""
                                     + "" supported."");
        }
        srcResource = src;
    }

    
    public void addConfigured(ResourceCollection a) {
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported as archives"");
        }
        setSrcResource((Resource) a.iterator().next());
    }

    
    public void setDest(File dest) {
        this.dest = dest;
    }

    private void validate() throws BuildException {
        if (srcResource == null) {
            throw new BuildException(""No Src specified"", getLocation());
        }

        if (dest == null) {
            dest = new File(source.getParent());
        }

        if (dest.isDirectory()) {
            String defaultExtension = getDefaultExtension();
            createDestFile(defaultExtension);
        }
    }

    private void createDestFile(String defaultExtension) {
        String sourceName = source.getName();
        int len = sourceName.length();
        if (defaultExtension != null
            && len > defaultExtension.length()
            && defaultExtension.equalsIgnoreCase(
                sourceName.substring(len - defaultExtension.length()))) {
            dest = new File(dest, sourceName.substring(0,
                                                       len - defaultExtension.length()));
        } else {
            dest = new File(dest, sourceName);
        }
    }

    
    public void execute() throws BuildException {
        File savedDest = dest; 
        try {
            validate();
            extract();
        } finally {
            dest = savedDest;
        }
    }

    
    protected abstract String getDefaultExtension();

    
    protected abstract void extract();

    
    protected boolean supportsNonFileResources() {
        return false;
    }

}
"
org.apache.tools.ant.taskdefs.optional.extension.ExtensionResolver,1,1,0,7,1,0,4,3,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public interface ExtensionResolver {
    
    File resolve(Extension extension, Project project)
        throws BuildException;
}
"
org.apache.tools.tar.TarUtils,8,1,0,1,14,28,1,0,8,2.0,271,0.0,0,0.0,0.45,0,0,32.875,7,2.875,0,"



package org.apache.tools.tar;


public class TarUtils {

    
    public static long parseOctal(byte[] header, int offset, int length) {
        long    result = 0;
        boolean stillPadding = true;
        int     end = offset + length;

        for (int i = offset; i < end; ++i) {
            if (header[i] == 0) {
                break;
            }

            if (header[i] == (byte) ' ' || header[i] == '0') {
                if (stillPadding) {
                    continue;
                }

                if (header[i] == (byte) ' ') {
                    break;
                }
            }

            stillPadding = false;
            result = (result << 3) + (header[i] - '0');
        }

        return result;
    }

    
    public static StringBuffer parseName(byte[] header, int offset, int length) {
        StringBuffer result = new StringBuffer(length);
        int          end = offset + length;

        for (int i = offset; i < end; ++i) {
            if (header[i] == 0) {
                break;
            }

            result.append((char) header[i]);
        }

        return result;
    }

    
    public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {
        int i;

        for (i = 0; i < length && i < name.length(); ++i) {
            buf[offset + i] = (byte) name.charAt(i);
        }

        for (; i < length; ++i) {
            buf[offset + i] = 0;
        }

        return offset + length;
    }

    
    public static int getOctalBytes(long value, byte[] buf, int offset, int length) {
        int    idx = length - 1;

        buf[offset + idx] = 0;
        --idx;
        buf[offset + idx] = (byte) ' ';
        --idx;

        if (value == 0) {
            buf[offset + idx] = (byte) '0';
            --idx;
        } else {
            for (long val = value; idx >= 0 && val > 0; --idx) {
                buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));
                val = val >> 3;
            }
        }

        for (; idx >= 0; --idx) {
            buf[offset + idx] = (byte) ' ';
        }

        return offset + length;
    }

    
    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {
        byte[] temp = new byte[length + 1];

        getOctalBytes(value, temp, 0, length + 1);
        System.arraycopy(temp, 0, buf, offset, length);

        return offset + length;
    }

    
    public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {
        getOctalBytes(value, buf, offset, length);

        buf[offset + length - 1] = (byte) ' ';
        buf[offset + length - 2] = 0;

        return offset + length;
    }

    
    public static long computeCheckSum(byte[] buf) {
        long sum = 0;

        for (int i = 0; i < buf.length; ++i) {
            sum += 255 & buf[i];
        }

        return sum;
    }
}
"
org.apache.tools.zip.UnixStat,0,1,0,1,0,0,1,0,0,2.0,7,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.tools.zip;


public interface UnixStat {

    
    int PERM_MASK =           07777;
    
    int LINK_FLAG =         0120000;
    
    int FILE_FLAG =         0100000;
    
    int DIR_FLAG =           040000;

    
    
    
    

    
    int DEFAULT_LINK_PERM =    0777;
    
    int DEFAULT_DIR_PERM =     0755;
    
    int DEFAULT_FILE_PERM =    0644;
}
"
org.apache.tools.ant.types.resources.selectors.Type,5,1,0,6,10,0,2,4,4,0.9,74,0.6,3,0.0,0.583333333,0,0,12.8,5,1.2,0,"
package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class Type implements ResourceSelector {

    private static final String FILE_ATTR = ""file"";
    private static final String DIR_ATTR = ""dir"";

    
    public static final Type FILE = new Type(new FileDir(FILE_ATTR));

    
    public static final Type DIR = new Type(new FileDir(DIR_ATTR));

    
    public static class FileDir extends EnumeratedAttribute {
        private static final String[] VALUES = new String[] {FILE_ATTR, DIR_ATTR};

        
        public FileDir() {
        }

        
        public FileDir(String value) {
            setValue(value);
        }

        
        public String[] getValues() {
            return VALUES;
        }
    }

    private FileDir type = null;

    
    public Type() {
    }

    
    public Type(FileDir fd) {
        setType(fd);
    }

    
    public void setType(FileDir fd) {
        type = fd;
    }

    
    public boolean isSelected(Resource r) {
        if (type == null) {
            throw new BuildException(""The type attribute is required."");
        }
        int i = type.getIndex();
        return r.isDirectory() ? i == 1 : i == 0;
    }

}
"
org.apache.tools.ant.types.FileList,12,3,0,13,32,0,6,7,10,0.454545455,192,1.0,0,0.75,0.238095238,1,1,14.83333333,4,1.6667,0,"

package org.apache.tools.ant.types;

import java.io.File;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Iterator;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.resources.FileResourceIterator;


public class FileList extends DataType implements ResourceCollection {

    private Vector filenames = new Vector();
    private File dir;

    
    public FileList() {
        super();
    }

    
    protected FileList(FileList filelist) {
        this.dir       = filelist.dir;
        this.filenames = filelist.filenames;
        setProject(filelist.getProject());
    }

    
    public void setRefid(Reference r) throws BuildException {
        if ((dir != null) || (filenames.size() != 0)) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public void setDir(File dir) throws BuildException {
        checkAttributesAllowed();
        this.dir = dir;
    }

    
    public File getDir(Project p) {
        if (isReference()) {
            return getRef(p).getDir(p);
        }
        return dir;
    }

    
    public void setFiles(String filenames) {
        checkAttributesAllowed();
        if (filenames != null && filenames.length() > 0) {
            StringTokenizer tok = new StringTokenizer(
                filenames, "", \t\n\r\f"", false);
            while (tok.hasMoreTokens()) {
               this.filenames.addElement(tok.nextToken());
            }
        }
    }

    
    public String[] getFiles(Project p) {
        if (isReference()) {
            return getRef(p).getFiles(p);
        }

        if (dir == null) {
            throw new BuildException(""No directory specified for filelist."");
        }

        if (filenames.size() == 0) {
            throw new BuildException(""No files specified for filelist."");
        }

        String[] result = new String[filenames.size()];
        filenames.copyInto(result);
        return result;
    }

    
    protected FileList getRef(Project p) {
        return (FileList) getCheckedRef(p);
    }

    
    public static class FileName {
        private String name;

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }
    }

    
    public void addConfiguredFile(FileName name) {
        if (name.getName() == null) {
            throw new BuildException(
                ""No name specified in nested file element"");
        }
        filenames.addElement(name.getName());
    }

    
    public Iterator iterator() {
        if (isReference()) {
            return ((FileList) getRef(getProject())).iterator();
        }
        return new FileResourceIterator(dir,
            (String[]) (filenames.toArray(new String[filenames.size()])));
    }

    
    public int size() {
        if (isReference()) {
            return ((FileList) getRef(getProject())).size();
        }
        return filenames.size();
    }

    
    public boolean isFilesystemOnly() {
        return true;
    }

}
"
org.apache.tools.ant.taskdefs.optional.TraXLiaison,25,1,0,15,108,244,0,15,15,0.81547619,712,1.0,4,0.0,0.178030303,0,0,26.92,8,1.48,2,"

package org.apache.tools.ant.taskdefs.optional;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;
import java.net.URL;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.URIResolver;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.TransformerConfigurationException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.XSLTLiaison3;
import org.apache.tools.ant.taskdefs.XSLTLogger;
import org.apache.tools.ant.taskdefs.XSLTLoggerAware;
import org.apache.tools.ant.taskdefs.XSLTProcess;
import org.apache.tools.ant.types.XMLCatalog;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.URLResource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JAXPUtils;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;


public class TraXLiaison implements XSLTLiaison3, ErrorListener, XSLTLoggerAware {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private Project project;

    
    private String factoryName = null;

    
    private TransformerFactory tfactory = null;

    
    private Resource stylesheet;

    private XSLTLogger logger;

    
    private EntityResolver entityResolver;

    
    private Transformer transformer;

    
    private Templates templates;

    
    private long templatesModTime;

    
    private URIResolver uriResolver;

    
    private Vector outputProperties = new Vector();

    
    private Hashtable params = new Hashtable();

    
    private Vector attributes = new Vector();

    
    public TraXLiaison() throws Exception {
    }

    
    public void setStylesheet(File stylesheet) throws Exception {
        FileResource fr = new FileResource();
        fr.setProject(project);
        fr.setFile(stylesheet);
        setStylesheet(fr);
    }

    
    public void setStylesheet(Resource stylesheet) throws Exception {
        if (this.stylesheet != null) {
            
            transformer = null;

            
            if (!this.stylesheet.equals(stylesheet)
                || (stylesheet.getLastModified() != templatesModTime)) {
                templates = null;
            }
        }
        this.stylesheet = stylesheet;
    }

    
    public void transform(File infile, File outfile) throws Exception {
        if (transformer == null) {
            createTransformer();
        }

        InputStream fis = null;
        OutputStream fos = null;
        try {
            fis = new BufferedInputStream(new FileInputStream(infile));
            fos = new BufferedOutputStream(new FileOutputStream(outfile));
            StreamResult res = new StreamResult(fos);
            
            res.setSystemId(JAXPUtils.getSystemId(outfile));
            Source src = getSource(fis, infile);

            
            
            setTransformationParameters();

            transformer.transform(src, res);
        } finally {
            
            
            
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException ignored) {
                
            }
            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException ignored) {
                
            }
        }
    }

    
    private Source getSource(InputStream is, File infile)
        throws ParserConfigurationException, SAXException {
        
        
        
        Source src = null;
        if (entityResolver != null) {
            if (getFactory().getFeature(SAXSource.FEATURE)) {
                SAXParserFactory spFactory = SAXParserFactory.newInstance();
                spFactory.setNamespaceAware(true);
                XMLReader reader = spFactory.newSAXParser().getXMLReader();
                reader.setEntityResolver(entityResolver);
                src = new SAXSource(reader, new InputSource(is));
            } else {
                throw new IllegalStateException(""xcatalog specified, but ""
                    + ""parser doesn't support SAX"");
            }
        } else {
            
            
            src = new StreamSource(is);
        }
        src.setSystemId(JAXPUtils.getSystemId(infile));
        return src;
    }

    private Source getSource(InputStream is, Resource resource)
        throws ParserConfigurationException, SAXException {
        
        
        
        Source src = null;
        if (entityResolver != null) {
            if (getFactory().getFeature(SAXSource.FEATURE)) {
                SAXParserFactory spFactory = SAXParserFactory.newInstance();
                spFactory.setNamespaceAware(true);
                XMLReader reader = spFactory.newSAXParser().getXMLReader();
                reader.setEntityResolver(entityResolver);
                src = new SAXSource(reader, new InputSource(is));
            } else {
                throw new IllegalStateException(""xcatalog specified, but ""
                    + ""parser doesn't support SAX"");
            }
        } else {
            
            
            src = new StreamSource(is);
        }
        
        
        
        src.setSystemId(resourceToURI(resource));
        return src;
    }

    private String resourceToURI(Resource resource) {
        if (resource instanceof FileResource) {
            File f = ((FileResource) resource).getFile();
            return FILE_UTILS.toURI(f.getAbsolutePath());
        }
        if (resource instanceof URLResource) {
            URL u = ((URLResource) resource).getURL();
            return String.valueOf(u);
        } else {
            return resource.getName();
        }
    }

    
    private void readTemplates()
        throws IOException, TransformerConfigurationException,
               ParserConfigurationException, SAXException {

        
        
        
        
        InputStream xslStream = null;
        try {
            xslStream
                = new BufferedInputStream(stylesheet.getInputStream());
            templatesModTime = stylesheet.getLastModified();
            Source src = getSource(xslStream, stylesheet);
            templates = getFactory().newTemplates(src);
        } finally {
            if (xslStream != null) {
                xslStream.close();
            }
        }
    }

    
    private void createTransformer() throws Exception {
        if (templates == null) {
            readTemplates();
        }

        transformer = templates.newTransformer();

        
        transformer.setErrorListener(this);
        if (uriResolver != null) {
            transformer.setURIResolver(uriResolver);
        }
        for (int i = 0; i < outputProperties.size(); i++) {
            final String[] pair = (String[]) outputProperties.elementAt(i);
            transformer.setOutputProperty(pair[0], pair[1]);
        }
    }

    
    private void setTransformationParameters() {
        for (final Enumeration enumeration = params.keys();
             enumeration.hasMoreElements();) {
            final String name = (String) enumeration.nextElement();
            final String value = (String) params.get(name);
            transformer.setParameter(name, value);
        }
    }

    
    private TransformerFactory getFactory() throws BuildException {
        if (tfactory != null) {
            return tfactory;
        }
        
        if (factoryName == null) {
            tfactory = TransformerFactory.newInstance();
        } else {
            try {
                Class clazz = Class.forName(factoryName);
                tfactory = (TransformerFactory) clazz.newInstance();
            } catch (Exception e) {
                throw new BuildException(e);
            }
        }
        tfactory.setErrorListener(this);

        
        for (int i = 0; i < attributes.size(); i++) {
            final Object[] pair = (Object[]) attributes.elementAt(i);
            tfactory.setAttribute((String) pair[0], pair[1]);
        }

        if (uriResolver != null) {
            tfactory.setURIResolver(uriResolver);
        }
        return tfactory;
    }


    
    public void setFactory(String name) {
        factoryName = name;
    }

    
    public void setAttribute(String name, Object value) {
        final Object[] pair = new Object[]{name, value};
        attributes.addElement(pair);
    }

    
    public void setOutputProperty(String name, String value) {
        final String[] pair = new String[]{name, value};
        outputProperties.addElement(pair);
    }

    
    public void setEntityResolver(EntityResolver aResolver) {
        entityResolver = aResolver;
    }

    
    public void setURIResolver(URIResolver aResolver) {
        uriResolver = aResolver;
    }

    
    public void addParam(String name, String value) {
        params.put(name, value);
    }

    
    public void setLogger(XSLTLogger l) {
        logger = l;
    }

    
    public void error(TransformerException e) {
        logError(e, ""Error"");
    }

    
    public void fatalError(TransformerException e) {
        logError(e, ""Fatal Error"");
        throw new BuildException(""Fatal error during transformation"", e);
    }

    
    public void warning(TransformerException e) {
        logError(e, ""Warning"");
    }

    private void logError(TransformerException e, String type) {
        if (logger == null) {
            return;
        }

        StringBuffer msg = new StringBuffer();
        SourceLocator locator = e.getLocator();
        if (locator != null) {
            String systemid = locator.getSystemId();
            if (systemid != null) {
                String url = systemid;
                if (url.startsWith(""file:"")) {
                    url = FileUtils.getFileUtils().fromURI(url);
                }
                msg.append(url);
            } else {
                msg.append(""Unknown file"");
            }
            int line = locator.getLineNumber();
            if (line != -1) {
                msg.append("":"");
                msg.append(line);
                int column = locator.getColumnNumber();
                if (column != -1) {
                    msg.append("":"");
                    msg.append(column);
                }
            }
        }
        msg.append("": "");
        msg.append(type);
        msg.append(""! "");
        msg.append(e.getMessage());
        if (e.getCause() != null) {
            msg.append("" Cause: "");
            msg.append(e.getCause());
        }

        logger.log(msg.toString());
    }

    
    
    protected String getSystemId(File file) {
        return JAXPUtils.getSystemId(file);
    }


    
    public void configure(XSLTProcess xsltTask) {
        project = xsltTask.getProject();
        XSLTProcess.Factory factory = xsltTask.getFactory();
        if (factory != null) {
            setFactory(factory.getName());

            
            for (Enumeration attrs = factory.getAttributes();
                    attrs.hasMoreElements();) {
                XSLTProcess.Factory.Attribute attr =
                        (XSLTProcess.Factory.Attribute) attrs.nextElement();
                setAttribute(attr.getName(), attr.getValue());
            }
        }

        XMLCatalog xmlCatalog = xsltTask.getXMLCatalog();
        
        if (xmlCatalog != null) {
            setEntityResolver(xmlCatalog);
            setURIResolver(xmlCatalog);
        }


        
        for (Enumeration props = xsltTask.getOutputProperties();
                props.hasMoreElements();) {
            XSLTProcess.OutputProperty prop
                = (XSLTProcess.OutputProperty) props.nextElement();
            setOutputProperty(prop.getName(), prop.getValue());
        }
    }
}
"
org.apache.tools.ant.ExitException,3,5,0,3,7,0,3,0,3,0.0,27,1.0,0,0.928571429,0.666666667,0,0,7.666666667,1,0.3333,0,"
package org.apache.tools.ant;


public class ExitException extends SecurityException {

    
    private int status;

    
    public ExitException(int status) {
        super(""ExitException: status "" + status);
        this.status = status;
    }

    
    public ExitException(String msg, int status) {
        super(msg);
        this.status = status;
    }

    
    public int getStatus() {
        return status;
    }
}
"
org.apache.tools.ant.taskdefs.optional.net.MimeMail,2,4,0,2,9,1,0,2,2,2.0,22,0.0,0,0.985507246,1.0,1,1,10.0,1,0.5,0,"
package org.apache.tools.ant.taskdefs.optional.net;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.email.EmailTask;


public class MimeMail extends EmailTask {
    
    public void execute()
        throws BuildException {
        log(""DEPRECATED - The "" + getTaskName() + "" task is deprecated. ""
            + ""Use the mail task instead."");
        super.execute();
    }
}
"
org.apache.tools.ant.launch.Locator,11,1,0,8,75,53,7,1,9,0.825,968,0.5,0,0.0,0.183333333,0,0,86.27272727,17,3.1818,4,"
package org.apache.tools.ant.launch;

import java.net.MalformedURLException;

import java.net.URL;
import java.io.File;
import java.io.FilenameFilter;
import java.io.ByteArrayOutputStream;
import java.io.UnsupportedEncodingException;
import java.text.CharacterIterator;
import java.text.StringCharacterIterator;
import java.util.Locale;


public final class Locator {
    
    public static final String URI_ENCODING = ""UTF-8"";
    
    
    
    private static boolean[] gNeedEscaping = new boolean[128];
    
    private static char[] gAfterEscaping1 = new char[128];
    
    private static char[] gAfterEscaping2 = new char[128];
    private static char[] gHexChs = {'0', '1', '2', '3', '4', '5', '6', '7',
                                     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    
    static {
        for (int i = 0; i <= 0x1f; i++) {
            gNeedEscaping[i] = true;
            gAfterEscaping1[i] = gHexChs[i >> 4];
            gAfterEscaping2[i] = gHexChs[i & 0xf];
        }
        gNeedEscaping[0x7f] = true;
        gAfterEscaping1[0x7f] = '7';
        gAfterEscaping2[0x7f] = 'F';
        char[] escChs = {' ', '<', '>', '#', '%', '""', '{', '}',
                         '|', '\\', '^', '~', '[', ']', '`'};
        int len = escChs.length;
        char ch;
        for (int i = 0; i < len; i++) {
            ch = escChs[i];
            gNeedEscaping[ch] = true;
            gAfterEscaping1[ch] = gHexChs[ch >> 4];
            gAfterEscaping2[ch] = gHexChs[ch & 0xf];
        }
    }
    
    private Locator() {
    }

    
    public static File getClassSource(Class c) {
        String classResource = c.getName().replace('.', '/') + "".class"";
        return getResourceSource(c.getClassLoader(), classResource);
    }

    
    public static File getResourceSource(ClassLoader c, String resource) {
        if (c == null) {
            c = Locator.class.getClassLoader();
        }
        URL url = null;
        if (c == null) {
            url = ClassLoader.getSystemResource(resource);
        } else {
            url = c.getResource(resource);
        }
        if (url != null) {
            String u = url.toString();
            if (u.startsWith(""jar:file:"")) {
                int pling = u.indexOf(""!"");
                String jarName = u.substring(4, pling);
                return new File(fromURI(jarName));
            } else if (u.startsWith(""file:"")) {
                int tail = u.indexOf(resource);
                String dirName = u.substring(0, tail);
                return new File(fromURI(dirName));
            }
        }
        return null;
    }

    
    public static String fromURI(String uri) {
        
        Class uriClazz = null;
        try {
            uriClazz = Class.forName(""java.net.URI"");
        } catch (ClassNotFoundException cnfe) {
            
        }
        
        
        
        
        if (uriClazz != null && uri.startsWith(""file:/"")) {
            try {
                java.lang.reflect.Method createMethod
                    = uriClazz.getMethod(""create"", new Class[] {String.class});
                Object uriObj = createMethod.invoke(null, new Object[] {uri});
                java.lang.reflect.Constructor fileConst
                    = File.class.getConstructor(new Class[] {uriClazz});
                File f = (File) fileConst.newInstance(new Object[] {uriObj});
                return f.getAbsolutePath();
            } catch (java.lang.reflect.InvocationTargetException e) {
                Throwable e2 = e.getTargetException();
                if (e2 instanceof IllegalArgumentException) {
                    
                    throw (IllegalArgumentException) e2;
                } else {
                    
                    e2.printStackTrace();
                }
            } catch (Exception e) {
                
                e.printStackTrace();
            }
        }

        

        URL url = null;
        try {
            url = new URL(uri);
        } catch (MalformedURLException emYouEarlEx) {
            
        }
        if (url == null || !(""file"".equals(url.getProtocol()))) {
            throw new IllegalArgumentException(""Can only handle valid file: URIs"");
        }
        StringBuffer buf = new StringBuffer(url.getHost());
        if (buf.length() > 0) {
            buf.insert(0, File.separatorChar).insert(0, File.separatorChar);
        }
        String file = url.getFile();
        int queryPos = file.indexOf('?');
        buf.append((queryPos < 0) ? file : file.substring(0, queryPos));

        uri = buf.toString().replace('/', File.separatorChar);

        if (File.pathSeparatorChar == ';' && uri.startsWith(""\\"") && uri.length() > 2
            && Character.isLetter(uri.charAt(1)) && uri.lastIndexOf(':') > -1) {
            uri = uri.substring(1);
        }
        String path = null;
        try {
            path = decodeUri(uri);
            String cwd = System.getProperty(""user.dir"");
            int posi = cwd.indexOf("":"");
            if ((posi > 0) && path.startsWith(File.separator)) {
               path = cwd.substring(0, posi + 1) + path;
            }
        } catch (UnsupportedEncodingException exc) {
            
            
            throw new IllegalStateException(""Could not convert URI to path: ""
                                            + exc.getMessage());
        }
        return path;
    }

    
    public static String decodeUri(String uri) throws UnsupportedEncodingException {
        if (uri.indexOf('%') == -1) {
            return uri;
        }
        ByteArrayOutputStream sb = new ByteArrayOutputStream(uri.length());
        CharacterIterator iter = new StringCharacterIterator(uri);
        for (char c = iter.first(); c != CharacterIterator.DONE;
             c = iter.next()) {
            if (c == '%') {
                char c1 = iter.next();
                if (c1 != CharacterIterator.DONE) {
                    int i1 = Character.digit(c1, 16);
                    char c2 = iter.next();
                    if (c2 != CharacterIterator.DONE) {
                        int i2 = Character.digit(c2, 16);
                        sb.write((char) ((i1 << 4) + i2));
                    }
                }
            } else {
                sb.write(c);
            }
        }
        return sb.toString(URI_ENCODING);
    }
    
    public static String encodeURI(String path) throws UnsupportedEncodingException {
        int i = 0;
        int len = path.length();
        int ch = 0;
        StringBuffer sb = null;
        for (; i < len; i++) {
            ch = path.charAt(i);
            
            if (ch >= 128) {
                break;
            }
            if (gNeedEscaping[ch]) {
                if (sb == null) {
                    sb = new StringBuffer(path.substring(0, i));
                }
                sb.append('%');
                sb.append(gAfterEscaping1[ch]);
                sb.append(gAfterEscaping2[ch]);
                
            } else if (sb != null) {
                sb.append((char) ch);
            }
        }

        
        if (i < len) {
            if (sb == null) {
                sb = new StringBuffer(path.substring(0, i));
            }
            
            byte[] bytes = null;
            byte b;
            bytes = path.substring(i).getBytes(URI_ENCODING);
            len = bytes.length;

            
            for (i = 0; i < len; i++) {
                b = bytes[i];
                
                if (b < 0) {
                    ch = b + 256;
                    sb.append('%');
                    sb.append(gHexChs[ch >> 4]);
                    sb.append(gHexChs[ch & 0xf]);
                } else if (gNeedEscaping[b]) {
                    sb.append('%');
                    sb.append(gAfterEscaping1[b]);
                    sb.append(gAfterEscaping2[b]);
                } else {
                    sb.append((char) b);
                }
            }
        }
        return sb == null ? path : sb.toString();
    }

    
    public static URL fileToURL(File file)
        throws MalformedURLException {
        try {
            return new URL(encodeURI(file.toURL().toString()));
        } catch (UnsupportedEncodingException ex) {
            throw new MalformedURLException(ex.toString());
        }
    }

    
    public static File getToolsJar() {
        
        boolean toolsJarAvailable = false;
        try {
            
            Class.forName(""com.sun.tools.javac.Main"");
            toolsJarAvailable = true;
        } catch (Exception e) {
            try {
                Class.forName(""sun.tools.javac.Main"");
                toolsJarAvailable = true;
            } catch (Exception e2) {
                
            }
        }
        if (toolsJarAvailable) {
            return null;
        }
        
        
        String javaHome = System.getProperty(""java.home"");
        File toolsJar = new File(javaHome + ""/lib/tools.jar"");
        if (toolsJar.exists()) {
            
            return toolsJar;
        }
        if (javaHome.toLowerCase(Locale.US).endsWith(File.separator + ""jre"")) {
            javaHome = javaHome.substring(0, javaHome.length() - 4);
            toolsJar = new File(javaHome + ""/lib/tools.jar"");
        }
        if (!toolsJar.exists()) {
            System.out.println(""Unable to locate tools.jar. ""
                 + ""Expected to find it in "" + toolsJar.getPath());
            return null;
        }
        return toolsJar;
    }

    
    public static URL[] getLocationURLs(File location)
         throws MalformedURLException {
        return getLocationURLs(location, new String[]{"".jar""});
    }

    
    public static URL[] getLocationURLs(File location,
                                        final String[] extensions)
         throws MalformedURLException {
        URL[] urls = new URL[0];

        if (!location.exists()) {
            return urls;
        }
        if (!location.isDirectory()) {
            urls = new URL[1];
            String path = location.getPath();
            for (int i = 0; i < extensions.length; ++i) {
                if (path.toLowerCase().endsWith(extensions[i])) {
                    urls[0] = fileToURL(location);
                    break;
                }
            }
            return urls;
        }
        File[] matches = location.listFiles(
            new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    for (int i = 0; i < extensions.length; ++i) {
                        if (name.toLowerCase().endsWith(extensions[i])) {
                            return true;
                        }
                    }
                    return false;
                }
            });
        urls = new URL[matches.length];
        for (int i = 0; i < matches.length; ++i) {
            urls[i] = fileToURL(matches[i]);
        }
        return urls;
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.IntegerCPInfo,3,3,0,2,11,3,1,1,3,2.0,25,0.0,0,0.8,0.666666667,2,2,7.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class IntegerCPInfo extends ConstantCPInfo {

    
    public IntegerCPInfo() {
        super(CONSTANT_INTEGER, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Integer(cpStream.readInt()));
    }

    
    public String toString() {
        return ""Integer Constant Pool Entry: "" + getValue();
    }

}

"
org.apache.tools.ant.taskdefs.optional.perforce.P4Labelsync,9,4,0,5,20,28,0,5,9,0.78125,156,1.0,0,0.86440678,0.481481481,2,2,15.88888889,1,0.8889,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.StringUtils;


public class P4Labelsync extends P4Base {

    
    protected String name;
    private boolean add; 
    private boolean delete; 
    private boolean simulationmode;  
    
    
    public boolean isAdd() {
        return add;
    }
    
    public void setAdd(boolean add) {
        this.add = add;
    }
    
    public boolean isDelete() {
        return delete;
    }

    
    public void setDelete(boolean delete) {
        this.delete = delete;
    }


    
    public void setName(String name) {
        this.name = name;
    }
    
    public boolean isSimulationmode() {
        return simulationmode;
    }
    
    public void setSimulationmode(boolean simulationmode) {
        this.simulationmode = simulationmode;
    }


    
    public void execute() throws BuildException {
        log(""P4Labelsync exec:"", Project.MSG_INFO);

        if (P4View != null && P4View.length() >= 1) {
            P4View = StringUtils.replace(P4View, "":"", ""\n\t"");
            P4View = StringUtils.replace(P4View, "";"", ""\n\t"");
        }
        if (P4View == null) {
            P4View = """";
        }

        if (name == null || name.length() < 1) {
            throw new BuildException(""name attribute is compulsory for labelsync"");
        }

        if (this.isSimulationmode()) {
            P4CmdOpts = P4CmdOpts + "" -n"";
        }
        if (this.isDelete()) {
            P4CmdOpts = P4CmdOpts + "" -d"";
        }
        if (this.isAdd()) {
            P4CmdOpts = P4CmdOpts + "" -a"";
        }

        execP4Command(""-s labelsync -l "" + name + "" "" + P4CmdOpts + "" "" + P4View,
            new SimpleP4OutputHandler(this));


    }
}

"
org.apache.tools.ant.taskdefs.optional.dotnet.VisualBasicCompile,26,6,0,5,42,233,0,5,19,0.8,269,1.0,0,0.857142857,0.269230769,1,7,9.115384615,3,1.3846,0,"

package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.BuildException;




public class VisualBasicCompile extends DotnetCompile {

    
    private boolean removeIntChecks = false;

    
    private boolean optionExplicit = false;

    
    private boolean optionStrict = false;

    
    private String optionCompare;

    
    private String rootNamespace;

    
    private String imports;

    
    public VisualBasicCompile() {
        clear();
    }

    
    public void clear() {
        super.clear();
        imports = null;
        rootNamespace = null;
        optionCompare = null;
        optionExplicit = false;
        optionStrict = false;
        removeIntChecks = false;
        setExecutable(""vbc"");
    }

    
    protected String getWin32ResParameter() {
        if (getWin32Res() != null) {
            return ""/win32resource:"" + getWin32Res().toString();
        } else {
            return null;
        }
    }

    
    public void setRemoveIntChecks(boolean flag) {
        removeIntChecks = flag;
    }

    
    public boolean getRemoveIntChecks() {
        return removeIntChecks;
    }

    
    public String getRemoveIntChecksParameter() {
        return ""/removeintchecks"" + (removeIntChecks ? ""+"" : ""-"");
    }

    
    public void setOptionExplicit(boolean flag) {
        optionExplicit = flag;
    }

    
    public boolean getOptionExplicit() {
        return optionExplicit;
    }

    
    public String getOptionExplicitParameter() {
        return ""/optionexplicit"" + (optionExplicit ? ""+"" : ""-"");
    }

    
    public void setOptionStrict(boolean flag) {
        optionStrict = flag;
    }

    
    public boolean getOptionStrict() {
        return optionStrict;
    }

    
    public String getOptionStrictParameter() {
        return ""/optionstrict"" + (optionStrict ? ""+"" : ""-"");
    }


    
    public void setRootNamespace(String rootNamespace) {
        this.rootNamespace = rootNamespace;
    }


    
    public String getRootNamespace() {
        return this.rootNamespace;
    }


    
    protected String getRootNamespaceParameter() {
        if (rootNamespace != null && rootNamespace.length() != 0) {
            return ""/rootnamespace:"" + rootNamespace;
        } else {
            return null;
        }
    }


    
    public void setImports(String imports) {
        this.imports = imports;
    }


    
    public String getImports() {
        return this.imports;
    }


    
    protected String getImportsParameter() {
        if (imports != null && imports.length() != 0) {
            return ""/imports:"" + imports;
        } else {
            return null;
        }
    }


    
    public void setOptionCompare(String optionCompare) {
        if (""text"".equalsIgnoreCase(optionCompare)) {
            this.optionCompare = ""text"";
        } else {
            this.optionCompare = ""binary"";
        }
    }


    
    public String getOptionCompare() {
        return this.optionCompare;
    }

    
    protected String getOptionCompareParameter() {
        if (optionCompare != null && ""text"".equalsIgnoreCase(optionCompare)) {
            return ""/optioncompare:text"";
        } else {
            return ""/optioncompare:binary"";
        }
    }

    
    protected void addCompilerSpecificOptions(NetCommand command) {
        command.addArgument(getRemoveIntChecksParameter());
        command.addArgument(getImportsParameter());
        command.addArgument(getOptionExplicitParameter());
        command.addArgument(getOptionStrictParameter());
        command.addArgument(getRootNamespaceParameter());
        command.addArgument(getOptionCompareParameter());
    }

    
    public String getReferenceDelimiter() {
        return "","";
    }



    
    public String getFileExtension() {
        return ""vb"";
    }

    
    protected void createResourceParameter(NetCommand command, DotnetResource resource) {
        resource.getParameters(getProject(), command, false);
    }

    
    protected void validate()
            throws BuildException {
        super.validate();
        if (getDestFile() == null) {
            throw new BuildException(""DestFile was not specified"");
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.JarLibAvailableTask,7,3,0,7,28,0,0,7,6,0.666666667,191,1.0,1,0.860465116,0.314285714,0,0,25.71428571,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import java.util.Iterator;
import java.util.Vector;
import java.util.jar.Manifest;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;


public class JarLibAvailableTask extends Task {
    
    private File libraryFile;

    
    private final Vector extensionFileSets = new Vector();

    
    private String propertyName;

    
    private ExtensionAdapter requiredExtension;

    
    public void setProperty(final String property) {
        this.propertyName = property;
    }

    
    public void setFile(final File file) {
        this.libraryFile = file;
    }

    
    public void addConfiguredExtension(final ExtensionAdapter extension) {
        if (null != requiredExtension) {
            final String message = ""Can not specify extension to ""
                + ""search for multiple times."";
            throw new BuildException(message);
        }
        requiredExtension = extension;
    }

    
    public void addConfiguredExtensionSet(final ExtensionSet extensionSet) {
        extensionFileSets.addElement(extensionSet);
    }

    
    public void execute() throws BuildException {
        validate();

        final Extension test = requiredExtension.toExtension();

        
        if (!extensionFileSets.isEmpty()) {
            final Iterator iterator = extensionFileSets.iterator();
            while (iterator.hasNext()) {
                final ExtensionSet extensionSet
                    = (ExtensionSet) iterator.next();
                final Extension[] extensions =
                    extensionSet.toExtensions(getProject());
                for (int i = 0; i < extensions.length; i++) {
                    final Extension extension = extensions[ i ];
                    if (extension.isCompatibleWith(test)) {
                        getProject().setNewProperty(propertyName, ""true"");
                    }
                }
            }
        } else {
            final Manifest manifest = ExtensionUtil.getManifest(libraryFile);
            final Extension[] extensions = Extension.getAvailable(manifest);
            for (int i = 0; i < extensions.length; i++) {
                final Extension extension = extensions[ i ];
                if (extension.isCompatibleWith(test)) {
                    getProject().setNewProperty(propertyName, ""true"");
                }
            }
        }
    }

    
    private void validate() throws BuildException {
        if (null == requiredExtension) {
            final String message = ""Extension element must be specified."";
            throw new BuildException(message);
        }

        if (null == libraryFile && extensionFileSets.isEmpty()) {
            final String message = ""File attribute not specified."";
            throw new BuildException(message);
        }
        if (null != libraryFile && !libraryFile.exists()) {
            final String message = ""File '"" + libraryFile + ""' does not exist."";
            throw new BuildException(message);
        }
        if (null != libraryFile && !libraryFile.isFile()) {
            final String message = ""\'"" + libraryFile + ""\' is not a file."";
            throw new BuildException(message);
        }
    }
}
"
org.apache.tools.ant.DynamicElement,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;


public interface DynamicElement {

    
    Object createDynamicElement(String name) throws BuildException;
}
"
org.apache.tools.ant.taskdefs.email.Header,5,1,0,3,6,6,3,0,5,0.75,24,1.0,0,0.0,0.7,0,0,3.4,1,0.8,0,"

package org.apache.tools.ant.taskdefs.email;


public class Header {
    private String name;
    private String value;

    
    public void setName(String name) {
        this.name = name;
    }

    
    public String getName() {
        return name;
    }

    
    public void setValue(String value) {
        this.value = value;
    }

    
    public String getValue() {
        return value;
    }

}
"
org.apache.tools.ant.taskdefs.Tstamp,6,3,0,5,27,3,1,5,4,0.4,135,1.0,0,0.880952381,0.5,0,0,21.16666667,2,1.0,0,"

package org.apache.tools.ant.taskdefs;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import java.util.TimeZone;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class Tstamp extends Task {

    private Vector customFormats = new Vector();
    private String prefix = """";

    
    public void setPrefix(String prefix) {
        this.prefix = prefix;
        if (!this.prefix.endsWith(""."")) {
            this.prefix += ""."";
        }
    }

    
    public void execute() throws BuildException {
        try {
            Date d = new Date();

            Enumeration i = customFormats.elements();
            while (i.hasMoreElements()) {
                CustomFormat cts = (CustomFormat) i.nextElement();
                cts.execute(getProject(), d, getLocation());
            }

            SimpleDateFormat dstamp = new SimpleDateFormat (""yyyyMMdd"");
            setProperty(""DSTAMP"", dstamp.format(d));

            SimpleDateFormat tstamp = new SimpleDateFormat (""HHmm"");
            setProperty(""TSTAMP"", tstamp.format(d));

            SimpleDateFormat today
                = new SimpleDateFormat (""MMMM d yyyy"", Locale.US);
            setProperty(""TODAY"", today.format(d));

        } catch (Exception e) {
            throw new BuildException(e);
        }
    }

    
    public CustomFormat createFormat() {
        CustomFormat cts = new CustomFormat();
        customFormats.addElement(cts);
        return cts;
    }

    
    private void setProperty(String name, String value) {
        getProject().setNewProperty(prefix + name, value);
    }

    
    public class CustomFormat {
        private TimeZone timeZone;
        private String propertyName;
        private String pattern;
        private String language;
        private String country;
        private String variant;
        private int offset = 0;
        private int field = Calendar.DATE;

        
        public CustomFormat() {
        }

        
        public void setProperty(String propertyName) {
            this.propertyName = propertyName;
        }

        
        public void setPattern(String pattern) {
            this.pattern = pattern;
        }

        
        public void setLocale(String locale) {
            StringTokenizer st = new StringTokenizer(locale, "" \t\n\r\f,"");
            try {
                language = st.nextToken();
                if (st.hasMoreElements()) {
                    country = st.nextToken();
                    if (st.hasMoreElements()) {
                        variant = st.nextToken();
                        if (st.hasMoreElements()) {
                            throw new BuildException(""bad locale format"",
                                                      getLocation());
                        }
                    }
                } else {
                    country = """";
                }
            } catch (NoSuchElementException e) {
                throw new BuildException(""bad locale format"", e,
                                         getLocation());
            }
        }

        
        public void setTimezone(String id) {
            timeZone = TimeZone.getTimeZone(id);
        }

        
        public void setOffset(int offset) {
            this.offset = offset;
        }

        
        public void setUnit(String unit) {
            log(""DEPRECATED - The setUnit(String) method has been deprecated.""
                + "" Use setUnit(Tstamp.Unit) instead."");
            Unit u = new Unit();
            u.setValue(unit);
            field = u.getCalendarField();
        }

        
        public void setUnit(Unit unit) {
            field = unit.getCalendarField();
        }

        
        public void execute(Project project, Date date, Location location) {
            if (propertyName == null) {
                throw new BuildException(""property attribute must be provided"",
                                         location);
            }

            if (pattern == null) {
                throw new BuildException(""pattern attribute must be provided"",
                                         location);
            }

            SimpleDateFormat sdf;
            if (language == null) {
                sdf = new SimpleDateFormat(pattern);
            } else if (variant == null) {
                sdf = new SimpleDateFormat(pattern,
                                           new Locale(language, country));
            } else {
                sdf = new SimpleDateFormat(pattern,
                                           new Locale(language, country,
                                                      variant));
            }
            if (offset != 0) {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(field, offset);
                date = calendar.getTime();
            }
            if (timeZone != null) {
                sdf.setTimeZone(timeZone);
            }
            Tstamp.this.setProperty(propertyName, sdf.format(date));
        }
    }

    
    public static class Unit extends EnumeratedAttribute {

        private static final String MILLISECOND = ""millisecond"";
        private static final String SECOND = ""second"";
        private static final String MINUTE = ""minute"";
        private static final String HOUR = ""hour"";
        private static final String DAY = ""day"";
        private static final String WEEK = ""week"";
        private static final String MONTH = ""month"";
        private static final String YEAR = ""year"";

        private static final String[] UNITS = {
                                                MILLISECOND,
                                                SECOND,
                                                MINUTE,
                                                HOUR,
                                                DAY,
                                                WEEK,
                                                MONTH,
                                                YEAR
                                              };

        private Map calendarFields = new HashMap();

        
        public Unit() {
            calendarFields.put(MILLISECOND,
                               new Integer(Calendar.MILLISECOND));
            calendarFields.put(SECOND, new Integer(Calendar.SECOND));
            calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));
            calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));
            calendarFields.put(DAY, new Integer(Calendar.DATE));
            calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));
            calendarFields.put(MONTH, new Integer(Calendar.MONTH));
            calendarFields.put(YEAR, new Integer(Calendar.YEAR));
        }

        
        public int getCalendarField() {
            String key = getValue().toLowerCase();
            Integer i = (Integer) calendarFields.get(key);
            return i.intValue();
        }

        
        public String[] getValues() {
            return UNITS;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.sound.SoundTask,5,3,0,5,16,0,1,5,5,0.5,82,1.0,2,0.902439024,1.0,1,1,15.0,3,1.2,0,"

package org.apache.tools.ant.taskdefs.optional.sound;

import java.io.File;
import java.util.Random;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;



public class SoundTask extends Task {

    private BuildAlert success = null;
    private BuildAlert fail = null;

    
    public BuildAlert createSuccess() {
        success = new BuildAlert();
        return success;
    }

    
    public BuildAlert createFail() {
        fail = new BuildAlert();
        return fail;
     }

    
    public SoundTask() {
    }

    
    public void init() {
    }

    
    public void execute() {

        AntSoundPlayer soundPlayer = new AntSoundPlayer();

        if (success == null) {
            log(""No nested success element found."", Project.MSG_WARN);
        } else {
            soundPlayer.addBuildSuccessfulSound(success.getSource(),
              success.getLoops(), success.getDuration());
        }

        if (fail == null) {
            log(""No nested failure element found."", Project.MSG_WARN);
        } else {
            soundPlayer.addBuildFailedSound(fail.getSource(),
              fail.getLoops(), fail.getDuration());
        }

        getProject().addBuildListener(soundPlayer);

    }

    
    public class BuildAlert {
        private File source = null;
        private int loops = 0;
        private Long duration = null;

        
        public void setDuration(Long duration) {
            this.duration = duration;
        }

        
        public void setSource(File source) {
            this.source = source;
        }

        
        public void setLoops(int loops) {
            this.loops = loops;
        }

        
        public File getSource() {
            File nofile = null;
            
            if (source.exists()) {
                if (source.isDirectory()) {
                    
                    String[] entries = source.list();
                    Vector files = new Vector();
                    for (int i = 0; i < entries.length; i++) {
                        File f = new File(source, entries[i]);
                        if (f.isFile()) {
                            files.addElement(f);
                        }
                    }
                    if (files.size() < 1) {
                        throw new BuildException(""No files found in directory "" + source);
                    }
                    int numfiles = files.size();
                    
                    Random rn = new Random();
                    int x = rn.nextInt(numfiles);
                    
                    this.source = (File) files.elementAt(x);
                }
            } else {
                log(source + "": invalid path."", Project.MSG_WARN);
                this.source = nofile;
            }
            return this.source;
        }

        
        public int getLoops() {
            return this.loops;
        }

        
        public Long getDuration() {
            return this.duration;
        }
    }
}

"
org.apache.tools.ant.taskdefs.optional.javacc.JJDoc,8,3,0,13,57,4,0,13,7,0.909090909,377,1.0,1,0.840909091,0.5,1,1,44.75,7,1.875,0,"

package org.apache.tools.ant.taskdefs.optional.javacc;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.JavaEnvUtils;


public class JJDoc extends Task {

    
    private static final String OUTPUT_FILE       = ""OUTPUT_FILE"";
    private static final String TEXT              = ""TEXT"";
    private static final String ONE_TABLE         = ""ONE_TABLE"";

    private final Hashtable optionalAttrs = new Hashtable();

    private String outputFile = null;
    private boolean plainText = false;

    private static final String DEFAULT_SUFFIX_HTML = "".html"";
    private static final String DEFAULT_SUFFIX_TEXT = "".txt"";

    
    private File targetFile      = null;
    private File javaccHome      = null;

    private CommandlineJava cmdl = new CommandlineJava();


    
    public void setText(boolean plainText) {
        optionalAttrs.put(TEXT, plainText ? Boolean.TRUE : Boolean.FALSE);
        this.plainText = plainText;
    }

    
    public void setOnetable(boolean oneTable) {
        optionalAttrs.put(ONE_TABLE, oneTable ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setOutputfile(String outputFile) {
        this.outputFile = outputFile;
    }

    
    public void setTarget(File target) {
        this.targetFile = target;
    }

    
    public void setJavacchome(File javaccHome) {
        this.javaccHome = javaccHome;
    }

    
    public JJDoc() {
        cmdl.setVm(JavaEnvUtils.getJreExecutable(""java""));
    }

    
    public void execute() throws BuildException {

        
        Enumeration iter = optionalAttrs.keys();
        while (iter.hasMoreElements()) {
            String name  = (String) iter.nextElement();
            Object value = optionalAttrs.get(name);
            cmdl.createArgument()
                .setValue(""-"" + name + "":"" + value.toString());
        }

        if (targetFile == null || !targetFile.isFile()) {
            throw new BuildException(""Invalid target: "" + targetFile);
        }

        if (outputFile != null) {
            cmdl.createArgument() .setValue(""-"" + OUTPUT_FILE + "":""
                                            + outputFile.replace('\\', '/'));
        }

        
        File javaFile = new File(createOutputFileName(targetFile, outputFile,
                                                      plainText));

        if (javaFile.exists()
             && targetFile.lastModified() < javaFile.lastModified()) {
            log(""Target is already built - skipping ("" + targetFile + "")"",
                Project.MSG_VERBOSE);
            return;
        }

        cmdl.createArgument().setValue(targetFile.getAbsolutePath());

        final Path classpath = cmdl.createClasspath(getProject());
        final File javaccJar = JavaCC.getArchiveFile(javaccHome);
        classpath.createPathElement().setPath(javaccJar.getAbsolutePath());
        classpath.addJavaRuntime();

        cmdl.setClassname(JavaCC.getMainClass(classpath,
                                              JavaCC.TASKDEF_TYPE_JJDOC));

        final Commandline.Argument arg = cmdl.createVmArgument();
        arg.setValue(""-mx140M"");
        arg.setValue(""-Dinstall.root="" + javaccHome.getAbsolutePath());

        final Execute process =
            new Execute(new LogStreamHandler(this,
                                             Project.MSG_INFO,
                                             Project.MSG_INFO),
                        null);
        log(cmdl.describeCommand(), Project.MSG_VERBOSE);
        process.setCommandline(cmdl.getCommandline());

        try {
            if (process.execute() != 0) {
                throw new BuildException(""JJDoc failed."");
            }
        } catch (IOException e) {
            throw new BuildException(""Failed to launch JJDoc"", e);
        }
    }

    private String createOutputFileName(File destFile, String optionalOutputFile,
                                        boolean plain) {
        String suffix = DEFAULT_SUFFIX_HTML;
        String javaccFile = destFile.getAbsolutePath().replace('\\', '/');

        if (plain) {
            suffix = DEFAULT_SUFFIX_TEXT;
        }

        if ((optionalOutputFile == null) || optionalOutputFile.equals("""")) {
            int filePos = javaccFile.lastIndexOf(""/"");

            if (filePos >= 0) {
                javaccFile = javaccFile.substring(filePos + 1);
            }

            int suffixPos = javaccFile.lastIndexOf('.');

            if (suffixPos == -1) {
                optionalOutputFile = javaccFile + suffix;
            } else {
                String currentSuffix = javaccFile.substring(suffixPos);

                if (currentSuffix.equals(suffix)) {
                    optionalOutputFile = javaccFile + suffix;
                } else {
                    optionalOutputFile = javaccFile.substring(0, suffixPos)
                        + suffix;
                }
            }
        } else {
            optionalOutputFile = optionalOutputFile.replace('\\', '/');
        }

        return (getProject().getBaseDir() + ""/"" + optionalOutputFile)
            .replace('\\', '/');
    }
}
"
org.apache.tools.ant.types.selectors.modifiedselector.Cache,7,1,0,2,7,21,2,0,7,2.0,7,0.0,0,0.0,0.642857143,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.util.Iterator;



public interface Cache {

    
    boolean isValid();

    
    void delete();

    
    void load();

    
    void save();

    
    Object get(Object key);

    
    void put(Object key, Object value);

    
    Iterator iterator();
}
"
org.apache.tools.ant.types.TarFileSet,21,6,1,10,42,126,2,8,15,0.7875,274,1.0,0,0.871428571,0.178571429,5,19,11.66666667,4,1.381,0,"
package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class TarFileSet extends ArchiveFileSet {

    private boolean userNameSet;
    private boolean groupNameSet;
    private boolean userIdSet;
    private boolean groupIdSet;

    private String userName = """";
    private String groupName = """";
    private int    uid;
    private int    gid;

    
    public TarFileSet() {
        super();
    }

    
    protected TarFileSet(FileSet fileset) {
        super(fileset);
    }

    
    protected TarFileSet(TarFileSet fileset) {
        super(fileset);
    }

    
    public void setUserName(String userName) {
        checkTarFileSetAttributesAllowed();
        userNameSet = true;
        this.userName = userName;
    }

    
    public String getUserName() {
        if (isReference()) {
            return ((TarFileSet) getCheckedRef()).getUserName();
        }
        return userName;
    }

    
    public boolean hasUserNameBeenSet() {
        return userNameSet;
    }

    
    public void setUid(int uid) {
        checkTarFileSetAttributesAllowed();
        userIdSet = true;
        this.uid = uid;
    }

    
    public int getUid() {
        if (isReference()) {
            return ((TarFileSet) getCheckedRef()).getUid();
        }
        return uid;
    }

    
    public boolean hasUserIdBeenSet() {
        return userIdSet;
    }

    
    public void setGroup(String groupName) {
        checkTarFileSetAttributesAllowed();
        groupNameSet = true;
        this.groupName = groupName;
    }

    
    public String getGroup() {
        if (isReference()) {
            return ((TarFileSet) getCheckedRef()).getGroup();
        }
        return groupName;
    }

    
    public boolean hasGroupBeenSet() {
        return groupNameSet;
    }

    
    public void setGid(int gid) {
        checkTarFileSetAttributesAllowed();
        groupIdSet = true;
        this.gid = gid;
    }

    
    public int getGid() {
        if (isReference()) {
            return ((TarFileSet) getCheckedRef()).getGid();
        }
        return gid;
    }

    
    public boolean hasGroupIdBeenSet() {
        return groupIdSet;
    }

    
    protected ArchiveScanner newArchiveScanner() {
        TarScanner zs = new TarScanner();
        return zs;
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (userNameSet || userIdSet || groupNameSet || groupIdSet) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    protected AbstractFileSet getRef(Project p) {
        dieOnCircularReference(p);
        Object o = getRefid().getReferencedObject(p);
        if (o instanceof TarFileSet) {
            return (AbstractFileSet) o;
        } else if (o instanceof FileSet) {
            TarFileSet zfs = new TarFileSet((FileSet) o);
            configureFileSet(zfs);
            return zfs;
        } else {
            String msg = getRefid().getRefId() + "" doesn\'t denote a tarfileset or a fileset"";
            throw new BuildException(msg);
        }
    }

    
    protected void configureFileSet(ArchiveFileSet zfs) {
        super.configureFileSet(zfs);
        if (zfs instanceof TarFileSet) {
            TarFileSet tfs = (TarFileSet) zfs;
            tfs.setUserName(userName);
            tfs.setGroup(groupName);
            tfs.setUid(uid);
            tfs.setGid(gid);
        }
    }

    
    public Object clone() {
        if (isReference()) {
            return ((TarFileSet) getRef(getProject())).clone();
        } else {
            return super.clone();
        }
    }

    
    private void checkTarFileSetAttributesAllowed() {
        if (getProject() == null
            || (isReference()
                && (getRefid().getReferencedObject(
                        getProject())
                    instanceof TarFileSet))) {
            checkAttributesAllowed();
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.ejb.JonasDeploymentTool,28,2,0,12,97,302,1,11,16,0.962962963,1230,1.0,0,0.542372881,0.272321429,2,8,41.78571429,20,2.2857,0,"
package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import javax.xml.parsers.SAXParser;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Path;


public class JonasDeploymentTool extends GenericDeploymentTool {

    
    protected static final String EJB_JAR_1_1_PUBLIC_ID
        = ""-
    protected static final String EJB_JAR_2_0_PUBLIC_ID
        = ""-

    
    protected static final String JONAS_EJB_JAR_2_4_PUBLIC_ID
        = ""-
    protected static final String JONAS_EJB_JAR_2_5_PUBLIC_ID
        = ""-

    
    protected static final String RMI_ORB = ""RMI"";

    
    protected static final String JEREMIE_ORB = ""JEREMIE"";

    
    protected static final String DAVID_ORB = ""DAVID"";

    
    protected static final String EJB_JAR_1_1_DTD = ""ejb-jar_1_1.dtd"";
    protected static final String EJB_JAR_2_0_DTD = ""ejb-jar_2_0.dtd"";

    
    protected static final String JONAS_EJB_JAR_2_4_DTD
        = ""jonas-ejb-jar_2_4.dtd"";
    protected static final String JONAS_EJB_JAR_2_5_DTD
        = ""jonas-ejb-jar_2_5.dtd"";

    
    protected static final String JONAS_DD = ""jonas-ejb-jar.xml"";

    
    protected static final String GENIC_CLASS =
    ""org.objectweb.jonas_ejb.genic.GenIC"";

    
    protected static final String OLD_GENIC_CLASS_1 =
        ""org.objectweb.jonas_ejb.tools.GenWholeIC"";

    
    protected static final String OLD_GENIC_CLASS_2 =
        ""org.objectweb.jonas_ejb.tools.GenIC"";

    
    private String descriptorName;

    
    private String jonasDescriptorName;

    
    
    

    
    private File outputdir;

    
    private boolean keepgenerated = false;

    
    private boolean nocompil = false;

    
    private boolean novalidation = false;

    
    private String javac;

    
    private String javacopts;

    
    private String rmicopts;

    
    private boolean secpropag = false;

    
    private boolean verbose = false;

    
    private String additionalargs;

    
    
    

    
    private File jonasroot;

    
    private boolean keepgeneric = false;

    
    private String suffix = "".jar"";

    
    private String orb;

    
    private boolean nogenic = false;

    
    
    

    
    public void setKeepgenerated(boolean aBoolean) {
        keepgenerated = aBoolean;
    }

    
    public void setAdditionalargs(String aString) {
        additionalargs = aString;
    }

    
    public void setNocompil(boolean aBoolean) {
        nocompil = aBoolean;
    }

    
    public void setNovalidation(boolean aBoolean) {
        novalidation = aBoolean;
    }

    
    public void setJavac(String aString) {
        javac = aString;
    }

    
    public void setJavacopts(String aString) {
        javacopts = aString;
    }

    
    public void setRmicopts(String aString) {
        rmicopts = aString;
    }

    
    public void setSecpropag(boolean aBoolean) {
        secpropag = aBoolean;
    }

    
    public void setVerbose(boolean aBoolean) {
        verbose = aBoolean;
    }

    
    
    

    
    public void setJonasroot(File aFile) {
        jonasroot = aFile;
    }

    
    public void setKeepgeneric(boolean aBoolean) {
        keepgeneric = aBoolean;
    }

    
    public void setJarsuffix(String aString) {
        suffix = aString;
    }

    
    public void setOrb(String aString) {
        orb = aString;
    }

    
    public void setNogenic(boolean aBoolean) {
        nogenic = aBoolean;
    }

    
    
    

    
    public void processDescriptor(String aDescriptorName, SAXParser saxParser) {

        descriptorName = aDescriptorName;

        log(""JOnAS Deployment Tool processing: "" + descriptorName,
            Project.MSG_VERBOSE);

        super.processDescriptor(descriptorName, saxParser);

        if (outputdir != null) {
            
            log(""Deleting temp output directory '"" + outputdir + ""'."", Project.MSG_VERBOSE);
            deleteAllFiles(outputdir);
        }
    }

    
    protected void writeJar(String baseName, File jarfile, Hashtable ejbFiles, String publicId)
    throws BuildException {

        
        File genericJarFile = super.getVendorOutputJarFile(baseName);
        super.writeJar(baseName, genericJarFile, ejbFiles, publicId);

        
        addGenICGeneratedFiles(genericJarFile, ejbFiles);

        
        super.writeJar(baseName, getVendorOutputJarFile(baseName), ejbFiles, publicId);

        if (!keepgeneric) {
            log(""Deleting generic JAR "" + genericJarFile.toString(), Project.MSG_VERBOSE);
            genericJarFile.delete();
        }
    }

    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {

    
    jonasDescriptorName = getJonasDescriptorName();
        File jonasDD = new File(getConfig().descriptorDir, jonasDescriptorName);

        if (jonasDD.exists()) {
            ejbFiles.put(META_DIR + JONAS_DD, jonasDD);
        } else {
            log(""Unable to locate the JOnAS deployment descriptor. It was expected to be in: ""
                + jonasDD.getPath() + ""."", Project.MSG_WARN);
        }
    }

    
    protected File getVendorOutputJarFile(String baseName) {
        return new File(getDestDir(), baseName + suffix);
    }

    
    private String getJonasDescriptorName() {

        
        
        

        String jonasDN; 
        boolean jonasConvention = false; 
        String path;            
        String fileName;        
        String baseName;        
        String remainder;       

        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);
        if (startOfFileName != -1) {
            
            path = descriptorName.substring(0, startOfFileName + 1);
            fileName = descriptorName.substring(startOfFileName + 1);
        } else {
            
            path = """";
            fileName = descriptorName;
        }

        if (fileName.startsWith(EJB_DD)) {
            return path + JONAS_DD;
        }

        int endOfBaseName = descriptorName.indexOf(getConfig().baseNameTerminator, startOfFileName);

        
        if (endOfBaseName < 0) {
            
            
            
            
            endOfBaseName = descriptorName.lastIndexOf('.') - 1;
            if (endOfBaseName < 0) {
                
                endOfBaseName = descriptorName.length() - 1;
            }

            jonasConvention = true;
        }

        baseName = descriptorName.substring(startOfFileName + 1, endOfBaseName + 1);
        remainder = descriptorName.substring(endOfBaseName + 1);

        if (jonasConvention) {
            jonasDN = path + ""jonas-"" + baseName + "".xml"";
        } else {
            jonasDN = path + baseName + ""jonas-"" + remainder;
        }

        log(""Standard EJB descriptor name: "" + descriptorName, Project.MSG_VERBOSE);
        log(""JOnAS-specific descriptor name: "" + jonasDN, Project.MSG_VERBOSE);

        return jonasDN;
    }

    
    protected String getJarBaseName(String descriptorFileName) {

        String baseName = null;

        if (getConfig().namingScheme.getValue().equals(EjbJar.NamingScheme.DESCRIPTOR)) {

            
            if (descriptorFileName.indexOf(getConfig().baseNameTerminator) == -1) {

                
                
                
                

                String aCanonicalDescriptor = descriptorFileName.replace('\\', '/');
                int lastSeparatorIndex = aCanonicalDescriptor.lastIndexOf('/');
                int endOfBaseName;

                if (lastSeparatorIndex != -1) {
                    endOfBaseName = descriptorFileName.indexOf("".xml"", lastSeparatorIndex);
                } else {
                    endOfBaseName = descriptorFileName.indexOf("".xml"");
                }

                if (endOfBaseName != -1) {
                    baseName = descriptorFileName.substring(0, endOfBaseName);
                }
            }
        }

        if (baseName == null) {
            
            baseName = super.getJarBaseName(descriptorFileName);
        }

        log(""JAR base name: "" + baseName, Project.MSG_VERBOSE);

        return baseName;
    }

    
    protected void registerKnownDTDs(DescriptorHandler handler) {
        handler.registerDTD(EJB_JAR_1_1_PUBLIC_ID,
                    jonasroot + File.separator + ""xml"" + File.separator + EJB_JAR_1_1_DTD);
        handler.registerDTD(EJB_JAR_2_0_PUBLIC_ID,
                    jonasroot + File.separator + ""xml"" + File.separator + EJB_JAR_2_0_DTD);

        handler.registerDTD(JONAS_EJB_JAR_2_4_PUBLIC_ID,
                    jonasroot + File.separator + ""xml"" + File.separator + JONAS_EJB_JAR_2_4_DTD);
        handler.registerDTD(JONAS_EJB_JAR_2_5_PUBLIC_ID,
                    jonasroot + File.separator + ""xml"" + File.separator + JONAS_EJB_JAR_2_5_DTD);
    }

    
    private void addGenICGeneratedFiles(
        File genericJarFile, Hashtable ejbFiles) {
        Java genicTask = null;    
        String genicClass = null; 
                                  
        if (nogenic) {
            return;
        }

        genicTask = new Java(getTask());
        genicTask.setTaskName(""genic"");
        genicTask.setFork(true);

        
        genicTask.createJvmarg().setValue(""-Dinstall.root="" + jonasroot);

        
        String jonasConfigDir = jonasroot + File.separator + ""config"";
        File javaPolicyFile = new File(jonasConfigDir, ""java.policy"");
        if (javaPolicyFile.exists()) {
            genicTask.createJvmarg().setValue(""-Djava.security.policy=""
                              + javaPolicyFile.toString());
        }

        
        try {
            outputdir = createTempDir();
        } catch (IOException aIOException) {
            String msg = ""Cannot create temp dir: "" + aIOException.getMessage();
            throw new BuildException(msg, aIOException);
        }
        log(""Using temporary output directory: "" + outputdir, Project.MSG_VERBOSE);

        genicTask.createArg().setValue(""-d"");
        genicTask.createArg().setFile(outputdir);

        
        String key;
        File f;
        Enumeration keys = ejbFiles.keys();
        while (keys.hasMoreElements()) {
            key = (String) keys.nextElement();
            f = new File(outputdir + File.separator + key);
            f.getParentFile().mkdirs();
        }
        log(""Worked around a bug of GenIC 2.5."", Project.MSG_VERBOSE);

        
        Path classpath = getCombinedClasspath();
        if (classpath == null) {
            classpath = new Path(getTask().getProject());
        }
        classpath.append(new Path(classpath.getProject(), jonasConfigDir));
        classpath.append(new Path(classpath.getProject(), outputdir.toString()));

        
        if (orb != null) {
            String orbJar = jonasroot + File.separator + ""lib""
                + File.separator + orb + ""_jonas.jar"";
            classpath.append(new Path(classpath.getProject(), orbJar));
        }
        log(""Using classpath: "" + classpath.toString(), Project.MSG_VERBOSE);
        genicTask.setClasspath(classpath);

        
        genicClass = getGenicClassName(classpath);
        if (genicClass == null) {
            log(""Cannot find GenIC class in classpath."", Project.MSG_ERR);
            throw new BuildException(""GenIC class not found, please check the classpath."");
        } else {
            log(""Using '"" + genicClass + ""' GenIC class."" , Project.MSG_VERBOSE);
            genicTask.setClassname(genicClass);
        }

        
        if (keepgenerated) {
            genicTask.createArg().setValue(""-keepgenerated"");
        }

        
        if (nocompil) {
            genicTask.createArg().setValue(""-nocompil"");
        }

        
        if (novalidation) {
            genicTask.createArg().setValue(""-novalidation"");
        }

        
        if (javac != null) {
            genicTask.createArg().setValue(""-javac"");
            genicTask.createArg().setLine(javac);
        }

        
        if (javacopts != null && !javacopts.equals("""")) {
            genicTask.createArg().setValue(""-javacopts"");
            genicTask.createArg().setLine(javacopts);
        }

        
        if (rmicopts != null && !rmicopts.equals("""")) {
            genicTask.createArg().setValue(""-rmicopts"");
            genicTask.createArg().setLine(rmicopts);
        }

        
        if (secpropag) {
            genicTask.createArg().setValue(""-secpropag"");
        }

        
        if (verbose) {
            genicTask.createArg().setValue(""-verbose"");
        }

        
        if (additionalargs != null) {
            genicTask.createArg().setValue(additionalargs);
        }

        
        
        genicTask.createArg().setValue(""-noaddinjar"");

        
        genicTask.createArg().setValue(genericJarFile.getPath());

        
        log(""Calling "" + genicClass + "" for "" + getConfig().descriptorDir
            + File.separator + descriptorName + ""."", Project.MSG_VERBOSE);

        if (genicTask.executeJava() != 0) {

            
            log(""Deleting temp output directory '"" + outputdir + ""'."", Project.MSG_VERBOSE);
            deleteAllFiles(outputdir);

            if (!keepgeneric) {
                log(""Deleting generic JAR "" + genericJarFile.toString(),
                    Project.MSG_VERBOSE);
                genericJarFile.delete();
            }

            throw new BuildException(""GenIC reported an error."");
        }

        
        addAllFiles(outputdir, """", ejbFiles);
    }

    
    String getGenicClassName(Path classpath) {

        log(""Looking for GenIC class in classpath: ""
            + classpath.toString(), Project.MSG_VERBOSE);

        AntClassLoader cl = classpath.getProject().createClassLoader(classpath);

        try {
            cl.loadClass(JonasDeploymentTool.GENIC_CLASS);
            log(""Found GenIC class '"" + JonasDeploymentTool.GENIC_CLASS
                + ""' in classpath."", Project.MSG_VERBOSE);
            return JonasDeploymentTool.GENIC_CLASS;

        } catch (ClassNotFoundException cnf1) {
            log(""GenIC class '"" + JonasDeploymentTool.GENIC_CLASS
                + ""' not found in classpath."",
            Project.MSG_VERBOSE);
        }

        try {
            cl.loadClass(JonasDeploymentTool.OLD_GENIC_CLASS_1);
            log(""Found GenIC class '"" + JonasDeploymentTool.OLD_GENIC_CLASS_1
                + ""' in classpath."", Project.MSG_VERBOSE);
            return JonasDeploymentTool.OLD_GENIC_CLASS_1;

        } catch (ClassNotFoundException cnf2) {
            log(""GenIC class '"" + JonasDeploymentTool.OLD_GENIC_CLASS_1
                + ""' not found in classpath."",
            Project.MSG_VERBOSE);
        }

        try {
            cl.loadClass(JonasDeploymentTool.OLD_GENIC_CLASS_2);
            log(""Found GenIC class '"" + JonasDeploymentTool.OLD_GENIC_CLASS_2
                + ""' in classpath."", Project.MSG_VERBOSE);
            return JonasDeploymentTool.OLD_GENIC_CLASS_2;

        } catch (ClassNotFoundException cnf3) {
            log(""GenIC class '"" + JonasDeploymentTool.OLD_GENIC_CLASS_2
                + ""' not found in classpath."",
            Project.MSG_VERBOSE);
        }
        return null;
    }

    
    protected void checkConfiguration(String descriptorFileName,
                      SAXParser saxParser) throws BuildException {

        
        if (jonasroot == null) {
            throw new BuildException(""The jonasroot attribut is not set."");
        } else if (!jonasroot.isDirectory()) {
            throw new BuildException(""The jonasroot attribut '"" + jonasroot
                + ""' is not a valid directory."");
        }

        
        if (orb != null && !orb.equals(RMI_ORB) && !orb.equals(JEREMIE_ORB)
            && !orb.equals(DAVID_ORB)) {
            throw new BuildException(""The orb attribut '"" + orb
                + ""' is not valid (must be either ""
                + RMI_ORB + "", "" + JEREMIE_ORB + "" or "" + DAVID_ORB + "")."");
        }

        
        if (additionalargs != null && additionalargs.equals("""")) {
            throw new BuildException(""Empty additionalargs attribut."");
        }

        
        if (javac != null && javac.equals("""")) {
            throw new BuildException(""Empty javac attribut."");
        }
    }

    
    
    

    
    private File createTempDir() throws IOException {
        File tmpDir = File.createTempFile(""genic"", null, null);
        tmpDir.delete();
        if (!tmpDir.mkdir()) {
            throw new IOException(""Cannot create the temporary directory '"" + tmpDir + ""'."");
        }
        return tmpDir;
    }

    
    private void deleteAllFiles(File aFile) {
        if (aFile.isDirectory()) {
            File[] someFiles = aFile.listFiles();

            for (int i = 0; i < someFiles.length; i++) {
                deleteAllFiles(someFiles[i]);
            }
        }
        aFile.delete();
    }

    
    private void addAllFiles(File file, String rootDir, Hashtable hashtable) {

        if (!file.exists()) {
            throw new IllegalArgumentException();
        }

        String newRootDir;
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                if (rootDir.length() > 0) {
                    newRootDir = rootDir + File.separator + files[i].getName();
                } else {
                    newRootDir = files[i].getName();
                }
                addAllFiles(files[i], newRootDir, hashtable);
            }
        } else {
            hashtable.put(rootDir, file);
        }
    }
}
"
org.apache.tools.tar.TarConstants,0,1,0,1,0,0,1,0,0,2.0,25,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"



package org.apache.tools.tar;



public interface TarConstants {

    
    int    NAMELEN = 100;

    
    int    MODELEN = 8;

    
    int    UIDLEN = 8;

    
    int    GIDLEN = 8;

    
    int    CHKSUMLEN = 8;

    
    int    SIZELEN = 12;

    
    long   MAXSIZE = 077777777777L;

    
    int    MAGICLEN = 8;

    
    int    MODTIMELEN = 12;

    
    int    UNAMELEN = 32;

    
    int    GNAMELEN = 32;

    
    int    DEVLEN = 8;

    
    byte   LF_OLDNORM = 0;

    
    byte   LF_NORMAL = (byte) '0';

    
    byte   LF_LINK = (byte) '1';

    
    byte   LF_SYMLINK = (byte) '2';

    
    byte   LF_CHR = (byte) '3';

    
    byte   LF_BLK = (byte) '4';

    
    byte   LF_DIR = (byte) '5';

    
    byte   LF_FIFO = (byte) '6';

    
    byte   LF_CONTIG = (byte) '7';

    
    String TMAGIC = ""ustar"";

    
    String GNU_TMAGIC = ""ustar  "";

    
    String GNU_LONGLINK = ""././@LongLink"";

    
    byte LF_GNUTYPE_LONGNAME = (byte) 'L';
}
"
org.apache.tools.ant.taskdefs.compilers.Sj,3,2,0,5,12,3,1,4,2,2.0,44,0.0,0,0.92,1.0,1,1,13.66666667,1,0.6667,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;


public class Sj extends DefaultCompilerAdapter {

    
    public boolean execute() throws BuildException {
        attributes.log(""Using symantec java compiler"", Project.MSG_VERBOSE);

        Commandline cmd = setupJavacCommand();
        String exec = getJavac().getExecutable();
        cmd.setExecutable(exec == null ? ""sj"" : exec);

        int firstFileName = cmd.size() - compileList.length;

        return
            executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
    }

    
    protected String getNoDebugArgument() {
        return null;
    }
}

"
org.apache.tools.ant.taskdefs.optional.perforce.P4Delete,3,4,0,4,10,0,0,4,3,0.0,55,0.0,0,0.962264151,0.666666667,1,1,17.0,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;


public class P4Delete extends P4Base {

    
    
    public String change = null;
    

    
    public void setChange(String change) {
        this.change = change;
    }

    
    public void execute() throws BuildException {
        if (change != null) {
            P4CmdOpts = ""-c "" + change;
        }
        if (P4View == null) {
            throw new BuildException(""No view specified to delete"");
        }
        execP4Command(""-s delete "" + P4CmdOpts + "" "" + P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.optional.EchoProperties,14,3,0,10,90,63,1,10,9,0.923076923,615,1.0,0,0.74,0.222222222,1,1,42.14285714,3,1.2857,0,"
package org.apache.tools.ant.taskdefs.optional;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Iterator;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.PropertySet;
import org.apache.tools.ant.util.CollectionUtils;
import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;


public class EchoProperties extends Task {

    
    private static final String PROPERTIES = ""properties"";

    
    private static final String PROPERTY = ""property"";

    
    private static final String ATTR_NAME = ""name"";

    
    private static final String ATTR_VALUE = ""value"";

    
    private File inFile = null;

    
    private File destfile = null;

    
    private boolean failonerror = true;

    private Vector propertySets = new Vector();

    private String format = ""text"";

    private String prefix;

    
    private String regex;

    
    public void setSrcfile(File file) {
        inFile = file;
    }

    
    public void setDestfile(File destfile) {
        this.destfile = destfile;
    }


    
    public void setFailOnError(boolean failonerror) {
        this.failonerror = failonerror;
    }


    
    public void setPrefix(String prefix) {
        if (prefix != null && prefix.length() != 0) {
            this.prefix = prefix;
            PropertySet ps = new PropertySet();
            ps.setProject(getProject());
            ps.appendPrefix(prefix);
            addPropertyset(ps);
        }
    }

    
    public void setRegex(String regex) {
        if (regex != null && regex.length() != 0) {
            this.regex = regex;
            PropertySet ps = new PropertySet();
            ps.setProject(getProject());
            ps.appendRegex(regex);
            addPropertyset(ps);
        }
    }

    
    public void addPropertyset(PropertySet ps) {
        propertySets.addElement(ps);
    }

    
    public void setFormat(FormatAttribute ea) {
        format = ea.getValue();
    }

    
    public static class FormatAttribute extends EnumeratedAttribute {
        private String [] formats = new String[]{""xml"", ""text""};

        
        public String[] getValues() {
            return formats;
        }
    }

    
    public void execute() throws BuildException {
        if (prefix != null && regex != null) {
            throw new BuildException(""Please specify either prefix""
                    + "" or regex, but not both"", getLocation());
        }
        
        Hashtable allProps = new Hashtable();

        
        if (inFile == null && propertySets.size() == 0) {
            
            allProps.putAll(getProject().getProperties());
        } else if (inFile != null) {
            if (inFile.exists() && inFile.isDirectory()) {
                String message = ""srcfile is a directory!"";
                if (failonerror) {
                    throw new BuildException(message, getLocation());
                } else {
                    log(message, Project.MSG_ERR);
                }
                return;
            }

            if (inFile.exists() && !inFile.canRead()) {
                String message = ""Can not read from the specified srcfile!"";
                if (failonerror) {
                    throw new BuildException(message, getLocation());
                } else {
                    log(message, Project.MSG_ERR);
                }
                return;
            }

            FileInputStream in = null;
            try {
                in = new FileInputStream(inFile);
                Properties props = new Properties();
                props.load(in);
                allProps.putAll(props);
            } catch (FileNotFoundException fnfe) {
                String message =
                    ""Could not find file "" + inFile.getAbsolutePath();
                if (failonerror) {
                    throw new BuildException(message, fnfe, getLocation());
                } else {
                    log(message, Project.MSG_WARN);
                }
                return;
            } catch (IOException ioe) {
                String message =
                    ""Could not read file "" + inFile.getAbsolutePath();
                if (failonerror) {
                    throw new BuildException(message, ioe, getLocation());
                } else {
                    log(message, Project.MSG_WARN);
                }
                return;
            } finally {
                FileUtils.close(in);
            }
        }

        Enumeration e = propertySets.elements();
        while (e.hasMoreElements()) {
            PropertySet ps = (PropertySet) e.nextElement();
            allProps.putAll(ps.getProperties());
        }

        OutputStream os = null;
        try {
            if (destfile == null) {
                os = new ByteArrayOutputStream();
                saveProperties(allProps, os);
                log(os.toString(), Project.MSG_INFO);
            } else {
                if (destfile.exists() && destfile.isDirectory()) {
                    String message = ""destfile is a directory!"";
                    if (failonerror) {
                        throw new BuildException(message, getLocation());
                    } else {
                        log(message, Project.MSG_ERR);
                    }
                    return;
                }

                if (destfile.exists() && !destfile.canWrite()) {
                    String message =
                        ""Can not write to the specified destfile!"";
                    if (failonerror) {
                        throw new BuildException(message, getLocation());
                    } else {
                        log(message, Project.MSG_ERR);
                    }
                    return;
                }
                os = new FileOutputStream(this.destfile);
                saveProperties(allProps, os);
            }
        } catch (IOException ioe) {
            if (failonerror) {
                throw new BuildException(ioe, getLocation());
            } else {
                log(ioe.getMessage(), Project.MSG_INFO);
            }
        } finally {
            if (os != null) {
                try {
                    os.close();
                } catch (IOException ex) {
                    
                }
            }
        }
    }


    
    protected void saveProperties(Hashtable allProps, OutputStream os)
        throws IOException, BuildException {
        final List keyList = new ArrayList(allProps.keySet());
        Collections.sort(keyList);
        Properties props = new Properties() {
            public Enumeration keys() {
                return CollectionUtils.asEnumeration(keyList.iterator());
            }
            public Set entrySet() {
                Set result = super.entrySet();
                if (JavaEnvUtils.isKaffe()) {
                    TreeSet t = new TreeSet(new Comparator() {
                        public int compare(Object o1, Object o2) {
                            String key1 = (String) ((Map.Entry) o1).getKey();
                            String key2 = (String) ((Map.Entry) o2).getKey();
                            return key1.compareTo(key2);
                        }
                    });
                    t.addAll(result);
                    result = t;
                }
                return result;
            }
        };
        for (int i = 0; i < keyList.size(); i++) {
            String name = keyList.get(i).toString();
            String value = allProps.get(name).toString();
            props.setProperty(name, value);
        }
        if (""text"".equals(format)) {
            jdkSaveProperties(props, os, ""Ant properties"");
        } else if (""xml"".equals(format)) {
            xmlSaveProperties(props, os);
        }
    }

    
    private static class Tuple implements Comparable {
        private String key;
        private String value;

        private Tuple(String key, String value) {
            this.key = key;
            this.value = value;
        }

        
        public int compareTo(Object o) {
            Tuple that = (Tuple) o;
            return key.compareTo(that.key);
        }
    }

    private List sortProperties(Properties props) {
        
        List sorted = new ArrayList(props.size());
        Enumeration e = props.propertyNames();
        while (e.hasMoreElements()) {
            String name = (String) e.nextElement();
            sorted.add(new Tuple(name, props.getProperty(name)));
        }
        Collections.sort(sorted);
        return sorted;
    }

    
    protected void xmlSaveProperties(Properties props,
                                     OutputStream os) throws IOException {
        
        Document doc = getDocumentBuilder().newDocument();
        Element rootElement = doc.createElement(PROPERTIES);

        List sorted = sortProperties(props);


        
        Iterator iten = sorted.iterator();
        while (iten.hasNext()) {
            Tuple tuple = (Tuple) iten.next();
            Element propElement = doc.createElement(PROPERTY);
            propElement.setAttribute(ATTR_NAME, tuple.key);
            propElement.setAttribute(ATTR_VALUE, tuple.value);
            rootElement.appendChild(propElement);
        }

        Writer wri = null;
        try {
            wri = new OutputStreamWriter(os, ""UTF8"");
            wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
            (new DOMElementWriter()).write(rootElement, wri, 0, ""\t"");
            wri.flush();
        } catch (IOException ioe) {
            throw new BuildException(""Unable to write XML file"", ioe);
        } finally {
            FileUtils.close(wri);
        }
    }

    
    protected void jdkSaveProperties(Properties props, OutputStream os,
                                     String header) throws IOException {
       try {
           props.store(os, header);

       } catch (IOException ioe) {
           throw new BuildException(ioe, getLocation());
       } finally {
           if (os != null) {
               try {
                   os.close();
               } catch (IOException ioex) {
                   log(""Failed to close output stream"");
               }
           }
       }
    }


    
    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }
}

"
org.apache.tools.ant.taskdefs.condition.Http,4,2,0,4,15,0,1,3,4,0.666666667,105,1.0,0,0.75,0.5,0,0,24.5,1,0.75,0,"

package org.apache.tools.ant.taskdefs.condition;

import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;


public class Http extends ProjectComponent implements Condition {
    private static final int ERROR_BEGINS = 400;
    private String spec = null;

    
    public void setUrl(String url) {
        spec = url;
    }

    private int errorsBeginAt = ERROR_BEGINS;

    
    public void setErrorsBeginAt(int errorsBeginAt) {
        this.errorsBeginAt = errorsBeginAt;
    }

    
    public boolean eval() throws BuildException {
        if (spec == null) {
            throw new BuildException(""No url specified in http condition"");
        }
        log(""Checking for "" + spec, Project.MSG_VERBOSE);
        try {
            URL url = new URL(spec);
            try {
                URLConnection conn = url.openConnection();
                if (conn instanceof HttpURLConnection) {
                    HttpURLConnection http = (HttpURLConnection) conn;
                    int code = http.getResponseCode();
                    log(""Result code for "" + spec + "" was "" + code,
                        Project.MSG_VERBOSE);
                    if (code > 0 && code < errorsBeginAt) {
                        return true;
                    }
                    return false;
                }
            } catch (java.io.IOException e) {
                return false;
            }
        } catch (MalformedURLException e) {
            throw new BuildException(""Badly formed URL: "" + spec, e);
        }
        return true;
    }
}
"
org.apache.tools.ant.taskdefs.Rename,6,3,0,5,21,3,0,5,5,0.75,104,1.0,1,0.902439024,0.533333333,1,1,15.66666667,1,0.6667,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;


public class Rename extends Task {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private File src;
    private File dest;
    private boolean replace = true;


    
    public void setSrc(File src) {
        this.src = src;
    }

    
    public void setDest(File dest) {
        this.dest = dest;
    }

    
    public void setReplace(String replace) {
        this.replace = Project.toBoolean(replace);
    }


    
    public void execute() throws BuildException {
        log(""DEPRECATED - The rename task is deprecated.  Use move instead."");

        if (dest == null) {
            throw new BuildException(""dest attribute is required"", getLocation());
        }

        if (src == null) {
            throw new BuildException(""src attribute is required"", getLocation());
        }

        if (!replace && dest.exists()) {
            throw new BuildException(dest + "" already exists."");
        }

        try {
            FILE_UTILS.rename(src, dest);
        } catch (IOException e) {
            throw new BuildException(""Unable to rename "" + src + "" to ""
                + dest, e, getLocation());
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.ClassFileIterator,1,1,0,3,1,0,2,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend;


public interface ClassFileIterator {

    
    ClassFile getNextClassFile();
}

"
org.apache.tools.ant.taskdefs.Jikes,2,1,0,6,30,0,0,6,0,0.0,182,1.0,2,0.0,0.6,0,0,88.5,9,4.5,0,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Random;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;


public class Jikes {

    
    protected JikesOutputParser jop;
    protected String command;
    protected Project project;
    

    
    protected Jikes(JikesOutputParser jop, String command, Project project) {
        super();

        System.err.println(""As of Ant 1.2 released in October 2000, ""
            + ""the Jikes class"");
        System.err.println(""is considered to be dead code by the Ant ""
            + ""developers and is unmaintained."");
        System.err.println(""Don\'t use it!"");

        this.jop = jop;
        this.command = command;
        this.project = project;
    }

    
    protected void compile(String[] args) {
        String[] commandArray = null;
        File tmpFile = null;

        try {
            String myos = System.getProperty(""os.name"");

            
            

            
            
            if (myos.toLowerCase().indexOf(""windows"") >= 0
                && args.length > 250) {
                PrintWriter out = null;
                try {
                    String tempFileName = ""jikes""
                        + (new Random(System.currentTimeMillis())).nextLong();
                    tmpFile = new File(tempFileName);
                    out = new PrintWriter(new FileWriter(tmpFile));
                    for (int i = 0; i < args.length; i++) {
                        out.println(args[i]);
                    }
                    out.flush();
                    commandArray = new String[] {command,
                                               ""@"" + tmpFile.getAbsolutePath()};
                } catch (IOException e) {
                    throw new BuildException(""Error creating temporary file"",
                                             e);
                } finally {
                    FileUtils.close(out);
                }
            } else {
                commandArray = new String[args.length + 1];
                commandArray[0] = command;
                System.arraycopy(args, 0, commandArray, 1, args.length);
            }

            
            
            
            
            try {
                Execute exe = new Execute(jop);
                exe.setAntRun(project);
                exe.setWorkingDirectory(project.getBaseDir());
                exe.setCommandline(commandArray);
                exe.execute();
            } catch (IOException e) {
                throw new BuildException(""Error running Jikes compiler"", e);
            }
        } finally {
            if (tmpFile != null) {
                tmpFile.delete();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPoolEntry,7,1,7,14,24,11,10,12,7,1.083333333,124,0.214285714,0,0.0,0.357142857,0,0,14.71428571,1,0.8571,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public abstract class ConstantPoolEntry {

    
    public static final int CONSTANT_UTF8 = 1;

    
    public static final int CONSTANT_INTEGER = 3;

    
    public static final int CONSTANT_FLOAT = 4;

    
    public static final int CONSTANT_LONG = 5;

    
    public static final int CONSTANT_DOUBLE = 6;

    
    public static final int CONSTANT_CLASS = 7;

    
    public static final int CONSTANT_STRING = 8;

    
    public static final int CONSTANT_FIELDREF = 9;

    
    public static final int CONSTANT_METHODREF = 10;

    
    public static final int CONSTANT_INTERFACEMETHODREF = 11;

    
    public static final int CONSTANT_NAMEANDTYPE = 12;

    
    private int tag;

    
    private int numEntries;

    
    private boolean resolved;

    
    public ConstantPoolEntry(int tagValue, int entries) {
        tag = tagValue;
        numEntries = entries;
        resolved = false;
    }

    
    public static ConstantPoolEntry readEntry(DataInputStream cpStream)
         throws IOException {
        ConstantPoolEntry cpInfo = null;
        int cpTag = cpStream.readUnsignedByte();

        switch (cpTag) {

            case CONSTANT_UTF8:
                cpInfo = new Utf8CPInfo();

                break;
            case CONSTANT_INTEGER:
                cpInfo = new IntegerCPInfo();

                break;
            case CONSTANT_FLOAT:
                cpInfo = new FloatCPInfo();

                break;
            case CONSTANT_LONG:
                cpInfo = new LongCPInfo();

                break;
            case CONSTANT_DOUBLE:
                cpInfo = new DoubleCPInfo();

                break;
            case CONSTANT_CLASS:
                cpInfo = new ClassCPInfo();

                break;
            case CONSTANT_STRING:
                cpInfo = new StringCPInfo();

                break;
            case CONSTANT_FIELDREF:
                cpInfo = new FieldRefCPInfo();

                break;
            case CONSTANT_METHODREF:
                cpInfo = new MethodRefCPInfo();

                break;
            case CONSTANT_INTERFACEMETHODREF:
                cpInfo = new InterfaceMethodRefCPInfo();

                break;
            case CONSTANT_NAMEANDTYPE:
                cpInfo = new NameAndTypeCPInfo();

                break;
            default:
                throw new ClassFormatError(""Invalid Constant Pool entry Type ""
                     + cpTag);
        }

        cpInfo.read(cpStream);

        return cpInfo;
    }

    
    public boolean isResolved() {
        return resolved;
    }

    
    public void resolve(ConstantPool constantPool) {
        resolved = true;
    }

    
    public abstract void read(DataInputStream cpStream) throws IOException;

    
    public int getTag() {
        return tag;
    }

    
    public final int getNumEntries() {
        return numEntries;
    }

}

"
org.apache.tools.ant.taskdefs.optional.perforce.P4OutputStream,4,2,0,2,12,0,1,1,3,0.222222222,68,1.0,1,0.625,0.5,1,1,15.25,1,0.75,0,"

package org.apache.tools.ant.taskdefs.optional.perforce;

import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;


public class P4OutputStream extends OutputStream {
    private P4Handler handler;
    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    private boolean skip = false;

    
    public P4OutputStream(P4Handler handler) {
        this.handler = handler;
    }

    
    public void write(int cc) throws IOException {
        final byte c = (byte) cc;
        if ((c == '\n') || (c == '\r')) {
            if (!skip) {
                processBuffer();
            }
        } else {
            buffer.write(cc);
        }
        skip = (c == '\r');
    }


    
    protected void processBuffer() {
        handler.process(buffer.toString());
        buffer.reset();
    }

    
    public void close() throws IOException {
        if (buffer.size() > 0) {
            processBuffer();
        }
        super.close();
    }

}


"
org.apache.tools.ant.taskdefs.condition.Matches,8,2,0,6,15,6,0,6,8,0.742857143,122,1.0,1,0.5625,0.4375,0,0,13.625,2,1.125,0,"
package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.util.regexp.Regexp;
import org.apache.tools.ant.types.RegularExpression;
import org.apache.tools.ant.util.regexp.RegexpMatcher;


public class Matches extends ProjectComponent implements Condition {

    private String  string;
    private boolean caseSensitive = true;
    private boolean multiLine = false;
    private boolean singleLine = false;
    private RegularExpression regularExpression;

    
    public void setString(String string) {
        this.string = string;
    }

    
    public void setPattern(String pattern) {
        if (regularExpression != null) {
            throw new BuildException(
                ""Only one regular expression is allowed."");
        }
        regularExpression = new RegularExpression();
        regularExpression.setPattern(pattern);
    }

    
    public void addRegexp(RegularExpression regularExpression) {
        if (this.regularExpression != null) {
            throw new BuildException(
                ""Only one regular expression is allowed."");
        }
        this.regularExpression = regularExpression;
    }

    
    public void setCasesensitive(boolean b) {
        caseSensitive = b;
    }

    
    public void setMultiline(boolean b) {
        multiLine = b;
    }

    
    public void setSingleLine(boolean b) {
        singleLine = b;
    }

    
    public boolean eval() throws BuildException {
        if (string == null) {
            throw new BuildException(
                ""Parameter string is required in matches."");
        }
        if (regularExpression == null) {
            throw new BuildException(""Missing pattern in matches."");
        }
        int options = RegexpMatcher.MATCH_DEFAULT;
        if (!caseSensitive) {
            options = options | RegexpMatcher.MATCH_CASE_INSENSITIVE;
        }
        if (multiLine) {
            options = options | RegexpMatcher.MATCH_MULTILINE;
        }
        if (singleLine) {
            options = options | RegexpMatcher.MATCH_SINGLELINE;
        }
        Regexp regexp = regularExpression.getRegexp(getProject());
        return regexp.matches(string, options);
    }
}
"
org.apache.tools.ant.taskdefs.Exec,10,3,0,5,45,21,1,5,7,0.740740741,359,1.0,0,0.804347826,0.45,0,0,34.3,2,1.1,0,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;


public class Exec extends Task {
    private String os;
    private String out;
    private File dir;
    private String command;
    
    protected PrintWriter fos = null;
    
    private boolean failOnError = false;

    
    public Exec() {
        System.err.println(""As of Ant 1.2 released in October 2000, ""
            + ""the Exec class"");
        System.err.println(""is considered to be dead code by the Ant ""
            + ""developers and is unmaintained."");
        System.err.println(""Don\'t use it!"");
    }

    
    public void execute() throws BuildException {
        run(command);
    }

    
    protected int run(String command) throws BuildException {

        int err = -1; 

        
        String myos = System.getProperty(""os.name"");
        log(""Myos = "" + myos, Project.MSG_VERBOSE);
        if ((os != null) && (os.indexOf(myos) < 0)) {
            
            log(""Not found in "" + os, Project.MSG_VERBOSE);
            return 0;
        }

        
        if (dir == null) {
          dir = getProject().getBaseDir();
        }

        if (myos.toLowerCase().indexOf(""windows"") >= 0) {
            if (!dir.equals(getProject().resolveFile("".""))) {
                if (myos.toLowerCase().indexOf(""nt"") >= 0) {
                    command = ""cmd /c cd "" + dir + "" && "" + command;
                } else {
                    String ant = getProject().getProperty(MagicNames.ANT_HOME);
                    if (ant == null) {
                        throw new BuildException(""Property '"" + MagicNames.ANT_HOME + ""' not ""
                            + ""found"", getLocation());
                    }

                    String antRun = getProject().resolveFile(ant + ""/bin/antRun.bat"").toString();
                    command = antRun + "" "" + dir + "" "" + command;
                }
            }
        } else {
            String ant = getProject().getProperty(MagicNames.ANT_HOME);
            if (ant == null) {
              throw new BuildException(""Property '"" + MagicNames.ANT_HOME + ""' not found"",
                                       getLocation());
            }
            String antRun = getProject().resolveFile(ant + ""/bin/antRun"").toString();

            command = antRun + "" "" + dir + "" "" + command;
        }

        try {
            
            log(command, Project.MSG_VERBOSE);

            
            Process proc = Runtime.getRuntime().exec(command);

            if (out != null)  {
                fos = new PrintWriter(new FileWriter(out));
                log(""Output redirected to "" + out, Project.MSG_VERBOSE);
            }

            
            StreamPumper inputPumper =
                new StreamPumper(proc.getInputStream(), Project.MSG_INFO);
            StreamPumper errorPumper =
                new StreamPumper(proc.getErrorStream(), Project.MSG_WARN);

            
            inputPumper.start();
            errorPumper.start();

            
            proc.waitFor();
            inputPumper.join();
            errorPumper.join();
            proc.destroy();

            
            logFlush();

            
            err = proc.exitValue();
            if (err != 0) {
                if (failOnError) {
                    throw new BuildException(""Exec returned: "" + err, getLocation());
                } else {
                    log(""Result: "" + err, Project.MSG_ERR);
                }
            }
        } catch (IOException ioe) {
            throw new BuildException(""Error exec: "" + command, ioe, getLocation());
        } catch (InterruptedException ex) {
            
        }

        return err;
    }

    
    public void setDir(String d) {
        this.dir = getProject().resolveFile(d);
    }

    
    public void setOs(String os) {
        this.os = os;
    }

    
    public void setCommand(String command) {
        this.command = command;
    }

    
    public void setOutput(String out) {
        this.out = out;
    }

    
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }

    
    protected void outputLog(String line, int messageLevel) {
        if (fos == null) {
            log(line, messageLevel);
        } else {
            fos.println(line);
        }
    }

    
    protected void logFlush() {
        if (fos != null) {
          fos.close();
        }
    }

    
    
    class StreamPumper extends Thread {
        private BufferedReader din;
        private int messageLevel;
        private boolean endOfStream = false;
        private static final int SLEEP_TIME = 5;

        public StreamPumper(InputStream is, int messageLevel) {
            this.din = new BufferedReader(new InputStreamReader(is));
            this.messageLevel = messageLevel;
        }

        public void pumpStream() throws IOException {
            if (!endOfStream) {
                String line = din.readLine();

                if (line != null) {
                    outputLog(line, messageLevel);
                } else {
                    endOfStream = true;
                }
            }
        }

        public void run() {
            try {
                try {
                    while (!endOfStream) {
                        pumpStream();
                        sleep(SLEEP_TIME);
                    }
                } catch (InterruptedException ie) {
                    
                }
                din.close();
            } catch (IOException ioe) {
                
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.jsp.compilers.JspCompilerAdapter,4,1,0,5,4,6,3,3,4,2.0,4,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.jsp.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.optional.jsp.JspC;
import org.apache.tools.ant.taskdefs.optional.jsp.JspMangler;



public interface JspCompilerAdapter {

    
    void setJspc(JspC attributes);

    
    boolean execute() throws BuildException;

    

    JspMangler createMangler();

    
    boolean implementsOwnDependencyChecking();
}
"
org.apache.tools.ant.util.TaskLogger,6,1,0,1,8,0,0,1,6,0.0,43,1.0,1,0.0,0.666666667,0,0,6.0,1,0.8333,0,"
package org.apache.tools.ant.util;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;


public final class TaskLogger {
    
    private Task task;

    
    public TaskLogger(final Task task) {
        this.task = task;
    }

    
    public void info(final String message) {
        task.log(message, Project.MSG_INFO);
    }

    
    public void error(final String message) {
        task.log(message, Project.MSG_ERR);
    }

    
    public void warning(final String message) {
        task.log(message, Project.MSG_WARN);
    }

    
    public void verbose(final String message) {
        task.log(message, Project.MSG_VERBOSE);
    }

    
    public void debug(final String message) {
        task.log(message, Project.MSG_DEBUG);
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter,13,1,0,7,40,58,0,7,11,0.833333333,292,1.0,0,0.0,0.32967033,0,0,20.92307692,10,1.8462,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.NumberFormat;

import junit.framework.AssertionFailedError;
import junit.framework.Test;

import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;


public class BriefJUnitResultFormatter implements JUnitResultFormatter {

    
    private OutputStream out;

    
    private PrintWriter output;

    
    private StringWriter results;

    
    private PrintWriter resultWriter;

    
    private NumberFormat numberFormat = NumberFormat.getInstance();

    
    private String systemOutput = null;

    
    private String systemError = null;

    
    public BriefJUnitResultFormatter() {
        results = new StringWriter();
        resultWriter = new PrintWriter(results);
    }

    
    public void setOutput(OutputStream out) {
        this.out = out;
        output = new PrintWriter(out);
    }

    
    
    public void setSystemOutput(String out) {
        systemOutput = out;
    }

    
    
    public void setSystemError(String err) {
        systemError = err;
    }


    
    public void startTestSuite(JUnitTest suite) {
        if (output == null) {
            return; 
        }
        StringBuffer sb = new StringBuffer(""Testsuite: "");
        sb.append(suite.getName());
        sb.append(StringUtils.LINE_SEP);
        output.write(sb.toString());
        output.flush();
    }

    
    public void endTestSuite(JUnitTest suite) {
        StringBuffer sb = new StringBuffer(""Tests run: "");
        sb.append(suite.runCount());
        sb.append("", Failures: "");
        sb.append(suite.failureCount());
        sb.append("", Errors: "");
        sb.append(suite.errorCount());
        sb.append("", Time elapsed: "");
        sb.append(numberFormat.format(suite.getRunTime() / 1000.0));
        sb.append("" sec"");
        sb.append(StringUtils.LINE_SEP);
        sb.append(StringUtils.LINE_SEP);

        
        if (systemOutput != null && systemOutput.length() > 0) {
            sb.append(""------------- Standard Output ---------------"")
                    .append(StringUtils.LINE_SEP)
                    .append(systemOutput)
                    .append(""------------- ---------------- ---------------"")
                    .append(StringUtils.LINE_SEP);
        }

        if (systemError != null && systemError.length() > 0) {
            sb.append(""------------- Standard Error -----------------"")
                    .append(StringUtils.LINE_SEP)
                    .append(systemError)
                    .append(""------------- ---------------- ---------------"")
                    .append(StringUtils.LINE_SEP);
        }

        if (output != null) {
            try {
                output.write(sb.toString());
                resultWriter.close();
                output.write(results.toString());
                output.flush();
            } finally {
                if (out != System.out && out != System.err) {
                    FileUtils.close(out);
                }
            }
        }
    }

    
    public void startTest(Test test) {
    }

    
    public void endTest(Test test) {
    }

    
    public void addFailure(Test test, Throwable t) {
        formatError(""\tFAILED"", test, t);
    }

    
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }

    
    public void addError(Test test, Throwable error) {
        formatError(""\tCaused an ERROR"", test, error);
    }

    
    protected String formatTest(Test test) {
        if (test == null) {
            return ""Null Test: "";
        } else {
            return ""Testcase: "" + test.toString() + "":"";
        }
    }

    
    protected synchronized void formatError(String type, Test test,
                                            Throwable error) {
        if (test != null) {
            endTest(test);
        }

        resultWriter.println(formatTest(test) + type);
        resultWriter.println(error.getMessage());
        String strace = JUnitTestRunner.getFilteredTrace(error);
        resultWriter.println(strace);
        resultWriter.println();
    }
}
"
org.apache.tools.ant.taskdefs.condition.FilesMatch,6,1,0,4,15,3,1,3,5,0.75,70,1.0,1,0.0,0.533333333,0,0,10.0,1,0.6667,0,"
 package org.apache.tools.ant.taskdefs.condition;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;



public class FilesMatch implements Condition {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private File file1, file2;

    private boolean textfile = false;


    
    public void setFile1(File file1) {
        this.file1 = file1;
    }


    
    public void setFile2(File file2) {
        this.file2 = file2;
    }

    
    public void setTextfile(boolean textfile) {
        this.textfile = textfile;
    }

    
    public boolean eval()
        throws BuildException {

        
        if (file1 == null || file2 == null) {
            throw new BuildException(""both file1 and file2 are required in ""
                                     + ""filesmatch"");
        }

        
        boolean matches = false;
        try {
            matches = FILE_UTILS.contentEquals(file1, file2, textfile);
        } catch (IOException ioe) {
            throw new BuildException(""when comparing files: ""
                + ioe.getMessage(), ioe);
        }
        return matches;
    }
}

"
org.apache.tools.ant.taskdefs.optional.clearcase.CCRmtype,20,4,0,7,39,148,0,7,16,0.923076923,285,0.538461538,0,0.71641791,0.375,2,2,12.6,5,1.3,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCRmtype extends ClearCase {
    private String mTypeKind = null;
    private String mTypeName = null;
    private String mVOB = null;
    private String mComment = null;
    private String mCfile = null;
    private boolean mRmall = false;
    private boolean mIgnore = false;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        int result = 0;

        
        if (getTypeKind() == null) {
            throw new BuildException(""Required attribute TypeKind not specified"");
        }
        if (getTypeName() == null) {
            throw new BuildException(""Required attribute TypeName not specified"");
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_RMTYPE);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getTypeSpecifier(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getIgnore()) {
            
            cmd.createArgument().setValue(FLAG_IGNORE);
        }
        if (getRmAll()) {
            
            cmd.createArgument().setValue(FLAG_RMALL);
            cmd.createArgument().setValue(FLAG_FORCE);
        }
        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        
        cmd.createArgument().setValue(getTypeSpecifier());
    }

    
    public void setIgnore(boolean ignore) {
        mIgnore = ignore;
    }

    
    public boolean getIgnore() {
        return mIgnore;
    }

    
    public void setRmAll(boolean rmall) {
        mRmall = rmall;
    }

    
    public boolean getRmAll() {
        return mRmall;
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setTypeKind(String tk) {
        mTypeKind = tk;
    }

    
    public String getTypeKind() {
        return mTypeKind;
    }

    
    public void setTypeName(String tn) {
        mTypeName = tn;
    }

    
    public String getTypeName() {
        return mTypeName;
    }

    
    public void setVOB(String vob) {
        mVOB = vob;
    }

    
    public String getVOB() {
        return mVOB;
    }

    
    private String getTypeSpecifier() {
        String tkind = getTypeKind();
        String tname = getTypeName();
        String typeSpec = null;

        
        typeSpec = tkind + "":"" + tname;
        if (getVOB() != null) {
            typeSpec += ""@"" + getVOB();
        }
        return typeSpec;
    }

    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }


    
    public static final String FLAG_IGNORE = ""-ignore"";
    
    public static final String FLAG_RMALL = ""-rmall"";
    
    public static final String FLAG_FORCE = ""-force"";
    
    public static final String FLAG_COMMENT = ""-c"";
    
    public static final String FLAG_COMMENTFILE = ""-cfile"";
    
    public static final String FLAG_NOCOMMENT = ""-nc"";

}

"
org.apache.tools.ant.util.PackageNameMapper,2,2,0,1,6,1,0,1,1,2.0,20,0.0,0,0.875,0.75,1,1,9.0,1,0.5,0,"
package org.apache.tools.ant.util;

import java.io.File;


public class PackageNameMapper extends GlobPatternMapper {
    
    protected String extractVariablePart(String name) {
        String var = name.substring(prefixLength,
                name.length() - postfixLength);
        return var.replace(File.separatorChar, '.');
    }
}

"
org.apache.tools.ant.types.selectors.SelectorUtils,18,1,0,10,47,145,8,2,15,0.794117647,1004,1.0,2,0.0,0.18487395,0,0,54.66666667,47,6.7778,1,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.util.FileUtils;


public final class SelectorUtils {

    private static SelectorUtils instance = new SelectorUtils();
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private SelectorUtils() {
    }

    
    public static SelectorUtils getInstance() {
        return instance;
    }

    
    public static boolean matchPatternStart(String pattern, String str) {
        return matchPatternStart(pattern, str, true);
    }

    
    public static boolean matchPatternStart(String pattern, String str,
                                            boolean isCaseSensitive) {
        
        
        
        
        if (str.startsWith(File.separator)
                != pattern.startsWith(File.separator)) {
            return false;
        }

        String[] patDirs = tokenizePathAsArray(pattern);
        String[] strDirs = tokenizePathAsArray(str);

        int patIdxStart = 0;
        int patIdxEnd = patDirs.length - 1;
        int strIdxStart = 0;
        int strIdxEnd = strDirs.length - 1;

        
        while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
            String patDir = patDirs[patIdxStart];
            if (patDir.equals(""**"")) {
                break;
            }
            if (!match(patDir, strDirs[strIdxStart], isCaseSensitive)) {
                return false;
            }
            patIdxStart++;
            strIdxStart++;
        }

        if (strIdxStart > strIdxEnd) {
            
            return true;
        } else if (patIdxStart > patIdxEnd) {
            
            return false;
        } else {
            
            
            return true;
        }
    }

    
    public static boolean matchPath(String pattern, String str) {
        return matchPath(pattern, str, true);
    }

    
    public static boolean matchPath(String pattern, String str,
                                    boolean isCaseSensitive) {
        String[] patDirs = tokenizePathAsArray(pattern);
        String[] strDirs = tokenizePathAsArray(str);

        int patIdxStart = 0;
        int patIdxEnd = patDirs.length - 1;
        int strIdxStart = 0;
        int strIdxEnd = strDirs.length - 1;

        
        while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
            String patDir = patDirs[patIdxStart];
            if (patDir.equals(""**"")) {
                break;
            }
            if (!match(patDir, strDirs[strIdxStart], isCaseSensitive)) {
                patDirs = null;
                strDirs = null;
                return false;
            }
            patIdxStart++;
            strIdxStart++;
        }
        if (strIdxStart > strIdxEnd) {
            
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (!patDirs[i].equals(""**"")) {
                    patDirs = null;
                    strDirs = null;
                    return false;
                }
            }
            return true;
        } else {
            if (patIdxStart > patIdxEnd) {
                
                patDirs = null;
                strDirs = null;
                return false;
            }
        }

        
        while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
            String patDir = patDirs[patIdxEnd];
            if (patDir.equals(""**"")) {
                break;
            }
            if (!match(patDir, strDirs[strIdxEnd], isCaseSensitive)) {
                patDirs = null;
                strDirs = null;
                return false;
            }
            patIdxEnd--;
            strIdxEnd--;
        }
        if (strIdxStart > strIdxEnd) {
            
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (!patDirs[i].equals(""**"")) {
                    patDirs = null;
                    strDirs = null;
                    return false;
                }
            }
            return true;
        }

        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
            int patIdxTmp = -1;
            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {
                if (patDirs[i].equals(""**"")) {
                    patIdxTmp = i;
                    break;
                }
            }
            if (patIdxTmp == patIdxStart + 1) {
                
                patIdxStart++;
                continue;
            }
            
            
            int patLength = (patIdxTmp - patIdxStart - 1);
            int strLength = (strIdxEnd - strIdxStart + 1);
            int foundIdx = -1;
            strLoop:
                        for (int i = 0; i <= strLength - patLength; i++) {
                            for (int j = 0; j < patLength; j++) {
                                String subPat = patDirs[patIdxStart + j + 1];
                                String subStr = strDirs[strIdxStart + i + j];
                                if (!match(subPat, subStr, isCaseSensitive)) {
                                    continue strLoop;
                                }
                            }

                            foundIdx = strIdxStart + i;
                            break;
                        }

            if (foundIdx == -1) {
                patDirs = null;
                strDirs = null;
                return false;
            }

            patIdxStart = patIdxTmp;
            strIdxStart = foundIdx + patLength;
        }

        for (int i = patIdxStart; i <= patIdxEnd; i++) {
            if (!patDirs[i].equals(""**"")) {
                patDirs = null;
                strDirs = null;
                return false;
            }
        }

        return true;
    }

    
    public static boolean match(String pattern, String str) {
        return match(pattern, str, true);
    }

    
    public static boolean match(String pattern, String str,
                                boolean isCaseSensitive) {
        char[] patArr = pattern.toCharArray();
        char[] strArr = str.toCharArray();
        int patIdxStart = 0;
        int patIdxEnd = patArr.length - 1;
        int strIdxStart = 0;
        int strIdxEnd = strArr.length - 1;
        char ch;

        boolean containsStar = false;
        for (int i = 0; i < patArr.length; i++) {
            if (patArr[i] == '*') {
                containsStar = true;
                break;
            }
        }

        if (!containsStar) {
            
            if (patIdxEnd != strIdxEnd) {
                return false; 
            }
            for (int i = 0; i <= patIdxEnd; i++) {
                ch = patArr[i];
                if (ch != '?') {
                    if (isCaseSensitive && ch != strArr[i]) {
                        return false; 
                    }
                    if (!isCaseSensitive && Character.toUpperCase(ch)
                            != Character.toUpperCase(strArr[i])) {
                        return false;  
                    }
                }
            }
            return true; 
        }

        if (patIdxEnd == 0) {
            return true; 
        }

        
        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {
            if (ch != '?') {
                if (isCaseSensitive && ch != strArr[strIdxStart]) {
                    return false; 
                }
                if (!isCaseSensitive && Character.toUpperCase(ch)
                        != Character.toUpperCase(strArr[strIdxStart])) {
                    return false; 
                }
            }
            patIdxStart++;
            strIdxStart++;
        }
        if (strIdxStart > strIdxEnd) {
            
            
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (patArr[i] != '*') {
                    return false;
                }
            }
            return true;
        }

        
        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {
            if (ch != '?') {
                if (isCaseSensitive && ch != strArr[strIdxEnd]) {
                    return false; 
                }
                if (!isCaseSensitive && Character.toUpperCase(ch)
                        != Character.toUpperCase(strArr[strIdxEnd])) {
                    return false; 
                }
            }
            patIdxEnd--;
            strIdxEnd--;
        }
        if (strIdxStart > strIdxEnd) {
            
            
            for (int i = patIdxStart; i <= patIdxEnd; i++) {
                if (patArr[i] != '*') {
                    return false;
                }
            }
            return true;
        }

        
        
        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
            int patIdxTmp = -1;
            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {
                if (patArr[i] == '*') {
                    patIdxTmp = i;
                    break;
                }
            }
            if (patIdxTmp == patIdxStart + 1) {
                
                patIdxStart++;
                continue;
            }
            
            
            int patLength = (patIdxTmp - patIdxStart - 1);
            int strLength = (strIdxEnd - strIdxStart + 1);
            int foundIdx = -1;
            strLoop:
            for (int i = 0; i <= strLength - patLength; i++) {
                for (int j = 0; j < patLength; j++) {
                    ch = patArr[patIdxStart + j + 1];
                    if (ch != '?') {
                        if (isCaseSensitive && ch != strArr[strIdxStart + i
                                + j]) {
                            continue strLoop;
                        }
                        if (!isCaseSensitive
                            && Character.toUpperCase(ch)
                                != Character.toUpperCase(strArr[strIdxStart + i + j])) {
                            continue strLoop;
                        }
                    }
                }

                foundIdx = strIdxStart + i;
                break;
            }

            if (foundIdx == -1) {
                return false;
            }

            patIdxStart = patIdxTmp;
            strIdxStart = foundIdx + patLength;
        }

        
        
        for (int i = patIdxStart; i <= patIdxEnd; i++) {
            if (patArr[i] != '*') {
                return false;
            }
        }
        return true;
    }

    
    public static Vector tokenizePath (String path) {
        return tokenizePath(path, File.separator);
    }

    
    public static Vector tokenizePath (String path, String separator) {
        Vector ret = new Vector();
        if (FileUtils.isAbsolutePath(path)) {
            String[] s = FILE_UTILS.dissect(path);
            ret.add(s[0]);
            path = s[1];
        }
        StringTokenizer st = new StringTokenizer(path, separator);
        while (st.hasMoreTokens()) {
            ret.addElement(st.nextToken());
        }
        return ret;
    }

    
    private static String[] tokenizePathAsArray(String path) {
        String root = null;
        if (FileUtils.isAbsolutePath(path)) {
            String[] s = FILE_UTILS.dissect(path);
            root = s[0];
            path = s[1];
        }
        char sep = File.separatorChar;
        int start = 0;
        int len = path.length();
        int count = 0;
        for (int pos = 0; pos < len; pos++) {
            if (path.charAt(pos) == sep) {
                if (pos != start) {
                    count++;
                }
                start = pos + 1;
            }
        }
        if (len != start) {
            count++;
        }
        String[] l = new String[count + ((root == null) ? 0 : 1)];

        if (root != null) {
            l[0] = root;
            count = 1;
        } else {
            count = 0;
        }
        start = 0;
        for (int pos = 0; pos < len; pos++) {
            if (path.charAt(pos) == sep) {
                if (pos != start) {
                    String tok = path.substring(start, pos);
                    l[count++] = tok;
                }
                start = pos + 1;
            }
        }
        if (len != start) {
            String tok = path.substring(start);
            l[count] = tok;
        }
        return l;
    }

    
    public static boolean isOutOfDate(File src, File target, int granularity) {
        if (!src.exists()) {
            return false;
        }
        if (!target.exists()) {
            return true;
        }
        if ((src.lastModified() - granularity) > target.lastModified()) {
            return true;
        }
        return false;
    }

    
    public static boolean isOutOfDate(Resource src, Resource target,
                                      int granularity) {
        return isOutOfDate(src, target, (long) granularity);
    }

    
    public static boolean isOutOfDate(Resource src, Resource target,
                                      long granularity) {
        if (!src.isExists()) {
            return false;
        }
        if (!target.isExists()) {
            return true;
        }
        if ((src.getLastModified() - granularity) > target.getLastModified()) {
            return true;
        }
        return false;
    }

    
    public static String removeWhitespace(String input) {
        StringBuffer result = new StringBuffer();
        if (input != null) {
            StringTokenizer st = new StringTokenizer(input);
            while (st.hasMoreTokens()) {
                result.append(st.nextToken());
            }
        }
        return result.toString();
    }

    
    public static boolean hasWildcards(String input) {
        return (input.indexOf('*') != -1 || input.indexOf('?') != -1);
    }

    
    public static String rtrimWildcardTokens(String input) {
        String[] tokens = tokenizePathAsArray(input);
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < tokens.length; i++) {
            if (hasWildcards(tokens[i])) {
                break;
            }
            if (i > 0 && sb.charAt(sb.length() - 1) != File.separatorChar) {
                sb.append(File.separator);
            }
            sb.append(tokens[i]);
        }
        return sb.toString();
    }
}

"
org.apache.tools.ant.taskdefs.optional.Javah,31,3,0,16,79,365,4,14,29,0.905555556,466,1.0,3,0.560606061,0.20952381,0,0,13.64516129,4,1.2581,0,"

package org.apache.tools.ant.taskdefs.optional;

import java.io.File;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.optional.javah.JavahAdapter;
import org.apache.tools.ant.taskdefs.optional.javah.JavahAdapterFactory;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.facade.FacadeTaskHelper;
import org.apache.tools.ant.util.facade.ImplementationSpecificArgument;



public class Javah extends Task {

    private Vector classes = new Vector(2);
    private String cls;
    private File destDir;
    private Path classpath = null;
    private File outputFile = null;
    private boolean verbose = false;
    private boolean force   = false;
    private boolean old     = false;
    private boolean stubs   = false;
    private Path bootclasspath;
    
    private static String lSep = System.getProperty(""line.separator"");
    private FacadeTaskHelper facade = null;

    
    public Javah() {
        facade = new FacadeTaskHelper(JavahAdapterFactory.getDefault());
    }

    
    public void setClass(String cls) {
        this.cls = cls;
    }

    
    public ClassArgument createClass() {
        ClassArgument ga = new ClassArgument();
        classes.addElement(ga);
        return ga;
    }

    
    public class ClassArgument {
        private String name;

        
        public ClassArgument() {
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }
    }

    
    public String[] getClasses() {
        ArrayList al = new ArrayList();
        if (cls != null) {
            StringTokenizer tok = new StringTokenizer(cls, "","", false);
            while (tok.hasMoreTokens()) {
                al.add(tok.nextToken().trim());
            }
        }

        Enumeration e = classes.elements();
        while (e.hasMoreElements()) {
            ClassArgument arg = (ClassArgument) e.nextElement();
            al.add(arg.getName());
        }
        return (String[]) al.toArray(new String[al.size()]);
    }

    
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }

    
    public File getDestdir() {
        return destDir;
    }

    
    public void setClasspath(Path src) {
        if (classpath == null) {
            classpath = src;
        } else {
            classpath.append(src);
        }
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(getProject());
        }
        return classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public void setBootclasspath(Path src) {
        if (bootclasspath == null) {
            bootclasspath = src;
        } else {
            bootclasspath.append(src);
        }
    }

    
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(getProject());
        }
        return bootclasspath.createPath();
    }

    
    public void setBootClasspathRef(Reference r) {
        createBootclasspath().setRefid(r);
    }

    
    public Path getBootclasspath() {
        return bootclasspath;
    }

    
    public void setOutputFile(File outputFile) {
        this.outputFile = outputFile;
    }

    
    public File getOutputfile() {
        return outputFile;
    }

    
    public void setForce(boolean force) {
        this.force = force;
    }

    
    public boolean getForce() {
        return force;
    }

    
    public void setOld(boolean old) {
        this.old = old;
    }

    
    public boolean getOld() {
        return old;
    }

    
    public void setStubs(boolean stubs) {
        this.stubs = stubs;
    }

    
    public boolean getStubs() {
        return stubs;
    }

    
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    
    public boolean getVerbose() {
        return verbose;
    }

    
    public void setImplementation(String impl) {
        if (""default"".equals(impl)) {
            facade.setImplementation(JavahAdapterFactory.getDefault());
        } else {
            facade.setImplementation(impl);
        }
    }

    
    public ImplementationSpecificArgument createArg() {
        ImplementationSpecificArgument arg =
            new ImplementationSpecificArgument();
        facade.addImplementationArgument(arg);
        return arg;
    }

    
    public String[] getCurrentArgs() {
        return facade.getArgs();
    }

    
    public void execute() throws BuildException {
        

        if ((cls == null) && (classes.size() == 0)) {
            throw new BuildException(""class attribute must be set!"",
                getLocation());
        }

        if ((cls != null) && (classes.size() > 0)) {
            throw new BuildException(""set class attribute or class element, ""
                + ""not both."", getLocation());
        }

        if (destDir != null) {
            if (!destDir.isDirectory()) {
                throw new BuildException(""destination directory \"""" + destDir
                    + ""\"" does not exist or is not a directory"", getLocation());
            }
            if (outputFile != null) {
                throw new BuildException(""destdir and outputFile are mutually ""
                    + ""exclusive"", getLocation());
            }
        }

        if (classpath == null) {
            classpath = (new Path(getProject())).concatSystemClasspath(""last"");
        } else {
            classpath = classpath.concatSystemClasspath(""ignore"");
        }

        JavahAdapter ad =
            JavahAdapterFactory.getAdapter(facade.getImplementation(),
                                           this);
        if (!ad.compile(this)) {
            throw new BuildException(""compilation failed"");
        }
    }

    
    public void logAndAddFiles(Commandline cmd) {
        logAndAddFilesToCompile(cmd);
    }

    
    protected void logAndAddFilesToCompile(Commandline cmd) {
        log(""Compilation "" + cmd.describeArguments(),
            Project.MSG_VERBOSE);

        StringBuffer niceClassList = new StringBuffer();
        String[] c = getClasses();
        for (int i = 0; i < c.length; i++) {
            cmd.createArgument().setValue(c[i]);
            niceClassList.append(""    "");
            niceClassList.append(c[i]);
            niceClassList.append(lSep);
        }

        StringBuffer prefix = new StringBuffer(""Class"");
        if (c.length > 1) {
            prefix.append(""es"");
        }
        prefix.append("" to be compiled:"");
        prefix.append(lSep);

        log(prefix.toString() + niceClassList.toString(), Project.MSG_VERBOSE);
    }
}

"
org.apache.tools.ant.taskdefs.LoadFile,2,4,0,3,5,1,0,3,2,2.0,12,0.0,0,0.977777778,0.75,0,0,5.0,1,0.5,0,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.types.resources.FileResource;



public class LoadFile extends LoadResource {

    
    public final void setSrcFile(final File srcFile) {
        addConfigured(new FileResource(srcFile));
    }
}
"
org.apache.tools.ant.taskdefs.condition.HasMethod,12,2,0,7,37,44,0,7,9,0.803030303,231,1.0,2,0.45,0.291666667,0,0,17.75,5,1.6667,0,"
package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;

import java.lang.reflect.Method;
import java.lang.reflect.Field;


public class HasMethod extends ProjectComponent implements Condition {
    private String classname;
    private String method;
    private String field;
    private Path classpath;
    private AntClassLoader loader;
    private boolean ignoreSystemClasses = false;


    
    public void setClasspath(Path classpath) {
        createClasspath().append(classpath);
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setClassname(String classname) {
        this.classname = classname;
    }

    
    public void setMethod(String method) {
        this.method = method;
    }

    
    public void setField(String field) {
        this.field = field;
    }

    
    public void setIgnoreSystemClasses(boolean ignoreSystemClasses) {
        this.ignoreSystemClasses = ignoreSystemClasses;
    }

    
    private Class loadClass(String classname) {
        try {
            if (ignoreSystemClasses) {
                loader = getProject().createClassLoader(classpath);
                loader.setParentFirst(false);
                loader.addJavaLibraries();
                if (loader != null) {
                    try {
                        return loader.findClass(classname);
                    } catch (SecurityException se) {
                        
                        
                        
                        return null;
                    }
                } else {
                    return null;
                }
            } else if (loader != null) {
                return loader.loadClass(classname);
            } else {
                ClassLoader l = this.getClass().getClassLoader();
                
                
                if (l != null) {
                    return Class.forName(classname, true, l);
                } else {
                    return Class.forName(classname);
                }
            }
        } catch (ClassNotFoundException e) {
            throw new BuildException(""class \"""" + classname + ""\"" was not found"");
        } catch (NoClassDefFoundError e) {
            throw new BuildException(""Could not load dependent class \"""" + e.getMessage()
                    + ""\"" for class \"""" + classname + ""\"""");
        }
    }


    
    public boolean eval() throws BuildException {
        if (classname == null) {
            throw new BuildException(""No classname defined"");
        }
        Class clazz = loadClass(classname);
        if (method != null) {
            return isMethodFound(clazz);
        }
        if (field != null) {
            return isFieldFound(clazz);
        }
        throw new BuildException(""Neither method nor field defined"");
    }

    private boolean isFieldFound(Class clazz) {
        Field[] fields = clazz.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            Field fieldEntry = fields[i];
            if (fieldEntry.getName().equals(field)) {
                return true;
            }
        }
        return false;
    }

    private boolean isMethodFound(Class clazz) {
        Method[] methods = clazz.getDeclaredMethods();
        for (int i = 0; i < methods.length; i++) {
            Method methodEntry = methods[i];
            if (methodEntry.getName().equals(method)) {
                return true;
            }
        }
        return false;
    }

}
"
org.apache.tools.ant.taskdefs.WhichResource,8,3,0,5,30,8,0,5,7,0.714285714,214,1.0,1,0.840909091,0.5,2,2,25.25,6,1.75,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.AntClassLoader;

import java.net.URL;


public class WhichResource extends Task {
    
    private Path classpath;

    
    private String classname;

    
    private String resource;

    
    private String property;


    
    public void setClasspath(Path cp) {
        if (classpath == null) {
            classpath = cp;
        } else {
            classpath.append(cp);
        }
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(getProject());
        }
        return classpath.createPath();
    }


    
    private void validate() {
        int setcount = 0;
        if (classname != null) {
            setcount++;
        }
        if (resource != null) {
            setcount++;
        }


        if (setcount == 0) {
            throw new BuildException(
                    ""One of classname or resource must be specified"");
        }
        if (setcount > 1) {
            throw new BuildException(
                    ""Only one of classname or resource can be specified"");
        }
        if (property == null) {
            throw new BuildException(""No property defined"");
        }
    }

    
    public void execute() throws BuildException {
        validate();
        if (classpath != null) {
            getProject().log(""using user supplied classpath: "" + classpath,
                    Project.MSG_DEBUG);
            classpath = classpath.concatSystemClasspath(""ignore"");
        } else {
            classpath = new Path(getProject());
            classpath = classpath.concatSystemClasspath(""only"");
            getProject().log(""using system classpath: "" + classpath, Project.MSG_DEBUG);
        }
        AntClassLoader loader;
        loader = new AntClassLoader(getProject().getCoreLoader(),
                    getProject(),
                    classpath, false);
        String loc = null;
        if (classname != null) {
            
            resource = classname.replace('.', '/') + "".class"";
        }

        if (resource == null) {
            throw new BuildException(""One of class or resource is required"");
        }

        if (resource.startsWith(""/"")) {
            resource = resource.substring(1);
        }

        log(""Searching for "" + resource, Project.MSG_VERBOSE);
        URL url;
        url = loader.getResource(resource);
        if (url != null) {
            
            loc = url.toExternalForm();
            getProject().setNewProperty(property, loc);
        }
    }

    
    public void setResource(String resource) {
        this.resource = resource;
    }

    
    public void setClass(String classname) {
        this.classname = classname;
    }

    
    public void setProperty(String property) {
        this.property = property;
    }

}
"
org.apache.tools.ant.types.resources.Difference,3,4,0,3,20,3,0,3,1,2.0,82,0.0,0,0.956521739,0.5,1,1,26.33333333,6,2.3333,0,"
package org.apache.tools.ant.types.resources;

import java.util.List;
import java.util.HashSet;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collection;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.ResourceCollection;


public class Difference extends BaseResourceCollectionContainer {

    
    protected Collection getCollection() {
        List rc = getResourceCollections();
        int size = rc.size();
        if (size < 2) {
            throw new BuildException(""The difference of "" + size
                + "" resource collection"" + ((size == 1) ? """" : ""s"")
                + "" is undefined."");
        }
        HashSet hs = new HashSet();
        ArrayList al = new ArrayList();
        for (Iterator rcIter = rc.iterator(); rcIter.hasNext();) {
            for (Iterator r = nextRC(rcIter).iterator(); r.hasNext();) {
                Object next = r.next();
                if (hs.add(next)) {
                    al.add(next);
                } else {
                    al.remove(next);
                }
            }
        }
        return al;
    }

    private static ResourceCollection nextRC(Iterator i) {
        return (ResourceCollection) i.next();
    }

}
"
org.apache.tools.ant.taskdefs.optional.sound.AntSoundPlayer,14,1,0,4,43,81,1,3,11,0.857142857,230,0.857142857,0,0.0,0.285714286,0,0,14.92857143,5,1.5714,0,"

package org.apache.tools.ant.taskdefs.optional.sound;


import java.io.File;
import java.io.IOException;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.Line;
import javax.sound.sampled.LineEvent;
import javax.sound.sampled.LineListener;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.Project;





public class AntSoundPlayer implements LineListener, BuildListener {

    private File fileSuccess = null;
    private int loopsSuccess = 0;
    private Long durationSuccess = null;

    private File fileFail = null;
    private int loopsFail = 0;
    private Long durationFail = null;

    
    public AntSoundPlayer() {
    }

    
    public void addBuildSuccessfulSound(File file, int loops, Long duration) {
        this.fileSuccess = file;
        this.loopsSuccess = loops;
        this.durationSuccess = duration;
    }


    
    public void addBuildFailedSound(File fileFail, int loopsFail, Long durationFail) {
        this.fileFail = fileFail;
        this.loopsFail = loopsFail;
        this.durationFail = durationFail;
    }

    
    private void play(Project project, File file, int loops, Long duration) {

        Clip audioClip = null;

        AudioInputStream audioInputStream = null;


        try {
            audioInputStream = AudioSystem.getAudioInputStream(file);
        } catch (UnsupportedAudioFileException uafe) {
            project.log(""Audio format is not yet supported: ""
                + uafe.getMessage());
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }

        if (audioInputStream != null) {
            AudioFormat format = audioInputStream.getFormat();
            DataLine.Info   info = new DataLine.Info(Clip.class, format,
                                             AudioSystem.NOT_SPECIFIED);
            try {
                audioClip = (Clip) AudioSystem.getLine(info);
                audioClip.addLineListener(this);
                audioClip.open(audioInputStream);
            } catch (LineUnavailableException e) {
                project.log(""The sound device is currently unavailable"");
                return;
            } catch (IOException e) {
                e.printStackTrace();
            }

            if (duration != null) {
                playClip(audioClip, duration.longValue());
            } else {
                playClip(audioClip, loops);
            }
            audioClip.drain();
            audioClip.close();
        } else {
            project.log(""Can't get data from file "" + file.getName());
        }
    }

    private void playClip(Clip clip, int loops) {

        clip.loop(loops);
        while (clip.isRunning()) {
            
        }
    }

    private void playClip(Clip clip, long duration) {
        clip.loop(Clip.LOOP_CONTINUOUSLY);
        try {
            Thread.sleep(duration);
        } catch (InterruptedException e) {
            
        }
    }

    
    public void update(LineEvent event) {
        if (event.getType().equals(LineEvent.Type.STOP)) {
            Line line = event.getLine();
            line.close();
        } else if (event.getType().equals(LineEvent.Type.CLOSE)) {
            
            
        }
    }


    
    public void buildStarted(BuildEvent event) {
    }

    
    public void buildFinished(BuildEvent event) {
        if (event.getException() == null && fileSuccess != null) {
            
            play(event.getProject(), fileSuccess, loopsSuccess, durationSuccess);
        } else if (event.getException() != null && fileFail != null) {
            play(event.getProject(), fileFail, loopsFail, durationFail);
        }
    }

    
    public void targetStarted(BuildEvent event) {
    }

    
    public void targetFinished(BuildEvent event) {
    }

    
    public void taskStarted(BuildEvent event) {
    }

    
    public void taskFinished(BuildEvent event) {
    }

    
    public void messageLogged(BuildEvent event) {
    }
}

"
org.apache.tools.ant.taskdefs.optional.j2ee.GenericHotDeploymentTool,11,2,1,8,27,21,2,7,9,0.733333333,94,1.0,1,0.608695652,0.4,2,3,7.272727273,1,0.8182,0,"

package org.apache.tools.ant.taskdefs.optional.j2ee;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Commandline;


public class GenericHotDeploymentTool extends AbstractHotDeploymentTool {
    
    private Java java;

    
    private String className;

    
    private static final String[] VALID_ACTIONS = {ACTION_DEPLOY};

    
    public Commandline.Argument createArg() {
        return java.createArg();
    }

    
    public Commandline.Argument createJvmarg() {
        return java.createJvmarg();
    }

    
    protected boolean isActionValid() {
        return (getTask().getAction().equals(VALID_ACTIONS[0]));
    }

    
    public void setTask(ServerDeploy task) {
        super.setTask(task);
        java = new Java(task);
    }

    
    public void deploy() throws BuildException {
        java.setClassname(className);
        java.setClasspath(getClasspath());
        java.setFork(true);
        java.setFailonerror(true);
        java.execute();
    }

    
    public void validateAttributes() throws BuildException {
        super.validateAttributes();

        if (className == null) {
            throw new BuildException(""The classname attribute must be set"");
        }
    }

    
    public void setClassName(String className) {
        this.className = className;
    }

    
    public Java getJava() {
        return java;
    }

    
    public String getClassName() {
        return className;
    }
}
"
org.apache.tools.ant.util.facade.ImplementationSpecificArgument,3,3,2,8,6,1,7,1,3,0.5,25,1.0,0,0.882352941,0.833333333,1,1,7.0,3,1.3333,0,"

package org.apache.tools.ant.util.facade;

import org.apache.tools.ant.types.Commandline;


public class ImplementationSpecificArgument extends Commandline.Argument {
    private String impl;

    
    public ImplementationSpecificArgument() {
        super();
    }

    
    public void setImplementation(String impl) {
        this.impl = impl;
    }

    
    public final String[] getParts(String chosenImpl) {
        if (impl == null || impl.equals(chosenImpl)) {
            return super.getParts();
        } else {
            return new String[0];
        }
    }
}
"
org.apache.tools.ant.taskdefs.Move,9,4,0,10,64,22,1,9,1,2.0,791,0.0,0,0.909090909,0.703703704,4,9,86.88888889,23,4.8889,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FilterSet;
import org.apache.tools.ant.types.FilterSetCollection;


public class Move extends Copy {

    
    public Move() {
        super();
        setOverwrite(true);
    }

    
    protected void validateAttributes() throws BuildException {
        if (file != null && file.isDirectory()) {
            if ((destFile != null && destDir != null)
                || (destFile == null && destDir == null)) {
                throw new BuildException(""One and only one of tofile and todir ""
                                         + ""must be set."");
            }
            destFile = (destFile == null)
                ? new File(destDir, file.getName()) : destFile;
            destDir = (destDir == null)
                ? destFile.getParentFile() : destDir;

            completeDirMap.put(file, destFile);
            file = null;
        } else {
            super.validateAttributes();
        }
    }





    
    protected void doFileOperations() {
        
        if (completeDirMap.size() > 0) {
            Enumeration e = completeDirMap.keys();
            while (e.hasMoreElements()) {
                File fromDir = (File) e.nextElement();
                File toDir = (File) completeDirMap.get(fromDir);
                boolean renamed = false;
                try {
                    log(""Attempting to rename dir: "" + fromDir
                        + "" to "" + toDir, verbosity);
                    renamed =
                        renameFile(fromDir, toDir, filtering, forceOverwrite);
                } catch (IOException ioe) {
                    String msg = ""Failed to rename dir "" + fromDir
                        + "" to "" + toDir
                        + "" due to "" + ioe.getMessage();
                    throw new BuildException(msg, ioe, getLocation());
                }
                if (!renamed) {
                    FileSet fs = new FileSet();
                    fs.setProject(getProject());
                    fs.setDir(fromDir);
                    addFileset(fs);
                    DirectoryScanner ds = fs.getDirectoryScanner(getProject());
                    String[] files = ds.getIncludedFiles();
                    String[] dirs = ds.getIncludedDirectories();
                    scan(fromDir, toDir, files, dirs);
                }
            }
        }
        int moveCount = fileCopyMap.size();
        if (moveCount > 0) {   
            log(""Moving "" + moveCount + "" file""
                + ((moveCount == 1) ? """" : ""s"")
                + "" to "" + destDir.getAbsolutePath());

            Enumeration e = fileCopyMap.keys();
            while (e.hasMoreElements()) {
                String fromFile = (String) e.nextElement();

                File f = new File(fromFile);
                boolean selfMove = false;
                if (f.exists()) { 
                    String[] toFiles = (String[]) fileCopyMap.get(fromFile);
                    for (int i = 0; i < toFiles.length; i++) {
                        String toFile = (String) toFiles[i];

                        if (fromFile.equals(toFile)) {
                            log(""Skipping self-move of "" + fromFile, verbosity);
                            selfMove = true;

                            
                            
                            continue;
                        }
                        File d = new File(toFile);
                        if ((i + 1) == toFiles.length && !selfMove) {
                            
                            
                            moveFile(f, d, filtering, forceOverwrite);
                        } else {
                            copyFile(f, d, filtering, forceOverwrite);
                        }
                    }
                }
            }
        }

        if (includeEmpty) {
            Enumeration e = dirCopyMap.keys();
            int createCount = 0;
            while (e.hasMoreElements()) {
                String fromDirName = (String) e.nextElement();
                String[] toDirNames = (String[]) dirCopyMap.get(fromDirName);
                boolean selfMove = false;
                for (int i = 0; i < toDirNames.length; i++) {

                    if (fromDirName.equals(toDirNames[i])) {
                        log(""Skipping self-move of "" + fromDirName, verbosity);
                        selfMove = true;
                        continue;
                    }

                    File d = new File(toDirNames[i]);
                    if (!d.exists()) {
                        if (!d.mkdirs()) {
                            log(""Unable to create directory ""
                                + d.getAbsolutePath(), Project.MSG_ERR);
                        } else {
                            createCount++;
                        }
                    }
                }

                File fromDir = new File(fromDirName);
                if (!selfMove && okToDelete(fromDir)) {
                    deleteDir(fromDir);
                }

            }

            if (createCount > 0) {
                log(""Moved "" + dirCopyMap.size()
                    + "" empty director""
                    + (dirCopyMap.size() == 1 ? ""y"" : ""ies"")
                    + "" to "" + createCount
                    + "" empty director""
                    + (createCount == 1 ? ""y"" : ""ies"") + "" under ""
                    + destDir.getAbsolutePath());
            }
        }
    }

    
    private void moveFile(File fromFile, File toFile,
                          boolean filtering, boolean overwrite) {
        boolean moved = false;
        try {
            log(""Attempting to rename: "" + fromFile
                + "" to "" + toFile, verbosity);
            moved = renameFile(fromFile, toFile, filtering, forceOverwrite);
        } catch (IOException ioe) {
            String msg = ""Failed to rename "" + fromFile
                + "" to "" + toFile
                + "" due to "" + ioe.getMessage();
            throw new BuildException(msg, ioe, getLocation());
        }

        if (!moved) {
            copyFile(fromFile, toFile, filtering, overwrite);
            if (!fromFile.delete()) {
                throw new BuildException(""Unable to delete ""
                                        + ""file ""
                                        + fromFile.getAbsolutePath());
            }
        }
    }

    
    private void copyFile(File fromFile, File toFile,
                          boolean filtering, boolean overwrite) {
        try {
            log(""Copying "" + fromFile + "" to "" + toFile,
                verbosity);

            FilterSetCollection executionFilters =
                new FilterSetCollection();
            if (filtering) {
                executionFilters
                    .addFilterSet(getProject().getGlobalFilterSet());
            }
            for (Enumeration filterEnum =
                    getFilterSets().elements();
                filterEnum.hasMoreElements();) {
                executionFilters
                    .addFilterSet((FilterSet) filterEnum
                                .nextElement());
            }

            getFileUtils().copyFile(fromFile, toFile, executionFilters,
                                    getFilterChains(),
                                    forceOverwrite,
                                    getPreserveLastModified(),
                                    getEncoding(),
                                    getOutputEncoding(),
                                    getProject());

        } catch (IOException ioe) {
            String msg = ""Failed to copy "" + fromFile
                + "" to "" + toFile
                + "" due to "" + ioe.getMessage();
            throw new BuildException(msg, ioe, getLocation());
        }
    }


    
    protected boolean okToDelete(File d) {
        String[] list = d.list();
        if (list == null) {
            return false;
        }     

        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(d, s);
            if (f.isDirectory()) {
                if (!okToDelete(f)) {
                    return false;
                }
            } else {
                return false;   
            }
        }

        return true;
    }

    
    protected void deleteDir(File d) {
        deleteDir(d, false);
    }

    
    protected void deleteDir(File d, boolean deleteFiles) {
        String[] list = d.list();
        if (list == null) {
            return;
        }      

        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(d, s);
            if (f.isDirectory()) {
                deleteDir(f);
            } else if (deleteFiles && !(f.delete())) {
                throw new BuildException(""Unable to delete file ""
                                         + f.getAbsolutePath());
            } else {
                throw new BuildException(""UNEXPECTED ERROR - The file ""
                                         + f.getAbsolutePath()
                                         + "" should not exist!"");
            }
        }
        log(""Deleting directory "" + d.getAbsolutePath(), verbosity);
        if (!d.delete()) {
            throw new BuildException(""Unable to delete directory ""
                                     + d.getAbsolutePath());
        }
    }

    
    protected boolean renameFile(File sourceFile, File destFile,
                                 boolean filtering, boolean overwrite)
        throws IOException, BuildException {

        boolean renamed = false;
        if ((getFilterSets().size() + getFilterChains().size() == 0)
            && !(filtering || destFile.isDirectory())) {
            
            File parent = destFile.getParentFile();
            if (parent != null && !parent.exists()) {
                parent.mkdirs();
            }
            if (destFile.isFile() && !destFile.equals(sourceFile)
                && !destFile.delete()) {
                throw new BuildException(""Unable to remove existing ""
                                         + ""file "" + destFile);
            }
            renamed = sourceFile.renameTo(destFile);
        }
        return renamed;
    }
}
"
org.apache.tools.ant.taskdefs.condition.Equals,6,1,0,3,11,1,1,2,6,0.7,74,1.0,0,0.0,0.555555556,0,0,10.66666667,1,0.8333,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;


public class Equals implements Condition {

    private String arg1, arg2;
    private boolean trim = false;
    private boolean caseSensitive = true;

    
    public void setArg1(String a1) {
        arg1 = a1;
    }

    
    public void setArg2(String a2) {
        arg2 = a2;
    }

    
    public void setTrim(boolean b) {
        trim = b;
    }

    
    public void setCasesensitive(boolean b) {
        caseSensitive = b;
    }

    
    public boolean eval() throws BuildException {
        if (arg1 == null || arg2 == null) {
            throw new BuildException(""both arg1 and arg2 are required in ""
                                     + ""equals"");
        }

        if (trim) {
            arg1 = arg1.trim();
            arg2 = arg2.trim();
        }

        return caseSensitive ? arg1.equals(arg2) : arg1.equalsIgnoreCase(arg2);
    }
}
"
org.apache.tools.ant.types.Comparison,5,2,2,9,10,6,7,2,4,0.9,185,0.4,6,0.8,0.5,1,1,34.0,5,1.2,0,"
package org.apache.tools.ant.types;

import java.util.Arrays;

import org.apache.tools.ant.BuildException;


public class Comparison extends EnumeratedAttribute {
    private static final String[] VALUES
        = new String[] {""equal"", ""greater"", ""less"",
                        ""ne"", ""ge"", ""le"", ""eq"", ""gt"", ""lt"", ""more""};

    
    public static final Comparison EQUAL = new Comparison(""equal"");

    
    public static final Comparison NOT_EQUAL = new Comparison(""ne"");

    
    public static final Comparison GREATER = new Comparison(""greater"");

    
    public static final Comparison LESS = new Comparison(""less"");

    
    public static final Comparison GREATER_EQUAL = new Comparison(""ge"");

    
    public static final Comparison LESS_EQUAL = new Comparison(""le"");

    private static final int[] EQUAL_INDEX = {0, 4, 5, 6};
    private static final int[] LESS_INDEX = {2, 3, 5, 8};
    private static final int[] GREATER_INDEX = {1, 3, 4, 7, 9};

    
    public Comparison() {
    }

    
    public Comparison(String value) {
        setValue(value);
    }

    
    public String[] getValues() {
        return VALUES;
    }

    
    public boolean evaluate(int comparisonResult) {
        if (getIndex() == -1) {
            throw new BuildException(""Comparison value not set."");
        }
        int[] i = comparisonResult < 0 ? LESS_INDEX
            : comparisonResult > 0 ? GREATER_INDEX : EQUAL_INDEX;
        return Arrays.binarySearch(i, getIndex()) >= 0;
    }

}

"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTaskMirrorImpl,4,1,0,13,14,6,0,13,4,1.0,56,1.0,1,0.0,0.375,0,0,12.75,1,0.75,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.OutputStream;
import junit.framework.AssertionFailedError;
import junit.framework.TestCase;
import junit.framework.TestResult;
import org.apache.tools.ant.AntClassLoader;


public final class JUnitTaskMirrorImpl implements JUnitTaskMirror {

    private final JUnitTask task;

    
    public JUnitTaskMirrorImpl(JUnitTask task) {
        this.task = task;
    }

    
    public void addVmExit(JUnitTest test, JUnitTaskMirror.JUnitResultFormatterMirror aFormatter,
            OutputStream out, String message, String testCase) {
        JUnitResultFormatter formatter = (JUnitResultFormatter) aFormatter;
        formatter.setOutput(out);
        formatter.startTestSuite(test);
        
        
        
        TestCase t = new VmExitErrorTest(message, test, testCase);
        formatter.startTest(t);
        formatter.addError(t, new AssertionFailedError(message));
        formatter.endTestSuite(test);
    }

    
    public JUnitTaskMirror.JUnitTestRunnerMirror newJUnitTestRunner(JUnitTest test,
            boolean haltOnError, boolean filterTrace, boolean haltOnFailure,
            boolean showOutput, boolean logTestListenerEvents, AntClassLoader classLoader) {
        return new JUnitTestRunner(test, haltOnError, filterTrace, haltOnFailure,
                showOutput, logTestListenerEvents, classLoader);
    }

    
    public JUnitTaskMirror.SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter() {
        return new SummaryJUnitResultFormatter();
    }

    static class VmExitErrorTest extends TestCase {

        private String message;
        private JUnitTest test;
        private String testCase;

        VmExitErrorTest(String aMessage, JUnitTest anOriginalTest, String aTestCase) {
            message = aMessage;
            test = anOriginalTest;
            testCase = aTestCase;
        }

        public int countTestCases() {
            return 1;
        }

        public void run(TestResult r) {
            throw new AssertionFailedError(message);
        }

        public String getName() {
            return testCase;
        }

        String getClassName() {
            return test.getName();
        }

        public String toString() {
            return test.getName() + "":"" + testCase;
        }
    }
}
"
org.apache.tools.ant.IntrospectionHelper,35,1,0,32,120,417,20,28,24,0.927893738,2098,0.387096774,0,0.0,0.290441176,0,0,58.05714286,19,2.5143,4,"

package org.apache.tools.ant;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.taskdefs.PreSetDef;


public final class IntrospectionHelper  {

    
    private static final Map EMPTY_MAP
        = Collections.unmodifiableMap(new HashMap(0));

    
    private static final Map HELPERS = new Hashtable();

    
    private static final Map PRIMITIVE_TYPE_MAP = new HashMap(8);

    
    static {
        Class[] primitives = {Boolean.TYPE, Byte.TYPE, Character.TYPE,
                              Short.TYPE, Integer.TYPE, Long.TYPE,
                              Float.TYPE, Double.TYPE};
        Class[] wrappers = {Boolean.class, Byte.class, Character.class,
                            Short.class, Integer.class, Long.class,
                            Float.class, Double.class};
        for (int i = 0; i < primitives.length; i++) {
            PRIMITIVE_TYPE_MAP.put (primitives[i], wrappers[i]);
        }
    }

    private static final int MAX_REPORT_NESTED_TEXT = 20;
    private static final String ELLIPSIS = ""..."";

    
    private Hashtable attributeTypes = new Hashtable();

    
    private Hashtable attributeSetters = new Hashtable();

    
    private Hashtable nestedTypes = new Hashtable();

    
    private Hashtable nestedCreators = new Hashtable();

    
    private List addTypeMethods = new ArrayList();

    
    private Method addText = null;

    
    private Class bean;

    
    private IntrospectionHelper(final Class bean) {
        this.bean = bean;
        Method[] methods = bean.getMethods();
        for (int i = 0; i < methods.length; i++) {
            final Method m = methods[i];
            final String name = m.getName();
            Class returnType = m.getReturnType();
            Class[] args = m.getParameterTypes();

            
            if (args.length == 1 && java.lang.Void.TYPE.equals(returnType)
                && (""add"".equals(name) || ""addConfigured"".equals(name))) {
                insertAddTypeMethod(m);
                continue;
            }
            
            if (org.apache.tools.ant.ProjectComponent.class.isAssignableFrom(
                    bean)
                 && args.length == 1 && isHiddenSetMethod(name, args[0])) {
                continue;
            }
            
            if (isContainer() && args.length == 1 && ""addTask"".equals(name)
                && org.apache.tools.ant.Task.class.equals(args[0])) {
                continue;
            }
            if (""addText"".equals(name) && java.lang.Void.TYPE.equals(returnType)
                && args.length == 1 && java.lang.String.class.equals(args[0])) {

                addText = methods[i];
            } else if (name.startsWith(""set"")
                       && java.lang.Void.TYPE.equals(returnType)
                       && args.length == 1 && !args[0].isArray()) {
                String propName = getPropertyName(name, ""set"");
                if (attributeSetters.get(propName) != null) {
                    if (java.lang.String.class.equals(args[0])) {
                        
                        continue;
                    }
                    
                }
                AttributeSetter as = createAttributeSetter(m, args[0], propName);
                if (as != null) {
                    attributeTypes.put(propName, args[0]);
                    attributeSetters.put(propName, as);
                }
            } else if (name.startsWith(""create"") && !returnType.isArray()
                       && !returnType.isPrimitive() && args.length == 0) {

                String propName = getPropertyName(name, ""create"");
                
                
                if (nestedCreators.get(propName) == null) {
                    nestedTypes.put(propName, returnType);
                    nestedCreators.put(propName, new CreateNestedCreator(m));
                }
            } else if (name.startsWith(""addConfigured"")
                && java.lang.Void.TYPE.equals(returnType) && args.length == 1
                && !java.lang.String.class.equals(args[0])
                && !args[0].isArray() && !args[0].isPrimitive()) {
                try {
                    Constructor constructor = null;
                    try {
                        constructor = args[0].getConstructor(new Class[] {});
                    } catch (NoSuchMethodException ex) {
                        constructor =
                            args[0].getConstructor(new Class[] {Project.class});
                    }
                    String propName = getPropertyName(name, ""addConfigured"");
                    nestedTypes.put(propName, args[0]);
                    nestedCreators.put(propName, new AddNestedCreator(m,
                        constructor, AddNestedCreator.ADD_CONFIGURED));
                } catch (NoSuchMethodException nse) {
                    
                }
            } else if (name.startsWith(""add"")
                && java.lang.Void.TYPE.equals(returnType) && args.length == 1
                && !java.lang.String.class.equals(args[0])
                && !args[0].isArray() && !args[0].isPrimitive()) {
                try {
                    Constructor constructor = null;
                    try {
                        constructor = args[0].getConstructor(new Class[] {});
                    } catch (NoSuchMethodException ex) {
                        constructor =
                            args[0].getConstructor(new Class[] {Project.class});
                    }

                    String propName = getPropertyName(name, ""add"");
                    if (nestedTypes.get(propName) != null) {
                        
                        continue;
                    }
                    nestedTypes.put(propName, args[0]);
                    nestedCreators.put(propName, new AddNestedCreator(m,
                        constructor, AddNestedCreator.ADD));
                } catch (NoSuchMethodException nse) {
                    
                }
            }
        }
    }

    
    private boolean isHiddenSetMethod(String name, Class type) {
        if (""setLocation"".equals(name)
             && org.apache.tools.ant.Location.class.equals(type)) {
            return true;
        }

        if (""setTaskType"".equals(name)
             && java.lang.String.class.equals(type)) {
            return true;
        }

        return false;
    }

    
    public static synchronized IntrospectionHelper getHelper(Class c) {
        return getHelper(null, c);
    }

    
    public static IntrospectionHelper getHelper(Project p, Class c) {
        IntrospectionHelper ih = (IntrospectionHelper) HELPERS.get(c.getName());
        
        
        if (ih == null || ih.bean != c) {
            ih = new IntrospectionHelper(c);
            if (p != null) {
                
                
                HELPERS.put(c.getName(), ih);
            }
        }
        return ih;
    }

    
    public void setAttribute(Project p, Object element, String attributeName,
                             String value) throws BuildException {
        AttributeSetter as
            = (AttributeSetter) attributeSetters.get(
                attributeName.toLowerCase(Locale.US));
        if (as == null) {
            if (element instanceof DynamicAttributeNS) {
                DynamicAttributeNS dc = (DynamicAttributeNS) element;
                String uriPlusPrefix =
                    ProjectHelper.extractUriFromComponentName(attributeName);
                String uri =
                    ProjectHelper.extractUriFromComponentName(uriPlusPrefix);
                String localName =
                    ProjectHelper.extractNameFromComponentName(attributeName);
                String qName = ("""".equals(uri)
                                ? localName : (uri + "":"" + localName));

                dc.setDynamicAttribute(uri, localName, qName, value);
                return;
            } else if (element instanceof DynamicAttribute) {
                DynamicAttribute dc = (DynamicAttribute) element;
                dc.setDynamicAttribute(attributeName.toLowerCase(Locale.US), value);
                return;
            } else {
                if (attributeName.indexOf(':') != -1) {
                    return; 
                }
                String msg = getElementName(p, element)
                    + "" doesn't support the \"""" + attributeName
                    + ""\"" attribute."";
                throw new UnsupportedAttributeException(msg, attributeName);
            }
        }
        try {
            as.set(p, element, value);
        } catch (IllegalAccessException ie) {
            
            throw new BuildException(ie);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }


    
    public void addText(Project project, Object element, String text)
        throws BuildException {
        if (addText == null) {
            text = text.trim();
            
            if (text.length() == 0) {
                
                return;
            } else {
                
                String msg = project.getElementName(element)
                    + "" doesn't support nested text data (\""""
                    + condenseText(text) + ""\"")."";
                throw new BuildException(msg);
            }
        }
        try {
            addText.invoke(element, new Object[] {text});
        } catch (IllegalAccessException ie) {
            
            throw new BuildException(ie);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }

    
    public void throwNotSupported(Project project, Object parent,
        String elementName) {
        String msg = project.getElementName(parent)
            + "" doesn't support the nested \"""" + elementName + ""\"" element."";
        throw new UnsupportedElementException(msg, elementName);
    }

    private NestedCreator getNestedCreator(
        Project project, String parentUri, Object parent,
        String elementName, UnknownElement child) throws BuildException {

        String uri = ProjectHelper.extractUriFromComponentName(elementName);
        String name = ProjectHelper.extractNameFromComponentName(elementName);

        if (uri.equals(ProjectHelper.ANT_CORE_URI)) {
            uri = """";
        }
        if (parentUri.equals(ProjectHelper.ANT_CORE_URI)) {
            parentUri = """";
        }
        NestedCreator nc = null;
        if (uri.equals(parentUri) || uri.equals("""")) {
            nc = (NestedCreator) nestedCreators.get(
                name.toLowerCase(Locale.US));
        }
        if (nc == null) {
            nc = createAddTypeCreator(project, parent, elementName);
        }
        if (nc == null && parent instanceof DynamicElementNS) {
            DynamicElementNS dc = (DynamicElementNS) parent;
            String qName = (child == null ? name : child.getQName());
            final Object nestedElement =
                dc.createDynamicElement(
                    (child == null ? """" : child.getNamespace()),
                    name, qName);
            if (nestedElement != null) {
                nc = new NestedCreator(null) {
                    Object create(
                        Project project, Object parent, Object ignore) {
                        return nestedElement;
                    }
                };
            }
        }
        if (nc == null && parent instanceof DynamicElement) {
            DynamicElement dc = (DynamicElement) parent;
            final Object nestedElement =
                dc.createDynamicElement(name.toLowerCase(Locale.US));
            if (nestedElement != null) {
                nc = new NestedCreator(null) {
                    Object create(
                        Project project, Object parent, Object ignore) {
                        return nestedElement;
                    }
                };
            }
        }
        if (nc == null) {
            throwNotSupported(project, parent, elementName);
        }
        return nc;
    }

    
    public Object createElement(Project project, Object parent,
        String elementName) throws BuildException {
        NestedCreator nc = getNestedCreator(project, """", parent, elementName, null);
        try {
            Object nestedElement = nc.create(project, parent, null);
            if (project != null) {
                project.setProjectReference(nestedElement);
            }
            return nestedElement;
        } catch (IllegalAccessException ie) {
            
            throw new BuildException(ie);
        } catch (InstantiationException ine) {
            
            throw new BuildException(ine);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }

    
    public Creator getElementCreator(
        Project project, String parentUri, Object parent, String elementName,
        UnknownElement ue) {
        NestedCreator nc = getNestedCreator(
            project, parentUri, parent, elementName, ue);
        return new Creator(project, parent, nc);
    }

    
    public boolean isDynamic() {
        return DynamicElement.class.isAssignableFrom(bean)
            || DynamicElementNS.class.isAssignableFrom(bean);
    }

    
    public boolean isContainer() {
        return TaskContainer.class.isAssignableFrom(bean);
    }

    
    public boolean supportsNestedElement(String elementName) {
        return nestedCreators.containsKey(elementName.toLowerCase(Locale.US))
            || isDynamic()
            || addTypeMethods.size() != 0;
    }

    
    public boolean supportsNestedElement(String parentUri, String elementName) {
        if (parentUri.equals(ProjectHelper.ANT_CORE_URI)) {
            parentUri = """";
        }
        String uri = ProjectHelper.extractUriFromComponentName(elementName);
        if (uri.equals(ProjectHelper.ANT_CORE_URI)) {
            uri = """";
        }
        String name = ProjectHelper.extractNameFromComponentName(elementName);

        return (
            nestedCreators.containsKey(name.toLowerCase(Locale.US))
            && (uri.equals(parentUri) || """".equals(uri)))
            || isDynamic() || addTypeMethods.size() != 0;
    }

    
    public void storeElement(Project project, Object parent, Object child,
        String elementName) throws BuildException {
        if (elementName == null) {
            return;
        }
        NestedCreator ns = (NestedCreator) nestedCreators.get(
            elementName.toLowerCase(Locale.US));
        if (ns == null) {
            return;
        }
        try {
            ns.store(parent, child);
        } catch (IllegalAccessException ie) {
            
            throw new BuildException(ie);
        } catch (InstantiationException ine) {
            
            throw new BuildException(ine);
        } catch (InvocationTargetException ite) {
            Throwable t = ite.getTargetException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(t);
        }
    }

    
    public Class getElementType(String elementName)
        throws BuildException {
        Class nt = (Class) nestedTypes.get(elementName);
        if (nt == null) {
            throw new UnsupportedElementException(""Class ""
                + bean.getName() + "" doesn't support the nested \""""
                + elementName + ""\"" element."", elementName);
        }
        return nt;
    }

    
    public Class getAttributeType(String attributeName)
        throws BuildException {
        Class at = (Class) attributeTypes.get(attributeName);
        if (at == null) {
            throw new UnsupportedAttributeException(""Class ""
                + bean.getName() + "" doesn't support the \""""
                + attributeName + ""\"" attribute."", attributeName);
        }
        return at;
    }

    
    public Method getAddTextMethod()
                  throws BuildException {
        if (!supportsCharacters()) {
            throw new BuildException(""Class "" + bean.getName()
                + "" doesn't support nested text data."");
        }
        return addText;
    }

    
    public Method getElementMethod(String elementName)
                  throws BuildException {
        Object creator = nestedCreators.get(elementName);
        if (creator == null) {
            throw new UnsupportedElementException(""Class ""
                + bean.getName() + "" doesn't support the nested \""""
                + elementName + ""\"" element."", elementName);
        }
        return ((NestedCreator) creator).method;
    }

    
    public Method getAttributeMethod(String attributeName)
                  throws BuildException {
        Object setter = attributeSetters.get(attributeName);
        if (setter == null) {
            throw new UnsupportedAttributeException(""Class ""
                + bean.getName() + "" doesn't support the \""""
                + attributeName + ""\"" attribute."", attributeName);
        }
        return ((AttributeSetter) setter).method;
    }

    
    public boolean supportsCharacters() {
        return addText != null;
    }

    
    public Enumeration getAttributes() {
        return attributeSetters.keys();
    }

    
    public Map getAttributeMap() {
        return (attributeTypes.size() < 1)
            ? EMPTY_MAP : Collections.unmodifiableMap(attributeTypes);
    }

    
    public Enumeration getNestedElements() {
        return nestedTypes.keys();
    }

    
    public Map getNestedElementMap() {
        return (nestedTypes.size() < 1)
            ? EMPTY_MAP : Collections.unmodifiableMap(nestedTypes);
    }

    
    public List getExtensionPoints() {
        return (addTypeMethods.size() < 1) ? Collections.EMPTY_LIST
            : Collections.unmodifiableList(addTypeMethods);
    }

    
    private AttributeSetter createAttributeSetter(final Method m,
                                                  Class arg,
                                                  final String attrName) {
        
        
        final Class reflectedArg = PRIMITIVE_TYPE_MAP.containsKey(arg)
            ? (Class) PRIMITIVE_TYPE_MAP.get(arg) : arg;

        
        if (java.lang.String.class.equals(reflectedArg)) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException {
                    m.invoke(parent, (Object[]) (new String[] {value}));
                }
            };
        
        } else if (java.lang.Character.class.equals(reflectedArg)) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException {
                    if (value.length() == 0) {
                        throw new BuildException(""The value \""\"" is not a ""
                            + ""legal value for attribute \"""" + attrName + ""\"""");
                    }
                    m.invoke(parent, (Object[])
                        (new Character[] {new Character(value.charAt(0))}));
                }
            };
        
        
        } else if (java.lang.Boolean.class.equals(reflectedArg)) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException {
                    m.invoke(parent, (Object[]) (
                         new Boolean[] {Project.toBoolean(value)
                                        ? Boolean.TRUE : Boolean.FALSE}));
                }
            };
        
        } else if (java.lang.Class.class.equals(reflectedArg)) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException, BuildException {
                    try {
                        m.invoke(parent, new Object[] {Class.forName(value)});
                    } catch (ClassNotFoundException ce) {
                        throw new BuildException(ce);
                    }
                }
            };
        
        } else if (java.io.File.class.equals(reflectedArg)) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException {
                    m.invoke(parent, new Object[] {p.resolveFile(value)});
                }
            };
        
        } else if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException, BuildException {
                    try {
                        EnumeratedAttribute ea =
                            (EnumeratedAttribute) reflectedArg.newInstance();
                        ea.setValue(value);
                        m.invoke(parent, new Object[] {ea});
                    } catch (InstantiationException ie) {
                        throw new BuildException(ie);
                    }
                }
            };
        } else if (reflectedArg.getSuperclass() != null
                   && reflectedArg.getSuperclass().getName().equals(""java.lang.Enum"")) {
            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException, BuildException {
                    try {
                        m.invoke(parent, new Object[] {
                            reflectedArg.getMethod(""valueOf"", new Class[] {String.class}).
                                    invoke(null, new Object[] {value})});
                    } catch (InvocationTargetException x) {
                        if (x.getTargetException() instanceof IllegalArgumentException) {
                            throw new BuildException(
                                ""'"" + value + ""' is not a permitted value for ""
                                + reflectedArg.getName());
                        } else {
                            throw new BuildException(x.getTargetException());
                        }
                    } catch (Exception x) {
                        throw new BuildException(x);
                    }
                }
            };
        
        
        
        
        } else {
            boolean includeProject;
            Constructor c;
            try {
                
                c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});
                includeProject = true;
            } catch (NoSuchMethodException nme) {
                
                try {
                    c = reflectedArg.getConstructor(new Class[] {String.class});
                    includeProject = false;
                } catch (NoSuchMethodException nme2) {
                    
                    return null;
                }
            }
            final boolean finalIncludeProject = includeProject;
            final Constructor finalConstructor = c;

            return new AttributeSetter(m) {
                public void set(Project p, Object parent, String value)
                        throws InvocationTargetException, IllegalAccessException, BuildException {
                    try {
                        Object[] args = (finalIncludeProject)
                            ? new Object[] {p, value} : new Object[] {value};

                        Object attribute = finalConstructor.newInstance(args);
                        if (p != null) {
                            p.setProjectReference(attribute);
                        }
                        m.invoke(parent, new Object[] {attribute});
                    } catch (InstantiationException ie) {
                        throw new BuildException(ie);
                    }
                }
            };
        }
    }

    
    protected String getElementName(Project project, Object element) {
        return project.getElementName(element);
    }

    
    private String getPropertyName(String methodName, String prefix) {
        return methodName.substring(prefix.length()).toLowerCase(Locale.US);
    }

    
    public static final class Creator {
        private NestedCreator nestedCreator;
        private Object parent;
        private Project project;
        private Object nestedObject;
        private String polyType;

        
        private Creator(
            Project project, Object parent, NestedCreator nestedCreator) {
            this.project = project;
            this.parent = parent;
            this.nestedCreator = nestedCreator;
        }

        
        public void setPolyType(String polyType) {
            this.polyType = polyType;
        }

        
        public Object create() {
            if (polyType != null) {
                if (!nestedCreator.isPolyMorphic()) {
                    throw new BuildException(
                        ""Not allowed to use the polymorphic form""
                        + "" for this element"");
                }
                ComponentHelper helper =
                    ComponentHelper.getComponentHelper(project);
                nestedObject = helper.createComponent(polyType);
                if (nestedObject == null) {
                    throw new BuildException(
                        ""Unable to create object of type "" + polyType);
                }
            }
            try {
                nestedObject = nestedCreator.create(
                    project, parent, nestedObject);
                if (project != null) {
                    project.setProjectReference(nestedObject);
                }
                return nestedObject;
            } catch (IllegalAccessException ex) {
                throw new BuildException(ex);
            } catch (InstantiationException ex) {
                throw new BuildException(ex);
            } catch (IllegalArgumentException ex) {
                if (polyType != null) {
                    throw new BuildException(
                        ""Invalid type used "" + polyType);
                }
                throw ex;
            } catch (InvocationTargetException ex) {
                Throwable t = ex.getTargetException();
                if (t instanceof BuildException) {
                    throw (BuildException) t;
                }
                throw new BuildException(t);
            }
        }

        
        public Object getRealObject() {
            return nestedCreator.getRealObject();
        }

        
        public void store() {
            try {
                nestedCreator.store(parent, nestedObject);
            } catch (IllegalAccessException ex) {
                throw new BuildException(ex);
            } catch (InstantiationException ex) {
                throw new BuildException(ex);
            } catch (IllegalArgumentException ex) {
                if (polyType != null) {
                    throw new BuildException(
                        ""Invalid type used "" + polyType);
                }
                throw ex;
            } catch (InvocationTargetException ex) {
                Throwable t = ex.getTargetException();
                if (t instanceof BuildException) {
                    throw (BuildException) t;
                }
                throw new BuildException(t);
            }
        }
    }

    
    private abstract static class NestedCreator {
        private Method method; 

        NestedCreator(Method m) {
            this.method = m;
        }
        Method getMethod() {
            return method;
        }
        boolean isPolyMorphic() {
            return false;
        }
        Object getRealObject() {
            return null;
        }
        abstract Object create(Project project, Object parent, Object child)
                        throws InvocationTargetException,
                               IllegalAccessException,
                               InstantiationException;
        void store(Object parent, Object child)
             throws InvocationTargetException,
                    IllegalAccessException,
                    InstantiationException {
            
        }
    }

    private class CreateNestedCreator extends NestedCreator {
        CreateNestedCreator(Method m) {
            super(m);
        }

        Object create(Project project, Object parent, Object ignore)
            throws InvocationTargetException, IllegalAccessException {
            return getMethod().invoke(parent, new Object[] {});
        }
    }

    
    private class AddNestedCreator extends NestedCreator {

        static final int ADD = 1;
        static final int ADD_CONFIGURED = 2;

        private Constructor constructor;
        private int behavior; 

        AddNestedCreator(Method m, Constructor c, int behavior) {
            super(m);
            this.constructor = c;
            this.behavior = behavior;
        }

        boolean isPolyMorphic() {
            return true;
        }

        Object create(Project project, Object parent, Object child)
                throws InvocationTargetException,
                IllegalAccessException, InstantiationException {
            if (child == null) {
                child = constructor.newInstance(
                    (constructor.getParameterTypes().length == 0)
                    ? new Object[] {} : new Object[] {project});
            }
            if (child instanceof PreSetDef.PreSetDefinition) {
                child = ((PreSetDef.PreSetDefinition) child)
                    .createObject(project);
            }
            if (behavior == ADD) {
                istore(parent, child);
            }
            return child;
        }

        void store(Object parent, Object child)
                throws InvocationTargetException,
                IllegalAccessException, InstantiationException {
            if (behavior == ADD_CONFIGURED) {
                istore(parent, child);
            }
        }

        private void istore(Object parent, Object child)
                throws InvocationTargetException,
                IllegalAccessException, InstantiationException {
            getMethod().invoke(parent, new Object[] {child});
        }
    }

    
    private abstract static class AttributeSetter {
        private Method method; 
        AttributeSetter(Method m) {
            this.method = m;
        }
        abstract void set(Project p, Object parent, String value)
                      throws InvocationTargetException,
                             IllegalAccessException,
                             BuildException;
    }

    
    public static void clearCache() {
        HELPERS.clear();
    }

    
    private NestedCreator createAddTypeCreator(
        Project project, Object parent, String elementName)
        throws BuildException {
        if (addTypeMethods.size() == 0) {
            return null;
        }
        ComponentHelper helper = ComponentHelper.getComponentHelper(project);

        Object addedObject = null;
        Method addMethod = null;
        Class clazz = helper.getComponentClass(elementName);
        if (clazz == null) {
            return null;
        }
        addMethod = findMatchingMethod(clazz, addTypeMethods);
        if (addMethod == null) {
            return null;
        }
        addedObject = helper.createComponent(elementName);
        if (addedObject == null) {
            return null;
        }
        Object rObject = addedObject;
        if (addedObject instanceof PreSetDef.PreSetDefinition) {
            rObject = ((PreSetDef.PreSetDefinition) addedObject).createObject(
                project);
        }
        final Object nestedObject = addedObject;
        final Object realObject = rObject;

        return new NestedCreator(addMethod) {
            Object create(Project project, Object parent, Object ignore)
                    throws InvocationTargetException, IllegalAccessException {
                if (!getMethod().getName().endsWith(""Configured"")) {
                    getMethod().invoke(parent, new Object[] {realObject});
                }
                return nestedObject;
            }

            Object getRealObject() {
                return realObject;
            }

            void store(Object parent, Object child)
                    throws InvocationTargetException, IllegalAccessException,
                    InstantiationException {
                if (getMethod().getName().endsWith(""Configured"")) {
                    getMethod().invoke(parent, new Object[] {realObject});
                }
            }
        };
    }

    
    private void insertAddTypeMethod(Method method) {
        Class argClass = method.getParameterTypes()[0];
        for (int c = 0; c < addTypeMethods.size(); ++c) {
            Method current = (Method) addTypeMethods.get(c);
            if (current.getParameterTypes()[0].equals(argClass)) {
                if (method.getName().equals(""addConfigured"")) {
                    
                    addTypeMethods.set(c, method);
                }
                return; 
            }
            if (current.getParameterTypes()[0].isAssignableFrom(
                            argClass)) {
                addTypeMethods.add(c, method);
                return; 
            }
        }
        addTypeMethods.add(method);
    }

    
    private Method findMatchingMethod(Class paramClass, List methods) {
        Class matchedClass = null;
        Method matchedMethod = null;

        for (int i = 0; i < methods.size(); ++i) {
            Method method = (Method) methods.get(i);
            Class  methodClass = method.getParameterTypes()[0];
            if (methodClass.isAssignableFrom(paramClass)) {
                if (matchedClass == null) {
                    matchedClass = methodClass;
                    matchedMethod = method;
                } else {
                    if (!methodClass.isAssignableFrom(matchedClass)) {
                        throw new BuildException(""ambiguous: types ""
                            + matchedClass.getName() + "" and ""
                            + methodClass.getName() + "" match ""
                            + paramClass.getName());
                    }
                }
            }
        }
        return matchedMethod;
    }

    private String condenseText(final String text) {
        if (text.length() <= MAX_REPORT_NESTED_TEXT) {
            return text;
        }
        int ends = (MAX_REPORT_NESTED_TEXT - ELLIPSIS.length()) / 2;
        return new StringBuffer(text).replace(ends, text.length() - ends,
            ELLIPSIS).toString();
    }
}
"
org.apache.tools.ant.taskdefs.XSLTLoggerAware,1,1,0,3,1,0,2,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs;


public interface XSLTLoggerAware {
    
    void setLogger(XSLTLogger l);
}
"
org.apache.tools.ant.taskdefs.cvslib.ChangeLogTask,15,4,0,13,87,69,0,13,10,0.826530612,498,1.0,0,0.847826087,0.233333333,3,5,31.73333333,7,1.4667,2,"
package org.apache.tools.ant.taskdefs.cvslib;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.AbstractCvsTask;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.util.FileUtils;


public class ChangeLogTask extends AbstractCvsTask {
    
    private File usersFile;

    
    private Vector cvsUsers = new Vector();

    
    private File inputDir;

    
    private File destFile;

    
    private Date startDate;

    
    private Date endDate;

    
    private final Vector filesets = new Vector();


    
    public void setDir(final File inputDir) {
        this.inputDir = inputDir;
    }


    
    public void setDestfile(final File destFile) {
        this.destFile = destFile;
    }


    
    public void setUsersfile(final File usersFile) {
        this.usersFile = usersFile;
    }


    
    public void addUser(final CvsUser user) {
        cvsUsers.addElement(user);
    }


    
    public void setStart(final Date start) {
        this.startDate = start;
    }


    
    public void setEnd(final Date endDate) {
        this.endDate = endDate;
    }


    
    public void setDaysinpast(final int days) {
        final long time = System.currentTimeMillis()
             - (long) days * 24 * 60 * 60 * 1000;

        setStart(new Date(time));
    }


    
    public void addFileset(final FileSet fileSet) {
        filesets.addElement(fileSet);
    }


    
    public void execute() throws BuildException {
        File savedDir = inputDir; 

        try {

            validate();
            final Properties userList = new Properties();

            loadUserlist(userList);

            for (int i = 0, size = cvsUsers.size(); i < size; i++) {
                final CvsUser user = (CvsUser) cvsUsers.get(i);
                user.validate();
                userList.put(user.getUserID(), user.getDisplayname());
            }

            setCommand(""log"");

            if (getTag() != null) {
                CvsVersion myCvsVersion = new CvsVersion();
                myCvsVersion.setProject(getProject());
                myCvsVersion.setTaskName(""cvsversion"");
                myCvsVersion.setCvsRoot(getCvsRoot());
                myCvsVersion.setCvsRsh(getCvsRsh());
                myCvsVersion.setPassfile(getPassFile());
                myCvsVersion.setDest(inputDir);
                myCvsVersion.execute();
                if (myCvsVersion.supportsCvsLogWithSOption()) {
                    addCommandArgument(""-S"");
                }
            }
            if (null != startDate) {
                final SimpleDateFormat outputDate =
                    new SimpleDateFormat(""yyyy-MM-dd"");

                
                final String dateRange = "">="" + outputDate.format(startDate);

                
                addCommandArgument(""-d"");
                addCommandArgument(dateRange);
            }

            
            if (!filesets.isEmpty()) {
                final Enumeration e = filesets.elements();

                while (e.hasMoreElements()) {
                    final FileSet fileSet = (FileSet) e.nextElement();
                    final DirectoryScanner scanner =
                        fileSet.getDirectoryScanner(getProject());
                    final String[] files = scanner.getIncludedFiles();

                    for (int i = 0; i < files.length; i++) {
                        addCommandArgument(files[i]);
                    }
                }
            }

            final ChangeLogParser parser = new ChangeLogParser();
            final RedirectingStreamHandler handler =
                new RedirectingStreamHandler(parser);

            log(getCommand(), Project.MSG_VERBOSE);

            setDest(inputDir);
            setExecuteStreamHandler(handler);
            try {
                super.execute();
            } finally {
                final String errors = handler.getErrors();

                if (null != errors) {
                    log(errors, Project.MSG_ERR);
                }
            }
            final CVSEntry[] entrySet = parser.getEntrySetAsArray();
            final CVSEntry[] filteredEntrySet = filterEntrySet(entrySet);

            replaceAuthorIdWithName(userList, filteredEntrySet);

            writeChangeLog(filteredEntrySet);

        } finally {
            inputDir = savedDir;
        }
    }

    
    private void validate()
         throws BuildException {
        if (null == inputDir) {
            inputDir = getProject().getBaseDir();
        }
        if (null == destFile) {
            final String message = ""Destfile must be set."";

            throw new BuildException(message);
        }
        if (!inputDir.exists()) {
            final String message = ""Cannot find base dir ""
                 + inputDir.getAbsolutePath();

            throw new BuildException(message);
        }
        if (null != usersFile && !usersFile.exists()) {
            final String message = ""Cannot find user lookup list ""
                 + usersFile.getAbsolutePath();

            throw new BuildException(message);
        }
    }

    
    private void loadUserlist(final Properties userList)
         throws BuildException {
        if (null != usersFile) {
            try {
                userList.load(new FileInputStream(usersFile));
            } catch (final IOException ioe) {
                throw new BuildException(ioe.toString(), ioe);
            }
        }
    }

    
    private CVSEntry[] filterEntrySet(final CVSEntry[] entrySet) {
        final Vector results = new Vector();

        for (int i = 0; i < entrySet.length; i++) {
            final CVSEntry cvsEntry = entrySet[i];
            final Date date = cvsEntry.getDate();

            
            
            
            
            
            
            
            
            
            
            

            
            if (null == date) {
                continue;
            }

            if (null != startDate && startDate.after(date)) {
                
                continue;
            }
            if (null != endDate && endDate.before(date)) {
                
                continue;
            }
            results.addElement(cvsEntry);
        }

        final CVSEntry[] resultArray = new CVSEntry[results.size()];

        results.copyInto(resultArray);
        return resultArray;
    }

    
    private void replaceAuthorIdWithName(final Properties userList,
                                         final CVSEntry[] entrySet) {
        for (int i = 0; i < entrySet.length; i++) {

            final CVSEntry entry = entrySet[ i ];
            if (userList.containsKey(entry.getAuthor())) {
                entry.setAuthor(userList.getProperty(entry.getAuthor()));
            }
        }
    }

    
    private void writeChangeLog(final CVSEntry[] entrySet)
         throws BuildException {
        FileOutputStream output = null;

        try {
            output = new FileOutputStream(destFile);

            final PrintWriter writer =
                new PrintWriter(new OutputStreamWriter(output, ""UTF-8""));

            final ChangeLogWriter serializer = new ChangeLogWriter();

            serializer.printChangeLog(writer, entrySet);
        } catch (final UnsupportedEncodingException uee) {
            getProject().log(uee.toString(), Project.MSG_ERR);
        } catch (final IOException ioe) {
            throw new BuildException(ioe.toString(), ioe);
        } finally {
            FileUtils.close(output);
        }
    }
}

"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.FieldRefCPInfo,7,2,0,4,21,3,2,4,7,0.666666667,108,1.0,0,0.5,0.428571429,1,1,13.71428571,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class FieldRefCPInfo extends ConstantPoolEntry {
    
    private String fieldClassName;
    
    private String fieldName;
    
    private String fieldType;
    
    private int classIndex;
    
    private int nameAndTypeIndex;

    
    public FieldRefCPInfo() {
        super(CONSTANT_FIELDREF, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        classIndex = cpStream.readUnsignedShort();
        nameAndTypeIndex = cpStream.readUnsignedShort();
    }

    
    public void resolve(ConstantPool constantPool) {
        ClassCPInfo fieldClass
            = (ClassCPInfo) constantPool.getEntry(classIndex);

        fieldClass.resolve(constantPool);

        fieldClassName = fieldClass.getClassName();

        NameAndTypeCPInfo nt
            = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);

        nt.resolve(constantPool);

        fieldName = nt.getName();
        fieldType = nt.getType();

        super.resolve(constantPool);
    }

    
    public String toString() {
        String value;

        if (isResolved()) {
            value = ""Field : Class = "" + fieldClassName + "", name = ""
                + fieldName + "", type = "" + fieldType;
        } else {
            value = ""Field : Class index = "" + classIndex
                + "", name and type index = "" + nameAndTypeIndex;
        }

        return value;
    }

    
    public String getFieldClassName() {
        return fieldClassName;
    }

    
    public String getFieldName() {
        return fieldName;
    }

    
    public String getFieldType() {
        return fieldType;
    }

}

"
org.apache.tools.ant.taskdefs.cvslib.ChangeLogParser,12,1,0,4,41,0,3,1,3,0.76969697,381,1.0,0,0.0,0.818181818,0,0,29.5,3,1.6667,1,"
package org.apache.tools.ant.taskdefs.cvslib;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Locale;
import java.util.TimeZone;


class ChangeLogParser {
    
    private static final int GET_FILE = 1;
    private static final int GET_DATE = 2;
    private static final int GET_COMMENT = 3;
    private static final int GET_REVISION = 4;
    private static final int GET_PREVIOUS_REV = 5;



    
    private static final SimpleDateFormat INPUT_DATE
        = new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss"", Locale.US);
    
    private static final SimpleDateFormat CVS1129_INPUT_DATE =
        new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss Z"", Locale.US);

    static {
        TimeZone utc = TimeZone.getTimeZone(""UTC"");
        INPUT_DATE.setTimeZone(utc);
        CVS1129_INPUT_DATE.setTimeZone(utc);
    }

    
    private String file;
    private String date;
    private String author;
    private String comment;
    private String revision;
    private String previousRevision;

    private int status = GET_FILE;

    
    private final Hashtable entries = new Hashtable();

    
    public CVSEntry[] getEntrySetAsArray() {
        final CVSEntry[] array = new CVSEntry[ entries.size() ];
        int i = 0;
        for (Enumeration e = entries.elements(); e.hasMoreElements();) {
            array[i++] = (CVSEntry) e.nextElement();
        }
        return array;
    }

    
    public void stdout(final String line) {
        switch(status) {
            case GET_FILE:
                
                
                reset();
                processFile(line);
                break;
            case GET_REVISION:
                processRevision(line);
                break;

            case GET_DATE:
                processDate(line);
                break;

            case GET_COMMENT:
                processComment(line);
                break;

            case GET_PREVIOUS_REV:
                processGetPreviousRevision(line);
                break;

            default:
                
                break;
        }
    }

    
    private void processComment(final String line) {
        final String lineSeparator = System.getProperty(""line.separator"");
        if (line.equals(
                ""============================================================================="")) {
            
            
            final int end
                = comment.length() - lineSeparator.length(); 
            comment = comment.substring(0, end);
            saveEntry();
            status = GET_FILE;
        } else if (line.equals(""----------------------------"")) {
            final int end
                = comment.length() - lineSeparator.length(); 
            comment = comment.substring(0, end);
            status = GET_PREVIOUS_REV;
        } else {
            comment += line + lineSeparator;
        }
    }

    
    private void processFile(final String line) {
        if (line.startsWith(""Working file:"")) {
            file = line.substring(14, line.length());
            status = GET_REVISION;
        }
    }

    
    private void processRevision(final String line) {
        if (line.startsWith(""revision"")) {
            revision = line.substring(9);
            status = GET_DATE;
        } else if (line.startsWith(""======"")) {
            
            
            status = GET_FILE;
        }
    }

    
    private void processDate(final String line) {
        if (line.startsWith(""date:"")) {
            
            
            
            int endOfDateIndex = line.indexOf(';');
            date = line.substring(""date: "".length(), endOfDateIndex);

            int startOfAuthorIndex = line.indexOf(""author: "", endOfDateIndex + 1);
            int endOfAuthorIndex = line.indexOf(';', startOfAuthorIndex + 1);
            author = line.substring(""author: "".length() + startOfAuthorIndex, endOfAuthorIndex);

            status = GET_COMMENT;

            
            
            comment = """";
        }
    }

    
    private void processGetPreviousRevision(final String line) {
        if (!line.startsWith(""revision "")) {
            throw new IllegalStateException(""Unexpected line from CVS: ""
                + line);
        }
        previousRevision = line.substring(""revision "".length());

        saveEntry();

        revision = previousRevision;
        status = GET_DATE;
    }

    
    private void saveEntry() {
        final String entryKey = date + author + comment;
        CVSEntry entry;
        if (!entries.containsKey(entryKey)) {
            Date dateObject = parseDate(date);
            entry = new CVSEntry(dateObject, author, comment);
            entries.put(entryKey, entry);
        } else {
            entry = (CVSEntry) entries.get(entryKey);
        }

        entry.addFile(file, revision, previousRevision);
    }

    
    private Date parseDate(final String date) {
        try {
            return INPUT_DATE.parse(date);
        } catch (ParseException e) {
            try {
                return CVS1129_INPUT_DATE.parse(date);
            } catch (ParseException e2) {
                throw new IllegalStateException(""Invalid date format: "" + date);
            }
        }
    }

    
    public void reset() {
        this.file = null;
        this.date = null;
        this.author = null;
        this.comment = null;
        this.revision = null;
        this.previousRevision = null;
    }
}
"
org.apache.tools.ant.dispatch.Dispatchable,1,1,0,2,1,0,2,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.dispatch;


public interface Dispatchable {
    
    String getActionParameterName();
}
"
org.apache.tools.ant.taskdefs.cvslib.CvsTagDiff,13,4,0,6,72,22,0,6,8,0.898809524,623,0.571428571,2,0.876404494,0.273809524,1,2,45.84615385,1,0.8462,1,"
package org.apache.tools.ant.taskdefs.cvslib;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Vector;
import java.util.StringTokenizer;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.AbstractCvsTask;
import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.DOMUtils;
import org.apache.tools.ant.util.FileUtils;

import org.w3c.dom.Document;
import org.w3c.dom.Element;


public class CvsTagDiff extends AbstractCvsTask {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private static final DOMElementWriter DOM_WRITER = new DOMElementWriter();

    
    static final String FILE_STRING = ""File "";
    
    static final String TO_STRING = "" to "";
    
    static final String FILE_IS_NEW = "" is new;"";
    
    static final String REVISION = ""revision "";

    
    static final String FILE_HAS_CHANGED = "" changed from revision "";

    
    static final String FILE_WAS_REMOVED = "" is removed"";

    
    private String mypackage;

    
    private String mystartTag;

    
    private String myendTag;

    
    private String mystartDate;

    
    private String myendDate;

    
    private File mydestfile;

    
    public void setPackage(String p) {
        mypackage = p;
    }

    
    public void setStartTag(String s) {
        mystartTag = s;
    }

    
    public void setStartDate(String s) {
        mystartDate = s;
    }

    
    public void setEndTag(String s) {
        myendTag = s;
    }

    
    public void setEndDate(String s) {
        myendDate = s;
    }

    
    public void setDestFile(File f) {
        mydestfile = f;
    }

    
    public void execute() throws BuildException {
        
        validate();

        
        addCommandArgument(""rdiff"");
        addCommandArgument(""-s"");
        if (mystartTag != null) {
            addCommandArgument(""-r"");
            addCommandArgument(mystartTag);
        } else {
            addCommandArgument(""-D"");
            addCommandArgument(mystartDate);
        }
        if (myendTag != null) {
            addCommandArgument(""-r"");
            addCommandArgument(myendTag);
        } else {
            addCommandArgument(""-D"");
            addCommandArgument(myendDate);
        }
        
        StringTokenizer myTokenizer = new StringTokenizer(mypackage);
        while (myTokenizer.hasMoreTokens()) {
            addCommandArgument(myTokenizer.nextToken());
        }
        
        setCommand("""");
        File tmpFile = null;
        try {
            tmpFile = FILE_UTILS.createTempFile(""cvstagdiff"", "".log"", null);
            tmpFile.deleteOnExit();
            setOutput(tmpFile);

            
            super.execute();

            
            CvsTagEntry[] entries = parseRDiff(tmpFile);

            
            writeTagDiff(entries);

        } finally {
            if (tmpFile != null) {
                tmpFile.delete();
            }
        }
    }

    
    private CvsTagEntry[] parseRDiff(File tmpFile) throws BuildException {
        
        BufferedReader reader = null;

        try {
            reader = new BufferedReader(new FileReader(tmpFile));

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            String toBeRemoved = FILE_STRING + mypackage + ""/"";
            int headerLength = toBeRemoved.length();
            Vector entries = new Vector();

            String line = reader.readLine();
            int index;
            CvsTagEntry entry = null;

            while (null != line) {
                if (line.length() > headerLength) {
                    if (line.startsWith(toBeRemoved)) {
                        line = line.substring(headerLength);
                    } else {
                        line = line.substring(FILE_STRING.length());
                    }

                    if ((index = line.indexOf(FILE_IS_NEW)) != -1) {
                        
                        
                        String filename = line.substring(0, index);
                        String rev = null;
                        int indexrev = -1;
                        if ((indexrev = line.indexOf(REVISION, index)) != -1) {
                            rev = line.substring(indexrev + REVISION.length());
                        }
                        entry = new CvsTagEntry(filename, rev);
                        entries.addElement(entry);
                        log(entry.toString(), Project.MSG_VERBOSE);
                    } else if ((index = line.indexOf(FILE_HAS_CHANGED)) != -1) {
                        
                        
                        String filename = line.substring(0, index);
                        int revSeparator = line.indexOf("" to "", index);
                        String prevRevision =
                            line.substring(index + FILE_HAS_CHANGED.length(),
                                revSeparator);
                        String revision = line.substring(revSeparator + TO_STRING.length());
                        entry = new CvsTagEntry(filename,
                            revision,
                            prevRevision);
                        entries.addElement(entry);
                        log(entry.toString(), Project.MSG_VERBOSE);
                    } else if ((index = line.indexOf(FILE_WAS_REMOVED)) != -1) {
                        
                        String filename = line.substring(0, index);
                        String rev = null;
                        int indexrev = -1;
                        if ((indexrev = line.indexOf(REVISION, index)) != -1) {
                            rev = line.substring(indexrev + REVISION.length());
                        }
                        entry = new CvsTagEntry(filename, null, rev);
                        entries.addElement(entry);
                        log(entry.toString(), Project.MSG_VERBOSE);
                    }
                }
                line = reader.readLine();
            }

            CvsTagEntry[] array = new CvsTagEntry[entries.size()];
            entries.copyInto(array);

            return array;
        } catch (IOException e) {
            throw new BuildException(""Error in parsing"", e);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    log(e.toString(), Project.MSG_ERR);
                }
            }
        }
    }

    
    private void writeTagDiff(CvsTagEntry[] entries) throws BuildException {
        FileOutputStream output = null;
        try {
            output = new FileOutputStream(mydestfile);
            PrintWriter writer = new PrintWriter(
                                     new OutputStreamWriter(output, ""UTF-8""));
            writer.println(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
            Document doc = DOMUtils.newDocument();
            Element root = doc.createElement(""tagdiff"");
            if (mystartTag != null) {
                root.setAttribute(""startTag"", mystartTag);
            } else {
                root.setAttribute(""startDate"", mystartDate);
            }
            if (myendTag != null) {
                root.setAttribute(""endTag"", myendTag);
            } else {
                root.setAttribute(""endDate"", myendDate);
            }

            root.setAttribute(""cvsroot"", getCvsRoot());
            root.setAttribute(""package"", mypackage);
            DOM_WRITER.openElement(root, writer, 0, ""\t"");
            writer.println();
            for (int i = 0, c = entries.length; i < c; i++) {
                writeTagEntry(doc, writer, entries[i]);
            }
            DOM_WRITER.closeElement(root, writer, 0, ""\t"", true);
            writer.flush();
            writer.close();
        } catch (UnsupportedEncodingException uee) {
            log(uee.toString(), Project.MSG_ERR);
        } catch (IOException ioe) {
            throw new BuildException(ioe.toString(), ioe);
        } finally {
            if (null != output) {
                try {
                    output.close();
                } catch (IOException ioe) {
                    log(ioe.toString(), Project.MSG_ERR);
                }
            }
        }
    }

    
    private void writeTagEntry(Document doc, PrintWriter writer,
                               CvsTagEntry entry)
        throws IOException {
        Element ent = doc.createElement(""entry"");
        Element f = DOMUtils.createChildElement(ent, ""file"");
        DOMUtils.appendCDATAElement(f, ""name"", entry.getFile());
        if (entry.getRevision() != null) {
            DOMUtils.appendTextElement(f, ""revision"", entry.getRevision());
        }
        if (entry.getPreviousRevision() != null) {
            DOMUtils.appendTextElement(f, ""prevrevision"",
                                       entry.getPreviousRevision());
        }
        DOM_WRITER.write(ent, writer, 1, ""\t"");
    }

    
    private void validate() throws BuildException {
        if (null == mypackage) {
            throw new BuildException(""Package/module must be set."");
        }

        if (null == mydestfile) {
            throw new BuildException(""Destfile must be set."");
        }

        if (null == mystartTag && null == mystartDate) {
            throw new BuildException(""Start tag or start date must be set."");
        }

        if (null != mystartTag && null != mystartDate) {
            throw new BuildException(""Only one of start tag and start date ""
                                     + ""must be set."");
        }

        if (null == myendTag && null == myendDate) {
            throw new BuildException(""End tag or end date must be set."");
        }

        if (null != myendTag && null != myendDate) {
            throw new BuildException(""Only one of end tag and end date must ""
                                     + ""be set."");
        }
    }
}
"
org.apache.tools.bzip2.CBZip2OutputStream,41,2,0,6,60,402,3,3,8,0.889166667,4541,0.933333333,2,0.11627907,0.191666667,1,1,109.0243902,47,5.5854,6,"



package org.apache.tools.bzip2;

import java.io.OutputStream;
import java.io.IOException;


public class CBZip2OutputStream extends OutputStream implements BZip2Constants {

    
    public static final int MIN_BLOCKSIZE = 1;

    
    public static final int MAX_BLOCKSIZE = 9;

    
    protected static final int SETMASK = (1 << 21);

    
    protected static final int CLEARMASK = (~SETMASK);

    
    protected static final int GREATER_ICOST = 15;

    
    protected static final int LESSER_ICOST = 0;

    
    protected static final int SMALL_THRESH = 20;

    
    protected static final int DEPTH_THRESH = 10;

    
    protected static final int WORK_FACTOR = 30;

    
    protected static final int QSORT_STACK_SIZE = 1000;

    
    private static final int[] INCS = {
        1,
        4,
        13,
        40,
        121,
        364,
        1093,
        3280,
        9841,
        29524,
        88573,
        265720,
        797161,
        2391484
    };

    
    protected static void hbMakeCodeLengths(char[] len, int[] freq,
                                            int alphaSize, int maxLen) {
        
        final int[] heap    = new int[MAX_ALPHA_SIZE * 2];
        final int[] weight  = new int[MAX_ALPHA_SIZE * 2];
        final int[] parent  = new int[MAX_ALPHA_SIZE * 2];

        for (int i = alphaSize; --i >= 0;) {
            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
        }

        for (boolean tooLong = true; tooLong;) {
            tooLong = false;

            int nNodes = alphaSize;
            int nHeap = 0;
            heap[0] = 0;
            weight[0] = 0;
            parent[0] = -2;

            for (int i = 1; i <= alphaSize; i++) {
                parent[i] = -1;
                nHeap++;
                heap[nHeap] = i;

                int zz = nHeap;
                int tmp = heap[zz];
                while (weight[tmp] < weight[heap[zz >> 1]]) {
                    heap[zz] = heap[zz >> 1];
                    zz >>= 1;
                }
                heap[zz] = tmp;
            }

            

            while (nHeap > 1) {
                int n1 = heap[1];
                heap[1] = heap[nHeap];
                nHeap--;

                int yy = 0;
                int zz = 1;
                int tmp = heap[1];

                while (true) {
                    yy = zz << 1;

                    if (yy > nHeap) {
                        break;
                    }

                    if ((yy < nHeap)
                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                        yy++;
                    }

                    if (weight[tmp] < weight[heap[yy]]) {
                        break;
                    }

                    heap[zz] = heap[yy];
                    zz = yy;
                }

                heap[zz] = tmp;

                int n2 = heap[1];
                heap[1] = heap[nHeap];
                nHeap--;

                yy = 0;
                zz = 1;
                tmp = heap[1];

                while (true) {
                    yy = zz << 1;

                    if (yy > nHeap) {
                        break;
                    }

                    if ((yy < nHeap)
                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                        yy++;
                    }

                    if (weight[tmp] < weight[heap[yy]]) {
                        break;
                    }

                    heap[zz] = heap[yy];
                    zz = yy;
                }

                heap[zz] = tmp;
                nNodes++;
                parent[n1] = parent[n2] = nNodes;

                final int weight_n1 = weight[n1];
                final int weight_n2 = weight[n2];
                weight[nNodes] = (((weight_n1 & 0xffffff00)
                                   + (weight_n2 & 0xffffff00))
                                  | (1 + (((weight_n1 & 0x000000ff)
                                           > (weight_n2 & 0x000000ff))
                                          ? (weight_n1 & 0x000000ff)
                                          : (weight_n2 & 0x000000ff))));
                
                parent[nNodes] = -1;
                nHeap++;
                heap[nHeap] = nNodes;

                tmp = 0;
                zz = nHeap;
                tmp = heap[zz];
                final int weight_tmp = weight[tmp];
                while (weight_tmp < weight[heap[zz >> 1]]) {
                    heap[zz] = heap[zz >> 1];
                    zz >>= 1;
                }
                heap[zz] = tmp;

            }

            

            for (int i = 1; i <= alphaSize; i++) {
                int j = 0;
                int k = i;

                for (int parent_k; (parent_k = parent[k]) >= 0;) {
                    k = parent_k;
                    j++;
                }

                len[i - 1] = (char) j;
                if (j > maxLen) {
                    tooLong = true;
                }
            }

            if (tooLong) {
                for (int i = 1; i < alphaSize; i++) {
                    int j = weight[i] >> 8;
                    j = 1 + (j >> 1);
                    weight[i] = j << 8;
                }
            }
        }
    }

    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,
                                          final Data dat, final int alphaSize,
                                          final int maxLen) {
        
        final int[] heap    = dat.heap;
        final int[] weight  = dat.weight;
        final int[] parent  = dat.parent;

        for (int i = alphaSize; --i >= 0;) {
            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
        }

        for (boolean tooLong = true; tooLong;) {
            tooLong = false;

            int nNodes = alphaSize;
            int nHeap = 0;
            heap[0] = 0;
            weight[0] = 0;
            parent[0] = -2;

            for (int i = 1; i <= alphaSize; i++) {
                parent[i] = -1;
                nHeap++;
                heap[nHeap] = i;

                int zz = nHeap;
                int tmp = heap[zz];
                while (weight[tmp] < weight[heap[zz >> 1]]) {
                    heap[zz] = heap[zz >> 1];
                    zz >>= 1;
                }
                heap[zz] = tmp;
            }

            while (nHeap > 1) {
                int n1 = heap[1];
                heap[1] = heap[nHeap];
                nHeap--;

                int yy = 0;
                int zz = 1;
                int tmp = heap[1];

                while (true) {
                    yy = zz << 1;

                    if (yy > nHeap) {
                        break;
                    }

                    if ((yy < nHeap)
                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                        yy++;
                    }

                    if (weight[tmp] < weight[heap[yy]]) {
                        break;
                    }

                    heap[zz] = heap[yy];
                    zz = yy;
                }

                heap[zz] = tmp;

                int n2 = heap[1];
                heap[1] = heap[nHeap];
                nHeap--;

                yy = 0;
                zz = 1;
                tmp = heap[1];

                while (true) {
                    yy = zz << 1;

                    if (yy > nHeap) {
                        break;
                    }

                    if ((yy < nHeap)
                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                        yy++;
                    }

                    if (weight[tmp] < weight[heap[yy]]) {
                        break;
                    }

                    heap[zz] = heap[yy];
                    zz = yy;
                }

                heap[zz] = tmp;
                nNodes++;
                parent[n1] = parent[n2] = nNodes;

                final int weight_n1 = weight[n1];
                final int weight_n2 = weight[n2];
                weight[nNodes] = ((weight_n1 & 0xffffff00)
                                  + (weight_n2 & 0xffffff00))
                    | (1 + (((weight_n1 & 0x000000ff)
                             > (weight_n2 & 0x000000ff))
                            ? (weight_n1 & 0x000000ff)
                            : (weight_n2 & 0x000000ff)));

                parent[nNodes] = -1;
                nHeap++;
                heap[nHeap] = nNodes;

                tmp = 0;
                zz = nHeap;
                tmp = heap[zz];
                final int weight_tmp = weight[tmp];
                while (weight_tmp < weight[heap[zz >> 1]]) {
                    heap[zz] = heap[zz >> 1];
                    zz >>= 1;
                }
                heap[zz] = tmp;

            }

            for (int i = 1; i <= alphaSize; i++) {
                int j = 0;
                int k = i;

                for (int parent_k; (parent_k = parent[k]) >= 0;) {
                    k = parent_k;
                    j++;
                }

                len[i - 1] = (byte) j;
                if (j > maxLen) {
                    tooLong = true;
                }
            }

            if (tooLong) {
                for (int i = 1; i < alphaSize; i++) {
                    int j = weight[i] >> 8;
                    j = 1 + (j >> 1);
                    weight[i] = j << 8;
                }
            }
        }
    }

    
    private int last;

    
    private int origPtr;

    
    private final int blockSize100k;

    private boolean blockRandomised;

    private int bsBuff;
    private int bsLive;
    private final CRC crc = new CRC();

    private int nInUse;

    private int nMTF;

    
    private int workDone;
    private int workLimit;
    private boolean firstAttempt;

    private int currentChar = -1;
    private int runLength = 0;

    private int blockCRC;
    private int combinedCRC;
    private int allowableBlockSize;

    
    private CBZip2OutputStream.Data data;

    private OutputStream out;

    
    public static int chooseBlockSize(long inputLength) {
        return (inputLength > 0)
            ? (int) Math.min((inputLength / 132000) + 1, 9)
            : MAX_BLOCKSIZE;
    }

    
    public CBZip2OutputStream(final OutputStream out) throws IOException {
        this(out, MAX_BLOCKSIZE);
    }

    
    public CBZip2OutputStream(final OutputStream out, final int blockSize)
        throws IOException {
        super();

        if (blockSize < 1) {
            throw new IllegalArgumentException(""blockSize("" + blockSize
                                               + "") < 1"");
        }
        if (blockSize > 9) {
            throw new IllegalArgumentException(""blockSize("" + blockSize
                                               + "") > 9"");
        }

        this.blockSize100k = blockSize;
        this.out = out;
        init();
    }

    public void write(final int b) throws IOException {
        if (this.out != null) {
            write0(b);
        } else {
            throw new IOException(""closed"");
        }
    }

    private void writeRun() throws IOException {
        final int lastShadow = this.last;

        if (lastShadow < this.allowableBlockSize) {
            final int currentCharShadow = this.currentChar;
            final Data dataShadow = this.data;
            dataShadow.inUse[currentCharShadow] = true;
            final byte ch = (byte) currentCharShadow;

            int runLengthShadow = this.runLength;
            this.crc.updateCRC(currentCharShadow, runLengthShadow);

            switch (runLengthShadow) {
            case 1:
                dataShadow.block[lastShadow + 2] = ch;
                this.last = lastShadow + 1;
                break;

            case 2:
                dataShadow.block[lastShadow + 2] = ch;
                dataShadow.block[lastShadow + 3] = ch;
                this.last = lastShadow + 2;
                break;

            case 3:
                {
                    final byte[] block = dataShadow.block;
                    block[lastShadow + 2] = ch;
                    block[lastShadow + 3] = ch;
                    block[lastShadow + 4] = ch;
                    this.last = lastShadow + 3;
                }
                break;

            default:
                {
                    runLengthShadow -= 4;
                    dataShadow.inUse[runLengthShadow] = true;
                    final byte[] block = dataShadow.block;
                    block[lastShadow + 2] = ch;
                    block[lastShadow + 3] = ch;
                    block[lastShadow + 4] = ch;
                    block[lastShadow + 5] = ch;
                    block[lastShadow + 6] = (byte) runLengthShadow;
                    this.last = lastShadow + 5;
                }
                break;

            }
        } else {
            endBlock();
            initBlock();
            writeRun();
        }
    }

    
    protected void finalize() throws Throwable {
        close();
        super.finalize();
    }

    public void close() throws IOException {
        OutputStream outShadow = this.out;
        if (outShadow != null) {
            try {
                if (this.runLength > 0) {
                    writeRun();
                }
                this.currentChar = -1;
                endBlock();
                endCompression();
                outShadow.close();
            } finally {
                this.out = null;
                this.data = null;
            }
        }
    }

    public void flush() throws IOException {
        OutputStream outShadow = this.out;
        if (outShadow != null) {
            outShadow.flush();
        }
    }

    private void init() throws IOException {
        
        
        

        this.data = new Data(this.blockSize100k);

        
        bsPutUByte('h');
        bsPutUByte('0' + this.blockSize100k);

        this.combinedCRC = 0;
        initBlock();
    }

    private void initBlock() {
        
        this.crc.initialiseCRC();
        this.last = -1;
        

        boolean[] inUse = this.data.inUse;
        for (int i = 256; --i >= 0;) {
            inUse[i] = false;
        }

        
        this.allowableBlockSize
            = (this.blockSize100k * BZip2Constants.baseBlockSize) - 20;
    }

    private void endBlock() throws IOException {
        this.blockCRC = this.crc.getFinalCRC();
        this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);
        this.combinedCRC ^= this.blockCRC;

        
        if (this.last == -1) {
            return;
        }

        
        blockSort();

        
        bsPutUByte(0x31);
        bsPutUByte(0x41);
        bsPutUByte(0x59);
        bsPutUByte(0x26);
        bsPutUByte(0x53);
        bsPutUByte(0x59);

        
        bsPutInt(this.blockCRC);

        
        if (this.blockRandomised) {
            bsW(1, 1);
        } else {
            bsW(1, 0);
        }

        
        moveToFrontCodeAndSend();
    }

    private void endCompression() throws IOException {
        
        bsPutUByte(0x17);
        bsPutUByte(0x72);
        bsPutUByte(0x45);
        bsPutUByte(0x38);
        bsPutUByte(0x50);
        bsPutUByte(0x90);

        bsPutInt(this.combinedCRC);
        bsFinishedWithStream();
    }

    
    public final int getBlockSize() {
        return this.blockSize100k;
    }

    public void write(final byte[] buf, int offs, final int len)
        throws IOException {
        if (offs < 0) {
            throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
        }
        if (len < 0) {
            throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
        }
        if (offs + len > buf.length) {
            throw new IndexOutOfBoundsException(""offs("" + offs + "") + len(""
                                                + len + "") > buf.length(""
                                                + buf.length + "")."");
        }
        if (this.out == null) {
            throw new IOException(""stream closed"");
        }

        for (int hi = offs + len; offs < hi;) {
            write0(buf[offs++]);
        }
    }

    private void write0(int b) throws IOException {
        if (this.currentChar != -1) {
            b &= 0xff;
            if (this.currentChar == b) {
                if (++this.runLength > 254) {
                    writeRun();
                    this.currentChar = -1;
                    this.runLength = 0;
                }
                
            } else {
                writeRun();
                this.runLength = 1;
                this.currentChar = b;
            }
        } else {
            this.currentChar = b & 0xff;
            this.runLength++;
        }
    }

    private static void hbAssignCodes(final int[] code, final byte[] length,
                                      final int minLen, final int maxLen,
                                      final int alphaSize) {
        int vec = 0;
        for (int n = minLen; n <= maxLen; n++) {
            for (int i = 0; i < alphaSize; i++) {
                if ((length[i] & 0xff) == n) {
                    code[i] = vec;
                    vec++;
                }
            }
            vec <<= 1;
        }
    }

    private void bsFinishedWithStream() throws IOException {
        while (this.bsLive > 0) {
            int ch = this.bsBuff >> 24;
            this.out.write(ch); 
            this.bsBuff <<= 8;
            this.bsLive -= 8;
        }
    }

    private void bsW(final int n, final int v) throws IOException {
        final OutputStream outShadow = this.out;
        int bsLiveShadow    = this.bsLive;
        int bsBuffShadow    = this.bsBuff;

        while (bsLiveShadow >= 8) {
            outShadow.write(bsBuffShadow >> 24); 
            bsBuffShadow <<= 8;
            bsLiveShadow -= 8;
        }

        this.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));
        this.bsLive = bsLiveShadow + n;
    }

    private void bsPutUByte(final int c) throws IOException {
        bsW(8, c);
    }

    private void bsPutInt(final int u) throws IOException {
        bsW(8, (u >> 24) & 0xff);
        bsW(8, (u >> 16) & 0xff);
        bsW(8, (u >>  8) & 0xff);
        bsW(8,  u        & 0xff);
    }

    private void sendMTFValues() throws IOException {
        final byte[][] len  = this.data.sendMTFValues_len;
        final int alphaSize = this.nInUse + 2;

        for (int t = N_GROUPS; --t >= 0;) {
            byte[] len_t = len[t];
            for (int v = alphaSize; --v >= 0;) {
                len_t[v] = GREATER_ICOST;
            }
        }

        
        
        final int nGroups =
            (this.nMTF <  200) ? 2
            : (this.nMTF <  600) ? 3
            : (this.nMTF < 1200) ? 4
            : (this.nMTF < 2400) ? 5
            : 6;

        
        sendMTFValues0(nGroups, alphaSize);

        
        final int nSelectors = sendMTFValues1(nGroups, alphaSize);

        
        sendMTFValues2(nGroups, nSelectors);

        
        sendMTFValues3(nGroups, alphaSize);

        
        sendMTFValues4();

        
        sendMTFValues5(nGroups, nSelectors);

        
        sendMTFValues6(nGroups, alphaSize);

        
        sendMTFValues7(nSelectors);
    }

    private void sendMTFValues0(final int nGroups, final int alphaSize) {
        final byte[][] len  = this.data.sendMTFValues_len;
        final int[] mtfFreq = this.data.mtfFreq;

        int remF = this.nMTF;
        int gs = 0;

        for (int nPart = nGroups; nPart > 0; nPart--) {
            final int tFreq = remF / nPart;
            int ge = gs - 1;
            int aFreq = 0;

            for (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {
                aFreq += mtfFreq[++ge];
            }

            if ((ge > gs)
                && (nPart != nGroups)
                && (nPart != 1)
                && (((nGroups - nPart) & 1) != 0)) {
                aFreq -= mtfFreq[ge--];
            }

            final byte[] len_np = len[nPart - 1];
            for (int v = alphaSize; --v >= 0;) {
                if ((v >= gs) && (v <= ge)) {
                    len_np[v] = LESSER_ICOST;
                } else {
                    len_np[v] = GREATER_ICOST;
                }
            }

            gs = ge + 1;
            remF -= aFreq;
        }
    }

    private int sendMTFValues1(final int nGroups, final int alphaSize) {
        final Data dataShadow       = this.data;
        final int[][] rfreq   = dataShadow.sendMTFValues_rfreq;
        final int[] fave      = dataShadow.sendMTFValues_fave;
        final short[] cost    = dataShadow.sendMTFValues_cost;
        final char[] sfmap    = dataShadow.sfmap;
        final byte[] selector = dataShadow.selector;
        final byte[][] len    = dataShadow.sendMTFValues_len;
        final byte[] len_0 = len[0];
        final byte[] len_1 = len[1];
        final byte[] len_2 = len[2];
        final byte[] len_3 = len[3];
        final byte[] len_4 = len[4];
        final byte[] len_5 = len[5];
        final int nMTFShadow = this.nMTF;

        int nSelectors = 0;

        for (int iter = 0; iter < N_ITERS; iter++) {
            for (int t = nGroups; --t >= 0;) {
                fave[t] = 0;
                int[] rfreqt = rfreq[t];
                for (int i = alphaSize; --i >= 0;) {
                    rfreqt[i] = 0;
                }
            }

            nSelectors = 0;

            for (int gs = 0; gs < this.nMTF;) {
                

                

                final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);

                if (nGroups == N_GROUPS) {
                    

                    short cost0 = 0;
                    short cost1 = 0;
                    short cost2 = 0;
                    short cost3 = 0;
                    short cost4 = 0;
                    short cost5 = 0;

                    for (int i = gs; i <= ge; i++) {
                        final int icv = sfmap[i];
                        cost0 += len_0[icv] & 0xff;
                        cost1 += len_1[icv] & 0xff;
                        cost2 += len_2[icv] & 0xff;
                        cost3 += len_3[icv] & 0xff;
                        cost4 += len_4[icv] & 0xff;
                        cost5 += len_5[icv] & 0xff;
                    }

                    cost[0] = cost0;
                    cost[1] = cost1;
                    cost[2] = cost2;
                    cost[3] = cost3;
                    cost[4] = cost4;
                    cost[5] = cost5;

                } else {
                    for (int t = nGroups; --t >= 0;) {
                        cost[t] = 0;
                    }

                    for (int i = gs; i <= ge; i++) {
                        final int icv = sfmap[i];
                        for (int t = nGroups; --t >= 0;) {
                            cost[t] += len[t][icv] & 0xff;
                        }
                    }
                }

                
                int bt = -1;
                for (int t = nGroups, bc = 999999999; --t >= 0;) {
                    final int cost_t = cost[t];
                    if (cost_t < bc) {
                        bc = cost_t;
                        bt = t;
                    }
                }

                fave[bt]++;
                selector[nSelectors] = (byte) bt;
                nSelectors++;

                
                final int[] rfreq_bt = rfreq[bt];
                for (int i = gs; i <= ge; i++) {
                    rfreq_bt[sfmap[i]]++;
                }

                gs = ge + 1;
            }

            
            for (int t = 0; t < nGroups; t++) {
                hbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);
            }
        }

        return nSelectors;
    }

    private void sendMTFValues2(final int nGroups, final int nSelectors) {
        

        final Data dataShadow = this.data;
        byte[] pos = dataShadow.sendMTFValues2_pos;

        for (int i = nGroups; --i >= 0;) {
            pos[i] = (byte) i;
        }

        for (int i = 0; i < nSelectors; i++) {
            final byte ll_i = dataShadow.selector[i];
            byte tmp = pos[0];
            int j = 0;

            while (ll_i != tmp) {
                j++;
                byte tmp2 = tmp;
                tmp = pos[j];
                pos[j] = tmp2;
            }

            pos[0] = tmp;
            dataShadow.selectorMtf[i] = (byte) j;
        }
    }

    private void sendMTFValues3(final int nGroups, final int alphaSize) {
        int[][] code  = this.data.sendMTFValues_code;
        byte[][] len  = this.data.sendMTFValues_len;

        for (int t = 0; t < nGroups; t++) {
            int minLen = 32;
            int maxLen = 0;
            final byte[] len_t = len[t];
            for (int i = alphaSize; --i >= 0;) {
                final int l = len_t[i] & 0xff;
                if (l > maxLen) {
                    maxLen = l;
                }
                if (l < minLen) {
                    minLen = l;
                }
            }

            
            

            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);
        }
    }

    private void sendMTFValues4() throws IOException {
        final boolean[] inUse = this.data.inUse;
        final boolean[] inUse16 = this.data.sentMTFValues4_inUse16;

        for (int i = 16; --i >= 0;) {
            inUse16[i] = false;
            final int i16 = i * 16;
            for (int j = 16; --j >= 0;) {
                if (inUse[i16 + j]) {
                    inUse16[i] = true;
                }
            }
        }

        for (int i = 0; i < 16; i++) {
            bsW(1, inUse16[i] ? 1 : 0);
        }

        final OutputStream outShadow = this.out;
        int bsLiveShadow    = this.bsLive;
        int bsBuffShadow    = this.bsBuff;

        for (int i = 0; i < 16; i++) {
            if (inUse16[i]) {
                final int i16 = i * 16;
                for (int j = 0; j < 16; j++) {
                    
                    while (bsLiveShadow >= 8) {
                        outShadow.write(bsBuffShadow >> 24); 
                        bsBuffShadow <<= 8;
                        bsLiveShadow -= 8;
                    }
                    if (inUse[i16 + j]) {
                        bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
                    }
                    bsLiveShadow++;
                }
            }
        }

        this.bsBuff = bsBuffShadow;
        this.bsLive = bsLiveShadow;
    }

    private void sendMTFValues5(final int nGroups, final int nSelectors)
        throws IOException {
        bsW(3, nGroups);
        bsW(15, nSelectors);

        final OutputStream outShadow = this.out;
        final byte[] selectorMtf = this.data.selectorMtf;

        int bsLiveShadow    = this.bsLive;
        int bsBuffShadow    = this.bsBuff;

        for (int i = 0; i < nSelectors; i++) {
            for (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {
                
                while (bsLiveShadow >= 8) {
                    outShadow.write(bsBuffShadow >> 24);
                    bsBuffShadow <<= 8;
                    bsLiveShadow -= 8;
                }
                bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
                bsLiveShadow++;
            }

            
            while (bsLiveShadow >= 8) {
                outShadow.write(bsBuffShadow >> 24);
                bsBuffShadow <<= 8;
                bsLiveShadow -= 8;
            }
            
            bsLiveShadow++;
        }

        this.bsBuff = bsBuffShadow;
        this.bsLive = bsLiveShadow;
    }

    private void sendMTFValues6(final int nGroups, final int alphaSize)
        throws IOException {
        final byte[][] len = this.data.sendMTFValues_len;
        final OutputStream outShadow = this.out;

        int bsLiveShadow = this.bsLive;
        int bsBuffShadow = this.bsBuff;

        for (int t = 0; t < nGroups; t++) {
            byte[] len_t = len[t];
            int curr = len_t[0] & 0xff;

            
            while (bsLiveShadow >= 8) {
                outShadow.write(bsBuffShadow >> 24); 
                bsBuffShadow <<= 8;
                bsLiveShadow -= 8;
            }
            bsBuffShadow |= curr << (32 - bsLiveShadow - 5);
            bsLiveShadow += 5;

            for (int i = 0; i < alphaSize; i++) {
                int lti = len_t[i] & 0xff;
                while (curr < lti) {
                    
                    while (bsLiveShadow >= 8) {
                        outShadow.write(bsBuffShadow >> 24); 
                        bsBuffShadow <<= 8;
                        bsLiveShadow -= 8;
                    }
                    bsBuffShadow |= 2 << (32 - bsLiveShadow - 2);
                    bsLiveShadow += 2;

                    curr++; 
                }

                while (curr > lti) {
                    
                    while (bsLiveShadow >= 8) {
                        outShadow.write(bsBuffShadow >> 24); 
                        bsBuffShadow <<= 8;
                        bsLiveShadow -= 8;
                    }
                    bsBuffShadow |= 3 << (32 - bsLiveShadow - 2);
                    bsLiveShadow += 2;

                    curr--; 
                }

                
                while (bsLiveShadow >= 8) {
                    outShadow.write(bsBuffShadow >> 24); 
                    bsBuffShadow <<= 8;
                    bsLiveShadow -= 8;
                }
                
                bsLiveShadow++;
            }
        }

        this.bsBuff = bsBuffShadow;
        this.bsLive = bsLiveShadow;
    }

    private void sendMTFValues7(final int nSelectors) throws IOException {
        final Data dataShadow         = this.data;
        final byte[][] len      = dataShadow.sendMTFValues_len;
        final int[][] code      = dataShadow.sendMTFValues_code;
        final OutputStream outShadow  = this.out;
        final byte[] selector   = dataShadow.selector;
        final char[] sfmap      = dataShadow.sfmap;
        final int nMTFShadow          = this.nMTF;

        int selCtr = 0;

        int bsLiveShadow = this.bsLive;
        int bsBuffShadow = this.bsBuff;

        for (int gs = 0; gs < nMTFShadow;) {
            final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
            final int selector_selCtr = selector[selCtr] & 0xff;
            final int[] code_selCtr = code[selector_selCtr];
            final byte[] len_selCtr = len[selector_selCtr];

            while (gs <= ge) {
                final int sfmap_i = sfmap[gs];

                
                
                
                
                while (bsLiveShadow >= 8) {
                    outShadow.write(bsBuffShadow >> 24);
                    bsBuffShadow <<= 8;
                    bsLiveShadow -= 8;
                }
                final int n = len_selCtr[sfmap_i] & 0xFF;
                bsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);
                bsLiveShadow += n;

                gs++;
            }

            gs = ge + 1;
            selCtr++;
        }

        this.bsBuff = bsBuffShadow;
        this.bsLive = bsLiveShadow;
    }

    private void moveToFrontCodeAndSend() throws IOException {
        bsW(24, this.origPtr);
        generateMTFValues();
        sendMTFValues();
    }

    
    private boolean mainSimpleSort(final Data dataShadow, final int lo, final int hi,
                                   final int d) {
        final int bigN = hi - lo + 1;
        if (bigN < 2) {
            return this.firstAttempt && (this.workDone > this.workLimit);
        }

        int hp = 0;
        while (INCS[hp] < bigN) {
            hp++;
        }

        final int[] fmap            = dataShadow.fmap;
        final char[] quadrant       = dataShadow.quadrant;
        final byte[] block          = dataShadow.block;
        final int lastShadow              = this.last;
        final int lastPlus1         = lastShadow + 1;
        final boolean firstAttemptShadow  = this.firstAttempt;
        final int workLimitShadow         = this.workLimit;
        int workDoneShadow                = this.workDone;

        
        

        HP: while (--hp >= 0) {
            final int h = INCS[hp];
            final int mj = lo + h - 1;

            for (int i = lo + h; i <= hi;) {
                
                for (int k = 3; (i <= hi) && (--k >= 0); i++) {
                    final int v = fmap[i];
                    final int vd = v + d;
                    int j = i;

                    
                    
                    
                    
                    
                    
                    
                    

                    
                    boolean onceRunned = false;
                    int a = 0;

                    HAMMER: while (true) {
                        if (onceRunned) {
                            fmap[j] = a;
                            if ((j -= h) <= mj) {
                                break HAMMER;
                            }
                        } else {
                            onceRunned = true;
                        }

                        a = fmap[j - h];
                        int i1 = a + d;
                        int i2 = vd;

                        
                        
                        if (block[i1 + 1] == block[i2 + 1]) {
                            if (block[i1 + 2] == block[i2 + 2]) {
                                if (block[i1 + 3] == block[i2 + 3]) {
                                    if (block[i1 + 4] == block[i2 + 4]) {
                                        if (block[i1 + 5] == block[i2 + 5]) {
                                            if (block[(i1 += 6)]
                                                == block[(i2 += 6)]) {
                                                int x = lastShadow;
                                                X: while (x > 0) {
                                                    x -= 4;

                                                    if (block[i1 + 1]
                                                        == block[i2 + 1]) {
                                                        if (quadrant[i1]
                                                            == quadrant[i2]) {
                                                            if (block[i1 + 2] == block[i2 + 2]) {
                                                                if (quadrant[i1 + 1] == quadrant[i2 + 1]) {
                                                                    if (block[i1 + 3] == block[i2 + 3]) {
                                                                        if (quadrant[i1 + 2] == quadrant[i2 + 2]) {
                                                                            if (block[i1 + 4] == block[i2 + 4]) {
                                                                                if (quadrant[i1 + 3] == quadrant[i2 + 3]) {
                                                                                    if ((i1 += 4) >= lastPlus1) {
                                                                                        i1 -= lastPlus1;
                                                                                    }
                                                                                    if ((i2 += 4) >= lastPlus1) {
                                                                                        i2 -= lastPlus1;
                                                                                    }
                                                                                    workDoneShadow++;
                                                                                    continue X;
                                                                                } else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {
                                                                                    continue HAMMER;
                                                                                } else {
                                                                                    break HAMMER;
                                                                                }
                                                                            } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
                                                                                continue HAMMER;
                                                                            } else {
                                                                                break HAMMER;
                                                                            }
                                                                        } else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {
                                                                            continue HAMMER;
                                                                        } else {
                                                                            break HAMMER;
                                                                        }
                                                                    } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
                                                                        continue HAMMER;
                                                                    } else {
                                                                        break HAMMER;
                                                                    }
                                                                } else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {
                                                                    continue HAMMER;
                                                                } else {
                                                                    break HAMMER;
                                                                }
                                                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
                                                                continue HAMMER;
                                                            } else {
                                                                break HAMMER;
                                                            }
                                                        } else if ((quadrant[i1] > quadrant[i2])) {
                                                            continue HAMMER;
                                                        } else {
                                                            break HAMMER;
                                                        }
                                                    } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
                                                        continue HAMMER;
                                                    } else {
                                                        break HAMMER;
                                                    }

                                                }
                                                break HAMMER;
                                            } 
                                            else {
                                                if ((block[i1] & 0xff)
                                                    > (block[i2] & 0xff)) {
                                                    continue HAMMER;
                                                } else {
                                                    break HAMMER;
                                                }
                                            }
                                        } else if ((block[i1 + 5] & 0xff)
                                                   > (block[i2 + 5] & 0xff)) {
                                            continue HAMMER;
                                        } else {
                                            break HAMMER;
                                        }
                                    } else if ((block[i1 + 4] & 0xff)
                                               > (block[i2 + 4] & 0xff)) {
                                        continue HAMMER;
                                    } else {
                                        break HAMMER;
                                    }
                                } else if ((block[i1 + 3] & 0xff)
                                           > (block[i2 + 3] & 0xff)) {
                                    continue HAMMER;
                                } else {
                                    break HAMMER;
                                }
                            } else if ((block[i1 + 2] & 0xff)
                                       > (block[i2 + 2] & 0xff)) {
                                continue HAMMER;
                            } else {
                                break HAMMER;
                            }
                        } else if ((block[i1 + 1] & 0xff)
                                   > (block[i2 + 1] & 0xff)) {
                            continue HAMMER;
                        } else {
                            break HAMMER;
                        }

                    } 
                    

                    fmap[j] = v;
                }

                if (firstAttemptShadow && (i <= hi) && (workDoneShadow > workLimitShadow)) {
                    break HP;
                }
            }
        }

        this.workDone = workDoneShadow;
        return firstAttemptShadow && (workDoneShadow > workLimitShadow);
    }

    private static void vswap(int[] fmap, int p1, int p2, int n) {
        n += p1;
        while (p1 < n) {
            int t = fmap[p1];
            fmap[p1++] = fmap[p2];
            fmap[p2++] = t;
        }
    }

    private static byte med3(byte a, byte b, byte c) {
        return (a < b)
            ? (b < c ? b : a < c ? c : a)
            : (b > c ? b : a > c ? c : a);
    }

    private void blockSort() {
        this.workLimit = WORK_FACTOR * this.last;
        this.workDone = 0;
        this.blockRandomised = false;
        this.firstAttempt = true;
        mainSort();

        if (this.firstAttempt && (this.workDone > this.workLimit)) {
            randomiseBlock();
            this.workLimit = this.workDone = 0;
            this.firstAttempt = false;
            mainSort();
        }

        int[] fmap = this.data.fmap;
        this.origPtr = -1;
        for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {
            if (fmap[i] == 0) {
                this.origPtr = i;
                break;
            }
        }

        
    }

    
    private void mainQSort3(final Data dataShadow, final int loSt, final int hiSt,
                            final int dSt) {
        final int[] stack_ll = dataShadow.stack_ll;
        final int[] stack_hh = dataShadow.stack_hh;
        final int[] stack_dd = dataShadow.stack_dd;
        final int[] fmap     = dataShadow.fmap;
        final byte[] block   = dataShadow.block;

        stack_ll[0] = loSt;
        stack_hh[0] = hiSt;
        stack_dd[0] = dSt;

        for (int sp = 1; --sp >= 0;) {
            final int lo = stack_ll[sp];
            final int hi = stack_hh[sp];
            final int d = stack_dd[sp];

            if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {
                if (mainSimpleSort(dataShadow, lo, hi, d)) {
                    return;
                }
            } else {
                final int d1 = d + 1;
                final int med = med3(block[fmap[lo]              + d1],
                                     block[fmap[hi            ]  + d1],
                                     block[fmap[(lo + hi) >> 1]  + d1])
                    & 0xff;

                int unLo = lo;
                int unHi = hi;
                int ltLo = lo;
                int gtHi = hi;

                while (true) {
                    while (unLo <= unHi) {
                        final int n =
                            ((int) block[fmap[unLo] + d1] & 0xff) - med;
                        if (n == 0) {
                            final int temp = fmap[unLo];
                            fmap[unLo++] = fmap[ltLo];
                            fmap[ltLo++] = temp;
                        } else if (n < 0) {
                            unLo++;
                        } else {
                            break;
                        }
                    }

                    while (unLo <= unHi) {
                        final int n =
                            ((int) block[fmap[unHi] + d1] & 0xff) - med;
                        if (n == 0) {
                            final int temp = fmap[unHi];
                            fmap[unHi--] = fmap[gtHi];
                            fmap[gtHi--] = temp;
                        } else if (n > 0) {
                            unHi--;
                        } else {
                            break;
                        }
                    }

                    if (unLo <= unHi) {
                        final int temp = fmap[unLo];
                        fmap[unLo++] = fmap[unHi];
                        fmap[unHi--] = temp;
                    } else {
                        break;
                    }
                }

                if (gtHi < ltLo) {
                    stack_ll[sp] = lo;
                    stack_hh[sp] = hi;
                    stack_dd[sp] = d1;
                    sp++;
                } else {
                    int n = ((ltLo - lo) < (unLo - ltLo))
                        ? (ltLo - lo) : (unLo - ltLo);
                    vswap(fmap, lo, unLo - n, n);
                    int m = ((hi - gtHi) < (gtHi - unHi))
                        ? (hi - gtHi) : (gtHi - unHi);
                    vswap(fmap, unLo, hi - m + 1, m);

                    n = lo + unLo - ltLo - 1;
                    m = hi - (gtHi - unHi) + 1;

                    stack_ll[sp] = lo;
                    stack_hh[sp] = n;
                    stack_dd[sp] = d;
                    sp++;

                    stack_ll[sp] = n + 1;
                    stack_hh[sp] = m - 1;
                    stack_dd[sp] = d1;
                    sp++;

                    stack_ll[sp] = m;
                    stack_hh[sp] = hi;
                    stack_dd[sp] = d;
                    sp++;
                }
            }
        }
    }

    private void mainSort() {
        final Data dataShadow             = this.data;
        final int[] runningOrder    = dataShadow.mainSort_runningOrder;
        final int[] copy            = dataShadow.mainSort_copy;
        final boolean[] bigDone     = dataShadow.mainSort_bigDone;
        final int[] ftab            = dataShadow.ftab;
        final byte[] block          = dataShadow.block;
        final int[] fmap            = dataShadow.fmap;
        final char[] quadrant       = dataShadow.quadrant;
        final int lastShadow              = this.last;
        final int workLimitShadow         = this.workLimit;
        final boolean firstAttemptShadow  = this.firstAttempt;

        
        for (int i = 65537; --i >= 0;) {
            ftab[i] = 0;
        }

        
        for (int i = 0; i < NUM_OVERSHOOT_BYTES; i++) {
            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];
        }
        for (int i = lastShadow + NUM_OVERSHOOT_BYTES; --i >= 0;) {
            quadrant[i] = 0;
        }
        block[0] = block[lastShadow + 1];

        

        int c1 = block[0] & 0xff;
        for (int i = 0; i <= lastShadow; i++) {
            final int c2 = block[i + 1] & 0xff;
            ftab[(c1 << 8) + c2]++;
            c1 = c2;
        }

        for (int i = 1; i <= 65536; i++)
            ftab[i] += ftab[i - 1];

        c1 = block[1] & 0xff;
        for (int i = 0; i < lastShadow; i++) {
            final int c2 = block[i + 2] & 0xff;
            fmap[--ftab[(c1 << 8) + c2]] = i;
            c1 = c2;
        }

        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]]
            = lastShadow;

        
        for (int i = 256; --i >= 0;) {
            bigDone[i] = false;
            runningOrder[i] = i;
        }

        for (int h = 364; h != 1;) {
            h /= 3;
            for (int i = h; i <= 255; i++) {
                final int vv = runningOrder[i];
                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
                final int b = h - 1;
                int j = i;
                for (int ro = runningOrder[j - h];
                     (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a;
                     ro = runningOrder[j - h]) {
                    runningOrder[j] = ro;
                    j -= h;
                    if (j <= b) {
                        break;
                    }
                }
                runningOrder[j] = vv;
            }
        }

        
        for (int i = 0; i <= 255; i++) {
            
            final int ss = runningOrder[i];

            
            
            for (int j = 0; j <= 255; j++) {
                final int sb = (ss << 8) + j;
                final int ftab_sb = ftab[sb];
                if ((ftab_sb & SETMASK) != SETMASK) {
                    final int lo = ftab_sb & CLEARMASK;
                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;
                    if (hi > lo) {
                        mainQSort3(dataShadow, lo, hi, 2);
                        if (firstAttemptShadow && (this.workDone > workLimitShadow)) {
                            return;
                        }
                    }
                    ftab[sb] = ftab_sb | SETMASK;
                }
            }

            
            
            

            for (int j = 0; j <= 255; j++) {
                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
            }

            for (int j = ftab[ss << 8] & CLEARMASK,
                     hj = (ftab[(ss + 1) << 8] & CLEARMASK);
                 j < hj;
                 j++) {
                final int fmap_j = fmap[j];
                c1 = block[fmap_j] & 0xff;
                if (!bigDone[c1]) {
                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);
                    copy[c1]++;
                }
            }

            for (int j = 256; --j >= 0;)
                ftab[(j << 8) + ss] |= SETMASK;

            
            
            bigDone[ss] = true;

            if (i < 255) {
                final int bbStart = ftab[ss << 8] & CLEARMASK;
                final int bbSize  = 
                    (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
                int shifts = 0;

                while ((bbSize >> shifts) > 65534) {
                    shifts++;
                }

                for (int j = 0; j < bbSize; j++) {
                    final int a2update = fmap[bbStart + j];
                    final char qVal = (char) (j >> shifts);
                    quadrant[a2update] = qVal;
                    if (a2update < NUM_OVERSHOOT_BYTES) {
                        quadrant[a2update + lastShadow + 1] = qVal;
                    }
                }
            }

        }
    }

    private void randomiseBlock() {
        final boolean[] inUse = this.data.inUse;
        final byte[] block    = this.data.block;
        final int lastShadow        = this.last;

        for (int i = 256; --i >= 0;)
            inUse[i] = false;

        int rNToGo = 0;
        int rTPos  = 0;
        for (int i = 0, j = 1; i <= lastShadow; i = j, j++) {
            if (rNToGo == 0) {
                rNToGo = (char) BZip2Constants.rNums[rTPos];
                if (++rTPos == 512) {
                    rTPos = 0;
                }
            }

            rNToGo--;
            block[j] ^= ((rNToGo == 1) ? 1 : 0);

            
            inUse[block[j] & 0xff] = true;
        }

        this.blockRandomised = true;
    }

    private void generateMTFValues() {
        final int lastShadow          = this.last;
        final Data dataShadow         = this.data;
        final boolean[] inUse   = dataShadow.inUse;
        final byte[] block      = dataShadow.block;
        final int[] fmap        = dataShadow.fmap;
        final char[] sfmap      = dataShadow.sfmap;
        final int[] mtfFreq     = dataShadow.mtfFreq;
        final byte[] unseqToSeq = dataShadow.unseqToSeq;
        final byte[] yy         = dataShadow.generateMTFValues_yy;

        
        int nInUseShadow = 0;
        for (int i = 0; i < 256; i++) {
            if (inUse[i]) {
                unseqToSeq[i] = (byte) nInUseShadow;
                nInUseShadow++;
            }
        }
        this.nInUse = nInUseShadow;

        final int eob = nInUseShadow + 1;

        for (int i = eob; i >= 0; i--) {
            mtfFreq[i] = 0;
        }

        for (int i = nInUseShadow; --i >= 0;) {
            yy[i] = (byte) i;
        }

        int wr = 0;
        int zPend = 0;

        for (int i = 0; i <= lastShadow; i++) {
            final byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];
            byte tmp = yy[0];
            int j = 0;

            while (ll_i != tmp) {
                j++;
                byte tmp2 = tmp;
                tmp = yy[j];
                yy[j] = tmp2;
            }
            yy[0] = tmp;

            if (j == 0) {
                zPend++;
            } else {
                if (zPend > 0) {
                    zPend--;
                    while (true) {
                        if ((zPend & 1) == 0) {
                            sfmap[wr] = RUNA;
                            wr++;
                            mtfFreq[RUNA]++;
                        } else {
                            sfmap[wr] = RUNB;
                            wr++;
                            mtfFreq[RUNB]++;
                        }

                        if (zPend >= 2) {
                            zPend = (zPend - 2) >> 1;
                        } else {
                            break;
                        }
                    }
                    zPend = 0;
                }
                sfmap[wr] = (char) (j + 1);
                wr++;
                mtfFreq[j + 1]++;
            }
        }

        if (zPend > 0) {
            zPend--;
            while (true) {
                if ((zPend & 1) == 0) {
                    sfmap[wr] = RUNA;
                    wr++;
                    mtfFreq[RUNA]++;
                } else {
                    sfmap[wr] = RUNB;
                    wr++;
                    mtfFreq[RUNB]++;
                }

                if (zPend >= 2) {
                    zPend = (zPend - 2) >> 1;
                } else {
                    break;
                }
            }
        }

        sfmap[wr] = (char) eob;
        mtfFreq[eob]++;
        this.nMTF = wr + 1;
    }

    private static final class Data extends Object {

        
        final boolean[] inUse     = new boolean[256];                           
        final byte[] unseqToSeq   = new byte[256];                              
        final int[] mtfFreq       = new int[MAX_ALPHA_SIZE];                    
        final byte[] selector     = new byte[MAX_SELECTORS];                    
        final byte[] selectorMtf  = new byte[MAX_SELECTORS];                    

        final byte[] generateMTFValues_yy = new byte[256];                      
        final byte[][] sendMTFValues_len  = new byte[N_GROUPS][MAX_ALPHA_SIZE]; 
        final int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];  
        final int[] sendMTFValues_fave    = new int[N_GROUPS];                  
        final short[] sendMTFValues_cost  = new short[N_GROUPS];                
        final int[][] sendMTFValues_code  = new int[N_GROUPS][MAX_ALPHA_SIZE];  
        final byte[] sendMTFValues2_pos   = new byte[N_GROUPS];                 
        final boolean[] sentMTFValues4_inUse16 = new boolean[16];               

        final int[] stack_ll = new int[QSORT_STACK_SIZE];                       
        final int[] stack_hh = new int[QSORT_STACK_SIZE];                       
        final int[] stack_dd = new int[QSORT_STACK_SIZE];                       

        final int[] mainSort_runningOrder = new int[256];                       
        final int[] mainSort_copy         = new int[256];                       
        final boolean[] mainSort_bigDone  = new boolean[256];                   

        final int[] heap   = new int[MAX_ALPHA_SIZE + 2];                       
        final int[] weight = new int[MAX_ALPHA_SIZE * 2];                       
        final int[] parent = new int[MAX_ALPHA_SIZE * 2];                       

        final int[] ftab = new int[65537];                                      
        
        

        final byte[] block;                                                     
        final int[] fmap;                                                       
        final char[] sfmap;                                                     
        
        
        

        
        final char[] quadrant;

        Data(int blockSize100k) {
            super();

            final int n = blockSize100k * BZip2Constants.baseBlockSize;
            this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];
            this.fmap = new int[n];
            this.sfmap = new char[2 * n];
            this.quadrant = this.sfmap;
        }

    }

}
"
org.apache.tools.ant.taskdefs.condition.Os,13,1,0,27,23,68,25,2,12,0.929166667,400,0.4,0,0.0,0.708333333,0,0,28.23076923,50,4.5385,1,"

package org.apache.tools.ant.taskdefs.condition;

import java.util.Locale;

import org.apache.tools.ant.BuildException;


public class Os implements Condition {
    private static final String OS_NAME =
        System.getProperty(""os.name"").toLowerCase(Locale.US);
    private static final String OS_ARCH =
        System.getProperty(""os.arch"").toLowerCase(Locale.US);
    private static final String OS_VERSION =
        System.getProperty(""os.version"").toLowerCase(Locale.US);
    private static final String PATH_SEP =
        System.getProperty(""path.separator"");

    
    private String family;
    
    private String name;
    
    private String version;
    
    private String arch;
    
    public static final String FAMILY_WINDOWS = ""windows"";
    
    public static final String FAMILY_9X = ""win9x"";
    
    public static final String FAMILY_NT = ""winnt"";
    
    public static final String FAMILY_OS2 = ""os/2"";
    
    public static final String FAMILY_NETWARE = ""netware"";
    
    public static final String FAMILY_DOS = ""dos"";
    
    public static final String FAMILY_MAC = ""mac"";
    
    public static final String FAMILY_TANDEM = ""tandem"";
    
    public static final String FAMILY_UNIX = ""unix"";
    
    public static final String FAMILY_VMS = ""openvms"";
    
    public static final String FAMILY_ZOS = ""z/os"";
    
    public static final String FAMILY_OS400 = ""os/400"";

    
    public Os() {
        
    }

    
    public Os(String family) {
        setFamily(family);
    }

    
    public void setFamily(String f) {
        family = f.toLowerCase(Locale.US);
    }

    
    public void setName(String name) {
        this.name = name.toLowerCase(Locale.US);
    }

    
    public void setArch(String arch) {
        this.arch = arch.toLowerCase(Locale.US);
    }

    
    public void setVersion(String version) {
        this.version = version.toLowerCase(Locale.US);
    }

    
    public boolean eval() throws BuildException {
        return isOs(family, name, arch, version);
    }

    
    public static boolean isFamily(String family) {
        return isOs(family, null, null, null);
    }

    
    public static boolean isName(String name) {
        return isOs(null, name, null, null);
    }

    
    public static boolean isArch(String arch) {
        return isOs(null, null, arch, null);
    }

    
    public static boolean isVersion(String version) {
        return isOs(null, null, null, version);
    }

    
    public static boolean isOs(String family, String name, String arch,
                               String version) {
        boolean retValue = false;

        if (family != null || name != null || arch != null
            || version != null) {

            boolean isFamily = true;
            boolean isName = true;
            boolean isArch = true;
            boolean isVersion = true;

            if (family != null) {

                
                
                boolean isWindows = OS_NAME.indexOf(FAMILY_WINDOWS) > -1;
                boolean is9x = false;
                boolean isNT = false;
                if (isWindows) {
                    
                    is9x = (OS_NAME.indexOf(""95"") >= 0
                            || OS_NAME.indexOf(""98"") >= 0
                            || OS_NAME.indexOf(""me"") >= 0
                            
                            
                            || OS_NAME.indexOf(""ce"") >= 0);
                    isNT = !is9x;
                }
                if (family.equals(FAMILY_WINDOWS)) {
                    isFamily = isWindows;
                } else if (family.equals(FAMILY_9X)) {
                    isFamily = isWindows && is9x;
                } else if (family.equals(FAMILY_NT)) {
                    isFamily = isWindows && isNT;
                } else if (family.equals(FAMILY_OS2)) {
                    isFamily = OS_NAME.indexOf(FAMILY_OS2) > -1;
                } else if (family.equals(FAMILY_NETWARE)) {
                    isFamily = OS_NAME.indexOf(FAMILY_NETWARE) > -1;
                } else if (family.equals(FAMILY_DOS)) {
                    isFamily = PATH_SEP.equals("";"") && !isFamily(FAMILY_NETWARE);
                } else if (family.equals(FAMILY_MAC)) {
                    isFamily = OS_NAME.indexOf(FAMILY_MAC) > -1;
                } else if (family.equals(FAMILY_TANDEM)) {
                    isFamily = OS_NAME.indexOf(""nonstop_kernel"") > -1;
                } else if (family.equals(FAMILY_UNIX)) {
                    isFamily = PATH_SEP.equals("":"")
                        && !isFamily(FAMILY_VMS)
                        && (!isFamily(FAMILY_MAC) || OS_NAME.endsWith(""x""));
                } else if (family.equals(FAMILY_ZOS)) {
                    isFamily = OS_NAME.indexOf(FAMILY_ZOS) > -1
                        || OS_NAME.indexOf(""os/390"") > -1;
                } else if (family.equals(FAMILY_OS400)) {
                    isFamily = OS_NAME.indexOf(FAMILY_OS400) > -1;
                } else if (family.equals(FAMILY_VMS)) {
                    isFamily = OS_NAME.indexOf(FAMILY_VMS) > -1;
                } else {
                    throw new BuildException(
                        ""Don\'t know how to detect os family \""""
                        + family + ""\"""");
                }
            }
            if (name != null) {
                isName = name.equals(OS_NAME);
            }
            if (arch != null) {
                isArch = arch.equals(OS_ARCH);
            }
            if (version != null) {
                isVersion = version.equals(OS_VERSION);
            }
            retValue = isFamily && isName && isArch && isVersion;
        }
        return retValue;
    }
}
"
org.apache.tools.ant.util.ScriptRunnerHelper,16,1,0,13,31,76,5,8,13,0.791666667,165,1.0,2,0.0,0.1953125,0,0,8.8125,4,1.3125,0,"
package org.apache.tools.ant.util;

import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.types.Path;
import java.io.File;
import org.apache.tools.ant.types.Reference;



public class ScriptRunnerHelper {
    private ClasspathUtils.Delegate cpDelegate = null;
    private File    srcFile;
    private String  manager = ""auto"";
    private String  language;
    private String  text;
    private boolean setBeans = true;
    private ProjectComponent projectComponent;
    private ClassLoader scriptLoader = null;

    
    public void setProjectComponent(ProjectComponent component) {
        this.projectComponent = component;
    }

    
    public ScriptRunnerBase getScriptRunner() {
        ScriptRunnerBase runner = getRunner();
        if (srcFile != null) {
            runner.setSrc(srcFile);
        }
        if (text != null) {
            runner.addText(text);
        }
        if (setBeans) {
            runner.bindToComponent(projectComponent);
        } else {
            runner.bindToComponentMinimum(projectComponent);
        }
        return runner;
    }

    
    public Path createClasspath() {
        return getClassPathDelegate().createClasspath();
    }

    
    public void setClasspath(Path classpath) {
        getClassPathDelegate().setClasspath(classpath);
    }

    
    public void setClasspathRef(Reference r) {
        getClassPathDelegate().setClasspathref(r);
    }

    
    public void setSrc(File file) {
        this.srcFile = file;
    }

    
    public void addText(String text) {
        this.text = text;
    }

    
    public void setManager(String manager) {
        this.manager = manager;
    }

    
    public void setLanguage(String language) {
        this.language = language;
    }

    
    public String getLanguage() {
        return language;
    }

    
    public void setSetBeans(boolean setBeans) {
        this.setBeans = setBeans;
    }

    
    public void setClassLoader(ClassLoader loader) {
        scriptLoader = loader;
    }


    private ClassLoader generateClassLoader() {
        if (scriptLoader != null) {
            return scriptLoader;
        }
        if (cpDelegate == null) {
            scriptLoader = getClass().getClassLoader();
            return scriptLoader;
        }

        scriptLoader = cpDelegate.getClassLoader();
        return scriptLoader;
    }

    private ClasspathUtils.Delegate getClassPathDelegate() {
        if (cpDelegate == null) {
            cpDelegate = ClasspathUtils.getDelegate(projectComponent);
        }
        return cpDelegate;
    }

    
    private ScriptRunnerBase getRunner() {
        return new ScriptRunnerCreator(
            projectComponent.getProject()).createRunner(
                manager, language, generateClassLoader());
    }
}
"
org.apache.tools.ant.taskdefs.Exit,12,3,0,6,30,30,0,6,8,0.781818182,282,1.0,1,0.770833333,0.472222222,1,1,22.08333333,6,2.0833,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ExitStatusException;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.taskdefs.condition.ConditionBase;


public class Exit extends Task {

    private static class NestedCondition extends ConditionBase implements Condition {
        public boolean eval() {
            if (countConditions() != 1) {
                throw new BuildException(
                    ""A single nested condition is required."");
            }
            return ((Condition) (getConditions().nextElement())).eval();
        }
    }

    private String message;
    private String ifCondition, unlessCondition;
    private NestedCondition nestedCondition;
    private Integer status;

    
    public void setMessage(String value) {
        this.message = value;
    }

    
    public void setIf(String c) {
        ifCondition = c;
    }

    
    public void setUnless(String c) {
        unlessCondition = c;
    }

    
    public void setStatus(int i) {
        status = new Integer(i);
    }

    
    public void execute() throws BuildException {
        boolean fail = (nestedConditionPresent()) ? testNestedCondition()
                     : (testIfCondition() && testUnlessCondition());
        if (fail) {
            String text = null;
            if (message != null && message.trim().length() > 0) {
                text = message.trim();
            } else {
                if (ifCondition != null && ifCondition.length() > 0
                    && getProject().getProperty(ifCondition) != null) {
                    text = ""if="" + ifCondition;
                }
                if (unlessCondition != null && unlessCondition.length() > 0
                    && getProject().getProperty(unlessCondition) == null) {
                    if (text == null) {
                        text = """";
                    } else {
                        text += "" and "";
                    }
                    text += ""unless="" + unlessCondition;
                }
                if (nestedConditionPresent()) {
                    text = ""condition satisfied"";
                } else {
                    if (text == null) {
                        text = ""No message"";
                    }
                }
            }
            log(""failing due to "" + text, Project.MSG_DEBUG);
            throw ((status == null) ? new BuildException(text)
             : new ExitStatusException(text, status.intValue()));
        }
    }

    
    public void addText(String msg) {
        if (message == null) {
            message = """";
        }
        message += getProject().replaceProperties(msg);
    }

    
    public ConditionBase createCondition() {
        if (nestedCondition != null) {
            throw new BuildException(""Only one nested condition is allowed."");
        }
        nestedCondition = new NestedCondition();
        return nestedCondition;
    }

    
    private boolean testIfCondition() {
        if (ifCondition == null || """".equals(ifCondition)) {
            return true;
        }
        return getProject().getProperty(ifCondition) != null;
    }

    
    private boolean testUnlessCondition() {
        if (unlessCondition == null || """".equals(unlessCondition)) {
            return true;
        }
        return getProject().getProperty(unlessCondition) == null;
    }

    
    private boolean testNestedCondition() {
        boolean result = nestedConditionPresent();

        if (result && ifCondition != null || unlessCondition != null) {
            throw new BuildException(""Nested conditions ""
                + ""not permitted in conjunction with if/unless attributes"");
        }

        return result && nestedCondition.eval();
    }

    
    private boolean nestedConditionPresent() {
        return (nestedCondition != null);
    }

}
"
org.apache.tools.ant.util.MergingMapper,4,1,0,4,5,0,3,1,4,0.333333333,24,1.0,0,0.0,0.875,0,0,4.75,1,0.75,0,"

package org.apache.tools.ant.util;


public class MergingMapper implements FileNameMapper {
    
    protected String[] mergedFile = null;
    

    
    public void setFrom(String from) {
    }

    
    public void setTo(String to) {
        mergedFile = new String[] {to};
    }

    
    public String[] mapFileName(String sourceFileName) {
        return mergedFile;
    }

}
"
org.apache.tools.ant.taskdefs.MacroDef,21,4,0,15,76,152,5,14,16,0.833333333,573,0.888888889,2,0.672131148,0.178571429,1,1,25.85714286,23,3.1905,1,"

package org.apache.tools.ant.taskdefs;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Locale;
import java.util.HashMap;
import java.util.Iterator;

import org.apache.tools.ant.AntTypeDefinition;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.RuntimeConfigurable;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.UnknownElement;


public class MacroDef extends AntlibDefinition  {

    private NestedSequential nestedSequential;
    private String     name;
    private boolean    backTrace = true;
    private List       attributes = new ArrayList();
    private Map        elements   = new HashMap();
    private String     textName   = null;
    private Text       text       = null;
    private boolean    hasImplicitElement = false;

    
     public void setName(String name) {
        this.name = name;
    }

    
    public void addConfiguredText(Text text) {
        if (this.text != null) {
            throw new BuildException(
                ""Only one nested text element allowed"");
        }
        if (text.getName() == null) {
            throw new BuildException(
                ""the text nested element needed a \""name\"" attribute"");
        }
        
        for (Iterator i = attributes.iterator(); i.hasNext();) {
            Attribute attribute = (Attribute) i.next();
            if (text.getName().equals(attribute.getName())) {
                throw new BuildException(
                    ""the name \"""" + text.getName()
                    + ""\"" is already used as an attribute"");
            }
        }
        this.text = text;
        this.textName = text.getName();
    }

    
    public Text getText() {
        return text;
    }

    
    public void setBackTrace(boolean backTrace) {
        this.backTrace = backTrace;
    }

    
    public boolean getBackTrace() {
        return backTrace;
    }

    
    public NestedSequential createSequential() {
        if (this.nestedSequential != null) {
            throw new BuildException(""Only one sequential allowed"");
        }
        this.nestedSequential = new NestedSequential();
        return this.nestedSequential;
    }

    
    public static class NestedSequential implements TaskContainer {
        private List nested = new ArrayList();

        
        public void addTask(Task task) {
            nested.add(task);
        }

        
        public List getNested() {
            return nested;
        }

        
        public boolean similar(NestedSequential other) {
            if (nested.size() != other.nested.size()) {
                return false;
            }
            for (int i = 0; i < nested.size(); ++i) {
                UnknownElement me = (UnknownElement) nested.get(i);
                UnknownElement o = (UnknownElement) other.nested.get(i);
                if (!me.similar(o)) {
                    return false;
                }
            }
            return true;
        }
    }

    
    public UnknownElement getNestedTask() {
        UnknownElement ret = new UnknownElement(""sequential"");
        ret.setTaskName(""sequential"");
        ret.setNamespace("""");
        ret.setQName(""sequential"");
        new RuntimeConfigurable(ret, ""sequential"");
        for (int i = 0; i < nestedSequential.getNested().size(); ++i) {
            UnknownElement e =
                (UnknownElement) nestedSequential.getNested().get(i);
            ret.addChild(e);
            ret.getWrapper().addChild(e.getWrapper());
        }
        return ret;
    }

    
    public List getAttributes() {
        return attributes;
    }

    
    public Map getElements() {
        return elements;
    }

    
    public static boolean isValidNameCharacter(char c) {
        
        return Character.isLetterOrDigit(c) || c == '.' || c == '-';
    }

    
    private static boolean isValidName(String name) {
        if (name.length() == 0) {
            return false;
        }
        for (int i = 0; i < name.length(); ++i) {
            if (!isValidNameCharacter(name.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    
    public void addConfiguredAttribute(Attribute attribute) {
        if (attribute.getName() == null) {
            throw new BuildException(
                ""the attribute nested element needed a \""name\"" attribute"");
        }
        if (attribute.getName().equals(textName)) {
            throw new BuildException(
                ""the name \"""" + attribute.getName()
                + ""\"" has already been used by the text element"");
        }
        for (int i = 0; i < attributes.size(); ++i) {
            Attribute att = (Attribute) attributes.get(i);
            if (att.getName().equals(attribute.getName())) {
                throw new BuildException(
                    ""the name \"""" + attribute.getName()
                        + ""\"" has already been used in ""
                        + ""another attribute element"");
            }
        }
        attributes.add(attribute);
    }

    
    public void addConfiguredElement(TemplateElement element) {
        if (element.getName() == null) {
            throw new BuildException(
                ""the element nested element needed a \""name\"" attribute"");
        }
        if (elements.get(element.getName()) != null) {
            throw new BuildException(
                ""the element "" + element.getName()
                + "" has already been specified"");
        }
        if (hasImplicitElement
            || (element.isImplicit() && elements.size() != 0)) {
            throw new BuildException(
                ""Only one element allowed when using implicit elements"");
        }
        hasImplicitElement = element.isImplicit();
        elements.put(element.getName(), element);
    }

    
    public void execute() {
        if (nestedSequential == null) {
            throw new BuildException(""Missing sequential element"");
        }
        if (name == null) {
            throw new BuildException(""Name not specified"");
        }

        name = ProjectHelper.genComponentName(getURI(), name);

        MyAntTypeDefinition def = new MyAntTypeDefinition(this);
        def.setName(name);
        def.setClass(MacroInstance.class);

        ComponentHelper helper = ComponentHelper.getComponentHelper(
            getProject());

        helper.addDataTypeDefinition(def);
        log(""creating macro  "" + name, Project.MSG_VERBOSE);
    }


    
    public static class Attribute {
        private String name;
        private String defaultValue;
        private String description;

        
        public void setName(String name) {
            if (!isValidName(name)) {
                throw new BuildException(
                    ""Illegal name ["" + name + ""] for attribute"");
            }
            this.name = name.toLowerCase(Locale.US);
        }

        
        public String getName() {
            return name;
        }

        
        public void setDefault(String defaultValue) {
            this.defaultValue = defaultValue;
        }

        
        public String getDefault() {
            return defaultValue;
        }

        
        public void setDescription(String desc) {
            description = desc;
        }

        
        public String getDescription() {
            return description;
        }

        
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (obj.getClass() != getClass()) {
                return false;
            }
            Attribute other = (Attribute) obj;
            if (name == null) {
                if (other.name != null) {
                    return false;
                }
            } else if (!name.equals(other.name)) {
                return false;
            }
            if (defaultValue == null) {
                if (other.defaultValue != null) {
                    return false;
                }
            } else if (!defaultValue.equals(other.defaultValue)) {
                return false;
            }
            return true;
        }

        
        public int hashCode() {
            return objectHashCode(defaultValue) + objectHashCode(name);
        }
    }

    
    public static class Text {
        private String  name;
        private boolean optional;
        private boolean trim;
        private String  description;

        
        public void setName(String name) {
            if (!isValidName(name)) {
                throw new BuildException(
                    ""Illegal name ["" + name + ""] for attribute"");
            }
            this.name = name.toLowerCase(Locale.US);
        }

        
        public String getName() {
            return name;
        }

        
        public void setOptional(boolean optional) {
            this.optional = optional;
        }

        
        public boolean getOptional() {
            return optional;
        }

        
        public void setTrim(boolean trim) {
            this.trim = trim;
        }

        
        public boolean getTrim() {
            return trim;
        }

        
        public void setDescription(String desc) {
            description = desc;
        }

        
        public String getDescription() {
            return description;
        }

        
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (obj.getClass() != getClass()) {
                return false;
            }
            Text other = (Text) obj;
            if (name == null) {
                if (other.name != null) {
                    return false;
                }
            } else if (!name.equals(other.name)) {
                return false;
            }
            if (optional != other.optional) {
                return false;
            }
            if (trim != other.trim) {
                return false;
            }
            return true;
        }

        
        public int hashCode() {
            return objectHashCode(name);
        }
    }

    
    public static class TemplateElement {

        private String name;
        private String description;
        private boolean optional = false;
        private boolean implicit = false;

        
        public void setName(String name) {
            if (!isValidName(name)) {
                throw new BuildException(
                    ""Illegal name ["" + name + ""] for macro element"");
            }
            this.name = name.toLowerCase(Locale.US);
        }

        
        public String getName() {
            return name;
        }

        
        public void setDescription(String desc) {
            description = desc;
        }

        
        public String getDescription() {
            return description;
        }

        
        public void setOptional(boolean optional) {
            this.optional = optional;
        }

        
        public boolean isOptional() {
            return optional;
        }

        
        public void setImplicit(boolean implicit) {
            this.implicit = implicit;
        }

        
        public boolean isImplicit() {
            return implicit;
        }

        
        public boolean equals(Object obj) {
            if (obj == this) {
              return true;
            }
            if (obj == null || !obj.getClass().equals(getClass())) {
                return false;
            }
            TemplateElement t = (TemplateElement) obj;
            return
                (name == null ? t.name == null : name.equals(t.name))
                && optional == t.optional
                && implicit == t.implicit;
        }

        
        public int hashCode() {
            return objectHashCode(name)
                + (optional ? 1 : 0) + (implicit ? 1 : 0);
        }

    } 

    
    private boolean sameOrSimilar(Object obj, boolean same) {
        if (obj == this) {
            return true;
        }

        if (obj == null) {
            return false;
        }
        if (!obj.getClass().equals(getClass())) {
            return false;
        }
        MacroDef other = (MacroDef) obj;
        if (name == null) {
            return other.name == null;
        }
        if (!name.equals(other.name)) {
            return false;
        }
        
        
        if (other.getLocation() != null
            && other.getLocation().equals(getLocation())
            && !same) {
            return true;
        }
        if (text == null) {
            if (other.text != null) {
                return false;
            }
        } else {
            if (!text.equals(other.text)) {
                return false;
            }
        }
        if (getURI() == null || getURI().equals("""")
            || getURI().equals(ProjectHelper.ANT_CORE_URI)) {
            if (!(other.getURI() == null || other.getURI().equals("""")
                  || other.getURI().equals(ProjectHelper.ANT_CORE_URI))) {
                return false;
            }
        } else {
            if (!getURI().equals(other.getURI())) {
                return false;
            }
        }

        if (!nestedSequential.similar(other.nestedSequential)) {
            return false;
        }
        if (!attributes.equals(other.attributes)) {
            return false;
        }
        if (!elements.equals(other.elements)) {
            return false;
        }
        return true;
    }

    
    public boolean similar(Object obj) {
        return sameOrSimilar(obj, false);
    }

    
    public boolean sameDefinition(Object obj) {
        return sameOrSimilar(obj, true);
    }

    
    private static class MyAntTypeDefinition extends AntTypeDefinition {
        private MacroDef macroDef;

        
        public MyAntTypeDefinition(MacroDef macroDef) {
            this.macroDef = macroDef;
        }

        
        public Object create(Project project) {
            Object o = super.create(project);
            if (o == null) {
                return null;
            }
            ((MacroInstance) o).setMacroDef(macroDef);
            return o;
        }

        
        public boolean sameDefinition(AntTypeDefinition other, Project project) {
            if (!super.sameDefinition(other, project)) {
                return false;
            }
            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
            return macroDef.sameDefinition(otherDef.macroDef);
        }

        
        public boolean similarDefinition(
            AntTypeDefinition other, Project project) {
            if (!super.similarDefinition(other, project)) {
                return false;
            }
            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
            return macroDef.similar(otherDef.macroDef);
        }
    }

    private static int objectHashCode(Object o) {
        if (o == null) {
            return 0;
        } else {
            return o.hashCode();
        }
    }

}
"
org.apache.tools.ant.taskdefs.TempFile,9,3,0,5,18,14,1,4,8,0.8125,90,1.0,1,0.840909091,0.40625,0,0,8.333333333,1,0.7778,1,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;



public class TempFile extends Task {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private String property;

    
    private File destDir = null;

    
    private String prefix;

    
    private String suffix = """";

    
    private boolean deleteOnExit;

    
    public void setProperty(String property) {
        this.property = property;
    }


    
    public void setDestDir(File destDir) {
        this.destDir = destDir;
    }


    
    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }


    
    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }

    
    public void setDeleteOnExit(boolean deleteOnExit) {
        this.deleteOnExit = deleteOnExit;
    }

    
    public boolean isDeleteOnExit() {
        return deleteOnExit;
    }

    
    public void execute() throws BuildException {
        if (property == null || property.length() == 0) {
            throw new BuildException(""no property specified"");
        }
        if (destDir == null) {
            destDir = getProject().resolveFile(""."");
        }
        File tfile = FILE_UTILS.createTempFile(
                prefix, suffix, destDir, deleteOnExit);

        getProject().setNewProperty(property, tfile.toString());
    }
}
"
org.apache.tools.ant.taskdefs.MakeUrl,14,3,0,7,46,27,0,7,8,0.837606838,372,0.666666667,0,0.74,0.214285714,1,1,24.92857143,5,1.8571,0,"
package org.apache.tools.ant.taskdefs;


import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;

import java.io.File;
import java.util.List;
import java.util.LinkedList;
import java.util.ListIterator;



public class MakeUrl extends Task {

    
    private String property;

    
    private File file;

    
    private String separator = "" "";

    
    private List filesets = new LinkedList();

    
    private List paths = new LinkedList();

    
    private boolean validate = true;

    
    
    public static final String ERROR_MISSING_FILE = ""A source file is missing :"";
    
    public static final String ERROR_NO_PROPERTY = ""No property defined"";
    
    public static final String ERROR_NO_FILES = ""No files defined"";

    
    public void setProperty(String property) {
        this.property = property;
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void addFileSet(FileSet fileset) {
        filesets.add(fileset);
    }

    
    public void setSeparator(String separator) {
        this.separator = separator;
    }

    
    public void setValidate(boolean validate) {
        this.validate = validate;
    }

    
    public void addPath(Path path) {
        paths.add(path);
    }

    
    private String filesetsToURL() {
        if (filesets.isEmpty()) {
            return """";
        }
        int count = 0;
        StringBuffer urls = new StringBuffer();
        ListIterator list = filesets.listIterator();
        while (list.hasNext()) {
            FileSet set = (FileSet) list.next();
            DirectoryScanner scanner = set.getDirectoryScanner(getProject());
            String[] files = scanner.getIncludedFiles();
            for (int i = 0; i < files.length; i++) {
                File f = new File(scanner.getBasedir(), files[i]);
                validateFile(f);
                String asUrl = toURL(f);
                urls.append(asUrl);
                log(asUrl, Project.MSG_DEBUG);
                urls.append(separator);
                count++;
            }
        }
        
        return stripTrailingSeparator(urls, count);
    }

    
    private String stripTrailingSeparator(StringBuffer urls,
                                          int count) {
        if (count > 0) {
            urls.delete(urls.length() - separator.length(), urls.length());
            return new String(urls);
        } else {
            return """";
        }
    }


    
    private String pathsToURL() {
        if (paths.isEmpty()) {
            return """";
        }
        int count = 0;
        StringBuffer urls = new StringBuffer();
        ListIterator list = paths.listIterator();
        while (list.hasNext()) {
            Path path = (Path) list.next();
            String[] elements = path.list();
            for (int i = 0; i < elements.length; i++) {
                File f = new File(elements[i]);
                validateFile(f);
                String asUrl = toURL(f);
                urls.append(asUrl);
                log(asUrl, Project.MSG_DEBUG);
                urls.append(separator);
                count++;
            }
        }
        
        return stripTrailingSeparator(urls, count);
    }

    
    private void validateFile(File fileToCheck) {
        if (validate && !fileToCheck.exists()) {
            throw new BuildException(ERROR_MISSING_FILE + fileToCheck.toString());
        }
    }

    
    public void execute() throws BuildException {
        validate();
        
        if (getProject().getProperty(property) != null) {
            return;
        }
        String url;
        String filesetURL = filesetsToURL();
        if (file != null) {
            validateFile(file);
            url = toURL(file);
            
            if (filesetURL.length() > 0) {
                url = url + separator + filesetURL;
            }
        } else {
            url = filesetURL;
        }
        
        String pathURL = pathsToURL();
        if (pathURL.length() > 0) {
            if (url.length() > 0) {
                url = url + separator + pathURL;
            } else {
                url = pathURL;
            }
        }
        log(""Setting "" + property + "" to URL "" + url, Project.MSG_VERBOSE);
        getProject().setNewProperty(property, url);
    }

    
    private void validate() {
        
        if (property == null) {
            throw new BuildException(ERROR_NO_PROPERTY);
        }
        if (file == null && filesets.isEmpty() && paths.isEmpty()) {
            throw new BuildException(ERROR_NO_FILES);
        }
    }

    
    private String toURL(File fileToConvert) {
        String url;
        
        
        url = FileUtils.getFileUtils().toURI(fileToConvert.getAbsolutePath());

        return url;
    }

}
"
org.apache.tools.ant.taskdefs.optional.sos.SOSCmd,0,1,0,1,0,0,1,0,0,2.0,26,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.tools.ant.taskdefs.optional.sos;


public interface SOSCmd {
    
    
    String COMMAND_SOS_EXE = ""soscmd"";
    
    String COMMAND_GET_FILE = ""GetFile"";
    
    String COMMAND_GET_PROJECT = ""GetProject"";
    
    String COMMAND_CHECKOUT_FILE = ""CheckOutFile"";
    
    String COMMAND_CHECKOUT_PROJECT = ""CheckOutProject"";
    
    String COMMAND_CHECKIN_FILE = ""CheckInFile"";
    
    String COMMAND_CHECKIN_PROJECT = ""CheckInProject"";
    
    String COMMAND_HISTORY = ""GetFileHistory"";
    
    String COMMAND_LABEL = ""AddLabel"";
    
    String PROJECT_PREFIX = ""$"";

    
    
    String FLAG_COMMAND = ""-command"";
    
    String FLAG_VSS_SERVER = ""-database"";
    
    String FLAG_USERNAME = ""-name"";
    
    String FLAG_PASSWORD = ""-password"";
    
    String FLAG_COMMENT = ""-log"";
    
    String FLAG_WORKING_DIR = ""-workdir"";
    
    String FLAG_RECURSION = ""-recursive"";
    
    String FLAG_VERSION = ""-revision"";
    
    String FLAG_LABEL = ""-label"";
    
    String FLAG_NO_COMPRESSION = ""-nocompress"";
    
    String FLAG_NO_CACHE = ""-nocache"";
    
    String FLAG_SOS_SERVER = ""-server"";
    
    String FLAG_SOS_HOME = ""-soshome"";
    
    String FLAG_PROJECT = ""-project"";
    
    String FLAG_FILE = ""-file"";
    
    String FLAG_VERBOSE = ""-verbose"";
}
"
org.apache.tools.ant.taskdefs.condition.IsReachable,7,2,0,3,30,9,0,3,5,1.0625,278,0.375,0,0.642857143,0.555555556,0,0,36.42857143,3,1.0,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.UnknownHostException;


public class IsReachable extends ProjectComponent implements Condition {

    private static final int SECOND = 1000; 
    private String host;
    private String url;

    
    public static final int DEFAULT_TIMEOUT = 30;
    private int timeout = DEFAULT_TIMEOUT;
    
    public static final String ERROR_NO_HOSTNAME = ""No hostname defined"";
    
    public static final String ERROR_BAD_TIMEOUT = ""Invalid timeout value"";
    
    private static final String WARN_UNKNOWN_HOST = ""Unknown host: "";
    
    public static final String ERROR_ON_NETWORK = ""network error to "";
    
    public static final String ERROR_BOTH_TARGETS
        = ""Both url and host have been specified"";
    
    public static final String MSG_NO_REACHABLE_TEST
        = ""cannot do a proper reachability test on this Java version"";
    
    public static final String ERROR_BAD_URL = ""Bad URL "";
    
    public static final String ERROR_NO_HOST_IN_URL = ""No hostname in URL "";
    
    public static final String METHOD_NAME = ""isReachable"";

    
    public void setHost(String host) {
        this.host = host;
    }

    
    public void setUrl(String url) {
        this.url = url;
    }

    
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    
    private boolean empty(String string) {
        return string == null || string.length() == 0;
    }

    private static Class[] parameterTypes = {Integer.TYPE};

    
    public boolean eval() throws BuildException {
        if (empty(host) && empty(url)) {
            throw new BuildException(ERROR_NO_HOSTNAME);
        }
        if (timeout < 0) {
            throw new BuildException(ERROR_BAD_TIMEOUT);
        }
        String target = host;
        if (!empty(url)) {
            if (!empty(host)) {
                throw new BuildException(ERROR_BOTH_TARGETS);
            }
            try {
                
                URL realURL = new URL(url);
                target = realURL.getHost();
                if (empty(target)) {
                    throw new BuildException(ERROR_NO_HOST_IN_URL + url);
                }
            } catch (MalformedURLException e) {
                throw new BuildException(ERROR_BAD_URL + url, e);
            }
        }
        log(""Probing host "" + target, Project.MSG_VERBOSE);
        InetAddress address;
        try {
            address = InetAddress.getByName(target);
        } catch (UnknownHostException e1) {
            log(WARN_UNKNOWN_HOST + target);
            return false;
        }
        log(""Host address = "" + address.getHostAddress(),
                Project.MSG_VERBOSE);
        boolean reachable;
        
        Method reachableMethod = null;
        try {
            reachableMethod = InetAddress.class.getMethod(METHOD_NAME,
                    parameterTypes);
            Object[] params = new Object[1];
            params[0] = new Integer(timeout * SECOND);
            try {
                reachable = ((Boolean) reachableMethod.invoke(address, params))
                        .booleanValue();
            } catch (IllegalAccessException e) {
                
                throw new BuildException(""When calling "" + reachableMethod);
            } catch (InvocationTargetException e) {
                
                Throwable nested = e.getTargetException();
                log(ERROR_ON_NETWORK + target + "": "" + nested.toString());
                
                reachable = false;
            }
        } catch (NoSuchMethodException e) {
            
            log(""Not found: InetAddress."" + METHOD_NAME, Project.MSG_VERBOSE);
            log(MSG_NO_REACHABLE_TEST);
            reachable = true;

        }

        log(""host is"" + (reachable ? """" : "" not"") + "" reachable"", Project.MSG_VERBOSE);
        return reachable;
    }
}
"
org.apache.tools.ant.taskdefs.DefaultExcludes,6,3,0,4,17,0,0,4,6,0.64,131,1.0,0,0.880952381,0.555555556,2,2,20.0,1,0.8333,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.util.StringUtils;


public class DefaultExcludes extends Task {
    private String add = """";
    private String remove = """";
    private boolean defaultrequested = false;
    private boolean echo = false;

    
    private int logLevel = Project.MSG_WARN;

    
    public void execute() throws BuildException {
        if (!defaultrequested && add.equals("""") && remove.equals("""") && !echo) {
            throw new BuildException(""<defaultexcludes> task must set ""
                + ""at least one attribute (echo=\""false\""""
                + "" doesn't count since that is the default"");
        }
        if (defaultrequested) {
            DirectoryScanner.resetDefaultExcludes();
        }
        if (!add.equals("""")) {
            DirectoryScanner.addDefaultExclude(add);
        }
        if (!remove.equals("""")) {
            DirectoryScanner.removeDefaultExclude(remove);
        }
        if (echo) {
            StringBuffer message
                = new StringBuffer(""Current Default Excludes:"");
            message.append(StringUtils.LINE_SEP);
            String[] excludes = DirectoryScanner.getDefaultExcludes();
            for (int i = 0; i < excludes.length; i++) {
                message.append(""  "");
                message.append(excludes[i]);
                message.append(StringUtils.LINE_SEP);
            }
            log(message.toString(), logLevel);
        }
    }

    
    public void setDefault(boolean def) {
        defaultrequested = def;
    }
    
    public void setAdd(String add) {
        this.add = add;
    }

     
    public void setRemove(String remove) {
        this.remove = remove;
    }

    
    public void setEcho(boolean echo) {
        this.echo = echo;
    }


}
"
org.apache.tools.ant.filters.StripLineBreaks,7,5,0,4,17,0,1,3,5,0.777777778,107,1.0,0,0.848484848,0.476190476,2,5,13.85714286,5,1.2857,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.types.Parameter;


public final class StripLineBreaks
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String DEFAULT_LINE_BREAKS = ""\r\n"";

    
    private static final String LINE_BREAKS_KEY = ""linebreaks"";

    
    private String lineBreaks = DEFAULT_LINE_BREAKS;

    
    public StripLineBreaks() {
        super();
    }

    
    public StripLineBreaks(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = in.read();
        while (ch != -1) {
            if (lineBreaks.indexOf(ch) == -1) {
                break;
            } else {
                ch = in.read();
            }
        }
        return ch;
    }

    
    public void setLineBreaks(final String lineBreaks) {
        this.lineBreaks = lineBreaks;
    }

    
    private String getLineBreaks() {
        return lineBreaks;
    }

    
    public Reader chain(final Reader rdr) {
        StripLineBreaks newFilter = new StripLineBreaks(rdr);
        newFilter.setLineBreaks(getLineBreaks());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        String userDefinedLineBreaks = null;
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (LINE_BREAKS_KEY.equals(params[i].getName())) {
                    userDefinedLineBreaks = params[i].getValue();
                    break;
                }
            }
        }
        if (userDefinedLineBreaks != null) {
            lineBreaks = userDefinedLineBreaks;
        }
    }
}
"
org.apache.tools.ant.taskdefs.Transform,1,5,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs;


public class Transform extends ExecuteOn {
}
"
org.apache.tools.ant.DefaultLogger,18,1,4,14,42,113,7,7,12,0.890756303,356,0.857142857,0,0.0,0.268907563,0,0,18.38888889,11,1.7778,3,"

package org.apache.tools.ant;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;
import java.io.StringReader;

import org.apache.tools.ant.util.DateUtils;
import org.apache.tools.ant.util.StringUtils;


public class DefaultLogger implements BuildLogger {
    
    public static final int LEFT_COLUMN_SIZE = 12;

    
    
    protected PrintStream out;

    
    protected PrintStream err;

    
    protected int msgOutputLevel = Project.MSG_ERR;

    
    private long startTime = System.currentTimeMillis();

    
    
    protected static final String lSep = StringUtils.LINE_SEP;
    

    
    protected boolean emacsMode = false;
    


    
    public DefaultLogger() {
    }

    
    public void setMessageOutputLevel(int level) {
        this.msgOutputLevel = level;
    }

    
    public void setOutputPrintStream(PrintStream output) {
        this.out = new PrintStream(output, true);
    }

    
    public void setErrorPrintStream(PrintStream err) {
        this.err = new PrintStream(err, true);
    }

    
    public void setEmacsMode(boolean emacsMode) {
        this.emacsMode = emacsMode;
    }

    
    public void buildStarted(BuildEvent event) {
        startTime = System.currentTimeMillis();
    }

    
    public void buildFinished(BuildEvent event) {
        Throwable error = event.getException();
        StringBuffer message = new StringBuffer();
        if (error == null) {
            message.append(StringUtils.LINE_SEP);
            message.append(getBuildSuccessfulMessage());
        } else {
            message.append(StringUtils.LINE_SEP);
            message.append(getBuildFailedMessage());
            message.append(StringUtils.LINE_SEP);

            if (Project.MSG_VERBOSE <= msgOutputLevel
                || !(error instanceof BuildException)) {
                message.append(StringUtils.getStackTrace(error));
            } else {
                message.append(error.toString()).append(lSep);
            }
        }
        message.append(StringUtils.LINE_SEP);
        message.append(""Total time: "");
        message.append(formatTime(System.currentTimeMillis() - startTime));

        String msg = message.toString();
        if (error == null) {
            printMessage(msg, out, Project.MSG_VERBOSE);
        } else {
            printMessage(msg, err, Project.MSG_ERR);
        }
        log(msg);
    }

    
    protected String getBuildFailedMessage() {
        return ""BUILD FAILED"";
    }

    
    protected String getBuildSuccessfulMessage() {
        return ""BUILD SUCCESSFUL"";
    }

    
    public void targetStarted(BuildEvent event) {
        if (Project.MSG_INFO <= msgOutputLevel
            && !event.getTarget().getName().equals("""")) {
            String msg = StringUtils.LINE_SEP
                + event.getTarget().getName() + "":"";
            printMessage(msg, out, event.getPriority());
            log(msg);
        }
    }

    
    public void targetFinished(BuildEvent event) {
    }

    
    public void taskStarted(BuildEvent event) {
    }

    
    public void taskFinished(BuildEvent event) {
    }

    
    public void messageLogged(BuildEvent event) {
        int priority = event.getPriority();
        
        if (priority <= msgOutputLevel) {

            StringBuffer message = new StringBuffer();
            if (event.getTask() != null && !emacsMode) {
                
                String name = event.getTask().getTaskName();
                String label = ""["" + name + ""] "";
                int size = LEFT_COLUMN_SIZE - label.length();
                StringBuffer tmp = new StringBuffer();
                for (int i = 0; i < size; i++) {
                    tmp.append("" "");
                }
                tmp.append(label);
                label = tmp.toString();

                try {
                    BufferedReader r =
                        new BufferedReader(
                            new StringReader(event.getMessage()));
                    String line = r.readLine();
                    boolean first = true;
                    do {
                        if (first) {
                            if (line == null) {
                                message.append(label);
                                break;
                            }
                        } else {
                            message.append(StringUtils.LINE_SEP);
                        }
                        first = false;
                        message.append(label).append(line);
                        line = r.readLine();
                    } while (line != null);
                } catch (IOException e) {
                    
                    message.append(label).append(event.getMessage());
                }
            } else {
                message.append(event.getMessage());
            }
            Throwable ex = event.getException();
            if (Project.MSG_DEBUG <= msgOutputLevel && ex != null) {
                    message.append(StringUtils.getStackTrace(ex));
            }

            String msg = message.toString();
            if (priority != Project.MSG_ERR) {
                printMessage(msg, out, priority);
            } else {
                printMessage(msg, err, priority);
            }
            log(msg);
        }
    }

    
    protected static String formatTime(final long millis) {
        return DateUtils.formatElapsedTime(millis);
    }

    
    protected void printMessage(final String message,
                                final PrintStream stream,
                                final int priority) {
        stream.println(message);
    }

    
    protected void log(String message) {
    }
}
"
org.apache.tools.ant.util.ClasspathUtils,12,1,0,19,33,66,13,7,10,1.045454545,261,0.0,0,0.0,0.259259259,0,0,20.58333333,8,1.9167,0,"
package org.apache.tools.ant.util;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;




public class ClasspathUtils {

    
    public static final String REUSE_LOADER_REF = MagicNames.REFID_CLASSPATH_REUSE_LOADER;

    
    public static ClassLoader getClassLoaderForPath(
        Project p, Reference ref) {

        return getClassLoaderForPath(p, ref, false);
    }

    
    public static ClassLoader getClassLoaderForPath(
        Project p, Reference ref, boolean reverseLoader) {

        String pathId = ref.getRefId();
        Object path = p.getReference(pathId);
        if (!(path instanceof Path)) {
            throw new BuildException(
                ""The specified classpathref ""
                    + pathId
                    + "" does not reference a Path."");
        }
        String loaderId = MagicNames.REFID_CLASSPATH_LOADER_PREFIX + pathId;
        return getClassLoaderForPath(p, (Path) path, loaderId, reverseLoader);
    }

    
    public static ClassLoader getClassLoaderForPath(
        Project p, Path path, String loaderId) {

        return getClassLoaderForPath(p, path, loaderId, false);
    }

    
    public static ClassLoader getClassLoaderForPath(
        Project p, Path path, String loaderId, boolean reverseLoader) {
        return getClassLoaderForPath(p, path, loaderId, reverseLoader,
                                     isMagicPropertySet(p));
    }

    
    public static ClassLoader getClassLoaderForPath(
        Project p, Path path, String loaderId, boolean reverseLoader,
        boolean reuseLoader) {

        ClassLoader cl = null;

        
        if (loaderId != null && reuseLoader) {
            Object reusedLoader = p.getReference(loaderId);
            if (reusedLoader != null
                && !(reusedLoader instanceof ClassLoader)) {
                throw new BuildException(""The specified loader id "" + loaderId
                    + "" does not reference a class loader"");
            }
            cl = (ClassLoader) reusedLoader;
        }
        if (cl == null) {
            cl = getUniqueClassLoaderForPath(p, path, reverseLoader);
            if (loaderId != null && reuseLoader) {
                p.addReference(loaderId, cl);
            }
        }
        return cl;
    }

    
    public static ClassLoader getUniqueClassLoaderForPath(
        Project p,
        Path path,
        boolean reverseLoader) {
        AntClassLoader acl = p.createClassLoader(path);
        if (reverseLoader) {
            acl.setParentFirst(false);
            acl.addJavaLibraries();
        }
        return acl;
    }

    
    public static Object newInstance(
            String className,
            ClassLoader userDefinedLoader) {
        return newInstance(className, userDefinedLoader, Object.class);
    }

    
    public static Object newInstance(
        String className,
        ClassLoader userDefinedLoader,
        Class expectedType) {
        try {
            Class clazz = Class.forName(className, true, userDefinedLoader);
            Object o = clazz.newInstance();
            if (!expectedType.isInstance(o)) {
                throw new BuildException(
                    ""Class of unexpected Type: ""
                        + className
                        + "" expected :""
                        + expectedType);
            }
            return o;
        } catch (ClassNotFoundException e) {
            throw new BuildException(
                ""Class not found: ""
                    + className,
                e);
        } catch (InstantiationException e) {
            throw new BuildException(
                ""Could not instantiate ""
                    + className
                    + "". Specified class should have a no ""
                    + ""argument constructor."",
                e);
        } catch (IllegalAccessException e) {
            throw new BuildException(
                ""Could not instantiate ""
                    + className
                    + "". Specified class should have a ""
                    + ""public constructor."",
                e);
        } catch (LinkageError e) {
            throw new BuildException(
                ""Class ""
                    + className
                    + "" could not be loaded because of an invalid dependency."",
                e);
        }
    }

    
    public static Delegate getDelegate(ProjectComponent component) {
        return new Delegate(component);
    }

    
    private static boolean isMagicPropertySet(Project p) {
        return p.getProperty(REUSE_LOADER_REF) != null;
    }

    
    public static class Delegate {
        private final ProjectComponent component;
        private Path classpath;
        private String classpathId;
        private String className;
        private String loaderId;
        private boolean reverseLoader = false;

        
        Delegate(ProjectComponent component) {
            this.component = component;
        }

        
        public void setClasspath(Path classpath) {
            if (this.classpath == null) {
                this.classpath = classpath;
            } else {
                this.classpath.append(classpath);
            }
        }

        
        public Path createClasspath() {
            if (this.classpath == null) {
                this.classpath = new Path(component.getProject());
            }
            return this.classpath.createPath();
        }

        
        public void setClassname(String fcqn) {
            this.className = fcqn;
        }

        
        public void setClasspathref(Reference r) {
            this.classpathId = r.getRefId();
            createClasspath().setRefid(r);
        }

        
        public void setReverseLoader(boolean reverseLoader) {
            this.reverseLoader = reverseLoader;
        }

        
        public void setLoaderRef(Reference r) {
            this.loaderId = r.getRefId();
        }


        
        public ClassLoader getClassLoader() {
            return getClassLoaderForPath(
                    getContextProject(),
                    this.classpath,
                    getClassLoadId(),
                    this.reverseLoader,
                    loaderId != null || isMagicPropertySet(getContextProject()));
        }

        
        private Project getContextProject() {
            return this.component.getProject();
        }

        
        public String getClassLoadId() {
            return this.loaderId == null && this.classpathId != null
                ? MagicNames.REFID_CLASSPATH_LOADER_PREFIX + this.classpathId
                : this.loaderId;
        }

        
        public Object newInstance() {
            return ClasspathUtils.newInstance(this.className, getClassLoader());
        }

        
        public Path getClasspath() {
            return classpath;
        }

        
        public boolean isReverseLoader() {
            return reverseLoader;
        }

        
        
    }
}
"
org.apache.tools.ant.types.resources.Sort,4,4,1,11,20,0,2,9,2,0.0,75,1.0,1,0.933333333,0.4375,2,5,17.5,3,1.5,2,"
package org.apache.tools.ant.types.resources;

import java.util.Stack;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Collection;
import java.util.Comparator;
import java.util.Collections;
import java.util.AbstractCollection;
import java.util.NoSuchElementException;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.comparators.ResourceComparator;
import org.apache.tools.ant.types.resources.comparators.DelegatedResourceComparator;


public class Sort extends BaseResourceCollectionWrapper {

    
    private static class SortedBag extends AbstractCollection {
        private class MutableInt {
            private int value = 0;
        }
        private class MyIterator implements Iterator {
            private Iterator keyIter = t.keySet().iterator();
            private Object current;
            private int occurrence;
            public synchronized boolean hasNext() {
                return occurrence > 0 || keyIter.hasNext();
            }
            public synchronized Object next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                if (occurrence == 0) {
                    current = keyIter.next();
                    occurrence = ((MutableInt) t.get(current)).value;
                }
                --occurrence;
                return current;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        }
        private TreeMap t;
        private int size;

        SortedBag(Comparator c) {
            t = new TreeMap(c);
        }
        public synchronized Iterator iterator() {
            return new MyIterator();
        }
        public synchronized boolean add(Object o) {
            if (size < Integer.MAX_VALUE) {
                ++size;
            }
            MutableInt m = (MutableInt) (t.get(o));
            if (m == null) {
                m = new MutableInt();
                t.put(o, m);
            }
            m.value++;
            return true;
        }
        public synchronized int size() {
            return size;
        }
    }

    private DelegatedResourceComparator comp = new DelegatedResourceComparator();

    
    protected synchronized Collection getCollection() {
        ResourceCollection rc = getResourceCollection();
        Iterator iter = rc.iterator();
        if (!(iter.hasNext())) {
            return Collections.EMPTY_SET;
        }
        SortedBag b = new SortedBag(comp);
        while (iter.hasNext()) {
            b.add(iter.next());
        }
        return b;
    }

    
    public synchronized void add(ResourceComparator c) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        comp.add(c);
        FailFast.invalidate(this);
    }

    
    protected synchronized void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            DataType.invokeCircularReferenceCheck(comp, stk, p);
            setChecked(true);
        }
    }

}
"
org.apache.tools.ant.taskdefs.Copydir,8,4,0,5,39,4,0,5,7,0.714285714,274,1.0,0,0.917647059,0.46875,4,4,32.5,5,1.375,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;



public class Copydir extends MatchingTask {

    private File srcDir;
    private File destDir;
    private boolean filtering = false;
    private boolean flatten = false;
    private boolean forceOverwrite = false;
    private Hashtable filecopyList = new Hashtable();

    
    public void setSrc(File src) {
        srcDir = src;
    }

    
    public void setDest(File dest) {
        destDir = dest;
    }

    
    public void setFiltering(boolean filter) {
        filtering = filter;
    }

    
    public void setFlatten(boolean flatten) {
        this.flatten = flatten;
    }

    
    public void setForceoverwrite(boolean force) {
        forceOverwrite = force;
    }

    
    public void execute() throws BuildException {
        log(""DEPRECATED - The copydir task is deprecated.  Use copy instead."");

        if (srcDir == null) {
            throw new BuildException(""src attribute must be set!"",
                                     getLocation());
        }

        if (!srcDir.exists()) {
            throw new BuildException(""srcdir "" + srcDir.toString()
                                     + "" does not exist!"", getLocation());
        }

        if (destDir == null) {
            throw new BuildException(""The dest attribute must be set."",
                                     getLocation());
        }

        if (srcDir.equals(destDir)) {
            log(""Warning: src == dest"", Project.MSG_WARN);
        }

        DirectoryScanner ds = super.getDirectoryScanner(srcDir);

        try {
            String[] files = ds.getIncludedFiles();
            scanDir(srcDir, destDir, files);
            if (filecopyList.size() > 0) {
                log(""Copying "" + filecopyList.size() + "" file""
                    + (filecopyList.size() == 1 ? """" : ""s"")
                    + "" to "" + destDir.getAbsolutePath());
                Enumeration e = filecopyList.keys();
                while (e.hasMoreElements()) {
                    String fromFile = (String) e.nextElement();
                    String toFile = (String) filecopyList.get(fromFile);
                    try {
                        getProject().copyFile(fromFile, toFile, filtering,
                                         forceOverwrite);
                    } catch (IOException ioe) {
                        String msg = ""Failed to copy "" + fromFile + "" to ""
                            + toFile + "" due to "" + ioe.getMessage();
                        throw new BuildException(msg, ioe, getLocation());
                    }
                }
            }
        } finally {
            filecopyList.clear();
        }
    }

    private void scanDir(File from, File to, String[] files) {
        for (int i = 0; i < files.length; i++) {
            String filename = files[i];
            File srcFile = new File(from, filename);
            File destFile;
            if (flatten) {
                destFile = new File(to, new File(filename).getName());
            } else {
                destFile = new File(to, filename);
            }
            if (forceOverwrite
                || (srcFile.lastModified() > destFile.lastModified())) {
                filecopyList.put(srcFile.getAbsolutePath(),
                                 destFile.getAbsolutePath());
            }
        }
    }
}
"
org.apache.tools.ant.types.PatternSet,22,3,0,14,62,133,10,5,17,0.571428571,625,1.0,0,0.588235294,0.266233766,2,3,27.22727273,9,2.8182,0,"

package org.apache.tools.ant.types;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class PatternSet extends DataType implements Cloneable {
    private Vector includeList = new Vector();
    private Vector excludeList = new Vector();
    private Vector includesFileList = new Vector();
    private Vector excludesFileList = new Vector();

    
    public class NameEntry {
        private String name;
        private String ifCond;
        private String unlessCond;

        
        public void setName(String name) {
            this.name = name;
        }

        
        public void setIf(String cond) {
            ifCond = cond;
        }

        
        public void setUnless(String cond) {
            unlessCond = cond;
        }

        
        public String getName() {
            return name;
        }

        
        public String evalName(Project p) {
            return valid(p) ? name : null;
        }

        private boolean valid(Project p) {
            if (ifCond != null && p.getProperty(ifCond) == null) {
                return false;
            } else if (unlessCond != null && p.getProperty(unlessCond) != null) {
                return false;
            }
            return true;
        }

        
        public String toString() {
            StringBuffer buf = new StringBuffer();
            if (name == null) {
                buf.append(""noname"");
            } else {
                buf.append(name);
            }
            if ((ifCond != null) || (unlessCond != null)) {
                buf.append("":"");
                String connector = """";

                if (ifCond != null) {
                    buf.append(""if->"");
                    buf.append(ifCond);
                    connector = "";"";
                }
                if (unlessCond != null) {
                    buf.append(connector);
                    buf.append(""unless->"");
                    buf.append(unlessCond);
                }
            }

            return buf.toString();
        }
    }

    
    public PatternSet() {
        super();
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (!includeList.isEmpty() || !excludeList.isEmpty()) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public void addConfiguredPatternset(PatternSet p) {
        if (isReference()) {
            throw noChildrenAllowed();
        }

        String[] nestedIncludes = p.getIncludePatterns(getProject());
        String[] nestedExcludes = p.getExcludePatterns(getProject());

        if (nestedIncludes != null) {
            for (int i = 0; i < nestedIncludes.length; i++) {
                createInclude().setName(nestedIncludes[i]);
            }
        }

        if (nestedExcludes != null) {
            for (int i = 0; i < nestedExcludes.length; i++) {
                createExclude().setName(nestedExcludes[i]);
            }
        }
    }

    
    public NameEntry createInclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return addPatternToList(includeList);
    }

    
    public NameEntry createIncludesFile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return addPatternToList(includesFileList);
    }

    
    public NameEntry createExclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return addPatternToList(excludeList);
    }

    
    public NameEntry createExcludesFile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return addPatternToList(excludesFileList);
    }

    
    public void setIncludes(String includes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (includes != null && includes.length() > 0) {
            StringTokenizer tok = new StringTokenizer(includes, "", "", false);
            while (tok.hasMoreTokens()) {
                createInclude().setName(tok.nextToken());
            }
        }
    }

    
    public void setExcludes(String excludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (excludes != null && excludes.length() > 0) {
            StringTokenizer tok = new StringTokenizer(excludes, "", "", false);
            while (tok.hasMoreTokens()) {
                createExclude().setName(tok.nextToken());
            }
        }
    }

    
    private NameEntry addPatternToList(Vector list) {
        NameEntry result = new NameEntry();
        list.addElement(result);
        return result;
    }

    
     public void setIncludesfile(File includesFile) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         createIncludesFile().setName(includesFile.getAbsolutePath());
     }

    
     public void setExcludesfile(File excludesFile) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         createExcludesFile().setName(excludesFile.getAbsolutePath());
     }

    
    private void readPatterns(File patternfile, Vector patternlist, Project p)
        throws BuildException {

        BufferedReader patternReader = null;
        try {
            
            patternReader =
                new BufferedReader(new FileReader(patternfile));

            
            
            String line = patternReader.readLine();
            while (line != null) {
                if (line.length() > 0) {
                    line = p.replaceProperties(line);
                    addPatternToList(patternlist).setName(line);
                }
                line = patternReader.readLine();
            }
        } catch (IOException ioe)  {
            String msg = ""An error occurred while reading from pattern file: ""
                + patternfile;
            throw new BuildException(msg, ioe);
        } finally {
            if (null != patternReader) {
                try {
                    patternReader.close();
                } catch (IOException ioe) {
                    
                }
            }
        }
    }

    
    public void append(PatternSet other, Project p) {
        if (isReference()) {
            throw new BuildException(""Cannot append to a reference"");
        }

        String[] incl = other.getIncludePatterns(p);
        if (incl != null) {
            for (int i = 0; i < incl.length; i++) {
                createInclude().setName(incl[i]);
            }
        }

        String[] excl = other.getExcludePatterns(p);
        if (excl != null) {
            for (int i = 0; i < excl.length; i++) {
                createExclude().setName(excl[i]);
            }
        }
    }

    
    public String[] getIncludePatterns(Project p) {
        if (isReference()) {
            return getRef(p).getIncludePatterns(p);
        } else {
            readFiles(p);
            return makeArray(includeList, p);
        }
    }

    
    public String[] getExcludePatterns(Project p) {
        if (isReference()) {
            return getRef(p).getExcludePatterns(p);
        } else {
            readFiles(p);
            return makeArray(excludeList, p);
        }
    }

    
    public boolean hasPatterns(Project p) {
        if (isReference()) {
            return getRef(p).hasPatterns(p);
        } else {
            return includesFileList.size() > 0 || excludesFileList.size() > 0
                || includeList.size() > 0 || excludeList.size() > 0;
        }
    }

    
    private PatternSet getRef(Project p) {
        return (PatternSet) getCheckedRef(p);
    }

    
    private String[] makeArray(Vector list, Project p) {
        if (list.size() == 0) {
            return null;
        }

        Vector tmpNames = new Vector();
        for (Enumeration e = list.elements(); e.hasMoreElements();) {
            NameEntry ne = (NameEntry) e.nextElement();
            String pattern = ne.evalName(p);
            if (pattern != null && pattern.length() > 0) {
                tmpNames.addElement(pattern);
            }
        }

        String[] result = new String[tmpNames.size()];
        tmpNames.copyInto(result);
        return result;
    }

    
    private void readFiles(Project p) {
        if (includesFileList.size() > 0) {
            Enumeration e = includesFileList.elements();
            while (e.hasMoreElements()) {
                NameEntry ne = (NameEntry) e.nextElement();
                String fileName = ne.evalName(p);
                if (fileName != null) {
                    File inclFile = p.resolveFile(fileName);
                    if (!inclFile.exists()) {
                        throw new BuildException(""Includesfile ""
                                                 + inclFile.getAbsolutePath()
                                                 + "" not found."");
                    }
                    readPatterns(inclFile, includeList, p);
                }
            }
            includesFileList.removeAllElements();
        }

        if (excludesFileList.size() > 0) {
            Enumeration e = excludesFileList.elements();
            while (e.hasMoreElements()) {
                NameEntry ne = (NameEntry) e.nextElement();
                String fileName = ne.evalName(p);
                if (fileName != null) {
                    File exclFile = p.resolveFile(fileName);
                    if (!exclFile.exists()) {
                        throw new BuildException(""Excludesfile ""
                                                 + exclFile.getAbsolutePath()
                                                 + "" not found."");
                    }
                    readPatterns(exclFile, excludeList, p);
                }
            }
            excludesFileList.removeAllElements();
        }
    }

    
    public String toString() {
        return ""patternSet{ includes: "" + includeList
                + "" excludes: "" + excludeList + "" }"";
    }

    
    public Object clone() {
        try {
            PatternSet ps = (PatternSet) super.clone();
            ps.includeList = (Vector) includeList.clone();
            ps.excludeList = (Vector) excludeList.clone();
            ps.includesFileList = (Vector) includesFileList.clone();
            ps.excludesFileList = (Vector) excludesFileList.clone();
            return ps;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
    }

}
"
org.apache.tools.ant.types.Environment,4,1,1,8,10,0,6,2,4,0.0,51,1.0,0,0.0,0.625,0,0,11.5,1,0.75,0,"

package org.apache.tools.ant.types;

import java.util.Vector;
import org.apache.tools.ant.BuildException;


public class Environment {
    

    
    protected Vector variables;

    

    
    public static class Variable {

        
        private String key, value;

        
        public Variable() {
            super();
        }

        
        public void setKey(String key) {
            this.key = key;
        }

        
        public void setValue(String value) {
            this.value = value;
        }

        
        public String getKey() {
            return this.key;
        }

        
        public String getValue() {
            return this.value;
        }

        
        public void setPath(Path path) {
            this.value = path.toString();
        }

        
        public void setFile(java.io.File file) {
            this.value = file.getAbsolutePath();
        }

        
        public String getContent() throws BuildException {
            validate();
            StringBuffer sb = new StringBuffer(key.trim());
            sb.append(""="").append(value.trim());
            return sb.toString();
        }

        
        public void validate() {
            if (key == null || value == null) {
                throw new BuildException(""key and value must be specified ""
                    + ""for environment variables."");
            }
        }
    }

    
    public Environment() {
        variables = new Vector();
    }

    
    public void addVariable(Variable var) {
        variables.addElement(var);
    }

    
    public String[] getVariables() throws BuildException {
        if (variables.size() == 0) {
            return null;
        }
        String[] result = new String[variables.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = ((Variable) variables.elementAt(i)).getContent();
        }
        return result;
    }

    
    public Vector getVariablesVector() {
        return variables;
    }
}
"
org.apache.tools.ant.helper.ProjectHelperImpl,15,2,0,18,66,77,9,13,2,0.87755102,315,1.0,3,0.566666667,0.222222222,1,1,19.53333333,2,0.9333,0,"

package org.apache.tools.ant.helper;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Locale;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.IntrospectionHelper;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.RuntimeConfigurable;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TypeAdapter;
import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.UnknownElement;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JAXPUtils;
import org.xml.sax.AttributeList;
import org.xml.sax.DocumentHandler;
import org.xml.sax.HandlerBase;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.XMLReaderAdapter;


public class ProjectHelperImpl extends ProjectHelper {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private org.xml.sax.Parser parser;

    
    private Project project;
    
    private File buildFile;
    
    private File buildFileParent;
    
    private Locator locator;
    
    private Target implicitTarget = new Target();

    
    public ProjectHelperImpl() {
        implicitTarget.setName("""");
    }

    
    public void parse(Project project, Object source) throws BuildException {
        if (!(source instanceof File)) {
            throw new BuildException(""Only File source supported by ""
                + ""default plugin"");
        }
        File bFile = (File) source;
        FileInputStream inputStream = null;
        InputSource inputSource = null;

        this.project = project;
        this.buildFile = new File(bFile.getAbsolutePath());
        buildFileParent = new File(this.buildFile.getParent());

        try {
            try {
                parser = JAXPUtils.getParser();
            } catch (BuildException e) {
                parser = new XMLReaderAdapter(JAXPUtils.getXMLReader());
            }


            String uri = FILE_UTILS.toURI(bFile.getAbsolutePath());
            inputStream = new FileInputStream(bFile);
            inputSource = new InputSource(inputStream);
            inputSource.setSystemId(uri);
            project.log(""parsing buildfile "" + bFile + "" with URI = ""
                + uri, Project.MSG_VERBOSE);
            HandlerBase hb = new RootHandler(this);
            parser.setDocumentHandler(hb);
            parser.setEntityResolver(hb);
            parser.setErrorHandler(hb);
            parser.setDTDHandler(hb);
            parser.parse(inputSource);
        } catch (SAXParseException exc) {
            Location location =
                new Location(exc.getSystemId(), exc.getLineNumber(),
                    exc.getColumnNumber());

            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                BuildException be = (BuildException) t;
                if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                    be.setLocation(location);
                }
                throw be;
            }

            throw new BuildException(exc.getMessage(), t, location);
        } catch (SAXException exc) {
            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(exc.getMessage(), t);
        } catch (FileNotFoundException exc) {
            throw new BuildException(exc);
        } catch (UnsupportedEncodingException exc) {
            throw new BuildException(""Encoding of project file is invalid."",
                                     exc);
        } catch (IOException exc) {
            throw new BuildException(""Error reading project file: ""
                                     + exc.getMessage(), exc);
        } finally {
            FileUtils.close(inputStream);
        }
    }

    
    static class AbstractHandler extends HandlerBase {
        

        
        protected DocumentHandler parentHandler;

        
        ProjectHelperImpl helperImpl;
        

        
        public AbstractHandler(ProjectHelperImpl helperImpl, DocumentHandler parentHandler) {
            this.parentHandler = parentHandler;
            this.helperImpl = helperImpl;

            
            helperImpl.parser.setDocumentHandler(this);
        }

        
        public void startElement(String tag, AttributeList attrs) throws SAXParseException {
            throw new SAXParseException(""Unexpected element \"""" + tag + ""\"""", helperImpl.locator);
        }

        
        public void characters(char[] buf, int start, int count) throws SAXParseException {
            String s = new String(buf, start, count).trim();

            if (s.length() > 0) {
                throw new SAXParseException(""Unexpected text \"""" + s + ""\"""", helperImpl.locator);
            }
        }

        
        public void endElement(String name) throws SAXException {
            
            helperImpl.parser.setDocumentHandler(parentHandler);
        }
    }

    
    static class RootHandler extends HandlerBase {
        
        ProjectHelperImpl helperImpl;
        

        public RootHandler(ProjectHelperImpl helperImpl) {
            this.helperImpl = helperImpl;
        }

        
        public InputSource resolveEntity(String publicId,
                                         String systemId) {

            helperImpl.project.log(""resolving systemId: "" + systemId, Project.MSG_VERBOSE);

            if (systemId.startsWith(""file:"")) {
                String path = FILE_UTILS.fromURI(systemId);

                File file = new File(path);
                if (!file.isAbsolute()) {
                    file = FILE_UTILS.resolveFile(helperImpl.buildFileParent, path);
                    helperImpl.project.log(
                            ""Warning: '"" + systemId + ""' in "" + helperImpl.buildFile
                            + "" should be expressed simply as '"" + path.replace('\\', '/')
                            + ""' for compliance with other XML tools"",
                            Project.MSG_WARN);
                }
                try {
                    InputSource inputSource = new InputSource(new FileInputStream(file));
                    inputSource.setSystemId(FILE_UTILS.toURI(file.getAbsolutePath()));
                    return inputSource;
                } catch (FileNotFoundException fne) {
                    helperImpl.project.log(file.getAbsolutePath() + "" could not be found"",
                                Project.MSG_WARN);
                }
            }
            
            return null;
        }

        
        public void startElement(String tag, AttributeList attrs) throws SAXParseException {
            if (tag.equals(""project"")) {
                new ProjectHandler(helperImpl, this).init(tag, attrs);
            } else {
                throw new SAXParseException(""Config file is not of expected ""
                    + ""XML type"", helperImpl.locator);
            }
        }

        
        public void setDocumentLocator(Locator locator) {
            helperImpl.locator = locator;
        }
    }

    
    static class ProjectHandler extends AbstractHandler {

        
        public ProjectHandler(ProjectHelperImpl helperImpl, DocumentHandler parentHandler) {
            super(helperImpl, parentHandler);
        }

        
        public void init(String tag, AttributeList attrs) throws SAXParseException {
            String def = null;
            String name = null;
            String id = null;
            String baseDir = null;

            for (int i = 0; i < attrs.getLength(); i++) {
                String key = attrs.getName(i);
                String value = attrs.getValue(i);

                if (key.equals(""default"")) {
                    def = value;
                } else if (key.equals(""name"")) {
                    name = value;
                } else if (key.equals(""id"")) {
                    id = value;
                } else if (key.equals(""basedir"")) {
                    baseDir = value;
                } else {
                    throw new SAXParseException(""Unexpected attribute \"""" + attrs.getName(i) + ""\"""",
                                                helperImpl.locator);
                }
            }

            if (def != null && !def.equals("""")) {
                helperImpl.project.setDefaultTarget(def);
            } else {
                throw new BuildException(""The default attribute is required"");
            }

            if (name != null) {
                helperImpl.project.setName(name);
                helperImpl.project.addReference(name, helperImpl.project);
            }

            if (id != null) {
                helperImpl.project.addReference(id, helperImpl.project);
            }

            if (helperImpl.project.getProperty(""basedir"") != null) {
                helperImpl.project.setBasedir(helperImpl.project.getProperty(""basedir""));
            } else {
                if (baseDir == null) {
                    helperImpl.project.setBasedir(helperImpl.buildFileParent.getAbsolutePath());
                } else {
                    
                    if ((new File(baseDir)).isAbsolute()) {
                        helperImpl.project.setBasedir(baseDir);
                    } else {
                        File resolvedBaseDir = FILE_UTILS.resolveFile(
                                helperImpl.buildFileParent, baseDir);
                        helperImpl.project.setBaseDir(resolvedBaseDir);
                    }
                }
            }

            helperImpl.project.addTarget("""", helperImpl.implicitTarget);
        }

        
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            if (name.equals(""target"")) {
                handleTarget(name, attrs);
            } else {
                handleElement(helperImpl, this, helperImpl.implicitTarget,
                              name, attrs);
            }
        }

        
        private void handleTarget(String tag, AttributeList attrs) throws SAXParseException {
            new TargetHandler(helperImpl, this).init(tag, attrs);
        }

    }

    
    static class TargetHandler extends AbstractHandler {
        private Target target;

        
        public TargetHandler(ProjectHelperImpl helperImpl, DocumentHandler parentHandler) {
            super(helperImpl, parentHandler);
        }

        
        public void init(String tag, AttributeList attrs) throws SAXParseException {
            String name = null;
            String depends = """";
            String ifCond = null;
            String unlessCond = null;
            String id = null;
            String description = null;

            for (int i = 0; i < attrs.getLength(); i++) {
                String key = attrs.getName(i);
                String value = attrs.getValue(i);

                if (key.equals(""name"")) {
                    name = value;
                    if (name.equals("""")) {
                        throw new BuildException(""name attribute must not""
                                                 + "" be empty"",
                                                 new Location(helperImpl.locator));
                    }
                } else if (key.equals(""depends"")) {
                    depends = value;
                } else if (key.equals(""if"")) {
                    ifCond = value;
                } else if (key.equals(""unless"")) {
                    unlessCond = value;
                } else if (key.equals(""id"")) {
                    id = value;
                } else if (key.equals(""description"")) {
                    description = value;
                } else {
                    throw new SAXParseException(""Unexpected attribute \""""
                        + key + ""\"""", helperImpl.locator);
                }
            }

            if (name == null) {
                throw new SAXParseException(""target element appears without a name attribute"",
                                            helperImpl.locator);
            }

            target = new Target();

            
            target.addDependency("""");

            target.setName(name);
            target.setIf(ifCond);
            target.setUnless(unlessCond);
            target.setDescription(description);
            helperImpl.project.addTarget(name, target);

            if (id != null && !id.equals("""")) {
                helperImpl.project.addReference(id, target);
            }

            

            if (depends.length() > 0) {
                target.setDepends(depends);
            }
        }

        
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            handleElement(helperImpl, this, target, name, attrs);
        }
    }

    
    private static void handleElement(ProjectHelperImpl helperImpl,
                                      DocumentHandler parent,
                                      Target target, String elementName,
                                      AttributeList attrs)
        throws SAXParseException {
        if (elementName.equals(""description"")) {
            new DescriptionHandler(helperImpl, parent);
        } else if (helperImpl.project.getDataTypeDefinitions()
                   .get(elementName) != null) {
            new DataTypeHandler(helperImpl, parent, target)
                .init(elementName, attrs);
        } else {
            new TaskHandler(helperImpl, parent, target, null, target)
                .init(elementName, attrs);
        }
    }

    
    static class DescriptionHandler extends AbstractHandler {

        
        public DescriptionHandler(ProjectHelperImpl helperImpl,
                                  DocumentHandler parentHandler) {
            super(helperImpl, parentHandler);
        }

        
        public void characters(char[] buf, int start, int count) {
            String text = new String(buf, start, count);
            String currentDescription = helperImpl.project.getDescription();
            if (currentDescription == null) {
                helperImpl.project.setDescription(text);
            } else {
                helperImpl.project.setDescription(currentDescription + text);
            }
        }

    }

    
    static class TaskHandler extends AbstractHandler {
        
        private Target target;
        
        private TaskContainer container;
        
        private Task task;
        
        private RuntimeConfigurable parentWrapper;
        
        private RuntimeConfigurable wrapper = null;

        
        public TaskHandler(ProjectHelperImpl helperImpl, DocumentHandler parentHandler,
                           TaskContainer container,
                           RuntimeConfigurable parentWrapper, Target target) {
            super(helperImpl, parentHandler);
            this.container = container;
            this.parentWrapper = parentWrapper;
            this.target = target;
        }

        
        public void init(String tag, AttributeList attrs) throws SAXParseException {
            try {
                task = helperImpl.project.createTask(tag);
            } catch (BuildException e) {
                
                
            }

            if (task == null) {
                task = new UnknownElement(tag);
                task.setProject(helperImpl.project);
                
                task.setTaskName(tag);
            }

            task.setLocation(new Location(helperImpl.locator));
            helperImpl.configureId(task, attrs);

            task.setOwningTarget(target);
            container.addTask(task);
            task.init();
            wrapper = task.getRuntimeConfigurableWrapper();
            wrapper.setAttributes(attrs);
            if (parentWrapper != null) {
                parentWrapper.addChild(wrapper);
            }
        }

        
        public void characters(char[] buf, int start, int count) {
            wrapper.addText(buf, start, count);
        }

        
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            if (task instanceof TaskContainer) {
                
                new TaskHandler(helperImpl, this, (TaskContainer) task,
                    wrapper, target).init(name, attrs);
            } else {
                new NestedElementHandler(helperImpl, this, task,
                    wrapper, target).init(name, attrs);
            }
        }
    }

    
    static class NestedElementHandler extends AbstractHandler {
        
        private Object parent;
        
        private Object child;
        
        private RuntimeConfigurable parentWrapper;
        
        private RuntimeConfigurable childWrapper = null;
        
        private Target target;

        
        public NestedElementHandler(ProjectHelperImpl helperImpl,
                                    DocumentHandler parentHandler,
                                    Object parent,
                                    RuntimeConfigurable parentWrapper,
                                    Target target) {
            super(helperImpl, parentHandler);

            if (parent instanceof TypeAdapter) {
                this.parent = ((TypeAdapter) parent).getProxy();
            } else {
                this.parent = parent;
            }
            this.parentWrapper = parentWrapper;
            this.target = target;
        }

        
        public void init(String propType, AttributeList attrs) throws SAXParseException {
            Class parentClass = parent.getClass();
            IntrospectionHelper ih =
                IntrospectionHelper.getHelper(helperImpl.project, parentClass);

            try {
                String elementName = propType.toLowerCase(Locale.US);
                if (parent instanceof UnknownElement) {
                    UnknownElement uc = new UnknownElement(elementName);
                    uc.setProject(helperImpl.project);
                    ((UnknownElement) parent).addChild(uc);
                    child = uc;
                } else {
                    child = ih.createElement(helperImpl.project, parent, elementName);
                }

                helperImpl.configureId(child, attrs);

                childWrapper = new RuntimeConfigurable(child, propType);
                childWrapper.setAttributes(attrs);
                parentWrapper.addChild(childWrapper);
            } catch (BuildException exc) {
                throw new SAXParseException(exc.getMessage(), helperImpl.locator, exc);
            }
        }

        
        public void characters(char[] buf, int start, int count) {
            childWrapper.addText(buf, start, count);
        }

        
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            if (child instanceof TaskContainer) {
                
                
                new TaskHandler(helperImpl, this, (TaskContainer) child,
                    childWrapper, target).init(name, attrs);
            } else {
                new NestedElementHandler(helperImpl, this, child,
                    childWrapper, target).init(name, attrs);
            }
        }
    }

    
    static class DataTypeHandler extends AbstractHandler {
        
        private Target target;
        
        private Object element;
        
        private RuntimeConfigurable wrapper = null;

        
        public DataTypeHandler(ProjectHelperImpl helperImpl,
                               DocumentHandler parentHandler, Target target) {
            super(helperImpl, parentHandler);
            this.target = target;
        }

        
        public void init(String propType, AttributeList attrs) throws SAXParseException {
            try {
                element = helperImpl.project.createDataType(propType);
                if (element == null) {
                    throw new BuildException(""Unknown data type "" + propType);
                }

                wrapper = new RuntimeConfigurable(element, propType);
                wrapper.setAttributes(attrs);
                target.addDataType(wrapper);
            } catch (BuildException exc) {
                throw new SAXParseException(exc.getMessage(), helperImpl.locator, exc);
            }
        }

        
        public void characters(char[] buf, int start, int count) {
            wrapper.addText(buf, start, count);
        }

        
        public void startElement(String name, AttributeList attrs) throws SAXParseException {
            new NestedElementHandler(helperImpl, this, element, wrapper, target).init(name, attrs);
        }
    }

    
    private void configureId(Object target, AttributeList attr) {
        String id = attr.getValue(""id"");
        if (id != null) {
            project.addReference(id, target);
        }
    }
}
"
org.apache.tools.ant.taskdefs.Expand,16,3,1,18,80,86,1,17,11,0.878787879,631,0.909090909,3,0.725490196,0.188888889,2,2,37.75,4,1.1875,4,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.selectors.SelectorUtils;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.zip.ZipEntry;
import org.apache.tools.zip.ZipFile;


public class Expand extends Task {
    private File dest; 
    private File source; 
    private boolean overwrite = true;
    private Mapper mapperElement = null;
    private Vector patternsets = new Vector();
    private Union resources = new Union();
    private boolean resourcesSpecified = false;

    private static final String NATIVE_ENCODING = ""native-encoding"";

    private String encoding = ""UTF8"";
    
    public static final String ERROR_MULTIPLE_MAPPERS = ""Cannot define more than one mapper"";

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public void execute() throws BuildException {
        if (""expand"".equals(getTaskType())) {
            log(""!! expand is deprecated. Use unzip instead. !!"");
        }

        if (source == null && !resourcesSpecified) {
            throw new BuildException(""src attribute and/or resources must be ""
                                     + ""specified"");
        }

        if (dest == null) {
            throw new BuildException(
                ""Dest attribute must be specified"");
        }

        if (dest.exists() && !dest.isDirectory()) {
            throw new BuildException(""Dest must be a directory."", getLocation());
        }

        if (source != null) {
            if (source.isDirectory()) {
                throw new BuildException(""Src must not be a directory.""
                    + "" Use nested filesets instead."", getLocation());
            } else {
                expandFile(FILE_UTILS, source, dest);
            }
        }
        Iterator iter = resources.iterator();
        while (iter.hasNext()) {
            Resource r = (Resource) iter.next();
            if (!r.isExists()) {
                continue;
            }

            if (r instanceof FileResource) {
                expandFile(FILE_UTILS, ((FileResource) r).getFile(), dest);
            } else {
                expandResource(r, dest);
            }
        }
    }

    
    protected void expandFile(FileUtils fileUtils, File srcF, File dir) {
        log(""Expanding: "" + srcF + "" into "" + dir, Project.MSG_INFO);
        ZipFile zf = null;
        FileNameMapper mapper = getMapper();
        try {
            zf = new ZipFile(srcF, encoding);
            Enumeration e = zf.getEntries();
            while (e.hasMoreElements()) {
                ZipEntry ze = (ZipEntry) e.nextElement();
                extractFile(fileUtils, srcF, dir, zf.getInputStream(ze),
                            ze.getName(), new Date(ze.getTime()),
                            ze.isDirectory(), mapper);
            }

            log(""expand complete"", Project.MSG_VERBOSE);
        } catch (IOException ioe) {
            throw new BuildException(""Error while expanding "" + srcF.getPath(),
                                     ioe);
        } finally {
            ZipFile.closeQuietly(zf);
        }
    }

    
    protected void expandResource(Resource srcR, File dir) {
        throw new BuildException(""only filesystem based resources are""
                                 + "" supported by this task."");
    }

    
    protected FileNameMapper getMapper() {
        FileNameMapper mapper = null;
        if (mapperElement != null) {
            mapper = mapperElement.getImplementation();
        } else {
            mapper = new IdentityMapper();
        }
        return mapper;
    }

    
    protected void extractFile(FileUtils fileUtils, File srcF, File dir,
                               InputStream compressedInputStream,
                               String entryName, Date entryDate,
                               boolean isDirectory, FileNameMapper mapper)
                               throws IOException {

        if (patternsets != null && patternsets.size() > 0) {
            String name = entryName.replace('/', File.separatorChar)
                .replace('\\', File.separatorChar);
            boolean included = false;
            Set includePatterns = new HashSet();
            Set excludePatterns = new HashSet();
            for (int v = 0, size = patternsets.size(); v < size; v++) {
                PatternSet p = (PatternSet) patternsets.elementAt(v);
                String[] incls = p.getIncludePatterns(getProject());
                if (incls == null || incls.length == 0) {
                    
                    incls = new String[] {""**""};
                }

                for (int w = 0; w < incls.length; w++) {
                    String pattern = incls[w].replace('/', File.separatorChar)
                        .replace('\\', File.separatorChar);
                    if (pattern.endsWith(File.separator)) {
                        pattern += ""**"";
                    }
                    includePatterns.add(pattern);
                }

                String[] excls = p.getExcludePatterns(getProject());
                if (excls != null) {
                    for (int w = 0; w < excls.length; w++) {
                        String pattern = excls[w]
                            .replace('/', File.separatorChar)
                            .replace('\\', File.separatorChar);
                        if (pattern.endsWith(File.separator)) {
                            pattern += ""**"";
                        }
                        excludePatterns.add(pattern);
                    }
                }
            }

            for (Iterator iter = includePatterns.iterator();
                 !included && iter.hasNext();) {
                String pattern = (String) iter.next();
                included = SelectorUtils.matchPath(pattern, name);
            }

            for (Iterator iter = excludePatterns.iterator();
                 included && iter.hasNext();) {
                String pattern = (String) iter.next();
                included = !SelectorUtils.matchPath(pattern, name);
            }

            if (!included) {
                
                return;
            }
        }
        String[] mappedNames = mapper.mapFileName(entryName);
        if (mappedNames == null || mappedNames.length == 0) {
            mappedNames = new String[] {entryName};
        }
        File f = fileUtils.resolveFile(dir, mappedNames[0]);
        try {
            if (!overwrite && f.exists()
                && f.lastModified() >= entryDate.getTime()) {
                log(""Skipping "" + f + "" as it is up-to-date"",
                    Project.MSG_DEBUG);
                return;
            }

            log(""expanding "" + entryName + "" to "" + f,
                Project.MSG_VERBOSE);
            
            File dirF = f.getParentFile();
            if (dirF != null) {
                dirF.mkdirs();
            }

            if (isDirectory) {
                f.mkdirs();
            } else {
                byte[] buffer = new byte[1024];
                int length = 0;
                FileOutputStream fos = null;
                try {
                    fos = new FileOutputStream(f);

                    while ((length =
                            compressedInputStream.read(buffer)) >= 0) {
                        fos.write(buffer, 0, length);
                    }

                    fos.close();
                    fos = null;
                } finally {
                    FileUtils.close(fos);
                }
            }

            fileUtils.setFileLastModified(f, entryDate.getTime());
        } catch (FileNotFoundException ex) {
            log(""Unable to expand to file "" + f.getPath(), Project.MSG_WARN);
        }

    }

    
    public void setDest(File d) {
        this.dest = d;
    }

    
    public void setSrc(File s) {
        this.source = s;
    }

    
    public void setOverwrite(boolean b) {
        overwrite = b;
    }

    
    public void addPatternset(PatternSet set) {
        patternsets.addElement(set);
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void add(ResourceCollection rc) {
        resourcesSpecified = true;
        resources.add(rc);
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(ERROR_MULTIPLE_MAPPERS,
                                     getLocation());
        }
        mapperElement = new Mapper(getProject());
        return mapperElement;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        createMapper().add(fileNameMapper);
    }


    
    public void setEncoding(String encoding) {
        if (NATIVE_ENCODING.equals(encoding)) {
            encoding = null;
        }
        this.encoding = encoding;
    }

}
"
org.apache.tools.ant.types.selectors.BaseSelectorContainer,28,4,5,23,45,348,5,23,28,0.037037037,204,1.0,0,0.564516129,0.079192547,0,0,6.25,4,1.2143,1,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;


public abstract class BaseSelectorContainer extends BaseSelector
        implements SelectorContainer {

    private Vector selectorsList = new Vector();

    
    public BaseSelectorContainer() {
    }

    
    public boolean hasSelectors() {
        return !(selectorsList.isEmpty());
    }

    
    public int selectorCount() {
        return selectorsList.size();
    }

    
    public FileSelector[] getSelectors(Project p) {
        FileSelector[] result = new FileSelector[selectorsList.size()];
        selectorsList.copyInto(result);
        return result;
    }

    
    public Enumeration selectorElements() {
        return selectorsList.elements();
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        Enumeration e = selectorElements();
        if (e.hasMoreElements()) {
            while (e.hasMoreElements()) {
                buf.append(e.nextElement().toString());
                if (e.hasMoreElements()) {
                    buf.append("", "");
                }
            }
        }

        return buf.toString();
    }

    
    public void appendSelector(FileSelector selector) {
        selectorsList.addElement(selector);
    }

    
    public void validate() {
        verifySettings();
        String errmsg = getError();
        if (errmsg != null) {
            throw new BuildException(errmsg);
        }
        Enumeration e = selectorElements();
        while (e.hasMoreElements()) {
            Object o = e.nextElement();
            if (o instanceof BaseSelector) {
                ((BaseSelector) o).validate();
            }
        }
    }


    
    public abstract boolean isSelected(File basedir, String filename,
                                       File file);


    

    
    public void addSelector(SelectSelector selector) {
        appendSelector(selector);
    }

    
    public void addAnd(AndSelector selector) {
        appendSelector(selector);
    }

    
    public void addOr(OrSelector selector) {
        appendSelector(selector);
    }

    
    public void addNot(NotSelector selector) {
        appendSelector(selector);
    }

    
    public void addNone(NoneSelector selector) {
        appendSelector(selector);
    }

    
    public void addMajority(MajoritySelector selector) {
        appendSelector(selector);
    }

    
    public void addDate(DateSelector selector) {
        appendSelector(selector);
    }

    
    public void addSize(SizeSelector selector) {
        appendSelector(selector);
    }

    
    public void addFilename(FilenameSelector selector) {
        appendSelector(selector);
    }

    
    public void addCustom(ExtendSelector selector) {
        appendSelector(selector);
    }

    
    public void addContains(ContainsSelector selector) {
        appendSelector(selector);
    }

    
    public void addPresent(PresentSelector selector) {
        appendSelector(selector);
    }

    
    public void addDepth(DepthSelector selector) {
        appendSelector(selector);
    }

    
    public void addDepend(DependSelector selector) {
        appendSelector(selector);
    }

    
    public void addDifferent(DifferentSelector selector) {
        appendSelector(selector);
    }

    
    public void addType(TypeSelector selector) {
        appendSelector(selector);
    }

    
    public void addContainsRegexp(ContainsRegexpSelector selector) {
        appendSelector(selector);
    }

    
    public void addModified(ModifiedSelector selector) {
        appendSelector(selector);
    }

    
    public void add(FileSelector selector) {
        appendSelector(selector);
    }

}
"
org.apache.tools.ant.taskdefs.optional.javah.JavahAdapter,1,1,0,5,1,0,4,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.javah;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.optional.Javah;


public interface JavahAdapter {
    
    boolean compile(Javah javah) throws BuildException;
}
"
org.apache.tools.ant.types.selectors.PresentSelector,7,4,0,13,26,0,6,7,7,0.458333333,198,1.0,2,0.853658537,0.392857143,1,3,26.71428571,5,2.5714,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.IdentityMapper;


public class PresentSelector extends BaseSelector {

    private File targetdir = null;
    private Mapper mapperElement = null;
    private FileNameMapper map = null;
    private boolean destmustexist = true;

    
    public PresentSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{presentselector targetdir: "");
        if (targetdir == null) {
            buf.append(""NOT YET SET"");
        } else {
            buf.append(targetdir.getName());
        }
        buf.append("" present: "");
        if (destmustexist) {
            buf.append(""both"");
        } else {
            buf.append(""srconly"");
        }
        if (map != null) {
            buf.append(map.toString());
        } else if (mapperElement != null) {
            buf.append(mapperElement.toString());
        }
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setTargetdir(File targetdir) {
        this.targetdir = targetdir;
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"");
        }
        mapperElement = new Mapper(getProject());
        return mapperElement;
    }


    
    public void setPresent(FilePresence fp) {
        if (fp.getIndex() == 0) {
            destmustexist = false;
        }
    }

    
    public void verifySettings() {
        if (targetdir == null) {
            setError(""The targetdir attribute is required."");
        }
        if (mapperElement == null) {
            map = new IdentityMapper();
        } else {
            map = mapperElement.getImplementation();
        }
        if (map == null) {
            setError(""Could not set <mapper> element."");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {

        
        validate();

        
        String[] destfiles = map.mapFileName(filename);
        
        
        if (destfiles == null) {
            return false;
        }
        
        if (destfiles.length != 1 || destfiles[0] == null) {
            throw new BuildException(""Invalid destination file results for ""
                    + targetdir + "" with filename "" + filename);
        }
        String destname = destfiles[0];
        File destfile = new File(targetdir, destname);
        return destfile.exists() == destmustexist;
    }

    
    public static class FilePresence extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[]{""srconly"", ""both""};
        }
    }

}

"
org.apache.tools.ant.input.MultipleChoiceInputRequest,3,2,0,3,10,0,2,1,3,0.0,44,1.0,0,0.75,0.555555556,1,1,13.33333333,4,1.6667,0,"

package org.apache.tools.ant.input;

import java.util.Vector;


public class MultipleChoiceInputRequest extends InputRequest {
    private Vector choices = new Vector();

    
    public MultipleChoiceInputRequest(String prompt, Vector choices) {
        super(prompt);
        if (choices == null) {
            throw new IllegalArgumentException(""choices must not be null"");
        }
        this.choices = choices;
    }

    
    public Vector getChoices() {
        return choices;
    }

    
    public boolean isInputValid() {
        return choices.contains(getInput()) || ("""".equals(getInput()) && getDefaultValue() != null);
    }
}
"
org.apache.tools.ant.taskdefs.EchoXML,4,3,0,6,15,2,0,6,4,0.888888889,85,1.0,0,0.833333333,0.5,0,0,19.5,6,2.0,1,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.OutputStream;
import java.io.FileOutputStream;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.XMLFragment;
import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.FileUtils;

import org.w3c.dom.Node;
import org.w3c.dom.Element;


public class EchoXML extends XMLFragment {

    private File file;
    private boolean append;
    private static final String ERROR_NO_XML = ""No nested XML specified"";

    
    public void setFile(File f) {
        file = f;
    }

    
    public void setAppend(boolean b) {
        append = b;
    }

    
    public void execute() {
        DOMElementWriter writer = new DOMElementWriter(!append);
        OutputStream os = null;
        try {
            if (file != null) {
                os = new FileOutputStream(file.getAbsolutePath(), append);
            } else {
                os = new LogOutputStream(this, Project.MSG_INFO);
            }
            Node n = getFragment().getFirstChild();
            if (n == null) {
                throw new BuildException(ERROR_NO_XML);
            }
            writer.write((Element) n, os);
        } catch (BuildException e) {
            throw e;
        } catch (Exception e) {
            throw new BuildException(e);
        } finally {
            FileUtils.close(os);
        }
    }

}
"
org.apache.tools.mail.MailMessage,31,1,0,5,70,407,2,3,13,0.904761905,615,0.904761905,2,0.0,0.316129032,0,0,18.16129032,11,1.4516,0,"



package org.apache.tools.mail;

import java.io.IOException;
import java.io.PrintStream;
import java.io.BufferedOutputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.InetAddress;
import java.util.Vector;
import java.util.Enumeration;


public class MailMessage {

    
    public static final String DEFAULT_HOST = ""localhost"";

    
    public static final int DEFAULT_PORT = 25;

    
    private String host;

    
    private int port = DEFAULT_PORT;

    
    private String from;

    
    private Vector replyto;

    
    private Vector to;

    
    private Vector cc;

    
    private Vector headersKeys;
    private Vector headersValues;

    private MailPrintStream out;

    private SmtpResponseReader in;

    private Socket socket;
    private static final int OK_READY = 220;
    private static final int OK_HELO = 250;
    private static final int OK_FROM = 250;
    private static final int OK_RCPT_1 = 250;
    private static final int OK_RCPT_2 = 251;
    private static final int OK_DATA = 354;
    private static final int OK_DOT = 250;
    private static final int OK_QUIT = 221;

  
  public MailMessage() throws IOException {
    this(DEFAULT_HOST, DEFAULT_PORT);
  }

  
  public MailMessage(String host) throws IOException {
    this(host, DEFAULT_PORT);
  }

  
  public MailMessage(String host, int port) throws IOException {
    this.port = port;
    this.host = host;
    replyto = new Vector();
    to = new Vector();
    cc = new Vector();
    headersKeys = new Vector();
    headersValues = new Vector();
    connect();
    sendHelo();
  }

    
    public void setPort(int port) {
        this.port = port;
    }

    
    public void from(String from) throws IOException {
        sendFrom(from);
        this.from = from;
    }

    
    public void replyto(String rto) {
      this.replyto.addElement(rto);
    }

  
  public void to(String to) throws IOException {
    sendRcpt(to);
    this.to.addElement(to);
  }

  
  public void cc(String cc) throws IOException {
    sendRcpt(cc);
    this.cc.addElement(cc);
  }

  
  public void bcc(String bcc) throws IOException {
    sendRcpt(bcc);
    
  }

  
  public void setSubject(String subj) {
    setHeader(""Subject"", subj);
  }

  
  public void setHeader(String name, String value) {
    
    headersKeys.add(name);
    headersValues.add(value);
  }

  
  public PrintStream getPrintStream() throws IOException {
    setFromHeader();
    setReplyToHeader();
    setToHeader();
    setCcHeader();
    setHeader(""X-Mailer"", ""org.apache.tools.mail.MailMessage (ant.apache.org)"");
    sendData();
    flushHeaders();
    return out;
  }


  
  
  void setFromHeader() {
    setHeader(""From"", from);
  }

  
  void setReplyToHeader() {
    if (!replyto.isEmpty()) {
      setHeader(""Reply-To"", vectorToList(replyto));
    }
  }

  void setToHeader() {
    if (!to.isEmpty()) {
      setHeader(""To"", vectorToList(to));
    }
  }

  void setCcHeader() {
    if (!cc.isEmpty()) {
      setHeader(""Cc"", vectorToList(cc));
    }
  }

  String vectorToList(Vector v) {
    StringBuffer buf = new StringBuffer();
    Enumeration e = v.elements();
    while (e.hasMoreElements()) {
      buf.append(e.nextElement());
      if (e.hasMoreElements()) {
        buf.append("", "");
      }
    }
    return buf.toString();
  }

  void flushHeaders() throws IOException {
    
    
    
    
   for (int i = 0; i < headersKeys.size(); i++) {
      String name = (String) headersKeys.elementAt(i);
      String value = (String) headersValues.elementAt(i);
      out.println(name + "": "" + value);
    }
    out.println();
    out.flush();
  }

  
  public void sendAndClose() throws IOException {
      try {
          sendDot();
          sendQuit();
      } finally {
          disconnect();
      }
  }

  
  
  static String sanitizeAddress(String s) {
    int paramDepth = 0;
    int start = 0;
    int end = 0;
    int len = s.length();

    for (int i = 0; i < len; i++) {
      char c = s.charAt(i);
      if (c == '(') {
        paramDepth++;
        if (start == 0) {
          end = i;  
        }
      } else if (c == ')') {
        paramDepth--;
        if (end == 0) {
          start = i + 1;  
        }
      } else if (paramDepth == 0 && c == '<') {
        start = i + 1;
      } else if (paramDepth == 0 && c == '>') {
        end = i;
      }
    }

    if (end == 0) {
      end = len;
    }

    return s.substring(start, end);
  }

  

  void connect() throws IOException {
    socket = new Socket(host, port);
    out = new MailPrintStream(
          new BufferedOutputStream(
          socket.getOutputStream()));
    in = new SmtpResponseReader(socket.getInputStream());
    getReady();
  }

  void getReady() throws IOException {
    String response = in.getResponse();
    int[] ok = {OK_READY};
    if (!isResponseOK(response, ok)) {
      throw new IOException(
        ""Didn't get introduction from server: "" + response);
    }
  }
  void sendHelo() throws IOException {
    String local = InetAddress.getLocalHost().getHostName();
    int[] ok = {OK_HELO};
    send(""HELO "" + local, ok);
  }
  void sendFrom(String from) throws IOException {
    int[] ok = {OK_FROM};
    send(""MAIL FROM: "" + ""<"" + sanitizeAddress(from) + "">"", ok);
  }
  void sendRcpt(String rcpt) throws IOException {
    int[] ok = {OK_RCPT_1, OK_RCPT_2};
    send(""RCPT TO: "" + ""<"" + sanitizeAddress(rcpt) + "">"", ok);
  }

  void sendData() throws IOException {
    int[] ok = {OK_DATA};
    send(""DATA"", ok);
  }

  void sendDot() throws IOException {
    int[] ok = {OK_DOT};
    send(""\r\n."", ok);  
  }

    void sendQuit() throws IOException {
        int[] ok = {OK_QUIT};
        try {
            send(""QUIT"", ok);
        } catch (IOException e) {
            throw new ErrorInQuitException(e);
        }
    }

    void send(String msg, int[] ok) throws IOException {
        out.rawPrint(msg + ""\r\n"");  
        String response = in.getResponse();
        if (!isResponseOK(response, ok)) {
            throw new IOException(""Unexpected reply to command: ""
                                  + msg + "": "" + response);
        }
    }

  boolean isResponseOK(String response, int[] ok) {
    
    for (int i = 0; i < ok.length; i++) {
      if (response.startsWith("""" + ok[i])) {
        return true;
      }
    }
    return false;
  }

    void disconnect() throws IOException {
        if (out != null) {
            out.close();
        }
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                
            }
        }
        if (socket != null) {
            try {
                socket.close();
            } catch (IOException e) {
                
            }
        }
    }
}


class MailPrintStream extends PrintStream {

  private int lastChar;

  public MailPrintStream(OutputStream out) {
    super(out, true);  
  }

  
  
  public void write(int b) {
    if (b == '\n' && lastChar != '\r') {
      rawWrite('\r');  
      rawWrite(b);
    } else if (b == '.' && lastChar == '\n') {
      rawWrite('.');  
      rawWrite(b);
    } else {
      rawWrite(b);
    }
    lastChar = b;
  }

  public void write(byte[] buf, int off, int len) {
    for (int i = 0; i < len; i++) {
      write(buf[off + i]);
    }
  }

  void rawWrite(int b) {
    super.write(b);
  }

  void rawPrint(String s) {
    int len = s.length();
    for (int i = 0; i < len; i++) {
      rawWrite(s.charAt(i));
    }
  }
}

"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.DoubleCPInfo,3,3,0,2,11,3,1,1,3,2.0,25,0.0,0,0.8,0.666666667,2,2,7.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class DoubleCPInfo extends ConstantCPInfo {
    
    public DoubleCPInfo() {
        super(CONSTANT_DOUBLE, 2);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Double(cpStream.readDouble()));
    }

    
    public String toString() {
        return ""Double Constant Pool Entry: "" + getValue();
    }

}

"
org.apache.tools.ant.taskdefs.condition.Socket,4,2,0,4,13,0,1,3,4,0.333333333,85,1.0,0,0.75,0.5,0,0,19.75,1,0.75,0,"

package org.apache.tools.ant.taskdefs.condition;

import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;


public class Socket extends ProjectComponent implements Condition {
    private String server = null;
    private int port = 0;

    
    public void setServer(String server) {
        this.server = server;
    }

    
    public void setPort(int port) {
        this.port = port;
    }

    
    public boolean eval() throws BuildException {
        if (server == null) {
            throw new BuildException(""No server specified in socket ""
                                     + ""condition"");
        }
        if (port == 0) {
            throw new BuildException(""No port specified in socket condition"");
        }
        log(""Checking for listener at "" + server + "":"" + port,
            Project.MSG_VERBOSE);
        java.net.Socket s = null;
        try {
            s = new java.net.Socket(server, port);
        } catch (IOException e) {
            return false;
        } finally {
          if (s != null) {
            try {
              s.close();
            } catch (IOException ioe) {
              
            }
          }
        }
        return true;
    }

}
"
org.apache.tools.ant.ExitStatusException,4,5,0,5,7,0,3,2,4,0.0,29,1.0,0,0.954545455,0.625,0,0,6.0,1,0.25,0,"
package org.apache.tools.ant;


public class ExitStatusException extends BuildException {

    
    private int status;

    
    public ExitStatusException(int status) {
        super();
        this.status = status;
    }

    
    public ExitStatusException(String msg, int status) {
        super(msg);
        this.status = status;
    }

    
    public ExitStatusException(String message, int status, Location location) {
        super(message, location);
        this.status = status;
    }

    
    public int getStatus() {
        return status;
    }
}
"
org.apache.tools.ant.Target,28,1,0,34,63,200,29,7,24,0.805555556,528,1.0,2,0.0,0.219387755,0,0,17.57142857,8,1.8571,1,"

package org.apache.tools.ant;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import org.apache.tools.ant.util.CollectionUtils;


public class Target implements TaskContainer {

    
    private String name;
    
    private String ifCondition = """";
    
    private String unlessCondition = """";
    
    private List dependencies = null;
    
    private List children = new ArrayList();
    
    private Location location = Location.UNKNOWN_LOCATION;

    
    private Project project;

    
    private String description = null;

    
    public Target() {
        
    }

    
    public Target(Target other) {
        this.name = other.name;
        this.ifCondition = other.ifCondition;
        this.unlessCondition = other.unlessCondition;
        this.dependencies = other.dependencies;
        this.location = other.location;
        this.project = other.project;
        this.description = other.description;
        
        this.children = other.children;
    }

    
    public void setProject(Project project) {
        this.project = project;
    }

    
    public Project getProject() {
        return project;
    }

    
    public void setLocation(Location location) {
        this.location = location;
    }

    
    public Location getLocation() {
        return location;
    }

    
    public void setDepends(String depS) {
        if (depS.length() > 0) {
            StringTokenizer tok =
                new StringTokenizer(depS, "","", true);
            while (tok.hasMoreTokens()) {
                String token = tok.nextToken().trim();

                
                if ("""".equals(token) || "","".equals(token)) {
                    throw new BuildException(""Syntax Error: depends ""
                        + ""attribute of target \"""" + getName()
                        + ""\"" has an empty string as dependency."");
                }

                addDependency(token);

                
                
                if (tok.hasMoreTokens()) {
                    token = tok.nextToken();
                    if (!tok.hasMoreTokens() || !"","".equals(token)) {
                        throw new BuildException(""Syntax Error: Depend ""
                            + ""attribute for target \"""" + getName()
                            + ""\"" ends with a , character"");
                    }
                }
            }
        }
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public String getName() {
        return name;
    }

    
    public void addTask(Task task) {
        children.add(task);
    }

    
    public void addDataType(RuntimeConfigurable r) {
        children.add(r);
    }

    
    public Task[] getTasks() {
        List tasks = new ArrayList(children.size());
        Iterator it = children.iterator();
        while (it.hasNext()) {
            Object o = it.next();
            if (o instanceof Task) {
                tasks.add(o);
            }
        }

        return (Task[]) tasks.toArray(new Task[tasks.size()]);
    }

    
    public void addDependency(String dependency) {
        if (dependencies == null) {
            dependencies = new ArrayList(2);
        }
        dependencies.add(dependency);
    }

    
    public Enumeration getDependencies() {
        return (dependencies != null ? Collections.enumeration(dependencies)
                                     : new CollectionUtils.EmptyEnumeration());
    }

    
    public boolean dependsOn(String other) {
        Project p = getProject();
        Hashtable t = (p == null) ? null : p.getTargets();
        return (p != null
                && p.topoSort(getName(), t, false).contains(t.get(other)));
    }

    
    public void setIf(String property) {
        ifCondition = (property == null) ? """" : property;
    }

    
    public String getIf() {
        return ("""".equals(ifCondition) ? null : ifCondition);
    }

    
    public void setUnless(String property) {
        unlessCondition = (property == null) ? """" : property;
    }

    
    public String getUnless() {
        return ("""".equals(unlessCondition) ? null : unlessCondition);
    }

    
    public void setDescription(String description) {
        this.description = description;
    }

    
    public String getDescription() {
        return description;
    }

    
    public String toString() {
        return name;
    }

    
    public void execute() throws BuildException {
        if (testIfCondition() && testUnlessCondition()) {
            for (int taskPosition = 0;
                 taskPosition < children.size();
                 ++taskPosition) {
                Object o = children.get(taskPosition);
                if (o instanceof Task) {
                    Task task = (Task) o;
                    task.perform();
                } else {
                    RuntimeConfigurable r = (RuntimeConfigurable) o;
                    r.maybeConfigure(project);
                }
            }
        } else if (!testIfCondition()) {
            project.log(this, ""Skipped because property '""
                        + project.replaceProperties(ifCondition)
                        + ""' not set."", Project.MSG_VERBOSE);
        } else {
            project.log(this, ""Skipped because property '""
                        + project.replaceProperties(unlessCondition)
                        + ""' set."", Project.MSG_VERBOSE);
        }
    }

    
    public final void performTasks() {
        RuntimeException thrown = null;
        project.fireTargetStarted(this);
        try {
            execute();
        } catch (RuntimeException exc) {
            thrown = exc;
            throw exc;
        } finally {
            project.fireTargetFinished(this, thrown);
        }
    }

    
    void replaceChild(Task el, RuntimeConfigurable o) {
        int index;
        while ((index = children.indexOf(el)) >= 0) {
            children.set(index, o);
        }
    }

    
    void replaceChild(Task el, Task o) {
        int index;
        while ((index = children.indexOf(el)) >= 0) {
            children.set(index, o);
        }
    }

    
    private boolean testIfCondition() {
        if ("""".equals(ifCondition)) {
            return true;
        }

        String test = project.replaceProperties(ifCondition);
        return project.getProperty(test) != null;
    }

    
    private boolean testUnlessCondition() {
        if ("""".equals(unlessCondition)) {
            return true;
        }
        String test = project.replaceProperties(unlessCondition);
        return project.getProperty(test) == null;
    }
}
"
org.apache.tools.ant.types.resources.selectors.Name,6,1,0,3,11,0,0,3,6,0.5,56,1.0,0,0.0,0.375,0,0,8.0,3,1.1667,0,"
package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.selectors.SelectorUtils;


public class Name implements ResourceSelector {
    private String pattern;
    private boolean cs = true;

    
    public void setName(String n) {
        pattern = n;
    }

    
    public String getName() {
        return pattern;
    }

    
    public void setCaseSensitive(boolean b) {
        cs = b;
    }

    
    public boolean isCaseSensitive() {
        return cs;
    }

    
    public boolean isSelected(Resource r) {
        String n = r.getName();
        if (SelectorUtils.match(pattern, n, cs)) {
            return true;
        }
        String s = r.toString();
        return s.equals(n) ? false : SelectorUtils.match(pattern, s, cs);
    }

}
"
org.apache.tools.ant.taskdefs.condition.Contains,5,1,0,3,9,0,1,2,5,0.666666667,64,1.0,0,0.0,0.533333333,0,0,11.2,1,0.8,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;


public class Contains implements Condition {

    private String string, subString;
    private boolean caseSensitive = true;

    
    public void setString(String string) {
        this.string = string;
    }

    
    public void setSubstring(String subString) {
        this.subString = subString;
    }

    
    public void setCasesensitive(boolean b) {
        caseSensitive = b;
    }

    
    public boolean eval() throws BuildException {
        if (string == null || subString == null) {
            throw new BuildException(""both string and substring are required ""
                                     + ""in contains"");
        }

        return caseSensitive
            ? string.indexOf(subString) > -1
            : string.toLowerCase().indexOf(subString.toLowerCase()) > -1;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTaskMirror,3,1,0,7,3,3,2,5,3,2.0,3,0.0,0,0.0,0.476190476,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.IOException;
import java.io.OutputStream;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.types.Permissions;


public interface JUnitTaskMirror {

    
    void addVmExit(JUnitTest test, JUnitResultFormatterMirror formatter,
            OutputStream out, String message, String testCase);

    
    JUnitTestRunnerMirror newJUnitTestRunner(JUnitTest test, boolean haltOnError,
            boolean filterTrace, boolean haltOnFailure, boolean showOutput,
            boolean logTestListenerEvents, AntClassLoader classLoader);

    
    SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter();


    
    public interface JUnitResultFormatterMirror {
        
        void setOutput(OutputStream outputStream);
    }

    
    public interface SummaryJUnitResultFormatterMirror
        extends JUnitResultFormatterMirror {

        
        void setWithOutAndErr(boolean value);
    }

    
    public interface JUnitTestRunnerMirror {

        
        String IGNORED_FILE_NAME = ""IGNORETHIS"";

        
        int SUCCESS = 0;

        
        int FAILURES = 1;

        
        int ERRORS = 2;

        
        void setPermissions(Permissions perm);

        
        void run();

        
        void addFormatter(JUnitResultFormatterMirror formatter);

        
        int getRetCode();

        
        void handleErrorFlush(String output);

        
        void handleErrorOutput(String output);

        
        void handleOutput(String output);

        
        int handleInput(byte[] buffer, int offset, int length) throws IOException;

        
       void handleFlush(String output);

    }
}
"
org.apache.tools.ant.ProjectComponent,10,1,28,67,14,35,66,2,10,0.740740741,75,1.0,2,0.0,0.32,0,0,6.2,3,1.1,0,"

package org.apache.tools.ant;



public abstract class ProjectComponent implements Cloneable {

    
    
    protected Project project;

    
    protected Location location = Location.UNKNOWN_LOCATION;

    
    protected String description;
    

    
    public ProjectComponent() {
    }

    
    public void setProject(Project project) {
        this.project = project;
    }

    
    public Project getProject() {
        return project;
    }

    
    public Location getLocation() {
        return location;
    }

    
    public void setLocation(Location location) {
        this.location = location;
    }

    
    public void setDescription(String desc) {
        description = desc;
    }

    
    public String getDescription() {
        return description;
    }

    
    public void log(String msg) {
        log(msg, Project.MSG_INFO);
    }

    
    public void log(String msg, int msgLevel) {
        if (getProject() != null) {
            getProject().log(msg, msgLevel);
        } else {
            
            
            
            if (msgLevel <= Project.MSG_INFO) {
                System.err.println(msg);
            }
        }
    }
    
    public Object clone() throws CloneNotSupportedException {
        ProjectComponent pc = (ProjectComponent) super.clone();
        pc.setLocation(getLocation());
        pc.setProject(getProject());
        return pc;
    }
}
"
org.apache.tools.ant.filters.StripLineComments,8,5,0,5,26,0,1,4,5,0.571428571,172,1.0,0,0.823529412,0.375,2,5,20.125,4,1.125,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.util.Vector;
import org.apache.tools.ant.types.Parameter;


public final class StripLineComments
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String COMMENTS_KEY = ""comment"";

    
    private Vector comments = new Vector();

    
    private String line = null;

    
    public StripLineComments() {
        super();
    }

    
    public StripLineComments(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;

        if (line != null) {
            ch = line.charAt(0);
            if (line.length() == 1) {
                line = null;
            } else {
                line = line.substring(1);
            }
        } else {
            line = readLine();
            final int commentsSize = comments.size();

            while (line != null) {
                for (int i = 0; i < commentsSize; i++) {
                    String comment = (String) comments.elementAt(i);
                    if (line.startsWith(comment)) {
                        line = null;
                        break;
                    }
                }

                if (line == null) {
                    
                    line = readLine();
                } else {
                    break;
                }
            }

            if (line != null) {
                return read();
            }
        }

        return ch;
    }

    
    public void addConfiguredComment(final Comment comment) {
        comments.addElement(comment.getValue());
    }

    
    private void setComments(final Vector comments) {
        this.comments = comments;
    }

    
    private Vector getComments() {
        return comments;
    }

    
    public Reader chain(final Reader rdr) {
        StripLineComments newFilter = new StripLineComments(rdr);
        newFilter.setComments(getComments());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (COMMENTS_KEY.equals(params[i].getType())) {
                    comments.addElement(params[i].getValue());
                }
            }
        }
    }

    
    public static class Comment {

        
        private String value;

        
        public final void setValue(String comment) {
            value = comment;
        }

        
        public final String getValue() {
            return value;
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.CSharp,23,6,0,4,42,185,0,4,15,0.811688312,249,0.857142857,0,0.872093023,0.211180124,1,7,9.52173913,3,1.3913,0,"







package org.apache.tools.ant.taskdefs.optional.dotnet;





import java.io.File;





public class CSharp extends DotnetCompile {

    
    
    String definitions;


    
    private File docFile;

    
    private int fileAlign = 0;

    
    private boolean fullpaths = false;

    
    private boolean incremental;

    
    protected boolean unsafe;

    
    private boolean noconfig = false;
    


    

    public CSharp() {
        clear();
    }

    
    public void clear() {
        super.clear();
        docFile = null;
        fileAlign = 0;
        fullpaths = true;
        incremental = false;
        unsafe = false;
        noconfig = false;
        definitions = null;
        setExecutable(isWindows ? ""csc"" : ""mcs"");
    }



    
    public void setDocFile(File f) {
        docFile = f;
    }


    
    protected String getDocFileParameter() {
        if (docFile != null) {
            return ""/doc:"" + docFile.toString();
        } else {
            return null;
        }
    }

    
    public void setFileAlign(int fileAlign) {
        this.fileAlign = fileAlign;
    }

    
    protected String getFileAlignParameter() {
        if (fileAlign != 0 && !""mcs"".equals(getExecutable())) {
            return ""/filealign:"" + fileAlign;
        } else {
            return null;
        }
    }


    
    public void setFullPaths(boolean enabled) {
        fullpaths = enabled;
    }


    
    protected String getFullPathsParameter() {
        return fullpaths ? ""/fullpaths"" : null;
    }


    
    public void setIncremental(boolean incremental) {
        this.incremental = incremental;
    }


    
    public boolean getIncremental() {
        return incremental;
    }


    
    protected String getIncrementalParameter() {
        return ""/incremental"" + (incremental ? ""+"" : ""-"");
    }

    
    public void setOutputFile(File params) {
        setDestFile(params);
    }


    
    public void setUnsafe(boolean unsafe) {
        this.unsafe = unsafe;
    }


    
    public boolean getUnsafe() {
        return this.unsafe;
    }


    
    protected String getUnsafeParameter() {
        return unsafe ? ""/unsafe"" : null;
    }


    
    public void setNoConfig(boolean enabled) {
        noconfig = enabled;
    }


    
    protected String getNoConfigParameter() {
        return noconfig ? ""/noconfig"" : null;
    }


    
    public void setDefinitions(String params) {
        definitions = params;
    }

    
    protected String getDefinitionsParameter() {
        String predecessors = super.getDefinitionsParameter();
        if (notEmpty(definitions)) {
            if (predecessors == null) {
                predecessors = ""/define:"";
            }
            return  predecessors + definitions;
        } else {
            return predecessors;
        }
    }


    
    public void addCompilerSpecificOptions(NetCommand command) {
        command.addArgument(getIncludeDefaultReferencesParameter());
        command.addArgument(getWarnLevelParameter());
        command.addArgument(getDocFileParameter());
        command.addArgument(getFullPathsParameter());
        command.addArgument(getFileAlignParameter());
        command.addArgument(getIncrementalParameter());
        command.addArgument(getNoConfigParameter());
        command.addArgument(getUnsafeParameter());
    }

    

    
    public String getReferenceDelimiter() {
        return "";"";
    }


    
    public String getFileExtension() {
        return ""cs"";
    }

    
    protected void createResourceParameter(
        NetCommand command, DotnetResource resource) {
        resource.getParameters(getProject(), command, true);
    }

}

"
org.apache.tools.ant.types.ResourceFactory,1,1,0,9,1,0,8,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.types;


public interface ResourceFactory {

    
    Resource getResource(String name);
}
"
org.apache.tools.ant.DynamicConfiguratorNS,0,1,0,3,0,0,1,2,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.tools.ant;


public interface DynamicConfiguratorNS
    extends DynamicAttributeNS, DynamicElementNS {
}
"
org.apache.tools.ant.types.TimeComparison,8,2,1,8,15,20,5,3,7,0.914285714,136,0.4,4,0.615384615,0.476190476,1,1,15.375,7,1.5,0,"
package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;


public class TimeComparison extends EnumeratedAttribute {
    private static final String[] VALUES
        = new String[] {""before"", ""after"", ""equal""};

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public static final TimeComparison BEFORE = new TimeComparison(""before"");

    
    public static final TimeComparison AFTER = new TimeComparison(""after"");

    
    public static final TimeComparison EQUAL = new TimeComparison(""equal"");

    
    public TimeComparison() {
    }

    
    public TimeComparison(String value) {
        setValue(value);
    }

    
    public String[] getValues() {
        return VALUES;
    }

    
    public boolean evaluate(long t1, long t2) {
        return evaluate(t1, t2, FILE_UTILS.getFileTimestampGranularity());
    }

    
    public boolean evaluate(long t1, long t2, long g) {
        int cmp = getIndex();
        if (cmp == -1) {
            throw new BuildException(""TimeComparison value not set."");
        }
        if (cmp == 0) {
            return t1 - g < t2;
        }
        if (cmp == 1) {
            return t1 + g > t2;
        }
        return Math.abs(t1 - t2) <= g;
    }

    
    public static int compare(long t1, long t2) {
        return compare(t1, t2, FILE_UTILS.getFileTimestampGranularity());
    }

    
    public static int compare(long t1, long t2, long g) {
        long diff = t1 - t2;
        long abs = Math.abs(diff);
        return abs > Math.abs(g) ? (int) (diff / abs) : 0;
    }

}

"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSCREATE,5,4,0,5,21,10,0,5,4,2.0,71,0.0,0,0.957894737,0.533333333,1,1,13.2,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;


public class MSVSSCREATE extends MSVSS {

    
    Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_CREATE);

        
        commandLine.createArgument().setValue(getVsspath());
        
        commandLine.createArgument().setValue(getComment());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(getQuiet());
        
        commandLine.createArgument().setValue(getLogin());

        return commandLine;
    }

    
    public void setComment(String comment) {
        super.setInternalComment(comment);
    }

    
    public final void setQuiet (boolean quiet) {
        super.setInternalQuiet(quiet);
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }
}
"
org.apache.tools.tar.TarBuffer,21,1,0,2,36,38,2,0,17,0.631818182,620,0.818181818,0,0.0,0.293650794,0,0,28.0,3,0.8571,1,"



package org.apache.tools.tar;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Arrays;



public class TarBuffer {

    
    public static final int DEFAULT_RCDSIZE = (512);

    
    public static final int DEFAULT_BLKSIZE = (DEFAULT_RCDSIZE * 20);

    private InputStream     inStream;
    private OutputStream    outStream;
    private byte[]          blockBuffer;
    private int             currBlkIdx;
    private int             currRecIdx;
    private int             blockSize;
    private int             recordSize;
    private int             recsPerBlock;
    private boolean         debug;

    
    public TarBuffer(InputStream inStream) {
        this(inStream, TarBuffer.DEFAULT_BLKSIZE);
    }

    
    public TarBuffer(InputStream inStream, int blockSize) {
        this(inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    
    public TarBuffer(InputStream inStream, int blockSize, int recordSize) {
        this.inStream = inStream;
        this.outStream = null;

        this.initialize(blockSize, recordSize);
    }

    
    public TarBuffer(OutputStream outStream) {
        this(outStream, TarBuffer.DEFAULT_BLKSIZE);
    }

    
    public TarBuffer(OutputStream outStream, int blockSize) {
        this(outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    
    public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {
        this.inStream = null;
        this.outStream = outStream;

        this.initialize(blockSize, recordSize);
    }

    
    private void initialize(int blockSize, int recordSize) {
        this.debug = false;
        this.blockSize = blockSize;
        this.recordSize = recordSize;
        this.recsPerBlock = (this.blockSize / this.recordSize);
        this.blockBuffer = new byte[this.blockSize];

        if (this.inStream != null) {
            this.currBlkIdx = -1;
            this.currRecIdx = this.recsPerBlock;
        } else {
            this.currBlkIdx = 0;
            this.currRecIdx = 0;
        }
    }

    
    public int getBlockSize() {
        return this.blockSize;
    }

    
    public int getRecordSize() {
        return this.recordSize;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public boolean isEOFRecord(byte[] record) {
        for (int i = 0, sz = this.getRecordSize(); i < sz; ++i) {
            if (record[i] != 0) {
                return false;
            }
        }

        return true;
    }

    
    public void skipRecord() throws IOException {
        if (this.debug) {
            System.err.println(""SkipRecord: recIdx = "" + this.currRecIdx
                               + "" blkIdx = "" + this.currBlkIdx);
        }

        if (this.inStream == null) {
            throw new IOException(""reading (via skip) from an output buffer"");
        }

        if (this.currRecIdx >= this.recsPerBlock) {
            if (!this.readBlock()) {
                return;    
            }
        }

        this.currRecIdx++;
    }

    
    public byte[] readRecord() throws IOException {
        if (this.debug) {
            System.err.println(""ReadRecord: recIdx = "" + this.currRecIdx
                               + "" blkIdx = "" + this.currBlkIdx);
        }

        if (this.inStream == null) {
            throw new IOException(""reading from an output buffer"");
        }

        if (this.currRecIdx >= this.recsPerBlock) {
            if (!this.readBlock()) {
                return null;
            }
        }

        byte[] result = new byte[this.recordSize];

        System.arraycopy(this.blockBuffer,
                         (this.currRecIdx * this.recordSize), result, 0,
                         this.recordSize);

        this.currRecIdx++;

        return result;
    }

    
    private boolean readBlock() throws IOException {
        if (this.debug) {
            System.err.println(""ReadBlock: blkIdx = "" + this.currBlkIdx);
        }

        if (this.inStream == null) {
            throw new IOException(""reading from an output buffer"");
        }

        this.currRecIdx = 0;

        int offset = 0;
        int bytesNeeded = this.blockSize;

        while (bytesNeeded > 0) {
            long numBytes = this.inStream.read(this.blockBuffer, offset,
                                               bytesNeeded);

            
            
            
            
            
            
            
            
            
            
            
            
            
            if (numBytes == -1) {
                if (offset == 0) {
                    
                    
                    
                    return false;
                }
                
                
                
                
                

                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);

                break;
            }

            offset += numBytes;
            bytesNeeded -= numBytes;

            if (numBytes != this.blockSize) {
                if (this.debug) {
                    System.err.println(""ReadBlock: INCOMPLETE READ ""
                                       + numBytes + "" of "" + this.blockSize
                                       + "" bytes read."");
                }
            }
        }

        this.currBlkIdx++;

        return true;
    }

    
    public int getCurrentBlockNum() {
        return this.currBlkIdx;
    }

    
    public int getCurrentRecordNum() {
        return this.currRecIdx - 1;
    }

    
    public void writeRecord(byte[] record) throws IOException {
        if (this.debug) {
            System.err.println(""WriteRecord: recIdx = "" + this.currRecIdx
                               + "" blkIdx = "" + this.currBlkIdx);
        }

        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        }

        if (record.length != this.recordSize) {
            throw new IOException(""record to write has length '""
                                  + record.length
                                  + ""' which is not the record size of '""
                                  + this.recordSize + ""'"");
        }

        if (this.currRecIdx >= this.recsPerBlock) {
            this.writeBlock();
        }

        System.arraycopy(record, 0, this.blockBuffer,
                         (this.currRecIdx * this.recordSize),
                         this.recordSize);

        this.currRecIdx++;
    }

    
    public void writeRecord(byte[] buf, int offset) throws IOException {
        if (this.debug) {
            System.err.println(""WriteRecord: recIdx = "" + this.currRecIdx
                               + "" blkIdx = "" + this.currBlkIdx);
        }

        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        }

        if ((offset + this.recordSize) > buf.length) {
            throw new IOException(""record has length '"" + buf.length
                                  + ""' with offset '"" + offset
                                  + ""' which is less than the record size of '""
                                  + this.recordSize + ""'"");
        }

        if (this.currRecIdx >= this.recsPerBlock) {
            this.writeBlock();
        }

        System.arraycopy(buf, offset, this.blockBuffer,
                         (this.currRecIdx * this.recordSize),
                         this.recordSize);

        this.currRecIdx++;
    }

    
    private void writeBlock() throws IOException {
        if (this.debug) {
            System.err.println(""WriteBlock: blkIdx = "" + this.currBlkIdx);
        }

        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        }

        this.outStream.write(this.blockBuffer, 0, this.blockSize);
        this.outStream.flush();

        this.currRecIdx = 0;
        this.currBlkIdx++;
    }

    
    private void flushBlock() throws IOException {
        if (this.debug) {
            System.err.println(""TarBuffer.flushBlock() called."");
        }

        if (this.outStream == null) {
            throw new IOException(""writing to an input buffer"");
        }

        if (this.currRecIdx > 0) {
            this.writeBlock();
        }
    }

    
    public void close() throws IOException {
        if (this.debug) {
            System.err.println(""TarBuffer.closeBuffer()."");
        }

        if (this.outStream != null) {
            this.flushBlock();

            if (this.outStream != System.out
                    && this.outStream != System.err) {
                this.outStream.close();

                this.outStream = null;
            }
        } else if (this.inStream != null) {
            if (this.inStream != System.in) {
                this.inStream.close();

                this.inStream = null;
            }
        }
    }
}
"
org.apache.tools.ant.types.selectors.NotSelector,4,6,0,8,13,6,6,2,4,2.0,44,0.0,0,0.96969697,0.625,2,3,10.0,2,1.0,0,"

package org.apache.tools.ant.types.selectors;



public class NotSelector extends NoneSelector {

    
    public NotSelector() {
    }

    
    public NotSelector(FileSelector other) {
        this();
        appendSelector(other);
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (hasSelectors()) {
            buf.append(""{notselect: "");
            buf.append(super.toString());
            buf.append(""}"");
        }
        return buf.toString();
    }

    
    public void verifySettings() {
        if (selectorCount() != 1) {
            setError(""One and only one selector is allowed within the ""
                + ""<not> tag"");
        }
    }

}

"
org.apache.tools.ant.util.depend.bcel.AncestorAnalyzer,3,2,0,3,31,3,0,3,1,2.0,202,0.0,0,0.882352941,0.666666667,1,2,66.33333333,14,5.0,0,"
package org.apache.tools.ant.util.depend.bcel;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.bcel.classfile.ClassParser;
import org.apache.bcel.classfile.JavaClass;
import org.apache.tools.ant.util.depend.AbstractAnalyzer;


public class AncestorAnalyzer extends AbstractAnalyzer {

    
    public AncestorAnalyzer() {
        
        try {
            new ClassParser(""force"");
        } catch (IOException e) {
            
        }
    }

    
    protected void determineDependencies(Vector files, Vector classes) {
        
        
        Hashtable dependencies = new Hashtable();
        Hashtable containers = new Hashtable();
        Hashtable toAnalyze = new Hashtable();
        Hashtable nextAnalyze = new Hashtable();
        for (Enumeration e = getRootClasses(); e.hasMoreElements();) {
            String classname = (String) e.nextElement();
            toAnalyze.put(classname, classname);
        }

        int count = 0;
        int maxCount = isClosureRequired() ? MAX_LOOPS : 2;
        while (toAnalyze.size() != 0 && count++ < maxCount) {
            nextAnalyze.clear();
            for (Enumeration e = toAnalyze.keys(); e.hasMoreElements();) {
                String classname = (String) e.nextElement();
                dependencies.put(classname, classname);
                try {
                    File container = getClassContainer(classname);
                    if (container == null) {
                        continue;
                    }
                    containers.put(container, container);

                    ClassParser parser = null;
                    if (container.getName().endsWith("".class"")) {
                        parser = new ClassParser(container.getPath());
                    } else {
                        parser = new ClassParser(container.getPath(),
                            classname.replace('.', '/') + "".class"");
                    }

                    JavaClass javaClass = parser.parse();
                    String[] interfaces = javaClass.getInterfaceNames();
                    for (int i = 0; i < interfaces.length; ++i) {
                        String interfaceName = interfaces[i];
                        if (!dependencies.containsKey(interfaceName)) {
                            nextAnalyze.put(interfaceName, interfaceName);
                        }
                    }

                    if (javaClass.isClass()) {
                        String superClass = javaClass.getSuperclassName();
                        if (!dependencies.containsKey(superClass)) {
                            nextAnalyze.put(superClass, superClass);
                        }
                    }
                } catch (IOException ioe) {
                    
                }
            }

            Hashtable temp = toAnalyze;
            toAnalyze = nextAnalyze;
            nextAnalyze = temp;
        }

        files.removeAllElements();
        for (Enumeration e = containers.keys(); e.hasMoreElements();) {
            files.addElement((File) e.nextElement());
        }

        classes.removeAllElements();
        for (Enumeration e = dependencies.keys(); e.hasMoreElements();) {
            classes.addElement((String) e.nextElement());
        }
    }

    
    protected boolean supportsFileDependencies() {
        return true;
    }

}

"
org.apache.tools.ant.taskdefs.DependSet,14,4,0,25,59,67,3,25,8,0.8,304,1.0,5,0.866666667,0.261538462,1,2,20.35714286,4,1.2857,3,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.Iterator;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FileList;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.TimeComparison;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.Sort;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.resources.Restrict;
import org.apache.tools.ant.types.resources.Resources;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.selectors.Not;
import org.apache.tools.ant.types.resources.selectors.Exists;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.types.resources.comparators.Reverse;
import org.apache.tools.ant.types.resources.comparators.ResourceComparator;


public class DependSet extends MatchingTask {

    private static final ResourceSelector NOT_EXISTS = new Not(new Exists());
    private static final ResourceComparator DATE_ASC
        = new org.apache.tools.ant.types.resources.comparators.Date();
    private static final ResourceComparator DATE_DESC = new Reverse(DATE_ASC);

    private static class NonExistent extends Restrict {
        private NonExistent(ResourceCollection rc) {
            super.add(rc);
            super.add(NOT_EXISTS);
        }
    }
    private static class Xest extends Sort {
        private Xest(ResourceCollection rc, ResourceComparator c) {
            super.add(c);
            super.add(rc);
        }
    }
    private static class Oldest extends Xest {
        private Oldest(ResourceCollection rc) {
            super(rc, DATE_ASC);
        }
    }
    private static class Newest extends Xest {
        private Newest(ResourceCollection rc) {
            super(rc, DATE_DESC);
        }
    }
    private static class HideMissingBasedir implements ResourceCollection {
        private FileSet fs;

        private HideMissingBasedir(FileSet fs) {
            this.fs = fs;
        }
        public Iterator iterator() {
            return basedirExists() ? fs.iterator() : Resources.EMPTY_ITERATOR;
        }
        public int size() {
            return basedirExists() ? fs.size() : 0;
        }
        public boolean isFilesystemOnly() {
            return true;
        }
        private boolean basedirExists() {
            File basedir = fs.getDir();
            
            return basedir == null || basedir.exists();
        }
    }

    private Union sources = null;
    private Path targets = null;

    
    public synchronized Union createSources() {
        sources = (sources == null) ? new Union() : sources;
        return sources;
    }

    
    public void addSrcfileset(FileSet fs) {
        createSources().add(fs);
    }

    
    public void addSrcfilelist(FileList fl) {
        createSources().add(fl);
    }

    
    public synchronized Path createTargets() {
        targets = (targets == null) ? new Path(getProject()) : targets;
        return targets;
    }

    
    public void addTargetfileset(FileSet fs) {
        createTargets().add(new HideMissingBasedir(fs));
    }

    
    public void addTargetfilelist(FileList fl) {
        createTargets().add(fl);
    }

    
    public void execute() throws BuildException {
        if (sources == null) {
          throw new BuildException(
              ""At least one set of source resources must be specified"");
        }
        if (targets == null) {
          throw new BuildException(
              ""At least one set of target files must be specified"");
        }
        
        if (sources.size() > 0 && targets.size() > 0 && !uptodate(sources, targets)) {
           log(""Deleting all target files."", Project.MSG_VERBOSE);
           Delete delete = new Delete();
           delete.bindToOwner(this);
           delete.add(targets);
           delete.perform();
        }
    }

    private boolean uptodate(ResourceCollection src, ResourceCollection target) {
        org.apache.tools.ant.types.resources.selectors.Date datesel
            = new org.apache.tools.ant.types.resources.selectors.Date();
        datesel.setMillis(System.currentTimeMillis());
        datesel.setWhen(TimeComparison.AFTER);
        logFuture(targets, datesel);

        int neTargets = new NonExistent(targets).size();
        if (neTargets > 0) {
            log(neTargets + "" nonexistent targets"", Project.MSG_VERBOSE);
            return false;
        }
        FileResource oldestTarget = (FileResource) (new Oldest(targets).iterator().next());
        log(oldestTarget + "" is oldest target file"", Project.MSG_VERBOSE);

        logFuture(sources, datesel);

        int neSources = new NonExistent(sources).size();
        if (neSources > 0) {
            log(neSources + "" nonexistent sources"", Project.MSG_VERBOSE);
            return false;
        }
        Resource newestSource = (Resource) (new Newest(sources).iterator().next());
        log(newestSource.toLongString() + "" is newest source"", Project.MSG_VERBOSE);
        return oldestTarget.getLastModified() >= newestSource.getLastModified();
    }

    private void logFuture(ResourceCollection rc, ResourceSelector rsel) {
        Restrict r = new Restrict();
        r.add(rsel);
        r.add(rc);
        for (Iterator i = r.iterator(); i.hasNext();) {
            log(""Warning: "" + i.next() + "" modified in the future."", Project.MSG_WARN);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.Ilasm,31,5,0,7,51,381,0,7,20,0.919047619,376,1.0,0,0.743589744,0.241935484,2,4,10.67741935,4,1.5161,0,"


package org.apache.tools.ant.taskdefs.optional.dotnet;


import java.io.File;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;



public class Ilasm
         extends DotnetBaseMatchingTask {

    
    
    
    protected static final String exe_name = ""ilasm"";

    
    protected static final String file_ext = ""il"";

    
    protected static final String file_pattern = ""**
    protected static final String exe_title = ""ilasm"";

    
    protected String targetType;

    
    protected boolean verbose;

    

    protected boolean listing;

    
    protected File resourceFile;

    
    protected boolean failOnError;

    
    protected boolean debug;

    

    private File keyfile;

    
    protected String extraOptions;

    
    protected Vector referenceFilesets = new Vector();

    
    

    
    private boolean isMono = !Os.isFamily(""windows"");

    
    public Ilasm() {
        Clear();
        setIncludes(file_pattern);
    }

    
    
    public void Clear() {
        targetType = null;
        srcDir = null;
        listing = false;
        verbose = false;
        debug = true;
        outputFile = null;
        failOnError = true;
        resourceFile = null;
        extraOptions = null;
    }
    



    
    public void setTargetType(String targetType)
             throws BuildException {
        this.targetType = targetType.toLowerCase();
        if (!targetType.equals(""exe"") && !targetType.equals(""library"")) {
            throw new BuildException(""targetType "" + targetType + "" is not a valid type"");
        }
    }


    
    public String getTargetType() {
        return targetType;
    }


    

    protected String getTargetTypeParameter() {
        if (!notEmpty(targetType)) {
            return null;
        }
        if (targetType.equals(""exe"")) {
            return ""/exe"";
        } else if (targetType.equals(""library"")) {
            return ""/dll"";
        } else {
            return null;
        }
    }


    
    public void setOwner(String s) {
        log(""This option is not supported by ILASM as of Beta-2, ""
            + ""and will be ignored"", Project.MSG_WARN);
    }


    
    protected boolean notEmpty(String s) {
        return s != null && s.length() != 0;
    }


    
    public void setVerbose(boolean b) {
        verbose = b;
    }


    
    protected String getVerboseParameter() {
        return verbose ? null : ""/quiet"";
    }


    
    public void setListing(boolean b) {
        listing = b;
    }


    
    protected String getListingParameter() {
        if (!isMono) {
            return listing ? ""/listing"" : ""/nolisting"";
        }
        return null;
    }


    
    public void setOutputFile(File params) {
        outputFile = params;
    }


    
    protected String getOutputFileParameter() {
        if (outputFile == null) {
            return null;
        }
        return ""/output="" + outputFile.toString();
    }


    
    public void setResourceFile(File fileName) {
        resourceFile = fileName;
    }


    
    protected String getResourceFileParameter() {
        if (resourceFile != null) {
            return ""/resource="" + resourceFile.toString();
        } else {
            return null;
        }
    }


    
    public void setFailOnError(boolean b) {
        failOnError = b;
    }


    
    public boolean getFailOnError() {
        return failOnError;
    }


    
    public void setDebug(boolean f) {
        debug = f;
    }


    
    public boolean getDebug() {
        return debug;
    }


    
    protected String getDebugParameter() {
        return debug ? ""/debug"" : null;
    }


    
    public void setKeyfile(File keyfile) {
        this.keyfile = keyfile;
    }


    
    protected String getKeyfileParameter() {
        if (keyfile != null) {
            return ""/keyfile:"" + keyfile.toString();
        } else {
            return null;
        }
    }


    
    public void setExtraOptions(String extraOptions) {
        this.extraOptions = extraOptions;
    }


    
    public String getExtraOptions() {
        return this.extraOptions;
    }


    
    protected String getExtraOptionsParameter() {
        if (extraOptions != null && extraOptions.length() != 0) {
            return extraOptions;
        } else {
            return null;
        }
    }

    
    public void setTargetType(TargetTypes targetType) {
        this.targetType = targetType.getValue();
    }

    
    public void setMono(boolean b) {
        isMono = b;
    }

    
    public void execute()
             throws BuildException {
        log(""This task is deprecated and will be removed in a future version\n""
            + ""of Ant.  It is now part of the .NET Antlib:\n""
            + ""http:
            Project.MSG_WARN);
        NetCommand command = buildIlasmCommand();

        addFilesAndExecute(command, false);

    }
    


    
    private NetCommand buildIlasmCommand() {
        NetCommand command = new NetCommand(this, exe_title, exe_name);
        command.setFailOnError(getFailOnError());
        
        command.addArgument(getDebugParameter());
        command.addArgument(getTargetTypeParameter());
        command.addArgument(getListingParameter());
        command.addArgument(getOutputFileParameter());
        command.addArgument(getResourceFileParameter());
        command.addArgument(getVerboseParameter());
        command.addArgument(getKeyfileParameter());
        command.addArgument(getExtraOptionsParameter());

        
        return command;
    }

    
    public void addReference(FileSet reference) {
        referenceFilesets.add(reference);
    }

    
    protected static boolean isFileManagedBinary(File file) {
        String filename = file.toString().toLowerCase();
        return filename.endsWith("".exe"") || filename.endsWith("".dll"")
                || filename.endsWith("".netmodule"");
    }


    
    public static class TargetTypes extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[]{
                ""exe"",
                ""library"",
            };
        }
    }

}

"
org.apache.tools.ant.types.selectors.DependSelector,3,5,0,10,12,1,6,4,3,2.0,76,0.0,0,0.953488372,0.666666667,1,1,24.33333333,4,1.6667,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;


public class DependSelector extends MappingSelector {

    
    public DependSelector() {

    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{dependselector targetdir: "");
        if (targetdir == null) {
            buf.append(""NOT YET SET"");
        } else {
            buf.append(targetdir.getName());
        }
        buf.append("" granularity: "");
        buf.append(granularity);
        if (map != null) {
            buf.append("" mapper: "");
            buf.append(map.toString());
        } else if (mapperElement != null) {
            buf.append("" mapper: "");
            buf.append(mapperElement.toString());
        }
        buf.append(""}"");
        return buf.toString();
    }


    
    public boolean selectionTest(File srcfile, File destfile) {
        boolean selected = SelectorUtils.isOutOfDate(srcfile, destfile,
                granularity);
        return selected;
    }

}

"
org.apache.tools.ant.types.resources.TarResource,11,5,0,8,49,21,2,6,9,0.55,265,1.0,0,0.896103896,0.363636364,2,4,22.72727273,7,1.7273,0,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.tar.TarEntry;
import org.apache.tools.tar.TarInputStream;


public class TarResource extends ArchiveResource {

    private String userName = """";
    private String groupName = """";
    private int    uid;
    private int    gid;

    
    public TarResource() {
    }

    
    public TarResource(File a, TarEntry e) {
        super(a, true);
        setEntry(e);
    }

    
    public TarResource(Resource a, TarEntry e) {
        super(a, true);
        setEntry(e);
    }

    
    public InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        Resource archive = getArchive();
        final TarInputStream i = new TarInputStream(archive.getInputStream());
        TarEntry te = null;
        while ((te = i.getNextEntry()) != null) {
            if (te.getName().equals(getName())) {
                return i;
            }
        }

        FileUtils.close(i);
        throw new BuildException(""no entry "" + getName() + "" in ""
                                 + getArchive());
    }

    
    public OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        throw new UnsupportedOperationException(
            ""Use the tar task for tar output."");
    }

    
    public String getUserName() {
        if (isReference()) {
            return ((TarResource) getCheckedRef()).getUserName();
        }
        return userName;
    }

    
    public String getGroup() {
        if (isReference()) {
            return ((TarResource) getCheckedRef()).getGroup();
        }
        return groupName;
    }

    
    public int getUid() {
        if (isReference()) {
            return ((TarResource) getCheckedRef()).getUid();
        }
        return uid;
    }

    
    public int getGid() {
        if (isReference()) {
            return ((TarResource) getCheckedRef()).getGid();
        }
        return uid;
    }

    
    protected void fetchEntry() {
        Resource archive = getArchive();
        TarInputStream i = null;
        try {
            i = new TarInputStream(archive.getInputStream());
            TarEntry te = null;
            while ((te = i.getNextEntry()) != null) {
                if (te.getName().equals(getName())) {
                    setEntry(te);
                    return;
                }
            }
        } catch (IOException e) {
            log(e.getMessage(), Project.MSG_DEBUG);
            throw new BuildException(e);
        } finally {
            if (i != null) {
                FileUtils.close(i);
            }
        }
        setEntry(null);
    }

    private void setEntry(TarEntry e) {
        if (e == null) {
            setExists(false);
            return;
        }
        setName(e.getName());
        setExists(true);
        setLastModified(e.getModTime().getTime());
        setDirectory(e.isDirectory());
        setSize(e.getSize());
        setMode(e.getMode());
        userName = e.getUserName();
        groupName = e.getGroupName();
        uid = e.getUserId();
        gid = e.getGroupId();
    }

}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Submit,7,4,0,4,14,15,1,4,5,0.833333333,56,0.666666667,0,0.894736842,0.476190476,1,1,6.571428571,1,0.8571,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import java.util.Vector;


public class P4Submit extends P4Base {

    
    
    
    public String change;
    
    
    private String changeProperty;
    
    private String needsResolveProperty;
    
    public void setChange(String change) {
        this.change = change;
    }
    
    public void setChangeProperty(String changeProperty) {
        this.changeProperty = changeProperty;
    }
    
    public void setNeedsResolveProperty(String needsResolveProperty) {
        this.needsResolveProperty = needsResolveProperty;
    }

    
    public void execute() throws BuildException {
        if (change != null) {
            execP4Command(""submit -c "" + change, (P4HandlerAdapter) new P4SubmitAdapter(this));
        } else {
            
            
            throw new BuildException(""No change specified (no support for default change yet...."");
        }
    }

    
    public class P4SubmitAdapter extends SimpleP4OutputHandler {
        
        public P4SubmitAdapter(P4Base parent) {
            super(parent);
        }
        
        public void process(String line) {
            super.process(line);
            getProject().setProperty(""p4.needsresolve"", ""0"");
            
            
            if (util.match(""/renamed/"", line)) {
                try {
                    Vector myarray = new Vector();
                    util.split(myarray, line);
                    boolean found = false;
                    for (int counter = 0; counter < myarray.size(); counter++) {
                        if (found) {
                            String chnum = (String) myarray.elementAt(counter + 1);
                            int changenumber = Integer.parseInt(chnum);
                            log(""Perforce change renamed "" + changenumber, Project.MSG_INFO);
                            getProject().setProperty(""p4.change"", """" + changenumber);
                            if (changeProperty != null) {
                                getProject().setNewProperty(changeProperty, chnum);
                            }
                            found = false;
                        }
                        if (((myarray.elementAt(counter))).equals(""renamed"")) {
                            found = true;
                        }
                    }
                
                } catch (Exception e) {
                    String msg = ""Failed to parse "" + line  + ""\n""
                            + "" due to "" + e.getMessage();
                    throw new BuildException(msg, e, getLocation());
                }
            }
            if (util.match(""/p4 submit -c/"", line)) {
                getProject().setProperty(""p4.needsresolve"", ""1"");
                if (needsResolveProperty != null) {
                    getProject().setNewProperty(needsResolveProperty, ""true"");
                }
            }

        }
    }

}
"
org.apache.tools.ant.types.Parameterizable,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.types;


public interface Parameterizable {
    
    void setParameters(Parameter[] parameters);
}
"
org.apache.tools.ant.taskdefs.Copy,45,3,2,25,157,744,4,22,27,0.902097902,1828,0.846153846,2,0.4625,0.13986014,1,1,39.04444444,19,2.2444,5,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FilterSet;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.FilterSetCollection;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.ResourceFactory;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.ant.util.ResourceUtils;
import org.apache.tools.ant.util.SourceFileScanner;
import org.apache.tools.ant.util.FlatFileNameMapper;


public class Copy extends Task {
    static final File NULL_FILE_PLACEHOLDER = new File(""/NULL_FILE"");
    static final String LINE_SEPARATOR = System.getProperty(""line.separator"");
    
    protected File file = null;     
    protected File destFile = null; 
    protected File destDir = null;  
    protected Vector rcs = new Vector();

    private boolean enableMultipleMappings = false;
    protected boolean filtering = false;
    protected boolean preserveLastModified = false;
    protected boolean forceOverwrite = false;
    protected boolean flatten = false;
    protected int verbosity = Project.MSG_VERBOSE;
    protected boolean includeEmpty = true;
    protected boolean failonerror = true;

    protected Hashtable fileCopyMap = new Hashtable();
    protected Hashtable dirCopyMap = new Hashtable();
    protected Hashtable completeDirMap = new Hashtable();

    protected Mapper mapperElement = null;
    protected FileUtils fileUtils;
    private Vector filterChains = new Vector();
    private Vector filterSets = new Vector();
    private String inputEncoding = null;
    private String outputEncoding = null;
    private long granularity = 0;
    

    
    public Copy() {
        fileUtils = FileUtils.getFileUtils();
        granularity = fileUtils.getFileTimestampGranularity();
    }

    
    protected FileUtils getFileUtils() {
        return fileUtils;
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setTofile(File destFile) {
        this.destFile = destFile;
    }

    
    public void setTodir(File destDir) {
        this.destDir = destDir;
    }

    
    public FilterChain createFilterChain() {
        FilterChain filterChain = new FilterChain();
        filterChains.addElement(filterChain);
        return filterChain;
    }

    
    public FilterSet createFilterSet() {
        FilterSet filterSet = new FilterSet();
        filterSets.addElement(filterSet);
        return filterSet;
    }

    
    public void setPreserveLastModified(String preserve) {
        setPreserveLastModified(Project.toBoolean(preserve));
    }

    
    public void setPreserveLastModified(boolean preserve) {
        preserveLastModified = preserve;
    }

    
    public boolean getPreserveLastModified() {
        return preserveLastModified;
    }

    
    protected Vector getFilterSets() {
        return filterSets;
    }

    
    protected Vector getFilterChains() {
        return filterChains;
    }

    
    public void setFiltering(boolean filtering) {
        this.filtering = filtering;
    }

    
    public void setOverwrite(boolean overwrite) {
        this.forceOverwrite = overwrite;
    }

    
    public void setFlatten(boolean flatten) {
        this.flatten = flatten;
    }

    
    public void setVerbose(boolean verbose) {
        this.verbosity = verbose ? Project.MSG_INFO : Project.MSG_VERBOSE;
    }

    
    public void setIncludeEmptyDirs(boolean includeEmpty) {
        this.includeEmpty = includeEmpty;
    }

    
    public void setEnableMultipleMappings(boolean enableMultipleMappings) {
        this.enableMultipleMappings = enableMultipleMappings;
    }

    
    public boolean isEnableMultipleMapping() {
        return enableMultipleMappings;
    }

    
    public void setFailOnError(boolean failonerror) {
        this.failonerror = failonerror;
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void add(ResourceCollection res) {
        rcs.add(res);
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     getLocation());
        }
        mapperElement = new Mapper(getProject());
        return mapperElement;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        createMapper().add(fileNameMapper);
    }

    
    public void setEncoding(String encoding) {
        this.inputEncoding = encoding;
        if (outputEncoding == null) {
            outputEncoding = encoding;
        }
    }

    
    public String getEncoding() {
        return inputEncoding;
    }

    
    public void setOutputEncoding(String encoding) {
        this.outputEncoding = encoding;
    }

    
    public String getOutputEncoding() {
        return outputEncoding;
    }

    
    public void setGranularity(long granularity) {
        this.granularity = granularity;
    }

    
    public void execute() throws BuildException {
        File savedFile = file; 
        File savedDestFile = destFile;
        File savedDestDir = destDir;
        ResourceCollection savedRc = null;
        if (file == null && destFile != null && rcs.size() == 1) {
            
            savedRc = (ResourceCollection) rcs.elementAt(0);
        }
        
        validateAttributes();

        try {
            
            if (file != null) {
                if (file.exists()) {
                    if (destFile == null) {
                        destFile = new File(destDir, file.getName());
                    }
                    if (forceOverwrite || !destFile.exists()
                        || (file.lastModified() - granularity
                                > destFile.lastModified())) {
                        fileCopyMap.put(file.getAbsolutePath(),
                                        new String[] {destFile.getAbsolutePath()});
                    } else {
                        log(file + "" omitted as "" + destFile
                            + "" is up to date."", Project.MSG_VERBOSE);
                    }
                } else {
                    String message = ""Warning: Could not find file ""
                        + file.getAbsolutePath() + "" to copy."";
                    if (!failonerror) {
                        log(message, Project.MSG_ERR);
                    } else {
                        throw new BuildException(message);
                    }
                }
            }
            

            

            HashMap filesByBasedir = new HashMap();
            HashMap dirsByBasedir = new HashMap();
            HashSet baseDirs = new HashSet();
            ArrayList nonFileResources = new ArrayList();
            for (int i = 0; i < rcs.size(); i++) {
                ResourceCollection rc = (ResourceCollection) rcs.elementAt(i);

                
                if (rc instanceof FileSet && rc.isFilesystemOnly()) {
                    FileSet fs = (FileSet) rc;
                    DirectoryScanner ds = null;
                    try {
                        ds = fs.getDirectoryScanner(getProject());
                    } catch (BuildException e) {
                        if (failonerror
                            || !getMessage(e).endsWith("" not found."")) {
                            throw e;
                        } else {
                            log(""Warning: "" + getMessage(e), Project.MSG_ERR);
                            continue;
                        }
                    }
                    File fromDir = fs.getDir(getProject());

                    String[] srcFiles = ds.getIncludedFiles();
                    String[] srcDirs = ds.getIncludedDirectories();
                    if (!flatten && mapperElement == null
                        && ds.isEverythingIncluded() && !fs.hasPatterns()) {
                        completeDirMap.put(fromDir, destDir);
                    }
                    add(fromDir, srcFiles, filesByBasedir);
                    add(fromDir, srcDirs, dirsByBasedir);
                    baseDirs.add(fromDir);
                } else { 

                    if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
                        throw new BuildException(
                                   ""Only FileSystem resources are supported."");
                    }

                    Iterator resources = rc.iterator();
                    while (resources.hasNext()) {
                        Resource r = (Resource) resources.next();
                        if (!r.isExists()) {
                            continue;
                        }

                        File baseDir = NULL_FILE_PLACEHOLDER;
                        String name = r.getName();
                        if (r instanceof FileResource) {
                            FileResource fr = (FileResource) r;
                            baseDir = getKeyFile(fr.getBaseDir());
                            if (fr.getBaseDir() == null) {
                                name = fr.getFile().getAbsolutePath();
                            }
                        }

                        
                        
                        
                        if (r.isDirectory() || r instanceof FileResource) {
                            add(baseDir, name,
                                r.isDirectory() ? dirsByBasedir
                                                : filesByBasedir);
                            baseDirs.add(baseDir);
                        } else { 
                            
                            nonFileResources.add(r);
                        }
                    }
                }
            }

            Iterator iter = baseDirs.iterator();
            while (iter.hasNext()) {
                File f = (File) iter.next();
                List files = (List) filesByBasedir.get(f);
                List dirs = (List) dirsByBasedir.get(f);

                String[] srcFiles = new String[0];
                if (files != null) {
                    srcFiles = (String[]) files.toArray(srcFiles);
                }
                String[] srcDirs = new String[0];
                if (dirs != null) {
                    srcDirs = (String[]) dirs.toArray(srcDirs);
                }
                scan(f == NULL_FILE_PLACEHOLDER ? null : f, destDir, srcFiles,
                     srcDirs);
            }

            
            try {
                doFileOperations();
            } catch (BuildException e) {
                if (!failonerror) {
                    log(""Warning: "" + getMessage(e), Project.MSG_ERR);
                } else {
                    throw e;
                }
            }

            if (nonFileResources.size() > 0) {
                Resource[] nonFiles =
                    (Resource[]) nonFileResources.toArray(new Resource[nonFileResources.size()]);
                
                Map map = scan(nonFiles, destDir);
                try {
                    doResourceOperations(map);
                } catch (BuildException e) {
                    if (!failonerror) {
                        log(""Warning: "" + getMessage(e), Project.MSG_ERR);
                    } else {
                        throw e;
                    }
                }
            }
        } finally {
            
            
            file = savedFile;
            destFile = savedDestFile;
            destDir = savedDestDir;
            if (savedRc != null) {
                rcs.insertElementAt(savedRc, 0);
            }
            fileCopyMap.clear();
            dirCopyMap.clear();
            completeDirMap.clear();
        }
    }

    

    
    protected void validateAttributes() throws BuildException {
        if (file == null && rcs.size() == 0) {
            throw new BuildException(
                ""Specify at least one source--a file or a resource collection."");
        }
        if (destFile != null && destDir != null) {
            throw new BuildException(
                ""Only one of tofile and todir may be set."");
        }
        if (destFile == null && destDir == null) {
            throw new BuildException(""One of tofile or todir must be set."");
        }
        if (file != null && file.isDirectory()) {
            throw new BuildException(""Use a resource collection to copy directories."");
        }
        if (destFile != null && rcs.size() > 0) {
            if (rcs.size() > 1) {
                throw new BuildException(
                    ""Cannot concatenate multiple files into a single file."");
            } else {
                ResourceCollection rc = (ResourceCollection) rcs.elementAt(0);
                if (!rc.isFilesystemOnly()) {
                    throw new BuildException(""Only FileSystem resources are""
                                             + "" supported when concatenating""
                                             + "" files."");
                }
                if (rc.size() == 0) {
                    throw new BuildException(
                        ""Cannot perform operation from directory to file."");
                } else if (rc.size() == 1) {
                    FileResource r = (FileResource) rc.iterator().next();
                    if (file == null) {
                        file = r.getFile();
                        rcs.removeElementAt(0);
                    } else {
                        throw new BuildException(
                            ""Cannot concatenate multiple files into a single file."");
                    }
                } else {
                    throw new BuildException(
                        ""Cannot concatenate multiple files into a single file."");
                }
            }
        }
        if (destFile != null) {
            destDir = destFile.getParentFile();
        }
    }

    
    protected void scan(File fromDir, File toDir, String[] files,
                        String[] dirs) {
        FileNameMapper mapper = getMapper();
        buildMap(fromDir, toDir, files, mapper, fileCopyMap);

        if (includeEmpty) {
            buildMap(fromDir, toDir, dirs, mapper, dirCopyMap);
        }
    }

    
    protected Map scan(Resource[] fromResources, File toDir) {
        return buildMap(fromResources, toDir, getMapper());
    }

    
    protected void buildMap(File fromDir, File toDir, String[] names,
                            FileNameMapper mapper, Hashtable map) {
        String[] toCopy = null;
        if (forceOverwrite) {
            Vector v = new Vector();
            for (int i = 0; i < names.length; i++) {
                if (mapper.mapFileName(names[i]) != null) {
                    v.addElement(names[i]);
                }
            }
            toCopy = new String[v.size()];
            v.copyInto(toCopy);
        } else {
            SourceFileScanner ds = new SourceFileScanner(this);
            toCopy = ds.restrict(names, fromDir, toDir, mapper, granularity);
        }
        for (int i = 0; i < toCopy.length; i++) {
            File src = new File(fromDir, toCopy[i]);
            String[] mappedFiles = mapper.mapFileName(toCopy[i]);

            if (!enableMultipleMappings) {
                map.put(src.getAbsolutePath(),
                        new String[] {new File(toDir, mappedFiles[0]).getAbsolutePath()});
            } else {
                
                for (int k = 0; k < mappedFiles.length; k++) {
                    mappedFiles[k] = new File(toDir, mappedFiles[k]).getAbsolutePath();
                }
                map.put(src.getAbsolutePath(), mappedFiles);
            }
        }
    }

    
    protected Map buildMap(Resource[] fromResources, final File toDir,
                           FileNameMapper mapper) {
        HashMap map = new HashMap();
        Resource[] toCopy = null;
        if (forceOverwrite) {
            Vector v = new Vector();
            for (int i = 0; i < fromResources.length; i++) {
                if (mapper.mapFileName(fromResources[i].getName()) != null) {
                    v.addElement(fromResources[i]);
                }
            }
            toCopy = new Resource[v.size()];
            v.copyInto(toCopy);
        } else {
            toCopy =
                ResourceUtils.selectOutOfDateSources(this, fromResources,
                                                     mapper,
                                                     new ResourceFactory() {
                           public Resource getResource(String name) {
                               return new FileResource(toDir, name);
                           }
                                                     },
                                                     granularity);
        }
        for (int i = 0; i < toCopy.length; i++) {
            String[] mappedFiles = mapper.mapFileName(toCopy[i].getName());

            if (!enableMultipleMappings) {
                map.put(toCopy[i],
                        new String[] {new File(toDir, mappedFiles[0]).getAbsolutePath()});
            } else {
                
                for (int k = 0; k < mappedFiles.length; k++) {
                    mappedFiles[k] = new File(toDir, mappedFiles[k]).getAbsolutePath();
                }
                map.put(toCopy[i], mappedFiles);
            }
        }
        return map;
    }

    
    protected void doFileOperations() {
        if (fileCopyMap.size() > 0) {
            log(""Copying "" + fileCopyMap.size()
                + "" file"" + (fileCopyMap.size() == 1 ? """" : ""s"")
                + "" to "" + destDir.getAbsolutePath());

            Enumeration e = fileCopyMap.keys();
            while (e.hasMoreElements()) {
                String fromFile = (String) e.nextElement();
                String[] toFiles = (String[]) fileCopyMap.get(fromFile);

                for (int i = 0; i < toFiles.length; i++) {
                    String toFile = toFiles[i];

                    if (fromFile.equals(toFile)) {
                        log(""Skipping self-copy of "" + fromFile, verbosity);
                        continue;
                    }
                    try {
                        log(""Copying "" + fromFile + "" to "" + toFile, verbosity);

                        FilterSetCollection executionFilters =
                            new FilterSetCollection();
                        if (filtering) {
                            executionFilters
                                .addFilterSet(getProject().getGlobalFilterSet());
                        }
                        for (Enumeration filterEnum = filterSets.elements();
                            filterEnum.hasMoreElements();) {
                            executionFilters
                                .addFilterSet((FilterSet) filterEnum.nextElement());
                        }
                        fileUtils.copyFile(fromFile, toFile, executionFilters,
                                           filterChains, forceOverwrite,
                                           preserveLastModified, inputEncoding,
                                           outputEncoding, getProject());
                    } catch (IOException ioe) {
                        String msg = ""Failed to copy "" + fromFile + "" to "" + toFile
                            + "" due to "" + getDueTo(ioe);
                        File targetFile = new File(toFile);
                        if (targetFile.exists() && !targetFile.delete()) {
                            msg += "" and I couldn't delete the corrupt "" + toFile;
                        }
                        if (failonerror) {
                            throw new BuildException(msg, ioe, getLocation());
                        }
                        log(msg, Project.MSG_ERR);
                    }
                }
            }
        }
        if (includeEmpty) {
            Enumeration e = dirCopyMap.elements();
            int createCount = 0;
            while (e.hasMoreElements()) {
                String[] dirs = (String[]) e.nextElement();
                for (int i = 0; i < dirs.length; i++) {
                    File d = new File(dirs[i]);
                    if (!d.exists()) {
                        if (!d.mkdirs()) {
                            log(""Unable to create directory ""
                                + d.getAbsolutePath(), Project.MSG_ERR);
                        } else {
                            createCount++;
                        }
                    }
                }
            }
            if (createCount > 0) {
                log(""Copied "" + dirCopyMap.size()
                    + "" empty director""
                    + (dirCopyMap.size() == 1 ? ""y"" : ""ies"")
                    + "" to "" + createCount
                    + "" empty director""
                    + (createCount == 1 ? ""y"" : ""ies"") + "" under ""
                    + destDir.getAbsolutePath());
            }
        }
    }

    
    protected void doResourceOperations(Map map) {
        if (map.size() > 0) {
            log(""Copying "" + map.size()
                + "" resource"" + (map.size() == 1 ? """" : ""s"")
                + "" to "" + destDir.getAbsolutePath());

            Iterator iter = map.keySet().iterator();
            while (iter.hasNext()) {
                Resource fromResource = (Resource) iter.next();
                String[] toFiles = (String[]) map.get(fromResource);

                for (int i = 0; i < toFiles.length; i++) {
                    String toFile = toFiles[i];

                    try {
                        log(""Copying "" + fromResource + "" to "" + toFile,
                            verbosity);

                        FilterSetCollection executionFilters =
                            new FilterSetCollection();
                        if (filtering) {
                            executionFilters
                                .addFilterSet(getProject().getGlobalFilterSet());
                        }
                        for (Enumeration filterEnum = filterSets.elements();
                            filterEnum.hasMoreElements();) {
                            executionFilters
                                .addFilterSet((FilterSet) filterEnum.nextElement());
                        }
                        ResourceUtils.copyResource(fromResource,
                                                   new FileResource(destDir,
                                                                    toFile),
                                                   executionFilters,
                                                   filterChains,
                                                   forceOverwrite,
                                                   preserveLastModified,
                                                   inputEncoding,
                                                   outputEncoding,
                                                   getProject());
                    } catch (IOException ioe) {
                        String msg = ""Failed to copy "" + fromResource
                            + "" to "" + toFile
                            + "" due to "" + getDueTo(ioe);
                        File targetFile = new File(toFile);
                        if (targetFile.exists() && !targetFile.delete()) {
                            msg += "" and I couldn't delete the corrupt "" + toFile;
                        }
                        if (failonerror) {
                            throw new BuildException(msg, ioe, getLocation());
                        }
                        log(msg, Project.MSG_ERR);
                    }
                }
            }
        }
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(Copy.class);
    }

    
    private static void add(File baseDir, String[] names, Map m) {
        if (names != null) {
            baseDir = getKeyFile(baseDir);
            List l = (List) m.get(baseDir);
            if (l == null) {
                l = new ArrayList(names.length);
                m.put(baseDir, l);
            }
            l.addAll(java.util.Arrays.asList(names));
        }
    }

    
    private static void add(File baseDir, String name, Map m) {
        if (name != null) {
            add(baseDir, new String[] {name}, m);
        }
    }

    
    private static File getKeyFile(File f) {
        return f == null ? NULL_FILE_PLACEHOLDER : f;
    }

    
    private FileNameMapper getMapper() {
        FileNameMapper mapper = null;
        if (mapperElement != null) {
            mapper = mapperElement.getImplementation();
        } else if (flatten) {
            mapper = new FlatFileNameMapper();
        } else {
            mapper = new IdentityMapper();
        }
        return mapper;
    }

    
    private String getMessage(Exception ex) {
        return ex.getMessage() == null ? ex.toString() : ex.getMessage();
    }

    
    private String getDueTo(Exception ex) {
        boolean baseIOException = ex.getClass() == IOException.class;
        StringBuffer message = new StringBuffer();
        if (!baseIOException || ex.getMessage() == null) {
            message.append(ex.getClass().getName());
        }
        if (ex.getMessage() != null) {
            if (!baseIOException) {
                message.append("" "");
            }
            message.append(ex.getMessage());
        }
        if (ex.getClass().getName().indexOf(""MalformedInput"") != -1) {
            message.append(LINE_SEPARATOR);
            message.append(
                ""This is normally due to the input file containing invalid"");
             message.append(LINE_SEPARATOR);
            message.append(""bytes for the character encoding used : "");
            message.append(
                (inputEncoding == null
                 ? fileUtils.getDefaultEncoding() : inputEncoding));
            message.append(LINE_SEPARATOR);
        }
        return message.toString();
    }
}
"
org.apache.tools.ant.util.WeakishReference,3,1,1,1,6,1,1,0,2,0.0,22,1.0,0,0.0,0.666666667,0,0,6.0,1,0.6667,0,"

package org.apache.tools.ant.util;


import java.lang.ref.WeakReference;


public class WeakishReference  {


    private WeakReference weakref;

    
    WeakishReference(Object reference) {
        this.weakref = new WeakReference(reference);
    }

    
    public Object get() {
        return weakref.get();
    }

    
    public static WeakishReference createReference(Object object) {
            return new WeakishReference(object);
    }


    
    public static class HardReference extends WeakishReference {

        
        public HardReference(Object object) {
            super(object);
        }

    }

}
"
org.apache.tools.ant.taskdefs.CVSPass,6,3,0,3,32,0,0,3,5,0.6,1254,1.0,0,0.880952381,0.555555556,1,1,207.3333333,2,1.0,0,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.StringUtils;


public class CVSPass extends Task {
    
    private String cvsRoot = null;
    
    private File passFile = null;
    
    private String password = null;

    
    private final char[] shifts = {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
         16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
        114, 120,  53,  79,  96, 109,  72, 108,  70,  64,  76,  67, 116,  74,  68,  87,
        111,  52,  75, 119,  49,  34,  82,  81,  95,  65, 112,  86, 118, 110, 122, 105,
         41,  57,  83,  43,  46, 102,  40,  89,  38, 103,  45,  50,  42, 123,  91,  35,
        125,  55,  54,  66, 124, 126,  59,  47,  92,  71, 115,  78,  88, 107, 106,  56,
         36, 121, 117, 104, 101, 100,  69,  73,  99,  63,  94,  93,  39,  37,  61,  48,
         58, 113,  32,  90,  44,  98,  60,  51,  33,  97,  62,  77,  84,  80,  85, 223,
        225, 216, 187, 166, 229, 189, 222, 188, 141, 249, 148, 200, 184, 136, 248, 190,
        199, 170, 181, 204, 138, 232, 218, 183, 255, 234, 220, 247, 213, 203, 226, 193,
        174, 172, 228, 252, 217, 201, 131, 230, 197, 211, 145, 238, 161, 179, 160, 212,
        207, 221, 254, 173, 202, 146, 224, 151, 140, 196, 205, 130, 135, 133, 143, 246,
        192, 159, 244, 239, 185, 168, 215, 144, 139, 165, 180, 157, 147, 186, 214, 176,
        227, 231, 219, 169, 175, 156, 206, 198, 129, 164, 150, 210, 154, 177, 134, 127,
        182, 128, 158, 208, 162, 132, 167, 209, 149, 241, 153, 251, 237, 236, 171, 195,
        243, 233, 253, 240, 194, 250, 191, 155, 142, 137, 245, 235, 163, 242, 178, 152
    };

    
    public CVSPass() {
        passFile = new File(
            System.getProperty(""cygwin.user.home"",
                System.getProperty(""user.home""))
            + File.separatorChar + "".cvspass"");
    }

    
    public final void execute() throws BuildException {
        if (cvsRoot == null) {
            throw new BuildException(""cvsroot is required"");
        }
        if (password == null) {
            throw new BuildException(""password is required"");
        }

        log(""cvsRoot: "" + cvsRoot, Project.MSG_DEBUG);
        log(""password: "" + password, Project.MSG_DEBUG);
        log(""passFile: "" + passFile, Project.MSG_DEBUG);

        BufferedReader reader = null;
        PrintWriter writer = null;
        try {
            StringBuffer buf = new StringBuffer();

            if (passFile.exists()) {
                reader = new BufferedReader(new FileReader(passFile));

                String line = null;

                while ((line = reader.readLine()) != null) {
                    if (!line.startsWith(cvsRoot)) {
                        buf.append(line).append(StringUtils.LINE_SEP);
                    }
                }
            }

            String pwdfile = buf.toString() + cvsRoot + "" A""
                + mangle(password);

            log(""Writing -> "" + pwdfile , Project.MSG_DEBUG);

            writer = new PrintWriter(new FileWriter(passFile));

            writer.println(pwdfile);
        } catch (IOException e) {
            throw new BuildException(e);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    
                }
            }
            if (writer != null) {
                writer.close();
            }
        }
    }

    private final String mangle(String password) {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < password.length(); i++) {
            buf.append(shifts[password.charAt(i)]);
        }
        return buf.toString();
    }

    
    public void setCvsroot(String cvsRoot) {
        this.cvsRoot = cvsRoot;
    }

    
    public void setPassfile(File passFile) {
        this.passFile = passFile;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

}
"
org.apache.tools.ant.types.LogLevel,5,2,2,3,8,8,2,1,3,0.958333333,101,0.166666667,5,0.8,0.625,1,1,18.0,1,0.4,0,"

package org.apache.tools.ant.types;

import org.apache.tools.ant.Project;


public class LogLevel extends EnumeratedAttribute {

    
    public static final LogLevel ERR = new LogLevel(""error"");

    
    public static final LogLevel WARN = new LogLevel(""warn"");

    
    public static final LogLevel INFO = new LogLevel(""info"");

    
    public static final LogLevel VERBOSE = new LogLevel(""verbose"");

    
    public static final LogLevel DEBUG = new LogLevel(""debug"");

    
    public LogLevel() {
    }

    private LogLevel(String value) {
        this();
        setValue(value);
    }

    
    public String[] getValues() {
        return new String[] {
            ""error"",
            ""warn"",
            ""warning"",
            ""info"",
            ""verbose"",
            ""debug""};
    }

    
    private static int[] levels = {
        Project.MSG_ERR,
        Project.MSG_WARN,
        Project.MSG_WARN,
        Project.MSG_INFO,
        Project.MSG_VERBOSE,
        Project.MSG_DEBUG
    };

    
    public int getLevel() {
        return levels[getIndex()];
    }
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.WsdlToDotnet,18,3,0,6,55,79,0,6,15,0.890756303,322,0.857142857,3,0.698113208,0.268907563,1,1,16.11111111,3,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.dotnet;

import java.io.File;
import java.util.Vector;
import java.util.Iterator;
import java.net.MalformedURLException;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.util.FileUtils;



public class WsdlToDotnet extends Task  {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private File destFile = null;

    
    private String language = ""CS"";

    
    private boolean server = false;

    
    private String namespace = null;

    
    private boolean failOnError = true;

    
    
    protected String extraOptions = null;

    


    
    private String protocol = null;

    
    private boolean ideErrors = false;

    
    private Vector schemas = new Vector();

    
    private Schema wsdl = new Schema();

    
    private Compiler compiler = null;

    
    public static final String ERROR_DEST_FILE_IS_DIR = ""destination file is a directory"";

    
    public static final String ERROR_NO_DEST_FILE = ""destination file must be specified"";

    
    public void setDestFile(File destFile) {
        this.destFile = destFile;
    }

    

    public void setUrl(String url) {
        wsdl.setUrl(url);
    }

    
    public void setSrcFile(File srcFile) {
        wsdl.setFile(srcFile);
    }

    
    public void setLanguage(String language) {
        this.language = language;
    }

    

    public void setServer(boolean server) {
        this.server = server;
    }

    
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    
    public void setFailOnError(boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    public void setExtraOptions(String extraOptions) {
        this.extraOptions = extraOptions;
    }

    
    public void setIdeErrors(boolean ideErrors) {
        this.ideErrors = ideErrors;
    }

    
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }

    
    public void addSchema(Schema source) {
        schemas.add(source);
    }

    
    public void setMakeURL(boolean b) {
        wsdl.setMakeURL(b);
    }

    
    public void setCompiler(Compiler compiler) {
        this.compiler = compiler;
    }

    
    protected void validate()
            throws BuildException {
        if (destFile == null) {
            throw new BuildException(ERROR_NO_DEST_FILE);
        }
        if (destFile.isDirectory()) {
            throw new BuildException(
                    ERROR_DEST_FILE_IS_DIR);
        }
        wsdl.validate();
    }

    
    public void execute()
             throws BuildException {
        log(""This task is deprecated and will be removed in a future version\n""
            + ""of Ant.  It is now part of the .NET Antlib:\n""
            + ""http:
            Project.MSG_WARN);

        if (compiler == null) {
            compiler = Compiler.createDefaultCompiler();
        }
        validate();
        NetCommand command = new NetCommand(this,
                ""WSDL"",
                compiler.getCommand());
        command.setFailOnError(failOnError);
        
        compiler.applyExtraArgs(command);
        command.addArgument(""/nologo"");
        command.addArgument(""/out:"" + destFile);
        command.addArgument(""/language:"", language);
        if (server) {
            command.addArgument(""/server"");
        }
        command.addArgument(""/namespace:"", namespace);
        if (protocol != null) {
            command.addArgument(""/protocol:"" + protocol);
        }
        if (ideErrors) {
            command.addArgument(""/parsableErrors"");
        }
        command.addArgument(extraOptions);

        
        boolean rebuild = true;
        long destLastModified = -1;

        
        if (destFile.exists()) {
            destLastModified = destFile.lastModified();
            rebuild = isRebuildNeeded(wsdl, destLastModified);
        }
        String path;
        
        path = wsdl.evaluate();
        if (!compiler.supportsAbsoluteFiles() && wsdl.getFile() != null) {
            
            File f = wsdl.getFile();
            command.setDirectory(f.getParentFile());
            path = f.getName();
        }
        command.addArgument(path);
        
        
        
        Iterator it = schemas.iterator();
        while (it.hasNext()) {
            Schema schema = (Schema) it.next();
            
            rebuild |= isRebuildNeeded(schema, destLastModified);
            command.addArgument(schema.evaluate());
        }
        
        if (rebuild) {
            command.runCommand();
        }
    }

    
    private boolean isRebuildNeeded(Schema schema, long destLastModified) {
        if (destLastModified == -1) {
            return true;
        }
        return !FILE_UTILS.isUpToDate(schema.getTimestamp(), destLastModified);
    }


    
    public static class Schema {
        private File file;
        private String url;
        private boolean makeURL = false;

        
        
        public static final String ERROR_NONE_DECLARED = ""One of file and url must be set"";
        
        public static final String ERROR_BOTH_DECLARED = ""Only one of file or url can be set"";
        
        public static final String ERROR_FILE_NOT_FOUND = ""Not found: "";
        
        public static final String ERROR_FILE_IS_DIR = ""File is a directory: "";
        
        public static final String ERROR_NO_URL_CONVERT = ""Could not URL convert "";

        
        public  void validate() {

            if (file != null) {
                if (!file.exists()) {
                    throw new BuildException(ERROR_FILE_NOT_FOUND + file.toString());
                }
                if (file.isDirectory()) {
                    throw new BuildException(ERROR_FILE_IS_DIR + file.toString());
                }
            }
            if (file != null && url != null) {
                throw new BuildException(ERROR_BOTH_DECLARED);
            }
            if (file == null && url == null) {
                throw new BuildException(ERROR_NONE_DECLARED);
            }
        }

        
        public String evaluate() {
            validate();
            if (url != null) {
                return getUrl();
            }
            if (makeURL) {
                try {
                    return file.toURL().toExternalForm();
                } catch (MalformedURLException e) {
                    throw new BuildException(ERROR_NO_URL_CONVERT + file);
                }
            }
            return file.toString();
        }

        
        public File getFile() {
            return file;
        }

        
        public void setFile(File file) {
            this.file = file;
        }

        
        public String getUrl() {
            return url;
        }

        
        public void setUrl(String url) {
            this.url = url;
        }

        
        public boolean isMakeURL() {
            return makeURL;
        }

        
        public void setMakeURL(boolean makeURL) {
            this.makeURL = makeURL;
        }

        
        public long getTimestamp() {
            if (file != null) {
                return file.lastModified();
            } else {
                return -1;
            }
        }
    }

    
    public static class Compiler extends EnumeratedAttribute {

        
        public static final String COMPILER_MS = ""microsoft"";
        
        public static final String COMPILER_MONO = ""mono"";
        
        public static final String COMPILER_MS_ON_MONO = ""microsoft-on-mono"";
        
        
        String[] compilers = {
            COMPILER_MS,
            COMPILER_MONO,
            COMPILER_MS_ON_MONO
        };

        
        public static final String EXE_WSDL = ""wsdl"";
        
        public static final String EXE_MONO = ""mono"";
        
        String[] compilerExecutables = {
            EXE_WSDL,
            EXE_WSDL,
            EXE_MONO
        };


        
        String[][] extraCompilerArgs = {
            {},
            {},
            {EXE_WSDL + "".exe""}
        };

        boolean[] absoluteFiles = {
            true,
            false,
            true
        };

        
        
        public String[] getValues() {
            return compilers;
        }

        
        public static Compiler createDefaultCompiler() {
            Compiler c = new Compiler();
            String compilerName;
            compilerName = Os.isFamily(""windows"") ? COMPILER_MS : COMPILER_MONO;
            c.setValue(compilerName);
            return c;
        }

        
        public String getCommand() {
            return compilerExecutables[getIndex()];
        }

        
        public String[] getExtraArgs() {
            return extraCompilerArgs[getIndex()];
        }

        
        public boolean supportsAbsoluteFiles() {
            return absoluteFiles[getIndex()];
        }

        
        public void applyExtraArgs(NetCommand command) {
            String[] args = getExtraArgs();
            for (int i = 0; i < args.length; i++) {
               command.addArgument(args[i]);
            }
        }

    }

}
"
org.apache.tools.ant.types.resources.comparators.Size,2,4,0,2,4,1,0,2,1,2.0,12,0.0,0,0.971428571,0.75,1,1,5.0,1,0.5,0,"
package org.apache.tools.ant.types.resources.comparators;

import org.apache.tools.ant.types.Resource;


public class Size extends ResourceComparator {
    
    protected int resourceCompare(Resource foo, Resource bar) {
        return (int) (foo.getSize() - bar.getSize());
    }

}
"
org.apache.tools.ant.types.PropertySet,24,3,0,21,96,246,9,13,20,0.722826087,610,0.875,1,0.566037736,0.154166667,1,1,24.08333333,14,2.5417,0,"

package org.apache.tools.ant.types;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.Map;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeMap;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.resources.PropertyResource;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.regexp.RegexpMatcher;
import org.apache.tools.ant.util.regexp.RegexpMatcherFactory;


public class PropertySet extends DataType implements ResourceCollection {

    private boolean dynamic = true;
    private boolean negate = false;
    private Set cachedNames;
    private Vector ptyRefs = new Vector();
    private Vector setRefs = new Vector();
    private Mapper mapper;

    
    public static class PropertyRef {

        private int count;
        private String name;
        private String regex;
        private String prefix;
        private String builtin;

        
        public void setName(String name) {
            assertValid(""name"", name);
            this.name = name;
        }

        
        public void setRegex(String regex) {
            assertValid(""regex"", regex);
            this.regex = regex;
        }

        
        public void setPrefix(String prefix) {
            assertValid(""prefix"", prefix);
            this.prefix = prefix;
        }

        
        public void setBuiltin(BuiltinPropertySetName b) {
            String pBuiltIn = b.getValue();
            assertValid(""builtin"", pBuiltIn);
            this.builtin = pBuiltIn;
        }

        private void assertValid(String attr, String value) {
            if (value == null || value.length() < 1) {
                throw new BuildException(""Invalid attribute: "" + attr);
            }

            if (++count != 1) {
                throw new BuildException(""Attributes name, regex, and ""
                    + ""prefix are mutually exclusive"");
            }
        }

        
        public String toString() {
            return ""name="" + name + "", regex="" + regex + "", prefix="" + prefix
                + "", builtin="" + builtin;
        }

    } 

    
    public void appendName(String name) {
        PropertyRef r = new PropertyRef();
        r.setName(name);
        addPropertyref(r);
    }

    
    public void appendRegex(String regex) {
        PropertyRef r = new PropertyRef();
        r.setRegex(regex);
        addPropertyref(r);
    }

    
    public void appendPrefix(String prefix) {
        PropertyRef r = new PropertyRef();
        r.setPrefix(prefix);
        addPropertyref(r);
    }

    
    public void appendBuiltin(BuiltinPropertySetName b) {
        PropertyRef r = new PropertyRef();
        r.setBuiltin(b);
        addPropertyref(r);
    }

    
    public void setMapper(String type, String from, String to) {
        Mapper m = createMapper();
        Mapper.MapperType mapperType = new Mapper.MapperType();
        mapperType.setValue(type);
        m.setType(mapperType);
        m.setFrom(from);
        m.setTo(to);
    }

    
    public void addPropertyref(PropertyRef ref) {
        assertNotReference();
        ptyRefs.addElement(ref);
    }

    
    public void addPropertyset(PropertySet ref) {
        assertNotReference();
        setRefs.addElement(ref);
    }

    
    public Mapper createMapper() {
        assertNotReference();
        if (mapper != null) {
            throw new BuildException(""Too many <mapper>s!"");
        }
        mapper = new Mapper(getProject());
        return mapper;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        createMapper().add(fileNameMapper);
    }

    
    public void setDynamic(boolean dynamic) {
        assertNotReference();
        this.dynamic = dynamic;
    }

    
    public void setNegate(boolean negate) {
        assertNotReference();
        this.negate = negate;
    }

    
    public boolean getDynamic() {
        return isReference() ? getRef().dynamic : dynamic;
    }

    
    public Mapper getMapper() {
        return isReference() ? getRef().mapper : mapper;
    }

    
    private Hashtable getAllSystemProperties() {
        Hashtable ret = new Hashtable();
        for (Enumeration e = System.getProperties().propertyNames();
             e.hasMoreElements();) {
            String name = (String) e.nextElement();
            ret.put(name, System.getProperties().getProperty(name));
        }
        return ret;
    }

    
    public Properties getProperties() {
        if (isReference()) {
            return getRef().getProperties();
        }
        Set names = null;
        Project prj = getProject();
        Hashtable props =
            prj == null ? getAllSystemProperties() : prj.getProperties();

        
        for (Enumeration e = setRefs.elements(); e.hasMoreElements();) {
            PropertySet set = (PropertySet) e.nextElement();
            props.putAll(set.getProperties());
        }

        if (getDynamic() || cachedNames == null) {
            names = new HashSet();
            addPropertyNames(names, props);
            
            for (Enumeration e = setRefs.elements(); e.hasMoreElements();) {
                PropertySet set = (PropertySet) e.nextElement();
                names.addAll(set.getProperties().keySet());
            }
            if (negate) {
                
                HashSet complement = new HashSet(props.keySet());
                complement.removeAll(names);
                names = complement;
            }
            if (!getDynamic()) {
                cachedNames = names;
            }
        } else {
            names = cachedNames;
        }
        FileNameMapper m = null;
        Mapper myMapper = getMapper();
        if (myMapper != null) {
            m = myMapper.getImplementation();
        }
        Properties properties = new Properties();
        
        for (Iterator iter = names.iterator(); iter.hasNext();) {
            String name = (String) iter.next();
            String value = (String) props.get(name);
            if (value != null) {
                
                
                if (m != null) {
                    
                    String[] newname = m.mapFileName(name);
                    if (newname != null) {
                        name = newname[0];
                    }
                }
                properties.setProperty(name, value);
            }
        }
        return properties;
    }

    
    private void addPropertyNames(Set names, Hashtable properties) {
        
        for (Enumeration e = ptyRefs.elements(); e.hasMoreElements();) {
            PropertyRef r = (PropertyRef) e.nextElement();
            if (r.name != null) {
                if (properties.get(r.name) != null) {
                    names.add(r.name);
                }
            } else if (r.prefix != null) {
                for (Enumeration p = properties.keys(); p.hasMoreElements();) {
                    String name = (String) p.nextElement();
                    if (name.startsWith(r.prefix)) {
                        names.add(name);
                    }
                }
            } else if (r.regex != null) {
                RegexpMatcherFactory matchMaker = new RegexpMatcherFactory();
                RegexpMatcher matcher = matchMaker.newRegexpMatcher();
                matcher.setPattern(r.regex);
                for (Enumeration p = properties.keys(); p.hasMoreElements();) {
                    String name = (String) p.nextElement();
                    if (matcher.matches(name)) {
                        names.add(name);
                    }
                }
            } else if (r.builtin != null) {

                if (r.builtin.equals(BuiltinPropertySetName.ALL)) {
                    names.addAll(properties.keySet());
                } else if (r.builtin.equals(BuiltinPropertySetName.SYSTEM)) {
                    names.addAll(System.getProperties().keySet());
                } else if (r.builtin.equals(BuiltinPropertySetName
                                              .COMMANDLINE)) {
                    names.addAll(getProject().getUserProperties().keySet());
                } else {
                    throw new BuildException(""Impossible: Invalid builtin ""
                                             + ""attribute!"");
                }
            } else {
                throw new BuildException(""Impossible: Invalid PropertyRef!"");
            }
        }
    }

    
    protected PropertySet getRef() {
        return (PropertySet) getCheckedRef(PropertySet.class, ""propertyset"");
    }

    
    public final void setRefid(Reference r) {
        if (!noAttributeSet) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    protected final void assertNotReference() {
        if (isReference()) {
            throw tooManyAttributes();
        }
        noAttributeSet = false;
    }

    
    private boolean noAttributeSet = true;

    
    public static class BuiltinPropertySetName extends EnumeratedAttribute {
        static final String ALL = ""all"";
        static final String SYSTEM = ""system"";
        static final String COMMANDLINE = ""commandline"";
        
        public String[] getValues() {
            return new String[] {ALL, SYSTEM, COMMANDLINE};
        }
    }

    
    public String toString() {
        StringBuffer b = new StringBuffer();
        TreeMap sorted = new TreeMap(getProperties());
        for (Iterator i = sorted.entrySet().iterator(); i.hasNext();) {
            Map.Entry e = (Map.Entry) i.next();
            if (b.length() != 0) {
                b.append("", "");
            }
            b.append(e.getKey().toString());
            b.append(""="");
            b.append(e.getValue().toString());
        }
        return b.toString();
    }

    
    public Iterator iterator() {
        final Enumeration e = getProperties().propertyNames();
        return new Iterator() {
            public boolean hasNext() {
                return e.hasMoreElements();
            }
            public Object next() {
                return new PropertyResource(getProject(), (String) e.nextElement());
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    
    public int size() {
        return isReference() ? getRef().size() : getProperties().size();
    }

    
    public boolean isFilesystemOnly() {
        return isReference() && getRef().isFilesystemOnly();
    }

}
"
org.apache.tools.ant.taskdefs.optional.j2ee.ServerDeploy,9,3,0,7,20,12,5,6,9,0.75,75,1.0,0,0.822222222,0.259259259,0,0,7.0,1,0.8889,0,"

package org.apache.tools.ant.taskdefs.optional.j2ee;

import java.io.File;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;


public class ServerDeploy extends Task {
    
    private String action;

    
    private File source;

    
    private Vector vendorTools = new Vector();

    
    
    
    
    

    
    public void addGeneric(GenericHotDeploymentTool tool) {
        tool.setTask(this);
        vendorTools.addElement(tool);
    }

    
    public void addWeblogic(WebLogicHotDeploymentTool tool) {
        tool.setTask(this);
        vendorTools.addElement(tool);
    }

    
    public void addJonas(JonasHotDeploymentTool tool) {
        tool.setTask(this);
        vendorTools.addElement(tool);
    }


    
    
    
    
    

    
    public void execute() throws BuildException {
        for (Enumeration e = vendorTools.elements();
             e.hasMoreElements();) {
            HotDeploymentTool tool = (HotDeploymentTool) e.nextElement();
            tool.validateAttributes();
            tool.deploy();
        }
    }

    
    
    
    
    

    
    public String getAction() {
        return action;
    }

    
    public void setAction(String action) {
        this.action = action;
    }

    
    public File getSource() {
        return source;
    }

    
    public void setSource(File source) {
        this.source = source;
    }
}

"
org.apache.tools.ant.util.CollectionUtils,7,1,0,5,19,21,2,3,7,2.0,105,0.0,0,0.0,0.2,1,1,14.0,8,2.4286,4,"
package org.apache.tools.ant.util;

import java.util.Vector;
import java.util.Iterator;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.NoSuchElementException;




public class CollectionUtils {

    
    public static boolean equals(Vector v1, Vector v2) {
        if (v1 == v2) {
            return true;
        }

        if (v1 == null || v2 == null) {
            return false;
        }

        return v1.equals(v2);
    }

    
    public static boolean equals(Dictionary d1, Dictionary d2) {
        if (d1 == d2) {
            return true;
        }

        if (d1 == null || d2 == null) {
            return false;
        }

        if (d1.size() != d2.size()) {
            return false;
        }

        Enumeration e1 = d1.keys();
        while (e1.hasMoreElements()) {
            Object key = e1.nextElement();
            Object value1 = d1.get(key);
            Object value2 = d2.get(key);
            if (value2 == null || !value1.equals(value2)) {
                return false;
            }
        }

        
        

        return true;
    }

    
    public static void putAll(Dictionary m1, Dictionary m2) {
        for (Enumeration it = m2.keys(); it.hasMoreElements();) {
            Object key = it.nextElement();
            m1.put(key, m2.get(key));
        }
    }

    
    public static final class EmptyEnumeration implements Enumeration {
        
        public EmptyEnumeration() {
        }

        
        public boolean hasMoreElements() {
            return false;
        }

        
        public Object nextElement() throws NoSuchElementException {
            throw new NoSuchElementException();
        }
    }

    
    public static Enumeration append(Enumeration e1, Enumeration e2) {
        return new CompoundEnumeration(e1, e2);
    }

    
    public static Enumeration asEnumeration(final Iterator iter) {
        return new Enumeration() {
            public boolean hasMoreElements() {
                return iter.hasNext();
            }
            public Object nextElement() {
                return iter.next();
            }
        };
    }

    
    public static Iterator asIterator(final Enumeration e) {
        return new Iterator() {
            public boolean hasNext() {
                return e.hasMoreElements();
            }
            public Object next() {
                return e.nextElement();
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    private static final class CompoundEnumeration implements Enumeration {

        private final Enumeration e1, e2;

        public CompoundEnumeration(Enumeration e1, Enumeration e2) {
            this.e1 = e1;
            this.e2 = e2;
        }

        public boolean hasMoreElements() {
            return e1.hasMoreElements() || e2.hasMoreElements();
        }

        public Object nextElement() throws NoSuchElementException {
            if (e1.hasMoreElements()) {
                return e1.nextElement();
            } else {
                return e2.nextElement();
            }
        }

    }

}
"
org.apache.tools.ant.Project,120,1,0,365,288,6692,352,30,103,0.97547127,2384,0.594594595,5,0.0,0.090084034,0,0,18.55833333,6,1.4167,10,"

package org.apache.tools.ant;

import java.io.File;
import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import org.apache.tools.ant.input.DefaultInputHandler;
import org.apache.tools.ant.input.InputHandler;
import org.apache.tools.ant.helper.DefaultExecutor;
import org.apache.tools.ant.types.FilterSet;
import org.apache.tools.ant.types.FilterSetCollection;
import org.apache.tools.ant.types.Description;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceFactory;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.StringUtils;


public class Project implements ResourceFactory {
    private static final String LINE_SEP = System.getProperty(""line.separator"");

    
    public static final int MSG_ERR = 0;
    
    public static final int MSG_WARN = 1;
    
    public static final int MSG_INFO = 2;
    
    public static final int MSG_VERBOSE = 3;
    
    public static final int MSG_DEBUG = 4;

    
    private static final String VISITING = ""VISITING"";
    
    private static final String VISITED = ""VISITED"";

    
    public static final String JAVA_1_0 = JavaEnvUtils.JAVA_1_0;
    
    public static final String JAVA_1_1 = JavaEnvUtils.JAVA_1_1;
    
    public static final String JAVA_1_2 = JavaEnvUtils.JAVA_1_2;
    
    public static final String JAVA_1_3 = JavaEnvUtils.JAVA_1_3;
    
    public static final String JAVA_1_4 = JavaEnvUtils.JAVA_1_4;

    
    public static final String TOKEN_START = FilterSet.DEFAULT_TOKEN_START;
    
    public static final String TOKEN_END = FilterSet.DEFAULT_TOKEN_END;

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private String name;
    
    private String description;


    
    private Hashtable references = new AntRefTable();

    
    private HashMap idReferences = new HashMap();

    
    private Project parentIdProject = null;

    
    private String defaultTarget;

    
    private Hashtable targets = new Hashtable();
    
    private FilterSet globalFilterSet = new FilterSet();
    {
        
        globalFilterSet.setProject(this);
    }

    
    private FilterSetCollection globalFilters
        = new FilterSetCollection(globalFilterSet);

    
    private File baseDir;

    
    private Vector listeners = new Vector();

    
    private ClassLoader coreLoader = null;

    
    private Map threadTasks = Collections.synchronizedMap(new WeakHashMap());

    
    private Map threadGroupTasks
        = Collections.synchronizedMap(new WeakHashMap());

    
    private InputHandler inputHandler = null;

    
    private InputStream defaultInputStream = null;

    
    private boolean keepGoingMode = false;

    
    private boolean loggingMessage = false;

    
    public void setInputHandler(InputHandler handler) {
        inputHandler = handler;
    }

    
    public void setDefaultInputStream(InputStream defaultInputStream) {
        this.defaultInputStream = defaultInputStream;
    }

    
    public InputStream getDefaultInputStream() {
        return defaultInputStream;
    }

    
    public InputHandler getInputHandler() {
        return inputHandler;
    }

    
    public Project() {
        inputHandler = new DefaultInputHandler();
    }

    
    public Project createSubProject() {
        Project subProject = null;
        try {
            subProject = (Project) (getClass().newInstance());
        } catch (Exception e) {
            subProject = new Project();
        }
        initSubProject(subProject);
        return subProject;
    }

    
    public void initSubProject(Project subProject) {
        ComponentHelper.getComponentHelper(subProject)
            .initSubProject(ComponentHelper.getComponentHelper(this));
        subProject.setDefaultInputStream(getDefaultInputStream());
        subProject.setKeepGoingMode(this.isKeepGoingMode());
        subProject.setExecutor(getExecutor().getSubProjectExecutor());
    }

    
    public void init() throws BuildException {
        initProperties();

        ComponentHelper.getComponentHelper(this).initDefaultDefinitions();
    }

    
    public void initProperties() throws BuildException {
        setJavaVersionProperty();
        setSystemProperties();
        setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());
        setAntLib();
    }

    private void setAntLib() {
        File antlib = org.apache.tools.ant.launch.Locator.getClassSource(
            Project.class);
        if (antlib != null) {
            setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());
        }
    }
    
    public AntClassLoader createClassLoader(Path path) {
        return new AntClassLoader(
            getClass().getClassLoader(), this, path);
    }

    
    public AntClassLoader createClassLoader(
        ClassLoader parent, Path path) {
        return new AntClassLoader(parent, this, path);
    }

    
    public void setCoreLoader(ClassLoader coreLoader) {
        this.coreLoader = coreLoader;
    }

    
    public ClassLoader getCoreLoader() {
        return coreLoader;
    }

    
    public synchronized void addBuildListener(BuildListener listener) {
        
        if (listeners.contains(listener)) {
            return;
        }
        
        
        Vector newListeners = getBuildListeners();
        newListeners.addElement(listener);
        listeners = newListeners;
    }

    
    public synchronized void removeBuildListener(BuildListener listener) {
        
        
        Vector newListeners = getBuildListeners();
        newListeners.removeElement(listener);
        listeners = newListeners;
    }

    
    public Vector getBuildListeners() {
        return (Vector) listeners.clone();
    }

    

    public void log(String message) {
        log(message, MSG_INFO);
    }

    
    public void log(String message, int msgLevel) {
        log(message, null, msgLevel);
    }

    
    public void log(String message, Throwable throwable, int msgLevel) {
        fireMessageLogged(this, message, throwable, msgLevel);
    }

    
    public void log(Task task, String message, int msgLevel) {
        fireMessageLogged(task, message, null, msgLevel);
    }

    
    public void log(Task task, String message, Throwable throwable, int msgLevel) {
        fireMessageLogged(task, message, throwable, msgLevel);
    }

    
    public void log(Target target, String message, int msgLevel) {
        log(target, message, null, msgLevel);
    }

    
    public void log(Target target, String message, Throwable throwable,
            int msgLevel) {
        fireMessageLogged(target, message, throwable, msgLevel);
    }

    
    public FilterSet getGlobalFilterSet() {
        return globalFilterSet;
    }

    
    public void setProperty(String name, String value) {
        PropertyHelper.getPropertyHelper(this).
                setProperty(null, name, value, true);
    }

    
    public void setNewProperty(String name, String value) {
        PropertyHelper.getPropertyHelper(this).setNewProperty(null, name,
                                                              value);
    }

    
    public void setUserProperty(String name, String value) {
        PropertyHelper.getPropertyHelper(this).setUserProperty(null, name,
                                                               value);
    }

    
    public void setInheritedProperty(String name, String value) {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        ph.setInheritedProperty(null, name, value);
    }

    
    private void setPropertyInternal(String name, String value) {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        ph.setProperty(null, name, value, false);
    }

    
    public String getProperty(String propertyName) {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        return (String) ph.getProperty(null, propertyName);
    }

    
    public String replaceProperties(String value)
        throws BuildException {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        return ph.replaceProperties(null, value, null);
    }

    
     public String getUserProperty(String propertyName) {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        return (String) ph.getUserProperty(null, propertyName);
    }

    
    public Hashtable getProperties() {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        return ph.getProperties();
    }

    
    public Hashtable getUserProperties() {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        return ph.getUserProperties();
    }

    
    public void copyUserProperties(Project other) {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        ph.copyUserProperties(other);
    }

    
    public void copyInheritedProperties(Project other) {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
        ph.copyInheritedProperties(other);
    }

    
    public void setDefaultTarget(String defaultTarget) {
        this.defaultTarget = defaultTarget;
    }

    
    public String getDefaultTarget() {
        return defaultTarget;
    }

    
    public void setDefault(String defaultTarget) {
        this.defaultTarget = defaultTarget;
    }

    
    public void setName(String name) {
        setUserProperty(""ant.project.name"",  name);
        this.name = name;
    }

    
    public String getName() {
        return name;
    }

    
    public void setDescription(String description) {
        this.description = description;
    }

    
    public String getDescription() {
        if (description == null) {
            description = Description.getDescription(this);
        }
        return description;
    }

    
    public void addFilter(String token, String value) {
        if (token == null) {
            return;
        }
        globalFilterSet.addFilter(new FilterSet.Filter(token, value));
    }

    
    public Hashtable getFilters() {
        
        return globalFilterSet.getFilterHash();
    }

    
    public void setBasedir(String baseD) throws BuildException {
        setBaseDir(new File(baseD));
    }

    
    public void setBaseDir(File baseDir) throws BuildException {
        baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());
        if (!baseDir.exists()) {
            throw new BuildException(""Basedir "" + baseDir.getAbsolutePath()
                + "" does not exist"");
        }
        if (!baseDir.isDirectory()) {
            throw new BuildException(""Basedir "" + baseDir.getAbsolutePath()
                + "" is not a directory"");
        }
        this.baseDir = baseDir;
        setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());
        String msg = ""Project base dir set to: "" + this.baseDir;
         log(msg, MSG_VERBOSE);
    }

    
    public File getBaseDir() {
        if (baseDir == null) {
            try {
                setBasedir(""."");
            } catch (BuildException ex) {
                ex.printStackTrace();
            }
        }
        return baseDir;
    }

    
    public void setKeepGoingMode(boolean keepGoingMode) {
        this.keepGoingMode = keepGoingMode;
    }

    
    public boolean isKeepGoingMode() {
        return this.keepGoingMode;
    }

    
    public static String getJavaVersion() {
        return JavaEnvUtils.getJavaVersion();
    }

    
    public void setJavaVersionProperty() throws BuildException {
        String javaVersion = JavaEnvUtils.getJavaVersion();
        setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);

        
        if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_0)
                || JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1))  {
            throw new BuildException(""Ant cannot work on Java 1.0 / 1.1"");
        }
        log(""Detected Java version: "" + javaVersion + "" in: ""
            + System.getProperty(""java.home""), MSG_VERBOSE);

        log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
    }

    
    public void setSystemProperties() {
        Properties systemP = System.getProperties();
        Enumeration e = systemP.propertyNames();
        while (e.hasMoreElements()) {
            String propertyName = (String) e.nextElement();
            String value = systemP.getProperty(propertyName);
            this.setPropertyInternal(propertyName, value);
        }
    }

    
    public void addTaskDefinition(String taskName, Class taskClass)
         throws BuildException {
        ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName,
                taskClass);
    }

    
    public void checkTaskClass(final Class taskClass) throws BuildException {
        ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);

        if (!Modifier.isPublic(taskClass.getModifiers())) {
            final String message = taskClass + "" is not public"";
            log(message, Project.MSG_ERR);
            throw new BuildException(message);
        }
        if (Modifier.isAbstract(taskClass.getModifiers())) {
            final String message = taskClass + "" is abstract"";
            log(message, Project.MSG_ERR);
            throw new BuildException(message);
        }
        try {
            taskClass.getConstructor((Class[]) null);
            
            
        } catch (NoSuchMethodException e) {
            final String message = ""No public no-arg constructor in ""
                + taskClass;
            log(message, Project.MSG_ERR);
            throw new BuildException(message);
        } catch (LinkageError e) {
            String message = ""Could not load "" + taskClass + "": "" + e;
            log(message, Project.MSG_ERR);
            throw new BuildException(message, e);
        }
        if (!Task.class.isAssignableFrom(taskClass)) {
            TaskAdapter.checkTaskClass(taskClass, this);
        }
    }

    
    public Hashtable getTaskDefinitions() {
        return ComponentHelper.getComponentHelper(this).getTaskDefinitions();
    }

    
    public void addDataTypeDefinition(String typeName, Class typeClass) {
        ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName,
                typeClass);
    }

    
    public Hashtable getDataTypeDefinitions() {
        return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();
    }

    
    public void addTarget(Target target) throws BuildException {
        addTarget(target.getName(), target);
    }

    
     public void addTarget(String targetName, Target target)
         throws BuildException {
         if (targets.get(targetName) != null) {
             throw new BuildException(""Duplicate target: `"" + targetName + ""'"");
         }
         addOrReplaceTarget(targetName, target);
     }

    
    public void addOrReplaceTarget(Target target) {
        addOrReplaceTarget(target.getName(), target);
    }

    
    public void addOrReplaceTarget(String targetName, Target target) {
        String msg = "" +Target: "" + targetName;
        log(msg, MSG_DEBUG);
        target.setProject(this);
        targets.put(targetName, target);
    }

    
    public Hashtable getTargets() {
        return targets;
    }

    
    public Task createTask(String taskType) throws BuildException {
        return ComponentHelper.getComponentHelper(this).createTask(taskType);
    }

    
    public Object createDataType(String typeName) throws BuildException {
        return ComponentHelper.getComponentHelper(this).createDataType(typeName);
    }

    
    public void setExecutor(Executor e) {
        addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);
    }

    
    public Executor getExecutor() {
        Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);
        if (o == null) {
            String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);
            if (classname == null) {
                classname = DefaultExecutor.class.getName();
            }
            log(""Attempting to create object of type "" + classname, MSG_DEBUG);
            try {
                o = Class.forName(classname, true, coreLoader).newInstance();
            } catch (ClassNotFoundException seaEnEfEx) {
                
                try {
                    o = Class.forName(classname).newInstance();
                } catch (Exception ex) {
                    log(ex.toString(), MSG_ERR);
                }
            } catch (Exception ex) {
                log(ex.toString(), MSG_ERR);
            }
            if (o == null) {
                throw new BuildException(
                    ""Unable to obtain a Target Executor instance."");
            }
            setExecutor((Executor) o);
        }
        return (Executor) o;
    }

    
    public void executeTargets(Vector names) throws BuildException {
        getExecutor().executeTargets(this,
            (String[]) (names.toArray(new String[names.size()])));
    }

    
    public void demuxOutput(String output, boolean isWarning) {
        Task task = getThreadTask(Thread.currentThread());
        if (task == null) {
            log(output, isWarning ? MSG_WARN : MSG_INFO);
        } else {
            if (isWarning) {
                task.handleErrorOutput(output);
            } else {
                task.handleOutput(output);
            }
        }
    }

    
    public int defaultInput(byte[] buffer, int offset, int length)
        throws IOException {
        if (defaultInputStream != null) {
            System.out.flush();
            return defaultInputStream.read(buffer, offset, length);
        } else {
            throw new EOFException(""No input provided for project"");
        }
    }

    
    public int demuxInput(byte[] buffer, int offset, int length)
        throws IOException {
        Task task = getThreadTask(Thread.currentThread());
        if (task == null) {
            return defaultInput(buffer, offset, length);
        } else {
            return task.handleInput(buffer, offset, length);
        }
    }

    
    public void demuxFlush(String output, boolean isError) {
        Task task = getThreadTask(Thread.currentThread());
        if (task == null) {
            fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);
        } else {
            if (isError) {
                task.handleErrorFlush(output);
            } else {
                task.handleFlush(output);
            }
        }
    }

    
    public void executeTarget(String targetName) throws BuildException {

        
        

        if (targetName == null) {
            String msg = ""No target specified"";
            throw new BuildException(msg);
        }

        
        
        
        
        executeSortedTargets(topoSort(targetName, targets, false));
    }

    
    public void executeSortedTargets(Vector sortedTargets)
        throws BuildException {
        Set succeededTargets = new HashSet();
        BuildException buildException = null; 
        for (Enumeration iter = sortedTargets.elements();
             iter.hasMoreElements();) {
            Target curtarget = (Target) iter.nextElement();
            boolean canExecute = true;
            for (Enumeration depIter = curtarget.getDependencies();
                 depIter.hasMoreElements();) {
                String dependencyName = ((String) depIter.nextElement());
                if (!succeededTargets.contains(dependencyName)) {
                    canExecute = false;
                    log(curtarget,
                        ""Cannot execute '"" + curtarget.getName() + ""' - '""
                        + dependencyName + ""' failed or was not executed."",
                        MSG_ERR);
                    break;
                }
            }
            if (canExecute) {
                Throwable thrownException = null;
                try {
                    curtarget.performTasks();
                    succeededTargets.add(curtarget.getName());
                } catch (RuntimeException ex) {
                    if (!(keepGoingMode)) {
                        throw ex; 
                    }
                    thrownException = ex;
                } catch (Throwable ex) {
                    if (!(keepGoingMode)) {
                        throw new BuildException(ex);
                    }
                    thrownException = ex;
                }
                if (thrownException != null) {
                    if (thrownException instanceof BuildException) {
                        log(curtarget,
                            ""Target '"" + curtarget.getName()
                            + ""' failed with message '""
                            + thrownException.getMessage() + ""'."", MSG_ERR);
                        
                        if (buildException == null) {
                            buildException = (BuildException) thrownException;
                        }
                    } else {
                        log(curtarget,
                            ""Target '"" + curtarget.getName()
                            + ""' failed with message '""
                            + thrownException.getMessage() + ""'."", MSG_ERR);
                        thrownException.printStackTrace(System.err);
                        if (buildException == null) {
                            buildException =
                                new BuildException(thrownException);
                        }
                    }
                }
            }
        }
        if (buildException != null) {
            throw buildException;
        }
    }

    
    public File resolveFile(String fileName, File rootDir) {
        return FILE_UTILS.resolveFile(rootDir, fileName);
    }

    
    public File resolveFile(String fileName) {
        return FILE_UTILS.resolveFile(baseDir, fileName);
    }

    
    public static String translatePath(String toProcess) {
        return FileUtils.translatePath(toProcess);
    }

    
    public void copyFile(String sourceFile, String destFile)
          throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile);
    }

    
    public void copyFile(String sourceFile, String destFile, boolean filtering)
        throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile,
            filtering ? globalFilters : null);
    }

    
    public void copyFile(String sourceFile, String destFile, boolean filtering,
                         boolean overwrite) throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile,
            filtering ? globalFilters : null, overwrite);
    }

    
    public void copyFile(String sourceFile, String destFile, boolean filtering,
                         boolean overwrite, boolean preserveLastModified)
        throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile,
            filtering ? globalFilters : null, overwrite, preserveLastModified);
    }

    
    public void copyFile(File sourceFile, File destFile) throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile);
    }

    
    public void copyFile(File sourceFile, File destFile, boolean filtering)
        throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile,
            filtering ? globalFilters : null);
    }

    
    public void copyFile(File sourceFile, File destFile, boolean filtering,
                         boolean overwrite) throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile,
            filtering ? globalFilters : null, overwrite);
    }

    
    public void copyFile(File sourceFile, File destFile, boolean filtering,
                         boolean overwrite, boolean preserveLastModified)
        throws IOException {
        FILE_UTILS.copyFile(sourceFile, destFile,
            filtering ? globalFilters : null, overwrite, preserveLastModified);
    }

    
    public void setFileLastModified(File file, long time)
         throws BuildException {
        FILE_UTILS.setFileLastModified(file, time);
        log(""Setting modification time for "" + file, MSG_VERBOSE);
    }

    
    public static boolean toBoolean(String s) {
        return (""on"".equalsIgnoreCase(s)
                || ""true"".equalsIgnoreCase(s)
                || ""yes"".equalsIgnoreCase(s));
    }

    
    public final Vector topoSort(String root, Hashtable targetTable)
        throws BuildException {
        return topoSort(new String[] {root}, targetTable, true);
    }

    
    public final Vector topoSort(String root, Hashtable targetTable,
                                 boolean returnAll) throws BuildException {
        return topoSort(new String[] {root}, targetTable, returnAll);
    }

    
    public final Vector topoSort(String[] root, Hashtable targetTable,
                                 boolean returnAll) throws BuildException {
        Vector ret = new Vector();
        Hashtable state = new Hashtable();
        Stack visiting = new Stack();

        
        
        
        
        
        
        

        for (int i = 0; i < root.length; i++) {
            String st = (String) (state.get(root[i]));
            if (st == null) {
                tsort(root[i], targetTable, state, visiting, ret);
            } else if (st == VISITING) {
                throw new RuntimeException(""Unexpected node in visiting state: ""
                    + root[i]);
            }
        }
        StringBuffer buf = new StringBuffer(""Build sequence for target(s)"");

        for (int j = 0; j < root.length; j++) {
            buf.append((j == 0) ? "" `"" : "", `"").append(root[j]).append('\'');
        }
        buf.append("" is "" + ret);
        log(buf.toString(), MSG_VERBOSE);

        Vector complete = (returnAll) ? ret : new Vector(ret);
        for (Enumeration en = targetTable.keys(); en.hasMoreElements();) {
            String curTarget = (String) en.nextElement();
            String st = (String) state.get(curTarget);
            if (st == null) {
                tsort(curTarget, targetTable, state, visiting, complete);
            } else if (st == VISITING) {
                throw new RuntimeException(""Unexpected node in visiting state: ""
                    + curTarget);
            }
        }
        log(""Complete build sequence is "" + complete, MSG_VERBOSE);
        return ret;
    }

    
    private void tsort(String root, Hashtable targetTable,
                             Hashtable state, Stack visiting,
                             Vector ret)
        throws BuildException {
        state.put(root, VISITING);
        visiting.push(root);

        Target target = (Target) targetTable.get(root);

        
        if (target == null) {
            StringBuffer sb = new StringBuffer(""Target \"""");
            sb.append(root);
            sb.append(""\"" does not exist in the project \"""");
            sb.append(name);
            sb.append(""\"". "");
            visiting.pop();
            if (!visiting.empty()) {
                String parent = (String) visiting.peek();
                sb.append(""It is used from target \"""");
                sb.append(parent);
                sb.append(""\""."");
            }
            throw new BuildException(new String(sb));
        }
        for (Enumeration en = target.getDependencies(); en.hasMoreElements();) {
            String cur = (String) en.nextElement();
            String m = (String) state.get(cur);
            if (m == null) {
                
                tsort(cur, targetTable, state, visiting, ret);
            } else if (m == VISITING) {
                
                throw makeCircularException(cur, visiting);
            }
        }
        String p = (String) visiting.pop();
        if (root != p) {
            throw new RuntimeException(""Unexpected internal error: expected to ""
                + ""pop "" + root + "" but got "" + p);
        }
        state.put(root, VISITED);
        ret.addElement(target);
    }

    
    private static BuildException makeCircularException(String end, Stack stk) {
        StringBuffer sb = new StringBuffer(""Circular dependency: "");
        sb.append(end);
        String c;
        do {
            c = (String) stk.pop();
            sb.append("" <- "");
            sb.append(c);
        } while (!c.equals(end));
        return new BuildException(new String(sb));
    }

    
    public void inheritIDReferences(Project parent) {
        parentIdProject = parent;
    }

    
    private Object resolveIdReference(String key, Project callerProject) {
        UnknownElement origUE = (UnknownElement) idReferences.get(key);
        if (origUE == null) {
            return parentIdProject == null
                ? null
                : parentIdProject.resolveIdReference(key, callerProject);
        }
        callerProject.log(
            ""Warning: Reference "" + key + "" has not been set at runtime,""
            + "" but was found during"" + LINE_SEP
            + ""build file parsing, attempting to resolve.""
            + "" Future versions of Ant may support"" + LINE_SEP
            + "" referencing ids defined in non-executed targets."", MSG_WARN);
        UnknownElement copyUE = origUE.copy(callerProject);
        copyUE.maybeConfigure();
        return copyUE.getRealThing();
    }

    
    public void addIdReference(String id, Object value) {
        idReferences.put(id, value);
    }

    
    public void addReference(String referenceName, Object value) {
        synchronized (references) {
            Object old = ((AntRefTable) references).getReal(referenceName);
            if (old == value) {
                
                return;
            }
            if (old != null && !(old instanceof UnknownElement)) {
                log(""Overriding previous definition of reference to "" + referenceName,
                    MSG_VERBOSE);
            }
            log(""Adding reference: "" + referenceName, MSG_DEBUG);
            references.put(referenceName, value);
        }
    }

    
    public Hashtable getReferences() {
        return references;
    }

    
    public Object getReference(String key) {
        Object ret = references.get(key);
        if (ret != null) {
            return ret;
        }
        
        ret = resolveIdReference(key, this);
        if (ret == null && !key.equals(MagicNames.REFID_PROPERTY_HELPER)) {
            Vector p = new Vector();
            PropertyHelper.getPropertyHelper(this).parsePropertyString(
                key, new Vector(), p);
            if (p.size() == 1) {
                log(""Unresolvable reference "" + key
                    + "" might be a misuse of property expansion syntax."",
                    MSG_WARN);
            }
        }
        return ret;
    }

    
    public String getElementName(Object element) {
        return ComponentHelper.getComponentHelper(this).getElementName(element);
    }

    
    public void fireBuildStarted() {
        BuildEvent event = new BuildEvent(this);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            BuildListener listener = (BuildListener) iter.next();
            listener.buildStarted(event);
        }
    }

    
    public void fireBuildFinished(Throwable exception) {
        BuildEvent event = new BuildEvent(this);
        event.setException(exception);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            BuildListener listener = (BuildListener) iter.next();
            listener.buildFinished(event);
        }
        
        IntrospectionHelper.clearCache();
    }

    
    public void fireSubBuildStarted() {
        BuildEvent event = new BuildEvent(this);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            Object listener = iter.next();
            if (listener instanceof SubBuildListener) {
                ((SubBuildListener) listener).subBuildStarted(event);
            }
        }
    }

    
    public void fireSubBuildFinished(Throwable exception) {
        BuildEvent event = new BuildEvent(this);
        event.setException(exception);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            Object listener = iter.next();
            if (listener instanceof SubBuildListener) {
                ((SubBuildListener) listener).subBuildFinished(event);
            }
        }
    }

    
    protected void fireTargetStarted(Target target) {
        BuildEvent event = new BuildEvent(target);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            BuildListener listener = (BuildListener) iter.next();
            listener.targetStarted(event);
        }
    }

    
    protected void fireTargetFinished(Target target, Throwable exception) {
        BuildEvent event = new BuildEvent(target);
        event.setException(exception);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            BuildListener listener = (BuildListener) iter.next();
            listener.targetFinished(event);
        }
    }

    
    protected void fireTaskStarted(Task task) {
        
        registerThreadTask(Thread.currentThread(), task);
        BuildEvent event = new BuildEvent(task);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            BuildListener listener = (BuildListener) iter.next();
            listener.taskStarted(event);
        }
    }

    
    protected void fireTaskFinished(Task task, Throwable exception) {
        registerThreadTask(Thread.currentThread(), null);
        System.out.flush();
        System.err.flush();
        BuildEvent event = new BuildEvent(task);
        event.setException(exception);
        Iterator iter = listeners.iterator();
        while (iter.hasNext()) {
            BuildListener listener = (BuildListener) iter.next();
            listener.taskFinished(event);
        }
    }

    
    private void fireMessageLoggedEvent(BuildEvent event, String message,
                                        int priority) {

        if (message.endsWith(StringUtils.LINE_SEP)) {
            int endIndex = message.length() - StringUtils.LINE_SEP.length();
            event.setMessage(message.substring(0, endIndex), priority);
        } else {
            event.setMessage(message, priority);
        }
        synchronized (this) {
            if (loggingMessage) {
                
                return;
            }
            try {
                loggingMessage = true;
                Iterator iter = listeners.iterator();
                while (iter.hasNext()) {
                    BuildListener listener = (BuildListener) iter.next();
                    listener.messageLogged(event);
                }
            } finally {
                loggingMessage = false;
            }
        }
    }

    
    protected void fireMessageLogged(Project project, String message,
                                     int priority) {
        fireMessageLogged(project, message, null, priority);
    }

    
    protected void fireMessageLogged(Project project, String message,
            Throwable throwable, int priority) {
        BuildEvent event = new BuildEvent(project);
        event.setException(throwable);
        fireMessageLoggedEvent(event, message, priority);
    }

    
    protected void fireMessageLogged(Target target, String message,
                                     int priority) {
        fireMessageLogged(target, message, null, priority);
    }

    
    protected void fireMessageLogged(Target target, String message,
            Throwable throwable, int priority) {
        BuildEvent event = new BuildEvent(target);
        event.setException(throwable);
        fireMessageLoggedEvent(event, message, priority);
    }

    
    protected void fireMessageLogged(Task task, String message, int priority) {
        fireMessageLogged(task, message, null, priority);
    }

    
    protected void fireMessageLogged(Task task, String message,
            Throwable throwable, int priority) {
        BuildEvent event = new BuildEvent(task);
        event.setException(throwable);
        fireMessageLoggedEvent(event, message, priority);
    }

    
    public synchronized void registerThreadTask(Thread thread, Task task) {
        if (task != null) {
            threadTasks.put(thread, task);
            threadGroupTasks.put(thread.getThreadGroup(), task);
        } else {
            threadTasks.remove(thread);
            threadGroupTasks.remove(thread.getThreadGroup());
        }
    }

    
    public Task getThreadTask(Thread thread) {
        Task task = (Task) threadTasks.get(thread);
        if (task == null) {
            ThreadGroup group = thread.getThreadGroup();
            while (task == null && group != null) {
                task = (Task) threadGroupTasks.get(group);
                group = group.getParent();
            }
        }
        return task;
    }


    
    
    private static class AntRefTable extends Hashtable {

        AntRefTable() {
            super();
        }

        
        private Object getReal(Object key) {
            return super.get(key);
        }

        
        public Object get(Object key) {
            
            Object o = getReal(key);
            if (o instanceof UnknownElement) {
                
                UnknownElement ue = (UnknownElement) o;
                ue.maybeConfigure();
                o = ue.getRealThing();
            }
            return o;
        }
    }

    
    public final void setProjectReference(final Object obj) {
        if (obj instanceof ProjectComponent) {
            ((ProjectComponent) obj).setProject(this);
            return;
        }
        try {
            Method method =
                obj.getClass().getMethod(
                    ""setProject"", new Class[] {Project.class});
            if (method != null) {
                method.invoke(obj, new Object[] {this});
            }
        } catch (Throwable e) {
            
            
            
        }
    }

    
    public Resource getResource(String name) {
        return new FileResource(getBaseDir(), name);
    }
}
"
org.apache.tools.ant.taskdefs.optional.jsp.JspNameMangler,7,1,0,2,24,19,1,1,3,0.666666667,373,0.0,0,0.0,0.416666667,0,0,52.14285714,6,2.0,0,"
package org.apache.tools.ant.taskdefs.optional.jsp;
import java.io.File;


public class JspNameMangler implements JspMangler {

    

    
    public static final String[] keywords = {
            ""assert"",
            ""abstract"", ""boolean"", ""break"", ""byte"",
            ""case"", ""catch"", ""char"", ""class"",
            ""const"", ""continue"", ""default"", ""do"",
            ""double"", ""else"", ""extends"", ""final"",
            ""finally"", ""float"", ""for"", ""goto"",
            ""if"", ""implements"", ""import"",
            ""instanceof"", ""int"", ""interface"",
            ""long"", ""native"", ""new"", ""package"",
            ""private"", ""protected"", ""public"",
            ""return"", ""short"", ""static"", ""super"",
            ""switch"", ""synchronized"", ""this"",
            ""throw"", ""throws"", ""transient"",
            ""try"", ""void"", ""volatile"", ""while""
            };

    

    
    public String mapJspToJavaName(File jspFile) {
        return mapJspToBaseName(jspFile) + "".java"";
    }


    
    private String mapJspToBaseName(File jspFile) {
        String className;
        className = stripExtension(jspFile);

        
        
        for (int i = 0; i < keywords.length; ++i) {
            if (className.equals(keywords[i])) {
                className += ""%"";
                break;
            }
        }

        
        StringBuffer modifiedClassName = new StringBuffer(className.length());
        
        char firstChar = className.charAt(0);
        if (Character.isJavaIdentifierStart(firstChar)) {
            modifiedClassName.append(firstChar);
        } else {
            modifiedClassName.append(mangleChar(firstChar));
        }
        
        for (int i = 1; i < className.length(); i++) {
            char subChar = className.charAt(i);
            if (Character.isJavaIdentifierPart(subChar)) {
                modifiedClassName.append(subChar);
            } else {
                modifiedClassName.append(mangleChar(subChar));
            }
        }
        return modifiedClassName.toString();
    }


    
    private String stripExtension(File jspFile) {
        String className;
        String filename = jspFile.getName();
        if (filename.endsWith("".jsp"")) {
            className = filename.substring(0, filename.length() - 4);
        } else {
            className = filename;
        }
        return className;
    }


    
    private static String mangleChar(char ch) {

        if (ch == File.separatorChar) {
            ch = '/';
        }
        String s = Integer.toHexString(ch);
        int nzeros = 5 - s.length();
        char[] result = new char[6];
        result[0] = '_';
        for (int i = 1; i <= nzeros; ++i) {
            result[i] = '0';
        }
        int resultIndex = 0;
        for (int i = nzeros + 1; i < 6; ++i) {
            result[i] = s.charAt(resultIndex++);
        }
        return new String(result);
    }

    
    public String mapPath(String path) {
        return null;
    }
}

"
org.apache.tools.ant.taskdefs.Replace,30,4,0,10,100,271,4,10,16,0.891246684,788,1.0,3,0.735849057,0.216748768,2,2,24.83333333,3,1.1667,3,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;


public class Replace extends MatchingTask {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private File src = null;
    private NestedString token = null;
    private NestedString value = new NestedString();

    private File propertyFile = null;
    private File replaceFilterFile = null;
    private Properties properties = null;
    private Vector replacefilters = new Vector();

    private File dir = null;

    private int fileCount;
    private int replaceCount;
    private boolean summary = false;

    
    private String encoding = null;

    
    public class NestedString {

        private StringBuffer buf = new StringBuffer();

        
        public void addText(String val) {
            buf.append(val);
        }

        
        public String getText() {
            return buf.toString();
        }
    }

    
    public class Replacefilter {
        private String token;
        private String value;
        private String replaceValue;
        private String property;

        private StringBuffer inputBuffer;
        private StringBuffer outputBuffer = new StringBuffer();

        
        public void validate() throws BuildException {
            
            if (token == null) {
                String message = ""token is a mandatory attribute ""
                    + ""of replacefilter."";
                throw new BuildException(message);
            }

            if ("""".equals(token)) {
                String message = ""The token attribute must not be an empty ""
                    + ""string."";
                throw new BuildException(message);
            }

            
            if ((value != null) && (property != null)) {
                String message = ""Either value or property ""
                    + ""can be specified, but a replacefilter ""
                    + ""element cannot have both."";
                throw new BuildException(message);
            }

            if ((property != null)) {
                
                if (propertyFile == null) {
                    String message = ""The replacefilter's property attribute ""
                        + ""can only be used with the replacetask's ""
                        + ""propertyFile attribute."";
                    throw new BuildException(message);
                }

                
                if (properties == null
                    || properties.getProperty(property) == null) {
                    String message = ""property \"""" + property
                        + ""\"" was not found in "" + propertyFile.getPath();
                    throw new BuildException(message);
                }
            }

            replaceValue = getReplaceValue();
        }

        
        public String getReplaceValue() {
            if (property != null) {
                return properties.getProperty(property);
            } else if (value != null) {
                return value;
            } else if (Replace.this.value != null) {
                return Replace.this.value.getText();
            } else {
                
                return """";
            }
        }

        
        public void setToken(String token) {
            this.token = token;
        }

        
        public String getToken() {
            return token;
        }

        
        public void setValue(String value) {
            this.value = value;
        }

        
        public String getValue() {
            return value;
        }

        
        public void setProperty(String property) {
            this.property = property;
        }

        
        public String getProperty() {
            return property;
        }

        
        StringBuffer getOutputBuffer() {
            return outputBuffer;
        }

        
        void setInputBuffer(StringBuffer input) {
            inputBuffer = input;
        }

        
        boolean process() {
            if (inputBuffer.length() > token.length()) {
                int pos = replace();
                pos = Math.max((inputBuffer.length() - token.length()), pos);
                outputBuffer.append(inputBuffer.substring(0, pos));
                inputBuffer.delete(0, pos);
                return true;
            }
            return false;
        }

        
        void flush() {
            replace();
            
            outputBuffer.append(inputBuffer.toString());
            inputBuffer.delete(0, inputBuffer.length());
        }

        
        private int replace() {
            int found = inputBuffer.toString().indexOf(token);
            int pos = -1;
            while (found >= 0) {
                inputBuffer.replace(found, found + token.length(),
                        replaceValue);
                pos = found + replaceValue.length();
                found = inputBuffer.toString().indexOf(token, pos);
                ++replaceCount;
            }
            return pos;
        }
    }

    
    private class FileInput {
        private StringBuffer outputBuffer;
        private Reader reader;
        private char[] buffer;
        private static final int BUFF_SIZE = 4096;

        
        FileInput(File source) throws IOException {
            outputBuffer = new StringBuffer();
            buffer = new char[BUFF_SIZE];
            if (encoding == null) {
                reader = new BufferedReader(new FileReader(source));
            } else {
                reader = new BufferedReader(new InputStreamReader(
                        new FileInputStream(source), encoding));
            }
        }

        
        StringBuffer getOutputBuffer() {
            return outputBuffer;
        }

        
        boolean readChunk() throws IOException {
            int bufferLength = 0;
            bufferLength = reader.read(buffer);
            if (bufferLength < 0) {
                return false;
            }
            outputBuffer.append(new String(buffer, 0, bufferLength));
            return true;
        }

        
        void close() throws IOException {
            reader.close();
        }

        
        void closeQuietly() {
            FileUtils.close(reader);
        }

    }

    
    private class FileOutput {
        private StringBuffer inputBuffer;
        private Writer writer;

        
        FileOutput(File out) throws IOException {
                if (encoding == null) {
                    writer = new BufferedWriter(new FileWriter(out));
                } else {
                    writer = new BufferedWriter(new OutputStreamWriter
                            (new FileOutputStream(out), encoding));
                }
        }

        
        void setInputBuffer(StringBuffer input) {
            inputBuffer = input;
        }

        
        boolean process() throws IOException {
            writer.write(inputBuffer.toString());
            inputBuffer.delete(0, inputBuffer.length());
            return false;
        }

        
        void flush() throws IOException {
            process();
            writer.flush();
        }

        
        void close() throws IOException {
            writer.close();
        }

        
        void closeQuietly() {
            FileUtils.close(writer);
        }
    }

    
    public void execute() throws BuildException {

        Vector savedFilters = (Vector) replacefilters.clone();
        Properties savedProperties =
            properties == null ? null : (Properties) properties.clone();

        if (token != null) {
            
            
            
            StringBuffer val = new StringBuffer(value.getText());
            stringReplace(val, ""\r\n"", ""\n"");
            stringReplace(val, ""\n"", StringUtils.LINE_SEP);
            StringBuffer tok = new StringBuffer(token.getText());
            stringReplace(tok, ""\r\n"", ""\n"");
            stringReplace(tok, ""\n"", StringUtils.LINE_SEP);
            Replacefilter firstFilter = createPrimaryfilter();
            firstFilter.setToken(tok.toString());
            firstFilter.setValue(val.toString());
        }

        try {
            if (replaceFilterFile != null) {
                Properties props = getProperties(replaceFilterFile);
                Enumeration e = props.keys();
                while (e.hasMoreElements()) {
                    String tok =  e.nextElement().toString();
                    Replacefilter replaceFilter = createReplacefilter();
                    replaceFilter.setToken(tok);
                    replaceFilter.setValue(props.getProperty(tok));
                }
            }

            validateAttributes();

            if (propertyFile != null) {
                properties = getProperties(propertyFile);
            }

            validateReplacefilters();
            fileCount = 0;
            replaceCount = 0;

            if (src != null) {
                processFile(src);
            }

            if (dir != null) {
                DirectoryScanner ds = super.getDirectoryScanner(dir);
                String[] srcs = ds.getIncludedFiles();

                for (int i = 0; i < srcs.length; i++) {
                    File file = new File(dir, srcs[i]);
                    processFile(file);
                }
            }

            if (summary) {
                log(""Replaced "" + replaceCount + "" occurrences in ""
                    + fileCount + "" files."", Project.MSG_INFO);
            }
        } finally {
            replacefilters = savedFilters;
            properties = savedProperties;
        } 

    }

    
    public void validateAttributes() throws BuildException {
        if (src == null && dir == null) {
            String message = ""Either the file or the dir attribute ""
                + ""must be specified"";
            throw new BuildException(message, getLocation());
        }
        if (propertyFile != null && !propertyFile.exists()) {
            String message = ""Property file "" + propertyFile.getPath()
                + "" does not exist."";
            throw new BuildException(message, getLocation());
        }
        if (token == null && replacefilters.size() == 0) {
            String message = ""Either token or a nested replacefilter ""
                + ""must be specified"";
            throw new BuildException(message, getLocation());
        }
        if (token != null && """".equals(token.getText())) {
            String message = ""The token attribute must not be an empty string."";
            throw new BuildException(message, getLocation());
        }
    }

    
    public void validateReplacefilters()
            throws BuildException {
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter element =
                (Replacefilter) replacefilters.elementAt(i);
            element.validate();
        }
    }

    
    public Properties getProperties(File propertyFile) throws BuildException {
        Properties props = new Properties();

        FileInputStream in = null;
        try {
            in = new FileInputStream(propertyFile);
            props.load(in);
        } catch (FileNotFoundException e) {
            String message = ""Property file ("" + propertyFile.getPath()
                + "") not found."";
            throw new BuildException(message);
        } catch (IOException e) {
            String message = ""Property file ("" + propertyFile.getPath()
                + "") cannot be loaded."";
            throw new BuildException(message);
        } finally {
            FileUtils.close(in);
        }

        return props;
    }

    
    private void processFile(File src) throws BuildException {
        if (!src.exists()) {
            throw new BuildException(""Replace: source file "" + src.getPath()
                                     + "" doesn't exist"", getLocation());
        }

        File temp = null;
        FileInput in = null;
        FileOutput out = null;
        try {
            in = new FileInput(src);

            temp = FILE_UTILS.createTempFile(""rep"", "".tmp"",
                    src.getParentFile());
            out = new FileOutput(temp);

            int repCountStart = replaceCount;

            logFilterChain(src.getPath());

            out.setInputBuffer(buildFilterChain(in.getOutputBuffer()));

            while (in.readChunk()) {
                if (processFilterChain()) {
                    out.process();
                }
            }

            flushFilterChain();

            out.flush();
            in.close();
            in = null;
            out.close();
            out = null;

            boolean changes = (replaceCount != repCountStart);
            if (changes) {
                FILE_UTILS.rename(temp, src);
                temp = null;
            }
        } catch (IOException ioe) {
            throw new BuildException(""IOException in "" + src + "" - ""
                    + ioe.getClass().getName() + "":""
                    + ioe.getMessage(), ioe, getLocation());
        } finally {
            if (null != in) {
                in.closeQuietly();
            }
            if (null != out) {
                out.closeQuietly();
            }
            if (temp != null) {
                if (!temp.delete()) {
                    temp.deleteOnExit();
                }
            }
        }
    }

    
    private void flushFilterChain() {
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter filter = (Replacefilter) replacefilters.elementAt(i);
            filter.flush();
        }
    }

    
    private boolean processFilterChain() {
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter filter = (Replacefilter) replacefilters.elementAt(i);
            if (!filter.process()) {
                return false;
            }
        }
        return true;
    }

    
    private StringBuffer buildFilterChain(StringBuffer inputBuffer) {
        StringBuffer buf = inputBuffer;
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter filter = (Replacefilter) replacefilters.elementAt(i);
            filter.setInputBuffer(buf);
            buf = filter.getOutputBuffer();
        }
        return buf;
    }

    
    private void logFilterChain(String filename) {
        for (int i = 0; i < replacefilters.size(); i++) {
            Replacefilter filter = (Replacefilter) replacefilters.elementAt(i);
            log(""Replacing in "" + filename + "": "" + filter.getToken()
                    + "" --> "" + filter.getReplaceValue(), Project.MSG_VERBOSE);
        }
    }
    
    public void setFile(File file) {
        this.src = file;
    }

    
    public void setSummary(boolean summary) {
        this.summary = summary;
    }


    
    public void setReplaceFilterFile(File replaceFilterFile) {
        this.replaceFilterFile = replaceFilterFile;
    }

    
    public void setDir(File dir) {
        this.dir = dir;
    }

    
    public void setToken(String token) {
        createReplaceToken().addText(token);
    }

    
    public void setValue(String value) {
        createReplaceValue().addText(value);
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public NestedString createReplaceToken() {
        if (token == null) {
            token = new NestedString();
        }
        return token;
    }

    
    public NestedString createReplaceValue() {
        return value;
    }

    
    public void setPropertyFile(File propertyFile) {
        this.propertyFile = propertyFile;
    }

    
    public Replacefilter createReplacefilter() {
        Replacefilter filter = new Replacefilter();
        replacefilters.addElement(filter);
        return filter;
    }

    
    private Replacefilter createPrimaryfilter() {
        Replacefilter filter = new Replacefilter();
        replacefilters.insertElementAt(filter, 0);
        return filter;
    }

    
    private void stringReplace(StringBuffer str, String str1, String str2) {
        int found = str.toString().indexOf(str1);
        while (found >= 0) {
            str.replace(found, found + str1.length(), str2);
            found = str.toString().indexOf(str1, found + str2.length());
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCMkdir,11,4,0,7,33,37,0,7,8,0.9,178,0.428571429,0,0.827586207,0.386363636,2,3,14.54545455,4,1.3636,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCMkdir extends ClearCase {
    private String  mComment = null;
    private String  mCfile   = null;
    private boolean mNoco    = false;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_MKDIR);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }

    
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }
        if (getNoCheckout()) {
            
            cmd.createArgument().setValue(FLAG_NOCHECKOUT);
        }
        
        cmd.createArgument().setValue(getViewPath());
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setNoCheckout(boolean co) {
        mNoco = co;
    }

    
    public boolean getNoCheckout() {
        return mNoco;
    }


    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }

    
    public static final String FLAG_COMMENT = ""-c"";
    
    public static final String FLAG_COMMENTFILE = ""-cfile"";
    
    public static final String FLAG_NOCOMMENT = ""-nc"";
    
    public static final String FLAG_NOCHECKOUT = ""-nco"";
}

"
org.apache.tools.zip.UnrecognizedExtraField,10,1,0,3,13,31,1,2,10,0.703703704,76,1.0,1,0.0,0.375,0,0,6.3,2,1.1,1,"

package org.apache.tools.zip;


public class UnrecognizedExtraField implements ZipExtraField {

    
    private ZipShort headerId;

    
    public void setHeaderId(ZipShort headerId) {
        this.headerId = headerId;
    }

    
    public ZipShort getHeaderId() {
        return headerId;
    }

    
    private byte[] localData;

    
    public void setLocalFileDataData(byte[] data) {
        localData = data;
    }

    
    public ZipShort getLocalFileDataLength() {
        return new ZipShort(localData.length);
    }

    
    public byte[] getLocalFileDataData() {
        return localData;
    }

    
    private byte[] centralData;

    
    public void setCentralDirectoryData(byte[] data) {
        centralData = data;
    }

    
    public ZipShort getCentralDirectoryLength() {
        if (centralData != null) {
            return new ZipShort(centralData.length);
        }
        return getLocalFileDataLength();
    }

    
    public byte[] getCentralDirectoryData() {
        if (centralData != null) {
            return centralData;
        }
        return getLocalFileDataData();
    }

    
    public void parseFromLocalFileData(byte[] data, int offset, int length) {
        byte[] tmp = new byte[length];
        System.arraycopy(data, offset, tmp, 0, length);
        setLocalFileDataData(tmp);
    }
}
"
org.apache.tools.ant.taskdefs.optional.SchemaValidate,17,4,0,3,58,108,0,3,9,0.95625,345,0.4,1,0.8,0.254901961,2,6,18.70588235,4,1.5882,0,"
package org.apache.tools.ant.taskdefs.optional;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.XmlConstants;
import org.xml.sax.XMLReader;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXException;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.ParserConfigurationException;
import java.util.Iterator;
import java.util.HashMap;
import java.io.File;
import java.net.MalformedURLException;



public class SchemaValidate extends XMLValidateTask {

    
    private HashMap schemaLocations = new HashMap();

    
    private boolean fullChecking = true;

    
    private boolean disableDTD = false;

    
    private SchemaLocation anonymousSchema;

    
    
    public static final String ERROR_SAX_1 = ""SAX1 parsers are not supported"";

    
    public static final String ERROR_NO_XSD_SUPPORT
        = ""Parser does not support Xerces or JAXP schema features"";

    
    public static final String ERROR_TOO_MANY_DEFAULT_SCHEMAS
        = ""Only one of defaultSchemaFile and defaultSchemaURL allowed"";

    
    public static final String ERROR_PARSER_CREATION_FAILURE
        = ""Could not create parser"";

    
    public static final String MESSAGE_ADDING_SCHEMA = ""Adding schema "";

    
    public static final String ERROR_DUPLICATE_SCHEMA
        = ""Duplicate declaration of schema "";

    
    public void init() throws BuildException {
        super.init();
        
        setLenient(false);
    }

    
    public boolean enableXercesSchemaValidation() {
        try {
            setFeature(XmlConstants.FEATURE_XSD, true);
            
            setNoNamespaceSchemaProperty(XmlConstants.PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION);
        } catch (BuildException e) {
            log(e.toString(), Project.MSG_VERBOSE);
            return false;
        }
        return true;
    }

    
    private void setNoNamespaceSchemaProperty(String property) {
        String anonSchema = getNoNamespaceSchemaURL();
        if (anonSchema != null) {
            setProperty(property, anonSchema);
        }
    }

    
    public boolean enableJAXP12SchemaValidation() {
        try {
            
            setProperty(XmlConstants.FEATURE_JAXP12_SCHEMA_LANGUAGE, XmlConstants.URI_XSD);
            
            setNoNamespaceSchemaProperty(XmlConstants.FEATURE_JAXP12_SCHEMA_SOURCE);
        } catch (BuildException e) {
            log(e.toString(), Project.MSG_VERBOSE);
            return false;
        }
        return true;
    }

    
    public void addConfiguredSchema(SchemaLocation location) {
        log(""adding schema "" + location, Project.MSG_DEBUG);
        location.validateNamespace();
        SchemaLocation old = (SchemaLocation) schemaLocations.get(location.getNamespace());
        if (old != null && !old.equals(location)) {
            throw new BuildException(ERROR_DUPLICATE_SCHEMA + location);
        }
        schemaLocations.put(location.getNamespace(), location);
    }

    
    public void setFullChecking(boolean fullChecking) {
        this.fullChecking = fullChecking;
    }

    
    protected void createAnonymousSchema() {
        if (anonymousSchema == null) {
            anonymousSchema = new SchemaLocation();
        }
        anonymousSchema.setNamespace(""(no namespace)"");
    }

    
    public void setNoNamespaceURL(String defaultSchemaURL) {
        createAnonymousSchema();
        this.anonymousSchema.setUrl(defaultSchemaURL);
    }

    
    public void setNoNamespaceFile(File defaultSchemaFile) {
        createAnonymousSchema();
        this.anonymousSchema.setFile(defaultSchemaFile);
    }

    
    public void setDisableDTD(boolean disableDTD) {
        this.disableDTD = disableDTD;
    }

    
    protected void initValidator() {
        super.initValidator();
        
        if (isSax1Parser()) {
            throw new BuildException(ERROR_SAX_1);
        }

        
        
        setFeature(XmlConstants.FEATURE_NAMESPACES, true);
        if (!enableXercesSchemaValidation() && !enableJAXP12SchemaValidation()) {
            
            throw new BuildException(ERROR_NO_XSD_SUPPORT);
        }

        
        setFeature(XmlConstants.FEATURE_XSD_FULL_VALIDATION, fullChecking);

        
        setFeatureIfSupported(XmlConstants.FEATURE_DISALLOW_DTD, disableDTD);

        
        addSchemaLocations();
    }

    
    protected XMLReader createDefaultReader() {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setValidating(true);
        factory.setNamespaceAware(true);
        XMLReader reader = null;
        try {
            SAXParser saxParser = factory.newSAXParser();
            reader = saxParser.getXMLReader();
        } catch (ParserConfigurationException e) {
            throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
        } catch (SAXException e) {
            throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
        }
        return reader;
    }

    
    protected void addSchemaLocations() {
        Iterator it = schemaLocations.values().iterator();
        StringBuffer buffer = new StringBuffer();
        int count = 0;
        while (it.hasNext()) {
            if (count > 0) {
                buffer.append(' ');
            }
            SchemaLocation schemaLocation = (SchemaLocation) it.next();
            String tuple = schemaLocation.getURIandLocation();
            buffer.append(tuple);
            log(""Adding schema "" + tuple, Project.MSG_VERBOSE);
            count++;
        }
        if (count > 0) {
            setProperty(XmlConstants.PROPERTY_SCHEMA_LOCATION, buffer.toString());
        }

    }

    
    protected String getNoNamespaceSchemaURL() {
        if (anonymousSchema == null) {
            return null;
        } else {
            return anonymousSchema.getSchemaLocationURL();
        }
    }

    
    protected void setFeatureIfSupported(String feature, boolean value) {
        try {
            getXmlReader().setFeature(feature, value);
        } catch (SAXNotRecognizedException e) {
            log(""Not recognizied: "" + feature, Project.MSG_VERBOSE);
        } catch (SAXNotSupportedException e) {
            log(""Not supported: "" + feature, Project.MSG_VERBOSE);
        }
    }

    
    protected void onSuccessfulValidation(int fileProcessed) {
        log(fileProcessed + MESSAGE_FILES_VALIDATED, Project.MSG_VERBOSE);
    }

    
    public static class SchemaLocation {
        private String namespace;

        private File file;

        private String url;

        
        public static final String ERROR_NO_URI = ""No namespace URI"";

        
        public static final String ERROR_TWO_LOCATIONS
            = ""Both URL and File were given for schema "";

        
        public static final String ERROR_NO_FILE = ""File not found: "";

        
        public static final String ERROR_NO_URL_REPRESENTATION
            = ""Cannot make a URL of "";

        
        public static final String ERROR_NO_LOCATION
            = ""No file or URL supplied for the schema "";

        
        public SchemaLocation() {
        }

        
        public String getNamespace() {
            return namespace;
        }

        
        public void setNamespace(String namespace) {
            this.namespace = namespace;
        }

        
        public File getFile() {
            return file;
        }

        
        public void setFile(File file) {
            this.file = file;
        }

        
        public String getUrl() {
            return url;
        }

        
        public void setUrl(String url) {
            this.url = url;
        }

        
        public String getSchemaLocationURL() {
            boolean hasFile = file != null;
            boolean hasURL = isSet(url);
            
            if (!hasFile && !hasURL) {
                throw new BuildException(ERROR_NO_LOCATION + namespace);
            }
            if (hasFile && hasURL) {
                throw new BuildException(ERROR_TWO_LOCATIONS + namespace);
            }
            String schema = url;
            if (hasFile) {
                if (!file.exists()) {
                    throw new BuildException(ERROR_NO_FILE + file);
                }

                try {
                    schema = FileUtils.getFileUtils().getFileURL(file).toString();
                } catch (MalformedURLException e) {
                    
                    throw new BuildException(ERROR_NO_URL_REPRESENTATION + file, e);
                }
            }
            return schema;
        }

        
        public String getURIandLocation() throws BuildException {
            validateNamespace();
            StringBuffer buffer = new StringBuffer();
            buffer.append(namespace);
            buffer.append(' ');
            buffer.append(getSchemaLocationURL());
            return new String(buffer);
        }

        
        public void validateNamespace() {
            if (!isSet(getNamespace())) {
                throw new BuildException(ERROR_NO_URI);
            }
        }

        
        private boolean isSet(String property) {
            return property != null && property.length() != 0;
        }

        

        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof SchemaLocation)) {
                return false;
            }

            final SchemaLocation schemaLocation = (SchemaLocation) o;

            if (file != null ? !file.equals(schemaLocation.file) : schemaLocation.file != null) {
                return false;
            }
            if (namespace != null ? !namespace.equals(schemaLocation.namespace)
                    : schemaLocation.namespace != null) {
                return false;
            }
            if (url != null ? !url.equals(schemaLocation.url) : schemaLocation.url != null) {
                return false;
            }

            return true;
        }

        
        public int hashCode() {
            int result;
            result = (namespace != null ? namespace.hashCode() : 0);
            result = 29 * result + (file != null ? file.hashCode() : 0);
            result = 29 * result + (url != null ? url.hashCode() : 0);
            return result;
        }

        
        public String toString() {
            StringBuffer buffer = new StringBuffer();
            buffer.append(namespace != null ? namespace : ""(anonymous)"");
            buffer.append(' ');
            buffer.append(url != null ? (url + "" "") : """");
            buffer.append(file != null ? file.getAbsolutePath() : """");
            return buffer.toString();
        }
    } 
}
"
org.apache.tools.ant.types.Path,34,3,0,112,112,461,101,13,28,0.803030303,1021,0.5,3,0.491803279,0.127705628,2,6,28.91176471,7,2.2353,1,"

package org.apache.tools.ant.types;

import java.io.File;
import java.util.Collections;
import java.util.Iterator;
import java.util.Locale;
import java.util.Stack;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.PathTokenizer;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.resources.FileResourceIterator;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JavaEnvUtils;



public class Path extends DataType implements Cloneable, ResourceCollection {
    

    
    public static Path systemClasspath =
        new Path(null, System.getProperty(""java.class.path""));


    
    public static Path systemBootClasspath =
        new Path(null, System.getProperty(""sun.boot.class.path""));

    private static final Iterator EMPTY_ITERATOR
        = Collections.EMPTY_SET.iterator();

    

    
    public class PathElement implements ResourceCollection {
        private String[] parts;

        
        public void setLocation(File loc) {
            parts = new String[] {translateFile(loc.getAbsolutePath())};
        }

        
        public void setPath(String path) {
            parts = Path.translatePath(getProject(), path);
        }

        
        public String[] getParts() {
            return parts;
        }

        
        public Iterator iterator() {
            return new FileResourceIterator(null, parts);
        }

        
        public boolean isFilesystemOnly() {
            return true;
        }

        
        public int size() {
            return parts == null ? 0 : parts.length;
        }

    }

    private Union union = null;

    
    public Path(Project p, String path) {
        this(p);
        createPathElement().setPath(path);
    }

    
    public Path(Project project) {
        setProject(project);
    }

    
    public void setLocation(File location) throws BuildException {
        checkAttributesAllowed();
        createPathElement().setLocation(location);
    }

    
    public void setPath(String path) throws BuildException {
        checkAttributesAllowed();
        createPathElement().setPath(path);
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (union != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public PathElement createPathElement() throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        PathElement pe = new PathElement();
        add(pe);
        return pe;
    }

    
    public void addFileset(FileSet fs) throws BuildException {
        if (fs.getProject() == null) {
            fs.setProject(getProject());
        }
        add(fs);
    }

    
    public void addFilelist(FileList fl) throws BuildException {
        if (fl.getProject() == null) {
            fl.setProject(getProject());
        }
        add(fl);
    }

    
    public void addDirset(DirSet dset) throws BuildException {
        if (dset.getProject() == null) {
            dset.setProject(getProject());
        }
        add(dset);
    }

    
    public void add(Path path) throws BuildException {
        if (path == this) {
            throw circularReference();
        }
        if (path.getProject() == null) {
            path.setProject(getProject());
        }
        add((ResourceCollection) path);
    }

    
    public void add(ResourceCollection c) {
        checkChildrenAllowed();
        if (c == null) {
            return;
        }
        if (union == null) {
            union = new Union();
            union.setProject(getProject());
            union.setCache(false);
        }
        union.add(c);
        setChecked(false);
    }

    
    public Path createPath() throws BuildException {
        Path p = new Path(getProject());
        add(p);
        return p;
    }

    
    public void append(Path other) {
        if (other == null) {
            return;
        }
        add(other);
    }

    
     public void addExisting(Path source) {
         addExisting(source, false);
     }

    
    public void addExisting(Path source, boolean tryUserDir) {
        String[] list = source.list();
        File userDir = (tryUserDir) ? new File(System.getProperty(""user.dir""))
                : null;

        for (int i = 0; i < list.length; i++) {
            File f = resolveFile(getProject(), list[i]);

            
            
            if (tryUserDir && !f.exists()) {
                f = new File(userDir, list[i]);
            }
            if (f.exists()) {
                setLocation(f);
            } else {
                log(""dropping "" + f + "" from path as it doesn't exist"",
                    Project.MSG_VERBOSE);
            }
        }
    }

    
    public String[] list() {
        if (isReference()) {
            return ((Path) getCheckedRef()).list();
        }
        return assertFilesystemOnly(union) == null
            ? new String[0] : union.list();
    }

    
    public String toString() {
        return isReference() ? getCheckedRef().toString()
            : union == null ? """" : union.toString();
    }

    
    public static String[] translatePath(Project project, String source) {
        final Vector result = new Vector();
        if (source == null) {
            return new String[0];
        }
        PathTokenizer tok = new PathTokenizer(source);
        StringBuffer element = new StringBuffer();
        while (tok.hasMoreTokens()) {
            String pathElement = tok.nextToken();
            try {
                element.append(resolveFile(project, pathElement).getPath());
            } catch (BuildException e) {
                project.log(""Dropping path element "" + pathElement
                    + "" as it is not valid relative to the project"",
                    Project.MSG_VERBOSE);
            }
            for (int i = 0; i < element.length(); i++) {
                translateFileSep(element, i);
            }
            result.addElement(element.toString());
            element = new StringBuffer();
        }
        String[] res = new String[result.size()];
        result.copyInto(res);
        return res;
    }

    
    public static String translateFile(String source) {
        if (source == null) {
          return """";
        }
        final StringBuffer result = new StringBuffer(source);
        for (int i = 0; i < result.length(); i++) {
            translateFileSep(result, i);
        }
        return result.toString();
    }

    
    protected static boolean translateFileSep(StringBuffer buffer, int pos) {
        if (buffer.charAt(pos) == '/' || buffer.charAt(pos) == '\\') {
            buffer.setCharAt(pos, File.separatorChar);
            return true;
        }
        return false;
    }

    
    public synchronized int size() {
        if (isReference()) {
            return ((Path) getCheckedRef()).size();
        }
        dieOnCircularReference();
        return union == null ? 0 : assertFilesystemOnly(union).size();
    }

    
    public Object clone() {
        try {
            Path result = (Path) super.clone();
            result.union = union == null ? union : (Union) union.clone();
            return result;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
    }

    
    protected synchronized void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            if (union != null) {
                stk.push(union);
                invokeCircularReferenceCheck(union, stk, p);
                stk.pop();
            }
            setChecked(true);
        }
    }

    
    private static File resolveFile(Project project, String relativeName) {
        return FileUtils.getFileUtils().resolveFile(
            (project == null) ? null : project.getBaseDir(), relativeName);
    }

    
    public Path concatSystemClasspath() {
        return concatSystemClasspath(""last"");
    }

    
    public Path concatSystemClasspath(String defValue) {
        return concatSpecialPath(defValue, Path.systemClasspath);
    }

    
    public Path concatSystemBootClasspath(String defValue) {
        return concatSpecialPath(defValue, Path.systemBootClasspath);
    }

    
    private Path concatSpecialPath(String defValue, Path p) {
        Path result = new Path(getProject());

        String order = defValue;
        if (getProject() != null) {
            String o = getProject().getProperty(""build.sysclasspath"");
            if (o != null) {
                order = o;
            }
        }
        if (order.equals(""only"")) {
            
            result.addExisting(p, true);

        } else if (order.equals(""first"")) {
            
            result.addExisting(p, true);
            result.addExisting(this);

        } else if (order.equals(""ignore"")) {
            
            result.addExisting(this);

        } else {
            
            if (!order.equals(""last"")) {
                log(""invalid value for build.sysclasspath: "" + order,
                    Project.MSG_WARN);
            }
            result.addExisting(this);
            result.addExisting(p, true);
        }
        return result;
    }

    
    public void addJavaRuntime() {
        if (JavaEnvUtils.isKaffe()) {
            
            
            File kaffeShare = new File(System.getProperty(""java.home"")
                                       + File.separator + ""share""
                                       + File.separator + ""kaffe"");
            if (kaffeShare.isDirectory()) {
                FileSet kaffeJarFiles = new FileSet();
                kaffeJarFiles.setDir(kaffeShare);
                kaffeJarFiles.setIncludes(""*.jar"");
                addFileset(kaffeJarFiles);
            }
        } else if (""GNU libgcj"".equals(System.getProperty(""java.vm.name""))) {
            addExisting(systemBootClasspath);
        }

        if (System.getProperty(""java.vendor"").toLowerCase(Locale.US).indexOf(""microsoft"") >= 0) {
            
            
            FileSet msZipFiles = new FileSet();
            msZipFiles.setDir(new File(System.getProperty(""java.home"")
                + File.separator + ""Packages""));
            msZipFiles.setIncludes(""*.ZIP"");
            addFileset(msZipFiles);
        } else {
            
            addExisting(new Path(null,
                                 System.getProperty(""java.home"")
                                 + File.separator + ""lib""
                                 + File.separator + ""rt.jar""));
            
            
            addExisting(new Path(null,
                                 System.getProperty(""java.home"")
                                 + File.separator + ""jre""
                                 + File.separator + ""lib""
                                 + File.separator + ""rt.jar""));

            
            String[] secJars = {""jce"", ""jsse""};
            for (int i = 0; i < secJars.length; i++) {
                addExisting(new Path(null,
                                     System.getProperty(""java.home"")
                                     + File.separator + ""lib""
                                     + File.separator + secJars[i] + "".jar""));
                addExisting(new Path(null,
                                     System.getProperty(""java.home"")
                                     + File.separator + ""..""
                                     + File.separator + ""Classes""
                                     + File.separator + secJars[i] + "".jar""));
            }

            
            
            String[] ibmJars
                = {""core"", ""graphics"", ""security"", ""server"", ""xml""};
            for (int i = 0; i < ibmJars.length; i++) {
                addExisting(new Path(null,
                                     System.getProperty(""java.home"")
                                     + File.separator + ""lib""
                                     + File.separator + ibmJars[i] + "".jar""));
            }

            
            addExisting(new Path(null,
                                 System.getProperty(""java.home"")
                                 + File.separator + ""..""
                                 + File.separator + ""Classes""
                                 + File.separator + ""classes.jar""));
            addExisting(new Path(null,
                                 System.getProperty(""java.home"")
                                 + File.separator + ""..""
                                 + File.separator + ""Classes""
                                 + File.separator + ""ui.jar""));
        }
    }

    
    public void addExtdirs(Path extdirs) {
        if (extdirs == null) {
            String extProp = System.getProperty(""java.ext.dirs"");
            if (extProp != null) {
                extdirs = new Path(getProject(), extProp);
            } else {
                return;
            }
        }

        String[] dirs = extdirs.list();
        for (int i = 0; i < dirs.length; i++) {
            File dir = resolveFile(getProject(), dirs[i]);
            if (dir.exists() && dir.isDirectory()) {
                FileSet fs = new FileSet();
                fs.setDir(dir);
                fs.setIncludes(""*"");
                addFileset(fs);
            }
        }
    }

    
    public final synchronized Iterator iterator() {
        if (isReference()) {
            return ((Path) getCheckedRef()).iterator();
        }
        dieOnCircularReference();
        return union == null ? EMPTY_ITERATOR
            : assertFilesystemOnly(union).iterator();
    }

    
    public synchronized boolean isFilesystemOnly() {
        if (isReference()) {
            return ((Path) getCheckedRef()).isFilesystemOnly();
        }
        dieOnCircularReference();
        assertFilesystemOnly(union);
        return true;
    }

    
    protected ResourceCollection assertFilesystemOnly(ResourceCollection rc) {
        if (rc != null && !(rc.isFilesystemOnly())) {
            throw new BuildException(getDataTypeName()
                + "" allows only filesystem resources."");
        }
        return rc;
    }
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCMkelem,22,4,0,7,45,183,0,7,18,0.949579832,307,0.470588235,0,0.695652174,0.386363636,2,3,12.18181818,11,1.5455,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCMkelem extends ClearCase {
    private String  mComment = null;
    private String  mCfile   = null;
    private boolean mNwarn   = false;
    private boolean mPtime   = false;
    private boolean mNoco    = false;
    private boolean mCheckin = false;
    private boolean mMaster  = false;
    private String  mEltype  = null;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_MKELEM);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        if (getNoWarn()) {
            
            cmd.createArgument().setValue(FLAG_NOWARN);
        }
        
        if (getNoCheckout() && getCheckin()) {
            throw new BuildException(""Should choose either [nocheckout | checkin]"");
        }
        if (getNoCheckout()) {
            
            cmd.createArgument().setValue(FLAG_NOCHECKOUT);
        }
        if (getCheckin()) {
            
            cmd.createArgument().setValue(FLAG_CHECKIN);
            if (getPreserveTime()) {
                
                cmd.createArgument().setValue(FLAG_PRESERVETIME);
            }
        }
        if (getMaster()) {
            
            cmd.createArgument().setValue(FLAG_MASTER);
        }
        if (getEltype() != null) {
            
            getEltypeCommand(cmd);
        }
        
        cmd.createArgument().setValue(getViewPath());
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setNoWarn(boolean nwarn) {
        mNwarn = nwarn;
    }

    
    public boolean getNoWarn() {
        return mNwarn;
    }

    
    public void setPreserveTime(boolean ptime) {
        mPtime = ptime;
    }

    
    public boolean getPreserveTime() {
        return mPtime;
    }

    
    public void setNoCheckout(boolean co) {
        mNoco = co;
    }

    
    public boolean getNoCheckout() {
        return mNoco;
    }

    
    public void setCheckin(boolean ci) {
        mCheckin = ci;
    }

    
    public boolean getCheckin() {
        return mCheckin;
    }

    
    public void setMaster(boolean master) {
        mMaster = master;
    }

    
    public boolean getMaster() {
        return mMaster;
    }

    
    public void setEltype(String eltype) {
        mEltype = eltype;
    }

    
    public String getEltype() {
        return mEltype;
    }


    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }

    
    private void getEltypeCommand(Commandline cmd) {
        if (getEltype() != null) {
            
            cmd.createArgument().setValue(FLAG_ELTYPE);
            cmd.createArgument().setValue(getEltype());
        }
    }

    
    public static final String FLAG_COMMENT = ""-c"";
    
    public static final String FLAG_COMMENTFILE = ""-cfile"";
    
    public static final String FLAG_NOCOMMENT = ""-nc"";
    
    public static final String FLAG_NOWARN = ""-nwarn"";
    
    public static final String FLAG_PRESERVETIME = ""-ptime"";
    
    public static final String FLAG_NOCHECKOUT = ""-nco"";
    
    public static final String FLAG_CHECKIN = ""-ci"";
    
    public static final String FLAG_MASTER = ""-master"";
    
    public static final String FLAG_ELTYPE = ""-eltype"";
}

"
org.apache.tools.ant.types.RegularExpression,8,3,0,10,15,0,6,4,5,0.595238095,110,0.833333333,2,0.833333333,0.571428571,0,0,12.0,2,1.375,0,"
package org.apache.tools.ant.types;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.regexp.Regexp;
import org.apache.tools.ant.util.regexp.RegexpFactory;


public class RegularExpression extends DataType {
    
    public static final String DATA_TYPE_NAME = ""regexp"";
    private boolean alreadyInit = false;

    
    private static final RegexpFactory FACTORY = new RegexpFactory();

    private Regexp regexp = null;
    
    private String myPattern;
    private boolean setPatternPending = false;

    
    public RegularExpression() {
    }

    private void init(Project p) {
        if (!alreadyInit) {
            this.regexp = FACTORY.newRegexp(p);
            alreadyInit = true;
        }
    }
    private void setPattern() {
        if (setPatternPending) {
            regexp.setPattern(myPattern);
            setPatternPending = false;
        }
    }
    
    public void setPattern(String pattern) {
        if (regexp == null) {
            myPattern = pattern;
            setPatternPending = true;
        } else {
            regexp.setPattern(pattern);
        }
    }

    
    public String getPattern(Project p) {
        init(p);
        if (isReference()) {
            return getRef(p).getPattern(p);
        }
        setPattern();
        return regexp.getPattern();
    }

    
    public Regexp getRegexp(Project p) {
        init(p);
        if (isReference()) {
            return getRef(p).getRegexp(p);
        }
        setPattern();
        return this.regexp;
    }

    
    public RegularExpression getRef(Project p) {
        return (RegularExpression) getCheckedRef(p);
    }
}
"
org.apache.tools.ant.types.resources.FailFast,9,1,0,5,24,4,5,0,3,0.416666667,156,1.0,0,0.0,0.3125,0,0,16.0,6,1.8889,0,"
package org.apache.tools.ant.types.resources;

import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.WeakHashMap;
import java.util.NoSuchElementException;
import java.util.ConcurrentModificationException;


 class FailFast implements Iterator {
    private static final WeakHashMap MAP = new WeakHashMap();

    
    static synchronized void invalidate(Object o) {
        Set s = (Set) (MAP.get(o));
        if (s != null) {
            s.clear();
        }
    }

    private static synchronized void add(FailFast f) {
        Set s = (Set) (MAP.get(f.parent));
        if (s == null) {
            s = new HashSet();
            MAP.put(f.parent, s);
        }
        s.add(f);
    }

    private static synchronized void remove(FailFast f) {
        Set s = (Set) (MAP.get(f.parent));
        if (s != null) {
            s.remove(f);
        }
    }

    private static synchronized void failFast(FailFast f) {
        Set s = (Set) (MAP.get(f.parent));
        if (!s.contains(f)) {
            throw new ConcurrentModificationException();
        }
    }

    private Object parent;
    private Iterator wrapped;

    
    FailFast(Object o, Iterator i) {
        if (o == null) {
            throw new IllegalArgumentException(""parent object is null"");
        }
        if (i == null) {
            throw new IllegalArgumentException(""cannot wrap null iterator"");
        }
        parent = o;
        if (i.hasNext()) {
            wrapped = i;
            add(this);
        }
    }

    
    public boolean hasNext() {
        if (wrapped == null) {
            return false;
        }
        failFast(this);
        return wrapped.hasNext();
    }

    
    public Object next() {
        if (wrapped == null || !wrapped.hasNext()) {
            throw new NoSuchElementException();
        }
        failFast(this);
        try {
            return wrapped.next();
        } finally {
            if (!wrapped.hasNext()) {
                wrapped = null;
                remove(this);
            }
        }
    }

    
    public void remove() {
        throw new UnsupportedOperationException();
    }

}

"
org.apache.tools.ant.taskdefs.CopyPath,11,3,0,9,38,29,0,9,9,0.888888889,260,0.666666667,3,0.804347826,0.228571429,3,3,21.81818182,2,1.0,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;

import java.io.File;
import java.io.IOException;



public class CopyPath extends Task {

    
    
    public static final String ERROR_NO_DESTDIR = ""No destDir specified"";

    
    public static final String ERROR_NO_PATH = ""No path specified"";

    
    public static final String ERROR_NO_MAPPER = ""No mapper specified"";

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private FileNameMapper mapper;

    private Path path;

    private File destDir;

    
    private long granularity = FILE_UTILS.getFileTimestampGranularity();

    private boolean preserveLastModified = false;

    
    public void setDestDir(File destDir) {
        this.destDir = destDir;
    }

    
    public void add(FileNameMapper newmapper) {
        if (mapper != null) {
            throw new BuildException(""Only one mapper allowed"");
        }
        mapper = newmapper;
    }

    
    public void setPath(Path s) {
        createPath().append(s);
    }

    
    public void setPathRef(Reference r) {
        createPath().setRefid(r);
    }

    
    public Path createPath() {
        if (path == null) {
            path = new Path(getProject());
        }
        return path;
    }

    
    public void setGranularity(long granularity) {
        this.granularity = granularity;
    }

    
    public void setPreserveLastModified(boolean preserveLastModified) {
        this.preserveLastModified = preserveLastModified;
    }

    
    protected void validateAttributes() throws BuildException {
        if (destDir == null) {
            throw new BuildException(ERROR_NO_DESTDIR);
        }
        if (mapper == null) {
            throw new BuildException(ERROR_NO_MAPPER);
        }
        if (path == null) {
            throw new BuildException(ERROR_NO_PATH);
        }
    }

    
    public void execute() throws BuildException {
        validateAttributes();
        String[] sourceFiles = path.list();
        if (sourceFiles.length == 0) {
            log(""Path is empty"", Project.MSG_VERBOSE);
            return;
        }

        for (int sources = 0; sources < sourceFiles.length; sources++) {

            String sourceFileName = sourceFiles[sources];
            File sourceFile = new File(sourceFileName);
            String[] toFiles = (String[]) mapper.mapFileName(sourceFileName);

            for (int i = 0; i < toFiles.length; i++) {
                String destFileName = toFiles[i];
                File destFile = new File(destDir, destFileName);

                if (sourceFile.equals(destFile)) {
                    log(""Skipping self-copy of "" + sourceFileName, Project.MSG_VERBOSE);
                    continue;
                }
                if (sourceFile.isDirectory()) {
                    log(""Skipping directory "" + sourceFileName);
                    continue;
                }
                try {
                    log(""Copying "" + sourceFile + "" to "" + destFile, Project.MSG_VERBOSE);

                    FILE_UTILS.copyFile(sourceFile, destFile, null, null, false,
                            preserveLastModified, null, null, getProject());
                } catch (IOException ioe) {
                    String msg = ""Failed to copy "" + sourceFile + "" to "" + destFile + "" due to ""
                            + ioe.getMessage();
                    if (destFile.exists() && !destFile.delete()) {
                        msg += "" and I couldn't delete the corrupt "" + destFile;
                    }
                    throw new BuildException(msg, ioe, getLocation());
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Jvc,2,2,0,8,26,1,1,7,2,2.0,149,0.0,0,0.958333333,1.0,0,0,73.5,1,0.5,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class Jvc extends DefaultCompilerAdapter {

    
    public boolean execute() throws BuildException {
        attributes.log(""Using jvc compiler"", Project.MSG_VERBOSE);

        Path classpath = new Path(project);

        
        
        Path p = getBootClassPath();
        if (p.size() > 0) {
            classpath.append(p);
        }

        if (includeJavaRuntime) {
            
            
            classpath.addExtdirs(extdirs);
        }

        classpath.append(getCompileClasspath());

        
        
        if (compileSourcepath != null) {
            classpath.append(compileSourcepath);
        } else {
            classpath.append(src);
        }

        Commandline cmd = new Commandline();
        String exec = getJavac().getExecutable();
        cmd.setExecutable(exec == null ? ""jvc"" : exec);

        if (destDir != null) {
            cmd.createArgument().setValue(""/d"");
            cmd.createArgument().setFile(destDir);
        }

        
        cmd.createArgument().setValue(""/cp:p"");
        cmd.createArgument().setPath(classpath);

        boolean msExtensions = true;
        String mse = getProject().getProperty(""build.compiler.jvc.extensions"");
        if (mse != null) {
            msExtensions = Project.toBoolean(mse);
        }

        if (msExtensions) {
            
            cmd.createArgument().setValue(""/x-"");
            
            cmd.createArgument().setValue(""/nomessage"");
        }

        
        cmd.createArgument().setValue(""/nologo"");

        if (debug) {
            cmd.createArgument().setValue(""/g"");
        }
        if (optimize) {
            cmd.createArgument().setValue(""/O"");
        }
        if (verbose) {
            cmd.createArgument().setValue(""/verbose"");
        }

        addCurrentCompilerArgs(cmd);

        int firstFileName = cmd.size();
        logAndAddFilesToCompile(cmd);

        return
            executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
    }
}
"
org.apache.tools.ant.types.resolver.ApacheCatalogResolver,6,2,0,7,31,3,1,7,5,0.7,123,0.5,1,0.6,0.55,0,0,19.16666667,2,0.8333,0,"

package org.apache.tools.ant.types.resolver;

import java.io.IOException;

import java.net.MalformedURLException;
import java.net.URL;

import org.apache.tools.ant.BuildException;

import org.apache.tools.ant.types.XMLCatalog;
import org.apache.tools.ant.types.ResourceLocation;

import org.apache.xml.resolver.Catalog;
import org.apache.xml.resolver.CatalogManager;

import org.apache.xml.resolver.tools.CatalogResolver;



public class ApacheCatalogResolver extends CatalogResolver {

    
    private XMLCatalog xmlCatalog = null;

    static {
        
        
        
        
        
        
        
        
        CatalogManager.getStaticManager().setIgnoreMissingProperties(true);

        
        
        
        
        System.getProperties().put(""xml.catalog.className"",
                                   ApacheCatalog.class.getName());

        CatalogManager.getStaticManager().setUseStaticCatalog(false);

        
        
    }

    
    public void setXMLCatalog(XMLCatalog xmlCatalog) {
        this.xmlCatalog = xmlCatalog;
    }

    
    public void parseCatalog(String file) {

        Catalog catalog = getCatalog();
        if (!(catalog instanceof ApacheCatalog)) {
            throw new BuildException(""Wrong catalog type found: "" + catalog.getClass().getName());
        }
        ApacheCatalog apacheCatalog = (ApacheCatalog) catalog;

        
        apacheCatalog.setResolver(this);

        try {
            apacheCatalog.parseCatalog(file);
        } catch (MalformedURLException ex) {
            throw new BuildException(ex);
        } catch (IOException ex) {
            throw new BuildException(ex);
        }
    }

    
    public void addPublicEntry(String publicid,
                               String systemid,
                               URL base) {

        ResourceLocation dtd = new ResourceLocation();
        dtd.setBase(base);
        dtd.setPublicId(publicid);
        dtd.setLocation(systemid);

        xmlCatalog.addDTD(dtd);
    }

    
    public void addURIEntry(String uri,
                            String altURI,
                            URL base) {

        ResourceLocation entity = new ResourceLocation();
        entity.setBase(base);
        entity.setPublicId(uri);
        entity.setLocation(altURI);

        xmlCatalog.addEntity(entity);
    }

} 
"
org.apache.tools.ant.taskdefs.optional.extension.Specification,20,1,0,5,54,138,1,4,13,0.789473684,703,0.421052632,6,0.0,0.177631579,0,0,33.2,11,2.3,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Map;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

import org.apache.tools.ant.util.StringUtils;


public final class Specification {

    private static final String MISSING = ""Missing "";

    
    public static final Attributes.Name SPECIFICATION_TITLE
        = Attributes.Name.SPECIFICATION_TITLE;

    
    public static final Attributes.Name SPECIFICATION_VERSION
        = Attributes.Name.SPECIFICATION_VERSION;

    
    public static final Attributes.Name SPECIFICATION_VENDOR
        = Attributes.Name.SPECIFICATION_VENDOR;

    
    public static final Attributes.Name IMPLEMENTATION_TITLE
        = Attributes.Name.IMPLEMENTATION_TITLE;

    
    public static final Attributes.Name IMPLEMENTATION_VERSION
        = Attributes.Name.IMPLEMENTATION_VERSION;

    
    public static final Attributes.Name IMPLEMENTATION_VENDOR
        = Attributes.Name.IMPLEMENTATION_VENDOR;

    
    public static final Compatibility COMPATIBLE =
        new Compatibility(""COMPATIBLE"");

    
    public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE =
        new Compatibility(""REQUIRE_SPECIFICATION_UPGRADE"");

    
    public static final Compatibility REQUIRE_VENDOR_SWITCH =
        new Compatibility(""REQUIRE_VENDOR_SWITCH"");

    
    public static final Compatibility REQUIRE_IMPLEMENTATION_CHANGE =
        new Compatibility(""REQUIRE_IMPLEMENTATION_CHANGE"");

    
    public static final Compatibility INCOMPATIBLE =
        new Compatibility(""INCOMPATIBLE"");

    
    private String specificationTitle;

    
    private DeweyDecimal specificationVersion;

    
    private String specificationVendor;

    
    private String implementationTitle;

    
    private String implementationVendor;

    
    private String implementationVersion;

    
    private String[] sections;

    
    public static Specification[] getSpecifications(final Manifest manifest)
        throws ParseException {
        if (null == manifest) {
            return new Specification[ 0 ];
        }

        final ArrayList results = new ArrayList();

        final Map entries = manifest.getEntries();
        final Iterator keys = entries.keySet().iterator();
        while (keys.hasNext()) {
            final String key = (String) keys.next();
            final Attributes attributes = (Attributes) entries.get(key);
            final Specification specification
                = getSpecification(key, attributes);
            if (null != specification) {
                results.add(specification);
            }
        }

        final ArrayList trimmedResults = removeDuplicates(results);
        return (Specification[]) trimmedResults.toArray(new Specification[trimmedResults.size()]);
    }

    
    public Specification(final String specificationTitle,
                          final String specificationVersion,
                          final String specificationVendor,
                          final String implementationTitle,
                          final String implementationVersion,
                          final String implementationVendor) {
        this(specificationTitle, specificationVersion, specificationVendor,
              implementationTitle, implementationVersion, implementationVendor,
              null);
    }

    
    public Specification(final String specificationTitle,
                          final String specificationVersion,
                          final String specificationVendor,
                          final String implementationTitle,
                          final String implementationVersion,
                          final String implementationVendor,
                          final String[] sections) {
        this.specificationTitle = specificationTitle;
        this.specificationVendor = specificationVendor;

        if (null != specificationVersion) {
            try {
                this.specificationVersion
                    = new DeweyDecimal(specificationVersion);
            } catch (final NumberFormatException nfe) {
                final String error = ""Bad specification version format '""
                    + specificationVersion + ""' in '"" + specificationTitle
                    + ""'. (Reason: "" + nfe + "")"";
                throw new IllegalArgumentException(error);
            }
        }

        this.implementationTitle = implementationTitle;
        this.implementationVendor = implementationVendor;
        this.implementationVersion = implementationVersion;

        if (null == this.specificationTitle) {
            throw new NullPointerException(""specificationTitle"");
        }

        String[] copy = null;
        if (null != sections) {
            copy = new String[ sections.length ];
            System.arraycopy(sections, 0, copy, 0, sections.length);
        }
        this.sections = copy;
    }

    
    public String getSpecificationTitle() {
        return specificationTitle;
    }

    
    public String getSpecificationVendor() {
        return specificationVendor;
    }

    
    public String getImplementationTitle() {
        return implementationTitle;
    }

    
    public DeweyDecimal getSpecificationVersion() {
        return specificationVersion;
    }

    
    public String getImplementationVendor() {
        return implementationVendor;
    }

    
    public String getImplementationVersion() {
        return implementationVersion;
    }

    
    public String[] getSections() {
        if (null == sections) {
            return null;
        }
        final String[] newSections = new String[ sections.length ];
        System.arraycopy(sections, 0, newSections, 0, sections.length);
        return newSections;
    }

    
    public Compatibility getCompatibilityWith(final Specification other) {
        
        if (!specificationTitle.equals(other.getSpecificationTitle())) {
            return INCOMPATIBLE;
        }

        
        final DeweyDecimal otherSpecificationVersion
            = other.getSpecificationVersion();
        if (null != specificationVersion) {
            if (null == otherSpecificationVersion
                || !isCompatible(specificationVersion, otherSpecificationVersion)) {
                return REQUIRE_SPECIFICATION_UPGRADE;
            }
        }

        
        final String otherImplementationVendor
            = other.getImplementationVendor();
        if (null != implementationVendor) {
            if (null == otherImplementationVendor
                || !implementationVendor.equals(otherImplementationVendor)) {
                return REQUIRE_VENDOR_SWITCH;
            }
        }

        
        final String otherImplementationVersion
            = other.getImplementationVersion();
        if (null != implementationVersion) {
            if (null == otherImplementationVersion
                || !implementationVersion.equals(otherImplementationVersion)) {
                return REQUIRE_IMPLEMENTATION_CHANGE;
            }
        }

        
        return COMPATIBLE;
    }

    
    public boolean isCompatibleWith(final Specification other) {
        return (COMPATIBLE == getCompatibilityWith(other));
    }

    
    public String toString() {
        final String brace = "": "";

        final StringBuffer sb
            = new StringBuffer(SPECIFICATION_TITLE.toString());
        sb.append(brace);
        sb.append(specificationTitle);
        sb.append(StringUtils.LINE_SEP);

        if (null != specificationVersion) {
            sb.append(SPECIFICATION_VERSION);
            sb.append(brace);
            sb.append(specificationVersion);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != specificationVendor) {
            sb.append(SPECIFICATION_VENDOR);
            sb.append(brace);
            sb.append(specificationVendor);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationTitle) {
            sb.append(IMPLEMENTATION_TITLE);
            sb.append(brace);
            sb.append(implementationTitle);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationVersion) {
            sb.append(IMPLEMENTATION_VERSION);
            sb.append(brace);
            sb.append(implementationVersion);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationVendor) {
            sb.append(IMPLEMENTATION_VENDOR);
            sb.append(brace);
            sb.append(implementationVendor);
            sb.append(StringUtils.LINE_SEP);
        }

        return sb.toString();
    }

    
    private boolean isCompatible(final DeweyDecimal first,
                                 final DeweyDecimal second) {
        return first.isGreaterThanOrEqual(second);
    }

    
    private static ArrayList removeDuplicates(final ArrayList list) {
        final ArrayList results = new ArrayList();
        final ArrayList sections = new ArrayList();
        while (list.size() > 0) {
            final Specification specification = (Specification) list.remove(0);
            final Iterator iterator = list.iterator();
            while (iterator.hasNext()) {
                final Specification other = (Specification) iterator.next();
                if (isEqual(specification, other)) {
                    final String[] otherSections = other.getSections();
                    if (null != sections) {
                        sections.addAll(Arrays.asList(otherSections));
                    }
                    iterator.remove();
                }
            }

            final Specification merged =
                mergeInSections(specification, sections);
            results.add(merged);
            
            sections.clear();
        }

        return results;
    }

    
    private static boolean isEqual(final Specification specification,
                                    final Specification other) {
        return
            specification.getSpecificationTitle().equals(other.getSpecificationTitle())
            && specification.getSpecificationVersion().isEqual(other.getSpecificationVersion())
            && specification.getSpecificationVendor().equals(other.getSpecificationVendor())
            && specification.getImplementationTitle().equals(other.getImplementationTitle())
            && specification.getImplementationVersion().equals(other.getImplementationVersion())
            && specification.getImplementationVendor().equals(other.getImplementationVendor());
    }

    
    private static Specification mergeInSections(final Specification specification,
                                              final ArrayList sectionsToAdd) {
        if (0 == sectionsToAdd.size()) {
            return specification;
        }
        sectionsToAdd.addAll(Arrays.asList(specification.getSections()));

        final String[] sections =
            (String[]) sectionsToAdd.toArray(new String[sectionsToAdd.size()]);

        return new Specification(specification.getSpecificationTitle(),
                specification.getSpecificationVersion().toString(),
                specification.getSpecificationVendor(),
                specification.getImplementationTitle(),
                specification.getImplementationVersion(),
                specification.getImplementationVendor(),
                sections);
    }

    
    private static String getTrimmedString(final String value) {
        return value == null ? null : value.trim();
    }

    
    private static Specification getSpecification(final String section,
                                                   final Attributes attributes)
        throws ParseException {
        
        
        
        final String name
            = getTrimmedString(attributes.getValue(SPECIFICATION_TITLE));
        if (null == name) {
            return null;
        }

        final String specVendor
            = getTrimmedString(attributes.getValue(SPECIFICATION_VENDOR));
        if (null == specVendor) {
            throw new ParseException(MISSING + SPECIFICATION_VENDOR, 0);
        }

        final String specVersion
            = getTrimmedString(attributes.getValue(SPECIFICATION_VERSION));
        if (null == specVersion) {
            throw new ParseException(MISSING + SPECIFICATION_VERSION, 0);
        }

        final String impTitle
            = getTrimmedString(attributes.getValue(IMPLEMENTATION_TITLE));
        if (null == impTitle) {
            throw new ParseException(MISSING + IMPLEMENTATION_TITLE, 0);
        }

        final String impVersion
            = getTrimmedString(attributes.getValue(IMPLEMENTATION_VERSION));
        if (null == impVersion) {
            throw new ParseException(MISSING + IMPLEMENTATION_VERSION, 0);
        }

        final String impVendor
            = getTrimmedString(attributes.getValue(IMPLEMENTATION_VENDOR));
        if (null == impVendor) {
            throw new ParseException(MISSING + IMPLEMENTATION_VENDOR, 0);
        }

        return new Specification(name, specVersion, specVendor,
                                  impTitle, impVersion, impVendor,
                                  new String[]{section});
    }
}
"
org.apache.tools.ant.taskdefs.optional.script.ScriptDefBase,8,3,0,5,25,16,1,5,7,0.761904762,152,1.0,0,0.840909091,0.75,0,0,17.625,3,1.375,0,"
package org.apache.tools.ant.taskdefs.optional.script;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DynamicConfigurator;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;


public class ScriptDefBase extends Task implements DynamicConfigurator {

    
    private Map nestedElementMap = new HashMap();

    
    private Map attributes = new HashMap();

    private String text;

    
    public void execute() {
        getScript().executeScript(attributes, nestedElementMap, this);
    }

    private ScriptDef getScript() {
        String name = getTaskType();
        Map scriptRepository
            = (Map) getProject().getReference(MagicNames.SCRIPT_REPOSITORY);
        if (scriptRepository == null) {
            throw new BuildException(""Script repository not found for "" + name);
        }

        ScriptDef definition = (ScriptDef) scriptRepository.get(getTaskType());
        if (definition == null) {
            throw new BuildException(""Script definition not found for "" + name);
        }
        return definition;
    }

    
    public Object createDynamicElement(String name)  {
        List nestedElementList = (List) nestedElementMap.get(name);
        if (nestedElementList == null) {
            nestedElementList = new ArrayList();
            nestedElementMap.put(name, nestedElementList);
        }
        Object element = getScript().createNestedElement(name);
        nestedElementList.add(element);
        return element;
    }

    
    public void setDynamicAttribute(String name, String value) {
        ScriptDef definition = getScript();
        if (!definition.isAttributeSupported(name)) {
                throw new BuildException(""<"" + getTaskType()
                    + ""> does not support the \"""" + name + ""\"" attribute"");
        }

        attributes.put(name, value);
    }

    
    public void addText(String text) {
        this.text = getProject().replaceProperties(text);
    }

    
    public String getText() {
        return text;
    }

    
    public void fail(String message) {
        throw new BuildException(message);
    }
}

"
org.apache.tools.ant.taskdefs.optional.clearcase.CCUpdate,16,4,0,7,38,84,0,7,14,0.943589744,234,0.461538462,0,0.761904762,0.375,2,3,12.8125,6,1.3125,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCUpdate extends ClearCase {
    private boolean mGraphical = false;
    private boolean mOverwrite = false;
    private boolean mRename = false;
    private boolean mCtime = false;
    private boolean mPtime = false;
    private String mLog = null;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_UPDATE);

        
        checkOptions(commandLine);

        
        getProject().log(commandLine.toString(), Project.MSG_DEBUG);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }

    
    private void checkOptions(Commandline cmd) {
        
        if (getGraphical()) {
            
            cmd.createArgument().setValue(FLAG_GRAPHICAL);
        } else {
            if (getOverwrite()) {
                
                cmd.createArgument().setValue(FLAG_OVERWRITE);
            } else {
                if (getRename()) {
                    
                    cmd.createArgument().setValue(FLAG_RENAME);
                } else {
                    
                    cmd.createArgument().setValue(FLAG_NOVERWRITE);
                }
            }

            if (getCurrentTime()) {
                
                cmd.createArgument().setValue(FLAG_CURRENTTIME);
            } else {
                if (getPreserveTime()) {
                    
                    cmd.createArgument().setValue(FLAG_PRESERVETIME);
                }
            }

            
            getLogCommand(cmd);
        }

        
        cmd.createArgument().setValue(getViewPath());
    }

    
    public void setGraphical(boolean graphical) {
        mGraphical = graphical;
    }

    
    public boolean getGraphical() {
        return mGraphical;
    }

    
    public void setOverwrite(boolean ow) {
        mOverwrite = ow;
    }

    
    public boolean getOverwrite() {
        return mOverwrite;
    }

    
    public void setRename(boolean ren) {
        mRename = ren;
    }

    
    public boolean getRename() {
        return mRename;
    }

    
    public void setCurrentTime(boolean ct) {
        mCtime = ct;
    }

    
    public boolean getCurrentTime() {
        return mCtime;
    }

    
    public void setPreserveTime(boolean pt) {
        mPtime = pt;
    }

    
    public boolean getPreserveTime() {
        return mPtime;
    }

    
    public void setLog(String log) {
        mLog = log;
    }

    
    public String getLog() {
        return mLog;
    }


    
    private void getLogCommand(Commandline cmd) {
        if (getLog() == null) {
            return;
        } else {
            
            cmd.createArgument().setValue(FLAG_LOG);
            cmd.createArgument().setValue(getLog());
        }
    }

    
    public static final String FLAG_GRAPHICAL = ""-graphical"";
    
    public static final String FLAG_LOG = ""-log"";
    
    public static final String FLAG_OVERWRITE = ""-overwrite"";
    
    public static final String FLAG_NOVERWRITE = ""-noverwrite"";
    
    public static final String FLAG_RENAME = ""-rename"";
    
    public static final String FLAG_CURRENTTIME = ""-ctime"";
    
    public static final String FLAG_PRESERVETIME = ""-ptime"";

}

"
org.apache.tools.ant.taskdefs.optional.depend.Depend,27,4,0,13,118,265,0,13,12,0.895604396,1542,1.0,3,0.75,0.177777778,1,1,55.59259259,10,2.963,2,"
package org.apache.tools.ant.taskdefs.optional.depend;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URL;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.taskdefs.rmic.DefaultRmicAdapter;
import org.apache.tools.ant.taskdefs.rmic.WLRmic;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.depend.DependencyAnalyzer;


public class Depend extends MatchingTask {
    
    private static class ClassFileInfo {
        
        private File absoluteFile;

        
        private String className;

        
        private File sourceFile;

        
        private boolean isUserWarned = false;
    }

    
    private Path srcPath;

    
    private Path destPath;

    
    private File cache;

    
    private String[] srcPathList;

    
    private Hashtable affectedClassMap;

    
    private Hashtable classFileInfoMap;

    
    private Hashtable classpathDependencies;

    
    private Hashtable outOfDateClasses;

    
    private boolean closure = false;

    
    private boolean warnOnRmiStubs = true;

    
    private boolean dump = false;

    
    private Path dependClasspath;

    
    private static final String CACHE_FILE_NAME = ""dependencies.txt"";
    
    private static final String CLASSNAME_PREPEND = ""||:"";

    
    public void setClasspath(Path classpath) {
        if (dependClasspath == null) {
            dependClasspath = classpath;
        } else {
            dependClasspath.append(classpath);
        }
    }

    
    public Path getClasspath() {
        return dependClasspath;
    }

    
    public Path createClasspath() {
        if (dependClasspath == null) {
            dependClasspath = new Path(getProject());
        }
        return dependClasspath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setWarnOnRmiStubs(boolean warnOnRmiStubs) {
        this.warnOnRmiStubs = warnOnRmiStubs;
    }

    
    private Hashtable readCachedDependencies(File depFile) throws IOException {
        Hashtable dependencyMap = new Hashtable();

        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(depFile));
            String line = null;
            Vector dependencyList = null;
            String className = null;
            int prependLength = CLASSNAME_PREPEND.length();
            while ((line = in.readLine()) != null) {
                if (line.startsWith(CLASSNAME_PREPEND)) {
                    dependencyList = new Vector();
                    className = line.substring(prependLength);
                    dependencyMap.put(className, dependencyList);
                } else {
                    dependencyList.addElement(line);
                }
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }

        return dependencyMap;
    }

    
    private void writeCachedDependencies(Hashtable dependencyMap)
         throws IOException {
        if (cache != null) {
            PrintWriter pw = null;
            try {
                cache.mkdirs();
                File depFile = new File(cache, CACHE_FILE_NAME);

                pw = new PrintWriter(new FileWriter(depFile));
                Enumeration e = dependencyMap.keys();
                while (e.hasMoreElements()) {
                    String className = (String) e.nextElement();

                    pw.println(CLASSNAME_PREPEND + className);

                    Vector dependencyList
                         = (Vector) dependencyMap.get(className);
                    int size = dependencyList.size();
                    for (int x = 0; x < size; x++) {
                        pw.println(dependencyList.elementAt(x));
                    }
                }
            } finally {
                if (pw != null) {
                    pw.close();
                }
            }
        }
    }

    
    private Path getCheckClassPath() {
        if (dependClasspath == null) {
            return null;
        }

        String[] destPathElements = destPath.list();
        String[] classpathElements = dependClasspath.list();
        String checkPath = """";
        for (int i = 0; i < classpathElements.length; ++i) {
            String element = classpathElements[i];
            boolean inDestPath = false;
            for (int j = 0; j < destPathElements.length && !inDestPath; ++j) {
                inDestPath = destPathElements[j].equals(element);
            }
            if (!inDestPath) {
                if (checkPath.length() == 0) {
                    checkPath = element;
                } else {
                    checkPath += "":"" + element;
                }
            }
        }

        if (checkPath.length() == 0) {
            return null;
        }

        return new Path(getProject(), checkPath);
    }

    
    private void determineDependencies() throws IOException {
        affectedClassMap = new Hashtable();
        classFileInfoMap = new Hashtable();
        boolean cacheDirty = false;

        Hashtable dependencyMap = new Hashtable();
        File cacheFile = null;
        boolean cacheFileExists = true;
        long cacheLastModified = Long.MAX_VALUE;

        
        if (cache != null) {
            cacheFile = new File(cache, CACHE_FILE_NAME);
            cacheFileExists = cacheFile.exists();
            cacheLastModified = cacheFile.lastModified();
            if (cacheFileExists) {
                dependencyMap = readCachedDependencies(cacheFile);
            }
        }
        Enumeration classfileEnum = getClassFiles(destPath).elements();
        while (classfileEnum.hasMoreElements()) {
            ClassFileInfo info = (ClassFileInfo) classfileEnum.nextElement();
            log(""Adding class info for "" + info.className, Project.MSG_DEBUG);
            classFileInfoMap.put(info.className, info);

            Vector dependencyList = null;

            if (cache != null) {
                
                
                if (cacheFileExists
                    && cacheLastModified > info.absoluteFile.lastModified()) {
                    
                    
                    dependencyList = (Vector) dependencyMap.get(info.className);
                }
            }

            if (dependencyList == null) {
                
                DependencyAnalyzer analyzer = new AntAnalyzer();
                analyzer.addRootClass(info.className);
                analyzer.addClassPath(destPath);
                analyzer.setClosure(false);
                dependencyList = new Vector();
                Enumeration depEnum = analyzer.getClassDependencies();
                while (depEnum.hasMoreElements()) {
                    dependencyList.addElement(depEnum.nextElement());
                }
                cacheDirty = true;
                dependencyMap.put(info.className, dependencyList);
            }

            
            
            Enumeration depEnum = dependencyList.elements();
            while (depEnum.hasMoreElements()) {
                String dependentClass = (String) depEnum.nextElement();

                Hashtable affectedClasses
                    = (Hashtable) affectedClassMap.get(dependentClass);
                if (affectedClasses == null) {
                    affectedClasses = new Hashtable();
                    affectedClassMap.put(dependentClass, affectedClasses);
                }

                affectedClasses.put(info.className, info);
            }
        }

        classpathDependencies = null;
        Path checkPath = getCheckClassPath();
        if (checkPath != null) {
            
            classpathDependencies = new Hashtable();
            AntClassLoader loader = getProject().createClassLoader(checkPath);

            Hashtable classpathFileCache = new Hashtable();
            Object nullFileMarker = new Object();
            for (Enumeration e = dependencyMap.keys(); e.hasMoreElements();) {
                String className = (String) e.nextElement();
                Vector dependencyList = (Vector) dependencyMap.get(className);
                Hashtable dependencies = new Hashtable();
                classpathDependencies.put(className, dependencies);
                Enumeration e2 = dependencyList.elements();
                while (e2.hasMoreElements()) {
                    String dependency = (String) e2.nextElement();
                    Object classpathFileObject
                        = classpathFileCache.get(dependency);
                    if (classpathFileObject == null) {
                        classpathFileObject = nullFileMarker;

                        if (!dependency.startsWith(""java."")
                            && !dependency.startsWith(""javax."")) {
                            URL classURL
                                = loader.getResource(dependency.replace('.', '/') + "".class"");
                            if (classURL != null) {
                                if (classURL.getProtocol().equals(""jar"")) {
                                    String jarFilePath = classURL.getFile();
                                    int classMarker = jarFilePath.indexOf('!');
                                    jarFilePath = jarFilePath.substring(0, classMarker);
                                    if (jarFilePath.startsWith(""file:"")) {
                                        classpathFileObject = new File(
                                            FileUtils.getFileUtils().fromURI(jarFilePath));
                                    } else {
                                        throw new IOException(
                                            ""Bizarre nested path in jar: protocol: ""
                                            + jarFilePath);
                                    }
                                } else if (classURL.getProtocol().equals(""file"")) {
                                    classpathFileObject = new File(
                                        FileUtils.getFileUtils()
                                        .fromURI(classURL.toExternalForm()));
                                }
                                log(""Class "" + className
                                    + "" depends on "" + classpathFileObject
                                    + "" due to "" + dependency, Project.MSG_DEBUG);
                            }
                        }
                        classpathFileCache.put(dependency, classpathFileObject);
                    }
                    if (classpathFileObject != null && classpathFileObject != nullFileMarker) {
                        
                        File jarFile = (File) classpathFileObject;
                        dependencies.put(jarFile, jarFile);
                    }
                }
            }
        }

        
        if (cache != null && cacheDirty) {
            writeCachedDependencies(dependencyMap);
        }
    }

    
    private int deleteAllAffectedFiles() {
        int count = 0;
        for (Enumeration e = outOfDateClasses.elements(); e.hasMoreElements();) {
            String className = (String) e.nextElement();
            count += deleteAffectedFiles(className);
            ClassFileInfo classInfo
                = (ClassFileInfo) classFileInfoMap.get(className);
            if (classInfo != null && classInfo.absoluteFile.exists()) {
                classInfo.absoluteFile.delete();
                count++;
            }
        }
        return count;
    }

    
    private int deleteAffectedFiles(String className) {
        int count = 0;

        Hashtable affectedClasses = (Hashtable) affectedClassMap.get(className);
        if (affectedClasses == null) {
            return count;
        }
        for (Enumeration e = affectedClasses.keys(); e.hasMoreElements();) {
            String affectedClass = (String) e.nextElement();
            ClassFileInfo affectedClassInfo
                = (ClassFileInfo) affectedClasses.get(affectedClass);

            if (!affectedClassInfo.absoluteFile.exists()) {
                continue;
            }

            if (affectedClassInfo.sourceFile == null) {
                warnOutOfDateButNotDeleted(affectedClassInfo, affectedClass, className);
                continue;
            }

            log(""Deleting file "" + affectedClassInfo.absoluteFile.getPath()
                + "" since "" + className + "" out of date"", Project.MSG_VERBOSE);

            affectedClassInfo.absoluteFile.delete();
            count++;
            if (closure) {
                count += deleteAffectedFiles(affectedClass);
            } else {
                
                

                if (affectedClass.indexOf(""$"") == -1) {
                    continue;
                }
                
                String topLevelClassName
                     = affectedClass.substring(0, affectedClass.indexOf(""$""));
                log(""Top level class = "" + topLevelClassName,
                    Project.MSG_VERBOSE);
                ClassFileInfo topLevelClassInfo
                     = (ClassFileInfo) classFileInfoMap.get(topLevelClassName);
                if (topLevelClassInfo != null
                    && topLevelClassInfo.absoluteFile.exists()) {
                    log(""Deleting file ""
                        + topLevelClassInfo.absoluteFile.getPath()
                        + "" since one of its inner classes was removed"",
                        Project.MSG_VERBOSE);
                    topLevelClassInfo.absoluteFile.delete();
                    count++;
                    if (closure) {
                        count += deleteAffectedFiles(topLevelClassName);
                    }
                }
            }
        }
        return count;
    }

    
    private void warnOutOfDateButNotDeleted(
            ClassFileInfo affectedClassInfo, String affectedClass,
            String className) {
        if (affectedClassInfo.isUserWarned) {
            return;
        }
        int level = Project.MSG_WARN;
        if (!warnOnRmiStubs) {
            
            
            
            if (isRmiStub(affectedClass, className)) {
                level = Project.MSG_VERBOSE;
            }
        }
        log(""The class "" + affectedClass + "" in file ""
            + affectedClassInfo.absoluteFile.getPath()
            + "" is out of date due to "" + className
            + "" but has not been deleted because its source file""
            + "" could not be determined"", level);
        affectedClassInfo.isUserWarned = true;
    }

    
    private boolean isRmiStub(String affectedClass, String className) {
        return isStub(affectedClass, className, DefaultRmicAdapter.RMI_STUB_SUFFIX)
                || isStub(affectedClass, className, DefaultRmicAdapter.RMI_SKEL_SUFFIX)
                || isStub(affectedClass, className, WLRmic.RMI_STUB_SUFFIX)
                || isStub(affectedClass, className, WLRmic.RMI_SKEL_SUFFIX);
    }

    private boolean isStub(String affectedClass, String baseClass, String suffix) {
        return (baseClass + suffix).equals(affectedClass);
    }

    
    private void dumpDependencies() {
        log(""Reverse Dependency Dump for "" + affectedClassMap.size()
            + "" classes:"", Project.MSG_DEBUG);

        Enumeration classEnum = affectedClassMap.keys();
        while (classEnum.hasMoreElements()) {
            String className = (String) classEnum.nextElement();
            log("" Class "" + className + "" affects:"", Project.MSG_DEBUG);
            Hashtable affectedClasses
                = (Hashtable) affectedClassMap.get(className);
            Enumeration affectedClassEnum = affectedClasses.keys();
            while (affectedClassEnum.hasMoreElements()) {
                String affectedClass = (String) affectedClassEnum.nextElement();
                ClassFileInfo info
                    = (ClassFileInfo) affectedClasses.get(affectedClass);
                log(""    "" + affectedClass + "" in ""
                    + info.absoluteFile.getPath(), Project.MSG_DEBUG);
            }
        }

        if (classpathDependencies != null) {
            log(""Classpath file dependencies (Forward):"", Project.MSG_DEBUG);

            Enumeration classpathEnum = classpathDependencies.keys();
            while (classpathEnum.hasMoreElements()) {
                String className = (String) classpathEnum.nextElement();
                log("" Class "" + className + "" depends on:"", Project.MSG_DEBUG);
                Hashtable dependencies
                    = (Hashtable) classpathDependencies.get(className);

                Enumeration classpathFileEnum = dependencies.elements();
                while (classpathFileEnum.hasMoreElements()) {
                    File classpathFile = (File) classpathFileEnum.nextElement();
                    log(""    "" + classpathFile.getPath(), Project.MSG_DEBUG);
                }
            }
        }
    }

    private void determineOutOfDateClasses() {
        outOfDateClasses = new Hashtable();
        for (int i = 0; i < srcPathList.length; i++) {
            File srcDir = getProject().resolveFile(srcPathList[i]);
            if (srcDir.exists()) {
                DirectoryScanner ds = this.getDirectoryScanner(srcDir);
                String[] files = ds.getIncludedFiles();
                scanDir(srcDir, files);
            }
        }

        
        if (classpathDependencies == null) {
            return;
        }

        Enumeration classpathDepsEnum = classpathDependencies.keys();
        while (classpathDepsEnum.hasMoreElements()) {
            String className = (String) classpathDepsEnum.nextElement();
            if (outOfDateClasses.containsKey(className)) {
                continue;
            }
            ClassFileInfo info
                = (ClassFileInfo) classFileInfoMap.get(className);

            
            
            if (info != null) {
                Hashtable dependencies
                    = (Hashtable) classpathDependencies.get(className);
                for (Enumeration e2 = dependencies.elements(); e2.hasMoreElements();) {
                    File classpathFile = (File) e2.nextElement();
                    if (classpathFile.lastModified()
                        > info.absoluteFile.lastModified()) {
                        log(""Class "" + className
                            + "" is out of date with respect to ""
                            + classpathFile, Project.MSG_DEBUG);
                        outOfDateClasses.put(className, className);
                        break;
                    }
                }
            }
        }
    }

    
    public void execute() throws BuildException {
        try {
            long start = System.currentTimeMillis();
            if (srcPath == null) {
                throw new BuildException(""srcdir attribute must be set"",
                                         getLocation());
            }

            srcPathList = srcPath.list();
            if (srcPathList.length == 0) {
                throw new BuildException(""srcdir attribute must be non-empty"",
                                         getLocation());
            }

            if (destPath == null) {
                destPath = srcPath;
            }

            if (cache != null && cache.exists() && !cache.isDirectory()) {
                throw new BuildException(""The cache, if specified, must ""
                    + ""point to a directory"");
            }

            if (cache != null && !cache.exists()) {
                cache.mkdirs();
            }

            determineDependencies();
            if (dump) {
                dumpDependencies();
            }
            determineOutOfDateClasses();
            int count = deleteAllAffectedFiles();

            long duration = (System.currentTimeMillis() - start) / 1000;

            final int summaryLogLevel;
            if (count > 0) {
                summaryLogLevel = Project.MSG_INFO;
            }  else {
                summaryLogLevel = Project.MSG_DEBUG;
            }

            log(""Deleted "" + count + "" out of date files in ""
                + duration + "" seconds"", summaryLogLevel);
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }

    
    protected void scanDir(File srcDir, String[] files) {

        for (int i = 0; i < files.length; i++) {
            File srcFile = new File(srcDir, files[i]);
            if (files[i].endsWith("".java"")) {
                String filePath = srcFile.getPath();
                String className
                    = filePath.substring(srcDir.getPath().length() + 1,
                        filePath.length() - "".java"".length());
                className = ClassFileUtils.convertSlashName(className);
                ClassFileInfo info
                    = (ClassFileInfo) classFileInfoMap.get(className);
                if (info == null) {
                    
                    outOfDateClasses.put(className, className);
                } else {
                    if (srcFile.lastModified()
                        > info.absoluteFile.lastModified()) {
                        outOfDateClasses.put(className, className);
                    }
                }
            }
        }
    }


    
    private Vector getClassFiles(Path classLocations) {
        
        String[] classLocationsList = classLocations.list();

        Vector classFileList = new Vector();

        for (int i = 0; i < classLocationsList.length; ++i) {
            File dir = new File(classLocationsList[i]);
            if (dir.isDirectory()) {
                addClassFiles(classFileList, dir, dir);
            }
        }

        return classFileList;
    }

    
    private File findSourceFile(String classname) {
        String sourceFilename = classname + "".java"";
        int innerIndex = classname.indexOf(""$"");
        if (innerIndex != -1) {
            sourceFilename = classname.substring(0, innerIndex) + "".java"";
        }

        
        for (int i = 0; i < srcPathList.length; ++i) {
            File sourceFile = new File(srcPathList[i], sourceFilename);
            if (sourceFile.exists()) {
                return sourceFile;
            }
        }
        return null;
    }

    
    private void addClassFiles(Vector classFileList, File dir, File root) {
        String[] filesInDir = dir.list();

        if (filesInDir == null) {
            return;
        }
        int length = filesInDir.length;

        int rootLength = root.getPath().length();
        for (int i = 0; i < length; ++i) {
            File file = new File(dir, filesInDir[i]);
            if (file.isDirectory()) {
                addClassFiles(classFileList, file, root);
            } else if (file.getName().endsWith("".class"")) {
                ClassFileInfo info = new ClassFileInfo();
                info.absoluteFile = file;
                String relativeName = file.getPath().substring(rootLength + 1,
                    file.getPath().length() - 6);
                info.className
                    = ClassFileUtils.convertSlashName(relativeName);
                info.sourceFile = findSourceFile(relativeName);
                classFileList.addElement(info);
            }
        }
    }


    
    public void setSrcdir(Path srcPath) {
        this.srcPath = srcPath;
    }

    
    public void setDestDir(Path destPath) {
        this.destPath = destPath;
    }

    
    public void setCache(File cache) {
        this.cache = cache;
    }

    
    public void setClosure(boolean closure) {
        this.closure = closure;
    }

    
    public void setDump(boolean dump) {
        this.dump = dump;
    }
}

"
org.apache.tools.ant.taskdefs.optional.perforce.P4Base,15,3,15,27,41,57,17,11,13,0.818181818,312,1.0,0,0.725490196,0.45,0,0,19.06666667,4,1.1333,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import java.io.IOException;
import org.apache.oro.text.perl.Perl5Util;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;



public abstract class P4Base extends org.apache.tools.ant.Task {
    
    
    
    protected Perl5Util util = null;
    
    protected String shell;

    
    
    protected String P4Port = """";
    
    protected String P4Client = """";
    
    protected String P4User = """";
    
    protected boolean failOnError = true;

    
    
    protected String P4Opts = """";
    
    protected String P4CmdOpts = """";

    
    private boolean inError = false;

    
    private String errorMessage = """";

    
    

    
    public boolean getInError() {
        return inError;
    }

    
    public void setInError(boolean inError) {
        this.inError = inError;
    }

    
    public String getErrorMessage() {
        return errorMessage;
    }

    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    

    
    public void setPort(String p4Port) {
        this.P4Port = ""-p"" + p4Port;
    }

    
    public void setClient(String p4Client) {
        this.P4Client = ""-c"" + p4Client;
    }

    
    public void setUser(String p4User) {
        this.P4User = ""-u"" + p4User;
    }
    
    public void setGlobalopts(String p4Opts) {
        this.P4Opts = p4Opts;
    }
    
    public void setView(String p4View) {
        this.P4View = p4View;
    }

    
    public void setCmdopts(String p4CmdOpts) {
        this.P4CmdOpts = p4CmdOpts;
    }

    
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }
    
    public void init() {

        util = new Perl5Util();

        
        
        String tmpprop;
        if ((tmpprop = getProject().getProperty(""p4.port"")) != null) {
            setPort(tmpprop);
        }
        if ((tmpprop = getProject().getProperty(""p4.client"")) != null) {
            setClient(tmpprop);
        }
        if ((tmpprop = getProject().getProperty(""p4.user"")) != null) {
            setUser(tmpprop);
        }
    }
    
    protected void execP4Command(String command) throws BuildException {
        execP4Command(command, null);
    }

    
    protected void execP4Command(String command, P4Handler handler) throws BuildException {
        try {
            
            inError = false;
            errorMessage = """";
            Commandline commandline = new Commandline();
            commandline.setExecutable(""p4"");

            
            if (P4Port != null && P4Port.length() != 0) {
                commandline.createArgument().setValue(P4Port);
            }
            if (P4User != null && P4User.length() != 0) {
                commandline.createArgument().setValue(P4User);
            }
            if (P4Client != null && P4Client.length() != 0) {
                commandline.createArgument().setValue(P4Client);
            }
            if (P4Opts != null && P4Opts.length() != 0) {
                commandline.createArgument().setLine(P4Opts);
            }
            commandline.createArgument().setLine(command);

            log(commandline.describeCommand(), Project.MSG_VERBOSE);

            if (handler == null) {
                handler = new SimpleP4OutputHandler(this);
            }

            Execute exe = new Execute(handler, null);

            exe.setAntRun(getProject());

            exe.setCommandline(commandline.getCommandline());

            try {
                exe.execute();

                if (inError && failOnError) {
                    throw new BuildException(errorMessage);
                }
            } catch (IOException e) {
                throw new BuildException(e);
            } finally {
                try {
                    handler.stop();
                } catch (Exception e) {
                    log(e.toString(), Project.MSG_ERR);
                }
            }


        } catch (Exception e) {
            String failMsg = ""Problem exec'ing P4 command: "" + e.getMessage();
            if (failOnError) {
                throw new BuildException(failMsg);
            } else {
                log(failMsg, Project.MSG_ERR);
            }

        }
    }
}
"
org.apache.tools.tar.TarOutputStream,15,3,0,3,39,41,1,2,14,0.704081633,469,0.785714286,1,0.454545455,0.311111111,1,2,29.33333333,1,0.8,1,"



package org.apache.tools.tar;

import java.io.FilterOutputStream;
import java.io.OutputStream;
import java.io.IOException;


public class TarOutputStream extends FilterOutputStream {
    
    public static final int LONGFILE_ERROR = 0;

    
    public static final int LONGFILE_TRUNCATE = 1;

    
    public static final int LONGFILE_GNU = 2;

    
    protected boolean   debug;
    protected long      currSize;
    protected String    currName;
    protected long      currBytes;
    protected byte[]    oneBuf;
    protected byte[]    recordBuf;
    protected int       assemLen;
    protected byte[]    assemBuf;
    protected TarBuffer buffer;
    protected int       longFileMode = LONGFILE_ERROR;
    

    private boolean closed = false;

    
    public TarOutputStream(OutputStream os) {
        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
    }

    
    public TarOutputStream(OutputStream os, int blockSize) {
        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    
    public TarOutputStream(OutputStream os, int blockSize, int recordSize) {
        super(os);

        this.buffer = new TarBuffer(os, blockSize, recordSize);
        this.debug = false;
        this.assemLen = 0;
        this.assemBuf = new byte[recordSize];
        this.recordBuf = new byte[recordSize];
        this.oneBuf = new byte[1];
    }

    
    public void setLongFileMode(int longFileMode) {
        this.longFileMode = longFileMode;
    }


    
    public void setDebug(boolean debugF) {
        this.debug = debugF;
    }

    
    public void setBufferDebug(boolean debug) {
        this.buffer.setDebug(debug);
    }

    
    public void finish() throws IOException {
        
        
        this.writeEOFRecord();
        this.writeEOFRecord();
    }

    
    public void close() throws IOException {
        if (!closed) {
            this.finish();
            this.buffer.close();
            out.close();
            closed = true;
        }
    }

    
    public int getRecordSize() {
        return this.buffer.getRecordSize();
    }

    
    public void putNextEntry(TarEntry entry) throws IOException {
        if (entry.getName().length() >= TarConstants.NAMELEN) {

            if (longFileMode == LONGFILE_GNU) {
                
                
                TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK,
                                                      TarConstants.LF_GNUTYPE_LONGNAME);

                longLinkEntry.setSize(entry.getName().length() + 1);
                putNextEntry(longLinkEntry);
                write(entry.getName().getBytes());
                write(0);
                closeEntry();
            } else if (longFileMode != LONGFILE_TRUNCATE) {
                throw new RuntimeException(""file name '"" + entry.getName()
                                             + ""' is too long ( > ""
                                             + TarConstants.NAMELEN + "" bytes)"");
            }
        }

        entry.writeEntryHeader(this.recordBuf);
        this.buffer.writeRecord(this.recordBuf);

        this.currBytes = 0;

        if (entry.isDirectory()) {
            this.currSize = 0;
        } else {
            this.currSize = entry.getSize();
        }
        currName = entry.getName();
    }

    
    public void closeEntry() throws IOException {
        if (this.assemLen > 0) {
            for (int i = this.assemLen; i < this.assemBuf.length; ++i) {
                this.assemBuf[i] = 0;
            }

            this.buffer.writeRecord(this.assemBuf);

            this.currBytes += this.assemLen;
            this.assemLen = 0;
        }

        if (this.currBytes < this.currSize) {
            throw new IOException(""entry '"" + currName + ""' closed at '""
                                  + this.currBytes
                                  + ""' before the '"" + this.currSize
                                  + ""' bytes specified in the header were written"");
        }
    }

    
    public void write(int b) throws IOException {
        this.oneBuf[0] = (byte) b;

        this.write(this.oneBuf, 0, 1);
    }

    
    public void write(byte[] wBuf) throws IOException {
        this.write(wBuf, 0, wBuf.length);
    }

    
    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
        if ((this.currBytes + numToWrite) > this.currSize) {
            throw new IOException(""request to write '"" + numToWrite
                                  + ""' bytes exceeds size in header of '""
                                  + this.currSize + ""' bytes for entry '""
                                  + currName + ""'"");

            
            
            
            
            
            
            
        }

        if (this.assemLen > 0) {
            if ((this.assemLen + numToWrite) >= this.recordBuf.length) {
                int aLen = this.recordBuf.length - this.assemLen;

                System.arraycopy(this.assemBuf, 0, this.recordBuf, 0,
                                 this.assemLen);
                System.arraycopy(wBuf, wOffset, this.recordBuf,
                                 this.assemLen, aLen);
                this.buffer.writeRecord(this.recordBuf);

                this.currBytes += this.recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                this.assemLen = 0;
            } else {
                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen,
                                 numToWrite);

                wOffset += numToWrite;
                this.assemLen += numToWrite;
                numToWrite -= numToWrite;
            }
        }

        
        
        
        
        
        while (numToWrite > 0) {
            if (numToWrite < this.recordBuf.length) {
                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen,
                                 numToWrite);

                this.assemLen += numToWrite;

                break;
            }

            this.buffer.writeRecord(wBuf, wOffset);

            int num = this.recordBuf.length;

            this.currBytes += num;
            numToWrite -= num;
            wOffset += num;
        }
    }

    
    private void writeEOFRecord() throws IOException {
        for (int i = 0; i < this.recordBuf.length; ++i) {
            this.recordBuf[i] = 0;
        }

        this.buffer.writeRecord(this.recordBuf);
    }
}


"
org.apache.tools.ant.types.resources.Resources,12,3,0,15,47,44,9,8,6,0.781818182,240,0.4,1,0.75,0.254545455,1,3,18.58333333,6,2.1667,0,"

package org.apache.tools.ant.types.resources;

import java.io.File;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import java.util.Iterator;
import java.util.Collection;
import java.util.Collections;
import java.util.AbstractCollection;
import java.util.NoSuchElementException;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.ResourceCollection;


public class Resources extends DataType implements ResourceCollection {
    
    public static final ResourceCollection NONE = new ResourceCollection() {
        public boolean isFilesystemOnly() {
            return true;
        }
        public Iterator iterator() {
            return EMPTY_ITERATOR;
        }
        public int size() {
            return 0;
        }
    };

    
    public static final Iterator EMPTY_ITERATOR = new Iterator() {
        public Object next() {
            throw new NoSuchElementException();
        }
        public boolean hasNext() {
            return false;
        }
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };

    private class MyCollection extends AbstractCollection {
        private int size;

        MyCollection() {
            size = 0;
            for (Iterator rci = getNested().iterator(); rci.hasNext();) {
                size += ((ResourceCollection) rci.next()).size();
            }
        }
        public int size() {
            return size;
        }
        public Iterator iterator() {
            return new MyIterator();
        }
        private class MyIterator implements Iterator {
            private Iterator rci = getNested().iterator();
            private Iterator ri = null;

            public boolean hasNext() {
                boolean result = ri != null && ri.hasNext();
                while (!result && rci.hasNext()) {
                    ri = ((ResourceCollection) rci.next()).iterator();
                    result = ri.hasNext();
                }
                return result;
            }
            public Object next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return ri.next();
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        }
    }

    private Vector rc;
    private Collection coll;

    
    public synchronized void add(ResourceCollection c) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (c == null) {
            return;
        }
        if (rc == null) {
            rc = new Vector();
        }
        rc.add(c);
        FailFast.invalidate(this);
        coll = null;
        setChecked(false);
    }

    
    public synchronized Iterator iterator() {
        if (isReference()) {
            return getRef().iterator();
        }
        validate();
        return new FailFast(this, coll.iterator());
    }

    
    public synchronized int size() {
        if (isReference()) {
            return getRef().size();
        }
        validate();
        return coll.size();
    }

    
    public boolean isFilesystemOnly() {
        if (isReference()) {
            return getRef().isFilesystemOnly();
        }
        validate();

        for (Iterator i = getNested().iterator(); i.hasNext();) {
            if ((!((ResourceCollection) i.next()).isFilesystemOnly())) {
                return false;
            }
        }
        return true;
    }

    
    public synchronized String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        if (coll == null || coll.isEmpty()) {
            return """";
        }
        StringBuffer sb = new StringBuffer();
        for (Iterator i = coll.iterator(); i.hasNext();) {
            if (sb.length() > 0) {
                sb.append(File.pathSeparatorChar);
            }
            sb.append(i.next());
        }
        return sb.toString();
    }

    
    protected void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            for (Iterator i = getNested().iterator(); i.hasNext();) {
                Object o = i.next();
                if (o instanceof DataType) {
                    invokeCircularReferenceCheck((DataType) o, stk, p);
                }
            }
            setChecked(true);
        }
    }

    
    private ResourceCollection getRef() {
        return (ResourceCollection) getCheckedRef(
            ResourceCollection.class, ""ResourceCollection"");
    }

    private synchronized void validate() {
        dieOnCircularReference();
        coll = (coll == null) ? new MyCollection() : coll;
    }

    private synchronized List getNested() {
        return rc == null ? Collections.EMPTY_LIST : rc;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ssh.ScpFromMessage,9,2,1,6,50,24,2,4,5,0.85,404,1.0,0,0.6875,0.458333333,1,3,43.33333333,2,0.6667,1,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import java.io.File;
import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.ByteArrayOutputStream;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.Channel;


public class ScpFromMessage extends AbstractSshMessage {

    private static final byte LINE_FEED = 0x0a;
    private static final int BUFFER_SIZE = 1024;

    private String remoteFile;
    private File localFile;
    private boolean isRecursive = false;

    
    public ScpFromMessage(Session session) {
        super(session);
    }

    
    public ScpFromMessage(boolean verbose, Session session) {
        super(verbose, session);
    }

    
    public ScpFromMessage(boolean verbose,
                          Session session,
                          String aRemoteFile,
                          File aLocalFile,
                          boolean recursive) {
        super(verbose, session);
        this.remoteFile = aRemoteFile;
        this.localFile = aLocalFile;
        this.isRecursive = recursive;
    }

    
    public ScpFromMessage(Session session,
                           String aRemoteFile,
                           File aLocalFile,
                           boolean recursive) {
        this(false, session, aRemoteFile, aLocalFile, recursive);
    }

    
    public void execute() throws IOException, JSchException {
        String command = ""scp -f "";
        if (isRecursive) {
            command += ""-r "";
        }
        command += remoteFile;
        Channel channel = openExecChannel(command);
        try {
            
            OutputStream out = channel.getOutputStream();
            InputStream in = channel.getInputStream();

            channel.connect();

            sendAck(out);
            startRemoteCpProtocol(in, out, localFile);
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
        }
        log(""done\n"");
    }

    private void startRemoteCpProtocol(InputStream in,
                                       OutputStream out,
                                       File localFile) throws IOException {
        File startFile = localFile;
        while (true) {
            
            
            
            ByteArrayOutputStream stream = new ByteArrayOutputStream();
            while (true) {
                int read = in.read();
                if (read < 0) {
                    return;
                }
                if ((byte) read == LINE_FEED) {
                    break;
                }
                stream.write(read);
            }
            String serverResponse = stream.toString(""UTF-8"");
            if (serverResponse.charAt(0) == 'C') {
                parseAndFetchFile(serverResponse, startFile, out, in);
            } else if (serverResponse.charAt(0) == 'D') {
                startFile = parseAndCreateDirectory(serverResponse,
                        startFile);
                sendAck(out);
            } else if (serverResponse.charAt(0) == 'E') {
                startFile = startFile.getParentFile();
                sendAck(out);
            } else if (serverResponse.charAt(0) == '\01'
                    || serverResponse.charAt(0) == '\02') {
                
                throw new IOException(serverResponse.substring(1));
            }
        }
    }

    private File parseAndCreateDirectory(String serverResponse,
                                         File localFile) {
        int start = serverResponse.indexOf("" "");
        
        start = serverResponse.indexOf("" "", start + 1);
        String directoryName = serverResponse.substring(start + 1);
        if (localFile.isDirectory()) {
            File dir = new File(localFile, directoryName);
            dir.mkdir();
            log(""Creating: "" + dir);
            return dir;
        }
        return null;
    }

    private void parseAndFetchFile(String serverResponse,
                                   File localFile,
                                   OutputStream out,
                                   InputStream in) throws IOException {
        int start = 0;
        int end = serverResponse.indexOf("" "", start + 1);
        start = end + 1;
        end = serverResponse.indexOf("" "", start + 1);
        long filesize = Long.parseLong(serverResponse.substring(start, end));
        String filename = serverResponse.substring(end + 1);
        log(""Receiving: "" + filename + "" : "" + filesize);
        File transferFile = (localFile.isDirectory())
                ? new File(localFile, filename)
                : localFile;
        fetchFile(transferFile, filesize, out, in);
        waitForAck(in);
        sendAck(out);
    }

    private void fetchFile(File localFile,
                            long filesize,
                            OutputStream out,
                            InputStream in) throws IOException {
        byte[] buf = new byte[BUFFER_SIZE];
        sendAck(out);

        
        FileOutputStream fos = new FileOutputStream(localFile);
        int length;
        long totalLength = 0;
        long startTime = System.currentTimeMillis();

        
        boolean trackProgress = getVerbose() && filesize > 102400;
        
        
        long initFilesize = filesize;
        int percentTransmitted = 0;

        try {
            while (true) {
                length = in.read(buf, 0,
                                 (BUFFER_SIZE < filesize) ? BUFFER_SIZE
                                                          : (int) filesize);
                if (length < 0) {
                    throw new EOFException(""Unexpected end of stream."");
                }
                fos.write(buf, 0, length);
                filesize -= length;
                totalLength += length;
                if (filesize == 0) {
                    break;
                }

                if (trackProgress) {
                    percentTransmitted = trackProgress(initFilesize,
                                                       totalLength,
                                                       percentTransmitted);
                }
            }
        } finally {
            long endTime = System.currentTimeMillis();
            logStats(startTime, endTime, totalLength);
            fos.flush();
            fos.close();
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitResultFormatter,5,1,0,11,5,10,7,4,5,2.0,5,0.0,0,0.0,0.5,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.OutputStream;
import junit.framework.TestListener;
import org.apache.tools.ant.BuildException;


public interface JUnitResultFormatter
    extends TestListener, JUnitTaskMirror.JUnitResultFormatterMirror {
    
    void startTestSuite(JUnitTest suite) throws BuildException;

    
    void endTestSuite(JUnitTest suite) throws BuildException;

    
    void setOutput(OutputStream out);

    
    void setSystemOutput(String out);

    
    void setSystemError(String err);
}
"
org.apache.tools.ant.taskdefs.Ear,8,6,0,7,31,16,0,7,4,0.80952381,147,1.0,1,0.9625,0.357142857,3,9,17.0,2,0.875,1,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.ZipFileSet;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.zip.ZipOutputStream;


public class Ear extends Jar {
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private File deploymentDescriptor;
    private boolean descriptorAdded;

    
    public Ear() {
        super();
        archiveType = ""ear"";
        emptyBehavior = ""create"";
    }

    
    public void setEarfile(File earFile) {
        setDestFile(earFile);
    }

    
    public void setAppxml(File descr) {
        deploymentDescriptor = descr;
        if (!deploymentDescriptor.exists()) {
            throw new BuildException(""Deployment descriptor: ""
                                     + deploymentDescriptor
                                     + "" does not exist."");
        }

        
        ZipFileSet fs = new ZipFileSet();
        fs.setFile(deploymentDescriptor);
        fs.setFullpath(""META-INF/application.xml"");
        super.addFileset(fs);
    }


    
    public void addArchives(ZipFileSet fs) {
        
        
        fs.setPrefix(""/"");
        super.addFileset(fs);
    }


    
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException {
        
        if (deploymentDescriptor == null && !isInUpdateMode()) {
            throw new BuildException(""appxml attribute is required"", getLocation());
        }

        super.initZipOutputStream(zOut);
    }

    
    protected void zipFile(File file, ZipOutputStream zOut, String vPath,
                           int mode)
        throws IOException {
        
        
        
        
        
        if (vPath.equalsIgnoreCase(""META-INF/application.xml""))  {
            if (deploymentDescriptor == null
                || !FILE_UTILS.fileNameEquals(deploymentDescriptor, file)
                || descriptorAdded) {
                log(""Warning: selected "" + archiveType
                    + "" files include a META-INF/application.xml which will""
                    + "" be ignored (please use appxml attribute to ""
                    + archiveType + "" task)"", Project.MSG_WARN);
            } else {
                super.zipFile(file, zOut, vPath, mode);
                descriptorAdded = true;
            }
        } else {
            super.zipFile(file, zOut, vPath, mode);
        }
    }

    
    protected void cleanUp() {
        descriptorAdded = false;
        super.cleanUp();
    }
}
"
org.apache.tools.ant.util.Tokenizer,2,1,0,6,2,1,6,0,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.util;

import java.io.Reader;
import java.io.IOException;


public interface Tokenizer {
    
    String getToken(Reader in) throws IOException;

    
    String getPostToken();
}
"
org.apache.tools.ant.taskdefs.Rmic,48,4,0,25,112,962,8,19,44,0.965045593,837,0.678571429,4,0.629032258,0.155319149,3,3,15.85416667,7,1.375,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.rmi.Remote;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.rmic.RmicAdapter;
import org.apache.tools.ant.taskdefs.rmic.RmicAdapterFactory;
import org.apache.tools.ant.types.FilterSetCollection;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.SourceFileScanner;
import org.apache.tools.ant.util.facade.FacadeTaskHelper;



public class Rmic extends MatchingTask {

    
    public static final String ERROR_RMIC_FAILED
        = ""Rmic failed; see the compiler error output for details."";

    private File baseDir;
    private String classname;
    private File sourceBase;
    private String stubVersion;
    private Path compileClasspath;
    private Path extDirs;
    private boolean verify = false;
    private boolean filtering = false;

    private boolean iiop = false;
    private String  iiopOpts;
    private boolean idl  = false;
    private String  idlOpts;
    private boolean debug  = false;
    private boolean includeAntRuntime = true;
    private boolean includeJavaRuntime = false;

    private Vector compileList = new Vector();

    private ClassLoader loader = null;

    private FacadeTaskHelper facade;
    
    public static final String ERROR_UNABLE_TO_VERIFY_CLASS = ""Unable to verify class "";
    
    public static final String ERROR_NOT_FOUND = "". It could not be found."";
    
    public static final String ERROR_NOT_DEFINED = "". It is not defined."";
    
    public static final String ERROR_LOADING_CAUSED_EXCEPTION = "". Loading caused Exception: "";
    
    public static final String ERROR_NO_BASE_EXISTS = ""base does not exist: "";
    
    public static final String ERROR_NOT_A_DIR = ""base is not a directory:"";
    
    public static final String ERROR_BASE_NOT_SET = ""base attribute must be set!"";

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public Rmic() {
        facade = new FacadeTaskHelper(RmicAdapterFactory.DEFAULT_COMPILER);
    }

    
    public void setBase(File base) {
        this.baseDir = base;
    }

    

    public File getBase() {
        return this.baseDir;
    }

    
    public void setClassname(String classname) {
        this.classname = classname;
    }

    
    public String getClassname() {
        return classname;
    }

    
    public void setSourceBase(File sourceBase) {
        this.sourceBase = sourceBase;
    }

    
    public File getSourceBase() {
        return sourceBase;
    }

    
    public void setStubVersion(String stubVersion) {
        this.stubVersion = stubVersion;
    }

    
    public String getStubVersion() {
        return stubVersion;
    }

    
    public void setFiltering(boolean filter) {
        this.filtering = filter;
    }

    
    public boolean getFiltering() {
        return filtering;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public boolean getDebug() {
        return debug;
    }

    
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(getProject());
        }
        return compileClasspath.createPath();
    }

    
    public void setClasspathRef(Reference pathRef) {
        createClasspath().setRefid(pathRef);
    }

    
    public Path getClasspath() {
        return compileClasspath;
    }

    

    public void setVerify(boolean verify) {
        this.verify = verify;
    }

    
    public boolean getVerify() {
        return verify;
    }

    
    public void setIiop(boolean iiop) {
        this.iiop = iiop;
    }

    
    public boolean getIiop() {
        return iiop;
    }

    
    public void setIiopopts(String iiopOpts) {
        this.iiopOpts = iiopOpts;
    }

    
    public String getIiopopts() {
        return iiopOpts;
    }

    
    public void setIdl(boolean idl) {
        this.idl = idl;
    }

    
    public boolean getIdl() {
        return idl;
    }

    
    public void setIdlopts(String idlOpts) {
        this.idlOpts = idlOpts;
    }

    
    public String getIdlopts() {
        return idlOpts;
    }

    
    public Vector getFileList() {
        return compileList;
    }

    
    public void setIncludeantruntime(boolean include) {
        includeAntRuntime = include;
    }

    
    public boolean getIncludeantruntime() {
        return includeAntRuntime;
    }

    
    public void setIncludejavaruntime(boolean include) {
        includeJavaRuntime = include;
    }

    
    public boolean getIncludejavaruntime() {
        return includeJavaRuntime;
    }

    
    public void setExtdirs(Path extDirs) {
        if (this.extDirs == null) {
            this.extDirs = extDirs;
        } else {
            this.extDirs.append(extDirs);
        }
    }

    
    public Path createExtdirs() {
        if (extDirs == null) {
            extDirs = new Path(getProject());
        }
        return extDirs.createPath();
    }

    
    public Path getExtdirs() {
        return extDirs;
    }

    
    public Vector getCompileList() {
        return compileList;
    }

    
    public void setCompiler(String compiler) {
        if (compiler.length() > 0) {
            facade.setImplementation(compiler);
        }
    }

    
    public String getCompiler() {
        facade.setMagicValue(getProject().getProperty(""build.rmic""));
        return facade.getImplementation();
    }

    
    public ImplementationSpecificArgument createCompilerArg() {
        ImplementationSpecificArgument arg =
            new ImplementationSpecificArgument();
        facade.addImplementationArgument(arg);
        return arg;
    }

    
    public String[] getCurrentCompilerArgs() {
        getCompiler();
        return facade.getArgs();
    }

    
    public void execute() throws BuildException {
        if (baseDir == null) {
            throw new BuildException(ERROR_BASE_NOT_SET, getLocation());
        }
        if (!baseDir.exists()) {
            throw new BuildException(ERROR_NO_BASE_EXISTS + baseDir, getLocation());
        }
        if (!baseDir.isDirectory()) {
            throw new BuildException(ERROR_NOT_A_DIR + baseDir, getLocation());
        }
        if (verify) {
            log(""Verify has been turned on."", Project.MSG_VERBOSE);
        }

        RmicAdapter adapter = RmicAdapterFactory.getRmic(getCompiler(), this);

        
        adapter.setRmic(this);

        Path classpath = adapter.getClasspath();
        loader = getProject().createClassLoader(classpath);

        try {
            
            
            if (classname == null) {
                DirectoryScanner ds = this.getDirectoryScanner(baseDir);
                String[] files = ds.getIncludedFiles();
                scanDir(baseDir, files, adapter.getMapper());
            } else {
                
                scanDir(baseDir,
                        new String[] {classname.replace('.',
                                                        File.separatorChar)
                                          + "".class""},
                        adapter.getMapper());
            }

            int fileCount = compileList.size();
            if (fileCount > 0) {
                log(""RMI Compiling "" + fileCount
                    + "" class"" + (fileCount > 1 ? ""es"" : """") + "" to "" + baseDir,
                    Project.MSG_INFO);

                
                if (!adapter.execute()) {
                    throw new BuildException(ERROR_RMIC_FAILED, getLocation());
                }
            }

            
            if (null != sourceBase && !baseDir.equals(sourceBase)
                && fileCount > 0) {
                if (idl) {
                    log(""Cannot determine sourcefiles in idl mode, "",
                        Project.MSG_WARN);
                    log(""sourcebase attribute will be ignored."",
                        Project.MSG_WARN);
                } else {
                    for (int j = 0; j < fileCount; j++) {
                        moveGeneratedFile(baseDir, sourceBase,
                                          (String) compileList.elementAt(j),
                                          adapter);
                    }
                }
            }
        } finally {
            compileList.removeAllElements();
        }
    }

    
    private void moveGeneratedFile (File baseDir, File sourceBaseFile,
                                    String classname,
                                    RmicAdapter adapter)
        throws BuildException {

        String classFileName =
            classname.replace('.', File.separatorChar) + "".class"";
        String[] generatedFiles =
            adapter.getMapper().mapFileName(classFileName);

        for (int i = 0; i < generatedFiles.length; i++) {
            final String generatedFile = generatedFiles[i];
            if (!generatedFile.endsWith("".class"")) {
                
                
                continue;
            }

            final int pos = generatedFile.length() - "".class"".length();
            String sourceFileName =
                generatedFile.substring(0, pos) + "".java"";

            File oldFile = new File(baseDir, sourceFileName);
            if (!oldFile.exists()) {
                
                continue;
            }

            File newFile = new File(sourceBaseFile, sourceFileName);
            try {
                if (filtering) {
                    FILE_UTILS.copyFile(oldFile, newFile,
                        new FilterSetCollection(getProject()
                                                .getGlobalFilterSet()));
                } else {
                    FILE_UTILS.copyFile(oldFile, newFile);
                }
                oldFile.delete();
            } catch (IOException ioe) {
                String msg = ""Failed to copy "" + oldFile + "" to ""
                    + newFile + "" due to "" + ioe.getMessage();
                throw new BuildException(msg, ioe, getLocation());
            }
        }
    }

    
    protected void scanDir(File baseDir, String[] files,
                           FileNameMapper mapper) {

        String[] newFiles = files;
        if (idl) {
            log(""will leave uptodate test to rmic implementation in idl mode."",
                Project.MSG_VERBOSE);
        } else if (iiop
                   && iiopOpts != null && iiopOpts.indexOf(""-always"") > -1) {
            log(""no uptodate test as -always option has been specified"",
                Project.MSG_VERBOSE);
        } else {
            SourceFileScanner sfs = new SourceFileScanner(this);
            newFiles = sfs.restrict(files, baseDir, baseDir, mapper);
        }

        for (int i = 0; i < newFiles.length; i++) {
            String name = newFiles[i].replace(File.separatorChar, '.');
            name = name.substring(0, name.lastIndexOf("".class""));
            compileList.addElement(name);
        }
    }

    
    public boolean isValidRmiRemote(String classname) {
        try {
            Class testClass = loader.loadClass(classname);
            
            if (testClass.isInterface() && !iiop && !idl) {
                return false;
            }
            return isValidRmiRemote(testClass);
        } catch (ClassNotFoundException e) {
            log(ERROR_UNABLE_TO_VERIFY_CLASS + classname
                + ERROR_NOT_FOUND, Project.MSG_WARN);
        } catch (NoClassDefFoundError e) {
            log(ERROR_UNABLE_TO_VERIFY_CLASS + classname
                + ERROR_NOT_DEFINED, Project.MSG_WARN);
        } catch (Throwable t) {
            log(ERROR_UNABLE_TO_VERIFY_CLASS + classname
                + ERROR_LOADING_CAUSED_EXCEPTION
                + t.getMessage(), Project.MSG_WARN);
        }
        
        return false;
    }

    
    public Class getRemoteInterface(Class testClass) {
        if (Remote.class.isAssignableFrom(testClass)) {
            Class [] interfaces = testClass.getInterfaces();
            if (interfaces != null) {
                for (int i = 0; i < interfaces.length; i++) {
                    if (Remote.class.isAssignableFrom(interfaces[i])) {
                        return interfaces[i];
                    }
                }
            }
        }
        return null;
    }

    
    private boolean isValidRmiRemote (Class testClass) {
        return getRemoteInterface(testClass) != null;
    }

    
    public ClassLoader getLoader() {
        return loader;
    }

    
    public class ImplementationSpecificArgument extends
        org.apache.tools.ant.util.facade.ImplementationSpecificArgument {

        
        public void setCompiler(String impl) {
            super.setImplementation(impl);
        }
    }

}

"
org.apache.tools.ant.input.DefaultInputHandler,4,1,1,8,26,6,4,4,2,2.0,152,0.0,0,0.0,0.75,0,0,37.0,7,2.25,0,"

package org.apache.tools.ant.input;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Enumeration;
import org.apache.tools.ant.BuildException;


public class DefaultInputHandler implements InputHandler {

    
    public DefaultInputHandler() {
    }

    
    public void handleInput(InputRequest request) throws BuildException {
        String prompt = getPrompt(request);
        BufferedReader r = null;
        try {
            r = new BufferedReader(new InputStreamReader(getInputStream()));
            do {
                System.err.println(prompt);
                System.err.flush();
                try {
                    String input = r.readLine();
                    request.setInput(input);
                } catch (IOException e) {
                    throw new BuildException(""Failed to read input from""
                                             + "" Console."", e);
                }
            } while (!request.isInputValid());
        } finally {
            if (r != null) {
                try {
                    r.close();
                } catch (IOException e) {
                    throw new BuildException(""Failed to close input."", e);
                }
            }
        }
    }

    
    protected String getPrompt(InputRequest request) {
        String prompt = request.getPrompt();
        String def = request.getDefaultValue();
        if (request instanceof MultipleChoiceInputRequest) {
            StringBuffer sb = new StringBuffer(prompt);
            sb.append("" ("");
            Enumeration e =
                ((MultipleChoiceInputRequest) request).getChoices().elements();
            boolean first = true;
            while (e.hasMoreElements()) {
                if (!first) {
                    sb.append("", "");
                }
                String next = (String) e.nextElement();
                if (next.equals(def)) {
                    sb.append('[');
                }
                sb.append(next);
                if (next.equals(def)) {
                    sb.append(']');
                }
                first = false;
            }
            sb.append("")"");
            return sb.toString();
        } else if (def != null) {
            return prompt + "" ["" + def + ""]"";
        } else {
            return prompt;
        }
    }

    
    protected InputStream getInputStream() {
        return System.in;
    }

}
"
org.apache.tools.ant.util.RegexpPatternMapper,7,1,0,4,24,0,0,4,6,0.566666667,186,1.0,1,0.0,0.619047619,0,0,24.85714286,6,2.2857,1,"

package org.apache.tools.ant.util;

import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.regexp.RegexpMatcher;
import org.apache.tools.ant.util.regexp.RegexpMatcherFactory;


public class RegexpPatternMapper implements FileNameMapper {
    
    protected RegexpMatcher reg = null;
    protected char[] to = null;
    protected StringBuffer result = new StringBuffer();
    

    
    public RegexpPatternMapper() throws BuildException {
        reg = (new RegexpMatcherFactory()).newRegexpMatcher();
    }

    private boolean handleDirSep = false;
    private int     regexpOptions = 0;

    
    public void setHandleDirSep(boolean handleDirSep) {
        this.handleDirSep = handleDirSep;
    }

    
    public void setCaseSensitive(boolean caseSensitive) {
        if (!caseSensitive) {
            regexpOptions = RegexpMatcher.MATCH_CASE_INSENSITIVE;
        } else {
            regexpOptions = 0;
        }
    }

    
    public void setFrom(String from) throws BuildException {
        try {
            reg.setPattern(from);
        } catch (NoClassDefFoundError e) {
            
            
            throw new BuildException(""Cannot load regular expression matcher"",
                                     e);
        }
    }

    
    public void setTo(String to) {
        this.to = to.toCharArray();
    }

    
    public String[] mapFileName(String sourceFileName) {
        if (handleDirSep) {
            if (sourceFileName.indexOf(""\\"") != -1) {
                sourceFileName = sourceFileName.replace('\\', '/');
            }
        }
        if (reg == null  || to == null
            || !reg.matches(sourceFileName, regexpOptions)) {
            return null;
        }
        return new String[] {replaceReferences(sourceFileName)};
    }

    
    protected String replaceReferences(String source) {
        Vector v = reg.getGroups(source, regexpOptions);

        result.setLength(0);
        for (int i = 0; i < to.length; i++) {
            if (to[i] == '\\') {
                if (++i < to.length) {
                    int value = Character.digit(to[i], 10);
                    if (value > -1) {
                        result.append((String) v.elementAt(value));
                    } else {
                        result.append(to[i]);
                    }
                } else {
                    
                    result.append('\\');
                }
            } else {
                result.append(to[i]);
            }
        }
        return result.substring(0);
    }

}
"
org.apache.tools.ant.taskdefs.optional.ccm.CCMCheckinDefault,1,5,0,1,4,0,0,1,1,2.0,11,0.0,0,1.0,1.0,0,0,9.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;


public class CCMCheckinDefault extends CCMCheck {

    
    public CCMCheckinDefault() {
        super();
        setCcmAction(COMMAND_CHECKIN);
        setTask(DEFAULT_TASK);
    }

    
    public static final String DEFAULT_TASK = ""default"";
}

"
org.apache.tools.ant.taskdefs.condition.Condition,1,1,0,36,1,0,35,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;


public interface Condition {
    
    boolean eval() throws BuildException;
}

"
org.apache.tools.ant.taskdefs.optional.unix.Chgrp,4,6,0,4,16,0,0,4,3,0.333333333,52,1.0,0,0.973913043,0.75,2,2,11.75,2,1.0,0,"



package org.apache.tools.ant.taskdefs.optional.unix;

import org.apache.tools.ant.BuildException;


public class Chgrp extends AbstractAccessTask {

    private boolean haveGroup = false;

    
    public Chgrp() {
        super.setExecutable(""chgrp"");
    }

    
    public void setGroup(String group) {
        createArg().setValue(group);
        haveGroup = true;
    }

    
    protected void checkConfiguration() {
        if (!haveGroup) {
            throw new BuildException(""Required attribute group not set in ""
                                     + ""chgrp"", getLocation());
        }
        super.checkConfiguration();
    }

    
    public void setExecutable(String e) {
        throw new BuildException(getTaskType()
                                 + "" doesn\'t support the executable""
                                 + "" attribute"", getLocation());
    }
}
"
org.apache.tools.ant.taskdefs.XSLTLiaison2,1,1,0,3,1,0,2,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs;


public interface XSLTLiaison2 extends XSLTLiaison {
    
    void configure(XSLTProcess xsltTask);
}
"
org.apache.tools.ant.taskdefs.XSLTLiaison3,1,1,0,4,1,0,2,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.types.Resource;


public interface XSLTLiaison3 extends XSLTLiaison2 {
    
    void setStylesheet(Resource stylesheet) throws Exception;
}
"
org.apache.tools.ant.taskdefs.rmic.RmicAdapter,4,1,0,6,4,6,3,4,4,2.0,4,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.rmic;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Rmic;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileNameMapper;



public interface RmicAdapter {

    
    void setRmic(Rmic attributes);

    
    boolean execute() throws BuildException;

    
    FileNameMapper getMapper();

    
    Path getClasspath();
}
"
org.apache.tools.ant.util.java15.ProxyDiagnostics,3,1,0,1,23,1,0,1,3,0.666666667,121,0.666666667,0,0.0,0.666666667,0,0,38.33333333,5,1.6667,0,"

package org.apache.tools.ant.util.java15;

import org.apache.tools.ant.BuildException;

import java.net.ProxySelector;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.Proxy;
import java.net.SocketAddress;
import java.net.InetSocketAddress;
import java.net.InetAddress;
import java.util.List;
import java.util.Iterator;


public class ProxyDiagnostics {

    private String destination;

    private URI destURI;

    
    public static final String DEFAULT_DESTINATION = ""http:

    
    public ProxyDiagnostics(String destination) {
        this.destination = destination;
        try {
            this.destURI = new URI(destination);
        } catch (URISyntaxException e) {
            throw new BuildException(e);
        }
    }

    
    public ProxyDiagnostics() {
        this(DEFAULT_DESTINATION);
    }

    
    public String toString() {
        ProxySelector selector = ProxySelector.getDefault();
        List list = selector.select(destURI);
        StringBuffer result = new StringBuffer();
        Iterator proxies = list.listIterator();
        while (proxies.hasNext()) {
            Proxy proxy = (Proxy) proxies.next();
            SocketAddress address = proxy.address();
            if (address == null) {
                result.append(""Direct connection\n"");
            } else {
                result.append(proxy.toString());
                if (address instanceof InetSocketAddress) {
                    InetSocketAddress ina = (InetSocketAddress) address;
                    result.append(' ');
                    result.append(ina.getHostName());
                    result.append(':');
                    result.append(ina.getPort());
                    if (ina.isUnresolved()) {
                        result.append("" [unresolved]"");
                    } else {
                        InetAddress addr = ina.getAddress();
                        result.append("" ["");
                        result.append(addr.getHostAddress());
                        result.append(']');
                    }
                }
                result.append('\n');
            }
        }
        return result.toString();
    }



}
"
org.apache.tools.ant.taskdefs.condition.Xor,2,3,0,3,7,1,0,3,2,2.0,25,0.0,0,0.96969697,1.0,0,0,11.5,1,0.5,0,"
package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;

import java.util.Enumeration;


public class Xor extends ConditionBase implements Condition {

    
    public boolean eval() throws BuildException {
        Enumeration e = getConditions();
        
        boolean state = false;
        while (e.hasMoreElements()) {
            Condition c = (Condition) e.nextElement();
            
            state ^= c.eval();
        }
        return state;
    }

}
"
org.apache.tools.ant.util.FlatFileNameMapper,4,1,0,2,7,6,1,1,4,2.0,20,0.0,0,0.0,0.875,0,0,4.0,1,0.75,0,"

package org.apache.tools.ant.util;


public class FlatFileNameMapper implements FileNameMapper {

    
    public void setFrom(String from) {
    }

    
    public void setTo(String to) {
    }

    
    public String[] mapFileName(String sourceFileName) {
        return new String[] {new java.io.File(sourceFileName).getName()};
    }
}
"
org.apache.tools.ant.filters.util.JavaClassHelper,3,1,0,4,19,1,0,4,2,0.5,89,1.0,0,0.0,0.5,0,0,28.33333333,1,0.3333,0,"
package org.apache.tools.ant.filters.util;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import org.apache.bcel.classfile.ClassParser;
import org.apache.bcel.classfile.ConstantValue;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.JavaClass;



public final class JavaClassHelper {
    
    private static final String LS = System.getProperty(""line.separator"");

    
    public static StringBuffer getConstants(byte[] bytes)
        throws IOException {
        final StringBuffer sb = new StringBuffer();
        final ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
        final ClassParser parser = new ClassParser(bis, """");
        final JavaClass javaClass = parser.parse();
        final Field[] fields = javaClass.getFields();
        for (int i = 0; i < fields.length; i++) {
            final Field field = fields[i];
            if (field != null) {
                final ConstantValue cv = field.getConstantValue();
                if (cv != null) {
                    String cvs = cv.toString();
                    
                    if (cvs.startsWith(""\"""") && cvs.endsWith(""\"""")) {
                        cvs = cvs.substring(1, cvs.length() - 1);
                    }
                    sb.append(field.getName());
                    sb.append('=');
                    sb.append(cvs);
                    sb.append(LS);
                }
            }
        }
        return sb;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.InnerClassFilenameFilter,2,1,0,1,11,0,1,0,1,0.0,47,1.0,0,0.0,0.833333333,0,0,22.0,3,1.5,0,"
package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.FilenameFilter;


public class InnerClassFilenameFilter implements FilenameFilter {
    private String baseClassName;

    
    InnerClassFilenameFilter(String baseclass) {
        int extidx = baseclass.lastIndexOf("".class"");
        if (extidx == -1) {
            extidx = baseclass.length() - 1;
        }
        baseClassName = baseclass.substring(0, extidx);
    }

    
    public boolean accept(File dir, String filename) {
        if ((filename.lastIndexOf(""."") != filename.lastIndexOf("".class""))
            || (filename.indexOf(baseClassName + ""$"") != 0)) {
            return false;
        }
        return true;
    }
}
"
org.apache.tools.ant.types.resources.selectors.Compare,8,3,0,11,33,4,0,11,6,0.771428571,167,1.0,4,0.810810811,0.25,1,3,19.25,5,2.0,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.util.Stack;
import java.util.Iterator;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Comparison;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Quantifier;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.types.resources.comparators.ResourceComparator;
import org.apache.tools.ant.types.resources.comparators.DelegatedResourceComparator;


public class Compare extends DataType implements ResourceSelector {

    private static final String ONE_CONTROL_MESSAGE
        = "" the <control> element should be specified exactly once."";

    private DelegatedResourceComparator comp = new DelegatedResourceComparator();
    private Quantifier against = Quantifier.ALL;

    private Comparison when = Comparison.EQUAL;

    private Union control;

    
    public synchronized void add(ResourceComparator c) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        comp.add(c);
    }

    
    public synchronized void setAgainst(Quantifier against) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.against = against;
    }

    
    public synchronized void setWhen(Comparison when) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.when = when;
    }

    
    public synchronized ResourceCollection createControl() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (control != null) {
            throw oneControl();
        }
        control = new Union();
        return control;
    }

    
    
    public synchronized boolean isSelected(Resource r) {
        if (isReference()) {
            return ((ResourceSelector) getCheckedRef()).isSelected(r);
        }
        if (control == null) {
            throw oneControl();
        }
        int t = 0, f = 0;
        for (Iterator it = control.iterator(); it.hasNext();) {
            if (when.evaluate(comp.compare(r, (Resource) it.next()))) {
                t++;
            } else {
                f++;
            }
        }
        return against.evaluate(t, f);
    }

    
    protected synchronized void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            if (control != null) {
                DataType.invokeCircularReferenceCheck(control, stk, p);
            }
            DataType.invokeCircularReferenceCheck(comp, stk, p);
            setChecked(true);
        }
    }

    private BuildException oneControl() {
        return new BuildException(super.toString() + ONE_CONTROL_MESSAGE);
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.FloatCPInfo,3,3,0,2,11,3,1,1,3,2.0,25,0.0,0,0.8,0.666666667,2,2,7.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class FloatCPInfo extends ConstantCPInfo {

    
    public FloatCPInfo() {
        super(CONSTANT_FLOAT, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Float(cpStream.readFloat()));
    }

    
    public String toString() {
        return ""Float Constant Pool Entry: "" + getValue();
    }

}

"
org.apache.tools.ant.util.FileNameMapper,3,1,0,38,3,3,38,0,3,2.0,3,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.util;


public interface FileNameMapper {

    
    void setFrom(String from);

    
    void setTo(String to);

    
    String[] mapFileName(String sourceFileName);
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Counter,5,4,0,6,17,0,1,6,5,0.55,134,0.0,0,0.927272727,0.533333333,1,1,24.8,1,0.8,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;



public class P4Counter extends P4Base {
    
    
    public String counter = null;
    
    public String property = null;
    
    public boolean shouldSetValue = false;
    
    public boolean shouldSetProperty = false;
    
    public int value = 0;

    

    
    public void setName(String counter) {
        this.counter = counter;
    }

    
    public void setValue(int value) {
        this.value = value;
        shouldSetValue = true;
    }

    
    public void setProperty(String property) {
        this.property = property;
        shouldSetProperty = true;
    }

    
    public void execute() throws BuildException {

        if ((counter == null) || counter.length() == 0) {
            throw new BuildException(""No counter specified to retrieve"");
        }

        if (shouldSetValue && shouldSetProperty) {
            throw new BuildException(""Cannot both set the value of the property and retrieve the ""
                + ""value of the property."");
        }

        String command = ""counter "" + P4CmdOpts + "" "" + counter;
        if (!shouldSetProperty) {
            
            
            
            
            command = ""-s "" + command;
        }
        if (shouldSetValue) {
            command += "" "" + value;
        }

        if (shouldSetProperty) {
            final Project myProj = getProject();

            P4Handler handler = new P4HandlerAdapter() {
                public void process(String line) {
                    log(""P4Counter retrieved line \"""" + line + ""\"""", Project.MSG_VERBOSE);
                    try {
                        value = Integer.parseInt(line);
                        myProj.setProperty(property, """" + value);
                    } catch (NumberFormatException nfe) {
                        throw new BuildException(""Perforce error. ""
                        + ""Could not retrieve counter value."");
                    }
                }
            };

            execP4Command(command, handler);
        } else {
            execP4Command(command, new SimpleP4OutputHandler(this));
        }
    }
}
"
org.apache.tools.ant.types.resources.ImmutableResourceException,2,4,0,2,4,1,2,0,2,2.0,9,0.0,0,1.0,0.75,0,0,3.5,0,0.0,0,"

package org.apache.tools.ant.types.resources;

import java.io.IOException;


public class ImmutableResourceException extends IOException {

    
    public ImmutableResourceException() {
        super();
    }

    
    public ImmutableResourceException(String s) {
        super(s);
    }

}
"
org.apache.tools.ant.taskdefs.optional.ejb.BorlandGenerateClient,14,3,0,9,52,15,1,8,10,0.730769231,468,0.0,1,0.74,0.214285714,2,2,31.85714286,2,1.0714,0,"


package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.ExecTask;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;


public class BorlandGenerateClient extends Task {
    static final String JAVA_MODE = ""java"";
    static final String FORK_MODE = ""fork"";

    
    
    boolean debug = false;

    
    File ejbjarfile = null;

    
    File clientjarfile = null;

    
    Path classpath;

    
    String mode = FORK_MODE;

    
    int version = BorlandDeploymentTool.BAS;
    

    
    public void setVersion(int version) {
        this.version = version;
    }

    
    public void setMode(String s) {
        mode = s;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public void setEjbjar(File ejbfile) {
        ejbjarfile = ejbfile;
    }

    
    public void setClientjar(File clientjar) {
        clientjarfile = clientjar;
    }

    
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }


    
    public void execute() throws BuildException {
        if (ejbjarfile == null || ejbjarfile.isDirectory()) {
            throw new BuildException(""invalid ejb jar file."");
        }

        if (clientjarfile == null || clientjarfile.isDirectory()) {
            log(""invalid or missing client jar file."", Project.MSG_VERBOSE);
            String ejbjarname = ejbjarfile.getAbsolutePath();
            
            String clientname = ejbjarname.substring(0, ejbjarname.lastIndexOf("".""));
            clientname = clientname + ""client.jar"";
            clientjarfile = new File(clientname);
        }

        if (mode == null) {
            log(""mode is null default mode  is java"");
            setMode(JAVA_MODE);
        }

        if (!(version == BorlandDeploymentTool.BES
            || version == BorlandDeploymentTool.BAS)) {
            throw new BuildException(""version "" + version
                                      + "" is not supported"");
        }

        log(""client jar file is "" + clientjarfile);

        if (mode.equalsIgnoreCase(FORK_MODE)) {
            executeFork();
        } else {
            executeJava();
        } 
    }

    
    protected void executeJava() throws BuildException {
        try {
            if (version == BorlandDeploymentTool.BES)  {
                throw new BuildException(""java mode is supported only for ""
                    + ""previous version <="" + BorlandDeploymentTool.BAS);
            }

            log(""mode : java"");

            Java execTask = null;
            execTask = new Java(this);

            execTask.setDir(new File("".""));
            execTask.setClassname(""com.inprise.server.commandline.EJBUtilities"");
            
            
            
            execTask.setClasspath(classpath.concatSystemClasspath());

            execTask.setFork(true);
            execTask.createArg().setValue(""generateclient"");
            if (debug) {
                execTask.createArg().setValue(""-trace"");
            }

            execTask.createArg().setValue(""-short"");
            execTask.createArg().setValue(""-jarfile"");
            
            execTask.createArg().setValue(ejbjarfile.getAbsolutePath());
            
            execTask.createArg().setValue(""-single"");
            execTask.createArg().setValue(""-clientjarfile"");
            execTask.createArg().setValue(clientjarfile.getAbsolutePath());

            log(""Calling EJBUtilities"", Project.MSG_VERBOSE);
            execTask.execute();

        } catch (Exception e) {
            
            String msg = ""Exception while calling generateclient Details: "" + e.toString();
            throw new BuildException(msg, e);
        }
    }

    
    protected  void executeFork() throws BuildException {
        if (version == BorlandDeploymentTool.BAS) {
            executeForkV4();
        }
        if (version == BorlandDeploymentTool.BES) {
            executeForkV5();
        }
    }

    
    protected  void executeForkV4() throws BuildException {
        try {

            log(""mode : fork "" + BorlandDeploymentTool.BAS, Project.MSG_DEBUG);

            ExecTask execTask = new ExecTask(this);

            execTask.setDir(new File("".""));
            execTask.setExecutable(""iastool"");
            execTask.createArg().setValue(""generateclient"");
            if (debug) {
                execTask.createArg().setValue(""-trace"");
            }

            execTask.createArg().setValue(""-short"");
            execTask.createArg().setValue(""-jarfile"");
            
            execTask.createArg().setValue(ejbjarfile.getAbsolutePath());
            
            execTask.createArg().setValue(""-single"");
            execTask.createArg().setValue(""-clientjarfile"");
            execTask.createArg().setValue(clientjarfile.getAbsolutePath());

            log(""Calling iastool"", Project.MSG_VERBOSE);
            execTask.execute();
        } catch (Exception e) {
            
            String msg = ""Exception while calling generateclient Details: ""
                + e.toString();
            throw new BuildException(msg, e);
        }

    }

    
    protected  void executeForkV5() throws BuildException {
        try {
            log(""mode : fork "" + BorlandDeploymentTool.BES, Project.MSG_DEBUG);
            ExecTask execTask = new ExecTask(this);

            execTask.setDir(new File("".""));

            execTask.setExecutable(""iastool"");
            if (debug) {
                execTask.createArg().setValue(""-debug"");
            }
            execTask.createArg().setValue(""-genclient"");
            execTask.createArg().setValue(""-jars"");
            
            execTask.createArg().setValue(ejbjarfile.getAbsolutePath());
            
            execTask.createArg().setValue(""-target"");
            execTask.createArg().setValue(clientjarfile.getAbsolutePath());
            
            execTask.createArg().setValue(""-cp"");
            execTask.createArg().setValue(classpath.toString());
            log(""Calling iastool"", Project.MSG_VERBOSE);
            execTask.execute();
        } catch (Exception e) {
            
            String msg = ""Exception while calling generateclient Details: ""
                + e.toString();
            throw new BuildException(msg, e);
        }

    }

}
"
org.apache.tools.ant.util.optional.NoExitSecurityManager,3,2,0,1,5,3,0,1,3,2.0,12,0.0,0,0.954545455,0.555555556,1,12,3.0,1,0.6667,0,"
package org.apache.tools.ant.util.optional;

import java.security.Permission;
import org.apache.tools.ant.ExitException;


public class NoExitSecurityManager extends SecurityManager {

    
    public void checkExit(int status) {
        throw new ExitException(status);
    }

    
    public void checkPermission(Permission perm) {
        
    }
}
"
org.apache.tools.ant.filters.util.ChainReaderHelper,9,1,0,17,39,10,6,11,8,0.875,353,0.25,1,0.0,0.277777778,0,0,37.33333333,3,1.1111,1,"
package org.apache.tools.ant.filters.util;

import java.io.FilterReader;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Vector;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.filters.BaseFilterReader;
import org.apache.tools.ant.filters.ChainableReader;
import org.apache.tools.ant.types.AntFilterReader;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.Parameterizable;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileUtils;


public final class ChainReaderHelper {

    
    private static final int DEFAULT_BUFFER_SIZE = 8192;
    
    
    public Reader primaryReader;

    
    public int bufferSize = DEFAULT_BUFFER_SIZE;

    
    public Vector filterChains = new Vector();

    
    private Project project = null;

    

    
    public void setPrimaryReader(Reader rdr) {
        primaryReader = rdr;
    }

    
    public void setProject(final Project project) {
        this.project = project;
    }

    
    public Project getProject() {
        return project;
    }

    
    public void setBufferSize(int size) {
        bufferSize = size;
    }

    
    public void setFilterChains(Vector fchain) {
        filterChains = fchain;
    }

    
    public Reader getAssembledReader() throws BuildException {
        if (primaryReader == null) {
            throw new BuildException(""primaryReader must not be null."");
        }

        Reader instream = primaryReader;
        final int filterReadersCount = filterChains.size();
        final Vector finalFilters = new Vector();

        for (int i = 0; i < filterReadersCount; i++) {
            final FilterChain filterchain =
                (FilterChain) filterChains.elementAt(i);
            final Vector filterReaders = filterchain.getFilterReaders();
            final int readerCount = filterReaders.size();
            for (int j = 0; j < readerCount; j++) {
                finalFilters.addElement(filterReaders.elementAt(j));
            }
        }

        final int filtersCount = finalFilters.size();

        if (filtersCount > 0) {
            for (int i = 0; i < filtersCount; i++) {
                Object o = finalFilters.elementAt(i);

                if (o instanceof AntFilterReader) {
                    final AntFilterReader filter
                        = (AntFilterReader) finalFilters.elementAt(i);
                    final String className = filter.getClassName();
                    final Path classpath = filter.getClasspath();
                    final Project pro = filter.getProject();
                    if (className != null) {
                        try {
                            Class clazz = null;
                            if (classpath == null) {
                                clazz = Class.forName(className);
                            } else {
                                AntClassLoader al
                                    = pro.createClassLoader(classpath);
                                clazz = Class.forName(className, true, al);
                            }
                            if (clazz != null) {
                                if (!FilterReader.class.isAssignableFrom(clazz)) {
                                    throw new BuildException(className
                                        + "" does not extend java.io.FilterReader"");
                                }
                                final Constructor[] constructors =
                                    clazz.getConstructors();
                                int j = 0;
                                boolean consPresent = false;
                                for (; j < constructors.length; j++) {
                                    Class[] types = constructors[j]
                                                      .getParameterTypes();
                                    if (types.length == 1
                                        && types[0].isAssignableFrom(Reader.class)) {
                                        consPresent = true;
                                        break;
                                    }
                                }
                                if (!consPresent) {
                                    throw new BuildException(className
                                        + "" does not define a public constructor""
                                        + "" that takes in a Reader as its ""
                                        + ""single argument."");
                                }
                                final Reader[] rdr = {instream};
                                instream =
                                    (Reader) constructors[j].newInstance((Object[]) rdr);
                                setProjectOnObject(instream);
                                if (Parameterizable.class.isAssignableFrom(clazz)) {
                                    final Parameter[] params = filter.getParams();
                                    ((Parameterizable)
                                        instream).setParameters(params);
                                }
                            }
                        } catch (final ClassNotFoundException cnfe) {
                            throw new BuildException(cnfe);
                        } catch (final InstantiationException ie) {
                            throw new BuildException(ie);
                        } catch (final IllegalAccessException iae) {
                            throw new BuildException(iae);
                        } catch (final InvocationTargetException ite) {
                            throw new BuildException(ite);
                        }
                    }
                } else if (o instanceof ChainableReader) {
                    setProjectOnObject(o);
                    instream = ((ChainableReader) o).chain(instream);
                    setProjectOnObject(instream);
                }
            }
        }
        return instream;
    }

    
    private void setProjectOnObject(Object obj) {
        if (project == null) {
            return;
        }
        if (obj instanceof BaseFilterReader) {
            ((BaseFilterReader) obj).setProject(project);
            return;
        }
        project.setProjectReference(obj);
    }

    
    public String readFully(Reader rdr)
        throws IOException {
        return FileUtils.readFully(rdr, bufferSize);
    }
}
"
org.apache.tools.ant.taskdefs.ManifestException,1,3,0,6,2,0,6,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
package org.apache.tools.ant.taskdefs;


public class ManifestException extends Exception {

    
    public ManifestException(String msg) {
        super(msg);
    }
}
"
org.apache.tools.ant.taskdefs.ExecuteWatchdog,9,1,0,17,23,0,14,3,8,0.5,141,1.0,1,0.0,0.288888889,0,0,14.11111111,4,1.3333,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.TimeoutObserver;
import org.apache.tools.ant.util.Watchdog;


public class ExecuteWatchdog implements TimeoutObserver {

    
    private Process process;

    
    private volatile boolean watch = false;

    
    private Exception caught = null;

    
    private volatile boolean killedProcess = false;

    
    private Watchdog watchdog;

    
    public ExecuteWatchdog(long timeout) {
        watchdog = new Watchdog(timeout);
        watchdog.addTimeoutObserver(this);
    }

    
    public ExecuteWatchdog(int timeout) {
        this((long) timeout);
    }

    
    public synchronized void start(Process process) {
        if (process == null) {
            throw new NullPointerException(""process is null."");
        }
        if (this.process != null) {
            throw new IllegalStateException(""Already running."");
        }
        this.caught = null;
        this.killedProcess = false;
        this.watch = true;
        this.process = process;
        watchdog.start();
    }

    
    public synchronized void stop() {
        watchdog.stop();
        cleanUp();
    }

    
    public synchronized void timeoutOccured(Watchdog w) {
        try {
            try {
                
                
                process.exitValue();
            } catch (IllegalThreadStateException itse) {
                
                
                if (watch) {
                    killedProcess = true;
                    process.destroy();
                }
            }
        } catch (Exception e) {
            caught = e;
        } finally {
            cleanUp();
        }
    }

    
    protected synchronized void cleanUp() {
        watch = false;
        process = null;
    }

    
    public synchronized void checkException() throws BuildException {
        if (caught != null) {
            throw new BuildException(""Exception in ExecuteWatchdog.run: ""
                                     + caught.getMessage(), caught);
        }
    }

    
    public boolean isWatching() {
        return watch;
    }

    
    public boolean killedProcess() {
        return killedProcess;
    }
}

"
org.apache.tools.ant.util.TeeOutputStream,6,2,0,4,12,0,4,0,6,0.0,70,1.0,0,0.5,0.458333333,1,1,10.33333333,1,0.8333,0,"

package org.apache.tools.ant.util;

import java.io.OutputStream;
import java.io.IOException;


public class TeeOutputStream extends OutputStream {
    private OutputStream left;
    private OutputStream right;

    
    public TeeOutputStream(OutputStream left, OutputStream right) {
        this.left = left;
        this.right = right;
    }

    
    public void close() throws IOException {
        try {
            left.close();
        } finally {
            right.close();
        }
    }

    
    public void flush() throws IOException {
        left.flush();
        right.flush();
    }

    
    public void write(byte[] b) throws IOException {
        left.write(b);
        right.write(b);
    }

    
    public void write(byte[] b, int off, int len) throws IOException {
        left.write(b, off, len);
        right.write(b, off, len);
    }

    
    public void write(int b) throws IOException {
        left.write(b);
        right.write(b);
    }
}

"
org.apache.tools.ant.taskdefs.optional.perforce.P4Handler,2,1,0,20,2,1,18,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;


public interface P4Handler extends ExecuteStreamHandler {

    
    void process(String line) throws BuildException;

    
    void setOutput(String line) throws BuildException;
}
"
org.apache.tools.ant.taskdefs.optional.clearcase.CCMkattr,22,4,0,8,46,189,0,8,16,0.919413919,333,0.538461538,0,0.695652174,0.397727273,2,3,13.54545455,8,1.5455,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.taskdefs.condition.Os;


public class CCMkattr extends ClearCase {
    private boolean mReplace = false;
    private boolean mRecurse = false;
    private String mVersion = null;
    private String mTypeName = null;
    private String mTypeValue = null;
    private String mComment = null;
    private String mCfile = null;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getTypeName() == null) {
            throw new BuildException(""Required attribute TypeName not specified"");
        }
        if (getTypeValue() == null) {
            throw new BuildException(""Required attribute TypeValue not specified"");
        }
        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_MKATTR);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }

        
        

        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getReplace()) {
            
            cmd.createArgument().setValue(FLAG_REPLACE);
        }

        if (getRecurse()) {
            
            cmd.createArgument().setValue(FLAG_RECURSE);
        }

        if (getVersion() != null) {
            
            getVersionCommand(cmd);
        }

        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        if (getTypeName() != null) {
            
            getTypeCommand(cmd);
        }
        if (getTypeValue() != null) {
            
            getTypeValueCommand(cmd);
        }
        
        cmd.createArgument().setValue(getViewPath());
    }


    
    public void setReplace(boolean replace) {
        mReplace = replace;
    }

    
    public boolean getReplace() {
        return mReplace;
    }

    
    public void setRecurse(boolean recurse) {
        mRecurse = recurse;
    }

    
    public boolean getRecurse() {
        return mRecurse;
    }

    
    public void setVersion(String version) {
        mVersion = version;
    }

    
    public String getVersion() {
        return mVersion;
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setTypeName(String tn) {
        mTypeName = tn;
    }

    
    public String getTypeName() {
        return mTypeName;
    }

    
    public void setTypeValue(String tv) {
        mTypeValue = tv;
    }

    
    public String getTypeValue() {
        return mTypeValue;
    }


    
    private void getVersionCommand(Commandline cmd) {
        if (getVersion() != null) {
            
            cmd.createArgument().setValue(FLAG_VERSION);
            cmd.createArgument().setValue(getVersion());
        }
    }

    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }

    
    private void getTypeCommand(Commandline cmd) {
        String typenm = getTypeName();

        if (typenm != null) {
            cmd.createArgument().setValue(typenm);
        }
    }

    
    private void getTypeValueCommand(Commandline cmd) {
        String typevl = getTypeValue();

        if (typevl != null) {
            if (Os.isFamily(""windows"")) {
                typevl = ""\\\"""" + typevl + ""\\\""""; 
            } else {
                typevl = ""\"""" + typevl + ""\"""";
            }
            cmd.createArgument().setValue(typevl);
        }
    }

    
    public static final String FLAG_REPLACE = ""-replace"";
    
    public static final String FLAG_RECURSE = ""-recurse"";
    
    public static final String FLAG_VERSION = ""-version"";
    
    public static final String FLAG_COMMENT = ""-c"";
    
    public static final String FLAG_COMMENTFILE = ""-cfile"";
    
    public static final String FLAG_NOCOMMENT = ""-nc"";
}

"
org.apache.tools.ant.util.regexp.RegexpFactory,4,2,0,7,18,6,1,6,3,2.0,119,0.0,0,0.625,0.5,0,0,28.75,1,0.75,0,"
package org.apache.tools.ant.util.regexp;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.JavaEnvUtils;


public class RegexpFactory extends RegexpMatcherFactory {

    
    public RegexpFactory() {
    }

    
    public Regexp newRegexp() throws BuildException {
        return (Regexp) newRegexp(null);
    }

    
    public Regexp newRegexp(Project p) throws BuildException {
        String systemDefault = null;
        if (p == null) {
            systemDefault = System.getProperty(""ant.regexp.regexpimpl"");
        } else {
            systemDefault = p.getProperty(""ant.regexp.regexpimpl"");
        }

        if (systemDefault != null) {
            return createRegexpInstance(systemDefault);
            
            
        }

        Throwable cause = null;

        try {
            testAvailability(""java.util.regex.Matcher"");
            return createRegexpInstance(""org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp"");
        } catch (BuildException be) {
            cause = orCause(cause, be, JavaEnvUtils.getJavaVersionNumber() < 14);
        }

        try {
            testAvailability(""org.apache.oro.text.regex.Pattern"");
            return createRegexpInstance(""org.apache.tools.ant.util.regexp.JakartaOroRegexp"");
        } catch (BuildException be) {
            cause = orCause(cause, be, true);
        }

        try {
            testAvailability(""org.apache.regexp.RE"");
            return createRegexpInstance(""org.apache.tools.ant.util.regexp.JakartaRegexpRegexp"");
        } catch (BuildException be) {
            cause = orCause(cause, be, true);
        }

        throw new BuildException(
            ""No supported regular expression matcher found""
            + (cause != null ? "": "" + cause : """"), cause);
    }

    
    protected Regexp createRegexpInstance(String classname)
        throws BuildException {

        RegexpMatcher m = createInstance(classname);
        if (m instanceof Regexp) {
            return (Regexp) m;
        } else {
            throw new BuildException(classname + "" doesn't implement the Regexp interface"");
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.extension.LibFileSet,7,5,0,3,8,15,2,1,4,0.833333333,34,1.0,0,0.93814433,0.476190476,0,0,3.428571429,1,0.8571,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import org.apache.tools.ant.types.FileSet;


public class LibFileSet
    extends FileSet {
    
    private boolean includeURL;

    
    private boolean includeImpl;

    
    private String urlBase;

    
    public void setIncludeUrl(boolean includeURL) {
        this.includeURL = includeURL;
    }

    
    public void setIncludeImpl(boolean includeImpl) {
        this.includeImpl = includeImpl;
    }

    
    public void setUrlBase(String urlBase) {
        this.urlBase = urlBase;
    }

    
    boolean isIncludeURL() {
        return includeURL;
    }

    
    boolean isIncludeImpl() {
        return includeImpl;
    }

    
    String getUrlBase() {
        return urlBase;
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.Compatibility,2,1,0,2,3,0,2,0,1,0.0,12,1.0,0,0.0,0.75,0,0,4.5,1,0.5,0,"
package org.apache.tools.ant.taskdefs.optional.extension;


public final class Compatibility {
    
    private final String name;

    
    Compatibility(final String name) {
        this.name = name;
    }

    
    public String toString() {
        return name;
    }
}
"
org.apache.tools.ant.types.resources.StringResource,17,4,0,8,41,104,3,6,14,0.8125,185,1.0,0,0.791044776,0.328125,2,10,9.764705882,4,1.2941,0,"

package org.apache.tools.ant.types.resources;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FilterOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Reference;


public class StringResource extends Resource {

    
    private static final int STRING_MAGIC
        = Resource.getMagicNumber(""StringResource"".getBytes());

    private String encoding = null;

    
    public StringResource() {
    }

    
    public StringResource(String value) {
        setValue(value);
    }

    
    public synchronized void setName(String s) {
        if (getName() != null) {
            throw new BuildException(new ImmutableResourceException());
        }
        super.setName(s);
    }

    
    public synchronized void setValue(String s) {
        setName(s);
    }

    
    public synchronized String getName() {
        return super.getName();
    }

    
    public synchronized String getValue() {
        return getName();
    }

    
    public synchronized void setEncoding(String s) {
        encoding = s;
    }

    
    public synchronized String getEncoding() {
        return encoding;
    }

    
    public synchronized long getSize() {
        return isReference()
            ? ((Resource) getCheckedRef()).getSize()
            : (long) getContent().length();
    }

    
    public synchronized int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        return super.hashCode() * STRING_MAGIC;
    }

    
    public String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        return String.valueOf(getContent());
    }

    
    public synchronized InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        
        return
            
            new ByteArrayInputStream(getContent().getBytes());
            
    }

    
    public synchronized OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        if (getValue() != null) {
            throw new ImmutableResourceException();
        }
        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
        return new FilterOutputStream(baos) {
            public void close() throws IOException {
                super.close();
                StringResource.this.setValue(encoding == null
                    ? baos.toString() : baos.toString(encoding));
            }
        };
    }

    
    public void setRefid(Reference r) {
        if (encoding != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    protected synchronized String getContent() {
        if (isReference()) {
            return ((StringResource) getCheckedRef()).getContent();
        }
        String value = getValue();
        if (value == null) {
            return value;
        }
        return getProject() == null
            ? value : getProject().replaceProperties(value);
    }

}
"
org.apache.tools.ant.filters.TokenFilter,19,4,0,19,41,23,5,17,19,0.688888889,319,1.0,1,0.604651163,0.119298246,2,4,15.52631579,6,1.2105,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.util.Vector;
import java.util.Enumeration;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.types.RegularExpression;
import org.apache.tools.ant.types.Substitution;
import org.apache.tools.ant.util.Tokenizer;
import org.apache.tools.ant.util.LineTokenizer;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.util.regexp.Regexp;


public class TokenFilter extends BaseFilterReader
    implements ChainableReader {
    
    public interface Filter {
        
        String filter(String string);
    }


    
    private Vector    filters   = new Vector();
    
    private Tokenizer tokenizer = null;
    
    private String    delimOutput = null;
    
    private String    line      = null;
    
    private int       linePos   = 0;

    
    public TokenFilter() {
        super();
    }

    
    public TokenFilter(final Reader in) {
        super(in);
    }


    

    public int read() throws IOException {
        if (tokenizer == null) {
            tokenizer = new LineTokenizer();
        }
        while (line == null || line.length() == 0) {
            line = tokenizer.getToken(in);
            if (line == null) {
                return -1;
            }
            for (Enumeration e = filters.elements(); e.hasMoreElements();) {
                Filter filter = (Filter) e.nextElement();
                line = filter.filter(line);
                if (line == null) {
                    break;
                }
            }
            linePos = 0;
            if (line != null) {
                if (tokenizer.getPostToken().length() != 0) {
                    if (delimOutput != null) {
                        line = line + delimOutput;
                    } else {
                        line = line + tokenizer.getPostToken();
                    }
                }
            }
        }
        int ch = line.charAt(linePos);
        linePos++;
        if (linePos == line.length()) {
            line = null;
        }
        return ch;
    }

    

    public final Reader chain(final Reader reader) {
        TokenFilter newFilter = new TokenFilter(reader);
        newFilter.filters = filters;
        newFilter.tokenizer = tokenizer;
        newFilter.delimOutput = delimOutput;
        newFilter.setProject(getProject());
        return newFilter;
    }

    

    public void setDelimOutput(String delimOutput) {
        this.delimOutput = resolveBackSlash(delimOutput);
    }

    
    
    

    

    public void addLineTokenizer(LineTokenizer tokenizer) {
        add(tokenizer);
    }

    

    public void addStringTokenizer(StringTokenizer tokenizer) {
        add(tokenizer);
    }

    
    public void addFileTokenizer(FileTokenizer tokenizer) {
        add(tokenizer);
    }

    

    public void add(Tokenizer tokenizer) {
        if (this.tokenizer != null) {
            throw new BuildException(""Only one tokenizer allowed"");
        }
        this.tokenizer = tokenizer;
    }

    
    
    

    
    public void addReplaceString(ReplaceString filter) {
        filters.addElement(filter);
    }

    
    public void addContainsString(ContainsString filter) {
        filters.addElement(filter);
    }

    
    public void addReplaceRegex(ReplaceRegex filter) {
        filters.addElement(filter);
    }

    
    public void addContainsRegex(ContainsRegex filter) {
        filters.addElement(filter);
    }

    
    public void addTrim(Trim filter) {
        filters.addElement(filter);
    }

    
    public void addIgnoreBlank(IgnoreBlank filter) {
        filters.addElement(filter);
    }

    
    public void addDeleteCharacters(DeleteCharacters filter) {
        filters.addElement(filter);
    }

    
    public void add(Filter filter) {
        filters.addElement(filter);
    }


    
    
    
    
    

    
    public static class FileTokenizer
        extends org.apache.tools.ant.util.FileTokenizer {
    }

    
    public static class StringTokenizer
        extends org.apache.tools.ant.util.StringTokenizer {
    }

    
    
    
    
    

    
    public abstract static class ChainableReaderFilter extends ProjectComponent
        implements ChainableReader, Filter {
        private boolean byLine = true;

        
        public void setByLine(boolean byLine) {
            this.byLine = byLine;
        }

        
        public Reader chain(Reader reader) {
            TokenFilter tokenFilter = new TokenFilter(reader);
            if (!byLine) {
                tokenFilter.add(new FileTokenizer());
            }
            tokenFilter.add(this);
            return tokenFilter;
        }
    }

    
    public static class ReplaceString extends ChainableReaderFilter {
        private String from;
        private String to;

        
        public void setFrom(String from) {
            this.from = from;
        }

        
        public void setTo(String to) {
            this.to = to;
        }

        
        public String filter(String line) {
            if (from == null) {
                throw new BuildException(""Missing from in stringreplace"");
            }
            StringBuffer ret = new StringBuffer();
            int start = 0;
            int found = line.indexOf(from);
            while (found >= 0) {
                
                if (found > start) {
                    ret.append(line.substring(start, found));
                }

                
                if (to != null) {
                    ret.append(to);
                }

                
                start = found + from.length();
                found = line.indexOf(from, start);
            }

            
            if (line.length() > start) {
                ret.append(line.substring(start, line.length()));
            }

            return ret.toString();
        }
    }

    
    public static class ContainsString extends ProjectComponent
        implements Filter {
        private String contains;

        
        public void setContains(String contains) {
            this.contains = contains;
        }

        
        public String filter(String string) {
            if (contains == null) {
                throw new BuildException(""Missing contains in containsstring"");
            }
            if (string.indexOf(contains) > -1) {
                return string;
            }
            return null;
        }
    }

    
    public static class ReplaceRegex extends ChainableReaderFilter {
        private String             from;
        private String             to;
        private RegularExpression  regularExpression;
        private Substitution       substitution;
        private boolean            initialized = false;
        private String             flags = """";
        private int                options;
        private Regexp             regexp;

        
        public void setPattern(String from) {
            this.from = from;
        }
        
        public void setReplace(String to) {
            this.to = to;
        }

        
        public void setFlags(String flags) {
            this.flags = flags;
        }

        private void initialize() {
            if (initialized) {
                return;
            }
            options = convertRegexOptions(flags);
            if (from == null) {
                throw new BuildException(""Missing pattern in replaceregex"");
            }
            regularExpression = new RegularExpression();
            regularExpression.setPattern(from);
            regexp = regularExpression.getRegexp(getProject());
            if (to == null) {
                to = """";
            }
            substitution = new Substitution();
            substitution.setExpression(to);
        }

        
        public String filter(String line) {
            initialize();

            if (!regexp.matches(line, options)) {
                return line;
            }
            return regexp.substitute(
                line, substitution.getExpression(getProject()), options);
        }
    }

    
    public static class ContainsRegex extends ChainableReaderFilter {
        private String             from;
        private String             to;
        private RegularExpression  regularExpression;
        private Substitution       substitution;
        private boolean            initialized = false;
        private String             flags = """";
        private int                options;
        private Regexp             regexp;


        
        public void setPattern(String from) {
            this.from = from;
        }

        
        public void setReplace(String to) {
            this.to = to;
        }

        
        public void setFlags(String flags) {
            this.flags = flags;
        }

        private void initialize() {
            if (initialized) {
                return;
            }
            options = convertRegexOptions(flags);
            if (from == null) {
                throw new BuildException(""Missing from in containsregex"");
            }
            regularExpression = new RegularExpression();
            regularExpression.setPattern(from);
            regexp = regularExpression.getRegexp(getProject());
            if (to == null) {
                return;
            }
            substitution = new Substitution();
            substitution.setExpression(to);
        }

        
        public String filter(String string) {
            initialize();
            if (!regexp.matches(string, options)) {
                return null;
            }
            if (substitution == null) {
                return string;
            }
            return regexp.substitute(
                string, substitution.getExpression(getProject()), options);
        }
    }

    
    public static class Trim extends ChainableReaderFilter {
        
        public String filter(String line) {
            return line.trim();
        }
    }



    
    public static class IgnoreBlank extends ChainableReaderFilter {
        
        public String filter(String line) {
            if (line.trim().length() == 0) {
                return null;
            }
            return line;
        }
    }

    
    public static class DeleteCharacters extends ProjectComponent
        implements Filter, ChainableReader {
        
        
        private String deleteChars = """";

        
        public void setChars(String deleteChars) {
            this.deleteChars = resolveBackSlash(deleteChars);
        }

        
        public String filter(String string) {
            StringBuffer output = new StringBuffer(string.length());
            for (int i = 0; i < string.length(); ++i) {
                char ch = string.charAt(i);
                if (!(isDeleteCharacter(ch))) {
                    output.append(ch);
                }
            }
            return output.toString();
        }

        
        public Reader chain(Reader reader) {
            return new BaseFilterReader(reader) {
                
                public int read()
                    throws IOException {
                    while (true) {
                        int c = in.read();
                        if (c == -1) {
                            return c;
                        }
                        if (!(isDeleteCharacter((char) c))) {
                            return c;
                        }
                    }
                }
            };
        }

        
        private boolean isDeleteCharacter(char c) {
            for (int d = 0; d < deleteChars.length(); ++d) {
                if (deleteChars.charAt(d) ==  c) {
                    return true;
                }
            }
            return false;
        }
    }

    
    
    

    
    public static String resolveBackSlash(String input) {
        return StringUtils.resolveBackSlash(input);
    }

    
    public static int convertRegexOptions(String flags) {
        if (flags == null) {
            return 0;
        }
        int options = 0;
        if (flags.indexOf('g') != -1) {
            options |= Regexp.REPLACE_ALL;
        }
        if (flags.indexOf('i') != -1) {
            options |= Regexp.MATCH_CASE_INSENSITIVE;
        }
        if (flags.indexOf('m') != -1) {
            options |= Regexp.MATCH_MULTILINE;
        }
        if (flags.indexOf('s') != -1) {
            options |= Regexp.MATCH_SINGLELINE;
        }
        return options;
    }
}
"
org.apache.tools.ant.util.OutputStreamFunneler,12,1,0,2,21,42,2,1,4,0.654545455,146,0.8,0,0.0,0.263888889,0,0,10.75,1,0.8333,0,"

package org.apache.tools.ant.util;

import java.io.IOException;
import java.io.OutputStream;


public class OutputStreamFunneler {

    
    public static final long DEFAULT_TIMEOUT_MILLIS = 1000;

    private final class Funnel extends OutputStream {
        private boolean closed = false;

        private Funnel() {
            synchronized (OutputStreamFunneler.this) {
                ++count;
            }
        }

        public void flush() throws IOException {
            synchronized (OutputStreamFunneler.this) {
                dieIfClosed();
                out.flush();
            }
        }

        public void write(int b) throws IOException {
            synchronized (OutputStreamFunneler.this) {
                dieIfClosed();
                out.write(b);
            }
        }

        public void write(byte[] b) throws IOException {
            synchronized (OutputStreamFunneler.this) {
                dieIfClosed();
                out.write(b);
            }
        }

        public void write(byte[] b, int off, int len) throws IOException {
            synchronized (OutputStreamFunneler.this) {
                dieIfClosed();
                out.write(b, off, len);
            }
        }

        public void close() throws IOException {
            release(this);
        }
    }

    private OutputStream out;
    private int count = 0;
    private boolean closed;
    private long timeoutMillis;

    
    public OutputStreamFunneler(OutputStream out) {
        this(out, DEFAULT_TIMEOUT_MILLIS);
    }

    
    public OutputStreamFunneler(OutputStream out, long timeoutMillis) {
        if (out == null) {
            throw new IllegalArgumentException(
                ""OutputStreamFunneler.<init>:  out == null"");
        }
        this.out = out;
        this.closed = false; 
        setTimeout(timeoutMillis);
    }

    
    public synchronized void setTimeout(long timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
    }

    
    public synchronized OutputStream getFunnelInstance()
        throws IOException {
        dieIfClosed();
        try {
            return new Funnel();
        } finally {
            notifyAll();
        }
    }

    private synchronized void release(Funnel funnel) throws IOException {
        
        if (!funnel.closed) {
            try {
                if (timeoutMillis > 0) {
                    try {
                        wait(timeoutMillis);
                    } catch (InterruptedException eyeEx) {
                        
                    }
                }
                if (--count == 0) {
                    close();
                }
            } finally {
                funnel.closed = true;
            }
        }
   }

    private synchronized void close() throws IOException {
        try {
            dieIfClosed();
            out.close();
        } finally {
            closed = true;
        }
    }

    private synchronized void dieIfClosed() throws IOException {
        if (closed) {
            throw new IOException(""The funneled OutputStream has been closed."");
        }
    }

}
"
org.apache.tools.ant.taskdefs.SubAnt,31,3,0,15,109,365,0,15,27,0.888095238,778,1.0,2,0.552238806,0.114919355,1,3,23.64516129,22,2.2903,1,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;

import java.util.Vector;
import java.util.Enumeration;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;

import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.DirSet;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FileList;
import org.apache.tools.ant.types.PropertySet;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.ResourceCollection;

import org.apache.tools.ant.taskdefs.Ant.TargetElement;



public class SubAnt
             extends Task {

    private Path buildpath;

    private Ant ant = null;
    private String subTarget = null;
    private String antfile = ""build.xml"";
    private File genericantfile = null;
    private boolean verbose = false;
    private boolean inheritAll = false;
    private boolean inheritRefs = false;
    private boolean failOnError = true;
    private String output  = null;

    private Vector properties = new Vector();
    private Vector references = new Vector();
    private Vector propertySets = new Vector();

    
    private Vector targets = new Vector();

    
    public void handleOutput(String output) {
        if (ant != null) {
            ant.handleOutput(output);
        } else {
            super.handleOutput(output);
        }
    }

    
    public int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        if (ant != null) {
            return ant.handleInput(buffer, offset, length);
        } else {
            return super.handleInput(buffer, offset, length);
        }
    }

    
    public void handleFlush(String output) {
        if (ant != null) {
            ant.handleFlush(output);
        } else {
            super.handleFlush(output);
        }
    }

    
    public void handleErrorOutput(String output) {
        if (ant != null) {
            ant.handleErrorOutput(output);
        } else {
            super.handleErrorOutput(output);
        }
    }

    
    public void handleErrorFlush(String output) {
        if (ant != null) {
            ant.handleErrorFlush(output);
        } else {
            super.handleErrorFlush(output);
        }
    }

    
    public void execute() {
        if (buildpath == null) {
            throw new BuildException(""No buildpath specified"");
        }

        final String[] filenames = buildpath.list();
        final int count = filenames.length;
        if (count < 1) {
            log(""No sub-builds to iterate on"", Project.MSG_WARN);
            return;
        }

        BuildException buildException = null;
        for (int i = 0; i < count; ++i) {
            File file = null;
            String subdirPath = null;
            Throwable thrownException = null;
            try {
                File directory = null;
                file = new File(filenames[i]);
                if (file.isDirectory()) {
                    if (verbose) {
                        subdirPath = file.getPath();
                        log(""Entering directory: "" + subdirPath + ""\n"", Project.MSG_INFO);
                    }
                    if (genericantfile != null) {
                        directory = file;
                        file = genericantfile;
                    } else {
                        file = new File(file, antfile);
                    }
                }
                execute(file, directory);
                if (verbose && subdirPath != null) {
                    log(""Leaving directory: "" + subdirPath + ""\n"", Project.MSG_INFO);
                }
            } catch (RuntimeException ex) {
                if (!(getProject().isKeepGoingMode())) {
                    if (verbose && subdirPath != null) {
                        log(""Leaving directory: "" + subdirPath + ""\n"", Project.MSG_INFO);
                    }
                    throw ex; 
                }
                thrownException = ex;
            } catch (Throwable ex) {
                if (!(getProject().isKeepGoingMode())) {
                    if (verbose && subdirPath != null) {
                        log(""Leaving directory: "" + subdirPath + ""\n"", Project.MSG_INFO);
                    }
                    throw new BuildException(ex);
                }
                thrownException = ex;
            }
            if (thrownException != null) {
                if (thrownException instanceof BuildException) {
                    log(""File '"" + file
                        + ""' failed with message '""
                        + thrownException.getMessage() + ""'."", Project.MSG_ERR);
                    
                    if (buildException == null) {
                        buildException = (BuildException) thrownException;
                    }
                } else {
                    log(""Target '"" + file
                        + ""' failed with message '""
                        + thrownException.getMessage() + ""'."", Project.MSG_ERR);
                    thrownException.printStackTrace(System.err);
                    if (buildException == null) {
                        buildException =
                            new BuildException(thrownException);
                    }
                }
                if (verbose && subdirPath != null) {
                    log(""Leaving directory: "" + subdirPath + ""\n"", Project.MSG_INFO);
                }
            }
        }
        
        if (buildException != null) {
            throw buildException;
        }
    }

    
    private void execute(File file, File directory)
                throws BuildException {
        if (!file.exists() || file.isDirectory() || !file.canRead()) {
            String msg = ""Invalid file: "" + file;
            if (failOnError) {
                throw new BuildException(msg);
            }
            log(msg, Project.MSG_WARN);
            return;
        }

        ant = createAntTask(directory);
        String antfilename = file.getAbsolutePath();
        ant.setAntfile(antfilename);
        for (int i = 0; i < targets.size(); i++) {
            TargetElement targetElement = (TargetElement) targets.get(i);
            ant.addConfiguredTarget(targetElement);
        }

        try {
            ant.execute();
        } catch (BuildException e) {
            if (failOnError) {
                throw e;
            }
            log(""Failure for target '"" + subTarget
               + ""' of: "" +  antfilename + ""\n""
               + e.getMessage(), Project.MSG_WARN);
        } catch (Throwable e) {
            if (failOnError) {
                throw new BuildException(e);
            }
            log(""Failure for target '"" + subTarget
                + ""' of: "" + antfilename + ""\n""
                + e.toString(),
                Project.MSG_WARN);
        } finally {
            ant = null;
        }
    }

    
    public void setAntfile(String antfile) {
        this.antfile = antfile;
    }

    
    public void setGenericAntfile(File afile) {
        this.genericantfile = afile;
    }

    
    public void setFailonerror(boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    
    public void setTarget(String target) {
        this.subTarget = target;
    }

    
    public void addConfiguredTarget(TargetElement t) {
        String name = t.getName();
        if ("""".equals(name)) {
            throw new BuildException(""target name must not be empty"");
        }
        targets.add(t);
    }

    
    public void setVerbose(boolean on) {
        this.verbose = on;
    }

    
    public void setOutput(String s) {
        this.output = s;
    }

    
    public void setInheritall(boolean b) {
        this.inheritAll = b;
    }

    
    public void setInheritrefs(boolean b) {
        this.inheritRefs = b;
    }

    
    public void addProperty(Property p) {
        properties.addElement(p);
    }

    
    public void addReference(Ant.Reference r) {
        references.addElement(r);
    }

    
    public void addPropertyset(PropertySet ps) {
        propertySets.addElement(ps);
    }

    
    public void addDirset(DirSet set) {
        add(set);
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void addFilelist(FileList list) {
        add(list);
    }

    
    public void add(ResourceCollection rc) {
        getBuildpath().add(rc);
    }

    
    public void setBuildpath(Path s) {
        getBuildpath().append(s);
    }

    
    public Path createBuildpath() {
        return getBuildpath().createPath();
    }

    
    public Path.PathElement createBuildpathElement() {
        return getBuildpath().createPathElement();
    }

    
    private Path getBuildpath() {
        if (buildpath == null) {
            buildpath = new Path(getProject());
        }
        return buildpath;
    }

    
    public void setBuildpathRef(Reference r) {
        createBuildpath().setRefid(r);
    }

    
    private Ant createAntTask(File directory) {
        Ant antTask = new Ant(this);
        antTask.init();
        if (subTarget != null && subTarget.length() > 0) {
            antTask.setTarget(subTarget);
        }


        if (output != null) {
            antTask.setOutput(output);
        }

        if (directory != null) {
            antTask.setDir(directory);
        }

        antTask.setInheritAll(inheritAll);
        for (Enumeration i = properties.elements(); i.hasMoreElements();) {
            copyProperty(antTask.createProperty(), (Property) i.nextElement());
        }

        for (Enumeration i = propertySets.elements(); i.hasMoreElements();) {
            antTask.addPropertyset((PropertySet) i.nextElement());
        }

        antTask.setInheritRefs(inheritRefs);
        for (Enumeration i = references.elements(); i.hasMoreElements();) {
            antTask.addReference((Ant.Reference) i.nextElement());
        }

        return antTask;
    }

    
    private static void copyProperty(Property to, Property from) {
        to.setName(from.getName());

        if (from.getValue() != null) {
            to.setValue(from.getValue());
        }
        if (from.getFile() != null) {
            to.setFile(from.getFile());
        }
        if (from.getResource() != null) {
            to.setResource(from.getResource());
        }
        if (from.getPrefix() != null) {
            to.setPrefix(from.getPrefix());
        }
        if (from.getRefid() != null) {
            to.setRefid(from.getRefid());
        }
        if (from.getEnvironment() != null) {
            to.setEnvironment(from.getEnvironment());
        }
        if (from.getClasspath() != null) {
            to.setClasspath(from.getClasspath());
        }
    }

} 
"
org.apache.tools.ant.types.optional.depend.DependScanner,15,2,0,6,43,95,1,5,15,0.946428571,202,0.75,1,0.813333333,0.266666667,1,1,12.2,2,1.0667,0,"
package org.apache.tools.ant.types.optional.depend;

import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.depend.DependencyAnalyzer;



public class DependScanner extends DirectoryScanner {
    
    public static final String DEFAULT_ANALYZER_CLASS
        = ""org.apache.tools.ant.util.depend.bcel.FullAnalyzer"";

    
    private Vector rootClasses;

    
    private Vector included;

    
    private DirectoryScanner parentScanner;

    
    public DependScanner(DirectoryScanner parentScanner) {
        this.parentScanner = parentScanner;
    }

    
    public synchronized void setRootClasses(Vector rootClasses) {
        this.rootClasses = rootClasses;
    }

    
    public String[] getIncludedFiles() {
        String[] files = new String[getIncludedFilesCount()];
        for (int i = 0; i < files.length; i++) {
            files[i] = (String) included.elementAt(i);
        }
        return files;
    }

    
    public synchronized int getIncludedFilesCount() {
        if (included == null) {
            throw new IllegalStateException();
        }
        return included.size();
    }

    
    public synchronized void scan() throws IllegalStateException {
        included = new Vector();
        String analyzerClassName = DEFAULT_ANALYZER_CLASS;
        DependencyAnalyzer analyzer = null;
        try {
            Class analyzerClass = Class.forName(analyzerClassName);
            analyzer = (DependencyAnalyzer) analyzerClass.newInstance();
        } catch (Exception e) {
            throw new BuildException(""Unable to load dependency analyzer: ""
                + analyzerClassName, e);
        }
        analyzer.addClassPath(new Path(null, basedir.getPath()));

        for (Enumeration e = rootClasses.elements(); e.hasMoreElements();) {
            String rootClass = (String) e.nextElement();
            analyzer.addRootClass(rootClass);
        }
        Enumeration e = analyzer.getClassDependencies();

        String[] parentFiles = parentScanner.getIncludedFiles();
        Hashtable parentSet = new Hashtable();
        for (int i = 0; i < parentFiles.length; ++i) {
            parentSet.put(parentFiles[i], parentFiles[i]);
        }
        while (e.hasMoreElements()) {
            String classname = (String) e.nextElement();
            String filename = classname.replace('.', File.separatorChar);
            filename = filename + "".class"";
            File depFile = new File(basedir, filename);
            if (depFile.exists() && parentSet.containsKey(filename)) {
                
                included.addElement(filename);
            }
        }
    }

    
    public void addDefaultExcludes() {
    }

    
    
    public String[] getExcludedDirectories() {
        return null;
    }

    
    
    public String[] getExcludedFiles() {
        return null;
    }

    
    
    public String[] getIncludedDirectories() {
        return new String[0];
    }

    
    
    public int getIncludedDirsCount() {
        return 0;
    }

    
    
    public String[] getNotIncludedDirectories() {
        return null;
    }

    
    
    public String[] getNotIncludedFiles() {
        return null;
    }

    
    
    public void setExcludes(String[] excludes) {
    }

    
    
    public void setIncludes(String[] includes) {
    }

    
    
    public void setCaseSensitive(boolean isCaseSensitive) {
    }
}
"
org.apache.tools.ant.launch.AntMain,1,1,0,2,1,0,2,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.launch;

import java.util.Properties;


public interface AntMain {
    
    void startAnt(String[] args, Properties additionalUserProperties,
                  ClassLoader coreLoader);
}

"
org.apache.tools.ant.taskdefs.Ant,28,3,0,18,132,130,3,15,19,0.846560847,1139,0.928571429,2,0.596774194,0.151515152,3,5,39.17857143,6,1.6786,3,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;
import java.util.Set;
import java.util.HashSet;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.Main;
import org.apache.tools.ant.types.PropertySet;
import org.apache.tools.ant.util.FileUtils;


public class Ant extends Task {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private File dir = null;

    
    private String antFile = null;

    
    private String output = null;

    
    private boolean inheritAll = true;

    
    private boolean inheritRefs = false;

    
    private Vector properties = new Vector();

    
    private Vector references = new Vector();

    
    private Project newProject;

    
    private PrintStream out = null;

    
    private Vector propertySets = new Vector();

    
    private Vector targets = new Vector();

    
    private boolean targetAttributeSet = false;

    
    public Ant() {
        
    }

    
    public Ant(Task owner) {
        bindToOwner(owner);
    }


    
    public void setInheritAll(boolean value) {
        inheritAll = value;
    }

    
    public void setInheritRefs(boolean value) {
        inheritRefs = value;
    }

    
    public void init() {
        newProject = getProject().createSubProject();
        newProject.setJavaVersionProperty();
    }

    
    private void reinit() {
        init();
    }

    
    private void initializeProject() {
        newProject.setInputHandler(getProject().getInputHandler());

        Iterator iter = getBuildListeners();
        while (iter.hasNext()) {
            newProject.addBuildListener((BuildListener) iter.next());
        }

        if (output != null) {
            File outfile = null;
            if (dir != null) {
                outfile = FILE_UTILS.resolveFile(dir, output);
            } else {
                outfile = getProject().resolveFile(output);
            }
            try {
                out = new PrintStream(new FileOutputStream(outfile));
                DefaultLogger logger = new DefaultLogger();
                logger.setMessageOutputLevel(Project.MSG_INFO);
                logger.setOutputPrintStream(out);
                logger.setErrorPrintStream(out);
                newProject.addBuildListener(logger);
            } catch (IOException ex) {
                log(""Ant: Can't set output to "" + output);
            }
        }
        
        getProject().copyUserProperties(newProject);

        if (!inheritAll) {
           
           
           newProject.setSystemProperties();

        } else {
            
            addAlmostAll(getProject().getProperties());
        }

        Enumeration e = propertySets.elements();
        while (e.hasMoreElements()) {
            PropertySet ps = (PropertySet) e.nextElement();
            addAlmostAll(ps.getProperties());
        }
    }

    
    public void handleOutput(String outputToHandle) {
        if (newProject != null) {
            newProject.demuxOutput(outputToHandle, false);
        } else {
            super.handleOutput(outputToHandle);
        }
    }

    
    public int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        if (newProject != null) {
            return newProject.demuxInput(buffer, offset, length);
        }
        return super.handleInput(buffer, offset, length);
    }

    
    public void handleFlush(String toFlush) {
        if (newProject != null) {
            newProject.demuxFlush(toFlush, false);
        } else {
            super.handleFlush(toFlush);
        }
    }

    
    public void handleErrorOutput(String errorOutputToHandle) {
        if (newProject != null) {
            newProject.demuxOutput(errorOutputToHandle, true);
        } else {
            super.handleErrorOutput(errorOutputToHandle);
        }
    }

    
    public void handleErrorFlush(String errorOutputToFlush) {
        if (newProject != null) {
            newProject.demuxFlush(errorOutputToFlush, true);
        } else {
            super.handleErrorFlush(errorOutputToFlush);
        }
    }

    
    public void execute() throws BuildException {
        File savedDir = dir;
        String savedAntFile = antFile;
        Vector locals = new Vector(targets);
        try {
            getNewProject();

            if (dir == null && inheritAll) {
                dir = getProject().getBaseDir();
            }

            initializeProject();

            if (dir != null) {
                newProject.setBaseDir(dir);
                if (savedDir != null) {
                    
                    newProject.setInheritedProperty(MagicNames.PROJECT_BASEDIR,
                                                    dir.getAbsolutePath());
                }
            } else {
                dir = getProject().getBaseDir();
            }

            overrideProperties();

            if (antFile == null) {
                antFile = Main.DEFAULT_BUILD_FILENAME;
            }

            File file = FILE_UTILS.resolveFile(dir, antFile);
            antFile = file.getAbsolutePath();

            log(""calling target(s) ""
                + ((locals.size() > 0) ? locals.toString() : ""[default]"")
                + "" in build file "" + antFile, Project.MSG_VERBOSE);
            newProject.setUserProperty(MagicNames.ANT_FILE , antFile);

            String thisAntFile = getProject().getProperty(MagicNames.ANT_FILE);
            
            
            if (thisAntFile != null
                && file.equals(getProject().resolveFile(thisAntFile))
                && getOwningTarget() != null) {

                if (getOwningTarget().getName().equals("""")) {
                    if (getTaskName().equals(""antcall"")) {
                        throw new BuildException(""antcall must not be used at""
                                                 + "" the top level."");
                    }
                    throw new BuildException(getTaskName() + "" task at the""
                                + "" top level must not invoke""
                                + "" its own build file."");
                }
            }

            try {
                ProjectHelper.configureProject(newProject, file);
            } catch (BuildException ex) {
                throw ProjectHelper.addLocationToBuildException(
                    ex, getLocation());
            }

            if (locals.size() == 0) {
                String defaultTarget = newProject.getDefaultTarget();
                if (defaultTarget != null) {
                    locals.add(defaultTarget);
                }
            }

            if (newProject.getProperty(MagicNames.ANT_FILE)
                .equals(getProject().getProperty(MagicNames.ANT_FILE))
                && getOwningTarget() != null) {

                String owningTargetName = getOwningTarget().getName();

                if (locals.contains(owningTargetName)) {
                    throw new BuildException(getTaskName() + "" task calling ""
                                             + ""its own parent target."");
                }
                boolean circular = false;
                for (Iterator it = locals.iterator();
                     !circular && it.hasNext();) {
                    Target other =
                        (Target) (getProject().getTargets().get(it.next()));
                    circular |= (other != null
                                 && other.dependsOn(owningTargetName));
                }
                if (circular) {
                    throw new BuildException(getTaskName()
                                             + "" task calling a target""
                                             + "" that depends on""
                                             + "" its parent target \'""
                                             + owningTargetName
                                             + ""\'."");
                }
            }

            addReferences();

            if (locals.size() > 0 && !(locals.size() == 1
                                       && """".equals(locals.get(0)))) {
                BuildException be = null;
                try {
                    log(""Entering "" + antFile + ""..."", Project.MSG_VERBOSE);
                    newProject.fireSubBuildStarted();
                    newProject.executeTargets(locals);
                } catch (BuildException ex) {
                    be = ProjectHelper
                        .addLocationToBuildException(ex, getLocation());
                    throw be;
                } finally {
                    log(""Exiting "" + antFile + ""."", Project.MSG_VERBOSE);
                    newProject.fireSubBuildFinished(be);
                }
            }
        } finally {
            
            newProject = null;
            Enumeration e = properties.elements();
            while (e.hasMoreElements()) {
                Property p = (Property) e.nextElement();
                p.setProject(null);
            }

            if (output != null && out != null) {
                try {
                    out.close();
                } catch (final Exception ex) {
                    
                }
            }
            dir = savedDir;
            antFile = savedAntFile;
        }
    }

    
    private void overrideProperties() throws BuildException {
        
        
        Set set = new HashSet();
        for (int i = properties.size() - 1; i >= 0; --i) {
            Property p = (Property) properties.get(i);
            if (p.getName() != null && !p.getName().equals("""")) {
                if (set.contains(p.getName())) {
                    properties.remove(i);
                } else {
                    set.add(p.getName());
                }
            }
        }
        Enumeration e = properties.elements();
        while (e.hasMoreElements()) {
            Property p = (Property) e.nextElement();
            p.setProject(newProject);
            p.execute();
        }
        getProject().copyInheritedProperties(newProject);
    }

    
    private void addReferences() throws BuildException {
        Hashtable thisReferences
            = (Hashtable) getProject().getReferences().clone();
        Hashtable newReferences = newProject.getReferences();
        Enumeration e;
        if (references.size() > 0) {
            for (e = references.elements(); e.hasMoreElements();) {
                Reference ref = (Reference) e.nextElement();
                String refid = ref.getRefId();
                if (refid == null) {
                    throw new BuildException(""the refid attribute is required""
                                             + "" for reference elements"");
                }
                if (!thisReferences.containsKey(refid)) {
                    log(""Parent project doesn't contain any reference '""
                        + refid + ""'"",
                        Project.MSG_WARN);
                    continue;
                }

                thisReferences.remove(refid);
                String toRefid = ref.getToRefid();
                if (toRefid == null) {
                    toRefid = refid;
                }
                copyReference(refid, toRefid);
            }
        }

        
        
        if (inheritRefs) {
            for (e = thisReferences.keys(); e.hasMoreElements();) {
                String key = (String) e.nextElement();
                if (newReferences.containsKey(key)) {
                    continue;
                }
                copyReference(key, key);
                newProject.inheritIDReferences(getProject());
            }
        }
    }

    
    private void copyReference(String oldKey, String newKey) {
        Object orig = getProject().getReference(oldKey);
        if (orig == null) {
            log(""No object referenced by "" + oldKey + "". Can't copy to ""
                + newKey,
                Project.MSG_WARN);
            return;
        }

        Class c = orig.getClass();
        Object copy = orig;
        try {
            Method cloneM = c.getMethod(""clone"", new Class[0]);
            if (cloneM != null) {
                copy = cloneM.invoke(orig, new Object[0]);
                log(""Adding clone of reference "" + oldKey, Project.MSG_DEBUG);
            }
        } catch (Exception e) {
            
        }


        if (copy instanceof ProjectComponent) {
            ((ProjectComponent) copy).setProject(newProject);
        } else {
            try {
                Method setProjectM =
                    c.getMethod(""setProject"", new Class[] {Project.class});
                if (setProjectM != null) {
                    setProjectM.invoke(copy, new Object[] {newProject});
                }
            } catch (NoSuchMethodException e) {
                
                
            } catch (Exception e2) {
                String msg = ""Error setting new project instance for ""
                    + ""reference with id "" + oldKey;
                throw new BuildException(msg, e2, getLocation());
            }
        }
        newProject.addReference(newKey, copy);
    }

    
    private void addAlmostAll(Hashtable props) {
        Enumeration e = props.keys();
        while (e.hasMoreElements()) {
            String key = e.nextElement().toString();
            if (MagicNames.PROJECT_BASEDIR.equals(key) || MagicNames.ANT_FILE.equals(key)) {
                
                continue;
            }

            String value = props.get(key).toString();
            
            if (newProject.getProperty(key) == null) {
                
                newProject.setNewProperty(key, value);
            }
        }
    }

    
    public void setDir(File dir) {
        this.dir = dir;
    }

    
    public void setAntfile(String antFile) {
        
        
        
        this.antFile = antFile;
    }

    
    public void setTarget(String targetToAdd) {
        if (targetToAdd.equals("""")) {
            throw new BuildException(""target attribute must not be empty"");
        }
        targets.add(targetToAdd);
        targetAttributeSet = true;
    }

    
    public void setOutput(String outputFile) {
        this.output = outputFile;
    }

    
    public Property createProperty() {
        Property p = new Property(true, getProject());
        p.setProject(getNewProject());
        p.setTaskName(""property"");
        properties.addElement(p);
        return p;
    }

    
    public void addReference(Reference ref) {
        references.addElement(ref);
    }

    
    public void addConfiguredTarget(TargetElement t) {
        if (targetAttributeSet) {
            throw new BuildException(
                ""nested target is incompatible with the target attribute"");
        }
        String name = t.getName();
        if (name.equals("""")) {
            throw new BuildException(""target name must not be empty"");
        }
        targets.add(name);
    }

    
    public void addPropertyset(PropertySet ps) {
        propertySets.addElement(ps);
    }

    
    protected Project getNewProject() {
        if (newProject == null) {
            reinit();
        }
        return newProject;
    }

    
    private Iterator getBuildListeners() {
        return getProject().getBuildListeners().iterator();
    }

    
    public static class Reference
        extends org.apache.tools.ant.types.Reference {

        
        public Reference() {
                super();
        }

        private String targetid = null;

        
        public void setToRefid(String targetid) {
            this.targetid = targetid;
        }

        
        public String getToRefid() {
            return targetid;
        }
    }

    
    public static class TargetElement {
        private String name;

        
        public TargetElement() {
                
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }
    }
}
"
org.apache.tools.ant.util.ReflectWrapper,6,1,0,3,14,0,2,1,6,0.0,58,1.0,0,0.0,0.533333333,0,0,8.5,1,0.6667,0,"
package org.apache.tools.ant.util;

import java.lang.reflect.Constructor;



public class ReflectWrapper {
    private Object obj;
    
    public ReflectWrapper(ClassLoader loader, String name) {
        try {
            Class clazz;
            clazz = Class.forName(name, true, loader);
            Constructor constructor;
            constructor = clazz.getConstructor((Class[]) null);
            obj = constructor.newInstance((Object[]) null);
        } catch (Exception t) {
            ReflectUtil.throwBuildException(t);
        }
    }

    
    public ReflectWrapper(Object obj) {
        this.obj = obj;
    }

    
    public Object getObject() {
        return obj;
    }

    
    public Object invoke(String methodName) {
        return ReflectUtil.invoke(obj, methodName);
    }

    
    public Object invoke(
        String methodName, Class argType, Object arg) {
        return ReflectUtil.invoke(obj, methodName, argType, arg);
    }

    
    public Object invoke(
        String methodName, Class argType1, Object arg1,
        Class argType2, Object arg2) {
        return ReflectUtil.invoke(
            obj, methodName, argType1, arg1, argType2, arg2);
    }
}
"
org.apache.tools.ant.types.selectors.SelectorScanner,3,1,0,3,3,3,2,1,3,2.0,3,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.types.selectors;


public interface SelectorScanner {
    
    void setSelectors(FileSelector[] selectors);

    
    String[] getDeselectedDirectories();

    
    String[] getDeselectedFiles();


}
"
org.apache.tools.ant.util.DateUtils,11,1,0,4,36,51,4,0,8,1.01,314,0.6,0,0.0,0.22,0,0,26.63636364,4,1.3636,1,"
package org.apache.tools.ant.util;

import java.text.ChoiceFormat;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;


public final class DateUtils {

    
    public static final String ISO8601_DATETIME_PATTERN
            = ""yyyy-MM-dd'T'HH:mm:ss"";

    
    public static final String ISO8601_DATE_PATTERN
            = ""yyyy-MM-dd"";

    
    public static final String ISO8601_TIME_PATTERN
            = ""HH:mm:ss"";

    
    public static final DateFormat DATE_HEADER_FORMAT
        = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss "", Locale.US);



    private static final MessageFormat MINUTE_SECONDS
            = new MessageFormat(""{0}{1}"");

    private static final double[] LIMITS = {0, 1, 2};

    private static final String[] MINUTES_PART = {"""", ""1 minute "", ""{0,number} minutes ""};

    private static final String[] SECONDS_PART = {""0 seconds"", ""1 second"", ""{1,number} seconds""};

    private static final ChoiceFormat MINUTES_FORMAT =
            new ChoiceFormat(LIMITS, MINUTES_PART);

    private static final ChoiceFormat SECONDS_FORMAT =
            new ChoiceFormat(LIMITS, SECONDS_PART);

    static {
        MINUTE_SECONDS.setFormat(0, MINUTES_FORMAT);
        MINUTE_SECONDS.setFormat(1, SECONDS_FORMAT);
    }

    
    private DateUtils() {
    }


    
    public static String format(long date, String pattern) {
        return format(new Date(date), pattern);
    }


    
    public static String format(Date date, String pattern) {
        DateFormat df = createDateFormat(pattern);
        return df.format(date);
    }


    
    public static String formatElapsedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        Object[] args = {new Long(minutes), new Long(seconds % 60)};
        return MINUTE_SECONDS.format(args);
    }

    
    private static DateFormat createDateFormat(String pattern) {
        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
        TimeZone gmt = TimeZone.getTimeZone(""GMT"");
        sdf.setTimeZone(gmt);
        sdf.setLenient(true);
        return sdf;
    }

    
    public static int getPhaseOfMoon(Calendar cal) {
        int dayOfTheYear = cal.get(Calendar.DAY_OF_YEAR);
        int yearInMetonicCycle = ((cal.get(Calendar.YEAR) - 1900) % 19) + 1;
        int epact = (11 * yearInMetonicCycle + 18) % 30;
        if ((epact == 25 && yearInMetonicCycle > 11) || epact == 24) {
            epact++;
        }
        return (((((dayOfTheYear + epact) * 6) + 11) % 177) / 22) & 7;
    }

    
    public static String getDateForHeader() {
        Calendar cal = Calendar.getInstance();
        TimeZone tz = cal.getTimeZone();
        int offset = tz.getOffset(cal.get(Calendar.ERA),
                                  cal.get(Calendar.YEAR),
                                  cal.get(Calendar.MONTH),
                                  cal.get(Calendar.DAY_OF_MONTH),
                                  cal.get(Calendar.DAY_OF_WEEK),
                                  cal.get(Calendar.MILLISECOND));
        StringBuffer tzMarker = new StringBuffer(offset < 0 ? ""-"" : ""+"");
        offset = Math.abs(offset);
        int hours = offset / (60 * 60 * 1000);
        int minutes = offset / (60 * 1000) - 60 * hours;
        if (hours < 10) {
            tzMarker.append(""0"");
        }
        tzMarker.append(hours);
        if (minutes < 10) {
            tzMarker.append(""0"");
        }
        tzMarker.append(minutes);
        return DATE_HEADER_FORMAT.format(cal.getTime()) + tzMarker.toString();
    }

    
    public static Date parseIso8601DateTime(String datestr)
        throws ParseException {
        return new SimpleDateFormat(ISO8601_DATETIME_PATTERN).parse(datestr);
    }

    
    public static Date parseIso8601Date(String datestr) throws ParseException {
        return new SimpleDateFormat(ISO8601_DATE_PATTERN).parse(datestr);
    }

    
    public static Date parseIso8601DateTimeOrDate(String datestr)
        throws ParseException {
        try {
            return parseIso8601DateTime(datestr);
        } catch (ParseException px) {
            return parseIso8601Date(datestr);
        }
    }
}
"
org.apache.tools.ant.types.FilterChain,25,3,1,35,39,0,9,26,25,0.0,189,1.0,0,0.555555556,0.08,1,1,6.52,1,0.96,0,"
package org.apache.tools.ant.types;

import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.filters.ChainableReader;
import org.apache.tools.ant.filters.ClassConstants;
import org.apache.tools.ant.filters.EscapeUnicode;
import org.apache.tools.ant.filters.ExpandProperties;
import org.apache.tools.ant.filters.HeadFilter;
import org.apache.tools.ant.filters.LineContains;
import org.apache.tools.ant.filters.LineContainsRegExp;
import org.apache.tools.ant.filters.PrefixLines;
import org.apache.tools.ant.filters.ReplaceTokens;
import org.apache.tools.ant.filters.StripJavaComments;
import org.apache.tools.ant.filters.StripLineBreaks;
import org.apache.tools.ant.filters.StripLineComments;
import org.apache.tools.ant.filters.TabsToSpaces;
import org.apache.tools.ant.filters.TailFilter;
import org.apache.tools.ant.filters.TokenFilter;



public class FilterChain extends DataType
    implements Cloneable {

    private Vector filterReaders = new Vector();

    
    public void addFilterReader(final AntFilterReader filterReader) {
        filterReaders.addElement(filterReader);
    }

    
    public Vector getFilterReaders() {
        return filterReaders;
    }

    
    public void addClassConstants(final ClassConstants classConstants) {
        filterReaders.addElement(classConstants);
    }

    
    public void addExpandProperties(final ExpandProperties expandProperties) {
        filterReaders.addElement(expandProperties);
    }

    
    public void addHeadFilter(final HeadFilter headFilter) {
        filterReaders.addElement(headFilter);
    }

    
    public void addLineContains(final LineContains lineContains) {
        filterReaders.addElement(lineContains);
    }

    
    public void addLineContainsRegExp(final LineContainsRegExp
                                                lineContainsRegExp) {
        filterReaders.addElement(lineContainsRegExp);
    }

    
    public void addPrefixLines(final PrefixLines prefixLines) {
        filterReaders.addElement(prefixLines);
    }

    
    public void addReplaceTokens(final ReplaceTokens replaceTokens) {
        filterReaders.addElement(replaceTokens);
    }

    
    public void addStripJavaComments(final StripJavaComments
                                                stripJavaComments) {
        filterReaders.addElement(stripJavaComments);
    }

    
    public void addStripLineBreaks(final StripLineBreaks
                                                stripLineBreaks) {
        filterReaders.addElement(stripLineBreaks);
    }

    
    public void addStripLineComments(final StripLineComments
                                                stripLineComments) {
        filterReaders.addElement(stripLineComments);
    }

    
    public void addTabsToSpaces(final TabsToSpaces tabsToSpaces) {
        filterReaders.addElement(tabsToSpaces);
    }

    
    public void addTailFilter(final TailFilter tailFilter) {
        filterReaders.addElement(tailFilter);
    }

    
    public void addEscapeUnicode(final EscapeUnicode escapeUnicode) {
        filterReaders.addElement(escapeUnicode);
    }

    
    public void addTokenFilter(final TokenFilter tokenFilter) {
        filterReaders.addElement(tokenFilter);
    }

    
    public void addDeleteCharacters(TokenFilter.DeleteCharacters filter) {
        filterReaders.addElement(filter);
    }

    
    public void addContainsRegex(TokenFilter.ContainsRegex filter) {
        filterReaders.addElement(filter);
    }

    
    public void addReplaceRegex(TokenFilter.ReplaceRegex filter) {
        filterReaders.addElement(filter);
    }

    
    public void addTrim(TokenFilter.Trim filter) {
        filterReaders.addElement(filter);
    }

    
    public void addReplaceString(
        TokenFilter.ReplaceString filter) {
        filterReaders.addElement(filter);
    }

    
    public void addIgnoreBlank(
        TokenFilter.IgnoreBlank filter) {
        filterReaders.addElement(filter);
    }


    
    public void setRefid(Reference r) throws BuildException {
        if (!filterReaders.isEmpty()) {
            throw tooManyAttributes();
        }
        
        Object o = r.getReferencedObject(getProject());
        if (o instanceof FilterChain) {
            FilterChain fc = (FilterChain) o;
            filterReaders = fc.getFilterReaders();
        } else {
            String msg = r.getRefId() + "" doesn\'t refer to a FilterChain"";
            throw new BuildException(msg);
        }

        super.setRefid(r);
    }

    

    public void add(ChainableReader filter) {
        filterReaders.addElement(filter);
    }

}
"
org.apache.tools.ant.launch.LaunchException,1,3,0,1,2,0,1,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
package org.apache.tools.ant.launch;


public class LaunchException extends Exception {

    
    public LaunchException(String message) {
        super(message);
    }

}
"
org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapter,1,1,0,4,1,0,3,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.native2ascii;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.optional.Native2Ascii;


public interface Native2AsciiAdapter {
    
    boolean convert(Native2Ascii args, File srcFile, File destFile)
        throws BuildException;
}
"
org.apache.tools.ant.input.GreedyInputHandler,2,2,0,6,20,1,1,5,2,2.0,80,1.0,0,0.75,0.75,1,1,38.5,1,0.5,0,"

package org.apache.tools.ant.input;

import java.io.InputStream;
import java.io.ByteArrayOutputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.StreamPumper;
import org.apache.tools.ant.util.FileUtils;


public class GreedyInputHandler extends DefaultInputHandler {

    private static final int BUFFER_SIZE = 1024;

    
    public GreedyInputHandler() {
    }

    
    public void handleInput(InputRequest request) throws BuildException {
        String prompt = getPrompt(request);
        InputStream in = null;
        try {
            in = getInputStream();
            System.err.println(prompt);
            System.err.flush();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            StreamPumper p = new StreamPumper(in, baos);
            Thread t = new Thread(p);
            t.start();
            try {
                t.join();
            } catch (InterruptedException e) {
                try {
                    t.join();
                } catch (InterruptedException e2) {
                    
                }
            }
            request.setInput(new String(baos.toByteArray()));
            if (!(request.isInputValid())) {
                throw new BuildException(
                    ""Received invalid console input"");
            }
            if (p.getException() != null) {
                throw new BuildException(
                    ""Failed to read input from console"", p.getException());
            }
        } finally {
            FileUtils.close(in);
        }
    }
}
"
org.apache.tools.ant.types.optional.ScriptMapper,7,3,0,3,16,13,0,3,6,0.75,55,0.5,0,0.8,0.833333333,0,0,6.571428571,2,0.8571,0,"
package org.apache.tools.ant.types.optional;

import org.apache.tools.ant.util.FileNameMapper;

import java.util.ArrayList;


public class ScriptMapper extends AbstractScriptComponent implements FileNameMapper {


    private ArrayList files;
    static final String[] EMPTY_STRING_ARRAY = new String[0];


    
    public void setFrom(String from) {

    }

    
    public void setTo(String to) {

    }

    
    public void clear() {
        files = new ArrayList(1);
    }

    
    public void addMappedName(String mapping) {
        files.add(mapping);
    }

    

    public String[] mapFileName(String sourceFileName) {
        initScriptRunner();
        getRunner().addBean(""source"", sourceFileName);
        clear();
        executeScript(""ant_mapper"");
        if (files.size() == 0) {
            return null;
        } else {
            return (String[]) files.toArray(EMPTY_STRING_ARRAY);
        }
    }
}
"
org.apache.tools.ant.types.resolver.ApacheCatalog,4,2,0,6,14,0,1,6,3,0.0,96,1.0,1,0.916666667,0.5,1,3,22.75,5,1.75,0,"

package org.apache.tools.ant.types.resolver;

import org.apache.xml.resolver.Catalog;
import org.apache.xml.resolver.CatalogEntry;

import org.apache.xml.resolver.helpers.PublicId;


public class ApacheCatalog extends Catalog {

    
    private ApacheCatalogResolver resolver = null;

    
    protected Catalog newCatalog() {
        ApacheCatalog cat = (ApacheCatalog) super.newCatalog();
        cat.setResolver(resolver);
        return cat;
    }

    
    public void setResolver(ApacheCatalogResolver resolver) {
        this.resolver = resolver;
    }

    
    public void addEntry(CatalogEntry entry) {

        int type = entry.getEntryType();

        if (type == PUBLIC) {

            String publicid = PublicId.normalize(entry.getEntryArg(0));
            String systemid = normalizeURI(entry.getEntryArg(1));

            if (resolver == null) {
                catalogManager.debug
                    .message(1, ""Internal Error: null ApacheCatalogResolver"");
            } else {
                resolver.addPublicEntry(publicid, systemid, base);
            }

        } else if (type == URI) {

            String uri = normalizeURI(entry.getEntryArg(0));
            String altURI = normalizeURI(entry.getEntryArg(1));

            if (resolver == null) {
                catalogManager.debug
                    .message(1, ""Internal Error: null ApacheCatalogResolver"");
            } else {
                resolver.addURIEntry(uri, altURI, base);
            }

        }

        super.addEntry(entry);
    }

} 
"
org.apache.tools.ant.taskdefs.StreamPumper,10,1,0,5,18,21,5,0,8,0.728395062,182,1.0,0,0.0,0.34,0,0,16.3,7,1.5,1,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;


public class StreamPumper implements Runnable {

    private InputStream is;
    private OutputStream os;
    private volatile boolean finish;
    private volatile boolean finished;
    private boolean closeWhenExhausted;
    private boolean autoflush = false;
    private Exception exception = null;
    private int bufferSize = 128;
    private boolean started = false;

    
    public StreamPumper(InputStream is, OutputStream os,
                        boolean closeWhenExhausted) {
        this.is = is;
        this.os = os;
        this.closeWhenExhausted = closeWhenExhausted;
    }

    
    public StreamPumper(InputStream is, OutputStream os) {
        this(is, os, false);
    }

    
     void setAutoflush(boolean autoflush) {
        this.autoflush = autoflush;
    }

    
    public void run() {
        synchronized (this) {
            started = true;
        }
        finished = false;
        finish = false;

        final byte[] buf = new byte[bufferSize];

        int length;
        try {
            while ((length = is.read(buf)) > 0 && !finish) {
                os.write(buf, 0, length);
                if (autoflush) {
                    os.flush();
                }
            }
            os.flush();
        } catch (Exception e) {
            synchronized (this) {
                exception = e;
            }
        } finally {
            if (closeWhenExhausted) {
                try {
                    os.close();
                } catch (IOException e) {
                    
                }
            }
            finished = true;
            synchronized (this) {
                notifyAll();
            }
        }
    }

    
    public boolean isFinished() {
        return finished;
    }

    
    public synchronized void waitFor()
        throws InterruptedException {
        while (!isFinished()) {
            wait();
        }
    }

    
    public synchronized void setBufferSize(int bufferSize) {
        if (started) {
            throw new IllegalStateException(
                ""Cannot set buffer size on a running StreamPumper"");
        }
        this.bufferSize = bufferSize;
    }

    
    public synchronized int getBufferSize() {
        return bufferSize;
    }

    
    public synchronized Exception getException() {
        return exception;
    }

    
     synchronized void stop() {
        finish = true;
        notifyAll();
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Edit,3,4,0,4,10,0,0,4,3,0.0,55,0.0,0,0.962264151,0.666666667,1,1,17.0,1,0.6667,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;



public class P4Edit extends P4Base {

    
    
    public String change = null;

    

    
    public void setChange(String change) {
        this.change = change;
    }

    
    public void execute() throws BuildException {
        if (change != null) {
            P4CmdOpts = ""-c "" + change;
        }
        if (P4View == null) {
            throw new BuildException(""No view specified to edit"");
        }
        execP4Command(""-s edit "" + P4CmdOpts + "" "" + P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSCHECKIN,7,4,0,6,28,21,0,6,6,2.0,92,0.0,0,0.93814433,0.428571429,1,1,12.14285714,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class MSVSSCHECKIN extends MSVSS {

    
    protected Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_CHECKIN);

        
        commandLine.createArgument().setValue(getVsspath());
        
        commandLine.createArgument().setValue(getLocalpath());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(getRecursive());
        
        commandLine.createArgument().setValue(getWritable());
        
        commandLine.createArgument().setValue(getLogin());
        
        commandLine.createArgument().setValue(getComment());

        return commandLine;
    }

    
    public void setLocalpath(Path localPath) {
        super.setInternalLocalPath(localPath.toString());
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public final void setWritable(boolean writable) {
        super.setInternalWritable(writable);
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }

    
    public void setComment(String comment) {
        super.setInternalComment(comment);
    }
}
"
org.apache.tools.ant.DynamicElementNS,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant;


public interface DynamicElementNS {
    
    Object createDynamicElement(
        String uri, String localName, String qName) throws BuildException;
}
"
org.apache.tools.ant.taskdefs.JDBCTask,26,3,1,8,60,225,1,7,20,0.872727273,526,1.0,2,0.606557377,0.24,0,0,18.80769231,10,1.3077,1,"

package org.apache.tools.ant.taskdefs;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Driver;
import java.sql.SQLException;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Locale;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;



public abstract class JDBCTask extends Task {


    
    private static Hashtable loaderMap = new Hashtable(3);

    private boolean caching = true;

    private Path classpath;

    private AntClassLoader loader;

    
    private boolean autocommit = false;

    
    private String driver = null;

    
    private String url = null;

    
    private String userId = null;

    
    private String password = null;

    
    private String rdbms = null;

    
    private String version = null;

    
    public void setClasspath(Path classpath) {
        this.classpath = classpath;
    }

    
    public void setCaching(boolean enable) {
        caching = enable;
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setDriver(String driver) {
        this.driver = driver.trim();
    }

    
    public void setUrl(String url) {
        this.url = url;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

    
    public void setAutocommit(boolean autocommit) {
        this.autocommit = autocommit;
    }

    
    public void setRdbms(String rdbms) {
        this.rdbms = rdbms;
    }

    
    public void setVersion(String version) {
        this.version = version;
    }

    
    protected boolean isValidRdbms(Connection conn) {
        if (rdbms == null && version == null) {
            return true;
        }

        try {
            DatabaseMetaData dmd = conn.getMetaData();

            if (rdbms != null) {
                String theVendor = dmd.getDatabaseProductName().toLowerCase();

                log(""RDBMS = "" + theVendor, Project.MSG_VERBOSE);
                if (theVendor == null || theVendor.indexOf(rdbms) < 0) {
                    log(""Not the required RDBMS: "" + rdbms, Project.MSG_VERBOSE);
                    return false;
                }
            }

            if (version != null) {
                String theVersion = dmd.getDatabaseProductVersion().toLowerCase(Locale.ENGLISH);

                log(""Version = "" + theVersion, Project.MSG_VERBOSE);
                if (theVersion == null
                        || !(theVersion.startsWith(version)
                        || theVersion.indexOf("" "" + version) >= 0)) {
                    log(""Not the required version: \"""" + version + ""\"""", Project.MSG_VERBOSE);
                    return false;
                }
            }
        } catch (SQLException e) {
            
            log(""Failed to obtain required RDBMS information"", Project.MSG_ERR);
            return false;
        }

        return true;
    }

    
    protected static Hashtable getLoaderMap() {
        return loaderMap;
    }

    
    protected AntClassLoader getLoader() {
        return loader;
    }

    
    protected Connection getConnection() throws BuildException {
        if (userId == null) {
            throw new BuildException(""UserId attribute must be set!"", getLocation());
        }
        if (password == null) {
            throw new BuildException(""Password attribute must be set!"", getLocation());
        }
        if (url == null) {
            throw new BuildException(""Url attribute must be set!"", getLocation());
        }
        try {

            log(""connecting to "" + getUrl(), Project.MSG_VERBOSE);
            Properties info = new Properties();
            info.put(""user"", getUserId());
            info.put(""password"", getPassword());
            Connection conn = getDriver().connect(getUrl(), info);

            if (conn == null) {
                
                throw new SQLException(""No suitable Driver for "" + url);
            }

            conn.setAutoCommit(autocommit);
            return conn;
        } catch (SQLException e) {
            throw new BuildException(e, getLocation());
        }

    }

    
    private Driver getDriver() throws BuildException {
        if (driver == null) {
            throw new BuildException(""Driver attribute must be set!"", getLocation());
        }

        Driver driverInstance = null;
        try {
            Class dc;
            if (classpath != null) {
                
                
                
                
                
                
                synchronized (loaderMap) {
                    if (caching) {
                        loader = (AntClassLoader) loaderMap.get(driver);
                    }
                    if (loader == null) {
                        log(""Loading "" + driver
                            + "" using AntClassLoader with classpath ""
                            + classpath, Project.MSG_VERBOSE);
                        loader = getProject().createClassLoader(classpath);
                        if (caching) {
                            loaderMap.put(driver, loader);
                        }
                    } else {
                        log(""Loading "" + driver
                            + "" using a cached AntClassLoader."",
                                Project.MSG_VERBOSE);
                    }
                }
                dc = loader.loadClass(driver);
            } else {
                log(""Loading "" + driver + "" using system loader."",
                    Project.MSG_VERBOSE);
                dc = Class.forName(driver);
            }
            driverInstance = (Driver) dc.newInstance();
        } catch (ClassNotFoundException e) {
            throw new BuildException(
                    ""Class Not Found: JDBC driver "" + driver + "" could not be loaded"",
                    e,
                    getLocation());
        } catch (IllegalAccessException e) {
            throw new BuildException(
                    ""Illegal Access: JDBC driver "" + driver + "" could not be loaded"",
                    e,
                    getLocation());
        } catch (InstantiationException e) {
            throw new BuildException(
                    ""Instantiation Exception: JDBC driver "" + driver + "" could not be loaded"",
                    e,
                    getLocation());
        }
        return driverInstance;
    }


    
    public void isCaching(boolean value) {
        caching = value;
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public boolean isAutocommit() {
        return autocommit;
    }

    
    public String getUrl() {
        return url;
    }

    
    public String getUserId() {
        return userId;
    }

    
    public void setUserid(String userId) {
        this.userId = userId;
    }

    
    public String getPassword() {
        return password;
    }

    
    public String getRdbms() {
        return rdbms;
    }

    
    public String getVersion() {
        return version;
    }

}
"
org.apache.tools.ant.taskdefs.email.EmailTask,32,3,2,16,97,362,2,14,32,0.941935484,941,0.76,3,0.544117647,0.201388889,3,3,27.625,45,2.625,4,"
package org.apache.tools.ant.taskdefs.email;

import java.io.File;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.ClasspathUtils;


public class EmailTask extends Task {
    
    public static final String AUTO = ""auto"";
    
    public static final String MIME = ""mime"";
    
    public static final String UU = ""uu"";
    
    public static final String PLAIN = ""plain"";

    
    public static class Encoding extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {AUTO, MIME, UU, PLAIN};
        }
    }

    private String encoding = AUTO;
    
    private String host = ""localhost"";
    private int port = 25;
    
    private String subject = null;
    
    private Message message = null;
    
    private boolean failOnError = true;
    private boolean includeFileNames = false;
    private String messageMimeType = null;
    
    
    private EmailAddress from = null;
    
    private Vector replyToList = new Vector();
    
    private Vector toList = new Vector();
    
    private Vector ccList = new Vector();
    
    private Vector bccList = new Vector();

    
    private Vector headers = new Vector();

    
    private Path attachments = null;
    
    private String charset = null;
    
    private String user = null;
    
    private String password = null;
    
    private boolean ssl = false;

    
    public void setUser(String user) {
        this.user = user;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

    
    public void setSSL(boolean ssl) {
        this.ssl = ssl;
    }

    
    public void setEncoding(Encoding encoding) {
        this.encoding = encoding.getValue();
    }

    
    public void setMailport(int port) {
        this.port = port;
    }

    
    public void setMailhost(String host) {
        this.host = host;
    }

    
    public void setSubject(String subject) {
        this.subject = subject;
    }

    
    public void setMessage(String message) {
        if (this.message != null) {
            throw new BuildException(""Only one message can be sent in an ""
                 + ""email"");
        }
        this.message = new Message(message);
        this.message.setProject(getProject());
    }

    
    public void setMessageFile(File file) {
        if (this.message != null) {
            throw new BuildException(""Only one message can be sent in an ""
                 + ""email"");
        }
        this.message = new Message(file);
        this.message.setProject(getProject());
    }

    
    public void setMessageMimeType(String type) {
        this.messageMimeType = type;
    }

    
    public void addMessage(Message message) throws BuildException {
        if (this.message != null) {
            throw new BuildException(
                ""Only one message can be sent in an email"");
        }
        this.message = message;
    }

    
    public void addFrom(EmailAddress address) {
        if (this.from != null) {
            throw new BuildException(""Emails can only be from one address"");
        }
        this.from = address;
    }

    
    public void setFrom(String address) {
        if (this.from != null) {
            throw new BuildException(""Emails can only be from one address"");
        }
        this.from = new EmailAddress(address);
    }

    
    public void addReplyTo(EmailAddress address) {
        this.replyToList.add(address);
    }

    
    public void setReplyTo(String address) {
        this.replyToList.add(new EmailAddress(address));
    }

    
    public void addTo(EmailAddress address) {
        toList.addElement(address);
    }

    
    public void setToList(String list) {
        StringTokenizer tokens = new StringTokenizer(list, "","");

        while (tokens.hasMoreTokens()) {
            toList.addElement(new EmailAddress(tokens.nextToken()));
        }
    }

    
    public void addCc(EmailAddress address) {
        ccList.addElement(address);
    }

    
    public void setCcList(String list) {
        StringTokenizer tokens = new StringTokenizer(list, "","");

        while (tokens.hasMoreTokens()) {
            ccList.addElement(new EmailAddress(tokens.nextToken()));
        }
    }

    
    public void addBcc(EmailAddress address) {
        bccList.addElement(address);
    }

    
    public void setBccList(String list) {
        StringTokenizer tokens = new StringTokenizer(list, "","");

        while (tokens.hasMoreTokens()) {
            bccList.addElement(new EmailAddress(tokens.nextToken()));
        }
    }

    
    public void setFailOnError(boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    public void setFiles(String filenames) {
        StringTokenizer t = new StringTokenizer(filenames, "", "");

        while (t.hasMoreTokens()) {
            createAttachments()
                .add(new FileResource(getProject().resolveFile(t.nextToken())));
        }
    }

    
    public void addFileset(FileSet fs) {
        createAttachments().add(fs);
    }

    
    public Path createAttachments() {
        if (attachments == null) {
            attachments = new Path(getProject());
        }
        return attachments.createPath();
    }

    
    public Header createHeader() {
        Header h = new Header();
        headers.add(h);
        return h;
    }

    
    public void setIncludefilenames(boolean includeFileNames) {
        this.includeFileNames = includeFileNames;
    }

    
    public boolean getIncludeFileNames() {
        return includeFileNames;
    }

    
    public void execute() {
        Message savedMessage = message;

        try {
            Mailer mailer = null;

            
            boolean autoFound = false;
            
            if (encoding.equals(MIME)
                 || (encoding.equals(AUTO) && !autoFound)) {
                try {
                    mailer = (Mailer) ClasspathUtils.newInstance(
                            ""org.apache.tools.ant.taskdefs.email.MimeMailer"",
                            EmailTask.class.getClassLoader(), Mailer.class);
                    autoFound = true;
                    log(""Using MIME mail"", Project.MSG_VERBOSE);
                } catch (BuildException e) {
                    Throwable t = e.getCause() == null ? e : e.getCause();
                    log(""Failed to initialise MIME mail: "" + t.getMessage(),
                            Project.MSG_WARN);
                    return;
                }
            }
            
            if (!autoFound && ((user != null) || (password != null))
                && (encoding.equals(UU) || encoding.equals(PLAIN))) {
                throw new BuildException(""SMTP auth only possible with MIME mail"");
            }
            
            if (!autoFound  && (ssl)
                && (encoding.equals(UU) || encoding.equals(PLAIN))) {
                throw new BuildException(""SSL only possible with MIME mail"");
            }
            
            if (encoding.equals(UU)
                 || (encoding.equals(AUTO) && !autoFound)) {
                try {
                    mailer = (Mailer) ClasspathUtils.newInstance(
                            ""org.apache.tools.ant.taskdefs.email.UUMailer"",
                            EmailTask.class.getClassLoader(), Mailer.class);
                    autoFound = true;
                    log(""Using UU mail"", Project.MSG_VERBOSE);
                } catch (BuildException e) {
                    Throwable t = e.getCause() == null ? e : e.getCause();
                    log(""Failed to initialise UU mail: "" + t.getMessage(),
                            Project.MSG_WARN);
                    return;
                }
            }
            
            if (encoding.equals(PLAIN)
                 || (encoding.equals(AUTO) && !autoFound)) {
                mailer = new PlainMailer();
                autoFound = true;
                log(""Using plain mail"", Project.MSG_VERBOSE);
            }
            
            if (mailer == null) {
                throw new BuildException(""Failed to initialise encoding: ""
                     + encoding);
            }
            
            if (message == null) {
                message = new Message();
                message.setProject(getProject());
            }
            
            if (from == null || from.getAddress() == null) {
                throw new BuildException(""A from element is required"");
            }
            
            if (toList.isEmpty() && ccList.isEmpty() && bccList.isEmpty()) {
                throw new BuildException(""At least one of to, cc or bcc must ""
                     + ""be supplied"");
            }
            
            if (messageMimeType != null) {
                if (message.isMimeTypeSpecified()) {
                    throw new BuildException(""The mime type can only be ""
                         + ""specified in one location"");
                }
                message.setMimeType(messageMimeType);
            }
            
            if (charset != null) {
                if (message.getCharset() != null) {
                    throw new BuildException(""The charset can only be ""
                         + ""specified in one location"");
                }
                message.setCharset(charset);
            }

            
            Vector files = new Vector();
            if (attachments != null) {
                Iterator iter = attachments.iterator();

                while (iter.hasNext()) {
                    FileResource fr = (FileResource) iter.next();
                    files.addElement(fr.getFile());
                }
            }
            
            log(""Sending email: "" + subject, Project.MSG_INFO);
            log(""From "" + from, Project.MSG_VERBOSE);
            log(""ReplyTo "" + replyToList, Project.MSG_VERBOSE);
            log(""To "" + toList, Project.MSG_VERBOSE);
            log(""Cc "" + ccList, Project.MSG_VERBOSE);
            log(""Bcc "" + bccList, Project.MSG_VERBOSE);

            
            mailer.setHost(host);
            mailer.setPort(port);
            mailer.setUser(user);
            mailer.setPassword(password);
            mailer.setSSL(ssl);
            mailer.setMessage(message);
            mailer.setFrom(from);
            mailer.setReplyToList(replyToList);
            mailer.setToList(toList);
            mailer.setCcList(ccList);
            mailer.setBccList(bccList);
            mailer.setFiles(files);
            mailer.setSubject(subject);
            mailer.setTask(this);
            mailer.setIncludeFileNames(includeFileNames);
            mailer.setHeaders(headers);

            
            mailer.send();

            
            int count = files.size();

            log(""Sent email with "" + count + "" attachment""
                 + (count == 1 ? """" : ""s""), Project.MSG_INFO);
        } catch (BuildException e) {
            Throwable t = e.getCause() == null ? e : e.getCause();
            log(""Failed to send email: "" + t.getMessage(), Project.MSG_WARN);
            if (failOnError) {
                throw e;
            }
        } catch (Exception e) {
          log(""Failed to send email: "" + e.getMessage(), Project.MSG_WARN);
          if (failOnError) {
            throw new BuildException(e);
          }
        } finally {
            message = savedMessage;
        }
    }

    
    public void setCharset(String charset) {
        this.charset = charset;
    }

    
    public String getCharset() {
        return charset;
    }

}

"
org.apache.tools.ant.taskdefs.Execute,33,1,0,70,121,440,54,22,25,0.860119048,1095,0.80952381,7,0.0,0.110576923,0,0,31.54545455,11,1.9697,0,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringReader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;


public class Execute {

    
    public static final int INVALID = Integer.MAX_VALUE;

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private String[] cmdl = null;
    private String[] env = null;
    private int exitValue = INVALID;
    private ExecuteStreamHandler streamHandler;
    private ExecuteWatchdog watchdog;
    private File workingDirectory = null;
    private Project project = null;
    private boolean newEnvironment = false;
    
    private boolean spawn = false;


    
    private boolean useVMLauncher = true;

    private static String antWorkingDirectory = System.getProperty(""user.dir"");
    private static CommandLauncher vmLauncher = null;
    private static CommandLauncher shellLauncher = null;
    private static Vector procEnvironment = null;

    
    private static ProcessDestroyer processDestroyer = new ProcessDestroyer();

    
    private static boolean environmentCaseInSensitive = false;

    
    static {
        
        try {
            if (!Os.isFamily(""os/2"")) {
                vmLauncher = new Java13CommandLauncher();
            }
        } catch (NoSuchMethodException exc) {
            
        }
        if (Os.isFamily(""mac"") && !Os.isFamily(""unix"")) {
            
            shellLauncher = new MacCommandLauncher(new CommandLauncher());
        } else if (Os.isFamily(""os/2"")) {
            
            shellLauncher = new OS2CommandLauncher(new CommandLauncher());
        } else if (Os.isFamily(""windows"")) {
            environmentCaseInSensitive = true;
            CommandLauncher baseLauncher = new CommandLauncher();

            if (!Os.isFamily(""win9x"")) {
                
                shellLauncher = new WinNTCommandLauncher(baseLauncher);
            } else {
                
                shellLauncher
                    = new ScriptCommandLauncher(""bin/antRun.bat"", baseLauncher);
            }
        } else if (Os.isFamily(""netware"")) {

            CommandLauncher baseLauncher = new CommandLauncher();

            shellLauncher
                = new PerlScriptCommandLauncher(""bin/antRun.pl"", baseLauncher);
        } else if (Os.isFamily(""openvms"")) {
            
            try {
                shellLauncher = new VmsCommandLauncher();
            } catch (NoSuchMethodException exc) {
            
            }
        } else {
            
            shellLauncher = new ScriptCommandLauncher(""bin/antRun"",
                new CommandLauncher());
        }
    }

    
    public void setSpawn(boolean spawn) {
        this.spawn = spawn;
    }

    
    public static synchronized Vector getProcEnvironment() {
        if (procEnvironment != null) {
            return procEnvironment;
        }
        procEnvironment = new Vector();
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            Execute exe = new Execute(new PumpStreamHandler(out));
            exe.setCommandline(getProcEnvCommand());
            
            exe.setNewenvironment(true);
            int retval = exe.execute();
            if (retval != 0) {
                
            }
            BufferedReader in =
                new BufferedReader(new StringReader(toString(out)));

            if (Os.isFamily(""openvms"")) {
                procEnvironment = addVMSLogicals(procEnvironment, in);
                return procEnvironment;
            }
            String var = null;
            String line, lineSep = StringUtils.LINE_SEP;
            while ((line = in.readLine()) != null) {
                if (line.indexOf('=') == -1) {
                    
                    
                    if (var == null) {
                        var = lineSep + line;
                    } else {
                        var += lineSep + line;
                    }
                } else {
                    
                    if (var != null) {
                        procEnvironment.addElement(var);
                    }
                    var = line;
                }
            }
            
            if (var != null) {
                procEnvironment.addElement(var);
            }
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
            
        }
        return procEnvironment;
    }

    
    private static String[] getProcEnvCommand() {
        if (Os.isFamily(""os/2"")) {
            
            return new String[] {""cmd"", ""/c"", ""set"" };
        } else if (Os.isFamily(""windows"")) {
            
            if (Os.isFamily(""win9x"")) {
                
                return new String[] {""command.com"", ""/c"", ""set"" };
            } else {
                
                return new String[] {""cmd"", ""/c"", ""set"" };
            }
        } else if (Os.isFamily(""z/os"") || Os.isFamily(""unix"")) {
            

            
            String[] cmd = new String[1];
            if (new File(""/bin/env"").canRead()) {
                cmd[0] = ""/bin/env"";
            } else if (new File(""/usr/bin/env"").canRead()) {
                cmd[0] = ""/usr/bin/env"";
            } else {
                
                cmd[0] = ""env"";
            }
            return cmd;
        } else if (Os.isFamily(""netware"") || Os.isFamily(""os/400"")) {
            
            return new String[] {""env""};
        } else if (Os.isFamily(""openvms"")) {
            return new String[] {""show"", ""logical""};
        } else {
            
            
            return null;
        }
    }

    
    public static String toString(ByteArrayOutputStream bos) {
        if (Os.isFamily(""z/os"")) {
            try {
                return bos.toString(""Cp1047"");
            } catch (java.io.UnsupportedEncodingException e) {
                
            }
        } else if (Os.isFamily(""os/400"")) {
            try {
                return bos.toString(""Cp500"");
            } catch (java.io.UnsupportedEncodingException e) {
                
            }
        }
        return bos.toString();
    }

    
    public Execute() {
        this(new PumpStreamHandler(), null);
    }

    
    public Execute(ExecuteStreamHandler streamHandler) {
        this(streamHandler, null);
    }

    
    public Execute(ExecuteStreamHandler streamHandler,
                   ExecuteWatchdog watchdog) {
        setStreamHandler(streamHandler);
        this.watchdog = watchdog;
        
        
        if (Os.isFamily(""openvms"")) {
            useVMLauncher = false;
        }
    }

    
    public void setStreamHandler(ExecuteStreamHandler streamHandler) {
        this.streamHandler = streamHandler;
    }

    
    public String[] getCommandline() {
        return cmdl;
    }

    
    public void setCommandline(String[] commandline) {
        cmdl = commandline;
    }

    
    public void setNewenvironment(boolean newenv) {
        newEnvironment = newenv;
    }

    
    public String[] getEnvironment() {
        return (env == null || newEnvironment)
            ? env : patchEnvironment();
    }

    
    public void setEnvironment(String[] env) {
        this.env = env;
    }

    
    public void setWorkingDirectory(File wd) {
        workingDirectory =
            (wd == null || wd.getAbsolutePath().equals(antWorkingDirectory))
            ? null : wd;
    }

    
    public File getWorkingDirectory() {
        return workingDirectory == null ? new File(antWorkingDirectory)
                                        : workingDirectory;
    }

    
    public void setAntRun(Project project) throws BuildException {
        this.project = project;
    }

    
    public void setVMLauncher(boolean useVMLauncher) {
        this.useVMLauncher = useVMLauncher;
    }

    
    public static Process launch(Project project, String[] command,
                                 String[] env, File dir, boolean useVM)
        throws IOException {
        if (dir != null && !dir.exists()) {
            throw new BuildException(dir + "" doesn't exist."");
        }
        CommandLauncher launcher
            = ((useVM && vmLauncher != null) ? vmLauncher : shellLauncher);
        return launcher.exec(project, command, env, dir);
    }

    
    public int execute() throws IOException {
        if (workingDirectory != null && !workingDirectory.exists()) {
            throw new BuildException(workingDirectory + "" doesn't exist."");
        }
        final Process process = launch(project, getCommandline(),
                                       getEnvironment(), workingDirectory,
                                       useVMLauncher);
        try {
            streamHandler.setProcessInputStream(process.getOutputStream());
            streamHandler.setProcessOutputStream(process.getInputStream());
            streamHandler.setProcessErrorStream(process.getErrorStream());
        } catch (IOException e) {
            process.destroy();
            throw e;
        }
        streamHandler.start();

        try {
            
            
            processDestroyer.add(process);

            if (watchdog != null) {
                watchdog.start(process);
            }
            waitFor(process);

            if (watchdog != null) {
                watchdog.stop();
            }
            streamHandler.stop();
            closeStreams(process);

            if (watchdog != null) {
                watchdog.checkException();
            }
            return getExitValue();
        } catch (ThreadDeath t) {
            
            process.destroy();
            throw t;
        } finally {
            
            
            
            processDestroyer.remove(process);
        }
    }

    
    public void spawn() throws IOException {
        if (workingDirectory != null && !workingDirectory.exists()) {
            throw new BuildException(workingDirectory + "" doesn't exist."");
        }
        final Process process = launch(project, getCommandline(),
                                       getEnvironment(), workingDirectory,
                                       useVMLauncher);
        if (Os.isFamily(""windows"")) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                project.log(""interruption in the sleep after having spawned a""
                            + "" process"", Project.MSG_VERBOSE);
            }
        }
        OutputStream dummyOut = new OutputStream() {
            public void write(int b) throws IOException {
            }
        };

        ExecuteStreamHandler handler = new PumpStreamHandler(dummyOut);
        handler.setProcessErrorStream(process.getErrorStream());
        handler.setProcessOutputStream(process.getInputStream());
        handler.start();
        process.getOutputStream().close();

        project.log(""spawned process "" + process.toString(),
                    Project.MSG_VERBOSE);
    }

    
    protected void waitFor(Process process) {
        try {
            process.waitFor();
            setExitValue(process.exitValue());
        } catch (InterruptedException e) {
            process.destroy();
        }
    }

    
    protected void setExitValue(int value) {
        exitValue = value;
    }

    
    public int getExitValue() {
        return exitValue;
    }

    
    public static boolean isFailure(int exitValue) {
        
        
        return Os.isFamily(""openvms"")
            ? (exitValue % 2 == 0) : (exitValue != 0);
    }

    
    public boolean isFailure() {
        return isFailure(getExitValue());
    }

    
    public boolean killedProcess() {
        return watchdog != null && watchdog.killedProcess();
    }

    
    private String[] patchEnvironment() {
        
        
        
        if (Os.isFamily(""openvms"")) {
            return env;
        }
        Vector osEnv = (Vector) getProcEnvironment().clone();
        for (int i = 0; i < env.length; i++) {
            String keyValue = env[i];
            
            String key = keyValue.substring(0, keyValue.indexOf('=') + 1);
            if (environmentCaseInSensitive) {
                
                key = key.toLowerCase();
            }
            int size = osEnv.size();
            
            
            for (int j = 0; j < size; j++) {
                String osEnvItem = (String) osEnv.elementAt(j);
                String convertedItem = environmentCaseInSensitive
                    ? osEnvItem.toLowerCase() : osEnvItem;
                if (convertedItem.startsWith(key)) {
                    osEnv.removeElementAt(j);
                    if (environmentCaseInSensitive) {
                        
                        keyValue = osEnvItem.substring(0, key.length())
                            + keyValue.substring(key.length());
                    }
                    break;
                }
            }
            
            osEnv.addElement(keyValue);
        }
        return (String[]) (osEnv.toArray(new String[osEnv.size()]));
    }

    
    public static void runCommand(Task task, String[] cmdline)
        throws BuildException {
        try {
            task.log(Commandline.describeCommand(cmdline),
                     Project.MSG_VERBOSE);
            Execute exe = new Execute(
                new LogStreamHandler(task, Project.MSG_INFO, Project.MSG_ERR));
            exe.setAntRun(task.getProject());
            exe.setCommandline(cmdline);
            int retval = exe.execute();
            if (isFailure(retval)) {
                throw new BuildException(cmdline[0]
                    + "" failed with return code "" + retval, task.getLocation());
            }
        } catch (java.io.IOException exc) {
            throw new BuildException(""Could not launch "" + cmdline[0] + "": ""
                + exc, task.getLocation());
        }
    }

    
    public static void closeStreams(Process process) {
        FileUtils.close(process.getInputStream());
        FileUtils.close(process.getOutputStream());
        FileUtils.close(process.getErrorStream());
    }

    
    private static Vector addVMSLogicals(Vector environment, BufferedReader in)
        throws IOException {
        HashMap logicals = new HashMap();
        String logName = null, logValue = null, newLogName;
        String line = null;
        while ((line = in.readLine()) != null) {
            
            if (line.startsWith(""\t="")) {
                
                if (logName != null) {
                    logValue += "","" + line.substring(4, line.length() - 1);
                }
            } else if (line.startsWith(""  \"""")) {
                
                if (logName != null) {
                    logicals.put(logName, logValue);
                }
                int eqIndex = line.indexOf('=');
                newLogName = line.substring(3, eqIndex - 2);
                if (logicals.containsKey(newLogName)) {
                    
                    logName = null;
                } else {
                    logName = newLogName;
                    logValue = line.substring(eqIndex + 3, line.length() - 1);
                }
            }
        }
        
        if (logName != null) {
            logicals.put(logName, logValue);
        }
        for (Iterator i = logicals.keySet().iterator(); i.hasNext();) {
            String logical = (String) i.next();
            environment.add(logical + ""="" + logicals.get(logical));
        }
        return environment;
    }

    
    private static class CommandLauncher {
        
        public Process exec(Project project, String[] cmd, String[] env)
             throws IOException {
            if (project != null) {
                project.log(""Execute:CommandLauncher: ""
                    + Commandline.describeCommand(cmd), Project.MSG_DEBUG);
            }
            return Runtime.getRuntime().exec(cmd, env);
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            if (workingDir == null) {
                return exec(project, cmd, env);
            }
            throw new IOException(""Cannot execute a process in different ""
                + ""directory under this JVM"");
        }
    }

    
    private static class Java13CommandLauncher extends CommandLauncher {
        private Method myExecWithCWD;

        public Java13CommandLauncher() throws NoSuchMethodException {
            
            
            myExecWithCWD = Runtime.class.getMethod(""exec"",
                new Class[] {String[].class, String[].class, File.class});
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            try {
                if (project != null) {
                    project.log(""Execute:Java13CommandLauncher: ""
                        + Commandline.describeCommand(cmd), Project.MSG_DEBUG);
                }
                return (Process) myExecWithCWD.invoke(Runtime.getRuntime(),
                    new Object[] {cmd, env, workingDir});
            } catch (InvocationTargetException exc) {
                Throwable realexc = exc.getTargetException();
                if (realexc instanceof ThreadDeath) {
                    throw (ThreadDeath) realexc;
                } else if (realexc instanceof IOException) {
                    throw (IOException) realexc;
                } else {
                    throw new BuildException(""Unable to execute command"",
                                             realexc);
                }
            } catch (Exception exc) {
                
                throw new BuildException(""Unable to execute command"", exc);
            }
        }
    }

    
    private static class CommandLauncherProxy extends CommandLauncher {
        private CommandLauncher myLauncher;

        CommandLauncherProxy(CommandLauncher launcher) {
            myLauncher = launcher;
        }

        
        public Process exec(Project project, String[] cmd, String[] env)
            throws IOException {
            return myLauncher.exec(project, cmd, env);
        }
    }

    
    private static class OS2CommandLauncher extends CommandLauncherProxy {
        OS2CommandLauncher(CommandLauncher launcher) {
            super(launcher);
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            File commandDir = workingDir;
            if (workingDir == null) {
                if (project != null) {
                    commandDir = project.getBaseDir();
                } else {
                    return exec(project, cmd, env);
                }
            }
            
            
            final int preCmdLength = 7;
            final String cmdDir = commandDir.getAbsolutePath();
            String[] newcmd = new String[cmd.length + preCmdLength];
            newcmd[0] = ""cmd"";
            newcmd[1] = ""/c"";
            newcmd[2] = cmdDir.substring(0, 2);
            newcmd[3] = ""&&"";
            newcmd[4] = ""cd"";
            newcmd[5] = cmdDir.substring(2);
            newcmd[6] = ""&&"";
            System.arraycopy(cmd, 0, newcmd, preCmdLength, cmd.length);

            return exec(project, newcmd, env);
        }
    }

    
    private static class WinNTCommandLauncher extends CommandLauncherProxy {
        WinNTCommandLauncher(CommandLauncher launcher) {
            super(launcher);
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            File commandDir = workingDir;
            if (workingDir == null) {
                if (project != null) {
                    commandDir = project.getBaseDir();
                } else {
                    return exec(project, cmd, env);
                }
            }
            
            
            final int preCmdLength = 6;
            String[] newcmd = new String[cmd.length + preCmdLength];
            newcmd[0] = ""cmd"";
            newcmd[1] = ""/c"";
            newcmd[2] = ""cd"";
            newcmd[3] = ""/d"";
            newcmd[4] = commandDir.getAbsolutePath();
            newcmd[5] = ""&&"";
            System.arraycopy(cmd, 0, newcmd, preCmdLength, cmd.length);

            return exec(project, newcmd, env);
        }
    }

    
    private static class MacCommandLauncher extends CommandLauncherProxy {
        MacCommandLauncher(CommandLauncher launcher) {
            super(launcher);
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            if (workingDir == null) {
                return exec(project, cmd, env);
            }
            System.getProperties().put(""user.dir"", workingDir.getAbsolutePath());
            try {
                return exec(project, cmd, env);
            } finally {
                System.getProperties().put(""user.dir"", antWorkingDirectory);
            }
        }
    }

    
    private static class ScriptCommandLauncher extends CommandLauncherProxy {
        ScriptCommandLauncher(String script, CommandLauncher launcher) {
            super(launcher);
            myScript = script;
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            if (project == null) {
                if (workingDir == null) {
                    return exec(project, cmd, env);
                }
                throw new IOException(""Cannot locate antRun script: ""
                    + ""No project provided"");
            }
            
            String antHome = project.getProperty(MagicNames.ANT_HOME);
            if (antHome == null) {
                throw new IOException(""Cannot locate antRun script: ""
                    + ""Property '"" + MagicNames.ANT_HOME + ""' not found"");
            }
            String antRun =
                FILE_UTILS.resolveFile(project.getBaseDir(),
                        antHome + File.separator + myScript).toString();

            
            File commandDir = workingDir;
            if (workingDir == null && project != null) {
                commandDir = project.getBaseDir();
            }
            String[] newcmd = new String[cmd.length + 2];
            newcmd[0] = antRun;
            newcmd[1] = commandDir.getAbsolutePath();
            System.arraycopy(cmd, 0, newcmd, 2, cmd.length);

            return exec(project, newcmd, env);
        }

        private String myScript;
    }

    
    private static class PerlScriptCommandLauncher
        extends CommandLauncherProxy {
        private String myScript;

        PerlScriptCommandLauncher(String script, CommandLauncher launcher) {
            super(launcher);
            myScript = script;
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            if (project == null) {
                if (workingDir == null) {
                    return exec(project, cmd, env);
                }
                throw new IOException(""Cannot locate antRun script: ""
                    + ""No project provided"");
            }
            
            String antHome = project.getProperty(MagicNames.ANT_HOME);
            if (antHome == null) {
                throw new IOException(""Cannot locate antRun script: ""
                    + ""Property '"" + MagicNames.ANT_HOME + ""' not found"");
            }
            String antRun =
                FILE_UTILS.resolveFile(project.getBaseDir(),
                        antHome + File.separator + myScript).toString();

            
            File commandDir = workingDir;
            if (workingDir == null && project != null) {
                commandDir = project.getBaseDir();
            }
            String[] newcmd = new String[cmd.length + 3];
            newcmd[0] = ""perl"";
            newcmd[1] = antRun;
            newcmd[2] = commandDir.getAbsolutePath();
            System.arraycopy(cmd, 0, newcmd, 3, cmd.length);

            return exec(project, newcmd, env);
        }
    }

    
    private static class VmsCommandLauncher extends Java13CommandLauncher {

        public VmsCommandLauncher() throws NoSuchMethodException {
            super();
        }

        
        public Process exec(Project project, String[] cmd, String[] env)
            throws IOException {
            File cmdFile = createCommandFile(cmd, env);
            Process p
                = super.exec(project, new String[] {cmdFile.getPath()}, env);
            deleteAfter(cmdFile, p);
            return p;
        }

        
        public Process exec(Project project, String[] cmd, String[] env,
                            File workingDir) throws IOException {
            File cmdFile = createCommandFile(cmd, env);
            Process p = super.exec(project, new String[] {cmdFile.getPath()},
                                   env, workingDir);
            deleteAfter(cmdFile, p);
            return p;
        }

        
        private File createCommandFile(String[] cmd, String[] env)
            throws IOException {
            File script = FILE_UTILS.createTempFile(""ANT"", "".COM"", null);
            script.deleteOnExit();
            PrintWriter out = null;
            try {
                out = new PrintWriter(new FileWriter(script));

                
                if (env != null) {
                    int eqIndex;
                    for (int i = 0; i < env.length; i++) {
                        eqIndex = env[i].indexOf('=');
                        if (eqIndex != -1) {
                            out.print(""$ DEFINE/NOLOG "");
                            out.print(env[i].substring(0, eqIndex));
                            out.print("" \"""");
                            out.print(env[i].substring(eqIndex + 1));
                            out.println('\""');
                        }
                    }
                }
                out.print(""$ "" + cmd[0]);
                for (int i = 1; i < cmd.length; i++) {
                    out.println("" -"");
                    out.print(cmd[i]);
                }
            } finally {
                if (out != null) {
                    out.close();
                }
            }
            return script;
        }

        private void deleteAfter(final File f, final Process p) {
            new Thread() {
                public void run() {
                    try {
                        p.waitFor();
                    } catch (InterruptedException e) {
                        
                    }
                    FileUtils.delete(f);
                }
            }
            .start();
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.XMLValidateTask,29,3,1,18,96,294,2,17,16,0.897619048,796,0.933333333,4,0.578125,0.162698413,2,2,25.93103448,5,1.3793,0,"
package org.apache.tools.ant.taskdefs.optional;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Vector;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.DTDLocation;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.XMLCatalog;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JAXPUtils;
import org.apache.tools.ant.util.XmlConstants;

import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Parser;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.ParserAdapter;


public class XMLValidateTask extends Task {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    protected static final String INIT_FAILED_MSG =
        ""Could not start xml validation: "";

    
    
    
    protected boolean failOnError = true;
    protected boolean warn = true;
    protected boolean lenient = false;
    protected String readerClassName = null;

    
    protected File file = null;
    
    protected Vector filesets = new Vector();
    protected Path classpath;

    
    protected XMLReader xmlReader = null;
    
    protected ValidatorErrorHandler errorHandler = new ValidatorErrorHandler();
    
    

    
    private Vector attributeList = new Vector();

    
    private final Vector propertyList = new Vector();

    private XMLCatalog xmlCatalog = new XMLCatalog();
    
    public static final String MESSAGE_FILES_VALIDATED
        = "" file(s) have been successfully validated."";

    
    public void setFailOnError(boolean fail) {
        failOnError = fail;
    }

    
    public void setWarn(boolean bool) {
        warn = bool;
    }

    
    public void setLenient(boolean bool) {
        lenient = bool;
    }

    
    public void setClassName(String className) {
        readerClassName = className;
    }

    
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void addConfiguredXMLCatalog(XMLCatalog catalog) {
        xmlCatalog.addConfiguredXMLCatalog(catalog);
    }

    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }

    
    public Attribute createAttribute() {
        final Attribute feature = new Attribute();
        attributeList.addElement(feature);
        return feature;
    }

    
    public Property createProperty() {
        final Property prop = new Property();
        propertyList.addElement(prop);
        return prop;
    }

    
    public void init() throws BuildException {
        super.init();
        xmlCatalog.setProject(getProject());
    }

    
    public DTDLocation createDTD() {
        DTDLocation dtdLocation = new DTDLocation();
        xmlCatalog.addDTD(dtdLocation);
        return dtdLocation;
    }
    
    protected EntityResolver getEntityResolver() {
        return xmlCatalog;
    }

    
    protected XMLReader getXmlReader() {
        return xmlReader;
    }

    
    public void execute() throws BuildException {

        int fileProcessed = 0;
        if (file == null && (filesets.size() == 0)) {
            throw new BuildException(
                ""Specify at least one source - "" + ""a file or a fileset."");
        }



        if (file != null) {
            if (file.exists() && file.canRead() && file.isFile()) {
                doValidate(file);
                fileProcessed++;
            } else {
                String errorMsg = ""File "" + file + "" cannot be read"";
                if (failOnError) {
                    throw new BuildException(errorMsg);
                } else {
                    log(errorMsg, Project.MSG_ERR);
                }
            }
        }

        for (int i = 0; i < filesets.size(); i++) {

            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            String[] files = ds.getIncludedFiles();

            for (int j = 0; j < files.length; j++) {
                File srcFile = new File(fs.getDir(getProject()), files[j]);
                doValidate(srcFile);
                fileProcessed++;
            }
        }
        onSuccessfulValidation(fileProcessed);
    }

    
    protected void onSuccessfulValidation(int fileProcessed) {
        log(fileProcessed + MESSAGE_FILES_VALIDATED);
    }

    
    protected void initValidator() {

        xmlReader = createXmlReader();

        xmlReader.setEntityResolver(getEntityResolver());
        xmlReader.setErrorHandler(errorHandler);

        if (!isSax1Parser()) {
            
            if (!lenient) {
                setFeature(XmlConstants.FEATURE_VALIDATION, true);
            }
            
            for (int i = 0; i < attributeList.size(); i++) {
                Attribute feature = (Attribute) attributeList.elementAt(i);
                setFeature(feature.getName(), feature.getValue());

            }
            
            for (int i = 0; i < propertyList.size(); i++) {
                final Property prop = (Property) propertyList.elementAt(i);
                setProperty(prop.getName(), prop.getValue());
            }
        }
    }

    
    protected boolean isSax1Parser() {
        return (xmlReader instanceof ParserAdapter);
    }

    
    protected XMLReader createXmlReader() {
        Object reader = null;
        if (readerClassName == null) {
            reader = createDefaultReaderOrParser();
        } else {

            Class readerClass = null;
            try {
                
                if (classpath != null) {
                    AntClassLoader loader =
                        getProject().createClassLoader(classpath);
                    readerClass = Class.forName(readerClassName, true, loader);
                } else {
                    readerClass = Class.forName(readerClassName);
                }

                reader = readerClass.newInstance();
            } catch (ClassNotFoundException e) {
                throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
            } catch (InstantiationException e) {
                throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
            } catch (IllegalAccessException e) {
                throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
            }
        }

        
        XMLReader newReader;
        if (reader instanceof XMLReader) {
            newReader = (XMLReader) reader;
            log(
                ""Using SAX2 reader "" + reader.getClass().getName(),
                Project.MSG_VERBOSE);
        } else {

            
            if (reader instanceof Parser) {
                newReader = new ParserAdapter((Parser) reader);
                log(
                    ""Using SAX1 parser "" + reader.getClass().getName(),
                    Project.MSG_VERBOSE);
            } else {
                throw new BuildException(
                    INIT_FAILED_MSG
                        + reader.getClass().getName()
                        + "" implements nor SAX1 Parser nor SAX2 XMLReader."");
            }
        }
        return newReader;
    }

    
    private Object createDefaultReaderOrParser() {
        Object reader;
        try {
            reader = createDefaultReader();
        } catch (BuildException exc) {
            reader = JAXPUtils.getParser();
        }
        return reader;
    }

    
    protected XMLReader createDefaultReader() {
        return JAXPUtils.getXMLReader();
    }

    
    protected void setFeature(String feature, boolean value)
        throws BuildException {
        log(""Setting feature "" + feature + ""="" + value, Project.MSG_DEBUG);
        try {
            xmlReader.setFeature(feature, value);
        } catch (SAXNotRecognizedException e) {
            throw new BuildException(
                ""Parser ""
                    + xmlReader.getClass().getName()
                    + "" doesn't recognize feature ""
                    + feature,
                e,
                getLocation());
        } catch (SAXNotSupportedException e) {
            throw new BuildException(
                ""Parser ""
                    + xmlReader.getClass().getName()
                    + "" doesn't support feature ""
                    + feature,
                e,
                getLocation());
        }
    }

    
    protected void setProperty(String name, String value) throws BuildException {
        
        if (name == null || value == null) {
            throw new BuildException(""Property name and value must be specified."");
        }

        try {
            xmlReader.setProperty(name, value);
        } catch (SAXNotRecognizedException e) {
            throw new BuildException(
                ""Parser ""
                    + xmlReader.getClass().getName()
                    + "" doesn't recognize property ""
                    + name,
                e,
                getLocation());
        } catch (SAXNotSupportedException e) {
            throw new BuildException(
                ""Parser ""
                    + xmlReader.getClass().getName()
                    + "" doesn't support property ""
                    + name,
                e,
                getLocation());
        }
    }

    
    protected boolean doValidate(File afile) {
        
        initValidator();
        boolean result = true;
        try {
            log(""Validating "" + afile.getName() + ""... "", Project.MSG_VERBOSE);
            errorHandler.init(afile);
            InputSource is = new InputSource(new FileInputStream(afile));
            String uri = FILE_UTILS.toURI(afile.getAbsolutePath());
            is.setSystemId(uri);
            xmlReader.parse(is);
        } catch (SAXException ex) {
            log(""Caught when validating: "" + ex.toString(), Project.MSG_DEBUG);
            if (failOnError) {
                throw new BuildException(
                    ""Could not validate document "" + afile);
            }
            log(""Could not validate document "" + afile + "": "" + ex.toString());
            result = false;
        } catch (IOException ex) {
            throw new BuildException(
                ""Could not validate document "" + afile,
                ex);
        }
        if (errorHandler.getFailure()) {
            if (failOnError) {
                throw new BuildException(
                    afile + "" is not a valid XML document."");
            }
            result = false;
            log(afile + "" is not a valid XML document"", Project.MSG_ERR);
        }
        return result;
    }

    
    protected class ValidatorErrorHandler implements ErrorHandler {

        
        protected File currentFile = null;
        protected String lastErrorMessage = null;
        protected boolean failed = false;
        
        
        public void init(File file) {
            currentFile = file;
            failed = false;
        }
        
        public boolean getFailure() {
            return failed;
        }

        
        public void fatalError(SAXParseException exception) {
            failed = true;
            doLog(exception, Project.MSG_ERR);
        }
        
        public void error(SAXParseException exception) {
            failed = true;
            doLog(exception, Project.MSG_ERR);
        }
        
        public void warning(SAXParseException exception) {
            
            
            if (warn) {
                doLog(exception, Project.MSG_WARN);
            }
        }

        private void doLog(SAXParseException e, int logLevel) {

            log(getMessage(e), logLevel);
        }

        private String getMessage(SAXParseException e) {
            String sysID = e.getSystemId();
            if (sysID != null) {
                String name = sysID;
                if (sysID.startsWith(""file:"")) {
                    try {
                        name = FILE_UTILS.fromURI(sysID);
                    } catch (Exception ex) {
                        
                    }
                }
                int line = e.getLineNumber();
                int col = e.getColumnNumber();
                return  name
                    + (line == -1
                       ? """"
                       : ("":"" + line + (col == -1 ? """" : ("":"" + col))))
                    + "": ""
                    + e.getMessage();
            }
            return e.getMessage();
        }
    }

    
    public static class Attribute {
        
        private String attributeName = null;

        
        private boolean attributeValue;

        
        public void setName(String name) {
            attributeName = name;
        }
        
        public void setValue(boolean value) {
            attributeValue = value;
        }

        
        public String getName() {
            return attributeName;
        }

        
        public boolean getValue() {
            return attributeValue;
        }
    }

    
    public static final class Property {

        private String name;
        private String value;
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }

    } 



}
"
org.apache.tools.ant.types.optional.depend.ClassfileSet,7,5,0,6,31,0,0,6,6,0.25,163,1.0,0,0.947916667,0.285714286,3,10,22.0,5,1.4286,0,"
package org.apache.tools.ant.types.optional.depend;

import java.util.Vector;
import java.util.Enumeration;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.FileSet;


public class ClassfileSet extends FileSet {
    
    private Vector rootClasses = new Vector();

    
    private Vector rootFileSets = new Vector();

    
    public static class ClassRoot {
        
        private String rootClass;

        
        public void setClassname(String name) {
            this.rootClass = name;
        }

        
        public String getClassname() {
            return rootClass;
        }
    }

    
    public ClassfileSet() {
    }

    
    public void addRootFileset(FileSet rootFileSet) {
        rootFileSets.addElement(rootFileSet);
    }

    
    protected ClassfileSet(ClassfileSet s) {
        super(s);
        rootClasses = (Vector) s.rootClasses.clone();
    }

    
    public void setRootClass(String rootClass) {
        rootClasses.addElement(rootClass);
    }

    
    public DirectoryScanner getDirectoryScanner(Project p) {
        if (isReference()) {
            return getRef(p).getDirectoryScanner(p);
        }
        Vector allRootClasses = (Vector) rootClasses.clone();
        for (Enumeration e = rootFileSets.elements(); e.hasMoreElements();) {
            FileSet additionalRootSet = (FileSet) e.nextElement();
            DirectoryScanner additionalScanner
                = additionalRootSet.getDirectoryScanner(p);
            String[] files = additionalScanner.getIncludedFiles();
            for (int i = 0; i < files.length; ++i) {
                if (files[i].endsWith("".class"")) {
                    String classFilePath
                        = files[i].substring(0, files[i].length() - 6);
                    String className
                        = classFilePath.replace('/', '.').replace('\\', '.');
                    allRootClasses.addElement(className);
                }
            }
        }
        DirectoryScanner parentScanner = super.getDirectoryScanner(p);
        DependScanner scanner = new DependScanner(parentScanner);
        scanner.setBasedir(getDir(p));
        scanner.setRootClasses(allRootClasses);
        scanner.scan();
        return scanner;
    }

    
    public void addConfiguredRoot(ClassRoot root) {
        rootClasses.addElement(root.getClassname());
    }

    
    public Object clone() {
        return new ClassfileSet(isReference()
            ? (ClassfileSet) (getRef(getProject())) : this);
    }

}
"
org.apache.tools.ant.util.KeepAliveOutputStream,2,3,0,2,3,1,2,0,2,2.0,7,0.0,0,0.909090909,0.75,1,1,2.5,1,0.5,0,"
package org.apache.tools.ant.util;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;


public class KeepAliveOutputStream extends FilterOutputStream {

    
    public KeepAliveOutputStream(OutputStream out) {
        super(out);
    }

    
    public void close() throws IOException {
        
    }
}
"
org.apache.tools.ant.taskdefs.optional.jlink.JlinkTask,11,4,0,6,35,9,0,6,8,0.7,217,1.0,2,0.886363636,0.363636364,2,2,18.36363636,3,1.4545,0,"
package org.apache.tools.ant.taskdefs.optional.jlink;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types.Path;


public class JlinkTask extends MatchingTask {

    
    public  void setOutfile(File outfile) {
        this.outfile = outfile;
    }

    
    public  Path createMergefiles() {
        if (this.mergefiles == null) {
            this.mergefiles = new Path(getProject());
        }
        return this.mergefiles.createPath();
    }

    
    public  void setMergefiles(Path mergefiles) {
        if (this.mergefiles == null) {
            this.mergefiles = mergefiles;
        } else {
            this.mergefiles.append(mergefiles);
        }
    }

    
    public  Path createAddfiles() {
        if (this.addfiles == null) {
            this.addfiles = new Path(getProject());
        }
        return this.addfiles.createPath();
    }

    
    public  void setAddfiles(Path addfiles) {
        if (this.addfiles == null) {
            this.addfiles = addfiles;
        } else {
            this.addfiles.append(addfiles);
        }
    }

    
    public  void setCompress(boolean compress) {
        this.compress = compress;
    }

    
    public  void execute() throws BuildException {
        
        if (outfile == null) {
            throw new BuildException(""outfile attribute is required! ""
                + ""Please set."");
        }
        if (!haveAddFiles() && !haveMergeFiles()) {
            throw new BuildException(""addfiles or mergefiles required! ""
                + ""Please set."");
        }
        log(""linking:     "" + outfile.getPath());
        log(""compression: "" + compress, Project.MSG_VERBOSE);
        jlink linker = new jlink();
        linker.setOutfile(outfile.getPath());
        linker.setCompression(compress);
        if (haveMergeFiles()) {
            log(""merge files: "" + mergefiles.toString(), Project.MSG_VERBOSE);
            linker.addMergeFiles(mergefiles.list());
        }
        if (haveAddFiles()) {
            log(""add files: "" + addfiles.toString(), Project.MSG_VERBOSE);
            linker.addAddFiles(addfiles.list());
        }
        try  {
            linker.link();
        } catch (Exception ex) {
            throw new BuildException(ex, getLocation());
        }
    }

    private boolean haveAddFiles() {
        return haveEntries(addfiles);
    }

    private boolean haveMergeFiles() {
        return haveEntries(mergefiles);
    }

    private boolean haveEntries(Path p) {
        if (p == null) {
            return false;
        }
        if (p.size() > 0) {
            return true;
        }
        return false;
    }

    private  File outfile = null;

    private  Path mergefiles = null;

    private  Path addfiles = null;

    private  boolean compress = false;

}


"
org.apache.tools.ant.XmlLogger,16,1,0,12,75,50,0,12,12,0.937037037,682,1.0,1,0.0,0.288888889,0,0,40.5,9,2.875,1,"

package org.apache.tools.ant;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.Writer;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Enumeration;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.tools.ant.util.DOMElementWriter;
import org.apache.tools.ant.util.StringUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;


public class XmlLogger implements BuildLogger {

    private int msgOutputLevel = Project.MSG_DEBUG;
    private PrintStream outStream;

    
    private static DocumentBuilder builder = getDocumentBuilder();

    
    private static DocumentBuilder getDocumentBuilder() {
        try {
            return DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (Exception exc) {
            throw new ExceptionInInitializerError(exc);
        }
    }

    
    private static final String BUILD_TAG = ""build"";
    
    private static final String TARGET_TAG = ""target"";
    
    private static final String TASK_TAG = ""task"";
    
    private static final String MESSAGE_TAG = ""message"";
    
    private static final String NAME_ATTR = ""name"";
    
    private static final String TIME_ATTR = ""time"";
    
    private static final String PRIORITY_ATTR = ""priority"";
    
    private static final String LOCATION_ATTR = ""location"";
    
    private static final String ERROR_ATTR = ""error"";
    
    private static final String STACKTRACE_TAG = ""stacktrace"";

    
    private Document doc = builder.newDocument();
    
    private Hashtable tasks = new Hashtable();
    
    private Hashtable targets = new Hashtable();
    
    private Hashtable threadStacks = new Hashtable();
    
    private TimedElement buildElement = null;

    
    private static class TimedElement {
        
        private long startTime;
        
        private Element element;
        public String toString() {
            return element.getTagName() + "":"" + element.getAttribute(""name"");
        }
    }

    
    public XmlLogger() {
    }

    
    public void buildStarted(BuildEvent event) {
        buildElement = new TimedElement();
        buildElement.startTime = System.currentTimeMillis();
        buildElement.element = doc.createElement(BUILD_TAG);
    }

    
    public void buildFinished(BuildEvent event) {
        long totalTime = System.currentTimeMillis() - buildElement.startTime;
        buildElement.element.setAttribute(TIME_ATTR,
                DefaultLogger.formatTime(totalTime));

        if (event.getException() != null) {
            buildElement.element.setAttribute(ERROR_ATTR,
                    event.getException().toString());
            
            
            Throwable t = event.getException();
            Text errText = doc.createCDATASection(StringUtils.getStackTrace(t));
            Element stacktrace = doc.createElement(STACKTRACE_TAG);
            stacktrace.appendChild(errText);
            buildElement.element.appendChild(stacktrace);
        }

        String outFilename = event.getProject().getProperty(""XmlLogger.file"");
        if (outFilename == null) {
            outFilename = ""log.xml"";
        }
        String xslUri
                = event.getProject().getProperty(""ant.XmlLogger.stylesheet.uri"");
        if (xslUri == null) {
            xslUri = ""log.xsl"";
        }
        Writer out = null;
        try {
            
            
            OutputStream stream = outStream;
            if (stream == null) {
                stream = new FileOutputStream(outFilename);
            }
            out = new OutputStreamWriter(stream, ""UTF8"");
            out.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
            if (xslUri.length() > 0) {
                out.write(""<?xml-stylesheet type=\""text/xsl\"" href=\""""
                        + xslUri + ""\""?>\n\n"");
            }
            (new DOMElementWriter()).write(buildElement.element, out, 0, ""\t"");
            out.flush();
        } catch (IOException exc) {
            throw new BuildException(""Unable to write log file"", exc);
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    
                }
            }
        }
        buildElement = null;
    }

    
    private Stack getStack() {
        Stack threadStack = (Stack) threadStacks.get(Thread.currentThread());
        if (threadStack == null) {
            threadStack = new Stack();
            threadStacks.put(Thread.currentThread(), threadStack);
        }
        
        return threadStack;
    }

    
    public void targetStarted(BuildEvent event) {
        Target target = event.getTarget();
        TimedElement targetElement = new TimedElement();
        targetElement.startTime = System.currentTimeMillis();
        targetElement.element = doc.createElement(TARGET_TAG);
        targetElement.element.setAttribute(NAME_ATTR, target.getName());
        targets.put(target, targetElement);
        getStack().push(targetElement);
    }

    
    public void targetFinished(BuildEvent event) {
        Target target = event.getTarget();
        TimedElement targetElement = (TimedElement) targets.get(target);
        if (targetElement != null) {
            long totalTime
                    = System.currentTimeMillis() - targetElement.startTime;
            targetElement.element.setAttribute(TIME_ATTR,
                    DefaultLogger.formatTime(totalTime));

            TimedElement parentElement = null;
            Stack threadStack = getStack();
            if (!threadStack.empty()) {
                TimedElement poppedStack = (TimedElement) threadStack.pop();
                if (poppedStack != targetElement) {
                    throw new RuntimeException(""Mismatch - popped element = ""
                            + poppedStack
                            + "" finished target element = ""
                            + targetElement);
                }
                if (!threadStack.empty()) {
                    parentElement = (TimedElement) threadStack.peek();
                }
            }
            if (parentElement == null) {
                buildElement.element.appendChild(targetElement.element);
            } else {
                parentElement.element.appendChild(targetElement.element);
            }
        }
        targets.remove(target);
    }

    
    public void taskStarted(BuildEvent event) {
        TimedElement taskElement = new TimedElement();
        taskElement.startTime = System.currentTimeMillis();
        taskElement.element = doc.createElement(TASK_TAG);

        Task task = event.getTask();
        String name = event.getTask().getTaskName();
        if (name == null) {
            name = """";
        }
        taskElement.element.setAttribute(NAME_ATTR, name);
        taskElement.element.setAttribute(LOCATION_ATTR,
                event.getTask().getLocation().toString());
        tasks.put(task, taskElement);
        getStack().push(taskElement);
    }

    
    public void taskFinished(BuildEvent event) {
        Task task = event.getTask();
        TimedElement taskElement = (TimedElement) tasks.get(task);
        if (taskElement != null) {
            long totalTime = System.currentTimeMillis() - taskElement.startTime;
            taskElement.element.setAttribute(TIME_ATTR,
                    DefaultLogger.formatTime(totalTime));
            Target target = task.getOwningTarget();
            TimedElement targetElement = null;
            if (target != null) {
                targetElement = (TimedElement) targets.get(target);
            }
            if (targetElement == null) {
                buildElement.element.appendChild(taskElement.element);
            } else {
                targetElement.element.appendChild(taskElement.element);
            }
            Stack threadStack = getStack();
            if (!threadStack.empty()) {
                TimedElement poppedStack = (TimedElement) threadStack.pop();
                if (poppedStack != taskElement) {
                    throw new RuntimeException(""Mismatch - popped element = ""
                            + poppedStack + "" finished task element = ""
                            + taskElement);
                }
            }
            tasks.remove(task);
        } else {
            throw new RuntimeException(""Unknown task "" + task + "" not in "" + tasks);
        }
    }


    
    private TimedElement getTaskElement(Task task) {
        TimedElement element = (TimedElement) tasks.get(task);
        if (element != null) {
            return element;
        }

        for (Enumeration e = tasks.keys(); e.hasMoreElements();) {
            Task key = (Task) e.nextElement();
            if (key instanceof UnknownElement) {
                if (((UnknownElement) key).getTask() == task) {
                    return (TimedElement) tasks.get(key);
                }
            }
        }

        return null;
    }

    
    public void messageLogged(BuildEvent event) {
        int priority = event.getPriority();
        if (priority > msgOutputLevel) {
            return;
        }
        Element messageElement = doc.createElement(MESSAGE_TAG);

        String name = ""debug"";
        switch (event.getPriority()) {
            case Project.MSG_ERR:
                name = ""error"";
                break;
            case Project.MSG_WARN:
                name = ""warn"";
                break;
            case Project.MSG_INFO:
                name = ""info"";
                break;
            default:
                name = ""debug"";
                break;
        }
        messageElement.setAttribute(PRIORITY_ATTR, name);

        Throwable ex = event.getException();
        if (Project.MSG_DEBUG <= msgOutputLevel && ex != null) {
            Text errText = doc.createCDATASection(StringUtils.getStackTrace(ex));
            Element stacktrace = doc.createElement(STACKTRACE_TAG);
            stacktrace.appendChild(errText);
            buildElement.element.appendChild(stacktrace);
        }
        Text messageText = doc.createCDATASection(event.getMessage());
        messageElement.appendChild(messageText);

        TimedElement parentElement = null;

        Task task = event.getTask();

        Target target = event.getTarget();
        if (task != null) {
            parentElement = getTaskElement(task);
        }
        if (parentElement == null && target != null) {
            parentElement = (TimedElement) targets.get(target);
        }

        

        if (parentElement != null) {
            parentElement.element.appendChild(messageElement);
        } else {
            buildElement.element.appendChild(messageElement);
        }
    }

    

    
    public void setMessageOutputLevel(int level) {
        msgOutputLevel = level;
    }

    
    public void setOutputPrintStream(PrintStream output) {
        this.outStream = new PrintStream(output, true);
    }

    
    public void setEmacsMode(boolean emacsMode) {
    }

    
    public void setErrorPrintStream(PrintStream err) {
    }

}
"
org.apache.tools.ant.taskdefs.optional.junit.XMLConstants,0,1,0,2,0,0,2,0,0,2.0,22,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.tools.ant.taskdefs.optional.junit;


public interface XMLConstants {
    
    String TESTSUITES = ""testsuites"";

    
    String TESTSUITE = ""testsuite"";

    
    String TESTCASE = ""testcase"";

    
    String ERROR = ""error"";

    
    String FAILURE = ""failure"";

    
    String SYSTEM_ERR = ""system-err"";

    
    String SYSTEM_OUT = ""system-out"";

    
    String ATTR_PACKAGE = ""package"";

    
    String ATTR_NAME = ""name"";

    
    String ATTR_TIME = ""time"";

    
    String ATTR_ERRORS = ""errors"";

    
    String ATTR_FAILURES = ""failures"";

    
    String ATTR_TESTS = ""tests"";

    
    String ATTR_TYPE = ""type"";

    
    String ATTR_MESSAGE = ""message"";

    
    String PROPERTIES = ""properties"";

    
    String PROPERTY = ""property"";

    
    String ATTR_VALUE = ""value"";

    
    String ATTR_CLASSNAME = ""classname"";

    
    String ATTR_ID = ""id"";

    
    String TIMESTAMP = ""timestamp"";

    
    String HOSTNAME = ""hostname"";
}
"
org.apache.tools.ant.filters.StringInputStream,2,3,0,1,5,1,0,1,2,2.0,17,0.0,0,1.0,1.0,0,0,7.5,0,0.0,0,"
package org.apache.tools.ant.filters;

import java.io.StringReader;

import org.apache.tools.ant.util.ReaderInputStream;


public class StringInputStream extends ReaderInputStream {

    
    public StringInputStream(String source) {
        super(new StringReader(source));
    }

    
    public StringInputStream(String source, String encoding) {
        super(new StringReader(source), encoding);
    }

}
"
org.apache.tools.ant.taskdefs.rmic.DefaultRmicAdapter,15,1,4,12,53,71,5,8,5,0.976190476,390,0.333333333,2,0.0,0.228571429,0,0,24.4,18,2.3333,3,"

package org.apache.tools.ant.taskdefs.rmic;

import java.io.File;
import java.util.Random;
import java.util.Vector;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Rmic;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileNameMapper;


public abstract class DefaultRmicAdapter implements RmicAdapter {

    private Rmic attributes;
    private FileNameMapper mapper;
    private static final Random RAND = new Random();
    
    public static final String RMI_STUB_SUFFIX = ""_Stub"";
    
    public static final String RMI_SKEL_SUFFIX = ""_Skel"";
    
    public static final String RMI_TIE_SUFFIX = ""_Tie"";
    
    public static final String STUB_COMPAT = ""-vcompat"";
    
    public static final String STUB_1_1 = ""-v1.1"";
    
    public static final String STUB_1_2 = ""-v1.2"";

    
    public DefaultRmicAdapter() {
    }

    
    public void setRmic(final Rmic attributes) {
        this.attributes = attributes;
        mapper = new RmicFileNameMapper();
    }

    
    public Rmic getRmic() {
        return attributes;
    }

    
    protected String getStubClassSuffix() {
        return RMI_STUB_SUFFIX;
    }

    
    protected String getSkelClassSuffix() {
        return RMI_SKEL_SUFFIX;
    }

    
    protected String getTieClassSuffix() {
        return RMI_TIE_SUFFIX;
    }

    
    public FileNameMapper getMapper() {
        return mapper;
    }

    
    public Path getClasspath() {
        return getCompileClasspath();
    }

    
    protected Path getCompileClasspath() {
        Path classpath = new Path(attributes.getProject());
        
        
        classpath.setLocation(attributes.getBase());

        
        

        Path cp = attributes.getClasspath();
        if (cp == null) {
            cp = new Path(attributes.getProject());
        }
        if (attributes.getIncludeantruntime()) {
            classpath.addExisting(cp.concatSystemClasspath(""last""));
        } else {
            classpath.addExisting(cp.concatSystemClasspath(""ignore""));
        }

        if (attributes.getIncludejavaruntime()) {
            classpath.addJavaRuntime();
        }
        return classpath;
    }

    
    protected Commandline setupRmicCommand() {
        return setupRmicCommand(null);
    }

    
    protected Commandline setupRmicCommand(String[] options) {
        Commandline cmd = new Commandline();

        if (options != null) {
            for (int i = 0; i < options.length; i++) {
                cmd.createArgument().setValue(options[i]);
            }
        }

        Path classpath = getCompileClasspath();

        cmd.createArgument().setValue(""-d"");
        cmd.createArgument().setFile(attributes.getBase());

        if (attributes.getExtdirs() != null) {
            cmd.createArgument().setValue(""-extdirs"");
            cmd.createArgument().setPath(attributes.getExtdirs());
        }

        cmd.createArgument().setValue(""-classpath"");
        cmd.createArgument().setPath(classpath);

        
        String stubVersion = attributes.getStubVersion();
        
        String stubOption = null;
        if (null != stubVersion) {
            if (""1.1"".equals(stubVersion)) {
                stubOption = STUB_1_1;
            } else if (""1.2"".equals(stubVersion)) {
                stubOption = STUB_1_2;
            } else if (""compat"".equals(stubVersion)) {
                stubOption = STUB_COMPAT;
            } else {
                
                attributes.log(""Unknown stub option "" + stubVersion);
                
            }
        }
        
        
        if (stubOption == null
            && !attributes.getIiop()
            && !attributes.getIdl()) {
            stubOption = STUB_COMPAT;
        }
        if (stubOption != null) {
            
            cmd.createArgument().setValue(stubOption);
        }
        if (null != attributes.getSourceBase()) {
            cmd.createArgument().setValue(""-keepgenerated"");
        }

        if (attributes.getIiop()) {
            attributes.log(""IIOP has been turned on."", Project.MSG_INFO);
            cmd.createArgument().setValue(""-iiop"");
            if (attributes.getIiopopts() != null) {
                attributes.log(""IIOP Options: "" + attributes.getIiopopts(),
                               Project.MSG_INFO);
                cmd.createArgument().setValue(attributes.getIiopopts());
            }
        }

        if (attributes.getIdl())  {
            cmd.createArgument().setValue(""-idl"");
            attributes.log(""IDL has been turned on."", Project.MSG_INFO);
            if (attributes.getIdlopts() != null) {
                cmd.createArgument().setValue(attributes.getIdlopts());
                attributes.log(""IDL Options: "" + attributes.getIdlopts(),
                               Project.MSG_INFO);
            }
        }

        if (attributes.getDebug()) {
            cmd.createArgument().setValue(""-g"");
        }

        cmd.addArguments(attributes.getCurrentCompilerArgs());

        logAndAddFilesToCompile(cmd);
        return cmd;
     }

    
    protected void logAndAddFilesToCompile(Commandline cmd) {
        Vector compileList = attributes.getCompileList();

        attributes.log(""Compilation "" + cmd.describeArguments(),
                       Project.MSG_VERBOSE);

        StringBuffer niceSourceList = new StringBuffer(""File"");
        int cListSize = compileList.size();
        if (cListSize != 1) {
            niceSourceList.append(""s"");
        }
        niceSourceList.append("" to be compiled:"");

        for (int i = 0; i < cListSize; i++) {
            String arg = (String) compileList.elementAt(i);
            cmd.createArgument().setValue(arg);
            niceSourceList.append(""    "");
            niceSourceList.append(arg);
        }

        attributes.log(niceSourceList.toString(), Project.MSG_VERBOSE);
    }

    
    private class RmicFileNameMapper implements FileNameMapper {

        RmicFileNameMapper() {
        }

        
        public void setFrom(String s) {
        }
        
        public void setTo(String s) {
        }

        public String[] mapFileName(String name) {
            if (name == null
                || !name.endsWith("".class"")
                || name.endsWith(getStubClassSuffix() + "".class"")
                || name.endsWith(getSkelClassSuffix() + "".class"")
                || name.endsWith(getTieClassSuffix() + "".class"")) {
                
                return null;
            }

            
            String base = name.substring(0, name.length() - 6);

            String classname = base.replace(File.separatorChar, '.');
            if (attributes.getVerify()
                && !attributes.isValidRmiRemote(classname)) {
                return null;
            }

            
            String[] target = new String[] {name + "".tmp."" + RAND.nextLong()};

            if (!attributes.getIiop() && !attributes.getIdl()) {
                
                if (""1.2"".equals(attributes.getStubVersion())) {
                    target = new String[] {
                        base + getStubClassSuffix() + "".class""
                    };
                } else {
                    target = new String[] {
                        base + getStubClassSuffix() + "".class"",
                        base + getSkelClassSuffix() + "".class"",
                    };
                }
            } else if (!attributes.getIdl()) {
                int lastSlash = base.lastIndexOf(File.separatorChar);

                String dirname = """";
                
                int index = -1;
                if (lastSlash == -1) {
                    
                    index = 0;
                } else {
                    index = lastSlash + 1;
                    dirname = base.substring(0, index);
                }

                String filename = base.substring(index);

                try {
                    Class c = attributes.getLoader().loadClass(classname);

                    if (c.isInterface()) {
                        
                        target = new String[] {
                            dirname + ""_"" + filename + getStubClassSuffix()
                            + "".class""
                        };
                    } else {
                        
                        Class interf = attributes.getRemoteInterface(c);
                        String iName = interf.getName();
                        String iDir = """";
                        int iIndex = -1;
                        int lastDot = iName.lastIndexOf(""."");
                        if (lastDot == -1) {
                            
                            iIndex = 0;
                        } else {
                            iIndex = lastDot + 1;
                            iDir = iName.substring(0, iIndex);
                            iDir = iDir.replace('.', File.separatorChar);
                        }

                        target = new String[] {
                            dirname + ""_"" + filename + getTieClassSuffix()
                            + "".class"",
                            iDir + ""_"" + iName.substring(iIndex)
                            + getStubClassSuffix() + "".class""
                        };
                    }
                } catch (ClassNotFoundException e) {
                    attributes.log(""Unable to verify class "" + classname
                                   + "". It could not be found."",
                                   Project.MSG_WARN);
                } catch (NoClassDefFoundError e) {
                    attributes.log(""Unable to verify class "" + classname
                                   + "". It is not defined."", Project.MSG_WARN);
                } catch (Throwable t) {
                    attributes.log(""Unable to verify class "" + classname
                                   + "". Loading caused Exception: ""
                                   + t.getMessage(), Project.MSG_WARN);
                }
            }
            return target;
        }
    }
}
"
org.apache.tools.ant.taskdefs.Dirname,4,3,0,4,10,2,0,4,4,0.666666667,48,1.0,0,0.925,0.5,0,0,10.5,1,0.75,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;



public class Dirname extends Task {
    private File file;
    private String property;

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setProperty(String property) {
        this.property = property;
    }


    
    public void execute() throws BuildException {
        if (property == null) {
            throw new BuildException(""property attribute required"", getLocation());
        }
        if (file == null) {
            throw new BuildException(""file attribute required"", getLocation());
        } else {
            String value = file.getParent();
            getProject().setNewProperty(property, value);
        }
    }
}

"
org.apache.tools.ant.taskdefs.optional.perforce.P4Fstat,9,4,0,7,37,10,1,7,6,0.9296875,323,1.0,1,0.86440678,0.277777778,0,0,33.11111111,4,1.4444,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;


import java.io.File;
import java.util.Vector;
import java.util.ArrayList;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.FileSet;


public class P4Fstat extends P4Base {

    private int changelist;
    private String addCmd = """";
    private Vector filesets = new Vector();
    private static final int DEFAULT_CMD_LENGTH = 300;
    private int cmdLength = DEFAULT_CMD_LENGTH;
    private static final int SHOW_ALL = 0;
    private static final int SHOW_EXISTING = 1;
    private static final int SHOW_NON_EXISTING = 2;
    private int show = SHOW_NON_EXISTING;
    private FStatP4OutputHandler handler;
    private StringBuffer filelist;
    private int fileNum = 0;
    private int doneFileNum = 0;
    private boolean debug = false;

    private static final String EXISTING_HEADER
        = ""Following files exist in perforce"";
    private static final String NONEXISTING_HEADER
        = ""Following files do not exist in perforce"";

    
    public void setShowFilter(String filter) {
        if (filter.equalsIgnoreCase(""all"")) {
            show = SHOW_ALL;
        } else if (filter.equalsIgnoreCase(""existing"")) {
            show = SHOW_EXISTING;
        } else if (filter.equalsIgnoreCase(""non-existing"")) {
            show = SHOW_NON_EXISTING;
        } else {
            throw new BuildException(""P4Fstat: ShowFilter should be one of: ""
                + ""all, existing, non-existing"");
        }
    }

    
    public void setChangelist(int changelist) throws BuildException {
        if (changelist <= 0) {
            throw new BuildException(""P4FStat: Changelist# should be a ""
                + ""positive number"");
        }
        this.changelist = changelist;
    }

    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }

    
    public void execute() throws BuildException {
        handler = new FStatP4OutputHandler(this);
        if (P4View != null) {
            addCmd = P4View;
        }
        P4CmdOpts = (changelist > 0) ? (""-c "" + changelist) : """";

        filelist = new StringBuffer();

        for (int i = 0; i < filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());

            String[] srcFiles = ds.getIncludedFiles();
            fileNum = srcFiles.length;

            if (srcFiles != null) {
                for (int j = 0; j < srcFiles.length; j++) {
                    File f = new File(ds.getBasedir(), srcFiles[j]);
                    filelist.append("" "").append('""').append(f.getAbsolutePath()).append('""');
                    doneFileNum++;
                    if (filelist.length() > cmdLength) {

                        execP4Fstat(filelist);
                        filelist = new StringBuffer();
                    }
                }
                if (filelist.length() > 0) {
                    execP4Fstat(filelist);
                }
            } else {
                log(""No files specified to query status on!"", Project.MSG_WARN);
            }
        }
        if (show == SHOW_ALL || show == SHOW_EXISTING) {
            printRes(handler.getExisting(), EXISTING_HEADER);
        }
        if (show == SHOW_ALL || show == SHOW_NON_EXISTING) {
            printRes(handler.getNonExisting(), NONEXISTING_HEADER);
        }
    }

    
    public int getLengthOfTask() {
        return fileNum;
    }

    
    int getPasses() {
        return filesets.size();
    }

    private void printRes(ArrayList ar, String header) {
        log(header, Project.MSG_INFO);
        for (int i = 0; i < ar.size(); i++) {
            log((String) ar.get(i), Project.MSG_INFO);
        }
    }

    private void execP4Fstat(StringBuffer list) {
        String l = list.substring(0);
        if (debug) {
            log(""Executing fstat "" + P4CmdOpts + "" "" + addCmd + l + ""\n"",
                Project.MSG_INFO);
        }
        execP4Command(""fstat "" + P4CmdOpts + "" "" + addCmd + l, handler);
    }

}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSCHECKOUT,11,4,0,8,38,55,0,8,10,2.0,122,0.0,0,0.900990099,0.303030303,1,1,10.09090909,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class MSVSSCHECKOUT extends MSVSS {

    
    protected Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_CHECKOUT);

        
        commandLine.createArgument().setValue(getVsspath());
        
        commandLine.createArgument().setValue(getLocalpath());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(getRecursive());
        
        commandLine.createArgument().setValue(getVersionDateLabel());
        
        commandLine.createArgument().setValue(getLogin());
        
        commandLine.createArgument().setValue(getFileTimeStamp());
        
        commandLine.createArgument().setValue(getWritableFiles());
        
        commandLine.createArgument().setValue(getGetLocalCopy());

        return commandLine;
    }

    
    public void setLocalpath(Path localPath) {
        super.setInternalLocalPath(localPath.toString());
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public void setVersion(String version) {
        super.setInternalVersion(version);
    }

    
    public void setDate(String date) {
        super.setInternalDate(date);
    }

    
    public void setLabel(String label) {
        super.setInternalLabel(label);
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }

    
    public void setFileTimeStamp(CurrentModUpdated timestamp) {
        super.setInternalFileTimeStamp(timestamp);
    }

    
    public void setWritableFiles(WritableFiles files) {
        super.setInternalWritableFiles(files);
    }

    
    public void setGetLocalCopy(boolean get) {
        super.setInternalGetLocalCopy(get);
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.LibraryDisplayer,6,1,0,5,26,15,1,4,0,2.0,211,0.0,0,0.0,0.4,0,0,34.16666667,3,1.3333,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import java.text.ParseException;
import java.util.jar.Manifest;
import org.apache.tools.ant.BuildException;


class LibraryDisplayer {
    
    void displayLibrary(final File file)
        throws BuildException {
        final Manifest manifest = ExtensionUtil.getManifest(file);
        displayLibrary(file, manifest);
    }

    
    void displayLibrary(final File file,
                         final Manifest manifest)
        throws BuildException {
        final Extension[] available = Extension.getAvailable(manifest);
        final Extension[] required = Extension.getRequired(manifest);
        final Extension[] options = Extension.getOptions(manifest);
        final Specification[] specifications = getSpecifications(manifest);

        if (0 == available.length && 0 == required.length && 0 == options.length
            && 0 == specifications.length) {
            return;
        }

        final String message = ""File: "" + file;
        final int size = message.length();
        printLine(size);
        System.out.println(message);
        printLine(size);
        if (0 != available.length) {
            System.out.println(""Extensions Supported By Library:"");
            for (int i = 0; i < available.length; i++) {
                final Extension extension = available[ i ];
                System.out.println(extension.toString());
            }
        }

        if (0 != required.length) {
            System.out.println(""Extensions Required By Library:"");
            for (int i = 0; i < required.length; i++) {
                final Extension extension = required[ i ];
                System.out.println(extension.toString());
            }
        }

        if (0 != options.length) {
            System.out.println(""Extensions that will be used by Library if present:"");
            for (int i = 0; i < options.length; i++) {
                final Extension extension = options[ i ];
                System.out.println(extension.toString());
            }
        }

        if (0 != specifications.length) {
            System.out.println(""Specifications Supported By Library:"");
            for (int i = 0; i < specifications.length; i++) {
                final Specification specification = specifications[ i ];
                displaySpecification(specification);
            }
        }
    }

    
    private void printLine(final int size) {
        for (int i = 0; i < size; i++) {
            System.out.print(""-"");
        }
        System.out.println();
    }

    
    private Specification[] getSpecifications(final Manifest manifest)
        throws BuildException {
        try {
            return Specification.getSpecifications(manifest);
        } catch (final ParseException pe) {
            throw new BuildException(pe.getMessage(), pe);
        }
    }

    
    private void displaySpecification(final Specification specification) {
        final String[] sections = specification.getSections();
        if (null != sections) {
            final StringBuffer sb = new StringBuffer(""Sections: "");
            for (int i = 0; i < sections.length; i++) {
                sb.append("" "");
                sb.append(sections[ i ]);
            }
            System.out.println(sb);
        }
        System.out.println(specification.toString());
    }
}
"
org.apache.tools.ant.types.TarScanner,2,3,0,7,17,1,1,6,1,2.0,108,0.0,0,0.987179487,0.625,1,3,53.0,8,4.0,0,"

package org.apache.tools.ant.types;

import java.io.IOException;
import java.util.Map;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.resources.TarResource;
import org.apache.tools.tar.TarEntry;
import org.apache.tools.tar.TarInputStream;


public class TarScanner extends ArchiveScanner {

    
    protected void fillMapsFromArchive(Resource src, String encoding,
                                       Map fileEntries, Map matchFileEntries,
                                       Map dirEntries, Map matchDirEntries) {
        TarEntry entry = null;
        TarInputStream ti = null;

        try {
            try {
                ti = new TarInputStream(src.getInputStream());
            } catch (IOException ex) {
                throw new BuildException(""problem opening "" + srcFile, ex);
            }
            while ((entry = ti.getNextEntry()) != null) {
                Resource r = new TarResource(src, entry);
                String name = entry.getName();
                if (entry.isDirectory()) {
                    name = trimSeparator(name);
                    dirEntries.put(name, r);
                    if (match(name)) {
                        matchDirEntries.put(name, r);
                    }
                } else {
                    fileEntries.put(name, r);
                    if (match(name)) {
                        matchFileEntries.put(name, r);
                    }
                }
            }
        } catch (IOException ex) {
            throw new BuildException(""problem reading "" + srcFile, ex);
        } finally {
            if (ti != null) {
                try {
                    ti.close();
                } catch (IOException ex) {
                    
                }
            }
        }
    }
}
"
org.apache.tools.ant.filters.ConcatFilter,9,5,0,4,28,12,0,4,8,0.5,217,1.0,0,0.8,0.481481481,2,5,22.66666667,1,0.7778,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.io.File;
import java.io.BufferedReader;
import java.io.FileReader;
import org.apache.tools.ant.types.Parameter;


public final class ConcatFilter extends BaseParamFilterReader
    implements ChainableReader {

    
    private File prepend;

    
    private File append;

    
    private Reader prependReader = null;

    
    private Reader appendReader = null;

    
    public ConcatFilter() {
        super();
    }

    
    public ConcatFilter(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;

        
        
        if (prependReader != null) {
            ch = prependReader.read();
            if (ch == -1) {
                
                prependReader.close();
                prependReader = null;
            }
        }
        if (ch == -1) {
            ch = super.read();
        }
        if (ch == -1) {
            
            
            if (appendReader != null) {
                ch = appendReader.read();
                if (ch == -1) {
                    
                    appendReader.close();
                    appendReader = null;
                }
            }
        }

        return ch;
    }

    
    public void setPrepend(final File prepend) {
        this.prepend = prepend;
    }

    
    public File getPrepend() {
        return prepend;
    }

    
    public void setAppend(final File append) {
        this.append = append;
    }

    
    public File getAppend() {
        return append;
    }

    
    public Reader chain(final Reader rdr) {
        ConcatFilter newFilter = new ConcatFilter(rdr);
        newFilter.setPrepend(getPrepend());
        newFilter.setAppend(getAppend());
        
        
        
        
        return newFilter;
    }

    
    private void initialize() throws IOException {
        
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (""prepend"".equals(params[i].getName())) {
                    setPrepend(new File(params[i].getValue()));
                    continue;
                }
                if (""append"".equals(params[i].getName())) {
                    setAppend(new File(params[i].getValue()));
                    continue;
                }
            }
        }
        if (prepend != null) {
            if (!prepend.isAbsolute()) {
                prepend = new File(getProject().getBaseDir(), prepend.getPath());
            }
            prependReader = new BufferedReader(new FileReader(prepend));
        }
        if (append != null) {
            if (!append.isAbsolute()) {
                append = new File(getProject().getBaseDir(), append.getPath());
            }
            appendReader = new BufferedReader(new FileReader(append));
        }
   }
}
"
org.apache.tools.ant.taskdefs.ImportTask,5,3,0,7,31,4,0,7,4,0.75,178,1.0,1,0.925,0.5,2,2,34.0,11,2.6,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;

import java.io.File;
import java.util.Vector;


public class ImportTask extends Task {
    private String file;
    private boolean optional;
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public void setOptional(boolean optional) {
        this.optional = optional;
    }

    
    public void setFile(String file) {
        
        
        this.file = file;
    }

    
    public void execute() {
        if (file == null) {
            throw new BuildException(""import requires file attribute"");
        }
        if (getOwningTarget() == null
            || !"""".equals(getOwningTarget().getName())) {
            throw new BuildException(""import only allowed as a top-level task"");
        }

        ProjectHelper helper =
                (ProjectHelper) getProject().
                    getReference(ProjectHelper.PROJECTHELPER_REFERENCE);

        if (helper == null) {
            
            throw new BuildException(""import requires support in ProjectHelper"");
        }

        Vector importStack = helper.getImportStack();

        if (importStack.size() == 0) {
            
            
            throw new BuildException(""import requires support in ProjectHelper"");
        }

        if (getLocation() == null || getLocation().getFileName() == null) {
            throw new BuildException(""Unable to get location of import task"");
        }

        File buildFile = new File(getLocation().getFileName()).getAbsoluteFile();

        
        

        File buildFileParent = new File(buildFile.getParent());
        File importedFile = FILE_UTILS.resolveFile(buildFileParent, file);

        getProject().log(""Importing file "" + importedFile + "" from ""
                         + buildFile.getAbsolutePath(), Project.MSG_VERBOSE);

        if (!importedFile.exists()) {
            String message =
                ""Cannot find "" + file + "" imported from ""
                + buildFile.getAbsolutePath();
            if (optional) {
                getProject().log(message, Project.MSG_VERBOSE);
                return;
            } else {
                throw new BuildException(message);
            }
        }

        if (importStack.contains(importedFile)) {
            getProject().log(
                ""Skipped already imported file:\n   ""
                + importedFile + ""\n"", Project.MSG_VERBOSE);
            return;
        }

        try {
            helper.parse(getProject(), importedFile);
        } catch (BuildException ex) {
            throw ProjectHelper.addLocationToBuildException(
                ex, getLocation());
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Resolve,13,4,0,4,22,56,0,4,12,0.946969697,298,1.0,0,0.822580645,0.472222222,2,2,21.07692308,4,1.0769,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;


public class P4Resolve extends P4Base {
    private String resolvemode = null;


    private boolean redoall; 
    private boolean simulationmode;  
    private boolean forcetextmode;  
    private boolean markersforall; 
    private static final String AUTOMATIC = ""automatic"";
    private static final String FORCE = ""force"";
    private static final String SAFE = ""safe"";
    private static final String THEIRS = ""theirs"";
    private static final String YOURS = ""yours"";
    private static final String[] RESOLVE_MODES = {
        AUTOMATIC,
        FORCE,
        SAFE,
        THEIRS,
        YOURS
    };
   
    public String getResolvemode() {
        return resolvemode;
    }
    
    public void setResolvemode(String resolvemode) {
        boolean found = false;
        for (int counter = 0; counter < RESOLVE_MODES.length; counter++) {
            if (resolvemode.equals(RESOLVE_MODES[counter])) {
                found = true;
                break;
            }
        }
        if (!found) {
            throw new BuildException(""Unacceptable value for resolve mode"");
        }
        this.resolvemode = resolvemode;
    }

    
    public boolean isRedoall() {
        return redoall;
    }

    
    public void setRedoall(boolean redoall) {
        this.redoall = redoall;
    }

    
    public boolean isSimulationmode() {
        return simulationmode;
    }

    
    public void setSimulationmode(boolean simulationmode) {
        this.simulationmode = simulationmode;
    }

    
    public boolean isForcetextmode() {
        return forcetextmode;
    }

    
    public void setForcetextmode(boolean forcetextmode) {
        this.forcetextmode = forcetextmode;
    }

    
    public boolean isMarkersforall() {
        return markersforall;
    }

    
    public void setMarkersforall(boolean markersforall) {
        this.markersforall = markersforall;
    }

    
    public void execute() throws BuildException {
        if (this.resolvemode.equals(AUTOMATIC)) {
            P4CmdOpts = P4CmdOpts + "" -am"";
        } else if (this.resolvemode.equals(FORCE)) {
            P4CmdOpts = P4CmdOpts + "" -af"";
        } else if (this.resolvemode.equals(SAFE)) {
            P4CmdOpts = P4CmdOpts + "" -as"";
        } else if (this.resolvemode.equals(THEIRS)) {
            P4CmdOpts = P4CmdOpts + "" -at"";
        } else if (this.resolvemode.equals(YOURS)) {
            P4CmdOpts = P4CmdOpts + "" -ay"";
        } else {
            throw new BuildException(""unsupported or absent resolve mode"");
        }
        if (P4View == null) {
            throw new BuildException(""please specify a view"");
        }
        if (this.isRedoall()) {
            P4CmdOpts = P4CmdOpts + "" -f"";
        }
        if (this.isSimulationmode()) {
            P4CmdOpts = P4CmdOpts + "" -n"";
        }
        if (this.isForcetextmode()) {
            P4CmdOpts = P4CmdOpts + "" -t"";
        }
        if (this.isMarkersforall()) {
            P4CmdOpts = P4CmdOpts + "" -v"";
        }
        execP4Command(""-s resolve "" + P4CmdOpts + "" "" + P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.SendEmail,2,4,0,1,5,1,0,1,2,2.0,10,0.0,0,0.985507246,0.75,1,1,4.0,1,0.5,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.taskdefs.email.EmailTask;


public class SendEmail extends EmailTask {
    
    public void setMailport(Integer value) {
        setMailport(value.intValue());
    }
}
"
org.apache.tools.ant.taskdefs.Delete,46,4,0,39,135,17,2,37,40,0.883760684,1100,1.0,3,0.639344262,0.074666667,3,5,22.63043478,16,1.6739,5,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.Arrays;
import java.util.Vector;
import java.util.Iterator;
import java.util.Comparator;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.Sort;
import org.apache.tools.ant.types.resources.Restrict;
import org.apache.tools.ant.types.resources.Resources;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.FileResourceIterator;
import org.apache.tools.ant.types.resources.comparators.Reverse;
import org.apache.tools.ant.types.resources.comparators.FileSystem;
import org.apache.tools.ant.types.resources.comparators.ResourceComparator;
import org.apache.tools.ant.types.resources.selectors.Exists;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.types.selectors.OrSelector;
import org.apache.tools.ant.types.selectors.AndSelector;
import org.apache.tools.ant.types.selectors.NotSelector;
import org.apache.tools.ant.types.selectors.DateSelector;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.NoneSelector;
import org.apache.tools.ant.types.selectors.SizeSelector;
import org.apache.tools.ant.types.selectors.DepthSelector;
import org.apache.tools.ant.types.selectors.DependSelector;
import org.apache.tools.ant.types.selectors.ExtendSelector;
import org.apache.tools.ant.types.selectors.SelectSelector;
import org.apache.tools.ant.types.selectors.PresentSelector;
import org.apache.tools.ant.types.selectors.ContainsSelector;
import org.apache.tools.ant.types.selectors.FilenameSelector;
import org.apache.tools.ant.types.selectors.MajoritySelector;
import org.apache.tools.ant.types.selectors.ContainsRegexpSelector;
import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;


public class Delete extends MatchingTask {
    private static final int DELETE_RETRY_SLEEP_MILLIS = 10;
    private static final ResourceComparator REVERSE_FILESYSTEM = new Reverse(new FileSystem());
    private static final ResourceSelector EXISTS = new Exists();

    private static class ReverseDirs implements ResourceCollection {
        static final Comparator REVERSE = new Comparator() {
            public int compare(Object foo, Object bar) {
                return ((Comparable) foo).compareTo(bar) * -1;
            }
        };
        private File basedir;
        private String[] dirs;
        ReverseDirs(File basedir, String[] dirs) {
            this.basedir = basedir;
            this.dirs = dirs;
            Arrays.sort(this.dirs, REVERSE);
        }
        public Iterator iterator() {
            return new FileResourceIterator(basedir, dirs);
        }
        public boolean isFilesystemOnly() { return true; }
        public int size() { return dirs.length; }
    }

    
    protected File file = null;
    protected File dir = null;
    protected Vector filesets = new Vector();
    protected boolean usedMatchingTask = false;
    
    protected boolean includeEmpty = false;

    private int verbosity = Project.MSG_VERBOSE;
    private boolean quiet = false;
    private boolean failonerror = true;
    private boolean deleteOnExit = false;
    private Resources rcs = null;
    

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setDir(File dir) {
        this.dir = dir;
        getImplicitFileSet().setDir(dir);
    }

    
    public void setVerbose(boolean verbose) {
        if (verbose) {
            this.verbosity = Project.MSG_INFO;
        } else {
            this.verbosity = Project.MSG_VERBOSE;
        }
    }

    
    public void setQuiet(boolean quiet) {
        this.quiet = quiet;
        if (quiet) {
            this.failonerror = false;
        }
    }

    
     public void setFailOnError(boolean failonerror) {
         this.failonerror = failonerror;
     }

    
     public void setDeleteOnExit(boolean deleteOnExit) {
         this.deleteOnExit = deleteOnExit;
     }


    
    public void setIncludeEmptyDirs(boolean includeEmpty) {
        this.includeEmpty = includeEmpty;
    }

   
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }

    
    public void add(ResourceCollection rc) {
        if (rc == null) {
            return;
        }
        rcs = (rcs == null) ? new Resources() : rcs;
        rcs.add(rc);
    }

    
    public PatternSet.NameEntry createInclude() {
        usedMatchingTask = true;
        return super.createInclude();
    }

    
    public PatternSet.NameEntry createIncludesFile() {
        usedMatchingTask = true;
        return super.createIncludesFile();
    }

    
    public PatternSet.NameEntry createExclude() {
        usedMatchingTask = true;
        return super.createExclude();
    }

    
    public PatternSet.NameEntry createExcludesFile() {
        usedMatchingTask = true;
        return super.createExcludesFile();
    }

    
    public PatternSet createPatternSet() {
        usedMatchingTask = true;
        return super.createPatternSet();
    }

    
    public void setIncludes(String includes) {
        usedMatchingTask = true;
        super.setIncludes(includes);
    }

    
    public void setExcludes(String excludes) {
        usedMatchingTask = true;
        super.setExcludes(excludes);
    }

    
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        usedMatchingTask = true;
        super.setDefaultexcludes(useDefaultExcludes);
    }

    
    public void setIncludesfile(File includesfile) {
        usedMatchingTask = true;
        super.setIncludesfile(includesfile);
    }

    
    public void setExcludesfile(File excludesfile) {
        usedMatchingTask = true;
        super.setExcludesfile(excludesfile);
    }

    
    public void setCaseSensitive(boolean isCaseSensitive) {
        usedMatchingTask = true;
        super.setCaseSensitive(isCaseSensitive);
    }

    
    public void setFollowSymlinks(boolean followSymlinks) {
        usedMatchingTask = true;
        super.setFollowSymlinks(followSymlinks);
    }

    
    public void addSelector(SelectSelector selector) {
        usedMatchingTask = true;
        super.addSelector(selector);
    }

    
    public void addAnd(AndSelector selector) {
        usedMatchingTask = true;
        super.addAnd(selector);
    }

    
    public void addOr(OrSelector selector) {
        usedMatchingTask = true;
        super.addOr(selector);
    }

    
    public void addNot(NotSelector selector) {
        usedMatchingTask = true;
        super.addNot(selector);
    }

    
    public void addNone(NoneSelector selector) {
        usedMatchingTask = true;
        super.addNone(selector);
    }

    
    public void addMajority(MajoritySelector selector) {
        usedMatchingTask = true;
        super.addMajority(selector);
    }

    
    public void addDate(DateSelector selector) {
        usedMatchingTask = true;
        super.addDate(selector);
    }

    
    public void addSize(SizeSelector selector) {
        usedMatchingTask = true;
        super.addSize(selector);
    }

    
    public void addFilename(FilenameSelector selector) {
        usedMatchingTask = true;
        super.addFilename(selector);
    }

    
    public void addCustom(ExtendSelector selector) {
        usedMatchingTask = true;
        super.addCustom(selector);
    }

    
    public void addContains(ContainsSelector selector) {
        usedMatchingTask = true;
        super.addContains(selector);
    }

    
    public void addPresent(PresentSelector selector) {
        usedMatchingTask = true;
        super.addPresent(selector);
    }

    
    public void addDepth(DepthSelector selector) {
        usedMatchingTask = true;
        super.addDepth(selector);
    }

    
    public void addDepend(DependSelector selector) {
        usedMatchingTask = true;
        super.addDepend(selector);
    }

    
    public void addContainsRegexp(ContainsRegexpSelector selector) {
        usedMatchingTask = true;
        super.addContainsRegexp(selector);
    }

    
    public void addModified(ModifiedSelector selector) {
        usedMatchingTask = true;
        super.addModified(selector);
    }

    
    public void add(FileSelector selector) {
        usedMatchingTask = true;
        super.add(selector);
    }

    
    public void execute() throws BuildException {
        if (usedMatchingTask) {
            log(""DEPRECATED - Use of the implicit FileSet is deprecated.  ""
                + ""Use a nested fileset element instead."", quiet ? Project.MSG_VERBOSE : verbosity);
        }

        if (file == null && dir == null && filesets.size() == 0 && rcs == null) {
            throw new BuildException(""At least one of the file or dir ""
                                     + ""attributes, or a nested resource collection, ""
                                     + ""must be set."");
        }

        if (quiet && failonerror) {
            throw new BuildException(""quiet and failonerror cannot both be ""
                                     + ""set to true"", getLocation());
        }

        
        if (file != null) {
            if (file.exists()) {
                if (file.isDirectory()) {
                    log(""Directory "" + file.getAbsolutePath()
                        + "" cannot be removed using the file attribute.  ""
                        + ""Use dir instead."", quiet ? Project.MSG_VERBOSE : verbosity);
                } else {
                    log(""Deleting: "" + file.getAbsolutePath());

                    if (!delete(file)) {
                        handle(""Unable to delete file "" + file.getAbsolutePath());
                    }
                }
            } else {
                log(""Could not find file "" + file.getAbsolutePath()
                    + "" to delete."", quiet ? Project.MSG_VERBOSE : verbosity);
            }
        }

        
        if (dir != null && dir.exists() && dir.isDirectory()
            && !usedMatchingTask) {
            
            if (verbosity == Project.MSG_VERBOSE) {
                log(""Deleting directory "" + dir.getAbsolutePath());
            }
            removeDir(dir);
        }
        Resources resourcesToDelete = new Resources();
        resourcesToDelete.setProject(getProject());
        Resources filesetDirs = new Resources();
        filesetDirs.setProject(getProject());
        FileSet implicit = null;
        if (usedMatchingTask && dir != null && dir.isDirectory()) {
            
            implicit = getImplicitFileSet();
            implicit.setProject(getProject());
            filesets.add(implicit);
        }

        for (int i = 0, size = filesets.size(); i < size; i++) {
            FileSet fs = (FileSet) filesets.get(i);
            if (fs.getProject() == null) {
                log(""Deleting fileset with no project specified;""
                    + "" assuming executing project"", Project.MSG_VERBOSE);
                fs = (FileSet) fs.clone();
                fs.setProject(getProject());
            }
            if (!fs.getDir().isDirectory()) {
                handle(""Directory does not exist:"" + fs.getDir());
            } else {
                resourcesToDelete.add(fs);
                if (includeEmpty) {
                    filesetDirs.add(new ReverseDirs(fs.getDir(), fs
                            .getDirectoryScanner().getIncludedDirectories()));
                }
            }
        }
        resourcesToDelete.add(filesetDirs);
        if (rcs != null) {
            
            Restrict exists = new Restrict();
            exists.add(EXISTS);
            exists.add(rcs);
            Sort s = new Sort();
            s.add(REVERSE_FILESYSTEM);
            s.add(exists);
            resourcesToDelete.add(s);
        }
        try {
            if (resourcesToDelete.isFilesystemOnly()) {
                for (Iterator iter = resourcesToDelete.iterator(); iter.hasNext();) {
                    FileResource r = (FileResource) iter.next();
                    
                    
                    if (!r.isExists()) {
                        continue;
                    }
                    if (!(r.isDirectory()) || r.getFile().list().length == 0) {
                        log(""Deleting "" + r, verbosity);
                        if (!delete(r.getFile()) && failonerror) {
                            handle(""Unable to delete ""
                                + (r.isDirectory() ? ""directory "" : ""file "") + r);
                        }
                    }
                }
            } else {
                 handle(getTaskName() + "" handles only filesystem resources"");
            }
        } catch (Exception e) {
            handle(e);
        } finally {
            if (implicit != null) {
                filesets.remove(implicit);
            }
        }
    }





    private void handle(String msg) {
        handle(new BuildException(msg));
    }

    private void handle(Exception e) {
        if (failonerror) {
            throw (e instanceof BuildException)
                ? (BuildException) e : new BuildException(e);
        }
        log(e, quiet ? Project.MSG_VERBOSE : verbosity);
    }

    
    private boolean delete(File f) {
        if (!f.delete()) {
            if (Os.isFamily(""windows"")) {
                System.gc();
            }
            try {
                Thread.sleep(DELETE_RETRY_SLEEP_MILLIS);
            } catch (InterruptedException ex) {
                
            }
            if (!f.delete()) {
                if (deleteOnExit) {
                    int level = quiet ? Project.MSG_VERBOSE : Project.MSG_INFO;
                    log(""Failed to delete "" + f + "", calling deleteOnExit.""
                        + "" This attempts to delete the file when the Ant jvm""
                        + "" has exited and might not succeed."", level);
                    f.deleteOnExit();
                    return true;
                }
                return false;
            }
        }
        return true;
    }

    
    protected void removeDir(File d) {
        String[] list = d.list();
        if (list == null) {
            list = new String[0];
        }
        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(d, s);
            if (f.isDirectory()) {
                removeDir(f);
            } else {
                log(""Deleting "" + f.getAbsolutePath(), quiet ? Project.MSG_VERBOSE : verbosity);
                if (!delete(f)) {
                    handle(""Unable to delete file "" + f.getAbsolutePath());
                }
            }
        }
        log(""Deleting directory "" + d.getAbsolutePath(), verbosity);
        if (!delete(d)) {
            handle(""Unable to delete directory "" + dir.getAbsolutePath());
        }
    }

    
    protected void removeFiles(File d, String[] files, String[] dirs) {
        if (files.length > 0) {
            log(""Deleting "" + files.length + "" files from ""
                + d.getAbsolutePath(), quiet ? Project.MSG_VERBOSE : verbosity);
            for (int j = 0; j < files.length; j++) {
                File f = new File(d, files[j]);
                log(""Deleting "" + f.getAbsolutePath(),
                        quiet ? Project.MSG_VERBOSE : verbosity);
                if (!delete(f)) {
                    handle(""Unable to delete file "" + f.getAbsolutePath());
                }
            }
        }

        if (dirs.length > 0 && includeEmpty) {
            int dirCount = 0;
            for (int j = dirs.length - 1; j >= 0; j--) {
                File currDir = new File(d, dirs[j]);
                String[] dirFiles = currDir.list();
                if (dirFiles == null || dirFiles.length == 0) {
                    log(""Deleting "" + currDir.getAbsolutePath(),
                            quiet ? Project.MSG_VERBOSE : verbosity);
                    if (!delete(currDir)) {
                        handle(""Unable to delete directory ""
                                + currDir.getAbsolutePath());
                    } else {
                        dirCount++;
                    }
                }
            }

            if (dirCount > 0) {
                log(""Deleted ""
                     + dirCount
                     + "" director"" + (dirCount == 1 ? ""y"" : ""ies"")
                     + "" form "" + d.getAbsolutePath(),
                     quiet ? Project.MSG_VERBOSE : verbosity);
            }
        }
    }
}
"
org.apache.tools.ant.util.StringTokenizer,8,2,1,4,18,2,1,3,7,0.69047619,194,1.0,0,0.5625,0.35,0,0,22.5,4,1.5,0,"
package org.apache.tools.ant.util;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.ProjectComponent;


public class StringTokenizer extends ProjectComponent implements Tokenizer {
    private String intraString = """";
    private int    pushed = -2;
    private char[] delims = null;
    private boolean delimsAreTokens = false;
    private boolean suppressDelims = false;
    private boolean includeDelims = false;

    
    public void setDelims(String delims) {
        this.delims = StringUtils.resolveBackSlash(delims).toCharArray();
    }

    

    public void setDelimsAreTokens(boolean delimsAreTokens) {
        this.delimsAreTokens = delimsAreTokens;
    }
    
    public void setSuppressDelims(boolean suppressDelims) {
        this.suppressDelims = suppressDelims;
    }

    
    public void setIncludeDelims(boolean includeDelims) {
        this.includeDelims = includeDelims;
    }

    
    public String getToken(Reader in) throws IOException {
        int ch = -1;
        if (pushed != -2) {
            ch = pushed;
            pushed = -2;
        } else {
            ch = in.read();
        }
        if (ch == -1) {
            return null;
        }
        boolean inToken = true;
        intraString = """";
        StringBuffer word = new StringBuffer();
        StringBuffer padding = new StringBuffer();
        while (ch != -1) {
            char c = (char) ch;
            boolean isDelim = isDelim(c);
            if (inToken) {
                if (isDelim) {
                    if (delimsAreTokens) {
                        if (word.length() == 0) {
                            word.append(c);
                        } else {
                            pushed = ch;
                        }
                        break;
                    }
                    padding.append(c);
                    inToken = false;
                } else {
                    word.append(c);
                }
            } else {
                if (isDelim) {
                    padding.append(c);
                } else {
                    pushed = ch;
                    break;
                }
            }
            ch = in.read();
        }
        intraString = padding.toString();
        if (includeDelims) {
            word.append(intraString);
        }
        return word.toString();
    }

    
    public String getPostToken() {
        return suppressDelims || includeDelims ? """" : intraString;
    }

    private boolean isDelim(char ch) {
        if (delims == null) {
            return Character.isWhitespace(ch);
        }
        for (int i = 0; i < delims.length; ++i) {
            if (delims[i] == ch) {
                return true;
            }
        }
        return false;
    }
}
"
org.apache.tools.ant.taskdefs.Input,8,3,0,8,32,0,1,8,8,0.775510204,190,0.857142857,1,0.840909091,0.8125,1,1,21.875,3,1.25,0,"

package org.apache.tools.ant.taskdefs;

import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.input.DefaultInputHandler;
import org.apache.tools.ant.input.GreedyInputHandler;
import org.apache.tools.ant.input.InputHandler;
import org.apache.tools.ant.input.InputRequest;
import org.apache.tools.ant.input.MultipleChoiceInputRequest;
import org.apache.tools.ant.input.PropertyFileInputHandler;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.StringUtils;


public class Input extends Task {

    
    public class Handler extends DefBase {

        private String refid = null;
        private HandlerType type = null;
        private String classname = null;

        
        public void setRefid(String refid) {
            this.refid = refid;
        }
        
        public String getRefid() {
            return refid;
        }
        
        public void setClassname(String classname) {
            this.classname = classname;
        }
        
        public String getClassname() {
            return classname;
        }
        
        public void setType(HandlerType type) {
            this.type = type;
        }
        
        public HandlerType getType() {
            return type;
        }
        private InputHandler getInputHandler() {
            if (type != null) {
               return type.getInputHandler();
            }
            if (refid != null) {
               try {
                   return (InputHandler) (getProject().getReference(refid));
               } catch (ClassCastException e) {
                   throw new BuildException(
                       refid + "" does not denote an InputHandler"", e);
               }
            }
            if (classname != null) {
               return (InputHandler) (ClasspathUtils.newInstance(classname,
                   createLoader(), InputHandler.class));
            }
            throw new BuildException(
                ""Must specify refid, classname or type"");
        }
    }

    
    public static class HandlerType extends EnumeratedAttribute {
        private static final String[] VALUES
            = {""default"", ""propertyfile"", ""greedy""};

        private static final InputHandler[] HANDLERS
            = {new DefaultInputHandler(),
               new PropertyFileInputHandler(),
               new GreedyInputHandler()};

        
        public String[] getValues() {
            return VALUES;
        }
        private InputHandler getInputHandler() {
            return HANDLERS[getIndex()];
        }
    }

    private String validargs = null;
    private String message = """";
    private String addproperty = null;
    private String defaultvalue = null;
    private Handler handler = null;
    private boolean messageAttribute;

    
    public void setValidargs (String validargs) {
        this.validargs = validargs;
    }

    
    public void setAddproperty (String addproperty) {
        this.addproperty = addproperty;
    }

    
    public void setMessage (String message) {
        this.message = message;
        messageAttribute = true;
    }

    
    public void setDefaultvalue (String defaultvalue) {
        this.defaultvalue = defaultvalue;
    }

    
    public void addText(String msg) {
        if (messageAttribute && """".equals(msg.trim())) {
            return;
        }
        message += getProject().replaceProperties(msg);
    }

    
    public Input () {
    }

    
    public void execute () throws BuildException {
        if (addproperty != null
            && getProject().getProperty(addproperty) != null) {
            log(""skipping "" + getTaskName() + "" as property "" + addproperty
                + "" has already been set."");
            return;
        }

        InputRequest request = null;
        if (validargs != null) {
            Vector accept = StringUtils.split(validargs, ',');
            request = new MultipleChoiceInputRequest(message, accept);
        } else {
            request = new InputRequest(message);
        }
        request.setDefaultValue(defaultvalue);

        InputHandler h = handler == null
            ? getProject().getInputHandler()
            : handler.getInputHandler();

        h.handleInput(request);

        String value = request.getInput();
        if ((value == null || value.trim().length() == 0)
            && defaultvalue != null) {
            value = defaultvalue;
        }
        if (addproperty != null && value != null) {
            getProject().setNewProperty(addproperty, value);
        }
    }

    
    public Handler createHandler() {
        if (handler != null) {
            throw new BuildException(
                ""Cannot define > 1 nested input handler"");
        }
        handler = new Handler();
        return handler;
    }

}
"
org.apache.tools.ant.taskdefs.optional.sos.SOS,38,3,4,16,68,601,4,12,13,0.92845787,534,1.0,1,0.5,0.289473684,0,0,12.60526316,5,1.3684,0,"
package org.apache.tools.ant.taskdefs.optional.sos;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileUtils;



public abstract class SOS extends Task implements SOSCmd {

    private String sosCmdDir = null;
    private String sosUsername = null;
    private String sosPassword = """";
    private String projectPath = null;
    private String vssServerPath = null;
    private String sosServerPath = null;
    private String sosHome = null;
    private String localPath = null;
    private String version = null;
    private String label = null;
    private String comment = null;
    private String filename = null;

    private boolean noCompress = false;
    private boolean noCache = false;
    private boolean recursive = false;
    private boolean verbose = false;

    
    
    protected Commandline commandLine;
    

    
    public final void setNoCache(boolean nocache) {
        noCache = nocache;
    }

    
    public final void setNoCompress(boolean nocompress) {
        noCompress = nocompress;
    }

    
    public final void setSosCmd(String dir) {
        sosCmdDir = FileUtils.translatePath(dir);
    }

    
    public final void setUsername(String username) {
        sosUsername = username;
    }

    
    public final void setPassword(String password) {
        sosPassword = password;
    }

    
    public final void setProjectPath(String projectpath) {
        if (projectpath.startsWith(SOSCmd.PROJECT_PREFIX)) {
            projectPath = projectpath;
        } else {
            projectPath = SOSCmd.PROJECT_PREFIX + projectpath;
        }
    }

    
    public final void setVssServerPath(String vssServerPath) {
        this.vssServerPath = vssServerPath;
    }

    
    public final void setSosHome(String sosHome) {
        this.sosHome = sosHome;
    }

    
    public final void setSosServerPath(String sosServerPath) {
        this.sosServerPath = sosServerPath;
    }

    
    public final void setLocalPath(Path path) {
        localPath = path.toString();
    }

    
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    

    
    protected void setInternalFilename(String file) {
        filename = file;
    }

    
    protected void setInternalRecursive(boolean recurse) {
        recursive = recurse;
    }

    
    protected void setInternalComment(String text) {
        comment = text;
    }

    
    protected void setInternalLabel(String text) {
        label = text;
    }

    
    protected void setInternalVersion(String text) {
        version = text;
    }

    
    protected String getSosCommand() {
        if (sosCmdDir == null) {
            return COMMAND_SOS_EXE;
        } else {
            return sosCmdDir + File.separator + COMMAND_SOS_EXE;
        }
    }

    
    protected String getComment() {
        return comment;
    }

    
    protected String getVersion() {
        return version;
    }

    
    protected String getLabel() {
        return label;
    }

    
    protected String getUsername() {
        return sosUsername;
    }

    
    protected String getPassword() {
        return sosPassword;
    }

    
    protected String getProjectPath() {
        return projectPath;
    }

    
    protected String getVssServerPath() {
        return vssServerPath;
    }

    
    protected String getSosHome() {
        return sosHome;
    }

    
    protected String getSosServerPath() {
        return sosServerPath;
    }

    
    protected String getFilename() {
        return filename;
    }

    
    protected String getNoCompress() {
        return noCompress ? FLAG_NO_COMPRESSION : """";
    }

    
    protected String getNoCache() {
        return noCache ? FLAG_NO_CACHE : """";
    }

    
    protected String getVerbose() {
        return verbose ? FLAG_VERBOSE : """";
    }

    
    protected String getRecursive() {
        return recursive ? FLAG_RECURSION : """";
    }

    
    protected String getLocalPath() {
        if (localPath == null) {
            return getProject().getBaseDir().getAbsolutePath();
        } else {
            
            File dir = getProject().resolveFile(localPath);
            if (!dir.exists()) {
                boolean done = dir.mkdirs();
                if (!done) {
                    String msg = ""Directory "" + localPath + "" creation was not ""
                        + ""successful for an unknown reason"";
                    throw new BuildException(msg, getLocation());
                }
                getProject().log(""Created dir: "" + dir.getAbsolutePath());
            }
            return dir.getAbsolutePath();
        }
    }

    
    abstract Commandline buildCmdLine();


    
    public void execute()
        throws BuildException {
        int result = 0;
        buildCmdLine();
        result = run(commandLine);
        if (result == 255) {  
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }

    
    protected int run(Commandline cmd) {
        try {
            Execute exe = new Execute(new LogStreamHandler(this,
                    Project.MSG_INFO,
                    Project.MSG_WARN));

            exe.setAntRun(getProject());
            exe.setWorkingDirectory(getProject().getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            exe.setVMLauncher(false);  
            return exe.execute();
        } catch (java.io.IOException e) {
            throw new BuildException(e, getLocation());
        }
    }

    
    protected void getRequiredAttributes() {
        
        commandLine.setExecutable(getSosCommand());
        
        if (getSosServerPath() == null) {
            throw new BuildException(""sosserverpath attribute must be set!"", getLocation());
        }
        commandLine.createArgument().setValue(FLAG_SOS_SERVER);
        commandLine.createArgument().setValue(getSosServerPath());
        
        if (getUsername() == null) {
            throw new BuildException(""username attribute must be set!"", getLocation());
        }
        commandLine.createArgument().setValue(FLAG_USERNAME);
        commandLine.createArgument().setValue(getUsername());
        
        
        commandLine.createArgument().setValue(FLAG_PASSWORD);
        commandLine.createArgument().setValue(getPassword());
        
        if (getVssServerPath() == null) {
            throw new BuildException(""vssserverpath attribute must be set!"", getLocation());
        }
        commandLine.createArgument().setValue(FLAG_VSS_SERVER);
        commandLine.createArgument().setValue(getVssServerPath());
        
        if (getProjectPath() == null) {
            throw new BuildException(""projectpath attribute must be set!"", getLocation());
        }
        commandLine.createArgument().setValue(FLAG_PROJECT);
        commandLine.createArgument().setValue(getProjectPath());
    }

    
    protected void getOptionalAttributes() {
        
        commandLine.createArgument().setValue(getVerbose());
        
        commandLine.createArgument().setValue(getNoCompress());
        
        if (getSosHome() == null) {
            
            commandLine.createArgument().setValue(getNoCache());
        } else {
            commandLine.createArgument().setValue(FLAG_SOS_HOME);
            commandLine.createArgument().setValue(getSosHome());
        }
        
        if (getLocalPath() != null) {
            commandLine.createArgument().setValue(FLAG_WORKING_DIR);
            commandLine.createArgument().setValue(getLocalPath());
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.DotnetDefine,7,1,0,5,12,11,1,4,7,0.666666667,72,1.0,0,0.0,0.571428571,0,0,8.857142857,5,1.4286,0,"
package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;


public class DotnetDefine {
    private String name;
    private String ifCond;
    private String unlessCond;


    
    public void setIf(String condition) {
        this.ifCond = condition;
    }

    
    public void setUnless(String condition) {
        this.unlessCond = condition;
    }

    
    public String getName() {
        return name;
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public String getValue(Task owner) throws BuildException {
        if (name == null) {
            throw new BuildException(""No name provided for the define element"",
                owner.getLocation());
        }
        if (!isSet(owner)) {
            return null;
        }
        return name;
    }


    
    public boolean isSet(Task owner) {
        Project p = owner.getProject();
        if (ifCond != null && p.getProperty(ifCond) == null) {
            return false;
        } else if (unlessCond != null && p.getProperty(unlessCond) != null) {
            return false;
        }
        return true;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ccm.CCMCheckin,1,5,0,1,8,0,0,1,1,2.0,18,0.0,0,1.0,1.0,0,0,17.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;

import java.util.Date;


public class CCMCheckin extends CCMCheck {

    
    public CCMCheckin() {
        super();
        setCcmAction(COMMAND_CHECKIN);
        setComment(""Checkin "" + new Date());
    }

}

"
org.apache.tools.ant.SubBuildListener,2,1,0,6,2,1,4,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;


public interface SubBuildListener extends BuildListener {

    
    void subBuildStarted(BuildEvent event);

    
    void subBuildFinished(BuildEvent event);
}
"
org.apache.tools.ant.taskdefs.XmlProperty,34,3,0,9,106,435,0,9,15,0.933014354,1020,0.947368421,3,0.536231884,0.188552189,2,2,28.44117647,46,3.0588,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.XMLCatalog;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.EntityResolver;



public class XmlProperty extends org.apache.tools.ant.Task {

    private Resource src;
    private String prefix = """";
    private boolean keepRoot = true;
    private boolean validate = false;
    private boolean collapseAttributes = false;
    private boolean semanticAttributes = false;
    private boolean includeSemanticAttribute = false;
    private File rootDirectory = null;
    private Hashtable addedAttributes = new Hashtable();
    private XMLCatalog xmlCatalog = new XMLCatalog();

    private static final String ID = ""id"";
    private static final String REF_ID = ""refid"";
    private static final String LOCATION = ""location"";
    private static final String VALUE = ""value"";
    private static final String PATH = ""path"";
    private static final String PATHID = ""pathid"";
    private static final String[] ATTRIBUTES = new String[] {
        ID, REF_ID, LOCATION, VALUE, PATH, PATHID
    };
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public XmlProperty() {
        super();
    }

    

    public void init() {
        super.init();
        xmlCatalog.setProject(getProject());
    }


    
    protected EntityResolver getEntityResolver() {
        return xmlCatalog;
    }

    
    public void execute()
            throws BuildException {

        Resource r = getResource();

        if (r == null) {
            String msg = ""XmlProperty task requires a source resource"";
            throw new BuildException(msg);
        }

        try {
            log(""Loading "" + src, Project.MSG_VERBOSE);

            if (r.isExists()) {

              DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
              factory.setValidating(validate);
              factory.setNamespaceAware(false);
              DocumentBuilder builder = factory.newDocumentBuilder();
              builder.setEntityResolver(getEntityResolver());
              Document document = null;
              if (src instanceof FileResource) {
                  document = builder.parse(((FileResource) src).getFile());
              } else {
                  document = builder.parse(src.getInputStream());
              }
              Element topElement = document.getDocumentElement();

              
              
              
              
              addedAttributes = new Hashtable();

              if (keepRoot) {
                  addNodeRecursively(topElement, prefix, null);
              } else {
                  NodeList topChildren = topElement.getChildNodes();
                  int numChildren = topChildren.getLength();
                  for (int i = 0; i < numChildren; i++) {
                    addNodeRecursively(topChildren.item(i), prefix, null);
                  }
              }

            } else {
                log(""Unable to find property resource: "" + r,
                    Project.MSG_VERBOSE);
            }

        } catch (SAXException sxe) {
            
            Exception x = sxe;
            if (sxe.getException() != null) {
                x = sxe.getException();
            }
            throw new BuildException(""Failed to load "" + src, x);

        } catch (ParserConfigurationException pce) {
            
            throw new BuildException(pce);
        } catch (IOException ioe) {
            
            throw new BuildException(""Failed to load "" + src, ioe);
        }
    }

    
    private void addNodeRecursively(Node node, String prefix,
                                    Object container) {

        
        String nodePrefix = prefix;
        if (node.getNodeType() != Node.TEXT_NODE) {
            if (prefix.trim().length() > 0) {
                nodePrefix += ""."";
            }
            nodePrefix += node.getNodeName();
        }

        
        Object nodeObject = processNode(node, nodePrefix, container);

        
        if (node.hasChildNodes()) {

            NodeList nodeChildren = node.getChildNodes();
            int numChildren = nodeChildren.getLength();

            for (int i = 0; i < numChildren; i++) {
                
                
                
                addNodeRecursively(nodeChildren.item(i), nodePrefix,
                                   nodeObject);
            }
        }
    }

    void addNodeRecursively(org.w3c.dom.Node node, String prefix) {
        addNodeRecursively(node, prefix, null);
    }

    
    public Object processNode (Node node, String prefix, Object container) {

        
        
        
        
        Object addedPath = null;

        
        String id = null;

        if (node.hasAttributes()) {

            NamedNodeMap nodeAttributes = node.getAttributes();

            
            Node idNode = nodeAttributes.getNamedItem(ID);
            id = (semanticAttributes && idNode != null
                  ? idNode.getNodeValue() : null);

            
            for (int i = 0; i < nodeAttributes.getLength(); i++) {

                Node attributeNode = nodeAttributes.item(i);

                if (!semanticAttributes) {
                    String attributeName = getAttributeName(attributeNode);
                    String attributeValue = getAttributeValue(attributeNode);
                    addProperty(prefix + attributeName, attributeValue, null);
                } else {

                    String nodeName = attributeNode.getNodeName();
                    String attributeValue = getAttributeValue(attributeNode);

                    Path containingPath = (container != null
                        && container instanceof Path ? (Path) container : null);

                    
                    if (nodeName.equals(ID)) {
                        
                        continue;
                    } else if (containingPath != null
                               && nodeName.equals(PATH)) {
                        
                        containingPath.setPath(attributeValue);
                    } else if (container instanceof Path
                               && nodeName.equals(REF_ID)) {
                        
                        containingPath.setPath(attributeValue);
                    } else if (container instanceof Path
                               && nodeName.equals(LOCATION)) {
                        
                        
                        containingPath.setLocation(resolveFile(attributeValue));
                    } else if (nodeName.equals(PATHID)) {
                        
                        if (container != null) {
                            throw new BuildException(""XmlProperty does not ""
                                                     + ""support nested paths"");
                        }

                        addedPath = new Path(getProject());
                        getProject().addReference(attributeValue, addedPath);
                    } else {
                        
                        String attributeName = getAttributeName(attributeNode);
                        addProperty(prefix + attributeName, attributeValue, id);
                    }
                }
            }
        }

        String nodeText = null;
        boolean emptyNode = false;
        boolean semanticEmptyOverride = false;
        if (node.getNodeType() == Node.ELEMENT_NODE
            && semanticAttributes
            && node.hasAttributes()
            && (node.getAttributes().getNamedItem(VALUE) != null
                || node.getAttributes().getNamedItem(LOCATION) != null
                || node.getAttributes().getNamedItem(REF_ID) != null
                || node.getAttributes().getNamedItem(PATH) != null
                || node.getAttributes().getNamedItem(PATHID) != null)) {
            semanticEmptyOverride = true;
        }
        if (node.getNodeType() == Node.TEXT_NODE) {
            
            nodeText = getAttributeValue(node);
        } else if ((node.getNodeType() == Node.ELEMENT_NODE)
            && (node.getChildNodes().getLength() == 1)
            && (node.getFirstChild().getNodeType() == Node.CDATA_SECTION_NODE)) {

            nodeText = node.getFirstChild().getNodeValue();
            if ("""".equals(nodeText) && !semanticEmptyOverride) {
                emptyNode = true;
            }
        } else if ((node.getNodeType() == Node.ELEMENT_NODE)
                   && (node.getChildNodes().getLength() == 0)
                   && !semanticEmptyOverride) {
            nodeText = """";
            emptyNode = true;
        } else if ((node.getNodeType() == Node.ELEMENT_NODE)
                   && (node.getChildNodes().getLength() == 1)
                   && (node.getFirstChild().getNodeType() == Node.TEXT_NODE)
                   && ("""".equals(node.getFirstChild().getNodeValue()))
                   && !semanticEmptyOverride) {
            nodeText = """";
            emptyNode = true;
        }

        if (nodeText != null) {
            
            if (semanticAttributes && id == null
                && container instanceof String) {
                id = (String) container;
            }
            if (nodeText.trim().length() != 0 || emptyNode) {
                addProperty(prefix, nodeText, id);
            }
        }

        
        
        
        
        return (addedPath != null ? addedPath : id);
    }

    
    private void addProperty (String name, String value, String id) {
        String msg = name + "":"" + value;
        if (id != null) {
            msg += (""(id="" + id + "")"");
        }
        log(msg, Project.MSG_DEBUG);

        if (addedAttributes.containsKey(name)) {
            
            
            
            
            
            
            
            
            value = (String) addedAttributes.get(name) + "","" + value;
            getProject().setProperty(name, value);
            addedAttributes.put(name, value);
        } else if (getProject().getProperty(name) == null) {
            getProject().setNewProperty(name, value);
            addedAttributes.put(name, value);
        } else {
            log(""Override ignored for property "" + name, Project.MSG_VERBOSE);
        }
        if (id != null) {
            getProject().addReference(id, value);
        }
    }

    
    private String getAttributeName (Node attributeNode) {
        String attributeName = attributeNode.getNodeName();

        if (semanticAttributes) {
            
            
            if (attributeName.equals(REF_ID)) {
                return """";
            
            } else if (!isSemanticAttribute(attributeName)
                       || includeSemanticAttribute) {
                return ""."" + attributeName;
            } else {
                return """";
            }
        } else if (collapseAttributes) {
            return ""."" + attributeName;
        } else {
            return ""("" + attributeName + "")"";
        }
    }

    
    private static boolean isSemanticAttribute (String attributeName) {
        for (int i = 0; i < ATTRIBUTES.length; i++) {
            if (attributeName.equals(ATTRIBUTES[i])) {
                return true;
            }
        }
        return false;
    }

    
    private String getAttributeValue (Node attributeNode) {
        String nodeValue = attributeNode.getNodeValue().trim();
        if (semanticAttributes) {
            String attributeName = attributeNode.getNodeName();
            nodeValue = getProject().replaceProperties(nodeValue);
            if (attributeName.equals(LOCATION)) {
                File f = resolveFile(nodeValue);
                return f.getPath();
            } else if (attributeName.equals(REF_ID)) {
                Object ref = getProject().getReference(nodeValue);
                if (ref != null) {
                    return ref.toString();
                }
            }
        }
        return nodeValue;
    }

    
    public void setFile(File src) {
        setSrcResource(new FileResource(src));
    }

    
    public void setSrcResource(Resource src) {
        if (src.isDirectory()) {
            throw new BuildException(""the source can't be a directory"");
        }
        if (src instanceof FileResource && !supportsNonFileResources()) {
            throw new BuildException(""Only FileSystem resources are""
                                     + "" supported."");
        }
        this.src = src;
    }

    
    public void addConfigured(ResourceCollection a) {
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported as archives"");
        }
        setSrcResource((Resource) a.iterator().next());
    }

    
    public void setPrefix(String prefix) {
        this.prefix = prefix.trim();
    }

    
    public void setKeeproot(boolean keepRoot) {
        this.keepRoot = keepRoot;
    }

    
    public void setValidate(boolean validate) {
        this.validate = validate;
    }

    
    public void setCollapseAttributes(boolean collapseAttributes) {
        this.collapseAttributes = collapseAttributes;
    }

    
    public void setSemanticAttributes(boolean semanticAttributes) {
        this.semanticAttributes = semanticAttributes;
    }

    
    public void setRootDirectory(File rootDirectory) {
        this.rootDirectory = rootDirectory;
    }

    
    public void setIncludeSemanticAttribute(boolean includeSemanticAttribute) {
        this.includeSemanticAttribute = includeSemanticAttribute;
    }

    
    public void addConfiguredXMLCatalog(XMLCatalog catalog) {
        xmlCatalog.addConfiguredXMLCatalog(catalog);
    }

    

    
    protected File getFile () {
        if (src instanceof FileResource) {
            return ((FileResource) src).getFile();
        } else {
            return null;
        }
    }

    
    protected Resource getResource() {
        
        
        File f = getFile();
        if (f != null) {
            return new FileResource(f);
        } else {
            return src;
        }
    }

    
    protected String getPrefix () {
        return this.prefix;
    }

    
    protected boolean getKeeproot () {
        return this.keepRoot;
    }

    
    protected boolean getValidate () {
        return this.validate;
    }

    
    protected boolean getCollapseAttributes () {
        return this.collapseAttributes;
    }

    
    protected boolean getSemanticAttributes () {
        return this.semanticAttributes;
    }

    
    protected File getRootDirectory () {
        return this.rootDirectory;
    }

    
    protected boolean getIncludeSementicAttribute () {
        return this.includeSemanticAttribute;
    }

    
    private File resolveFile(String fileName) {
        if (rootDirectory == null) {
            return FILE_UTILS.resolveFile(getProject().getBaseDir(), fileName);
        }
        return FILE_UTILS.resolveFile(rootDirectory, fileName);
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(XmlProperty.class);
    }
}
"
org.apache.tools.ant.types.resources.GZipResource,5,5,0,2,9,10,0,2,2,2.0,24,0.0,0,0.961538462,0.4,1,2,3.8,1,0.6,0,"
package org.apache.tools.ant.types.resources;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;


public class GZipResource extends CompressedResource {

    
    public GZipResource() {
    }

    
    public GZipResource(org.apache.tools.ant.types.ResourceCollection other) {
        super(other);
    }

    
    protected InputStream wrapStream(InputStream in) throws IOException {
        return new GZIPInputStream(in);
    }

    
     protected OutputStream wrapStream(OutputStream out) throws IOException {
        return new GZIPOutputStream(out);
    }

    
    protected String getCompressionName() {
        return ""GZip"";
    }
}
"
org.apache.tools.ant.Main,23,1,0,17,126,161,2,17,5,0.770833333,2117,0.791666667,0,0.0,0.148760331,0,0,90.0,53,4.5217,4,"

package org.apache.tools.ant;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;
import java.util.HashMap;

import org.apache.tools.ant.input.DefaultInputHandler;
import org.apache.tools.ant.input.InputHandler;
import org.apache.tools.ant.launch.AntMain;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.ProxySetup;



public class Main implements AntMain {

    
    public static final String DEFAULT_BUILD_FILENAME = ""build.xml"";

    
    private int msgOutputLevel = Project.MSG_INFO;

    
    private File buildFile; 

    
    private static PrintStream out = System.out;

    
    private static PrintStream err = System.err;

    
    private Vector targets = new Vector();

    
    private Properties definedProps = new Properties();

    
    private Vector listeners = new Vector(1);

    
    private Vector propertyFiles = new Vector(1);

    
    private boolean allowInput = true;

    
    private boolean keepGoingMode = false;

    
    private String loggerClassname = null;

    
    private String inputHandlerClassname = null;

    
    private boolean emacsMode = false;

    
    private boolean readyToRun = false;

    
    private boolean projectHelp = false;

    
    private static boolean isLogFileUsed = false;

    
    private Integer threadPriority = null;

    
    private boolean proxy = false;

    
    private static void printMessage(Throwable t) {
        String message = t.getMessage();
        if (message != null) {
            System.err.println(message);
        }
    }

    
    public static void start(String[] args, Properties additionalUserProperties,
                             ClassLoader coreLoader) {
        Main m = new Main();
        m.startAnt(args, additionalUserProperties, coreLoader);
    }

    
    public void startAnt(String[] args, Properties additionalUserProperties,
                         ClassLoader coreLoader) {

        try {
            Diagnostics.validateVersion();
            processArgs(args);
        } catch (Throwable exc) {
            handleLogfile();
            printMessage(exc);
            exit(1);
            return;
        }

        if (additionalUserProperties != null) {
            for (Enumeration e = additionalUserProperties.keys();
                    e.hasMoreElements();) {
                String key = (String) e.nextElement();
                String property = additionalUserProperties.getProperty(key);
                definedProps.put(key, property);
            }
        }

        
        int exitCode = 1;
        try {
            try {
                runBuild(coreLoader);
                exitCode = 0;
            } catch (ExitStatusException ese) {
                exitCode = ese.getStatus();
                if (exitCode != 0) {
                    throw ese;
                }
            }
        } catch (BuildException be) {
            if (err != System.err) {
                printMessage(be);
            }
        } catch (Throwable exc) {
            exc.printStackTrace();
            printMessage(exc);
        } finally {
            handleLogfile();
        }
        exit(exitCode);
    }

    
    protected void exit(int exitCode) {
        System.exit(exitCode);
    }

    
    private static void handleLogfile() {
        if (isLogFileUsed) {
            FileUtils.close(out);
            FileUtils.close(err);
        }
    }

    
    public static void main(String[] args) {
        start(args, null, null);
    }

    
    public Main() {
    }

    
    protected Main(String[] args) throws BuildException {
        processArgs(args);
    }

    
    private void processArgs(String[] args) {
        String searchForThis = null;
        PrintStream logTo = null;

        
        HashMap launchCommands = new HashMap();
        launchCommands.put(""-lib"", """");
        launchCommands.put(""-cp"", """");
        launchCommands.put(""-noclasspath"", """");
        launchCommands.put(""--noclasspath"", """");
        launchCommands.put(""-nouserlib"", """");
        launchCommands.put(""--nouserlib"", """");
        launchCommands.put(""-main"", """");
        

        for (int i = 0; i < args.length; i++) {
            String arg = args[i];

            if (arg.equals(""-help"") || arg.equals(""-h"")) {
                printUsage();
                return;
            } else if (arg.equals(""-version"")) {
                printVersion();
                return;
            } else if (arg.equals(""-diagnostics"")) {
                Diagnostics.doReport(System.out);
                return;
            } else if (arg.equals(""-quiet"") || arg.equals(""-q"")) {
                msgOutputLevel = Project.MSG_WARN;
            } else if (arg.equals(""-verbose"") || arg.equals(""-v"")) {
                printVersion();
                msgOutputLevel = Project.MSG_VERBOSE;
            } else if (arg.equals(""-debug"") || arg.equals(""-d"")) {
                printVersion();
                msgOutputLevel = Project.MSG_DEBUG;
            } else if (arg.equals(""-noinput"")) {
                allowInput = false;
            } else if (arg.equals(""-logfile"") || arg.equals(""-l"")) {
                try {
                    File logFile = new File(args[i + 1]);
                    i++;
                    logTo = new PrintStream(new FileOutputStream(logFile));
                    isLogFileUsed = true;
                } catch (IOException ioe) {
                    String msg = ""Cannot write on the specified log file. ""
                        + ""Make sure the path exists and you have write ""
                        + ""permissions."";
                    throw new BuildException(msg);
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a log file when ""
                        + ""using the -log argument"";
                    throw new BuildException(msg);
                }
            } else if (arg.equals(""-buildfile"") || arg.equals(""-file"")
                       || arg.equals(""-f"")) {
                try {
                    buildFile = new File(args[i + 1].replace('/', File.separatorChar));
                    i++;
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a buildfile when ""
                        + ""using the -buildfile argument"";
                    throw new BuildException(msg);
                }
            } else if (arg.equals(""-listener"")) {
                try {
                    listeners.addElement(args[i + 1]);
                    i++;
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a classname when ""
                        + ""using the -listener argument"";
                    throw new BuildException(msg);
                }
            } else if (arg.startsWith(""-D"")) {

                

                String name = arg.substring(2, arg.length());
                String value = null;
                int posEq = name.indexOf(""="");
                if (posEq > 0) {
                    value = name.substring(posEq + 1);
                    name = name.substring(0, posEq);
                } else if (i < args.length - 1) {
                    value = args[++i];
                } else {
                    throw new BuildException(""Missing value for property ""
                                             + name);
                }

                definedProps.put(name, value);
            } else if (arg.equals(""-logger"")) {
                if (loggerClassname != null) {
                    throw new BuildException(""Only one logger class may ""
                        + "" be specified."");
                }
                try {
                    loggerClassname = args[++i];
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    throw new BuildException(""You must specify a classname when""
                                             + "" using the -logger argument"");
                }
            } else if (arg.equals(""-inputhandler"")) {
                if (inputHandlerClassname != null) {
                    throw new BuildException(""Only one input handler class may ""
                                             + ""be specified."");
                }
                try {
                    inputHandlerClassname = args[++i];
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    throw new BuildException(""You must specify a classname when""
                                             + "" using the -inputhandler""
                                             + "" argument"");
                }
            } else if (arg.equals(""-emacs"") || arg.equals(""-e"")) {
                emacsMode = true;
            } else if (arg.equals(""-projecthelp"") || arg.equals(""-p"")) {
                
                projectHelp = true;
            } else if (arg.equals(""-find"") || arg.equals(""-s"")) {
                
                if (i < args.length - 1) {
                    searchForThis = args[++i];
                } else {
                    searchForThis = DEFAULT_BUILD_FILENAME;
                }
            } else if (arg.startsWith(""-propertyfile"")) {
                try {
                    propertyFiles.addElement(args[i + 1]);
                    i++;
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    String msg = ""You must specify a property filename when ""
                        + ""using the -propertyfile argument"";
                    throw new BuildException(msg);
                }
            } else if (arg.equals(""-k"") || arg.equals(""-keep-going"")) {
                keepGoingMode = true;
            } else if (arg.equals(""-nice"")) {
                try {
                    threadPriority = Integer.decode(args[i + 1]);
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    throw new BuildException(
                            ""You must supply a niceness value (1-10)""
                            + "" after the -nice option"");
                } catch (NumberFormatException e) {
                    throw new BuildException(""Unrecognized niceness value: ""
                                             + args[i + 1]);
                }
                i++;
                if (threadPriority.intValue() < Thread.MIN_PRIORITY
                    || threadPriority.intValue() > Thread.MAX_PRIORITY) {
                    throw new BuildException(
                            ""Niceness value is out of the range 1-10"");
                }
            } else if (launchCommands.get(arg) != null) {
                
                
                
                String msg = ""Ant's Main method is being handed ""
                        + ""an option "" + arg + "" that is only for the launcher class.""
                        + ""\nThis can be caused by a version mismatch between ""
                        + ""the ant script/.bat file and Ant itself."";
                throw new BuildException(msg);
            } else if (arg.equals(""-autoproxy"")) {
                proxy = false;
            } else if (arg.startsWith(""-"")) {
                
                String msg = ""Unknown argument: "" + arg;
                System.err.println(msg);
                printUsage();
                throw new BuildException("""");
            } else {
                
                targets.addElement(arg);
            }
        }

        
        if (buildFile == null) {
            
            if (searchForThis != null) {
                buildFile = findBuildFile(System.getProperty(""user.dir""),
                                          searchForThis);
            } else {
                buildFile = new File(DEFAULT_BUILD_FILENAME);
            }
        }

        
        if (!buildFile.exists()) {
            System.out.println(""Buildfile: "" + buildFile + "" does not exist!"");
            throw new BuildException(""Build failed"");
        }

        
        

        if (buildFile.isDirectory()) {
            System.out.println(""What? Buildfile: "" + buildFile + "" is a dir!"");
            throw new BuildException(""Build failed"");
        }

        
        for (int propertyFileIndex = 0;
             propertyFileIndex < propertyFiles.size();
             propertyFileIndex++) {
            String filename
                = (String) propertyFiles.elementAt(propertyFileIndex);
            Properties props = new Properties();
            FileInputStream fis = null;
            try {
                fis = new FileInputStream(filename);
                props.load(fis);
            } catch (IOException e) {
                System.out.println(""Could not load property file ""
                   + filename + "": "" + e.getMessage());
            } finally {
                FileUtils.close(fis);
            }

            
            Enumeration propertyNames = props.propertyNames();
            while (propertyNames.hasMoreElements()) {
                String name = (String) propertyNames.nextElement();
                if (definedProps.getProperty(name) == null) {
                    definedProps.put(name, props.getProperty(name));
                }
            }
        }

        if (msgOutputLevel >= Project.MSG_INFO) {
            System.out.println(""Buildfile: "" + buildFile);
        }

        if (logTo != null) {
            out = logTo;
            err = logTo;
            System.setOut(out);
            System.setErr(err);
        }
        readyToRun = true;
    }

    
    private File getParentFile(File file) {
        File parent = file.getParentFile();

        if (parent != null && msgOutputLevel >= Project.MSG_VERBOSE) {
            System.out.println(""Searching in "" + parent.getAbsolutePath());
        }

        return parent;
    }

    
    private File findBuildFile(String start, String suffix)
         throws BuildException {
        if (msgOutputLevel >= Project.MSG_INFO) {
            System.out.println(""Searching for "" + suffix + "" ..."");
        }

        File parent = new File(new File(start).getAbsolutePath());
        File file = new File(parent, suffix);

        
        while (!file.exists()) {
            
            parent = getParentFile(parent);

            
            
            if (parent == null) {
                throw new BuildException(""Could not locate a build file!"");
            }

            
            file = new File(parent, suffix);
        }

        return file;
    }

    
    private void runBuild(ClassLoader coreLoader) throws BuildException {

        if (!readyToRun) {
            return;
        }

        final Project project = new Project();
        project.setCoreLoader(coreLoader);

        Throwable error = null;

        try {
            addBuildListeners(project);
            addInputHandler(project);

            PrintStream savedErr = System.err;
            PrintStream savedOut = System.out;
            InputStream savedIn = System.in;

            
            SecurityManager oldsm = null;
            oldsm = System.getSecurityManager();

                
                
                
                
            try {
                if (allowInput) {
                    project.setDefaultInputStream(System.in);
                }
                System.setIn(new DemuxInputStream(project));
                System.setOut(new PrintStream(new DemuxOutputStream(project, false)));
                System.setErr(new PrintStream(new DemuxOutputStream(project, true)));


                if (!projectHelp) {
                    project.fireBuildStarted();
                }

                
                if (threadPriority != null) {
                    try {
                        project.log(""Setting Ant's thread priority to ""
                                + threadPriority, Project.MSG_VERBOSE);
                        Thread.currentThread().setPriority(threadPriority.intValue());
                    } catch (SecurityException swallowed) {
                        
                        project.log(""A security manager refused to set the -nice value"");
                    }
                }



                project.init();

                
                Enumeration e = definedProps.keys();
                while (e.hasMoreElements()) {
                    String arg = (String) e.nextElement();
                    String value = (String) definedProps.get(arg);
                    project.setUserProperty(arg, value);
                }

                project.setUserProperty(MagicNames.ANT_FILE,
                                        buildFile.getAbsolutePath());

                project.setKeepGoingMode(keepGoingMode);
                if (proxy) {
                    
                    ProxySetup proxySetup = new ProxySetup(project);
                    proxySetup.enableProxies();
                }

                ProjectHelper.configureProject(project, buildFile);

                if (projectHelp) {
                    printDescription(project);
                    printTargets(project, msgOutputLevel > Project.MSG_INFO);
                    return;
                }

                
                if (targets.size() == 0) {
                    if (project.getDefaultTarget() != null) {
                        targets.addElement(project.getDefaultTarget());
                    }
                }

                project.executeTargets(targets);
            } finally {
                
                
                if (oldsm != null) {
                    System.setSecurityManager(oldsm);
                }

                System.setOut(savedOut);
                System.setErr(savedErr);
                System.setIn(savedIn);
            }
        } catch (RuntimeException exc) {
            error = exc;
            throw exc;
        } catch (Error e) {
            error = e;
            throw e;
        } finally {
            if (!projectHelp) {
                project.fireBuildFinished(error);
            } else if (error != null) {
                project.log(error.toString(), Project.MSG_ERR);
            }
        }
    }

    
    protected void addBuildListeners(Project project) {

        
        project.addBuildListener(createLogger());

        for (int i = 0; i < listeners.size(); i++) {
            String className = (String) listeners.elementAt(i);
            BuildListener listener =
                    (BuildListener) ClasspathUtils.newInstance(className,
                            Main.class.getClassLoader(), BuildListener.class);
            if (project != null) {
                project.setProjectReference(listener);
            }
            project.addBuildListener(listener);
        }
    }

    
    private void addInputHandler(Project project) throws BuildException {
        InputHandler handler = null;
        if (inputHandlerClassname == null) {
            handler = new DefaultInputHandler();
        } else {
            handler = (InputHandler) ClasspathUtils.newInstance(
                    inputHandlerClassname, Main.class.getClassLoader(),
                    InputHandler.class);
            if (project != null) {
                project.setProjectReference(handler);
            }
        }
        project.setInputHandler(handler);
    }

    
    
    
    
    
    private BuildLogger createLogger() {
        BuildLogger logger = null;
        if (loggerClassname != null) {
            try {
                logger = (BuildLogger) ClasspathUtils.newInstance(
                        loggerClassname, Main.class.getClassLoader(),
                        BuildLogger.class);
            } catch (BuildException e) {
                System.err.println(""The specified logger class ""
                    + loggerClassname
                    + "" could not be used because "" + e.getMessage());
                throw new RuntimeException();
            }
        } else {
            logger = new DefaultLogger();
        }

        logger.setMessageOutputLevel(msgOutputLevel);
        logger.setOutputPrintStream(out);
        logger.setErrorPrintStream(err);
        logger.setEmacsMode(emacsMode);

        return logger;
    }

    
    private static void printUsage() {
        String lSep = System.getProperty(""line.separator"");
        StringBuffer msg = new StringBuffer();
        msg.append(""ant [options] [target [target2 [target3] ...]]"" + lSep);
        msg.append(""Options: "" + lSep);
        msg.append(""  -help, -h              print this message"" + lSep);
        msg.append(""  -projecthelp, -p       print project help information"" + lSep);
        msg.append(""  -version               print the version information and exit"" + lSep);
        msg.append(""  -diagnostics           print information that might be helpful to"" + lSep);
        msg.append(""                         diagnose or report problems."" + lSep);
        msg.append(""  -quiet, -q             be extra quiet"" + lSep);
        msg.append(""  -verbose, -v           be extra verbose"" + lSep);
        msg.append(""  -debug, -d             print debugging information"" + lSep);
        msg.append(""  -emacs, -e             produce logging information without adornments""
                   + lSep);
        msg.append(""  -lib <path>            specifies a path to search for jars and classes""
                   + lSep);
        msg.append(""  -logfile <file>        use given file for log"" + lSep);
        msg.append(""    -l     <file>                ''"" + lSep);
        msg.append(""  -logger <classname>    the class which is to perform logging"" + lSep);
        msg.append(""  -listener <classname>  add an instance of class as a project listener""
                   + lSep);
        msg.append(""  -noinput               do not allow interactive input"" + lSep);
        msg.append(""  -buildfile <file>      use given buildfile"" + lSep);
        msg.append(""    -file    <file>              ''"" + lSep);
        msg.append(""    -f       <file>              ''"" + lSep);
        msg.append(""  -D<property>=<value>   use value for given property"" + lSep);
        msg.append(""  -keep-going, -k        execute all targets that do not depend"" + lSep);
        msg.append(""                         on failed target(s)"" + lSep);
        msg.append(""  -propertyfile <name>   load all properties from file with -D"" + lSep);
        msg.append(""                         properties taking precedence"" + lSep);
        msg.append(""  -inputhandler <class>  the class which will handle input requests"" + lSep);
        msg.append(""  -find <file>           (s)earch for buildfile towards the root of"" + lSep);
        msg.append(""    -s  <file>           the filesystem and use it"" + lSep);
        msg.append(""  -nice  number          A niceness value for the main thread:"" + lSep
                   + ""                         1 (lowest) to 10 (highest); 5 is the default""
                   + lSep);
        msg.append(""  -nouserlib             Run ant without using the jar files from"" + lSep
                   + ""                         ${user.home}/.ant/lib"" + lSep);
        msg.append(""  -noclasspath           Run ant without using CLASSPATH"" + lSep);
        msg.append(""  -autoproxy             Java1.5+: use the OS proxy settings""
                + lSep);
        msg.append(""  -main <class>          override Ant's normal entry point"");
        System.out.println(msg.toString());
    }

    
    private static void printVersion() throws BuildException {
        System.out.println(getAntVersion());
    }

    
    private static String antVersion = null;

    
    public static synchronized String getAntVersion() throws BuildException {
        if (antVersion == null) {
            try {
                Properties props = new Properties();
                InputStream in =
                    Main.class.getResourceAsStream(""/org/apache/tools/ant/version.txt"");
                props.load(in);
                in.close();

                StringBuffer msg = new StringBuffer();
                msg.append(""Apache Ant version "");
                msg.append(props.getProperty(""VERSION""));
                msg.append("" compiled on "");
                msg.append(props.getProperty(""DATE""));
                antVersion = msg.toString();
            } catch (IOException ioe) {
                throw new BuildException(""Could not load the version information:""
                                         + ioe.getMessage());
            } catch (NullPointerException npe) {
                throw new BuildException(""Could not load the version information."");
            }
        }
        return antVersion;
    }

     
    private static void printDescription(Project project) {
       if (project.getDescription() != null) {
          project.log(project.getDescription());
       }
    }

    
    private static void printTargets(Project project, boolean printSubTargets) {
        
        int maxLength = 0;
        Enumeration ptargets = project.getTargets().elements();
        String targetName;
        String targetDescription;
        Target currentTarget;
        
        
        Vector topNames = new Vector();
        Vector topDescriptions = new Vector();
        Vector subNames = new Vector();

        while (ptargets.hasMoreElements()) {
            currentTarget = (Target) ptargets.nextElement();
            targetName = currentTarget.getName();
            if (targetName.equals("""")) {
                continue;
            }
            targetDescription = currentTarget.getDescription();
            
            if (targetDescription == null) {
                int pos = findTargetPosition(subNames, targetName);
                subNames.insertElementAt(targetName, pos);
            } else {
                int pos = findTargetPosition(topNames, targetName);
                topNames.insertElementAt(targetName, pos);
                topDescriptions.insertElementAt(targetDescription, pos);
                if (targetName.length() > maxLength) {
                    maxLength = targetName.length();
                }
            }
        }

        printTargets(project, topNames, topDescriptions, ""Main targets:"",
                     maxLength);
        
        
        if (topNames.size() == 0) {
            printSubTargets = true;
        }
        if (printSubTargets) {
            printTargets(project, subNames, null, ""Other targets:"", 0);
        }

        String defaultTarget = project.getDefaultTarget();
        if (defaultTarget != null && !"""".equals(defaultTarget)) {
            
            project.log(""Default target: "" + defaultTarget);
        }
    }

    
    private static int findTargetPosition(Vector names, String name) {
        int res = names.size();
        for (int i = 0; i < names.size() && res == names.size(); i++) {
            if (name.compareTo((String) names.elementAt(i)) < 0) {
                res = i;
            }
        }
        return res;
    }

    
    private static void printTargets(Project project, Vector names,
                                     Vector descriptions, String heading,
                                     int maxlen) {
        
        String lSep = System.getProperty(""line.separator"");
        
        String spaces = ""    "";
        while (spaces.length() <= maxlen) {
            spaces += spaces;
        }
        StringBuffer msg = new StringBuffer();
        msg.append(heading + lSep + lSep);
        for (int i = 0; i < names.size(); i++) {
            msg.append("" "");
            msg.append(names.elementAt(i));
            if (descriptions != null) {
                msg.append(
                    spaces.substring(0, maxlen - ((String) names.elementAt(i)).length() + 2));
                msg.append(descriptions.elementAt(i));
            }
            msg.append(lSep);
        }
        project.log(msg.toString(), Project.MSG_WARN);
    }
}
"
org.apache.tools.ant.filters.LineContainsRegExp,10,5,0,7,32,0,1,6,7,0.688888889,221,1.0,0,0.777777778,0.3,2,5,20.6,5,1.2,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import java.util.Vector;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.RegularExpression;
import org.apache.tools.ant.util.regexp.Regexp;


public final class LineContainsRegExp
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String REGEXP_KEY = ""regexp"";

    
    private static final String NEGATE_KEY = ""negate"";

    
    private Vector regexps = new Vector();

    
    private String line = null;

    private boolean negate = false;

    
    public LineContainsRegExp() {
        super();
    }

    
    public LineContainsRegExp(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;

        if (line != null) {
            ch = line.charAt(0);
            if (line.length() == 1) {
                line = null;
            } else {
                line = line.substring(1);
            }
        } else {
            final int regexpsSize = regexps.size();

            for (line = readLine(); line != null; line = readLine()) {
                boolean matches = true;
                for (int i = 0; matches && i < regexpsSize; i++) {
                    RegularExpression regexp
                        = (RegularExpression) regexps.elementAt(i);
                    Regexp re = regexp.getRegexp(getProject());
                    matches = re.matches(line);
                }
                if (matches ^ isNegated()) {
                    break;
                }
            }
            if (line != null) {
                return read();
            }
        }
        return ch;
    }

    
    public void addConfiguredRegexp(final RegularExpression regExp) {
        this.regexps.addElement(regExp);
    }

    
    private void setRegexps(final Vector regexps) {
        this.regexps = regexps;
    }

    
    private Vector getRegexps() {
        return regexps;
    }

    
    public Reader chain(final Reader rdr) {
        LineContainsRegExp newFilter = new LineContainsRegExp(rdr);
        newFilter.setRegexps(getRegexps());
        newFilter.setNegate(isNegated());
        return newFilter;
    }

    
    public void setNegate(boolean b) {
        negate = b;
    }

    
    public boolean isNegated() {
        return negate;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (REGEXP_KEY.equals(params[i].getType())) {
                    String pattern = params[i].getValue();
                    RegularExpression regexp = new RegularExpression();
                    regexp.setPattern(pattern);
                    regexps.addElement(regexp);
                } else if (NEGATE_KEY.equals(params[i].getType())) {
                    setNegate(Project.toBoolean(params[i].getValue()));
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTask,63,3,0,36,267,1715,4,35,36,0.922939068,2328,0.861111111,9,0.37755102,0.091642229,2,4,35.38095238,21,2.0794,5,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Vector;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteWatchdog;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.taskdefs.PumpStreamHandler;
import org.apache.tools.ant.types.Assertions;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Permissions;
import org.apache.tools.ant.types.PropertySet;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.LoaderUtils;


public class JUnitTask extends Task {

    private static final String CLASSPATH = ""CLASSPATH="";
    private CommandlineJava commandline;
    private Vector tests = new Vector();
    private Vector batchTests = new Vector();
    private Vector formatters = new Vector();
    private File dir = null;

    private Integer timeout = null;
    private boolean summary = false;
    private boolean reloading = true;
    private String summaryValue = """";
    private JUnitTaskMirror.JUnitTestRunnerMirror runner = null;

    private boolean newEnvironment = false;
    private Environment env = new Environment();

    private boolean includeAntRuntime = true;
    private Path antRuntimeClasses = null;

    
    private boolean showOutput = false;

    
    private boolean outputToFormatters = true;

    private File tmpDir;
    private AntClassLoader classLoader = null;
    private Permissions perm = null;
    private ForkMode forkMode = new ForkMode(""perTest"");

    private boolean splitJunit = false;
    private JUnitTaskMirror delegate;

    
    private boolean haltOnError = false;
    private boolean haltOnFail  = false;
    private boolean filterTrace = true;
    private boolean fork        = false;
    private String  failureProperty;
    private String  errorProperty;

    private static final int STRING_BUFFER_SIZE = 128;
    
    public static final String TESTLISTENER_PREFIX =
        ""junit.framework.TestListener: "";

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public void setReloading(boolean value) {
        reloading = value;
    }

    
    public void setFiltertrace(boolean value) {
        this.filterTrace = value;
    }

    
    public void setHaltonerror(boolean value) {
        this.haltOnError = value;
    }

    
    public void setErrorProperty(String propertyName) {
        this.errorProperty = propertyName;
    }

    
    public void setHaltonfailure(boolean value) {
        this.haltOnFail = value;
    }

    
    public void setFailureProperty(String propertyName) {
        this.failureProperty = propertyName;
    }

    
    public void setFork(boolean value) {
        this.fork = value;
    }

    
    public void setForkMode(ForkMode mode) {
        this.forkMode = mode;
    }

    
    public void setPrintsummary(SummaryAttribute value) {
        summaryValue = value.getValue();
        summary = value.asBoolean();
    }

    
    public static class SummaryAttribute extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""true"", ""yes"", ""false"", ""no"",
                                 ""on"", ""off"", ""withOutAndErr""};
        }

        
        public boolean asBoolean() {
            String v = getValue();
            return ""true"".equals(v)
                || ""on"".equals(v)
                || ""yes"".equals(v)
                || ""withOutAndErr"".equals(v);
        }
    }

    
    public void setTimeout(Integer value) {
        timeout = value;
    }

    
    public void setMaxmemory(String max) {
        getCommandline().setMaxmemory(max);
    }

    
    public void setJvm(String value) {
        getCommandline().setVm(value);
    }

    
    public Commandline.Argument createJvmarg() {
        return getCommandline().createVmArgument();
    }

    
    public void setDir(File dir) {
        this.dir = dir;
    }

    
    public void addSysproperty(Environment.Variable sysp) {

        getCommandline().addSysproperty(sysp);
    }

    
    public void addConfiguredSysproperty(Environment.Variable sysp) {
        
        
        String testString = sysp.getContent();
        getProject().log(""sysproperty added : "" + testString, Project.MSG_DEBUG);
        getCommandline().addSysproperty(sysp);
    }

    
    public void addSyspropertyset(PropertySet sysp) {
        getCommandline().addSyspropertyset(sysp);
    }

    
    public Path createClasspath() {
        return getCommandline().createClasspath(getProject()).createPath();
    }

    
    public Path createBootclasspath() {
        return getCommandline().createBootclasspath(getProject()).createPath();
    }

    
    public void addEnv(Environment.Variable var) {
        env.addVariable(var);
    }

    
    public void setNewenvironment(boolean newenv) {
        newEnvironment = newenv;
    }

    
    private void preConfigure(BaseTest test) {
        test.setFiltertrace(filterTrace);
        test.setHaltonerror(haltOnError);
        if (errorProperty != null) {
            test.setErrorProperty(errorProperty);
        }
        test.setHaltonfailure(haltOnFail);
        if (failureProperty != null) {
            test.setFailureProperty(failureProperty);
        }
        test.setFork(fork);
    }

    
    public void addTest(JUnitTest test) {
        tests.addElement(test);
        preConfigure(test);
    }

    
    public BatchTest createBatchTest() {
        BatchTest test = new BatchTest(getProject());
        batchTests.addElement(test);
        preConfigure(test);
        return test;
    }

    
    public void addFormatter(FormatterElement fe) {
        formatters.addElement(fe);
    }

    
    public void setIncludeantruntime(boolean b) {
        includeAntRuntime = b;
    }

    
    public void setShowOutput(boolean showOutput) {
        this.showOutput = showOutput;
    }

    
    public void setOutputToFormatters(boolean outputToFormatters) {
        this.outputToFormatters = outputToFormatters;
    }

    
    public void addAssertions(Assertions asserts) {
        if (getCommandline().getAssertions() != null) {
            throw new BuildException(""Only one assertion declaration is allowed"");
        }
        getCommandline().setAssertions(asserts);
    }

    
    public Permissions createPermissions() {
        if (perm == null) {
            perm = new Permissions();
        }
        return perm;
    }

    
    public void setCloneVm(boolean cloneVm) {
        getCommandline().setCloneVm(cloneVm);
    }

    
    public JUnitTask() throws Exception {
        getCommandline()
            .setClassname(""org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner"");
    }

    
    public void setTempdir(File tmpDir) {
        if (tmpDir != null) {
            if (!tmpDir.exists() || !tmpDir.isDirectory()) {
                throw new BuildException(tmpDir.toString()
                                         + "" is not a valid temp directory"");
            }
        }
        this.tmpDir = tmpDir;
    }

    
    public void init() {
        antRuntimeClasses = new Path(getProject());
        splitJunit = !addClasspathEntry(""/junit/framework/TestCase.class"");
        addClasspathEntry(""/org/apache/tools/ant/launch/AntMain.class"");
        addClasspathEntry(""/org/apache/tools/ant/Task.class"");
        addClasspathEntry(""/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.class"");
    }

    private static JUnitTaskMirror createMirror(JUnitTask task, ClassLoader loader) {
        try {
            loader.loadClass(""junit.framework.Test""); 
        } catch (ClassNotFoundException e) {
            throw new BuildException(
                    ""The <classpath> for <junit> must include junit.jar ""
                    + ""if not in Ant's own classpath"",
                    e, task.getLocation());
        }
        try {
            Class c = loader.loadClass(JUnitTaskMirror.class.getName() + ""Impl"");
            if (c.getClassLoader() != loader) {
                throw new BuildException(""Overdelegating loader"", task.getLocation());
            }
            Constructor cons = c.getConstructor(new Class[] {JUnitTask.class});
            return (JUnitTaskMirror) cons.newInstance(new Object[] {task});
        } catch (Exception e) {
            throw new BuildException(e, task.getLocation());
        }
    }

    private final class SplitLoader extends AntClassLoader {

        public SplitLoader(ClassLoader parent, Path path) {
            super(parent, getProject(), path, true);
        }

        
        
        protected synchronized Class loadClass(String classname, boolean resolve)
        throws ClassNotFoundException {
            Class theClass = findLoadedClass(classname);
            if (theClass != null) {
                return theClass;
            }
            if (isSplit(classname)) {
                theClass = findClass(classname);
                if (resolve) {
                    resolveClass(theClass);
                }
                return theClass;
            } else {
                return super.loadClass(classname, resolve);
            }
        }

        private final String[] splitClasses = {
            ""BriefJUnitResultFormatter"",
            ""JUnitResultFormatter"",
            ""JUnitTaskMirrorImpl"",
            ""JUnitTestRunner"",
            ""JUnitVersionHelper"",
            ""OutErrSummaryJUnitResultFormatter"",
            ""PlainJUnitResultFormatter"",
            ""SummaryJUnitResultFormatter"",
            ""XMLJUnitResultFormatter"",
        };

        private boolean isSplit(String classname) {
            String simplename = classname.substring(classname.lastIndexOf('.') + 1);
            for (int i = 0; i < splitClasses.length; i++) {
                if (simplename.equals(splitClasses[i])
                        || simplename.startsWith(splitClasses[i] + '$')) {
                    return true;
                }
            }
            return false;
        }

    }

    
    public void execute() throws BuildException {
        ClassLoader myLoader = JUnitTask.class.getClassLoader();
        ClassLoader mirrorLoader;
        if (splitJunit) {
            Path path = new Path(getProject());
            path.add(antRuntimeClasses);
            path.add(getCommandline().getClasspath());
            mirrorLoader = new SplitLoader(myLoader, path);
        } else {
            mirrorLoader = myLoader;
        }
        delegate = createMirror(this, mirrorLoader);

        List testLists = new ArrayList();

        boolean forkPerTest = forkMode.getValue().equals(ForkMode.PER_TEST);
        if (forkPerTest || forkMode.getValue().equals(ForkMode.ONCE)) {
            testLists.addAll(executeOrQueue(getIndividualTests(),
                                            forkPerTest));
        } else { 
            final int count = batchTests.size();
            for (int i = 0; i < count; i++) {
                BatchTest batchtest = (BatchTest) batchTests.elementAt(i);
                testLists.addAll(executeOrQueue(batchtest.elements(), false));
            }
            testLists.addAll(executeOrQueue(tests.elements(), forkPerTest));
        }

        try {
            Iterator iter = testLists.iterator();
            while (iter.hasNext()) {
                List l = (List) iter.next();
                if (l.size() == 1) {
                    execute((JUnitTest) l.get(0));
                } else {
                    execute(l);
                }
            }
        } finally {
            deleteClassLoader();
            if (mirrorLoader instanceof SplitLoader) {
                ((SplitLoader) mirrorLoader).cleanup();
            }
            delegate = null;
        }
    }

    
    protected void execute(JUnitTest arg) throws BuildException {
        JUnitTest test = (JUnitTest) arg.clone();
        
        
        if (test.getTodir() == null) {
            test.setTodir(getProject().resolveFile("".""));
        }

        if (test.getOutfile() == null) {
            test.setOutfile(""TEST-"" + test.getName());
        }

        
        TestResultHolder result = null;
        if (!test.getFork()) {
            result = executeInVM(test);
        } else {
            ExecuteWatchdog watchdog = createWatchdog();
            result = executeAsForked(test, watchdog, null);
            
        }
        actOnTestResult(result, test, ""Test "" + test.getName());
    }

    
    protected void execute(List tests) throws BuildException {
        JUnitTest test = null;
        
        
        File casesFile = createTempPropertiesFile(""junittestcases"");
        PrintWriter writer = null;
        try {
            writer =
                new PrintWriter(new BufferedWriter(new FileWriter(casesFile)));
            Iterator iter = tests.iterator();
            while (iter.hasNext()) {
                test = (JUnitTest) iter.next();
                writer.print(test.getName());
                if (test.getTodir() == null) {
                    writer.print("","" + getProject().resolveFile("".""));
                } else {
                    writer.print("","" + test.getTodir());
                }

                if (test.getOutfile() == null) {
                    writer.println("","" + ""TEST-"" + test.getName());
                } else {
                    writer.println("","" + test.getOutfile());
                }
            }
            writer.flush();
            writer.close();
            writer = null;

            
            ExecuteWatchdog watchdog = createWatchdog();
            TestResultHolder result =
                executeAsForked(test, watchdog, casesFile);
            actOnTestResult(result, test, ""Tests"");
        } catch (IOException e) {
            log(e.toString(), Project.MSG_ERR);
            throw new BuildException(e);
        } finally {
            if (writer != null) {
                writer.close();
            }

            try {
                casesFile.delete();
            } catch (Exception e) {
                log(e.toString(), Project.MSG_ERR);
            }
        }
    }

    
    private TestResultHolder executeAsForked(JUnitTest test,
                                             ExecuteWatchdog watchdog,
                                             File casesFile)
        throws BuildException {

        if (perm != null) {
            log(""Permissions ignored when running in forked mode!"",
                Project.MSG_WARN);
        }

        CommandlineJava cmd = null;
        try {
            cmd = (CommandlineJava) (getCommandline().clone());
        } catch (CloneNotSupportedException e) {
            throw new BuildException(""This shouldn't happen"", e, getLocation());
        }
        cmd.setClassname(""org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner"");
        if (casesFile == null) {
            cmd.createArgument().setValue(test.getName());
        } else {
            log(""Running multiple tests in the same VM"", Project.MSG_VERBOSE);
            cmd.createArgument().setValue(Constants.TESTSFILE + casesFile);
        }

        cmd.createArgument().setValue(Constants.FILTERTRACE + test.getFiltertrace());
        cmd.createArgument().setValue(Constants.HALT_ON_ERROR + test.getHaltonerror());
        cmd.createArgument().setValue(Constants.HALT_ON_FAILURE
                                      + test.getHaltonfailure());
        if (includeAntRuntime) {
            Vector v = Execute.getProcEnvironment();
            Enumeration e = v.elements();
            while (e.hasMoreElements()) {
                String s = (String) e.nextElement();
                if (s.startsWith(CLASSPATH)) {
                    cmd.createClasspath(getProject()).createPath()
                        .append(new Path(getProject(),
                                         s.substring(CLASSPATH.length()
                                                     )));
                }
            }
            log(""Implicitly adding "" + antRuntimeClasses + "" to CLASSPATH"",
                Project.MSG_VERBOSE);
            cmd.createClasspath(getProject()).createPath()
                .append(antRuntimeClasses);
        }

        if (summary) {
            String prefix = """";
            if (""withoutanderr"".equalsIgnoreCase(summaryValue)) {
                prefix = ""OutErr"";
            }
            cmd.createArgument()
                .setValue(Constants.FORMATTER
                          + ""org.apache.tools.ant.taskdefs.optional.junit.""
                          + prefix + ""SummaryJUnitResultFormatter"");
        }

        cmd.createArgument().setValue(Constants.SHOWOUTPUT
                                      + String.valueOf(showOutput));
        cmd.createArgument().setValue(Constants.OUTPUT_TO_FORMATTERS
                                      + String.valueOf(outputToFormatters));

        cmd.createArgument().setValue(
            Constants.LOGTESTLISTENEREVENTS + ""true""); 

        StringBuffer formatterArg = new StringBuffer(STRING_BUFFER_SIZE);
        final FormatterElement[] feArray = mergeFormatters(test);
        for (int i = 0; i < feArray.length; i++) {
            FormatterElement fe = feArray[i];
            if (fe.shouldUse(this)) {
                formatterArg.append(Constants.FORMATTER);
                formatterArg.append(fe.getClassname());
                File outFile = getOutput(fe, test);
                if (outFile != null) {
                    formatterArg.append("","");
                    formatterArg.append(outFile);
                }
                cmd.createArgument().setValue(formatterArg.toString());
                formatterArg = new StringBuffer();
            }
        }

        File vmWatcher = createTempPropertiesFile(""junitvmwatcher"");
        cmd.createArgument().setValue(Constants.CRASHFILE
                                      + vmWatcher.getAbsolutePath());
        File propsFile = createTempPropertiesFile(""junit"");
        cmd.createArgument().setValue(Constants.PROPSFILE
                                      + propsFile.getAbsolutePath());
        Hashtable p = getProject().getProperties();
        Properties props = new Properties();
        for (Enumeration e = p.keys(); e.hasMoreElements();) {
            Object key = e.nextElement();
            props.put(key, p.get(key));
        }
        try {
            FileOutputStream outstream = new FileOutputStream(propsFile);
            props.store(outstream, ""Ant JUnitTask generated properties file"");
            outstream.close();
        } catch (java.io.IOException e) {
            propsFile.delete();
            throw new BuildException(""Error creating temporary properties ""
                                     + ""file."", e, getLocation());
        }

        Execute execute = new Execute(
            new JUnitLogStreamHandler(
                this,
                Project.MSG_INFO,
                Project.MSG_WARN),
            watchdog);
        execute.setCommandline(cmd.getCommandline());
        execute.setAntRun(getProject());
        if (dir != null) {
            execute.setWorkingDirectory(dir);
        }

        String[] environment = env.getVariables();
        if (environment != null) {
            for (int i = 0; i < environment.length; i++) {
                log(""Setting environment variable: "" + environment[i],
                    Project.MSG_VERBOSE);
            }
        }
        execute.setNewenvironment(newEnvironment);
        execute.setEnvironment(environment);

        log(cmd.describeCommand(), Project.MSG_VERBOSE);
        TestResultHolder result = new TestResultHolder();
        try {
            result.exitCode = execute.execute();
        } catch (IOException e) {
            throw new BuildException(""Process fork failed."", e, getLocation());
        } finally {
            String vmCrashString = ""unknown"";
            BufferedReader br = null;
            try {
                br = new BufferedReader(new FileReader(vmWatcher));
                vmCrashString = br.readLine();
            } catch (Exception e) {
                e.printStackTrace();
                
            } finally {
                FileUtils.close(br);
            }
            if (watchdog != null && watchdog.killedProcess()) {
                result.timedOut = true;
                logTimeout(feArray, test, vmCrashString);
            } else if (!Constants.TERMINATED_SUCCESSFULLY.equals(vmCrashString)) {
                result.crashed = true;
                logVmCrash(feArray, test, vmCrashString);
            }
            vmWatcher.delete();

            if (!propsFile.delete()) {
                throw new BuildException(""Could not delete temporary ""
                                         + ""properties file."");
            }
        }

        return result;
    }

    
    private File createTempPropertiesFile(String prefix) {
        File propsFile =
            FILE_UTILS.createTempFile(prefix, "".properties"",
                tmpDir != null ? tmpDir : getProject().getBaseDir(), true);
        return propsFile;
    }


    
    protected void handleOutput(String output) {
        if (output.startsWith(TESTLISTENER_PREFIX)) {
            log(output, Project.MSG_VERBOSE);
        } else if (runner != null) {
            if (outputToFormatters) {
                runner.handleOutput(output);
            }
            if (showOutput) {
                super.handleOutput(output);
            }
        } else {
            super.handleOutput(output);
        }
    }

    
    protected int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        if (runner != null) {
            return runner.handleInput(buffer, offset, length);
        } else {
            return super.handleInput(buffer, offset, length);
        }
    }


    
    protected void handleFlush(String output) {
        if (runner != null) {
            runner.handleFlush(output);
            if (showOutput) {
                super.handleFlush(output);
            }
        } else {
            super.handleFlush(output);
        }
    }

    
    public void handleErrorOutput(String output) {
        if (runner != null) {
            runner.handleErrorOutput(output);
            if (showOutput) {
                super.handleErrorOutput(output);
            }
        } else {
            super.handleErrorOutput(output);
        }
    }


    
    public void handleErrorFlush(String output) {
        if (runner != null) {
            runner.handleErrorFlush(output);
            if (showOutput) {
                super.handleErrorFlush(output);
            }
        } else {
            super.handleErrorFlush(output);
        }
    }

    
    
    

    
    private TestResultHolder executeInVM(JUnitTest arg) throws BuildException {
        JUnitTest test = (JUnitTest) arg.clone();
        test.setProperties(getProject().getProperties());
        if (dir != null) {
            log(""dir attribute ignored if running in the same VM"",
                Project.MSG_WARN);
        }

        if (newEnvironment || null != env.getVariables()) {
            log(""Changes to environment variables are ignored if running in ""
                + ""the same VM."", Project.MSG_WARN);
        }

        if (getCommandline().getBootclasspath() != null) {
            log(""bootclasspath is ignored if running in the same VM."",
                Project.MSG_WARN);
        }

        CommandlineJava.SysProperties sysProperties =
                getCommandline().getSystemProperties();
        if (sysProperties != null) {
            sysProperties.setSystem();
        }

        try {
            log(""Using System properties "" + System.getProperties(),
                Project.MSG_VERBOSE);
            if (splitJunit) {
                classLoader = (AntClassLoader) delegate.getClass().getClassLoader();
            } else {
                createClassLoader();
            }
            if (classLoader != null) {
                classLoader.setThreadContextLoader();
            }
            runner = delegate.newJUnitTestRunner(test, test.getHaltonerror(),
                                         test.getFiltertrace(),
                                         test.getHaltonfailure(), false,
                                         true, classLoader);
            if (summary) {

                JUnitTaskMirror.SummaryJUnitResultFormatterMirror f =
                    delegate.newSummaryJUnitResultFormatter();
                f.setWithOutAndErr(""withoutanderr""
                                   .equalsIgnoreCase(summaryValue));
                f.setOutput(getDefaultOutput());
                runner.addFormatter(f);
            }

            runner.setPermissions(perm);

            final FormatterElement[] feArray = mergeFormatters(test);
            for (int i = 0; i < feArray.length; i++) {
                FormatterElement fe = feArray[i];
                if (fe.shouldUse(this)) {
                    File outFile = getOutput(fe, test);
                    if (outFile != null) {
                        fe.setOutfile(outFile);
                    } else {
                        fe.setOutput(getDefaultOutput());
                    }
                    runner.addFormatter(fe.createFormatter(classLoader));
                }
            }

            runner.run();
            TestResultHolder result = new TestResultHolder();
            result.exitCode = runner.getRetCode();
            return result;
        } finally {
            if (sysProperties != null) {
                sysProperties.restoreSystem();
            }
            if (classLoader != null) {
                classLoader.resetThreadContextLoader();
            }
        }
    }

    
    protected ExecuteWatchdog createWatchdog() throws BuildException {
        if (timeout == null) {
            return null;
        }
        return new ExecuteWatchdog((long) timeout.intValue());
    }

    
    protected OutputStream getDefaultOutput() {
        return new LogOutputStream(this, Project.MSG_INFO);
    }

    
    protected Enumeration getIndividualTests() {
        final int count = batchTests.size();
        final Enumeration[] enums = new Enumeration[ count + 1];
        for (int i = 0; i < count; i++) {
            BatchTest batchtest = (BatchTest) batchTests.elementAt(i);
            enums[i] = batchtest.elements();
        }
        enums[enums.length - 1] = tests.elements();
        return Enumerations.fromCompound(enums);
    }

    
    protected Enumeration allTests() {
        Enumeration[] enums = {tests.elements(), batchTests.elements()};
        return Enumerations.fromCompound(enums);
    }

    
    private FormatterElement[] mergeFormatters(JUnitTest test) {
        Vector feVector = (Vector) formatters.clone();
        test.addFormattersTo(feVector);
        FormatterElement[] feArray = new FormatterElement[feVector.size()];
        feVector.copyInto(feArray);
        return feArray;
    }

    
    protected File getOutput(FormatterElement fe, JUnitTest test) {
        if (fe.getUseFile()) {
            String base = test.getOutfile();
            if (base == null) {
                base = JUnitTaskMirror.JUnitTestRunnerMirror.IGNORED_FILE_NAME;
            }
            String filename = base + fe.getExtension();
            File destFile = new File(test.getTodir(), filename);
            String absFilename = destFile.getAbsolutePath();
            return getProject().resolveFile(absFilename);
        }
        return null;
    }

    
    protected boolean addClasspathEntry(String resource) {
        
        if (resource.startsWith(""/"")) {
            resource = resource.substring(1);
        } else {
            resource = ""org/apache/tools/ant/taskdefs/optional/junit/""
                + resource;
        }

        File f = LoaderUtils.getResourceSource(getClass().getClassLoader(),
                                               resource);
        if (f != null) {
            log(""Found "" + f.getAbsolutePath(), Project.MSG_DEBUG);
            antRuntimeClasses.createPath().setLocation(f);
            return true;
        } else {
            log(""Couldn\'t find "" + resource, Project.MSG_DEBUG);
            return false;
        }
    }

    

    private void logTimeout(FormatterElement[] feArray, JUnitTest test, String testCase) {
        logVmExit(
            feArray, test,
            ""Timeout occurred. Please note the time in the report does""
            + "" not reflect the time until the timeout."",
            testCase);
    }

    
    private void logVmCrash(FormatterElement[] feArray, JUnitTest test, String testCase) {
        logVmExit(
            feArray, test,
            ""Forked Java VM exited abnormally. Please note the time in the report""
            + "" does not reflect the time until the VM exit."",
            testCase);
    }

    
    private void logVmExit(FormatterElement[] feArray, JUnitTest test,
                           String message, String testCase) {
        try {
            log(""Using System properties "" + System.getProperties(),
                Project.MSG_VERBOSE);
            if (splitJunit) {
                classLoader = (AntClassLoader) delegate.getClass().getClassLoader();
            } else {
                createClassLoader();
            }
            if (classLoader != null) {
                classLoader.setThreadContextLoader();
            }

            test.setCounts(1, 0, 1);
            test.setProperties(getProject().getProperties());
            for (int i = 0; i < feArray.length; i++) {
                FormatterElement fe = feArray[i];
                File outFile = getOutput(fe, test);
                JUnitTaskMirror.JUnitResultFormatterMirror formatter =
                    fe.createFormatter(classLoader);
                if (outFile != null && formatter != null) {
                    try {
                        OutputStream out = new FileOutputStream(outFile);
                        delegate.addVmExit(test, formatter, out, message, testCase);
                    } catch (IOException e) {
                        
                    }
                }
            }
            if (summary) {
                JUnitTaskMirror.SummaryJUnitResultFormatterMirror f =
                    delegate.newSummaryJUnitResultFormatter();
                f.setWithOutAndErr(""withoutanderr"".equalsIgnoreCase(summaryValue));
                delegate.addVmExit(test, f, getDefaultOutput(), message, testCase);
            }
        } finally {
            if (classLoader != null) {
                classLoader.resetThreadContextLoader();
            }
        }
    }

    
    private void createClassLoader() {
        Path userClasspath = getCommandline().getClasspath();
        if (userClasspath != null) {
            if (reloading || classLoader == null) {
                deleteClassLoader();
                Path classpath = (Path) userClasspath.clone();
                if (includeAntRuntime) {
                    log(""Implicitly adding "" + antRuntimeClasses
                        + "" to CLASSPATH"", Project.MSG_VERBOSE);
                    classpath.append(antRuntimeClasses);
                }
                classLoader = getProject().createClassLoader(classpath);
                if (getClass().getClassLoader() != null
                    && getClass().getClassLoader() != Project.class.getClassLoader()) {
                    classLoader.setParent(getClass().getClassLoader());
                }
                classLoader.setParentFirst(false);
                classLoader.addJavaLibraries();
                log(""Using CLASSPATH "" + classLoader.getClasspath(),
                    Project.MSG_VERBOSE);
                
                classLoader.addSystemPackageRoot(""junit"");
                
                classLoader.addSystemPackageRoot(""org.junit"");
                
                classLoader.addSystemPackageRoot(""org.apache.tools.ant"");
            }
        }
    }

    
    private void deleteClassLoader() {
        if (classLoader != null) {
            classLoader.cleanup();
            classLoader = null;
        }
    }

    
    protected CommandlineJava getCommandline() {
        if (commandline == null) {
            commandline = new CommandlineJava();
        }
        return commandline;
    }

    
    private static final class ForkedTestConfiguration {
        private boolean filterTrace;
        private boolean haltOnError;
        private boolean haltOnFailure;
        private String errorProperty;
        private String failureProperty;

        
        ForkedTestConfiguration(boolean filterTrace, boolean haltOnError,
                                boolean haltOnFailure, String errorProperty,
                                String failureProperty) {
            this.filterTrace = filterTrace;
            this.haltOnError = haltOnError;
            this.haltOnFailure = haltOnFailure;
            this.errorProperty = errorProperty;
            this.failureProperty = failureProperty;
        }

        
        ForkedTestConfiguration(JUnitTest test) {
            this(test.getFiltertrace(),
                    test.getHaltonerror(),
                    test.getHaltonfailure(),
                    test.getErrorProperty(),
                    test.getFailureProperty());
        }

        
        public boolean equals(Object other) {
            if (other == null
                || other.getClass() != ForkedTestConfiguration.class) {
                return false;
            }
            ForkedTestConfiguration o = (ForkedTestConfiguration) other;
            return filterTrace == o.filterTrace
                && haltOnError == o.haltOnError
                && haltOnFailure == o.haltOnFailure
                && ((errorProperty == null && o.errorProperty == null)
                    ||
                    (errorProperty != null
                     && errorProperty.equals(o.errorProperty)))
                && ((failureProperty == null && o.failureProperty == null)
                    ||
                    (failureProperty != null
                     && failureProperty.equals(o.failureProperty)));
        }

        
        public int hashCode() {
            return (filterTrace ? 1 : 0)
                + (haltOnError ? 2 : 0)
                + (haltOnFailure ? 4 : 0);
        }
    }

    
    public static final class ForkMode extends EnumeratedAttribute {

        
        public static final String ONCE = ""once"";
        
        public static final String PER_TEST = ""perTest"";
        
        public static final String PER_BATCH = ""perBatch"";

        
        public ForkMode() {
            super();
        }

        
        public ForkMode(String value) {
            super();
            setValue(value);
        }

        
        public String[] getValues() {
            return new String[] {ONCE, PER_TEST, PER_BATCH};
        }
    }

    
    protected Collection executeOrQueue(Enumeration testList,
                                        boolean runIndividual) {
        Map testConfigurations = new HashMap();
        while (testList.hasMoreElements()) {
            JUnitTest test = (JUnitTest) testList.nextElement();
            if (test.shouldRun(getProject())) {
                if (runIndividual || !test.getFork()) {
                    execute(test);
                } else {
                    ForkedTestConfiguration c =
                        new ForkedTestConfiguration(test);
                    List l = (List) testConfigurations.get(c);
                    if (l == null) {
                        l = new ArrayList();
                        testConfigurations.put(c, l);
                    }
                    l.add(test);
                }
            }
        }
        return testConfigurations.values();
    }

    
    protected void actOnTestResult(int exitValue, boolean wasKilled,
                                   JUnitTest test, String name) {
        TestResultHolder t = new TestResultHolder();
        t.exitCode = exitValue;
        t.timedOut = wasKilled;
        actOnTestResult(t, test, name);
    }

    
    protected void actOnTestResult(TestResultHolder result, JUnitTest test,
                                   String name) {
        
        
        boolean fatal = result.timedOut || result.crashed;
        boolean errorOccurredHere =
            result.exitCode == JUnitTaskMirror.JUnitTestRunnerMirror.ERRORS || fatal;
        boolean failureOccurredHere =
            result.exitCode != JUnitTaskMirror.JUnitTestRunnerMirror.SUCCESS || fatal;
        if (errorOccurredHere || failureOccurredHere) {
            if ((errorOccurredHere && test.getHaltonerror())
                || (failureOccurredHere && test.getHaltonfailure())) {
                throw new BuildException(name + "" failed""
                    + (result.timedOut ? "" (timeout)"" : """")
                    + (result.crashed ? "" (crashed)"" : """"), getLocation());
            } else {
                log(name + "" FAILED""
                    + (result.timedOut ? "" (timeout)"" : """")
                    + (result.crashed ? "" (crashed)"" : """"), Project.MSG_ERR);
                if (errorOccurredHere && test.getErrorProperty() != null) {
                    getProject().setNewProperty(test.getErrorProperty(), ""true"");
                }
                if (failureOccurredHere && test.getFailureProperty() != null) {
                    getProject().setNewProperty(test.getFailureProperty(), ""true"");
                }
            }
        }
    }

    
    protected class TestResultHolder {
        
        
        public int exitCode = JUnitTaskMirror.JUnitTestRunnerMirror.ERRORS;
        
        public boolean timedOut = false;
        
        public boolean crashed = false;
        
    }

    
    protected static class JUnitLogOutputStream extends LogOutputStream {
        private Task task; 

        
        public JUnitLogOutputStream(Task task, int level) {
            super(task, level);
            this.task = task;
        }

        
        protected void processLine(String line, int level) {
            if (line.startsWith(TESTLISTENER_PREFIX)) {
                task.log(line, Project.MSG_VERBOSE);
            } else {
                super.processLine(line, level);
            }
        }
    }

    
    protected static class JUnitLogStreamHandler extends PumpStreamHandler {
        
        public JUnitLogStreamHandler(Task task, int outlevel, int errlevel) {
            super(new JUnitLogOutputStream(task, outlevel),
                  new LogOutputStream(task, errlevel));
        }
    }
}
"
org.apache.tools.ant.types.FileSet,6,4,5,64,17,15,59,5,5,2.0,67,0.0,0,0.956043956,0.583333333,3,4,10.16666667,2,1.1667,0,"

package org.apache.tools.ant.types;

import java.util.Iterator;

import org.apache.tools.ant.types.resources.FileResourceIterator;


public class FileSet extends AbstractFileSet implements ResourceCollection {

    
    public FileSet() {
        super();
    }

    
    protected FileSet(FileSet fileset) {
        super(fileset);
    }

    
    public Object clone() {
        if (isReference()) {
            return ((FileSet) getRef(getProject())).clone();
        } else {
            return super.clone();
        }
    }

    
    public Iterator iterator() {
        if (isReference()) {
            return ((FileSet) getRef(getProject())).iterator();
        }
        return new FileResourceIterator(getDir(getProject()),
            getDirectoryScanner(getProject()).getIncludedFiles());
    }

    
    public int size() {
        if (isReference()) {
            return ((FileSet) getRef(getProject())).size();
        }
        return getDirectoryScanner(getProject()).getIncludedFilesCount();
    }

    
    public boolean isFilesystemOnly() {
        return true;
    }

}
"
org.apache.tools.ant.taskdefs.condition.ResourcesMatch,4,1,0,6,18,0,0,6,4,0.333333333,100,1.0,1,0.0,0.5,0,0,23.5,3,1.25,0,"
 package org.apache.tools.ant.taskdefs.condition;

import java.io.IOException;
import java.util.Iterator;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.util.ResourceUtils;


public class ResourcesMatch implements Condition {

    private Union resources = null;
    private boolean asText = false;

    
    public void setAsText(boolean asText) {
        this.asText = asText;
    }

    
    public void add(ResourceCollection rc) {
        if (rc == null) {
            return;
        }
        resources = resources == null ? new Union() : resources;
        resources.add(rc);
    }

    
    public boolean eval() throws BuildException {
        if (resources == null) {
            throw new BuildException(
                ""You must specify one or more nested resource collections"");
        }
        if (resources.size() > 1) {
            Iterator i = resources.iterator();
            Resource r1 = (Resource) i.next();
            Resource r2 = null;

            while (i.hasNext()) {
                r2 = (Resource) i.next();
                try {
                    if (!ResourceUtils.contentEquals(r1, r2, asText)) {
                        return false;
                    }
                } catch (IOException ioe) {
                    throw new BuildException(""when comparing resources ""
                        + r1.toString() + "" and "" + r2.toString(), ioe);
                }
                r1 = r2;
            }
        }
        return true;
    }
}
"
org.apache.tools.ant.taskdefs.ConditionTask,5,3,0,4,18,0,0,4,5,0.5,148,1.0,0,0.888888889,0.8,0,0,28.0,1,0.8,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.Condition;
import org.apache.tools.ant.taskdefs.condition.ConditionBase;


public class ConditionTask extends ConditionBase {

    private String property = null;
    private String value = ""true"";
    private String alternative = null;

    
    public ConditionTask() {
        super(""condition"");
    }

    
    public void setProperty(String p) {
        property = p;
    }

    
    public void setValue(String v) {
        value = v;
    }

    
    public void setElse(String e) {
        alternative = e;
    }

    
    public void execute() throws BuildException {
        if (countConditions() > 1) {
            throw new BuildException(""You must not nest more than one ""
                + ""condition into <""
                + getTaskName() + "">"");
        }
        if (countConditions() < 1) {
            throw new BuildException(""You must nest a condition into <""
                + getTaskName() + "">"");
        }
        if (property == null) {
            throw new BuildException(""The property attribute is required."");
        }
        Condition c = (Condition) getConditions().nextElement();
        if (c.eval()) {
            log(""Condition true; setting "" + property + "" to "" + value,
                Project.MSG_DEBUG);
            getProject().setNewProperty(property, value);
        } else if (alternative != null) {
            log(""Condition false; setting "" + property + "" to "" + alternative,
                Project.MSG_DEBUG);
            getProject().setNewProperty(property, alternative);
        } else {
            log(""Condition false; not setting "" + property,
                Project.MSG_DEBUG);
        }
    }
}
"
org.apache.tools.ant.taskdefs.Java,60,3,0,35,178,1304,10,25,43,0.891326022,1152,1.0,5,0.389473684,0.098245614,1,4,17.91666667,5,1.3167,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ExitException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.ExitStatusException;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.PropertySet;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.Assertions;
import org.apache.tools.ant.types.Permissions;
import org.apache.tools.ant.types.RedirectorElement;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.util.KeepAliveInputStream;


public class Java extends Task {

    private CommandlineJava cmdl = new CommandlineJava();
    private Environment env = new Environment();
    private boolean fork = false;
    private boolean newEnvironment = false;
    private File dir = null;
    private boolean failOnError = false;
    private Long timeout = null;

    
    private String inputString;
    private File input;
    private File output;
    private File error;

    
    protected Redirector redirector = new Redirector(this);
    protected RedirectorElement redirectorElement;
    

    private String resultProperty;
    private Permissions perm = null;

    private boolean spawn = false;
    private boolean incompatibleWithSpawn = false;

    
    public Java() {
    }

    
    public Java(Task owner) {
        bindToOwner(owner);
    }

    
    public void execute() throws BuildException {
        File savedDir = dir;
        Permissions savedPermissions = perm;

        int err = -1;
        try {
            err = executeJava();
            if (err != 0) {
                if (failOnError) {
                    throw new ExitStatusException(""Java returned: "" + err,
                            err,
                            getLocation());
                } else {
                    log(""Java Result: "" + err, Project.MSG_ERR);
                }
            }
            maybeSetResultPropertyValue(err);
        } finally {
            dir = savedDir;
            perm = savedPermissions;
        }
    }

    
    public int executeJava() throws BuildException {
        String classname = getCommandLine().getClassname();
        if (classname == null && getCommandLine().getJar() == null) {
            throw new BuildException(""Classname must not be null."");
        }
        if (!fork && getCommandLine().getJar() != null) {
            throw new BuildException(""Cannot execute a jar in non-forked mode.""
                                     + "" Please set fork='true'. "");
        }
        if (spawn && !fork) {
            throw new BuildException(""Cannot spawn a java process in non-forked mode.""
                                     + "" Please set fork='true'. "");
        }
        if (getCommandLine().getClasspath() != null
            && getCommandLine().getJar() != null) {
            log(""When using 'jar' attribute classpath-settings are ignored. ""
                + ""See the manual for more information."", Project.MSG_VERBOSE);
        }
        if (spawn && incompatibleWithSpawn) {
            getProject().log(""spawn does not allow attributes related to input, ""
            + ""output, error, result"", Project.MSG_ERR);
            getProject().log(""spawn also does not allow timeout"", Project.MSG_ERR);
            getProject().log(""finally, spawn is not compatible ""
                + ""with a nested I/O <redirector>"", Project.MSG_ERR);
            throw new BuildException(""You have used an attribute ""
                + ""or nested element which is not compatible with spawn"");
        }
        if (getCommandLine().getAssertions() != null && !fork) {
            log(""Assertion statements are currently ignored in non-forked mode"");
        }
        if (fork) {
            if (perm != null) {
                log(""Permissions can not be set this way in forked mode."", Project.MSG_WARN);
            }
            log(getCommandLine().describeCommand(), Project.MSG_VERBOSE);
        } else {
            if (getCommandLine().getVmCommand().size() > 1) {
                log(""JVM args ignored when same JVM is used."",
                    Project.MSG_WARN);
            }
            if (dir != null) {
                log(""Working directory ignored when same JVM is used."",
                    Project.MSG_WARN);
            }
            if (newEnvironment || null != env.getVariables()) {
                log(""Changes to environment variables are ignored when same ""
                    + ""JVM is used."", Project.MSG_WARN);
            }
            if (getCommandLine().getBootclasspath() != null) {
                log(""bootclasspath ignored when same JVM is used."",
                    Project.MSG_WARN);
            }
            if (perm == null) {
                perm = new Permissions(true);
                log(""running "" + this.getCommandLine().getClassname()
                    + "" with default permissions (exit forbidden)"", Project.MSG_VERBOSE);
            }
            log(""Running in same VM "" + getCommandLine().describeJavaCommand(),
                Project.MSG_VERBOSE);
        }
        setupRedirector();
        try {
            if (fork) {
                if (!spawn) {
                    return fork(getCommandLine().getCommandline());
                } else {
                    spawn(getCommandLine().getCommandline());
                    return 0;
                }
            } else {
                try {
                    run(getCommandLine());
                    return 0;
                } catch (ExitException ex) {
                    return ex.getStatus();
                }
            }
        } catch (BuildException e) {
            if (e.getLocation() == null && getLocation() != null) {
                e.setLocation(getLocation());
            }
            if (failOnError) {
                throw e;
            } else {
                log(e);
                return 0;
            }
        } catch (ThreadDeath t) {
            throw t; 
        } catch (Throwable t) {
            if (failOnError) {
                throw new BuildException(t, getLocation());
            } else {
                log(t);
                return 0;
            }
        }
    }

    
    public void setSpawn(boolean spawn) {
        this.spawn = spawn;
    }

    
    public void setClasspath(Path s) {
        createClasspath().append(s);
    }

    
    public Path createClasspath() {
        return getCommandLine().createClasspath(getProject()).createPath();
    }

    
    public Path createBootclasspath() {
        return getCommandLine().createBootclasspath(getProject()).createPath();
    }

    
    public Permissions createPermissions() {
        perm = (perm == null) ? new Permissions() : perm;
        return perm;
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setJar(File jarfile) throws BuildException {
        if (getCommandLine().getClassname() != null) {
            throw new BuildException(""Cannot use 'jar' and 'classname' ""
                                     + ""attributes in same command."");
        }
        getCommandLine().setJar(jarfile.getAbsolutePath());
    }

    
    public void setClassname(String s) throws BuildException {
        if (getCommandLine().getJar() != null) {
            throw new BuildException(""Cannot use 'jar' and 'classname' ""
                                     + ""attributes in same command"");
        }
        getCommandLine().setClassname(s);
    }

    
    public void setArgs(String s) {
        log(""The args attribute is deprecated. ""
            + ""Please use nested arg elements."", Project.MSG_WARN);
        getCommandLine().createArgument().setLine(s);
    }

    
    public void setCloneVm(boolean cloneVm) {
        getCommandLine().setCloneVm(cloneVm);
    }

    
    public Commandline.Argument createArg() {
        return getCommandLine().createArgument();
    }

    
    public void setResultProperty(String resultProperty) {
        this.resultProperty = resultProperty;
        incompatibleWithSpawn = true;
    }

    
    protected void maybeSetResultPropertyValue(int result) {
        String res = Integer.toString(result);
        if (resultProperty != null) {
            getProject().setNewProperty(resultProperty, res);
        }
    }

    
    public void setFork(boolean s) {
        this.fork = s;
    }

    
    public void setJvmargs(String s) {
        log(""The jvmargs attribute is deprecated. ""
            + ""Please use nested jvmarg elements."", Project.MSG_WARN);
        getCommandLine().createVmArgument().setLine(s);
    }

    
    public Commandline.Argument createJvmarg() {
        return getCommandLine().createVmArgument();
    }

    
    public void setJvm(String s) {
        getCommandLine().setVm(s);
    }

    
    public void addSysproperty(Environment.Variable sysp) {
        getCommandLine().addSysproperty(sysp);
    }

    
    public void addSyspropertyset(PropertySet sysp) {
        getCommandLine().addSyspropertyset(sysp);
    }

    
    public void setFailonerror(boolean fail) {
        failOnError = fail;
        incompatibleWithSpawn |= fail;
    }

    
    public void setDir(File d) {
        this.dir = d;
    }

    
    public void setOutput(File out) {
        this.output = out;
        incompatibleWithSpawn = true;
    }

    
    public void setInput(File input) {
        if (inputString != null) {
            throw new BuildException(""The \""input\"" and \""inputstring\"" ""
                + ""attributes cannot both be specified"");
        }
        this.input = input;
        incompatibleWithSpawn = true;
    }

    
    public void setInputString(String inputString) {
        if (input != null) {
            throw new BuildException(""The \""input\"" and \""inputstring\"" ""
                + ""attributes cannot both be specified"");
        }
        this.inputString = inputString;
        incompatibleWithSpawn = true;
    }

    
    public void setLogError(boolean logError) {
        redirector.setLogError(logError);
        incompatibleWithSpawn |= logError;
    }

    
    public void setError(File error) {
        this.error = error;
        incompatibleWithSpawn = true;
    }

    
    public void setOutputproperty(String outputProp) {
        redirector.setOutputProperty(outputProp);
        incompatibleWithSpawn = true;
    }

    
    public void setErrorProperty(String errorProperty) {
        redirector.setErrorProperty(errorProperty);
        incompatibleWithSpawn = true;
    }

    
    public void setMaxmemory(String max) {
        getCommandLine().setMaxmemory(max);
    }

    
    public void setJVMVersion(String value) {
        getCommandLine().setVmversion(value);
    }

    
    public void addEnv(Environment.Variable var) {
        env.addVariable(var);
    }

    
    public void setNewenvironment(boolean newenv) {
        newEnvironment = newenv;
    }

    
    public void setAppend(boolean append) {
        redirector.setAppend(append);
        incompatibleWithSpawn = true;
    }

    
    public void setTimeout(Long value) {
        timeout = value;
        incompatibleWithSpawn |= timeout != null;
    }

    
    public void addAssertions(Assertions asserts) {
        if (getCommandLine().getAssertions() != null) {
            throw new BuildException(""Only one assertion declaration is allowed"");
        }
        getCommandLine().setAssertions(asserts);
    }

    
    public void addConfiguredRedirector(RedirectorElement redirectorElement) {
        if (this.redirectorElement != null) {
            throw new BuildException(""cannot have > 1 nested redirectors"");
        }
        this.redirectorElement = redirectorElement;
        incompatibleWithSpawn = true;
    }

    
    protected void handleOutput(String output) {
        if (redirector.getOutputStream() != null) {
            redirector.handleOutput(output);
        } else {
            super.handleOutput(output);
        }
    }

    
    public int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        
        return redirector.handleInput(buffer, offset, length);
    }

    
    protected void handleFlush(String output) {
        if (redirector.getOutputStream() != null) {
            redirector.handleFlush(output);
        } else {
            super.handleFlush(output);
        }
    }

    
    protected void handleErrorOutput(String output) {
        if (redirector.getErrorStream() != null) {
            redirector.handleErrorOutput(output);
        } else {
            super.handleErrorOutput(output);
        }
    }

    
    protected void handleErrorFlush(String output) {
        if (redirector.getErrorStream() != null) {
            redirector.handleErrorFlush(output);
        } else {
            super.handleErrorOutput(output);
        }
    }

    
    protected void setupRedirector() {
        redirector.setInput(input);
        redirector.setInputString(inputString);
        redirector.setOutput(output);
        redirector.setError(error);
        if (redirectorElement != null) {
            redirectorElement.configure(redirector);
        }
        if (!spawn && input == null && inputString == null) {
            
            redirector.setInputStream(
                new KeepAliveInputStream(getProject().getDefaultInputStream()));
        }
    }

    
    private void run(CommandlineJava command) throws BuildException {
        try {
            ExecuteJava exe = new ExecuteJava();
            exe.setJavaCommand(command.getJavaCommand());
            exe.setClasspath(command.getClasspath());
            exe.setSystemProperties(command.getSystemProperties());
            exe.setPermissions(perm);
            exe.setTimeout(timeout);
            redirector.createStreams();
            exe.execute(getProject());
            redirector.complete();
            if (exe.killedProcess()) {
                throw new BuildException(""Timeout: killed the sub-process"");
            }
        } catch (IOException e) {
            throw new BuildException(e);
        }
    }

    
    private int fork(String[] command) throws BuildException {
        Execute exe
            = new Execute(redirector.createHandler(), createWatchdog());
        setupExecutable(exe, command);

        try {
            int rc = exe.execute();
            redirector.complete();
            if (exe.killedProcess()) {
                throw new BuildException(""Timeout: killed the sub-process"");
            }
            return rc;
        } catch (IOException e) {
            throw new BuildException(e, getLocation());
        }
    }

    
    private void spawn(String[] command) throws BuildException {
        Execute exe = new Execute();
        setupExecutable(exe, command);
        try {
            exe.spawn();
        } catch (IOException e) {
            throw new BuildException(e, getLocation());
        }
    }

    
    private void setupExecutable(Execute exe, String[] command) {
        exe.setAntRun(getProject());
        setupWorkingDir(exe);
        setupEnvironment(exe);
        setupCommandLine(exe, command);
    }

    
    private void setupEnvironment(Execute exe) {
        String[] environment = env.getVariables();
        if (environment != null) {
            for (int i = 0; i < environment.length; i++) {
                log(""Setting environment variable: "" + environment[i],
                    Project.MSG_VERBOSE);
            }
        }
        exe.setNewenvironment(newEnvironment);
        exe.setEnvironment(environment);
    }

    
    private void setupWorkingDir(Execute exe) {
        if (dir == null) {
            dir = getProject().getBaseDir();
        } else if (!dir.exists() || !dir.isDirectory()) {
            throw new BuildException(dir.getAbsolutePath()
                                     + "" is not a valid directory"",
                                     getLocation());
        }
        exe.setWorkingDirectory(dir);
    }

    
    private void setupCommandLine(Execute exe, String[] command) {
        
        
        
        if (Os.isFamily(""openvms"")) {
            setupCommandLineForVMS(exe, command);
        } else {
            exe.setCommandline(command);
        }
    }

    
    private void setupCommandLineForVMS(Execute exe, String[] command) {
        ExecuteJava.setupCommandLineForVMS(exe, command);
    }

    
    protected void run(String classname, Vector args) throws BuildException {
        CommandlineJava cmdj = new CommandlineJava();
        cmdj.setClassname(classname);
        for (int i = 0; i < args.size(); i++) {
            cmdj.createArgument().setValue((String) args.elementAt(i));
        }
        run(cmdj);
    }

    
    public void clearArgs() {
        getCommandLine().clearJavaArgs();
    }

    
    protected ExecuteWatchdog createWatchdog() throws BuildException {
        if (timeout == null) {
            return null;
        }
        return new ExecuteWatchdog(timeout.longValue());
    }

    
    private void log(Throwable t) {
        StringWriter sw = new StringWriter();
        PrintWriter w = new PrintWriter(sw);
        t.printStackTrace(w);
        w.close();
        log(sw.toString(), Project.MSG_ERR);
    }

    
    public CommandlineJava getCommandLine() {
        return cmdl;
    }

    
    public CommandlineJava.SysProperties getSysProperties() {
        return getCommandLine().getSystemProperties();
    }
}
"
org.apache.tools.ant.util.depend.DependencyAnalyzer,10,1,0,5,10,45,4,1,10,2.0,10,0.0,0,0.0,0.36,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.util.depend;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import org.apache.tools.ant.types.Path;


public interface DependencyAnalyzer {
    
    void addSourcePath(Path sourcePath);

    
    void addClassPath(Path classpath);

    
    void addRootClass(String classname);

    
    Enumeration getFileDependencies();

    
    Enumeration getClassDependencies();


    
    void reset();

    
    void config(String name, Object info);

    
    void setClosure(boolean closure);


    
    File getClassContainer(String classname) throws IOException;

    
    File getSourceContainer(String classname) throws IOException;
}

"
org.apache.tools.ant.taskdefs.optional.sos.SOSCheckout,4,4,0,3,14,6,0,3,3,2.0,68,0.0,0,0.961038961,0.5,1,2,16.0,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.sos;

import org.apache.tools.ant.types.Commandline;


public class SOSCheckout extends SOS {

    
    public final void setFile(String filename) {
        super.setInternalFilename(filename);
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    protected Commandline buildCmdLine() {
        commandLine = new Commandline();

        
        if (getFilename() != null) {
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
            commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKOUT_FILE);
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_FILE);
            commandLine.createArgument().setValue(getFilename());
        } else {
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
            commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKOUT_PROJECT);
            
            commandLine.createArgument().setValue(getRecursive());
        }

        getRequiredAttributes();
        getOptionalAttributes();

        return commandLine;
    }
}
"
org.apache.tools.ant.types.optional.ScriptCondition,4,3,0,3,7,0,0,3,4,0.0,26,1.0,0,0.869565217,0.625,0,0,5.25,1,0.75,0,"
package org.apache.tools.ant.types.optional;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Condition;


public class ScriptCondition extends AbstractScriptComponent implements Condition {

    
    private boolean value = false;


    
    public boolean eval() throws BuildException {
        initScriptRunner();
        executeScript(""ant_condition"");
        return getValue();
    }

    
    public boolean getValue() {
        return value;
    }

    
    public void setValue(boolean value) {
        this.value = value;
    }
}
"
org.apache.tools.ant.util.FileTokenizer,3,2,1,4,5,3,1,3,3,2.0,11,0.0,0,0.818181818,0.666666667,0,0,2.666666667,1,0.6667,0,"
package org.apache.tools.ant.util;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.ProjectComponent;


public class FileTokenizer extends ProjectComponent implements Tokenizer {

    
    public String getToken(Reader in) throws IOException {
        return FileUtils.readFully(in);
    }

    
    public String getPostToken() {
        return """";
    }
}
"
org.apache.tools.ant.taskdefs.Copyfile,6,3,0,4,24,1,0,4,6,0.7,135,1.0,0,0.880952381,0.416666667,3,3,20.83333333,1,0.8333,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;



public class Copyfile extends Task {

    private File srcFile;
    private File destFile;
    private boolean filtering = false;
    private boolean forceOverwrite = false;

    
    public void setSrc(File src) {
        srcFile = src;
    }

    
    public void setForceoverwrite(boolean force) {
        forceOverwrite = force;
    }

    
    public void setDest(File dest) {
        destFile = dest;
    }

    
    public void setFiltering(String filter) {
        filtering = Project.toBoolean(filter);
    }

    
    public void execute() throws BuildException {
        log(""DEPRECATED - The copyfile task is deprecated.  Use copy instead."");

        if (srcFile == null) {
            throw new BuildException(""The src attribute must be present."",
                                     getLocation());
        }

        if (!srcFile.exists()) {
            throw new BuildException(""src "" + srcFile.toString()
                                     + "" does not exist."", getLocation());
        }

        if (destFile == null) {
            throw new BuildException(""The dest attribute must be present."",
                                     getLocation());
        }

        if (srcFile.equals(destFile)) {
            log(""Warning: src == dest"", Project.MSG_WARN);
        }

        if (forceOverwrite
            || srcFile.lastModified() > destFile.lastModified()) {
            try {
                getProject().copyFile(srcFile, destFile, filtering, forceOverwrite);
            } catch (IOException ioe) {
                String msg = ""Error copying file: "" + srcFile.getAbsolutePath()
                    + "" due to "" + ioe.getMessage();
                throw new BuildException(msg);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ssh.ScpFromMessageBySftp,5,3,0,9,44,8,1,8,3,0.625,298,1.0,0,0.842105263,0.542857143,1,1,57.8,1,0.6,1,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import java.io.File;
import java.io.IOException;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.SftpException;
import com.jcraft.jsch.SftpATTRS;
import com.jcraft.jsch.SftpProgressMonitor;


public class ScpFromMessageBySftp extends ScpFromMessage {

    private String remoteFile;
    private File localFile;
    private boolean isRecursive = false;
    private boolean verbose = false;

    
    public ScpFromMessageBySftp(boolean verbose,
                                Session session,
                                String aRemoteFile,
                                File aLocalFile,
                                boolean recursive) {
        super(verbose, session);
        this.verbose = verbose;
        this.remoteFile = aRemoteFile;
        this.localFile = aLocalFile;
        this.isRecursive = recursive;
    }

    
    public ScpFromMessageBySftp(Session session,
                                String aRemoteFile,
                                File aLocalFile,
                                boolean recursive) {
        this(false, session, aRemoteFile, aLocalFile, recursive);
    }

    
    public void execute() throws IOException, JSchException {
        ChannelSftp channel = openSftpChannel();
        try {
            channel.connect();
            try {
                SftpATTRS attrs = channel.stat(remoteFile);
                if (attrs.isDir() && !remoteFile.endsWith(""/"")) {
                    remoteFile = remoteFile + ""/"";
                }
            } catch (SftpException ee) {
                
            }
            getDir(channel, remoteFile, localFile);
        } catch (SftpException e) {
            throw new JSchException(e.toString());
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
        }
        log(""done\n"");
    }

    private void getDir(ChannelSftp channel,
                        String remoteFile,
                        File localFile) throws IOException, SftpException {
        String pwd = remoteFile;
        if (remoteFile.lastIndexOf('/') != -1) {
            if (remoteFile.length() > 1) {
                pwd = remoteFile.substring(0, remoteFile.lastIndexOf('/'));
            }
        }
        channel.cd(pwd);
        if (!localFile.exists()) {
            localFile.mkdirs();
        }
        java.util.Vector files = channel.ls(remoteFile);
        for (int i = 0; i < files.size(); i++) {
            ChannelSftp.LsEntry le = (ChannelSftp.LsEntry) files.elementAt(i);
            String name = le.getFilename();
            if (le.getAttrs().isDir()) {
                if (name.equals(""."") || name.equals("".."")) {
                    continue;
                }
                getDir(channel,
                       channel.pwd() + ""/"" + name + ""/"",
                       new File(localFile, le.getFilename()));
            } else {
                getFile(channel, le, localFile);
            }
        }
        channel.cd("".."");
    }

    private void getFile(ChannelSftp channel,
                         ChannelSftp.LsEntry le,
                         File localFile) throws IOException, SftpException {
        String remoteFile = le.getFilename();
        if (!localFile.exists()) {
            String path = localFile.getAbsolutePath();
            int i = 0;
            if ((i = path.lastIndexOf(File.pathSeparator)) != -1) {
                if (path.length() > File.pathSeparator.length()) {
                    new File(path.substring(0, i)).mkdirs();
                }
            }
        }

        if (localFile.isDirectory()) {
            localFile = new File(localFile, remoteFile);
        }

        long startTime = System.currentTimeMillis();
        long totalLength = le.getAttrs().getSize();

        SftpProgressMonitor monitor = null;
        boolean trackProgress = getVerbose() && totalLength > 102400;
        if (trackProgress) {
            monitor = getProgressMonitor();
        }
        try {
            log(""Receiving: "" + remoteFile + "" : "" + le.getAttrs().getSize());
            channel.get(remoteFile, localFile.getAbsolutePath(), monitor);
        } finally {
            long endTime = System.currentTimeMillis();
            logStats(startTime, endTime, (int) totalLength);
        }
    }
}
"
org.apache.tools.ant.TaskAdapter,6,3,0,7,28,9,2,6,6,0.85,261,0.25,0,0.880952381,0.375,1,1,41.83333333,4,1.3333,0,"

package org.apache.tools.ant;

import java.lang.reflect.Method;
import org.apache.tools.ant.dispatch.Dispatchable;
import org.apache.tools.ant.dispatch.DispatchUtils;


public class TaskAdapter extends Task implements TypeAdapter {

    
    private Object proxy;

    
    public static void checkTaskClass(final Class taskClass,
                                      final Project project) {
        if (!Dispatchable.class.isAssignableFrom(taskClass)) {
            
            
            try {
                final Method executeM = taskClass.getMethod(""execute"", (Class[]) null);
                
                
                
                
                if (!Void.TYPE.equals(executeM.getReturnType())) {
                    final String message = ""return type of execute() should be ""
                        + ""void but was \"""" + executeM.getReturnType() + ""\"" in ""
                        + taskClass;
                    project.log(message, Project.MSG_WARN);
                }
            } catch (NoSuchMethodException e) {
                final String message = ""No public execute() in "" + taskClass;
                project.log(message, Project.MSG_ERR);
                throw new BuildException(message);
            } catch (LinkageError e) {
                String message = ""Could not load "" + taskClass + "": "" + e;
                project.log(message, Project.MSG_ERR);
                throw new BuildException(message, e);
            }
        }
    }

    
    public void checkProxyClass(Class proxyClass) {
        checkTaskClass(proxyClass, getProject());
    }

    
    public void execute() throws BuildException {
        try {
            Method setLocationM = proxy.getClass().getMethod(
                ""setLocation"", new Class[] {Location.class});
            if (setLocationM != null) {
                setLocationM.invoke(proxy, new Object[] {getLocation()});
            }
        } catch (NoSuchMethodException e) {
            
            
        } catch (Exception ex) {
            log(""Error setting location in "" + proxy.getClass(),
                Project.MSG_ERR);
            throw new BuildException(ex);
        }

        try {
            Method setProjectM = proxy.getClass().getMethod(
                ""setProject"", new Class[] {Project.class});
            if (setProjectM != null) {
                setProjectM.invoke(proxy, new Object[] {getProject()});
            }
        } catch (NoSuchMethodException e) {
            
            
        } catch (Exception ex) {
            log(""Error setting project in "" + proxy.getClass(),
                Project.MSG_ERR);
            throw new BuildException(ex);
        }

        try {
            DispatchUtils.execute(proxy);
        } catch (BuildException be) {
            throw be;
        } catch (Exception ex) {
            log(""Error in "" + proxy.getClass(), Project.MSG_VERBOSE);
            throw new BuildException(ex);
        }
    }

    
    public void setProxy(Object o) {
        this.proxy = o;
    }

    
    public Object getProxy() {
        return proxy;
    }

}
"
org.apache.tools.ant.taskdefs.AntStructure,8,3,0,6,36,18,1,6,4,1.0,182,0.428571429,1,0.860465116,0.285714286,0,0,20.875,1,0.75,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.IntrospectionHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Reference;


public class AntStructure extends Task {

    private static final String LINE_SEP
        = System.getProperty(""line.separator"");

    private File output;
    private StructurePrinter printer = new DTDPrinter();

    
    public void setOutput(File output) {
        this.output = output;
    }

    
    public void add(StructurePrinter p) {
        printer = p;
    }

    
    public void execute() throws BuildException {

        if (output == null) {
            throw new BuildException(""output attribute is required"", getLocation());
        }

        PrintWriter out = null;
        try {
            try {
                out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(output), ""UTF8""));
            } catch (UnsupportedEncodingException ue) {
                
                out = new PrintWriter(new FileWriter(output));
            }

            printer.printHead(out, getProject(),
                              getProject().getTaskDefinitions(),
                              getProject().getDataTypeDefinitions());

            printer.printTargetDecl(out);

            Enumeration dataTypes = getProject().getDataTypeDefinitions().keys();
            while (dataTypes.hasMoreElements()) {
                String typeName = (String) dataTypes.nextElement();
                printer.printElementDecl(
                    out, getProject(), typeName,
                    (Class) getProject().getDataTypeDefinitions().get(typeName));
            }

            Enumeration tasks = getProject().getTaskDefinitions().keys();
            while (tasks.hasMoreElements()) {
                String tName = (String) tasks.nextElement();
                printer.printElementDecl(out, getProject(), tName,
                                         (Class) getProject().getTaskDefinitions().get(tName));
            }

            printer.printTail(out);

        } catch (IOException ioe) {
            throw new BuildException(""Error writing ""
                                     + output.getAbsolutePath(), ioe, getLocation());
        } finally {
            if (out != null) {
                out.close();
            }
        }
    }

    
    public static interface StructurePrinter {
        
        void printHead(PrintWriter out, Project p, Hashtable tasks,
                       Hashtable types);

        
        void printTargetDecl(PrintWriter out);

        
        void printElementDecl(PrintWriter out, Project p, String name,
                              Class element);

        
        void printTail(PrintWriter out);
    }

    private static class DTDPrinter implements StructurePrinter {

        private static final String BOOLEAN = ""%boolean;"";
        private static final String TASKS = ""%tasks;"";
        private static final String TYPES = ""%types;"";

        private Hashtable visited = new Hashtable();

        public void printTail(PrintWriter out) {
            visited.clear();
        }

        public void printHead(PrintWriter out, Project p, Hashtable tasks, Hashtable types) {
            printHead(out, tasks.keys(), types.keys());
        }


        
        private void printHead(PrintWriter out, Enumeration tasks,
                               Enumeration types) {
            out.println(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>"");
            out.println(""<!ENTITY % boolean \""(true|false|on|off|yes|no)\"">"");
            out.print(""<!ENTITY % tasks \"""");
            boolean first = true;
            while (tasks.hasMoreElements()) {
                String tName = (String) tasks.nextElement();
                if (!first) {
                    out.print("" | "");
                } else {
                    first = false;
                }
                out.print(tName);
            }
            out.println(""\"">"");
            out.print(""<!ENTITY % types \"""");
            first = true;
            while (types.hasMoreElements()) {
                String typeName = (String) types.nextElement();
                if (!first) {
                    out.print("" | "");
                } else {
                    first = false;
                }
                out.print(typeName);
            }
            out.println(""\"">"");

            out.println("""");

            out.print(""<!ELEMENT project (target | "");
            out.print(TASKS);
            out.print("" | "");
            out.print(TYPES);
            out.println("")*>"");
            out.println(""<!ATTLIST project"");
            out.println(""          name    CDATA #IMPLIED"");
            out.println(""          default CDATA #IMPLIED"");
            out.println(""          basedir CDATA #IMPLIED>"");
            out.println("""");
        }

        
        public void printTargetDecl(PrintWriter out) {
            out.print(""<!ELEMENT target ("");
            out.print(TASKS);
            out.print("" | "");
            out.print(TYPES);
            out.println("")*>"");
            out.println("""");

            out.println(""<!ATTLIST target"");
            out.println(""          id          ID    #IMPLIED"");
            out.println(""          name        CDATA #REQUIRED"");
            out.println(""          if          CDATA #IMPLIED"");
            out.println(""          unless      CDATA #IMPLIED"");
            out.println(""          depends     CDATA #IMPLIED"");
            out.println(""          description CDATA #IMPLIED>"");
            out.println("""");
        }

        
        public void printElementDecl(PrintWriter out, Project p,
                                     String name, Class element) {

            if (visited.containsKey(name)) {
                return;
            }
            visited.put(name, """");

            IntrospectionHelper ih = null;
            try {
                ih = IntrospectionHelper.getHelper(p, element);
            } catch (Throwable t) {
                
                return;
            }

            StringBuffer sb = new StringBuffer(""<!ELEMENT "");
            sb.append(name).append("" "");

            if (org.apache.tools.ant.types.Reference.class.equals(element)) {
                sb.append(""EMPTY>"").append(LINE_SEP);
                sb.append(""<!ATTLIST "").append(name);
                sb.append(LINE_SEP).append(""          id ID #IMPLIED"");
                sb.append(LINE_SEP).append(""          refid IDREF #IMPLIED"");
                sb.append("">"").append(LINE_SEP);
                out.println(sb);
                return;
            }

            Vector v = new Vector();
            if (ih.supportsCharacters()) {
                v.addElement(""#PCDATA"");
            }

            if (TaskContainer.class.isAssignableFrom(element)) {
                v.addElement(TASKS);
            }

            Enumeration e = ih.getNestedElements();
            while (e.hasMoreElements()) {
                v.addElement(e.nextElement());
            }

            if (v.isEmpty()) {
                sb.append(""EMPTY"");
            } else {
                sb.append(""("");
                final int count = v.size();
                for (int i = 0; i < count; i++) {
                    if (i != 0) {
                        sb.append("" | "");
                    }
                    sb.append(v.elementAt(i));
                }
                sb.append("")"");
                if (count > 1 || !v.elementAt(0).equals(""#PCDATA"")) {
                    sb.append(""*"");
                }
            }
            sb.append("">"");
            out.println(sb);

            sb = new StringBuffer(""<!ATTLIST "");
            sb.append(name);
            sb.append(LINE_SEP).append(""          id ID #IMPLIED"");

            e = ih.getAttributes();
            while (e.hasMoreElements()) {
                String attrName = (String) e.nextElement();
                if (""id"".equals(attrName)) {
                    continue;
                }

                sb.append(LINE_SEP).append(""          "")
                    .append(attrName).append("" "");
                Class type = ih.getAttributeType(attrName);
                if (type.equals(java.lang.Boolean.class)
                    || type.equals(java.lang.Boolean.TYPE)) {
                    sb.append(BOOLEAN).append("" "");
                } else if (Reference.class.isAssignableFrom(type)) {
                    sb.append(""IDREF "");
                } else if (EnumeratedAttribute.class.isAssignableFrom(type)) {
                    try {
                        EnumeratedAttribute ea =
                            (EnumeratedAttribute) type.newInstance();
                        String[] values = ea.getValues();
                        if (values == null
                            || values.length == 0
                            || !areNmtokens(values)) {
                            sb.append(""CDATA "");
                        } else {
                            sb.append(""("");
                            for (int i = 0; i < values.length; i++) {
                                if (i != 0) {
                                    sb.append("" | "");
                                }
                                sb.append(values[i]);
                            }
                            sb.append("") "");
                        }
                    } catch (InstantiationException ie) {
                        sb.append(""CDATA "");
                    } catch (IllegalAccessException ie) {
                        sb.append(""CDATA "");
                    }
                } else if (type.getSuperclass() != null
                           && type.getSuperclass().getName().equals(""java.lang.Enum"")) {
                    try {
                        Object[] values = (Object[]) type.getMethod(""values"", (Class[])  null)
                            .invoke(null, (Object[]) null);
                        if (values.length == 0) {
                            sb.append(""CDATA "");
                        } else {
                            sb.append('(');
                            for (int i = 0; i < values.length; i++) {
                                if (i != 0) {
                                    sb.append("" | "");
                                }
                                sb.append(type.getMethod(""name"", (Class[]) null)
                                          .invoke(values[i], (Object[]) null));
                            }
                            sb.append("") "");
                        }
                    } catch (Exception x) {
                        sb.append(""CDATA "");
                    }
                } else {
                    sb.append(""CDATA "");
                }
                sb.append(""#IMPLIED"");
            }
            sb.append("">"").append(LINE_SEP);
            out.println(sb);

            final int count = v.size();
            for (int i = 0; i < count; i++) {
                String nestedName = (String) v.elementAt(i);
                if (!""#PCDATA"".equals(nestedName)
                    && !TASKS.equals(nestedName)
                    && !TYPES.equals(nestedName)) {
                    printElementDecl(out, p, nestedName, ih.getElementType(nestedName));
                }
            }
        }

        
        public static final boolean isNmtoken(String s) {
            final int length = s.length();
            for (int i = 0; i < length; i++) {
                char c = s.charAt(i);
                
                if (!Character.isLetterOrDigit(c)
                    && c != '.' && c != '-' && c != '_' && c != ':') {
                    return false;
                }
            }
            return true;
        }

        
        public static final boolean areNmtokens(String[] s) {
            for (int i = 0; i < s.length; i++) {
                if (!isNmtoken(s[i])) {
                    return false;
                }
            }
            return true;
        }
    }

    
    protected boolean isNmtoken(String s) {
        return DTDPrinter.isNmtoken(s);
    }

    
    protected boolean areNmtokens(String[] s) {
        return DTDPrinter.areNmtokens(s);
    }
}
"
org.apache.tools.ant.taskdefs.cvslib.CVSEntry,9,1,0,4,19,14,3,1,9,0.65625,88,1.0,0,0.0,0.518518519,0,0,8.333333333,1,0.8889,0,"
package org.apache.tools.ant.taskdefs.cvslib;

import java.util.Date;
import java.util.Vector;


public class CVSEntry {
    private Date date;
    private String author;
    private final String comment;
    private final Vector files = new Vector();

    
    public CVSEntry(final Date date, final String author, final String comment) {
        this.date = date;
        this.author = author;
        this.comment = comment;
    }

    
    public void addFile(final String file, final String revision) {
        files.addElement(new RCSFile(file, revision));
    }

    
    public void addFile(final String file, final String revision, final String previousRevision) {
        files.addElement(new RCSFile(file, revision, previousRevision));
    }

    
    public Date getDate() {
        return date;
    }

    
    public void setAuthor(final String author) {
        this.author = author;
    }

    
    public String getAuthor() {
        return author;
    }

    
    public String getComment() {
        return comment;
    }

    
    public Vector getFiles() {
        return files;
    }

    
    public String toString() {
        return getAuthor() + ""\n"" + getDate() + ""\n"" + getFiles() + ""\n""
            + getComment();
    }
}
"
org.apache.tools.ant.NoBannerLogger,4,2,0,4,17,0,0,4,4,0.333333333,57,1.0,0,0.842105263,0.875,1,1,13.0,5,1.75,1,"

package org.apache.tools.ant;

import org.apache.tools.ant.util.StringUtils;


public class NoBannerLogger extends DefaultLogger {

    
    
    protected String targetName;
    

    
    public NoBannerLogger() {
    }

    
    public void targetStarted(BuildEvent event) {
        targetName = event.getTarget().getName();
    }

    
    public void targetFinished(BuildEvent event) {
        targetName = null;
    }

    
    public void messageLogged(BuildEvent event) {

        if (event.getPriority() > msgOutputLevel
            || null == event.getMessage()
            || """".equals(event.getMessage().trim())) {
                return;
        }

        if (null != targetName) {
            out.println(StringUtils.LINE_SEP + targetName + "":"");
            targetName = null;
        }

        super.messageLogged(event);
    }
}
"
org.apache.tools.ant.taskdefs.Antlib,7,3,0,10,46,9,1,9,4,0.733333333,212,0.6,0,0.860465116,0.285714286,1,1,28.57142857,4,2.0,1,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.helper.ProjectHelper2;
import org.apache.tools.ant.UnknownElement;



public class Antlib extends Task implements TaskContainer {
    
    
    

    
    public static final String TAG = ""antlib"";

    
    public static Antlib createAntlib(Project project, URL antlibUrl,
                                      String uri) {
        
        try {
            antlibUrl.openConnection().connect();
        } catch (IOException ex) {
            throw new BuildException(
                ""Unable to find "" + antlibUrl, ex);
        }
        ComponentHelper helper =
            ComponentHelper.getComponentHelper(project);
        helper.enterAntLib(uri);
        try {
            
            ProjectHelper2 parser = new ProjectHelper2();
            UnknownElement ue =
                parser.parseUnknownElement(project, antlibUrl);
            
            if (!(ue.getTag().equals(TAG))) {
                throw new BuildException(
                    ""Unexpected tag "" + ue.getTag() + "" expecting ""
                    + TAG, ue.getLocation());
            }
            Antlib antlib = new Antlib();
            antlib.setProject(project);
            antlib.setLocation(ue.getLocation());
            antlib.setTaskName(""antlib"");
            antlib.init();
            ue.configure(antlib);
            return antlib;
        } finally {
            helper.exitAntLib();
        }
    }


    
    
    
    private ClassLoader classLoader;
    private String      uri = """";
    private List  tasks = new ArrayList();

    
    protected void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    
    protected void  setURI(String uri) {
        this.uri = uri;
    }

    private ClassLoader getClassLoader() {
        if (classLoader == null) {
            classLoader = Antlib.class.getClassLoader();
        }
        return classLoader;
    }

    
    public void addTask(Task nestedTask) {
        tasks.add(nestedTask);
    }

    
    public void execute() {
        for (Iterator i = tasks.iterator(); i.hasNext();) {
            UnknownElement ue = (UnknownElement) i.next();
            setLocation(ue.getLocation());
            ue.maybeConfigure();
            Object configuredObject = ue.getRealThing();
            if (configuredObject == null) {
                continue;
            }
            if (!(configuredObject instanceof AntlibDefinition)) {
                throw new BuildException(
                    ""Invalid task in antlib "" + ue.getTag()
                    + "" "" + configuredObject.getClass() + "" does not ""
                    + ""extend org.apache.tools.ant.taskdefs.AntlibDefinition"");
            }
            AntlibDefinition def = (AntlibDefinition) configuredObject;
            def.setURI(uri);
            def.setAntlibClassLoader(getClassLoader());
            def.init();
            def.execute();
        }
    }

}
"
org.apache.tools.ant.types.resources.selectors.InstanceOf,9,1,0,7,21,16,0,7,9,0.85,123,1.0,1,0.0,0.311111111,0,0,12.11111111,7,1.6667,0,"

package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.AntTypeDefinition;
import org.apache.tools.ant.types.Resource;


public class InstanceOf implements ResourceSelector {
    private static final String ONE_ONLY = ""Exactly one of class|type must be set."";

    private Project project;
    private Class clazz;
    private String type;
    private String uri;

    
    public void setProject(Project p) {
        project = p;
    }

    
    public void setClass(Class c) {
        if (clazz != null) {
            throw new BuildException(""The class attribute has already been set."");
        }
        clazz = c;
    }

    
    public void setType(String s) {
        type = s;
    }

    
    public void setURI(String u) {
        uri = u;
    }

    
    public Class getCheckClass() {
        return clazz;
    }

    
    public String getType() {
        return type;
    }

    
    public String getURI() {
        return uri;
    }

    
    public boolean isSelected(Resource r) {
        if ((clazz == null) == (type == null)) {
            throw new BuildException(ONE_ONLY);
        }
        Class c = clazz;
        if (type != null) {
            if (project == null) {
                throw new BuildException(
                    ""No project set for InstanceOf ResourceSelector; ""
                    + ""the type attribute is invalid."");
            }
            AntTypeDefinition d = ComponentHelper.getComponentHelper(
                project).getDefinition(ProjectHelper.genComponentName(uri, type));
            if (d == null) {
                throw new BuildException(""type "" + type + "" not found."");
            }
            try {
                c = d.innerGetTypeClass();
            } catch (ClassNotFoundException e) {
                throw new BuildException(e);
            }
        }
        return c.isAssignableFrom(r.getClass());
    }

}
"
org.apache.tools.ant.taskdefs.optional.jsp.WLJspc,9,4,0,9,61,14,0,9,7,0.770833333,586,1.0,1,0.906976744,0.333333333,4,4,63.44444444,8,2.1111,0,"
package org.apache.tools.ant.taskdefs.optional.jsp;


import java.io.File;
import java.util.Date;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types.Path;



public class WLJspc extends MatchingTask {
    
    
    

    
    private File destinationDirectory;

    
    private File sourceDirectory;

    
    private String destinationPackage;

    
    private Path compileClasspath;

    

    private String pathToPackage = """";
    private Vector filesToDo = new Vector();

    
    public void execute() throws BuildException {
        if (!destinationDirectory.isDirectory()) {
            throw new BuildException(""destination directory ""
                + destinationDirectory.getPath() + "" is not valid"");
        }

        if (!sourceDirectory.isDirectory()) {
            throw new BuildException(""src directory ""
                + sourceDirectory.getPath() + "" is not valid"");
        }

        if (destinationPackage == null) {
            throw new BuildException(""package attribute must be present."",
                                     getLocation());
        }


        pathToPackage
            = this.destinationPackage.replace('.', File.separatorChar);
        
        DirectoryScanner ds = super.getDirectoryScanner(sourceDirectory);

        
        if (compileClasspath == null) {
            compileClasspath = new Path(getProject());
        }

        compileClasspath = compileClasspath.concatSystemClasspath();
        String[] files = ds.getIncludedFiles();

        
        
        
        
        Java helperTask = new Java(this);
        helperTask.setFork(true);
        helperTask.setClassname(""weblogic.jspc"");
        helperTask.setTaskName(getTaskName());
        String[] args = new String[12];

        File jspFile = null;
        String parents = """";
        int j = 0;
        
        args[j++] = ""-d"";
        args[j++] = destinationDirectory.getAbsolutePath().trim();
        args[j++] = ""-docroot"";
        args[j++] = sourceDirectory.getAbsolutePath().trim();
        args[j++] = ""-keepgenerated"";  
        
        
        args[j++] =  ""-compilerclass"";
        args[j++] = ""sun.tools.javac.Main"";
        
        
        
        args[j++] = ""-classpath"";
        args[j++] = compileClasspath.toString();

        this.scanDir(files);
        log(""Compiling "" + filesToDo.size() + "" JSP files"");

        for (int i = 0; i < filesToDo.size(); i++) {
            
            
            
            
            String filename = (String) filesToDo.elementAt(i);
            jspFile = new File(filename);
            args[j] = ""-package"";
            parents = jspFile.getParent();
            if ((parents != null)  && (!("""").equals(parents))) {
                parents =  this.replaceString(parents, File.separator, ""_."");
                args[j + 1] = destinationPackage + ""."" + ""_"" + parents;
            } else {
                args[j + 1] = destinationPackage;
            }


            args[j + 2] =  sourceDirectory + File.separator + filename;
            helperTask.clearArgs();

            for (int x = 0; x < j + 3; x++) {
                helperTask.createArg().setValue(args[x]);
            }

            helperTask.setClasspath(compileClasspath);
            if (helperTask.executeJava() != 0) {
                log(filename + "" failed to compile"", Project.MSG_WARN);
            }
        }
    }



    
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(getProject());
        }
        return compileClasspath;
    }

    
    public void setSrc(File dirName) {

        sourceDirectory = dirName;
    }

     
    public void setDest(File dirName) {

        destinationDirectory = dirName;
    }

    
    public void setPackage(String packageName) {

        destinationPackage = packageName;
    }

    
    protected void scanDir(String[] files) {

        long now = (new Date()).getTime();
        File jspFile = null;
        String parents = null;
        String pack = """";
        for (int i = 0; i < files.length; i++) {
            File srcFile = new File(this.sourceDirectory, files[i]);
            
            
            
            jspFile = new File(files[i]);
            parents = jspFile.getParent();

            if ((parents != null)  && (!("""").equals(parents))) {
                parents =  this.replaceString(parents, File.separator, ""_/"");
                pack = pathToPackage + File.separator + ""_"" + parents;
            } else {
                pack = pathToPackage;
            }

            String filePath = pack + File.separator + ""_"";
            int startingIndex = files[i].lastIndexOf(File.separator) != -1
                    ? files[i].lastIndexOf(File.separator) + 1 : 0;
            int endingIndex = files[i].indexOf("".jsp"");
            if (endingIndex == -1) {
                log(""Skipping "" + files[i] + "". Not a JSP"",
                    Project.MSG_VERBOSE);
                continue;
            }

            filePath += files[i].substring(startingIndex, endingIndex);
            filePath += "".class"";
            File classFile = new File(this.destinationDirectory, filePath);

            if (srcFile.lastModified() > now) {
                log(""Warning: file modified in the future: ""
                    + files[i], Project.MSG_WARN);
            }
            if (srcFile.lastModified() > classFile.lastModified()) {
                filesToDo.addElement(files[i]);
                log(""Recompiling File "" + files[i], Project.MSG_VERBOSE);
            }
        }
    }


    
    protected String replaceString(String inpString, String escapeChars,
                                   String replaceChars) {
        String localString = """";
        int numTokens = 0;
        StringTokenizer st = new StringTokenizer(inpString, escapeChars, true);
        numTokens = st.countTokens();
        for (int i = 0; i < numTokens; i++) {
            String test = st.nextToken();
            test = (test.equals(escapeChars) ? replaceChars : test);
            localString += test;
        }
        return localString;
    }
}
"
org.apache.tools.ant.MagicNames,1,1,0,0,2,0,0,0,0,2.0,26,0.0,0,0.0,1.0,0,0,3.0,0,0.0,2,"
package org.apache.tools.ant;
import org.apache.tools.ant.launch.Launcher;


public final class MagicNames {

    private MagicNames() {
    }

    
    public static final String ANTLIB_PREFIX = ""antlib:"";

    
    public static final String ANT_VERSION = ""ant.version"";

    
    public static final String BUILD_SYSCLASSPATH = ""build.sysclasspath"";

    
    public static final String SCRIPT_REPOSITORY = ""org.apache.ant.scriptrepo"";

    
    public static final String SYSTEM_LOADER_REF = ""ant.coreLoader"";

    
    public static final String REPOSITORY_DIR_PROPERTY = ""ant.maven.repository.dir"";
    
    public static final String REPOSITORY_URL_PROPERTY = ""ant.maven.repository.url"";

    
    public static final String TASKDEF_PROPERTIES_RESOURCE =
            ""/org/apache/tools/ant/taskdefs/defaults.properties"";
    
    public static final String TYPEDEFS_PROPERTIES_RESOURCE =
            ""/org/apache/tools/ant/types/defaults.properties"";

    
    public static final String ANT_EXECUTOR_REFERENCE = ""ant.executor"";

    
    public static final String ANT_EXECUTOR_CLASSNAME = ""ant.executor.class"";
    
    public static final String PROJECT_BASEDIR = ""basedir"";
    
    public static final String ANT_FILE = ""ant.file"";

    
    public static final String ANT_JAVA_VERSION = ""ant.java.version"";

    
    public static final String ANT_HOME = Launcher.ANTHOME_PROPERTY;

    
    public static final String ANT_LIB = ""ant.core.lib"";

    
    public static final String REGEXP_IMPL = ""ant.regexp.regexpimpl"";

    
    public static final String BUILD_JAVAC_SOURCE = ""ant.build.javac.source"";

    
    public static final String BUILD_JAVAC_TARGET = ""ant.build.javac.target"";

    
    public static final String REFID_CLASSPATH_REUSE_LOADER = ""ant.reuse.loader"";

    
    public static final String REFID_CLASSPATH_LOADER_PREFIX = ""ant.loader."";

    
    public static final String REFID_PROPERTY_HELPER = ""ant.PropertyHelper"";

}

"
org.apache.tools.ant.types.RedirectorElement,28,3,0,13,85,248,5,8,24,0.87654321,860,0.952380952,3,0.526315789,0.189285714,1,4,28.96428571,28,3.3214,0,"
package org.apache.tools.ant.types;

import java.io.File;
import java.util.Stack;
import java.util.Vector;
import java.util.Iterator;
import java.util.ArrayList;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Redirector;


public class RedirectorElement extends DataType {

    
    private boolean usingInput = false;

    
    private boolean usingOutput = false;

    
    private boolean usingError = false;

    
    private Boolean logError;

    
    private String outputProperty;

    
    private String errorProperty;

    
    private String inputString;

    
    private Boolean append;

    
    private Boolean alwaysLog;

    
    private Boolean createEmptyFiles;

    
    private Mapper inputMapper;

    
    private Mapper outputMapper;

    
    private Mapper errorMapper;

    
    private Vector inputFilterChains = new Vector();

    
    private Vector outputFilterChains = new Vector();

    
    private Vector errorFilterChains = new Vector();

    
    private String outputEncoding;

    
    private String errorEncoding;

    
    private String inputEncoding;

    
    private Boolean logInputString;

    
    public void addConfiguredInputMapper(Mapper inputMapper) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.inputMapper != null) {
            if (usingInput) {
                throw new BuildException(""attribute \""input\""""
                    + "" cannot coexist with a nested <inputmapper>"");
            } else {
                throw new BuildException(""Cannot have > 1 <inputmapper>"");
            }
        }
        this.inputMapper = inputMapper;
    }

    
    public void addConfiguredOutputMapper(Mapper outputMapper) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.outputMapper != null) {
            if (usingOutput) {
                throw new BuildException(""attribute \""output\""""
                    + "" cannot coexist with a nested <outputmapper>"");
            } else {
                throw new BuildException(""Cannot have > 1 <outputmapper>"");
            }
        }
        this.outputMapper = outputMapper;
    }

    
    public void addConfiguredErrorMapper(Mapper errorMapper) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.errorMapper != null) {
            if (usingError) {
                throw new BuildException(""attribute \""error\""""
                    + "" cannot coexist with a nested <errormapper>"");
            } else {
                throw new BuildException(""Cannot have > 1 <errormapper>"");
            }
        }
        this.errorMapper = errorMapper;
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (usingInput
            || usingOutput
            || usingError
            || inputString != null
            || logError != null
            || append != null
            || createEmptyFiles != null
            || inputEncoding != null
            || outputEncoding != null
            || errorEncoding != null
            || outputProperty != null
            || errorProperty != null
            || logInputString != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public void setInput(File input) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (inputString != null) {
            throw new BuildException(""The \""input\"" and \""inputstring\"" ""
                + ""attributes cannot both be specified"");
        }
        usingInput = true;
        inputMapper = createMergeMapper(input);
    }

    
    public void setInputString(String inputString) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (usingInput) {
            throw new BuildException(""The \""input\"" and \""inputstring\"" ""
                + ""attributes cannot both be specified"");
        }
        this.inputString = inputString;
    }

    
    public void setLogInputString(boolean logInputString) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.logInputString = logInputString ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public void setOutput(File out) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (out == null) {
            throw new IllegalArgumentException(""output file specified as null"");
        }
        usingOutput = true;
        outputMapper = createMergeMapper(out);
    }

    
    public void setOutputEncoding(String outputEncoding) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.outputEncoding = outputEncoding;
    }

    
    public void setErrorEncoding(String errorEncoding) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.errorEncoding = errorEncoding;
    }

    
    public void setInputEncoding(String inputEncoding) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.inputEncoding = inputEncoding;
    }

    
    public void setLogError(boolean logError) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.logError = ((logError) ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setError(File error) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (error == null) {
            throw new IllegalArgumentException(""error file specified as null"");
        }
        usingError = true;
        errorMapper = createMergeMapper(error);
    }

    
    public void setOutputProperty(String outputProperty) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.outputProperty = outputProperty;
    }

    
    public void setAppend(boolean append) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.append = ((append) ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setAlwaysLog(boolean alwaysLog) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.alwaysLog = ((alwaysLog) ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setCreateEmptyFiles(boolean createEmptyFiles) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.createEmptyFiles = ((createEmptyFiles)
            ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setErrorProperty(String errorProperty) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.errorProperty = errorProperty;
    }

    
    public FilterChain createInputFilterChain() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        FilterChain result = new FilterChain();
        result.setProject(getProject());
        inputFilterChains.add(result);
        return result;
    }

    
    public FilterChain createOutputFilterChain() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        FilterChain result = new FilterChain();
        result.setProject(getProject());
        outputFilterChains.add(result);
        return result;
    }

    
    public FilterChain createErrorFilterChain() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        FilterChain result = new FilterChain();
        result.setProject(getProject());
        errorFilterChains.add(result);
        return result;
    }

    
    public void configure(Redirector redirector) {
        configure(redirector, null);
    }

    
    public void configure(Redirector redirector, String sourcefile) {
        if (isReference()) {
            getRef().configure(redirector, sourcefile);
            return;
        }
        if (alwaysLog != null) {
            redirector.setAlwaysLog(alwaysLog.booleanValue());
        }
        if (logError != null) {
            redirector.setLogError(logError.booleanValue());
        }
        if (append != null) {
            redirector.setAppend(append.booleanValue());
        }
        if (createEmptyFiles != null) {
            redirector.setCreateEmptyFiles(createEmptyFiles.booleanValue());
        }
        if (outputProperty != null) {
            redirector.setOutputProperty(outputProperty);
        }
        if (errorProperty != null) {
            redirector.setErrorProperty(errorProperty);
        }
        if (inputString != null) {
            redirector.setInputString(inputString);
        }
        if (logInputString != null) {
            redirector.setLogInputString(logInputString.booleanValue());
        }
        if (inputMapper != null) {
            String[] inputTargets = null;
            try {
                inputTargets =
                    inputMapper.getImplementation().mapFileName(sourcefile);
            } catch (NullPointerException enPeaEx) {
                if (sourcefile != null) {
                    throw enPeaEx;
                }
            }
            if (inputTargets != null && inputTargets.length > 0) {
                redirector.setInput(toFileArray(inputTargets));
            }
        }
        if (outputMapper != null) {
            String[] outputTargets = null;
            try {
                outputTargets =
                    outputMapper.getImplementation().mapFileName(sourcefile);
            } catch (NullPointerException enPeaEx) {
                if (sourcefile != null) {
                    throw enPeaEx;
                }
            }
            if (outputTargets != null && outputTargets.length > 0) {
                redirector.setOutput(toFileArray(outputTargets));
            }
        }
        if (errorMapper != null) {
            String[] errorTargets = null;
            try {
                errorTargets =
                    errorMapper.getImplementation().mapFileName(sourcefile);
            } catch (NullPointerException enPeaEx) {
                if (sourcefile != null) {
                    throw enPeaEx;
                }
            }
            if (errorTargets != null && errorTargets.length > 0) {
                redirector.setError(toFileArray(errorTargets));
            }
        }
        if (inputFilterChains.size() > 0) {
            redirector.setInputFilterChains(inputFilterChains);
        }
        if (outputFilterChains.size() > 0) {
            redirector.setOutputFilterChains(outputFilterChains);
        }
        if (errorFilterChains.size() > 0) {
            redirector.setErrorFilterChains(errorFilterChains);
        }
        if (inputEncoding != null) {
            redirector.setInputEncoding(inputEncoding);
        }
        if (outputEncoding != null) {
            redirector.setOutputEncoding(outputEncoding);
        }
        if (errorEncoding != null) {
            redirector.setErrorEncoding(errorEncoding);
        }
    }

    
    protected Mapper createMergeMapper(File destfile) {
        Mapper result = new Mapper(getProject());
        result.setClassname(
            org.apache.tools.ant.util.MergingMapper.class.getName());
        result.setTo(destfile.getAbsolutePath());
        return result;
    }

    
    protected File[] toFileArray(String[] name) {
        if (name == null) {
            return null;
        }
        
        ArrayList list = new ArrayList(name.length);
        for (int i = 0; i < name.length; i++) {
            if (name[i] != null) {
                list.add(getProject().resolveFile(name[i]));
            }
        }
        return (File[]) (list.toArray(new File[list.size()]));
    }

    
    protected void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            Mapper[] m = new Mapper[] {inputMapper, outputMapper, errorMapper};
            for (int i = 0; i < m.length; i++) {
                if (m[i] != null) {
                    stk.push(m[i]);
                    m[i].dieOnCircularReference(stk, p);
                    stk.pop();
                }
            }
            Vector[] v = new Vector[]
                {inputFilterChains, outputFilterChains, errorFilterChains};
            for (int i = 0; i < v.length; i++) {
                if (v[i] != null) {
                    for (Iterator fci = v[i].iterator(); fci.hasNext();) {
                        FilterChain fc = (FilterChain) fci.next();
                        stk.push(fc);
                        fc.dieOnCircularReference(stk, p);
                        stk.pop();
                    }
                }
            }
            setChecked(true);
        }
    }

    
    private RedirectorElement getRef() {
        return (RedirectorElement) getCheckedRef();
    }

}
"
org.apache.tools.ant.taskdefs.compilers.Kjc,3,2,0,10,23,3,1,9,2,2.0,145,0.0,0,0.92,1.0,0,0,47.33333333,10,3.6667,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecuteJava;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class Kjc extends DefaultCompilerAdapter {

    
    public boolean execute() throws BuildException {
        attributes.log(""Using kjc compiler"", Project.MSG_VERBOSE);
        Commandline cmd = setupKjcCommand();
        cmd.setExecutable(""at.dms.kjc.Main"");
        ExecuteJava ej = new ExecuteJava();
        ej.setJavaCommand(cmd);
        return ej.fork(getJavac()) == 0;
    }

    
    protected Commandline setupKjcCommand() {
        Commandline cmd = new Commandline();

        
        Path classpath = getCompileClasspath();

        if (deprecation) {
            cmd.createArgument().setValue(""-deprecation"");
        }

        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);
        }

        
        cmd.createArgument().setValue(""-classpath"");

        Path cp = new Path(project);

        
        Path p = getBootClassPath();
        if (p.size() > 0) {
            cp.append(p);
        }

        if (extdirs != null) {
            cp.addExtdirs(extdirs);
        }

        cp.append(classpath);
        if (compileSourcepath != null) {
            cp.append(compileSourcepath);
        } else {
            cp.append(src);
        }

        cmd.createArgument().setPath(cp);

        
        
        if (encoding != null) {
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(encoding);
        }

        if (debug) {
            cmd.createArgument().setValue(""-g"");
        }

        if (optimize) {
            cmd.createArgument().setValue(""-O2"");
        }

        if (verbose) {
            cmd.createArgument().setValue(""-verbose"");
        }

        addCurrentCompilerArgs(cmd);

        logAndAddFilesToCompile(cmd);
        return cmd;
    }
}


"
org.apache.tools.ant.types.resources.selectors.None,3,4,0,3,9,3,0,3,3,2.0,33,0.0,0,0.972222222,0.555555556,0,0,10.0,4,1.3333,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.util.Iterator;

import org.apache.tools.ant.types.Resource;


public class None
    extends ResourceSelectorContainer implements ResourceSelector {

    
    public None() {
    }

    
    public None(ResourceSelector[] r) {
        super(r);
    }

    
    public boolean isSelected(Resource r) {
        boolean none = true;
        for (Iterator i = getSelectors(); none && i.hasNext();) {
            none = !((ResourceSelector) i.next()).isSelected(r);
        }
        return none;
    }

}
"
org.apache.tools.ant.taskdefs.Classloader,10,3,0,6,38,9,0,6,10,0.796296296,260,0.833333333,1,0.804347826,0.34,3,3,24.4,16,2.7,3,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.Path;

import java.io.File;


public class Classloader extends Task {
    
    public static final String SYSTEM_LOADER_REF = MagicNames.SYSTEM_LOADER_REF;

    private String name = null;
    private Path classpath;
    private boolean reset = false;
    private boolean parentFirst = true;
    private String parentName = null;

    
    public Classloader() {
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public void setReset(boolean b) {
        this.reset = b;
    }

    
    public void setReverse(boolean b) {
        this.parentFirst = !b;
    }

    
    public void setParentFirst(boolean b) {
        this.parentFirst = b;
    }

    
    public void setParentName(String name) {
        this.parentName = name;
    }


    
    public void setClasspathRef(Reference pathRef) throws BuildException {
        classpath = (Path) pathRef.getReferencedObject(getProject());
    }

    
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(null);
        }
        return this.classpath.createPath();
    }


    
    public void execute() {
        try {
            
            if (""only"".equals(getProject().getProperty(""build.sysclasspath""))
                && (name == null || SYSTEM_LOADER_REF.equals(name))) {
                log(""Changing the system loader is disabled ""
                    + ""by build.sysclasspath=only"", Project.MSG_WARN);
                return;
            }

            String loaderName = (name == null) ? SYSTEM_LOADER_REF : name;

            Object obj = getProject().getReference(loaderName);
            if (reset) {
                
                
                obj = null; 
            }

            
            if (obj != null && !(obj instanceof AntClassLoader)) {
                log(""Referenced object is not an AntClassLoader"",
                        Project.MSG_ERR);
                return;
            }

            AntClassLoader acl = (AntClassLoader) obj;

            if (acl == null) {
                
                Object parent = null;
                if (parentName != null) {
                    parent = getProject().getReference(parentName);
                    if (!(parent instanceof ClassLoader)) {
                        parent = null;
                    }
                }
                
                if (parent == null) {
                    parent = this.getClass().getClassLoader();
                }

                if (name == null) {
                    
                    
                }
                getProject().log(""Setting parent loader "" + name + "" ""
                    + parent + "" "" + parentFirst, Project.MSG_DEBUG);

                
                acl = new AntClassLoader((ClassLoader) parent,
                         getProject(), classpath, parentFirst);

                getProject().addReference(loaderName, acl);

                if (name == null) {
                    
                    
                    acl.addLoaderPackageRoot(""org.apache.tools.ant.taskdefs.optional"");
                    getProject().setCoreLoader(acl);
                }
            }
            if (classpath != null) {
                String[] list = classpath.list();
                for (int i = 0; i < list.length; i++) {
                    File f = new File(list[i]);
                    if (f.exists()) {
                        acl.addPathElement(f.getAbsolutePath());
                        log(""Adding to class loader "" +  acl + "" "" + f.getAbsolutePath(),
                                Project.MSG_DEBUG);
                    }
                }
            }

            

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WeblogicTOPLinkDeploymentTool,6,3,0,5,22,7,1,4,4,0.866666667,98,1.0,0,0.925373134,0.458333333,2,4,14.83333333,2,1.1667,0,"

package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.util.Hashtable;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class WeblogicTOPLinkDeploymentTool extends WeblogicDeploymentTool {

    private static final String TL_DTD_LOC
        = ""http:

    private String toplinkDescriptor;
    private String toplinkDTD;

    
    public void setToplinkdescriptor(String inString) {
        this.toplinkDescriptor = inString;
    }

    
    public void setToplinkdtd(String inString) {
        this.toplinkDTD = inString;
    }

    
    protected DescriptorHandler getDescriptorHandler(File srcDir) {
        DescriptorHandler handler = super.getDescriptorHandler(srcDir);
        if (toplinkDTD != null) {
            handler.registerDTD(""-
                + ""DTD TOPLink for WebLogic CMP 2.5.1
        } else {
            handler.registerDTD(""-
                + ""DTD TOPLink for WebLogic CMP 2.5.1
        }
        return handler;
    }

    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
        super.addVendorFiles(ejbFiles, ddPrefix);
        

        


        File toplinkDD = new File(getConfig().descriptorDir, ddPrefix + toplinkDescriptor);

        if (toplinkDD.exists()) {
            ejbFiles.put(META_DIR + toplinkDescriptor,
                         toplinkDD);
        } else {
            log(""Unable to locate toplink deployment descriptor. ""
                + ""It was expected to be in ""
                + toplinkDD.getPath(), Project.MSG_WARN);
        }
    }

    
    public void validateConfigured() throws BuildException {
        super.validateConfigured();
        if (toplinkDescriptor == null) {
            throw new BuildException(""The toplinkdescriptor attribute must ""
                + ""be specified"");
        }
    }
}
"
org.apache.tools.ant.DynamicConfigurator,0,1,0,4,0,0,2,2,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.tools.ant;


public interface DynamicConfigurator
    extends DynamicAttribute, DynamicElement {
}

"
org.apache.tools.ant.taskdefs.optional.j2ee.JonasHotDeploymentTool,9,3,0,8,38,14,1,8,7,0.875,345,1.0,0,0.766666667,0.375,3,5,36.55555556,3,1.2222,0,"
package org.apache.tools.ant.taskdefs.optional.j2ee;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Path;


public class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool {

    
    protected static final String DEFAULT_ORB = ""RMI"";

    
    private static final String JONAS_DEPLOY_CLASS_NAME = ""org.objectweb.jonas.adm.JonasAdmin"";

    
    private static final String[] VALID_ACTIONS
        = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};

    
    private File jonasroot;

    
    private String orb = null;

    
    private String davidHost;

    
    private int davidPort;


    
    public void setDavidhost(final String inValue) {
        davidHost = inValue;
    }


    
    public void setDavidport(final int inValue) {
        davidPort = inValue;
    }


    
    public void setJonasroot(final File inValue) {
        jonasroot = inValue;
    }


    
    public void setOrb(final String inValue) {
        orb = inValue;
    }


    
    public Path getClasspath() {

        Path aClassPath = super.getClasspath();

        if (aClassPath == null) {
            aClassPath = new Path(getTask().getProject());
        }
        if (orb != null) {
            String aOrbJar = new File(jonasroot, ""lib/"" + orb + ""_jonas.jar"").toString();
            String aConfigDir = new File(jonasroot, ""config/"").toString();
            Path aJOnASOrbPath = new Path(aClassPath.getProject(),
                    aOrbJar + File.pathSeparator + aConfigDir);
            aClassPath.append(aJOnASOrbPath);
        }
        return aClassPath;
    }


    
    public void validateAttributes() throws BuildException {
        

        Java java = getJava();

        String action = getTask().getAction();
        if (action == null) {
            throw new BuildException(""The \""action\"" attribute must be set"");
        }

        if (!isActionValid()) {
            throw new BuildException(""Invalid action \"""" + action + ""\"" passed"");
        }

        if (getClassName() == null) {
            setClassName(JONAS_DEPLOY_CLASS_NAME);
        }

        if (jonasroot == null || jonasroot.isDirectory()) {
            java.createJvmarg().setValue(""-Dinstall.root="" + jonasroot);
            java.createJvmarg().setValue(""-Djava.security.policy="" + jonasroot
                + ""/config/java.policy"");

            if (""DAVID"".equals(orb)) {
                java.createJvmarg().setValue(""-Dorg.omg.CORBA.ORBClass""
                    + ""=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB"");
                java.createJvmarg().setValue(""-Dorg.omg.CORBA.ORBSingletonClass=""
                    + ""org.objectweb.david.libs.binding.orbs.ORBSingletonClass"");
                java.createJvmarg().setValue(""-Djavax.rmi.CORBA.StubClass=""
                    + ""org.objectweb.david.libs.stub_factories.rmi.StubDelegate"");
                java.createJvmarg().setValue(""-Djavax.rmi.CORBA.PortableRemoteObjectClass=""
                    + ""org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate"");
                java.createJvmarg().setValue(""-Djavax.rmi.CORBA.UtilClass=""
                    + ""org.objectweb.david.libs.helpers.RMIUtilDelegate"");
                java.createJvmarg().setValue(""-Ddavid.CosNaming.default_method=0"");
                java.createJvmarg().setValue(""-Ddavid.rmi.ValueHandlerClass=""
                    + ""com.sun.corba.se.internal.io.ValueHandlerImpl"");
                if (davidHost != null) {
                    java.createJvmarg().setValue(""-Ddavid.CosNaming.default_host=""
                        + davidHost);
                }
                if (davidPort != 0) {
                    java.createJvmarg().setValue(""-Ddavid.CosNaming.default_port=""
                        + davidPort);
                }
            }
        }

        if (getServer() != null) {
            java.createArg().setLine(""-n "" + getServer());
        }

        if (action.equals(ACTION_DEPLOY)
            || action.equals(ACTION_UPDATE)
            || action.equals(""redeploy"")) {
            java.createArg().setLine(""-a "" + getTask().getSource());
        } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {
            java.createArg().setLine(""-r "" + getTask().getSource());
        } else if (action.equals(ACTION_LIST)) {
            java.createArg().setValue(""-l"");
        }
    }


    
    protected boolean isActionValid() {
        boolean valid = false;

        String action = getTask().getAction();

        for (int i = 0; i < VALID_ACTIONS.length; i++) {
            if (action.equals(VALID_ACTIONS[i])) {
                valid = true;
                break;
            }
        }

        return valid;
    }
}

"
org.apache.tools.ant.taskdefs.optional.clearcase.CCUnCheckout,5,4,0,7,27,4,0,7,4,0.916666667,109,0.333333333,0,0.923076923,0.466666667,2,3,20.2,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCUnCheckout extends ClearCase {
    private boolean mKeep = false;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_UNCHECKOUT);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        
        if (getKeepCopy()) {
            
            cmd.createArgument().setValue(FLAG_KEEPCOPY);
        } else {
            
            cmd.createArgument().setValue(FLAG_RM);
        }

        
        cmd.createArgument().setValue(getViewPath());
    }

    
    public void setKeepCopy(boolean keep) {
        mKeep = keep;
    }

    
    public boolean getKeepCopy() {
        return mKeep;
    }


    
    public static final String FLAG_KEEPCOPY = ""-keep"";
    
    public static final String FLAG_RM = ""-rm"";

}

"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSHISTORY,12,4,0,6,45,66,0,6,11,2.0,173,0.0,0,0.892156863,0.305555556,1,1,13.41666667,5,1.4167,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import java.io.File;
import java.text.SimpleDateFormat;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class MSVSSHISTORY extends MSVSS {

    
    Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        if (getVsspath() == null) {
            String msg = ""vsspath attribute must be set!"";
            throw new BuildException(msg, getLocation());
        }

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_HISTORY);

        
        commandLine.createArgument().setValue(getVsspath());
        
        commandLine.createArgument().setValue(FLAG_AUTORESPONSE_DEF);  
        
        commandLine.createArgument().setValue(getVersionDate());
        
        commandLine.createArgument().setValue(getVersionLabel());
        
        commandLine.createArgument().setValue(getRecursive());
        
        commandLine.createArgument().setValue(getStyle());
        
        commandLine.createArgument().setValue(getLogin());
        
        commandLine.createArgument().setValue(getOutput());

        return commandLine;
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public void setUser(String user) {
        super.setInternalUser(user);
    }

    
    public void setFromDate(String fromDate) {
        super.setInternalFromDate(fromDate);
    }

    
    public void setToDate(String toDate) {
        super.setInternalToDate(toDate);
    }

    
    public void setFromLabel(String fromLabel) {
        super.setInternalFromLabel(fromLabel);
    }

    
    public void setToLabel(String toLabel) {
        super.setInternalToLabel(toLabel);
    }

    
    public void setNumdays(int numd) {
        super.setInternalNumDays(numd);
    }

    
    public void setOutput(File outfile) {
        if (outfile != null) {
            super.setInternalOutputFilename(outfile.getAbsolutePath());
        }
    }

    
    public void setDateFormat(String dateFormat) {
        super.setInternalDateFormat(new SimpleDateFormat(dateFormat));
    }

   
    public void setStyle(BriefCodediffNofile attr) {
        String option = attr.getValue();
        if (option.equals(STYLE_BRIEF)) {
            super.setInternalStyle(FLAG_BRIEF);
        } else if (option.equals(STYLE_CODEDIFF)) {
            super.setInternalStyle(FLAG_CODEDIFF);
        } else if (option.equals(STYLE_DEFAULT)) {
            super.setInternalStyle("""");
        } else if (option.equals(STYLE_NOFILE)) {
            super.setInternalStyle(FLAG_NO_FILE);
        } else {
            throw new BuildException(""Style "" + attr + "" unknown."", getLocation());
        }
    }

    
    public static class BriefCodediffNofile extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {STYLE_BRIEF, STYLE_CODEDIFF, STYLE_NOFILE, STYLE_DEFAULT};
        }
    }
}
"
org.apache.tools.ant.DynamicAttributeNS,1,1,0,3,1,0,2,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant;


public interface DynamicAttributeNS {

    
    void setDynamicAttribute(
        String uri, String localName, String qName, String value)
            throws BuildException;

}
"
org.apache.tools.ant.taskdefs.Tar,22,4,0,25,172,151,1,25,10,0.921768707,1224,0.285714286,2,0.787878788,0.178030303,1,1,54.0,12,2.2273,4,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Vector;
import java.util.zip.GZIPOutputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.ArchiveFileSet;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.ArchiveResource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.selectors.SelectorUtils;
import org.apache.tools.ant.types.resources.TarResource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.MergingMapper;
import org.apache.tools.ant.util.SourceFileScanner;
import org.apache.tools.bzip2.CBZip2OutputStream;
import org.apache.tools.tar.TarConstants;
import org.apache.tools.tar.TarEntry;
import org.apache.tools.tar.TarOutputStream;


public class Tar extends MatchingTask {

    
    public static final String WARN = ""warn"";
    
    public static final String FAIL = ""fail"";
    
    public static final String TRUNCATE = ""truncate"";
    
    public static final String GNU = ""gnu"";
    
    public static final String OMIT = ""omit"";

    
    File tarFile;
    File baseDir;

    private TarLongFileMode longFileMode = new TarLongFileMode();

    
    Vector filesets = new Vector();
    
    
    private Vector resourceCollections = new Vector();

    Vector fileSetFiles = new Vector();

    

    
    private boolean longWarningGiven = false;

    private TarCompressionMethod compression = new TarCompressionMethod();

    
    public TarFileSet createTarFileSet() {
        TarFileSet fs = new TarFileSet();
        fs.setProject(getProject());
        filesets.addElement(fs);
        return fs;
    }

    
    public void add(ResourceCollection res) {
        resourceCollections.add(res);
    }

    
    public void setTarfile(File tarFile) {
        this.tarFile = tarFile;
    }

    
    public void setDestFile(File destFile) {
        this.tarFile = destFile;
    }

    
    public void setBasedir(File baseDir) {
        this.baseDir = baseDir;
    }

    
    public void setLongfile(String mode) {
        log(""DEPRECATED - The setLongfile(String) method has been deprecated.""
            + "" Use setLongfile(Tar.TarLongFileMode) instead."");
        this.longFileMode = new TarLongFileMode();
        longFileMode.setValue(mode);
    }

    
    public void setLongfile(TarLongFileMode mode) {
        this.longFileMode = mode;
    }

    
    public void setCompression(TarCompressionMethod mode) {
        this.compression = mode;
    }

    
    public void execute() throws BuildException {
        if (tarFile == null) {
            throw new BuildException(""tarfile attribute must be set!"",
                                     getLocation());
        }

        if (tarFile.exists() && tarFile.isDirectory()) {
            throw new BuildException(""tarfile is a directory!"",
                                     getLocation());
        }

        if (tarFile.exists() && !tarFile.canWrite()) {
            throw new BuildException(""Can not write to the specified tarfile!"",
                                     getLocation());
        }

        Vector savedFileSets = (Vector) filesets.clone();
        try {
            if (baseDir != null) {
                if (!baseDir.exists()) {
                    throw new BuildException(""basedir does not exist!"",
                                             getLocation());
                }

                
                TarFileSet mainFileSet = new TarFileSet(fileset);
                mainFileSet.setDir(baseDir);
                filesets.addElement(mainFileSet);
            }

            if (filesets.size() == 0 && resourceCollections.size() == 0) {
                throw new BuildException(""You must supply either a basedir ""
                                         + ""attribute or some nested resource""
                                         + "" collections."",
                                         getLocation());
            }

            
            
            boolean upToDate = true;
            for (Enumeration e = filesets.elements(); e.hasMoreElements();) {
                upToDate &= check((TarFileSet) e.nextElement());
            }
            for (Enumeration e = resourceCollections.elements();
                 e.hasMoreElements();) {
                upToDate &= check((ResourceCollection) e.nextElement());
            }

            if (upToDate) {
                log(""Nothing to do: "" + tarFile.getAbsolutePath()
                    + "" is up to date."", Project.MSG_INFO);
                return;
            }

            log(""Building tar: "" + tarFile.getAbsolutePath(), Project.MSG_INFO);

            TarOutputStream tOut = null;
            try {
                tOut = new TarOutputStream(
                    compression.compress(
                        new BufferedOutputStream(
                            new FileOutputStream(tarFile))));
                tOut.setDebug(true);
                if (longFileMode.isTruncateMode()) {
                    tOut.setLongFileMode(TarOutputStream.LONGFILE_TRUNCATE);
                } else if (longFileMode.isFailMode()
                            || longFileMode.isOmitMode()) {
                    tOut.setLongFileMode(TarOutputStream.LONGFILE_ERROR);
                } else {
                    
                    tOut.setLongFileMode(TarOutputStream.LONGFILE_GNU);
                }

                longWarningGiven = false;
                for (Enumeration e = filesets.elements();
                     e.hasMoreElements();) {
                    tar((TarFileSet) e.nextElement(), tOut);
                }
                for (Enumeration e = resourceCollections.elements();
                     e.hasMoreElements();) {
                    tar((ResourceCollection) e.nextElement(), tOut);
                }
            } catch (IOException ioe) {
                String msg = ""Problem creating TAR: "" + ioe.getMessage();
                throw new BuildException(msg, ioe, getLocation());
            } finally {
                FileUtils.close(tOut);
            }
        } finally {
            filesets = savedFileSets;
        }
    }

    
    protected void tarFile(File file, TarOutputStream tOut, String vPath,
                           TarFileSet tarFileSet)
        throws IOException {
        if (file.equals(tarFile)) {
            
            
            
            
            
            
            
            
            
            return;
        }
        tarResource(new FileResource(file), tOut, vPath, tarFileSet);
    }

    
    protected void tarResource(Resource r, TarOutputStream tOut, String vPath,
                               TarFileSet tarFileSet)
        throws IOException {

        if (!r.isExists()) {
            return;
        }

        if (tarFileSet != null) {
            String fullpath = tarFileSet.getFullpath(this.getProject());
            if (fullpath.length() > 0) {
                vPath = fullpath;
            } else {
                
                if (vPath.length() <= 0) {
                    return;
                }

                String prefix = tarFileSet.getPrefix(this.getProject());
                
                if (prefix.length() > 0 && !prefix.endsWith(""/"")) {
                    prefix = prefix + ""/"";
                }
                vPath = prefix + vPath;
            }

            if (vPath.startsWith(""/"")
                && !tarFileSet.getPreserveLeadingSlashes()) {
                int l = vPath.length();
                if (l <= 1) {
                    
                    return;
                }
                vPath = vPath.substring(1, l);
            }
        }

        if (r.isDirectory() && !vPath.endsWith(""/"")) {
            vPath += ""/"";
        }

        if (vPath.length() >= TarConstants.NAMELEN) {
            if (longFileMode.isOmitMode()) {
                log(""Omitting: "" + vPath, Project.MSG_INFO);
                return;
            } else if (longFileMode.isWarnMode()) {
                log(""Entry: "" + vPath + "" longer than ""
                    + TarConstants.NAMELEN + "" characters."",
                    Project.MSG_WARN);
                if (!longWarningGiven) {
                    log(""Resulting tar file can only be processed ""
                        + ""successfully by GNU compatible tar commands"",
                        Project.MSG_WARN);
                    longWarningGiven = true;
                }
            } else if (longFileMode.isFailMode()) {
                throw new BuildException(""Entry: "" + vPath
                        + "" longer than "" + TarConstants.NAMELEN
                        + ""characters."", getLocation());
            }
        }

        TarEntry te = new TarEntry(vPath);
        te.setModTime(r.getLastModified());
        
        if (r instanceof ArchiveResource) {
            ArchiveResource ar = (ArchiveResource) r;
            te.setMode(ar.getMode());
            if (r instanceof TarResource) {
                TarResource tr = (TarResource) r;
                te.setUserName(tr.getUserName());
                te.setUserId(tr.getUid());
                te.setGroupName(tr.getGroup());
                te.setGroupId(tr.getGid());
            }
        }

        if (!r.isDirectory()) {
            if (r.size() > TarConstants.MAXSIZE) {
                throw new BuildException(
                    ""Resource: "" + r + "" larger than ""
                    + TarConstants.MAXSIZE + "" bytes."");
            }
            te.setSize(r.getSize());
            
            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {
                te.setMode(tarFileSet.getMode());
            }
        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {
            
            te.setMode(tarFileSet.getDirMode(this.getProject()));
        }

        if (tarFileSet != null) {
            
            if (tarFileSet.hasUserNameBeenSet()) {
                te.setUserName(tarFileSet.getUserName());
            }
            if (tarFileSet.hasGroupBeenSet()) {
                te.setGroupName(tarFileSet.getGroup());
            }
            if (tarFileSet.hasUserIdBeenSet()) {
                te.setUserId(tarFileSet.getUid());
            }
            if (tarFileSet.hasGroupIdBeenSet()) {
                te.setGroupId(tarFileSet.getGid());
            }
        }

        InputStream in = null;
        try {
            tOut.putNextEntry(te);

            if (!r.isDirectory()) {
                in = r.getInputStream();

                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    tOut.write(buffer, 0, count);
                    count = in.read(buffer, 0, buffer.length);
                } while (count != -1);
            }

            tOut.closeEntry();
        } finally {
            FileUtils.close(in);
        }
    }

    
    protected boolean archiveIsUpToDate(String[] files) {
        return archiveIsUpToDate(files, baseDir);
    }

    
    protected boolean archiveIsUpToDate(String[] files, File dir) {
        SourceFileScanner sfs = new SourceFileScanner(this);
        MergingMapper mm = new MergingMapper();
        mm.setTo(tarFile.getAbsolutePath());
        return sfs.restrict(files, dir, null, mm).length == 0;
    }

    
    protected boolean archiveIsUpToDate(Resource r) {
        return SelectorUtils.isOutOfDate(new FileResource(tarFile), r,
                                         FileUtils.getFileUtils()
                                         .getFileTimestampGranularity());
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(Tar.class);
    }

    
    protected boolean check(ResourceCollection rc) {
        boolean upToDate = true;
        if (isFileFileSet(rc)) {
            FileSet fs = (FileSet) rc;
            upToDate = check(fs.getDir(getProject()), getFileNames(fs));
        } else if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
            throw new BuildException(""only filesystem resources are supported"");
        } else if (rc.isFilesystemOnly()) {
            HashSet basedirs = new HashSet();
            HashMap basedirToFilesMap = new HashMap();
            Iterator iter = rc.iterator();
            while (iter.hasNext()) {
                FileResource r = (FileResource) iter.next();
                File base = r.getBaseDir();
                if (base == null) {
                    base = Copy.NULL_FILE_PLACEHOLDER;
                }
                basedirs.add(base);
                Vector files = (Vector) basedirToFilesMap.get(base);
                if (files == null) {
                    files = new Vector();
                    basedirToFilesMap.put(base, new Vector());
                }
                files.add(r.getName());
            }
            iter = basedirs.iterator();
            while (iter.hasNext()) {
                File base = (File) iter.next();
                Vector f = (Vector) basedirToFilesMap.get(base);
                String[] files = (String[]) f.toArray(new String[f.size()]);
                upToDate &=
                    check(base == Copy.NULL_FILE_PLACEHOLDER ? null : base,
                          files);
            }
        } else { 
            Iterator iter = rc.iterator();
            while (upToDate && iter.hasNext()) {
                Resource r = (Resource) iter.next();
                upToDate &= archiveIsUpToDate(r);
            }
        }

        return upToDate;
    }

    
    protected boolean check(File basedir, String[] files) {
        boolean upToDate = true;
        if (!archiveIsUpToDate(files, basedir)) {
            upToDate = false;
        }

        for (int i = 0; i < files.length; ++i) {
            if (tarFile.equals(new File(basedir, files[i]))) {
                throw new BuildException(""A tar file cannot include ""
                                         + ""itself"", getLocation());
            }
        }
        return upToDate;
    }

    
    protected void tar(ResourceCollection rc, TarOutputStream tOut)
        throws IOException {
        ArchiveFileSet afs = null;
        if (rc instanceof ArchiveFileSet) {
            afs = (ArchiveFileSet) rc;
        }
        if (afs != null && afs.size() > 1
            && afs.getFullpath(this.getProject()).length() > 0) {
            throw new BuildException(""fullpath attribute may only ""
                                     + ""be specified for ""
                                     + ""filesets that specify a ""
                                     + ""single file."");
        }
        TarFileSet tfs = asTarFileSet(afs);

        if (isFileFileSet(rc)) {
            FileSet fs = (FileSet) rc;
            String[] files = getFileNames(fs);
            for (int i = 0; i < files.length; i++) {
                File f = new File(fs.getDir(getProject()), files[i]);
                String name = files[i].replace(File.separatorChar, '/');
                tarFile(f, tOut, name, tfs);
            }
        } else if (rc.isFilesystemOnly()) {
            Iterator iter = rc.iterator();
            while (iter.hasNext()) {
                FileResource r = (FileResource) iter.next();
                File f = r.getFile();
                if (f == null) {
                    f = new File(r.getBaseDir(), r.getName());
                }
                tarFile(f, tOut, f.getName(), tfs);
            }
        } else { 
            Iterator iter = rc.iterator();
            while (iter.hasNext()) {
                Resource r = (Resource) iter.next();
                tarResource(r, tOut, r.getName(), tfs);
            }
        }
    }

    
    protected static final boolean isFileFileSet(ResourceCollection rc) {
        return rc instanceof FileSet && rc.isFilesystemOnly();
    }

    
    protected static final String[] getFileNames(FileSet fs) {
        DirectoryScanner ds = fs.getDirectoryScanner(fs.getProject());
        String[] directories = ds.getIncludedDirectories();
        String[] filesPerSe = ds.getIncludedFiles();
        String[] files = new String [directories.length + filesPerSe.length];
        System.arraycopy(directories, 0, files, 0, directories.length);
        System.arraycopy(filesPerSe, 0, files, directories.length,
                         filesPerSe.length);
        return files;
    }

    
    protected TarFileSet asTarFileSet(ArchiveFileSet archiveFileSet) {
        TarFileSet tfs = null;
        if (archiveFileSet != null && archiveFileSet instanceof TarFileSet) {
            tfs = (TarFileSet) archiveFileSet;
        } else {
            tfs = new TarFileSet();
            tfs.setProject(getProject());
            if (archiveFileSet != null) {
                tfs.setPrefix(archiveFileSet.getPrefix(getProject()));
                tfs.setFullpath(archiveFileSet.getFullpath(getProject()));
                if (archiveFileSet.hasFileModeBeenSet()) {
                    tfs.integerSetFileMode(archiveFileSet
                                           .getFileMode(getProject()));
                }
                if (archiveFileSet.hasDirModeBeenSet()) {
                    tfs.integerSetDirMode(archiveFileSet
                                          .getDirMode(getProject()));
                }

                if (archiveFileSet
                    instanceof org.apache.tools.ant.types.TarFileSet) {
                    org.apache.tools.ant.types.TarFileSet t =
                        (org.apache.tools.ant.types.TarFileSet) archiveFileSet;
                    if (t.hasUserNameBeenSet()) {
                        tfs.setUserName(t.getUserName());
                    }
                    if (t.hasGroupBeenSet()) {
                        tfs.setGroup(t.getGroup());
                    }
                    if (t.hasUserIdBeenSet()) {
                        tfs.setUid(t.getUid());
                    }
                    if (t.hasGroupIdBeenSet()) {
                        tfs.setGid(t.getGid());
                    }
                }
            }
        }
        return tfs;
    }

    
    public static class TarFileSet
        extends org.apache.tools.ant.types.TarFileSet {
        private String[] files = null;

        private boolean preserveLeadingSlashes = false;

        
        public TarFileSet(FileSet fileset) {
            super(fileset);
        }

        
        public TarFileSet() {
            super();
        }

        
        public String[] getFiles(Project p) {
            if (files == null) {
                files = getFileNames(this);
            }

            return files;
        }

        
        public void setMode(String octalString) {
            setFileMode(octalString);
        }

        
        public int getMode() {
            return getFileMode(this.getProject());
        }

        
        public void setPreserveLeadingSlashes(boolean b) {
            this.preserveLeadingSlashes = b;
        }

        
        public boolean getPreserveLeadingSlashes() {
            return preserveLeadingSlashes;
        }
    }

    
    public static class TarLongFileMode extends EnumeratedAttribute {

        
        public static final String
            WARN = ""warn"",
            FAIL = ""fail"",
            TRUNCATE = ""truncate"",
            GNU = ""gnu"",
            OMIT = ""omit"";

        private final String[] validModes = {WARN, FAIL, TRUNCATE, GNU, OMIT};

        
        public TarLongFileMode() {
            super();
            setValue(WARN);
        }

        
        public String[] getValues() {
            return validModes;
        }

        
        public boolean isTruncateMode() {
            return TRUNCATE.equalsIgnoreCase(getValue());
        }

        
        public boolean isWarnMode() {
            return WARN.equalsIgnoreCase(getValue());
        }

        
        public boolean isGnuMode() {
            return GNU.equalsIgnoreCase(getValue());
        }

        
        public boolean isFailMode() {
            return FAIL.equalsIgnoreCase(getValue());
        }

        
        public boolean isOmitMode() {
            return OMIT.equalsIgnoreCase(getValue());
        }
    }

    
    public static final class TarCompressionMethod extends EnumeratedAttribute {

        
        
        private static final String NONE = ""none"";
        
        private static final String GZIP = ""gzip"";
        
        private static final String BZIP2 = ""bzip2"";


        
        public TarCompressionMethod() {
            super();
            setValue(NONE);
        }

        
        public String[] getValues() {
            return new String[] {NONE, GZIP, BZIP2 };
        }

        
        private OutputStream compress(final OutputStream ostream)
            throws IOException {
            final String v = getValue();
            if (GZIP.equals(v)) {
                return new GZIPOutputStream(ostream);
            } else {
                if (BZIP2.equals(v)) {
                    ostream.write('B');
                    ostream.write('Z');
                    return new CBZip2OutputStream(ostream);
                }
            }
            return ostream;
        }
    }
}
"
org.apache.tools.ant.taskdefs.rmic.WLRmic,4,2,0,9,22,6,1,8,4,1.285714286,130,0.0,0,0.8125,1.0,0,0,29.75,1,0.75,2,"

package org.apache.tools.ant.taskdefs.rmic;

import java.lang.reflect.Method;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;


public class WLRmic extends DefaultRmicAdapter {
    
    public static final String WLRMIC_CLASSNAME = ""weblogic.rmic"";
    
    public static final String COMPILER_NAME = ""weblogic"";

    
    public static final String ERROR_NO_WLRMIC_ON_CLASSPATH =
        ""Cannot use WebLogic rmic, as it is not ""
        + ""available.  A common solution is to ""
        + ""set the environment variable ""
        + ""CLASSPATH."";

    
    public static final String ERROR_WLRMIC_FAILED = ""Error starting WebLogic rmic: "";
    
    public static final String WL_RMI_STUB_SUFFIX = ""_WLStub"";
    
    public static final String WL_RMI_SKEL_SUFFIX = ""_WLSkel"";

    
    public boolean execute() throws BuildException {
        getRmic().log(""Using WebLogic rmic"", Project.MSG_VERBOSE);
        Commandline cmd = setupRmicCommand(new String[] {""-noexit""});

        AntClassLoader loader = null;
        try {
            
            Class c = null;
            if (getRmic().getClasspath() == null) {
                c = Class.forName(WLRMIC_CLASSNAME);
            } else {
                loader
                    = getRmic().getProject().createClassLoader(getRmic().getClasspath());
                c = Class.forName(WLRMIC_CLASSNAME, true, loader);
            }
            Method doRmic = c.getMethod(""main"",
                                        new Class [] {String[].class});
            doRmic.invoke(null, new Object[] {cmd.getArguments()});
            return true;
        } catch (ClassNotFoundException ex) {
            throw new BuildException(ERROR_NO_WLRMIC_ON_CLASSPATH, getRmic().getLocation());
        } catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(ERROR_WLRMIC_FAILED, ex,
                                         getRmic().getLocation());
            }
        } finally {
            if (loader != null) {
                loader.cleanup();
            }
        }
    }

    
    public String getStubClassSuffix() {
        return WL_RMI_STUB_SUFFIX;
    }

    
    public String getSkelClassSuffix() {
        return WL_RMI_SKEL_SUFFIX;
    }
}
"
org.apache.tools.ant.taskdefs.SignJar,20,4,0,9,56,150,0,9,15,0.956140351,455,0.611111111,2,0.769230769,0.289473684,0,0,20.85,6,1.3,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.IsSigned;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.ant.util.FileNameMapper;


public class SignJar extends AbstractJarSignerTask {
    

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    protected String sigfile;

    
    protected File signedjar;

    
    protected boolean internalsf;

    
    protected boolean sectionsonly;

    
    private boolean preserveLastModified;

    
    protected boolean lazy;

    
    protected File destDir;

    
    private FileNameMapper mapper;

    
    protected String tsaurl;

    
    protected String tsacert;

    
    public static final String ERROR_TODIR_AND_SIGNEDJAR
            = ""'destdir' and 'signedjar' cannot both be set"";
    
    public static final String ERROR_TOO_MANY_MAPPERS = ""Too many mappers"";
    
    public static final String ERROR_SIGNEDJAR_AND_PATHS
        = ""You cannot specify the signed JAR when using paths or filesets"";
    
    public static final String ERROR_BAD_MAP = ""Cannot map source file to anything sensible: "";
    
    public static final String ERROR_MAPPER_WITHOUT_DEST
        = ""The destDir attribute is required if a mapper is set"";
    
    public static final String ERROR_NO_ALIAS = ""alias attribute must be set"";
    
    public static final String ERROR_NO_STOREPASS = ""storepass attribute must be set"";
    

    
    public void setSigfile(final String sigfile) {
        this.sigfile = sigfile;
    }

    
    public void setSignedjar(final File signedjar) {
        this.signedjar = signedjar;
    }

    
    public void setInternalsf(final boolean internalsf) {
        this.internalsf = internalsf;
    }

    
    public void setSectionsonly(final boolean sectionsonly) {
        this.sectionsonly = sectionsonly;
    }

    
    public void setLazy(final boolean lazy) {
        this.lazy = lazy;
    }

    
    public void setDestDir(File destDir) {
        this.destDir = destDir;
    }


    
    public void add(FileNameMapper newMapper) {
        if (mapper != null) {
            throw new BuildException(ERROR_TOO_MANY_MAPPERS);
        }
        mapper = newMapper;
    }

    
    public FileNameMapper getMapper() {
        return mapper;
    }

    
    public String getTsaurl() {
        return tsaurl;
    }

    
    public void setTsaurl(String tsaurl) {
        this.tsaurl = tsaurl;
    }

    
    public String getTsacert() {
        return tsacert;
    }

    
    public void setTsacert(String tsacert) {
        this.tsacert = tsacert;
    }

    
    public void execute() throws BuildException {
        
        final boolean hasJar = jar != null;
        final boolean hasSignedJar = signedjar != null;
        final boolean hasDestDir = destDir != null;
        final boolean hasMapper = mapper != null;

        if (!hasJar && !hasResources()) {
            throw new BuildException(ERROR_NO_SOURCE);
        }
        if (null == alias) {
            throw new BuildException(ERROR_NO_ALIAS);
        }

        if (null == storepass) {
            throw new BuildException(ERROR_NO_STOREPASS);
        }

        if (hasDestDir && hasSignedJar) {
            throw new BuildException(ERROR_TODIR_AND_SIGNEDJAR);
        }


        if (hasResources() && hasSignedJar) {
            throw new BuildException(ERROR_SIGNEDJAR_AND_PATHS);
        }

        
        
        if (!hasDestDir && hasMapper) {
            throw new BuildException(ERROR_MAPPER_WITHOUT_DEST);
        }

        beginExecution();


        try {
            
            if (hasJar && hasSignedJar) {
                
                signOneJar(jar, signedjar);
                
                return;
            }

            
            

            Path sources = createUnifiedSourcePath();
            
            FileNameMapper destMapper;
            if (hasMapper) {
                destMapper = mapper;
            } else {
                
                destMapper = new IdentityMapper();
            }


            
            
            
            
            Iterator iter = sources.iterator();
            while (iter.hasNext()) {
                FileResource fr = (FileResource) iter.next();

                
                
                File toDir = hasDestDir ? destDir : fr.getBaseDir();

                
                String[] destFilenames = destMapper.mapFileName(fr.getName());
                if (destFilenames == null || destFilenames.length != 1) {
                    
                    throw new BuildException(ERROR_BAD_MAP + fr.getFile());
                }
                File destFile = new File(toDir, destFilenames[0]);
                signOneJar(fr.getFile(), destFile);
            }
        } finally {
            endExecution();
        }
    }

    
    private void signOneJar(File jarSource, File jarTarget)
            throws BuildException {


        File targetFile = jarTarget;
        if (targetFile == null) {
            targetFile = jarSource;
        }
        if (isUpToDate(jarSource, targetFile)) {
            return;
        }

        long lastModified = jarSource.lastModified();
        final ExecTask cmd = createJarSigner();

        setCommonOptions(cmd);

        bindToKeystore(cmd);
        if (null != sigfile) {
            addValue(cmd, ""-sigfile"");
            String value = this.sigfile;
            addValue(cmd, value);
        }

        
        
        if (null != targetFile && !jarSource.equals(targetFile)) {
            addValue(cmd, ""-signedjar"");
            addValue(cmd, targetFile.getPath());
        }

        if (internalsf) {
            addValue(cmd, ""-internalsf"");
        }

        if (sectionsonly) {
            addValue(cmd, ""-sectionsonly"");
        }

        
        addTimestampAuthorityCommands(cmd);

        
        addValue(cmd, jarSource.getPath());

        
        addValue(cmd, alias);

        log(""Signing JAR: ""
            + jarSource.getAbsolutePath()
            + "" to ""
            + targetFile.getAbsolutePath()
            + "" as "" + alias);

        cmd.execute();

        
        if (preserveLastModified) {
            targetFile.setLastModified(lastModified);
        }
    }

    
    private void addTimestampAuthorityCommands(final ExecTask cmd) {
        if (tsaurl != null) {
            addValue(cmd, ""-tsa"");
            addValue(cmd, tsaurl);
        }
        if (tsacert != null) {
            addValue(cmd, ""-tsacert"");
            addValue(cmd, tsacert);
        }
    }

    
    protected boolean isUpToDate(File jarFile, File signedjarFile) {
        if (null == jarFile || !jarFile.exists()) {
            
            
            return false;
        }

        
        File destFile = signedjarFile;
        if (destFile == null) {
            
            destFile = jarFile;
        }

        
        if (jarFile.equals(destFile)) {
            if (lazy) {
                
                return isSigned(jarFile);
            }
            
            return false;
        }

        
        return FILE_UTILS.isUpToDate(jarFile, destFile);
    }

    
    protected boolean isSigned(File file) {
        try {
            return IsSigned.isSigned(file, alias);
        } catch (IOException e) {
            
            log(e.toString(), Project.MSG_VERBOSE);
            return false;
        }
    }

    
    public void setPreserveLastModified(boolean preserveLastModified) {
        this.preserveLastModified = preserveLastModified;
    }
}
"
org.apache.tools.ant.taskdefs.Definer,25,5,1,14,91,196,3,13,16,0.878205128,800,1.0,1,0.701298701,0.21875,0,0,30.48,6,1.68,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Map;
import java.util.HashMap;
import java.util.Enumeration;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Properties;

import org.apache.tools.ant.AntTypeDefinition;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.EnumeratedAttribute;


public abstract class Definer extends DefBase {

    
    private static final String ANTLIB_XML = ""/antlib.xml"";

    private static class ResourceStack extends ThreadLocal {
        public Object initialValue() {
            return new HashMap();
        }
        Map getStack() {
            return (Map) get();
        }
    }
    private static ResourceStack resourceStack = new ResourceStack();
    private String name;
    private String classname;
    private File file;
    private String resource;

    private   int    format = Format.PROPERTIES;
    private   boolean definerSet = false;
    private   int         onError = OnError.FAIL;
    private   String      adapter;
    private   String      adaptTo;

    private   Class       adapterClass;
    private   Class       adaptToClass;

    
    public static class OnError extends EnumeratedAttribute {
        
        public static final int  FAIL = 0, REPORT = 1, IGNORE = 2, FAIL_ALL = 3;

        
        public static final String POLICY_FAIL = ""fail"";
        
        public static final String POLICY_REPORT = ""report"";
        
        public static final String POLICY_IGNORE = ""ignore"";
        
        public static final String POLICY_FAILALL = ""failall"";

        
        public OnError() {
            super();
        }

        
        public OnError(String value) {
            setValue(value);
        }

        
        public String[] getValues() {
            return new String[] {POLICY_FAIL, POLICY_REPORT, POLICY_IGNORE, POLICY_FAILALL};
        }
    }

    
    public static class Format extends EnumeratedAttribute {
        
        public static final int PROPERTIES = 0, XML = 1;

        
        public String[] getValues() {
            return new String[] {""properties"", ""xml""};
        }
    }

    
    public void setOnError(OnError onError) {
        this.onError = onError.getIndex();
    }

    
    public void setFormat(Format format) {
        this.format = format.getIndex();
    }

    
    public String getName() {
        return name;
    }

    
    public File getFile() {
        return file;
    }

    
    public String getResource() {
        return resource;
    }


    
    public void execute() throws BuildException {
        ClassLoader al = createLoader();

        if (!definerSet) {
            
            
            
            
            if (getURI() == null) {
                throw new BuildException(
                        ""name, file or resource attribute of ""
                                + getTaskName() + "" is undefined"",
                        getLocation());
            }

            if (getURI().startsWith(MagicNames.ANTLIB_PREFIX)) {
                
                String uri1 = getURI();
                setResource(makeResourceFromURI(uri1));
            } else {
                throw new BuildException(
                        ""Only antlib URIs can be located from the URI alone,""
                                + ""not the URI "" + getURI());
            }
        }

        if (name != null) {
            if (classname == null) {
                throw new BuildException(
                    ""classname attribute of "" + getTaskName() + "" element ""
                    + ""is undefined"", getLocation());
            }
            addDefinition(al, name, classname);
        } else {
            if (classname != null) {
                String msg = ""You must not specify classname ""
                    + ""together with file or resource."";
                throw new BuildException(msg, getLocation());
            }
            Enumeration urls = null;
            if (file != null) {
                final URL url = fileToURL();
                if (url == null) {
                    return;
                }
                urls = new Enumeration() {
                    private boolean more = true;
                    public boolean hasMoreElements() {
                        return more;
                    }
                    public Object nextElement() throws NoSuchElementException {
                        if (more) {
                            more = false;
                            return url;
                        } else {
                            throw new NoSuchElementException();
                        }
                    }
                };
            } else {
                urls = resourceToURLs(al);
            }

            while (urls.hasMoreElements()) {
                URL url = (URL) urls.nextElement();

                int fmt = this.format;
                if (url.toString().toLowerCase(Locale.US).endsWith("".xml"")) {
                    fmt = Format.XML;
                }

                if (fmt == Format.PROPERTIES) {
                    loadProperties(al, url);
                    break;
                } else {
                    if (resourceStack.getStack().get(url) != null) {
                        log(""Warning: Recursive loading of "" + url
                            + "" ignored""
                            + "" at "" + getLocation()
                            + "" originally loaded at ""
                            + resourceStack.getStack().get(url),
                            Project.MSG_WARN);
                    } else {
                        try {
                            resourceStack.getStack().put(url, getLocation());
                            loadAntlib(al, url);
                        } finally {
                            resourceStack.getStack().remove(url);
                        }
                    }
                }
            }
        }
    }

    

    public static String makeResourceFromURI(String uri) {
        String path = uri.substring(MagicNames.ANTLIB_PREFIX.length());
        String resource;
        if (path.startsWith(""
            
            
            resource = path.substring(""
            if (!resource.endsWith("".xml"")) {
                
                resource = resource + ANTLIB_XML;
            }
        } else {
            
            resource = path.replace('.', '/') + ANTLIB_XML;
        }
        return resource;
    }

    
    private URL fileToURL() {
        String message = null;
        if (!(file.exists())) {
            message = ""File "" + file + "" does not exist"";
        }
        if (message == null && !(file.isFile())) {
            message = ""File "" + file + "" is not a file"";
        }
        try {
            if (message == null) {
                return file.toURL();
            }
        } catch (Exception ex) {
            message =
                ""File "" + file + "" cannot use as URL: ""
                + ex.toString();
        }
        
        switch (onError) {
            case OnError.FAIL_ALL:
                throw new BuildException(message);
            case OnError.FAIL:
                
            case OnError.REPORT:
                log(message, Project.MSG_WARN);
                break;
            case OnError.IGNORE:
                
                log(message, Project.MSG_VERBOSE);
                break;
            default:
                
                break;
        }
        return null;
    }

    private Enumeration resourceToURLs(ClassLoader classLoader) {
        Enumeration ret;
        try {
            ret = classLoader.getResources(resource);
        } catch (IOException e) {
            throw new BuildException(
                ""Could not fetch resources named "" + resource,
                e, getLocation());
        }
        if (!ret.hasMoreElements()) {
            String message = ""Could not load definitions from resource ""
                + resource + "". It could not be found."";
            switch (onError) {
                case OnError.FAIL_ALL:
                    throw new BuildException(message);
                case OnError.FAIL:
                case OnError.REPORT:
                    log(message, Project.MSG_WARN);
                    break;
                case OnError.IGNORE:
                    log(message, Project.MSG_VERBOSE);
                    break;
                default:
                    
                    break;
            }
        }
        return ret;
    }

    
    protected void loadProperties(ClassLoader al, URL url) {
        InputStream is = null;
        try {
            is = url.openStream();
            if (is == null) {
                log(""Could not load definitions from "" + url,
                    Project.MSG_WARN);
                return;
            }
            Properties props = new Properties();
            props.load(is);
            Enumeration keys = props.keys();
            while (keys.hasMoreElements()) {
                name = ((String) keys.nextElement());
                classname = props.getProperty(name);
                addDefinition(al, name, classname);
            }
        } catch (IOException ex) {
            throw new BuildException(ex, getLocation());
        } finally {
            FileUtils.close(is);
        }
    }

    
    private void loadAntlib(ClassLoader classLoader, URL url) {
        try {
            Antlib antlib = Antlib.createAntlib(getProject(), url, getURI());
            antlib.setClassLoader(classLoader);
            antlib.setURI(getURI());
            antlib.execute();
        } catch (BuildException ex) {
            throw ProjectHelper.addLocationToBuildException(
                ex, getLocation());
        }
    }

    
    public void setFile(File file) {
        if (definerSet) {
            tooManyDefinitions();
        }
        definerSet = true;
        this.file = file;
    }

    
    public void setResource(String res) {
        if (definerSet) {
            tooManyDefinitions();
        }
        definerSet = true;
        this.resource = res;
    }

    
    public void setAntlib(String antlib) {
        if (definerSet) {
            tooManyDefinitions();
        }
        if (!antlib.startsWith(""antlib:"")) {
            throw new BuildException(
                ""Invalid antlib attribute - it must start with antlib:"");
        }
        setURI(antlib);
        this.resource = antlib.substring(""antlib:"".length()).replace('.', '/')
            + ""/antlib.xml"";
        definerSet = true;
    }

    
    public void setName(String name) {
        if (definerSet) {
            tooManyDefinitions();
        }
        definerSet = true;
        this.name = name;
    }

    
    public String getClassname() {
        return classname;
    }

    
    public void setClassname(String classname) {
        this.classname = classname;
    }

    

    public void setAdapter(String adapter) {
        this.adapter = adapter;
    }

    
    protected void setAdapterClass(Class adapterClass) {
        this.adapterClass = adapterClass;
    }

    
    public void setAdaptTo(String adaptTo) {
        this.adaptTo = adaptTo;
    }

    
    protected void setAdaptToClass(Class adaptToClass) {
        this.adaptToClass = adaptToClass;
    }


    
    protected void addDefinition(ClassLoader al, String name, String classname)
        throws BuildException {
        Class cl = null;
        try {
            try {
                name = ProjectHelper.genComponentName(getURI(), name);

                if (onError != OnError.IGNORE) {
                    cl = Class.forName(classname, true, al);
                }

                if (adapter != null) {
                    adapterClass = Class.forName(adapter, true, al);
                }

                if (adaptTo != null) {
                    adaptToClass = Class.forName(adaptTo, true, al);
                }

                AntTypeDefinition def = new AntTypeDefinition();
                def.setName(name);
                def.setClassName(classname);
                def.setClass(cl);
                def.setAdapterClass(adapterClass);
                def.setAdaptToClass(adaptToClass);
                def.setClassLoader(al);
                if (cl != null) {
                    def.checkClass(getProject());
                }
                ComponentHelper.getComponentHelper(getProject())
                    .addDataTypeDefinition(def);
            } catch (ClassNotFoundException cnfe) {
                String msg = getTaskName() + "" class "" + classname
                    + "" cannot be found"";
                throw new BuildException(msg, cnfe, getLocation());
            } catch (NoClassDefFoundError ncdfe) {
                String msg = getTaskName() + "" A class needed by class ""
                    + classname + "" cannot be found: "" + ncdfe.getMessage();
                throw new BuildException(msg, ncdfe, getLocation());
            }
        } catch (BuildException ex) {
            switch (onError) {
                case OnError.FAIL_ALL:
                case OnError.FAIL:
                    throw ex;
                case OnError.REPORT:
                    log(ex.getLocation() + ""Warning: "" + ex.getMessage(),
                        Project.MSG_WARN);
                    break;
                default:
                    log(ex.getLocation() + ex.getMessage(),
                        Project.MSG_DEBUG);
            }
        }
    }

    
    private void tooManyDefinitions() {
        throw new BuildException(
            ""Only one of the attributes name, file and resource""
            + "" can be set"", getLocation());
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.JarLibResolveTask,13,3,0,10,36,20,0,10,9,0.716666667,369,1.0,1,0.755102041,0.211538462,1,1,27.0,6,1.4615,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import java.util.ArrayList;
import java.util.jar.Manifest;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.optional.extension.resolvers.AntResolver;
import org.apache.tools.ant.taskdefs.optional.extension.resolvers.LocationResolver;
import org.apache.tools.ant.taskdefs.optional.extension.resolvers.URLResolver;


public class JarLibResolveTask extends Task {
    
    private String propertyName;

    
    private Extension requiredExtension;

    
    private final ArrayList resolvers = new ArrayList();

    
    private boolean checkExtension = true;

    
    private boolean failOnError = true;

    
    public void setProperty(final String property) {
        this.propertyName = property;
    }

    
    public void setCheckExtension(final boolean checkExtension) {
        this.checkExtension = checkExtension;
    }

    
    public void setFailOnError(final boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    public void addConfiguredLocation(final LocationResolver loc) {
        resolvers.add(loc);
    }

    
    public void addConfiguredUrl(final URLResolver url) {
        resolvers.add(url);
    }

    
    public void addConfiguredAnt(final AntResolver ant) {
        resolvers.add(ant);
    }

    
    public void addConfiguredExtension(final ExtensionAdapter extension) {
        if (null != requiredExtension) {
            final String message = ""Can not specify extension to ""
                + ""resolve multiple times."";
            throw new BuildException(message);
        }
        requiredExtension = extension.toExtension();
    }

    
    public void execute() throws BuildException {
        validate();

        getProject().log(""Resolving extension: "" + requiredExtension,
                          Project.MSG_VERBOSE);

        String candidate =
            getProject().getProperty(propertyName);

        if (null != candidate) {
            final String message = ""Property Already set to: "" + candidate;
            if (failOnError) {
                throw new BuildException(message);
            }
            getProject().log(message, Project.MSG_ERR);
            return;
        }

        final int size = resolvers.size();
        for (int i = 0; i < size; i++) {
            final ExtensionResolver resolver =
                (ExtensionResolver) resolvers.get(i);

            getProject().log(""Searching for extension using Resolver:"" + resolver,
                              Project.MSG_VERBOSE);

            try {
                final File file =
                    resolver.resolve(requiredExtension, getProject());
                try {
                    checkExtension(file);
                    return;
                } catch (final BuildException be) {
                    final String message = ""File "" + file + "" returned by ""
                        + ""resolver failed to satisfy extension due to: ""
                        + be.getMessage();
                    getProject().log(message, Project.MSG_WARN);
                }
            } catch (final BuildException be) {
                final String message = ""Failed to resolve extension to file ""
                    + ""using resolver "" + resolver + "" due to: "" + be;
                getProject().log(message, Project.MSG_WARN);
            }
        }

        missingExtension();
    }

    
    private void missingExtension() {
        final String message =
            ""Unable to resolve extension to a file"";
        if (failOnError) {
            throw new BuildException(message);
        }
        getProject().log(message, Project.MSG_ERR);
    }

    
    private void checkExtension(final File file) {
        if (!file.exists()) {
            final String message =
                ""File "" + file + "" does not exist"";
            throw new BuildException(message);
        }
        if (!file.isFile()) {
            final String message =
                ""File "" + file + "" is not a file"";
            throw new BuildException(message);
        }

        if (!checkExtension) {
            final String message = ""Setting property to "" + file
                + "" without verifying library satisfies extension"";
            getProject().log(message, Project.MSG_VERBOSE);
            setLibraryProperty(file);
        } else {
            getProject().log(""Checking file "" + file
                + "" to see if it satisfies extension"", Project.MSG_VERBOSE);
            final Manifest manifest =
                ExtensionUtil.getManifest(file);
            final Extension[] extensions =
                Extension.getAvailable(manifest);
            for (int i = 0; i < extensions.length; i++) {
                final Extension extension = extensions[ i ];
                if (extension.isCompatibleWith(requiredExtension)) {
                    setLibraryProperty(file);
                    return;
                }
            }

            getProject().log(""File "" + file + "" skipped as it ""
                + ""does not satisfy extension"", Project.MSG_VERBOSE);

            final String message =
                ""File "" + file + "" does not satisfy extension"";
            throw new BuildException(message);
        }
    }

    
    private void setLibraryProperty(final File file) {
        getProject().setNewProperty(propertyName,
                                     file.getAbsolutePath());
    }

    
    private void validate() throws BuildException {
        if (null == propertyName) {
            final String message = ""Property attribute must be specified."";
            throw new BuildException(message);
        }

        if (null == requiredExtension) {
            final String message = ""Extension element must be specified."";
            throw new BuildException(message);
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.AptExternalCompilerAdapter,3,2,0,6,15,3,0,6,2,2.0,50,0.0,0,0.92,1.0,0,0,15.66666667,1,0.6667,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Apt;
import org.apache.tools.ant.types.Commandline;


public class AptExternalCompilerAdapter extends DefaultCompilerAdapter {


    
    protected Apt getApt() {
        return (Apt) getJavac();
    }

    
    public boolean execute() throws BuildException {
        attributes.log(""Using external apt compiler"", Project.MSG_VERBOSE);


        
        Apt apt = getApt();
        Commandline cmd = new Commandline();
        cmd.setExecutable(apt.getAptExecutable());
        setupModernJavacCommandlineSwitches(cmd);
        AptCompilerAdapter.setAptCommandlineSwitches(apt, cmd);
        int firstFileName = cmd.size();
        
        logAndAddFilesToCompile(cmd);

        
        return 0 == executeExternalCompile(cmd.getCommandline(),
                firstFileName,
                true);

    }

}

"
org.apache.tools.ant.taskdefs.optional.jsp.compilers.DefaultJspCompilerAdapter,10,1,1,6,26,41,1,5,5,0.833333333,129,1.0,1,0.0,0.37037037,0,0,11.7,3,1.4,0,"

package org.apache.tools.ant.taskdefs.optional.jsp.compilers;

import java.io.File;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.optional.jsp.JspC;
import org.apache.tools.ant.types.CommandlineJava;


public abstract class DefaultJspCompilerAdapter
    implements JspCompilerAdapter {

    private static String lSep = System.getProperty(""line.separator"");

    
    protected void logAndAddFilesToCompile(JspC jspc,
                                           Vector compileList,
                                           CommandlineJava cmd) {
        jspc.log(""Compilation "" + cmd.describeJavaCommand(),
                 Project.MSG_VERBOSE);

        StringBuffer niceSourceList = new StringBuffer(""File"");
        if (compileList.size() != 1) {
            niceSourceList.append(""s"");
        }
        niceSourceList.append("" to be compiled:"");

        niceSourceList.append(lSep);

        Enumeration e = compileList.elements();
        while (e.hasMoreElements()) {
            String arg = (String) e.nextElement();
            cmd.createArgument().setValue(arg);
            niceSourceList.append(""    "");
            niceSourceList.append(arg);
            niceSourceList.append(lSep);
        }

        jspc.log(niceSourceList.toString(), Project.MSG_VERBOSE);
    }

    

    
    protected JspC owner;

    

    
    public void setJspc(JspC owner) {
        this.owner = owner;
    }

    
    public JspC getJspc() {
        return owner;
    }


    
    protected void addArg(CommandlineJava cmd, String argument) {
        if (argument != null && argument.length() != 0) {
           cmd.createArgument().setValue(argument);
        }
    }


    
    protected void addArg(CommandlineJava cmd, String argument, String value) {
        if (value != null) {
            cmd.createArgument().setValue(argument);
            cmd.createArgument().setValue(value);
        }
    }

    
    protected void addArg(CommandlineJava cmd, String argument, File file) {
        if (file != null) {
            cmd.createArgument().setValue(argument);
            cmd.createArgument().setFile(file);
        }
    }

    
    public boolean implementsOwnDependencyChecking() {
        return false;
    }

    
    public Project getProject() {
        return getJspc().getProject();
    }
}

"
org.apache.tools.ant.types.ResourceLocation,7,1,1,6,8,3,6,0,7,0.666666667,43,1.0,0,0.0,0.476190476,0,0,4.714285714,1,0.8571,0,"
package org.apache.tools.ant.types;

import java.net.URL;


public class ResourceLocation {

    
    
    private String publicId = null;

    
    private String location = null;

    
    private URL base = null;

    

    
    public void setPublicId(String publicId) {
        this.publicId = publicId;
    }

    
    public void setLocation(String location) {
        this.location = location;
    }

    
    public void setBase(URL base) {
        this.base = base;
    }

    
    public String getPublicId() {
        return publicId;
    }

    
    public String getLocation() {
        return location;
    }

    
    public URL getBase() {
        return base;
    }

} 
"
org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector,40,5,0,30,121,622,6,24,36,0.886946387,1031,0.863636364,6,0.493506494,0.115625,2,4,24.225,21,2.35,2,"

package org.apache.tools.ant.types.selectors.modifiedselector;



import java.util.Comparator;
import java.util.Vector;
import java.util.Iterator;
import java.io.File;


import org.apache.tools.ant.Project;
import org.apache.tools.ant.IntrospectionHelper;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.types.selectors.BaseExtendSelector;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.ResourceUtils;



public class ModifiedSelector extends BaseExtendSelector
                              implements BuildListener, ResourceSelector {


    


    
    private CacheName cacheName = null;

    
    private String cacheClass;

    
    private AlgorithmName algoName = null;

    
    private String algorithmClass;

    
    private ComparatorName compName = null;

    
    private String comparatorClass;

    
    private boolean update = true;

    
    private boolean selectDirectories = true;

    
    private boolean selectResourcesWithoutInputStream = true;

    
    private boolean delayUpdate = true;


    


    
    private Comparator comparator = null;

    
    private Algorithm algorithm = null;

    
    private Cache cache = null;

    
    private int modified = 0;

    
    private boolean isConfigured = false;

    
    private Vector configParameter = new Vector();

    
    private Vector specialParameter = new Vector();

    
    private ClassLoader myClassLoader = null;

    
    private Path classpath = null;


    


    
    public ModifiedSelector() {
    }


    


    
    public void verifySettings() {
        configure();
        if (cache == null) {
            setError(""Cache must be set."");
        } else if (algorithm == null) {
            setError(""Algorithm must be set."");
        } else if (!cache.isValid()) {
            setError(""Cache must be proper configured."");
        } else if (!algorithm.isValid()) {
            setError(""Algorithm must be proper configured."");
        }
    }


    
    public void configure() {
        
        
        
        if (isConfigured) {
            return;
        }
        isConfigured = true;

        
        
        
        Project p = getProject();
        String filename = ""cache.properties"";
        File cachefile = null;
        if (p != null) {
            
            cachefile = new File(p.getBaseDir(), filename);

            
            getProject().addBuildListener(this);
        } else {
            
            cachefile = new File(filename);
            setDelayUpdate(false);
        }
        Cache      defaultCache      = new PropertiesfileCache(cachefile);
        Algorithm  defaultAlgorithm  = new DigestAlgorithm();
        Comparator defaultComparator = new EqualComparator();
        update = true;
        selectDirectories = true;

        
        
        
        for (Iterator itConfig = configParameter.iterator(); itConfig.hasNext();) {
            Parameter par = (Parameter) itConfig.next();
            if (par.getName().indexOf(""."") > 0) {
                
                specialParameter.add(par);
            } else {
                useParameter(par);
            }
        }
        configParameter = new Vector();

        
        if (algoName != null) {
            
            if (""hashvalue"".equals(algoName.getValue())) {
                algorithm = new HashvalueAlgorithm();
            } else if (""digest"".equals(algoName.getValue())) {
                algorithm = new DigestAlgorithm();
            } else if (""checksum"".equals(algoName.getValue())) {
                algorithm = new ChecksumAlgorithm();
            }
        } else {
            if (algorithmClass != null) {
                
                algorithm = (Algorithm) loadClass(
                    algorithmClass,
                    ""is not an Algorithm."",
                    Algorithm.class);
            } else {
                
                algorithm = defaultAlgorithm;
            }
        }

        
        if (cacheName != null) {
            
            if (""propertyfile"".equals(cacheName.getValue())) {
                cache = new PropertiesfileCache();
            }
        } else {
            if (cacheClass != null) {
                
                cache = (Cache) loadClass(cacheClass, ""is not a Cache."", Cache.class);
            } else {
                
                cache = defaultCache;
            }
        }

        
        if (compName != null) {
            
            if (""equal"".equals(compName.getValue())) {
                comparator = new EqualComparator();
             } else if (""rule"".equals(compName.getValue())) {
                
                
                
                throw new BuildException(""RuleBasedCollator not yet supported."");
                
                
            }
        } else {
            if (comparatorClass != null) {
                
                comparator = (Comparator) loadClass(
                    comparatorClass,
                    ""is not a Comparator."",
                    Comparator.class);
            } else {
                
                comparator = defaultComparator;
            }
        }

        
        
        
        for (Iterator itSpecial = specialParameter.iterator(); itSpecial.hasNext();) {
            Parameter par = (Parameter) itSpecial.next();
            useParameter(par);
        }
        specialParameter = new Vector();
    }


    
    protected Object loadClass(String classname, String msg, Class type) {
        try {
            
            ClassLoader cl = getClassLoader();
            Class clazz = null;
            if (cl != null) {
                clazz = cl.loadClass(classname);
            } else {
                clazz = Class.forName(classname);
            }

            Object rv = clazz.newInstance();

            if (!type.isInstance(rv)) {
                throw new BuildException(""Specified class ("" + classname + "") "" + msg);
            }
            return rv;
        } catch (ClassNotFoundException e) {
            throw new BuildException(""Specified class ("" + classname + "") not found."");
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }


    


    
    public boolean isSelected(Resource resource) {
        if (resource.isFilesystemOnly()) {
            
            
            FileResource fileResource = (FileResource) resource;
            File file = fileResource.getFile();
            String filename = fileResource.getName();
            File basedir = fileResource.getBaseDir();
            return isSelected(basedir, filename, file);
        } else {
            try {
                
                
                FileUtils fu = FileUtils.getFileUtils();
                File tmpFile = fu.createTempFile(""modified-"", "".tmp"", null);
                Resource tmpResource = new FileResource(tmpFile);
                ResourceUtils.copyResource(resource, tmpResource);
                boolean isSelected = isSelected(tmpFile.getParentFile(),
                                                tmpFile.getName(),
                                                resource.toLongString());
                tmpFile.delete();
                return isSelected;
            } catch (UnsupportedOperationException uoe) {
                log(""The resource '""
                  + resource.getName()
                  + ""' does not provide an InputStream, so it is not checked. ""
                  + ""Akkording to 'selres' attribute value it is ""
                  + ((selectResourcesWithoutInputStream) ? """" : "" not"")
                  + ""selected."", Project.MSG_INFO);
                return selectResourcesWithoutInputStream;
            } catch (Exception e) {
                throw new BuildException(e);
            }
        }
    }


    
    public boolean isSelected(File basedir, String filename, File file) {
        return isSelected(basedir, filename, file.getAbsolutePath());
    }


    
    private boolean isSelected(File basedir, String filename, String cacheKey) {
        validate();
        File f = new File(basedir, filename);

        
        if (f.isDirectory()) {
            return selectDirectories;
        }

        
        String cachedValue = String.valueOf(cache.get(f.getAbsolutePath()));
        String newValue = algorithm.getValue(f);

        boolean rv = (comparator.compare(cachedValue, newValue) != 0);

        
        if (update && rv) {
            cache.put(f.getAbsolutePath(), newValue);
            setModified(getModified() + 1);
            if (!getDelayUpdate()) {
                saveCache();
            }
        }

        return rv;
    }


   
    protected void saveCache() {
        if (getModified() > 1) {
            cache.save();
            setModified(0);
        }
    }


    


    
    public void setAlgorithmClass(String classname) {
        algorithmClass = classname;
    }


    
    public void setComparatorClass(String classname) {
        comparatorClass = classname;
    }


    
    public void setCacheClass(String classname) {
        cacheClass = classname;
    }


    
    public void setUpdate(boolean update) {
        this.update = update;
    }


    
    public void setSeldirs(boolean seldirs) {
        selectDirectories = seldirs;
    }


    
    public void setSelres(boolean newValue) {
        this.selectResourcesWithoutInputStream = newValue;
    }


    
    public int getModified() {
        return modified;
    }


    
    public void setModified(int modified) {
        this.modified = modified;
    }


    
    public boolean getDelayUpdate() {
        return delayUpdate;
    }


    
    public void setDelayUpdate(boolean delayUpdate) {
        this.delayUpdate = delayUpdate;
    }


    
    public void addClasspath(Path path) {
        if (classpath != null) {
            throw new BuildException(""<classpath> can be set only once."");
        }
        classpath = path;
    }


    
    public ClassLoader getClassLoader() {
        if (myClassLoader == null) {
            myClassLoader = (classpath == null)
                
                ? getClass().getClassLoader()
                
                : getProject().createClassLoader(classpath);
        }
        return myClassLoader;
    }


    
    public void setClassLoader(ClassLoader loader) {
        myClassLoader = loader;
    }


    
    public void addParam(String key, Object value) {
        Parameter par = new Parameter();
        par.setName(key);
        par.setValue(String.valueOf(value));
        configParameter.add(par);
    }


    
    public void addParam(Parameter parameter) {
        configParameter.add(parameter);
    }


    
    public void setParameters(Parameter[] parameters) {
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                configParameter.add(parameters[i]);
            }
        }
    }


    
    public void useParameter(Parameter parameter) {
        String key = parameter.getName();
        String value = parameter.getValue();
        if (""cache"".equals(key)) {
            CacheName cn = new CacheName();
            cn.setValue(value);
            setCache(cn);
        } else if (""algorithm"".equals(key)) {
            AlgorithmName an = new AlgorithmName();
            an.setValue(value);
            setAlgorithm(an);
        } else if (""comparator"".equals(key)) {
            ComparatorName cn = new ComparatorName();
            cn.setValue(value);
            setComparator(cn);
        } else if (""update"".equals(key)) {
            boolean updateValue =
                (""true"".equalsIgnoreCase(value))
                ? true
                : false;
            setUpdate(updateValue);
        } else if (""delayupdate"".equals(key)) {
            boolean updateValue =
                (""true"".equalsIgnoreCase(value))
                ? true
                : false;
            setDelayUpdate(updateValue);
        } else if (""seldirs"".equals(key)) {
            boolean sdValue =
                (""true"".equalsIgnoreCase(value))
                ? true
                : false;
            setSeldirs(sdValue);
        } else if (key.startsWith(""cache."")) {
            String name = key.substring(6);
            tryToSetAParameter(cache, name, value);
        } else if (key.startsWith(""algorithm."")) {
            String name = key.substring(10);
            tryToSetAParameter(algorithm, name, value);
        } else if (key.startsWith(""comparator."")) {
            String name = key.substring(11);
            tryToSetAParameter(comparator, name, value);
        } else {
            setError(""Invalid parameter "" + key);
        }
    }


    
    protected void tryToSetAParameter(Object obj, String name, String value) {
        Project prj = (getProject() != null) ? getProject() : new Project();
        IntrospectionHelper iHelper
            = IntrospectionHelper.getHelper(prj, obj.getClass());
        try {
            iHelper.setAttribute(prj, obj, name, value);
        } catch (org.apache.tools.ant.BuildException e) {
            
        }
    }


    


    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{modifiedselector"");
        buf.append("" update="").append(update);
        buf.append("" seldirs="").append(selectDirectories);
        buf.append("" cache="").append(cache);
        buf.append("" algorithm="").append(algorithm);
        buf.append("" comparator="").append(comparator);
        buf.append(""}"");
        return buf.toString();
    }


    


    
    public void buildFinished(BuildEvent event) {
        if (getDelayUpdate()) {
            saveCache();
        }
    }


    
    public void targetFinished(BuildEvent event) {
        if (getDelayUpdate()) {
            saveCache();
        }
    }


    
    public void taskFinished(BuildEvent event) {
        if (getDelayUpdate()) {
            saveCache();
        }
    }


    
    public void buildStarted(BuildEvent event) {
        
    }


    
    public void targetStarted(BuildEvent event) {
        
    }



    
    public void taskStarted(BuildEvent event) {
        
    }


    
    public void messageLogged(BuildEvent event) {
        
    }


    
    


    
    public Cache getCache() { return cache; }

    
    public void setCache(CacheName name) {
        cacheName = name;
    }

    
    public static class CacheName extends EnumeratedAttribute {
        
        
        public String[] getValues() {
            return new String[] {""propertyfile"" };
        }
    }

    
    public Algorithm getAlgorithm() { return algorithm; }

    
    public void setAlgorithm(AlgorithmName name) {
        algoName = name;
    }

    
    public static class AlgorithmName extends EnumeratedAttribute {
        
        
        public String[] getValues() {
            return new String[] {""hashvalue"", ""digest"", ""checksum"" };
        }
    }

    
    public Comparator getComparator() { return comparator; }

    
    public void setComparator(ComparatorName name) {
        compName = name;
    }

    
    public static class ComparatorName extends EnumeratedAttribute {
        
        
        public String[] getValues() {
            return new String[] {""equal"", ""rule"" };
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.AntAnalyzer,3,2,0,3,36,3,1,2,1,2.0,241,0.0,0,0.882352941,0.666666667,1,2,79.33333333,18,6.3333,1,"
package org.apache.tools.ant.taskdefs.optional.depend;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.apache.tools.ant.util.depend.AbstractAnalyzer;


public class AntAnalyzer extends AbstractAnalyzer {
    
    public AntAnalyzer() {
    }

    
    protected void determineDependencies(Vector files, Vector classes) {
        
        
        Hashtable dependencies = new Hashtable();
        Hashtable containers = new Hashtable();
        Hashtable toAnalyze = new Hashtable();
        for (Enumeration e = getRootClasses(); e.hasMoreElements();) {
            String classname = (String) e.nextElement();
            toAnalyze.put(classname, classname);
        }

        int count = 0;
        int maxCount = isClosureRequired() ? MAX_LOOPS : 1;
        Hashtable analyzedDeps = null;
        while (toAnalyze.size() != 0 && count++ < maxCount) {
            analyzedDeps = new Hashtable();
            for (Enumeration e = toAnalyze.keys(); e.hasMoreElements();) {
                String classname = (String) e.nextElement();
                dependencies.put(classname, classname);
                try {
                    File container = getClassContainer(classname);
                    if (container == null) {
                        continue;
                    }
                    containers.put(container, container);

                    ZipFile zipFile = null;
                    InputStream inStream = null;
                    try {
                        if (container.getName().endsWith("".class"")) {
                            inStream = new FileInputStream(container.getPath());
                        } else {
                            zipFile = new ZipFile(container.getPath());
                            String entryName
                                = classname.replace('.', '/') + "".class"";
                            ZipEntry entry = new ZipEntry(entryName);
                            inStream
                                = zipFile.getInputStream(entry);
                        }
                        ClassFile classFile = new ClassFile();
                        classFile.read(inStream);
                        Vector dependencyList = classFile.getClassRefs();
                        Enumeration depEnum = dependencyList.elements();
                        while (depEnum.hasMoreElements()) {
                            String dependency = (String) depEnum.nextElement();
                            analyzedDeps.put(dependency, dependency);
                        }
                    } finally {
                        if (inStream != null) {
                            inStream.close();
                        }
                        if (zipFile != null) {
                            zipFile.close();
                        }
                    }
                } catch (IOException ioe) {
                    
                }
            }

            toAnalyze.clear();

            
            Enumeration depsEnum = analyzedDeps.elements();
            while (depsEnum.hasMoreElements()) {
                String className = (String) depsEnum.nextElement();
                if (!dependencies.containsKey(className)) {
                    toAnalyze.put(className, className);
                }
            }
        }

        
        Enumeration depsEnum = analyzedDeps.elements();
        while (depsEnum.hasMoreElements()) {
            String className = (String) depsEnum.nextElement();
            dependencies.put(className, className);
        }

        files.removeAllElements();
        for (Enumeration e = containers.keys(); e.hasMoreElements();) {
            files.addElement((File) e.nextElement());
        }

        classes.removeAllElements();
        for (Enumeration e = dependencies.keys(); e.hasMoreElements();) {
            classes.addElement((String) e.nextElement());
        }
    }

    
    protected boolean supportsFileDependencies() {
        return true;
    }

}

"
org.apache.tools.ant.taskdefs.condition.ConditionBase,25,2,7,27,38,0,8,22,21,0.666666667,198,1.0,0,0.28125,0.092,0,0,6.8,2,0.96,0,"

package org.apache.tools.ant.taskdefs.condition;

import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.DynamicElement;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.taskdefs.Available;
import org.apache.tools.ant.taskdefs.Checksum;
import org.apache.tools.ant.taskdefs.UpToDate;


public abstract class ConditionBase extends ProjectComponent
    implements DynamicElement {

    private static final String CONDITION_ANTLIB
        = ""antlib:org.apache.tools.ant.types.conditions:"";

    
    private String taskName = ""condition"";

    
    private Vector conditions = new Vector();

    
    protected ConditionBase() {
        taskName = ""component"";
    }

    
    protected ConditionBase(String taskName) {
        this.taskName = taskName;
    }

    
    protected int countConditions() {
        return conditions.size();
    }

    
    protected final Enumeration getConditions() {
        return conditions.elements();
    }

    
    public void setTaskName(String name) {
        this.taskName = name;
    }

    
    public String getTaskName() {
        return taskName;
    }

    
    public void addAvailable(Available a) {
        conditions.addElement(a);
    }

    
    public void addChecksum(Checksum c) {
        conditions.addElement(c);
    }

    
    public void addUptodate(UpToDate u) {
        conditions.addElement(u);
    }

    
    public void addNot(Not n) {
        conditions.addElement(n);
    }

    
    public void addAnd(And a) {
        conditions.addElement(a);
    }

    
    public void addOr(Or o) {
        conditions.addElement(o);
    }

    
    public void addEquals(Equals e) {
        conditions.addElement(e);
    }

    
    public void addOs(Os o) {
        conditions.addElement(o);
    }

    
    public void addIsSet(IsSet i) {
        conditions.addElement(i);
    }

    
    public void addHttp(Http h) {
        conditions.addElement(h);
    }

    
    public void addSocket(Socket s) {
        conditions.addElement(s);
    }

    
    public void addFilesMatch(FilesMatch test) {
        conditions.addElement(test);
    }

    
    public void addContains(Contains test) {
        conditions.addElement(test);
    }

    
    public void addIsTrue(IsTrue test) {
        conditions.addElement(test);
    }

    
    public void addIsFalse(IsFalse test) {
        conditions.addElement(test);
    }

    
    public void addIsReference(IsReference i) {
        conditions.addElement(i);
    }

    
    public void addIsFileSelected(IsFileSelected test) {
        conditions.addElement(test);
    }

    
    public void add(Condition c) {
        conditions.addElement(c);
    }

    
    public Object createDynamicElement(String name) {
        Object cond = ComponentHelper.getComponentHelper(getProject())
            .createComponent(CONDITION_ANTLIB + name);
        if (!(cond instanceof Condition)) {
            return null;
        }
        log(""Dynamically discovered '"" + name + ""' "" + cond,
            Project.MSG_DEBUG);
        add((Condition) cond);
        return cond;
    }

}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Integrate,26,4,0,4,34,203,0,4,26,0.88,399,1.0,0,0.671052632,0.487179487,1,1,13.88461538,1,0.9615,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;



public class P4Integrate extends P4Base {

    private String change = null;
    private String fromfile = null;
    private String tofile = null;
    private String branch = null;
    private boolean restoredeletedrevisions = false;
    private boolean forceintegrate = false;
    private boolean leavetargetrevision = false;
    private boolean enablebaselessmerges = false;
    private boolean simulationmode = false;
    private boolean reversebranchmappings = false;
    private boolean propagatesourcefiletype = false;
    private boolean nocopynewtargetfiles = false;

    
    public String getChange() {
        return change;
    }

    
    public void setChange(String change) {
        this.change = change;
    }

    
    public String getFromfile() {
        return fromfile;
    }

    
    public void setFromfile(String fromf) {
        this.fromfile = fromf;
    }

    
    public String getTofile() {
        return tofile;
    }

    
    public void setTofile(String tof) {
        this.tofile = tof;
    }

    
    public String getBranch() {
        return branch;
    }

    
    public void setBranch(String br) {
        this.branch = br;
    }

    
    public boolean isRestoreDeletedRevisions() {
        return restoredeletedrevisions;
    }

    
    public void setRestoreDeletedRevisions(boolean setrest) {
        this.restoredeletedrevisions = setrest;
    }

    
    public boolean isForceIntegrate() {
        return forceintegrate;
    }

    
    public void setForceIntegrate(boolean setrest) {
        this.forceintegrate = setrest;
    }

    
    public boolean isLeaveTargetRevision() {
        return leavetargetrevision;
    }

    
    public void setLeaveTargetRevision(boolean setrest) {
        this.leavetargetrevision = setrest;
    }

    
    public boolean isEnableBaselessMerges() {
        return enablebaselessmerges;
    }

    
    public void setEnableBaselessMerges(boolean setrest) {
        this.enablebaselessmerges = setrest;
    }

    
    public boolean isSimulationMode() {
        return simulationmode;
    }

    
    public void setSimulationMode(boolean setrest) {
        this.simulationmode = setrest;
    }
    
    public boolean isReversebranchmappings() {
        return reversebranchmappings;
    }

    
    public void setReversebranchmappings(boolean reversebranchmappings) {
        this.reversebranchmappings = reversebranchmappings;
    }
    
    public boolean isPropagatesourcefiletype() {
        return propagatesourcefiletype;
    }
    
    public void setPropagatesourcefiletype(boolean propagatesourcefiletype) {
        this.propagatesourcefiletype = propagatesourcefiletype;
    }
    
    public boolean isNocopynewtargetfiles() {
        return nocopynewtargetfiles;
    }

    
    public void setNocopynewtargetfiles(boolean nocopynewtargetfiles) {
        this.nocopynewtargetfiles = nocopynewtargetfiles;
    }

    
    public void execute() throws BuildException {
        if (change != null) {
            P4CmdOpts = ""-c "" + change;
        }
        if (this.forceintegrate) {
            P4CmdOpts = P4CmdOpts + "" -f"";
        }
        if (this.restoredeletedrevisions) {
                P4CmdOpts = P4CmdOpts + "" -d"";
            }
        if (this.leavetargetrevision) {
            P4CmdOpts = P4CmdOpts + "" -h"";
        }
        if (this.enablebaselessmerges) {
            P4CmdOpts = P4CmdOpts + "" -i"";
        }
        if (this.simulationmode) {
            P4CmdOpts = P4CmdOpts + "" -n"";
        }
        if (this.reversebranchmappings) {
            P4CmdOpts = P4CmdOpts + "" -r"";
        }
        if (this.propagatesourcefiletype) {
            P4CmdOpts = P4CmdOpts + "" -t"";
        }
        if (this.nocopynewtargetfiles) {
            P4CmdOpts = P4CmdOpts + ""-v"";
        }
        String command;
        if (branch == null && fromfile != null && tofile != null) {
           command = P4CmdOpts + "" "" + fromfile + "" "" + tofile;
        } else if (branch != null && fromfile == null && tofile != null) {
            command = P4CmdOpts + "" -b "" + branch + "" "" + tofile;
        } else if (branch != null && fromfile != null) {
            command = P4CmdOpts + "" -b "" + branch + "" -s "" + fromfile + "" "" + tofile;
        } else {
            throw new BuildException(""you need to specify fromfile and tofile, ""
            + ""or branch and tofile, or branch and fromfile, or branch and fromfile and tofile "");
        }
        execP4Command(""-s integrate "" + command, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.util.ReflectUtil,6,1,0,4,15,15,3,1,5,2.0,125,0.0,0,0.0,0.4,0,0,19.83333333,1,0.8333,1,"
package org.apache.tools.ant.util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.tools.ant.BuildException;
import java.lang.reflect.Field;



public class ReflectUtil {

    
    private ReflectUtil() {
    }

    
    public static Object invoke(Object obj, String methodName) {
        try {
            Method method;
            method = obj.getClass().getMethod(
                methodName, (Class[]) null);
            return method.invoke(obj, (Object[]) null);
        } catch (Exception t) {
            throwBuildException(t);
            return null; 
        }
    }

    
    public static Object invoke(
        Object obj, String methodName, Class argType, Object arg) {
        try {
            Method method;
            method = obj.getClass().getMethod(
                methodName, new Class[] {argType});
            return method.invoke(obj, new Object[] {arg});
        } catch (Exception t) {
            throwBuildException(t);
            return null; 
        }
    }

    
    public static Object invoke(
        Object obj, String methodName, Class argType1, Object arg1,
        Class argType2, Object arg2) {
        try {
            Method method;
            method = obj.getClass().getMethod(
                methodName, new Class[] {argType1, argType2});
            return method.invoke(obj, new Object[] {arg1, arg2});
        } catch (Exception t) {
            throwBuildException(t);
            return null; 
        }
    }

    
    public static Object getField(Object obj, String fieldName)
        throws BuildException {
        try {
            Field field = obj.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            return field.get(obj);
        } catch (Exception t) {
            throwBuildException(t);
            return null; 
        }
    }

    
    public static void throwBuildException(Exception t)
        throws BuildException {
        if (t instanceof InvocationTargetException) {
            Throwable t2 = ((InvocationTargetException) t)
                .getTargetException();
            if (t2 instanceof BuildException) {
                throw (BuildException) t2;
            }
            throw new BuildException(t2);
        } else {
            throw new BuildException(t);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ccm.CCMCreateTask,20,4,0,7,52,154,0,7,19,0.942982456,377,0.5,0,0.693548387,0.3,2,2,17.25,6,1.2,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
import org.apache.tools.ant.types.Commandline;



public class CCMCreateTask extends Continuus implements ExecuteStreamHandler {

    private String comment = null;
    private String platform = null;
    private String resolver = null;
    private String release = null;
    private String subSystem = null;
    private String task = null;

    
    public CCMCreateTask() {
        super();
        setCcmAction(COMMAND_CREATE_TASK);
    }


    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        int result = 0;

        
        
        commandLine.setExecutable(getCcmCommand());
        commandLine.createArgument().setValue(getCcmAction());

        checkOptions(commandLine);

        result = run(commandLine, this);
        if (Execute.isFailure(result)) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }

        
        Commandline commandLine2 = new Commandline();
        commandLine2.setExecutable(getCcmCommand());
        commandLine2.createArgument().setValue(COMMAND_DEFAULT_TASK);
        commandLine2.createArgument().setValue(getTask());

        log(commandLine.describeCommand(), Project.MSG_DEBUG);

        result = run(commandLine2);
        if (result != 0) {
            String msg = ""Failed executing: "" + commandLine2.toString();
            throw new BuildException(msg, getLocation());
        }

    }


    
    private void checkOptions(Commandline cmd) {
        if (getComment() != null) {
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(""\"""" + getComment() + ""\"""");
        }

        if (getPlatform() != null) {
            cmd.createArgument().setValue(FLAG_PLATFORM);
            cmd.createArgument().setValue(getPlatform());
        } 

        if (getResolver() != null) {
            cmd.createArgument().setValue(FLAG_RESOLVER);
            cmd.createArgument().setValue(getResolver());
        } 

        if (getSubSystem() != null) {
            cmd.createArgument().setValue(FLAG_SUBSYSTEM);
            cmd.createArgument().setValue(""\"""" + getSubSystem() + ""\"""");
        } 

        if (getRelease() != null) {
            cmd.createArgument().setValue(FLAG_RELEASE);
            cmd.createArgument().setValue(getRelease());
        } 
    }


    
    public String getComment() {
        return comment;
    }

    
    public void setComment(String v) {
        this.comment = v;
    }


    
    public String getPlatform() {
        return platform;
    }

    
    public void setPlatform(String v) {
        this.platform = v;
    }


    
    public String getResolver() {
        return resolver;
    }

    
    public void setResolver(String v) {
        this.resolver = v;
    }


    
    public String getRelease() {
        return release;
    }

    
    public void setRelease(String v) {
        this.release = v;
    }

    
    public String getSubSystem() {
        return subSystem;
    }

    
    public void setSubSystem(String v) {
        this.subSystem = v;
    }


    
    public String getTask() {
        return task;
    }

    
    public void setTask(String v) {
        this.task = v;
    }

    
    public static final String FLAG_COMMENT = ""/synopsis"";

    
    public static final String FLAG_PLATFORM = ""/plat"";

    
    public static final String FLAG_RESOLVER = ""/resolver"";

    
    public static final String FLAG_RELEASE = ""/release"";

    
    public static final String FLAG_SUBSYSTEM = ""/subsystem"";

    
    public static final String FLAG_TASK = ""/task"";


    

    
    public void start() throws IOException {
    }

    
    public void stop() {
    }

    
    public void setProcessInputStream(OutputStream param1) throws IOException {
    }

    
    public void setProcessErrorStream(InputStream is) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        String s = reader.readLine();
        if (s != null) {
            log(""err "" + s, Project.MSG_DEBUG);
        } 
    }

    
    public void setProcessOutputStream(InputStream is) throws IOException {

        String buffer = """";
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            buffer = reader.readLine();
            if (buffer != null) {
                log(""buffer:"" + buffer, Project.MSG_DEBUG);
                String taskstring = buffer.substring(buffer.indexOf(' ')).trim();
                taskstring = taskstring.substring(0, taskstring.lastIndexOf(' ')).trim();
                setTask(taskstring);
                log(""task is "" + getTask(), Project.MSG_DEBUG);
            } 
        } catch (NullPointerException npe) {
            log(""error procession stream , null pointer exception"", Project.MSG_ERR);
            npe.printStackTrace();
            throw new BuildException(npe.getClass().getName());
        } catch (Exception e) {
            log(""error procession stream "" + e.getMessage(), Project.MSG_ERR);
            throw new BuildException(e.getMessage());
        } 

    }

}

"
org.apache.tools.ant.taskdefs.Get,11,3,0,9,54,15,1,8,10,0.7375,493,1.0,1,0.804347826,0.271428571,1,1,43.09090909,1,0.8182,3,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Date;


public class Get extends Task {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private URL source; 
    private File dest; 
    private boolean verbose = false;
    private boolean useTimestamp = false; 
    private boolean ignoreErrors = false;
    private String uname = null;
    private String pword = null;



    
    public void execute() throws BuildException {

        
        int logLevel = Project.MSG_INFO;
        DownloadProgress progress = null;
        if (verbose) {
            progress = new VerboseProgress(System.out);
        }

        
        try {
            doGet(logLevel, progress);
        } catch (IOException ioe) {
            log(""Error getting "" + source + "" to "" + dest);
            if (!ignoreErrors) {
                throw new BuildException(ioe, getLocation());
            }
        }
    }

    
    public boolean doGet(int logLevel, DownloadProgress progress)
            throws IOException {
        if (source == null) {
            throw new BuildException(""src attribute is required"", getLocation());
        }

        if (dest == null) {
            throw new BuildException(""dest attribute is required"", getLocation());
        }

        if (dest.exists() && dest.isDirectory()) {
            throw new BuildException(""The specified destination is a directory"",
                    getLocation());
        }

        if (dest.exists() && !dest.canWrite()) {
            throw new BuildException(""Can't write to "" + dest.getAbsolutePath(),
                    getLocation());
        }
        
        if (progress == null) {
            progress = new NullProgress();
        }
        log(""Getting: "" + source, logLevel);
        log(""To: "" + dest.getAbsolutePath(), logLevel);

        
        long timestamp = 0;

        boolean hasTimestamp = false;
        if (useTimestamp && dest.exists()) {
            timestamp = dest.lastModified();
            if (verbose) {
                Date t = new Date(timestamp);
                log(""local file date : "" + t.toString(), logLevel);
            }
            hasTimestamp = true;
        }

        
        URLConnection connection = source.openConnection();
        
        
        if (hasTimestamp) {
            connection.setIfModifiedSince(timestamp);
        }
        
        if (uname != null || pword != null) {
            String up = uname + "":"" + pword;
            String encoding;
            
            
            
            Base64Converter encoder = new Base64Converter();
            encoding = encoder.encode(up.getBytes());
            connection.setRequestProperty (""Authorization"",
                    ""Basic "" + encoding);
        }

        
        connection.connect();
        
        if (connection instanceof HttpURLConnection) {
            HttpURLConnection httpConnection
                    = (HttpURLConnection) connection;
            long lastModified = httpConnection.getLastModified();
            if (httpConnection.getResponseCode()
                    == HttpURLConnection.HTTP_NOT_MODIFIED
                || (lastModified != 0 && hasTimestamp
                && timestamp >= lastModified)) {
                
                
                
                
                log(""Not modified - so not downloaded"", logLevel);
                return false;
            }
            
            if (httpConnection.getResponseCode()
                    == HttpURLConnection.HTTP_UNAUTHORIZED)  {
                String message = ""HTTP Authorization failure"";
                if (ignoreErrors) {
                    log(message, logLevel);
                    return false;
                } else {
                    throw new BuildException(message);
                }
            }

        }

        
        
        
        
        

        InputStream is = null;
        for (int i = 0; i < 3; i++) {
            
            
            
            try {
                is = connection.getInputStream();
                break;
            } catch (IOException ex) {
                log(""Error opening connection "" + ex, logLevel);
            }
        }
        if (is == null) {
            log(""Can't get "" + source + "" to "" + dest, logLevel);
            if (ignoreErrors) {
                return false;
            }
            throw new BuildException(""Can't get "" + source + "" to "" + dest,
                    getLocation());
        }

        FileOutputStream fos = new FileOutputStream(dest);
        progress.beginDownload();
        boolean finished = false;
        try {
            byte[] buffer = new byte[100 * 1024];
            int length;
            while ((length = is.read(buffer)) >= 0) {
                fos.write(buffer, 0, length);
                progress.onTick();
            }
            finished = true;
        } finally {
            FileUtils.close(fos);
            FileUtils.close(is);

            
            
            
            if (!finished) {
                dest.delete();
            }
        }
        progress.endDownload();

        
        
        
        if (useTimestamp)  {
            long remoteTimestamp = connection.getLastModified();
            if (verbose)  {
                Date t = new Date(remoteTimestamp);
                log(""last modified = "" + t.toString()
                        + ((remoteTimestamp == 0)
                        ? "" - using current time instead""
                        : """"), logLevel);
            }
            if (remoteTimestamp != 0) {
                FILE_UTILS.setFileLastModified(dest, remoteTimestamp);
            }
        }

        
        return true;
    }


    
    public void setSrc(URL u) {
        this.source = u;
    }

    
    public void setDest(File dest) {
        this.dest = dest;
    }

    
    public void setVerbose(boolean v) {
        verbose = v;
    }

    
    public void setIgnoreErrors(boolean v) {
        ignoreErrors = v;
    }

    
    public void setUseTimestamp(boolean v) {
        useTimestamp = v;
    }


    
    public void setUsername(String u) {
        this.uname = u;
    }

    
    public void setPassword(String p) {
        this.pword = p;
    }

    
    protected static class Base64Converter
        extends org.apache.tools.ant.util.Base64Converter {
    }

    
    public interface DownloadProgress {
        
        void beginDownload();

        
        void onTick();

        
        void endDownload();
    }

    
    public static class NullProgress implements DownloadProgress {

        
        public void beginDownload() {

        }

        
        public void onTick() {
        }

        
        public void endDownload() {

        }
    }

    
    public static class VerboseProgress implements DownloadProgress  {
        private int dots = 0;
        
        PrintStream out;
        

        
        public VerboseProgress(PrintStream out) {
            this.out = out;
        }

        
        public void beginDownload() {
            dots = 0;
        }

        
        public void onTick() {
            out.print(""."");
            if (dots++ > 50) {
                out.flush();
                dots = 0;
            }
        }

        
        public void endDownload() {
            out.println();
            out.flush();
        }
    }

}
"
org.apache.tools.ant.util.RetryHandler,2,1,0,2,9,0,0,2,2,0.0,74,1.0,1,0.0,0.6,0,0,35.0,1,0.5,0,"
package org.apache.tools.ant.util;

import java.io.IOException;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;


public class RetryHandler {

    private int retriesAllowed = 0;
    private Task task;

    
    public RetryHandler(int retriesAllowed, Task task) {
        this.retriesAllowed = retriesAllowed;
        this.task = task;
    }

    
    public void execute(Retryable exe, String desc) throws IOException {
        int retries = 0;
        while (true) {
            try {
                exe.execute();
                break;
            } catch (IOException e) {
                retries++;
                if (retries > this.retriesAllowed && this.retriesAllowed > -1) {
                    task.log(""try #"" + retries + "": IO error (""
                            + desc + ""), number of maximum retries reached (""
                            + this.retriesAllowed + ""), giving up"", Project.MSG_WARN);
                    throw e;
                } else {
                    task.log(""try #"" + retries + "": IO error ("" + desc
                             + ""), retrying"", Project.MSG_WARN);
                }
            }
        }
    }

}
"
org.apache.tools.ant.types.mappers.FilterMapper,4,4,0,7,19,6,0,7,4,2.0,74,0.0,0,0.947368421,0.875,0,0,17.5,2,1.0,0,"

package org.apache.tools.ant.types.mappers;

import java.io.StringReader;
import java.io.Reader;

import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.UnsupportedAttributeException;
import org.apache.tools.ant.filters.util.ChainReaderHelper;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;


public class FilterMapper extends FilterChain implements FileNameMapper {
    
    public void setFrom(String from) {
        throw new UnsupportedAttributeException(
            ""filtermapper doesn't support the \""from\"" attribute."", ""from"");
    }

    
    public void setTo(String to) {
        throw new UnsupportedAttributeException(
            ""filtermapper doesn't support the \""to\"" attribute."", ""to"");
    }

    
    public String[] mapFileName(String sourceFileName) {
        try {
            Reader stringReader = new StringReader(sourceFileName);
            ChainReaderHelper helper = new ChainReaderHelper();
            helper.setBufferSize(8192);
            helper.setPrimaryReader(stringReader);
            helper.setProject(getProject());
            Vector filterChains = new Vector();
            filterChains.add(this);
            helper.setFilterChains(filterChains);
            String result = FileUtils.readFully(helper.getAssembledReader());
            if (result.length() == 0) {
                return null;
            } else {
                return new String[] {result};
            }
        } catch (BuildException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new BuildException(ex);
        }
    }
}
"
org.apache.tools.zip.ZipFile,17,1,0,13,73,82,8,6,10,0.8203125,598,1.0,0,0.0,0.183823529,0,0,33.70588235,3,0.9412,7,"

package org.apache.tools.zip;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipException;


public class ZipFile {

    
    private Hashtable entries = new Hashtable(509);

    
    private Hashtable nameMap = new Hashtable(509);

    private static final class OffsetEntry {
        private long headerOffset = -1;
        private long dataOffset = -1;
    }

    
    private String encoding = null;

    
    private RandomAccessFile archive;

    
    public ZipFile(File f) throws IOException {
        this(f, null);
    }

    
    public ZipFile(String name) throws IOException {
        this(new File(name), null);
    }

    
    public ZipFile(String name, String encoding) throws IOException {
        this(new File(name), encoding);
    }

    
    public ZipFile(File f, String encoding) throws IOException {
        this.encoding = encoding;
        archive = new RandomAccessFile(f, ""r"");
        try {
            populateFromCentralDirectory();
            resolveLocalFileHeaderData();
        } catch (IOException e) {
            try {
                archive.close();
            } catch (IOException e2) {
                
            }
            throw e;
        }
    }

    
    public String getEncoding() {
        return encoding;
    }

    
    public void close() throws IOException {
        archive.close();
    }

    
    public static void closeQuietly(ZipFile zipfile) {
        if (zipfile != null) {
            try {
                zipfile.close();
            } catch (IOException e) {
                
            }
        }
    }

    
    public Enumeration getEntries() {
        return entries.keys();
    }

    
    public ZipEntry getEntry(String name) {
        return (ZipEntry) nameMap.get(name);
    }

    
    public InputStream getInputStream(ZipEntry ze)
        throws IOException, ZipException {
        OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);
        if (offsetEntry == null) {
            return null;
        }
        long start = offsetEntry.dataOffset;
        BoundedInputStream bis =
            new BoundedInputStream(start, ze.getCompressedSize());
        switch (ze.getMethod()) {
            case ZipEntry.STORED:
                return bis;
            case ZipEntry.DEFLATED:
                bis.addDummy();
                return new InflaterInputStream(bis, new Inflater(true));
            default:
                throw new ZipException(""Found unsupported compression method ""
                                       + ze.getMethod());
        }
    }

    private static final int CFH_LEN =
         2
         + 2
         + 2
         + 2
         + 2
         + 2
         + 4
         + 4
         + 4
         + 2
         + 2
         + 2
         + 2
         + 2
         + 4
         + 4;

    
    private void populateFromCentralDirectory()
        throws IOException {
        positionAtCentralDirectory();

        byte[] cfh = new byte[CFH_LEN];

        byte[] signatureBytes = new byte[4];
        archive.readFully(signatureBytes);
        long sig = ZipLong.getValue(signatureBytes);
        final long cfhSig = ZipLong.getValue(ZipOutputStream.CFH_SIG);
        while (sig == cfhSig) {
            archive.readFully(cfh);
            int off = 0;
            ZipEntry ze = new ZipEntry();

            int versionMadeBy = ZipShort.getValue(cfh, off);
            off += 2;
            ze.setPlatform((versionMadeBy >> 8) & 0x0F);

            off += 4; 

            ze.setMethod(ZipShort.getValue(cfh, off));
            off += 2;

            
            
            
            long time = dosToJavaTime(ZipLong.getValue(cfh, off));
            ze.setTime(time);
            off += 4;

            ze.setCrc(ZipLong.getValue(cfh, off));
            off += 4;

            ze.setCompressedSize(ZipLong.getValue(cfh, off));
            off += 4;

            ze.setSize(ZipLong.getValue(cfh, off));
            off += 4;

            int fileNameLen = ZipShort.getValue(cfh, off);
            off += 2;

            int extraLen = ZipShort.getValue(cfh, off);
            off += 2;

            int commentLen = ZipShort.getValue(cfh, off);
            off += 2;

            off += 2; 

            ze.setInternalAttributes(ZipShort.getValue(cfh, off));
            off += 2;

            ze.setExternalAttributes(ZipLong.getValue(cfh, off));
            off += 4;

            byte[] fileName = new byte[fileNameLen];
            archive.readFully(fileName);
            ze.setName(getString(fileName));


            
            OffsetEntry offset = new OffsetEntry();
            offset.headerOffset = ZipLong.getValue(cfh, off);
            
            entries.put(ze, offset);

            nameMap.put(ze.getName(), ze);

            archive.skipBytes(extraLen);

            byte[] comment = new byte[commentLen];
            archive.readFully(comment);
            ze.setComment(getString(comment));

            archive.readFully(signatureBytes);
            sig = ZipLong.getValue(signatureBytes);
        }
    }

    private static final int MIN_EOCD_SIZE =
         4
         + 2
        
         + 2
        
         + 2
        
         + 2
         + 4
        
        
         + 4
         + 2;

    private static final int CFD_LOCATOR_OFFSET =
         4
         + 2
        
         + 2
        
         + 2
        
         + 2
         + 4;

    
    private void positionAtCentralDirectory()
        throws IOException {
        boolean found = false;
        long off = archive.length() - MIN_EOCD_SIZE;
        if (off >= 0) {
            archive.seek(off);
            byte[] sig = ZipOutputStream.EOCD_SIG;
            int curr = archive.read();
            while (curr != -1) {
                if (curr == sig[0]) {
                    curr = archive.read();
                    if (curr == sig[1]) {
                        curr = archive.read();
                        if (curr == sig[2]) {
                            curr = archive.read();
                            if (curr == sig[3]) {
                                found = true;
                                break;
                            }
                        }
                    }
                }
                archive.seek(--off);
                curr = archive.read();
            }
        }
        if (!found) {
            throw new ZipException(""archive is not a ZIP archive"");
        }
        archive.seek(off + CFD_LOCATOR_OFFSET);
        byte[] cfdOffset = new byte[4];
        archive.readFully(cfdOffset);
        archive.seek(ZipLong.getValue(cfdOffset));
    }

    
    private static final long LFH_OFFSET_FOR_FILENAME_LENGTH =
         4
         + 2
         + 2
         + 2
         + 2
         + 2
         + 4
         + 4
         + 4;

    
    private void resolveLocalFileHeaderData()
        throws IOException {
        Enumeration e = getEntries();
        while (e.hasMoreElements()) {
            ZipEntry ze = (ZipEntry) e.nextElement();
            OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);
            long offset = offsetEntry.headerOffset;
            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
            byte[] b = new byte[2];
            archive.readFully(b);
            int fileNameLen = ZipShort.getValue(b);
            archive.readFully(b);
            int extraFieldLen = ZipShort.getValue(b);
            archive.skipBytes(fileNameLen);
            byte[] localExtraData = new byte[extraFieldLen];
            archive.readFully(localExtraData);
            ze.setExtra(localExtraData);
            
            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH
                                     + 2 + 2 + fileNameLen + extraFieldLen;
        }
    }

    
    protected static Date fromDosTime(ZipLong zipDosTime) {
        long dosTime = zipDosTime.getValue();
        return new Date(dosToJavaTime(dosTime));
    }

    
    private static long dosToJavaTime(long dosTime) {
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);
        cal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);
        cal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);
        cal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);
        cal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);
        cal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);
        return cal.getTime().getTime();
    }


    
    protected String getString(byte[] bytes) throws ZipException {
        if (encoding == null) {
            return new String(bytes);
        } else {
            try {
                return new String(bytes, encoding);
            } catch (UnsupportedEncodingException uee) {
                throw new ZipException(uee.getMessage());
            }
        }
    }

    
    private class BoundedInputStream extends InputStream {
        private long remaining;
        private long loc;
        private boolean addDummyByte = false;

        BoundedInputStream(long start, long remaining) {
            this.remaining = remaining;
            loc = start;
        }

        public int read() throws IOException {
            if (remaining-- <= 0) {
                if (addDummyByte) {
                    addDummyByte = false;
                    return 0;
                }
                return -1;
            }
            synchronized (archive) {
                archive.seek(loc++);
                return archive.read();
            }
        }

        public int read(byte[] b, int off, int len) throws IOException {
            if (remaining <= 0) {
                if (addDummyByte) {
                    addDummyByte = false;
                    b[off] = 0;
                    return 1;
                }
                return -1;
            }

            if (len <= 0) {
                return 0;
            }

            if (len > remaining) {
                len = (int) remaining;
            }
            int ret = -1;
            synchronized (archive) {
                archive.seek(loc);
                ret = archive.read(b, off, len);
            }
            if (ret > 0) {
                loc += ret;
                remaining -= ret;
            }
            return ret;
        }

        
        void addDummy() {
            addDummyByte = true;
        }
    }

}
"
org.apache.tools.ant.taskdefs.compilers.CompilerAdapterFactory,4,1,0,14,27,4,1,13,1,0.777777778,221,0.333333333,0,0.0,0.333333333,0,0,53.5,3,1.25,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.JavaEnvUtils;


public final class CompilerAdapterFactory {
    private static final String MODERN_COMPILER = ""com.sun.tools.javac.Main"";

    
    private CompilerAdapterFactory() {
    }

    
    public static CompilerAdapter getCompiler(String compilerType, Task task)
        throws BuildException {
            boolean isClassicCompilerSupported = true;
            
            if (!JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2)
                && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3)) {
                isClassicCompilerSupported = false;
            }

            if (compilerType.equalsIgnoreCase(""jikes"")) {
                return new Jikes();
            }
            if (compilerType.equalsIgnoreCase(""extJavac"")) {
                return new JavacExternal();
            }
            if (compilerType.equalsIgnoreCase(""classic"")
                || compilerType.equalsIgnoreCase(""javac1.1"")
                || compilerType.equalsIgnoreCase(""javac1.2"")) {
                if (isClassicCompilerSupported) {
                    return new Javac12();
                } else {
                    task.log(""This version of java does ""
                                             + ""not support the classic ""
                                             + ""compiler; upgrading to modern"",
                                             Project.MSG_WARN);
                    compilerType = ""modern"";
                }
            }
            
            
            if (compilerType.equalsIgnoreCase(""modern"")
                || compilerType.equalsIgnoreCase(""javac1.3"")
                || compilerType.equalsIgnoreCase(""javac1.4"")
                || compilerType.equalsIgnoreCase(""javac1.5"")
                || compilerType.equalsIgnoreCase(""javac1.6"")) {
                
                if (doesModernCompilerExist()) {
                    return new Javac13();
                } else {
                    if (isClassicCompilerSupported) {
                        task.log(""Modern compiler not found - looking for ""
                                 + ""classic compiler"", Project.MSG_WARN);
                        return new Javac12();
                    } else {
                        throw new BuildException(""Unable to find a javac ""
                                                 + ""compiler;\n""
                                                 + MODERN_COMPILER
                                                 + "" is not on the ""
                                                 + ""classpath.\n""
                                                 + ""Perhaps JAVA_HOME does not""
                                                 + "" point to the JDK.\n""
                                + ""It is currently set to \""""
                                + JavaEnvUtils.getJavaHome()
                                + ""\"""");
                    }
                }
            }

            if (compilerType.equalsIgnoreCase(""jvc"")
                || compilerType.equalsIgnoreCase(""microsoft"")) {
                return new Jvc();
            }
            if (compilerType.equalsIgnoreCase(""kjc"")) {
                return new Kjc();
            }
            if (compilerType.equalsIgnoreCase(""gcj"")) {
                return new Gcj();
            }
            if (compilerType.equalsIgnoreCase(""sj"")
                || compilerType.equalsIgnoreCase(""symantec"")) {
                return new Sj();
            }
            return resolveClassName(compilerType);
        }

    
    private static boolean doesModernCompilerExist() {
        try {
            Class.forName(MODERN_COMPILER);
            return true;
        } catch (ClassNotFoundException cnfe) {
            try {
                ClassLoader cl = CompilerAdapterFactory.class.getClassLoader();
                if (cl != null) {
                    cl.loadClass(MODERN_COMPILER);
                    return true;
                }
            } catch (ClassNotFoundException cnfe2) {
                
            }
        }
        return false;
    }

    
    private static CompilerAdapter resolveClassName(String className)
        throws BuildException {
        return (CompilerAdapter) ClasspathUtils.newInstance(className,
                CompilerAdapterFactory.class.getClassLoader(),
                CompilerAdapter.class);
    }

}
"
org.apache.tools.ant.util.LazyHashtable,9,3,0,0,16,34,0,0,8,0.0,60,1.0,0,0.8,0.666666667,1,1,5.555555556,2,1.0,0,"
package org.apache.tools.ant.util;

import java.util.Hashtable;
import java.util.Enumeration;


public class LazyHashtable extends Hashtable {
    
    protected boolean initAllDone = false;
    

    
    public LazyHashtable() {
        super();
    }

    
    protected void initAll() {
        if (initAllDone) {
            return;
        }
        initAllDone = true;
    }


    
    public Enumeration elements() {
        initAll();
        return super.elements();
    }

    
    public boolean isEmpty() {
        initAll();
        return super.isEmpty();
    }

    
    public int size() {
        initAll();
        return super.size();
    }

    
    public boolean contains(Object value) {
        initAll();
        return super.contains(value);
    }

    
    public boolean containsKey(Object value) {
        initAll();
        return super.containsKey(value);
    }

    
    public boolean containsValue(Object value) {
        return contains(value);
    }

    
    public Enumeration keys() {
        initAll();
        return super.keys();
    }

    
    
}
"
org.apache.tools.ant.types.selectors.DateSelector,14,5,0,12,41,29,6,6,13,0.875739645,377,0.538461538,2,0.76,0.196581197,1,4,25.0,9,2.2857,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.Locale;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.TimeComparison;
import org.apache.tools.ant.util.FileUtils;


public class DateSelector extends BaseExtendSelector {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private long millis = -1;
    private String dateTime = null;
    private boolean includeDirs = false;
    private long granularity = 0;
    private String pattern;
    private TimeComparison when = TimeComparison.EQUAL;

    
    public static final String MILLIS_KEY = ""millis"";
    
    public static final String DATETIME_KEY = ""datetime"";
    
    public static final String CHECKDIRS_KEY = ""checkdirs"";
    
    public static final String GRANULARITY_KEY = ""granularity"";
    
    public static final String WHEN_KEY = ""when"";
    
    public static final String PATTERN_KEY = ""pattern"";

    
    public DateSelector() {
        granularity = FILE_UTILS.getFileTimestampGranularity();
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{dateselector date: "");
        buf.append(dateTime);
        buf.append("" compare: "").append(when.getValue());
        buf.append("" granularity: "");
        buf.append(granularity);
        if (pattern != null) {
            buf.append("" pattern: "").append(pattern);
        }
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setMillis(long millis) {
        this.millis = millis;
    }

    
    public long getMillis() {
        if (dateTime != null) {
            validate();
        }
        return millis;
    }

    
    public void setDatetime(String dateTime) {
        this.dateTime = dateTime;
        millis = -1;
    }

    
    public void setCheckdirs(boolean includeDirs) {
        this.includeDirs = includeDirs;
    }

    
    public void setGranularity(int granularity) {
        this.granularity = granularity;
    }

    
    public void setWhen(TimeComparisons tcmp) {
        setWhen((TimeComparison) tcmp);
    }

    
    public void setWhen(TimeComparison t) {
        when = t;
    }

    
    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (MILLIS_KEY.equalsIgnoreCase(paramname)) {
                    try {
                        setMillis(new Long(parameters[i].getValue()
                        ).longValue());
                    } catch (NumberFormatException nfe) {
                        setError(""Invalid millisecond setting ""
                                + parameters[i].getValue());
                    }
                } else if (DATETIME_KEY.equalsIgnoreCase(paramname)) {
                    setDatetime(parameters[i].getValue());
                } else if (CHECKDIRS_KEY.equalsIgnoreCase(paramname)) {
                    setCheckdirs(Project.toBoolean(parameters[i].getValue()));
                } else if (GRANULARITY_KEY.equalsIgnoreCase(paramname)) {
                    try {
                        setGranularity(new Integer(parameters[i].getValue()
                        ).intValue());
                    } catch (NumberFormatException nfe) {
                        setError(""Invalid granularity setting ""
                            + parameters[i].getValue());
                    }
                } else if (WHEN_KEY.equalsIgnoreCase(paramname)) {
                    setWhen(new TimeComparison(parameters[i].getValue()));
                } else if (PATTERN_KEY.equalsIgnoreCase(paramname)) {
                    setPattern(parameters[i].getValue());
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (dateTime == null && millis < 0) {
            setError(""You must provide a datetime or the number of ""
                    + ""milliseconds."");
        } else if (millis < 0 && dateTime != null) {
            
            DateFormat df = ((pattern == null)
                ? DateFormat.getDateTimeInstance(
                    DateFormat.SHORT, DateFormat.SHORT, Locale.US)
                : new SimpleDateFormat(pattern));

            try {
                setMillis(df.parse(dateTime).getTime());
                if (millis < 0) {
                    setError(""Date of "" + dateTime
                        + "" results in negative milliseconds value""
                        + "" relative to epoch (January 1, 1970, 00:00:00 GMT)."");
                }
            } catch (ParseException pe) {
                setError(""Date of "" + dateTime
                        + "" Cannot be parsed correctly. It should be in""
                        + ((pattern == null)
                        ? "" MM/DD/YYYY HH:MM AM_PM"" : pattern) + "" format."");
            }
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {

        validate();

        return (file.isDirectory() && !includeDirs)
            || when.evaluate(file.lastModified(), millis, granularity);
    }

    
    public static class TimeComparisons extends TimeComparison {
    }

}


"
org.apache.tools.ant.taskdefs.optional.script.ScriptDef,14,5,0,14,69,25,1,14,14,0.837606838,492,0.777777778,2,0.805970149,0.241071429,1,1,33.5,17,2.5,0,"
package org.apache.tools.ant.taskdefs.optional.script;

import org.apache.tools.ant.AntTypeDefinition;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.taskdefs.DefBase;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;
import java.io.File;

import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.ScriptRunnerBase;
import org.apache.tools.ant.util.ScriptRunnerHelper;


public class ScriptDef extends DefBase {
    
    private ScriptRunnerHelper helper = new ScriptRunnerHelper();
    
    
    private ScriptRunnerBase   runner = null;

    
    private String name;

    
    private List attributes = new ArrayList();

    
    private List nestedElements = new ArrayList();

    
    private Set attributeSet;

    
    private Map nestedElementMap;

    
    public void setProject(Project project) {
        super.setProject(project);
        helper.setProjectComponent(this);
        helper.setSetBeans(false);
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public boolean isAttributeSupported(String attributeName) {
        return attributeSet.contains(attributeName);
    }

    
    public static class Attribute {
        
        private String name;

        
        public void setName(String name) {
            this.name = name.toLowerCase(Locale.US);
        }
    }

    
    public void addAttribute(Attribute attribute) {
        attributes.add(attribute);
    }

    
    public static class NestedElement {
        
        private String name;

        
        private String type;

        
        private String className;

        
        public void setName(String name) {
            this.name = name.toLowerCase(Locale.US);
        }

        
        public void setType(String type) {
            this.type = type;
        }

        
        public void setClassName(String className) {
            this.className = className;
        }
    }

    
    public void addElement(NestedElement nestedElement) {
        nestedElements.add(nestedElement);
    }

    
    public void execute() {
        if (name == null) {
            throw new BuildException(""scriptdef requires a name attribute to ""
                + ""name the script"");
        }

        if (helper.getLanguage() == null) {
            throw new BuildException(""<scriptdef> requires a language attribute ""
                + ""to specify the script language"");
        }

        
        if (getAntlibClassLoader() != null || hasCpDelegate()) {
            helper.setClassLoader(createLoader());
        }

        
        runner = helper.getScriptRunner();

        attributeSet = new HashSet();
        for (Iterator i = attributes.iterator(); i.hasNext();) {
            Attribute attribute = (Attribute) i.next();
            if (attribute.name == null) {
                throw new BuildException(""scriptdef <attribute> elements ""
                    + ""must specify an attribute name"");
            }

            if (attributeSet.contains(attribute.name)) {
                throw new BuildException(""scriptdef <"" + name + ""> declares ""
                    + ""the "" + attribute.name + "" attribute more than once"");
            }
            attributeSet.add(attribute.name);
        }

        nestedElementMap = new HashMap();
        for (Iterator i = nestedElements.iterator(); i.hasNext();) {
            NestedElement nestedElement = (NestedElement) i.next();
            if (nestedElement.name == null) {
                throw new BuildException(""scriptdef <element> elements ""
                    + ""must specify an element name"");
            }
            if (nestedElementMap.containsKey(nestedElement.name)) {
                throw new BuildException(""scriptdef <"" + name + ""> declares ""
                    + ""the "" + nestedElement.name + "" nested element more ""
                    + ""than once"");
            }

            if (nestedElement.className == null
                && nestedElement.type == null) {
                throw new BuildException(""scriptdef <element> elements ""
                    + ""must specify either a classname or type attribute"");
            }
            if (nestedElement.className != null
                && nestedElement.type != null) {
                throw new BuildException(""scriptdef <element> elements ""
                    + ""must specify only one of the classname and type ""
                    + ""attributes"");
            }


            nestedElementMap.put(nestedElement.name, nestedElement);
        }

        
        Map scriptRepository = null;
        Project p = getProject();
        synchronized (p) {
            scriptRepository =
                (Map) p.getReference(MagicNames.SCRIPT_REPOSITORY);
            if (scriptRepository == null) {
                scriptRepository = new HashMap();
                p.addReference(MagicNames.SCRIPT_REPOSITORY,
                    scriptRepository);
            }
        }

        name = ProjectHelper.genComponentName(getURI(), name);
        scriptRepository.put(name, this);
        AntTypeDefinition def = new AntTypeDefinition();
        def.setName(name);
        def.setClass(ScriptDefBase.class);
        ComponentHelper.getComponentHelper(
            getProject()).addDataTypeDefinition(def);
    }

    
    public Object createNestedElement(String elementName) {
        NestedElement definition
            = (NestedElement) nestedElementMap.get(elementName);
        if (definition == null) {
            throw new BuildException(""<"" + name + ""> does not support ""
                + ""the <"" + elementName + ""> nested element"");
        }

        Object instance = null;
        String classname = definition.className;
        if (classname == null) {
            instance = getProject().createTask(definition.type);
            if (instance == null) {
                instance = getProject().createDataType(definition.type);
            }
        } else {
            
            ClassLoader loader = createLoader();

            try {
                instance = ClasspathUtils.newInstance(classname, loader);
            } catch (BuildException e) {
                instance = ClasspathUtils.newInstance(classname, ScriptDef.class.getClassLoader());
            }

            getProject().setProjectReference(instance);
        }

        if (instance == null) {
            throw new BuildException(""<"" + name + ""> is unable to create ""
                + ""the <"" + elementName + ""> nested element"");
        }
        return instance;
    }

    
    public void executeScript(Map attributes, Map elements) {
        executeScript(attributes, elements, null);
    }

    
    public void executeScript(Map attributes, Map elements, ScriptDefBase instance) {
        runner.addBean(""attributes"", attributes);
        runner.addBean(""elements"", elements);
        runner.addBean(""project"", getProject());
        if (instance != null) {
            runner.addBean(""self"", instance);
        }
        runner.executeScript(""scriptdef_"" + name);
    }

    
    public void setManager(String manager) {
        helper.setManager(manager);
    }

    
    public void setLanguage(String language) {
        helper.setLanguage(language);
    }

    
    public void setSrc(File file) {
        helper.setSrc(file);
    }

    
    public void addText(String text) {
        helper.addText(text);
    }
}

"
org.apache.tools.ant.taskdefs.condition.IsFileSelected,6,4,0,7,16,9,1,6,5,0.8,72,1.0,1,0.933333333,0.7,0,0,10.5,3,1.1667,0,"
package org.apache.tools.ant.taskdefs.condition;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;
import java.io.File;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.AbstractSelectorContainer;


public class IsFileSelected extends AbstractSelectorContainer implements Condition {

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private File file;
    private File baseDir;

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setBaseDir(File baseDir) {
        this.baseDir = baseDir;
    }

    
    public void validate() {
        if (selectorCount() != 1) {
            throw new BuildException(""Only one selector allowed"");
        }
        super.validate();
    }

    
    public boolean eval() {
        if (file == null) {
            throw new BuildException(""file attribute not set"");
        }
        validate();
        File myBaseDir = baseDir;
        if (myBaseDir == null) {
            myBaseDir = getProject().getBaseDir();
        }

        FileSelector f = getSelectors(getProject())[0];
        return f.isSelected(
            myBaseDir, FILE_UTILS.removeLeadingPath(myBaseDir, file), file);
    }
}
"
org.apache.tools.ant.taskdefs.ExecuteOn,31,4,4,29,104,347,4,25,20,0.861111111,1270,1.0,5,0.719626168,0.122983871,3,9,39.38709677,19,2.0,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.AbstractFileSet;
import org.apache.tools.ant.types.DirSet;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileList;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.SourceFileScanner;


public class ExecuteOn extends ExecTask {

    

    
    
    
    
    
    

    protected Vector filesets = new Vector(); 
                                              
    private Union resources = null;
    private boolean relative = false;
    private boolean parallel = false;
    private boolean forwardSlash = false;
    protected String type = FileDirBoth.FILE;
    protected Commandline.Marker srcFilePos = null;
    private boolean skipEmpty = false;
    protected Commandline.Marker targetFilePos = null;
    protected Mapper mapperElement = null;
    protected FileNameMapper mapper = null;
    protected File destDir = null;
    private int maxParallel = -1;
    private boolean addSourceFile = true;
    private boolean verbose = false;
    private boolean ignoreMissing = true;
    private boolean force = false;

    
    protected boolean srcIsFirst = true;

    
    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }

    
    public void addDirset(DirSet set) {
        filesets.addElement(set);
    }

    
    public void addFilelist(FileList list) {
        add(list);
    }

    
    public void add(ResourceCollection rc) {
        if (resources == null) {
            resources = new Union();
        }
        resources.add(rc);
    }

    
    public void setRelative(boolean relative) {
        this.relative = relative;
    }


    
    public void setParallel(boolean parallel) {
        this.parallel = parallel;
    }

    
    public void setType(FileDirBoth type) {
        this.type = type.getValue();
    }

    
    public void setSkipEmptyFilesets(boolean skip) {
        skipEmpty = skip;
    }

    
    public void setDest(File destDir) {
        this.destDir = destDir;
    }

    
    public void setForwardslash(boolean forwardSlash) {
        this.forwardSlash = forwardSlash;
    }

    
    public void setMaxParallel(int max) {
        maxParallel = max;
    }

    
    public void setAddsourcefile(boolean b) {
        addSourceFile = b;
    }

    
    public void setVerbose(boolean b) {
        verbose = b;
    }

    
    public void setIgnoremissing(boolean b) {
        ignoreMissing = b;
    }

    
    public void setForce(boolean b) {
        force = b;
    }

    
    public Commandline.Marker createSrcfile() {
        if (srcFilePos != null) {
            throw new BuildException(getTaskType() + "" doesn\'t support multiple ""
                                     + ""srcfile elements."", getLocation());
        }
        srcFilePos = cmdl.createMarker();
        return srcFilePos;
    }

    
    public Commandline.Marker createTargetfile() {
        if (targetFilePos != null) {
            throw new BuildException(getTaskType() + "" doesn\'t support multiple ""
                                     + ""targetfile elements."", getLocation());
        }
        targetFilePos = cmdl.createMarker();
        srcIsFirst = (srcFilePos != null);
        return targetFilePos;
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapperElement != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     getLocation());
        }
        mapperElement = new Mapper(getProject());
        return mapperElement;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        createMapper().add(fileNameMapper);
    }

    
    protected void checkConfiguration() {


        if (""execon"".equals(getTaskName())) {
            log(""!! execon is deprecated. Use apply instead. !!"");
        }
        super.checkConfiguration();
        if (filesets.size() == 0 && resources == null) {
            throw new BuildException(""no resources specified"",
                                     getLocation());
        }
        if (targetFilePos != null && mapperElement == null) {
            throw new BuildException(""targetfile specified without mapper"",
                                     getLocation());
        }
        if (destDir != null && mapperElement == null) {
            throw new BuildException(""dest specified without mapper"",
                                     getLocation());
        }
        if (mapperElement != null) {
            mapper = mapperElement.getImplementation();
        }
    }

    
    protected ExecuteStreamHandler createHandler() throws BuildException {
        
        return (redirectorElement == null)
            ? super.createHandler() : new PumpStreamHandler();
    }

    
    protected void setupRedirector() {
        super.setupRedirector();
        redirector.setAppendProperties(true);
    }

    
    protected void runExec(Execute exe) throws BuildException {
        int totalFiles = 0;
        int totalDirs = 0;
        boolean haveExecuted = false;
        try {
            Vector fileNames = new Vector();
            Vector baseDirs = new Vector();
            for (int i = 0; i < filesets.size(); i++) {
                String currentType = type;
                AbstractFileSet fs = (AbstractFileSet) filesets.elementAt(i);
                if (fs instanceof DirSet) {
                    if (!FileDirBoth.DIR.equals(type)) {
                        log(""Found a nested dirset but type is "" + type + "". ""
                            + ""Temporarily switching to type=\""dir\"" on the""
                            + "" assumption that you really did mean""
                            + "" <dirset> not <fileset>."", Project.MSG_DEBUG);
                        currentType = FileDirBoth.DIR;
                    }
                }
                File base = fs.getDir(getProject());

                DirectoryScanner ds = fs.getDirectoryScanner(getProject());

                if (!FileDirBoth.DIR.equals(currentType)) {
                    String[] s = getFiles(base, ds);
                    for (int j = 0; j < s.length; j++) {
                        totalFiles++;
                        fileNames.addElement(s[j]);
                        baseDirs.addElement(base);
                    }
                }
                if (!FileDirBoth.FILE.equals(currentType)) {
                    String[] s = getDirs(base, ds);
                    for (int j = 0; j < s.length; j++) {
                        totalDirs++;
                        fileNames.addElement(s[j]);
                        baseDirs.addElement(base);
                    }
                }
                if (fileNames.size() == 0 && skipEmpty) {
                    int includedCount
                        = ((!FileDirBoth.DIR.equals(currentType))
                        ? ds.getIncludedFilesCount() : 0)
                        + ((!FileDirBoth.FILE.equals(currentType))
                        ? ds.getIncludedDirsCount() : 0);

                    log(""Skipping fileset for directory "" + base + "". It is ""
                        + ((includedCount > 0) ? ""up to date."" : ""empty.""),
                        Project.MSG_INFO);
                    continue;
                }
                if (!parallel) {
                    String[] s = new String[fileNames.size()];
                    fileNames.copyInto(s);
                    for (int j = 0; j < s.length; j++) {
                        String[] command = getCommandline(s[j], base);
                        log(Commandline.describeCommand(command),
                            Project.MSG_VERBOSE);
                        exe.setCommandline(command);

                        if (redirectorElement != null) {
                            setupRedirector();
                            redirectorElement.configure(redirector, s[j]);
                        }
                        if (redirectorElement != null || haveExecuted) {
                            
                            
                            
                            exe.setStreamHandler(redirector.createHandler());
                        }
                        runExecute(exe);
                        haveExecuted = true;
                    }
                    fileNames.removeAllElements();
                    baseDirs.removeAllElements();
                }
            }

            if (resources != null) {
                Iterator iter = resources.iterator();
                while (iter.hasNext()) {
                    Resource res = (Resource) iter.next();

                    if (!res.isExists() && ignoreMissing) {
                        continue;
                    }

                    File base = null;
                    String name = res.getName();
                    if (res instanceof FileResource) {
                        FileResource fr = (FileResource) res;
                        base = fr.getBaseDir();
                        if (base == null) {
                            name = fr.getFile().getAbsolutePath();
                        }
                    }

                    if (restrict(new String[] {name}, base).length == 0) {
                        continue;
                    }

                    if ((!res.isDirectory() || !res.isExists())
                        && !FileDirBoth.DIR.equals(type)) {
                        totalFiles++;
                    } else if (res.isDirectory()
                               && !FileDirBoth.FILE.equals(type)) {
                        totalDirs++;
                    } else {
                        continue;
                    }

                    baseDirs.add(base);
                    fileNames.add(name);

                    if (!parallel) {
                        String[] command = getCommandline(name, base);
                        log(Commandline.describeCommand(command),
                            Project.MSG_VERBOSE);
                        exe.setCommandline(command);

                        if (redirectorElement != null) {
                            setupRedirector();
                            redirectorElement.configure(redirector, name);
                        }
                        if (redirectorElement != null || haveExecuted) {
                            
                            
                            
                            exe.setStreamHandler(redirector.createHandler());
                        }
                        runExecute(exe);
                        haveExecuted = true;
                        fileNames.removeAllElements();
                        baseDirs.removeAllElements();
                    }
                }
            }
            if (parallel && (fileNames.size() > 0 || !skipEmpty)) {
                runParallel(exe, fileNames, baseDirs);
                haveExecuted = true;
            }
            if (haveExecuted) {
                log(""Applied "" + cmdl.getExecutable() + "" to ""
                    + totalFiles + "" file""
                    + (totalFiles != 1 ? ""s"" : """") + "" and ""
                    + totalDirs + "" director""
                    + (totalDirs != 1 ? ""ies"" : ""y"") + ""."",
                    verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
            }
        } catch (IOException e) {
            throw new BuildException(""Execute failed: "" + e, e, getLocation());
        } finally {
            
            logFlush();
            redirector.setAppendProperties(false);
            redirector.setProperties();
        }
    }

    
    protected String[] getCommandline(String[] srcFiles, File[] baseDirs) {
        final char fileSeparator = File.separatorChar;
        Vector targets = new Vector();
        if (targetFilePos != null) {
            Hashtable addedFiles = new Hashtable();
            for (int i = 0; i < srcFiles.length; i++) {
                String[] subTargets = mapper.mapFileName(srcFiles[i]);
                if (subTargets != null) {
                    for (int j = 0; j < subTargets.length; j++) {
                        String name = null;
                        if (!relative) {
                            name = (new File(destDir, subTargets[j])).getAbsolutePath();
                        } else {
                            name = subTargets[j];
                        }
                        if (forwardSlash && fileSeparator != '/') {
                            name = name.replace(fileSeparator, '/');
                        }
                        if (!addedFiles.contains(name)) {
                            targets.addElement(name);
                            addedFiles.put(name, name);
                        }
                    }
                }
            }
        }
        String[] targetFiles = new String[targets.size()];
        targets.copyInto(targetFiles);

        if (!addSourceFile) {
            srcFiles = new String[0];
        }
        String[] orig = cmdl.getCommandline();
        String[] result
            = new String[orig.length + srcFiles.length + targetFiles.length];

        int srcIndex = orig.length;
        if (srcFilePos != null) {
            srcIndex = srcFilePos.getPosition();
        }
        if (targetFilePos != null) {
            int targetIndex = targetFilePos.getPosition();

            if (srcIndex < targetIndex
                || (srcIndex == targetIndex && srcIsFirst)) {

                
                System.arraycopy(orig, 0, result, 0, srcIndex);

                
                System.arraycopy(orig, srcIndex, result,
                                 srcIndex + srcFiles.length,
                                 targetIndex - srcIndex);

                
                System.arraycopy(targetFiles, 0, result,
                                 targetIndex + srcFiles.length,
                                 targetFiles.length);

                
                System.arraycopy(orig, targetIndex, result,
                    targetIndex + srcFiles.length + targetFiles.length,
                    orig.length - targetIndex);
            } else {
                
                System.arraycopy(orig, 0, result, 0, targetIndex);

                
                System.arraycopy(targetFiles, 0, result,
                                 targetIndex,
                                 targetFiles.length);

                
                System.arraycopy(orig, targetIndex, result,
                                 targetIndex + targetFiles.length,
                                 srcIndex - targetIndex);

                
                System.arraycopy(orig, srcIndex, result,
                    srcIndex + srcFiles.length + targetFiles.length,
                    orig.length - srcIndex);
                srcIndex += targetFiles.length;
            }

        } else { 

            
            System.arraycopy(orig, 0, result, 0, srcIndex);
            
            System.arraycopy(orig, srcIndex, result,
                             srcIndex + srcFiles.length,
                             orig.length - srcIndex);
        }
        
        for (int i = 0; i < srcFiles.length; i++) {
            if (!relative) {
                result[srcIndex + i] =
                    (new File(baseDirs[i], srcFiles[i])).getAbsolutePath();
            } else {
                result[srcIndex + i] = srcFiles[i];
            }
            if (forwardSlash && fileSeparator != '/') {
                result[srcIndex + i] =
                    result[srcIndex + i].replace(fileSeparator, '/');
            }
        }
        return result;
    }

    
    protected String[] getCommandline(String srcFile, File baseDir) {
        return getCommandline(new String[] {srcFile}, new File[] {baseDir});
    }

    
    protected String[] getFiles(File baseDir, DirectoryScanner ds) {
        return restrict(ds.getIncludedFiles(), baseDir);
    }

    
    protected String[] getDirs(File baseDir, DirectoryScanner ds) {
        return restrict(ds.getIncludedDirectories(), baseDir);
    }

    
    protected String[] getFilesAndDirs(FileList list) {
        return restrict(list.getFiles(getProject()), list.getDir(getProject()));
    }

    private String[] restrict(String[] s, File baseDir) {
        return (mapper == null || force) ? s
            : new SourceFileScanner(this).restrict(s, baseDir, destDir, mapper);
    }

    
    protected void runParallel(Execute exe, Vector fileNames,
                               Vector baseDirs)
        throws IOException, BuildException {
        String[] s = new String[fileNames.size()];
        fileNames.copyInto(s);
        File[] b = new File[baseDirs.size()];
        baseDirs.copyInto(b);

        if (maxParallel <= 0
            || s.length == 0 ) {
            String[] command = getCommandline(s, b);
            log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
            exe.setCommandline(command);
            runExecute(exe);
        } else {
            int stillToDo = fileNames.size();
            int currentOffset = 0;
            while (stillToDo > 0) {
                int currentAmount = Math.min(stillToDo, maxParallel);
                String[] cs = new String[currentAmount];
                System.arraycopy(s, currentOffset, cs, 0, currentAmount);
                File[] cb = new File[currentAmount];
                System.arraycopy(b, currentOffset, cb, 0, currentAmount);
                String[] command = getCommandline(cs, cb);
                log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
                exe.setCommandline(command);
                if (redirectorElement != null) {
                    setupRedirector();
                    redirectorElement.configure(redirector, null);
                }
                if (redirectorElement != null || currentOffset > 0) {
                    
                    
                    
                    exe.setStreamHandler(redirector.createHandler());
                }
                runExecute(exe);

                stillToDo -= currentAmount;
                currentOffset += currentAmount;
            }
        }
    }

    
    public static class FileDirBoth extends EnumeratedAttribute {
        
        public static final String FILE = ""file"";
        
        public static final String DIR = ""dir"";
        
        
       public String[] getValues() {
            return new String[] {FILE, DIR, ""both""};
        }
    }
}
"
org.apache.tools.ant.taskdefs.PathConvert,21,3,0,12,61,144,1,12,15,0.836363636,507,1.0,3,0.660714286,0.1875,2,2,22.61904762,4,1.4286,0,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.List;
import java.util.Vector;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.util.FileNameMapper;


public class PathConvert extends Task {

    
    private static boolean onWindows = Os.isFamily(""dos"");

    
    
    private Union path = null;
    
    private Reference refid = null;
    
    private String targetOS = null;
    
    private boolean targetWindows = false;
    
    private boolean setonempty = true;
    
    private String property = null;
    
    private Vector prefixMap = new Vector();
    
    private String pathSep = null;
    
    private String dirSep = null;

    
    private Mapper mapper = null;

    
    public PathConvert() {
    }

    
    public class MapEntry {

        
        private String from = null;
        private String to = null;

        
        public void setFrom(String from) {
            this.from = from;
        }

        
        public void setTo(String to) {
            this.to = to;
        }

        
        public String apply(String elem) {
            if (from == null || to == null) {
                throw new BuildException(""Both 'from' and 'to' must be set ""
                     + ""in a map entry"");
            }
            
            
            String cmpElem =
                onWindows ? elem.toLowerCase().replace('\\', '/') : elem;
            String cmpFrom =
                onWindows ? from.toLowerCase().replace('\\', '/') : from;

            
            

            return cmpElem.startsWith(cmpFrom)
                ? to + elem.substring(from.length()) : elem;
        }
    }

    
    public static class TargetOs extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[]{""windows"", ""unix"", ""netware"", ""os/2"", ""tandem""};
        }
    }

    
    public Path createPath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        Path result = new Path(getProject());
        add(result);
        return result;
    }

    
    public void add(ResourceCollection rc) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        getPath().add(rc);
    }

    private synchronized Union getPath() {
        if (path == null) {
            path = new Union();
            path.setProject(getProject());
        }
        return path;
    }

    
    public MapEntry createMap() {
        MapEntry entry = new MapEntry();
        prefixMap.addElement(entry);
        return entry;
    }

    
    public void setTargetos(String target) {
        TargetOs to = new TargetOs();
        to.setValue(target);
        setTargetos(to);
    }

    
    public void setTargetos(TargetOs target) {
        targetOS = target.getValue();

        
        

        
        
        

        targetWindows = !targetOS.equals(""unix"") && !targetOS.equals(""tandem"");
    }

    
     public void setSetonempty(boolean setonempty) {
         this.setonempty = setonempty;
     }

    
    public void setProperty(String p) {
        property = p;
    }

    
    public void setRefid(Reference r) {
        if (path != null) {
            throw noChildrenAllowed();
        }
        refid = r;
    }

    
    public void setPathSep(String sep) {
        pathSep = sep;
    }


    
    public void setDirSep(String sep) {
        dirSep = sep;
    }

    
    public boolean isReference() {
        return refid != null;
    }

    
    public void execute() throws BuildException {
        Union savedPath = path;
        String savedPathSep = pathSep; 
        String savedDirSep = dirSep; 

        try {
            
            if (isReference()) {
                Object o = refid.getReferencedObject(getProject());
                if (!(o instanceof ResourceCollection)) {
                    throw new BuildException(""refid '"" + refid.getRefId()
                        + ""' does not refer to a resource collection."");
                }
                getPath().add((ResourceCollection) o);
            }
            validateSetup(); 

            
            
            

            
            
            
            
            String fromDirSep = onWindows ? ""\\"" : ""/"";

            StringBuffer rslt = new StringBuffer();

            
            String[] elems = path.list();

            if (mapper != null) {
                FileNameMapper impl = mapper.getImplementation();
                List ret = new ArrayList();
                for (int i = 0; i < elems.length; ++i) {
                    String[] mapped = impl.mapFileName(elems[i]);
                    for (int m = 0; mapped != null && m < mapped.length; ++m) {
                        ret.add(mapped[m]);
                    }
                }
                elems = (String[]) ret.toArray(new String[ret.size()]);
            }
            for (int i = 0; i < elems.length; i++) {
                String elem = mapElement(elems[i]); 

                
                

                if (i != 0) {
                    rslt.append(pathSep);
                }
                StringTokenizer stDirectory =
                    new StringTokenizer(elem, fromDirSep, true);

                while (stDirectory.hasMoreTokens()) {
                    String token = stDirectory.nextToken();
                    rslt.append(fromDirSep.equals(token) ? dirSep : token);
                }
            }
            
            
            if (setonempty || rslt.length() > 0) {
                String value = rslt.toString();
                if (property == null) {
                    log(value);
                } else {
                    log(""Set property "" + property + "" = "" + value,
                        Project.MSG_VERBOSE);
                    getProject().setNewProperty(property, value);
                }
            }
        } finally {
            path = savedPath;
            dirSep = savedDirSep;
            pathSep = savedPathSep;
        }
    }

    
    private String mapElement(String elem) {

        int size = prefixMap.size();

        if (size != 0) {

            
            

            for (int i = 0; i < size; i++) {
                MapEntry entry = (MapEntry) prefixMap.elementAt(i);
                String newElem = entry.apply(elem);

                
                

                if (newElem != elem) {
                    elem = newElem;
                    break; 
                }
            }
        }
        return elem;
    }

    
    public void addMapper(Mapper mapper) {
        if (this.mapper != null) {
            throw new BuildException(
                ""Cannot define more than one mapper"");
        }
        this.mapper = mapper;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        Mapper m = new Mapper(getProject());
        m.add(fileNameMapper);
        addMapper(m);
    }

    
    private void validateSetup() throws BuildException {

        if (path == null) {
            throw new BuildException(""You must specify a path to convert"");
        }
        
        
        String dsep = File.separator;
        String psep = File.pathSeparator;

        if (targetOS != null) {
            psep = targetWindows ? "";"" : "":"";
            dsep = targetWindows ? ""\\"" : ""/"";
        }
        if (pathSep != null) {
            
            psep = pathSep;
        }
        if (dirSep != null) {
            
            dsep = dirSep;
        }
        pathSep = psep;
        dirSep = dsep;
    }

    
    private BuildException noChildrenAllowed() {
        return new BuildException(""You must not specify nested ""
             + ""elements when using the refid attribute."");
    }

}

"
org.apache.tools.tar.TarEntry,35,1,0,8,73,353,6,2,34,0.807189542,776,0.777777778,0,0.0,0.16,1,1,20.65714286,4,1.2,1,"



package org.apache.tools.tar;

import java.io.File;
import java.util.Date;
import java.util.Locale;



public class TarEntry implements TarConstants {
    
    private StringBuffer name;

    
    private int mode;

    
    private int userId;

    
    private int groupId;

    
    private long size;

    
    private long modTime;

    
    private byte linkFlag;

    
    private StringBuffer linkName;

    
    private StringBuffer magic;

    
    private StringBuffer userName;

    
    private StringBuffer groupName;

    
    private int devMajor;

    
    private int devMinor;

    
    private File file;

    
    public static final int MAX_NAMELEN = 31;

    
    public static final int DEFAULT_DIR_MODE = 040755;

    
    public static final int DEFAULT_FILE_MODE = 0100644;

    
    public static final int MILLIS_PER_SECOND = 1000;

    
    private TarEntry () {
        this.magic = new StringBuffer(TMAGIC);
        this.name = new StringBuffer();
        this.linkName = new StringBuffer();

        String user = System.getProperty(""user.name"", """");

        if (user.length() > MAX_NAMELEN) {
            user = user.substring(0, MAX_NAMELEN);
        }

        this.userId = 0;
        this.groupId = 0;
        this.userName = new StringBuffer(user);
        this.groupName = new StringBuffer("""");
        this.file = null;
    }

    
    public TarEntry(String name) {
        this();

        boolean isDir = name.endsWith(""/"");

        this.devMajor = 0;
        this.devMinor = 0;
        this.name = new StringBuffer(name);
        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;
        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;
        this.userId = 0;
        this.groupId = 0;
        this.size = 0;
        this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;
        this.linkName = new StringBuffer("""");
        this.userName = new StringBuffer("""");
        this.groupName = new StringBuffer("""");
        this.devMajor = 0;
        this.devMinor = 0;

    }

    
    public TarEntry(String name, byte linkFlag) {
        this(name);
        this.linkFlag = linkFlag;
    }

    
    public TarEntry(File file) {
        this();

        this.file = file;

        String fileName = file.getPath();
        String osname = System.getProperty(""os.name"").toLowerCase(Locale.US);

        if (osname != null) {

            
            

            if (osname.startsWith(""windows"")) {
                if (fileName.length() > 2) {
                    char ch1 = fileName.charAt(0);
                    char ch2 = fileName.charAt(1);

                    if (ch2 == ':'
                            && ((ch1 >= 'a' && ch1 <= 'z')
                                || (ch1 >= 'A' && ch1 <= 'Z'))) {
                        fileName = fileName.substring(2);
                    }
                }
            } else if (osname.indexOf(""netware"") > -1) {
                int colon = fileName.indexOf(':');
                if (colon != -1) {
                    fileName = fileName.substring(colon + 1);
                }
            }
        }

        fileName = fileName.replace(File.separatorChar, '/');

        
        
        
        while (fileName.startsWith(""/"")) {
            fileName = fileName.substring(1);
        }

        this.linkName = new StringBuffer("""");
        this.name = new StringBuffer(fileName);

        if (file.isDirectory()) {
            this.mode = DEFAULT_DIR_MODE;
            this.linkFlag = LF_DIR;

            if (this.name.charAt(this.name.length() - 1) != '/') {
                this.name.append(""/"");
            }
        } else {
            this.mode = DEFAULT_FILE_MODE;
            this.linkFlag = LF_NORMAL;
        }

        this.size = file.length();
        this.modTime = file.lastModified() / MILLIS_PER_SECOND;
        this.devMajor = 0;
        this.devMinor = 0;
    }

    
    public TarEntry(byte[] headerBuf) {
        this();
        this.parseTarHeader(headerBuf);
    }

    
    public boolean equals(TarEntry it) {
        return this.getName().equals(it.getName());
    }

    
    public boolean equals(Object it) {
        if (it == null || getClass() != it.getClass()) {
            return false;
        }
        return equals((TarEntry) it);
    }

    
    public int hashCode() {
        return getName().hashCode();
    }

    
    public boolean isDescendent(TarEntry desc) {
        return desc.getName().startsWith(this.getName());
    }

    
    public String getName() {
        return this.name.toString();
    }

    
    public void setName(String name) {
        this.name = new StringBuffer(name);
    }

    
    public void setMode(int mode) {
        this.mode = mode;
    }

    
    public String getLinkName() {
        return this.linkName.toString();
    }

    
    public int getUserId() {
        return this.userId;
    }

    
    public void setUserId(int userId) {
        this.userId = userId;
    }

    
    public int getGroupId() {
        return this.groupId;
    }

    
    public void setGroupId(int groupId) {
        this.groupId = groupId;
    }

    
    public String getUserName() {
        return this.userName.toString();
    }

    
    public void setUserName(String userName) {
        this.userName = new StringBuffer(userName);
    }

    
    public String getGroupName() {
        return this.groupName.toString();
    }

    
    public void setGroupName(String groupName) {
        this.groupName = new StringBuffer(groupName);
    }

    
    public void setIds(int userId, int groupId) {
        this.setUserId(userId);
        this.setGroupId(groupId);
    }

    
    public void setNames(String userName, String groupName) {
        this.setUserName(userName);
        this.setGroupName(groupName);
    }

    
    public void setModTime(long time) {
        this.modTime = time / MILLIS_PER_SECOND;
    }

    
    public void setModTime(Date time) {
        this.modTime = time.getTime() / MILLIS_PER_SECOND;
    }

    
    public Date getModTime() {
        return new Date(this.modTime * MILLIS_PER_SECOND);
    }

    
    public File getFile() {
        return this.file;
    }

    
    public int getMode() {
        return this.mode;
    }

    
    public long getSize() {
        return this.size;
    }

    
    public void setSize(long size) {
        this.size = size;
    }


    
    public boolean isGNULongNameEntry() {
        return linkFlag == LF_GNUTYPE_LONGNAME
                           && name.toString().equals(GNU_LONGLINK);
    }

    
    public boolean isDirectory() {
        if (this.file != null) {
            return this.file.isDirectory();
        }

        if (this.linkFlag == LF_DIR) {
            return true;
        }

        if (this.getName().endsWith(""/"")) {
            return true;
        }

        return false;
    }

    
    public TarEntry[] getDirectoryEntries() {
        if (this.file == null || !this.file.isDirectory()) {
            return new TarEntry[0];
        }

        String[]   list = this.file.list();
        TarEntry[] result = new TarEntry[list.length];

        for (int i = 0; i < list.length; ++i) {
            result[i] = new TarEntry(new File(this.file, list[i]));
        }

        return result;
    }

    
    public void writeEntryHeader(byte[] outbuf) {
        int offset = 0;

        offset = TarUtils.getNameBytes(this.name, outbuf, offset, NAMELEN);
        offset = TarUtils.getOctalBytes(this.mode, outbuf, offset, MODELEN);
        offset = TarUtils.getOctalBytes(this.userId, outbuf, offset, UIDLEN);
        offset = TarUtils.getOctalBytes(this.groupId, outbuf, offset, GIDLEN);
        offset = TarUtils.getLongOctalBytes(this.size, outbuf, offset, SIZELEN);
        offset = TarUtils.getLongOctalBytes(this.modTime, outbuf, offset, MODTIMELEN);

        int csOffset = offset;

        for (int c = 0; c < CHKSUMLEN; ++c) {
            outbuf[offset++] = (byte) ' ';
        }

        outbuf[offset++] = this.linkFlag;
        offset = TarUtils.getNameBytes(this.linkName, outbuf, offset, NAMELEN);
        offset = TarUtils.getNameBytes(this.magic, outbuf, offset, MAGICLEN);
        offset = TarUtils.getNameBytes(this.userName, outbuf, offset, UNAMELEN);
        offset = TarUtils.getNameBytes(this.groupName, outbuf, offset, GNAMELEN);
        offset = TarUtils.getOctalBytes(this.devMajor, outbuf, offset, DEVLEN);
        offset = TarUtils.getOctalBytes(this.devMinor, outbuf, offset, DEVLEN);

        while (offset < outbuf.length) {
            outbuf[offset++] = 0;
        }

        long chk = TarUtils.computeCheckSum(outbuf);

        TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);
    }

    
    public void parseTarHeader(byte[] header) {
        int offset = 0;

        this.name = TarUtils.parseName(header, offset, NAMELEN);
        offset += NAMELEN;
        this.mode = (int) TarUtils.parseOctal(header, offset, MODELEN);
        offset += MODELEN;
        this.userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);
        offset += UIDLEN;
        this.groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);
        offset += GIDLEN;
        this.size = TarUtils.parseOctal(header, offset, SIZELEN);
        offset += SIZELEN;
        this.modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);
        offset += MODTIMELEN;
        offset += CHKSUMLEN;
        this.linkFlag = header[offset++];
        this.linkName = TarUtils.parseName(header, offset, NAMELEN);
        offset += NAMELEN;
        this.magic = TarUtils.parseName(header, offset, MAGICLEN);
        offset += MAGICLEN;
        this.userName = TarUtils.parseName(header, offset, UNAMELEN);
        offset += UNAMELEN;
        this.groupName = TarUtils.parseName(header, offset, GNAMELEN);
        offset += GNAMELEN;
        this.devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
        offset += DEVLEN;
        this.devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
    }
}
"
org.apache.tools.ant.taskdefs.optional.jsp.Jasper41Mangler,4,1,0,2,17,6,1,1,3,2.0,127,0.0,0,0.0,0.375,0,0,30.75,6,2.5,0,"

package org.apache.tools.ant.taskdefs.optional.jsp;

import java.io.File;


public class Jasper41Mangler implements JspMangler {


    
    public String mapJspToJavaName(File jspFile) {
        String jspUri = jspFile.getAbsolutePath();
        int start = jspUri.lastIndexOf(File.separatorChar) + 1;
        int end = jspUri.length();
        StringBuffer modifiedClassName;
        modifiedClassName = new StringBuffer(jspUri.length() - start);
        if (!Character.isJavaIdentifierStart(jspUri.charAt(start))
            || jspUri.charAt(start) == '_') {
            
            
            modifiedClassName.append('_');
        }
        for (int i = start; i < end; i++) {
            char ch = jspUri.charAt(i);
            if (Character.isJavaIdentifierPart(ch)) {
                modifiedClassName.append(ch);
            } else if (ch == '.') {
                modifiedClassName.append('_');
            } else {
                modifiedClassName.append(mangleChar(ch));
            }
        }
        return modifiedClassName.toString();
    }

    
    private static String mangleChar(char ch) {

        String s = Integer.toHexString(ch);
        int nzeros = 5 - s.length();
        char[] result = new char[6];
        result[0] = '_';
        for (int i = 1; i <= nzeros; i++) {
            result[i] = '0';
        }
        for (int i = nzeros + 1, j = 0; i < 6; i++, j++) {
            result[i] = s.charAt(j);
        }
        return new String(result);
    }


    
    public String mapPath(String path) {
        return null;
    }

}
"
org.apache.tools.ant.types.resources.selectors.Not,4,1,0,5,7,4,3,2,4,0.333333333,35,1.0,1,0.0,0.583333333,0,0,7.5,2,1.0,0,"
package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.types.Resource;


public class Not implements ResourceSelector {

    private ResourceSelector sel;

    
    public Not() {
    }

    
    public Not(ResourceSelector s) {
        add(s);
    }

    
    public void add(ResourceSelector s) {
        if (sel != null) {
            throw new IllegalStateException(
                ""The Not ResourceSelector accepts a single nested ResourceSelector"");
        }
        sel = s;
    }

    
    public boolean isSelected(Resource r) {
        return !(sel.isSelected(r));
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.MethodRefCPInfo,7,2,0,4,21,3,2,4,7,0.666666667,108,1.0,0,0.5,0.428571429,1,1,13.71428571,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class MethodRefCPInfo extends ConstantPoolEntry {
    
    private String methodClassName;
    
    private String methodName;
    
    private String methodType;
    
    private int classIndex;
    
    private int nameAndTypeIndex;

    
    public MethodRefCPInfo() {
        super(CONSTANT_METHODREF, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        classIndex = cpStream.readUnsignedShort();
        nameAndTypeIndex = cpStream.readUnsignedShort();
    }

    
    public String toString() {
        String value;

        if (isResolved()) {
            value = ""Method : Class = "" + methodClassName + "", name = ""
                 + methodName + "", type = "" + methodType;
        } else {
            value = ""Method : Class index = "" + classIndex
                 + "", name and type index = "" + nameAndTypeIndex;
        }

        return value;
    }

    
    public void resolve(ConstantPool constantPool) {
        ClassCPInfo methodClass
             = (ClassCPInfo) constantPool.getEntry(classIndex);

        methodClass.resolve(constantPool);

        methodClassName = methodClass.getClassName();

        NameAndTypeCPInfo nt
             = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);

        nt.resolve(constantPool);

        methodName = nt.getName();
        methodType = nt.getType();

        super.resolve(constantPool);
    }

    
    public String getMethodClassName() {
        return methodClassName;
    }

    
    public String getMethodName() {
        return methodName;
    }

    
    public String getMethodType() {
        return methodType;
    }

}

"
org.apache.tools.ant.taskdefs.Echo,8,3,0,6,27,0,0,6,8,0.685714286,141,1.0,0,0.840909091,0.35,1,1,16.0,1,0.875,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.FileOutputStream;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.LogLevel;


public class Echo extends Task {
    
    protected String message = """";
    protected File file = null;
    protected boolean append = false;
    
    private String encoding = """";

    
    protected int logLevel = Project.MSG_WARN;
    

    
    public void execute() throws BuildException {
        if (file == null) {
            log(message, logLevel);
        } else {
            Writer out = null;
            try {
                String filename = file.getAbsolutePath();
                if (encoding == null || encoding.length() == 0) {
                    out = new FileWriter(filename, append);
                } else {
                    out = new BufferedWriter(
                            new OutputStreamWriter(
                                new FileOutputStream(filename, append), encoding));
                }
                out.write(message, 0, message.length());
            } catch (IOException ioe) {
                throw new BuildException(ioe, getLocation());
            } finally {
                FileUtils.close(out);
            }
        }
    }

    
    public void setMessage(String msg) {
        this.message = msg;
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setAppend(boolean append) {
        this.append = append;
    }

    
    public void addText(String msg) {
        message += getProject().replaceProperties(msg);
    }

    
    public void setLevel(EchoLevel echoLevel) {
        logLevel = echoLevel.getLevel();
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public static class EchoLevel extends LogLevel {
    }
}
"
org.apache.tools.ant.util.DOMUtils,7,1,0,3,15,21,2,1,7,2.0,66,0.0,0,0.0,0.523809524,0,0,8.428571429,1,0.8571,0,"

package org.apache.tools.ant.util;

import org.w3c.dom.CDATASection;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;




public class DOMUtils {

    
    public static Document newDocument() {
        return JAXPUtils.getDocumentBuilder().newDocument();
    }

    
    public static Element createChildElement(Element parent, String name) {
        Document doc = parent.getOwnerDocument();
        Element e = doc.createElement(name);
        parent.appendChild(e);
        return e;
    }

    
    public static void appendText(Element parent, String content) {
        Document doc = parent.getOwnerDocument();
        Text t = doc.createTextNode(content);
        parent.appendChild(t);
    }

    
    public static void appendCDATA(Element parent, String content) {
        Document doc = parent.getOwnerDocument();
        CDATASection c = doc.createCDATASection(content);
        parent.appendChild(c);
    }

    
    public static void appendTextElement(Element parent, String name,
                                         String content) {
        Element e = createChildElement(parent, name);
        appendText(e, content);
    }

    
    public static void appendCDATAElement(Element parent, String name,
                                          String content) {
        Element e = createChildElement(parent, name);
        appendCDATA(e, content);
    }
}
"
org.apache.tools.ant.helper.DefaultExecutor,4,1,0,4,8,4,0,4,3,0.666666667,45,1.0,1,0.0,0.555555556,0,0,10.0,1,0.5,0,"

package org.apache.tools.ant.helper;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.Executor;
import org.apache.tools.ant.BuildException;


public class DefaultExecutor implements Executor {

    private static final SingleCheckExecutor SUB_EXECUTOR = new SingleCheckExecutor();

    
    public void executeTargets(Project project, String[] targetNames)
        throws BuildException {
        BuildException thrownException = null;
        for (int i = 0; i < targetNames.length; i++) {
            try {
                project.executeTarget(targetNames[i]);
            } catch (BuildException ex) {
                if (project.isKeepGoingMode()) {
                    thrownException = ex;
                } else {
                    throw ex;
                }
            }
        }
        if (thrownException != null) {
            throw thrownException;
        }
    }

    
    public Executor getSubProjectExecutor() {
        return SUB_EXECUTOR;
    }

}
"
org.apache.tools.ant.taskdefs.optional.extension.Compatability,2,1,0,0,3,0,0,0,1,0.0,12,1.0,0,0.0,0.75,0,0,4.5,1,0.5,0,"
package org.apache.tools.ant.taskdefs.optional.extension;


public final class Compatability {
    
    private final String name;

    
    Compatability(final String name) {
        this.name = name;
    }

    
    public String toString() {
        return name;
    }
}
"
org.apache.tools.ant.util.Watchdog,7,1,0,3,22,0,3,1,6,0.708333333,112,0.75,0,0.0,0.476190476,0,0,14.42857143,4,1.4286,1,"

package org.apache.tools.ant.util;

import java.util.Enumeration;
import java.util.Vector;


public class Watchdog implements Runnable {

    private Vector observers = new Vector(1);
    private long timeout = -1;
    
    private volatile boolean stopped = false;
    
    public static final String ERROR_INVALID_TIMEOUT = ""timeout less than 1."";

    
    public Watchdog(long timeout) {
        if (timeout < 1) {
            throw new IllegalArgumentException(ERROR_INVALID_TIMEOUT);
        }
        this.timeout = timeout;
    }

    
    public void addTimeoutObserver(TimeoutObserver to) {
        
        observers.addElement(to);
    }

    
    public void removeTimeoutObserver(TimeoutObserver to) {
        
        observers.removeElement(to);
    }

    
    protected final void fireTimeoutOccured() {
        Enumeration e = observers.elements();
        while (e.hasMoreElements()) {
            ((TimeoutObserver) e.nextElement()).timeoutOccured(this);
        }
    }

    
    public synchronized void start() {
        stopped = false;
        Thread t = new Thread(this, ""WATCHDOG"");
        t.setDaemon(true);
        t.start();
    }

    
    public synchronized void stop() {
        stopped = true;
        notifyAll();
    }

    
    public synchronized void run() {
        final long until = System.currentTimeMillis() + timeout;
        long now;
        while (!stopped && until > (now = System.currentTimeMillis())) {
            try {
                wait(until - now);
            } catch (InterruptedException e) {
                
            }
        }
        if (!stopped) {
            fireTimeoutOccured();
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.vss.MSVSSGET,12,4,0,8,41,66,0,8,11,2.0,130,0.0,0,0.892156863,0.305555556,1,1,9.833333333,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.vss;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class MSVSSGET extends MSVSS {

    
    Commandline buildCmdLine() {
        Commandline commandLine = new Commandline();

        
        
        
        commandLine.setExecutable(getSSCommand());
        commandLine.createArgument().setValue(COMMAND_GET);

        if (getVsspath() == null) {
            throw new BuildException(""vsspath attribute must be set!"", getLocation());
        }
        commandLine.createArgument().setValue(getVsspath());

        
        commandLine.createArgument().setValue(getLocalpath());
        
        commandLine.createArgument().setValue(getAutoresponse());
        
        commandLine.createArgument().setValue(getQuiet());
        
        commandLine.createArgument().setValue(getRecursive());
        
        commandLine.createArgument().setValue(getVersionDateLabel());
        
        commandLine.createArgument().setValue(getWritable());
        
        commandLine.createArgument().setValue(getLogin());
        
        commandLine.createArgument().setValue(getFileTimeStamp());
        
        commandLine.createArgument().setValue(getWritableFiles());

        return commandLine;
    }

    
    public void setLocalpath(Path localPath) {
        super.setInternalLocalPath(localPath.toString());
    }

    
    public final void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public final void setQuiet (boolean quiet) {
        super.setInternalQuiet(quiet);
    }

    
    public final void setWritable(boolean writable) {
        super.setInternalWritable(writable);
    }

    
    public void setVersion(String version) {
        super.setInternalVersion(version);
    }

    
    public void setDate(String date) {
        super.setInternalDate(date);
    }

    
    public void setLabel(String label) {
        super.setInternalLabel(label);
    }

    
    public void setAutoresponse(String response) {
        super.setInternalAutoResponse(response);
    }

    
    public void setFileTimeStamp(CurrentModUpdated timestamp) {
        super.setInternalFileTimeStamp(timestamp);
    }

    
    public void setWritableFiles(WritableFiles files) {
        super.setInternalWritableFiles(files);
    }
}
"
org.apache.tools.ant.taskdefs.DiagnosticsTask,3,3,0,3,5,1,0,3,2,0.5,14,1.0,0,0.973684211,1.0,0,0,3.333333333,1,0.3333,0,"
package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Diagnostics;



public class DiagnosticsTask extends Task {

    private static final String[] ARGS = new String[0];

    
    public void execute() throws BuildException {
        Diagnostics.main(ARGS);
    }


}
"
org.apache.tools.ant.taskdefs.optional.extension.DeweyDecimal,2,2,0,5,4,1,4,1,2,2.0,10,0.0,0,1.0,0.666666667,0,0,4.0,0,0.0,0,"
package org.apache.tools.ant.taskdefs.optional.extension;



public final class DeweyDecimal extends org.apache.tools.ant.util.DeweyDecimal {

    
    public DeweyDecimal(final int[] components) {
        super(components);
    }

    
    public DeweyDecimal(final String string)
        throws NumberFormatException {
        super(string);
    }
}
"
org.apache.tools.ant.taskdefs.condition.And,2,3,0,3,7,1,1,3,2,2.0,23,0.0,0,0.96969697,1.0,0,0,10.5,1,0.5,0,"

package org.apache.tools.ant.taskdefs.condition;

import java.util.Enumeration;
import org.apache.tools.ant.BuildException;


public class And extends ConditionBase implements Condition {

    
    public boolean eval() throws BuildException {
        Enumeration e = getConditions();
        while (e.hasMoreElements()) {
            Condition c = (Condition) e.nextElement();
            if (!c.eval()) {
                return false;
            }
        }
        return true;
    }

}
"
org.apache.tools.ant.types.Commandline,31,1,0,81,71,311,78,5,27,0.75,644,1.0,0,0.0,0.176190476,0,0,19.64516129,16,2.1935,2,"

package org.apache.tools.ant.types;

import java.io.File;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.LinkedList;
import java.util.Iterator;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.taskdefs.condition.Os;


public class Commandline implements Cloneable {
    
    private static final boolean IS_WIN_9X = Os.isFamily(""win9x"");

    
    private Vector arguments = new Vector();

    
    private String executable = null;

    protected static final String DISCLAIMER =
        StringUtils.LINE_SEP
        + ""The \' characters around the executable and arguments are""
        + StringUtils.LINE_SEP
        + ""not part of the command.""
        + StringUtils.LINE_SEP;

    
    public Commandline(String toProcess) {
        super();
        String[] tmp = translateCommandline(toProcess);
        if (tmp != null && tmp.length > 0) {
            setExecutable(tmp[0]);
            for (int i = 1; i < tmp.length; i++) {
                createArgument().setValue(tmp[i]);
            }
        }
    }

    
    public Commandline() {
        super();
    }

    
    public static class Argument extends ProjectComponent {

        private String[] parts;

        
        public void setValue(String value) {
            parts = new String[] {value};
        }

        
        public void setLine(String line) {
            if (line == null) {
                return;
            }
            parts = translateCommandline(line);
        }

        
        public void setPath(Path value) {
            parts = new String[] {value.toString()};
        }

        
        public void setPathref(Reference value) {
            Path p = new Path(getProject());
            p.setRefid(value);
            parts = new String[] {p.toString()};
        }

        
        public void setFile(File value) {
            parts = new String[] {value.getAbsolutePath()};
        }

        
        public String[] getParts() {
            return parts;
        }
    }

    
    public class Marker {

        private int position;
        private int realPos = -1;

        
        Marker(int position) {
            this.position = position;
        }

        
        public int getPosition() {
            if (realPos == -1) {
                realPos = (executable == null ? 0 : 1);
                for (int i = 0; i < position; i++) {
                    Argument arg = (Argument) arguments.elementAt(i);
                    realPos += arg.getParts().length;
                }
            }
            return realPos;
        }
    }

    
    public Argument createArgument() {
        return this.createArgument(false);
    }

    
    public Argument createArgument(boolean insertAtStart) {
        Argument argument = new Argument();
        if (insertAtStart) {
            arguments.insertElementAt(argument, 0);
        } else {
            arguments.addElement(argument);
        }
        return argument;
    }

    
    public void setExecutable(String executable) {
        if (executable == null || executable.length() == 0) {
            return;
        }
        this.executable = executable.replace('/', File.separatorChar)
            .replace('\\', File.separatorChar);
    }

    
    public String getExecutable() {
        return executable;
    }

    
    public void addArguments(String[] line) {
        for (int i = 0; i < line.length; i++) {
            createArgument().setValue(line[i]);
        }
    }

    
    public String[] getCommandline() {
        List commands = new LinkedList();
        ListIterator list = commands.listIterator();
        addCommandToList(list);
        final String[] result = new String[commands.size()];
        return (String[]) commands.toArray(result);
    }

    
    public void addCommandToList(ListIterator list) {
        if (executable != null) {
            list.add(executable);
        }
        addArgumentsToList(list);
    }

    
    public String[] getArguments() {
        List result = new ArrayList(arguments.size() * 2);
        addArgumentsToList(result.listIterator());
        String [] res = new String[result.size()];
        return (String[]) result.toArray(res);
    }

    
    public void addArgumentsToList(ListIterator list) {
        for (int i = 0; i < arguments.size(); i++) {
            Argument arg = (Argument) arguments.elementAt(i);
            String[] s = arg.getParts();
            if (s != null) {
                for (int j = 0; j < s.length; j++) {
                    list.add(s[j]);
                }
            }
        }
    }

    
    public String toString() {
        return toString(getCommandline());
    }

    
    public static String quoteArgument(String argument) {
        if (argument.indexOf(""\"""") > -1) {
            if (argument.indexOf(""\'"") > -1) {
                throw new BuildException(""Can\'t handle single and double""
                        + "" quotes in same argument"");
            } else {
                return '\'' + argument + '\'';
            }
        } else if (argument.indexOf(""\'"") > -1
                   || argument.indexOf("" "") > -1
                   
                   || (IS_WIN_9X && argument.indexOf(';') != -1)) {
            return '\""' + argument + '\""';
        } else {
            return argument;
        }
    }

    
    public static String toString(String[] line) {
        
        if (line == null || line.length == 0) {
            return """";
        }
        
        final StringBuffer result = new StringBuffer();
        for (int i = 0; i < line.length; i++) {
            if (i > 0) {
                result.append(' ');
            }
            result.append(quoteArgument(line[i]));
        }
        return result.toString();
    }

    
    public static String[] translateCommandline(String toProcess) {
        if (toProcess == null || toProcess.length() == 0) {
            
            return new String[0];
        }
        

        final int normal = 0;
        final int inQuote = 1;
        final int inDoubleQuote = 2;
        int state = normal;
        StringTokenizer tok = new StringTokenizer(toProcess, ""\""\' "", true);
        Vector v = new Vector();
        StringBuffer current = new StringBuffer();
        boolean lastTokenHasBeenQuoted = false;

        while (tok.hasMoreTokens()) {
            String nextTok = tok.nextToken();
            switch (state) {
            case inQuote:
                if (""\'"".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            case inDoubleQuote:
                if (""\"""".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            default:
                if (""\'"".equals(nextTok)) {
                    state = inQuote;
                } else if (""\"""".equals(nextTok)) {
                    state = inDoubleQuote;
                } else if ("" "".equals(nextTok)) {
                    if (lastTokenHasBeenQuoted || current.length() != 0) {
                        v.addElement(current.toString());
                        current = new StringBuffer();
                    }
                } else {
                    current.append(nextTok);
                }
                lastTokenHasBeenQuoted = false;
                break;
            }
        }
        if (lastTokenHasBeenQuoted || current.length() != 0) {
            v.addElement(current.toString());
        }
        if (state == inQuote || state == inDoubleQuote) {
            throw new BuildException(""unbalanced quotes in "" + toProcess);
        }
        String[] args = new String[v.size()];
        v.copyInto(args);
        return args;
    }

    
    public int size() {
        return getCommandline().length;
    }

    
    public Object clone() {
        try {
            Commandline c = (Commandline) super.clone();
            c.arguments = (Vector) arguments.clone();
            return c;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
    }

    
    public void clear() {
        executable = null;
        arguments.removeAllElements();
    }

    
    public void clearArgs() {
        arguments.removeAllElements();
    }

    
    public Marker createMarker() {
        return new Marker(arguments.size());
    }

    
    public String describeCommand() {
        return describeCommand(this);
    }

    
    public String describeArguments() {
        return describeArguments(this);
    }

    
    public static String describeCommand(Commandline line) {
        return describeCommand(line.getCommandline());
    }

    
    public static String describeArguments(Commandline line) {
        return describeArguments(line.getArguments());
    }

    
    public static String describeCommand(String[] args) {
        if (args == null || args.length == 0) {
            return """";
        }
        StringBuffer buf = new StringBuffer(""Executing \'"");
        buf.append(args[0]);
        buf.append(""\'"");
        if (args.length > 1) {
            buf.append("" with "");
            buf.append(describeArguments(args, 1));
        } else {
            buf.append(DISCLAIMER);
        }
        return buf.toString();
    }

    
    public static String describeArguments(String[] args) {
        return describeArguments(args, 0);
    }

    
    protected static String describeArguments(String[] args, int offset) {
        if (args == null || args.length <= offset) {
            return """";
        }
        StringBuffer buf = new StringBuffer(""argument"");
        if (args.length > offset) {
            buf.append(""s"");
        }
        buf.append("":"").append(StringUtils.LINE_SEP);
        for (int i = offset; i < args.length; i++) {
            buf.append(""\'"").append(args[i]).append(""\'"")
                .append(StringUtils.LINE_SEP);
        }
        buf.append(DISCLAIMER);
        return buf.toString();
    }

    
    public Iterator iterator() {
        return arguments.iterator();
    }
}
"
org.apache.tools.ant.UnsupportedElementException,2,5,0,3,3,0,2,1,2,0.0,13,1.0,0,0.954545455,0.75,0,0,5.0,1,0.5,0,"
package org.apache.tools.ant;


public class UnsupportedElementException extends BuildException {

    private String element;

    
    public UnsupportedElementException(String msg, String element) {
        super(msg);
        this.element = element;
    }

    
    public String getElement() {
        return element;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ccm.CCMReconfigure,9,4,0,6,25,18,0,6,8,0.875,120,0.5,0,0.843137255,0.361111111,1,1,11.66666667,4,1.2222,0,"

package org.apache.tools.ant.taskdefs.optional.ccm;


import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;



public class CCMReconfigure extends Continuus {

    private String ccmProject = null;
    private boolean recurse = false;
    private boolean verbose = false;

    
    public CCMReconfigure() {
        super();
        setCcmAction(COMMAND_RECONFIGURE);
    }


    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        int result = 0;

        
        
        commandLine.setExecutable(getCcmCommand());
        commandLine.createArgument().setValue(getCcmAction());

        checkOptions(commandLine);

        result = run(commandLine);
        if (Execute.isFailure(result)) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {

        if (isRecurse()) {
            cmd.createArgument().setValue(FLAG_RECURSE);
        } 

        if (isVerbose()) {
            cmd.createArgument().setValue(FLAG_VERBOSE);
        } 

        if (getCcmProject() != null) {
            cmd.createArgument().setValue(FLAG_PROJECT);
            cmd.createArgument().setValue(getCcmProject());
        }

    }

    
    public String getCcmProject() {
        return ccmProject;
    }

    
    public void setCcmProject(String v) {
        this.ccmProject = v;
    }


    
    public boolean isRecurse() {
        return recurse;
    }

    
    public void setRecurse(boolean v) {
        this.recurse = v;
    }


    
    public boolean isVerbose() {
        return verbose;
    }

    
    public void setVerbose(boolean v) {
        this.verbose = v;
    }


    
    public static final String FLAG_RECURSE = ""/recurse"";

    
    public static final String FLAG_VERBOSE = ""/verbose"";


    
    public static final String FLAG_PROJECT = ""/project"";

}

"
org.apache.tools.ant.Executor,2,1,0,4,2,1,3,2,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;


public interface Executor {

    
    void executeTargets(Project project, String[] targetNames)
        throws BuildException;

    
    Executor getSubProjectExecutor();

}
"
org.apache.tools.ant.taskdefs.Recorder,20,3,0,9,46,160,0,9,17,0.859649123,206,1.0,0,0.672727273,0.263157895,1,1,9.0,2,1.05,2,"
package org.apache.tools.ant.taskdefs;

import java.util.Hashtable;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.SubBuildListener;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.LogLevel;


public class Recorder extends Task implements SubBuildListener {

    
    

    
    private String filename = null;
    
    private Boolean append = null;
    
    private Boolean start = null;
    
    private int loglevel = -1;
    
    private boolean emacsMode = false;
    
    private static Hashtable recorderEntries = new Hashtable();

    
    

    
    public void init() {
        getProject().addBuildListener(this);
    }

    
    

    
    public void setName(String fname) {
        filename = fname;
    }


    
    public void setAction(ActionChoices action) {
        if (action.getValue().equalsIgnoreCase(""start"")) {
            start = Boolean.TRUE;
        } else {
            start = Boolean.FALSE;
        }
    }


    
    public void setAppend(boolean append) {
        this.append = (append ? Boolean.TRUE : Boolean.FALSE);
    }


    
    public void setEmacsMode(boolean emacsMode) {
        this.emacsMode = emacsMode;
    }


    
    public void setLoglevel(VerbosityLevelChoices level) {
        loglevel = level.getLevel();
    }

    
    

    
    public void execute() throws BuildException {
        if (filename == null) {
            throw new BuildException(""No filename specified"");
        }

        getProject().log(""setting a recorder for name "" + filename,
            Project.MSG_DEBUG);

        
        RecorderEntry recorder = getRecorder(filename, getProject());
        
        recorder.setMessageOutputLevel(loglevel);
        recorder.setEmacsMode(emacsMode);
        if (start != null) {
            if (start.booleanValue()) {
                recorder.reopenFile();
                recorder.setRecordState(start);
            } else {
                recorder.setRecordState(start);
                recorder.closeFile();
            }
        }
    }

    
    

    
    public static class ActionChoices extends EnumeratedAttribute {
        private static final String[] VALUES = {""start"", ""stop""};

        
        
        public String[] getValues() {
            return VALUES;
        }
    }


    
    public static class VerbosityLevelChoices extends LogLevel {
    }


    
    protected RecorderEntry getRecorder(String name, Project proj)
         throws BuildException {
        Object o = recorderEntries.get(name);
        RecorderEntry entry;

        if (o == null) {
            
            entry = new RecorderEntry(name);

            if (append == null) {
                entry.openFile(false);
            } else {
                entry.openFile(append.booleanValue());
            }
            entry.setProject(proj);
            recorderEntries.put(name, entry);
        } else {
            entry = (RecorderEntry) o;
        }
        return entry;
    }

    
    public void buildStarted(BuildEvent event) {
    }

    
    public void subBuildStarted(BuildEvent event) {
    }

    
    public void targetStarted(BuildEvent event) {
    }

    
    public void targetFinished(BuildEvent event) {
    }

    
    public void taskStarted(BuildEvent event) {
    }

    
    public void taskFinished(BuildEvent event) {
    }

    
    public void messageLogged(BuildEvent event) {
    }

    
    public void buildFinished(BuildEvent event) {
        cleanup();
    }

    
    public void subBuildFinished(BuildEvent event) {
        if (event.getProject() == getProject()) {
            cleanup();
        }
    }

    
    private void cleanup() {
        recorderEntries.clear();
        getProject().removeBuildListener(this);
    }
}

"
org.apache.tools.ant.types.selectors.AbstractSelectorContainer,27,3,2,25,41,321,2,23,27,0.0,191,1.0,0,0.535714286,0.084656085,0,0,6.037037037,4,1.1852,1,"

package org.apache.tools.ant.types.selectors;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;


public abstract class AbstractSelectorContainer extends DataType
        implements SelectorContainer {

    private Vector selectorsList = new Vector();

    
    public boolean hasSelectors() {
        return !(selectorsList.isEmpty());
    }

    
    public int selectorCount() {
        return selectorsList.size();
    }

    
    public FileSelector[] getSelectors(Project p) {
        FileSelector[] result = new FileSelector[selectorsList.size()];
        selectorsList.copyInto(result);
        return result;
    }

    
    public Enumeration selectorElements() {
        return selectorsList.elements();
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        Enumeration e = selectorElements();
        if (e.hasMoreElements()) {
            while (e.hasMoreElements()) {
                buf.append(e.nextElement().toString());
                if (e.hasMoreElements()) {
                    buf.append("", "");
                }
            }
        }

        return buf.toString();
    }

    
    public void appendSelector(FileSelector selector) {
        selectorsList.addElement(selector);
    }

    
    public void validate() {
        Enumeration e = selectorElements();
        while (e.hasMoreElements()) {
            Object o = e.nextElement();
            if (o instanceof BaseSelector) {
                ((BaseSelector) o).validate();
            }
        }
    }


    

    
    public void addSelector(SelectSelector selector) {
        appendSelector(selector);
    }

    
    public void addAnd(AndSelector selector) {
        appendSelector(selector);
    }

    
    public void addOr(OrSelector selector) {
        appendSelector(selector);
    }

    
    public void addNot(NotSelector selector) {
        appendSelector(selector);
    }

    
    public void addNone(NoneSelector selector) {
        appendSelector(selector);
    }

    
    public void addMajority(MajoritySelector selector) {
        appendSelector(selector);
    }

    
    public void addDate(DateSelector selector) {
        appendSelector(selector);
    }

    
    public void addSize(SizeSelector selector) {
        appendSelector(selector);
    }

    
    public void addFilename(FilenameSelector selector) {
        appendSelector(selector);
    }

    
    public void addCustom(ExtendSelector selector) {
        appendSelector(selector);
    }

    
    public void addContains(ContainsSelector selector) {
        appendSelector(selector);
    }

    
    public void addPresent(PresentSelector selector) {
        appendSelector(selector);
    }

    
    public void addDepth(DepthSelector selector) {
        appendSelector(selector);
    }

    
    public void addDepend(DependSelector selector) {
        appendSelector(selector);
    }

    
    public void addDifferent(DifferentSelector selector) {
        appendSelector(selector);
    }

    
    public void addType(TypeSelector selector) {
        appendSelector(selector);
    }

    
    public void addContainsRegexp(ContainsRegexpSelector selector) {
        appendSelector(selector);
    }

    
    public void addModified(ModifiedSelector selector) {
        appendSelector(selector);
    }

    
    public void add(FileSelector selector) {
        appendSelector(selector);
    }

}
"
org.apache.tools.ant.types.resources.Tokens,5,4,0,10,27,2,0,10,3,0.625,146,1.0,1,0.913043478,0.36,2,5,27.8,5,2.0,0,"
package org.apache.tools.ant.types.resources;

import java.io.InputStreamReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Stack;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.util.ConcatResourceInputStream;
import org.apache.tools.ant.util.LineTokenizer;
import org.apache.tools.ant.util.Tokenizer;


public class Tokens extends BaseResourceCollectionWrapper {

    private Tokenizer tokenizer;
    private String encoding;

    
    protected synchronized Collection getCollection() {
        ResourceCollection rc = getResourceCollection();
        if (rc.size() == 0) {
            return Collections.EMPTY_SET;
        }
        if (tokenizer == null) {
            tokenizer = new LineTokenizer();
        }
        ConcatResourceInputStream cat = new ConcatResourceInputStream(rc);
        cat.setManagingComponent(this);

        InputStreamReader rdr = null;
        if (encoding == null) {
            rdr = new InputStreamReader(cat);
        } else {
            try {
                rdr = new InputStreamReader(cat, encoding);
            } catch (UnsupportedEncodingException e) {
                throw new BuildException(e);
            }
        }
        ArrayList result = new ArrayList();
        try {
            for (String s = tokenizer.getToken(rdr); s != null; s = tokenizer.getToken(rdr)) {
                result.add(new StringResource(s));
            }
        } catch (IOException e) {
            throw new BuildException(""Error reading tokens"", e);
        }
        return result;
    }

    
    public synchronized void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public synchronized void add(Tokenizer tokenizer) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.tokenizer != null) {
            throw new BuildException(""Only one nested tokenizer allowed."");
        }
        this.tokenizer = tokenizer;
    }

    
    protected synchronized void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            if (tokenizer instanceof DataType) {
                stk.push(tokenizer);
                invokeCircularReferenceCheck((DataType) tokenizer, stk, p);
            }
            setChecked(true);
        }
    }

}
"
org.apache.tools.ant.taskdefs.compilers.Javac13,2,2,0,6,13,1,1,5,2,2.0,66,1.0,0,0.958333333,1.0,0,0,31.5,1,0.5,0,"

package org.apache.tools.ant.taskdefs.compilers;

import java.lang.reflect.Method;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;



public class Javac13 extends DefaultCompilerAdapter {

    
    private static final int MODERN_COMPILER_SUCCESS = 0;

    
    public boolean execute() throws BuildException {
        attributes.log(""Using modern compiler"", Project.MSG_VERBOSE);
        Commandline cmd = setupModernJavacCommand();

        
        try {
            Class c = Class.forName (""com.sun.tools.javac.Main"");
            Object compiler = c.newInstance ();
            Method compile = c.getMethod (""compile"",
                new Class [] {(new String [] {}).getClass ()});
            int result = ((Integer) compile.invoke
                          (compiler, new Object[] {cmd.getArguments()}))
                .intValue ();
            return (result == MODERN_COMPILER_SUCCESS);
        } catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(""Error starting modern compiler"",
                                         ex, location);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.compilers.Javac12,2,2,0,10,22,1,1,9,2,1.25,163,0.25,0,0.958333333,1.0,0,0,78.5,1,0.5,0,"

package org.apache.tools.ant.taskdefs.compilers;

import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.Commandline;


public class Javac12 extends DefaultCompilerAdapter {
    protected static final String CLASSIC_COMPILER_CLASSNAME = ""sun.tools.javac.Main"";

    
    public boolean execute() throws BuildException {
        attributes.log(""Using classic compiler"", Project.MSG_VERBOSE);
        Commandline cmd = setupJavacCommand(true);

        OutputStream logstr = new LogOutputStream(attributes, Project.MSG_WARN);
        try {
            
            
            Class c = Class.forName(CLASSIC_COMPILER_CLASSNAME);
            Constructor cons =
                c.getConstructor(new Class[] {OutputStream.class,
                                              String.class});
            Object compiler
                = cons.newInstance(new Object[] {logstr, ""javac""});

            
            Method compile = c.getMethod(""compile"",
                                         new Class [] {String[].class});
            Boolean ok =
                (Boolean) compile.invoke(compiler,
                                        new Object[] {cmd.getArguments()});
            return ok.booleanValue();
        } catch (ClassNotFoundException ex) {
            throw new BuildException(""Cannot use classic compiler , as it is ""
                                        + ""not available. \n""
                                        + "" A common solution is ""
                                        + ""to set the environment variable""
                                        + "" JAVA_HOME to your jdk directory.\n""
                                        + ""It is currently set to \""""
                                        + JavaEnvUtils.getJavaHome()
                                        + ""\"""",
                                        location);
        } catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(""Error starting classic compiler: "",
                                         ex, location);
            }
        } finally {
            FileUtils.close(logstr);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Revert,4,4,0,4,13,0,0,4,4,0.333333333,81,1.0,0,0.944444444,0.5,1,1,18.75,1,0.75,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;


public class P4Revert extends P4Base {

    private String revertChange = null;
    private boolean onlyUnchanged = false;

    
    public void setChange(String revertChange) throws BuildException {
        if (revertChange == null || revertChange.equals("""")) {
            throw new BuildException(""P4Revert: change cannot be null or empty"");
        }

        this.revertChange = revertChange;

    }

    
    public void setRevertOnlyUnchanged(boolean onlyUnchanged) {
        this.onlyUnchanged = onlyUnchanged;
    }

    
    public void execute() throws BuildException {

        
        String p4cmd = ""-s revert"";
        if (onlyUnchanged) {
            p4cmd += "" -a"";
        }

        if (revertChange != null) {
            p4cmd += "" -c "" + revertChange;
        }

        execP4Command(p4cmd + "" "" + P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.filters.HeadFilter,10,5,0,5,25,0,1,4,6,0.703703704,251,1.0,1,0.777777778,0.375,2,4,23.2,5,1.6,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.util.LineTokenizer;
import org.apache.tools.ant.types.Parameter;


public final class HeadFilter extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String LINES_KEY = ""lines"";

    
    private static final String SKIP_KEY = ""skip"";

    
    private long linesRead = 0;

    
    private static final int DEFAULT_NUM_LINES = 10;

    
    private long lines = DEFAULT_NUM_LINES;

    
    private long skip = 0;

    
    private LineTokenizer lineTokenizer = null;

    
    private String    line      = null;
    
    private int       linePos   = 0;

    
    public HeadFilter() {
        super();
    }

    
    public HeadFilter(final Reader in) {
        super(in);
        lineTokenizer = new LineTokenizer();
        lineTokenizer.setIncludeDelims(true);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        while (line == null || line.length() == 0) {
            line = lineTokenizer.getToken(in);
            if (line == null) {
                return -1;
            }
            line = headFilter(line);
            linePos = 0;
        }

        int ch = line.charAt(linePos);
        linePos++;
        if (linePos == line.length()) {
            line = null;
        }
        return ch;
    }

    
    public void setLines(final long lines) {
        this.lines = lines;
    }

    
    private long getLines() {
        return lines;
    }

    
    public void setSkip(final long skip) {
        this.skip = skip;
    }

    
    private long getSkip() {
        return skip;
    }

    
    public Reader chain(final Reader rdr) {
        HeadFilter newFilter = new HeadFilter(rdr);
        newFilter.setLines(getLines());
        newFilter.setSkip(getSkip());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (LINES_KEY.equals(params[i].getName())) {
                    lines = new Long(params[i].getValue()).longValue();
                    continue;
                }
                if (SKIP_KEY.equals(params[i].getName())) {
                    skip = new Long(params[i].getValue()).longValue();
                    continue;
                }
            }
        }
    }

    
    private String headFilter(String line) {
        linesRead++;
        if (skip > 0) {
            if ((linesRead - 1) < skip) {
                return null;
            }
        }

        if (lines > 0) {
            if (linesRead > (lines + skip)) {
                return null;
            }
        }
        return line;
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner,39,1,0,25,150,625,8,21,24,0.878718535,1561,0.913043478,1,0.0,0.111111111,0,0,38.43589744,27,2.2308,6,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;
import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestFailure;
import junit.framework.TestListener;
import junit.framework.TestResult;
import junit.framework.TestSuite;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Permissions;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.util.TeeOutputStream;



public class JUnitTestRunner implements TestListener, JUnitTaskMirror.JUnitTestRunnerMirror {

    
    private Vector formatters = new Vector();

    
    private TestResult res;

    
    private static boolean filtertrace = true;

    
    private boolean showOutput = false;

    private boolean outputToFormatters = true;

    
    private Permissions perm = null;

    private static final String[] DEFAULT_TRACE_FILTERS = new String[] {
                ""junit.framework.TestCase"",
                ""junit.framework.TestResult"",
                ""junit.framework.TestSuite"",
                ""junit.framework.Assert."", 
                ""junit.swingui.TestRunner"",
                ""junit.awtui.TestRunner"",
                ""junit.textui.TestRunner"",
                ""java.lang.reflect.Method.invoke("",
                ""sun.reflect."",
                ""org.apache.tools.ant."",
                
                ""org.junit."",
                ""junit.framework.JUnit4TestAdapter"",
                
                ""Caused by: java.lang.AssertionError"",
                "" more"",
        };


    
    private boolean haltOnError = false;

    
    private boolean haltOnFailure = false;

    
    private int retCode = SUCCESS;

    
    private JUnitTest junitTest;

    
    private PrintStream systemError;

    
    private PrintStream systemOut;

    
    private boolean forked = false;

    
    private static boolean multipleTests = false;

    
    private ClassLoader loader;

    
    private boolean logTestListenerEvents = false;

    
    private boolean junit4;

    
    private static String crashFile = null;

    
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean filtertrace, boolean haltOnFailure) {
        this(test, haltOnError, filtertrace, haltOnFailure, false);
    }

    
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean filtertrace, boolean haltOnFailure,
                           boolean showOutput) {
        this(test, haltOnError, filtertrace, haltOnFailure, showOutput, false);
    }

    
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean filtertrace, boolean haltOnFailure,
                           boolean showOutput, boolean logTestListenerEvents) {
        this(test, haltOnError, filtertrace, haltOnFailure, showOutput,
             logTestListenerEvents, null);
    }

    
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean filtertrace, boolean haltOnFailure,
                           ClassLoader loader) {
        this(test, haltOnError, filtertrace, haltOnFailure, false, loader);
    }

    
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean filtertrace, boolean haltOnFailure,
                           boolean showOutput, ClassLoader loader) {
        this(test, haltOnError, filtertrace, haltOnFailure, showOutput,
             false, loader);
    }

    
    public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                           boolean filtertrace, boolean haltOnFailure,
                           boolean showOutput, boolean logTestListenerEvents,
                           ClassLoader loader) {
        JUnitTestRunner.filtertrace = filtertrace;
        this.junitTest = test;
        this.haltOnError = haltOnError;
        this.haltOnFailure = haltOnFailure;
        this.showOutput = showOutput;
        this.logTestListenerEvents = logTestListenerEvents;
        this.loader = loader;
    }

    private PrintStream savedOut = null;

    
    public void run() {
        res = new TestResult();
        res.addListener(wrapListener(this));
        for (int i = 0; i < formatters.size(); i++) {
            res.addListener(wrapListener((TestListener) formatters.elementAt(i)));
        }

        ByteArrayOutputStream errStrm = new ByteArrayOutputStream();
        systemError = new PrintStream(errStrm);

        ByteArrayOutputStream outStrm = new ByteArrayOutputStream();
        systemOut = new PrintStream(outStrm);

        PrintStream savedErr = null;

        if (forked) {
            if (!outputToFormatters) {
                if (!showOutput) {
                    savedOut = System.out;
                    savedErr = System.err;
                    System.setOut(
                        new PrintStream(
                            new OutputStream() {
                                public void write(int b) {
                                }
                            }));
                    System.setErr(
                        new PrintStream(
                            new OutputStream() {
                                public void write(int b) {
                                }
                            }));
                }
            } else {
                savedOut = System.out;
                savedErr = System.err;
                if (!showOutput) {
                    System.setOut(systemOut);
                    System.setErr(systemError);
                } else {
                    System.setOut(new PrintStream(
                                      new TeeOutputStream(savedOut, systemOut)
                                      )
                                  );
                    System.setErr(new PrintStream(
                                      new TeeOutputStream(savedErr,
                                                          systemError)
                                      )
                                  );
                }
                perm = null;
            }
        } else {
            if (perm != null) {
                perm.setSecurityManager();
            }
        }

        Test suite = null;
        Throwable exception = null;
        boolean startTestSuiteSuccess = false;

        try {

            try {
                Class testClass = null;
                if (loader == null) {
                    testClass = Class.forName(junitTest.getName());
                } else {
                    testClass = Class.forName(junitTest.getName(), true,
                                              loader);
                }

                
                
                Method suiteMethod = null;
                try {
                    
                    suiteMethod = testClass.getMethod(""suite"", new Class[0]);
                } catch (NoSuchMethodException e) {
                    
                    
                }

                if (suiteMethod != null) {
                    
                    
                    
                    suite = (Test) suiteMethod.invoke(null, new Class[0]);

                } else {
                    Class junit4TestAdapterClass = null;

                    
                    
                    
                    

                    
                    

                    try {
                        Class.forName(""java.lang.annotation.Annotation"");
                        if (loader == null) {
                            junit4TestAdapterClass =
                                Class.forName(""junit.framework.JUnit4TestAdapter"");
                        } else {
                            junit4TestAdapterClass =
                                Class.forName(""junit.framework.JUnit4TestAdapter"",
                                              true, loader);
                        }
                    } catch (ClassNotFoundException e) {
                        
                    }
                    junit4 = junit4TestAdapterClass != null;

                    if (junit4) {
                        
                        suite =
                            (Test) junit4TestAdapterClass
                            .getConstructor(new Class[] {Class.class}).
                            newInstance(new Object[] {testClass});
                    } else {
                        

                        
                        
                        
                        suite = new TestSuite(testClass);
                    }

                }

            } catch (Throwable e) {
                retCode = ERRORS;
                exception = e;
            }

            long start = System.currentTimeMillis();

            fireStartTestSuite();
            startTestSuiteSuccess = true;
            if (exception != null) { 
                for (int i = 0; i < formatters.size(); i++) {
                    ((TestListener) formatters.elementAt(i))
                        .addError(null, exception);
                }
                junitTest.setCounts(1, 0, 1);
                junitTest.setRunTime(0);
            } else {
                try {
                    logTestListenerEvent(""tests to run: "" + suite.countTestCases());
                    suite.run(res);
                } finally {
                    if (junit4) {
                        int[] cnts = findJUnit4FailureErrorCount(res);
                        junitTest.setCounts(res.runCount(), cnts[0], cnts[1]);
                    } else {
                        junitTest.setCounts(res.runCount(), res.failureCount(),
                                res.errorCount());
                    }
                    junitTest.setRunTime(System.currentTimeMillis() - start);
                }
            }
        } finally {
            if (perm != null) {
                perm.restoreSecurityManager();
            }
            if (savedOut != null) {
                System.setOut(savedOut);
            }
            if (savedErr != null) {
                System.setErr(savedErr);
            }

            systemError.close();
            systemError = null;
            systemOut.close();
            systemOut = null;
            if (startTestSuiteSuccess) {
                sendOutAndErr(new String(outStrm.toByteArray()),
                              new String(errStrm.toByteArray()));
            }
        }
        fireEndTestSuite();

        if (retCode != SUCCESS || res.errorCount() != 0) {
            retCode = ERRORS;
        } else if (res.failureCount() != 0) {
            retCode = FAILURES;
        }
    }

    
    public int getRetCode() {
        return retCode;
    }

    
    public void startTest(Test t) {
        String testName = JUnitVersionHelper.getTestCaseName(t);
        logTestListenerEvent(""startTest("" + testName + "")"");
    }

    
    public void endTest(Test test) {
        String testName = JUnitVersionHelper.getTestCaseName(test);
        logTestListenerEvent(""endTest("" + testName + "")"");
    }

    private void logTestListenerEvent(String msg) {
        PrintStream out = savedOut != null ? savedOut : System.out;
        if (logTestListenerEvents) {
            out.flush();
            out.println(JUnitTask.TESTLISTENER_PREFIX + msg);
            out.flush();
        }
    }

    
    public void addFailure(Test test, Throwable t) {
        String testName = JUnitVersionHelper.getTestCaseName(test);
        logTestListenerEvent(""addFailure("" + testName + "", "" + t.getMessage() + "")"");
        if (haltOnFailure) {
            res.stop();
        }
    }

    
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }

    
    public void addError(Test test, Throwable t) {
        String testName = JUnitVersionHelper.getTestCaseName(test);
        logTestListenerEvent(""addError("" + testName + "", "" + t.getMessage() + "")"");
        if (haltOnError) {
            res.stop();
        }
    }

    
    public void setPermissions(Permissions permissions) {
        perm = permissions;
    }

    
    public void handleOutput(String output) {
        if (!logTestListenerEvents && output.startsWith(JUnitTask.TESTLISTENER_PREFIX)) {
            
        } else if (systemOut != null) {
            systemOut.print(output);
        }
    }

    
    public int handleInput(byte[] buffer, int offset, int length)
        throws IOException {
        return -1;
    }

    
    public void handleErrorOutput(String output) {
        if (systemError != null) {
            systemError.print(output);
        }
    }

    
    public void handleFlush(String output) {
        if (systemOut != null) {
            systemOut.print(output);
        }
    }

    
    public void handleErrorFlush(String output) {
        if (systemError != null) {
            systemError.print(output);
        }
    }

    private void sendOutAndErr(String out, String err) {
        for (int i = 0; i < formatters.size(); i++) {
            JUnitResultFormatter formatter =
                ((JUnitResultFormatter) formatters.elementAt(i));

            formatter.setSystemOutput(out);
            formatter.setSystemError(err);
        }
    }

    private void fireStartTestSuite() {
        for (int i = 0; i < formatters.size(); i++) {
            ((JUnitResultFormatter) formatters.elementAt(i))
                .startTestSuite(junitTest);
        }
    }

    private void fireEndTestSuite() {
        for (int i = 0; i < formatters.size(); i++) {
            ((JUnitResultFormatter) formatters.elementAt(i))
                .endTestSuite(junitTest);
        }
    }

    
    public void addFormatter(JUnitResultFormatter f) {
        formatters.addElement(f);
    }

    
    public void addFormatter(JUnitTaskMirror.JUnitResultFormatterMirror f) {
        formatters.addElement((JUnitResultFormatter) f);
    }

    
    public static void main(String[] args) throws IOException {
        boolean haltError = false;
        boolean haltFail = false;
        boolean stackfilter = true;
        Properties props = new Properties();
        boolean showOut = false;
        boolean outputToFormat = true;
        boolean logTestListenerEvents = false;


        if (args.length == 0) {
            System.err.println(""required argument TestClassName missing"");
            System.exit(ERRORS);
        }

        if (args[0].startsWith(Constants.TESTSFILE)) {
            multipleTests = true;
            args[0] = args[0].substring(Constants.TESTSFILE.length());
        }

        for (int i = 1; i < args.length; i++) {
            if (args[i].startsWith(Constants.HALT_ON_ERROR)) {
                haltError = Project.toBoolean(args[i].substring(Constants.HALT_ON_ERROR.length()));
            } else if (args[i].startsWith(Constants.HALT_ON_FAILURE)) {
                haltFail = Project.toBoolean(args[i].substring(Constants.HALT_ON_FAILURE.length()));
            } else if (args[i].startsWith(Constants.FILTERTRACE)) {
                stackfilter = Project.toBoolean(args[i].substring(Constants.FILTERTRACE.length()));
            } else if (args[i].startsWith(Constants.CRASHFILE)) {
                crashFile = args[i].substring(Constants.CRASHFILE.length());
                registerTestCase(Constants.BEFORE_FIRST_TEST);
            } else if (args[i].startsWith(Constants.FORMATTER)) {
                try {
                    createAndStoreFormatter(args[i].substring(Constants.FORMATTER.length()));
                } catch (BuildException be) {
                    System.err.println(be.getMessage());
                    System.exit(ERRORS);
                }
            } else if (args[i].startsWith(Constants.PROPSFILE)) {
                FileInputStream in = new FileInputStream(args[i]
                                                         .substring(Constants.PROPSFILE.length()));
                props.load(in);
                in.close();
            } else if (args[i].startsWith(Constants.SHOWOUTPUT)) {
                showOut = Project.toBoolean(args[i].substring(Constants.SHOWOUTPUT.length()));
            } else if (args[i].startsWith(Constants.LOGTESTLISTENEREVENTS)) {
                logTestListenerEvents = Project.toBoolean(
                    args[i].substring(Constants.LOGTESTLISTENEREVENTS.length()));
            } else if (args[i].startsWith(Constants.OUTPUT_TO_FORMATTERS)) {
                outputToFormat = Project.toBoolean(
                    args[i].substring(Constants.OUTPUT_TO_FORMATTERS.length()));
            }
        }

        
        Hashtable p = System.getProperties();
        for (Enumeration e = p.keys(); e.hasMoreElements();) {
            Object key = e.nextElement();
            props.put(key, p.get(key));
        }

        int returnCode = SUCCESS;
        if (multipleTests) {
            try {
                java.io.BufferedReader reader =
                    new java.io.BufferedReader(new java.io.FileReader(args[0]));
                String testCaseName;
                int code = 0;
                boolean errorOccurred = false;
                boolean failureOccurred = false;
                String line = null;
                while ((line = reader.readLine()) != null) {
                    StringTokenizer st = new StringTokenizer(line, "","");
                    testCaseName = st.nextToken();
                    JUnitTest t = new JUnitTest(testCaseName);
                    t.setTodir(new File(st.nextToken()));
                    t.setOutfile(st.nextToken());
                    code = launch(t, haltError, stackfilter, haltFail,
                                  showOut, outputToFormat,
                                  logTestListenerEvents, props);
                    errorOccurred = (code == ERRORS);
                    failureOccurred = (code != SUCCESS);
                    if (errorOccurred || failureOccurred) {
                        if ((errorOccurred && haltError)
                            || (failureOccurred && haltFail)) {
                            registerNonCrash();
                            System.exit(code);
                        } else {
                            if (code > returnCode) {
                                returnCode = code;
                            }
                            System.out.println(""TEST "" + t.getName()
                                               + "" FAILED"");
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            returnCode = launch(new JUnitTest(args[0]), haltError,
                                stackfilter, haltFail,
                                showOut, outputToFormat,
                                logTestListenerEvents, props);
        }

        registerNonCrash();
        System.exit(returnCode);
    }

    private static Vector fromCmdLine = new Vector();

    private static void transferFormatters(JUnitTestRunner runner,
                                           JUnitTest test) {
        runner.addFormatter(new JUnitResultFormatter() {

            public void startTestSuite(JUnitTest suite) throws BuildException {
            }

            public void endTestSuite(JUnitTest suite) throws BuildException {
            }

            public void setOutput(OutputStream out) {
            }

            public void setSystemOutput(String out) {
            }

            public void setSystemError(String err) {
            }

            public void addError(Test arg0, Throwable arg1) {
            }

            public void addFailure(Test arg0, AssertionFailedError arg1) {
            }

            public void endTest(Test arg0) {
            }

            public void startTest(Test arg0) {
                registerTestCase(JUnitVersionHelper.getTestCaseName(arg0));
            }
        });
        for (int i = 0; i < fromCmdLine.size(); i++) {
            FormatterElement fe = (FormatterElement) fromCmdLine.elementAt(i);
            if (multipleTests && fe.getUseFile()) {
                File destFile =
                    new File(test.getTodir(),
                             test.getOutfile() + fe.getExtension());
                fe.setOutfile(destFile);
            }
            runner.addFormatter((JUnitResultFormatter) fe.createFormatter());
        }
    }

    
    private static void createAndStoreFormatter(String line)
        throws BuildException {
        FormatterElement fe = new FormatterElement();
        int pos = line.indexOf(',');
        if (pos == -1) {
            fe.setClassname(line);
            fe.setUseFile(false);
        } else {
            fe.setClassname(line.substring(0, pos));
            fe.setUseFile(true);
            if (!multipleTests) {
                fe.setOutfile(new File(line.substring(pos + 1)));
            } else {
                int fName = line.indexOf(IGNORED_FILE_NAME);
                if (fName > -1) {
                    fe.setExtension(line
                                    .substring(fName
                                               + IGNORED_FILE_NAME.length()));
                }
            }
        }
        fromCmdLine.addElement(fe);
    }

    
    public static String getFilteredTrace(Throwable t) {
        String trace = StringUtils.getStackTrace(t);
        return JUnitTestRunner.filterStack(trace);
    }

    
    public static String filterStack(String stack) {
        if (!filtertrace) {
            return stack;
        }
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        StringReader sr = new StringReader(stack);
        BufferedReader br = new BufferedReader(sr);

        String line;
        try {
            while ((line = br.readLine()) != null) {
                if (!filterLine(line)) {
                    pw.println(line);
                }
            }
        } catch (Exception e) {
            return stack; 
        }
        return sw.toString();
    }

    private static boolean filterLine(String line) {
        for (int i = 0; i < DEFAULT_TRACE_FILTERS.length; i++) {
            if (line.indexOf(DEFAULT_TRACE_FILTERS[i]) != -1) {
                return true;
            }
        }
        return false;
    }

    
    private static int launch(JUnitTest t, boolean haltError,
                              boolean stackfilter, boolean haltFail,
                              boolean showOut, boolean outputToFormat,
                              boolean logTestListenerEvents,
                              Properties props) {
        t.setProperties(props);
        JUnitTestRunner runner =
            new JUnitTestRunner(t, haltError, stackfilter, haltFail, showOut,
                                logTestListenerEvents, null);
        runner.forked = true;
        runner.outputToFormatters = outputToFormat;
        transferFormatters(runner, t);

        runner.run();
        return runner.getRetCode();
     }

    
    private static void registerNonCrash()
            throws IOException {
        if (crashFile != null) {
            FileWriter out = null;
            try {
                out = new FileWriter(crashFile);
                out.write(Constants.TERMINATED_SUCCESSFULLY + ""\n"");
                out.flush();
            } finally {
                if (out != null) {
                    out.close();
                }
            }
        }
    }

    private static void registerTestCase(String testCase) {
        if (crashFile != null) {
            try {
                FileWriter out = null;
                try {
                    out = new FileWriter(crashFile);
                    out.write(testCase + ""\n"");
                    out.flush();
                } finally {
                    if (out != null) {
                        out.close();
                    }
                }
            } catch (IOException e) {
                
            }
        }
    }

    
    private TestListener wrapListener(final TestListener testListener) {
        return new TestListener() {
            public void addError(Test test, Throwable t) {
                if (junit4 && t instanceof AssertionFailedError) {
                    
                    
                    
                    testListener.addFailure(test, (AssertionFailedError) t);
                } else if (junit4 && t.getClass().getName().equals(""java.lang.AssertionError"")) {
                    
                    
                    
                    
                    try {
                        String msg = t.getMessage();
                        AssertionFailedError failure = msg != null
                            ? new AssertionFailedError(msg) : new AssertionFailedError();
                        
                        Method initCause = Throwable.class.getMethod(
                            ""initCause"", new Class[] {Throwable.class});
                        initCause.invoke(failure, new Object[] {t});
                        testListener.addFailure(test, failure);
                    } catch (Exception e) {
                        
                        e.printStackTrace(); 
                        testListener.addError(test, t);
                    }
                } else {
                    testListener.addError(test, t);
                }
            }
            public void addFailure(Test test, AssertionFailedError t) {
                testListener.addFailure(test, t);
            }
            public void addFailure(Test test, Throwable t) { 
                if (t instanceof AssertionFailedError) {
                    testListener.addFailure(test, (AssertionFailedError) t);
                } else {
                    testListener.addError(test, t);
                }
            }
            public void endTest(Test test) {
                testListener.endTest(test);
            }
            public void startTest(Test test) {
                testListener.startTest(test);
            }
        };
    }

    
    private int[] findJUnit4FailureErrorCount(TestResult res) {
        int failures = 0;
        int errors = 0;
        Enumeration e = res.failures();
        while (e.hasMoreElements()) {
            e.nextElement();
            failures++;
        }
        e = res.errors();
        while (e.hasMoreElements()) {
            Throwable t = ((TestFailure) e.nextElement()).thrownException();
            if (t instanceof AssertionFailedError
                || t.getClass().getName().equals(""java.lang.AssertionError"")) {
                failures++;
            } else {
                errors++;
            }
        }
        return new int[] {failures, errors};
    }

} 
"
org.apache.tools.ant.dispatch.DispatchTask,4,3,1,3,5,4,1,2,4,0.666666667,17,1.0,0,0.925,0.625,0,0,3.0,1,0.75,0,"
package org.apache.tools.ant.dispatch;

import org.apache.tools.ant.Task;


public abstract class DispatchTask extends Task implements Dispatchable {
    private String action;

    
    public String getActionParameterName() {
        return ""action"";
    }

    
    public void setAction(String action) {
        this.action = action;
    }

    
    public String getAction() {
        return action;
    }
}
"
org.apache.tools.ant.types.resources.PropertyResource,10,4,0,6,32,41,1,5,9,0.888888889,134,1.0,0,0.883333333,0.407407407,1,6,12.2,3,1.3,0,"

package org.apache.tools.ant.types.resources;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayInputStream;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.util.PropertyOutputStream;


public class PropertyResource extends Resource {

    
    private static final int PROPERTY_MAGIC
        = Resource.getMagicNumber(""PropertyResource"".getBytes());

    private static final InputStream UNSET = new InputStream() {
        public int read() {
            return -1;
        }
    };

    
    public PropertyResource() {
    }

    
    public PropertyResource(Project p, String n) {
        super(n);
        setProject(p);
    }

    
    public String getValue() {
        Project p = getProject();
        return p == null ? null : p.getProperty(getName());
    }

    
    public boolean isExists() {
        return getValue() != null;
    }

    
    public long getSize() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getSize();
        }
        return isExists() ? (long) getValue().length() : 0L;
    }

    
    public int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        return super.hashCode() * PROPERTY_MAGIC;
    }

    
    public String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        return String.valueOf(getValue());
    }

    
    public InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        return isExists() ? new ByteArrayInputStream(getValue().getBytes()) : UNSET;
    }

    
    public OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        if (isExists()) {
            throw new ImmutableResourceException();
        }
        return new PropertyOutputStream(getProject(), getName());
    }

}
"
org.apache.tools.ant.taskdefs.Jar,31,5,2,24,152,349,2,22,13,0.857407407,1413,1.0,8,0.811688312,0.115789474,4,16,44.0,7,1.4839,6,"

package org.apache.tools.ant.taskdefs;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.Vector;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.ZipFileSet;
import org.apache.tools.ant.types.spi.Service;
import org.apache.tools.zip.JarMarker;
import org.apache.tools.zip.ZipExtraField;
import org.apache.tools.zip.ZipOutputStream;


public class Jar extends Zip {
    
    private static final String INDEX_NAME = ""META-INF/INDEX.LIST"";

    
    private static final String MANIFEST_NAME = ""META-INF/MANIFEST.MF"";

    
    private List serviceList = new ArrayList();

    
    private Manifest configuredManifest;
    
    private Manifest savedConfiguredManifest;

    
    private Manifest filesetManifest;

    
    private Manifest originalManifest;

    
    private FilesetManifestConfig filesetManifestConfig;

    
    private boolean mergeManifestsMain = true;

    
    private Manifest manifest;

    
    private String manifestEncoding;

    
    private File manifestFile;

    
    private boolean index = false;

    
    private boolean createEmpty = false;

    
    private Vector rootEntries;

    
    private Path indexJars;

    
    private static final ZipExtraField[] JAR_MARKER = new ZipExtraField[] {
        JarMarker.getInstance()
    };

    
    protected String emptyBehavior = ""create"";
    

    
    public Jar() {
        super();
        archiveType = ""jar"";
        emptyBehavior = ""create"";
        setEncoding(""UTF8"");
        rootEntries = new Vector();
    }

    
    public void setWhenempty(WhenEmpty we) {
        log(""JARs are never empty, they contain at least a manifest file"",
            Project.MSG_WARN);
    }

    
    public void setWhenmanifestonly(WhenEmpty we) {
        emptyBehavior = we.getValue();
    }

    
    public void setJarfile(File jarFile) {
        setDestFile(jarFile);
    }

    
    public void setIndex(boolean flag) {
        index = flag;
    }

    
    public void setManifestEncoding(String manifestEncoding) {
        this.manifestEncoding = manifestEncoding;
    }

    
    public void addConfiguredManifest(Manifest newManifest)
        throws ManifestException {
        if (configuredManifest == null) {
            configuredManifest = newManifest;
        } else {
            configuredManifest.merge(newManifest);
        }
        savedConfiguredManifest = configuredManifest;
    }

    
    public void setManifest(File manifestFile) {
        if (!manifestFile.exists()) {
            throw new BuildException(""Manifest file: "" + manifestFile
                                     + "" does not exist."", getLocation());
        }

        this.manifestFile = manifestFile;
    }

    private Manifest getManifest(File manifestFile) {

        Manifest newManifest = null;
        FileInputStream fis = null;
        InputStreamReader isr = null;
        try {
            fis = new FileInputStream(manifestFile);
            if (manifestEncoding == null) {
                isr = new InputStreamReader(fis);
            } else {
                isr = new InputStreamReader(fis, manifestEncoding);
            }
            newManifest = getManifest(isr);
        } catch (UnsupportedEncodingException e) {
            throw new BuildException(""Unsupported encoding while reading manifest: ""
                                     + e.getMessage(), e);
        } catch (IOException e) {
            throw new BuildException(""Unable to read manifest file: ""
                                     + manifestFile
                                     + "" ("" + e.getMessage() + "")"", e);
        } finally {
            if (isr != null) {
                try {
                    isr.close();
                } catch (IOException e) {
                    
                }
            }
        }
        return newManifest;
    }

    
    private Manifest getManifestFromJar(File jarFile) throws IOException {
        ZipFile zf = null;
        try {
            zf = new ZipFile(jarFile);

            
            
            Enumeration e = zf.entries();
            while (e.hasMoreElements()) {
                ZipEntry ze = (ZipEntry) e.nextElement();
                if (ze.getName().equalsIgnoreCase(MANIFEST_NAME)) {
                    InputStreamReader isr =
                        new InputStreamReader(zf.getInputStream(ze), ""UTF-8"");
                    return getManifest(isr);
                }
            }
            return null;
        } finally {
            if (zf != null) {
                try {
                    zf.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }

    private Manifest getManifest(Reader r) {

        Manifest newManifest = null;
        try {
            newManifest = new Manifest(r);
        } catch (ManifestException e) {
            log(""Manifest is invalid: "" + e.getMessage(), Project.MSG_ERR);
            throw new BuildException(""Invalid Manifest: "" + manifestFile,
                                     e, getLocation());
        } catch (IOException e) {
            throw new BuildException(""Unable to read manifest file""
                                     + "" ("" + e.getMessage() + "")"", e);
        }
        return newManifest;
    }

    
    public void setFilesetmanifest(FilesetManifestConfig config) {
        filesetManifestConfig = config;
        mergeManifestsMain = ""merge"".equals(config.getValue());

        if (filesetManifestConfig != null
            && !filesetManifestConfig.getValue().equals(""skip"")) {

            doubleFilePass = true;
        }
    }

    
    public void addMetainf(ZipFileSet fs) {
        
        fs.setPrefix(""META-INF/"");
        super.addFileset(fs);
    }

    
    public void addConfiguredIndexJars(Path p) {
        if (indexJars == null) {
            indexJars = new Path(getProject());
        }
        indexJars.append(p);
    }

    
    public void addConfiguredService(Service service) {
        
        service.check();
        serviceList.add(service);
    }

    
    private void writeServices(ZipOutputStream zOut) throws IOException {
        Iterator serviceIterator;
        Service service;

        serviceIterator = serviceList.iterator();
        while (serviceIterator.hasNext()) {
           service = (Service) serviceIterator.next();
           
           super.zipFile(service.getAsStream(), zOut,
                         ""META-INF/service/"" + service.getType(),
                         System.currentTimeMillis(), null,
                         ZipFileSet.DEFAULT_FILE_MODE);
        }
    }


    
    protected void initZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException {

        if (!skipWriting) {
            Manifest jarManifest = createManifest();
            writeManifest(zOut, jarManifest);
            writeServices(zOut);
        }
    }

    private Manifest createManifest()
        throws BuildException {
        try {
            Manifest finalManifest = Manifest.getDefaultManifest();

            if (manifest == null) {
                if (manifestFile != null) {
                    
                    
                    manifest = getManifest(manifestFile);
                }
            }

            

            if (isInUpdateMode()) {
                finalManifest.merge(originalManifest);
            }
            finalManifest.merge(filesetManifest);
            finalManifest.merge(configuredManifest);
            finalManifest.merge(manifest, !mergeManifestsMain);

            return finalManifest;

        } catch (ManifestException e) {
            log(""Manifest is invalid: "" + e.getMessage(), Project.MSG_ERR);
            throw new BuildException(""Invalid Manifest"", e, getLocation());
        }
    }

    private void writeManifest(ZipOutputStream zOut, Manifest manifest)
        throws IOException {
        for (Enumeration e = manifest.getWarnings();
             e.hasMoreElements();) {
            log(""Manifest warning: "" + (String) e.nextElement(),
                Project.MSG_WARN);
        }

        zipDir(null, zOut, ""META-INF/"", ZipFileSet.DEFAULT_DIR_MODE,
               JAR_MARKER);
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        OutputStreamWriter osw = new OutputStreamWriter(baos, Manifest.JAR_ENCODING);
        PrintWriter writer = new PrintWriter(osw);
        manifest.write(writer);
        writer.flush();

        ByteArrayInputStream bais =
            new ByteArrayInputStream(baos.toByteArray());
        super.zipFile(bais, zOut, MANIFEST_NAME,
                      System.currentTimeMillis(), null,
                      ZipFileSet.DEFAULT_FILE_MODE);
        super.initZipOutputStream(zOut);
    }

    
    protected void finalizeZipOutputStream(ZipOutputStream zOut)
        throws IOException, BuildException {

        if (index) {
            createIndexList(zOut);
        }
    }

    
    private void createIndexList(ZipOutputStream zOut) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        
        PrintWriter writer = new PrintWriter(new OutputStreamWriter(baos,
                                                                    ""UTF8""));

        
        writer.println(""JarIndex-Version: 1.0"");
        writer.println();

        
        writer.println(zipFile.getName());

        writeIndexLikeList(new ArrayList(addedDirs.keySet()),
                           rootEntries, writer);
        writer.println();

        if (indexJars != null) {
            Manifest mf = createManifest();
            Manifest.Attribute classpath =
                mf.getMainSection().getAttribute(Manifest.ATTRIBUTE_CLASSPATH);
            String[] cpEntries = null;
            if (classpath != null && classpath.getValue() != null) {
                StringTokenizer tok = new StringTokenizer(classpath.getValue(),
                                                          "" "");
                cpEntries = new String[tok.countTokens()];
                int c = 0;
                while (tok.hasMoreTokens()) {
                    cpEntries[c++] = tok.nextToken();
                }
            }
            String[] indexJarEntries = indexJars.list();
            for (int i = 0; i < indexJarEntries.length; i++) {
                String name = findJarName(indexJarEntries[i], cpEntries);
                if (name != null) {
                    ArrayList dirs = new ArrayList();
                    ArrayList files = new ArrayList();
                    grabFilesAndDirs(indexJarEntries[i], dirs, files);
                    if (dirs.size() + files.size() > 0) {
                        writer.println(name);
                        writeIndexLikeList(dirs, files, writer);
                        writer.println();
                    }
                }
            }
        }

        writer.flush();
        ByteArrayInputStream bais =
            new ByteArrayInputStream(baos.toByteArray());
        super.zipFile(bais, zOut, INDEX_NAME, System.currentTimeMillis(), null,
                      ZipFileSet.DEFAULT_FILE_MODE);
    }

    
    protected void zipFile(InputStream is, ZipOutputStream zOut, String vPath,
                           long lastModified, File fromArchive, int mode)
        throws IOException {
        if (MANIFEST_NAME.equalsIgnoreCase(vPath))  {
            if (!doubleFilePass || (doubleFilePass && skipWriting)) {
                filesetManifest(fromArchive, is);
            }
        } else if (INDEX_NAME.equalsIgnoreCase(vPath) && index) {
            log(""Warning: selected "" + archiveType
                + "" files include a META-INF/INDEX.LIST which will""
                + "" be replaced by a newly generated one."", Project.MSG_WARN);
        } else {
            if (index && vPath.indexOf(""/"") == -1) {
                rootEntries.addElement(vPath);
            }
            super.zipFile(is, zOut, vPath, lastModified, fromArchive, mode);
        }
    }

    private void filesetManifest(File file, InputStream is) throws IOException {
        if (manifestFile != null && manifestFile.equals(file)) {
            
            
            log(""Found manifest "" + file, Project.MSG_VERBOSE);
            try {
                if (is != null) {
                    InputStreamReader isr;
                    if (manifestEncoding == null) {
                        isr = new InputStreamReader(is);
                    } else {
                        isr = new InputStreamReader(is, manifestEncoding);
                    }
                    manifest = getManifest(isr);
                } else {
                    manifest = getManifest(file);
                }
            } catch (UnsupportedEncodingException e) {
                throw new BuildException(""Unsupported encoding while reading ""
                    + ""manifest: "" + e.getMessage(), e);
            }
        } else if (filesetManifestConfig != null
                    && !filesetManifestConfig.getValue().equals(""skip"")) {
            
            log(""Found manifest to merge in file "" + file,
                Project.MSG_VERBOSE);

            try {
                Manifest newManifest = null;
                if (is != null) {
                    InputStreamReader isr;
                    if (manifestEncoding == null) {
                        isr = new InputStreamReader(is);
                    } else {
                        isr = new InputStreamReader(is, manifestEncoding);
                    }
                    newManifest = getManifest(isr);
                } else {
                    newManifest = getManifest(file);
                }

                if (filesetManifest == null) {
                    filesetManifest = newManifest;
                } else {
                    filesetManifest.merge(newManifest);
                }
            } catch (UnsupportedEncodingException e) {
                throw new BuildException(""Unsupported encoding while reading ""
                    + ""manifest: "" + e.getMessage(), e);
            } catch (ManifestException e) {
                log(""Manifest in file "" + file + "" is invalid: ""
                    + e.getMessage(), Project.MSG_ERR);
                throw new BuildException(""Invalid Manifest"", e, getLocation());
            }
        } else {
            
            
            

            
            
            

            
            
            
            
            
            
        }
    }

    
    protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs,
                                             File zipFile,
                                             boolean needsUpdate)
        throws BuildException {

        
        if (zipFile.exists()) {
            
            

            try {
                originalManifest = getManifestFromJar(zipFile);
                if (originalManifest == null) {
                    log(""Updating jar since the current jar has no manifest"",
                        Project.MSG_VERBOSE);
                    needsUpdate = true;
                } else {
                    Manifest mf = createManifest();
                    if (!mf.equals(originalManifest)) {
                        log(""Updating jar since jar manifest has changed"",
                            Project.MSG_VERBOSE);
                        needsUpdate = true;
                    }
                }
            } catch (Throwable t) {
                log(""error while reading original manifest in file: ""
                    + zipFile.toString() + t.getMessage(),
                    Project.MSG_WARN);
                needsUpdate = true;
            }

        } else {
            
            needsUpdate = true;
        }

        createEmpty = needsUpdate;
        return super.getResourcesToAdd(rcs, zipFile, needsUpdate);
    }

    
    protected boolean createEmptyZip(File zipFile) throws BuildException {
        if (!createEmpty) {
            return true;
        }

        if (emptyBehavior.equals(""skip"")) {
                log(""Warning: skipping "" + archiveType + "" archive ""
                    + zipFile + "" because no files were included."",
                    Project.MSG_WARN);
                return true;
        } else if (emptyBehavior.equals(""fail"")) {
            throw new BuildException(""Cannot create "" + archiveType
                                     + "" archive "" + zipFile
                                     + "": no files were included."",
                                     getLocation());
        }

        ZipOutputStream zOut = null;
        try {
            log(""Building MANIFEST-only jar: ""
                + getDestFile().getAbsolutePath());
            zOut = new ZipOutputStream(new FileOutputStream(getDestFile()));

            zOut.setEncoding(getEncoding());
            if (isCompress()) {
                zOut.setMethod(ZipOutputStream.DEFLATED);
            } else {
                zOut.setMethod(ZipOutputStream.STORED);
            }
            initZipOutputStream(zOut);
            finalizeZipOutputStream(zOut);
        } catch (IOException ioe) {
            throw new BuildException(""Could not create almost empty JAR archive""
                                     + "" ("" + ioe.getMessage() + "")"", ioe,
                                     getLocation());
        } finally {
            
            try {
                if (zOut != null) {
                    zOut.close();
                }
            } catch (IOException ex) {
                
            }
            createEmpty = false;
        }
        return true;
    }

    
    protected void cleanUp() {
        super.cleanUp();

        
        if (!doubleFilePass || (doubleFilePass && !skipWriting)) {
            manifest = null;
            configuredManifest = savedConfiguredManifest;
            filesetManifest = null;
            originalManifest = null;
        }
        rootEntries.removeAllElements();
    }

    
    public void reset() {
        super.reset();
        emptyBehavior = ""create"";
        configuredManifest = null;
        filesetManifestConfig = null;
        mergeManifestsMain = false;
        manifestFile = null;
        index = false;
    }

    
    public static class FilesetManifestConfig extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {""skip"", ""merge"", ""mergewithoutmain""};
        }
    }

    
    protected final void writeIndexLikeList(List dirs, List files,
                                            PrintWriter writer)
        throws IOException {
        
        
        
        Collections.sort(dirs);
        Collections.sort(files);
        Iterator iter = dirs.iterator();
        while (iter.hasNext()) {
            String dir = (String) iter.next();

            
            dir = dir.replace('\\', '/');
            if (dir.startsWith(""./"")) {
                dir = dir.substring(2);
            }
            while (dir.startsWith(""/"")) {
                dir = dir.substring(1);
            }
            int pos = dir.lastIndexOf('/');
            if (pos != -1) {
                dir = dir.substring(0, pos);
            }

            
            
            
            if (dir.startsWith(""META-INF"")) {
                continue;
            }
            
            writer.println(dir);
        }

        iter = files.iterator();
        while (iter.hasNext()) {
            writer.println(iter.next());
        }
    }

    
    protected static final String findJarName(String fileName,
                                              String[] classpath) {
        if (classpath == null) {
            return (new File(fileName)).getName();
        }
        fileName = fileName.replace(File.separatorChar, '/');
        TreeMap matches = new TreeMap(new Comparator() {
                
                public int compare(Object o1, Object o2) {
                    if (o1 instanceof String && o2 instanceof String) {
                        return ((String) o2).length()
                            - ((String) o1).length();
                    }
                    return 0;
                }
            });

        for (int i = 0; i < classpath.length; i++) {
            if (fileName.endsWith(classpath[i])) {
                matches.put(classpath[i], classpath[i]);
            } else {
                int slash = classpath[i].indexOf(""/"");
                String candidate = classpath[i];
                while (slash > -1) {
                    candidate = candidate.substring(slash + 1);
                    if (fileName.endsWith(candidate)) {
                        matches.put(candidate, classpath[i]);
                        break;
                    }
                    slash = candidate.indexOf(""/"");
                }
            }
        }

        return matches.size() == 0
            ? null : (String) matches.get(matches.firstKey());
    }

    
    protected static final void grabFilesAndDirs(String file, List dirs,
                                                 List files)
        throws IOException {
        org.apache.tools.zip.ZipFile zf = null;
        try {
            zf = new org.apache.tools.zip.ZipFile(file, ""utf-8"");
            Enumeration entries = zf.getEntries();
            HashSet dirSet = new HashSet();
            while (entries.hasMoreElements()) {
                org.apache.tools.zip.ZipEntry ze =
                    (org.apache.tools.zip.ZipEntry) entries.nextElement();
                String name = ze.getName();
                
                
                if (!name.startsWith(""META-INF/"")) {
                    if (ze.isDirectory()) {
                        dirSet.add(name);
                    } else if (name.indexOf(""/"") == -1) {
                        files.add(name);
                    } else {
                        
                        
                        
                        
                        dirSet.add(name.substring(0,
                                                  name.lastIndexOf(""/"") + 1));
                    }
                }
            }
            dirs.addAll(dirSet);
        } finally {
            if (zf != null) {
                zf.close();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.jsp.JspC,42,4,0,15,92,753,3,13,36,0.948350072,707,0.941176471,4,0.655462185,0.140692641,3,3,15.42857143,5,1.4048,0,"

package org.apache.tools.ant.taskdefs.optional.jsp;

import java.io.File;
import java.util.Date;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.taskdefs.optional.jsp.compilers.JspCompilerAdapter;
import org.apache.tools.ant.taskdefs.optional.jsp.compilers.JspCompilerAdapterFactory;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;


public class JspC extends MatchingTask {
    private Path classpath;
    private Path compilerClasspath;
    private Path src;
    private File destDir;
    private String packageName;
    
    private String compilerName = ""jasper"";

    
    private String iepluginid;
    private boolean mapped;
    private int verbose = 0;
    
    protected Vector compileList = new Vector();
    Vector javaFiles = new Vector();

    
    protected boolean failOnError = true;

    
    private File uriroot;

    
    private File webinc;

    

    private File webxml;

    
    protected WebAppParameter webApp;



    private static final String FAIL_MSG
        = ""Compile failed, messages should have been provided."";

    

    
    public void setSrcDir(Path srcDir) {
        if (src == null) {
            src = srcDir;
        } else {
            src.append(srcDir);
        }
    }

    
    public Path getSrcDir() {
        return src;
    }

    
    public void setDestdir(File destDir) {
        this.destDir = destDir;
    }

    
    public File getDestdir() {
        return destDir;
    }

    
    public void setPackage(String pkg) {
        this.packageName = pkg;
    }

    
    public String getPackage() {
        return packageName;
    }

    
    public void setVerbose(int i) {
        verbose = i;
    }

    
    public int getVerbose() {
        return verbose;
    }

    
    public void setFailonerror(boolean fail) {
        failOnError = fail;
    }
    
    public boolean getFailonerror() {
        return failOnError;
    }

    
    public String getIeplugin() {
        return iepluginid;
    }
    
    public void setIeplugin(String iepluginid) {
        this.iepluginid = iepluginid;
    }

    
    public boolean isMapped() {
        return mapped;
    }

    
    public void setMapped(boolean mapped) {
        this.mapped = mapped;
    }

    
    public void setUribase(File uribase) {
        log(""Uribase is currently an unused parameter"", Project.MSG_WARN);
    }

    
    public File getUribase() {
        return uriroot;
    }

    
    public void setUriroot(File uriroot) {
        this.uriroot = uriroot;
    }

    
    public File getUriroot() {
        return uriroot;
    }


    
    public void setClasspath(Path cp) {
        if (classpath == null) {
            classpath = cp;
        } else {
            classpath.append(cp);
        }
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(getProject());
        }
        return classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public void setCompilerclasspath(Path cp) {
        if (compilerClasspath == null) {
            compilerClasspath = cp;
        } else {
            compilerClasspath.append(cp);
        }
    }

    
    public Path getCompilerclasspath() {
        return compilerClasspath;
    }

    
    public Path createCompilerclasspath() {
        if (compilerClasspath == null) {
            compilerClasspath = new Path(getProject());
        }
        return compilerClasspath.createPath();
    }

    
    public void setWebxml(File webxml) {
        this.webxml = webxml;
    }

    
    public File getWebxml() {
        return this.webxml;
    }

    
    public void setWebinc(File webinc) {
        this.webinc = webinc;
    }

    
    public File getWebinc() {
        return this.webinc;
    }

    
    public void addWebApp(WebAppParameter webappParam)
        throws BuildException {
        
        if (webApp == null) {
            webApp = webappParam;
        } else {
            throw new BuildException(""Only one webapp can be specified"");
        }
    }

    
    public WebAppParameter getWebApp() {
        return webApp;
    }

    
    public void setCompiler(String compiler) {
        this.compilerName = compiler;
    }

    
    public Vector getCompileList() {
        return compileList;
    }

    
    public void execute()
        throws BuildException {

        
        if (destDir == null) {
            throw new BuildException(""destdir attribute must be set!"",
                                     getLocation());
        }

        if (!destDir.isDirectory()) {
            throw new BuildException(""destination directory \"""" + destDir
                    + ""\"" does not exist or is not a directory"", getLocation());
        }

        File dest = getActualDestDir();

        
        JspCompilerAdapter compiler =
            JspCompilerAdapterFactory.getCompiler(compilerName, this,
                getProject().createClassLoader(compilerClasspath));

        
        if (webApp != null) {
            doCompilation(compiler);
            return;
        }

        
        if (src == null) {
            throw new BuildException(""srcdir attribute must be set!"",
                                     getLocation());
        }
        String [] list = src.list();
        if (list.length == 0) {
            throw new BuildException(""srcdir attribute must be set!"",
                    getLocation());
        }


        
        if (compiler.implementsOwnDependencyChecking()) {
            doCompilation(compiler);
            return;
        }

        
        JspMangler mangler = compiler.createMangler();

        
        
        resetFileLists();
        int filecount = 0;
        for (int i = 0; i < list.length; i++) {
            File srcDir = getProject().resolveFile(list[i]);
            if (!srcDir.exists()) {
                throw new BuildException(""srcdir \"""" + srcDir.getPath()
                    + ""\"" does not exist!"", getLocation());
            }
            DirectoryScanner ds = this.getDirectoryScanner(srcDir);
            String[] files = ds.getIncludedFiles();
            filecount = files.length;
            scanDir(srcDir, dest, mangler, files);
        }

        

        log(""compiling "" + compileList.size() + "" files"", Project.MSG_VERBOSE);

        if (compileList.size() > 0) {

            log(""Compiling "" + compileList.size() + "" source file""
                + (compileList.size() == 1 ? """" : ""s"")
                + "" to ""
                + dest);
            doCompilation(compiler);

        } else {
            if (filecount == 0) {
                log(""there were no files to compile"", Project.MSG_INFO);
            } else {
                log(""all files are up to date"", Project.MSG_VERBOSE);
            }
        }
    }

    
    private File getActualDestDir() {
        File dest = null;
        if (packageName == null) {
            dest = destDir;
        } else {
            String path = destDir.getPath() + File.separatorChar
                + packageName.replace('.', File.separatorChar);
            dest = new File(path);
        }
        return dest;
    }

    
    private void doCompilation(JspCompilerAdapter compiler)
            throws BuildException {
        
        compiler.setJspc(this);

        
        if (!compiler.execute()) {
            if (failOnError) {
                throw new BuildException(FAIL_MSG, getLocation());
            } else {
                log(FAIL_MSG, Project.MSG_ERR);
            }
        }
    }

    
    protected void resetFileLists() {
        compileList.removeAllElements();
    }

    
    protected void scanDir(
        File srcDir, File dest, JspMangler mangler, String[] files) {

        long now = (new Date()).getTime();

        for (int i = 0; i < files.length; i++) {
            String filename = files[i];
            File srcFile = new File(srcDir, filename);
            File javaFile = mapToJavaFile(mangler, srcFile, srcDir, dest);
            if (javaFile == null) {
                continue;
            }

            if (srcFile.lastModified() > now) {
                log(""Warning: file modified in the future: "" + filename,
                        Project.MSG_WARN);
            }
            boolean shouldCompile = false;
            shouldCompile = isCompileNeeded(srcFile, javaFile);
            if (shouldCompile) {
               compileList.addElement(srcFile.getAbsolutePath());
               javaFiles.addElement(javaFile);
            }
        }
    }

    
    private boolean isCompileNeeded(File srcFile, File javaFile) {
        boolean shouldCompile = false;
        if (!javaFile.exists()) {
            shouldCompile = true;
            log(""Compiling "" + srcFile.getPath()
                + "" because java file "" + javaFile.getPath()
                + "" does not exist"", Project.MSG_VERBOSE);
            } else {
                if (srcFile.lastModified() > javaFile.lastModified()) {
                    shouldCompile = true;
                    log(""Compiling "" + srcFile.getPath()
                        + "" because it is out of date with respect to ""
                        + javaFile.getPath(),
                        Project.MSG_VERBOSE);
                } else {
                    if (javaFile.length() == 0) {
                        shouldCompile = true;
                        log(""Compiling "" + srcFile.getPath()
                            + "" because java file "" + javaFile.getPath()
                            + "" is empty"", Project.MSG_VERBOSE);
                    }
                }
        }
        return shouldCompile;
    }


    
    protected File mapToJavaFile(JspMangler mangler, File srcFile, File srcDir, File dest) {
        if (!srcFile.getName().endsWith("".jsp"")) {
            return null;
        }
        String javaFileName = mangler.mapJspToJavaName(srcFile);

        return new File(dest, javaFileName);
    }

    
    public void deleteEmptyJavaFiles() {
        if (javaFiles != null) {
            Enumeration e = javaFiles.elements();
            while (e.hasMoreElements()) {
                File file = (File) e.nextElement();
                if (file.exists() && file.length() == 0) {
                    log(""deleting empty output file "" + file);
                    file.delete();
                }
            }
        }
    }

    
    public static class WebAppParameter {

        
        private File directory;

        
        public File getDirectory() {
            return directory;
        }

        
        public void setBaseDir(File directory) {
            this.directory = directory;
        }
    
    }



}
"
org.apache.tools.zip.ZipLong,10,1,0,3,11,15,3,0,10,0.333333333,154,1.0,0,0.0,0.32,1,1,14.3,4,1.0,1,"

package org.apache.tools.zip;


public final class ZipLong implements Cloneable {

    private long value;

    
    public ZipLong(long value) {
        this.value = value;
    }

    
    public ZipLong (byte[] bytes) {
        this(bytes, 0);
    }

    
    public ZipLong (byte[] bytes, int offset) {
        value = ZipLong.getValue(bytes, offset);
    }

    
    public byte[] getBytes() {
        return ZipLong.getBytes(value);
    }

    
    public long getValue() {
        return value;
    }

    
    public static byte[] getBytes(long value) {
        byte[] result = new byte[4];
        result[0] = (byte) ((value & 0xFF));
        result[1] = (byte) ((value & 0xFF00) >> 8);
        result[2] = (byte) ((value & 0xFF0000) >> 16);
        result[3] = (byte) ((value & 0xFF000000L) >> 24);
        return result;
    }

    
    public static long getValue(byte[] bytes, int offset) {
        long value = (bytes[offset + 3] << 24) & 0xFF000000L;
        value += (bytes[offset + 2] << 16) & 0xFF0000;
        value += (bytes[offset + 1] << 8) & 0xFF00;
        value += (bytes[offset] & 0xFF);
        return value;
    }

    
    public static long getValue(byte[] bytes) {
        return getValue(bytes, 0);
    }

    
    public boolean equals(Object o) {
        if (o == null || !(o instanceof ZipLong)) {
            return false;
        }
        return value == ((ZipLong) o).getValue();
    }

    
    public int hashCode() {
        return (int) value;
    }
}
"
org.apache.tools.ant.util.depend.AbstractAnalyzer,16,1,3,6,40,80,3,3,10,0.858333333,254,0.875,2,0.0,0.241071429,0,0,14.375,3,1.375,0,"
package org.apache.tools.ant.util.depend;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;
import java.util.zip.ZipFile;
import org.apache.tools.ant.types.Path;


public abstract class AbstractAnalyzer implements DependencyAnalyzer {
    
    public static final int MAX_LOOPS = 1000;

    
    private Path sourcePath = new Path(null);

    
    private Path classPath = new Path(null);

    
    private Vector rootClasses = new Vector();

    
    private boolean determined = false;

    
    private Vector fileDependencies;
    
    private Vector classDependencies;

    
    private boolean closure = true;

    
    protected AbstractAnalyzer() {
        reset();
    }

    
    public void setClosure(boolean closure) {
        this.closure = closure;
    }

    
    public Enumeration getFileDependencies() {
        if (!supportsFileDependencies()) {
            throw new RuntimeException(""File dependencies are not supported ""
                + ""by this analyzer"");
        }
        if (!determined) {
            determineDependencies(fileDependencies, classDependencies);
        }
        return fileDependencies.elements();
    }

    
    public Enumeration getClassDependencies() {
        if (!determined) {
            determineDependencies(fileDependencies, classDependencies);
        }
        return classDependencies.elements();
    }

    
    public File getClassContainer(String classname) throws IOException {
        String classLocation = classname.replace('.', '/') + "".class"";
        
        
        return getResourceContainer(classLocation, classPath.list());
    }

    
    public File getSourceContainer(String classname) throws IOException {
        String sourceLocation = classname.replace('.', '/') + "".java"";

        
        
        
        return getResourceContainer(sourceLocation, sourcePath.list());
    }

    
    public void addSourcePath(Path sourcePath) {
        if (sourcePath == null) {
            return;
        }
        this.sourcePath.append(sourcePath);
        this.sourcePath.setProject(sourcePath.getProject());
    }

    
    public void addClassPath(Path classPath) {
        if (classPath == null) {
            return;
        }

        this.classPath.append(classPath);
        this.classPath.setProject(classPath.getProject());
    }

    
    public void addRootClass(String className) {
        if (className == null) {
            return;
        }
        if (!rootClasses.contains(className)) {
            rootClasses.addElement(className);
        }
    }

    
    public void config(String name, Object info) {
        
    }

    
    public void reset() {
        rootClasses.removeAllElements();
        determined = false;
        fileDependencies = new Vector();
        classDependencies = new Vector();
    }

    
    protected Enumeration getRootClasses() {
        return rootClasses.elements();
    }

    
    protected boolean isClosureRequired() {
        return closure;
    }

    
    protected abstract void determineDependencies(Vector files, Vector classes);

    
    protected abstract boolean supportsFileDependencies();

    
    private File getResourceContainer(String resourceLocation, String[] paths)
         throws IOException {
        for (int i = 0; i < paths.length; ++i) {
            File element = new File(paths[i]);
            if (!element.exists()) {
                continue;
            }
            if (element.isDirectory()) {
                File resource = new File(element, resourceLocation);
                if (resource.exists()) {
                    return resource;
                }
            } else {
                
                ZipFile zipFile = null;
                try {
                    zipFile = new ZipFile(element);
                    if (zipFile.getEntry(resourceLocation) != null) {
                        return element;
                    }
                } finally {
                    if (zipFile != null) {
                        zipFile.close();
                    }
                }
            }
        }
        return null;
    }
}

"
org.apache.tools.ant.util.ReaderInputStream,9,2,1,2,23,0,2,0,9,0.5,246,1.0,0,0.5625,0.333333333,1,2,25.88888889,1,0.7778,0,"
package org.apache.tools.ant.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;


public class ReaderInputStream extends InputStream {

    
    private Reader in;

    private String encoding = System.getProperty(""file.encoding"");

    private byte[] slack;

    private int begin;

    
    public ReaderInputStream(Reader reader) {
        in = reader;
    }

    
    public ReaderInputStream(Reader reader, String encoding) {
        this(reader);
        if (encoding == null) {
            throw new IllegalArgumentException(""encoding must not be null"");
        } else {
            this.encoding = encoding;
        }
    }

    
    public synchronized int read() throws IOException {
        if (in == null) {
            throw new IOException(""Stream Closed"");
        }

        byte result;
        if (slack != null && begin < slack.length) {
            result = slack[begin];
            if (++begin == slack.length) {
                slack = null;
            }
        } else {
            byte[] buf = new byte[1];
            if (read(buf, 0, 1) <= 0) {
                return -1;
            } else {
                result = buf[0];
            }
        }

        return result & 0xFF;
    }

    
    public synchronized int read(byte[] b, int off, int len)
        throws IOException {
        if (in == null) {
            throw new IOException(""Stream Closed"");
        }
        if (len == 0) {
            return 0;
        }
        while (slack == null) {
            char[] buf = new char[len]; 
            int n = in.read(buf);
            if (n == -1) {
                return -1;
            }
            if (n > 0) {
                slack = new String(buf, 0, n).getBytes(encoding);
                begin = 0;
            }
        }

        if (len > slack.length - begin) {
            len = slack.length - begin;
        }

        System.arraycopy(slack, begin, b, off, len);

        if ((begin += len) >= slack.length) {
            slack = null;
        }

        return len;
    }

    
    public synchronized void mark(final int limit) {
        try {
            in.mark(limit);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe.getMessage());
        }
    }


    
    public synchronized int available() throws IOException {
        if (in == null) {
            throw new IOException(""Stream Closed"");
        }
        if (slack != null) {
            return slack.length - begin;
        }
        if (in.ready()) {
            return 1;
        } else {
            return 0;
        }
    }

    
    public boolean markSupported () {
        return false;   
    }

    
    public synchronized void reset() throws IOException {
        if (in == null) {
            throw new IOException(""Stream Closed"");
        }
        slack = null;
        in.reset();
    }

    
    public synchronized void close() throws IOException {
        if (in != null) {
            in.close();
            slack = null;
            in = null;
        }
    }
}
"
org.apache.tools.ant.types.selectors.ContainsSelector,9,5,0,15,34,4,6,9,9,0.785714286,266,0.428571429,0,0.826086957,0.296296296,1,4,27.77777778,11,2.8889,0,"

package org.apache.tools.ant.types.selectors;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.util.FileUtils;


public class ContainsSelector extends BaseExtendSelector implements ResourceSelector {

    private String contains = null;
    private boolean casesensitive = true;
    private boolean ignorewhitespace = false;
    
    public static final String EXPRESSION_KEY = ""expression"";
    
    public static final String CONTAINS_KEY = ""text"";
    
    public static final String CASE_KEY = ""casesensitive"";
    
    public static final String WHITESPACE_KEY = ""ignorewhitespace"";


    
    public ContainsSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(""{containsselector text: "");
        buf.append('""').append(contains).append('""');
        buf.append("" casesensitive: "");
        buf.append(casesensitive ? ""true"" : ""false"");
        buf.append("" ignorewhitespace: "");
        buf.append(ignorewhitespace ? ""true"" : ""false"");
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setText(String contains) {
        this.contains = contains;
    }

    
    public void setCasesensitive(boolean casesensitive) {
        this.casesensitive = casesensitive;
    }

    
    public void setIgnorewhitespace(boolean ignorewhitespace) {
        this.ignorewhitespace = ignorewhitespace;
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (CONTAINS_KEY.equalsIgnoreCase(paramname)) {
                    setText(parameters[i].getValue());
                } else if (CASE_KEY.equalsIgnoreCase(paramname)) {
                    setCasesensitive(Project.toBoolean(
                            parameters[i].getValue()));
                } else if (WHITESPACE_KEY.equalsIgnoreCase(paramname)) {
                    setIgnorewhitespace(Project.toBoolean(
                            parameters[i].getValue()));
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (contains == null) {
            setError(""The text attribute is required"");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        return isSelected(new FileResource(file));
    }

    
    public boolean isSelected(Resource r) {

        
        validate();

        if (r.isDirectory()) {
            return true;
        }

        String userstr = contains;
        if (!casesensitive) {
            userstr = contains.toLowerCase();
        }
        if (ignorewhitespace) {
            userstr = SelectorUtils.removeWhitespace(userstr);
        }
        BufferedReader in = null;
        try {
            in = new BufferedReader(new InputStreamReader(r.getInputStream()));
        } catch (Exception e) {
            throw new BuildException(""Could not get InputStream from ""
                    + r.toLongString(), e);
        }
        try {
            String teststr = in.readLine();
            while (teststr != null) {
                if (!casesensitive) {
                    teststr = teststr.toLowerCase();
                }
                if (ignorewhitespace) {
                    teststr = SelectorUtils.removeWhitespace(teststr);
                }
                if (teststr.indexOf(userstr) > -1) {
                    return true;
                }
                teststr = in.readLine();
            }
            return false;
        } catch (IOException ioe) {
            throw new BuildException(""Could not read "" + r.toLongString());
        } finally {
            FileUtils.close(in);
        }
    }

}

"
org.apache.tools.ant.taskdefs.GenerateKey,14,3,0,6,34,65,0,6,14,0.91025641,378,1.0,1,0.74,0.595238095,1,1,25.14285714,2,1.0,0,"
package org.apache.tools.ant.taskdefs;

import java.util.Enumeration;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.util.JavaEnvUtils;


public class GenerateKey extends Task {

    
    public static class DnameParam {
        private String name;
        private String value;

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }

        
        public void setValue(String value) {
            this.value = value;
        }

        
        public String getValue() {
            return value;
        }
    }

    
    public static class DistinguishedName {
        private Vector params = new Vector();

        
        public Object createParam() {
            DnameParam param = new DnameParam();
            params.addElement(param);

            return param;
        }

        
        public Enumeration getParams() {
            return params.elements();
        }

        
        public String toString() {
            final int size = params.size();
            final StringBuffer sb = new StringBuffer();
            boolean firstPass = true;

            for (int i = 0; i < size; i++) {
                if (!firstPass) {
                    sb.append("" ,"");
                }
                firstPass = false;

                final DnameParam param = (DnameParam) params.elementAt(i);
                sb.append(encode(param.getName()));
                sb.append('=');
                sb.append(encode(param.getValue()));
            }

            return sb.toString();
        }

        
        public String encode(final String string) {
            int end = string.indexOf(',');

            if (-1 == end) {
              return string;
            }

            final StringBuffer sb = new StringBuffer();

            int start = 0;

            while (-1 != end) {
                sb.append(string.substring(start, end));
                sb.append(""\\,"");
                start = end + 1;
                end = string.indexOf(',', start);
            }

            sb.append(string.substring(start));

            return sb.toString();
        }
    }

    

    
    protected String alias;

    
    protected String keystore;
    protected String storepass;
    protected String storetype;
    protected String keypass;

    protected String sigalg;
    protected String keyalg;
    protected String dname;
    protected DistinguishedName expandedDname;
    protected int keysize;
    protected int validity;
    protected boolean verbose;
    

    
    public DistinguishedName createDname() throws BuildException {
        if (null != expandedDname) {
            throw new BuildException(""DName sub-element can only be ""
                                     + ""specified once."");
        }
        if (null != dname) {
            throw new BuildException(""It is not possible to specify dname ""
                                    + "" both as attribute and element."");
        }
        expandedDname = new DistinguishedName();
        return expandedDname;
    }

    
    public void setDname(final String dname) {
        if (null != expandedDname) {
            throw new BuildException(""It is not possible to specify dname ""
                                    + "" both as attribute and element."");
        }
        this.dname = dname;
    }

    
    public void setAlias(final String alias) {
        this.alias = alias;
    }

    
    public void setKeystore(final String keystore) {
        this.keystore = keystore;
    }

    
    public void setStorepass(final String storepass) {
        this.storepass = storepass;
    }

    
    public void setStoretype(final String storetype) {
        this.storetype = storetype;
    }

    
    public void setKeypass(final String keypass) {
        this.keypass = keypass;
    }

    
    public void setSigalg(final String sigalg) {
        this.sigalg = sigalg;
    }

    
    public void setKeyalg(final String keyalg) {
        this.keyalg = keyalg;
    }

    
    public void setKeysize(final String keysize) throws BuildException {
        try {
            this.keysize = Integer.parseInt(keysize);
        } catch (final NumberFormatException nfe) {
            throw new BuildException(""KeySize attribute should be a integer"");
        }
    }

    
    public void setValidity(final String validity) throws BuildException {
        try {
            this.validity = Integer.parseInt(validity);
        } catch (final NumberFormatException nfe) {
            throw new BuildException(""Validity attribute should be a integer"");
        }
    }

    
    public void setVerbose(final boolean verbose) {
        this.verbose = verbose;
    }

    
    public void execute() throws BuildException {

        if (null == alias) {
            throw new BuildException(""alias attribute must be set"");
        }

        if (null == storepass) {
            throw new BuildException(""storepass attribute must be set"");
        }

        if (null == dname && null == expandedDname) {
            throw new BuildException(""dname must be set"");
        }

        final StringBuffer sb = new StringBuffer();

        sb.append(""-genkey "");

        if (verbose) {
            sb.append(""-v "");
        }

        sb.append(""-alias \"""");
        sb.append(alias);
        sb.append(""\"" "");

        if (null != dname) {
            sb.append(""-dname \"""");
            sb.append(dname);
            sb.append(""\"" "");
        }

        if (null != expandedDname) {
            sb.append(""-dname \"""");
            sb.append(expandedDname);
            sb.append(""\"" "");
        }

        if (null != keystore) {
            sb.append(""-keystore \"""");
            sb.append(keystore);
            sb.append(""\"" "");
        }

        if (null != storepass) {
            sb.append(""-storepass \"""");
            sb.append(storepass);
            sb.append(""\"" "");
        }

        if (null != storetype) {
            sb.append(""-storetype \"""");
            sb.append(storetype);
            sb.append(""\"" "");
        }

        sb.append(""-keypass \"""");
        if (null != keypass) {
            sb.append(keypass);
        } else {
            sb.append(storepass);
        }
        sb.append(""\"" "");

        if (null != sigalg) {
            sb.append(""-sigalg \"""");
            sb.append(sigalg);
            sb.append(""\"" "");
        }

        if (null != keyalg) {
            sb.append(""-keyalg \"""");
            sb.append(keyalg);
            sb.append(""\"" "");
        }


        if (0 < keysize) {
            sb.append(""-keysize \"""");
            sb.append(keysize);
            sb.append(""\"" "");
        }

        if (0 < validity) {
            sb.append(""-validity \"""");
            sb.append(validity);
            sb.append(""\"" "");
        }

        log(""Generating Key for "" + alias);
        final ExecTask cmd = new ExecTask(this);
        cmd.setExecutable(JavaEnvUtils.getJdkExecutable(""keytool""));
        Commandline.Argument arg = cmd.createArg();
        arg.setLine(sb.toString());
        cmd.setFailonerror(true);
        cmd.setTaskName(getTaskName());
        cmd.execute();
    }
}

"
org.apache.tools.ant.types.resources.BaseResourceCollectionContainer,15,3,3,10,47,39,4,6,11,0.547619048,310,1.0,0,0.681818182,0.222222222,2,5,19.46666667,7,1.8667,1,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.util.List;
import java.util.Stack;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.ResourceCollection;


public abstract class BaseResourceCollectionContainer
    extends DataType implements ResourceCollection, Cloneable {
    private List rc = new ArrayList();
    private Collection coll = null;
    private boolean cache = true;

    
    public synchronized void setCache(boolean b) {
        cache = b;
    }

    
    public synchronized boolean isCache() {
        return cache;
    }

    
    public synchronized void clear() throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        rc.clear();
        FailFast.invalidate(this);
        coll = null;
        setChecked(false);
    }

    
    public synchronized void add(ResourceCollection c) throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (c == null) {
            return;
        }
        rc.add(c);
        FailFast.invalidate(this);
        coll = null;
        setChecked(false);
    }

    
    public synchronized void addAll(Collection c) throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        try {
            for (Iterator i = c.iterator(); i.hasNext();) {
                add((ResourceCollection) i.next());
            }
        } catch (ClassCastException e) {
            throw new BuildException(e);
        }
    }

    
    public final synchronized Iterator iterator() {
        if (isReference()) {
            return ((BaseResourceCollectionContainer) getCheckedRef()).iterator();
        }
        dieOnCircularReference();
        return new FailFast(this, cacheCollection().iterator());
    }

    
    public synchronized int size() {
        if (isReference()) {
            return ((BaseResourceCollectionContainer) getCheckedRef()).size();
        }
        dieOnCircularReference();
        return cacheCollection().size();
    }

    
    public synchronized boolean isFilesystemOnly() {
        if (isReference()) {
            return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();
        }
        dieOnCircularReference();
        
        boolean goEarly = true;
        for (Iterator i = rc.iterator(); goEarly && i.hasNext();) {
            goEarly &= ((ResourceCollection) i.next()).isFilesystemOnly();
        }
        if (goEarly) {
            return true;
        }
        
        for (Iterator i = cacheCollection().iterator(); i.hasNext();) {
            if (!(i.next() instanceof FileResource)) {
                return false;
            }
        }
        return true;
    }

    
    protected synchronized void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            for (Iterator i = rc.iterator(); i.hasNext();) {
                Object o = i.next();
                if (o instanceof DataType) {
                    stk.push(o);
                    invokeCircularReferenceCheck((DataType) o, stk, p);
                    stk.pop();
                }
            }
            setChecked(true);
        }
    }

    
    protected final synchronized List getResourceCollections() {
        dieOnCircularReference();
        return Collections.unmodifiableList(rc);
    }

    
    protected abstract Collection getCollection();

    
    public Object clone() {
        try {
            BaseResourceCollectionContainer c
                = (BaseResourceCollectionContainer) super.clone();
            c.rc = new ArrayList(rc);
            c.coll = null;
            return c;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
   }

    
    public synchronized String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        if (cacheCollection().size() == 0) {
            return """";
        }
        StringBuffer sb = new StringBuffer();
        for (Iterator i = coll.iterator(); i.hasNext();) {
            if (sb.length() > 0) {
                sb.append(File.pathSeparatorChar);
            }
            sb.append(i.next());
        }
        return sb.toString();
    }

    private synchronized Collection cacheCollection() {
        if (coll == null || !isCache()) {
            coll = getCollection();
        }
        return coll;
    }

}
"
org.apache.tools.ant.taskdefs.Typedef,1,6,1,3,2,0,2,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.tools.ant.taskdefs;




public class Typedef extends Definer {
}
"
org.apache.tools.ant.helper.SingleCheckExecutor,3,1,0,4,7,3,1,3,3,2.0,17,0.0,0,0.0,0.555555556,0,0,4.666666667,1,0.6667,0,"

package org.apache.tools.ant.helper;


import org.apache.tools.ant.Project;
import org.apache.tools.ant.Executor;
import org.apache.tools.ant.BuildException;



public class SingleCheckExecutor implements Executor {

    
    public void executeTargets(Project project, String[] targetNames)
        throws BuildException {
            project.executeSortedTargets(
                project.topoSort(targetNames, project.getTargets(), false));
    }

    
    public Executor getSubProjectExecutor() {
        return this;
    }

}
"
org.apache.tools.ant.types.Resource,29,3,7,89,59,328,85,5,27,0.880952381,471,0.777777778,0,0.566037736,0.234693878,3,4,14.93103448,6,2.0345,0,"
package org.apache.tools.ant.types;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Resource extends DataType
    implements Cloneable, Comparable, ResourceCollection {

    
    public static final long UNKNOWN_SIZE = -1;

    
    public static final long UNKNOWN_DATETIME = 0L;

    
    protected static final int MAGIC = getMagicNumber(""Resource"".getBytes());

    private static final int NULL_NAME = getMagicNumber(""null name"".getBytes());

    
    protected static int getMagicNumber(byte[] seed) {
        return new BigInteger(seed).intValue();
    }

    private String name = null;
    private Boolean exists = null;
    private Long lastmodified = null;
    private Boolean directory = null;
    private Long size = null;

    
    public Resource() {
    }

    
    public Resource(String name) {
        this(name, false, 0, false);
    }

    
    public Resource(String name, boolean exists, long lastmodified) {
        this(name, exists, lastmodified, false);
    }

    
    public Resource(String name, boolean exists, long lastmodified,
                    boolean directory) {
        this(name, exists, lastmodified, directory, UNKNOWN_SIZE);
    }

    
    public Resource(String name, boolean exists, long lastmodified,
                    boolean directory, long size) {
        this.name = name;
        setName(name);
        setExists(exists);
        setLastModified(lastmodified);
        setDirectory(directory);
        setSize(size);
    }

    
    public String getName() {
        return isReference() ? ((Resource) getCheckedRef()).getName() : name;
    }

    
    public void setName(String name) {
        checkAttributesAllowed();
        this.name = name;
    }

    
    public boolean isExists() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).isExists();
        }
        
        return exists == null || exists.booleanValue();
    }

    
    public void setExists(boolean exists) {
        checkAttributesAllowed();
        this.exists = exists ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public long getLastModified() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getLastModified();
        }
        if (!isExists() || lastmodified == null) {
            return UNKNOWN_DATETIME;
        }
        long result = lastmodified.longValue();
        return result < UNKNOWN_DATETIME ? UNKNOWN_DATETIME : result;
    }

    
    public void setLastModified(long lastmodified) {
        checkAttributesAllowed();
        this.lastmodified = new Long(lastmodified);
    }

    
    public boolean isDirectory() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).isDirectory();
        }
        
        return directory != null && directory.booleanValue();
    }

    
    public void setDirectory(boolean directory) {
        checkAttributesAllowed();
        this.directory = directory ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public void setSize(long size) {
        checkAttributesAllowed();
        this.size = new Long(size > UNKNOWN_SIZE ? size : UNKNOWN_SIZE);
    }

    
    public long getSize() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getSize();
        }
        return isExists()
            ? (size != null ? size.longValue() : UNKNOWN_SIZE)
            : 0L;
    }

    
    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            throw new UnsupportedOperationException(
                    ""CloneNotSupportedException for a Resource caught. ""
                    + ""Derived classes must support cloning."");
        }
    }

    
    public int compareTo(Object other) {
        if (isReference()) {
            return ((Comparable) getCheckedRef()).compareTo(other);
        }
        if (!(other instanceof Resource)) {
            throw new IllegalArgumentException(
                ""Can only be compared with Resources"");
        }
        return toString().compareTo(other.toString());
    }

    
    public boolean equals(Object other) {
        if (isReference()) {
            return getCheckedRef().equals(other);
        }
        return other.getClass().equals(getClass()) && compareTo(other) == 0;
    }

    
    public int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        String name = getName();
        return MAGIC * (name == null ? NULL_NAME : name.hashCode());
    }

    
    public InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        throw new UnsupportedOperationException();
    }

    
    public OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        throw new UnsupportedOperationException();
    }

    
    public Iterator iterator() {
        return isReference() ? ((Resource) getCheckedRef()).iterator()
            : new Iterator() {
            private boolean done = false;
            public boolean hasNext() {
                return !done;
            }
            public Object next() {
                if (done) {
                    throw new NoSuchElementException();
                }
                done = true;
                return Resource.this;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    
    public int size() {
        return isReference() ? ((Resource) getCheckedRef()).size() : 1;
    }

    
    public boolean isFilesystemOnly() {
        
        return isReference() && ((Resource) getCheckedRef()).isFilesystemOnly();
    }

    
    public String toString() {
        if (isReference()) {
            return getCheckedRef().toString();
        }
        String n = getName();
        return n == null ? ""(anonymous)"" : n;
    }

    
    public final String toLongString() {
        return isReference() ? ((Resource) getCheckedRef()).toLongString()
            : getDataTypeName() + "" \"""" + toString() + '""';
    }

    
    public void setRefid(Reference r) {
        if (name != null
            || exists != null
            || lastmodified != null
            || directory != null
            || size != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Add,6,4,0,7,29,0,0,7,5,0.76,195,1.0,0,0.910714286,0.416666667,0,0,30.66666667,1,0.8333,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import java.io.File;
import java.util.Vector;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.FileSet;


public class P4Add extends P4Base {
    private static final int DEFAULT_CMD_LENGTH = 450;
    private int changelist;
    private String addCmd = """";
    private Vector filesets = new Vector();
    private int cmdLength = DEFAULT_CMD_LENGTH;

    

    public void setCommandlength(int len) throws BuildException {
        if (len <= 0) {
            throw new BuildException(""P4Add: Commandlength should be a positive number"");
        }
        this.cmdLength = len;
    }

    
    public void setChangelist(int changelist) throws BuildException {
        if (changelist <= 0) {
            throw new BuildException(""P4Add: Changelist# should be a positive number"");
        }
        this.changelist = changelist;
    }

    
    public void addFileset(FileSet set) {
        filesets.addElement(set);
    }

    
    public void execute() throws BuildException {
        if (P4View != null) {
            addCmd = P4View;
        }
        P4CmdOpts = (changelist > 0) ? (""-c "" + changelist) : """";

        StringBuffer filelist = new StringBuffer();

        for (int i = 0; i < filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());

            String[] srcFiles = ds.getIncludedFiles();
            if (srcFiles != null) {
                for (int j = 0; j < srcFiles.length; j++) {
                    File f = new File(ds.getBasedir(), srcFiles[j]);
                    filelist.append("" "").append('""').append(f.getAbsolutePath()).append('""');
                    if (filelist.length() > cmdLength) {
                        execP4Add(filelist);
                        filelist = new StringBuffer();
                    }
                }
                if (filelist.length() > 0) {
                    execP4Add(filelist);
                }
            } else {
                log(""No files specified to add!"", Project.MSG_WARN);
            }
        }
    }

    private void execP4Add(StringBuffer list) {
        log(""Execing add "" + P4CmdOpts + "" "" + addCmd + list, Project.MSG_INFO);
        execP4Command(""-s add "" + P4CmdOpts + "" "" + addCmd + list, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.optional.PropertyFile,10,3,0,5,41,21,0,5,5,0.666666667,214,1.0,0,0.804347826,0.433333333,0,0,20.0,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.EnumeratedAttribute;


public class PropertyFile extends Task {

    

    
    private String              comment;

    private Properties          properties;
    private File                propertyfile;

    private Vector entries = new Vector();

    

    

    
    public void execute() throws BuildException {
        checkParameters();
        readFile();
        executeOperation();
        writeFile();
    }

    
    public Entry createEntry() {
        Entry e = new Entry();
        entries.addElement(e);
        return e;
    }

    private void executeOperation() throws BuildException {
        for (Enumeration e = entries.elements(); e.hasMoreElements();) {
            Entry entry = (Entry) e.nextElement();
            entry.executeOn(properties);
        }
    }

    private void readFile() throws BuildException {
        
        properties = new Properties();
        try {
            if (propertyfile.exists()) {
                log(""Updating property file: ""
                    + propertyfile.getAbsolutePath());
                FileInputStream fis = null;
                try {
                    fis = new FileInputStream(propertyfile);
                    BufferedInputStream bis = new BufferedInputStream(fis);
                    properties.load(bis);
                } finally {
                    if (fis != null) {
                        fis.close();
                    }
                }
            } else {
                log(""Creating new property file: ""
                    + propertyfile.getAbsolutePath());
                FileOutputStream out = null;
                try {
                    out = new FileOutputStream(propertyfile.getAbsolutePath());
                    out.flush();
                } finally {
                    if (out != null) {
                        out.close();
                    }
                }
            }
        } catch (IOException ioe) {
            throw new BuildException(ioe.toString());
        }
    }

    private void checkParameters() throws BuildException {
        if (!checkParam(propertyfile)) {
            throw new BuildException(""file token must not be null."", getLocation());
        }
    }

    
    public void setFile(File file) {
        propertyfile = file;
    }

    
    public void setComment(String hdr) {
        comment = hdr;
    }

    private void writeFile() throws BuildException {
        BufferedOutputStream bos = null;
        try {
            bos = new BufferedOutputStream(new FileOutputStream(propertyfile));
            properties.store(bos, comment);
        } catch (IOException ioe) {
            throw new BuildException(ioe, getLocation());
        } finally {
            FileUtils.close(bos);
        }
    }

    private boolean checkParam(File param) {
        return !(param == null);
    }

    
    public static class Entry {
        private static final int DEFAULT_INT_VALUE = 0;
        private static final String DEFAULT_DATE_VALUE = ""now"";
        private static final String DEFAULT_STRING_VALUE = """";

        private String              key = null;
        private int                 type = Type.STRING_TYPE;
        private int                 operation = Operation.EQUALS_OPER;
        private String              value = null;
        private String              defaultValue = null;
        private String              newValue = null;
        private String              pattern = null;
        private int                 field = Calendar.DATE;

        
        public void setKey(String value) {
            this.key = value;
        }

        
        public void setValue(String value) {
            this.value = value;
        }

        
        public void setOperation(Operation value) {
            this.operation = Operation.toOperation(value.getValue());
        }

        
        public void setType(Type value) {
            this.type = Type.toType(value.getValue());
        }

        
        public void setDefault(String value) {
            this.defaultValue = value;
        }

        
        public void setPattern(String value) {
            this.pattern = value;
        }

        
        public void setUnit(PropertyFile.Unit unit) {
            field = unit.getCalendarField();
        }

        
        protected void executeOn(Properties props) throws BuildException {
            checkParameters();

            
            String oldValue = (String) props.get(key);
            try {
                if (type == Type.INTEGER_TYPE) {
                    executeInteger(oldValue);
                } else if (type == Type.DATE_TYPE) {
                    executeDate(oldValue);
                } else if (type == Type.STRING_TYPE) {
                    executeString(oldValue);
                } else {
                    throw new BuildException(""Unknown operation type: ""
                        + type);
                }
            } catch (NullPointerException npe) {
                
                
                npe.printStackTrace();
            }

            if (newValue == null) {
                newValue = """";
            }

            
            props.put(key, newValue);
        }

        
        private void executeDate(String oldValue) throws BuildException {
            Calendar currentValue = Calendar.getInstance();

            if (pattern == null) {
              pattern = ""yyyy/MM/dd HH:mm"";
            }
            DateFormat fmt = new SimpleDateFormat(pattern);

            String currentStringValue = getCurrentValue(oldValue);
            if (currentStringValue == null) {
                currentStringValue = DEFAULT_DATE_VALUE;
            }

            if (""now"".equals(currentStringValue)) {
                currentValue.setTime(new Date());
            } else {
                try {
                    currentValue.setTime(fmt.parse(currentStringValue));
                } catch (ParseException pe)  {
                    
                }
            }

            if (operation != Operation.EQUALS_OPER) {
                int offset = 0;
                try {
                    offset = Integer.parseInt(value);
                    if (operation == Operation.DECREMENT_OPER) {
                        offset = -1 * offset;
                    }
                } catch (NumberFormatException e) {
                    throw new BuildException(""Value not an integer on "" + key);
                }
                currentValue.add(field, offset);
            }

            newValue = fmt.format(currentValue.getTime());
        }


        
        private void executeInteger(String oldValue) throws BuildException {
            int currentValue = DEFAULT_INT_VALUE;
            int newV  = DEFAULT_INT_VALUE;


            DecimalFormat fmt = (pattern != null) ? new DecimalFormat(pattern)
                                                    : new DecimalFormat();
            try {
                String curval = getCurrentValue(oldValue);
                if (curval != null) {
                    currentValue = fmt.parse(curval).intValue();
                } else {
                    currentValue = 0;
                }
            } catch (NumberFormatException nfe) {
                
            } catch (ParseException pe)  {
                
            }

            if (operation == Operation.EQUALS_OPER) {
                newV = currentValue;
            } else {
                int operationValue = 1;
                if (value != null) {
                    try {
                        operationValue = fmt.parse(value).intValue();
                    } catch (NumberFormatException nfe) {
                        
                    } catch (ParseException pe)  {
                        
                    }
                }

                if (operation == Operation.INCREMENT_OPER) {
                    newV = currentValue + operationValue;
                } else if (operation == Operation.DECREMENT_OPER) {
                    newV = currentValue - operationValue;
                }
            }

            this.newValue = fmt.format(newV);
        }

        
        private void executeString(String oldValue) throws BuildException {
            String newV  = DEFAULT_STRING_VALUE;

            String currentValue = getCurrentValue(oldValue);

            if (currentValue == null) {
                currentValue = DEFAULT_STRING_VALUE;
            }

            if (operation == Operation.EQUALS_OPER) {
                newV = currentValue;
            } else if (operation == Operation.INCREMENT_OPER) {
                newV = currentValue + value;
            }
            this.newValue = newV;
        }

        
        private void checkParameters() throws BuildException {
            if (type == Type.STRING_TYPE
                && operation == Operation.DECREMENT_OPER) {
                throw new BuildException(""- is not supported for string ""
                    + ""properties (key:"" + key + "")"");
            }
            if (value == null && defaultValue == null) {
                throw new BuildException(""\""value\"" and/or \""default\"" ""
                    + ""attribute must be specified (key:"" + key + "")"");
            }
            if (key == null) {
                throw new BuildException(""key is mandatory"");
            }
            if (type == Type.STRING_TYPE && pattern != null) {
                throw new BuildException(""pattern is not supported for string ""
                    + ""properties (key:"" + key + "")"");
            }
        }

        private String getCurrentValue(String oldValue) {
            String ret = null;
            if (operation == Operation.EQUALS_OPER) {
                
                
                if (value != null && defaultValue == null) {
                    ret = value;
                }

                
                
                if (value == null && defaultValue != null && oldValue != null) {
                    ret = oldValue;
                }

                
                
                if (value == null && defaultValue != null && oldValue == null) {
                    ret = defaultValue;
                }

                
                
                
                if (value != null && defaultValue != null && oldValue != null) {
                    ret = value;
                }

                
                
                
                if (value != null && defaultValue != null && oldValue == null) {
                    ret = defaultValue;
                }
            } else {
                ret = (oldValue == null) ? defaultValue : oldValue;
            }

            return ret;
        }

        
        public static class Operation extends EnumeratedAttribute {

            
            
            public static final int INCREMENT_OPER =   0;
            
            public static final int DECREMENT_OPER =   1;
            
            public static final int EQUALS_OPER =      2;

            
            public String[] getValues() {
                return new String[] {""+"", ""-"", ""=""};
            }

            
            public static int toOperation(String oper) {
                if (""+"".equals(oper)) {
                    return INCREMENT_OPER;
                } else if (""-"".equals(oper)) {
                    return DECREMENT_OPER;
                }
                return EQUALS_OPER;
            }
        }

        
        public static class Type extends EnumeratedAttribute {

            
            
            public static final int INTEGER_TYPE =     0;
            
            public static final int DATE_TYPE =        1;
            
            public static final int STRING_TYPE =      2;

            
            public String[] getValues() {
                return new String[] {""int"", ""date"", ""string""};
            }

            
            public static int toType(String type) {
                if (""int"".equals(type)) {
                    return INTEGER_TYPE;
                } else if (""date"".equals(type)) {
                    return DATE_TYPE;
                }
                return STRING_TYPE;
            }
        }
    }

    
    public static class Unit extends EnumeratedAttribute {

        private static final String MILLISECOND = ""millisecond"";
        private static final String SECOND = ""second"";
        private static final String MINUTE = ""minute"";
        private static final String HOUR = ""hour"";
        private static final String DAY = ""day"";
        private static final String WEEK = ""week"";
        private static final String MONTH = ""month"";
        private static final String YEAR = ""year"";

        private static final String[] UNITS
            = {MILLISECOND, SECOND, MINUTE, HOUR,
               DAY, WEEK, MONTH, YEAR };

        private Map calendarFields = new HashMap();

        
        public Unit() {
            calendarFields.put(MILLISECOND,
                                    new Integer(Calendar.MILLISECOND));
            calendarFields.put(SECOND, new Integer(Calendar.SECOND));
            calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));
            calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));
            calendarFields.put(DAY, new Integer(Calendar.DATE));
            calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));
            calendarFields.put(MONTH, new Integer(Calendar.MONTH));
            calendarFields.put(YEAR, new Integer(Calendar.YEAR));
        }

        
        public int getCalendarField() {
            String key = getValue().toLowerCase();
            Integer i = (Integer) calendarFields.get(key);
            return i.intValue();
        }

        
        public String[] getValues() {
            return UNITS;
        }
    }
}
"
org.apache.tools.ant.types.Description,5,3,0,8,26,10,1,8,3,2.0,144,0.0,0,0.882352941,0.4,0,0,27.8,6,3.0,0,"

package org.apache.tools.ant.types;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.UnknownElement;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.helper.ProjectHelperImpl;

import java.util.Vector;



public class Description extends DataType {

    
    public void addText(String text) {

        ProjectHelper ph = ProjectHelper.getProjectHelper();
        if (!(ph instanceof ProjectHelperImpl)) {
            
            
            return;
        }
        String currentDescription = getProject().getDescription();
        if (currentDescription == null) {
            getProject().setDescription(text);
        } else {
            getProject().setDescription(currentDescription + text);
        }
    }

    
    public static String getDescription(Project project) {
        Vector targets = (Vector) project.getReference(""ant.targets"");
        if (targets == null) {
            return null;
        }
        StringBuffer description = new StringBuffer();
        for (int i = 0; i < targets.size(); i++) {
            Target t = (Target) targets.elementAt(i);
            concatDescriptions(project, t, description);
        }
        return description.toString();
    }

    private static void concatDescriptions(Project project, Target t,
                                           StringBuffer description) {
        if (t == null) {
            return;
        }
        Vector tasks = findElementInTarget(project, t, ""description"");
        if (tasks == null) {
            return;
        }
        for (int i = 0; i < tasks.size(); i++) {
            Task task = (Task) tasks.elementAt(i);
            if (!(task instanceof UnknownElement)) {
                continue;
            }
            UnknownElement ue = ((UnknownElement) task);
            String descComp = ue.getWrapper().getText().toString();
            if (descComp != null) {
                description.append(project.replaceProperties(descComp));
            }
        }
    }

    private static Vector findElementInTarget(Project project,
                                              Target t, String name) {
        Task[] tasks = t.getTasks();
        Vector elems = new Vector();
        for (int i = 0; i < tasks.length; i++) {
            if (name.equals(tasks[i].getTaskName())) {
                elems.addElement(tasks[i]);
            }
        }
        return elems;
    }

}
"
org.apache.tools.ant.types.FlexInteger,3,1,0,0,7,0,0,0,3,0.0,19,1.0,0,0.0,0.666666667,0,0,5.0,1,0.6667,0,"

package org.apache.tools.ant.types;


public class FlexInteger {
    private Integer value;

    
    public FlexInteger(String value) {
        this.value = Integer.decode(value);
    }

    
    public int intValue() {
        return value.intValue();
    }

    
    public String toString() {
        return value.toString();
    }
}
"
org.apache.tools.ant.taskdefs.Filter,6,3,0,5,17,5,0,5,5,0.733333333,94,1.0,0,0.880952381,0.5,0,0,14.16666667,1,0.8333,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;


public class Filter extends Task {

    private String token;
    private String value;
    private File filtersFile;

    
    public void setToken(String token) {
        this.token = token;
    }

    
    public void setValue(String value) {
        this.value = value;
    }

    
    public void setFiltersfile(File filtersFile) {
        this.filtersFile = filtersFile;
    }

    
    public void execute() throws BuildException {
        boolean isFiltersFromFile =
            filtersFile != null && token == null && value == null;
        boolean isSingleFilter =
            filtersFile == null && token != null && value != null;

        if (!isFiltersFromFile && !isSingleFilter) {
            throw new BuildException(""both token and value parameters, or ""
                                     + ""only a filtersFile parameter is ""
                                     + ""required"", getLocation());
        }

        if (isSingleFilter) {
            getProject().getGlobalFilterSet().addFilter(token, value);
        }

        if (isFiltersFromFile) {
            readFilters();
        }
    }

    
    protected void readFilters() throws BuildException {
        log(""Reading filters from "" + filtersFile, Project.MSG_VERBOSE);
        getProject().getGlobalFilterSet().readFiltersFromFile(filtersFile);
    }
}
"
org.apache.tools.ant.taskdefs.AbstractCvsTask,42,3,4,19,107,739,4,15,33,0.928861789,898,0.958333333,2,0.474358974,0.193121693,0,0,19.80952381,10,1.619,1,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.util.FileUtils;


public abstract class AbstractCvsTask extends Task {
    
    public static final int DEFAULT_COMPRESSION_LEVEL = 3;
    private static final int MAXIMUM_COMRESSION_LEVEL = 9;

    private Commandline cmd = new Commandline();

    
    private Vector vecCommandlines = new Vector();

    
    private String cvsRoot;

    
    private String cvsRsh;

    
    private String cvsPackage;
    
    private String tag;
    
    private static final String DEFAULT_COMMAND = ""checkout"";
    
    private String command = null;

    
    private boolean quiet = false;

    
    private boolean reallyquiet = false;

    
    private int compression = 0;

    
    private boolean noexec = false;

    
    private int port = 0;

    
    private File passFile = null;

    
    private File dest;

    
    private boolean append = false;

    
    private File output;

    
    private File error;

    
    private boolean failOnError = false;

    
    private ExecuteStreamHandler executeStreamHandler;
    private OutputStream outputStream;
    private OutputStream errorStream;

    
    public AbstractCvsTask() {
        super();
    }

    
    public void setExecuteStreamHandler(ExecuteStreamHandler handler) {
        this.executeStreamHandler = handler;
    }

    
    protected ExecuteStreamHandler getExecuteStreamHandler() {

        if (this.executeStreamHandler == null) {
            setExecuteStreamHandler(new PumpStreamHandler(getOutputStream(),
                                                          getErrorStream()));
        }

        return this.executeStreamHandler;
    }

    
    protected void setOutputStream(OutputStream outputStream) {

        this.outputStream = outputStream;
    }

    
    protected OutputStream getOutputStream() {

        if (this.outputStream == null) {

            if (output != null) {
                try {
                    setOutputStream(new PrintStream(
                                        new BufferedOutputStream(
                                            new FileOutputStream(output
                                                                 .getPath(),
                                                                 append))));
                } catch (IOException e) {
                    throw new BuildException(e, getLocation());
                }
            } else {
                setOutputStream(new LogOutputStream(this, Project.MSG_INFO));
            }
        }

        return this.outputStream;
    }

    
    protected void setErrorStream(OutputStream errorStream) {

        this.errorStream = errorStream;
    }

    
    protected OutputStream getErrorStream() {

        if (this.errorStream == null) {

            if (error != null) {

                try {
                    setErrorStream(new PrintStream(
                                       new BufferedOutputStream(
                                           new FileOutputStream(error.getPath(),
                                                                append))));
                } catch (IOException e) {
                    throw new BuildException(e, getLocation());
                }
            } else {
                setErrorStream(new LogOutputStream(this, Project.MSG_WARN));
            }
        }

        return this.errorStream;
    }

    
    protected void runCommand(Commandline toExecute) throws BuildException {
        
        
        

        
        

        Environment env = new Environment();

        if (port > 0) {
            Environment.Variable var = new Environment.Variable();
            var.setKey(""CVS_CLIENT_PORT"");
            var.setValue(String.valueOf(port));
            env.addVariable(var);
        }

        
        if (passFile == null) {

            File defaultPassFile = new File(
                System.getProperty(""cygwin.user.home"",
                    System.getProperty(""user.home""))
                + File.separatorChar + "".cvspass"");

            if (defaultPassFile.exists()) {
                this.setPassfile(defaultPassFile);
            }
        }

        if (passFile != null) {
            if (passFile.isFile() && passFile.canRead()) {
                Environment.Variable var = new Environment.Variable();
                var.setKey(""CVS_PASSFILE"");
                var.setValue(String.valueOf(passFile));
                env.addVariable(var);
                log(""Using cvs passfile: "" + String.valueOf(passFile),
                    Project.MSG_VERBOSE);
            } else if (!passFile.canRead()) {
                log(""cvs passfile: "" + String.valueOf(passFile)
                    + "" ignored as it is not readable"",
                    Project.MSG_WARN);
            } else {
                log(""cvs passfile: "" + String.valueOf(passFile)
                    + "" ignored as it is not a file"",
                    Project.MSG_WARN);
            }
        }

        if (cvsRsh != null) {
            Environment.Variable var = new Environment.Variable();
            var.setKey(""CVS_RSH"");
            var.setValue(String.valueOf(cvsRsh));
            env.addVariable(var);
        }

        
        
        
        
        Execute exe = new Execute(getExecuteStreamHandler(), null);

        exe.setAntRun(getProject());
        if (dest == null) {
            dest = getProject().getBaseDir();
        }

        if (!dest.exists()) {
            dest.mkdirs();
        }

        exe.setWorkingDirectory(dest);
        exe.setCommandline(toExecute.getCommandline());
        exe.setEnvironment(env.getVariables());

        try {
            String actualCommandLine = executeToString(exe);
            log(actualCommandLine, Project.MSG_VERBOSE);
            int retCode = exe.execute();
            log(""retCode="" + retCode, Project.MSG_DEBUG);
            
            if (failOnError && Execute.isFailure(retCode)) {
                throw new BuildException(""cvs exited with error code ""
                                         + retCode
                                         + StringUtils.LINE_SEP
                                         + ""Command line was [""
                                         + actualCommandLine + ""]"",
                                         getLocation());
            }
        } catch (IOException e) {
            if (failOnError) {
                throw new BuildException(e, getLocation());
            }
            log(""Caught exception: "" + e.getMessage(), Project.MSG_WARN);
        } catch (BuildException e) {
            if (failOnError) {
                throw(e);
            }
            Throwable t = e.getException();
            if (t == null) {
                t = e;
            }
            log(""Caught exception: "" + t.getMessage(), Project.MSG_WARN);
        } catch (Exception e) {
            if (failOnError) {
                throw new BuildException(e, getLocation());
            }
            log(""Caught exception: "" + e.getMessage(), Project.MSG_WARN);
        }
    }

    
    public void execute() throws BuildException {

        String savedCommand = getCommand();

        if (this.getCommand() == null && vecCommandlines.size() == 0) {
            
            this.setCommand(AbstractCvsTask.DEFAULT_COMMAND);
        }

        String c = this.getCommand();
        Commandline cloned = null;
        if (c != null) {
            cloned = (Commandline) cmd.clone();
            cloned.createArgument(true).setLine(c);
            this.addConfiguredCommandline(cloned, true);
        }

        try {
            for (int i = 0; i < vecCommandlines.size(); i++) {
                this.runCommand((Commandline) vecCommandlines.elementAt(i));
            }
        } finally {
            if (cloned != null) {
                removeCommandline(cloned);
            }
            setCommand(savedCommand);
            FileUtils.close(outputStream);
            FileUtils.close(errorStream);
        }
    }

    private String executeToString(Execute execute) {

        StringBuffer stringBuffer =
            new StringBuffer(Commandline.describeCommand(execute
                                                         .getCommandline()));

        String newLine = StringUtils.LINE_SEP;
        String[] variableArray = execute.getEnvironment();

        if (variableArray != null) {
            stringBuffer.append(newLine);
            stringBuffer.append(newLine);
            stringBuffer.append(""environment:"");
            stringBuffer.append(newLine);
            for (int z = 0; z < variableArray.length; z++) {
                stringBuffer.append(newLine);
                stringBuffer.append(""\t"");
                stringBuffer.append(variableArray[z]);
            }
        }

        return stringBuffer.toString();
    }

    
    public void setCvsRoot(String root) {

        
        if (root != null) {
            if (root.trim().equals("""")) {
                root = null;
            }
        }

        this.cvsRoot = root;
    }

    
    public String getCvsRoot() {

        return this.cvsRoot;
    }

    
    public void setCvsRsh(String rsh) {
        
        if (rsh != null) {
            if (rsh.trim().equals("""")) {
                rsh = null;
            }
        }

        this.cvsRsh = rsh;
    }

    
    public String getCvsRsh() {

        return this.cvsRsh;
    }

    
    public void setPort(int port) {
        this.port = port;
    }

    
    public int getPort() {

        return this.port;
    }

    
    public void setPassfile(File passFile) {
        this.passFile = passFile;
    }

    
    public File getPassFile() {

        return this.passFile;
    }

    
    public void setDest(File dest) {
        this.dest = dest;
    }

    
    public File getDest() {

        return this.dest;
    }

    
    public void setPackage(String p) {
        this.cvsPackage = p;
    }

    
    public String getPackage() {

        return this.cvsPackage;
    }
    
    public String getTag() {
        return tag;
    }

    
    public void setTag(String p) {
        
        if (p != null && p.trim().length() > 0) {
            tag = p;
            addCommandArgument(""-r"" + p);
        }
    }

    
    public void addCommandArgument(String arg) {
        this.addCommandArgument(cmd, arg);
    }

    
    public void addCommandArgument(Commandline c, String arg) {
        c.createArgument().setValue(arg);
    }


    
    public void setDate(String p) {
        if (p != null && p.trim().length() > 0) {
            addCommandArgument(""-D"");
            addCommandArgument(p);
        }
    }

    
    public void setCommand(String c) {
        this.command = c;
    }
    
    public String getCommand() {
        return this.command;
    }

    
    public void setQuiet(boolean q) {
        quiet = q;
    }

    
    public void setReallyquiet(boolean q) {
        reallyquiet = q;
    }


    
    public void setNoexec(boolean ne) {
        noexec = ne;
    }

    
    public void setOutput(File output) {
        this.output = output;
    }

    
    public void setError(File error) {
        this.error = error;
    }

    
    public void setAppend(boolean value) {
        this.append = value;
    }

    
    public void setFailOnError(boolean failOnError) {
        this.failOnError = failOnError;
    }

    
    protected void configureCommandline(Commandline c) {
        if (c == null) {
            return;
        }
        c.setExecutable(""cvs"");
        if (cvsPackage != null) {
            c.createArgument().setLine(cvsPackage);
        }
        if (this.compression > 0
            && this.compression <= MAXIMUM_COMRESSION_LEVEL) {
            c.createArgument(true).setValue(""-z"" + this.compression);
        }
        if (quiet && !reallyquiet) {
            c.createArgument(true).setValue(""-q"");
        }
        if (reallyquiet) {
            c.createArgument(true).setValue(""-Q"");
        }
        if (noexec) {
            c.createArgument(true).setValue(""-n"");
        }
        if (cvsRoot != null) {
            c.createArgument(true).setLine(""-d"" + cvsRoot);
        }
    }

    
    protected void removeCommandline(Commandline c) {
        vecCommandlines.removeElement(c);
    }

    
    public void addConfiguredCommandline(Commandline c) {
        this.addConfiguredCommandline(c, false);
    }

    
    public void addConfiguredCommandline(Commandline c,
                                         boolean insertAtStart) {
        if (c == null) {
            return;
        }
        this.configureCommandline(c);
        if (insertAtStart) {
            vecCommandlines.insertElementAt(c, 0);
        } else {
            vecCommandlines.addElement(c);
        }
    }

    
    public void setCompressionLevel(int level) {
        this.compression = level;
    }

    
    public void setCompression(boolean usecomp) {
        setCompressionLevel(usecomp
            ? AbstractCvsTask.DEFAULT_COMPRESSION_LEVEL : 0);
    }

}
"
org.apache.tools.ant.taskdefs.optional.extension.ExtensionUtil,7,1,0,12,46,21,4,8,0,2.0,264,0.0,0,0.0,0.30952381,0,0,36.71428571,9,2.0,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.FileSet;


public class ExtensionUtil {
    
    private ExtensionUtil() {
        
    }

    
    static ArrayList toExtensions(final List adapters)
        throws BuildException {
        final ArrayList results = new ArrayList();

        final int size = adapters.size();
        for (int i = 0; i < size; i++) {
            final ExtensionAdapter adapter =
                (ExtensionAdapter) adapters.get(i);
            final Extension extension = adapter.toExtension();
            results.add(extension);
        }

        return results;
    }

    
    static void extractExtensions(final Project project,
                                   final List libraries,
                                   final List fileset)
        throws BuildException {
        if (!fileset.isEmpty()) {
            final Extension[] extensions = getExtensions(project,
                                                          fileset);
            for (int i = 0; i < extensions.length; i++) {
                libraries.add(extensions[ i ]);
            }
        }
    }

    
    private static Extension[] getExtensions(final Project project,
                                              final List libraries)
        throws BuildException {
        final ArrayList extensions = new ArrayList();
        final Iterator iterator = libraries.iterator();
        while (iterator.hasNext()) {
            final FileSet fileSet = (FileSet) iterator.next();

            boolean includeImpl = true;
            boolean includeURL = true;

            if (fileSet instanceof LibFileSet) {
                LibFileSet libFileSet = (LibFileSet) fileSet;
                includeImpl = libFileSet.isIncludeImpl();
                includeURL = libFileSet.isIncludeURL();
            }

            final DirectoryScanner scanner = fileSet.getDirectoryScanner(project);
            final File basedir = scanner.getBasedir();
            final String[] files = scanner.getIncludedFiles();
            for (int i = 0; i < files.length; i++) {
                final File file = new File(basedir, files[ i ]);
                loadExtensions(file, extensions, includeImpl, includeURL);
            }
        }
        return (Extension[]) extensions.toArray(new Extension[extensions.size()]);
    }

    
    private static void loadExtensions(final File file,
                                        final List extensionList,
                                        final boolean includeImpl,
                                        final boolean includeURL)
        throws BuildException {
        try {
            final JarFile jarFile = new JarFile(file);
            final Extension[] extensions =
                Extension.getAvailable(jarFile.getManifest());
            for (int i = 0; i < extensions.length; i++) {
                final Extension extension = extensions[ i ];
                addExtension(extensionList, extension, includeImpl, includeURL);
            }
        } catch (final Exception e) {
            throw new BuildException(e.getMessage(), e);
        }
    }

    
    private static void addExtension(final List extensionList,
                                      final Extension originalExtension,
                                      final boolean includeImpl,
                                      final boolean includeURL) {
        Extension extension = originalExtension;
        if (!includeURL
            && null != extension.getImplementationURL()) {
            extension =
                new Extension(extension.getExtensionName(),
                               extension.getSpecificationVersion().toString(),
                               extension.getSpecificationVendor(),
                               extension.getImplementationVersion().toString(),
                               extension.getImplementationVendor(),
                               extension.getImplementationVendorID(),
                               null);
        }

        final boolean hasImplAttributes =
            null != extension.getImplementationURL()
            || null != extension.getImplementationVersion()
            || null != extension.getImplementationVendorID()
            || null != extension.getImplementationVendor();

        if (!includeImpl && hasImplAttributes) {
            extension =
                new Extension(extension.getExtensionName(),
                               extension.getSpecificationVersion().toString(),
                               extension.getSpecificationVendor(),
                               null,
                               null,
                               null,
                               extension.getImplementationURL());
        }

        extensionList.add(extension);
    }

    
    static Manifest getManifest(final File file)
        throws BuildException {
        try {
            final JarFile jarFile = new JarFile(file);
            Manifest m = jarFile.getManifest();
            if (m == null) {
                throw new BuildException(file + "" doesn't have a MANIFEST"");
            }
            return m;
        } catch (final IOException ioe) {
            throw new BuildException(ioe.getMessage(), ioe);
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.unix.Chown,4,6,0,4,16,0,0,4,3,0.333333333,52,1.0,0,0.973913043,0.75,2,2,11.75,2,1.0,0,"



package org.apache.tools.ant.taskdefs.optional.unix;

import org.apache.tools.ant.BuildException;


public class Chown extends AbstractAccessTask {

    private boolean haveOwner = false;

    
    public Chown() {
        super.setExecutable(""chown"");
    }

    
    public void setOwner(String owner) {
        createArg().setValue(owner);
        haveOwner = true;
    }

    
    protected void checkConfiguration() {
        if (!haveOwner) {
            throw new BuildException(""Required attribute owner not set in""
                                     + "" chown"", getLocation());
        }
        super.checkConfiguration();
    }

    
    public void setExecutable(String e) {
        throw new BuildException(getTaskType()
                                 + "" doesn\'t support the executable""
                                 + "" attribute"", getLocation());
    }
}
"
org.apache.tools.ant.BuildException,15,4,3,499,30,0,498,1,15,0.392857143,153,1.0,1,0.619047619,0.322222222,1,3,9.066666667,2,0.6667,0,"
package org.apache.tools.ant;

import java.io.PrintStream;
import java.io.PrintWriter;


public class BuildException extends RuntimeException {

    
    private Throwable cause;

    
    private Location location = Location.UNKNOWN_LOCATION;

    
    public BuildException() {
        super();
    }

    
    public BuildException(String message) {
        super(message);
    }

    
    public BuildException(String message, Throwable cause) {
        super(message);
        this.cause = cause;
    }

    
    public BuildException(String msg, Throwable cause, Location location) {
        this(msg, cause);
        this.location = location;
    }

    
    public BuildException(Throwable cause) {
        super(cause.toString());
        this.cause = cause;
    }

    
    public BuildException(String message, Location location) {
        super(message);
        this.location = location;
    }

    
    public BuildException(Throwable cause, Location location) {
        this(cause);
        this.location = location;
    }

    
    public Throwable getException() {
        return cause;
    }

    
    public Throwable getCause() {
        return getException();
    }

    
    public String toString() {
        return location.toString() + getMessage();
    }

    
    public void setLocation(Location location) {
        this.location = location;
    }

    
    public Location getLocation() {
        return location;
    }

    
    public void printStackTrace() {
        printStackTrace(System.err);
    }

    
    public void printStackTrace(PrintStream ps) {
        synchronized (ps) {
            super.printStackTrace(ps);
            if (cause != null) {
                ps.println(""--- Nested Exception ---"");
                cause.printStackTrace(ps);
            }
        }
    }

    
    public void printStackTrace(PrintWriter pw) {
        synchronized (pw) {
            super.printStackTrace(pw);
            if (cause != null) {
                pw.println(""--- Nested Exception ---"");
                cause.printStackTrace(pw);
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Sync,18,3,0,12,80,61,1,12,12,0.647058824,549,1.0,2,0.685185185,0.181818182,0,0,29.38888889,8,1.9444,4,"

package org.apache.tools.ant.taskdefs;

import java.io.File;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.AbstractFileSet;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.NoneSelector;


public class Sync extends Task {

    
    private MyCopy myCopy;

    
    private SyncTarget syncTarget;

    
    
    public void init()
        throws BuildException {
        
        myCopy = new MyCopy();
        configureTask(myCopy);

        
        myCopy.setFiltering(false);
        myCopy.setIncludeEmptyDirs(false);
        myCopy.setPreserveLastModified(true);
    }

    private void configureTask(Task helper) {
        helper.setProject(getProject());
        helper.setTaskName(getTaskName());
        helper.setOwningTarget(getOwningTarget());
        helper.init();
    }

    
    
    public void execute()
        throws BuildException {
        
        File toDir = myCopy.getToDir();

        
        Set allFiles = myCopy.nonOrphans;

        
        
        boolean noRemovalNecessary = !toDir.exists() || toDir.list().length < 1;

        
        log(""PASS#1: Copying files to "" + toDir, Project.MSG_DEBUG);
        myCopy.execute();

        
        if (noRemovalNecessary) {
            log(""NO removing necessary in "" + toDir, Project.MSG_DEBUG);
            return; 
        }

        
        log(""PASS#2: Removing orphan files from "" + toDir, Project.MSG_DEBUG);
        int[] removedFileCount = removeOrphanFiles(allFiles, toDir);
        logRemovedCount(removedFileCount[0], ""dangling director"", ""y"", ""ies"");
        logRemovedCount(removedFileCount[1], ""dangling file"", """", ""s"");

        
        if (!myCopy.getIncludeEmptyDirs()) {
            log(""PASS#3: Removing empty directories from "" + toDir,
                Project.MSG_DEBUG);
            int removedDirCount = removeEmptyDirectories(toDir, false);
            logRemovedCount(removedDirCount, ""empty director"", ""y"", ""ies"");
        }
    }

    private void logRemovedCount(int count, String prefix,
                                 String singularSuffix, String pluralSuffix) {
        File toDir = myCopy.getToDir();

        String what = (prefix == null) ? """" : prefix;
        what += (count < 2) ? singularSuffix : pluralSuffix;

        if (count > 0) {
            log(""Removed "" + count + "" "" + what + "" from "" + toDir,
                Project.MSG_INFO);
        } else {
            log(""NO "" + what + "" to remove from "" + toDir,
                Project.MSG_VERBOSE);
        }
    }

    
    private int[] removeOrphanFiles(Set nonOrphans, File toDir) {
        int[] removedCount = new int[] {0, 0};
        String[] excls =
            (String[]) nonOrphans.toArray(new String[nonOrphans.size() + 1]);
        
        excls[nonOrphans.size()] = """";

        DirectoryScanner ds = null;
        if (syncTarget != null) {
            FileSet fs = new FileSet();
            fs.setDir(toDir);
            fs.setCaseSensitive(syncTarget.isCaseSensitive());
            fs.setFollowSymlinks(syncTarget.isFollowSymlinks());

            
            
            
            PatternSet ps = syncTarget.mergePatterns(getProject());
            fs.appendExcludes(ps.getIncludePatterns(getProject()));
            fs.appendIncludes(ps.getExcludePatterns(getProject()));
            fs.setDefaultexcludes(!syncTarget.getDefaultexcludes());

            
            
            
            FileSelector[] s = syncTarget.getSelectors(getProject());
            if (s.length > 0) {
                NoneSelector ns = new NoneSelector();
                for (int i = 0; i < s.length; i++) {
                    ns.appendSelector(s[i]);
                }
                fs.appendSelector(ns);
            }
            ds = fs.getDirectoryScanner(getProject());
        } else {
            ds = new DirectoryScanner();
            ds.setBasedir(toDir);
        }
        ds.addExcludes(excls);

        ds.scan();
        String[] files = ds.getIncludedFiles();
        for (int i = 0; i < files.length; i++) {
            File f = new File(toDir, files[i]);
            log(""Removing orphan file: "" + f, Project.MSG_DEBUG);
            f.delete();
            ++removedCount[1];
        }
        String[] dirs = ds.getIncludedDirectories();
        
        
        
        
        
        for (int i = dirs.length - 1; i >= 0; --i) {
            File f = new File(toDir, dirs[i]);
            if (f.list().length < 1) {
            log(""Removing orphan directory: "" + f, Project.MSG_DEBUG);
            f.delete();
            ++removedCount[0];
            }
        }
        return removedCount;
    }

    
    private int removeEmptyDirectories(File dir, boolean removeIfEmpty) {
        int removedCount = 0;
        if (dir.isDirectory()) {
            File[] children = dir.listFiles();
            for (int i = 0; i < children.length; ++i) {
                File file = children[i];
                
                if (file.isDirectory()) {
                    removedCount += removeEmptyDirectories(file, true);
                }
            }
            if (children.length > 0) {
                
                
                children = dir.listFiles();
            }
            if (children.length < 1 && removeIfEmpty) {
                log(""Removing empty directory: "" + dir, Project.MSG_DEBUG);
                dir.delete();
                ++removedCount;
            }
        }
        return removedCount;
    }


    
    
    

    
    public void setTodir(File destDir) {
        myCopy.setTodir(destDir);
    }

    
    public void setVerbose(boolean verbose) {
        myCopy.setVerbose(verbose);
    }

    
    public void setOverwrite(boolean overwrite) {
        myCopy.setOverwrite(overwrite);
    }

    
    public void setIncludeEmptyDirs(boolean includeEmpty) {
        myCopy.setIncludeEmptyDirs(includeEmpty);
    }

    
    public void setFailOnError(boolean failonerror) {
        myCopy.setFailOnError(failonerror);
    }

    
    public void addFileset(FileSet set) {
        add(set);
    }

    
    public void add(ResourceCollection rc) {
        myCopy.add(rc);
    }

    
    public void setGranularity(long granularity) {
        myCopy.setGranularity(granularity);
    }

    
    public void addPreserveInTarget(SyncTarget s) {
        if (syncTarget != null) {
            throw new BuildException(""you must not specify multiple ""
                                     + ""preserveintarget elements."");
        }
        syncTarget = s;
    }

    
    public static class MyCopy extends Copy {

        
        
        private Set nonOrphans = new HashSet();

        
        public MyCopy() {
        }

        
        
        protected void scan(File fromDir, File toDir, String[] files,
                            String[] dirs) {
            assertTrue(""No mapper"", mapperElement == null);

            super.scan(fromDir, toDir, files, dirs);

            for (int i = 0; i < files.length; ++i) {
                nonOrphans.add(files[i]);
            }
            for (int i = 0; i < dirs.length; ++i) {
                nonOrphans.add(dirs[i]);
            }
        }

        
        
        protected Map scan(Resource[] resources, File toDir) {
            assertTrue(""No mapper"", mapperElement == null);

            Map m = super.scan(resources, toDir);

            Iterator iter = m.keySet().iterator();
            while (iter.hasNext()) {
                nonOrphans.add(((Resource) iter.next()).getName());
            }
            return m;
        }

        
        public File getToDir() {
            return destDir;
        }

        
        public boolean getIncludeEmptyDirs() {
            return includeEmpty;
        }

        
        protected boolean supportsNonFileResources() {
            return true;
        }
    }

    
    public static class SyncTarget extends AbstractFileSet {

        
        public SyncTarget() {
            super();
        }

        
        public void setDir(File dir) throws BuildException {
            throw new BuildException(""preserveintarget doesn't support the dir ""
                                     + ""attribute"");
        }

    }

    
    private static void assertTrue(String message, boolean condition) {
        if (!condition) {
            throw new BuildException(""Assertion Error: "" + message);
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.ClassFileUtils,3,1,0,2,5,3,2,0,3,2.0,19,0.0,0,0.0,0.5,0,0,5.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.depend;


public class ClassFileUtils {

    
    public static String convertSlashName(String name) {
        return name.replace('\\', '.').replace('/', '.');
    }

    
    public static String convertDotName(String dotName) {
        return dotName.replace('.', '/');
    }
}

"
org.apache.tools.ant.types.EnumeratedAttribute,9,1,59,62,22,28,61,1,8,0.75,130,0.666666667,0,0.0,0.481481481,0,0,13.11111111,5,1.4444,0,"

package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;


public abstract class EnumeratedAttribute {
    
    
    protected String value;

    

    
    private int index = -1;

    
    public abstract String[] getValues();

    
    protected EnumeratedAttribute() {
    }

    
    public static EnumeratedAttribute getInstance(
        Class clazz,
        String value) throws BuildException {
        if (!EnumeratedAttribute.class.isAssignableFrom(clazz)) {
            throw new BuildException(
                ""You have to provide a subclass from EnumeratedAttribut as clazz-parameter."");
        }
        EnumeratedAttribute ea = null;
        try {
            ea = (EnumeratedAttribute) clazz.newInstance();
        } catch (Exception e) {
            throw new BuildException(e);
        }
        ea.setValue(value);
        return ea;
    }

    
    public final void setValue(String value) throws BuildException {
        int idx = indexOfValue(value);
        if (idx == -1) {
            throw new BuildException(value + "" is not a legal value for this attribute"");
        }
        this.index = idx;
        this.value = value;
    }

    
    public final boolean containsValue(String value) {
        return (indexOfValue(value) != -1);
    }

    
    public final int indexOfValue(String value) {
        String[] values = getValues();
        if (values == null || value == null) {
            return -1;
        }
        for (int i = 0; i < values.length; i++) {
            if (value.equals(values[i])) {
                return i;
            }
        }
        return -1;
    }

    
    public final String getValue() {
        return value;
    }

    
    public final int getIndex() {
        return index;
    }

    
    public String toString() {
        return getValue();
    }

}
"
org.apache.tools.ant.taskdefs.optional.jsp.compilers.JasperC,6,2,0,15,56,13,1,14,3,0.8,280,0.0,1,0.615384615,0.583333333,0,0,45.5,5,2.1667,0,"

package org.apache.tools.ant.taskdefs.optional.jsp.compilers;

import java.io.File;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.taskdefs.optional.jsp.JspC;
import org.apache.tools.ant.taskdefs.optional.jsp.JspMangler;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;


public class JasperC extends DefaultJspCompilerAdapter {

    

    
    JspMangler mangler;

    

    
    public JasperC(JspMangler mangler) {
        this.mangler = mangler;
    }

    
    public boolean execute()
        throws BuildException {
        getJspc().log(""Using jasper compiler"", Project.MSG_VERBOSE);
        CommandlineJava cmd = setupJasperCommand();

        try {
            
            
            Java java = new Java(owner);
            Path p = getClasspath();
            if (getJspc().getClasspath() != null) {
                getProject().log(""using user supplied classpath: "" + p,
                                 Project.MSG_DEBUG);
            } else {
                getProject().log(""using system classpath: "" + p,
                                 Project.MSG_DEBUG);
            }
            java.setClasspath(p);
            java.setDir(getProject().getBaseDir());
            java.setClassname(""org.apache.jasper.JspC"");
            
            String []args = cmd.getJavaCommand().getArguments();
            for (int i = 0; i < args.length; i++) {
                java.createArg().setValue(args[i]);
            }
            java.setFailonerror(getJspc().getFailonerror());
            
            
            java.setFork(true);
            java.setTaskName(""jasperc"");
            java.execute();
            return true;
        } catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(""Error running jsp compiler: "",
                                         ex, getJspc().getLocation());
            }
        } finally {
            getJspc().deleteEmptyJavaFiles();
        }
    }



    
    private CommandlineJava setupJasperCommand() {
        CommandlineJava cmd = new CommandlineJava();
        JspC jspc = getJspc();
        addArg(cmd, ""-d"", jspc.getDestdir());
        addArg(cmd, ""-p"", jspc.getPackage());

        if (!isTomcat5x()) {
            addArg(cmd, ""-v"" + jspc.getVerbose());
        } else {
            getProject().log(""this task doesn't support Tomcat 5.x properly, ""
                             + ""please use the Tomcat provided jspc task ""
                             + ""instead"");
        }

        addArg(cmd, ""-uriroot"", jspc.getUriroot());
        addArg(cmd, ""-uribase"", jspc.getUribase());
        addArg(cmd, ""-ieplugin"", jspc.getIeplugin());
        addArg(cmd, ""-webinc"", jspc.getWebinc());
        addArg(cmd, ""-webxml"", jspc.getWebxml());
        addArg(cmd, ""-die9"");

        if (jspc.isMapped()) {
            addArg(cmd, ""-mapped"");
        }
        if (jspc.getWebApp() != null) {
            File dir = jspc.getWebApp().getDirectory();
            addArg(cmd, ""-webapp"", dir);
        }
        logAndAddFilesToCompile(getJspc(), getJspc().getCompileList(), cmd);
        return cmd;
    }

    

    public JspMangler createMangler() {
        return mangler;
    }

    
    private Path getClasspath() {
        Path p = getJspc().getClasspath();
        if (p == null) {
            p = new Path(getProject());
            return p.concatSystemClasspath(""only"");
        } else {
            return p.concatSystemClasspath(""ignore"");
        }
    }

    
    private boolean isTomcat5x() {
        AntClassLoader l = null;
        try {
            l = getProject().createClassLoader(getClasspath());
            l.loadClass(""org.apache.jasper.tagplugins.jstl.If"");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        } finally {
            if (l != null) {
                l.cleanup();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.IPlanetEjbcTask,14,3,0,7,43,57,0,7,10,0.769230769,386,1.0,1,0.74,0.314285714,0,0,26.07142857,2,1.1429,0,"

package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Path;
import org.xml.sax.SAXException;


public class IPlanetEjbcTask extends Task {

    
    private File    ejbdescriptor;
    private File    iasdescriptor;
    private File    dest;
    private Path    classpath;
    private boolean keepgenerated = false;
    private boolean debug         = false;
    private File    iashome;

    
    public void setEjbdescriptor(File ejbdescriptor) {
        this.ejbdescriptor = ejbdescriptor;
    }

    
    public void setIasdescriptor (File iasdescriptor) {
        this.iasdescriptor = iasdescriptor;
    }

    
    public void setDest(File dest) {
        this.dest = dest;
    }

    
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(getProject());
        }
        return classpath.createPath();
    }

    
    public void setKeepgenerated(boolean keepgenerated) {
        this.keepgenerated = keepgenerated;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    
    public void setIashome(File iashome) {
        this.iashome = iashome;
    }

    
    public void execute() throws BuildException {
        checkConfiguration();

        executeEjbc(getParser());
    }

    
    private void checkConfiguration() throws BuildException {

        if (ejbdescriptor == null) {
            String msg = ""The standard EJB descriptor must be specified using ""
                            + ""the \""ejbdescriptor\"" attribute."";
            throw new BuildException(msg, getLocation());
        }
        if ((!ejbdescriptor.exists()) || (!ejbdescriptor.isFile())) {
            String msg = ""The standard EJB descriptor ("" + ejbdescriptor
                            + "") was not found or isn't a file."";
            throw new BuildException(msg, getLocation());
        }

        if (iasdescriptor == null) {
            String msg = ""The iAS-speific XML descriptor must be specified using""
                            + "" the \""iasdescriptor\"" attribute."";
            throw new BuildException(msg, getLocation());
        }
        if ((!iasdescriptor.exists()) || (!iasdescriptor.isFile())) {
            String msg = ""The iAS-specific XML descriptor ("" + iasdescriptor
                            + "") was not found or isn't a file."";
            throw new BuildException(msg, getLocation());
        }

        if (dest == null) {
            String msg = ""The destination directory must be specified using ""
                            + ""the \""dest\"" attribute."";
            throw new BuildException(msg, getLocation());
        }
        if ((!dest.exists()) || (!dest.isDirectory())) {
            String msg = ""The destination directory ("" + dest + "") was not ""
                            + ""found or isn't a directory."";
            throw new BuildException(msg, getLocation());
        }

        if ((iashome != null) && (!iashome.isDirectory())) {
            String msg = ""If \""iashome\"" is specified, it must be a valid ""
                            + ""directory (it was set to "" + iashome + "")."";
            throw new BuildException(msg, getLocation());
        }
    }

    
    private SAXParser getParser() throws BuildException {

        SAXParser saxParser = null;
        try {
            SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
            saxParserFactory.setValidating(true);
            saxParser = saxParserFactory.newSAXParser();
        } catch (SAXException e) {
            String msg = ""Unable to create a SAXParser: "" + e.getMessage();
            throw new BuildException(msg, e, getLocation());
        } catch (ParserConfigurationException e) {
            String msg = ""Unable to create a SAXParser: "" + e.getMessage();
            throw new BuildException(msg, e, getLocation());
        }

        return saxParser;
    }

    
    private void executeEjbc(SAXParser saxParser) throws BuildException {
        IPlanetEjbc ejbc = new IPlanetEjbc(ejbdescriptor,
                                            iasdescriptor,
                                            dest,
                                            getClasspath().toString(),
                                            saxParser);
        ejbc.setRetainSource(keepgenerated);
        ejbc.setDebugOutput(debug);
        if (iashome != null) {
            ejbc.setIasHomeDir(iashome);
        }

        try {
            ejbc.execute();
        } catch (IOException e) {
            String msg = ""An IOException occurred while trying to read the XML ""
                            + ""descriptor file: "" + e.getMessage();
            throw new BuildException(msg, e, getLocation());
        } catch (SAXException e) {
            String msg = ""A SAXException occurred while trying to read the XML ""
                            + ""descriptor file: "" + e.getMessage();
            throw new BuildException(msg, e, getLocation());
        } catch (IPlanetEjbc.EjbcException e) {
            String msg = ""An exception occurred while trying to run the ejbc ""
                            + ""utility: "" + e.getMessage();
            throw new BuildException(msg, e, getLocation());
        }
    }

    
    private Path getClasspath() {
        Path cp = null;
        if (classpath == null) {
            cp = (new Path(getProject())).concatSystemClasspath(""last"");
        } else {
            cp = classpath.concatSystemClasspath(""ignore"");
        }

        return cp;
    }
}
"
org.apache.tools.ant.taskdefs.optional.javacc.JavaCC,34,3,0,12,86,0,2,10,27,0.998521803,822,1.0,1,0.536231884,0.308080808,1,1,21.97058824,4,1.5588,0,"

package org.apache.tools.ant.taskdefs.optional.javacc;

import java.io.File;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Hashtable;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.JavaEnvUtils;


public class JavaCC extends Task {

    
    private static final String LOOKAHEAD              = ""LOOKAHEAD"";
    private static final String CHOICE_AMBIGUITY_CHECK = ""CHOICE_AMBIGUITY_CHECK"";
    private static final String OTHER_AMBIGUITY_CHECK  = ""OTHER_AMBIGUITY_CHECK"";

    private static final String STATIC                 = ""STATIC"";
    private static final String DEBUG_PARSER           = ""DEBUG_PARSER"";
    private static final String DEBUG_LOOKAHEAD        = ""DEBUG_LOOKAHEAD"";
    private static final String DEBUG_TOKEN_MANAGER    = ""DEBUG_TOKEN_MANAGER"";
    private static final String OPTIMIZE_TOKEN_MANAGER = ""OPTIMIZE_TOKEN_MANAGER"";
    private static final String ERROR_REPORTING        = ""ERROR_REPORTING"";
    private static final String JAVA_UNICODE_ESCAPE    = ""JAVA_UNICODE_ESCAPE"";
    private static final String UNICODE_INPUT          = ""UNICODE_INPUT"";
    private static final String IGNORE_CASE            = ""IGNORE_CASE"";
    private static final String COMMON_TOKEN_ACTION    = ""COMMON_TOKEN_ACTION"";
    private static final String USER_TOKEN_MANAGER     = ""USER_TOKEN_MANAGER"";
    private static final String USER_CHAR_STREAM       = ""USER_CHAR_STREAM"";
    private static final String BUILD_PARSER           = ""BUILD_PARSER"";
    private static final String BUILD_TOKEN_MANAGER    = ""BUILD_TOKEN_MANAGER"";
    private static final String SANITY_CHECK           = ""SANITY_CHECK"";
    private static final String FORCE_LA_CHECK         = ""FORCE_LA_CHECK"";
    private static final String CACHE_TOKENS           = ""CACHE_TOKENS"";
    private static final String KEEP_LINE_COLUMN       = ""KEEP_LINE_COLUMN"";
    private static final String JDK_VERSION            = ""JDK_VERSION"";

    private final Hashtable optionalAttrs = new Hashtable();

    
    private File outputDirectory = null;
    private File targetFile      = null;
    private File javaccHome      = null;

    private CommandlineJava cmdl = new CommandlineJava();

    protected static final int TASKDEF_TYPE_JAVACC = 1;
    protected static final int TASKDEF_TYPE_JJTREE = 2;
    protected static final int TASKDEF_TYPE_JJDOC = 3;

    protected static final String[] ARCHIVE_LOCATIONS =
        new String[] {
            ""JavaCC.zip"",
            ""bin/lib/JavaCC.zip"",
            ""bin/lib/javacc.jar"",
            ""javacc.jar"", 
        };

    protected static final int[] ARCHIVE_LOCATIONS_VS_MAJOR_VERSION =
        new int[] {
            1,
            2,
            3,
            3,
        };

    protected static final String COM_PACKAGE = ""COM.sun.labs."";
    protected static final String COM_JAVACC_CLASS = ""javacc.Main"";
    protected static final String COM_JJTREE_CLASS = ""jjtree.Main"";
    protected static final String COM_JJDOC_CLASS = ""jjdoc.JJDocMain"";

    protected static final String ORG_PACKAGE_3_0 = ""org.netbeans.javacc."";
    protected static final String ORG_PACKAGE_3_1 = ""org.javacc."";
    protected static final String ORG_JAVACC_CLASS = ""parser.Main"";
    protected static final String ORG_JJTREE_CLASS = COM_JJTREE_CLASS;
    protected static final String ORG_JJDOC_CLASS = COM_JJDOC_CLASS;

    
    public void setLookahead(int lookahead) {
        optionalAttrs.put(LOOKAHEAD, new Integer(lookahead));
    }

    
    public void setChoiceambiguitycheck(int choiceAmbiguityCheck) {
        optionalAttrs.put(CHOICE_AMBIGUITY_CHECK, new Integer(choiceAmbiguityCheck));
    }

    
    public void setOtherambiguityCheck(int otherAmbiguityCheck) {
        optionalAttrs.put(OTHER_AMBIGUITY_CHECK, new Integer(otherAmbiguityCheck));
    }

    
    public void setStatic(boolean staticParser) {
        optionalAttrs.put(STATIC, staticParser ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setDebugparser(boolean debugParser) {
        optionalAttrs.put(DEBUG_PARSER, debugParser ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setDebuglookahead(boolean debugLookahead) {
        optionalAttrs.put(DEBUG_LOOKAHEAD, debugLookahead ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setDebugtokenmanager(boolean debugTokenManager) {
        optionalAttrs.put(DEBUG_TOKEN_MANAGER, debugTokenManager ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setOptimizetokenmanager(boolean optimizeTokenManager) {
        optionalAttrs.put(OPTIMIZE_TOKEN_MANAGER,
                          optimizeTokenManager ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setErrorreporting(boolean errorReporting) {
        optionalAttrs.put(ERROR_REPORTING, errorReporting ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setJavaunicodeescape(boolean javaUnicodeEscape) {
        optionalAttrs.put(JAVA_UNICODE_ESCAPE, javaUnicodeEscape ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setUnicodeinput(boolean unicodeInput) {
        optionalAttrs.put(UNICODE_INPUT, unicodeInput ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setIgnorecase(boolean ignoreCase) {
        optionalAttrs.put(IGNORE_CASE, ignoreCase ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setCommontokenaction(boolean commonTokenAction) {
        optionalAttrs.put(COMMON_TOKEN_ACTION, commonTokenAction ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setUsertokenmanager(boolean userTokenManager) {
        optionalAttrs.put(USER_TOKEN_MANAGER, userTokenManager ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setUsercharstream(boolean userCharStream) {
        optionalAttrs.put(USER_CHAR_STREAM, userCharStream ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setBuildparser(boolean buildParser) {
        optionalAttrs.put(BUILD_PARSER, buildParser ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setBuildtokenmanager(boolean buildTokenManager) {
        optionalAttrs.put(BUILD_TOKEN_MANAGER, buildTokenManager ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setSanitycheck(boolean sanityCheck) {
        optionalAttrs.put(SANITY_CHECK, sanityCheck ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setForcelacheck(boolean forceLACheck) {
        optionalAttrs.put(FORCE_LA_CHECK, forceLACheck ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setCachetokens(boolean cacheTokens) {
        optionalAttrs.put(CACHE_TOKENS, cacheTokens ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setKeeplinecolumn(boolean keepLineColumn) {
        optionalAttrs.put(KEEP_LINE_COLUMN, keepLineColumn ? Boolean.TRUE : Boolean.FALSE);
    }

    
    public void setJDKversion(String jdkVersion) {
        optionalAttrs.put(JDK_VERSION, jdkVersion);
    }

    
    public void setOutputdirectory(File outputDirectory) {
        this.outputDirectory = outputDirectory;
    }

    
    public void setTarget(File targetFile) {
        this.targetFile = targetFile;
    }

    
    public void setJavacchome(File javaccHome) {
        this.javaccHome = javaccHome;
    }

    
    public JavaCC() {
        cmdl.setVm(JavaEnvUtils.getJreExecutable(""java""));
    }

    
    public void execute() throws BuildException {

        
        Enumeration iter = optionalAttrs.keys();
        while (iter.hasMoreElements()) {
            String name  = (String) iter.nextElement();
            Object value = optionalAttrs.get(name);
            cmdl.createArgument().setValue(""-"" + name + "":"" + value.toString());
        }

        
        if (targetFile == null || !targetFile.isFile()) {
            throw new BuildException(""Invalid target: "" + targetFile);
        }

        
        if (outputDirectory == null) {
            outputDirectory = new File(targetFile.getParent());
        } else if (!outputDirectory.isDirectory()) {
            throw new BuildException(""Outputdir not a directory."");
        }
        cmdl.createArgument().setValue(""-OUTPUT_DIRECTORY:""
                                       + outputDirectory.getAbsolutePath());

        
        final File javaFile = getOutputJavaFile(outputDirectory, targetFile);
        if (javaFile.exists() && targetFile.lastModified() < javaFile.lastModified()) {
            log(""Target is already built - skipping ("" + targetFile + "")"", Project.MSG_VERBOSE);
            return;
        }
        cmdl.createArgument().setValue(targetFile.getAbsolutePath());

        final Path classpath = cmdl.createClasspath(getProject());
        final File javaccJar = JavaCC.getArchiveFile(javaccHome);
        classpath.createPathElement().setPath(javaccJar.getAbsolutePath());
        classpath.addJavaRuntime();

        cmdl.setClassname(JavaCC.getMainClass(classpath,
                                              JavaCC.TASKDEF_TYPE_JAVACC));

        final Commandline.Argument arg = cmdl.createVmArgument();
        arg.setValue(""-mx140M"");
        arg.setValue(""-Dinstall.root="" + javaccHome.getAbsolutePath());

        Execute.runCommand(this, cmdl.getCommandline());
    }

    
    protected static File getArchiveFile(File home) throws BuildException {
        return new File(home,
                        ARCHIVE_LOCATIONS[getArchiveLocationIndex(home)]);
    }

    
    protected static String getMainClass(File home, int type)
        throws BuildException {

        Path p = new Path(null);
        p.createPathElement().setLocation(getArchiveFile(home));
        p.addJavaRuntime();
        return getMainClass(p, type);
    }

    
    protected static String getMainClass(Path path, int type)
        throws BuildException {
        String packagePrefix = null;
        String mainClass = null;

        AntClassLoader l = new AntClassLoader();
        l.setClassPath(path.concatSystemClasspath(""ignore""));
        String javaccClass = COM_PACKAGE + COM_JAVACC_CLASS;
        InputStream is = l.getResourceAsStream(javaccClass.replace('.', '/')
                                               + "".class"");
        if (is != null) {
            packagePrefix = COM_PACKAGE;
            switch (type) {
            case TASKDEF_TYPE_JAVACC:
                mainClass = COM_JAVACC_CLASS;

                break;

            case TASKDEF_TYPE_JJTREE:
                mainClass = COM_JJTREE_CLASS;

                break;

            case TASKDEF_TYPE_JJDOC:
                mainClass = COM_JJDOC_CLASS;

                break;
            default:
                
            }
        } else {
            javaccClass = ORG_PACKAGE_3_1 + ORG_JAVACC_CLASS;
            is = l.getResourceAsStream(javaccClass.replace('.', '/')
                                       + "".class"");
            if (is != null) {
                packagePrefix = ORG_PACKAGE_3_1;
            } else {
                javaccClass = ORG_PACKAGE_3_0 + ORG_JAVACC_CLASS;
                is = l.getResourceAsStream(javaccClass.replace('.', '/')
                                           + "".class"");
                if (is != null) {
                    packagePrefix = ORG_PACKAGE_3_0;
                }
            }

            if (is != null) {
                switch (type) {
                case TASKDEF_TYPE_JAVACC:
                    mainClass = ORG_JAVACC_CLASS;

                break;

                case TASKDEF_TYPE_JJTREE:
                    mainClass = ORG_JJTREE_CLASS;

                    break;

                case TASKDEF_TYPE_JJDOC:
                    mainClass = ORG_JJDOC_CLASS;

                    break;
                default:
                    
                }
            }
        }

        if (packagePrefix == null) {
            throw new BuildException(""failed to load JavaCC"");
        }
        if (mainClass == null) {
            throw new BuildException(""unknown task type "" + type);
        }
        return packagePrefix + mainClass;
    }

    
    private static int getArchiveLocationIndex(File home)
        throws BuildException {

        if (home == null || !home.isDirectory()) {
            throw new BuildException(""JavaCC home must be a valid directory."");
        }

        for (int i = 0; i < ARCHIVE_LOCATIONS.length; i++) {
            File f = new File(home, ARCHIVE_LOCATIONS[i]);

            if (f.exists()) {
                return i;
            }
        }

        throw new BuildException(""Could not find a path to JavaCC.zip ""
                                 + ""or javacc.jar from '"" + home + ""'."");
    }

    
    protected static int getMajorVersionNumber(File home)
        throws BuildException {

        return
            ARCHIVE_LOCATIONS_VS_MAJOR_VERSION[getArchiveLocationIndex(home)];
    }

    
    private File getOutputJavaFile(File outputdir, File srcfile) {
        String path = srcfile.getPath();

        
        int startBasename = path.lastIndexOf(File.separator);
        if (startBasename != -1) {
            path = path.substring(startBasename + 1);
        }

        
        int startExtn = path.lastIndexOf('.');
        if (startExtn != -1) {
            path = path.substring(0, startExtn) + "".java"";
        } else {
            path += "".java"";
        }

        
        if (outputdir != null) {
            path = outputdir + File.separator + path;
        }

        return new File(path);
    }
}
"
org.apache.tools.ant.util.ConcatResourceInputStream,10,2,0,6,26,9,2,4,7,0.722222222,156,1.0,1,0.5,0.25,1,1,14.0,3,1.1,0,"

package org.apache.tools.ant.util;

import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.util.Iterator;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;


public class ConcatResourceInputStream extends InputStream {

    private static final int EOF = -1;
    private boolean eof = false;
    private Iterator iter;
    private InputStream currentStream;
    private ProjectComponent managingPc;
    private boolean ignoreErrors = false;

  
    public ConcatResourceInputStream(ResourceCollection rc) {
        iter = rc.iterator();
    }

    
    public void setIgnoreErrors(boolean b) {
        ignoreErrors = b;
    }

    
    public boolean isIgnoreErrors() {
        return ignoreErrors;
    }

    
     public void close() throws IOException {
        closeCurrent();
        eof = true;
    }

    
    public int read() throws IOException {
        if (eof) {
            return EOF;
        }
        int result = readCurrent();
        if (result == EOF) {
            nextResource();
            result = readCurrent();
        }
        return result;
    }

    
    public void setManagingComponent(ProjectComponent pc) {
        this.managingPc = pc;
    }

    
    public void log(String message, int loglevel) {
        if (managingPc != null) {
            managingPc.log(message, loglevel);
        } else {
            (loglevel > Project.MSG_WARN ? System.out : System.err).println(message);
        }
    }

    private int readCurrent() throws IOException {
        return eof || currentStream == null ? EOF : currentStream.read();
    }

    private void nextResource() throws IOException {
        closeCurrent();
        while (iter.hasNext()) {
            Resource r = (Resource) iter.next();
            if (!r.isExists()) {
                continue;
            }
            log(""Concating "" + r.toLongString(), Project.MSG_VERBOSE);
            try {
                currentStream = new BufferedInputStream(r.getInputStream());
                return;
            } catch (IOException eyeOhEx) {
                if (!ignoreErrors) {
                    log(""Failed to get input stream for "" + r, Project.MSG_ERR);
                    throw eyeOhEx;
                }
            }
        }
        eof = true;
    }

    private void closeCurrent() {
        FileUtils.close(currentStream);
        currentStream = null;
    }
}
"
org.apache.tools.ant.types.selectors.modifiedselector.EqualComparator,3,1,0,1,5,3,1,0,3,2.0,24,0.0,0,0.0,0.666666667,0,0,7.0,4,1.6667,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.util.Comparator;



public class EqualComparator implements Comparator {

    
    public int compare(Object o1, Object o2) {
        if (o1 == null) {
            if (o2 == null) {
                return 1;
            }
            return 0;
        }
        return (o1.equals(o2)) ? 0 : 1;
    }

    
    public String toString() {
        return ""EqualComparator"";
    }
}
"
org.apache.tools.ant.taskdefs.condition.IsFalse,3,2,0,4,6,0,1,3,3,0.0,34,1.0,0,0.818181818,0.666666667,0,0,10.0,2,1.0,0,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;


public class IsFalse extends ProjectComponent implements Condition {
    
    private Boolean value = null;

    
    public void setValue(boolean value) {
        this.value = value ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public boolean eval() throws BuildException {
        if (value == null) {
            throw new BuildException(""Nothing to test for falsehood"");
        }
        return !value.booleanValue();
    }

}

"
org.apache.tools.ant.taskdefs.RecorderEntry,25,1,0,10,53,224,1,9,17,0.720238095,460,1.0,1,0.0,0.2,0,0,17.12,5,1.84,1,"
package org.apache.tools.ant.taskdefs;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.BuildLogger;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.SubBuildListener;
import org.apache.tools.ant.util.StringUtils;


public class RecorderEntry implements BuildLogger, SubBuildListener {

    
    

    
    private String filename = null;
    
    private boolean record = true;
    
    private int loglevel = Project.MSG_INFO;
    
    private PrintStream out = null;
    
    private long targetStartTime = 0L;
    
    private boolean emacsMode = false;
    
    private Project project;

    
    

    
    protected RecorderEntry(String name) {
        targetStartTime = System.currentTimeMillis();
        filename = name;
    }

    
    

    
    public String getFilename() {
        return filename;
    }

    
    public void setRecordState(Boolean state) {
        if (state != null) {
            flush();
            record = state.booleanValue();
        }
    }

    
    
    public void buildStarted(BuildEvent event) {
        log(""> BUILD STARTED"", Project.MSG_DEBUG);
    }

    
    
    public void buildFinished(BuildEvent event) {
        log(""< BUILD FINISHED"", Project.MSG_DEBUG);

        if (record && out != null) {
            Throwable error = event.getException();

            if (error == null) {
                out.println(StringUtils.LINE_SEP + ""BUILD SUCCESSFUL"");
            } else {
                out.println(StringUtils.LINE_SEP + ""BUILD FAILED""
                            + StringUtils.LINE_SEP);
                error.printStackTrace(out);
            }
        }
        cleanup();
    }

    
    public void subBuildFinished(BuildEvent event) {
        if (event.getProject() == project) {
            cleanup();
        }
    }

    
    public void subBuildStarted(BuildEvent event) {
    }

    
    
    public void targetStarted(BuildEvent event) {
        log("">> TARGET STARTED -- "" + event.getTarget(), Project.MSG_DEBUG);
        log(StringUtils.LINE_SEP + event.getTarget().getName() + "":"",
            Project.MSG_INFO);
        targetStartTime = System.currentTimeMillis();
    }

    
    
    public void targetFinished(BuildEvent event) {
        log(""<< TARGET FINISHED -- "" + event.getTarget(), Project.MSG_DEBUG);

        String time = formatTime(System.currentTimeMillis() - targetStartTime);

        log(event.getTarget() + "":  duration "" + time, Project.MSG_VERBOSE);
        flush();
    }

    
    
    public void taskStarted(BuildEvent event) {
        log("">>> TASK STARTED -- "" + event.getTask(), Project.MSG_DEBUG);
    }

    
    
    public void taskFinished(BuildEvent event) {
        log(""<<< TASK FINISHED -- "" + event.getTask(), Project.MSG_DEBUG);
        flush();
    }

    
    
    public void messageLogged(BuildEvent event) {
        log(""--- MESSAGE LOGGED"", Project.MSG_DEBUG);

        StringBuffer buf = new StringBuffer();

        if (event.getTask() != null) {
            String name = event.getTask().getTaskName();

            if (!emacsMode) {
                String label = ""["" + name + ""] "";
                int size = DefaultLogger.LEFT_COLUMN_SIZE - label.length();

                for (int i = 0; i < size; i++) {
                    buf.append("" "");
                }
                buf.append(label);
            }
        }
        buf.append(event.getMessage());

        log(buf.toString(), event.getPriority());
    }


    
    private void log(String mesg, int level) {
        if (record && (level <= loglevel) && out != null) {
            out.println(mesg);
        }
    }

    private void flush() {
        if (record && out != null) {
            out.flush();
        }
    }

    
    
    public void setMessageOutputLevel(int level) {
        if (level >= Project.MSG_ERR && level <= Project.MSG_DEBUG) {
            loglevel = level;
        }
    }

    
    
    public void setOutputPrintStream(PrintStream output) {
        closeFile();
        out = output;
    }


    
    
    public void setEmacsMode(boolean emacsMode) {
        this.emacsMode = emacsMode;
    }


    
    
    public void setErrorPrintStream(PrintStream err) {
        setOutputPrintStream(err);
    }


    private static String formatTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;


        if (minutes > 0) {
            return Long.toString(minutes) + "" minute""
                 + (minutes == 1 ? "" "" : ""s "")
                 + Long.toString(seconds % 60) + "" second""
                 + (seconds % 60 == 1 ? """" : ""s"");
        } else {
            return Long.toString(seconds) + "" second""
                 + (seconds % 60 == 1 ? """" : ""s"");
        }

    }

    
    public void setProject(Project project) {
        this.project = project;
        if (project != null) {
            project.addBuildListener(this);
        }
    }

    
    public void cleanup() {
        closeFile();
        if (project != null) {
            project.removeBuildListener(this);
        }
        project = null;
    }

    
    void openFile(boolean append) throws BuildException {
        openFileImpl(append);
    }

    
    void closeFile() {
        if (out != null) {
            out.close();
            out = null;
        }
    }

    
    void reopenFile() throws BuildException {
        openFileImpl(true);
    }

    private void openFileImpl(boolean append) throws BuildException {
        if (out == null) {
            try {
                out = new PrintStream(new FileOutputStream(filename, append));
            } catch (IOException ioe) {
                throw new BuildException(""Problems opening file using a ""
                                         + ""recorder entry"", ioe);
            }
        }
    }

}
"
org.apache.tools.ant.dispatch.DispatchUtils,2,1,0,6,23,1,3,4,2,2.0,265,0.0,0,0.0,0.5,0,0,131.5,1,0.5,0,"
package org.apache.tools.ant.dispatch;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.UnknownElement;
import org.apache.tools.ant.Task;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;


public class DispatchUtils {
    
    public static final void execute(Object task) throws BuildException {
        String methodName = ""execute"";
        Dispatchable dispatchable = null;
        try {
            if (task instanceof Dispatchable) {
                dispatchable = (Dispatchable) task;
            } else if (task instanceof UnknownElement) {
                UnknownElement ue = (UnknownElement) task;
                Object realThing = ue.getRealThing();
                if (realThing != null
                    && realThing instanceof Dispatchable
                    && realThing instanceof Task) {
                    dispatchable = (Dispatchable) realThing;
                }
            }
            if (dispatchable != null) {
                String mName = null;
                try {
                    final String name = dispatchable.getActionParameterName();
                    if (name != null && name.trim().length() > 0) {
                        mName = ""get"" + name.trim().substring(0, 1).toUpperCase();
                        if (name.length() > 1) {
                            mName += name.substring(1);
                        }
                        final Class c = dispatchable.getClass();
                        final Method actionM = c.getMethod(mName, new Class[0]);
                        if (actionM != null) {
                            final Object o = actionM.invoke(dispatchable, (Object[]) null);
                            if (o != null) {
                                final String s = o.toString();
                                if (s != null && s.trim().length() > 0) {
                                    methodName = s.trim();
                                    Method executeM = null;
                                    executeM = dispatchable.getClass().getMethod(
                                        methodName, new Class[0]);
                                    if (executeM == null) {
                                        throw new BuildException(
                                            ""No public "" + methodName + ""() in ""
                                            + dispatchable.getClass());
                                    }
                                    executeM.invoke(dispatchable, (Object[]) null);
                                    if (task instanceof UnknownElement) {
                                        ((UnknownElement) task).setRealThing(null);
                                    }
                                } else {
                                    throw new BuildException(
                                        ""Dispatchable Task attribute '"" + name.trim()
                                        + ""' not set or value is empty."");
                                }
                            } else {
                                    throw new BuildException(
                                        ""Dispatchable Task attribute '"" + name.trim()
                                        + ""' not set or value is empty."");
                            }
                        }
                    } else {
                        throw new BuildException(
                            ""Action Parameter Name must not be empty for Dispatchable Task."");
                    }
                } catch (NoSuchMethodException nsme) {
                    throw new BuildException(""No public "" + mName + ""() in "" + task.getClass());
                }
            } else {
                Method executeM = null;
                executeM = task.getClass().getMethod(methodName, new Class[0]);
                if (executeM == null) {
                    throw new BuildException(""No public "" + methodName + ""() in ""
                        + task.getClass());
                }
                executeM.invoke(task, (Object[]) null);
                if (task instanceof UnknownElement) {
                    ((UnknownElement) task).setRealThing(null);
                }
            }
        } catch (InvocationTargetException ie) {
            Throwable t = ie.getTargetException();
            if (t instanceof BuildException) {
                throw ((BuildException) t);
            } else {
                throw new BuildException(t);
            }
        } catch (NoSuchMethodException e) {
            throw new BuildException(e);
        } catch (IllegalAccessException e) {
            throw new BuildException(e);
        }
    }
}
"
org.apache.tools.ant.util.regexp.Regexp,1,1,0,13,1,0,11,2,1,2.0,3,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.util.regexp;

import org.apache.tools.ant.BuildException;


public interface Regexp extends RegexpMatcher {

    
    int REPLACE_FIRST          = 0x00000001;

    
    int REPLACE_ALL            = 0x00000010;

    
    String substitute(String input, String argument, int options)
        throws BuildException;
}
"
org.apache.tools.ant.taskdefs.optional.sos.SOSLabel,5,4,0,5,18,10,0,5,4,2.0,81,0.0,0,0.948717949,0.8,1,2,15.2,3,1.2,0,"
package org.apache.tools.ant.taskdefs.optional.sos;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Commandline;


public class SOSLabel extends SOS {

    
    public void setVersion(String version) {
        super.setInternalVersion(version);
    }

    
    public void setLabel(String label) {
        super.setInternalLabel(label);
    }

    
    public void setComment(String comment) {
        super.setInternalComment(comment);
    }

    
    protected Commandline buildCmdLine() {
        commandLine = new Commandline();

        
        commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
        commandLine.createArgument().setValue(SOSCmd.COMMAND_LABEL);

        getRequiredAttributes();

        
        if (getLabel() == null) {
            throw new BuildException(""label attribute must be set!"", getLocation());
        }
        commandLine.createArgument().setValue(SOSCmd.FLAG_LABEL);
        commandLine.createArgument().setValue(getLabel());

        
        commandLine.createArgument().setValue(getVerbose());
        
        if (getComment() != null) {
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMENT);
            commandLine.createArgument().setValue(getComment());
        }
        return commandLine;
    }
}
"
org.apache.tools.ant.taskdefs.Manifest,16,1,0,8,76,0,3,5,16,0.883333333,616,0.25,1,0.0,0.166666667,1,1,36.5,8,1.5625,1,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;


public class Manifest {
    
    public static final String ATTRIBUTE_MANIFEST_VERSION
        = ""Manifest-Version"";

    
    public static final String ATTRIBUTE_SIGNATURE_VERSION
        = ""Signature-Version"";

    
    public static final String ATTRIBUTE_NAME = ""Name"";

    
    public static final String ATTRIBUTE_FROM = ""From"";

    
    public static final String ATTRIBUTE_CLASSPATH = ""Class-Path"";

    
    public static final  String DEFAULT_MANIFEST_VERSION = ""1.0"";

    
    public static final int MAX_LINE_LENGTH = 72;

    
    public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2;

    
    public static final String EOL = ""\r\n"";
    
    public static final String ERROR_FROM_FORBIDDEN = ""Manifest attributes should not start ""
                        + ""with \"""" + ATTRIBUTE_FROM + ""\"" in \"""";

    
    public static final String JAR_ENCODING = ""UTF-8"";

    
    public static class Attribute {

        
        private static final int MAX_NAME_VALUE_LENGTH = 68;

        
        private static final int MAX_NAME_LENGTH = 70;

        
        private String name = null;

        
        private Vector values = new Vector();

        
        private int currentIndex = 0;

        
        public Attribute() {
        }

        
        public Attribute(String line) throws ManifestException {
            parse(line);
        }

        
        public Attribute(String name, String value) {
            this.name = name;
            setValue(value);
        }

        
        public int hashCode() {
            int hashCode = 0;

            if (name != null) {
                hashCode += getKey().hashCode();
            }

            hashCode += values.hashCode();
            return hashCode;
        }

        
        public boolean equals(Object rhs) {
            if (rhs == null || rhs.getClass() != getClass()) {
                return false;
            }

            if (rhs == this) {
                return true;
            }

            Attribute rhsAttribute = (Attribute) rhs;
            String lhsKey = getKey();
            String rhsKey = rhsAttribute.getKey();
            if ((lhsKey == null && rhsKey != null)
                 || (lhsKey != null && rhsKey == null)
                 || !lhsKey.equals(rhsKey)) {
                return false;
            }

            return values.equals(rhsAttribute.values);
        }

        
        public void parse(String line) throws ManifestException {
            int index = line.indexOf("": "");
            if (index == -1) {
                throw new ManifestException(""Manifest line \"""" + line
                    + ""\"" is not valid as it does not ""
                    + ""contain a name and a value separated by ': ' "");
            }
            name = line.substring(0, index);
            setValue(line.substring(index + 2));
        }

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }

        
        public String getKey() {
            if (name == null) {
                return null;
            }
            return name.toLowerCase();
        }

        
        public void setValue(String value) {
            if (currentIndex >= values.size()) {
                values.addElement(value);
                currentIndex = values.size() - 1;
            } else {
                values.setElementAt(value, currentIndex);
            }
        }

        
        public String getValue() {
            if (values.size() == 0) {
                return null;
            }

            String fullValue = """";
            for (Enumeration e = getValues(); e.hasMoreElements();) {
                String value = (String) e.nextElement();
                fullValue += value + "" "";
            }
            return fullValue.trim();
        }

        
        public void addValue(String value) {
            currentIndex++;
            setValue(value);
        }

        
        public Enumeration getValues() {
            return values.elements();
        }

        
        public void addContinuation(String line) {
            String currentValue = (String) values.elementAt(currentIndex);
            setValue(currentValue + line.substring(1));
        }

        
        public void write(PrintWriter writer) throws IOException {
            for (Enumeration e = getValues(); e.hasMoreElements();) {
                writeValue(writer, (String) e.nextElement());
            }
        }

        
        private void writeValue(PrintWriter writer, String value)
             throws IOException {
            String line = null;
            int nameLength = name.getBytes(JAR_ENCODING).length;
            if (nameLength > MAX_NAME_VALUE_LENGTH) {
                if (nameLength > MAX_NAME_LENGTH) {
                    throw new IOException(""Unable to write manifest line ""
                            + name + "": "" + value);
                }
                writer.print(name + "": "" + EOL);
                line = "" "" + value;
            } else {
                line = name + "": "" + value;
            }
            while (line.getBytes(JAR_ENCODING).length > MAX_SECTION_LENGTH) {
                
                int breakIndex = MAX_SECTION_LENGTH;
                if (breakIndex >= line.length()) {
                    breakIndex = line.length() - 1;
                }
                String section = line.substring(0, breakIndex);
                while (section.getBytes(JAR_ENCODING).length > MAX_SECTION_LENGTH
                     && breakIndex > 0) {
                    breakIndex--;
                    section = line.substring(0, breakIndex);
                }
                if (breakIndex == 0) {
                    throw new IOException(""Unable to write manifest line ""
                        + name + "": "" + value);
                }
                writer.print(section + EOL);
                line = "" "" + line.substring(breakIndex);
            }
            writer.print(line + EOL);
        }
    }

    
    public static class Section {
        
        private Vector warnings = new Vector();

        
        private String name = null;

        
        private Hashtable attributes = new Hashtable();

        
        private Vector attributeIndex = new Vector();

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }

        
        public String read(BufferedReader reader)
             throws ManifestException, IOException {
            Attribute attribute = null;
            while (true) {
                String line = reader.readLine();
                if (line == null || line.length() == 0) {
                    return null;
                }
                if (line.charAt(0) == ' ') {
                    
                    if (attribute == null) {
                        if (name != null) {
                            
                            
                            
                            name += line.substring(1);
                        } else {
                            throw new ManifestException(""Can't start an ""
                                + ""attribute with a continuation line "" + line);
                        }
                    } else {
                        attribute.addContinuation(line);
                    }
                } else {
                    attribute = new Attribute(line);
                    String nameReadAhead = addAttributeAndCheck(attribute);
                    
                    attribute = getAttribute(attribute.getKey());
                    if (nameReadAhead != null) {
                        return nameReadAhead;
                    }
                }
            }
        }

        
        public void merge(Section section) throws ManifestException {
            if (name == null && section.getName() != null
                || name != null
                && !(name.equalsIgnoreCase(section.getName()))) {
                throw new ManifestException(""Unable to merge sections ""
                    + ""with different names"");
            }

            Enumeration e = section.getAttributeKeys();
            Attribute classpathAttribute = null;
            while (e.hasMoreElements()) {
                String attributeName = (String) e.nextElement();
                Attribute attribute = section.getAttribute(attributeName);
                if (attributeName.equalsIgnoreCase(ATTRIBUTE_CLASSPATH)) {
                    if (classpathAttribute == null) {
                        classpathAttribute = new Attribute();
                        classpathAttribute.setName(ATTRIBUTE_CLASSPATH);
                    }
                    Enumeration cpe = attribute.getValues();
                    while (cpe.hasMoreElements()) {
                        String value = (String) cpe.nextElement();
                        classpathAttribute.addValue(value);
                    }
                } else {
                    
                    storeAttribute(attribute);
                }
            }

            if (classpathAttribute != null) {
                
                storeAttribute(classpathAttribute);
            }

            
            Enumeration warnEnum = section.warnings.elements();
            while (warnEnum.hasMoreElements()) {
                warnings.addElement(warnEnum.nextElement());
            }
        }

        
        public void write(PrintWriter writer) throws IOException {
            if (name != null) {
                Attribute nameAttr = new Attribute(ATTRIBUTE_NAME, name);
                nameAttr.write(writer);
            }
            Enumeration e = getAttributeKeys();
            while (e.hasMoreElements()) {
                String key = (String) e.nextElement();
                Attribute attribute = getAttribute(key);
                attribute.write(writer);
            }
            writer.print(EOL);
        }

        
        public Attribute getAttribute(String attributeName) {
            return (Attribute) attributes.get(attributeName.toLowerCase());
        }

        
        public Enumeration getAttributeKeys() {
            return attributeIndex.elements();
        }

        
        public String getAttributeValue(String attributeName) {
            Attribute attribute = getAttribute(attributeName.toLowerCase());
            if (attribute == null) {
                return null;
            }
            return attribute.getValue();
        }

        
        public void removeAttribute(String attributeName) {
            String key = attributeName.toLowerCase();
            attributes.remove(key);
            attributeIndex.removeElement(key);
        }

        
        public void addConfiguredAttribute(Attribute attribute)
             throws ManifestException {
            String check = addAttributeAndCheck(attribute);
            if (check != null) {
                throw new BuildException(""Specify the section name using ""
                    + ""the \""name\"" attribute of the <section> element rather ""
                    + ""than using a \""Name\"" manifest attribute"");
            }
        }

        
        public String addAttributeAndCheck(Attribute attribute)
             throws ManifestException {
            if (attribute.getName() == null || attribute.getValue() == null) {
                throw new BuildException(""Attributes must have name and value"");
            }
            if (attribute.getKey().equalsIgnoreCase(ATTRIBUTE_NAME)) {
                warnings.addElement(""\"""" + ATTRIBUTE_NAME + ""\"" attributes ""
                    + ""should not occur in the main section and must be the ""
                    + ""first element in all other sections: \""""
                    + attribute.getName() + "": "" + attribute.getValue() + ""\"""");
                return attribute.getValue();
            }

            if (attribute.getKey().startsWith(ATTRIBUTE_FROM.toLowerCase())) {
                warnings.addElement(ERROR_FROM_FORBIDDEN
                    + attribute.getName() + "": "" + attribute.getValue() + ""\"""");
            } else {
                
                String attributeKey = attribute.getKey();
                if (attributeKey.equalsIgnoreCase(ATTRIBUTE_CLASSPATH)) {
                    Attribute classpathAttribute =
                        (Attribute) attributes.get(attributeKey);

                    if (classpathAttribute == null) {
                        storeAttribute(attribute);
                    } else {
                        warnings.addElement(""Multiple Class-Path attributes ""
                            + ""are supported but violate the Jar ""
                            + ""specification and may not be correctly ""
                            + ""processed in all environments"");
                        Enumeration e = attribute.getValues();
                        while (e.hasMoreElements()) {
                            String value = (String) e.nextElement();
                            classpathAttribute.addValue(value);
                        }
                    }
                } else if (attributes.containsKey(attributeKey)) {
                    throw new ManifestException(""The attribute \""""
                        + attribute.getName() + ""\"" may not occur more ""
                        + ""than once in the same section"");
                } else {
                    storeAttribute(attribute);
                }
            }
            return null;
        }

        
        public Object clone() {
            Section cloned = new Section();
            cloned.setName(name);
            Enumeration e = getAttributeKeys();
            while (e.hasMoreElements()) {
                String key = (String) e.nextElement();
                Attribute attribute = getAttribute(key);
                cloned.storeAttribute(new Attribute(attribute.getName(),
                                                    attribute.getValue()));
            }
            return cloned;
        }

        
        private void storeAttribute(Attribute attribute) {
            if (attribute == null) {
                return;
            }
            String attributeKey = attribute.getKey();
            attributes.put(attributeKey, attribute);
            if (!attributeIndex.contains(attributeKey)) {
                attributeIndex.addElement(attributeKey);
            }
        }

        
        public Enumeration getWarnings() {
            return warnings.elements();
        }

        
        public int hashCode() {
            return attributes.hashCode();
        }

        
        public boolean equals(Object rhs) {
            if (rhs == null || rhs.getClass() != getClass()) {
                return false;
            }

            if (rhs == this) {
                return true;
            }

            Section rhsSection = (Section) rhs;

            return attributes.equals(rhsSection.attributes);
        }
    }


    
    private String manifestVersion = DEFAULT_MANIFEST_VERSION;

    
    private Section mainSection = new Section();

    
    private Hashtable sections = new Hashtable();

    
    private Vector sectionIndex = new Vector();

    
    public static Manifest getDefaultManifest() throws BuildException {
        InputStream in = null;
        InputStreamReader insr = null;
        try {
            String defManifest = ""/org/apache/tools/ant/defaultManifest.mf"";
            in = Manifest.class.getResourceAsStream(defManifest);
            if (in == null) {
                throw new BuildException(""Could not find default manifest: ""
                    + defManifest);
            }
            try {
                insr = new InputStreamReader(in, ""UTF-8"");
                Manifest defaultManifest = new Manifest(insr);
                Attribute createdBy = new Attribute(""Created-By"",
                    System.getProperty(""java.vm.version"") + "" (""
                    + System.getProperty(""java.vm.vendor"") + "")"");
                defaultManifest.getMainSection().storeAttribute(createdBy);
                return defaultManifest;
            } catch (UnsupportedEncodingException e) {
                insr = new InputStreamReader(in);
                return new Manifest(insr);
            }
        } catch (ManifestException e) {
            throw new BuildException(""Default manifest is invalid !!"", e);
        } catch (IOException e) {
            throw new BuildException(""Unable to read default manifest"", e);
        } finally {
            FileUtils.close(insr);
            FileUtils.close(in);
        }
    }

    
    public Manifest() {
        manifestVersion = null;
    }

    
    public Manifest(Reader r) throws ManifestException, IOException {
        BufferedReader reader = new BufferedReader(r);
        
        String nextSectionName = mainSection.read(reader);
        String readManifestVersion
            = mainSection.getAttributeValue(ATTRIBUTE_MANIFEST_VERSION);
        if (readManifestVersion != null) {
            manifestVersion = readManifestVersion;
            mainSection.removeAttribute(ATTRIBUTE_MANIFEST_VERSION);
        }

        String line = null;
        while ((line = reader.readLine()) != null) {
            if (line.length() == 0) {
                continue;
            }

            Section section = new Section();
            if (nextSectionName == null) {
                Attribute sectionName = new Attribute(line);
                if (!sectionName.getName().equalsIgnoreCase(ATTRIBUTE_NAME)) {
                    throw new ManifestException(""Manifest sections should ""
                        + ""start with a \"""" + ATTRIBUTE_NAME
                        + ""\"" attribute and not \""""
                        + sectionName.getName() + ""\"""");
                }
                nextSectionName = sectionName.getValue();
            } else {
                
                
                
                Attribute firstAttribute = new Attribute(line);
                section.addAttributeAndCheck(firstAttribute);
            }

            section.setName(nextSectionName);
            nextSectionName = section.read(reader);
            addConfiguredSection(section);
        }
    }

    
    public void addConfiguredSection(Section section)
         throws ManifestException {
        String sectionName = section.getName();
        if (sectionName == null) {
            throw new BuildException(""Sections must have a name"");
        }
        sections.put(sectionName, section);
        if (!sectionIndex.contains(sectionName)) {
            sectionIndex.addElement(sectionName);
        }
    }

    
    public void addConfiguredAttribute(Attribute attribute)
         throws ManifestException {
        if (attribute.getKey() == null || attribute.getValue() == null) {
            throw new BuildException(""Attributes must have name and value"");
        }
        if (attribute.getKey().equalsIgnoreCase(ATTRIBUTE_MANIFEST_VERSION)) {
            manifestVersion = attribute.getValue();
        } else {
            mainSection.addConfiguredAttribute(attribute);
        }
    }

    
    public void merge(Manifest other) throws ManifestException {
        merge(other, false);
    }

    
    public void merge(Manifest other, boolean overwriteMain)
         throws ManifestException {
        if (other != null) {
             if (overwriteMain) {
                 mainSection = (Section) other.mainSection.clone();
             } else {
                 mainSection.merge(other.mainSection);
             }

             if (other.manifestVersion != null) {
                 manifestVersion = other.manifestVersion;
             }

             Enumeration e = other.getSectionNames();
             while (e.hasMoreElements()) {
                 String sectionName = (String) e.nextElement();
                 Section ourSection = (Section) sections.get(sectionName);
                 Section otherSection
                    = (Section) other.sections.get(sectionName);
                 if (ourSection == null) {
                     if (otherSection != null) {
                         addConfiguredSection((Section) otherSection.clone());
                     }
                 } else {
                     ourSection.merge(otherSection);
                 }
             }
         }
    }

    
    public void write(PrintWriter writer) throws IOException {
        writer.print(ATTRIBUTE_MANIFEST_VERSION + "": "" + manifestVersion + EOL);
        String signatureVersion
            = mainSection.getAttributeValue(ATTRIBUTE_SIGNATURE_VERSION);
        if (signatureVersion != null) {
            writer.print(ATTRIBUTE_SIGNATURE_VERSION + "": ""
                + signatureVersion + EOL);
            mainSection.removeAttribute(ATTRIBUTE_SIGNATURE_VERSION);
        }
        mainSection.write(writer);

        
        if (signatureVersion != null) {
            try {
                Attribute svAttr = new Attribute(ATTRIBUTE_SIGNATURE_VERSION,
                    signatureVersion);
                mainSection.addConfiguredAttribute(svAttr);
            } catch (ManifestException e) {
                
            }
        }

        Enumeration e = sectionIndex.elements();
        while (e.hasMoreElements()) {
            String sectionName = (String) e.nextElement();
            Section section = getSection(sectionName);
            section.write(writer);
        }
    }

    
    public String toString() {
        StringWriter sw = new StringWriter();
        try {
            write(new PrintWriter(sw));
        } catch (IOException e) {
            return null;
        }
        return sw.toString();
    }

    
    public Enumeration getWarnings() {
        Vector warnings = new Vector();

        Enumeration warnEnum = mainSection.getWarnings();
        while (warnEnum.hasMoreElements()) {
            warnings.addElement(warnEnum.nextElement());
        }

        
        Enumeration e = sections.elements();
        while (e.hasMoreElements()) {
            Section section = (Section) e.nextElement();
            Enumeration e2 = section.getWarnings();
            while (e2.hasMoreElements()) {
                warnings.addElement(e2.nextElement());
            }
        }

        return warnings.elements();
    }

    
    public int hashCode() {
        int hashCode = 0;

        if (manifestVersion != null) {
            hashCode += manifestVersion.hashCode();
        }
        hashCode += mainSection.hashCode();
        hashCode += sections.hashCode();

        return hashCode;
    }

    
    public boolean equals(Object rhs) {
        if (rhs == null || rhs.getClass() != getClass()) {
            return false;
        }

        if (rhs == this) {
            return true;
        }

        Manifest rhsManifest = (Manifest) rhs;
        if (manifestVersion == null) {
            if (rhsManifest.manifestVersion != null) {
                return false;
            }
        } else if (!manifestVersion.equals(rhsManifest.manifestVersion)) {
            return false;
        }

        if (!mainSection.equals(rhsManifest.mainSection)) {
            return false;
        }

        return sections.equals(rhsManifest.sections);
    }

    
    public String getManifestVersion() {
        return manifestVersion;
    }

    
    public Section getMainSection() {
        return mainSection;
    }

    
    public Section getSection(String name) {
        return (Section) sections.get(name);
    }

    
    public Enumeration getSectionNames() {
        return sectionIndex.elements();
    }
}
"
org.apache.tools.ant.types.resources.selectors.Exists,2,1,0,6,4,1,4,2,2,2.0,8,0.0,0,0.0,0.75,0,0,3.0,1,0.5,0,"
package org.apache.tools.ant.types.resources.selectors;

import org.apache.tools.ant.types.Resource;


public class Exists implements ResourceSelector {

    
    public boolean isSelected(Resource r) {
        return r.isExists();
    }

}
"
org.apache.tools.ant.taskdefs.optional.ejb.EjbJar,28,4,0,20,78,142,1,20,26,0.785185185,503,1.0,1,0.742857143,0.183035714,2,2,16.78571429,3,1.1429,0,"

package org.apache.tools.ant.taskdefs.optional.ejb;


import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.xml.sax.SAXException;


public class EjbJar extends MatchingTask {

    
    public static class DTDLocation
        extends org.apache.tools.ant.types.DTDLocation {
    }

    
    static class Config {
        
        
        public File srcDir;

        
        public File descriptorDir;

        
        public String baseNameTerminator = ""-"";

        
        public String baseJarName;

        
        public boolean flatDestDir = false;

        
        public Path classpath;

        
        public List supportFileSets = new ArrayList();

        
        public ArrayList dtdLocations = new ArrayList();

        
        public NamingScheme namingScheme;

        
        public File manifest;

        
        public String analyzer;
        
    }

    
    public static class NamingScheme extends EnumeratedAttribute {
        
        public static final String EJB_NAME = ""ejb-name"";

        
        public static final String DIRECTORY = ""directory"";

        
        public static final String DESCRIPTOR = ""descriptor"";

        
        public static final String BASEJARNAME = ""basejarname"";

        
        public String[] getValues() {
            return new String[] {EJB_NAME, DIRECTORY, DESCRIPTOR, BASEJARNAME};
        }
    }

    
    public static class CMPVersion extends EnumeratedAttribute {
        
        public static final String CMP1_0 = ""1.0"";
        
        public static final String CMP2_0 = ""2.0"";
        
        public String[] getValues() {
            return new String[]{
                CMP1_0,
                CMP2_0,
            };
        }
    }
    
    private Config config = new Config();


    
    private File destDir;

    
    private String genericJarSuffix = ""-generic.jar"";

    
    private String cmpVersion = CMPVersion.CMP1_0;

    
    private ArrayList deploymentTools = new ArrayList();

    
    protected void addDeploymentTool(EJBDeploymentTool deploymentTool) {
        deploymentTool.setTask(this);
        deploymentTools.add(deploymentTool);
    }

    
    public WeblogicDeploymentTool createWeblogic() {
        WeblogicDeploymentTool tool = new WeblogicDeploymentTool();
        addDeploymentTool(tool);
        return tool;
    }

    
    public WebsphereDeploymentTool createWebsphere() {
        WebsphereDeploymentTool tool = new WebsphereDeploymentTool();
        addDeploymentTool(tool);
        return tool;
    }

    
    public BorlandDeploymentTool createBorland() {
        log(""Borland deployment tools"",  Project.MSG_VERBOSE);

        BorlandDeploymentTool tool = new BorlandDeploymentTool();
        tool.setTask(this);
        deploymentTools.add(tool);
        return tool;
    }

    
    public IPlanetDeploymentTool createIplanet() {
        log(""iPlanet Application Server deployment tools"", Project.MSG_VERBOSE);

        IPlanetDeploymentTool tool = new IPlanetDeploymentTool();
        addDeploymentTool(tool);
        return tool;
    }

    
    public JbossDeploymentTool createJboss() {
        JbossDeploymentTool tool = new JbossDeploymentTool();
        addDeploymentTool(tool);
        return tool;
    }

    
    public JonasDeploymentTool createJonas() {
        log(""JOnAS deployment tools"",  Project.MSG_VERBOSE);

        JonasDeploymentTool tool = new JonasDeploymentTool();
        addDeploymentTool(tool);
        return tool;
    }

    
    public WeblogicTOPLinkDeploymentTool createWeblogictoplink() {
        log(""The <weblogictoplink> element is no longer required. Please use ""
            + ""the <weblogic> element and set newCMP=\""true\"""",
            Project.MSG_INFO);
        WeblogicTOPLinkDeploymentTool tool
            = new WeblogicTOPLinkDeploymentTool();
        addDeploymentTool(tool);
        return tool;
    }

    
    public Path createClasspath() {
        if (config.classpath == null) {
            config.classpath = new Path(getProject());
        }
        return config.classpath.createPath();
    }

    
    public DTDLocation createDTD() {
        DTDLocation dtdLocation = new DTDLocation();
        config.dtdLocations.add(dtdLocation);

        return dtdLocation;
    }

    
    public FileSet createSupport() {
        FileSet supportFileSet = new FileSet();
        config.supportFileSets.add(supportFileSet);
        return supportFileSet;
    }


    
     public void setManifest(File manifest) {
         config.manifest = manifest;
     }

    
    public void setSrcdir(File inDir) {
        config.srcDir = inDir;
    }

    
    public void setDescriptordir(File inDir) {
        config.descriptorDir = inDir;
    }

    
    public void setDependency(String analyzer) {
        config.analyzer = analyzer;
    }

    
    public void setBasejarname(String inValue) {
        config.baseJarName = inValue;
        if (config.namingScheme == null) {
            config.namingScheme = new NamingScheme();
            config.namingScheme.setValue(NamingScheme.BASEJARNAME);
        } else if (!config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)) {
            throw new BuildException(""The basejarname attribute is not ""
                + ""compatible with the ""
                + config.namingScheme.getValue() + "" naming scheme"");
        }
    }

    
    public void setNaming(NamingScheme namingScheme) {
        config.namingScheme = namingScheme;
        if (!config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)
            && config.baseJarName != null) {
            throw new BuildException(""The basejarname attribute is not ""
                + ""compatible with the ""
                + config.namingScheme.getValue() + "" naming scheme"");
        }
    }

    
    public File getDestdir() {
        return this.destDir;
    }

    
    public void setDestdir(File inDir) {
        this.destDir = inDir;
    }

    
    public String getCmpversion() {
        return this.cmpVersion;
    }

    
    public void setCmpversion(CMPVersion version) {
        this.cmpVersion = version.getValue();
    }

    
    public void setClasspath(Path classpath) {
        config.classpath = classpath;
    }

    
    public void setFlatdestdir(boolean inValue) {
        config.flatDestDir = inValue;
    }

    
    public void setGenericjarsuffix(String inString) {
        this.genericJarSuffix = inString;
    }

    
    public void setBasenameterminator(String inValue) {
        config.baseNameTerminator = inValue;
    }

    
    private void validateConfig() throws BuildException {
        if (config.srcDir == null) {
            throw new BuildException(""The srcDir attribute must be specified"");
        }

        if (config.descriptorDir == null) {
            config.descriptorDir = config.srcDir;
        }

        if (config.namingScheme == null) {
            config.namingScheme = new NamingScheme();
            config.namingScheme.setValue(NamingScheme.DESCRIPTOR);
        } else if (config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)
                    && config.baseJarName == null) {
            throw new BuildException(""The basejarname attribute must ""
                + ""be specified with the basejarname naming scheme"");
        }
    }

    
    public void execute() throws BuildException {
        validateConfig();

        if (deploymentTools.size() == 0) {
            GenericDeploymentTool genericTool = new GenericDeploymentTool();
            genericTool.setTask(this);
            genericTool.setDestdir(destDir);
            genericTool.setGenericJarSuffix(genericJarSuffix);
            deploymentTools.add(genericTool);
        }

        for (Iterator i = deploymentTools.iterator(); i.hasNext();) {
            EJBDeploymentTool tool = (EJBDeploymentTool) i.next();
            tool.configure(config);
            tool.validateConfigured();
        }

        try {
            
            SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
            saxParserFactory.setValidating(true);
            SAXParser saxParser = saxParserFactory.newSAXParser();


            DirectoryScanner ds = getDirectoryScanner(config.descriptorDir);
            ds.scan();
            String[] files = ds.getIncludedFiles();

            log(files.length + "" deployment descriptors located."",
                Project.MSG_VERBOSE);

            
            
            for (int index = 0; index < files.length; ++index) {
                
                for (Iterator i = deploymentTools.iterator(); i.hasNext();) {
                    EJBDeploymentTool tool = (EJBDeploymentTool) i.next();
                    tool.processDescriptor(files[index], saxParser);
                }
            }
        } catch (SAXException se) {
            String msg = ""SAXException while creating parser.""
                + ""  Details: ""
                + se.getMessage();
            throw new BuildException(msg, se);
        } catch (ParserConfigurationException pce) {
            String msg = ""ParserConfigurationException while creating parser. ""
                       + ""Details: "" + pce.getMessage();
            throw new BuildException(msg, pce);
        }
    } 

}







"
org.apache.tools.ant.taskdefs.optional.jdepend.JDependTask,31,3,0,19,107,391,0,19,28,0.922807018,977,0.894736842,5,0.560606061,0.15,3,3,29.90322581,3,1.129,0,"

package org.apache.tools.ant.taskdefs.optional.jdepend;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Vector;
import java.util.Enumeration;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteWatchdog;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.LoaderUtils;


public class JDependTask extends Task {
    

    
    private Path sourcesPath; 
    private Path classesPath; 

    
    private File outputFile;
    private File dir;
    private Path compileClasspath;
    private boolean haltonerror = false;
    private boolean fork = false;
    private Long timeout = null;

    private String jvm = null;
    private String format = ""text"";
    private PatternSet defaultPatterns = new PatternSet();

    private static Constructor packageFilterC;
    private static Method setFilter;

    private boolean includeRuntime = false;
    private Path runtimeClasses = null;

    static {
        try {
            Class packageFilter =
                Class.forName(""jdepend.framework.PackageFilter"");
            packageFilterC =
                packageFilter.getConstructor(new Class[] {java.util.Collection.class});
            setFilter =
                jdepend.textui.JDepend.class.getDeclaredMethod(""setFilter"",
                                                               new Class[] {packageFilter});
        } catch (Throwable t) {
            if (setFilter == null) {
                packageFilterC = null;
            }
        }
    }

    
    public void setIncluderuntime(boolean b) {
        includeRuntime = b;
    }

    
    public void setTimeout(Long value) {
        timeout = value;
    }

    
    public Long getTimeout() {
        return timeout;
    }

    
    public void setOutputFile(File outputFile) {
        this.outputFile = outputFile;
    }

    
    public File getOutputFile() {
        return outputFile;
    }

    
    public void setHaltonerror(boolean haltonerror) {
        this.haltonerror = haltonerror;
    }

    
    public boolean getHaltonerror() {
        return haltonerror;
    }

    
    public void setFork(boolean value) {
        fork = value;
    }

    
    public boolean getFork() {
        return fork;
    }

    
    public void setJvm(String value) {
        jvm = value;

    }

    
    public Path createSourcespath() {
        if (sourcesPath == null) {
            sourcesPath = new Path(getProject());
        }
        return sourcesPath.createPath();
    }

    
    public Path getSourcespath() {
        return sourcesPath;
    }

    
    public Path createClassespath() {
        if (classesPath == null) {
            classesPath = new Path(getProject());
        }
        return classesPath.createPath();
    }

    
    public Path getClassespath() {
        return classesPath;
    }

    
    public void setDir(File dir) {
        this.dir = dir;
    }

    
    public File getDir() {
        return dir;
    }

    
    public void setClasspath(Path classpath) {
        if (compileClasspath == null) {
            compileClasspath = classpath;
        } else {
            compileClasspath.append(classpath);
        }
    }

    
    public Path getClasspath() {
        return compileClasspath;
    }

    
    public Path createClasspath() {
        if (compileClasspath == null) {
            compileClasspath = new Path(getProject());
        }
        return compileClasspath.createPath();
    }

    
    public Commandline.Argument createJvmarg(CommandlineJava commandline) {
        return commandline.createVmArgument();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public PatternSet.NameEntry createExclude() {
        return defaultPatterns.createExclude();
    }

    
    public PatternSet getExcludes() {
        return defaultPatterns;
    }

    
    public void setFormat(FormatAttribute ea) {
        format = ea.getValue();
    }

    
    public static class FormatAttribute extends EnumeratedAttribute {
        private String [] formats = new String[]{""xml"", ""text""};

        
        public String[] getValues() {
            return formats;
        }
    }

    
    private static final int SUCCESS = 0;
    
    private static final int ERRORS = 1;

    
    private void addClasspathEntry(String resource) {
        
        if (resource.startsWith(""/"")) {
            resource = resource.substring(1);
        } else {
            resource = ""org/apache/tools/ant/taskdefs/optional/jdepend/""
                + resource;
        }

        File f = LoaderUtils.getResourceSource(getClass().getClassLoader(),
                                               resource);
        if (f != null) {
            log(""Found "" + f.getAbsolutePath(), Project.MSG_DEBUG);
            runtimeClasses.createPath().setLocation(f);
        } else {
            log(""Couldn\'t find "" + resource, Project.MSG_DEBUG);
        }
    }

    
    public void execute() throws BuildException {

        CommandlineJava commandline = new CommandlineJava();

        if (""text"".equals(format)) {
            commandline.setClassname(""jdepend.textui.JDepend"");
        } else
            if (""xml"".equals(format)) {
                commandline.setClassname(""jdepend.xmlui.JDepend"");
            }

        if (jvm != null) {
            commandline.setVm(jvm);
        }
        if (getSourcespath() == null && getClassespath() == null) {
            throw new BuildException(""Missing classespath required argument"");
        } else if (getClassespath() == null) {
            String msg =
                ""sourcespath is deprecated in JDepend >= 2.5 ""
                + ""- please convert to classespath"";
            log(msg);
        }

        
        int exitValue = JDependTask.ERRORS;
        boolean wasKilled = false;
        if (!getFork()) {
            exitValue = executeInVM(commandline);
        } else {
            ExecuteWatchdog watchdog = createWatchdog();
            exitValue = executeAsForked(commandline, watchdog);
            
            if (watchdog != null) {
                wasKilled = watchdog.killedProcess();
            }
        }

        
        
        boolean errorOccurred = exitValue == JDependTask.ERRORS || wasKilled;

        if (errorOccurred) {
            String errorMessage = ""JDepend FAILED""
                + (wasKilled ? "" - Timed out"" : """");

            if  (getHaltonerror()) {
                throw new BuildException(errorMessage, getLocation());
            } else {
                log(errorMessage, Project.MSG_ERR);
            }
        }
    }

    
    
    
    

    
    public int executeInVM(CommandlineJava commandline) throws BuildException {
        jdepend.textui.JDepend jdepend;

        if (""xml"".equals(format)) {
            jdepend = new jdepend.xmlui.JDepend();
        } else {
            jdepend = new jdepend.textui.JDepend();
        }

        FileWriter fw = null;
        if (getOutputFile() != null) {
            try {
                fw = new FileWriter(getOutputFile().getPath());
            } catch (IOException e) {
                String msg = ""JDepend Failed when creating the output file: ""
                    + e.getMessage();
                log(msg);
                throw new BuildException(msg);
            }
            jdepend.setWriter(new PrintWriter(fw));
            log(""Output to be stored in "" + getOutputFile().getPath());
        }


        try {
            if (getClassespath() != null) {
                
                
                
                String[] cP = getClassespath().list();
                for (int i = 0; i < cP.length; i++) {
                    File f = new File(cP[i]);
                    
                    
                    if (!f.exists()) {
                        String msg = ""\""""
                            + f.getPath()
                            + ""\"" does not represent a valid""
                            + "" file or directory. JDepend would fail."";
                        log(msg);
                        throw new BuildException(msg);
                    }
                    try {
                        jdepend.addDirectory(f.getPath());
                    } catch (IOException e) {
                        String msg =
                            ""JDepend Failed when adding a class directory: ""
                            + e.getMessage();
                        log(msg);
                        throw new BuildException(msg);
                    }
                }

            } else if (getSourcespath() != null) {

                
                
                String[] sP = getSourcespath().list();
                for (int i = 0; i < sP.length; i++) {
                    File f = new File(sP[i]);

                    
                    
                    if (!f.exists() || !f.isDirectory()) {
                        String msg = ""\""""
                            + f.getPath()
                            + ""\"" does not represent a valid""
                            + "" directory. JDepend would fail."";
                        log(msg);
                        throw new BuildException(msg);
                    }
                    try {
                        jdepend.addDirectory(f.getPath());
                    } catch (IOException e) {
                        String msg =
                            ""JDepend Failed when adding a source directory: ""
                            + e.getMessage();
                        log(msg);
                        throw new BuildException(msg);
                    }
                }
            }

            
            String[] patterns = defaultPatterns.getExcludePatterns(getProject());
            if (patterns != null && patterns.length > 0) {
                if (setFilter != null) {
                    Vector v = new Vector();
                    for (int i = 0; i < patterns.length; i++) {
                        v.addElement(patterns[i]);
                    }
                    try {
                        Object o = packageFilterC.newInstance(new Object[] {v});
                        setFilter.invoke(jdepend, new Object[] {o});
                    } catch (Throwable e) {
                        log(""excludes will be ignored as JDepend doesn't like me: ""
                            + e.getMessage(), Project.MSG_WARN);
                    }
                } else {
                    log(""Sorry, your version of JDepend doesn't support excludes"",
                        Project.MSG_WARN);
                }
            }

            jdepend.analyze();
        } finally {
            FileUtils.close(fw);
        }
        return SUCCESS;
    }


    
    
    public int executeAsForked(CommandlineJava commandline,
                               ExecuteWatchdog watchdog) throws BuildException {
        runtimeClasses = new Path(getProject());
        addClasspathEntry(""/jdepend/textui/JDepend.class"");

        
        createClasspath();

        
        
        if (getClasspath().toString().length() > 0) {
            createJvmarg(commandline).setValue(""-classpath"");
            createJvmarg(commandline).setValue(getClasspath().toString());
        }

        if (includeRuntime) {
            Vector v = Execute.getProcEnvironment();
            Enumeration e = v.elements();
            while (e.hasMoreElements()) {
                String s = (String) e.nextElement();
                if (s.startsWith(""CLASSPATH="")) {
                    commandline.createClasspath(getProject()).createPath()
                        .append(new Path(getProject(),
                                         s.substring(""CLASSPATH="".length()
                                                     )));
                }
            }
            log(""Implicitly adding "" + runtimeClasses + "" to CLASSPATH"",
                Project.MSG_VERBOSE);
            commandline.createClasspath(getProject()).createPath()
                .append(runtimeClasses);
        }

        if (getOutputFile() != null) {
            
            
            
            commandline.createArgument().setValue(""-file"");
            commandline.createArgument().setValue(outputFile.getPath());
            
        }

        if (getSourcespath() != null) {
            
            String[] sP = getSourcespath().list();
            for (int i = 0; i < sP.length; i++) {
                File f = new File(sP[i]);

                
                
                if (!f.exists() || !f.isDirectory()) {
                    throw new BuildException(""\"""" + f.getPath()
                                             + ""\"" does not represent a valid""
                                             + "" directory. JDepend would""
                                             + "" fail."");
                }
                commandline.createArgument().setValue(f.getPath());
            }
        }

        if (getClassespath() != null) {
            
            
            String[] cP = getClassespath().list();
            for (int i = 0; i < cP.length; i++) {
                File f = new File(cP[i]);
                
                
                if (!f.exists()) {
                    throw new BuildException(""\"""" + f.getPath()
                                             + ""\"" does not represent a valid""
                                             + "" file or directory. JDepend would""
                                             + "" fail."");
                }
                commandline.createArgument().setValue(f.getPath());
            }
        }

        Execute execute = new Execute(new LogStreamHandler(this,
            Project.MSG_INFO, Project.MSG_WARN), watchdog);
        execute.setCommandline(commandline.getCommandline());
        if (getDir() != null) {
            execute.setWorkingDirectory(getDir());
            execute.setAntRun(getProject());
        }

        if (getOutputFile() != null) {
            log(""Output to be stored in "" + getOutputFile().getPath());
        }
        log(commandline.describeCommand(), Project.MSG_VERBOSE);
        try {
            return execute.execute();
        } catch (IOException e) {
            throw new BuildException(""Process fork failed."", e, getLocation());
        }
    }

    
    protected ExecuteWatchdog createWatchdog() throws BuildException {
        if (getTimeout() == null) {
            return null;
        }
        return new ExecuteWatchdog(getTimeout().longValue());
    }
}
"
org.apache.tools.bzip2.CBZip2InputStream,27,2,0,6,46,53,3,3,4,0.74009324,2106,1.0,2,0.257142857,0.209876543,1,2,75.77777778,9,1.4815,1,"


package org.apache.tools.bzip2;

import java.io.InputStream;
import java.io.IOException;


public class CBZip2InputStream extends InputStream implements BZip2Constants {

    private static void reportCRCError() throws IOException {
        
        

        
        System.err.println(""BZip2 CRC error"");
    }

    private void makeMaps() {
        final boolean[] inUse   = this.data.inUse;
        final byte[] seqToUnseq = this.data.seqToUnseq;

        int nInUseShadow = 0;

        for (int i = 0; i < 256; i++) {
            if (inUse[i])
                seqToUnseq[nInUseShadow++] = (byte) i;
        }

        this.nInUse = nInUseShadow;
    }

    
    private int  last;

    
    private int  origPtr;

    
    private int blockSize100k;

    private boolean blockRandomised;

    private int bsBuff;
    private int bsLive;
    private final CRC crc = new CRC();

    private int nInUse;

    private InputStream in;

    private int currentChar = -1;

    private static final int EOF                  = 0;
    private static final int START_BLOCK_STATE = 1;
    private static final int RAND_PART_A_STATE = 2;
    private static final int RAND_PART_B_STATE = 3;
    private static final int RAND_PART_C_STATE = 4;
    private static final int NO_RAND_PART_A_STATE = 5;
    private static final int NO_RAND_PART_B_STATE = 6;
    private static final int NO_RAND_PART_C_STATE = 7;

    private int currentState = START_BLOCK_STATE;

    private int storedBlockCRC, storedCombinedCRC;
    private int computedBlockCRC, computedCombinedCRC;

    

    private int su_count;
    private int su_ch2;
    private int su_chPrev;
    private int su_i2;
    private int su_j2;
    private int su_rNToGo;
    private int su_rTPos;
    private int su_tPos;
    private char su_z;

    
    private CBZip2InputStream.Data data;

    
    public CBZip2InputStream(final InputStream in) throws IOException {
        super();

        this.in = in;
        init();
    }

    public int read() throws IOException {
        if (this.in != null) {
            return read0();
        } else {
            throw new IOException(""stream closed"");
        }
    }

    public int read(final byte[] dest, final int offs, final int len)
        throws IOException {
        if (offs < 0) {
            throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
        }
        if (len < 0) {
            throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
        }
        if (offs + len > dest.length) {
            throw new IndexOutOfBoundsException(""offs("" + offs + "") + len(""
                                                + len + "") > dest.length(""
                                                + dest.length + "")."");
        }
        if (this.in == null) {
            throw new IOException(""stream closed"");
        }

        final int hi = offs + len;
        int destOffs = offs;
        for (int b; (destOffs < hi) && ((b = read0()) >= 0);) {
            dest[destOffs++] = (byte) b;
        }

        return (destOffs == offs) ? -1 : (destOffs - offs);
    }

    private int read0() throws IOException {
        final int retChar = this.currentChar;

        switch (this.currentState) {
        case EOF:
            return -1;

        case START_BLOCK_STATE:
            throw new IllegalStateException();

        case RAND_PART_A_STATE:
            throw new IllegalStateException();

        case RAND_PART_B_STATE:
            setupRandPartB();
            break;

        case RAND_PART_C_STATE:
            setupRandPartC();
            break;

        case NO_RAND_PART_A_STATE:
            throw new IllegalStateException();

        case NO_RAND_PART_B_STATE:
            setupNoRandPartB();
            break;

        case NO_RAND_PART_C_STATE:
            setupNoRandPartC();
            break;

        default:
            throw new IllegalStateException();
        }

        return retChar;
    }

    private void init() throws IOException {
        int magic2 = this.in.read();
        if (magic2 != 'h') {
            throw new IOException(""Stream is not BZip2 formatted: expected 'h'""
                                  + "" as first byte but got '"" + (char) magic2
                                  + ""'"");
        }

        int blockSize = this.in.read();
        if ((blockSize < '1') || (blockSize > '9')) {
            throw new IOException(""Stream is not BZip2 formatted: illegal ""
                                  + ""blocksize "" + (char) blockSize);
        }

        this.blockSize100k = blockSize - '0';

        initBlock();
        setupBlock();
    }

    private void initBlock() throws IOException {
        char magic0 = bsGetUByte();
        char magic1 = bsGetUByte();
        char magic2 = bsGetUByte();
        char magic3 = bsGetUByte();
        char magic4 = bsGetUByte();
        char magic5 = bsGetUByte();

        if (magic0 == 0x17 &&
            magic1 == 0x72 &&
            magic2 == 0x45 &&
            magic3 == 0x38 &&
            magic4 == 0x50 &&
            magic5 == 0x90) {
            complete(); 
        } else if (magic0 != 0x31 || 
                   magic1 != 0x41 || 
                   magic2 != 0x59 || 
                   magic3 != 0x26 || 
                   magic4 != 0x53 || 
                   magic5 != 0x59   
                   ) {
            this.currentState = EOF;
            throw new IOException(""bad block header"");
        } else {
            this.storedBlockCRC = bsGetInt();
            this.blockRandomised = bsR(1) == 1;

            
            if (this.data == null) {
                this.data = new Data(this.blockSize100k);
            }

            
            getAndMoveToFrontDecode();

            this.crc.initialiseCRC();
            this.currentState = START_BLOCK_STATE;
        }
    }

    private void endBlock() throws IOException {
        this.computedBlockCRC = this.crc.getFinalCRC();

        
        if (this.storedBlockCRC != this.computedBlockCRC) {
            
            
            this.computedCombinedCRC
                = (this.storedCombinedCRC << 1)
                | (this.storedCombinedCRC >>> 31);
            this.computedCombinedCRC ^= this.storedBlockCRC;

            reportCRCError();
        }

        this.computedCombinedCRC
            = (this.computedCombinedCRC << 1)
            | (this.computedCombinedCRC >>> 31);
        this.computedCombinedCRC ^= this.computedBlockCRC;
    }

    private void complete() throws IOException {
        this.storedCombinedCRC = bsGetInt();
        this.currentState = EOF;
        this.data = null;

        if (this.storedCombinedCRC != this.computedCombinedCRC) {
            reportCRCError();
        }
    }

    public void close() throws IOException {
        InputStream inShadow = this.in;
        if (inShadow != null) {
            try {
                if (inShadow != System.in) {
                    inShadow.close();
                }
            } finally {
                this.data = null;
                this.in = null;
            }
        }
    }

    private int bsR(final int n) throws IOException {
        int bsLiveShadow = this.bsLive;
        int bsBuffShadow = this.bsBuff;

        if (bsLiveShadow < n) {
            final InputStream inShadow = this.in;
            do {
                int thech = inShadow.read();

                if (thech < 0) {
                    throw new IOException(""unexpected end of stream"");
                }

                bsBuffShadow = (bsBuffShadow << 8) | thech;
                bsLiveShadow += 8;
            } while (bsLiveShadow < n);

            this.bsBuff = bsBuffShadow;
        }

        this.bsLive = bsLiveShadow - n;
        return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);
    }

    private boolean bsGetBit() throws IOException {
        int bsLiveShadow = this.bsLive;
        int bsBuffShadow = this.bsBuff;

        if (bsLiveShadow < 1) {
            int thech = this.in.read();

            if (thech < 0) {
                throw new IOException(""unexpected end of stream"");
            }

            bsBuffShadow = (bsBuffShadow << 8) | thech;
            bsLiveShadow += 8;
            this.bsBuff = bsBuffShadow;
        }

        this.bsLive = bsLiveShadow - 1;
        return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;
    }

    private char bsGetUByte() throws IOException {
        return (char) bsR(8);
    }

    private int bsGetInt() throws IOException {
        return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);
    }

    
    private static void hbCreateDecodeTables(final int[] limit,
                                             final int[] base,
                                             final int[] perm,
                                             final char[] length,
                                             final int minLen,
                                             final int maxLen,
                                             final int alphaSize) {
        for (int i = minLen, pp = 0; i <= maxLen; i++) {
            for (int j = 0; j < alphaSize; j++) {
                if (length[j] == i) {
                    perm[pp++] = j;
                }
            }
        }

        for (int i = MAX_CODE_LEN; --i > 0;) {
            base[i] = 0;
            limit[i] = 0;
        }

        for (int i = 0; i < alphaSize; i++) {
            base[length[i] + 1]++;
        }

        for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {
            b += base[i];
            base[i] = b;
        }

        for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {
            final int nb = base[i + 1];
            vec += nb - b;
            b = nb;
            limit[i] = vec - 1;
            vec <<= 1;
        }

        for (int i = minLen + 1; i <= maxLen; i++) {
            base[i] = ((limit[i - 1] + 1) << 1) - base[i];
        }
    }

    private void recvDecodingTables() throws IOException {
        final Data dataShadow     = this.data;
        final boolean[] inUse     = dataShadow.inUse;
        final byte[] pos          = dataShadow.recvDecodingTables_pos;
        final byte[] selector     = dataShadow.selector;
        final byte[] selectorMtf  = dataShadow.selectorMtf;

        int inUse16 = 0;

        
        for (int i = 0; i < 16; i++) {
            if (bsGetBit()) {
                inUse16 |= 1 << i;
            }
        }

        for (int i = 256; --i >= 0;) {
            inUse[i] = false;
        }

        for (int i = 0; i < 16; i++) {
            if ((inUse16 & (1 << i)) != 0) {
                final int i16 = i << 4;
                for (int j = 0; j < 16; j++) {
                    if (bsGetBit()) {
                        inUse[i16 + j] = true;
                    }
                }
            }
        }

        makeMaps();
        final int alphaSize = this.nInUse + 2;

        
        final int nGroups = bsR(3);
        final int nSelectors = bsR(15);

        for (int i = 0; i < nSelectors; i++) {
            int j = 0;
            while (bsGetBit()) {
                j++;
            }
            selectorMtf[i] = (byte) j;
        }

        
        for (int v = nGroups; --v >= 0;) {
            pos[v] = (byte) v;
        }

        for (int i = 0; i < nSelectors; i++) {
            int v = selectorMtf[i] & 0xff;
            final byte tmp = pos[v];
            while (v > 0) {
                
                pos[v] = pos[v - 1];
                v--;
            }
            pos[0] = tmp;
            selector[i] = tmp;
        }

        final char[][] len  = dataShadow.temp_charArray2d;

        
        for (int t = 0; t < nGroups; t++) {
            int curr = bsR(5);
            final char[] len_t = len[t];
            for (int i = 0; i < alphaSize; i++) {
                while (bsGetBit()) {
                    curr += bsGetBit() ? -1 : 1;
                }
                len_t[i] = (char) curr;
            }
        }

        
        createHuffmanDecodingTables(alphaSize, nGroups);
    }

    
    private void createHuffmanDecodingTables(final int alphaSize,
                                             final int nGroups) {
        final Data dataShadow = this.data;
        final char[][] len  = dataShadow.temp_charArray2d;
        final int[] minLens = dataShadow.minLens;
        final int[][] limit = dataShadow.limit;
        final int[][] base  = dataShadow.base;
        final int[][] perm  = dataShadow.perm;

        for (int t = 0; t < nGroups; t++) {
            int minLen = 32;
            int maxLen = 0;
            final char[] len_t = len[t];
            for (int i = alphaSize; --i >= 0;) {
                final char lent = len_t[i];
                if (lent > maxLen) {
                    maxLen = lent;
                }
                if (lent < minLen) {
                    minLen = lent;
                }
            }
            hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,
                                 maxLen, alphaSize);
            minLens[t] = minLen;
        }
    }

    private void getAndMoveToFrontDecode() throws IOException {
        this.origPtr = bsR(24);
        recvDecodingTables();

        final InputStream inShadow = this.in;
        final Data dataShadow   = this.data;
        final byte[] ll8        = dataShadow.ll8;
        final int[] unzftab     = dataShadow.unzftab;
        final byte[] selector   = dataShadow.selector;
        final byte[] seqToUnseq = dataShadow.seqToUnseq;
        final char[] yy         = dataShadow.getAndMoveToFrontDecode_yy;
        final int[] minLens     = dataShadow.minLens;
        final int[][] limit     = dataShadow.limit;
        final int[][] base      = dataShadow.base;
        final int[][] perm      = dataShadow.perm;
        final int limitLast     = this.blockSize100k * 100000;

        
        for (int i = 256; --i >= 0;) {
            yy[i] = (char) i;
            unzftab[i] = 0;
        }

        int groupNo     = 0;
        int groupPos    = G_SIZE - 1;
        final int eob   = this.nInUse + 1;
        int nextSym     = getAndMoveToFrontDecode0(0);
        int bsBuffShadow      = this.bsBuff;
        int bsLiveShadow      = this.bsLive;
        int lastShadow        = -1;
        int zt          = selector[groupNo] & 0xff;
        int[] base_zt   = base[zt];
        int[] limit_zt  = limit[zt];
        int[] perm_zt   = perm[zt];
        int minLens_zt  = minLens[zt];

        while (nextSym != eob) {
            if ((nextSym == RUNA) || (nextSym == RUNB)) {
                int s = -1;

                for (int n = 1; true; n <<= 1) {
                    if (nextSym == RUNA) {
                        s += n;
                    } else if (nextSym == RUNB) {
                        s += n << 1;
                    } else {
                        break;
                    }

                    if (groupPos == 0) {
                        groupPos    = G_SIZE - 1;
                        zt          = selector[++groupNo] & 0xff;
                        base_zt     = base[zt];
                        limit_zt    = limit[zt];
                        perm_zt     = perm[zt];
                        minLens_zt  = minLens[zt];
                    } else {
                        groupPos--;
                    }

                    int zn = minLens_zt;

                    
                    
                    while (bsLiveShadow < zn) {
                        final int thech = inShadow.read();
                        if (thech >= 0) {
                            bsBuffShadow = (bsBuffShadow << 8) | thech;
                            bsLiveShadow += 8;
                            continue;
                        } else {
                            throw new IOException(""unexpected end of stream"");
                        }
                    }
                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);
                    bsLiveShadow -= zn;

                    while (zvec > limit_zt[zn]) {
                        zn++;
                        while (bsLiveShadow < 1) {
                            final int thech = inShadow.read();
                            if (thech >= 0) {
                                bsBuffShadow = (bsBuffShadow << 8) | thech;
                                bsLiveShadow += 8;
                                continue;
                            } else {
                                throw new IOException(""unexpected end of stream"");
                            }
                        }
                        bsLiveShadow--;
                        zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);
                    }
                    nextSym = perm_zt[zvec - base_zt[zn]];
                }

                final byte ch = seqToUnseq[yy[0]];
                unzftab[ch & 0xff] += s + 1;

                while (s-- >= 0) {
                    ll8[++lastShadow] = ch;
                }

                if (lastShadow >= limitLast) {
                    throw new IOException(""block overrun"");
                }
            } else {
                if (++lastShadow >= limitLast) {
                    throw new IOException(""block overrun"");
                }

                final char tmp = yy[nextSym - 1];
                unzftab[seqToUnseq[tmp] & 0xff]++;
                ll8[lastShadow] = seqToUnseq[tmp];

                
                if (nextSym <= 16) {
                    for (int j = nextSym - 1; j > 0;) {
                        yy[j] = yy[--j];
                    }
                } else {
                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);
                }

                yy[0] = tmp;

                if (groupPos == 0) {
                    groupPos    = G_SIZE - 1;
                    zt          = selector[++groupNo] & 0xff;
                    base_zt     = base[zt];
                    limit_zt    = limit[zt];
                    perm_zt     = perm[zt];
                    minLens_zt  = minLens[zt];
                } else {
                    groupPos--;
                }

                int zn = minLens_zt;

                
                
                while (bsLiveShadow < zn) {
                    final int thech = inShadow.read();
                    if (thech >= 0) {
                        bsBuffShadow = (bsBuffShadow << 8) | thech;
                        bsLiveShadow += 8;
                        continue;
                    } else {
                        throw new IOException(""unexpected end of stream"");
                    }
                }
                int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);
                bsLiveShadow -= zn;

                while (zvec > limit_zt[zn]) {
                    zn++;
                    while (bsLiveShadow < 1) {
                        final int thech = inShadow.read();
                        if (thech >= 0) {
                            bsBuffShadow = (bsBuffShadow << 8) | thech;
                            bsLiveShadow += 8;
                            continue;
                        } else {
                            throw new IOException(""unexpected end of stream"");
                        }
                    }
                    bsLiveShadow--;
                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);
                }
                nextSym = perm_zt[zvec - base_zt[zn]];
            }
        }

        this.last = lastShadow;
        this.bsLive = bsLiveShadow;
        this.bsBuff = bsBuffShadow;
    }

    private int getAndMoveToFrontDecode0(final int groupNo)
        throws IOException {
        final InputStream inShadow  = this.in;
        final Data dataShadow  = this.data;
        final int zt          = dataShadow.selector[groupNo] & 0xff;
        final int[] limit_zt  = dataShadow.limit[zt];
        int zn = dataShadow.minLens[zt];
        int zvec = bsR(zn);
        int bsLiveShadow = this.bsLive;
        int bsBuffShadow = this.bsBuff;

        while (zvec > limit_zt[zn]) {
            zn++;
            while (bsLiveShadow < 1) {
                final int thech = inShadow.read();

                if (thech >= 0) {
                    bsBuffShadow = (bsBuffShadow << 8) | thech;
                    bsLiveShadow += 8;
                    continue;
                } else {
                    throw new IOException(""unexpected end of stream"");
                }
            }
            bsLiveShadow--;
            zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);
        }

        this.bsLive = bsLiveShadow;
        this.bsBuff = bsBuffShadow;

        return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];
    }

    private void setupBlock() throws IOException {
        if (this.data == null) {
            return;
        }

        final int[] cftab = this.data.cftab;
        final int[] tt    = this.data.initTT(this.last + 1);
        final byte[] ll8  = this.data.ll8;
        cftab[0] = 0;
        System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);

        for (int i = 1, c = cftab[0]; i <= 256; i++) {
            c += cftab[i];
            cftab[i] = c;
        }

        for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {
            tt[cftab[ll8[i] & 0xff]++] = i;
        }

        if ((this.origPtr < 0) || (this.origPtr >= tt.length)) {
            throw new IOException(""stream corrupted"");
        }

        this.su_tPos = tt[this.origPtr];
        this.su_count = 0;
        this.su_i2 = 0;
        this.su_ch2 = 256;   

        if (this.blockRandomised) {
            this.su_rNToGo = 0;
            this.su_rTPos = 0;
            setupRandPartA();
        } else {
            setupNoRandPartA();
        }
    }

    private void setupRandPartA() throws IOException {
        if (this.su_i2 <= this.last) {
            this.su_chPrev = this.su_ch2;
            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
            this.su_tPos = this.data.tt[this.su_tPos];
            if (this.su_rNToGo == 0) {
                this.su_rNToGo = BZip2Constants.rNums[this.su_rTPos] - 1;
                if (++this.su_rTPos == 512) {
                    this.su_rTPos = 0;
                }
            } else {
                this.su_rNToGo--;
            }
            this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;
            this.su_i2++;
            this.currentChar = su_ch2Shadow;
            this.currentState = RAND_PART_B_STATE;
            this.crc.updateCRC(su_ch2Shadow);
        } else {
            endBlock();
            initBlock();
            setupBlock();
        }
    }

    private void setupNoRandPartA() throws IOException {
        if (this.su_i2 <= this.last) {
            this.su_chPrev = this.su_ch2;
            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
            this.su_ch2 = su_ch2Shadow;
            this.su_tPos = this.data.tt[this.su_tPos];
            this.su_i2++;
            this.currentChar = su_ch2Shadow;
            this.currentState = NO_RAND_PART_B_STATE;
            this.crc.updateCRC(su_ch2Shadow);
        } else {
            this.currentState = NO_RAND_PART_A_STATE;
            endBlock();
            initBlock();
            setupBlock();
        }
    }

    private void setupRandPartB() throws IOException {
        if (this.su_ch2 != this.su_chPrev) {
            this.currentState = RAND_PART_A_STATE;
            this.su_count = 1;
            setupRandPartA();
        } else if (++this.su_count >= 4) {
            this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
            this.su_tPos = this.data.tt[this.su_tPos];
            if (this.su_rNToGo == 0) {
                this.su_rNToGo = BZip2Constants.rNums[this.su_rTPos] - 1;
                if (++this.su_rTPos == 512) {
                    this.su_rTPos = 0;
                }
            } else {
                this.su_rNToGo--;
            }
            this.su_j2 = 0;
            this.currentState = RAND_PART_C_STATE;
            if (this.su_rNToGo == 1) {
                this.su_z ^= 1;
            }
            setupRandPartC();
        } else {
            this.currentState = RAND_PART_A_STATE;
            setupRandPartA();
        }
    }

    private void setupRandPartC() throws IOException {
        if (this.su_j2 < this.su_z) {
            this.currentChar = this.su_ch2;
            this.crc.updateCRC(this.su_ch2);
            this.su_j2++;
        } else {
            this.currentState = RAND_PART_A_STATE;
            this.su_i2++;
            this.su_count = 0;
            setupRandPartA();
        }
    }

    private void setupNoRandPartB() throws IOException {
        if (this.su_ch2 != this.su_chPrev) {
            this.su_count = 1;
            setupNoRandPartA();
        } else if (++this.su_count >= 4) {
            this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
            this.su_tPos = this.data.tt[this.su_tPos];
            this.su_j2 = 0;
            setupNoRandPartC();
        } else {
            setupNoRandPartA();
        }
    }

    private void setupNoRandPartC() throws IOException {
        if (this.su_j2 < this.su_z) {
            int su_ch2Shadow = this.su_ch2;
            this.currentChar = su_ch2Shadow;
            this.crc.updateCRC(su_ch2Shadow);
            this.su_j2++;
            this.currentState = NO_RAND_PART_C_STATE;
        } else {
            this.su_i2++;
            this.su_count = 0;
            setupNoRandPartA();
        }
    }

    private static final class Data extends Object {

        
        final boolean[] inUse   = new boolean[256];                                   

        final byte[] seqToUnseq   = new byte[256];                                    
        final byte[] selector     = new byte[MAX_SELECTORS];                          
        final byte[] selectorMtf  = new byte[MAX_SELECTORS];                          

        
        final int[] unzftab = new int[256];                                           

        final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE];                      
        final int[][] base  = new int[N_GROUPS][MAX_ALPHA_SIZE];                      
        final int[][] perm  = new int[N_GROUPS][MAX_ALPHA_SIZE];                      
        final int[] minLens = new int[N_GROUPS];                                      

        final int[]     cftab     = new int[257];                                     
        final char[]    getAndMoveToFrontDecode_yy = new char[256];                   
        final char[][]  temp_charArray2d  = new char[N_GROUPS][MAX_ALPHA_SIZE];       
        final byte[] recvDecodingTables_pos = new byte[N_GROUPS];                     
        
        

        int[] tt;                                                                     
        byte[] ll8;                                                                   
        
        
        

        Data(int blockSize100k) {
            super();

            this.ll8 = new byte[blockSize100k * BZip2Constants.baseBlockSize];
        }

        
        final int[] initTT(int length) {
            int[] ttShadow = this.tt;

            
            
            
            
            if ((ttShadow == null) || (ttShadow.length < length)) {
                this.tt = ttShadow = new int[length];
            }

            return ttShadow;
        }

    }
}

"
org.apache.tools.ant.taskdefs.compilers.JavacExternal,3,2,0,8,24,3,1,7,2,2.0,116,0.0,0,0.92,0.555555556,0,0,37.66666667,4,1.6667,0,"

package org.apache.tools.ant.taskdefs.compilers;

import java.io.IOException;
import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.FileUtils;


public class JavacExternal extends DefaultCompilerAdapter {

    
    public boolean execute() throws BuildException {
        attributes.log(""Using external javac compiler"", Project.MSG_VERBOSE);

        Commandline cmd = new Commandline();
        cmd.setExecutable(getJavac().getJavacExecutable());
        if (!assumeJava11() && !assumeJava12()) {
            setupModernJavacCommandlineSwitches(cmd);
        } else {
            setupJavacCommandlineSwitches(cmd, true);
        }
        int firstFileName = assumeJava11() ? -1 : cmd.size();
        logAndAddFilesToCompile(cmd);
        
        
        
        if (Os.isFamily(""openvms"")) {
            return execOnVMS(cmd, firstFileName);
        }
        return
                executeExternalCompile(cmd.getCommandline(), firstFileName,
                        true)
                == 0;
    }

    
    private boolean execOnVMS(Commandline cmd, int firstFileName) {
        File vmsFile = null;
        try {
            vmsFile = JavaEnvUtils.createVmsJavaOptionFile(cmd.getArguments());
            String[] commandLine = {cmd.getExecutable(),
                                    ""-V"",
                                    vmsFile.getPath()};
            return 0 == executeExternalCompile(commandLine,
                            firstFileName,
                            true);

        } catch (IOException e) {
            throw new BuildException(""Failed to create a temporary file for \""-V\"" switch"");
        } finally {
            FileUtils.delete(vmsFile);
        }
    }

}

"
org.apache.tools.ant.taskdefs.optional.ANTLR,25,3,0,18,91,218,0,18,18,0.889880952,671,1.0,2,0.616666667,0.325,1,1,25.28,10,1.56,0,"

package org.apache.tools.ant.taskdefs.optional;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.taskdefs.PumpStreamHandler;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.LoaderUtils;
import org.apache.tools.ant.util.TeeOutputStream;
import org.apache.tools.ant.util.FileUtils;


public class ANTLR extends Task {

    private CommandlineJava commandline = new CommandlineJava();

    
    private File targetFile;

    
    private File outputDirectory;

    
    private File superGrammar;

    
    private boolean html;

    
    private boolean diagnostic;

    
    private boolean trace;

    
    private boolean traceParser;

    
    private boolean traceLexer;

    
    private boolean traceTreeWalker;

    
    private File workingdir = null;

    
    private ByteArrayOutputStream bos = new ByteArrayOutputStream();

    
    private boolean debug;


    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public ANTLR() {
        commandline.setVm(JavaEnvUtils.getJreExecutable(""java""));
        commandline.setClassname(""antlr.Tool"");
    }

    
    public void setTarget(File target) {
        log(""Setting target to: "" + target.toString(), Project.MSG_VERBOSE);
        this.targetFile = target;
    }

    
    public void setOutputdirectory(File outputDirectory) {
        log(""Setting output directory to: "" + outputDirectory.toString(), Project.MSG_VERBOSE);
        this.outputDirectory = outputDirectory;
    }

    
    public void setGlib(String superGrammar) {
        String sg = null;
        if (Os.isFamily(""dos"")) {
            sg = superGrammar.replace('\\', '/');
        } else {
            sg = superGrammar;
        }
        setGlib(FILE_UTILS.resolveFile(getProject().getBaseDir(), sg));
    }
    
    public void setGlib(File superGrammar) {
        this.superGrammar = superGrammar;
    }
    
    public void setDebug(boolean enable) {
        this.debug = enable;
    }

    
    public void setHtml(boolean enable) {
        html = enable;
    }

    
    public void setDiagnostic(boolean enable) {
        diagnostic = enable;
    }

    
    public void setTrace(boolean enable) {
        trace = enable;
    }

    
    public void setTraceParser(boolean enable) {
        traceParser = enable;
    }

    
    public void setTraceLexer(boolean enable) {
        traceLexer = enable;
    }

    
    public void setTraceTreeWalker(boolean enable) {
        traceTreeWalker = enable;
    }

    
    
    
    
    
    public void setFork(boolean s) {
        
    }

    
    public void setDir(File d) {
        this.workingdir = d;
    }

    
    public Path createClasspath() {
        return commandline.createClasspath(getProject()).createPath();
    }

    
    public Commandline.Argument createJvmarg() {
        return commandline.createVmArgument();
    }

    
    public void init() throws BuildException {
        addClasspathEntry(""/antlr/ANTLRGrammarParseBehavior.class"");
    }

    
    protected void addClasspathEntry(String resource) {
        
        if (resource.startsWith(""/"")) {
            resource = resource.substring(1);
        } else {
            resource = ""org/apache/tools/ant/taskdefs/optional/""
                + resource;
        }

        File f = LoaderUtils.getResourceSource(getClass().getClassLoader(),
                                               resource);
        if (f != null) {
            log(""Found "" + f.getAbsolutePath(), Project.MSG_DEBUG);
            createClasspath().setLocation(f);
        } else {
            log(""Couldn\'t find "" + resource, Project.MSG_VERBOSE);
        }
    }

    
    public void execute() throws BuildException {
        validateAttributes();

        
        File generatedFile = getGeneratedFile();
        boolean targetIsOutOfDate =
            targetFile.lastModified() > generatedFile.lastModified();
        boolean superGrammarIsOutOfDate  = superGrammar != null
                && (superGrammar.lastModified() > generatedFile.lastModified());
        if (targetIsOutOfDate || superGrammarIsOutOfDate) {
            if (targetIsOutOfDate) {
                log(""Compiling "" + targetFile + "" as it is newer than ""
                    + generatedFile, Project.MSG_VERBOSE);
            } else if (superGrammarIsOutOfDate) {
                log(""Compiling "" + targetFile + "" as "" + superGrammar
                    + "" is newer than "" + generatedFile, Project.MSG_VERBOSE);
            }
            populateAttributes();
            commandline.createArgument().setValue(targetFile.toString());

            log(commandline.describeCommand(), Project.MSG_VERBOSE);
            int err = run(commandline.getCommandline());
            if (err != 0) {
                throw new BuildException(""ANTLR returned: "" + err, getLocation());
            } else {
                String output = bos.toString();
                if (output.indexOf(""error:"") > -1) {
                    throw new BuildException(""ANTLR signaled an error: ""
                                             + output, getLocation());
                }
            }
        } else {
            log(""Skipped grammar file. Generated file "" + generatedFile
                + "" is newer."", Project.MSG_VERBOSE);
        }
    }

    
    private void populateAttributes() {
        commandline.createArgument().setValue(""-o"");
        commandline.createArgument().setValue(outputDirectory.toString());
        if (superGrammar != null) {
            commandline.createArgument().setValue(""-glib"");
            commandline.createArgument().setValue(superGrammar.toString());
        }
        if (html) {
            commandline.createArgument().setValue(""-html"");
        }
        if (diagnostic) {
            commandline.createArgument().setValue(""-diagnostic"");
        }
        if (trace) {
            commandline.createArgument().setValue(""-trace"");
        }
        if (traceParser) {
            commandline.createArgument().setValue(""-traceParser"");
        }
        if (traceLexer) {
            commandline.createArgument().setValue(""-traceLexer"");
        }
        if (traceTreeWalker) {
            if (is272()) {
                commandline.createArgument().setValue(""-traceTreeParser"");
            } else {
                commandline.createArgument().setValue(""-traceTreeWalker"");
            }
        }
        if (debug) {
            commandline.createArgument().setValue(""-debug"");
        }
    }

    private void validateAttributes() throws BuildException {
        if (targetFile == null || !targetFile.isFile()) {
            throw new BuildException(""Invalid target: "" + targetFile);
        }

        
        if (outputDirectory == null) {
            setOutputdirectory(new File(targetFile.getParent()));
        }
        if (!outputDirectory.isDirectory()) {
            throw new BuildException(""Invalid output directory: "" + outputDirectory);
        }
    }

    private File getGeneratedFile() throws BuildException {
        String generatedFileName = null;
        try {
            BufferedReader in = new BufferedReader(new FileReader(targetFile));
            String line;
            while ((line = in.readLine()) != null) {
                int extendsIndex = line.indexOf("" extends "");
                if (line.startsWith(""class "") && extendsIndex > -1) {
                    generatedFileName = line.substring(6, extendsIndex).trim();
                    break;
                }
            }
            in.close();
        } catch (Exception e) {
            throw new BuildException(""Unable to determine generated class"", e);
        }
        if (generatedFileName == null) {
            throw new BuildException(""Unable to determine generated class"");
        }
        return new File(outputDirectory, generatedFileName
                        + (html ? "".html"" : "".java""));
    }

    
    private int run(String[] command) throws BuildException {
        PumpStreamHandler psh =
            new PumpStreamHandler(new LogOutputStream(this, Project.MSG_INFO),
                                  new TeeOutputStream(
                                                      new LogOutputStream(this,
                                                                          Project.MSG_WARN),
                                                      bos)
                                  );
        Execute exe = new Execute(psh, null);
        exe.setAntRun(getProject());
        if (workingdir != null) {
            exe.setWorkingDirectory(workingdir);
        }
        exe.setCommandline(command);
        try {
            return exe.execute();
        } catch (IOException e) {
            throw new BuildException(e, getLocation());
        } finally {
            FileUtils.close(bos);
        }
    }

    
    protected boolean is272() {
        AntClassLoader l = null;
        try {
            l = getProject().createClassLoader(commandline.getClasspath());
            l.loadClass(""antlr.Version"");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        } finally {
            if (l != null) {
                l.cleanup();
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.BorlandDeploymentTool,25,2,0,18,117,230,2,17,14,0.958333333,877,0.789473684,0,0.571428571,0.222222222,1,4,33.32,5,1.64,2,"


package org.apache.tools.ant.taskdefs.optional.ejb;


import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecTask;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;



public class BorlandDeploymentTool extends GenericDeploymentTool
                                   implements ExecuteStreamHandler {
    
    public static final String PUBLICID_BORLAND_EJB
    = ""-

    protected static final String DEFAULT_BAS45_EJB11_DTD_LOCATION
    = ""/com/inprise/j2ee/xml/dtds/ejb-jar.dtd"";

    protected static final String DEFAULT_BAS_DTD_LOCATION
    = ""/com/inprise/j2ee/xml/dtds/ejb-inprise.dtd"";

    protected static final String BAS_DD = ""ejb-inprise.xml"";
    protected static final String BES_DD = ""ejb-borland.xml"";


    
    protected static final String JAVA2IIOP = ""java2iiop"";

    
    protected static final String VERIFY = ""com.inprise.ejb.util.Verify"";

    
    private String jarSuffix = ""-ejb.jar"";

    
    private String borlandDTD;

    
    private boolean java2iiopdebug = false;

    
    private String java2iioparams = null;

    
    private boolean generateclient = false;

    
    static final int    BES       = 5;
    
    static final int    BAS       = 4;

    
    private int version = BAS;


    
    private boolean verify     = true;
    private String  verifyArgs = """";

    private Hashtable genfiles = new Hashtable();

    
    public void setDebug(boolean debug) {
        this.java2iiopdebug = debug;
    }

    
    public void setVerify(boolean verify) {
        this.verify = verify;
    }


    
    public void setSuffix(String inString) {
        this.jarSuffix = inString;
    }


    
    public void setVerifyArgs(String args) {
        this.verifyArgs = args;
    }

    
    public void setBASdtd(String inString) {
        this.borlandDTD = inString;
    }


    
    public void setGenerateclient(boolean b) {
        this.generateclient = b;
    }

    
    public void setVersion(int version) {
        this.version = version;
    }

    
    public void setJava2iiopParams(String params) {
        this.java2iioparams = params;
    }


    
    protected DescriptorHandler getBorlandDescriptorHandler(final File srcDir) {
        DescriptorHandler handler =
            new DescriptorHandler(getTask(), srcDir) {
                    protected void processElement() {
                        if (currentElement.equals(""type-storage"")) {
                            
                            String fileNameWithMETA = currentText;
                            
                            String fileName
                                = fileNameWithMETA.substring(META_DIR.length(),
                                    fileNameWithMETA.length());
                            File descriptorFile = new File(srcDir, fileName);

                            ejbFiles.put(fileNameWithMETA, descriptorFile);
                        }
                    }
                };
        handler.registerDTD(PUBLICID_BORLAND_EJB,
                            borlandDTD == null ? DEFAULT_BAS_DTD_LOCATION : borlandDTD);

        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
            handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }
        return handler;
    }

    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {

        
        if (!(version == BES || version == BAS)) {
            throw new BuildException(""version "" + version + "" is not supported"");
        }

        String dd = (version == BES ? BES_DD : BAS_DD);

        log(""vendor file : "" + ddPrefix + dd, Project.MSG_DEBUG);

        File borlandDD = new File(getConfig().descriptorDir, ddPrefix + dd);
        if (borlandDD.exists()) {
            log(""Borland specific file found "" + borlandDD,  Project.MSG_VERBOSE);
            ejbFiles.put(META_DIR + dd ,  borlandDD);
        } else {
            log(""Unable to locate borland deployment descriptor. ""
                + ""It was expected to be in ""
                + borlandDD.getPath(), Project.MSG_WARN);
            return;
        }
    }

    
    File getVendorOutputJarFile(String baseName) {
        return new File(getDestDir(), baseName +  jarSuffix);
    }

    
    private void verifyBorlandJar(File sourceJar) {
        if (version == BAS) {
            verifyBorlandJarV4(sourceJar);
            return;
        }
        if (version == BES) {
            verifyBorlandJarV5(sourceJar);
            return;
        }
        log(""verify jar skipped because the version is invalid [""
            + version + ""]"", Project.MSG_WARN);
    }

    
    private void verifyBorlandJarV5(File sourceJar) {
        log(""verify BES "" + sourceJar, Project.MSG_INFO);
        try {
            ExecTask execTask = null;
            execTask = new ExecTask(getTask());
            execTask.setDir(new File("".""));
            execTask.setExecutable(""iastool"");
            
            if (getCombinedClasspath() != null)  {
                execTask.createArg().setValue(""-VBJclasspath"");
                execTask.createArg().setValue(getCombinedClasspath().toString());
            }

            if (java2iiopdebug) {
                execTask.createArg().setValue(""-debug"");
            }
            execTask.createArg().setValue(""-verify"");
            execTask.createArg().setValue(""-src"");
            
            execTask.createArg().setValue(sourceJar.getPath());
            log(""Calling iastool"", Project.MSG_VERBOSE);
            execTask.execute();
        } catch (Exception e) {
            
            String msg = ""Exception while calling generateclient Details: ""
                + e.toString();
            throw new BuildException(msg, e);
        }
    }

    
    private void verifyBorlandJarV4(File sourceJar) {
        org.apache.tools.ant.taskdefs.Java javaTask = null;
        log(""verify BAS "" + sourceJar, Project.MSG_INFO);
        try  {
            String args = verifyArgs;
            args += "" "" + sourceJar.getPath();

            javaTask = new Java(getTask());
            javaTask.setTaskName(""verify"");
            javaTask.setClassname(VERIFY);
            Commandline.Argument arguments = javaTask.createArg();
            arguments.setLine(args);
            Path classpath = getCombinedClasspath();
            if (classpath != null)  {
                javaTask.setClasspath(classpath);
                javaTask.setFork(true);
            }

            log(""Calling "" + VERIFY + "" for "" + sourceJar.toString(),
                Project.MSG_VERBOSE);
            javaTask.execute();
        } catch (Exception e) {
            
            String msg = ""Exception while calling "" + VERIFY + "" Details: ""
                + e.toString();
            throw new BuildException(msg, e);
        }
    }


    
    private void generateClient(File sourceJar) {
        getTask().getProject().addTaskDefinition(""internal_bas_generateclient"",
            org.apache.tools.ant.taskdefs.optional.ejb.BorlandGenerateClient.class);

        org.apache.tools.ant.taskdefs.optional.ejb.BorlandGenerateClient gentask = null;
        log(""generate client for "" + sourceJar, Project.MSG_INFO);
        try {
            Project project = getTask().getProject();
            gentask
                = (BorlandGenerateClient) project.createTask(""internal_bas_generateclient"");
            gentask.setEjbjar(sourceJar);
            gentask.setDebug(java2iiopdebug);
            Path classpath = getCombinedClasspath();
            if (classpath != null) {
                gentask.setClasspath(classpath);
            }
            gentask.setVersion(version);
            gentask.setTaskName(""generate client"");
            gentask.execute();
        } catch (Exception e) {
            
            String msg = ""Exception while calling "" + VERIFY + "" Details: ""
                + e.toString();
            throw new BuildException(msg, e);
        }
    }

    
    private void buildBorlandStubs(Iterator ithomes) {
        Execute execTask = null;

        execTask = new Execute(this);
        Project project = getTask().getProject();
        execTask.setAntRun(project);
        execTask.setWorkingDirectory(project.getBaseDir());

        Commandline commandline = new Commandline();
        commandline.setExecutable(JAVA2IIOP);
        
        if (java2iiopdebug) {
            commandline.createArgument().setValue(""-VBJdebug"");
        }
        
        commandline.createArgument().setValue(""-VBJclasspath"");
        commandline.createArgument().setPath(getCombinedClasspath());
        
        commandline.createArgument().setValue(""-list_files"");
        
        commandline.createArgument().setValue(""-no_tie"");

        if (java2iioparams != null) {
            log(""additional  "" + java2iioparams + "" to java2iiop "", 0);
            commandline.createArgument().setValue(java2iioparams);
        }


        
        commandline.createArgument().setValue(""-root_dir"");
        commandline.createArgument().setValue(getConfig().srcDir.getAbsolutePath());
        
        commandline.createArgument().setValue(""-compile"");
        
        while (ithomes.hasNext()) {
            commandline.createArgument().setValue(ithomes.next().toString());
        }

        try {
            log(""Calling java2iiop"", Project.MSG_VERBOSE);
            log(commandline.describeCommand(), Project.MSG_DEBUG);
            execTask.setCommandline(commandline.getCommandline());
            int result = execTask.execute();
            if (Execute.isFailure(result)) {
                String msg = ""Failed executing java2iiop (ret code is ""
                    + result + "")"";
                throw new BuildException(msg, getTask().getLocation());
            }
        } catch (java.io.IOException e) {
            log(""java2iiop exception :"" + e.getMessage(), Project.MSG_ERR);
            throw new BuildException(e, getTask().getLocation());
        }
    }

    
    protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId)
        throws BuildException {
        
        Vector homes = new Vector();
        Iterator it = files.keySet().iterator();
        while (it.hasNext()) {
            String clazz = (String) it.next();
            if (clazz.endsWith(""Home.class"")) {
                
                String home = toClass(clazz);
                homes.add(home);
                log("" Home "" + home, Project.MSG_VERBOSE);
            }
        }

        buildBorlandStubs(homes.iterator());

        
        files.putAll(genfiles);

        super.writeJar(baseName, jarFile, files, publicId);

        if (verify) {
            verifyBorlandJar(jarFile);
        }

        if (generateclient) {
            generateClient(jarFile);
        }
    }

    
    private String toClass(String filename) {
        
        String classname = filename.substring(0, filename.lastIndexOf("".class""));
        classname = classname.replace('\\', '.');
        return classname;
    }

    
    private  String toClassFile(String filename) {
        
        String classfile = filename.substring(0, filename.lastIndexOf("".java""));
        classfile = classfile + "".class"";
        return classfile;
    }

    

    
    public void start() throws IOException  { }
    
    public void stop()  {  }
    
    public void setProcessInputStream(OutputStream param1) throws IOException   { }

    
    public void setProcessOutputStream(InputStream is) throws IOException {
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            String javafile;
            while ((javafile = reader.readLine()) != null) {
                if (javafile.endsWith("".java"")) {
                    String classfile = toClassFile(javafile);
                    String key = classfile.substring(
                        getConfig().srcDir.getAbsolutePath().length() + 1);
                    genfiles.put(key, new File(classfile));
                }
            }
            reader.close();
        } catch (Exception e) {
            String msg = ""Exception while parsing  java2iiop output. Details: "" + e.toString();
            throw new BuildException(msg, e);
        }
    }

    
    public void setProcessErrorStream(InputStream is) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        String s = reader.readLine();
        if (s != null) {
            log(""[java2iiop] "" + s, Project.MSG_ERR);
        }
    }
}

"
org.apache.tools.ant.listener.MailLogger,7,2,0,11,74,15,0,11,2,0.722222222,487,0.333333333,0,0.727272727,0.367346939,2,4,68.14285714,13,3.1429,4,"
package org.apache.tools.ant.listener;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Properties;
import java.util.Enumeration;
import java.util.StringTokenizer;

import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.email.EmailAddress;
import org.apache.tools.ant.taskdefs.email.Message;
import org.apache.tools.ant.taskdefs.email.Mailer;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.DateUtils;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.mail.MailMessage;


public class MailLogger extends DefaultLogger {
    
    private StringBuffer buffer = new StringBuffer();

    
    public void buildFinished(BuildEvent event) {
        super.buildFinished(event);

        Project project = event.getProject();
        Hashtable properties = project.getProperties();

        
        
        Properties fileProperties = new Properties();
        String filename = (String) properties.get(""MailLogger.properties.file"");
        if (filename != null) {
            InputStream is = null;
            try {
                is = new FileInputStream(filename);
                fileProperties.load(is);
            } catch (IOException ioe) {
                
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        
                    }
                }
            }
        }

        for (Enumeration e = fileProperties.keys(); e.hasMoreElements();) {
            String key = (String) e.nextElement();
            String value = fileProperties.getProperty(key);
            properties.put(key, project.replaceProperties(value));
        }

        boolean success = (event.getException() == null);
        String prefix = success ? ""success"" : ""failure"";

        try {
            boolean notify = Project.toBoolean(getValue(properties,
                    prefix + "".notify"", ""on""));

            if (!notify) {
                return;
            }

            String mailhost = getValue(properties, ""mailhost"", ""localhost"");
            int port = Integer.parseInt(getValue(properties, ""port"",
                                        String.valueOf(MailMessage.DEFAULT_PORT)));
            String user = getValue(properties, ""user"", """");
            String password = getValue(properties, ""password"", """");
            boolean ssl = Project.toBoolean(getValue(properties,
                     ""ssl"", ""off""));
            String from = getValue(properties, ""from"", null);
            String replytoList = getValue(properties, ""replyto"", """");
            String toList = getValue(properties, prefix + "".to"", null);
            String subject = getValue(properties, prefix + "".subject"",
                    (success) ? ""Build Success"" : ""Build Failure"");
            if (user.equals("""") && password.equals("""") && !ssl) {
                sendMail(mailhost, port,  from, replytoList, toList,
                         subject, buffer.substring(0));
            } else {
                sendMimeMail(event.getProject(), mailhost, port, user,
                             password, ssl, from, replytoList, toList,
                             subject, buffer.substring(0));
            }
        } catch (Exception e) {
            System.out.println(""MailLogger failed to send e-mail!"");
            e.printStackTrace(System.err);
        }
    }


    
    protected void log(String message) {
        buffer.append(message).append(StringUtils.LINE_SEP);
    }


    
    private String getValue(Hashtable properties, String name,
                            String defaultValue) throws Exception {
        String propertyName = ""MailLogger."" + name;
        String value = (String) properties.get(propertyName);

        if (value == null) {
            value = defaultValue;
        }

        if (value == null) {
            throw new Exception(""Missing required parameter: "" + propertyName);
        }

        return value;
    }


    
    private void sendMail(String mailhost, int port, String from, String replyToList, String toList,
                          String subject, String message) throws IOException {
        MailMessage mailMessage = new MailMessage(mailhost, port);
        mailMessage.setHeader(""Date"", DateUtils.getDateForHeader());

        mailMessage.from(from);
        if (!replyToList.equals("""")) {
            StringTokenizer t = new StringTokenizer(replyToList, "", "", false);
            while (t.hasMoreTokens()) {
                mailMessage.replyto(t.nextToken());
            }
        }
        StringTokenizer t = new StringTokenizer(toList, "", "", false);
        while (t.hasMoreTokens()) {
            mailMessage.to(t.nextToken());
        }

        mailMessage.setSubject(subject);

        PrintStream ps = mailMessage.getPrintStream();
        ps.println(message);

        mailMessage.sendAndClose();
    }
    
    private void sendMimeMail(Project project, String host, int port,
                              String user, String password, boolean ssl,
                              String from, String replyToString,
                              String toString, String subject,
                              String message)  {
        
        Mailer mailer = null;
        try {
            mailer = (Mailer) ClasspathUtils.newInstance(
                    ""org.apache.tools.ant.taskdefs.email.MimeMailer"",
                    MailLogger.class.getClassLoader(), Mailer.class);
        } catch (BuildException e) {
            Throwable t = e.getCause() == null ? e : e.getCause();
            log(""Failed to initialise MIME mail: "" + t.getMessage());
            return;
        }
        Vector replyToList = vectorizeEmailAddresses(replyToString);
        mailer.setHost(host);
        mailer.setPort(port);
        mailer.setUser(user);
        mailer.setPassword(password);
        mailer.setSSL(ssl);
        Message mymessage = new Message(message);
        mymessage.setProject(project);
        mailer.setMessage(mymessage);
        mailer.setFrom(new EmailAddress(from));
        mailer.setReplyToList(replyToList);
        Vector toList = vectorizeEmailAddresses(toString);
        mailer.setToList(toList);
        mailer.setCcList(new Vector());
        mailer.setBccList(new Vector());
        mailer.setFiles(new Vector());
        mailer.setSubject(subject);
        mailer.send();
    }
    private Vector vectorizeEmailAddresses(String listString) {
        Vector emailList = new Vector();
        StringTokenizer tokens = new StringTokenizer(listString, "","");
        while (tokens.hasMoreTokens()) {
            emailList.addElement(new EmailAddress(tokens.nextToken()));
        }
        return emailList;
    }
}


"
org.apache.tools.ant.taskdefs.optional.clearcase.CCMklabel,21,4,0,7,45,168,0,7,16,0.923076923,302,0.538461538,0,0.705882353,0.392857143,2,3,12.76190476,7,1.4762,0,"

package org.apache.tools.ant.taskdefs.optional.clearcase;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.types.Commandline;


public class CCMklabel extends ClearCase {
    private boolean mReplace = false;
    private boolean mRecurse = false;
    private String mVersion = null;
    private String mTypeName = null;
    private String mVOB = null;
    private String mComment = null;
    private String mCfile = null;

    
    public void execute() throws BuildException {
        Commandline commandLine = new Commandline();
        Project aProj = getProject();
        int result = 0;

        
        if (getTypeName() == null) {
            throw new BuildException(""Required attribute TypeName not specified"");
        }

        
        if (getViewPath() == null) {
            setViewPath(aProj.getBaseDir().getPath());
        }

        
        
        
        commandLine.setExecutable(getClearToolCommand());
        commandLine.createArgument().setValue(COMMAND_MKLABEL);

        checkOptions(commandLine);

        if (!getFailOnErr()) {
            getProject().log(""Ignoring any errors that occur for: ""
                    + getViewPathBasename(), Project.MSG_VERBOSE);
        }
        result = run(commandLine);
        if (Execute.isFailure(result) && getFailOnErr()) {
            String msg = ""Failed executing: "" + commandLine.toString();
            throw new BuildException(msg, getLocation());
        }
    }


    
    private void checkOptions(Commandline cmd) {
        if (getReplace()) {
            
            cmd.createArgument().setValue(FLAG_REPLACE);
        }

        if (getRecurse()) {
            
            cmd.createArgument().setValue(FLAG_RECURSE);
        }

        if (getVersion() != null) {
            
            getVersionCommand(cmd);
        }

        if (getComment() != null) {
            
            getCommentCommand(cmd);
        } else {
            if (getCommentFile() != null) {
                
                getCommentFileCommand(cmd);
            } else {
                cmd.createArgument().setValue(FLAG_NOCOMMENT);
            }
        }

        if (getTypeName() != null) {
            
            getTypeCommand(cmd);
        }

        
        cmd.createArgument().setValue(getViewPath());
    }


    
    public void setReplace(boolean replace) {
        mReplace = replace;
    }

    
    public boolean getReplace() {
        return mReplace;
    }

    
    public void setRecurse(boolean recurse) {
        mRecurse = recurse;
    }

    
    public boolean getRecurse() {
        return mRecurse;
    }

    
    public void setVersion(String version) {
        mVersion = version;
    }

    
    public String getVersion() {
        return mVersion;
    }

    
    public void setComment(String comment) {
        mComment = comment;
    }

    
    public String getComment() {
        return mComment;
    }

    
    public void setCommentFile(String cfile) {
        mCfile = cfile;
    }

    
    public String getCommentFile() {
        return mCfile;
    }

    
    public void setTypeName(String tn) {
        mTypeName = tn;
    }

    
    public String getTypeName() {
        return mTypeName;
    }

    
    public void setVOB(String vob) {
        mVOB = vob;
    }

    
    public String getVOB() {
        return mVOB;
    }


    
    private void getVersionCommand(Commandline cmd) {
        if (getVersion() != null) {
            
            cmd.createArgument().setValue(FLAG_VERSION);
            cmd.createArgument().setValue(getVersion());
        }
    }

    
    private void getCommentCommand(Commandline cmd) {
        if (getComment() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENT);
            cmd.createArgument().setValue(getComment());
        }
    }

    
    private void getCommentFileCommand(Commandline cmd) {
        if (getCommentFile() != null) {
            
            cmd.createArgument().setValue(FLAG_COMMENTFILE);
            cmd.createArgument().setValue(getCommentFile());
        }
    }

    
    private void getTypeCommand(Commandline cmd) {
        String typenm = null;

        if (getTypeName() != null) {
            typenm = getTypeName();
            if (getVOB() != null) {
                typenm += ""@"" + getVOB();
            }
            cmd.createArgument().setValue(typenm);
        }
    }


    
    public static final String FLAG_REPLACE = ""-replace"";
    
    public static final String FLAG_RECURSE = ""-recurse"";
    
    public static final String FLAG_VERSION = ""-version"";
    
    public static final String FLAG_COMMENT = ""-c"";
    
    public static final String FLAG_COMMENTFILE = ""-cfile"";
    
    public static final String FLAG_NOCOMMENT = ""-nc"";

}

"
org.apache.tools.ant.util.UUEncoder,6,1,0,1,16,11,1,0,2,0.85,202,1.0,0,0.0,0.361111111,0,0,32.0,1,0.8333,0,"
package org.apache.tools.ant.util;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;



public class UUEncoder {
    protected static final int DEFAULT_MODE = 644;
    private static final int MAX_CHARS_PER_LINE = 45;
    private OutputStream out;
    private String name;

    
    public UUEncoder(String name) {
        this.name = name;
    }

    
    public void encode(InputStream is, OutputStream out)
        throws IOException {
        this.out = out;
        encodeBegin();
        byte[] buffer = new byte[MAX_CHARS_PER_LINE * 100];
        int count;
        while ((count = is.read(buffer, 0, buffer.length)) != -1) {
            int pos = 0;
            while (count > 0) {
                int num = count > MAX_CHARS_PER_LINE
                    ? MAX_CHARS_PER_LINE
                    : count;
                encodeLine(buffer, pos, num, out);
                pos += num;
                count -= num;
            }
        }
        out.flush();
        encodeEnd();
    }

    
    private void encodeString(String n) throws IOException {
        PrintStream writer = new PrintStream(out);
        writer.print(n);
        writer.flush();
    }

    private void encodeBegin() throws IOException {
        encodeString(""begin "" + DEFAULT_MODE + "" "" + name + ""\n"");
    }

    private void encodeEnd() throws IOException {
        encodeString("" \nend\n"");
    }

    
    private void encodeLine(
        byte[] data, int offset, int length, OutputStream out)
        throws IOException {
        
        out.write((byte) ((length & 0x3F) + ' '));
        byte a;
        byte b;
        byte c;

        for (int i = 0; i < length;) {
            
            b = 1;
            c = 1;
            
            a = data[offset + i++];
            if (i < length) {
                b = data[offset + i++];
                if (i < length) {
                    c = data[offset + i++];
                }
            }

            byte d1 = (byte) (((a >>> 2) & 0x3F) + ' ');
            byte d2 = (byte) ((((a << 4) & 0x30) | ((b >>> 4) & 0x0F)) + ' ');
            byte d3 = (byte) ((((b << 2) & 0x3C) | ((c >>> 6) & 0x3)) + ' ');
            byte d4 = (byte) ((c & 0x3F) + ' ');

            out.write(d1);
            out.write(d2);
            out.write(d3);
            out.write(d4);
        }

        
        out.write('\n');
    }
}
"
org.apache.tools.ant.taskdefs.ExecuteJava,13,1,0,24,82,22,5,19,13,0.783333333,552,0.9,4,0.0,0.147435897,0,0,40.69230769,6,1.3846,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.CommandlineJava;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Permissions;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.util.TimeoutObserver;
import org.apache.tools.ant.util.Watchdog;


public class ExecuteJava implements Runnable, TimeoutObserver {

    private Commandline javaCommand = null;
    private Path classpath = null;
    private CommandlineJava.SysProperties sysProperties = null;
    private Permissions  perm = null;
    private Method main = null;
    private Long timeout = null;
    private volatile Throwable caught = null;
    private volatile boolean timedOut = false;
    private Thread thread = null;

    
    public void setJavaCommand(Commandline javaCommand) {
        this.javaCommand = javaCommand;
    }

    
    public void setClasspath(Path p) {
        classpath = p;
    }

    
    public void setSystemProperties(CommandlineJava.SysProperties s) {
        sysProperties = s;
    }

    
    public void setPermissions(Permissions permissions) {
        perm = permissions;
    }

    
    public void setOutput(PrintStream out) {
    }

    
    public void setTimeout(Long timeout) {
        this.timeout = timeout;
    }

    
    public void execute(Project project) throws BuildException {
        final String classname = javaCommand.getExecutable();

        AntClassLoader loader = null;
        try {
            if (sysProperties != null) {
                sysProperties.setSystem();
            }
            Class target = null;
            try {
                if (classpath == null) {
                    target = Class.forName(classname);
                } else {
                    loader = project.createClassLoader(classpath);
                    loader.setParent(project.getCoreLoader());
                    loader.setParentFirst(false);
                    loader.addJavaLibraries();
                    loader.setIsolated(true);
                    loader.setThreadContextLoader();
                    loader.forceLoadClass(classname);
                    target = Class.forName(classname, true, loader);
                }
            } catch (ClassNotFoundException e) {
                throw new BuildException(""Could not find "" + classname + "".""
                                         + "" Make sure you have it in your""
                                         + "" classpath"");
            }
            main = target.getMethod(""main"", new Class[] {String[].class});
            if (main == null) {
                throw new BuildException(""Could not find main() method in ""
                                         + classname);
            }
            if ((main.getModifiers() & Modifier.STATIC) == 0) {
                throw new BuildException(""main() method in "" + classname
                    + "" is not declared static"");
            }
            if (timeout == null) {
                run();
            } else {
                thread = new Thread(this, ""ExecuteJava"");
                Task currentThreadTask
                    = project.getThreadTask(Thread.currentThread());
                
                project.registerThreadTask(thread, currentThreadTask);
                
                
                
                
                thread.setDaemon(true);
                Watchdog w = new Watchdog(timeout.longValue());
                w.addTimeoutObserver(this);
                synchronized (this) {
                    thread.start();
                    w.start();
                    try {
                        wait();
                    } catch (InterruptedException e) {
                        
                    }
                    if (timedOut) {
                        project.log(""Timeout: sub-process interrupted"",
                                    Project.MSG_WARN);
                    } else {
                        thread = null;
                        w.stop();
                    }
                }
            }
            if (caught != null) {
                throw caught;
            }
        } catch (BuildException e) {
            throw e;
        } catch (SecurityException e) {
            throw e;
        } catch (ThreadDeath e) {
            
            throw e;
        } catch (Throwable e) {
            throw new BuildException(e);
        } finally {
            if (loader != null) {
                loader.resetThreadContextLoader();
                loader.cleanup();
                loader = null;
            }
            if (sysProperties != null) {
                sysProperties.restoreSystem();
            }
        }
    }

    
    public void run() {
        final Object[] argument = {javaCommand.getArguments()};
        try {
            if (perm != null) {
                perm.setSecurityManager();
            }
            main.invoke(null, argument);
        } catch (InvocationTargetException e) {
            Throwable t = e.getTargetException();
            if (!(t instanceof InterruptedException)) {
                caught = t;
            } 
        } catch (Throwable t) {
            caught = t;
        } finally {
            if (perm != null) {
                perm.restoreSecurityManager();
            }
            synchronized (this) {
                notifyAll();
            }
        }
    }

    
    public synchronized void timeoutOccured(Watchdog w) {
        if (thread != null) {
            timedOut = true;
            thread.interrupt();
        }
        notifyAll();
    }

    
    public synchronized boolean killedProcess() {
        return timedOut;
    }

    
    public int fork(ProjectComponent pc) throws BuildException {
        CommandlineJava cmdl = new CommandlineJava();
        cmdl.setClassname(javaCommand.getExecutable());
        String[] args = javaCommand.getArguments();
        for (int i = 0; i < args.length; i++) {
            cmdl.createArgument().setValue(args[i]);
        }
        if (classpath != null) {
            cmdl.createClasspath(pc.getProject()).append(classpath);
        }
        if (sysProperties != null) {
            cmdl.addSysproperties(sysProperties);
        }
        Redirector redirector = new Redirector(pc);
        Execute exe
            = new Execute(redirector.createHandler(),
                          timeout == null
                          ? null
                          : new ExecuteWatchdog(timeout.longValue()));
        exe.setAntRun(pc.getProject());
        if (Os.isFamily(""openvms"")) {
            setupCommandLineForVMS(exe, cmdl.getCommandline());
        } else {
            exe.setCommandline(cmdl.getCommandline());
        }
        try {
            int rc = exe.execute();
            redirector.complete();
            return rc;
        } catch (IOException e) {
            throw new BuildException(e);
        } finally {
            timedOut = exe.killedProcess();
        }
    }

    
    public static void setupCommandLineForVMS(Execute exe, String[] command) {
        
        exe.setVMLauncher(true);
        File vmsJavaOptionFile = null;
        try {
            String [] args = new String[command.length - 1];
            System.arraycopy(command, 1, args, 0, command.length - 1);
            vmsJavaOptionFile = JavaEnvUtils.createVmsJavaOptionFile(args);
            
            
            
            
            vmsJavaOptionFile.deleteOnExit();
            String [] vmsCmd = {command[0], ""-V"", vmsJavaOptionFile.getPath()};
            exe.setCommandline(vmsCmd);
        } catch (IOException e) {
            throw new BuildException(""Failed to create a temporary file for \""-V\"" switch"");
        }
    }

}
"
org.apache.tools.ant.taskdefs.condition.ParserSupports,8,2,0,5,19,8,0,5,7,1.0,165,0.3,0,0.5625,0.6875,0,0,18.375,2,1.0,0,"
package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.util.JAXPUtils;

import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLReader;


public class ParserSupports extends ProjectComponent implements Condition {

    private String feature;
    private String property;
    private String value;
    
    
    public static final String ERROR_BOTH_ATTRIBUTES =
            ""Property and feature attributes are exclusive"";
    
    public static final String FEATURE = ""feature"";
    
    public static final String PROPERTY = ""property"";

    
    public static final String NOT_RECOGNIZED =
            "" not recognized: "";
    
    public static final String NOT_SUPPORTED =
            "" not supported: "";
    
    public static final String ERROR_NO_ATTRIBUTES =
        ""Neither feature or property are set"";
    
    public static final String ERROR_NO_VALUE =
        ""A value is needed when testing for property support"";

    
    public void setFeature(String feature) {
        this.feature = feature;
    }

    
    public void setProperty(String property) {
        this.property = property;
    }

    
    public void setValue(String value) {
        this.value = value;
    }

    
    public boolean eval() throws BuildException {
        if (feature != null && property != null) {
            throw new BuildException(ERROR_BOTH_ATTRIBUTES);
        }
        if (feature == null && property == null) {
            throw new BuildException(ERROR_NO_ATTRIBUTES);
        }
        
        if (feature != null) {
            return evalFeature();
        }
        if (value == null) {
            throw new BuildException(ERROR_NO_VALUE);
        }
        return evalProperty();
    }

    
    private XMLReader getReader() {
        JAXPUtils.getParser();
        return JAXPUtils.getXMLReader();
    }

    
    public boolean evalFeature() {
        XMLReader reader = getReader();
        if (value == null) {
            value = ""true"";
        }
        boolean v = Project.toBoolean(value);
        try {
            reader.setFeature(feature, v);
        } catch (SAXNotRecognizedException e) {
            log(FEATURE + NOT_RECOGNIZED + feature, Project.MSG_VERBOSE);
            return false;
        } catch (SAXNotSupportedException e) {
            log(FEATURE + NOT_SUPPORTED + feature, Project.MSG_VERBOSE);
            return false;
        }
        return true;
    }

    
    public boolean evalProperty() {
        XMLReader reader = getReader();
        try {
            reader.setProperty(property, value);
        } catch (SAXNotRecognizedException e) {
            log(PROPERTY + NOT_RECOGNIZED + property, Project.MSG_VERBOSE);
            return false;
        } catch (SAXNotSupportedException e) {
            log(PROPERTY + NOT_SUPPORTED + property, Project.MSG_VERBOSE);
            return false;
        }
        return true;
    }
}
"
org.apache.tools.ant.taskdefs.optional.sos.SOSCheckin,5,4,0,3,17,10,0,3,4,2.0,87,0.0,0,0.948717949,0.533333333,1,2,16.4,3,1.2,0,"
package org.apache.tools.ant.taskdefs.optional.sos;

import org.apache.tools.ant.types.Commandline;


public class SOSCheckin extends SOS {

    
    public final void setFile(String filename) {
        super.setInternalFilename(filename);
    }

    
    public void setRecursive(boolean recursive) {
        super.setInternalRecursive(recursive);
    }

    
    public void setComment(String comment) {
        super.setInternalComment(comment);
    }

    
    protected Commandline buildCmdLine() {
        commandLine = new Commandline();

        
        if (getFilename() != null) {
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
            commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKIN_FILE);
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_FILE);
            commandLine.createArgument().setValue(getFilename());
        } else {
            
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND);
            commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKIN_PROJECT);
            
            commandLine.createArgument().setValue(getRecursive());
        }

        getRequiredAttributes();
        getOptionalAttributes();

        
        if (getComment() != null) {
            commandLine.createArgument().setValue(SOSCmd.FLAG_COMMENT);
            commandLine.createArgument().setValue(getComment());
        }
        return commandLine;
    }
}
"
org.apache.tools.ant.types.selectors.modifiedselector.Algorithm,2,1,0,4,2,1,4,0,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.io.File;



public interface Algorithm {

    
    boolean isValid();

    
    String getValue(File file);
}
"
org.apache.tools.ant.util.depend.bcel.DependencyVisitor,12,2,0,8,41,48,1,7,9,0.636363636,203,1.0,0,0.744186047,0.21875,1,1,15.75,7,1.5833,0,"
package org.apache.tools.ant.util.depend.bcel;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.apache.bcel.classfile.ConstantClass;
import org.apache.bcel.classfile.ConstantPool;
import org.apache.bcel.classfile.EmptyVisitor;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.classfile.ConstantNameAndType;


public class DependencyVisitor extends EmptyVisitor {
    
    private Hashtable dependencies = new Hashtable();
    
    private ConstantPool constantPool;

    
    public Enumeration getDependencies() {
        return dependencies.keys();
    }

    
    public void clearDependencies() {
        dependencies.clear();
    }

    
    public void visitConstantPool(ConstantPool constantPool) {
        this.constantPool = constantPool;
    }

    
    public void visitConstantClass(ConstantClass constantClass) {
        String classname
             = constantClass.getConstantValue(constantPool).toString();
        addSlashClass(classname);
    }

    
    public void visitConstantNameAndType(ConstantNameAndType obj) {
        String name = obj.getName(constantPool);
        if (obj.getSignature(constantPool).equals(""Ljava/lang/Class;"")
                && name.startsWith(""class$"")) {
            String classname = name.substring(6).replace('$', '.');
            
            int index = classname.lastIndexOf(""."");
            if (index > 0) {
                char start;
                
                int index2 = classname.lastIndexOf(""."", index - 1);
                if (index2 != -1) {
                    
                    start = classname.charAt(index2 + 1);
                } else {
                    
                    start = classname.charAt(0);
                }
                
                if ((start > 0x40) && (start < 0x5B)) {
                    
                    
                    classname = classname.substring(0, index) + ""$""
                        + classname.substring(index + 1);
                    addClass(classname);
                } else {
                    
                    addClass(classname);
                }
            } else {
                
                addClass(classname);
            }
        }
    }

    
    public void visitField(Field field) {
        addClasses(field.getSignature());
    }

    
    public void visitJavaClass(JavaClass javaClass) {
        addClass(javaClass.getClassName());
    }

    
    public void visitMethod(Method method) {
        String signature = method.getSignature();
        int pos = signature.indexOf("")"");
        addClasses(signature.substring(1, pos));
        addClasses(signature.substring(pos + 1));
    }

    
    void addClass(String classname) {
        dependencies.put(classname, classname);
    }

    
    private void addClasses(String string) {
        StringTokenizer tokens = new StringTokenizer(string, "";"");
        while (tokens.hasMoreTokens()) {
            String descriptor = tokens.nextToken();
            int pos = descriptor.indexOf('L');
            if (pos != -1) {
                addSlashClass(descriptor.substring(pos + 1));
            }
        }
    }

    
    private void addSlashClass(String classname) {
        addClass(classname.replace('/', '.'));
    }
}

"
org.apache.tools.ant.taskdefs.KeySubst,8,3,0,2,40,10,0,2,8,0.714285714,281,1.0,0,0.840909091,0.325,1,1,33.625,4,1.25,0,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;


public class KeySubst extends Task {
    private File source = null;
    private File dest = null;
    private String sep = ""*"";
    private Hashtable replacements = new Hashtable();

    
    public void execute() throws BuildException {
        log(""!! KeySubst is deprecated. Use Filter + Copy instead. !!"");
        log(""Performing Substitutions"");
        if (source == null || dest == null) {
            log(""Source and destinations must not be null"");
            return;
        }
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            br = new BufferedReader(new FileReader(source));
            dest.delete();
            bw = new BufferedWriter(new FileWriter(dest));

            String line = null;
            String newline = null;
            line = br.readLine();
            while (line != null) {
                if (line.length() == 0) {
                    bw.newLine();
                } else {
                    newline = KeySubst.replace(line, replacements);
                    bw.write(newline);
                    bw.newLine();
                }
                line = br.readLine();
            }
            bw.flush();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        } finally {
            if (bw != null) {
                try {
                    bw.close();
                } catch (IOException e) {
                    
                }
            }
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }

    
    public void setSrc(File s) {
        this.source = s;
    }

    
    public void setDest(File dest) {
        this.dest = dest;
    }

    
    public void setSep(String sep) {
        this.sep = sep;
    }
    
    public void setKeys(String keys) {
        if (keys != null && keys.length() > 0) {
            StringTokenizer tok =
            new StringTokenizer(keys, this.sep, false);
            while (tok.hasMoreTokens()) {
                String token = tok.nextToken().trim();
                StringTokenizer itok =
                new StringTokenizer(token, ""="", false);

                String name = itok.nextToken();
                String value = itok.nextToken();
                replacements.put(name, value);
            }
        }
    }


    
    public static void main(String[] args) {
        try {
            Hashtable hash = new Hashtable();
            hash.put(""VERSION"", ""1.0.3"");
            hash.put(""b"", ""ffff"");
            System.out.println(KeySubst.replace(""$f ${VERSION} f ${b} jj $"",
                                                hash));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    
    public static String replace(String origString, Hashtable keys)
        throws BuildException {
        StringBuffer finalString = new StringBuffer();
        int index = 0;
        int i = 0;
        String key = null;
        while ((index = origString.indexOf(""${"", i)) > -1) {
            key = origString.substring(index + 2, origString.indexOf(""}"",
                                       index + 3));
            finalString.append (origString.substring(i, index));
            if (keys.containsKey(key)) {
                finalString.append (keys.get(key));
            } else {
                finalString.append (""${"");
                finalString.append (key);
                finalString.append (""}"");
            }
            i = index + 3 + key.length();
        }
        finalString.append (origString.substring(i));
        return finalString.toString();
    }
}
"
org.apache.tools.ant.types.FilterSet,26,3,0,12,85,217,7,7,19,0.777142857,811,0.785714286,1,0.555555556,0.21978022,2,3,29.65384615,7,1.9615,2,"
package org.apache.tools.ant.types;

import java.io.File;
import java.io.FileInputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;


public class FilterSet extends DataType implements Cloneable {

    
    public static class Filter {
        
        
        String token;

        
        String value;
        

        
        public Filter(String token, String value) {
           setToken(token);
           setValue(value);
        }

        
        public Filter() {
        }

        
        public void setToken(String token) {
           this.token = token;
        }

        
        public void setValue(String value) {
           this.value = value;
        }

        
        public String getToken() {
           return token;
        }

        
        public String getValue() {
           return value;
        }
     }

    
    public class FiltersFile {

        
        public FiltersFile() {
        }

        
        public void setFile(File file) {
           filtersFiles.add(file);
        }
    }

    
    public static class OnMissing extends EnumeratedAttribute {
        private static final String[] VALUES
            = new String[] {""fail"", ""warn"", ""ignore""};

        
        public static final OnMissing FAIL = new OnMissing(""fail"");
        
        public static final OnMissing WARN = new OnMissing(""warn"");
        
        public static final OnMissing IGNORE = new OnMissing(""ignore"");

        private static final int FAIL_INDEX = 0;
        private static final int WARN_INDEX = 1;
        private static final int IGNORE_INDEX = 2;

        
        public OnMissing() {
        }

        
        public OnMissing(String value) {
            setValue(value);
        }

        
        
        public String[] getValues() {
            return VALUES;
        }
    }

    
    public static final String DEFAULT_TOKEN_START = ""@"";

    
    public static final String DEFAULT_TOKEN_END = ""@"";

    private String startOfToken = DEFAULT_TOKEN_START;
    private String endOfToken = DEFAULT_TOKEN_END;

    
    private Vector passedTokens;
    
    private boolean duplicateToken = false;

    private boolean recurse = true;
    private Hashtable filterHash = null;
    private Vector filtersFiles = new Vector();
    private OnMissing onMissingFiltersFile = OnMissing.FAIL;
    private boolean readingFiles = false;

    private int recurseDepth = 0;

    
    private Vector filters = new Vector();

    
    public FilterSet() {
    }

    
    protected FilterSet(FilterSet filterset) {
        super();
        this.filters = (Vector) filterset.getFilters().clone();
    }

    
    protected synchronized Vector getFilters() {
        if (isReference()) {
            return getRef().getFilters();
        }
        
        if (!readingFiles) {
            readingFiles = true;
            for (int i = 0, sz = filtersFiles.size(); i < sz; i++) {
                readFiltersFromFile((File) filtersFiles.get(i));
            }
            filtersFiles.clear();
            readingFiles = false;
        }
        return filters;
    }

    
    protected FilterSet getRef() {
        return (FilterSet) getCheckedRef(FilterSet.class, ""filterset"");
    }

    
    public synchronized Hashtable getFilterHash() {
        if (filterHash == null) {
            filterHash = new Hashtable(getFilters().size());
            for (Enumeration e = getFilters().elements(); e.hasMoreElements();) {
               Filter filter = (Filter) e.nextElement();
               filterHash.put(filter.getToken(), filter.getValue());
            }
        }
        return filterHash;
    }

    
    public void setFiltersfile(File filtersFile) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        filtersFiles.add(filtersFile);
    }

    
    public void setBeginToken(String startOfToken) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (startOfToken == null || """".equals(startOfToken)) {
            throw new BuildException(""beginToken must not be empty"");
        }
        this.startOfToken = startOfToken;
    }

    
    public String getBeginToken() {
        if (isReference()) {
            return getRef().getBeginToken();
        }
        return startOfToken;
    }

    
    public void setEndToken(String endOfToken) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (endOfToken == null || """".equals(endOfToken)) {
            throw new BuildException(""endToken must not be empty"");
        }
        this.endOfToken = endOfToken;
    }

    
    public String getEndToken() {
        if (isReference()) {
            return getRef().getEndToken();
        }
        return endOfToken;
    }

    
    public void setRecurse(boolean recurse) {
        this.recurse = recurse;
    }

    
    public boolean isRecurse() {
        return recurse;
    }

    
    public synchronized void readFiltersFromFile(File filtersFile) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (!filtersFile.exists()) {
           handleMissingFile(""Could not read filters from file ""
                                     + filtersFile + "" as it doesn't exist."");
        }
        if (filtersFile.isFile()) {
           log(""Reading filters from "" + filtersFile, Project.MSG_VERBOSE);
           FileInputStream in = null;
           try {
              Properties props = new Properties();
              in = new FileInputStream(filtersFile);
              props.load(in);

              Enumeration e = props.propertyNames();
              Vector filts = getFilters();
              while (e.hasMoreElements()) {
                 String strPropName = (String) e.nextElement();
                 String strValue = props.getProperty(strPropName);
                 filts.addElement(new Filter(strPropName, strValue));
              }
           } catch (Exception ex) {
              throw new BuildException(""Could not read filters from file: ""
                  + filtersFile);
           } finally {
              FileUtils.close(in);
           }
        } else {
           handleMissingFile(
               ""Must specify a file rather than a directory in ""
               + ""the filtersfile attribute:"" + filtersFile);
        }
        filterHash = null;
    }

    
    public synchronized String replaceTokens(String line) {
        return iReplaceTokens(line);
    }

    
    public synchronized void addFilter(Filter filter) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        filters.addElement(filter);
        filterHash = null;
    }

    
    public FiltersFile createFiltersfile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        return new FiltersFile();
    }

    
    public synchronized void addFilter(String token, String value) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        addFilter(new Filter(token, value));
    }

    
    public synchronized void addConfiguredFilterSet(FilterSet filterSet) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        for (Enumeration e = filterSet.getFilters().elements(); e.hasMoreElements();) {
            addFilter((Filter) e.nextElement());
        }
    }

    
    public synchronized boolean hasFilters() {
        return getFilters().size() > 0;
    }

    
    public synchronized Object clone() throws BuildException {
        if (isReference()) {
            return ((FilterSet) getRef()).clone();
        }
        try {
            FilterSet fs = (FilterSet) super.clone();
            fs.filters = (Vector) getFilters().clone();
            fs.setProject(getProject());
            return fs;
        } catch (CloneNotSupportedException e) {
            throw new BuildException(e);
        }
    }

    
    public void setOnMissingFiltersFile(OnMissing onMissingFiltersFile) {
        this.onMissingFiltersFile = onMissingFiltersFile;
    }

    
    public OnMissing getOnMissingFiltersFile() {
        return onMissingFiltersFile;
    }

    
    private synchronized String iReplaceTokens(String line) {
        String beginToken = getBeginToken();
        String endToken = getEndToken();
        int index = line.indexOf(beginToken);

        if (index > -1) {
            Hashtable tokens = getFilterHash();
            try {
                StringBuffer b = new StringBuffer();
                int i = 0;
                String token = null;
                String value = null;

                while (index > -1) {
                    
                    int endIndex = line.indexOf(endToken,
                        index + beginToken.length() + 1);
                    if (endIndex == -1) {
                        break;
                    }
                    token
                        = line.substring(index + beginToken.length(), endIndex);
                    b.append(line.substring(i, index));
                    if (tokens.containsKey(token)) {
                        value = (String) tokens.get(token);
                        if (recurse && !value.equals(token)) {
                            
                            value = replaceTokens(value, token);
                        }
                        log(""Replacing: "" + beginToken + token + endToken
                            + "" -> "" + value, Project.MSG_VERBOSE);
                        b.append(value);
                        i = index + beginToken.length() + token.length()
                            + endToken.length();
                    } else {
                        
                        b.append(beginToken);
                        i = index + beginToken.length();
                    }
                    index = line.indexOf(beginToken, i);
                }

                b.append(line.substring(i));
                return b.toString();
            } catch (StringIndexOutOfBoundsException e) {
                return line;
            }
        } else {
           return line;
        }
    }

    
    private synchronized String replaceTokens(String line, String parent)
        throws BuildException {
        String beginToken = getBeginToken();
        String endToken = getEndToken();
        if (recurseDepth == 0) {
            passedTokens = new Vector();
        }
        recurseDepth++;
        if (passedTokens.contains(parent) && !duplicateToken) {
            duplicateToken = true;
            System.out.println(
                ""Infinite loop in tokens. Currently known tokens : ""
                + passedTokens.toString() + ""\nProblem token : "" + beginToken
                + parent + endToken + "" called from "" + beginToken
                + passedTokens.lastElement().toString() + endToken);
            recurseDepth--;
            return parent;
        }
        passedTokens.addElement(parent);
        String value = iReplaceTokens(line);
        if (value.indexOf(beginToken) == -1 && !duplicateToken
                && recurseDepth == 1) {
            passedTokens = null;
        } else if (duplicateToken) {
            
            if (passedTokens.size() > 0) {
                value = (String) passedTokens.remove(passedTokens.size() - 1);
                if (passedTokens.size() == 0) {
                    value = beginToken + value + endToken;
                    duplicateToken = false;
                }
            }
        }
        recurseDepth--;
        return value;
    }

    private void handleMissingFile(String message) {
        switch (onMissingFiltersFile.getIndex()) {
        case OnMissing.IGNORE_INDEX:
            return;
        case OnMissing.FAIL_INDEX:
            throw new BuildException(message);
        case OnMissing.WARN_INDEX:
            log(message, Project.MSG_WARN);
            return;
        default:
            throw new BuildException(""Invalid value for onMissingFiltersFile"");
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.NameAndTypeCPInfo,6,2,0,6,16,1,5,3,6,0.6,84,1.0,0,0.545454545,0.444444444,1,1,12.33333333,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class NameAndTypeCPInfo extends ConstantPoolEntry {

    
    public NameAndTypeCPInfo() {
        super(CONSTANT_NAMEANDTYPE, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        nameIndex = cpStream.readUnsignedShort();
        descriptorIndex = cpStream.readUnsignedShort();
    }

    
    public String toString() {
        String value;

        if (isResolved()) {
            value = ""Name = "" + name + "", type = "" + type;
        } else {
            value = ""Name index = "" + nameIndex
                 + "", descriptor index = "" + descriptorIndex;
        }

        return value;
    }

    
    public void resolve(ConstantPool constantPool) {
        name = ((Utf8CPInfo) constantPool.getEntry(nameIndex)).getValue();
        type = ((Utf8CPInfo) constantPool.getEntry(descriptorIndex)).getValue();

        super.resolve(constantPool);
    }

    
    public String getName() {
        return name;
    }

    
    public String getType() {
        return type;
    }

    
    private String name;
    
    private String type;
    
    private int nameIndex;
    
    private int descriptorIndex;
}

"
org.apache.tools.ant.types.selectors.modifiedselector.ChecksumAlgorithm,6,1,0,3,25,0,1,2,6,0.3,135,1.0,0,0.0,0.444444444,0,0,21.16666667,4,2.0,0,"

package org.apache.tools.ant.types.selectors.modifiedselector;


import java.util.zip.Checksum;
import java.util.zip.CRC32;
import java.util.zip.Adler32;
import java.util.zip.CheckedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.BufferedInputStream;
import java.security.NoSuchAlgorithmException;
import org.apache.tools.ant.BuildException;



public class ChecksumAlgorithm implements Algorithm {


    


    
    private String algorithm = ""CRC"";

    
    private Checksum checksum = null;


    


    
    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }


    
    public void initChecksum() {
        if (checksum != null) {
            return;
        }
        if (""CRC"".equalsIgnoreCase(algorithm)) {
            checksum = new CRC32();
        } else if (""ADLER"".equalsIgnoreCase(algorithm)) {
            checksum = new Adler32();
        } else {
            throw new BuildException(new NoSuchAlgorithmException());
        }
    }


    


    
    public boolean isValid() {
        return ""CRC"".equalsIgnoreCase(algorithm) || ""ADLER"".equalsIgnoreCase(algorithm);
    }


    
    public String getValue(File file) {
        initChecksum();
        String rval = null;

        try {
            if (file.canRead()) {
                 checksum.reset();
                 FileInputStream fis = new FileInputStream(file);
                 CheckedInputStream check = new CheckedInputStream(fis, checksum);
                 BufferedInputStream in = new BufferedInputStream(check);
                 while (in.read() != -1) {
                     
                 }
                 rval = Long.toString(check.getChecksum().getValue());
                 in.close();
            }
        } catch (Exception e) {
            rval = null;
        }
        return rval;
    }


    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(""<ChecksumAlgorithm:"");
        buf.append(""algorithm="").append(algorithm);
        buf.append("">"");
        return buf.toString();
    }
}
"
org.apache.tools.ant.taskdefs.XSLTLogger,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs;


public interface XSLTLogger {
    
    void log(String msg);
}
"
org.apache.tools.ant.input.PropertyFileInputHandler,3,1,0,4,19,0,1,3,2,0.75,101,0.5,0,0.0,0.666666667,0,0,32.0,1,0.6667,0,"

package org.apache.tools.ant.input;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;
import org.apache.tools.ant.BuildException;


public class PropertyFileInputHandler implements InputHandler {
    private Properties props = null;

    
    public static final String FILE_NAME_KEY = ""ant.input.properties"";

    
    public PropertyFileInputHandler() {
    }

    
    public void handleInput(InputRequest request) throws BuildException {
        readProps();

        Object o = props.get(request.getPrompt());
        if (o == null) {
            throw new BuildException(""Unable to find input for \'""
                                     + request.getPrompt() + ""\'"");
        }
        request.setInput(o.toString());
        if (!request.isInputValid()) {
            throw new BuildException(""Found invalid input "" + o
                                     + "" for \'"" + request.getPrompt() + ""\'"");
        }
    }

    
    private synchronized void readProps() throws BuildException {
        if (props == null) {
            String propsFile = System.getProperty(FILE_NAME_KEY);
            if (propsFile == null) {
                throw new BuildException(""System property ""
                                         + FILE_NAME_KEY
                                         + "" for PropertyFileInputHandler not""
                                         + "" set"");
            }

            props = new Properties();

            try {
                props.load(new FileInputStream(propsFile));
            } catch (IOException e) {
                throw new BuildException(""Couldn't load "" + propsFile, e);
            }
        }
    }

}
"
org.apache.tools.ant.types.DTDLocation,1,2,1,3,2,0,2,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.tools.ant.types;


public class DTDLocation extends ResourceLocation {
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Sync,4,4,0,4,14,0,0,4,4,0.5,108,0.5,0,0.944444444,0.75,3,3,25.5,1,0.75,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class P4Sync extends P4Base {

    
    String label;
    private String syncCmd = """";
    

    
    public void setLabel(String label) throws BuildException {
        if (label == null || label.equals("""")) {
            throw new BuildException(""P4Sync: Labels cannot be Null or Empty"");
        }

        this.label = label;

    }


    
    public void setForce(String force) throws BuildException {
        if (force == null && !label.equals("""")) {
            throw new BuildException(""P4Sync: If you want to force, set force to non-null string!"");
        }
        P4CmdOpts = ""-f"";
    }

    
    public void execute() throws BuildException {


        if (P4View != null) {
            syncCmd = P4View;
        }


        if (label != null && !label.equals("""")) {
            syncCmd = syncCmd + ""@"" + label;
        }


        log(""Execing sync "" + P4CmdOpts + "" "" + syncCmd, Project.MSG_VERBOSE);

        execP4Command(""-s sync "" + P4CmdOpts + "" "" + syncCmd, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.Deltree,4,3,0,3,18,4,0,3,3,0.666666667,147,1.0,0,0.925,0.75,1,1,35.5,1,0.75,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;



public class Deltree extends Task {

    private File dir;

    
    public void setDir(File dir) {
        this.dir = dir;
    }

    
    public void execute() throws BuildException {
        log(""DEPRECATED - The deltree task is deprecated.  ""
            + ""Use delete instead."");

        if (dir == null) {
            throw new BuildException(""dir attribute must be set!"", getLocation());
        }

        if (dir.exists()) {
            if (!dir.isDirectory()) {
                if (!dir.delete()) {
                    throw new BuildException(""Unable to delete directory ""
                                             + dir.getAbsolutePath(),
                                             getLocation());
                }
                return;
            }

            log(""Deleting: "" + dir.getAbsolutePath());

            try {
                removeDir(dir);
            } catch (IOException ioe) {
                String msg = ""Unable to delete "" + dir.getAbsolutePath();
                throw new BuildException(msg, getLocation());
            }
        }
    }

    private void removeDir(File dir) throws IOException {

        
        
        

        
        
        
        String[] list = dir.list();
        for (int i = 0; i < list.length; i++) {
            String s = list[i];
            File f = new File(dir, s);
            if (f.isDirectory()) {
                removeDir(f);
            } else {
                if (!f.delete()) {
                    throw new BuildException(""Unable to delete file ""
                                             + f.getAbsolutePath());
                }
            }
        }
        if (!dir.delete()) {
            throw new BuildException(""Unable to delete directory ""
                                     + dir.getAbsolutePath());
        }
    }
}

"
org.apache.tools.ant.taskdefs.rmic.KaffeRmic,5,2,0,9,25,4,1,8,3,0.75,137,0.5,0,0.8125,0.5,0,0,26.0,2,1.0,0,"

package org.apache.tools.ant.taskdefs.rmic;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecuteJava;
import org.apache.tools.ant.types.Commandline;


public class KaffeRmic extends DefaultRmicAdapter {
    
    private static final String[] RMIC_CLASSNAMES = new String[] {
        ""gnu.classpath.tools.rmi.rmic.RMIC"",
        
        ""gnu.java.rmi.rmic.RMIC"",
        
        ""kaffe.rmi.rmic.RMIC"",
    };

    
    public static final String COMPILER_NAME = ""kaffe"";

    
    public boolean execute() throws BuildException {
        getRmic().log(""Using Kaffe rmic"", Project.MSG_VERBOSE);
        Commandline cmd = setupRmicCommand();

        Class c = getRmicClass();
        if (c == null) {
            StringBuffer buf = new StringBuffer(""Cannot use Kaffe rmic, as it""
                                                + "" is not available.  None""
                                                + "" of "");
            for (int i = 0; i < RMIC_CLASSNAMES.length; i++) {
                if (i != 0) {
                    buf.append("", "");
                }

                buf.append(RMIC_CLASSNAMES[i]);
            }
            buf.append("" have been found. A common solution is to set the""
                       + "" environment variable JAVA_HOME or CLASSPATH."");
            throw new BuildException(buf.toString(),
                                     getRmic().getLocation());
        }

        cmd.setExecutable(c.getName());
        if (!c.getName().equals(RMIC_CLASSNAMES[RMIC_CLASSNAMES.length - 1])) {
            
            cmd.createArgument().setValue(""-verbose"");
            getRmic().log(Commandline.describeCommand(cmd));
        }
        ExecuteJava ej = new ExecuteJava();
        ej.setJavaCommand(cmd);
        return ej.fork(getRmic()) == 0;
    }

    
    public static boolean isAvailable() {
        return getRmicClass() != null;
    }

    
    private static Class getRmicClass() {
        for (int i = 0; i < RMIC_CLASSNAMES.length; i++) {
            try {
                return Class.forName(RMIC_CLASSNAMES[i]);
            } catch (ClassNotFoundException cnfe) {
                
            }
        }
        return null;
    }
}
"
org.apache.tools.ant.input.InputRequest,7,1,1,6,9,15,6,0,7,0.833333333,42,1.0,0,0.0,0.714285714,0,0,4.571428571,1,0.8571,0,"

package org.apache.tools.ant.input;


public class InputRequest {
    private String prompt;
    private String input;
    private String defaultValue;

    
    public InputRequest(String prompt) {
        if (prompt == null) {
            throw new IllegalArgumentException(""prompt must not be null"");
        }

        this.prompt = prompt;
    }

    
    public String getPrompt() {
        return prompt;
    }

    
    public void setInput(String input) {
        this.input = input;
    }

    
    public boolean isInputValid() {
        return true;
    }

    
    public String getInput() {
        return input;
    }

    
    public String getDefaultValue() {
        return defaultValue;
    }

    
    public void setDefaultValue(String d) {
        defaultValue = d;
    }

}
"
org.apache.tools.ant.UnsupportedAttributeException,2,5,0,4,3,0,3,1,2,0.0,13,1.0,0,0.954545455,0.75,0,0,5.0,1,0.5,0,"
package org.apache.tools.ant;


public class UnsupportedAttributeException extends BuildException {

    private String attribute;

    
    public UnsupportedAttributeException(String msg, String attribute) {
        super(msg);
        this.attribute = attribute;
    }

    
    public String getAttribute() {
        return attribute;
    }

}
"
org.apache.tools.ant.taskdefs.Touch,20,3,0,18,70,136,1,18,13,0.824561404,515,1.0,5,0.672727273,0.167464115,0,0,24.15,7,1.45,2,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Iterator;
import java.util.Locale;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FileList;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.Touchable;
import org.apache.tools.ant.types.resources.Union;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.FileNameMapper;


public class Touch extends Task {

    private interface DateFormatFactory {
        DateFormat getPrimaryFormat();
        DateFormat getFallbackFormat();
    }

    private static final DateFormatFactory DEFAULT_DF_FACTORY
        = new DateFormatFactory() {
        
        public DateFormat getPrimaryFormat() {
            return DateFormat.getDateTimeInstance(DateFormat.SHORT,
                DateFormat.SHORT, Locale.US);
        }
        public DateFormat getFallbackFormat() {
            return DateFormat.getDateTimeInstance(DateFormat.SHORT,
                DateFormat.MEDIUM, Locale.US);
        }
    };
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private File file;
    private long millis = -1;
    private String dateTime;
    private Vector filesets = new Vector();
    private Union resources = new Union();
    private boolean dateTimeConfigured;
    private boolean mkdirs;
    private boolean verbose = true;
    private FileNameMapper fileNameMapper = null;
    private DateFormatFactory dfFactory = DEFAULT_DF_FACTORY;

    
    public Touch() {
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public void setMillis(long millis) {
        this.millis = millis;
    }

    
    public void setDatetime(String dateTime) {
        if (this.dateTime != null) {
            log(""Resetting datetime attribute to "" + dateTime, Project.MSG_VERBOSE);
        }
        this.dateTime = dateTime;
        dateTimeConfigured = false;
    }

    
    public void setMkdirs(boolean mkdirs) {
        this.mkdirs = mkdirs;
    }

    
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    
    public void setPattern(final String pattern) {
        dfFactory = new DateFormatFactory() {
            public DateFormat getPrimaryFormat() {
                return new SimpleDateFormat(pattern);
            }
            public DateFormat getFallbackFormat() {
                return null;
            }
        };
    }

    
    public void addConfiguredMapper(Mapper mapper) {
        add(mapper.getImplementation());
    }

    
    public void add(FileNameMapper fileNameMapper) throws BuildException {
        if (this.fileNameMapper != null) {
            throw new BuildException(""Only one mapper may be added to the ""
                + getTaskName() + "" task."");
        }
        this.fileNameMapper = fileNameMapper;
    }

    
    public void addFileset(FileSet set) {
        filesets.add(set);
        add(set);
    }

    
    public void addFilelist(FileList list) {
        add(list);
    }

    
    public void add(ResourceCollection rc) {
        resources.add(rc);
    }

    
    protected synchronized void checkConfiguration() throws BuildException {
        if (file == null && resources.size() == 0) {
            throw new BuildException(""Specify at least one source""
                                   + ""--a file or resource collection."");
        }
        if (file != null && file.exists() && file.isDirectory()) {
            throw new BuildException(""Use a resource collection to touch directories."");
        }
        if (dateTime != null && !dateTimeConfigured) {
            long workmillis = millis;
            DateFormat df = dfFactory.getPrimaryFormat();
            ParseException pe = null;
            try {
                workmillis = df.parse(dateTime).getTime();
            } catch (ParseException peOne) {
                df = dfFactory.getFallbackFormat();
                if (df == null) {
                    pe = peOne;
                } else {
                    try {
                        workmillis = df.parse(dateTime).getTime();
                    } catch (ParseException peTwo) {
                        pe = peTwo;
                    }
                }
            }
            if (pe != null) {
                throw new BuildException(pe.getMessage(), pe, getLocation());
            }
            if (workmillis < 0) {
                throw new BuildException(""Date of "" + dateTime
                                         + "" results in negative ""
                                         + ""milliseconds value ""
                                         + ""relative to epoch ""
                                         + ""(January 1, 1970, ""
                                         + ""00:00:00 GMT)."");
            }
            log(""Setting millis to "" + workmillis + "" from datetime attribute"",
                ((millis < 0) ? Project.MSG_DEBUG : Project.MSG_VERBOSE));
            setMillis(workmillis);
            
            dateTimeConfigured = true;
        }
    }

    
    public void execute() throws BuildException {
        checkConfiguration();
        touch();
    }

    
    protected void touch() throws BuildException {
        long defaultTimestamp = getTimestamp();

        if (file != null) {
            touch(new FileResource(file.getParentFile(), file.getName()),
                  defaultTimestamp);
        }
        
        Iterator iter = resources.iterator();
        while (iter.hasNext()) {
            Resource r = (Resource) iter.next();
            if (!(r instanceof Touchable)) {
                throw new BuildException(""Can't touch "" + r);
            }
            touch(r, defaultTimestamp);
        }

        
        
        
        for (int i = 0; i < filesets.size(); i++) {
            FileSet fs = (FileSet) filesets.elementAt(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            File fromDir = fs.getDir(getProject());

            String[] srcDirs = ds.getIncludedDirectories();

            for (int j = 0; j < srcDirs.length; j++) {
                touch(new FileResource(fromDir, srcDirs[j]), defaultTimestamp);
            }
        }
    }

    
    protected void touch(File file) {
        touch(file, getTimestamp());
    }

    private long getTimestamp() {
        return (millis < 0) ? System.currentTimeMillis() : millis;
    }

    private void touch(Resource r, long defaultTimestamp) {
        if (fileNameMapper == null) {
            if (r instanceof FileResource) {
                
                touch(((FileResource) r).getFile(), defaultTimestamp);
            } else {
                ((Touchable) r).touch(defaultTimestamp);
            }
        } else {
            String[] mapped = fileNameMapper.mapFileName(r.getName());
            if (mapped != null && mapped.length > 0) {
                long modTime = (r.isExists()) ? r.getLastModified()
                    : defaultTimestamp;
                for (int i = 0; i < mapped.length; i++) {
                    touch(getProject().resolveFile(mapped[i]), modTime);
                }
            }
        }
    }

    private void touch(File file, long modTime) {
        if (!file.exists()) {
            log(""Creating "" + file,
                ((verbose) ? Project.MSG_INFO : Project.MSG_VERBOSE));
            try {
                FILE_UTILS.createNewFile(file, mkdirs);
            } catch (IOException ioe) {
                throw new BuildException(""Could not create "" + file, ioe,
                                         getLocation());
            }
        }
        if (!file.canWrite()) {
            throw new BuildException(""Can not change modification date of ""
                                     + ""read-only file "" + file);
        }
        FILE_UTILS.setFileLastModified(file, modTime);
    }

}
"
org.apache.tools.ant.types.selectors.SignedSelector,3,3,0,4,11,0,0,4,3,0.0,35,1.0,1,0.9375,0.666666667,0,0,10.33333333,2,1.0,0,"

package org.apache.tools.ant.types.selectors;
import java.io.File;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.taskdefs.condition.IsSigned;


public class SignedSelector extends DataType implements FileSelector {
    private IsSigned isSigned = new IsSigned();

    
    public void setName(String name) {
        isSigned.setName(name);
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        if (file.isDirectory()) {
            return false; 
        }
        isSigned.setProject(getProject());
        isSigned.setFile(file);
        return isSigned.eval();
    }
}
"
org.apache.tools.ant.filters.PrefixLines,7,5,0,4,23,0,1,3,5,0.555555556,150,1.0,0,0.848484848,0.476190476,2,5,20.0,4,1.1429,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.types.Parameter;


public final class PrefixLines
    extends BaseParamFilterReader
    implements ChainableReader {
    
    private static final String PREFIX_KEY = ""prefix"";

    
    private String prefix = null;

    
    private String queuedData = null;

    
    public PrefixLines() {
        super();
    }

    
    public PrefixLines(final Reader in) {
        super(in);
    }

    
    public int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;

        if (queuedData != null && queuedData.length() == 0) {
            queuedData = null;
        }

        if (queuedData != null) {
            ch = queuedData.charAt(0);
            queuedData = queuedData.substring(1);
            if (queuedData.length() == 0) {
                queuedData = null;
            }
        } else {
            queuedData = readLine();
            if (queuedData == null) {
                ch = -1;
            } else {
                if (prefix != null) {
                    queuedData = prefix + queuedData;
                }
                return read();
            }
        }
        return ch;
    }

    
    public void setPrefix(final String prefix) {
        this.prefix = prefix;
    }

    
    private String getPrefix() {
        return prefix;
    }

    
    public Reader chain(final Reader rdr) {
        PrefixLines newFilter = new PrefixLines(rdr);
        newFilter.setPrefix(getPrefix());
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
        Parameter[] params = getParameters();
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (PREFIX_KEY.equals(params[i].getName())) {
                    prefix = params[i].getValue();
                    break;
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.splash.SplashTask,11,3,0,6,53,23,0,6,9,0.833333333,380,0.888888889,1,0.804347826,0.36,1,1,32.72727273,1,0.8182,1,"

package org.apache.tools.ant.taskdefs.optional.splash;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import javax.swing.ImageIcon;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.util.Base64Converter;


public class SplashTask extends Task {

    private String imgurl = null;
    private String proxy = null;
    private String user = null;
    private String password = null;
    private String port = ""80"";
    private int showDuration = 5000;
    private boolean useProxy = false;

    private static SplashScreen splash = null;

    
    public void setImageURL(String imgurl) {
        this.imgurl = imgurl;
    }

    
    public void setUseproxy(boolean useProxy) {
        this.useProxy = useProxy;
    }

    
    public void setProxy(String proxy) {
        this.proxy = proxy;
    }

    
    public void setPort(String port) {
        this.port = port;
    }

    
    public void setUser(String user) {
        this.user = user;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

    
    public void setShowduration(int duration) {
        this.showDuration = duration;
    }


    
    public void execute() throws BuildException {
        if (splash != null) {
            splash.setVisible(false);
            getProject().removeBuildListener(splash);
            splash.dispose();
            splash = null;
        }

        log(""Creating new SplashScreen"", Project.MSG_VERBOSE);
        InputStream in = null;

        if (imgurl != null) {
            try {
                URLConnection conn = null;

                if (useProxy && (proxy != null && proxy.length() > 0)
                    && (port != null && port.length() > 0)) {

                    log(""Using proxied Connection"",  Project.MSG_DEBUG);
                    System.getProperties().put(""http.proxySet"", ""true"");
                    System.getProperties().put(""http.proxyHost"", proxy);
                    System.getProperties().put(""http.proxyPort"", port);

                    URL url = new URL(imgurl);

                    conn = url.openConnection();
                    if (user != null && user.length() > 0) {
                        
                        
                        
                        String encodedcreds =
                            new Base64Converter().encode(user + "":"" + password);
                        conn.setRequestProperty(""Proxy-Authorization"",
                                                encodedcreds);
                    }

                } else {
                    System.getProperties().put(""http.proxySet"", ""false"");
                    System.getProperties().put(""http.proxyHost"", """");
                    System.getProperties().put(""http.proxyPort"", """");
                    log(""Using Direction HTTP Connection"", Project.MSG_DEBUG);
                    URL url = new URL(imgurl);
                    conn = url.openConnection();
                }
                conn.setDoInput(true);
                conn.setDoOutput(false);

                in = conn.getInputStream();

                
                
                

            } catch (Throwable ioe) {
                log(""Unable to download image, trying default Ant Logo"",
                    Project.MSG_DEBUG);
                log(""(Exception was \"""" + ioe.getMessage() + ""\"""",
                    Project.MSG_DEBUG);
            }
        }

        if (in == null) {
            ClassLoader cl = SplashTask.class.getClassLoader();
            if (cl != null) {
                in = cl.getResourceAsStream(""images/ant_logo_large.gif"");
            } else {
                in = ClassLoader
                    .getSystemResourceAsStream(""images/ant_logo_large.gif"");
            }
        }

        boolean success = false;
        if (in != null) {
            DataInputStream din = new DataInputStream(in);
            try {
                ByteArrayOutputStream bout = new ByteArrayOutputStream();
                int data;
                while ((data = din.read()) != -1) {
                    bout.write((byte) data);
                }

                log(""Got ByteArray, creating splash"",  Project.MSG_DEBUG);

                try {
                    ImageIcon img = new ImageIcon(bout.toByteArray());
                    splash = new SplashScreen(img);
                    success = true;
                } catch (Throwable e) {
                    logHeadless(e);
                }
            } catch (Exception e) {
                throw new BuildException(e);
            } finally {
                try {
                    din.close();
                } catch (IOException ioe) {
                    
                    
                    if (success) {
                        throw new BuildException(ioe);
                    }
                }
            }
        } else {
            try {
                splash = new SplashScreen(""Image Unavailable."");
                success = true;
            } catch (Throwable e) {
                logHeadless(e);
            }
        }

        if (success) {
            splash.setVisible(true);
            splash.toFront();
            getProject().addBuildListener(splash);
            try {
                Thread.sleep(showDuration);
            } catch (InterruptedException e) {
                
            }
        }
    }

    private void logHeadless(Throwable e) {
        log(""failed to display SplashScreen, caught ""
            + e.getClass().getName() + "" with message: "" + e.getMessage(),
            Project.MSG_WARN);
    }
}
"
org.apache.tools.ant.taskdefs.Patch,11,3,0,10,39,0,0,10,11,0.7,247,1.0,1,0.787234043,0.454545455,1,1,21.09090909,2,1.4545,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Commandline;


public class Patch extends Task {

    private File originalFile;
    private File directory;
    private boolean havePatchfile = false;
    private Commandline cmd = new Commandline();

    
    public void setOriginalfile(File file) {
        originalFile = file;
    }

    
    public void setDestfile(File file) {
        if (file != null) {
            cmd.createArgument().setValue(""-o"");
            cmd.createArgument().setFile(file);
        }
    }

    
    public void setPatchfile(File file) {
        if (!file.exists()) {
            throw new BuildException(""patchfile "" + file + "" doesn\'t exist"",
                                     getLocation());
        }
        cmd.createArgument().setValue(""-i"");
        cmd.createArgument().setFile(file);
        havePatchfile = true;
    }

    
    public void setBackups(boolean backups) {
        if (backups) {
            cmd.createArgument().setValue(""-b"");
        }
    }

    
    public void setIgnorewhitespace(boolean ignore) {
        if (ignore) {
            cmd.createArgument().setValue(""-l"");
        }
    }

    
    public void setStrip(int num) throws BuildException {
        if (num < 0) {
            throw new BuildException(""strip has to be >= 0"", getLocation());
        }
        cmd.createArgument().setValue(""-p"" + num);
    }

    
    public void setQuiet(boolean q) {
        if (q) {
            cmd.createArgument().setValue(""-s"");
        }
    }

    
    public void setReverse(boolean r) {
        if (r) {
            cmd.createArgument().setValue(""-R"");
        }
    }

    
    public void setDir(File directory) {
        this.directory = directory;
    }

    
    public void execute() throws BuildException {
        if (!havePatchfile) {
            throw new BuildException(""patchfile argument is required"",
                                     getLocation());
        }
        Commandline toExecute = (Commandline) cmd.clone();
        toExecute.setExecutable(""patch"");

        if (originalFile != null) {
            toExecute.createArgument().setFile(originalFile);
        }

        Execute exe = new Execute(new LogStreamHandler(this, Project.MSG_INFO,
                                                       Project.MSG_WARN),
                                  null);
        exe.setCommandline(toExecute.getCommandline());

        if (directory != null) {
            if (directory.exists() && directory.isDirectory()) {
                exe.setWorkingDirectory(directory);
            } else if (!directory.isDirectory()) {
                throw new BuildException(directory + "" is not a directory."",
                                         getLocation());
            } else {
                throw new BuildException(""directory "" + directory
                                         + "" doesn\'t exist"", getLocation());
            }
        } else {
            exe.setWorkingDirectory(getProject().getBaseDir());
        }

        log(toExecute.describeCommand(), Project.MSG_VERBOSE);
        try {
            exe.execute();
        } catch (IOException e) {
            throw new BuildException(e, getLocation());
        }
    }
}
"
org.apache.tools.ant.types.optional.ScriptSelector,17,4,0,8,32,16,0,8,16,0.822916667,140,1.0,2,0.68627451,0.235294118,1,1,6.882352941,1,0.9412,0,"
package org.apache.tools.ant.types.optional;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.selectors.BaseSelector;
import org.apache.tools.ant.util.ScriptRunnerBase;
import org.apache.tools.ant.util.ScriptRunnerHelper;


public class ScriptSelector extends BaseSelector {

    
    private ScriptRunnerHelper helper = new ScriptRunnerHelper();

    
    private ScriptRunnerBase runner;

    
    private File basedir;
    private String filename;
    private File file;

    
    private boolean selected;

    
    public void setProject(Project project) {
        super.setProject(project);
        helper.setProjectComponent(this);
    }

    
    public void setManager(String manager) {
        helper.setManager(manager);
    }

    
    public void setLanguage(String language) {
        helper.setLanguage(language);
    }

    
    private void init() throws BuildException {
        if (runner != null) {
            return;
        }
        runner = helper.getScriptRunner();
    }

    
    public void setSrc(File file) {
        helper.setSrc(file);
    }

    
    public void addText(String text) {
        helper.addText(text);
    }

    
    public void setClasspath(Path classpath) {
        helper.setClasspath(classpath);
    }

    
    public Path createClasspath() {
        return helper.createClasspath();
    }

    
    public void setClasspathRef(Reference r) {
        helper.setClasspathRef(r);
    }

    
    public void setSetBeans(boolean setBeans) {
        helper.setSetBeans(setBeans);
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        init();
        setSelected(true);
        this.file = file;
        this.basedir = basedir;
        this.filename = filename;
        runner.addBean(""basedir"", basedir);
        runner.addBean(""filename"", filename);
        runner.addBean(""file"", file);
        runner.executeScript(""ant_selector"");
        return isSelected();
    }

    
    public File getBasedir() {
        return basedir;
    }

    
    public String getFilename() {
        return filename;
    }

    
    public File getFile() {
        return file;
    }

    
    public boolean isSelected() {
        return selected;
    }

    
    public void setSelected(boolean selected) {
        this.selected = selected;
    }

}
"
org.apache.tools.ant.taskdefs.email.EmailAddress,8,1,0,5,16,6,5,0,7,0.571428571,284,1.0,0,0.0,0.541666667,0,0,34.25,13,2.375,0,"
package org.apache.tools.ant.taskdefs.email;


public class EmailAddress {
    private String name;
    private String address;


    
    public EmailAddress() {
    }


    
    
    
    public EmailAddress(String email) {
        final int minLen = 9;
        int len = email.length();

        
        if (len > minLen) {
            if ((email.charAt(0) == '<' || email.charAt(1) == '<')
            && (email.charAt(len - 1) == '>' || email.charAt(len - 2) == '>')) {
                this.address = trim(email, true);
                return;
            }
        }

        int paramDepth = 0;
        int start = 0;
        int end = 0;
        int nStart = 0;
        int nEnd = 0;

        for (int i = 0; i < len; i++) {
            char c = email.charAt(i);
            if (c == '(') {
                paramDepth++;
                if (start == 0) {
                    end = i;  
                    nStart = i + 1;
                }
            } else if (c == ')') {
                paramDepth--;
                if (end == 0) {
                    start = i + 1;  
                    nEnd = i;
                }
            } else if (paramDepth == 0 && c == '<') {
                if (start == 0) {
                    nEnd = i;
                }
                start = i + 1;
            } else if (paramDepth == 0 && c == '>') {
                end = i;
                if (end != len - 1) {
                    nStart = i + 1;
                }
            }
        }

        
        if (end == 0) {
            end = len;
        }
        
        if (nEnd == 0) {
            nEnd = len;
        }
        

        this.address = trim(email.substring(start, end), true);
        this.name = trim(email.substring(nStart, nEnd), false);

        
        
        if (this.name.length() + this.address.length() > len) {
            this.name = null;
        }
    }

    
    private String trim(String t, boolean trimAngleBrackets) {
        int start = 0;
        int end = t.length();
        boolean trim = false;
        do {
            trim = false;
            if (t.charAt(end - 1) == ')'
                || (t.charAt(end - 1) == '>' && trimAngleBrackets)
                || (t.charAt(end - 1) == '""' && t.charAt(end - 2) != '\\')
                || t.charAt(end - 1) <= '\u0020') {
                trim = true;
                end--;
            }
            if (t.charAt(start) == '('
                || (t.charAt(start) == '<' && trimAngleBrackets)
                || t.charAt(start) == '""'
                || t.charAt(start) <= '\u0020') {
                trim = true;
                start++;
            }
        } while (trim);
        return t.substring(start, end);
    }


    
    public void setName(String name) {
        this.name = name;
    }


    
    public void setAddress(String address) {
        this.address = address;
    }


    
    public String toString() {
        if (name == null) {
            return address;
        } else {
            return name + "" <"" + address + "">"";
        }
    }


    
    public String getAddress() {
        return address;
    }


    
    public String getName() {
        return name;
    }
}

"
org.apache.tools.ant.types.XMLCatalog,28,3,0,17,105,344,7,12,13,0.864197531,874,0.555555556,4,0.535714286,0.243386243,1,1,29.89285714,9,2.0714,0,"

package org.apache.tools.ant.types;

import java.lang.reflect.Method;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.Vector;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.sax.SAXSource;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JAXPUtils;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;




public class XMLCatalog extends DataType
    implements Cloneable, EntityResolver, URIResolver {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    

    
    private Vector elements = new Vector();

    
    private Path classpath;

    
    private Path catalogPath;

    
    public static final String APACHE_RESOLVER
        = ""org.apache.tools.ant.types.resolver.ApacheCatalogResolver"";

    
    public static final String CATALOG_RESOLVER
        = ""org.apache.xml.resolver.tools.CatalogResolver"";

        

    
    public XMLCatalog() {
        setChecked(false);
    }

    
    private Vector getElements() {
        return getRef().elements;
    }

    
    private Path getClasspath() {
        return getRef().classpath;
    }

    
    public Path createClasspath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        setChecked(false);
        return this.classpath.createPath();
    }

    
    public void setClasspath(Path classpath) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
        setChecked(false);
    }

    
    public void setClasspathRef(Reference r) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createClasspath().setRefid(r);
        setChecked(false);
    }

    
    public Path createCatalogPath() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (this.catalogPath == null) {
            this.catalogPath = new Path(getProject());
        }
        setChecked(false);
        return this.catalogPath.createPath();
    }

    
    public void setCatalogPathRef(Reference r) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        createCatalogPath().setRefid(r);
        setChecked(false);
    }


    
    public Path getCatalogPath() {
        return getRef().catalogPath;
    }


    
    public void addDTD(ResourceLocation dtd) throws BuildException {
        if (isReference()) {
            throw noChildrenAllowed();
        }

        getElements().addElement(dtd);
        setChecked(false);
    }

    
    public void addEntity(ResourceLocation entity) throws BuildException {
        addDTD(entity);
    }

    
    public void addConfiguredXMLCatalog(XMLCatalog catalog) {
        if (isReference()) {
            throw noChildrenAllowed();
        }

        
        Vector newElements = catalog.getElements();
        Vector ourElements = getElements();
        Enumeration e = newElements.elements();
        while (e.hasMoreElements()) {
            ourElements.addElement(e.nextElement());
        }

        
        Path nestedClasspath = catalog.getClasspath();
        createClasspath().append(nestedClasspath);

        
        Path nestedCatalogPath = catalog.getCatalogPath();
        createCatalogPath().append(nestedCatalogPath);
        setChecked(false);
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (!elements.isEmpty()) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public InputSource resolveEntity(String publicId, String systemId)
        throws SAXException, IOException {

        if (isReference()) {
            return getRef().resolveEntity(publicId, systemId);
        }

        dieOnCircularReference();

        log(""resolveEntity: '"" + publicId + ""': '"" + systemId + ""'"",
            Project.MSG_DEBUG);

        InputSource inputSource =
            getCatalogResolver().resolveEntity(publicId, systemId);

        if (inputSource == null) {
            log(""No matching catalog entry found, parser will use: '""
                + systemId + ""'"", Project.MSG_DEBUG);
        }

        return inputSource;
    }

    
    public Source resolve(String href, String base)
        throws TransformerException {

        if (isReference()) {
            return getRef().resolve(href, base);
        }

        dieOnCircularReference();

        SAXSource source = null;

        String uri = removeFragment(href);

        log(""resolve: '"" + uri + ""' with base: '"" + base + ""'"", Project.MSG_DEBUG);

        source = (SAXSource) getCatalogResolver().resolve(uri, base);

        if (source == null) {
            log(""No matching catalog entry found, parser will use: '""
                + href + ""'"", Project.MSG_DEBUG);
            
            
            
            
            source = new SAXSource();
            URL baseURL = null;
            try {
                if (base == null) {
                    baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
                } else {
                    baseURL = new URL(base);
                }
                URL url = (uri.length() == 0 ? baseURL : new URL(baseURL, uri));
                source.setInputSource(new InputSource(url.toString()));
            } catch (MalformedURLException ex) {
                
                
                source.setInputSource(new InputSource(uri));
            }
        }

        setEntityResolver(source);
        return source;
    }

    
    private XMLCatalog getRef() {
        if (!isReference()) {
            return this;
        }
        return (XMLCatalog) getCheckedRef(XMLCatalog.class, ""xmlcatalog"");
    }

    
    private CatalogResolver catalogResolver = null;

    
    private CatalogResolver getCatalogResolver() {

        if (catalogResolver == null) {

            AntClassLoader loader = null;

            loader = getProject().createClassLoader(Path.systemClasspath);

            try {
                Class clazz = Class.forName(APACHE_RESOLVER, true, loader);

                
                
                
                ClassLoader apacheResolverLoader = clazz.getClassLoader();

                
                Class baseResolverClass
                    = Class.forName(CATALOG_RESOLVER, true, apacheResolverLoader);

                
                ClassLoader baseResolverLoader
                    = baseResolverClass.getClassLoader();

                
                
                
                
                clazz = Class.forName(APACHE_RESOLVER, true, baseResolverLoader);

                Object obj  = clazz.newInstance();
                
                
                
                
                catalogResolver = new ExternalResolver(clazz, obj);
            } catch (Throwable ex) {
                
                
                
                
                catalogResolver = new InternalResolver();
                if (getCatalogPath() != null
                    && getCatalogPath().list().length != 0) {
                        log(""Warning: XML resolver not found; external catalogs""
                            + "" will be ignored"", Project.MSG_WARN);
                    }
                log(""Failed to load Apache resolver: "" + ex, Project.MSG_DEBUG);
            }
        }
        return catalogResolver;
    }

    
    private void setEntityResolver(SAXSource source) throws TransformerException {

        XMLReader reader = source.getXMLReader();
        if (reader == null) {
            SAXParserFactory spFactory = SAXParserFactory.newInstance();
            spFactory.setNamespaceAware(true);
            try {
                reader = spFactory.newSAXParser().getXMLReader();
            } catch (ParserConfigurationException ex) {
                throw new TransformerException(ex);
            } catch (SAXException ex) {
                throw new TransformerException(ex);
            }
        }
        reader.setEntityResolver(this);
        source.setXMLReader(reader);
    }

    
    private ResourceLocation findMatchingEntry(String publicId) {
        Enumeration e = getElements().elements();
        ResourceLocation element = null;
        while (e.hasMoreElements()) {
            Object o = e.nextElement();
            if (o instanceof ResourceLocation) {
                element = (ResourceLocation) o;
                if (element.getPublicId().equals(publicId)) {
                    return element;
                }
            }
        }
        return null;
    }

    
    private String removeFragment(String uri) {
        String result = uri;
        int hashPos = uri.indexOf(""#"");
        if (hashPos >= 0) {
            result = uri.substring(0, hashPos);
        }
        return result;
    }

    
    private InputSource filesystemLookup(ResourceLocation matchingEntry) {

        String uri = matchingEntry.getLocation();
        
        uri = uri.replace(File.separatorChar, '/');
        URL baseURL = null;

        
        
        
        
        
        if (matchingEntry.getBase() != null) {
            baseURL = matchingEntry.getBase();
        } else {
            try {
                baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
            } catch (MalformedURLException ex) {
                throw new BuildException(""Project basedir cannot be converted to a URL"");
            }
        }

        InputSource source = null;
        URL url = null;
        try {
            url = new URL(baseURL, uri);
        } catch (MalformedURLException ex) {
            
            
            
            File testFile = new File(uri);
            if (testFile.exists() && testFile.canRead()) {
                log(""uri : '""
                    + uri + ""' matches a readable file"", Project.MSG_DEBUG);
                try {
                    url = FILE_UTILS.getFileURL(testFile);
                } catch (MalformedURLException ex1) {
                    throw new BuildException(
                        ""could not find an URL for :"" + testFile.getAbsolutePath());
                }
            } else {
                log(""uri : '""
                    + uri + ""' does not match a readable file"", Project.MSG_DEBUG);

            }
        }

        if (url != null && url.getProtocol().equals(""file"")) {
            String fileName = FILE_UTILS.fromURI(url.toString());
            if (fileName != null) {
                log(""fileName "" + fileName, Project.MSG_DEBUG);
                File resFile = new File(fileName);
                if (resFile.exists() && resFile.canRead()) {
                    try {
                        source = new InputSource(new FileInputStream(resFile));
                        String sysid = JAXPUtils.getSystemId(resFile);
                        source.setSystemId(sysid);
                        log(""catalog entry matched a readable file: '""
                            + sysid + ""'"", Project.MSG_DEBUG);
                    } catch (IOException ex) {
                        
                    }
                }
            }
        }
        return source;
    }

    
    private InputSource classpathLookup(ResourceLocation matchingEntry) {

        InputSource source = null;

        AntClassLoader loader = null;
        Path cp = classpath;
        if (cp != null) {
            cp = classpath.concatSystemClasspath(""ignore"");
        } else {
            cp = (new Path(getProject())).concatSystemClasspath(""last"");
        }
        loader = getProject().createClassLoader(cp);

        
        
        
        InputStream is
            = loader.getResourceAsStream(matchingEntry.getLocation());

        if (is != null) {
            source = new InputSource(is);
            URL entryURL = loader.getResource(matchingEntry.getLocation());
            String sysid = entryURL.toExternalForm();
            source.setSystemId(sysid);
            log(""catalog entry matched a resource in the classpath: '""
                + sysid + ""'"", Project.MSG_DEBUG);
        }

        return source;
    }

    
    private InputSource urlLookup(ResourceLocation matchingEntry) {

        String uri = matchingEntry.getLocation();
        URL baseURL = null;

        
        
        
        
        
        if (matchingEntry.getBase() != null) {
            baseURL = matchingEntry.getBase();
        } else {
            try {
                baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
            } catch (MalformedURLException ex) {
                throw new BuildException(""Project basedir cannot be converted to a URL"");
            }
        }

        InputSource source = null;
        URL url = null;

        try {
            url = new URL(baseURL, uri);
        } catch (MalformedURLException ex) {
            
        }

        if (url != null) {
            try {
                InputStream is = url.openStream();
                if (is != null) {
                    source = new InputSource(is);
                    String sysid = url.toExternalForm();
                    source.setSystemId(sysid);
                    log(""catalog entry matched as a URL: '""
                        + sysid + ""'"", Project.MSG_DEBUG);
                }
            } catch (IOException ex) {
                
            }
        }

        return source;

    }

    
    private interface CatalogResolver extends URIResolver, EntityResolver {

        InputSource resolveEntity(String publicId, String systemId);

        Source resolve(String href, String base) throws TransformerException;
    }

    
    private class InternalResolver implements CatalogResolver {

        public InternalResolver() {
            log(""Apache resolver library not found, internal resolver will be used"",
                Project.MSG_VERBOSE);
        }

        public InputSource resolveEntity(String publicId,
                                         String systemId) {
            InputSource result = null;
            ResourceLocation matchingEntry = findMatchingEntry(publicId);

            if (matchingEntry != null) {

                log(""Matching catalog entry found for publicId: '""
                    + matchingEntry.getPublicId() + ""' location: '""
                    + matchingEntry.getLocation() + ""'"",
                    Project.MSG_DEBUG);

                result = filesystemLookup(matchingEntry);

                if (result == null) {
                    result = classpathLookup(matchingEntry);
                }

                if (result == null) {
                    result = urlLookup(matchingEntry);
                }
            }
            return result;
        }

        public Source resolve(String href, String base)
            throws TransformerException {

            SAXSource result = null;
            InputSource source = null;

            ResourceLocation matchingEntry = findMatchingEntry(href);

            if (matchingEntry != null) {

                log(""Matching catalog entry found for uri: '""
                    + matchingEntry.getPublicId() + ""' location: '""
                    + matchingEntry.getLocation() + ""'"",
                    Project.MSG_DEBUG);

                
                
                
                
                
                
                
                
                
                
                ResourceLocation entryCopy = matchingEntry;
                if (base != null) {
                    try {
                        URL baseURL = new URL(base);
                        entryCopy = new ResourceLocation();
                        entryCopy.setBase(baseURL);
                    } catch (MalformedURLException ex) {
                        
                    }
                }
                entryCopy.setPublicId(matchingEntry.getPublicId());
                entryCopy.setLocation(matchingEntry.getLocation());

                source = filesystemLookup(entryCopy);

                if (source == null) {
                    source = classpathLookup(entryCopy);
                }

                if (source == null) {
                    source = urlLookup(entryCopy);
                }

                if (source != null) {
                    result = new SAXSource(source);
                }
            }
            return result;
        }
    }

    
    private class ExternalResolver implements CatalogResolver {

        private Method setXMLCatalog = null;
        private Method parseCatalog = null;
        private Method resolveEntity = null;
        private Method resolve = null;

        
        private Object resolverImpl = null;

        private boolean externalCatalogsProcessed = false;

        public ExternalResolver(Class resolverImplClass,
                              Object resolverImpl) {

            this.resolverImpl = resolverImpl;

            
            
            
            
            
            
            
            try {
                setXMLCatalog =
                    resolverImplClass.getMethod(""setXMLCatalog"",
                                                new Class[] {XMLCatalog.class});

                parseCatalog =
                    resolverImplClass.getMethod(""parseCatalog"",
                                                new Class[] {String.class});

                resolveEntity =
                    resolverImplClass.getMethod(""resolveEntity"",
                                                new Class[] {String.class, String.class});

                resolve =
                    resolverImplClass.getMethod(""resolve"",
                                                new Class[] {String.class, String.class});
            } catch (NoSuchMethodException ex) {
                throw new BuildException(ex);
            }

            log(""Apache resolver library found, xml-commons resolver will be used"",
                Project.MSG_VERBOSE);
        }

        public InputSource resolveEntity(String publicId,
                                         String systemId) {
            InputSource result = null;

            processExternalCatalogs();

            ResourceLocation matchingEntry = findMatchingEntry(publicId);

            if (matchingEntry != null) {

                log(""Matching catalog entry found for publicId: '""
                    + matchingEntry.getPublicId() + ""' location: '""
                    + matchingEntry.getLocation() + ""'"",
                    Project.MSG_DEBUG);

                result = filesystemLookup(matchingEntry);

                if (result == null) {
                    result = classpathLookup(matchingEntry);
                }

                if (result == null) {
                    try {
                        result =
                            (InputSource) resolveEntity.invoke(resolverImpl,
                                                              new Object[] {publicId, systemId});
                    } catch (Exception ex) {
                        throw new BuildException(ex);
                    }
                }
            } else {
                
                
                
                
                
                
                
                
                try {
                    result =
                        (InputSource) resolveEntity.invoke(resolverImpl,
                                                          new Object[] {publicId, systemId});
                } catch (Exception ex) {
                    throw new BuildException(ex);
                }
            }

            return result;
        }

        public Source resolve(String href, String base)
            throws TransformerException {

            SAXSource result = null;
            InputSource source = null;

            processExternalCatalogs();

            ResourceLocation matchingEntry = findMatchingEntry(href);

            if (matchingEntry != null) {

                log(""Matching catalog entry found for uri: '""
                    + matchingEntry.getPublicId() + ""' location: '""
                    + matchingEntry.getLocation() + ""'"",
                    Project.MSG_DEBUG);

                
                
                
                
                
                
                
                
                
                
                
                
                ResourceLocation entryCopy = matchingEntry;
                if (base != null) {
                    try {
                        URL baseURL = new URL(base);
                        entryCopy = new ResourceLocation();
                        entryCopy.setBase(baseURL);
                    } catch (MalformedURLException ex) {
                        
                    }
                }
                entryCopy.setPublicId(matchingEntry.getPublicId());
                entryCopy.setLocation(matchingEntry.getLocation());

                source = filesystemLookup(entryCopy);

                if (source == null) {
                    source = classpathLookup(entryCopy);
                }

                if (source != null) {
                    result = new SAXSource(source);
                } else {
                    try {
                        result =
                            (SAXSource) resolve.invoke(resolverImpl,
                                                      new Object[] {href, base});
                    } catch (Exception ex) {
                        throw new BuildException(ex);
                    }
                }
            } else {
                
                
                
                
                
                
                
                
                try {
                    result =
                        (SAXSource) resolve.invoke(resolverImpl,
                                                  new Object[] {href, base});
                } catch (Exception ex) {
                    throw new BuildException(ex);
                }
            }
            return result;
        }

        
        private void processExternalCatalogs() {

            if (!externalCatalogsProcessed) {

                try {
                    setXMLCatalog.invoke(resolverImpl,
                                         new Object[] {XMLCatalog.this});
                } catch (Exception ex) {
                    throw new BuildException(ex);
                }

                
                Path catPath = getCatalogPath();
                if (catPath != null) {
                    log(""Using catalogpath '"" + getCatalogPath() + ""'"",
                        Project.MSG_DEBUG);
                    String[] catPathList = getCatalogPath().list();

                    for (int i = 0; i < catPathList.length; i++) {
                        File catFile = new File(catPathList[i]);
                        log(""Parsing "" + catFile, Project.MSG_DEBUG);
                        try {
                            parseCatalog.invoke(resolverImpl,
                                    new Object[] {catFile.getPath()});
                        } catch (Exception ex) {
                            throw new BuildException(ex);
                        }
                    }
                }
            }
            externalCatalogsProcessed = true;
        }
    }
} 
"
org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapterFactory,4,1,0,8,14,6,1,7,3,0.666666667,79,0.0,0,0.0,0.333333333,0,0,18.25,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.native2ascii;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.JavaEnvUtils;


public class Native2AsciiAdapterFactory {

    
    public static String getDefault() {
        if (JavaEnvUtils.isKaffe()) {
            return KaffeNative2Ascii.IMPLEMENTATION_NAME;
        }
        return SunNative2Ascii.IMPLEMENTATION_NAME;
    }

    
    public static Native2AsciiAdapter getAdapter(String choice,
                                                 ProjectComponent log)
        throws BuildException {
        if ((JavaEnvUtils.isKaffe() && choice == null)
            || KaffeNative2Ascii.IMPLEMENTATION_NAME.equals(choice)) {
            return new KaffeNative2Ascii();
        } else if (SunNative2Ascii.IMPLEMENTATION_NAME.equals(choice)) {
            return new SunNative2Ascii();
        } else if (choice != null) {
            return resolveClassName(choice);
        }

        
        
        return new SunNative2Ascii();
    }

    
    private static Native2AsciiAdapter resolveClassName(String className)
        throws BuildException {
        return (Native2AsciiAdapter) ClasspathUtils.newInstance(className,
            Native2AsciiAdapterFactory.class.getClassLoader(),
            Native2AsciiAdapter.class);
    }
}
"
org.apache.tools.bzip2.CRC,8,1,0,2,9,0,2,0,0,0.428571429,1107,0.0,0,0.0,0.714285714,0,0,137.125,3,1.125,0,"



package org.apache.tools.bzip2;


final class CRC {
    static final int crc32Table[] = {
        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
    };

    CRC() {
        initialiseCRC();
    }

    void initialiseCRC() {
        globalCrc = 0xffffffff;
    }

    int getFinalCRC() {
        return ~globalCrc;
    }

    int getGlobalCRC() {
        return globalCrc;
    }

    void setGlobalCRC(int newCrc) {
        globalCrc = newCrc;
    }

    void updateCRC(int inCh) {
        int temp = (globalCrc >> 24) ^ inCh;
        if (temp < 0) {
            temp = 256 + temp;
        }
        globalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];
    }

    void updateCRC(int inCh, int repeat) {
        int globalCrcShadow = this.globalCrc;
        while (repeat-- > 0) {
            int temp = (globalCrcShadow >> 24) ^ inCh;
            globalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)
                                                      ? temp
                                                      : (temp + 256)];
        }
        this.globalCrc = globalCrcShadow;
    }

    int globalCrc;
}

"
org.apache.tools.ant.taskdefs.compilers.AptCompilerAdapter,5,2,0,10,34,10,1,9,2,1.25,171,0.333333333,0,0.851851852,0.466666667,0,0,32.6,7,2.0,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Apt;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;

import java.io.File;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Vector;



public class AptCompilerAdapter extends DefaultCompilerAdapter {

    
    private static final int APT_COMPILER_SUCCESS = 0;
    
    public static final String APT_ENTRY_POINT = ""com.sun.tools.apt.Main"";

    
    public static final String APT_METHOD_NAME = ""process"";

    
    protected Apt getApt() {
        return (Apt) getJavac();
    }

    
    static void setAptCommandlineSwitches(Apt apt, Commandline cmd) {

        if (!apt.isCompile()) {
            cmd.createArgument().setValue(""-nocompile"");
        }

        
        String factory = apt.getFactory();
        if (factory != null) {
            cmd.createArgument().setValue(""-factory"");
            cmd.createArgument().setValue(factory);
        }

        
        Path factoryPath = apt.getFactoryPath();
        if (factoryPath != null) {
            cmd.createArgument().setValue(""-factorypath"");
            cmd.createArgument().setPath(factoryPath);
        }

        File preprocessDir = apt.getPreprocessDir();
        if (preprocessDir != null) {
            cmd.createArgument().setValue(""-s"");
            cmd.createArgument().setFile(preprocessDir);
        }

        
        Vector options = apt.getOptions();
        Enumeration elements = options.elements();
        Apt.Option opt;
        StringBuffer arg = null;
        while (elements.hasMoreElements()) {
            opt = (Apt.Option) elements.nextElement();
            arg = new StringBuffer();
            arg.append(""-A"").append(opt.getName());
            if (opt.getValue() != null) {
                arg.append(""="").append(opt.getValue());
            }
            cmd.createArgument().setValue(arg.toString());
        }
    }

    
    protected void setAptCommandlineSwitches(Commandline cmd) {
        Apt apt = getApt();
        setAptCommandlineSwitches(apt, cmd);
    }

    
    public boolean execute() throws BuildException {
        attributes.log(""Using apt compiler"", Project.MSG_VERBOSE);
        
        Commandline cmd = setupModernJavacCommand();
        
        setAptCommandlineSwitches(cmd);

        
        
        try {
            Class c = Class.forName(APT_ENTRY_POINT);
            Object compiler = c.newInstance();
            Method compile = c.getMethod(APT_METHOD_NAME,
                    new Class[]{(new String[]{}).getClass()});
            int result = ((Integer) compile.invoke
                    (compiler, new Object[]{cmd.getArguments()}))
                    .intValue();
            return (result == APT_COMPILER_SUCCESS);
        } catch (BuildException be) {
            
            throw be;
        } catch (Exception ex) {
            
            throw new BuildException(""Error starting apt compiler"",
                    ex, location);
        }
    }
}
"
org.apache.tools.ant.taskdefs.GZip,3,4,0,5,20,3,0,5,1,1.0,71,0.0,0,0.961538462,1.0,2,4,22.33333333,3,1.6667,0,"

package org.apache.tools.ant.taskdefs;

import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.GZIPOutputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;



public class GZip extends Pack {
    
    protected void pack() {
        GZIPOutputStream zOut = null;
        try {
            zOut = new GZIPOutputStream(new FileOutputStream(zipFile));
            zipResource(getSrcResource(), zOut);
        } catch (IOException ioe) {
            String msg = ""Problem creating gzip "" + ioe.getMessage();
            throw new BuildException(msg, ioe, getLocation());
        } finally {
            FileUtils.close(zOut);
        }
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(GZip.class);
    }
}
"
org.apache.tools.ant.taskdefs.cvslib.CvsTagEntry,7,1,0,1,11,7,1,0,7,0.333333333,105,1.0,0,0.0,0.714285714,0,0,13.57142857,7,1.4286,0,"
package org.apache.tools.ant.taskdefs.cvslib;


public class CvsTagEntry {

    
    private String filename;

    
    private String prevRevision;

    
    private String revision;

    
    public CvsTagEntry(final String filename) {
        this(filename, null, null);
    }

    
    public CvsTagEntry(final String filename, final String revision) {
        this(filename, revision, null);
    }

    
    public CvsTagEntry(final String filename, final String revision,
                       final String prevRevision) {
        this.filename = filename;
        this.revision = revision;
        this.prevRevision = prevRevision;
    }

    
    public String getFile() {
        return filename;
    }

    
    public String getRevision() {
        return revision;
    }

    
    public String getPreviousRevision() {
        return prevRevision;
    }

    
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        buffer.append(filename);
        if ((revision == null)) {
            buffer.append("" was removed"");
            if (prevRevision != null) {
                buffer.append(""; previous revision was "").append(prevRevision);
            }
        } else if (revision != null && prevRevision == null) {
            buffer.append("" is new; current revision is "")
                .append(revision);
        } else if (revision != null && prevRevision != null) {
            buffer.append("" has changed from "")
                .append(prevRevision).append("" to "").append(revision);
        }
        return buffer.toString();
    }
}
"
org.apache.tools.ant.util.ContainerMapper,8,1,2,4,17,16,3,2,7,0.285714286,89,1.0,0,0.0,0.4375,0,0,10.0,6,1.875,0,"

package org.apache.tools.ant.util;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collections;
import org.apache.tools.ant.types.Mapper;


public abstract class ContainerMapper implements FileNameMapper {

    private List mappers = new ArrayList();

    
    public void addConfiguredMapper(Mapper mapper) {
        add(mapper.getImplementation());
    }

    
    public void addConfigured(FileNameMapper fileNameMapper) {
        add(fileNameMapper);
    }

    
    public synchronized void add(FileNameMapper fileNameMapper) {
        if (this == fileNameMapper
            || (fileNameMapper instanceof ContainerMapper
            && ((ContainerMapper) fileNameMapper).contains(this))) {
            throw new IllegalArgumentException(
                ""Circular mapper containment condition detected"");
        } else {
            mappers.add(fileNameMapper);
        }
    }

    
    protected synchronized boolean contains(FileNameMapper fileNameMapper) {
        boolean foundit = false;
        for (Iterator iter = mappers.iterator(); iter.hasNext() && !foundit;) {
            FileNameMapper next = (FileNameMapper) (iter.next());
            foundit |= (next == fileNameMapper
                || (next instanceof ContainerMapper
                && ((ContainerMapper) next).contains(fileNameMapper)));
        }
        return foundit;
    }

    
    public synchronized List getMappers() {
        return Collections.unmodifiableList(mappers);
    }

    
    public void setFrom(String ignore) {
        
    }

    
    public void setTo(String ignore) {
        
    }

}

"
org.apache.tools.ant.util.XMLFragment,7,2,1,6,21,0,2,5,4,0.333333333,90,1.0,0,0.6,0.464285714,0,0,11.57142857,3,1.2857,0,"

package org.apache.tools.ant.util;

import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

import org.apache.tools.ant.DynamicElementNS;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.DynamicConfiguratorNS;


public class XMLFragment extends ProjectComponent implements DynamicElementNS {

    private Document doc;
    private DocumentFragment fragment;

    
    public XMLFragment() {
        doc = JAXPUtils.getDocumentBuilder().newDocument();
        fragment = doc.createDocumentFragment();
    }

    
    public DocumentFragment getFragment() {
        return fragment;
    }

    
    public void addText(String s) {
        addText(fragment, s);
    }

    
    public Object createDynamicElement(String uri, String name, String qName) {
        Element e = null;
        if (uri.equals("""")) {
            e = doc.createElement(name);
        } else {
            e = doc.createElementNS(uri, qName);
        }
        fragment.appendChild(e);
        return new Child(e);
    }

    
    private void addText(Node n, String s) {
        s = getProject().replaceProperties(s);
        
        if (s != null && !s.trim().equals("""")) {
            Text t = doc.createTextNode(s.trim());
            n.appendChild(t);
        }
    }

    
    public class Child implements DynamicConfiguratorNS {
        private Element e;

        Child(Element e) {
            this.e = e;
        }

        
        public void addText(String s) {
            XMLFragment.this.addText(e, s);
        }

        
        public void setDynamicAttribute(
            String uri, String name, String qName, String value) {
            if (uri.equals("""")) {
                e.setAttribute(name, value);
            } else {
                e.setAttributeNS(uri, qName, value);
            }
        }

        
        public Object createDynamicElement(String uri, String name, String qName) {
            Element e2 = null;
            if (uri.equals("""")) {
                e2 = doc.createElement(name);
            } else {
                e2 = doc.createElementNS(uri, qName);
            }
            e.appendChild(e2);
            return new Child(e2);
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.junit.SummaryJUnitResultFormatter,12,1,1,8,31,46,2,6,12,0.836363636,223,1.0,0,0.0,0.270833333,0,0,17.16666667,1,0.9167,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.IOException;
import java.io.OutputStream;
import java.text.NumberFormat;
import junit.framework.AssertionFailedError;
import junit.framework.Test;
import org.apache.tools.ant.BuildException;



public class SummaryJUnitResultFormatter
    implements JUnitResultFormatter, JUnitTaskMirror.SummaryJUnitResultFormatterMirror {

    
    private NumberFormat nf = NumberFormat.getInstance();
    
    private OutputStream out;

    private boolean withOutAndErr = false;
    private String systemOutput = null;
    private String systemError = null;

    
    public SummaryJUnitResultFormatter() {
    }
    
    public void startTestSuite(JUnitTest suite) {
        String newLine = System.getProperty(""line.separator"");
        StringBuffer sb = new StringBuffer(""Running "");
        sb.append(suite.getName());
        sb.append(newLine);

        try {
            out.write(sb.toString().getBytes());
            out.flush();
        } catch (IOException ioex) {
            throw new BuildException(""Unable to write summary output"", ioex);
        }
    }
    
    public void startTest(Test t) {
    }
    
    public void endTest(Test test) {
    }
    
    public void addFailure(Test test, Throwable t) {
    }
    
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }
    
    public void addError(Test test, Throwable t) {
    }

    
    public void setOutput(OutputStream out) {
        this.out = out;
    }

    
    public void setSystemOutput(String out) {
        systemOutput = out;
    }

    
    public void setSystemError(String err) {
        systemError = err;
    }

    
    public void setWithOutAndErr(boolean value) {
        withOutAndErr = value;
    }

    
    public void endTestSuite(JUnitTest suite) throws BuildException {
        String newLine = System.getProperty(""line.separator"");
        StringBuffer sb = new StringBuffer(""Tests run: "");
        sb.append(suite.runCount());
        sb.append("", Failures: "");
        sb.append(suite.failureCount());
        sb.append("", Errors: "");
        sb.append(suite.errorCount());
        sb.append("", Time elapsed: "");
        sb.append(nf.format(suite.getRunTime() / 1000.0));
        sb.append("" sec"");
        sb.append(newLine);

        if (withOutAndErr) {
            if (systemOutput != null && systemOutput.length() > 0) {
                sb.append(""Output:"").append(newLine).append(systemOutput)
                    .append(newLine);
            }

            if (systemError != null && systemError.length() > 0) {
                sb.append(""Error: "").append(newLine).append(systemError)
                    .append(newLine);
            }
        }

        try {
            out.write(sb.toString().getBytes());
            out.flush();
        } catch (IOException ioex) {
            throw new BuildException(""Unable to write summary output"", ioex);
        } finally {
            if (out != System.out && out != System.err) {
                try {
                    out.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.Redirector,42,1,0,24,109,653,6,19,30,0.899825784,1212,1.0,3,0.0,0.146341463,0,0,27.19047619,40,2.2619,2,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.Reader;
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PipedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Arrays;
import java.util.Vector;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.filters.util.ChainReaderHelper;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.util.TeeOutputStream;
import org.apache.tools.ant.util.ReaderInputStream;
import org.apache.tools.ant.util.LeadPipeInputStream;
import org.apache.tools.ant.util.LazyFileOutputStream;
import org.apache.tools.ant.util.OutputStreamFunneler;
import org.apache.tools.ant.util.ConcatFileInputStream;
import org.apache.tools.ant.util.KeepAliveOutputStream;


public class Redirector {

    private static final String DEFAULT_ENCODING
        = System.getProperty(""file.encoding"");

    private class PropertyOutputStream extends ByteArrayOutputStream {
        private String property;
        private boolean closed = false;

        PropertyOutputStream(String property) {
            super();
            this.property = property;
        }

        public void close() throws IOException {
            if (!closed && !(append && appendProperties)) {
                setPropertyFromBAOS(this, property);
                closed = true;
            }
        }
    }

    
    private File[] input;

    
    private File[] out;

    
    private File[] error;

    
    private boolean logError = false;

    
    private PropertyOutputStream baos = null;

    
    private PropertyOutputStream errorBaos = null;

    
    private String outputProperty;

    
    private String errorProperty;

    
    private String inputString;

    
    private boolean append = false;

    
    private boolean alwaysLog = false;

    
    private boolean createEmptyFiles = true;

    
    private ProjectComponent managingTask;

    
    private OutputStream outputStream = null;

    
    private OutputStream errorStream = null;

    
    private InputStream inputStream = null;

    
    private PrintStream outPrintStream = null;

    
    private PrintStream errorPrintStream = null;

    
    private Vector outputFilterChains;

    
    private Vector errorFilterChains;

    
    private Vector inputFilterChains;

    
    private String outputEncoding = DEFAULT_ENCODING;

    
    private String errorEncoding = DEFAULT_ENCODING;

    
    private String inputEncoding = DEFAULT_ENCODING;

    
    private boolean appendProperties = true;

    
    private ThreadGroup threadGroup = new ThreadGroup(""redirector"");

    
    private boolean logInputString = true;

    
    public Redirector(Task managingTask) {
        this((ProjectComponent) managingTask);
    }

    
    public Redirector(ProjectComponent managingTask) {
        this.managingTask = managingTask;
    }

    
    public void setInput(File input) {
        setInput((input == null) ? null : new File[] {input});
    }

    
    public synchronized void setInput(File[] input) {
        this.input = input;
    }

    
    public synchronized void setInputString(String inputString) {
        this.inputString = inputString;
    }

    
    public void setLogInputString(boolean logInputString) {
        this.logInputString = logInputString;
    }

    
     void setInputStream(InputStream inputStream) {
        this.inputStream = inputStream;
    }

    
    public void setOutput(File out) {
        setOutput((out == null) ? null : new File[] {out});
    }

    
    public synchronized void setOutput(File[] out) {
        this.out = out;
    }

    
    public synchronized void setOutputEncoding(String outputEncoding) {
        if (outputEncoding == null) {
            throw new IllegalArgumentException(
                ""outputEncoding must not be null"");
        } else {
            this.outputEncoding = outputEncoding;
        }
    }

    
    public synchronized void setErrorEncoding(String errorEncoding) {
        if (errorEncoding == null) {
            throw new IllegalArgumentException(
                ""errorEncoding must not be null"");
        } else {
            this.errorEncoding = errorEncoding;
        }
    }

    
    public synchronized void setInputEncoding(String inputEncoding) {
        if (inputEncoding == null) {
            throw new IllegalArgumentException(
                ""inputEncoding must not be null"");
        } else {
            this.inputEncoding = inputEncoding;
        }
    }

    
    public synchronized void setLogError(boolean logError) {
        this.logError = logError;
    }

    
    public synchronized void setAppendProperties(boolean appendProperties) {
        this.appendProperties = appendProperties;
    }

    
    public void setError(File error) {
        setError((error == null) ? null : new File[] {error});
    }

    
    public synchronized void setError(File[] error) {
        this.error = error;
    }

    
    public synchronized void setOutputProperty(String outputProperty) {
        if (outputProperty == null
         || !(outputProperty.equals(this.outputProperty))) {
            this.outputProperty = outputProperty;
            baos = null;
        }
    }

    
    public synchronized void setAppend(boolean append) {
        this.append = append;
    }

    
    public synchronized void setAlwaysLog(boolean alwaysLog) {
        this.alwaysLog = alwaysLog;
    }

    
    public synchronized void setCreateEmptyFiles(boolean createEmptyFiles) {
        this.createEmptyFiles = createEmptyFiles;
    }

    
    public synchronized void setErrorProperty(String errorProperty) {
        if (errorProperty == null
         || !(errorProperty.equals(this.errorProperty))) {
            this.errorProperty = errorProperty;
            errorBaos = null;
        }
    }

    
    public synchronized void setInputFilterChains(Vector inputFilterChains) {
        this.inputFilterChains = inputFilterChains;
    }

    
    public synchronized void setOutputFilterChains(Vector outputFilterChains) {
        this.outputFilterChains = outputFilterChains;
    }

    
    public synchronized void setErrorFilterChains(Vector errorFilterChains) {
        this.errorFilterChains = errorFilterChains;
    }

    
    private void setPropertyFromBAOS(ByteArrayOutputStream baos,
                                     String propertyName) throws IOException {

        BufferedReader in
            = new BufferedReader(new StringReader(Execute.toString(baos)));
        String line = null;
        StringBuffer val = new StringBuffer();
        while ((line = in.readLine()) != null) {
            if (val.length() != 0) {
                val.append(StringUtils.LINE_SEP);
            }
            val.append(line);
        }
        managingTask.getProject().setNewProperty(propertyName, val.toString());
    }

    
    public synchronized void createStreams() {
        if (out != null && out.length > 0) {
            String logHead = new StringBuffer(""Output "").append(
                ((append) ? ""appended"" : ""redirected"")).append(
                "" to "").toString();
            outputStream = foldFiles(out, logHead, Project.MSG_VERBOSE);
        }
        if (outputProperty != null) {
            if (baos == null) {
                baos = new PropertyOutputStream(outputProperty);
                managingTask.log(""Output redirected to property: ""
                    + outputProperty, Project.MSG_VERBOSE);
            }
            
            OutputStream keepAliveOutput = new KeepAliveOutputStream(baos);
            outputStream = (outputStream == null) ? keepAliveOutput
                : new TeeOutputStream(outputStream, keepAliveOutput);
        } else {
            baos = null;
        }

        if (error != null && error.length > 0) {
            String logHead = new StringBuffer(""Error "").append(
                ((append) ? ""appended"" : ""redirected"")).append(
                "" to "").toString();
            errorStream = foldFiles(error, logHead, Project.MSG_VERBOSE);
        } else if (!(logError || outputStream == null)) {
            long funnelTimeout = 0L;
            OutputStreamFunneler funneler
                = new OutputStreamFunneler(outputStream, funnelTimeout);
            try {
                outputStream = funneler.getFunnelInstance();
                errorStream = funneler.getFunnelInstance();
            } catch (IOException eyeOhEx) {
                throw new BuildException(
                    ""error splitting output/error streams"", eyeOhEx);
            }
        }
        if (errorProperty != null) {
            if (errorBaos == null) {
                errorBaos = new PropertyOutputStream(errorProperty);
                managingTask.log(""Error redirected to property: "" + errorProperty,
                    Project.MSG_VERBOSE);
            }
            
            OutputStream keepAliveError = new KeepAliveOutputStream(errorBaos);
            errorStream = (error == null || error.length == 0) ? keepAliveError
                : new TeeOutputStream(errorStream, keepAliveError);
        } else {
            errorBaos = null;
        }
        if (alwaysLog || outputStream == null) {
            OutputStream outputLog
                = new LogOutputStream(managingTask, Project.MSG_INFO);
            outputStream = (outputStream == null)
                ? outputLog : new TeeOutputStream(outputLog, outputStream);
        }
        if (alwaysLog || errorStream == null) {
            OutputStream errorLog
                = new LogOutputStream(managingTask, Project.MSG_WARN);
            errorStream = (errorStream == null)
                ? errorLog : new TeeOutputStream(errorLog, errorStream);
        }
        if ((outputFilterChains != null && outputFilterChains.size() > 0)
            || !(outputEncoding.equalsIgnoreCase(inputEncoding))) {
            try {
                LeadPipeInputStream snk = new LeadPipeInputStream();
                snk.setManagingComponent(managingTask);

                InputStream outPumpIn = snk;

                Reader reader = new InputStreamReader(outPumpIn, inputEncoding);

                if (outputFilterChains != null && outputFilterChains.size() > 0) {
                    ChainReaderHelper helper = new ChainReaderHelper();
                    helper.setProject(managingTask.getProject());
                    helper.setPrimaryReader(reader);
                    helper.setFilterChains(outputFilterChains);
                    reader = helper.getAssembledReader();
                }
                outPumpIn = new ReaderInputStream(reader, outputEncoding);

                Thread t = new Thread(threadGroup, new StreamPumper(
                    outPumpIn, outputStream, true), ""output pumper"");
                t.setPriority(Thread.MAX_PRIORITY);
                outputStream = new PipedOutputStream(snk);
                t.start();
            } catch (IOException eyeOhEx) {
                throw new BuildException(
                    ""error setting up output stream"", eyeOhEx);
            }
        }

        if ((errorFilterChains != null && errorFilterChains.size() > 0)
            || !(errorEncoding.equalsIgnoreCase(inputEncoding))) {
            try {
                LeadPipeInputStream snk = new LeadPipeInputStream();
                snk.setManagingComponent(managingTask);

                InputStream errPumpIn = snk;

                Reader reader = new InputStreamReader(errPumpIn, inputEncoding);

                if (errorFilterChains != null && errorFilterChains.size() > 0) {
                    ChainReaderHelper helper = new ChainReaderHelper();
                    helper.setProject(managingTask.getProject());
                    helper.setPrimaryReader(reader);
                    helper.setFilterChains(errorFilterChains);
                    reader = helper.getAssembledReader();
                }
                errPumpIn = new ReaderInputStream(reader, errorEncoding);

                Thread t = new Thread(threadGroup, new StreamPumper(
                    errPumpIn, errorStream, true), ""error pumper"");
                t.setPriority(Thread.MAX_PRIORITY);
                errorStream = new PipedOutputStream(snk);
                t.start();
            } catch (IOException eyeOhEx) {
                throw new BuildException(
                    ""error setting up error stream"", eyeOhEx);
            }
        }

        
        
        
        if (input != null && input.length > 0) {
            managingTask.log(""Redirecting input from file""
                + ((input.length == 1) ? """" : ""s""), Project.MSG_VERBOSE);
            try {
                inputStream = new ConcatFileInputStream(input);
            } catch (IOException eyeOhEx) {
                throw new BuildException(eyeOhEx);
            }
            ((ConcatFileInputStream) inputStream).setManagingComponent(managingTask);
        } else if (inputString != null) {
            StringBuffer buf = new StringBuffer(""Using input "");
            if (logInputString) {
                buf.append('""').append(inputString).append('""');
            } else {
                buf.append(""string"");
            }
            managingTask.log(buf.toString(), Project.MSG_VERBOSE);
            inputStream = new ByteArrayInputStream(inputString.getBytes());
        }

        if (inputStream != null
            && inputFilterChains != null && inputFilterChains.size() > 0) {
            ChainReaderHelper helper = new ChainReaderHelper();
            helper.setProject(managingTask.getProject());
            try {
                helper.setPrimaryReader(
                    new InputStreamReader(inputStream, inputEncoding));
            } catch (IOException eyeOhEx) {
                throw new BuildException(
                    ""error setting up input stream"", eyeOhEx);
            }
            helper.setFilterChains(inputFilterChains);
            inputStream = new ReaderInputStream(
                helper.getAssembledReader(), inputEncoding);
        }
    }

    
    public synchronized ExecuteStreamHandler createHandler()
        throws BuildException {
        createStreams();
        return new PumpStreamHandler(outputStream, errorStream, inputStream);
    }

    
    protected synchronized void handleOutput(String output) {
        if (outPrintStream == null) {
            outPrintStream = new PrintStream(outputStream);
        }
        outPrintStream.print(output);
    }

    
    protected synchronized int handleInput(byte[] buffer, int offset,
                                           int length) throws IOException {
        if (inputStream == null) {
            return managingTask.getProject().defaultInput(buffer, offset,
                                                          length);
        } else {
            return inputStream.read(buffer, offset, length);
        }
    }

    
    protected synchronized void handleFlush(String output) {
        if (outPrintStream == null) {
            outPrintStream = new PrintStream(outputStream);
        }
        outPrintStream.print(output);
        outPrintStream.flush();
    }

    
    protected synchronized void handleErrorOutput(String output) {
        if (errorPrintStream == null) {
            errorPrintStream = new PrintStream(errorStream);
        }
        errorPrintStream.print(output);
    }

    
    protected synchronized void handleErrorFlush(String output) {
        if (errorPrintStream == null) {
            errorPrintStream = new PrintStream(errorStream);
        }
        errorPrintStream.print(output);
    }

    
    public synchronized OutputStream getOutputStream() {
        return outputStream;
    }

    
    public synchronized OutputStream getErrorStream() {
        return errorStream;
    }

    
    public synchronized InputStream getInputStream() {
        return inputStream;
    }

    
    public synchronized void complete() throws IOException {
        System.out.flush();
        System.err.flush();

        if (inputStream != null) {
            inputStream.close();
        }

        outputStream.flush();
        outputStream.close();

        errorStream.flush();
        errorStream.close();

        
        while (threadGroup.activeCount() > 0) {
            try {
                managingTask.log(""waiting for "" + threadGroup.activeCount()
                    + "" Threads:"", Project.MSG_DEBUG);
                Thread[] thread = new Thread[threadGroup.activeCount()];
                threadGroup.enumerate(thread);
                for (int i = 0; i < thread.length && thread[i] != null; i++) {
                    try {
                        managingTask.log(thread[i].toString(), Project.MSG_DEBUG);
                    } catch (NullPointerException enPeaEx) {
                        
                    }
                }
                wait(1000);
            } catch (InterruptedException eyeEx) {
                
            }
        }

        setProperties();

        inputStream = null;
        outputStream = null;
        errorStream = null;
        outPrintStream = null;
        errorPrintStream = null;
   }

    
    public synchronized void setProperties() {
        if (baos != null) {
            try {
                baos.close();
            } catch (IOException eyeOhEx) {
                
            }
        }
        if (errorBaos != null) {
            try {
                errorBaos.close();
            } catch (IOException eyeOhEx) {
                
            }
        }
    }

    private OutputStream foldFiles(File[] file, String logHead, int loglevel) {
        OutputStream result
            = new LazyFileOutputStream(file[0], append, createEmptyFiles);

        managingTask.log(logHead + file[0], loglevel);
        char[] c = new char[logHead.length()];
        Arrays.fill(c, ' ');
        String indent = new String(c);

        for (int i = 1; i < file.length; i++) {
            outputStream = new TeeOutputStream(outputStream,
                new LazyFileOutputStream(file[i], append, createEmptyFiles));
            managingTask.log(indent + file[i], loglevel);
        }
        return result;
    }
}
"
org.apache.tools.zip.ZipShort,10,1,0,8,11,15,8,0,10,0.333333333,121,1.0,0,0.0,0.4,1,1,11.0,4,1.0,1,"

package org.apache.tools.zip;


public final class ZipShort implements Cloneable {

    private int value;

    
    public ZipShort (int value) {
        this.value = value;
    }

    
    public ZipShort (byte[] bytes) {
        this(bytes, 0);
    }

    
    public ZipShort (byte[] bytes, int offset) {
        value = ZipShort.getValue(bytes, offset);
    }

    
    public byte[] getBytes() {
        byte[] result = new byte[2];
        result[0] = (byte) (value & 0xFF);
        result[1] = (byte) ((value & 0xFF00) >> 8);
        return result;
    }

    
    public int getValue() {
        return value;
    }

    
    public static byte[] getBytes(int value) {
        byte[] result = new byte[2];
        result[0] = (byte) (value & 0xFF);
        result[1] = (byte) ((value & 0xFF00) >> 8);
        return result;
    }

    
    public static int getValue(byte[] bytes, int offset) {
        int value = (bytes[offset + 1] << 8) & 0xFF00;
        value += (bytes[offset] & 0xFF);
        return value;
    }

    
    public static int getValue(byte[] bytes) {
        return getValue(bytes, 0);
    }

    
    public boolean equals(Object o) {
        if (o == null || !(o instanceof ZipShort)) {
            return false;
        }
        return value == ((ZipShort) o).getValue();
    }

    
    public int hashCode() {
        return value;
    }
}
"
org.apache.tools.ant.types.resources.FileResourceIterator,8,1,0,9,13,12,8,1,8,0.428571429,109,1.0,0,0.0,0.5,0,0,12.25,3,1.125,0,"
package org.apache.tools.ant.types.resources;

import java.io.File;
import java.util.Iterator;
import java.util.NoSuchElementException;


public class FileResourceIterator implements Iterator {
    private File basedir;
    private String[] files;
    private int pos = 0;

    
    public FileResourceIterator() {
    }

    
    public FileResourceIterator(File f) {
        basedir = f;
    }

    
    public FileResourceIterator(File f, String[] s) {
        this(f);
        addFiles(s);
    }

    
    public void addFiles(String[] s) {
        int start = (files == null) ? 0 : files.length;
        String[] newfiles = new String[start + s.length];
        if (start > 0) {
            System.arraycopy(files, 0, newfiles, 0, start);
        }
        files = newfiles;
        System.arraycopy(s, 0, files, start, s.length);
    }

    
    public boolean hasNext() {
        return pos < files.length;
    }

    
    public Object next() {
        return nextResource();
    }

    
    public void remove() {
        throw new UnsupportedOperationException();
    }

    
    public FileResource nextResource() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        return new FileResource(basedir, files[pos++]);
    }

}
"
org.apache.tools.ant.TaskContainer,1,1,0,14,1,0,13,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant;


public interface TaskContainer {
    
    void addTask(Task task);
}

"
org.apache.tools.ant.types.selectors.AndSelector,3,5,0,7,14,3,6,2,3,2.0,52,0.0,0,0.96875,0.555555556,1,1,16.33333333,3,1.6667,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.Enumeration;


public class AndSelector extends BaseSelectorContainer {

    
    public AndSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (hasSelectors()) {
            buf.append(""{andselect: "");
            buf.append(super.toString());
            buf.append(""}"");
        }
        return buf.toString();
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        validate();
        Enumeration e = selectorElements();
        boolean result;

        while (e.hasMoreElements()) {
            result = ((FileSelector) e.nextElement()).isSelected(basedir,
                    filename, file);
            if (!result) {
                return false;
            }
        }
        return true;
    }

}

"
org.apache.tools.ant.util.regexp.JakartaOroRegexp,3,2,0,10,16,3,0,10,2,2.0,105,0.0,0,0.8,0.666666667,0,0,34.0,2,1.0,0,"
package org.apache.tools.ant.util.regexp;

import org.apache.oro.text.regex.Perl5Substitution;
import org.apache.oro.text.regex.Substitution;
import org.apache.oro.text.regex.Util;
import org.apache.tools.ant.BuildException;




public class JakartaOroRegexp extends JakartaOroMatcher implements Regexp {

    
    public JakartaOroRegexp() {
        super();
    }

    
    public String substitute(String input, String argument, int options)
        throws BuildException {
        
        StringBuffer subst = new StringBuffer();
        for (int i = 0; i < argument.length(); i++) {
            char c = argument.charAt(i);
            if (c == '$') {
                subst.append('\\');
                subst.append('$');
            } else if (c == '\\') {
                if (++i < argument.length()) {
                    c = argument.charAt(i);
                    int value = Character.digit(c, 10);
                    if (value > -1) {
                        subst.append(""$"").append(value);
                    } else {
                        subst.append(c);
                    }
                } else {
                    
                    subst.append('\\');
                }
            } else {
                subst.append(c);
            }
        }


        
        Substitution s =
            new Perl5Substitution(subst.toString(),
                                  Perl5Substitution.INTERPOLATE_ALL);
        return Util.substitute(matcher,
                               getCompiledPattern(options),
                               s,
                               input,
                               getSubsOptions(options));
    }

    
    protected int getSubsOptions(int options) {
        boolean replaceAll = RegexpUtil.hasFlag(options, REPLACE_ALL);
        int subsOptions = 1;
        if (replaceAll) {
            subsOptions = Util.SUBSTITUTE_ALL;
        }
        return subsOptions;
    }

}
"
org.apache.tools.ant.taskdefs.compilers.CompilerAdapter,2,1,0,4,2,1,3,2,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.compilers;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.Javac;



public interface CompilerAdapter {

    
    void setJavac(Javac attributes);

    
    boolean execute() throws BuildException;
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.DotnetCompile,64,5,3,15,111,1836,3,12,38,0.945578231,888,1.0,1,0.58,0.12109375,2,3,12.546875,6,1.4844,0,"






package org.apache.tools.ant.taskdefs.optional.dotnet;



import java.io.File;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.EnumeratedAttribute;




public abstract class DotnetCompile
         extends DotnetBaseMatchingTask {

    
    private String references;

    
    private boolean includeDefaultReferences = true;

    
    private File win32icon;

    
    private File win32res;

    
    private boolean failOnError;

    
    private Path referenceFiles;

    
    private boolean optimize;

    
    
    protected Vector definitionList = new Vector();

    
    protected Vector resources = new Vector();

    

    protected String executable;

    protected static final String REFERENCE_OPTION = ""/reference:"";

    
    protected boolean debug;

    
    private int warnLevel;

    
    protected String mainClass;

    
    protected String extraOptions;

    
    protected String targetType;

    

    protected boolean utf8output = false;

    
    protected String additionalModules;
    
    protected Vector referenceFilesets = new Vector();

    
    private boolean useResponseFile = false;
    private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64;

    

    

    public DotnetCompile() {
        clear();
        setIncludes(getFilePattern());
    }

    
    public void clear() {
        targetType = null;
        win32icon = null;
        srcDir = null;
        mainClass = null;
        warnLevel = 3;
        optimize = false;
        debug = true;
        references = null;
        failOnError = true;
        additionalModules = null;
        includeDefaultReferences = true;
        extraOptions = null;
    }


    
    public void setReferences(String s) {
        references = s;
    }


    
    protected String getReferencesParameter() {
        
        if (notEmpty(references)) {
            if (isWindows) {
                return '\""' + REFERENCE_OPTION + references + '\""';
            } else {
                return REFERENCE_OPTION + references;
            }
        } else {
            return null;
        }
    }

    
    public void setReferenceFiles(Path path) {
        
        if (referenceFiles == null) {
            referenceFiles = new Path(this.getProject());
        }
        referenceFiles.append(path);
    }

    
    public void addReference(FileSet reference) {
        referenceFilesets.add(reference);
    }



    
    protected String getReferenceFilesParameter() {
        
        if (references == null) {
            return null;
        }
        
        
        

        
        if (references.length() == 0) {
            return null;
        }

        StringBuffer s = new StringBuffer(REFERENCE_OPTION);
        if (isWindows) {
            s.append('\""');
        }
        s.append(references);
        if (isWindows) {
            s.append('\""');
        }
        return s.toString();
    }


    
    public void setIncludeDefaultReferences(boolean f) {
        includeDefaultReferences = f;
    }


    
    public boolean getIncludeDefaultReferences() {
        return includeDefaultReferences;
    }


    
    protected String getIncludeDefaultReferencesParameter() {
        return ""/nostdlib"" + (includeDefaultReferences ? ""-"" : ""+"");
    }



    
    public void setOptimize(boolean f) {
        optimize = f;
    }


    
    public boolean getOptimize() {
        return optimize;
    }


    
    protected String getOptimizeParameter() {
        return ""/optimize"" + (optimize ? ""+"" : ""-"");
    }


    
    public void setDebug(boolean f) {
        debug = f;
    }


    
    public boolean getDebug() {
        return debug;
    }


    
    protected String getDebugParameter() {
        return ""/debug"" + (debug ? ""+"" : ""-"");
    }


    
    public void setWarnLevel(int warnLevel) {
        this.warnLevel = warnLevel;
    }


    
    public int getWarnLevel() {
        return warnLevel;
    }


    
    protected String getWarnLevelParameter() {
        return ""/warn:"" + warnLevel;
    }


    
    public void setMainClass(String mainClass) {
        this.mainClass = mainClass;
    }


    
    public String getMainClass() {
        return this.mainClass;
    }


    
    protected String getMainClassParameter() {
        if (mainClass != null && mainClass.length() != 0) {
            return ""/main:"" + mainClass;
        } else {
            return null;
        }
    }


    
    public void setExtraOptions(String extraOptions) {
        this.extraOptions = extraOptions;
    }


    
    public String getExtraOptions() {
        return this.extraOptions;
    }


    
    protected String getExtraOptionsParameter() {
        if (extraOptions != null && extraOptions.length() != 0) {
            return extraOptions;
        } else {
            return null;
        }
    }

    
    protected String[] getExtraOptionsParameters() {
        String extra = getExtraOptionsParameter();
        return extra == null ? null : Commandline.translateCommandline(extra);
    }

    
    public void setDestDir(File dirName) {
        log(""DestDir currently unused"", Project.MSG_WARN);
    }


    
    public void setTargetType(TargetTypes targetType) {
        this.targetType = targetType.getValue();
    }
    
    public void setTargetType(String ttype)
             throws BuildException {
        ttype = ttype.toLowerCase();
        if (ttype.equals(""exe"") || ttype.equals(""library"")
            || ttype.equals(""module"") || ttype.equals(""winexe"")) {
            targetType = ttype;
        } else {
            throw new BuildException(""targetType "" + ttype
                    + "" is not one of 'exe', 'module', 'winexe' or 'library'"");
        }
    }


    
    public String getTargetType() {
        return targetType;
    }


    
    protected String getTargetTypeParameter() {
        if (notEmpty(targetType)) {
            return ""/target:"" + targetType;
        } else {
            return null;
        }
    }


    
    public void setWin32Icon(File fileName) {
        win32icon = fileName;
    }


    
    protected String getWin32IconParameter() {
        if (win32icon != null) {
            return ""/win32icon:"" + win32icon.toString();
        } else {
            return null;
        }
    }


    
    public void setWin32Res(File fileName) {
        win32res = fileName;
    }

    
    public File getWin32Res() {
        return win32res;
    }


    
    protected String getWin32ResParameter() {
        if (win32res != null) {
            return ""/win32res:"" + win32res.toString();
        } else {
            return null;
        }
    }


    
    public void setUtf8Output(boolean enabled) {
        utf8output = enabled;
    }


    
    protected String getUtf8OutputParameter() {
        return utf8output ? ""/utf8output"" : null;
    }


    
    public void addDefine(DotnetDefine define) {
        definitionList.addElement(define);
    }


    
    protected String getDefinitionsParameter() throws BuildException {
        StringBuffer defines = new StringBuffer();
        Enumeration defEnum = definitionList.elements();
        boolean firstDefinition = true;
        while (defEnum.hasMoreElements()) {
            
            DotnetDefine define = (DotnetDefine) defEnum.nextElement();
            if (define.isSet(this)) {
                
                if (!firstDefinition) {
                    defines.append(getDefinitionsDelimiter());
                }
                defines.append(define.getValue(this));
                firstDefinition = false;
            }
        }
        if (defines.length() == 0) {
            return null;
        } else {
            return ""/d:"" + defines;
        }
    }


    
    public void setAdditionalModules(String params) {
        additionalModules = params;
    }


    
    protected String getAdditionalModulesParameter() {
        if (notEmpty(additionalModules)) {
            return ""/addmodule:"" + additionalModules;
        } else {
            return null;
        }
    }


    
    protected String getDestFileParameter() {
        if (outputFile != null) {
            return ""/out:"" + outputFile.toString();
        } else {
            return null;
        }
    }


    
    public void setFailOnError(boolean b) {
        failOnError = b;
    }


    
    public boolean getFailOnError() {
        return failOnError;
    }

    
    public void addResource(DotnetResource resource) {
        resources.add(resource);
    }

    
    protected String getExecutable() {
        return executable;
    }

    
    public void setExecutable(String executable) {
        this.executable = executable;
    }

    
    protected boolean notEmpty(String s) {
        return s != null && s.length() != 0;
    }

    
    protected void validate()
            throws BuildException {
        if (outputFile != null && outputFile.isDirectory()) {
            throw new BuildException(""destFile cannot be a directory"");
        }
        if (getExecutable() == null) {
            throw new BuildException(""There is no executable defined for this task"");
        }
    }

    
    public String getFilePattern() {
        return ""**
    public boolean isUseResponseFile() {
        return useResponseFile;
    }

    
    public void setUseResponseFile(boolean useResponseFile) {
        this.useResponseFile = useResponseFile;
    }

    
    public void execute()
             throws BuildException {
        log(""This task is deprecated and will be removed in a future version\n""
            + ""of Ant.  It is now part of the .NET Antlib:\n""
            + ""http:
            Project.MSG_WARN);

        validate();
        NetCommand command = createNetCommand();
        
        command.setAutomaticResponseFileThreshold(AUTOMATIC_RESPONSE_FILE_THRESHOLD);
        command.setUseResponseFile(useResponseFile);
        
        fillInSharedParameters(command);
        addResources(command);
        addCompilerSpecificOptions(command);
        int referencesOutOfDate
            = addReferenceFilesets(command, getOutputFileTimestamp());
        
        boolean forceBuild = referencesOutOfDate > 0;
        addFilesAndExecute(command, forceBuild);

    }

    
    public abstract String getReferenceDelimiter();

    
    public abstract String getFileExtension();


    
    protected void fillInSharedParameters(NetCommand command) {
        command.setFailOnError(getFailOnError());
        
        command.addArgument(""/nologo"");
        command.addArgument(getAdditionalModulesParameter());
        command.addArgument(getDebugParameter());
        command.addArgument(getDefinitionsParameter());
        command.addArguments(getExtraOptionsParameters());
        command.addArgument(getMainClassParameter());
        command.addArgument(getOptimizeParameter());
        command.addArgument(getDestFileParameter());
        command.addArgument(getReferencesParameter());
        command.addArgument(getTargetTypeParameter());
        command.addArgument(getUtf8OutputParameter());
        command.addArgument(getWin32IconParameter());
        command.addArgument(getWin32ResParameter());
    }

    
    protected void addResources(NetCommand command) {
        Enumeration e = resources.elements();
        while (e.hasMoreElements()) {
            DotnetResource resource = (DotnetResource) e.nextElement();
            createResourceParameter(command, resource);
        }
    }

    
    protected abstract void createResourceParameter(NetCommand command, DotnetResource resource);


    

    protected int addReferenceFilesets(NetCommand command, long outputTimestamp) {
        int filesOutOfDate = 0;
        Hashtable filesToBuild = new Hashtable();
        for (int i = 0; i < referenceFilesets.size(); i++) {
            FileSet fs = (FileSet) referenceFilesets.elementAt(i);
            filesOutOfDate += command.scanOneFileset(
                    fs.getDirectoryScanner(getProject()),
                    filesToBuild,
                    outputTimestamp);
        }
        
        if (filesToBuild.size() == 0) {
            return 0;
        }
        
        Enumeration files = filesToBuild.elements();
        while (files.hasMoreElements()) {
            File file = (File) files.nextElement();
            if (isFileManagedBinary(file)) {
                if (isWindows) {
                    command.addArgument(
                    '""' + REFERENCE_OPTION + file.toString() + '""');
                } else {
                    command.addArgument(REFERENCE_OPTION + file.toString());
                }
            } else {
                log(""ignoring "" + file + "" as it is not a managed executable"",
                        Project.MSG_VERBOSE);
            }

        }

        return filesOutOfDate;
    }

    
    protected NetCommand createNetCommand() {
        NetCommand command = new NetCommand(this, getTaskName(), getExecutable());
        return command;
    }

    
    protected abstract void addCompilerSpecificOptions(NetCommand command);

    
    public String getDefinitionsDelimiter() {
        return "";"";
    }


    
    protected static boolean isFileManagedBinary(File file) {
        String filename = file.toString().toLowerCase();
        return filename.endsWith("".exe"") || filename.endsWith("".dll"")
                || filename.endsWith("".netmodule"");
    }

    
    public static class TargetTypes extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[] {
                ""exe"",
                ""library"",
                ""module"",
                ""winexe""
            };
        }
    }


}


"
org.apache.tools.ant.taskdefs.optional.junit.PlainJUnitResultFormatter,12,1,0,9,46,34,0,9,11,0.715909091,386,1.0,0,0.0,0.333333333,0,0,30.5,3,1.1667,0,"

package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.NumberFormat;
import java.util.Hashtable;

import junit.framework.AssertionFailedError;
import junit.framework.Test;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;




public class PlainJUnitResultFormatter implements JUnitResultFormatter {

    
    private NumberFormat nf = NumberFormat.getInstance();
    
    private Hashtable testStarts = new Hashtable();
    
    private OutputStream out;
    
    private StringWriter inner;
    
    private PrintWriter wri;
    
    private Hashtable failed = new Hashtable();

    private String systemOutput = null;
    private String systemError = null;

    
    public PlainJUnitResultFormatter() {
        inner = new StringWriter();
        wri = new PrintWriter(inner);
    }

    
    public void setOutput(OutputStream out) {
        this.out = out;
    }

    
    public void setSystemOutput(String out) {
        systemOutput = out;
    }

    
    public void setSystemError(String err) {
        systemError = err;
    }

    
    public void startTestSuite(JUnitTest suite) throws BuildException {
        if (out == null) {
            return; 
        }
        StringBuffer sb = new StringBuffer(""Testsuite: "");
        sb.append(suite.getName());
        sb.append(StringUtils.LINE_SEP);
        try {
            out.write(sb.toString().getBytes());
            out.flush();
        } catch (IOException ex) {
            throw new BuildException(""Unable to write output"", ex);
        }
    }

    
    public void endTestSuite(JUnitTest suite) throws BuildException {
        StringBuffer sb = new StringBuffer(""Tests run: "");
        sb.append(suite.runCount());
        sb.append("", Failures: "");
        sb.append(suite.failureCount());
        sb.append("", Errors: "");
        sb.append(suite.errorCount());
        sb.append("", Time elapsed: "");
        sb.append(nf.format(suite.getRunTime() / 1000.0));
        sb.append("" sec"");
        sb.append(StringUtils.LINE_SEP);

        
        if (systemOutput != null && systemOutput.length() > 0) {
            sb.append(""------------- Standard Output ---------------"")
                .append(StringUtils.LINE_SEP)
                .append(systemOutput)
                .append(""------------- ---------------- ---------------"")
                .append(StringUtils.LINE_SEP);
        }

        if (systemError != null && systemError.length() > 0) {
            sb.append(""------------- Standard Error -----------------"")
                .append(StringUtils.LINE_SEP)
                .append(systemError)
                .append(""------------- ---------------- ---------------"")
                .append(StringUtils.LINE_SEP);
        }

        sb.append(StringUtils.LINE_SEP);

        if (out != null) {
            try {
                out.write(sb.toString().getBytes());
                wri.close();
                out.write(inner.toString().getBytes());
                out.flush();
            } catch (IOException ioex) {
                throw new BuildException(""Unable to write output"", ioex);
            } finally {
                if (out != System.out && out != System.err) {
                    FileUtils.close(out);
                }
            }
        }
    }

    
    public void startTest(Test t) {
        testStarts.put(t, new Long(System.currentTimeMillis()));
        failed.put(t, Boolean.FALSE);
    }

    
    public void endTest(Test test) {
        if (Boolean.TRUE.equals(failed.get(test))) {
            return;
        }
        synchronized (wri) {
            wri.print(""Testcase: ""
                      + JUnitVersionHelper.getTestCaseName(test));
            Long l = (Long) testStarts.get(test);
            double seconds = 0;
            
            if (l != null) {
                seconds =
                    (System.currentTimeMillis() - l.longValue()) / 1000.0;
            }

            wri.println("" took "" + nf.format(seconds) + "" sec"");
        }
    }

    
    public void addFailure(Test test, Throwable t) {
        formatError(""\tFAILED"", test, t);
    }

    
    public void addFailure(Test test, AssertionFailedError t) {
        addFailure(test, (Throwable) t);
    }

    
    public void addError(Test test, Throwable t) {
        formatError(""\tCaused an ERROR"", test, t);
    }

    private void formatError(String type, Test test, Throwable t) {
        synchronized (wri) {
            if (test != null) {
                endTest(test);
                failed.put(test, Boolean.TRUE);
            }

            wri.println(type);
            wri.println(t.getMessage());
            String strace = JUnitTestRunner.getFilteredTrace(t);
            wri.print(strace);
            wri.println("""");
        }
    }

} 
"
org.apache.tools.ant.taskdefs.Sequential,3,3,0,3,10,0,0,3,3,0.0,32,1.0,0,0.948717949,0.666666667,0,0,9.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs;

import java.util.Iterator;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskContainer;


public class Sequential extends Task implements TaskContainer {

    
    private Vector nestedTasks = new Vector();

    
    public void addTask(Task nestedTask) {
        nestedTasks.addElement(nestedTask);
    }

    
    public void execute() throws BuildException {
        for (Iterator i = nestedTasks.iterator(); i.hasNext();) {
            Task nestedTask = (Task) i.next();
            nestedTask.perform();
        }
    }
}
"
org.apache.tools.ant.types.AbstractFileSet,59,3,3,38,121,1145,9,29,57,0.728448276,1035,1.0,2,0.344827586,0.061743341,2,3,16.40677966,8,1.8475,3,"
package org.apache.tools.ant.types;

import java.io.File;
import java.util.Vector;
import java.util.Enumeration;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.FileScanner;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.selectors.OrSelector;
import org.apache.tools.ant.types.selectors.AndSelector;
import org.apache.tools.ant.types.selectors.NotSelector;
import org.apache.tools.ant.types.selectors.DateSelector;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.NoneSelector;
import org.apache.tools.ant.types.selectors.SizeSelector;
import org.apache.tools.ant.types.selectors.TypeSelector;
import org.apache.tools.ant.types.selectors.DepthSelector;
import org.apache.tools.ant.types.selectors.DependSelector;
import org.apache.tools.ant.types.selectors.ExtendSelector;
import org.apache.tools.ant.types.selectors.SelectSelector;
import org.apache.tools.ant.types.selectors.PresentSelector;
import org.apache.tools.ant.types.selectors.SelectorScanner;
import org.apache.tools.ant.types.selectors.ContainsSelector;
import org.apache.tools.ant.types.selectors.FilenameSelector;
import org.apache.tools.ant.types.selectors.MajoritySelector;
import org.apache.tools.ant.types.selectors.DifferentSelector;
import org.apache.tools.ant.types.selectors.SelectorContainer;
import org.apache.tools.ant.types.selectors.ContainsRegexpSelector;
import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;


public abstract class AbstractFileSet extends DataType
    implements Cloneable, SelectorContainer {

    private PatternSet defaultPatterns = new PatternSet();
    private Vector additionalPatterns = new Vector();
    private Vector selectors = new Vector();

    private File dir;
    private boolean useDefaultExcludes = true;
    private boolean caseSensitive = true;
    private boolean followSymlinks = true;

    
    private DirectoryScanner directoryScanner = null;

    
    public AbstractFileSet() {
        super();
    }

    
    protected AbstractFileSet(AbstractFileSet fileset) {
        this.dir = fileset.dir;
        this.defaultPatterns = fileset.defaultPatterns;
        this.additionalPatterns = fileset.additionalPatterns;
        this.selectors = fileset.selectors;
        this.useDefaultExcludes = fileset.useDefaultExcludes;
        this.caseSensitive = fileset.caseSensitive;
        this.followSymlinks = fileset.followSymlinks;
        setProject(fileset.getProject());
    }

    
    public void setRefid(Reference r) throws BuildException {
        if (dir != null || defaultPatterns.hasPatterns(getProject())) {
            throw tooManyAttributes();
        }
        if (!additionalPatterns.isEmpty()) {
            throw noChildrenAllowed();
        }
        if (!selectors.isEmpty()) {
            throw noChildrenAllowed();
        }
        super.setRefid(r);
    }

    
    public synchronized void setDir(File dir) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.dir = dir;
        directoryScanner = null;
    }

    
    public File getDir() {
        return getDir(getProject());
    }

    
    public synchronized File getDir(Project p) {
        return (isReference()) ? getRef(p).getDir(p) : dir;
    }

    
    public synchronized PatternSet createPatternSet() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        PatternSet patterns = new PatternSet();
        additionalPatterns.addElement(patterns);
        directoryScanner = null;
        return patterns;
    }

    
    public synchronized PatternSet.NameEntry createInclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        directoryScanner = null;
        return defaultPatterns.createInclude();
    }

    
    public synchronized PatternSet.NameEntry createIncludesFile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        directoryScanner = null;
        return defaultPatterns.createIncludesFile();
    }

    
    public synchronized PatternSet.NameEntry createExclude() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        directoryScanner = null;
        return defaultPatterns.createExclude();
    }

    
    public synchronized PatternSet.NameEntry createExcludesFile() {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        directoryScanner = null;
        return defaultPatterns.createExcludesFile();
    }

    
    public synchronized void setFile(File file) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        setDir(file.getParentFile());
        createInclude().setName(file.getName());
    }

    
    public synchronized void setIncludes(String includes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        defaultPatterns.setIncludes(includes);
        directoryScanner = null;
    }

    
    public synchronized void appendIncludes(String[] includes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (includes != null) {
            for (int i = 0; i < includes.length; i++) {
                defaultPatterns.createInclude().setName(includes[i]);
            }
            directoryScanner = null;
        }
    }

    
    public synchronized void setExcludes(String excludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        defaultPatterns.setExcludes(excludes);
        directoryScanner = null;
    }

    
    public synchronized void appendExcludes(String[] excludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        if (excludes != null) {
            for (int i = 0; i < excludes.length; i++) {
                defaultPatterns.createExclude().setName(excludes[i]);
            }
            directoryScanner = null;
        }
    }

    
    public synchronized void setIncludesfile(File incl) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        defaultPatterns.setIncludesfile(incl);
        directoryScanner = null;
    }

    
    public synchronized void setExcludesfile(File excl) throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
        defaultPatterns.setExcludesfile(excl);
        directoryScanner = null;
    }

    
    public synchronized void setDefaultexcludes(boolean useDefaultExcludes) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.useDefaultExcludes = useDefaultExcludes;
        directoryScanner = null;
    }

    
    public synchronized boolean getDefaultexcludes() {
        return (isReference())
            ? getRef(getProject()).getDefaultexcludes() : useDefaultExcludes;
    }

    
    public synchronized void setCaseSensitive(boolean caseSensitive) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.caseSensitive = caseSensitive;
        directoryScanner = null;
    }

    
    public synchronized boolean isCaseSensitive() {
        return (isReference())
            ? getRef(getProject()).isCaseSensitive() : caseSensitive;
    }

    
    public synchronized void setFollowSymlinks(boolean followSymlinks) {
        if (isReference()) {
            throw tooManyAttributes();
        }
        this.followSymlinks = followSymlinks;
        directoryScanner = null;
    }

    
    public synchronized boolean isFollowSymlinks() {
        return (isReference())
            ? getRef(getProject()).isFollowSymlinks() : followSymlinks;
    }

    
    public DirectoryScanner getDirectoryScanner() {
        return getDirectoryScanner(getProject());
    }

    
    public DirectoryScanner getDirectoryScanner(Project p) {
        if (isReference()) {
            return getRef(p).getDirectoryScanner(p);
        }
        DirectoryScanner ds = null;
        synchronized (this) {
            if (directoryScanner != null && p == getProject()) {
                ds = directoryScanner;
            } else {
                if (dir == null) {
                    throw new BuildException(""No directory specified for ""
                                             + getDataTypeName() + ""."");
                }
                if (!dir.exists()) {
                    throw new BuildException(dir.getAbsolutePath()
                                             + "" not found."");
                }
                if (!dir.isDirectory()) {
                    throw new BuildException(dir.getAbsolutePath()
                                             + "" is not a directory."");
                }
                ds = new DirectoryScanner();
                setupDirectoryScanner(ds, p);
                ds.setFollowSymlinks(followSymlinks);
                directoryScanner = (p == getProject()) ? ds : directoryScanner;
            }
        }
        ds.scan();
        return ds;
    }

    
    public void setupDirectoryScanner(FileScanner ds) {
        setupDirectoryScanner(ds, getProject());
    }

    
    public synchronized void setupDirectoryScanner(FileScanner ds, Project p) {
        if (isReference()) {
            getRef(p).setupDirectoryScanner(ds, p);
            return;
        }
        if (ds == null) {
            throw new IllegalArgumentException(""ds cannot be null"");
        }
        ds.setBasedir(dir);

        PatternSet ps = mergePatterns(p);
        p.log(getDataTypeName() + "": Setup scanner in dir "" + dir
            + "" with "" + ps, Project.MSG_DEBUG);

        ds.setIncludes(ps.getIncludePatterns(p));
        ds.setExcludes(ps.getExcludePatterns(p));
        if (ds instanceof SelectorScanner) {
            SelectorScanner ss = (SelectorScanner) ds;
            ss.setSelectors(getSelectors(p));
        }
        if (useDefaultExcludes) {
            ds.addDefaultExcludes();
        }
        ds.setCaseSensitive(caseSensitive);
    }

    
    protected AbstractFileSet getRef(Project p) {
        return (AbstractFileSet) getCheckedRef(p);
    }

    

    
    public synchronized boolean hasSelectors() {
        return (isReference() && getProject() != null)
            ? getRef(getProject()).hasSelectors() : !(selectors.isEmpty());
    }

    
    public synchronized boolean hasPatterns() {
        if (isReference() && getProject() != null) {
            return getRef(getProject()).hasPatterns();
        }
        if (defaultPatterns.hasPatterns(getProject())) {
            return true;
        }
        Enumeration e = additionalPatterns.elements();
        while (e.hasMoreElements()) {
            PatternSet ps = (PatternSet) e.nextElement();
            if (ps.hasPatterns(getProject())) {
                return true;
            }
        }
        return false;
    }

    
    public synchronized int selectorCount() {
        return (isReference() && getProject() != null)
            ? getRef(getProject()).selectorCount() : selectors.size();
    }

    
    public synchronized FileSelector[] getSelectors(Project p) {
        return (isReference())
            ? getRef(p).getSelectors(p) : (FileSelector[]) (selectors.toArray(
            new FileSelector[selectors.size()]));
    }

    
    public synchronized Enumeration selectorElements() {
        return (isReference() && getProject() != null)
            ? getRef(getProject()).selectorElements() : selectors.elements();
    }

    
    public synchronized void appendSelector(FileSelector selector) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        selectors.addElement(selector);
        directoryScanner = null;
    }

    

    
    public void addSelector(SelectSelector selector) {
        appendSelector(selector);
    }

    
    public void addAnd(AndSelector selector) {
        appendSelector(selector);
    }

    
    public void addOr(OrSelector selector) {
        appendSelector(selector);
    }

    
    public void addNot(NotSelector selector) {
        appendSelector(selector);
    }

    
    public void addNone(NoneSelector selector) {
        appendSelector(selector);
    }

    
    public void addMajority(MajoritySelector selector) {
        appendSelector(selector);
    }

    
    public void addDate(DateSelector selector) {
        appendSelector(selector);
    }

    
    public void addSize(SizeSelector selector) {
        appendSelector(selector);
    }

    
    public void addDifferent(DifferentSelector selector) {
        appendSelector(selector);
    }

    
    public void addFilename(FilenameSelector selector) {
        appendSelector(selector);
    }

    
    public void addType(TypeSelector selector) {
        appendSelector(selector);
    }

    
    public void addCustom(ExtendSelector selector) {
        appendSelector(selector);
    }

    
    public void addContains(ContainsSelector selector) {
        appendSelector(selector);
    }

    
    public void addPresent(PresentSelector selector) {
        appendSelector(selector);
    }

    
    public void addDepth(DepthSelector selector) {
        appendSelector(selector);
    }

    
    public void addDepend(DependSelector selector) {
        appendSelector(selector);
    }

    
    public void addContainsRegexp(ContainsRegexpSelector selector) {
        appendSelector(selector);
    }

    
    public void addModified(ModifiedSelector selector) {
        appendSelector(selector);
    }

    
    public void add(FileSelector selector) {
        appendSelector(selector);
    }

    
    public String toString() {
        DirectoryScanner ds = getDirectoryScanner(getProject());
        String[] files = ds.getIncludedFiles();
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < files.length; i++) {
            if (i > 0) {
                sb.append(';');
            }
            sb.append(files[i]);
        }
        return sb.toString();
    }

    
    public synchronized Object clone() {
        if (isReference()) {
            return (getRef(getProject())).clone();
        } else {
            try {
                AbstractFileSet fs = (AbstractFileSet) super.clone();
                fs.defaultPatterns = (PatternSet) defaultPatterns.clone();
                fs.additionalPatterns = new Vector(additionalPatterns.size());
                Enumeration e = additionalPatterns.elements();
                while (e.hasMoreElements()) {
                    fs.additionalPatterns
                        .addElement(((PatternSet) e.nextElement()).clone());
                }
                fs.selectors = new Vector(selectors);
                return fs;
            } catch (CloneNotSupportedException e) {
                throw new BuildException(e);
            }
        }
    }

    
    public String[] mergeIncludes(Project p) {
        return mergePatterns(p).getIncludePatterns(p);
    }

    
    public String[] mergeExcludes(Project p) {
        return mergePatterns(p).getExcludePatterns(p);
    }

    
    public synchronized PatternSet mergePatterns(Project p) {
        if (isReference()) {
            return getRef(p).mergePatterns(p);
        }
        PatternSet ps = (PatternSet) defaultPatterns.clone();
        final int count = additionalPatterns.size();
        for (int i = 0; i < count; i++) {
            Object o = additionalPatterns.elementAt(i);
            ps.append((PatternSet) o, p);
        }
        return ps;
    }

}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.InterfaceMethodRefCPInfo,7,2,0,4,21,3,2,4,7,0.666666667,108,1.0,0,0.5,0.428571429,1,1,13.71428571,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class InterfaceMethodRefCPInfo extends ConstantPoolEntry {
    
    private String interfaceMethodClassName;
    
    private String interfaceMethodName;
    
    private String interfaceMethodType;
    
    private int classIndex;
    
    private int nameAndTypeIndex;

    
    public InterfaceMethodRefCPInfo() {
        super(CONSTANT_INTERFACEMETHODREF, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        classIndex = cpStream.readUnsignedShort();
        nameAndTypeIndex = cpStream.readUnsignedShort();
    }

    
    public void resolve(ConstantPool constantPool) {
        ClassCPInfo interfaceMethodClass
             = (ClassCPInfo) constantPool.getEntry(classIndex);

        interfaceMethodClass.resolve(constantPool);

        interfaceMethodClassName = interfaceMethodClass.getClassName();

        NameAndTypeCPInfo nt
             = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);

        nt.resolve(constantPool);

        interfaceMethodName = nt.getName();
        interfaceMethodType = nt.getType();

        super.resolve(constantPool);
    }

    
    public String toString() {
        String value;

        if (isResolved()) {
            value = ""InterfaceMethod : Class = "" + interfaceMethodClassName
                 + "", name = "" + interfaceMethodName + "", type = ""
                 + interfaceMethodType;
        } else {
            value = ""InterfaceMethod : Class index = "" + classIndex
                 + "", name and type index = "" + nameAndTypeIndex;
        }

        return value;
    }

    
    public String getInterfaceMethodClassName() {
        return interfaceMethodClassName;
    }

    
    public String getInterfaceMethodName() {
        return interfaceMethodName;
    }

    
    public String getInterfaceMethodType() {
        return interfaceMethodType;
    }

}

"
org.apache.tools.ant.FileScanner,14,1,0,5,14,91,5,0,14,2.0,14,0.0,0,0.0,0.271428571,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant;

import java.io.File;


public interface FileScanner {
    
    void addDefaultExcludes();

    
    File getBasedir();

    
    String[] getExcludedDirectories();

    
    String[] getExcludedFiles();

    
    String[] getIncludedDirectories();

    
    String[] getIncludedFiles();

    
    String[] getNotIncludedDirectories();

    
    String[] getNotIncludedFiles();

    
    void scan() throws IllegalStateException;

    
    void setBasedir(String basedir);

    
    void setBasedir(File basedir);

    
    void setExcludes(String[] excludes);

    
    void setIncludes(String[] includes);

    
    void setCaseSensitive(boolean isCaseSensitive);
}
"
org.apache.tools.ant.taskdefs.optional.ejb.EJBDeploymentTool,4,1,0,5,4,6,2,3,4,2.0,4,0.0,0,0.0,0.4,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.ejb;



import javax.xml.parsers.SAXParser;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;



public interface EJBDeploymentTool {
    
    void processDescriptor(String descriptorFilename, SAXParser saxParser)
        throws BuildException;

    
    void validateConfigured() throws BuildException;

    
    void setTask(Task task);

    
    void configure(EjbJar.Config config);
}
"
org.apache.tools.ant.taskdefs.optional.extension.JarLibManifestTask,13,3,0,7,52,48,0,7,7,0.892857143,355,1.0,1,0.755102041,0.195804196,1,1,25.76923077,2,1.0769,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;


public final class JarLibManifestTask extends Task {
    
    private static final String MANIFEST_VERSION = ""1.0"";

    
    private static final String CREATED_BY = ""Created-By"";

    
    private File destFile;

    
    private Extension extension;

    
    private final ArrayList dependencies = new ArrayList();

    
    private final ArrayList optionals = new ArrayList();

    
    private final ArrayList extraAttributes = new ArrayList();

    
    public void setDestfile(final File destFile) {
        this.destFile = destFile;
    }

    
    public void addConfiguredExtension(final ExtensionAdapter extensionAdapter)
        throws BuildException {
        if (null != extension) {
            final String message =
                ""Can not have multiple extensions defined in one library."";
            throw new BuildException(message);
        }
        extension = extensionAdapter.toExtension();
    }

    
    public void addConfiguredDepends(final ExtensionSet extensionSet) {
        dependencies.add(extensionSet);
    }

    
    public void addConfiguredOptions(final ExtensionSet extensionSet) {
        optionals.add(extensionSet);
    }

    
    public void addConfiguredAttribute(final ExtraAttribute attribute) {
        extraAttributes.add(attribute);
    }

    
    public void execute() throws BuildException {
        validate();

        final Manifest manifest = new Manifest();
        final Attributes attributes = manifest.getMainAttributes();

        attributes.put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION);
        final String createdBy = ""Apache Ant "" + getProject().getProperty(MagicNames.ANT_VERSION);
        attributes.putValue(CREATED_BY, createdBy);

        appendExtraAttributes(attributes);

        if (null != extension) {
            Extension.addExtension(extension, attributes);
        }

        
        final ArrayList depends = toExtensions(dependencies);
        appendExtensionList(attributes,
                             Extension.EXTENSION_LIST,
                             ""lib"",
                             depends.size());
        appendLibraryList(attributes, ""lib"", depends);

        
        
        final ArrayList option = toExtensions(optionals);
        appendExtensionList(attributes,
                             Extension.OPTIONAL_EXTENSION_LIST,
                             ""opt"",
                             option.size());
        appendLibraryList(attributes, ""opt"", option);

        try {
            final String message = ""Generating manifest "" + destFile.getAbsoluteFile();
            log(message, Project.MSG_INFO);
            writeManifest(manifest);
        } catch (final IOException ioe) {
            throw new BuildException(ioe.getMessage(), ioe);
        }
    }

    
    private void validate() throws BuildException {
        if (null == destFile) {
            final String message = ""Destfile attribute not specified."";
            throw new BuildException(message);
        }
        if (destFile.exists() && !destFile.isFile()) {
            final String message = destFile + "" is not a file."";
            throw new BuildException(message);
        }
    }

    
    private void appendExtraAttributes(final Attributes attributes) {
        final Iterator iterator = extraAttributes.iterator();
        while (iterator.hasNext()) {
            final ExtraAttribute attribute =
                (ExtraAttribute) iterator.next();
            attributes.putValue(attribute.getName(),
                                 attribute.getValue());
        }
    }

    
    private void writeManifest(final Manifest manifest)
        throws IOException {
        FileOutputStream output = null;
        try {
            output = new FileOutputStream(destFile);
            manifest.write(output);
            output.flush();
        } finally {
            if (null != output) {
                try {
                    output.close();
                } catch (IOException e) {
                    
                }
            }
        }
    }

    
    private void appendLibraryList(final Attributes attributes,
                                    final String listPrefix,
                                    final ArrayList extensions)
        throws BuildException {
        final int size = extensions.size();
        for (int i = 0; i < size; i++) {
            final Extension ext = (Extension) extensions.get(i);
            final String prefix = listPrefix + i + ""-"";
            Extension.addExtension(ext, prefix, attributes);
        }
    }

    
    private void appendExtensionList(final Attributes attributes,
                                      final Attributes.Name extensionKey,
                                      final String listPrefix,
                                      final int size) {
        final StringBuffer sb = new StringBuffer();
        for (int i = 0; i < size; i++) {
            sb.append(listPrefix);
            sb.append(i);
            sb.append(' ');
        }

        
        
        attributes.put(extensionKey, sb.toString());
    }

    
    private ArrayList toExtensions(final ArrayList extensionSets)
        throws BuildException {
        final ArrayList results = new ArrayList();

        final int size = extensionSets.size();
        for (int i = 0; i < size; i++) {
            final ExtensionSet set = (ExtensionSet) extensionSets.get(i);
            final Extension[] extensions = set.toExtensions(getProject());
            for (int j = 0; j < extensions.length; j++) {
                results.add(extensions[ j ]);
            }
        }

        return results;
    }
}
"
org.apache.tools.ant.taskdefs.optional.extension.Extension,23,1,0,15,56,191,11,4,16,0.807359307,850,0.333333333,7,0.0,0.1875,0,0,35.04347826,11,2.4783,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

import org.apache.tools.ant.util.StringUtils;


public final class Extension {
    
    public static final Attributes.Name EXTENSION_LIST
        = new Attributes.Name(""Extension-List"");

    
    public static final Attributes.Name OPTIONAL_EXTENSION_LIST
        = new Attributes.Name(""Optional-Extension-List"");

    
    public static final Attributes.Name EXTENSION_NAME =
        new Attributes.Name(""Extension-Name"");
    
    public static final Attributes.Name SPECIFICATION_VERSION
        = Attributes.Name.SPECIFICATION_VERSION;

    
    public static final Attributes.Name SPECIFICATION_VENDOR
        = Attributes.Name.SPECIFICATION_VENDOR;

    
    public static final Attributes.Name IMPLEMENTATION_VERSION
        = Attributes.Name.IMPLEMENTATION_VERSION;

    
    public static final Attributes.Name IMPLEMENTATION_VENDOR
        = Attributes.Name.IMPLEMENTATION_VENDOR;

    
    public static final Attributes.Name IMPLEMENTATION_URL
        = new Attributes.Name(""Implementation-URL"");

    
    public static final Attributes.Name IMPLEMENTATION_VENDOR_ID
        = new Attributes.Name(""Implementation-Vendor-Id"");

    
    public static final Compatibility COMPATIBLE
        = new Compatibility(""COMPATIBLE"");

    
    public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE
        = new Compatibility(""REQUIRE_SPECIFICATION_UPGRADE"");

    
    public static final Compatibility REQUIRE_VENDOR_SWITCH
        = new Compatibility(""REQUIRE_VENDOR_SWITCH"");

    
    public static final Compatibility REQUIRE_IMPLEMENTATION_UPGRADE
        = new Compatibility(""REQUIRE_IMPLEMENTATION_UPGRADE"");

    
    public static final Compatibility INCOMPATIBLE
        = new Compatibility(""INCOMPATIBLE"");

    
    private String extensionName;

    
    private DeweyDecimal specificationVersion;

    
    private String specificationVendor;

    
    private String implementationVendorID;

    
    private String implementationVendor;

    
    private DeweyDecimal implementationVersion;

    
    private String implementationURL;

    
    public static Extension[] getAvailable(final Manifest manifest) {
        if (null == manifest) {
            return new Extension[ 0 ];
        }

        final ArrayList results = new ArrayList();

        final Attributes mainAttributes = manifest.getMainAttributes();
        if (null != mainAttributes) {
            final Extension extension = getExtension("""", mainAttributes);
            if (null != extension) {
                results.add(extension);
            }
        }

        final Map entries = manifest.getEntries();
        final Iterator keys = entries.keySet().iterator();
        while (keys.hasNext()) {
            final String key = (String) keys.next();
            final Attributes attributes = (Attributes) entries.get(key);
            final Extension extension = getExtension("""", attributes);
            if (null != extension) {
                results.add(extension);
            }
        }

        return (Extension[]) results.toArray(new Extension[results.size()]);
    }

    
    public static Extension[] getRequired(final Manifest manifest) {
        return getListed(manifest, Attributes.Name.EXTENSION_LIST);
    }

    
    public static Extension[] getOptions(final Manifest manifest) {
        return getListed(manifest, OPTIONAL_EXTENSION_LIST);
    }

    
    public static void addExtension(final Extension extension,
                                     final Attributes attributes) {
        addExtension(extension, """", attributes);
    }

    
    public static void addExtension(final Extension extension,
                                     final String prefix,
                                     final Attributes attributes) {
        attributes.putValue(prefix + EXTENSION_NAME,
                             extension.getExtensionName());

        final String specificationVendor = extension.getSpecificationVendor();
        if (null != specificationVendor) {
            attributes.putValue(prefix + SPECIFICATION_VENDOR,
                                 specificationVendor);
        }

        final DeweyDecimal specificationVersion
            = extension.getSpecificationVersion();
        if (null != specificationVersion) {
            attributes.putValue(prefix + SPECIFICATION_VERSION,
                                 specificationVersion.toString());
        }

        final String implementationVendorID
            = extension.getImplementationVendorID();
        if (null != implementationVendorID) {
            attributes.putValue(prefix + IMPLEMENTATION_VENDOR_ID,
                                 implementationVendorID);
        }

        final String implementationVendor = extension.getImplementationVendor();
        if (null != implementationVendor) {
            attributes.putValue(prefix + IMPLEMENTATION_VENDOR,
                                 implementationVendor);
        }

        final DeweyDecimal implementationVersion
            = extension.getImplementationVersion();
        if (null != implementationVersion) {
            attributes.putValue(prefix + IMPLEMENTATION_VERSION,
                                 implementationVersion.toString());
        }

        final String implementationURL = extension.getImplementationURL();
        if (null != implementationURL) {
            attributes.putValue(prefix + IMPLEMENTATION_URL,
                                 implementationURL);
        }
    }

    
    public Extension(final String extensionName,
                      final String specificationVersion,
                      final String specificationVendor,
                      final String implementationVersion,
                      final String implementationVendor,
                      final String implementationVendorId,
                      final String implementationURL) {
        this.extensionName = extensionName;
        this.specificationVendor = specificationVendor;

        if (null != specificationVersion) {
            try {
                this.specificationVersion
                    = new DeweyDecimal(specificationVersion);
            } catch (final NumberFormatException nfe) {
                final String error = ""Bad specification version format '""
                    + specificationVersion + ""' in '"" + extensionName
                    + ""'. (Reason: "" + nfe + "")"";
                throw new IllegalArgumentException(error);
            }
        }

        this.implementationURL = implementationURL;
        this.implementationVendor = implementationVendor;
        this.implementationVendorID = implementationVendorId;

        if (null != implementationVersion) {
            try {
                this.implementationVersion
                    = new DeweyDecimal(implementationVersion);
            } catch (final NumberFormatException nfe) {
                final String error = ""Bad implementation version format '""
                    + implementationVersion + ""' in '"" + extensionName
                    + ""'. (Reason: "" + nfe + "")"";
                throw new IllegalArgumentException(error);
            }
        }

        if (null == this.extensionName) {
            throw new NullPointerException(""extensionName property is null"");
        }
    }

    
    public String getExtensionName() {
        return extensionName;
    }

    
    public String getSpecificationVendor() {
        return specificationVendor;
    }

    
    public DeweyDecimal getSpecificationVersion() {
        return specificationVersion;
    }

    
    public String getImplementationURL() {
        return implementationURL;
    }

    
    public String getImplementationVendor() {
        return implementationVendor;
    }

    
    public String getImplementationVendorID() {
        return implementationVendorID;
    }

    
    public DeweyDecimal getImplementationVersion() {
        return implementationVersion;
    }

    
    public Compatibility getCompatibilityWith(final Extension required) {
        
        if (!extensionName.equals(required.getExtensionName())) {
            return INCOMPATIBLE;
        }

        
        final DeweyDecimal requiredSpecificationVersion
            = required.getSpecificationVersion();
        if (null != requiredSpecificationVersion) {
            if (null == specificationVersion
                || !isCompatible(specificationVersion, requiredSpecificationVersion)) {
                return REQUIRE_SPECIFICATION_UPGRADE;
            }
        }

        
        final String requiredImplementationVendorID
            = required.getImplementationVendorID();
        if (null != requiredImplementationVendorID) {
            if (null == implementationVendorID
                || !implementationVendorID.equals(requiredImplementationVendorID)) {
                return REQUIRE_VENDOR_SWITCH;
            }
        }

        
        final DeweyDecimal requiredImplementationVersion
            = required.getImplementationVersion();
        if (null != requiredImplementationVersion) {
            if (null == implementationVersion
                || !isCompatible(implementationVersion, requiredImplementationVersion)) {
                return REQUIRE_IMPLEMENTATION_UPGRADE;
            }
        }

        
        return COMPATIBLE;
    }

    
    public boolean isCompatibleWith(final Extension required) {
        return (COMPATIBLE == getCompatibilityWith(required));
    }

    
    public String toString() {
        final String brace = "": "";

        final StringBuffer sb = new StringBuffer(EXTENSION_NAME.toString());
        sb.append(brace);
        sb.append(extensionName);
        sb.append(StringUtils.LINE_SEP);

        if (null != specificationVersion) {
            sb.append(SPECIFICATION_VERSION);
            sb.append(brace);
            sb.append(specificationVersion);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != specificationVendor) {
            sb.append(SPECIFICATION_VENDOR);
            sb.append(brace);
            sb.append(specificationVendor);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationVersion) {
            sb.append(IMPLEMENTATION_VERSION);
            sb.append(brace);
            sb.append(implementationVersion);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationVendorID) {
            sb.append(IMPLEMENTATION_VENDOR_ID);
            sb.append(brace);
            sb.append(implementationVendorID);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationVendor) {
            sb.append(IMPLEMENTATION_VENDOR);
            sb.append(brace);
            sb.append(implementationVendor);
            sb.append(StringUtils.LINE_SEP);
        }

        if (null != implementationURL) {
            sb.append(IMPLEMENTATION_URL);
            sb.append(brace);
            sb.append(implementationURL);
            sb.append(StringUtils.LINE_SEP);
        }

        return sb.toString();
    }

    
    private boolean isCompatible(final DeweyDecimal first,
                                 final DeweyDecimal second) {
        return first.isGreaterThanOrEqual(second);
    }

    
    private static Extension[] getListed(final Manifest manifest,
                                          final Attributes.Name listKey) {
        final ArrayList results = new ArrayList();
        final Attributes mainAttributes = manifest.getMainAttributes();

        if (null != mainAttributes) {
            getExtension(mainAttributes, results, listKey);
        }

        final Map entries = manifest.getEntries();
        final Iterator keys = entries.keySet().iterator();
        while (keys.hasNext()) {
            final String key = (String) keys.next();
            final Attributes attributes = (Attributes) entries.get(key);
            getExtension(attributes, results, listKey);
        }

        return (Extension[]) results.toArray(new Extension[results.size()]);
    }

    
    private static void getExtension(final Attributes attributes,
                                     final ArrayList required,
                                     final Attributes.Name listKey) {
        final String names = attributes.getValue(listKey);
        if (null == names) {
            return;
        }

        final String[] extentions = split(names, "" "");
        for (int i = 0; i < extentions.length; i++) {
            final String prefix = extentions[ i ] + ""-"";
            final Extension extension = getExtension(prefix, attributes);

            if (null != extension) {
                required.add(extension);
            }
        }
    }

    
    private static String[] split(final String string,
                                        final String onToken) {
        final StringTokenizer tokenizer = new StringTokenizer(string, onToken);
        final String[] result = new String[ tokenizer.countTokens() ];

        for (int i = 0; i < result.length; i++) {
            result[ i ] = tokenizer.nextToken();
        }

        return result;
    }

    
    private static Extension getExtension(final String prefix,
                                          final Attributes attributes) {
        
        
        
        final String nameKey = prefix + EXTENSION_NAME;
        final String name = getTrimmedString(attributes.getValue(nameKey));
        if (null == name) {
            return null;
        }

        final String specVendorKey = prefix + SPECIFICATION_VENDOR;
        final String specVendor
            = getTrimmedString(attributes.getValue(specVendorKey));
        final String specVersionKey = prefix + SPECIFICATION_VERSION;
        final String specVersion
            = getTrimmedString(attributes.getValue(specVersionKey));

        final String impVersionKey = prefix + IMPLEMENTATION_VERSION;
        final String impVersion
            = getTrimmedString(attributes.getValue(impVersionKey));
        final String impVendorKey = prefix + IMPLEMENTATION_VENDOR;
        final String impVendor
            = getTrimmedString(attributes.getValue(impVendorKey));
        final String impVendorIDKey = prefix + IMPLEMENTATION_VENDOR_ID;
        final String impVendorId
            = getTrimmedString(attributes.getValue(impVendorIDKey));
        final String impURLKey = prefix + IMPLEMENTATION_URL;
        final String impURL = getTrimmedString(attributes.getValue(impURLKey));

        return new Extension(name, specVersion, specVendor, impVersion,
                              impVendor, impVendorId, impURL);
    }

    
    private static String getTrimmedString(final String value) {
        return null == value ? null : value.trim();
    }
}
"
org.apache.tools.ant.util.IdentityMapper,4,1,0,8,5,6,7,1,4,2.0,16,0.0,0,0.0,0.875,0,0,3.0,1,0.75,0,"

package org.apache.tools.ant.util;


public class IdentityMapper implements FileNameMapper {

    
    public void setFrom(String from) {
    }

    
    public void setTo(String to) {
    }

    
    public String[] mapFileName(String sourceFileName) {
        return new String[] {sourceFileName};
    }
}
"
org.apache.tools.ant.util.JAXPUtils,13,1,0,12,32,70,10,2,9,0.833333333,155,1.0,1,0.0,0.083333333,0,0,10.61538462,2,0.9231,0,"
package org.apache.tools.ant.util;

import java.io.File;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.apache.tools.ant.BuildException;
import org.xml.sax.Parser;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;




public class JAXPUtils {

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private static SAXParserFactory parserFactory = null;

    
    private static SAXParserFactory nsParserFactory = null;

    
    private static DocumentBuilderFactory builderFactory = null;

    
    public static synchronized SAXParserFactory getParserFactory()
        throws BuildException {

        if (parserFactory == null) {
            parserFactory = newParserFactory();
        }
        return parserFactory;
    }

    
    public static synchronized SAXParserFactory getNSParserFactory()
        throws BuildException {

        if (nsParserFactory == null) {
            nsParserFactory = newParserFactory();
            nsParserFactory.setNamespaceAware(true);
        }
        return nsParserFactory;
    }

    
    public static SAXParserFactory newParserFactory() throws BuildException {

        try {
            return SAXParserFactory.newInstance();
        } catch (FactoryConfigurationError e) {
            throw new BuildException(""XML parser factory has not been ""
                                     + ""configured correctly: ""
                                     + e.getMessage(), e);
        }
    }

    
    public static Parser getParser() throws BuildException {
        try {
            return newSAXParser(getParserFactory()).getParser();
        } catch (SAXException e) {
            throw convertToBuildException(e);
        }
    }

    
    public static XMLReader getXMLReader() throws BuildException {
        try {
            return newSAXParser(getParserFactory()).getXMLReader();
        } catch (SAXException e) {
            throw convertToBuildException(e);
        }
    }

    
    public static XMLReader getNamespaceXMLReader() throws BuildException {
        try {
            return newSAXParser(getNSParserFactory()).getXMLReader();
        } catch (SAXException e) {
            throw convertToBuildException(e);
        }
    }

    
    public static String getSystemId(File file) {
        return FILE_UTILS.toURI(file.getAbsolutePath());
    }

    
    public static DocumentBuilder getDocumentBuilder() throws BuildException {
        try {
            return getDocumentBuilderFactory().newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            throw new BuildException(e);
        }
    }

    
    private static SAXParser newSAXParser(SAXParserFactory factory)
         throws BuildException {
        try {
            return factory.newSAXParser();
        } catch (ParserConfigurationException e) {
            throw new BuildException(""Cannot create parser for the given ""
                                     + ""configuration: "" + e.getMessage(), e);
        } catch (SAXException e) {
            throw convertToBuildException(e);
        }
    }

    
    private static BuildException convertToBuildException(SAXException e) {
        Exception nested = e.getException();
        if (nested != null) {
            return new BuildException(nested);
        } else {
            return new BuildException(e);
        }
    }

    
    private static synchronized
        DocumentBuilderFactory getDocumentBuilderFactory()
        throws BuildException {
        if (builderFactory == null) {
            try {
                builderFactory = DocumentBuilderFactory.newInstance();
            } catch (FactoryConfigurationError e) {
                throw new BuildException(""Document builder factory has not ""
                                         + ""been configured correctly: ""
                                         + e.getMessage(), e);
            }
        }
        return builderFactory;
    }

}
"
org.apache.tools.ant.util.UnPackageNameMapper,2,2,0,1,6,1,0,1,1,2.0,20,0.0,0,0.875,0.75,1,1,9.0,1,0.5,0,"
package org.apache.tools.ant.util;

import java.io.File;


public class UnPackageNameMapper extends GlobPatternMapper {
    
    protected String extractVariablePart(String name) {
        String var = name.substring(prefixLength,
                name.length() - postfixLength);
        return var.replace('.', File.separatorChar);
    }
}

"
org.apache.tools.ant.taskdefs.MatchingTask,42,3,21,47,98,0,21,26,40,0.0,327,1.0,1,0.474358974,0.073412698,2,2,6.761904762,6,1.1667,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.Enumeration;
import java.util.StringTokenizer;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.selectors.AndSelector;
import org.apache.tools.ant.types.selectors.ContainsRegexpSelector;
import org.apache.tools.ant.types.selectors.ContainsSelector;
import org.apache.tools.ant.types.selectors.DateSelector;
import org.apache.tools.ant.types.selectors.DependSelector;
import org.apache.tools.ant.types.selectors.DepthSelector;
import org.apache.tools.ant.types.selectors.DifferentSelector;
import org.apache.tools.ant.types.selectors.ExtendSelector;
import org.apache.tools.ant.types.selectors.FileSelector;
import org.apache.tools.ant.types.selectors.FilenameSelector;
import org.apache.tools.ant.types.selectors.MajoritySelector;
import org.apache.tools.ant.types.selectors.NoneSelector;
import org.apache.tools.ant.types.selectors.NotSelector;
import org.apache.tools.ant.types.selectors.OrSelector;
import org.apache.tools.ant.types.selectors.PresentSelector;
import org.apache.tools.ant.types.selectors.SelectSelector;
import org.apache.tools.ant.types.selectors.SelectorContainer;
import org.apache.tools.ant.types.selectors.SizeSelector;
import org.apache.tools.ant.types.selectors.TypeSelector;
import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;



public abstract class MatchingTask extends Task implements SelectorContainer {

    
    protected FileSet fileset = new FileSet();
    

    
    public void setProject(Project project) {
        super.setProject(project);
        fileset.setProject(project);
    }

    
    public PatternSet.NameEntry createInclude() {
        return fileset.createInclude();
    }

    
    public PatternSet.NameEntry createIncludesFile() {
        return fileset.createIncludesFile();
    }

    
    public PatternSet.NameEntry createExclude() {
        return fileset.createExclude();
    }

    
    public PatternSet.NameEntry createExcludesFile() {
        return fileset.createExcludesFile();
    }

    
    public PatternSet createPatternSet() {
        return fileset.createPatternSet();
    }

    
    public void setIncludes(String includes) {
        fileset.setIncludes(includes);
    }

    
    
    public void XsetItems(String itemString) {
        log(""The items attribute is deprecated. ""
            + ""Please use the includes attribute."", Project.MSG_WARN);
        if (itemString == null || itemString.equals(""*"")
            || itemString.equals(""."")) {
            createInclude().setName(""**"");
        } else {
            StringTokenizer tok = new StringTokenizer(itemString, "", "");
            while (tok.hasMoreTokens()) {
                String pattern = tok.nextToken().trim();
                if (pattern.length() > 0) {
                    createInclude().setName(pattern + ""
    public void setExcludes(String excludes) {
        fileset.setExcludes(excludes);
    }

    
    public void XsetIgnore(String ignoreString) {
        log(""The ignore attribute is deprecated.""
            + ""Please use the excludes attribute."", Project.MSG_WARN);
        if (ignoreString != null && ignoreString.length() > 0) {
            StringTokenizer tok = new StringTokenizer(ignoreString, "", "",
                                                      false);
            while (tok.hasMoreTokens()) {
                createExclude().setName(""**/"" + tok.nextToken().trim() + ""
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        fileset.setDefaultexcludes(useDefaultExcludes);
    }

    
    protected DirectoryScanner getDirectoryScanner(File baseDir) {
        fileset.setDir(baseDir);
        return fileset.getDirectoryScanner(getProject());
    }

    
    public void setIncludesfile(File includesfile) {
        fileset.setIncludesfile(includesfile);
    }

    
    public void setExcludesfile(File excludesfile) {
        fileset.setExcludesfile(excludesfile);
    }

    
    public void setCaseSensitive(boolean isCaseSensitive) {
        fileset.setCaseSensitive(isCaseSensitive);
    }

    
    public void setFollowSymlinks(boolean followSymlinks) {
        fileset.setFollowSymlinks(followSymlinks);
    }

    
    public boolean hasSelectors() {
        return fileset.hasSelectors();
    }

    
    public int selectorCount() {
        return fileset.selectorCount();
    }

    
    public FileSelector[] getSelectors(Project p) {
        return fileset.getSelectors(p);
    }

    
    public Enumeration selectorElements() {
        return fileset.selectorElements();
    }

    
    public void appendSelector(FileSelector selector) {
        fileset.appendSelector(selector);
    }

    

    
    public void addSelector(SelectSelector selector) {
        fileset.addSelector(selector);
    }

    
    public void addAnd(AndSelector selector) {
        fileset.addAnd(selector);
    }

    
    public void addOr(OrSelector selector) {
        fileset.addOr(selector);
    }

    
    public void addNot(NotSelector selector) {
        fileset.addNot(selector);
    }

    
    public void addNone(NoneSelector selector) {
        fileset.addNone(selector);
    }

    
    public void addMajority(MajoritySelector selector) {
        fileset.addMajority(selector);
    }

    
    public void addDate(DateSelector selector) {
        fileset.addDate(selector);
    }

    
    public void addSize(SizeSelector selector) {
        fileset.addSize(selector);
    }

    
    public void addFilename(FilenameSelector selector) {
        fileset.addFilename(selector);
    }

    
    public void addCustom(ExtendSelector selector) {
        fileset.addCustom(selector);
    }

    
    public void addContains(ContainsSelector selector) {
        fileset.addContains(selector);
    }

    
    public void addPresent(PresentSelector selector) {
        fileset.addPresent(selector);
    }

    
    public void addDepth(DepthSelector selector) {
        fileset.addDepth(selector);
    }

    
    public void addDepend(DependSelector selector) {
        fileset.addDepend(selector);
    }

    
    public void addContainsRegexp(ContainsRegexpSelector selector) {
        fileset.addContainsRegexp(selector);
    }

    
    public void addDifferent(DifferentSelector selector) {
        fileset.addDifferent(selector);
    }

    
    public void addType(TypeSelector selector) {
        fileset.addType(selector);
    }

    
    public void addModified(ModifiedSelector selector) {
        fileset.addModified(selector);
    }

    
    public void add(FileSelector selector) {
        fileset.add(selector);
    }

    
    protected final FileSet getImplicitFileSet() {
        return fileset;
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.GenericDeploymentTool,33,1,6,22,135,316,7,15,10,0.940625,1367,0.6,5,0.0,0.17630854,0,0,39.81818182,10,2.0909,0,"
package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;

import javax.xml.parsers.SAXParser;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.depend.DependencyAnalyzer;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;



public class GenericDeploymentTool implements EJBDeploymentTool {
    
    public static final int DEFAULT_BUFFER_SIZE = 1024;
    
    public static final int JAR_COMPRESS_LEVEL  = 9;

    
    protected static final String META_DIR  = ""META-INF/"";

    
    protected static final String MANIFEST  = META_DIR + ""MANIFEST.MF"";

    
    protected static final String EJB_DD    = ""ejb-jar.xml"";

    
    public static final String ANALYZER_SUPER = ""super"";
    
    public static final String ANALYZER_FULL = ""full"";
    
    public static final String ANALYZER_NONE = ""none"";

    
    public static final String DEFAULT_ANALYZER = ANALYZER_SUPER;

    
    public static final String ANALYZER_CLASS_SUPER
        = ""org.apache.tools.ant.util.depend.bcel.AncestorAnalyzer"";
    
    public static final String ANALYZER_CLASS_FULL
        = ""org.apache.tools.ant.util.depend.bcel.FullAnalyzer"";

    
    private EjbJar.Config config;

    
    private File destDir;

    
    private Path classpath;

    
    private String genericJarSuffix = ""-generic.jar"";

    
    private Task task;

    
    private ClassLoader classpathLoader = null;

     
    private Set addedfiles;

    
    private DescriptorHandler handler;

    
    private DependencyAnalyzer dependencyAnalyzer;

    
    public GenericDeploymentTool() {
    }


    
    public void setDestdir(File inDir) {
        this.destDir = inDir;
    }

    
    protected File getDestDir() {
        return destDir;
    }


    
    public void setTask(Task task) {
        this.task = task;
    }

    
    protected Task getTask() {
        return task;
    }

    
    protected EjbJar.Config getConfig() {
        return config;
    }

    
    protected boolean usingBaseJarName() {
        return config.baseJarName != null;
    }

    
    public void setGenericJarSuffix(String inString) {
        this.genericJarSuffix = inString;
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(task.getProject());
        }
        return classpath.createPath();
    }

    
    public void setClasspath(Path classpath) {
        this.classpath = classpath;
    }

    
    protected Path getCombinedClasspath() {
        Path combinedPath = classpath;
        if (config.classpath != null) {
            if (combinedPath == null) {
                combinedPath = config.classpath;
            } else {
                combinedPath.append(config.classpath);
            }
        }

        return combinedPath;
    }

    
    protected void log(String message, int level) {
        getTask().log(message, level);
    }

    
    protected Location getLocation() {
        return getTask().getLocation();
    }

    private void createAnalyzer() {
        String analyzer = config.analyzer;
        if (analyzer == null) {
            analyzer = DEFAULT_ANALYZER;
        }

        if (analyzer.equals(ANALYZER_NONE)) {
            return;
        }

        String analyzerClassName = null;
        if (analyzer.equals(ANALYZER_SUPER)) {
            analyzerClassName = ANALYZER_CLASS_SUPER;
        } else if (analyzer.equals(ANALYZER_FULL)) {
            analyzerClassName = ANALYZER_CLASS_FULL;
        } else {
            analyzerClassName = analyzer;
        }

        try {
            Class analyzerClass = Class.forName(analyzerClassName);
            dependencyAnalyzer
                = (DependencyAnalyzer) analyzerClass.newInstance();
            dependencyAnalyzer.addClassPath(new Path(task.getProject(),
                config.srcDir.getPath()));
            dependencyAnalyzer.addClassPath(config.classpath);
        } catch (NoClassDefFoundError e) {
            dependencyAnalyzer = null;
            task.log(""Unable to load dependency analyzer: "" + analyzerClassName
                + "" - dependent class not found: "" + e.getMessage(),
                Project.MSG_WARN);
        } catch (Exception e) {
            dependencyAnalyzer = null;
            task.log(""Unable to load dependency analyzer: "" + analyzerClassName
                     + "" - exception: "" + e.getMessage(),
                Project.MSG_WARN);
        }
    }


    
    public void configure(EjbJar.Config config) {
        this.config = config;

        createAnalyzer();
        classpathLoader = null;
    }

    
    protected void addFileToJar(JarOutputStream jStream,
                                File inputFile,
                                String logicalFilename)
        throws BuildException {
        FileInputStream iStream = null;
        try {
            if (!addedfiles.contains(logicalFilename)) {
                iStream = new FileInputStream(inputFile);
                
                ZipEntry zipEntry = new ZipEntry(logicalFilename.replace('\\', '/'));
                jStream.putNextEntry(zipEntry);

                
                
                byte[] byteBuffer = new byte[2 * DEFAULT_BUFFER_SIZE];
                int count = 0;
                do {
                    jStream.write(byteBuffer, 0, count);
                    count = iStream.read(byteBuffer, 0, byteBuffer.length);
                } while (count != -1);

                
                addedfiles.add(logicalFilename);
           }
        } catch (IOException ioe) {
            log(""WARNING: IOException while adding entry ""
                + logicalFilename + "" to jarfile from ""
                + inputFile.getPath() + "" ""  + ioe.getClass().getName()
                + ""-"" + ioe.getMessage(), Project.MSG_WARN);
        } finally {
            
            if (iStream != null) {
                try {
                    iStream.close();
                } catch (IOException closeException) {
                    
                }
            }
        }
    }

    
    protected DescriptorHandler getDescriptorHandler(File srcDir) {
        DescriptorHandler h = new DescriptorHandler(getTask(), srcDir);

        registerKnownDTDs(h);

        
        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
            h.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }
        return h;
    }

    
    protected void registerKnownDTDs(DescriptorHandler handler) {
        
    }

    
    public void processDescriptor(String descriptorFileName, SAXParser saxParser) {

        checkConfiguration(descriptorFileName, saxParser);

        try {
            handler = getDescriptorHandler(config.srcDir);

            
            Hashtable ejbFiles = parseEjbFiles(descriptorFileName, saxParser);

            
            addSupportClasses(ejbFiles);

            
            String baseName = getJarBaseName(descriptorFileName);

            String ddPrefix = getVendorDDPrefix(baseName, descriptorFileName);

            File manifestFile = getManifestFile(ddPrefix);
            if (manifestFile != null) {
                ejbFiles.put(MANIFEST, manifestFile);
            }



            
            ejbFiles.put(META_DIR + EJB_DD,
                         new File(config.descriptorDir, descriptorFileName));

            
            addVendorFiles(ejbFiles, ddPrefix);

            
            checkAndAddDependants(ejbFiles);

            
            
            if (config.flatDestDir && baseName.length() != 0) {
                int startName = baseName.lastIndexOf(File.separator);
                if (startName == -1) {
                    startName = 0;
                }

                int endName   = baseName.length();
                baseName = baseName.substring(startName, endName);
            }

            File jarFile = getVendorOutputJarFile(baseName);


            
            if (needToRebuild(ejbFiles, jarFile)) {
                
                log(""building ""
                              + jarFile.getName()
                              + "" with ""
                              + String.valueOf(ejbFiles.size())
                              + "" files"",
                              Project.MSG_INFO);

                
                String publicId = getPublicId();
                writeJar(baseName, jarFile, ejbFiles, publicId);

            } else {
                
                log(jarFile.toString() + "" is up to date."",
                              Project.MSG_VERBOSE);
            }

        } catch (SAXException se) {
            String msg = ""SAXException while parsing '""
                + descriptorFileName
                + ""'. This probably indicates badly-formed XML.""
                + ""  Details: ""
                + se.getMessage();
            throw new BuildException(msg, se);
        } catch (IOException ioe) {
            String msg = ""IOException while parsing'""
                + descriptorFileName.toString()
                + ""'.  This probably indicates that the descriptor""
                + "" doesn't exist. Details: ""
                + ioe.getMessage();
            throw new BuildException(msg, ioe);
        }
    }

    
    protected void checkConfiguration(String descriptorFileName,
                                    SAXParser saxParser) throws BuildException {

        
    }

    
    protected Hashtable parseEjbFiles(String descriptorFileName, SAXParser saxParser)
                            throws IOException, SAXException {
        FileInputStream descriptorStream = null;
        Hashtable ejbFiles = null;

        try {

            
            descriptorStream
                = new FileInputStream(new File(config.descriptorDir, descriptorFileName));
            saxParser.parse(new InputSource(descriptorStream), handler);

            ejbFiles = handler.getFiles();

        } finally {
            if (descriptorStream != null) {
                try {
                    descriptorStream.close();
                } catch (IOException closeException) {
                    
                }
            }
        }

        return ejbFiles;
    }

    
    protected void addSupportClasses(Hashtable ejbFiles) {
        
        Project project = task.getProject();
        for (Iterator i = config.supportFileSets.iterator(); i.hasNext();) {
            FileSet supportFileSet = (FileSet) i.next();
            File supportBaseDir = supportFileSet.getDir(project);
            DirectoryScanner supportScanner = supportFileSet.getDirectoryScanner(project);
            supportScanner.scan();
            String[] supportFiles = supportScanner.getIncludedFiles();
            for (int j = 0; j < supportFiles.length; ++j) {
                ejbFiles.put(supportFiles[j], new File(supportBaseDir, supportFiles[j]));
            }
        }
    }


    
    protected String getJarBaseName(String descriptorFileName) {

        String baseName = """";

        
        if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.BASEJARNAME)) {
            String canonicalDescriptor = descriptorFileName.replace('\\', '/');
            int index = canonicalDescriptor.lastIndexOf('/');
            if (index != -1) {
                baseName = descriptorFileName.substring(0, index + 1);
            }
            baseName += config.baseJarName;
        } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.DESCRIPTOR)) {
            int lastSeparatorIndex = descriptorFileName.lastIndexOf(File.separator);
            int endBaseName = -1;
            if (lastSeparatorIndex != -1) {
                endBaseName = descriptorFileName.indexOf(config.baseNameTerminator,
                                                            lastSeparatorIndex);
            } else {
                endBaseName = descriptorFileName.indexOf(config.baseNameTerminator);
            }

            if (endBaseName != -1) {
                baseName = descriptorFileName.substring(0, endBaseName);
            } else {
                throw new BuildException(""Unable to determine jar name ""
                    + ""from descriptor \"""" + descriptorFileName + ""\"""");
            }
        } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.DIRECTORY)) {
            File descriptorFile = new File(config.descriptorDir, descriptorFileName);
            String path = descriptorFile.getAbsolutePath();
            int lastSeparatorIndex
                = path.lastIndexOf(File.separator);
            if (lastSeparatorIndex == -1) {
                throw new BuildException(""Unable to determine directory name holding descriptor"");
            }
            String dirName = path.substring(0, lastSeparatorIndex);
            int dirSeparatorIndex = dirName.lastIndexOf(File.separator);
            if (dirSeparatorIndex != -1) {
                dirName = dirName.substring(dirSeparatorIndex + 1);
            }

            baseName = dirName;
        } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.EJB_NAME)) {
            baseName = handler.getEjbName();
        }
        return baseName;
    }

    
    public String getVendorDDPrefix(String baseName, String descriptorFileName) {
        String ddPrefix = null;

        if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.DESCRIPTOR)) {
            ddPrefix = baseName + config.baseNameTerminator;
        } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.BASEJARNAME)
            || config.namingScheme.getValue().equals(EjbJar.NamingScheme.EJB_NAME)
            || config.namingScheme.getValue().equals(EjbJar.NamingScheme.DIRECTORY)) {
            String canonicalDescriptor = descriptorFileName.replace('\\', '/');
            int index = canonicalDescriptor.lastIndexOf('/');
            if (index == -1) {
                ddPrefix = """";
            } else {
                ddPrefix = descriptorFileName.substring(0, index + 1);
            }
        }
        return ddPrefix;
    }

    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
        
    }


    
    File getVendorOutputJarFile(String baseName) {
        return new File(destDir, baseName + genericJarSuffix);
    }

    
    protected boolean needToRebuild(Hashtable ejbFiles, File jarFile) {
        if (jarFile.exists()) {
            long lastBuild = jarFile.lastModified();

            Iterator fileIter = ejbFiles.values().iterator();

            
            
            while (fileIter.hasNext()) {
                File currentFile = (File) fileIter.next();
                if (lastBuild < currentFile.lastModified()) {
                    log(""Build needed because "" + currentFile.getPath() + "" is out of date"",
                        Project.MSG_VERBOSE);
                    return true;
                }
            }
            return false;
        }

        return true;
    }

    
    protected String getPublicId() {
        return handler.getPublicId();
    }

    
    protected File getManifestFile(String prefix) {
        File manifestFile
            = new File(getConfig().descriptorDir, prefix + ""manifest.mf"");
        if (manifestFile.exists()) {
            return manifestFile;
        }

        if (config.manifest != null) {
            return config.manifest;
        }
        return null;
    }

    
    protected void writeJar(String baseName, File jarfile, Hashtable files,
                            String publicId) throws BuildException {

        JarOutputStream jarStream = null;
        try {
            
            if (addedfiles == null) {
                addedfiles = new HashSet();
            } else {
                addedfiles.clear();
            }

            
            if (jarfile.exists()) {
                jarfile.delete();
            }
            jarfile.getParentFile().mkdirs();
            jarfile.createNewFile();

            InputStream in = null;
            Manifest manifest = null;
            try {
                File manifestFile = (File) files.get(MANIFEST);
                if (manifestFile != null && manifestFile.exists()) {
                    in = new FileInputStream(manifestFile);
                } else {
                    String defaultManifest = ""/org/apache/tools/ant/defaultManifest.mf"";
                    in = this.getClass().getResourceAsStream(defaultManifest);
                    if (in == null) {
                        throw new BuildException(""Could not find ""
                            + ""default manifest: "" + defaultManifest);
                    }
                }

                manifest = new Manifest(in);
            } catch (IOException e) {
                throw new BuildException (""Unable to read manifest"", e, getLocation());
            } finally {
                if (in != null) {
                    in.close();
                }
            }

            

            jarStream = new JarOutputStream(new FileOutputStream(jarfile), manifest);
            jarStream.setMethod(JarOutputStream.DEFLATED);

            
            for (Iterator entryIterator = files.keySet().iterator(); entryIterator.hasNext();) {
                String entryName = (String) entryIterator.next();
                if (entryName.equals(MANIFEST)) {
                    continue;
                }

                File entryFile = (File) files.get(entryName);

                log(""adding file '"" + entryName + ""'"",
                              Project.MSG_VERBOSE);

                addFileToJar(jarStream, entryFile, entryName);

                
                InnerClassFilenameFilter flt = new InnerClassFilenameFilter(entryFile.getName());
                File entryDir = entryFile.getParentFile();
                String[] innerfiles = entryDir.list(flt);
                if (innerfiles != null) {
                    for (int i = 0, n = innerfiles.length; i < n; i++) {

                        
                        int entryIndex = entryName.lastIndexOf(entryFile.getName()) - 1;
                        if (entryIndex < 0) {
                            entryName = innerfiles[i];
                        } else {
                            entryName = entryName.substring(0, entryIndex)
                                + File.separatorChar + innerfiles[i];
                        }
                        
                        entryFile = new File(config.srcDir, entryName);

                        log(""adding innerclass file '"" + entryName + ""'"",
                                Project.MSG_VERBOSE);

                        addFileToJar(jarStream, entryFile, entryName);

                    }
                }
            }
        } catch (IOException ioe) {
            String msg = ""IOException while processing ejb-jar file '""
                + jarfile.toString()
                + ""'. Details: ""
                + ioe.getMessage();
            throw new BuildException(msg, ioe);
        } finally {
            if (jarStream != null) {
                try {
                    jarStream.close();
                } catch (IOException closeException) {
                    
                }
            }
        }
    } 


    
    protected void checkAndAddDependants(Hashtable checkEntries)
        throws BuildException {

        if (dependencyAnalyzer == null) {
            return;
        }

        dependencyAnalyzer.reset();

        Iterator i = checkEntries.keySet().iterator();
        while (i.hasNext()) {
            String entryName = (String) i.next();
            if (entryName.endsWith("".class"")) {
                String className = entryName.substring(0,
                    entryName.length() - "".class"".length());
                className = className.replace(File.separatorChar, '/');
                className = className.replace('/', '.');

                dependencyAnalyzer.addRootClass(className);
            }
        }

        Enumeration e = dependencyAnalyzer.getClassDependencies();

        while (e.hasMoreElements()) {
            String classname = (String) e.nextElement();
            String location
                = classname.replace('.', File.separatorChar) + "".class"";
            File classFile = new File(config.srcDir, location);
            if (classFile.exists()) {
                checkEntries.put(location, classFile);
                log(""dependent class: "" + classname + "" - "" + classFile,
                    Project.MSG_VERBOSE);
            }
        }
    }


    
    protected ClassLoader getClassLoaderForBuild() {
        if (classpathLoader != null) {
            return classpathLoader;
        }

        Path combinedClasspath = getCombinedClasspath();

        
        if (combinedClasspath == null) {
            classpathLoader = getClass().getClassLoader();
        } else {
            classpathLoader
                = getTask().getProject().createClassLoader(combinedClasspath);
        }

        return classpathLoader;
    }

    
    public void validateConfigured() throws BuildException {
        if ((destDir == null) || (!destDir.isDirectory())) {
            String msg = ""A valid destination directory must be specified ""
                            + ""using the \""destdir\"" attribute."";
            throw new BuildException(msg, getLocation());
        }
    }
}
"
org.apache.tools.ant.taskdefs.rmic.SunRmic,2,2,0,8,21,1,1,7,2,1.625,167,0.0,0,0.928571429,1.0,0,0,78.5,1,0.5,2,"

package org.apache.tools.ant.taskdefs.rmic;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.Commandline;


public class SunRmic extends DefaultRmicAdapter {

    
    public static final String RMIC_CLASSNAME = ""sun.rmi.rmic.Main"";

    
    public static final String COMPILER_NAME = ""sun"";

    
    public static final String RMIC_EXECUTABLE = ""rmic"";
    
    public static final String ERROR_NO_RMIC_ON_CLASSPATH = ""Cannot use SUN rmic, as it is not ""
                                         + ""available.  A common solution is to ""
                                         + ""set the environment variable ""
                                         + ""JAVA_HOME or CLASSPATH."";
    
    public static final String ERROR_RMIC_FAILED = ""Error starting SUN rmic: "";

    
    public boolean execute() throws BuildException {
        getRmic().log(""Using SUN rmic compiler"", Project.MSG_VERBOSE);
        Commandline cmd = setupRmicCommand();

        
        
        LogOutputStream logstr = new LogOutputStream(getRmic(),
                                                     Project.MSG_WARN);

        try {
            Class c = Class.forName(RMIC_CLASSNAME);
            Constructor cons
                = c.getConstructor(new Class[]  {OutputStream.class, String.class});
            Object rmic = cons.newInstance(new Object[] {logstr, ""rmic""});

            Method doRmic = c.getMethod(""compile"",
                                        new Class [] {String[].class});
            Boolean ok =
                (Boolean) doRmic.invoke(rmic,
                                       (new Object[] {cmd.getArguments()}));
            return ok.booleanValue();
        } catch (ClassNotFoundException ex) {
            throw new BuildException(ERROR_NO_RMIC_ON_CLASSPATH,
                                     getRmic().getLocation());
        } catch (Exception ex) {
            if (ex instanceof BuildException) {
                throw (BuildException) ex;
            } else {
                throw new BuildException(ERROR_RMIC_FAILED,
                                         ex, getRmic().getLocation());
            }
        } finally {
            try {
                logstr.close();
            } catch (IOException e) {
                throw new BuildException(e);
            }
        }
    }
}
"
org.apache.tools.ant.types.resources.Union,8,4,0,16,25,28,13,3,5,2.0,122,0.0,0,0.88,0.3125,1,1,14.25,6,1.75,0,"
package org.apache.tools.ant.types.resources;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;


public class Union extends BaseResourceCollectionContainer {

    
    public static Union getInstance(ResourceCollection rc) {
        return rc instanceof Union ? (Union) rc : new Union(rc);
    }

    
    public Union() {
    }

    
    public Union(ResourceCollection rc) {
        add(rc);
    }

    
    public String[] list() {
        if (isReference()) {
            return ((Union) getCheckedRef()).list();
        }
        Collection result = getCollection(true);
        return (String[]) (result.toArray(new String[result.size()]));
    }

    
    public Resource[] listResources() {
        if (isReference()) {
            return ((Union) getCheckedRef()).listResources();
        }
        Collection result = getCollection();
        return (Resource[]) (result.toArray(new Resource[result.size()]));
    }

    
    protected Collection getCollection() {
        return getCollection(false);
    }

    
    protected Collection getCollection(boolean asString) {
        List rc = getResourceCollections();
        if (rc.isEmpty()) {
            return Collections.EMPTY_LIST;
        }
        
        ArrayList union = new ArrayList(rc.size() * 2);
        for (Iterator rcIter = rc.iterator(); rcIter.hasNext();) {
            for (Iterator r = nextRC(rcIter).iterator(); r.hasNext();) {
                Object o = r.next();
                if (asString) {
                    o = o.toString();
                }
                if (!(union.contains(o))) {
                    union.add(o);
                }
            }
        }
        return union;
    }

    private static ResourceCollection nextRC(Iterator i) {
        return (ResourceCollection) i.next();
    }
}

"
org.apache.tools.ant.Diagnostics,30,1,0,10,104,429,2,9,5,1.013793103,1038,0.8,0,0.0,0.108333333,0,0,33.26666667,9,1.9,3,"
package org.apache.tools.ant;

import org.apache.tools.ant.util.LoaderUtils;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JAXPUtils;
import org.apache.tools.ant.util.ProxySetup;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.launch.Launcher;
import org.xml.sax.XMLReader;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;
import java.io.File;
import java.io.FilenameFilter;
import java.io.PrintStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.FileOutputStream;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Calendar;
import java.util.TimeZone;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;


public final class Diagnostics {

    
    private static final int BIG_DRIFT_LIMIT = 10000;
    
    private static final int TEST_FILE_SIZE = 32;
    private static final int KILOBYTE = 1024;
    private static final int SECONDS_PER_MILLISECOND = 1000;
    private static final int SECONDS_PER_MINUTE = 60;
    private static final int MINUTES_PER_HOUR = 60;
    private static final String TEST_CLASS
        = ""org.apache.tools.ant.taskdefs.optional.Test"";

    
    protected static final String ERROR_PROPERTY_ACCESS_BLOCKED
        = ""Access to this property blocked by a security manager"";

    
    private Diagnostics() {
        
    }

    
    public static boolean isOptionalAvailable() {
        try {
            Class.forName(TEST_CLASS);
        } catch (ClassNotFoundException e) {
            return false;
        }
        return true;
    }

    
    public static void validateVersion() throws BuildException {
        try {
            Class optional
                = Class.forName(TEST_CLASS);
            String coreVersion = getImplementationVersion(Main.class);
            String optionalVersion = getImplementationVersion(optional);

            if (coreVersion != null && !coreVersion.equals(optionalVersion)) {
                throw new BuildException(""Invalid implementation version ""
                    + ""between Ant core and Ant optional tasks.\n""
                    + "" core    : "" + coreVersion + ""\n""
                    + "" optional: "" + optionalVersion);
            }
        } catch (ClassNotFoundException e) {
            
            ignoreThrowable(e);
        }
    }

    
    public static File[] listLibraries() {
        String home = System.getProperty(MagicNames.ANT_HOME);
        if (home == null) {
            return null;
        }
        File libDir = new File(home, ""lib"");
        return listJarFiles(libDir);

    }

    
    private static File[] listJarFiles(File libDir) {
        FilenameFilter filter = new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.endsWith("".jar"");
            }
        };

        File[] files  = libDir.listFiles(filter);
        return files;
    }

    
    public static void main(String[] args) {
        doReport(System.out);
    }


    
    private static String getImplementationVersion(Class clazz) {
        Package pkg = clazz.getPackage();
        return pkg.getImplementationVersion();
    }

    
    private static String getXmlParserName() {
        SAXParser saxParser = getSAXParser();
        if (saxParser == null) {
            return ""Could not create an XML Parser"";
        }

        
        String saxParserName = saxParser.getClass().getName();
        return saxParserName;
    }

    
    private static SAXParser getSAXParser() {
        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
        if (saxParserFactory == null) {
            return null;
        }
        SAXParser saxParser = null;
        try {
            saxParser = saxParserFactory.newSAXParser();
        } catch (Exception e) {
            
            ignoreThrowable(e);
        }
        return saxParser;
    }

    

    private static String getXMLParserLocation() {
        SAXParser saxParser = getSAXParser();
        if (saxParser == null) {
            return null;
        }
        String location = getClassLocation(saxParser.getClass());
        return location;
    }

    private static String getNamespaceParserName() {
        try {
            XMLReader reader = JAXPUtils.getNamespaceXMLReader();
            return reader.getClass().getName();
        } catch (BuildException e) {
            
            ignoreThrowable(e);
            return null;
        }
    }

    private static String getNamespaceParserLocation() {
        try {
            XMLReader reader = JAXPUtils.getNamespaceXMLReader();
            return getClassLocation(reader.getClass());
        } catch (BuildException e) {
            
            ignoreThrowable(e);
            return null;
        }
    }

    
    private static void ignoreThrowable(Throwable thrown) {
    }

    

    private static String getClassLocation(Class clazz) {
        File f = LoaderUtils.getClassSource(clazz);
        return f == null ? null : f.getAbsolutePath();
    }


    
    public static void doReport(PrintStream out) {
        out.println(""------- Ant diagnostics report -------"");
        out.println(Main.getAntVersion());
        header(out, ""Implementation Version"");

        out.println(""core tasks     : "" + getImplementationVersion(Main.class));

        Class optional = null;
        try {
            optional = Class.forName(TEST_CLASS);
            out.println(""optional tasks : ""
                + getImplementationVersion(optional));
        } catch (ClassNotFoundException e) {
            ignoreThrowable(e);
            out.println(""optional tasks : not available"");
        }

        header(out, ""ANT PROPERTIES"");
        doReportAntProperties(out);

        header(out, ""ANT_HOME/lib jar listing"");
        doReportAntHomeLibraries(out);

        header(out, ""USER_HOME/.ant/lib jar listing"");
        doReportUserHomeLibraries(out);

        header(out, ""Tasks availability"");
        doReportTasksAvailability(out);

        header(out, ""org.apache.env.Which diagnostics"");
        doReportWhich(out);

        header(out, ""XML Parser information"");
        doReportParserInfo(out);

        header(out, ""System properties"");
        doReportSystemProperties(out);

        header(out, ""Temp dir"");
        doReportTempDir(out);

        header(out, ""Locale information"");
        doReportLocale(out);

        header(out, ""Proxy information"");
        doReportProxy(out);

        out.println();
    }

    private static void header(PrintStream out, String section) {
        out.println();
        out.println(""-------------------------------------------"");
        out.print("" "");
        out.println(section);
        out.println(""-------------------------------------------"");
    }

    
    private static void doReportSystemProperties(PrintStream out) {
        Properties sysprops = null;
        try {
            sysprops = System.getProperties();
        } catch (SecurityException  e) {
            ignoreThrowable(e);
            out.println(""Access to System.getProperties() blocked ""
                    + ""by a security manager"");
        }
        for (Enumeration keys = sysprops.propertyNames();
            keys.hasMoreElements();) {
            String key = (String) keys.nextElement();
            String value = getProperty(key);
            out.println(key + "" : "" + value);
        }
    }

    
    private static String getProperty(String key) {
        String value;
        try {
            value = System.getProperty(key);
        } catch (SecurityException e) {
            value = ERROR_PROPERTY_ACCESS_BLOCKED;
        }
        return value;
    }

    
    private static void doReportAntProperties(PrintStream out) {
        Project p = new Project();
        p.initProperties();
        out.println(MagicNames.ANT_VERSION + "": "" + p.getProperty(MagicNames.ANT_VERSION));
        out.println(MagicNames.ANT_JAVA_VERSION + "": ""
                    + p.getProperty(MagicNames.ANT_JAVA_VERSION));
        out.println(MagicNames.ANT_LIB + "": "" + p.getProperty(MagicNames.ANT_LIB));
        out.println(MagicNames.ANT_HOME + "": "" + p.getProperty(MagicNames.ANT_HOME));
    }

    
    private static void doReportAntHomeLibraries(PrintStream out) {
        out.println(MagicNames.ANT_HOME + "": "" + System.getProperty(MagicNames.ANT_HOME));
        File[] libs = listLibraries();
        printLibraries(libs, out);
    }

    
    private static void doReportUserHomeLibraries(PrintStream out) {
        String home = System.getProperty(Launcher.USER_HOMEDIR);
        out.println(""user.home: "" + home);
        File libDir = new File(home, Launcher.USER_LIBDIR);
        File[] libs = listJarFiles(libDir);
        printLibraries(libs, out);
    }

    
    private static void printLibraries(File[] libs, PrintStream out) {
        if (libs == null) {
            out.println(""No such directory."");
            return;
        }
        for (int i = 0; i < libs.length; i++) {
            out.println(libs[i].getName()
                    + "" ("" + libs[i].length() + "" bytes)"");
        }
    }


    
    private static void doReportWhich(PrintStream out) {
        Throwable error = null;
        try {
            Class which = Class.forName(""org.apache.env.Which"");
            Method method
                = which.getMethod(""main"", new Class[]{String[].class});
            method.invoke(null, new Object[]{new String[]{}});
        } catch (ClassNotFoundException e) {
            out.println(""Not available."");
            out.println(""Download it at http:
        } catch (InvocationTargetException e) {
            error = e.getTargetException() == null ? e : e.getTargetException();
        } catch (Throwable e) {
            error = e;
        }
        
        if (error != null) {
            out.println(""Error while running org.apache.env.Which"");
            error.printStackTrace();
        }
    }

    
    private static void doReportTasksAvailability(PrintStream out) {
        InputStream is = Main.class.getResourceAsStream(
                MagicNames.TASKDEF_PROPERTIES_RESOURCE);
        if (is == null) {
            out.println(""None available"");
        } else {
            Properties props = new Properties();
            try {
                props.load(is);
                for (Enumeration keys = props.keys(); keys.hasMoreElements();) {
                    String key = (String) keys.nextElement();
                    String classname = props.getProperty(key);
                    try {
                        Class.forName(classname);
                        props.remove(key);
                    } catch (ClassNotFoundException e) {
                        out.println(key + "" : Not Available ""
                                + ""(the implementation class is not present)"");
                    } catch (NoClassDefFoundError e) {
                        String pkg = e.getMessage().replace('/', '.');
                        out.println(key + "" : Missing dependency "" + pkg);
                    } catch (LinkageError e) {
                        out.println(key + "" : Initialization error"");
                    }
                }
                if (props.size() == 0) {
                    out.println(""All defined tasks are available"");
                } else {
                    out.println(""A task being missing/unavailable should only ""
                            + ""matter if you are trying to use it"");
                }
            } catch (IOException e) {
                out.println(e.getMessage());
            }
        }
    }

    
    private static void doReportParserInfo(PrintStream out) {
        String parserName = getXmlParserName();
        String parserLocation = getXMLParserLocation();
        printParserInfo(out, ""XML Parser"", parserName, parserLocation);
        printParserInfo(out, ""Namespace-aware parser"",
                getNamespaceParserName(),
                getNamespaceParserLocation());
    }

    private static void printParserInfo(PrintStream out,
                                        String parserType,
                                        String parserName,
                                        String parserLocation) {
        if (parserName == null) {
            parserName = ""unknown"";
        }
        if (parserLocation == null) {
            parserLocation = ""unknown"";
        }
        out.println(parserType + "" : "" + parserName);
        out.println(parserType + "" Location: "" + parserLocation);
    }

    
    private static void doReportTempDir(PrintStream out) {
        String tempdir = System.getProperty(""java.io.tmpdir"");
        if (tempdir == null) {
            out.println(""Warning: java.io.tmpdir is undefined"");
            return;
        }
        out.println(""Temp dir is "" + tempdir);
        File tempDirectory = new File(tempdir);
        if (!tempDirectory.exists()) {
            out.println(""Warning, java.io.tmpdir directory does not exist: ""
                    + tempdir);
            return;
        }
        
        long now = System.currentTimeMillis();
        File tempFile = null;
        FileOutputStream fileout = null;
        try {
            tempFile = File.createTempFile(""diag"", ""txt"", tempDirectory);
            
            fileout = new FileOutputStream(tempFile);
            byte[] buffer = new byte[KILOBYTE];
            for (int i = 0; i < TEST_FILE_SIZE; i++) {
                fileout.write(buffer);
            }
            fileout.close();
            fileout = null;
            long filetime = tempFile.lastModified();
            tempFile.delete();
            out.println(""Temp dir is writeable"");
            long drift = filetime - now;
            out.println(""Temp dir alignment with system clock is "" + drift + "" ms"");
            if (Math.abs(drift) > BIG_DRIFT_LIMIT) {
                out.println(""Warning: big clock drift -maybe a network filesystem"");
            }
        } catch (IOException e) {
            ignoreThrowable(e);
            out.println(""Failed to create a temporary file in the temp dir ""
                + tempdir);
            out.println(""File  "" + tempFile + "" could not be created/written to"");
        } finally {
            FileUtils.close(fileout);
            if (tempFile != null && tempFile.exists()) {
                tempFile.delete();
            }
        }
    }

    
    private static void doReportLocale(PrintStream out) {
        
        Calendar cal = Calendar.getInstance();
        TimeZone tz = cal.getTimeZone();
        out.println(""Timezone "" + tz.getDisplayName()
                + "" offset="" + tz.getOffset(cal.get(Calendar.ERA),
                        cal.get(Calendar.YEAR),
                        cal.get(Calendar.MONTH),
                        cal.get(Calendar.DAY_OF_MONTH),
                        cal.get(Calendar.DAY_OF_WEEK),
                        ((cal.get(Calendar.HOUR_OF_DAY) * MINUTES_PER_HOUR
                         + cal.get(Calendar.MINUTE)) * SECONDS_PER_MINUTE
                         + cal.get(Calendar.SECOND)) * SECONDS_PER_MILLISECOND
                         + cal.get(Calendar.MILLISECOND)));
    }

    
    private static void printProperty(PrintStream out, String key) {
        String value = getProperty(key);
        if (value != null) {
            out.print(key);
            out.print("" = "");
            out.print('""');
            out.print(value);
            out.println('""');
        }
    }

    
    private static void doReportProxy(PrintStream out) {
        printProperty(out, ProxySetup.HTTP_PROXY_HOST);
        printProperty(out, ProxySetup.HTTP_PROXY_PORT);
        printProperty(out, ProxySetup.HTTP_PROXY_USERNAME);
        printProperty(out, ProxySetup.HTTP_PROXY_PASSWORD);
        printProperty(out, ProxySetup.HTTP_NON_PROXY_HOSTS);
        printProperty(out, ProxySetup.HTTPS_PROXY_HOST);
        printProperty(out, ProxySetup.HTTPS_PROXY_PORT);
        printProperty(out, ProxySetup.HTTPS_NON_PROXY_HOSTS);
        printProperty(out, ProxySetup.FTP_PROXY_HOST);
        printProperty(out, ProxySetup.FTP_PROXY_PORT);
        printProperty(out, ProxySetup.FTP_NON_PROXY_HOSTS);
        printProperty(out, ProxySetup.SOCKS_PROXY_HOST);
        printProperty(out, ProxySetup.SOCKS_PROXY_PORT);
        printProperty(out, ProxySetup.SOCKS_PROXY_USERNAME);
        printProperty(out, ProxySetup.SOCKS_PROXY_PASSWORD);

        if (JavaEnvUtils.getJavaVersionNumber() < 15) {
            return;
        }
        printProperty(out, ProxySetup.USE_SYSTEM_PROXIES);
        final String proxyDiagClassname
            = ""org.apache.tools.ant.util.java15.ProxyDiagnostics"";
        try {
            Class proxyDiagClass = Class.forName(proxyDiagClassname);
            Object instance = proxyDiagClass.newInstance();
            out.println(""Java1.5+ proxy settings:"");
            out.println(instance.toString());
        } catch (ClassNotFoundException e) {
            
        } catch (IllegalAccessException e) {
            
        } catch (InstantiationException e) {
            
        } catch (NoClassDefFoundError e) {
            
        }
    }

}
"
org.apache.tools.ant.util.LineOrientedOutputStream,7,2,2,2,15,0,2,0,5,0.866666667,143,1.0,0,0.454545455,0.392857143,1,1,18.71428571,1,0.8571,0,"

package org.apache.tools.ant.util;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;


public abstract class LineOrientedOutputStream extends OutputStream {

    
    private static final int INTIAL_SIZE = 132;

    
    private static final int CR = 0x0d;

    
    private static final int LF = 0x0a;

    private ByteArrayOutputStream buffer
        = new ByteArrayOutputStream(INTIAL_SIZE);
    private boolean skip = false;

    
    public final void write(int cc) throws IOException {
        final byte c = (byte) cc;
        if ((c == LF) || (c == CR)) {
            if (!skip) {
              processBuffer();
            }
        } else {
            buffer.write(cc);
        }
        skip = (c == CR);
    }

    
    public final void flush() throws IOException {
        if (buffer.size() > 0) {
            processBuffer();
        }
    }

    
    protected void processBuffer() throws IOException {
        try {
            processLine(buffer.toString());
        } finally {
            buffer.reset();
        }
    }

    
    protected abstract void processLine(String line) throws IOException;

    
    public final void close() throws IOException {
        if (buffer.size() > 0) {
            processBuffer();
        }
        super.close();
    }

    
    public final void write(byte[] b, int off, int len) throws IOException {
        
        int offset = off;
        int blockStartOffset = offset;
        int remaining = len;
        while (remaining > 0) {
            while (remaining > 0 && b[offset] != LF && b[offset] != CR) {
                offset++;
                remaining--;
            }
            
            int blockLength = offset - blockStartOffset;
            if (blockLength > 0) {
                buffer.write(b, blockStartOffset, blockLength);
            }
            while (remaining > 0 && (b[offset] == LF || b[offset] == CR)) {
                write(b[offset]);
                offset++;
                remaining--;
            }
            blockStartOffset = offset;
        }
    }

}
"
org.apache.tools.ant.taskdefs.optional.splash.SplashScreen,12,5,0,3,39,58,1,2,11,0.690909091,213,1.0,0,0.975429975,0.4,0,0,16.33333333,2,1.0,1,"

package org.apache.tools.ant.taskdefs.optional.splash;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JWindow;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildListener;

class SplashScreen extends JWindow implements ActionListener, BuildListener {

    private JLabel text;
    private JProgressBar pb;
    private int total;
    private static final int MIN = 0;
    private static final int MAX = 200;

    public SplashScreen(String msg) {
        init(null);
        setText(msg);
    }

    public SplashScreen(ImageIcon img) {
        init(img);
    }

    protected void init(ImageIcon img) {

        JPanel pan = (JPanel) getContentPane();
        JLabel piccy;
        if (img == null) {
            piccy = new JLabel();
        } else {
            piccy = new JLabel(img);
        }

        piccy.setBorder(BorderFactory.createLineBorder(Color.black, 1));
        text = new JLabel(""Building...."", JLabel.CENTER);
        text.setFont(new Font(""Sans-Serif"", Font.BOLD, 12));
        text.setBorder(BorderFactory.createEtchedBorder());

        pb = new JProgressBar(MIN, MAX);
        pb.setBorder(BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        JPanel pan2 = new JPanel();
        pan2.setLayout(new BorderLayout());

        pan2.add(text, BorderLayout.NORTH);
        pan2.add(pb, BorderLayout.SOUTH);

        pan.setLayout(new BorderLayout());
        pan.add(piccy, BorderLayout.CENTER);
        pan.add(pan2, BorderLayout.SOUTH);

        pan.setBorder(BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        pack();

        Dimension size = getSize();
        Dimension scr = Toolkit.getDefaultToolkit().getScreenSize();
        int x = (scr.width - size.width) / 2;
        int y = (scr.height - size.height) / 2;
        setBounds(x, y, size.width, size.height);
    }

    public void setText(String txt) {
        text.setText(txt);
    }

    public void actionPerformed(ActionEvent a) {
        if (total < MAX) {
            total++;
        } else {
            total = MIN;
        }
        pb.setValue(total);
    }

    public void buildStarted(BuildEvent event) {
        actionPerformed(null);
    }

    public void buildFinished(BuildEvent event) {
        pb.setValue(MAX);
        setVisible(false);
        dispose();
    }
    public void targetStarted(BuildEvent event) {
        actionPerformed(null);
    }

    public void targetFinished(BuildEvent event) {
        actionPerformed(null);
    }

    public void taskStarted(BuildEvent event) {
        actionPerformed(null);
    }

    public void taskFinished(BuildEvent event) {
        actionPerformed(null);
    }

    public void messageLogged(BuildEvent event) {
        actionPerformed(null);
    }
}

"
org.apache.tools.ant.types.optional.ScriptFilter,13,3,0,8,26,0,0,8,12,0.611111111,98,1.0,2,0.47826087,0.282051282,1,1,6.307692308,1,0.9231,1,"

package org.apache.tools.ant.types.optional;

import org.apache.tools.ant.filters.TokenFilter;
import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.ScriptRunnerBase;
import org.apache.tools.ant.util.ScriptRunnerHelper;


public class ScriptFilter extends TokenFilter.ChainableReaderFilter {
    
    private ScriptRunnerHelper helper = new ScriptRunnerHelper();

    
    private ScriptRunnerBase   runner = null;

    
    private String token;

    
    public void setProject(Project project) {
        super.setProject(project);
        helper.setProjectComponent(this);
    }

    
    public void setLanguage(String language) {
        helper.setLanguage(language);
    }

    
    private void init() throws BuildException {
        if (runner != null) {
            return;
        }
        runner = helper.getScriptRunner();
    }

    
    public void setToken(String token) {
        this.token = token;
    }

    
    public String getToken() {
        return token;
    }

    
    public String filter(String token) {
        init();
        setToken(token);
        runner.executeScript(""ant_filter"");
        return getToken();
    }

    
    public void setSrc(File file) {
        helper.setSrc(file);
    }

    
    public void addText(String text) {
        helper.addText(text);
    }

    
    public void setManager(String manager) {
        helper.setManager(manager);
    }
    
    public void setClasspath(Path classpath) {
        helper.setClasspath(classpath);
    }

    
    public Path createClasspath() {
        return helper.createClasspath();
    }

    
    public void setClasspathRef(Reference r) {
        helper.setClasspathRef(r);
    }

}
"
org.apache.tools.ant.taskdefs.optional.jsp.compilers.JspCompilerAdapterFactory,4,1,0,11,18,6,1,10,2,2.0,97,0.0,0,0.0,0.5,0,0,23.25,1,0.75,0,"
package org.apache.tools.ant.taskdefs.optional.jsp.compilers;

import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.optional.jsp.JspNameMangler;
import org.apache.tools.ant.taskdefs.optional.jsp.Jasper41Mangler;



public final class JspCompilerAdapterFactory {

    
    private JspCompilerAdapterFactory() {
    }

    
    public static JspCompilerAdapter getCompiler(String compilerType, Task task)
        throws BuildException {
        return getCompiler(compilerType, task,
                           task.getProject().createClassLoader(null));
    }

    
    public static JspCompilerAdapter getCompiler(String compilerType, Task task,
                                                 AntClassLoader loader)
        throws BuildException {

        if (compilerType.equalsIgnoreCase(""jasper"")) {
            
            return new JasperC(new JspNameMangler());
        }
        if (compilerType.equalsIgnoreCase(""jasper41"")) {
            
            return new JasperC(new Jasper41Mangler());
        }
        return resolveClassName(compilerType, loader);
    }

    
    private static JspCompilerAdapter resolveClassName(String className,
                                                       AntClassLoader classloader)
        throws BuildException {
        try {
            Class c = classloader.findClass(className);
            Object o = c.newInstance();
            return (JspCompilerAdapter) o;
        } catch (ClassNotFoundException cnfe) {
            throw new BuildException(className + "" can\'t be found."", cnfe);
        } catch (ClassCastException cce) {
            throw new BuildException(className + "" isn\'t the classname of ""
                                     + ""a compiler adapter."", cce);
        } catch (Throwable t) {
            
            throw new BuildException(className + "" caused an interesting ""
                                     + ""exception."", t);
        }
    }

}
"
org.apache.tools.ant.taskdefs.LoadResource,8,3,1,10,45,2,1,9,8,0.714285714,336,1.0,1,0.840909091,0.35,2,2,40.25,2,1.125,1,"
package org.apache.tools.ant.taskdefs;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.filters.util.ChainReaderHelper;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.util.FileUtils;


public class LoadResource extends Task {

    
    private Resource src;

    
    private boolean failOnError = true;

    
    private boolean quiet = false;

    
    private String encoding = null;

    
    private String property = null;

    
    private final Vector filterChains = new Vector();

    

    public final void setEncoding(final String encoding) {
        this.encoding = encoding;
    }


    
    public final void setProperty(final String property) {
        this.property = property;
    }

    
    public final void setFailonerror(final boolean fail) {
        failOnError = fail;
    }

    
    public void setQuiet(final boolean quiet) {
        this.quiet = quiet;
        if (quiet) {
            this.failOnError = false;
        }
    }

    
    public final void execute()
        throws BuildException {
        
        if (src == null) {
            throw new BuildException(""source resource not defined"");
        }
        if (property == null) {
            throw new BuildException(""output property not defined"");
        }
        if (quiet && failOnError) {
            throw new BuildException(""quiet and failonerror cannot both be ""
                                     + ""set to true"");
        }
        if (!src.isExists()) {
            String message = src + "" doesn't exist"";
            if (failOnError) {
                throw new BuildException(message);
            } else {
                log(message, quiet ? Project.MSG_WARN : Project.MSG_ERR);
                return;
            }
        }
        InputStream is = null;
        BufferedInputStream bis = null;
        Reader instream = null;
        log(""loading "" + src + "" into property "" + property,
            Project.MSG_VERBOSE);
        try {
            final long len = src.getSize();
            log(""resource size = ""
                + (len != Resource.UNKNOWN_SIZE ? String.valueOf(len)
                   : ""unknown""), Project.MSG_DEBUG);
            
            final int size = (int) len;
            
            is = src.getInputStream();
            bis = new BufferedInputStream(is);
            if (encoding == null) {
                instream = new InputStreamReader(bis);
            } else {
                instream = new InputStreamReader(bis, encoding);
            }

            String text = """";
            if (size != 0) {
                ChainReaderHelper crh = new ChainReaderHelper();
                if (len != Resource.UNKNOWN_SIZE) {
                    crh.setBufferSize(size);
                }
                crh.setPrimaryReader(instream);
                crh.setFilterChains(filterChains);
                crh.setProject(getProject());
                instream = crh.getAssembledReader();

                text = crh.readFully(instream);
            }

            if (text != null) {
                if (text.length() > 0) {
                    getProject().setNewProperty(property, text);
                    log(""loaded "" + text.length() + "" characters"",
                        Project.MSG_VERBOSE);
                    log(property + "" := "" + text, Project.MSG_DEBUG);
                }
            }

        } catch (final IOException ioe) {
            final String message = ""Unable to load resource: ""
                + ioe.toString();
            if (failOnError) {
                throw new BuildException(message, ioe, getLocation());
            } else {
                log(message, quiet ? Project.MSG_VERBOSE : Project.MSG_ERR);
            }
        } catch (final BuildException be) {
            if (failOnError) {
                throw be;
            } else {
                log(be.getMessage(),
                    quiet ? Project.MSG_VERBOSE : Project.MSG_ERR);
            }
        } finally {
            FileUtils.close(is);
        }
    }

    
    public final void addFilterChain(FilterChain filter) {
        filterChains.addElement(filter);
    }

    
    public void addConfigured(ResourceCollection a) {
        if (a.size() != 1) {
            throw new BuildException(""only single argument resource collections""
                                     + "" are supported"");
        }
        src = (Resource) a.iterator().next();
    }

}
"
org.apache.tools.ant.taskdefs.optional.extension.ExtensionAdapter,12,3,0,11,28,36,5,6,10,0.727272727,214,1.0,2,0.731707317,0.555555556,1,1,16.25,1,0.9167,0,"
package org.apache.tools.ant.taskdefs.optional.extension;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.Reference;


public class ExtensionAdapter extends DataType {
    
    private String extensionName;

    
    private DeweyDecimal specificationVersion;

    
    private String specificationVendor;

    
    private String implementationVendorID;

    
    private String implementationVendor;

    
    private DeweyDecimal implementationVersion;

    
    private String implementationURL;

    
    public void setExtensionName(final String extensionName) {
        verifyNotAReference();
        this.extensionName = extensionName;
    }

    
    public void setSpecificationVersion(final String specificationVersion) {
        verifyNotAReference();
        this.specificationVersion = new DeweyDecimal(specificationVersion);
    }

    
    public void setSpecificationVendor(final String specificationVendor) {
        verifyNotAReference();
        this.specificationVendor = specificationVendor;
    }

    
    public void setImplementationVendorId(final String implementationVendorID) {
        verifyNotAReference();
        this.implementationVendorID = implementationVendorID;
    }

    
    public void setImplementationVendor(final String implementationVendor) {
        verifyNotAReference();
        this.implementationVendor = implementationVendor;
    }

    
    public void setImplementationVersion(final String implementationVersion) {
        verifyNotAReference();
        this.implementationVersion = new DeweyDecimal(implementationVersion);
    }

    
    public void setImplementationUrl(final String implementationURL) {
        verifyNotAReference();
        this.implementationURL = implementationURL;
    }

    
    public void setRefid(final Reference reference)
        throws BuildException {
        if (null != extensionName
            || null != specificationVersion
            || null != specificationVendor
            || null != implementationVersion
            || null != implementationVendorID
            || null != implementationVendor
            || null != implementationURL) {
            throw tooManyAttributes();
        }
        
        Object o = reference.getReferencedObject(getProject());
        if (o instanceof ExtensionAdapter) {
            final ExtensionAdapter other = (ExtensionAdapter) o;
            extensionName = other.extensionName;
            specificationVersion = other.specificationVersion;
            specificationVendor = other.specificationVendor;
            implementationVersion = other.implementationVersion;
            implementationVendorID = other.implementationVendorID;
            implementationVendor = other.implementationVendor;
            implementationURL = other.implementationURL;
        } else {
            final String message =
                reference.getRefId() + "" doesn\'t refer to a Extension"";
            throw new BuildException(message);
        }

        super.setRefid(reference);
    }

    private void verifyNotAReference()
        throws BuildException {
        if (isReference()) {
            throw tooManyAttributes();
        }
    }

    
    Extension toExtension()
        throws BuildException {
        if (null == extensionName) {
            final String message = ""Extension is missing name."";
            throw new BuildException(message);
        }

        String specificationVersionString = null;
        if (null != specificationVersion) {
            specificationVersionString = specificationVersion.toString();
        }
        String implementationVersionString = null;
        if (null != implementationVersion) {
            implementationVersionString = implementationVersion.toString();
        }
        return new Extension(extensionName,
                              specificationVersionString,
                              specificationVendor,
                              implementationVersionString,
                              implementationVendor,
                              implementationVendorID,
                              implementationURL);
    }

    
    public String toString() {
        return ""{"" + toExtension().toString() + ""}"";
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.ClassCPInfo,5,2,0,7,14,0,6,3,5,0.375,51,1.0,0,0.6,0.466666667,1,1,8.8,1,0.8,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class ClassCPInfo extends ConstantPoolEntry {

    
    private String className;

    
    private int index;

    
    public ClassCPInfo() {
        super(CONSTANT_CLASS, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        index = cpStream.readUnsignedShort();
        className = ""unresolved"";
    }

    
    public String toString() {
        return ""Class Constant Pool Entry for "" + className + ""["" + index + ""]"";
    }

    
    public void resolve(ConstantPool constantPool) {
        className = ((Utf8CPInfo) constantPool.getEntry(index)).getValue();

        super.resolve(constantPool);
    }

    
    public String getClassName() {
        return className;
    }

}

"
org.apache.tools.ant.util.regexp.JakartaOroMatcher,9,1,1,8,21,22,1,7,7,0.541666667,135,1.0,0,0.0,0.666666667,0,0,13.66666667,4,1.2222,0,"

package org.apache.tools.ant.util.regexp;

import java.util.Vector;
import org.apache.oro.text.regex.MatchResult;
import org.apache.oro.text.regex.Pattern;
import org.apache.oro.text.regex.Perl5Compiler;
import org.apache.oro.text.regex.Perl5Matcher;
import org.apache.tools.ant.BuildException;


public class JakartaOroMatcher implements RegexpMatcher {

    private String pattern;
    
    protected final Perl5Compiler compiler = new Perl5Compiler();
    protected final Perl5Matcher matcher = new Perl5Matcher();
    

    
    public JakartaOroMatcher() {
    }

    
    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    
    public String getPattern() {
        return this.pattern;
    }

    
    protected Pattern getCompiledPattern(int options)
        throws BuildException {
        try {
            
            Pattern p = compiler.compile(pattern, getCompilerOptions(options));
            return p;
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }

    
    public boolean matches(String argument) throws BuildException {
        return matches(argument, MATCH_DEFAULT);
    }

    
    public boolean matches(String input, int options)
        throws BuildException {
        Pattern p = getCompiledPattern(options);
        return matcher.contains(input, p);
    }

    
    public Vector getGroups(String argument) throws BuildException {
        return getGroups(argument, MATCH_DEFAULT);
    }

    
    public Vector getGroups(String input, int options)
        throws BuildException {
        if (!matches(input, options)) {
            return null;
        }
        Vector v = new Vector();
        MatchResult mr = matcher.getMatch();
        int cnt = mr.groups();
        for (int i = 0; i < cnt; i++) {
            String match = mr.group(i);
            
            if (match == null) {
                match = """";
            }
            v.addElement(match);
        }
        return v;
    }

    
    protected int getCompilerOptions(int options) {
        int cOptions = Perl5Compiler.DEFAULT_MASK;

        if (RegexpUtil.hasFlag(options, MATCH_CASE_INSENSITIVE)) {
            cOptions |= Perl5Compiler.CASE_INSENSITIVE_MASK;
        }
        if (RegexpUtil.hasFlag(options, MATCH_MULTILINE)) {
            cOptions |= Perl5Compiler.MULTILINE_MASK;
        }
        if (RegexpUtil.hasFlag(options, MATCH_SINGLELINE)) {
            cOptions |= Perl5Compiler.SINGLELINE_MASK;
        }

        return cOptions;
    }

}
"
org.apache.tools.ant.types.spi.Provider,4,2,0,4,8,0,1,3,4,0.333333333,37,1.0,0,0.75,0.625,0,0,8.0,3,1.25,0,"
package org.apache.tools.ant.types.spi;

import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.BuildException;


public class Provider extends ProjectComponent {
    private String type;

    
    public String getClassName() {
        return type;
    }

    
    public void setClassName(String type) {
        this.type = type;
    }

    
    public void check() {
        if (type == null) {
            throw new BuildException(
                ""classname attribute must be set for provider element"",
                getLocation());
        }
        if (type.length() == 0) {
            throw new BuildException(
                ""Invalid empty classname"", getLocation());
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Have,2,4,0,4,8,1,0,4,2,2.0,25,0.0,0,0.980769231,1.0,1,1,11.5,1,0.5,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;



public class P4Have extends P4Base {

    
    public void execute() throws BuildException {
        execP4Command(""have "" + P4CmdOpts + "" "" + P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.optional.Native2Ascii,16,4,0,19,56,60,5,16,14,0.80952381,362,1.0,2,0.838709677,0.25,3,3,21.1875,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapter;
import org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapterFactory;
import org.apache.tools.ant.types.Mapper;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.ant.util.SourceFileScanner;
import org.apache.tools.ant.util.facade.FacadeTaskHelper;
import org.apache.tools.ant.util.facade.ImplementationSpecificArgument;


public class Native2Ascii extends MatchingTask {

    private boolean reverse = false;  
    private String encoding = null;   
    private File srcDir = null;       
    private File destDir = null;      
    private String extension = null;  

    private Mapper mapper;
    private FacadeTaskHelper facade = null;

    
    public Native2Ascii() {
        facade = new FacadeTaskHelper(Native2AsciiAdapterFactory.getDefault());
    }

    
    public void setReverse(boolean reverse) {
        this.reverse = reverse;
    }

    
    public boolean getReverse() {
        return reverse;
    }

    
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    
    public String getEncoding() {
        return encoding;
    }

    
    public void setSrc(File srcDir) {
        this.srcDir = srcDir;
    }


    
    public void setDest(File destDir) {
        this.destDir = destDir;
    }

    
    public void setExt(String ext) {
        this.extension = ext;
    }

    
    public void setImplementation(String impl) {
        if (""default"".equals(impl)) {
            facade.setImplementation(Native2AsciiAdapterFactory.getDefault());
        } else {
            facade.setImplementation(impl);
        }
    }

    
    public Mapper createMapper() throws BuildException {
        if (mapper != null) {
            throw new BuildException(""Cannot define more than one mapper"",
                                     getLocation());
        }
        mapper = new Mapper(getProject());
        return mapper;
    }

    
    public void add(FileNameMapper fileNameMapper) {
        createMapper().add(fileNameMapper);
    }

    
    public ImplementationSpecificArgument createArg() {
        ImplementationSpecificArgument arg =
            new ImplementationSpecificArgument();
        facade.addImplementationArgument(arg);
        return arg;
    }

    
    public void execute() throws BuildException {

        DirectoryScanner scanner = null; 
        String[] files;                  

        
        if (srcDir == null) {
            srcDir = getProject().resolveFile(""."");
        }

        
        if (destDir == null) {
            throw new BuildException(""The dest attribute must be set."");
        }

        
        
        
        if (srcDir.equals(destDir) && extension == null && mapper == null) {
            throw new BuildException(""The ext attribute or a mapper must be set if""
                                     + "" src and dest dirs are the same."");
        }

        FileNameMapper m = null;
        if (mapper == null) {
            if (extension == null) {
                m = new IdentityMapper();
            } else {
                m = new ExtMapper();
            }
        } else {
            m = mapper.getImplementation();
        }

        scanner = getDirectoryScanner(srcDir);
        files = scanner.getIncludedFiles();
        SourceFileScanner sfs = new SourceFileScanner(this);
        files = sfs.restrict(files, srcDir, destDir, m);
        int count = files.length;
        if (count == 0) {
            return;
        }
        String message = ""Converting "" + count + "" file""
            + (count != 1 ? ""s"" : """") + "" from "";
        log(message + srcDir + "" to "" + destDir);
        for (int i = 0; i < files.length; i++) {
            convert(files[i], m.mapFileName(files[i])[0]);
        }
    }

    
    private void convert(String srcName, String destName)
        throws BuildException {
        File srcFile;                         
        File destFile;                        

        
        srcFile = new File(srcDir, srcName);
        destFile = new File(destDir, destName);

        
        if (srcFile.equals(destFile)) {
            throw new BuildException(""file "" + srcFile
                                     + "" would overwrite its self"");
        }

        
        
        String parentName = destFile.getParent();
        if (parentName != null) {
            File parentFile = new File(parentName);

            if ((!parentFile.exists()) && (!parentFile.mkdirs())) {
                throw new BuildException(""cannot create parent directory ""
                                         + parentName);
            }
        }

        log(""converting "" + srcName, Project.MSG_VERBOSE);
        Native2AsciiAdapter ad =
            Native2AsciiAdapterFactory.getAdapter(facade.getImplementation(),
                                                  this);
        if (!ad.convert(this, srcFile, destFile)) {
            throw new BuildException(""conversion failed"");
        }
    }

    
    public String[] getCurrentArgs() {
        return facade.getArgs();
    }

    private class ExtMapper implements FileNameMapper {

        public void setFrom(String s) {
        }
        public void setTo(String s) {
        }

        public String[] mapFileName(String fileName) {
            int lastDot = fileName.lastIndexOf('.');
            if (lastDot >= 0) {
                return new String[] {fileName.substring(0, lastDot)
                                         + extension};
            } else {
                return new String[] {fileName + extension};
            }
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.j2ee.AbstractHotDeploymentTool,15,1,2,7,24,77,2,5,13,0.871428571,109,1.0,2,0.0,0.333333333,0,0,5.933333333,2,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.j2ee;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Path;


public abstract class AbstractHotDeploymentTool implements HotDeploymentTool {
    
    private ServerDeploy task;

    
    private Path classpath;

    
    private String userName;

    
    private String password;

    
    private String server;

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(task.getProject());
        }
        return classpath.createPath();
    }

    
    protected abstract boolean isActionValid();

    
    public void validateAttributes() throws BuildException {
        if (task.getAction() == null) {
            throw new BuildException(""The \""action\"" attribute must be set"");
        }

        if (!isActionValid()) {
            throw new BuildException(""Invalid action \"""" + task.getAction() + ""\"" passed"");
        }

        if (classpath == null) {
            throw new BuildException(""The classpath attribute must be set"");
        }
    }

    
    public abstract void deploy() throws BuildException;

    
    public void setTask(ServerDeploy task) {
        this.task = task;
    }

    
    protected ServerDeploy getTask() {
        return task;
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public void setClasspath(Path classpath) {
        this.classpath = classpath;
    }

    
    public String getUserName() {
        return userName;
    }

    
    public void setUserName(String userName) {
        this.userName = userName;
    }

    
    public String getPassword() {
        return password;
    }

    
    public void setPassword(String password) {
        this.password = password;
    }

    
    public String getServer() {
        return server;
    }

    
    public void setServer(String server) {
        this.server = server;
    }
}
"
org.apache.tools.ant.types.resources.comparators.Date,2,4,0,3,4,1,1,2,1,2.0,12,0.0,0,0.971428571,0.75,1,1,5.0,1,0.5,1,"
package org.apache.tools.ant.types.resources.comparators;

import org.apache.tools.ant.types.Resource;


public class Date extends ResourceComparator {
    
    protected int resourceCompare(Resource foo, Resource bar) {
        return (int) (foo.getLastModified() - bar.getLastModified());
    }

}
"
org.apache.tools.ant.Location,11,1,0,150,26,41,149,1,9,0.56,134,0.8,2,0.0,0.3,1,1,10.72727273,4,1.0,0,"

package org.apache.tools.ant;

import java.io.Serializable;
import org.apache.tools.ant.util.FileUtils;
import org.xml.sax.Locator;


public class Location implements Serializable {

    
    private String fileName;
    
    private int lineNumber;
    
    private int columnNumber;

    
    public static final Location UNKNOWN_LOCATION = new Location();

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private Location() {
        this(null, 0, 0);
    }

    
    public Location(String fileName) {
        this(fileName, 0, 0);
    }

    
    public Location(Locator loc) {
        this(loc.getSystemId(), loc.getLineNumber(), loc.getColumnNumber());
    }

    
    public Location(String fileName, int lineNumber, int columnNumber) {
        if (fileName != null && fileName.startsWith(""file:"")) {
            this.fileName = FILE_UTILS.fromURI(fileName);
        } else {
            this.fileName = fileName;
        }
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }

    
    public String getFileName() {
        return fileName;
    }

    
    public int getLineNumber() {
        return lineNumber;
    }

    
    public int getColumnNumber() {
        return columnNumber;
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();

        if (fileName != null) {
            buf.append(fileName);

            if (lineNumber != 0) {
                buf.append("":"");
                buf.append(lineNumber);
            }

            buf.append("": "");
        }

        return buf.toString();
    }

    
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null) {
            return false;
        }
        if (!(other.getClass() == getClass())) {
            return false;
        }
        return toString().equals(other.toString());
    }

    
    public int hashCode() {
        return toString().hashCode();
    }
}
"
org.apache.tools.ant.types.ZipFileSet,9,6,0,12,28,6,4,8,4,0.125,143,1.0,0,0.953125,0.288888889,5,18,14.77777778,4,1.5556,0,"
package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class ZipFileSet extends ArchiveFileSet {

    private String encoding = null;

    
    public ZipFileSet() {
        super();
    }

    
    protected ZipFileSet(FileSet fileset) {
        super(fileset);
    }

    
    protected ZipFileSet(ZipFileSet fileset) {
        super(fileset);
        encoding = fileset.encoding;
    }

    
    public void setEncoding(String enc) {
        checkZipFileSetAttributesAllowed();
        this.encoding = enc;
    }

    
    public String getEncoding() {
        if (isReference()) {
            AbstractFileSet ref = getRef(getProject());
            if (ref instanceof ZipFileSet) {
                return ((ZipFileSet) ref).getEncoding();
            } else {
                return null;
            }
        }
        return encoding;
    }

    
    protected ArchiveScanner newArchiveScanner() {
        ZipScanner zs = new ZipScanner();
        zs.setEncoding(encoding);
        return zs;
    }

    
    protected AbstractFileSet getRef(Project p) {
        dieOnCircularReference(p);
        Object o = getRefid().getReferencedObject(p);
        if (o instanceof ZipFileSet) {
            return (AbstractFileSet) o;
        } else if (o instanceof FileSet) {
            ZipFileSet zfs = new ZipFileSet((FileSet) o);
            configureFileSet(zfs);
            return zfs;
        } else {
            String msg = getRefid().getRefId() + "" doesn\'t denote a zipfileset or a fileset"";
            throw new BuildException(msg);
        }
    }

    
    public Object clone() {
        if (isReference()) {
            return ((ZipFileSet) getRef(getProject())).clone();
        } else {
            return super.clone();
        }
    }

    
    private void checkZipFileSetAttributesAllowed() {
        if (getProject() == null
            || (isReference()
                && (getRefid().getReferencedObject(
                        getProject())
                    instanceof ZipFileSet))) {
            checkAttributesAllowed();
        }
    }

}
"
org.apache.tools.ant.taskdefs.GUnzip,4,4,0,5,26,6,0,5,1,1.166666667,129,0.5,0,0.942307692,1.0,3,5,30.75,5,2.0,0,"

package org.apache.tools.ant.taskdefs;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.GZIPInputStream;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;



public class GUnzip extends Unpack {

    private static final String DEFAULT_EXTENSION = "".gz"";

    
    protected String getDefaultExtension() {
        return DEFAULT_EXTENSION;
    }

    
    protected void extract() {
        if (source.lastModified() > dest.lastModified()) {
            log(""Expanding "" + source.getAbsolutePath() + "" to ""
                        + dest.getAbsolutePath());

            FileOutputStream out = null;
            GZIPInputStream zIn = null;
            InputStream fis = null;
            try {
                out = new FileOutputStream(dest);
                fis = srcResource.getInputStream();
                zIn = new GZIPInputStream(fis);
                byte[] buffer = new byte[8 * 1024];
                int count = 0;
                do {
                    out.write(buffer, 0, count);
                    count = zIn.read(buffer, 0, buffer.length);
                } while (count != -1);
            } catch (IOException ioe) {
                String msg = ""Problem expanding gzip "" + ioe.getMessage();
                throw new BuildException(msg, ioe, getLocation());
            } finally {
                FileUtils.close(fis);
                FileUtils.close(out);
                FileUtils.close(zIn);
            }
        }
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(GUnzip.class);
    }
}
"
org.apache.tools.ant.util.LeadPipeInputStream,9,3,0,3,20,34,1,2,9,0.625,177,1.0,1,0.761904762,0.333333333,1,3,18.55555556,4,1.1111,0,"

package org.apache.tools.ant.util;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.Project;


public class LeadPipeInputStream extends PipedInputStream {
    private ProjectComponent managingPc;

    
    public LeadPipeInputStream() {
        super();
    }

    
    public LeadPipeInputStream(int size) {
        super();
        setBufferSize(size);
    }

    
    public LeadPipeInputStream(PipedOutputStream src) throws IOException {
        super(src);
    }

    
    public LeadPipeInputStream(PipedOutputStream src, int size) throws IOException {
        super(src);
        setBufferSize(size);
    }

    
    
    public synchronized int read() throws IOException {
        int result = -1;
        try {
            result = super.read();
        } catch (IOException eyeOhEx) {
            if (""write end dead"".equalsIgnoreCase(eyeOhEx.getMessage())) {
                if (super.in > 0 && super.out < super.buffer.length
                    && super.out > super.in) {
                    result = super.buffer[super.out++] & 0xFF;
                }
            } else {
                log(""error at LeadPipeInputStream.read():  ""
                    + eyeOhEx.getMessage(), Project.MSG_INFO);
            }
        }
        return result;
    }

    
    public synchronized void setBufferSize(int size) {
        if (size > buffer.length) {
            byte[] newBuffer = new byte[size];
            if (in >= 0) {
                if (in > out) {
                    System.arraycopy(buffer, out, newBuffer, out, in - out);
                } else {
                    int outlen = buffer.length - out;
                    System.arraycopy(buffer, out, newBuffer, 0, outlen);
                    System.arraycopy(buffer, 0, newBuffer, outlen, in);
                    in += outlen;
                    out = 0;
                }
            }
            buffer = newBuffer;
        }
    }

    
    public void setManagingTask(Task task) {
        setManagingComponent(task);
    }

    
    public void setManagingComponent(ProjectComponent pc) {
        this.managingPc = pc;
    }

    
    public void log(String message, int loglevel) {
        if (managingPc != null) {
            managingPc.log(message, loglevel);
        } else {
            if (loglevel > Project.MSG_WARN) {
                System.out.println(message);
            } else {
                System.err.println(message);
            }
        }
    }
}

"
org.apache.tools.ant.helper.AntXMLContext,28,1,0,11,52,282,7,4,28,0.919753086,300,1.0,3,0.0,0.13961039,0,0,9.285714286,3,1.2857,0,"
package org.apache.tools.ant.helper;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import org.xml.sax.Locator;
import org.xml.sax.Attributes;


import org.apache.tools.ant.Project;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.RuntimeConfigurable;



public class AntXMLContext {
    
    private Project project;

    
    private File buildFile;

    
    private Vector targetVector = new Vector();

    
    private File buildFileParent;

    
    private String currentProjectName;

    
    private Locator locator;

     
    private Target implicitTarget = new Target();

    
    private Target currentTarget = null;

    
    private Vector wStack = new Vector();

    
    private boolean ignoreProjectTag = false;

    
    private Map prefixMapping = new HashMap();


    
    private Map currentTargets = null;

    
    public AntXMLContext(Project project) {
        this.project = project;
        implicitTarget.setProject(project);
        implicitTarget.setName("""");
        targetVector.addElement(implicitTarget);
    }

    
    public void setBuildFile(File buildFile) {
        this.buildFile = buildFile;
        this.buildFileParent = new File(buildFile.getParent());
        implicitTarget.setLocation(new Location(buildFile.getAbsolutePath()));
    }

    
    public File getBuildFile() {
        return buildFile;
    }

    
    public File getBuildFileParent() {
        return buildFileParent;
    }

    
    public Project getProject() {
        return project;
    }

    
    public String getCurrentProjectName() {
        return currentProjectName;
    }

    
    public void setCurrentProjectName(String name) {
        this.currentProjectName = name;
    }

    
    public RuntimeConfigurable currentWrapper() {
        if (wStack.size() < 1) {
            return null;
        }
        return (RuntimeConfigurable) wStack.elementAt(wStack.size() - 1);
    }

    
    public RuntimeConfigurable parentWrapper() {
        if (wStack.size() < 2) {
            return null;
        }
        return (RuntimeConfigurable) wStack.elementAt(wStack.size() - 2);
    }

    
    public void pushWrapper(RuntimeConfigurable wrapper) {
        wStack.addElement(wrapper);
    }

    
    public void popWrapper() {
        if (wStack.size() > 0) {
            wStack.removeElementAt(wStack.size() - 1);
        }
    }

    
    public Vector getWrapperStack() {
        return wStack;
    }

    
    public void addTarget(Target target) {
        targetVector.addElement(target);
        currentTarget = target;
    }

    
    public Target getCurrentTarget() {
        return currentTarget;
    }

    
    public Target getImplicitTarget() {
        return implicitTarget;
    }

    
    public void setCurrentTarget(Target target) {
        this.currentTarget = target;
    }

    
    public void setImplicitTarget(Target target) {
        this.implicitTarget = target;
    }

    
    public Vector getTargets() {
        return targetVector;
    }

    
    public void configureId(Object element, Attributes attr) {
        String id = attr.getValue(""id"");
        if (id != null) {
            project.addIdReference(id, element);
        }
    }

    
    public Locator getLocator() {
        return locator;
    }

    
    public void setLocator(Locator locator) {
        this.locator = locator;
    }

    
    public boolean isIgnoringProjectTag() {
        return ignoreProjectTag;
    }

    
    public void setIgnoreProjectTag(boolean flag) {
        this.ignoreProjectTag = flag;
    }

    
    public void startPrefixMapping(String prefix, String uri) {
        List list = (List) prefixMapping.get(prefix);
        if (list == null) {
            list = new ArrayList();
            prefixMapping.put(prefix, list);
        }
        list.add(uri);
    }

    
    public void endPrefixMapping(String prefix) {
        List list = (List) prefixMapping.get(prefix);
        if (list == null || list.size() == 0) {
            return; 
        }
        list.remove(list.size() - 1);
    }

    
    public String getPrefixMapping(String prefix) {
        List list = (List) prefixMapping.get(prefix);
        if (list == null || list.size() == 0) {
            return null;
        }
        return (String) list.get(list.size() - 1);
    }

    
    public Map getCurrentTargets() {
        return currentTargets;
    }

    
    public void setCurrentTargets(Map currentTargets) {
        this.currentTargets = currentTargets;
    }

}


"
org.apache.tools.ant.util.regexp.JakartaRegexpMatcher,10,1,1,6,20,39,1,5,7,0.555555556,129,1.0,0,0.0,0.525,0,0,11.8,4,1.2,0,"

package org.apache.tools.ant.util.regexp;

import java.util.Vector;
import org.apache.regexp.RE;
import org.apache.regexp.RESyntaxException;
import org.apache.tools.ant.BuildException;


public class JakartaRegexpMatcher implements RegexpMatcher {

    private String pattern;

    
    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    
    public String getPattern() {
        return pattern;
    }

    
    protected RE getCompiledPattern(int options)
        throws BuildException {
        int cOptions = getCompilerOptions(options);
        try {
            RE reg = new RE(pattern);
            reg.setMatchFlags(cOptions);
            return reg;
        } catch (RESyntaxException e) {
            throw new BuildException(e);
        }
    }

    
    public boolean matches(String argument) throws BuildException {
        return matches(argument, MATCH_DEFAULT);
    }

    
    public boolean matches(String input, int options)
        throws BuildException {
        return matches(input, getCompiledPattern(options));
    }

    private boolean matches(String input, RE reg) {
        return reg.match(input);
    }

    
    public Vector getGroups(String argument) throws BuildException {
        return getGroups(argument, MATCH_DEFAULT);
    }

    
    public Vector getGroups(String input, int options)
        throws BuildException {
        RE reg = getCompiledPattern(options);
        if (!matches(input, reg)) {
            return null;
        }
        Vector v = new Vector();
        int cnt = reg.getParenCount();
        for (int i = 0; i < cnt; i++) {
            String match = reg.getParen(i);
            
            if (match == null) {
                match = """";
            }
            v.addElement(match);
        }
        return v;
    }

    
    protected int getCompilerOptions(int options) {
        int cOptions = RE.MATCH_NORMAL;

        if (RegexpUtil.hasFlag(options, MATCH_CASE_INSENSITIVE)) {
            cOptions |= RE.MATCH_CASEINDEPENDENT;
        }
        if (RegexpUtil.hasFlag(options, MATCH_MULTILINE)) {
            cOptions |= RE.MATCH_MULTILINE;
        }
        if (RegexpUtil.hasFlag(options, MATCH_SINGLELINE)) {
            cOptions |= RE.MATCH_SINGLELINE;
        }

        return cOptions;
    }

}
"
org.apache.tools.ant.util.regexp.JakartaRegexpRegexp,3,2,0,5,16,3,0,5,2,2.0,95,0.0,0,0.818181818,0.666666667,0,0,30.66666667,2,1.0,0,"
package org.apache.tools.ant.util.regexp;


import java.util.Vector;
import org.apache.regexp.RE;
import org.apache.tools.ant.BuildException;


public class JakartaRegexpRegexp extends JakartaRegexpMatcher
    implements Regexp {

    
    public JakartaRegexpRegexp() {
        super();
    }

    
    protected int getSubsOptions(int options) {
        int subsOptions = RE.REPLACE_FIRSTONLY;
        if (RegexpUtil.hasFlag(options, REPLACE_ALL)) {
            subsOptions = RE.REPLACE_ALL;
        }
        return subsOptions;
    }

    
    public String substitute(String input, String argument, int options)
        throws BuildException {
        Vector v = getGroups(input, options);

        
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < argument.length(); i++) {
            char c = argument.charAt(i);
            if (c == '\\') {
                if (++i < argument.length()) {
                    c = argument.charAt(i);
                    int value = Character.digit(c, 10);
                    if (value > -1) {
                        result.append((String) v.elementAt(value));
                    } else {
                        result.append(c);
                    }
                } else {
                    
                    result.append('\\');
                }
            } else {
                result.append(c);
            }
        }
        argument = result.toString();

        RE reg = getCompiledPattern(options);
        int sOptions = getSubsOptions(options);
        return reg.subst(input, argument, sOptions);
    }
}
"
org.apache.tools.ant.taskdefs.optional.pvcs.Pvcs,36,3,0,12,111,528,0,12,32,0.947142857,1006,1.0,0,0.513888889,0.222222222,2,2,26.38888889,3,1.0833,0,"
package org.apache.tools.ant.taskdefs.optional.pvcs;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.MessageFormat;
import java.text.ParseException;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.taskdefs.PumpStreamHandler;
import org.apache.tools.ant.types.Commandline;


public class Pvcs extends org.apache.tools.ant.Task {
    
    
    private static final int POS_1 = 1;
    private static final int POS_2 = 2;
    private static final int POS_3 = 3;

    private String pvcsbin;
    private String repository;
    private String pvcsProject;
    private Vector pvcsProjects;
    private String workspace;
    private String force;
    private String promotiongroup;
    private String label;
    private String revision;
    private boolean ignorerc;
    private boolean updateOnly;
    private String filenameFormat;
    private String lineStart;
    private String userId;
    private String config;
    
    private static final String PCLI_EXE = ""pcli"";

    
    

    
    private static final String GET_EXE = ""get"";


    
    protected int runCmd(Commandline cmd, ExecuteStreamHandler out) {
        try {
            Project aProj = getProject();
            Execute exe = new Execute(out);
            exe.setAntRun(aProj);
            exe.setWorkingDirectory(aProj.getBaseDir());
            exe.setCommandline(cmd.getCommandline());
            return exe.execute();
        } catch (java.io.IOException e) {
            String msg = ""Failed executing: "" + cmd.toString()
                + "". Exception: "" + e.getMessage();
            throw new BuildException(msg, getLocation());
        }
    }

    private String getExecutable(String exe) {
        StringBuffer correctedExe = new StringBuffer();
        if (getPvcsbin() != null) {
            if (pvcsbin.endsWith(File.separator)) {
                correctedExe.append(pvcsbin);
            } else {
                correctedExe.append(pvcsbin).append(File.separator);
            }
        }
        return correctedExe.append(exe).toString();
    }

    
    public void execute() throws org.apache.tools.ant.BuildException {
        int result = 0;

        if (repository == null || repository.trim().equals("""")) {
            throw new BuildException(""Required argument repository not specified"");
        }

        
        
        
        
        Commandline commandLine = new Commandline();
        commandLine.setExecutable(getExecutable(PCLI_EXE));

        commandLine.createArgument().setValue(""lvf"");
        commandLine.createArgument().setValue(""-z"");
        commandLine.createArgument().setValue(""-aw"");
        if (getWorkspace() != null) {
            commandLine.createArgument().setValue(""-sp"" + getWorkspace());
        }
        commandLine.createArgument().setValue(""-pr"" + getRepository());

        String uid = getUserId();

        if (uid != null) {
            commandLine.createArgument().setValue(""-id"" + uid);
        }

        
        if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
            pvcsProject = ""/"";
        }

        if (getPvcsproject() != null) {
            commandLine.createArgument().setValue(getPvcsproject());
        }
        if (!getPvcsprojects().isEmpty()) {
            Enumeration e = getPvcsprojects().elements();
            while (e.hasMoreElements()) {
                String projectName = ((PvcsProject) e.nextElement()).getName();
                if (projectName == null || (projectName.trim()).equals("""")) {
                    throw new BuildException(""name is a required attribute ""
                        + ""of pvcsproject"");
                }
                commandLine.createArgument().setValue(projectName);
            }
        }

        File tmp = null;
        File tmp2 = null;
        try {
            Random rand = new Random(System.currentTimeMillis());
            tmp = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
            FileOutputStream fos = new FileOutputStream(tmp);
            tmp2 = new File(""pvcs_ant_"" + rand.nextLong() + "".log"");
            log(commandLine.describeCommand(), Project.MSG_VERBOSE);
            try {
                result = runCmd(commandLine,
                                new PumpStreamHandler(fos,
                                    new LogOutputStream(this,
                                                        Project.MSG_WARN)));
            } finally {
                fos.close();
            }

            if (Execute.isFailure(result) && !ignorerc) {
                String msg = ""Failed executing: "" + commandLine.toString();
                throw new BuildException(msg, getLocation());
            }

            if (!tmp.exists()) {
                throw new BuildException(""Communication between ant and pvcs ""
                    + ""failed. No output generated from executing PVCS ""
                    + ""commandline interface \""pcli\"" and \""get\"""");
            }

            
            log(""Creating folders"", Project.MSG_INFO);
            createFolders(tmp);

            
            massagePCLI(tmp, tmp2);

            
            commandLine.clearArgs();
            commandLine.setExecutable(getExecutable(GET_EXE));

            if (getConfig() != null && getConfig().length() > 0) {
                commandLine.createArgument().setValue(""-c"" + getConfig());
            }

            if (getForce() != null && getForce().equals(""yes"")) {
                commandLine.createArgument().setValue(""-Y"");
            } else {
                commandLine.createArgument().setValue(""-N"");
            }

            if (getPromotiongroup() != null) {
                commandLine.createArgument().setValue(""-G""
                    + getPromotiongroup());
            } else {
                if (getLabel() != null) {
                    commandLine.createArgument().setValue(""-v"" + getLabel());
                } else {
                    if (getRevision() != null) {
                        commandLine.createArgument().setValue(""-r""
                            + getRevision());
                    }
                }
            }

            if (updateOnly) {
                commandLine.createArgument().setValue(""-U"");
            }

            commandLine.createArgument().setValue(""@"" + tmp2.getAbsolutePath());
            log(""Getting files"", Project.MSG_INFO);
            log(""Executing "" + commandLine.toString(), Project.MSG_VERBOSE);
            result = runCmd(commandLine,
                new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
            if (result != 0 && !ignorerc) {
                String msg = ""Failed executing: "" + commandLine.toString()
                    + "". Return code was "" + result;
                throw new BuildException(msg, getLocation());
            }

        } catch (FileNotFoundException e) {
            String msg = ""Failed executing: "" + commandLine.toString()
                + "". Exception: "" + e.getMessage();
            throw new BuildException(msg, getLocation());
        } catch (IOException e) {
            String msg = ""Failed executing: "" + commandLine.toString()
                + "". Exception: "" + e.getMessage();
            throw new BuildException(msg, getLocation());
        } catch (ParseException e) {
            String msg = ""Failed executing: "" + commandLine.toString()
                + "". Exception: "" + e.getMessage();
            throw new BuildException(msg, getLocation());
        } finally {
            if (tmp != null) {
                tmp.delete();
            }
            if (tmp2 != null) {
                tmp2.delete();
            }
        }
    }

    
    private void createFolders(File file) throws IOException, ParseException {
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(file));
            MessageFormat mf = new MessageFormat(getFilenameFormat());
            String line = in.readLine();
            while (line != null) {
                log(""Considering \"""" + line + ""\"""", Project.MSG_VERBOSE);
                if (line.startsWith(""\""\\"")    
                    || line.startsWith(""\""/"")  
                                               
                   || (line.length() > POS_3 && line.startsWith(""\"""")
                        && Character.isLetter(line.charAt(POS_1))
                        && String.valueOf(line.charAt(POS_2)).equals("":"")
                        && String.valueOf(line.charAt(POS_3)).equals(""\\""))) {
                    Object[] objs = mf.parse(line);
                    String f = (String) objs[1];
                    
                    int index = f.lastIndexOf(File.separator);
                    if (index > -1) {
                        File dir = new File(f.substring(0, index));
                        if (!dir.exists()) {
                            log(""Creating "" + dir.getAbsolutePath(),
                                Project.MSG_VERBOSE);
                            if (dir.mkdirs()) {
                                log(""Created "" + dir.getAbsolutePath(),
                                    Project.MSG_INFO);
                            } else {
                                log(""Failed to create ""
                                    + dir.getAbsolutePath(),
                                    Project.MSG_INFO);
                            }
                        } else {
                            log(dir.getAbsolutePath() + "" exists. Skipping"",
                                Project.MSG_VERBOSE);
                        }
                    } else {
                        log(""File separator problem with "" + line,
                            Project.MSG_WARN);
                    }
                } else {
                    log(""Skipped \"""" + line + ""\"""", Project.MSG_VERBOSE);
                }
                line = in.readLine();
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
    }


    
    private void massagePCLI(File in, File out)
        throws IOException {
        BufferedReader inReader = null;
        BufferedWriter outWriter = null;
        try {
            inReader = new BufferedReader(new FileReader(in));
            outWriter = new BufferedWriter(new FileWriter(out));
            String s = null;
            while ((s = inReader.readLine()) != null) {
                String sNormal = s.replace('\\', '/');
                outWriter.write(sNormal);
                outWriter.newLine();
            }
        } finally {
            if (inReader != null) {
                inReader.close();
            }
            if (outWriter != null) {
                outWriter.close();
            }
        }
    }

    
    public String getRepository() {
        return repository;
    }

    
    public String getFilenameFormat() {
        return filenameFormat;
    }

    
    public void setFilenameFormat(String f) {
        filenameFormat = f;
    }

    
    public String getLineStart() {
        return lineStart;
    }

    
    public void setLineStart(String l) {
        lineStart = l;
    }

    
    public void setRepository(String repo) {
        repository = repo;
    }

    
    public String getPvcsproject() {
        return pvcsProject;
    }

    
    public void setPvcsproject(String prj) {
        pvcsProject = prj;
    }

    
    public Vector getPvcsprojects() {
        return pvcsProjects;
    }

    
    public String getWorkspace() {
        return workspace;
    }

    
    public void setWorkspace(String ws) {
        workspace = ws;
    }

    
    public String getPvcsbin() {
        return pvcsbin;
    }

    
    public void setPvcsbin(String bin) {
        pvcsbin = bin;
    }

    
    public String getForce() {
        return force;
    }

    
    public void setForce(String f) {
        if (f != null && f.equalsIgnoreCase(""yes"")) {
            force = ""yes"";
        } else {
            force = ""no"";
        }
    }

    
    public String getPromotiongroup() {
        return promotiongroup;
    }

    
    public void setPromotiongroup(String w) {
        promotiongroup = w;
    }

    
    public String getLabel() {
        return label;
    }

    
    public void setLabel(String l) {
        label = l;
    }

    
    public String getRevision() {
        return revision;
    }

    
    public void setRevision(String r) {
        revision = r;
    }

    
    public boolean getIgnoreReturnCode() {
        return ignorerc;
    }

    
    public void setIgnoreReturnCode(boolean b) {
        ignorerc = b;
    }

    
    public void addPvcsproject(PvcsProject p) {
        pvcsProjects.addElement(p);
    }

    
    public boolean getUpdateOnly() {
        return updateOnly;
    }

    
    public void setUpdateOnly(boolean l) {
        updateOnly = l;
    }

    
    public String getConfig() {
        return config;
    }

    
    public void setConfig(File f) {
        config = f.toString();
    }


    
    public String getUserId() {
        return userId;
    }

    
    public void setUserId(String u) {
        userId = u;
    }

    
    public Pvcs() {
        super();
        pvcsProject = null;
        pvcsProjects = new Vector();
        workspace = null;
        repository = null;
        pvcsbin = null;
        force = null;
        promotiongroup = null;
        label = null;
        ignorerc = false;
        updateOnly = false;
        lineStart = ""\""P:"";
        filenameFormat = ""{0}-arc({1})"";
    }
}

"
org.apache.tools.tar.TarInputStream,15,3,0,5,42,69,3,2,15,0.669642857,538,1.0,2,0.6,0.247619048,2,8,34.33333333,1,0.8,1,"



package org.apache.tools.tar;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;


public class TarInputStream extends FilterInputStream {

    
    protected boolean debug;
    protected boolean hasHitEOF;
    protected long entrySize;
    protected long entryOffset;
    protected byte[] readBuf;
    protected TarBuffer buffer;
    protected TarEntry currEntry;

    
    protected byte[] oneBuf;

    

    
    public TarInputStream(InputStream is) {
        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
    }

    
    public TarInputStream(InputStream is, int blockSize) {
        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
    }

    
    public TarInputStream(InputStream is, int blockSize, int recordSize) {
        super(is);

        this.buffer = new TarBuffer(is, blockSize, recordSize);
        this.readBuf = null;
        this.oneBuf = new byte[1];
        this.debug = false;
        this.hasHitEOF = false;
    }

    
    public void setDebug(boolean debug) {
        this.debug = debug;
        this.buffer.setDebug(debug);
    }

    
    public void close() throws IOException {
        this.buffer.close();
    }

    
    public int getRecordSize() {
        return this.buffer.getRecordSize();
    }

    
    public int available() throws IOException {
        if (this.entrySize - this.entryOffset > Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }
        return (int) (this.entrySize - this.entryOffset);
    }

    
    public long skip(long numToSkip) throws IOException {
        
        
        
        
        byte[] skipBuf = new byte[8 * 1024];
        long skip = numToSkip;
        while (skip > 0) {
            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
            int numRead = this.read(skipBuf, 0, realSkip);
            if (numRead == -1) {
                break;
            }
            skip -= numRead;
        }
        return (numToSkip - skip);
    }

    
    public boolean markSupported() {
        return false;
    }

    
    public void mark(int markLimit) {
    }

    
    public void reset() {
    }

    
    public TarEntry getNextEntry() throws IOException {
        if (this.hasHitEOF) {
            return null;
        }

        if (this.currEntry != null) {
            long numToSkip = this.entrySize - this.entryOffset;

            if (this.debug) {
                System.err.println(""TarInputStream: SKIP currENTRY '""
                        + this.currEntry.getName() + ""' SZ ""
                        + this.entrySize + "" OFF ""
                        + this.entryOffset + ""  skipping ""
                        + numToSkip + "" bytes"");
            }

            if (numToSkip > 0) {
                this.skip(numToSkip);
            }

            this.readBuf = null;
        }

        byte[] headerBuf = this.buffer.readRecord();

        if (headerBuf == null) {
            if (this.debug) {
                System.err.println(""READ NULL RECORD"");
            }
            this.hasHitEOF = true;
        } else if (this.buffer.isEOFRecord(headerBuf)) {
            if (this.debug) {
                System.err.println(""READ EOF RECORD"");
            }
            this.hasHitEOF = true;
        }

        if (this.hasHitEOF) {
            this.currEntry = null;
        } else {
            this.currEntry = new TarEntry(headerBuf);

            if (this.debug) {
                System.err.println(""TarInputStream: SET CURRENTRY '""
                        + this.currEntry.getName()
                        + ""' size = ""
                        + this.currEntry.getSize());
            }

            this.entryOffset = 0;

            this.entrySize = this.currEntry.getSize();
        }

        if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {
            
            StringBuffer longName = new StringBuffer();
            byte[] buf = new byte[256];
            int length = 0;
            while ((length = read(buf)) >= 0) {
                longName.append(new String(buf, 0, length));
            }
            getNextEntry();
            if (this.currEntry == null) {
                
                
                return null;
            }
            
            if (longName.length() > 0
                && longName.charAt(longName.length() - 1) == 0) {
                longName.deleteCharAt(longName.length() - 1);
            }
            this.currEntry.setName(longName.toString());
        }

        return this.currEntry;
    }

    
    public int read() throws IOException {
        int num = this.read(this.oneBuf, 0, 1);
        return num == -1 ? -1 : ((int) this.oneBuf[0]) & 0xFF;
    }

    
    public int read(byte[] buf, int offset, int numToRead) throws IOException {
        int totalRead = 0;

        if (this.entryOffset >= this.entrySize) {
            return -1;
        }

        if ((numToRead + this.entryOffset) > this.entrySize) {
            numToRead = (int) (this.entrySize - this.entryOffset);
        }

        if (this.readBuf != null) {
            int sz = (numToRead > this.readBuf.length) ? this.readBuf.length
                    : numToRead;

            System.arraycopy(this.readBuf, 0, buf, offset, sz);

            if (sz >= this.readBuf.length) {
                this.readBuf = null;
            } else {
                int newLen = this.readBuf.length - sz;
                byte[] newBuf = new byte[newLen];

                System.arraycopy(this.readBuf, sz, newBuf, 0, newLen);

                this.readBuf = newBuf;
            }

            totalRead += sz;
            numToRead -= sz;
            offset += sz;
        }

        while (numToRead > 0) {
            byte[] rec = this.buffer.readRecord();

            if (rec == null) {
                
                throw new IOException(""unexpected EOF with "" + numToRead
                        + "" bytes unread"");
            }

            int sz = numToRead;
            int recLen = rec.length;

            if (recLen > sz) {
                System.arraycopy(rec, 0, buf, offset, sz);

                this.readBuf = new byte[recLen - sz];

                System.arraycopy(rec, sz, this.readBuf, 0, recLen - sz);
            } else {
                sz = recLen;

                System.arraycopy(rec, 0, buf, offset, recLen);
            }

            totalRead += sz;
            numToRead -= sz;
            offset += sz;
        }

        this.entryOffset += totalRead;

        return totalRead;
    }

    
    public void copyEntryContents(OutputStream out) throws IOException {
        byte[] buf = new byte[32 * 1024];

        while (true) {
            int numRead = this.read(buf, 0, buf.length);

            if (numRead == -1) {
                break;
            }

            out.write(buf, 0, numRead);
        }
    }
}
"
org.apache.tools.ant.types.selectors.NoneSelector,3,5,1,9,14,3,8,2,3,2.0,52,0.0,0,0.96875,0.555555556,1,1,16.33333333,3,1.6667,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;
import java.util.Enumeration;


public class NoneSelector extends BaseSelectorContainer {

    
    public NoneSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer();
        if (hasSelectors()) {
            buf.append(""{noneselect: "");
            buf.append(super.toString());
            buf.append(""}"");
        }
        return buf.toString();
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        validate();
        Enumeration e = selectorElements();
        boolean result;

        while (e.hasMoreElements()) {
            result = ((FileSelector) e.nextElement()).isSelected(basedir,
                    filename, file);
            if (result) {
                return false;
            }
        }
        return true;
    }

}

"
org.apache.tools.ant.types.selectors.FileSelector,1,1,0,22,1,0,21,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.BuildException;


public interface FileSelector {

    
    boolean isSelected(File basedir, String filename, File file)
            throws BuildException;

}

"
org.apache.tools.ant.taskdefs.condition.Or,2,3,0,3,7,1,1,3,2,2.0,23,0.0,0,0.96969697,1.0,0,0,10.5,1,0.5,0,"

package org.apache.tools.ant.taskdefs.condition;

import java.util.Enumeration;
import org.apache.tools.ant.BuildException;


public class Or extends ConditionBase implements Condition {

    
    public boolean eval() throws BuildException {
        Enumeration e = getConditions();
        while (e.hasMoreElements()) {
            Condition c = (Condition) e.nextElement();
            if (c.eval()) {
                return true;
            }
        }
        return false;
    }

}
"
org.apache.tools.ant.taskdefs.Chmod,18,5,0,11,60,39,0,11,16,0.607843137,305,1.0,1,0.862903226,0.268518519,4,7,15.77777778,4,1.2222,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.PatternSet;


public class Chmod extends ExecuteOn {

    private FileSet defaultSet = new FileSet();
    private boolean defaultSetDefined = false;
    private boolean havePerm = false;

    
    public Chmod() {
        super.setExecutable(""chmod"");
        super.setParallel(true);
        super.setSkipEmptyFilesets(true);
    }

    
    public void setProject(Project project) {
        super.setProject(project);
        defaultSet.setProject(project);
    }

    
    public void setFile(File src) {
        FileSet fs = new FileSet();
        fs.setFile(src);
        addFileset(fs);
    }

    
    public void setDir(File src) {
        defaultSet.setDir(src);
    }

    
    public void setPerm(String perm) {
        createArg().setValue(perm);
        havePerm = true;
    }

    
    public PatternSet.NameEntry createInclude() {
        defaultSetDefined = true;
        return defaultSet.createInclude();
    }

    
    public PatternSet.NameEntry createExclude() {
        defaultSetDefined = true;
        return defaultSet.createExclude();
    }

    
    public PatternSet createPatternSet() {
        defaultSetDefined = true;
        return defaultSet.createPatternSet();
    }

    
    public void setIncludes(String includes) {
        defaultSetDefined = true;
        defaultSet.setIncludes(includes);
    }

    
    public void setExcludes(String excludes) {
        defaultSetDefined = true;
        defaultSet.setExcludes(excludes);
    }

    
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        defaultSetDefined = true;
        defaultSet.setDefaultexcludes(useDefaultExcludes);
    }

    
    protected void checkConfiguration() {
        if (!havePerm) {
            throw new BuildException(""Required attribute perm not set in chmod"",
                                     getLocation());
        }

        if (defaultSetDefined && defaultSet.getDir(getProject()) != null) {
            addFileset(defaultSet);
        }
        super.checkConfiguration();
    }

    
    public void execute() throws BuildException {
        
        if (defaultSetDefined || defaultSet.getDir(getProject()) == null) {
            try {
                super.execute();
            } finally {
                if (defaultSetDefined && defaultSet.getDir(getProject()) != null) {
                    filesets.removeElement(defaultSet);
                }
            }
        } else if (isValidOs()) {
            
            Execute execute = prepareExec();
            Commandline cloned = (Commandline) cmdl.clone();
            cloned.createArgument().setValue(defaultSet.getDir(getProject())
                                             .getPath());
            try {
                execute.setCommandline(cloned.getCommandline());
                runExecute(execute);
            } catch (IOException e) {
                throw new BuildException(""Execute failed: "" + e, e, getLocation());
            } finally {
                
                logFlush();
            }
        }
    }

    
    public void setExecutable(String e) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the executable attribute"", getLocation());
    }

    
    public void setCommand(Commandline cmdl) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the command attribute"", getLocation());
    }

    
    public void setSkipEmptyFilesets(boolean skip) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the skipemptyfileset attribute"", getLocation());
    }

    
    public void setAddsourcefile(boolean b) {
        throw new BuildException(getTaskType()
            + "" doesn\'t support the addsourcefile attribute"", getLocation());
    }

    
    protected boolean isValidOs() {
        return Os.isFamily(Os.FAMILY_UNIX) && super.isValidOs();
    }
}
"
org.apache.tools.ant.types.selectors.ContainsRegexpSelector,7,5,0,15,32,1,6,9,7,0.625,209,0.75,2,0.863636364,0.342857143,1,4,28.28571429,9,2.5714,0,"

package org.apache.tools.ant.types.selectors;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Parameter;
import org.apache.tools.ant.types.RegularExpression;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
import org.apache.tools.ant.util.regexp.Regexp;


public class ContainsRegexpSelector extends BaseExtendSelector
        implements ResourceSelector {

    private String userProvidedExpression = null;
    private RegularExpression myRegExp = null;
    private Regexp myExpression = null;
    
    public static final String EXPRESSION_KEY = ""expression"";

    
    public ContainsRegexpSelector() {
    }

    
    public String toString() {
        StringBuffer buf = new StringBuffer(
                ""{containsregexpselector expression: "");
        buf.append(userProvidedExpression);
        buf.append(""}"");
        return buf.toString();
    }

    
    public void setExpression(String theexpression) {
        this.userProvidedExpression = theexpression;
    }

    
    public void setParameters(Parameter[] parameters) {
        super.setParameters(parameters);
        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                String paramname = parameters[i].getName();
                if (EXPRESSION_KEY.equalsIgnoreCase(paramname)) {
                    setExpression(parameters[i].getValue());
                } else {
                    setError(""Invalid parameter "" + paramname);
                }
            }
        }
    }

    
    public void verifySettings() {
        if (userProvidedExpression == null) {
            setError(""The expression attribute is required"");
        }
    }

    
    public boolean isSelected(File basedir, String filename, File file) {
        return isSelected(new FileResource(file));
    }

    
    public boolean isSelected(Resource r) {
        String teststr = null;
        BufferedReader in = null;

        

        validate();

        if (r.isDirectory()) {
            return true;
        }

        if (myRegExp == null) {
            myRegExp = new RegularExpression();
            myRegExp.setPattern(userProvidedExpression);
            myExpression = myRegExp.getRegexp(getProject());
        }

        try {
            in = new BufferedReader(new InputStreamReader(r.getInputStream()));
        } catch (Exception e) {
            throw new BuildException(""Could not get InputStream from ""
                    + r.toLongString(), e);
        }
        try {
            teststr = in.readLine();

            while (teststr != null) {

                if (myExpression.matches(teststr)) {
                    return true;
                }
                teststr = in.readLine();
            }

            return false;
        } catch (IOException ioe) {
            throw new BuildException(""Could not read "" + r.toLongString());
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (Exception e) {
                    throw new BuildException(""Could not close ""
                                             + r.toLongString());
                }
            }
        }
    }
}

"
org.apache.tools.ant.types.resources.BZip2Resource,6,5,0,4,13,9,0,4,2,0.6,70,1.0,0,0.961538462,0.4,1,2,10.5,1,0.5,0,"
package org.apache.tools.ant.types.resources;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.apache.tools.bzip2.CBZip2InputStream;
import org.apache.tools.bzip2.CBZip2OutputStream;


public class BZip2Resource extends CompressedResource {
    private static final char[] MAGIC = new char[] {'B', 'Z'};

    
    public BZip2Resource() {
    }

    
    public BZip2Resource(org.apache.tools.ant.types.ResourceCollection other) {
        super(other);
    }

    
    protected InputStream wrapStream(InputStream in) throws IOException {
        for (int i = 0; i < MAGIC.length; i++) {
            if (in.read() != MAGIC[i]) {
                throw new IOException(""Invalid bz2 stream."");
            }
        }
        return new CBZip2InputStream(in);
    }

    
    protected OutputStream wrapStream(OutputStream out) throws IOException {
        for (int i = 0; i < MAGIC.length; i++) {
            out.write(MAGIC[i]);
        }
        return new CBZip2OutputStream(out);
    }

    
    protected String getCompressionName() {
        return ""Bzip2"";
    }
}
"
org.apache.tools.ant.taskdefs.optional.ssh.ScpToMessageBySftp,13,3,0,9,41,48,1,8,7,0.583333333,285,1.0,0,0.703703704,0.355769231,2,3,20.69230769,1,0.6154,0,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import com.jcraft.jsch.Session;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.SftpException;
import com.jcraft.jsch.SftpProgressMonitor;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Iterator;


public class ScpToMessageBySftp extends ScpToMessage {

    private File localFile;
    private String remotePath;
    private List directoryList;

    
    public ScpToMessageBySftp(boolean verbose,
                              Session session,
                              File aLocalFile,
                              String aRemotePath) {
        this(verbose, session, aRemotePath);

        this.localFile = aLocalFile;
    }

    
    public ScpToMessageBySftp(boolean verbose,
                              Session session,
                              List aDirectoryList,
                              String aRemotePath) {
        this(verbose, session, aRemotePath);

        this.directoryList = aDirectoryList;
    }

    
    private ScpToMessageBySftp(boolean verbose,
                               Session session,
                               String aRemotePath) {
        super(verbose, session);
        this.remotePath = aRemotePath;
    }

    
    public ScpToMessageBySftp(Session session,
                              File aLocalFile,
                              String aRemotePath) {
        this(false, session, aLocalFile, aRemotePath);
    }

    
    public ScpToMessageBySftp(Session session,
                              List aDirectoryList,
                              String aRemotePath) {
        this(false, session, aDirectoryList, aRemotePath);
    }

    
    public void execute() throws IOException, JSchException {
        if (directoryList != null) {
            doMultipleTransfer();
        }
        if (localFile != null) {
            doSingleTransfer();
        }
        log(""done.\n"");
    }

    private void doSingleTransfer() throws IOException, JSchException {
        ChannelSftp channel = openSftpChannel();
        try {
            channel.connect();
            try {
                sendFileToRemote(channel, localFile, remotePath);
            } catch (SftpException e) {
                throw new JSchException(e.toString());
            }
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
        }
    }

    private void doMultipleTransfer() throws IOException, JSchException {
        ChannelSftp channel = openSftpChannel();
        try {
            channel.connect();

            try {
                channel.cd(remotePath);
                for (Iterator i = directoryList.iterator(); i.hasNext();) {
                    Directory current = (Directory) i.next();
                    sendDirectory(channel, current);
                }
            } catch (SftpException e) {
                throw new JSchException(e.toString());
            }
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
        }
    }

    private void sendDirectory(ChannelSftp channel,
                               Directory current)
        throws IOException, SftpException {
        for (Iterator fileIt = current.filesIterator(); fileIt.hasNext();) {
            sendFileToRemote(channel, (File) fileIt.next(), null);
        }
        for (Iterator dirIt = current.directoryIterator(); dirIt.hasNext();) {
            Directory dir = (Directory) dirIt.next();
            sendDirectoryToRemote(channel, dir);
        }
    }

    private void sendDirectoryToRemote(ChannelSftp channel,
                                       Directory directory)
        throws IOException, SftpException {
        String dir = directory.getDirectory().getName();
        try {
            channel.stat(dir);
        } catch (SftpException e) {
            
            if (e.id == ChannelSftp.SSH_FX_NO_SUCH_FILE) {
                channel.mkdir(dir);
            }
        }
        channel.cd(dir);
        sendDirectory(channel, directory);
        channel.cd("".."");
    }

    private void sendFileToRemote(ChannelSftp channel,
                                  File localFile,
                                  String remotePath)
        throws IOException, SftpException {
        long filesize = localFile.length();

        if (remotePath == null) {
            remotePath = localFile.getName();
        }

        long startTime = System.currentTimeMillis();
        long totalLength = filesize;

        
        boolean trackProgress = getVerbose() && filesize > 102400;

        SftpProgressMonitor monitor = null;
        if (trackProgress) {
            monitor = getProgressMonitor();
        }

        try {
            if (this.getVerbose()) {
                log(""Sending: "" + localFile.getName() + "" : "" + filesize);
            }
            channel.put(localFile.getAbsolutePath(), remotePath, monitor);
        } finally {
            if (this.getVerbose()) {
                long endTime = System.currentTimeMillis();
                logStats(startTime, endTime, (int) totalLength);
            }
        }
    }

    
    public File getLocalFile() {
        return localFile;
    }

    
    public String getRemotePath() {
        return remotePath;
    }
}
"
org.apache.tools.ant.types.Assertions,13,3,0,11,40,0,3,9,10,0.375,289,1.0,0,0.714285714,0.179487179,2,3,21.07692308,4,2.0,0,"

package org.apache.tools.ant.types;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;


public class Assertions extends DataType implements Cloneable {

    
    private Boolean enableSystemAssertions;

    
    private ArrayList assertionList = new ArrayList();


    
    public void addEnable(EnabledAssertion assertion) {
        checkChildrenAllowed();
        assertionList.add(assertion);
    }

    
    public void addDisable(DisabledAssertion assertion) {
        checkChildrenAllowed();
        assertionList.add(assertion);
    }

    
    public void setEnableSystemAssertions(Boolean enableSystemAssertions) {
        checkAttributesAllowed();
        this.enableSystemAssertions = enableSystemAssertions;
    }

    
    public void setRefid(Reference ref) {
        if (assertionList.size() > 0 || enableSystemAssertions != null) {
            throw tooManyAttributes();
        }
        super.setRefid(ref);
    }

    
    private Assertions getFinalReference() {
        if (getRefid() == null) {
            return this;
        } else {
            Object o = getRefid().getReferencedObject(getProject());
            if (!(o instanceof Assertions)) {
                throw new BuildException(""reference is of wrong type"");
            }
            return (Assertions) o;
        }
    }

    
    public int size() {
        Assertions clause = getFinalReference();
        return clause.getFinalSize();
    }


    
    private int getFinalSize() {
        return assertionList.size() + (enableSystemAssertions != null ? 1 : 0);
    }

    
    public void applyAssertions(List commandList) {
        getProject().log(""Applying assertions"", Project.MSG_DEBUG);
        Assertions clause = getFinalReference();
        
        if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {
            getProject().log(""Enabling system assertions"", Project.MSG_DEBUG);
            commandList.add(""-enablesystemassertions"");
        } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {
            getProject().log(""disabling system assertions"", Project.MSG_DEBUG);
            commandList.add(""-disablesystemassertions"");
        }

        
        Iterator it = clause.assertionList.iterator();
        while (it.hasNext()) {
            BaseAssertion assertion = (BaseAssertion) it.next();
            String arg = assertion.toCommand();
            getProject().log(""adding assertion "" + arg, Project.MSG_DEBUG);
            commandList.add(arg);
        }
    }

    
    public void applyAssertions(CommandlineJava command) {
        Assertions clause = getFinalReference();
        
        if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {
            addVmArgument(command, ""-enablesystemassertions"");
        } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {
            addVmArgument(command, ""-disablesystemassertions"");
        }

        
        Iterator it = clause.assertionList.iterator();
        while (it.hasNext()) {
            BaseAssertion assertion = (BaseAssertion) it.next();
            String arg = assertion.toCommand();
            addVmArgument(command, arg);
        }
    }

    
    public void applyAssertions(final ListIterator commandIterator) {
        getProject().log(""Applying assertions"", Project.MSG_DEBUG);
        Assertions clause = getFinalReference();
        
        if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {
            getProject().log(""Enabling system assertions"", Project.MSG_DEBUG);
            commandIterator.add(""-enablesystemassertions"");
        } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {
            getProject().log(""disabling system assertions"", Project.MSG_DEBUG);
            commandIterator.add(""-disablesystemassertions"");
        }

        
        Iterator it = clause.assertionList.iterator();
        while (it.hasNext()) {
            BaseAssertion assertion = (BaseAssertion) it.next();
            String arg = assertion.toCommand();
            getProject().log(""adding assertion "" + arg, Project.MSG_DEBUG);
            commandIterator.add(arg);
        }
    }

    
    private static void addVmArgument(CommandlineJava command, String arg) {
        Commandline.Argument argument;
        argument = command.createVmArgument();
        argument.setValue(arg);
    }

    
    public Object clone() throws CloneNotSupportedException {
        Assertions that = (Assertions) super.clone();
        that.assertionList = (ArrayList) assertionList.clone();
        return that;
    }

    

    public abstract static class BaseAssertion {
        private String packageName;
        private String className;

        
        public void setClass(String className) {
            this.className = className;
        }

        
        public void setPackage(String packageName) {
            this.packageName = packageName;
        }

        
        protected String getClassName() {
            return className;
        }

        
        protected String getPackageName() {
            return packageName;
        }

        
        public abstract String getCommandPrefix();

        
        public String toCommand() {
            
            if (getPackageName() != null && getClassName() != null) {
                throw new BuildException(""Both package and class have been set"");
            }
            StringBuffer command = new StringBuffer(getCommandPrefix());
            
            if (getPackageName() != null) {
                
                command.append(':');
                command.append(getPackageName());
                if (!command.toString().endsWith(""..."")) {
                    
                    command.append(""..."");
                }
            } else if (getClassName() != null) {
                
                command.append(':');
                command.append(getClassName());
            }
            return command.toString();
        }
    }


    
    public static class EnabledAssertion extends BaseAssertion {
        
        public String getCommandPrefix() {
            return ""-ea"";
        }

    }

    
    public static class DisabledAssertion extends BaseAssertion {
        
        public String getCommandPrefix() {
            return ""-da"";
        }

    }
}
"
org.apache.tools.ant.taskdefs.condition.IsReference,4,2,0,6,14,2,1,5,4,0.666666667,68,1.0,1,0.75,0.5,0,0,15.5,1,0.75,1,"

package org.apache.tools.ant.taskdefs.condition;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.types.Reference;


public class IsReference extends ProjectComponent implements Condition {
    private Reference ref;
    private String type;

    
    public void setRefid(Reference r) {
        ref = r;
    }

    
    public void setType(String type) {
        this.type = type;
    }

    
    public boolean eval() throws BuildException {
        if (ref == null) {
            throw new BuildException(""No reference specified for isreference ""
                                     + ""condition"");
        }

        Object o = getProject().getReference(ref.getRefId());

        if (o == null) {
            return false;
        } else if (type == null) {
            return true;
        } else {
            Class typeClass =
                (Class) getProject().getDataTypeDefinitions().get(type);

            if (typeClass == null) {
                typeClass =
                    (Class) getProject().getTaskDefinitions().get(type);
            }

            if (typeClass == null) {
                
                return false;
            }

            return typeClass.isAssignableFrom(o.getClass());
        }
    }

}
"
org.apache.tools.ant.helper.ProjectHelper2,17,2,0,17,85,74,7,16,4,0.7875,461,1.0,5,0.53125,0.15625,1,1,25.82352941,1,0.8824,1,"

package org.apache.tools.ant.helper;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.RuntimeConfigurable;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.UnknownElement;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JAXPUtils;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Stack;


public class ProjectHelper2 extends ProjectHelper {
    

    
    private static AntHandler elementHandler = new ElementHandler();
    private static AntHandler targetHandler = new TargetHandler();
    private static AntHandler mainHandler = new MainHandler();
    private static AntHandler projectHandler = new ProjectHandler();

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    public UnknownElement parseUnknownElement(Project project, URL source)
        throws BuildException {
        Target dummyTarget = new Target();
        dummyTarget.setProject(project);

        AntXMLContext context = new AntXMLContext(project);
        context.addTarget(dummyTarget);
        context.setImplicitTarget(dummyTarget);

        parse(context.getProject(), source,
              new RootHandler(context, elementHandler));
        Task[] tasks = dummyTarget.getTasks();
        if (tasks.length != 1) {
            throw new BuildException(""No tasks defined"");
        }
        return (UnknownElement) tasks[0];
    }
    
    public void parse(Project project, Object source)
            throws BuildException {
        getImportStack().addElement(source);
        
        AntXMLContext context = null;
        context = (AntXMLContext) project.getReference(""ant.parsing.context"");


        if (context == null) {
            context = new AntXMLContext(project);
            project.addReference(""ant.parsing.context"", context);
            project.addReference(""ant.targets"", context.getTargets());
        }

        if (getImportStack().size() > 1) {
            
            context.setIgnoreProjectTag(true);
            Target currentTarget = context.getCurrentTarget();
            Target currentImplicit = context.getImplicitTarget();
            Map    currentTargets = context.getCurrentTargets();
            try {
                Target newCurrent = new Target();
                newCurrent.setProject(project);
                newCurrent.setName("""");
                context.setCurrentTarget(newCurrent);
                context.setCurrentTargets(new HashMap());
                context.setImplicitTarget(newCurrent);
                parse(project, source, new RootHandler(context, mainHandler));
                newCurrent.execute();
            } finally {
                context.setCurrentTarget(currentTarget);
                context.setImplicitTarget(currentImplicit);
                context.setCurrentTargets(currentTargets);
            }
        } else {
            
            context.setCurrentTargets(new HashMap());
            parse(project, source, new RootHandler(context, mainHandler));
            
            context.getImplicitTarget().execute();
        }
    }

    
    public void parse(Project project, Object source, RootHandler handler)
            throws BuildException {

        AntXMLContext context = handler.context;

        File buildFile = null;
        URL  url = null;
        String buildFileName = null;

        if (source instanceof File) {
            buildFile = (File) source;
            buildFile = FILE_UTILS.normalize(buildFile.getAbsolutePath());
            context.setBuildFile(buildFile);
            buildFileName = buildFile.toString();

        } else if (source instanceof URL) {
            url = (URL) source;
            buildFileName = url.toString();

        } else {
            throw new BuildException(""Source "" + source.getClass().getName()
                                     + "" not supported by this plugin"");
        }

        InputStream inputStream = null;
        InputSource inputSource = null;


        try {
            
            XMLReader parser = JAXPUtils.getNamespaceXMLReader();

            String uri = null;
            if (buildFile != null) {
                uri = FILE_UTILS.toURI(buildFile.getAbsolutePath());
                inputStream = new FileInputStream(buildFile);
            } else {
                inputStream = url.openStream();
                uri = url.toString(); 
            }

            inputSource = new InputSource(inputStream);
            if (uri != null) {
                inputSource.setSystemId(uri);
            }
            project.log(""parsing buildfile "" + buildFileName
                        + "" with URI = "" + uri, Project.MSG_VERBOSE);

            DefaultHandler hb = handler;

            parser.setContentHandler(hb);
            parser.setEntityResolver(hb);
            parser.setErrorHandler(hb);
            parser.setDTDHandler(hb);
            parser.parse(inputSource);
        } catch (SAXParseException exc) {
            Location location = new Location(exc.getSystemId(),
                exc.getLineNumber(), exc.getColumnNumber());

            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                BuildException be = (BuildException) t;
                if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                    be.setLocation(location);
                }
                throw be;
            } else if (t == null) {
                t = exc;
            }

            throw new BuildException(exc.getMessage(), t, location);
        } catch (SAXException exc) {
            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            } else if (t == null) {
                t = exc;
            }
            throw new BuildException(exc.getMessage(), t);
        } catch (FileNotFoundException exc) {
            throw new BuildException(exc);
        } catch (UnsupportedEncodingException exc) {
              throw new BuildException(""Encoding of project file ""
                                       + buildFileName + "" is invalid."",
                                       exc);
        } catch (IOException exc) {
            throw new BuildException(""Error reading project file ""
                                     + buildFileName + "": "" + exc.getMessage(),
                                     exc);
        } finally {
            FileUtils.close(inputStream);
        }
    }

    
    protected static AntHandler getMainHandler() {
        return mainHandler;
    }

    
    protected static void setMainHandler(AntHandler handler) {
        mainHandler = handler;
    }

    
    protected static AntHandler getProjectHandler() {
        return projectHandler;
    }

    
    protected static void setProjectHandler(AntHandler handler) {
        projectHandler = handler;
    }

    
    protected static AntHandler getTargetHandler() {
        return targetHandler;
    }

    
    protected static void setTargetHandler(AntHandler handler) {
        targetHandler = handler;
    }

    
    protected static AntHandler getElementHandler() {
        return elementHandler;
    }

    
    protected static void setElementHandler(AntHandler handler) {
        elementHandler = handler;
    }



    
    public static class AntHandler  {
        
        public void onStartElement(String uri, String tag, String qname,
                                   Attributes attrs,
                                   AntXMLContext context)
            throws SAXParseException {
        }

        
        public AntHandler onStartChild(String uri, String tag, String qname,
                                       Attributes attrs,
                                       AntXMLContext context)
            throws SAXParseException {
            throw new SAXParseException(""Unexpected element \"""" + qname
                + "" \"""", context.getLocator());
        }

        
        public void onEndChild(String uri, String tag, String qname,
                                     AntXMLContext context)
            throws SAXParseException {
        }

        
        public void onEndElement(String uri, String tag,
                                 AntXMLContext context) {
        }

        
        public void characters(char[] buf, int start, int count, AntXMLContext context)
            throws SAXParseException {
            String s = new String(buf, start, count).trim();

            if (s.length() > 0) {
                throw new SAXParseException(""Unexpected text \"""" + s
                    + ""\"""", context.getLocator());
            }
        }

        
        protected void checkNamespace(String uri) {

        }
    }

    
    public static class RootHandler extends DefaultHandler {
        private Stack antHandlers = new Stack();
        private AntHandler currentHandler = null;
        private AntXMLContext context;

        
        public RootHandler(AntXMLContext context, AntHandler rootHandler) {
            currentHandler = rootHandler;
            antHandlers.push(currentHandler);
            this.context = context;
        }

        
        public AntHandler getCurrentAntHandler() {
            return currentHandler;
        }

        
        public InputSource resolveEntity(String publicId,
                                         String systemId) {

            context.getProject().log(""resolving systemId: ""
                + systemId, Project.MSG_VERBOSE);

            if (systemId.startsWith(""file:"")) {
                String path = FILE_UTILS.fromURI(systemId);

                File file = new File(path);
                if (!file.isAbsolute()) {
                    file = FILE_UTILS.resolveFile(context.getBuildFileParent(), path);
                    context.getProject().log(
                            ""Warning: '"" + systemId + ""' in "" + context.getBuildFile()
                            + "" should be expressed simply as '"" + path.replace('\\', '/')
                            + ""' for compliance with other XML tools"",
                            Project.MSG_WARN);
                }
                context.getProject().log(""file="" + file, Project.MSG_DEBUG);
                try {
                    InputSource inputSource =
                            new InputSource(new FileInputStream(file));
                    inputSource.setSystemId(FILE_UTILS.toURI(file.getAbsolutePath()));
                    return inputSource;
                } catch (FileNotFoundException fne) {
                    context.getProject().log(file.getAbsolutePath()
                        + "" could not be found"", Project.MSG_WARN);
                }

            }
            
            context.getProject().log(
                ""could not resolve systemId"", Project.MSG_DEBUG);
            return null;
        }

        
        public void startElement(String uri, String tag, String qname, Attributes attrs)
            throws SAXParseException {
            AntHandler next
                = currentHandler.onStartChild(uri, tag, qname, attrs, context);
            antHandlers.push(currentHandler);
            currentHandler = next;
            currentHandler.onStartElement(uri, tag, qname, attrs, context);
        }

        
        public void setDocumentLocator(Locator locator) {
            context.setLocator(locator);
        }

        
        public void endElement(String uri, String name, String qName) throws SAXException {
            currentHandler.onEndElement(uri, name, context);
            AntHandler prev = (AntHandler) antHandlers.pop();
            currentHandler = prev;
            if (currentHandler != null) {
                currentHandler.onEndChild(uri, name, qName, context);
            }
        }

        
        public void characters(char[] buf, int start, int count)
            throws SAXParseException {
            currentHandler.characters(buf, start, count, context);
        }

        
        public void startPrefixMapping(String prefix, String uri) {
            context.startPrefixMapping(prefix, uri);
        }

        
        public void endPrefixMapping(String prefix) {
            context.endPrefixMapping(prefix);
        }
    }

    
    public static class MainHandler extends AntHandler {

        
        public AntHandler onStartChild(String uri, String name, String qname,
                                       Attributes attrs,
                                       AntXMLContext context)
            throws SAXParseException {
            if (name.equals(""project"")
                && (uri.equals("""") || uri.equals(ANT_CORE_URI))) {
                return ProjectHelper2.projectHandler;
            } else {





                if (name.equals(qname)) {
                    throw new SAXParseException(""Unexpected element \""{"" + uri
                    + ""}"" + name + ""\"" {"" + ANT_CORE_URI + ""}"" + name,
                    context.getLocator());
                } else {
                    throw new SAXParseException(""Unexpected element \"""" + qname
                    + ""\"" "" + name, context.getLocator());
                }
            }
        }
    }

    
    public static class ProjectHandler extends AntHandler {

        
        public void onStartElement(String uri, String tag, String qname,
                                   Attributes attrs,
                                   AntXMLContext context)
            throws SAXParseException {
            String baseDir = null;
            boolean nameAttributeSet = false;

            Project project = context.getProject();
            
            context.getImplicitTarget().setLocation(
                new Location(context.getLocator()));

            

            for (int i = 0; i < attrs.getLength(); i++) {
                String attrUri = attrs.getURI(i);
                if (attrUri != null
                    && !attrUri.equals("""")
                    && !attrUri.equals(uri)) {
                    continue; 
                }
                String key = attrs.getLocalName(i);
                String value = attrs.getValue(i);

                if (key.equals(""default"")) {
                    if (value != null && !value.equals("""")) {
                        if (!context.isIgnoringProjectTag()) {
                            project.setDefault(value);
                        }
                    }
                } else if (key.equals(""name"")) {
                    if (value != null) {
                        context.setCurrentProjectName(value);
                        nameAttributeSet = true;
                        if (!context.isIgnoringProjectTag()) {
                            project.setName(value);
                            project.addReference(value, project);
                        }
                    }
                } else if (key.equals(""id"")) {
                    if (value != null) {
                        
                        if (!context.isIgnoringProjectTag()) {
                            project.addReference(value, project);
                        }
                    }
                } else if (key.equals(""basedir"")) {
                    if (!context.isIgnoringProjectTag()) {
                        baseDir = value;
                    }
                } else {
                    
                    throw new SAXParseException(""Unexpected attribute \""""
                        + attrs.getQName(i) + ""\"""", context.getLocator());
                }
            }

            
            String antFileProp = ""ant.file."" + context.getCurrentProjectName();
            String dup = project.getProperty(antFileProp);
            if (dup != null && nameAttributeSet) {
                File dupFile = new File(dup);
                if (context.isIgnoringProjectTag()
                    && !dupFile.equals(context.getBuildFile())) {
                    project.log(""Duplicated project name in import. Project ""
                        + context.getCurrentProjectName() + "" defined first in ""
                        + dup + "" and again in "" + context.getBuildFile(),
                        Project.MSG_WARN);
                }
            }

            if (context.getBuildFile() != null && nameAttributeSet) {
                project.setUserProperty(""ant.file.""
                    + context.getCurrentProjectName(),
                    context.getBuildFile().toString());
            }

            if (context.isIgnoringProjectTag()) {
                
                return;
            }
            
            if (project.getProperty(""basedir"") != null) {
                project.setBasedir(project.getProperty(""basedir""));
            } else {
                
                if (baseDir == null) {
                    project.setBasedir(context.getBuildFileParent().getAbsolutePath());
                } else {
                    
                    if ((new File(baseDir)).isAbsolute()) {
                        project.setBasedir(baseDir);
                    } else {
                        project.setBaseDir(FILE_UTILS.resolveFile(
                                               context.getBuildFileParent(), baseDir));
                    }
                }
            }

            project.addTarget("""", context.getImplicitTarget());
            context.setCurrentTarget(context.getImplicitTarget());
        }

        
        public AntHandler onStartChild(String uri, String name, String qname,
                                       Attributes attrs,
                                       AntXMLContext context)
            throws SAXParseException {
            if (name.equals(""target"")
                && (uri.equals("""") || uri.equals(ANT_CORE_URI))) {
                return ProjectHelper2.targetHandler;
            } else {
                return ProjectHelper2.elementHandler;
            }
        }

    }

    
    public static class TargetHandler extends AntHandler {

        
        public void onStartElement(String uri, String tag, String qname,
                                   Attributes attrs,
                                   AntXMLContext context)
            throws SAXParseException {
            String name = null;
            String depends = """";

            Project project = context.getProject();
            Target target = new Target();
            target.setProject(project);
            target.setLocation(new Location(context.getLocator()));
            context.addTarget(target);

            for (int i = 0; i < attrs.getLength(); i++) {
                String attrUri = attrs.getURI(i);
                if (attrUri != null
                    && !attrUri.equals("""")
                    && !attrUri.equals(uri)) {
                    continue; 
                }
                String key = attrs.getLocalName(i);
                String value = attrs.getValue(i);

                if (key.equals(""name"")) {
                    name = value;
                    if ("""".equals(name)) {
                        throw new BuildException(""name attribute must ""
                            + ""not be empty"");
                    }
                } else if (key.equals(""depends"")) {
                    depends = value;
                } else if (key.equals(""if"")) {
                    target.setIf(value);
                } else if (key.equals(""unless"")) {
                    target.setUnless(value);
                } else if (key.equals(""id"")) {
                    if (value != null && !value.equals("""")) {
                        context.getProject().addReference(value, target);
                    }
                } else if (key.equals(""description"")) {
                    target.setDescription(value);
                } else {
                    throw new SAXParseException(""Unexpected attribute \""""
                        + key + ""\"""", context.getLocator());
                }
            }

            if (name == null) {
                throw new SAXParseException(""target element appears without ""
                    + ""a name attribute"", context.getLocator());
            }

            
            if (context.getCurrentTargets().get(name) != null) {
                throw new BuildException(
                    ""Duplicate target '"" + name + ""'"", target.getLocation());
            }

            Hashtable projectTargets = project.getTargets();
            boolean   usedTarget = false;
            
            if (projectTargets.containsKey(name)) {
                project.log(""Already defined in main or a previous import, ""
                            + ""ignore "" + name, Project.MSG_VERBOSE);
            } else {
                target.setName(name);
                context.getCurrentTargets().put(name, target);
                project.addOrReplaceTarget(name, target);
                usedTarget = true;
            }

            if (depends.length() > 0) {
                target.setDepends(depends);
            }

            if (context.isIgnoringProjectTag() && context.getCurrentProjectName() != null
                && context.getCurrentProjectName().length() != 0) {
                
                
                String newName = context.getCurrentProjectName()
                    + ""."" + name;
                Target newTarget = usedTarget ? new Target(target) : target;
                newTarget.setName(newName);
                context.getCurrentTargets().put(newName, newTarget);
                project.addOrReplaceTarget(newName, newTarget);
            }
        }

        
        public AntHandler onStartChild(String uri, String name, String qname,
                                       Attributes attrs,
                                       AntXMLContext context)
            throws SAXParseException {
            return ProjectHelper2.elementHandler;
        }

        
        public void onEndElement(String uri, String tag, AntXMLContext context) {
            context.setCurrentTarget(context.getImplicitTarget());
        }
    }

    
    public static class ElementHandler extends AntHandler {

        
        public ElementHandler() {
        }

        
        public void onStartElement(String uri, String tag, String qname,
                                   Attributes attrs,
                                   AntXMLContext context)
            throws SAXParseException {
            RuntimeConfigurable parentWrapper = context.currentWrapper();
            Object parent = null;

            if (parentWrapper != null) {
                parent = parentWrapper.getProxy();
            }

            
            UnknownElement task = new UnknownElement(tag);
            task.setProject(context.getProject());
            task.setNamespace(uri);
            task.setQName(qname);
            task.setTaskType(
                ProjectHelper.genComponentName(task.getNamespace(), tag));
            task.setTaskName(qname);

            Location location = new Location(context.getLocator().getSystemId(),
                    context.getLocator().getLineNumber(),
                    context.getLocator().getColumnNumber());
            task.setLocation(location);
            task.setOwningTarget(context.getCurrentTarget());

            if (parent != null) {
                
                ((UnknownElement) parent).addChild(task);
            }  else {
                
                context.getCurrentTarget().addTask(task);
            }

            context.configureId(task, attrs);

            
            

            RuntimeConfigurable wrapper
                = new RuntimeConfigurable(task, task.getTaskName());

            for (int i = 0; i < attrs.getLength(); i++) {
                String name = attrs.getLocalName(i);
                String attrUri = attrs.getURI(i);
                if (attrUri != null
                    && !attrUri.equals("""")
                    && !attrUri.equals(uri)) {
                    name = attrUri + "":"" + attrs.getQName(i);
                }
                String value = attrs.getValue(i);
                
                
                
                
                if (ANT_TYPE.equals(name)
                    || (ANT_CORE_URI.equals(attrUri)
                        && ANT_TYPE.equals(attrs.getLocalName(i)))) {
                    name = ANT_TYPE;
                    int index = value.indexOf("":"");
                    if (index != -1) {
                        String prefix = value.substring(0, index);
                        String mappedUri = context.getPrefixMapping(prefix);
                        if (mappedUri == null) {
                            throw new BuildException(
                                ""Unable to find XML NS prefix "" + prefix);
                        }
                        value = ProjectHelper.genComponentName(
                            mappedUri, value.substring(index + 1));
                    }
                }
                wrapper.setAttribute(name, value);
            }

            if (parentWrapper != null) {
                parentWrapper.addChild(wrapper);
            }

            context.pushWrapper(wrapper);
        }

        
        public void characters(char[] buf, int start, int count,
                               AntXMLContext context)
            throws SAXParseException {
            RuntimeConfigurable wrapper = context.currentWrapper();
            wrapper.addText(buf, start, count);
        }

        
        public AntHandler onStartChild(String uri, String tag, String qname,
                                       Attributes attrs,
                                       AntXMLContext context)
            throws SAXParseException {
            return ProjectHelper2.elementHandler;
        }

        
        public void onEndElement(String uri, String tag, AntXMLContext context) {
            context.popWrapper();
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.junit.AggregateTransformer,14,1,0,16,86,41,3,14,8,0.891025641,451,0.833333333,2,0.0,0.243589744,0,0,30.35714286,3,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.junit;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

import java.net.URL;

import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.XSLTProcess;
import org.apache.tools.ant.taskdefs.Delete;
import org.apache.tools.ant.taskdefs.TempFile;
import org.apache.tools.ant.util.JAXPUtils;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.resources.URLResource;
import org.apache.tools.ant.types.resources.FileResource;

import org.w3c.dom.Document;


public class AggregateTransformer {
    
    public static final String FRAMES = ""frames"";

    
    public static final String NOFRAMES = ""noframes"";

    
    public static class Format extends EnumeratedAttribute {
        
        public String[] getValues() {
            return new String[]{FRAMES, NOFRAMES};
        }
    }

    
    
    protected Task task;

    
    protected Document document;

    
    protected File styleDir;

    
    protected File toDir;

    
    private List params;

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private static int counter = 0;

    
    protected String format = FRAMES;

    
    private static DocumentBuilderFactory privateDBFactory;

    
    protected static DocumentBuilderFactory dbfactory;

    static {
       privateDBFactory = DocumentBuilderFactory.newInstance();
       dbfactory = privateDBFactory;
    }
    

    
    public AggregateTransformer(Task task) {
        this.task = task;
        params = new Vector();
    }

    
    protected static DocumentBuilderFactory getDocumentBuilderFactory() {
        return privateDBFactory;
    }

    
    public void setFormat(Format format) {
        this.format = format.getValue();
    }

    
    public void setXmlDocument(Document doc) {
        this.document = doc;
    }

    
    protected void setXmlfile(File xmlfile) throws BuildException {
        try {
            DocumentBuilder builder = privateDBFactory.newDocumentBuilder();
            InputStream in = new FileInputStream(xmlfile);
            try {
                Document doc = builder.parse(in);
                setXmlDocument(doc);
            } finally {
                in.close();
            }
        } catch (Exception e) {
            throw new BuildException(""Error while parsing document: "" + xmlfile, e);
        }
    }

    
    public void setStyledir(File styledir) {
        this.styleDir = styledir;
    }

    
    public void setTodir(File todir) {
        this.toDir = todir;
    }

    
    public void setExtension(String ext) {
        task.log(""extension is not used anymore"", Project.MSG_WARN);
    }

    
    public XSLTProcess.Param createParam() {
        XSLTProcess.Param p = new XSLTProcess.Param();
        params.add(p);
        return p;
    }

    
    public void transform() throws BuildException {
        checkOptions();
        Project project = task.getProject();

        TempFile tempFileTask = new TempFile();
        tempFileTask.bindToOwner(task);

        XSLTProcess xsltTask = new XSLTProcess();
        xsltTask.bindToOwner(task);

        xsltTask.setXslResource(getStylesheet());

        
        xsltTask.setIn(((XMLResultAggregator) task).getDestinationFile());
        File outputFile = null;
        if (format.equals(FRAMES)) {
            String tempFileProperty = getClass().getName() + String.valueOf(counter++);
            File tmp = FILE_UTILS.resolveFile(project.getBaseDir(),
                    project.getProperty(""java.io.tmpdir""));
            tempFileTask.setDestDir(tmp);
            tempFileTask.setProperty(tempFileProperty);
            tempFileTask.execute();
            outputFile = new File(project.getProperty(tempFileProperty));
        } else {
            outputFile = new File(toDir, ""junit-noframes.html"");
        }
        xsltTask.setOut(outputFile);
        for (Iterator i = params.iterator(); i.hasNext();) {
            XSLTProcess.Param param = (XSLTProcess.Param) i.next();
            XSLTProcess.Param newParam = xsltTask.createParam();
            newParam.setProject(task.getProject());
            newParam.setName(param.getName());
            newParam.setExpression(param.getExpression());
        }
        XSLTProcess.Param paramx = xsltTask.createParam();
        paramx.setProject(task.getProject());
        paramx.setName(""output.dir"");
        paramx.setExpression(toDir.getAbsolutePath());
        final long t0 = System.currentTimeMillis();
        try {
            xsltTask.execute();
        } catch (Exception e) {
            throw new BuildException(""Errors while applying transformations: ""
                    + e.getMessage(), e);
        }
        final long dt = System.currentTimeMillis() - t0;
        task.log(""Transform time: "" + dt + ""ms"");
        if (format.equals(FRAMES)) {
            Delete delete = new Delete();
            delete.bindToOwner(task);
            delete.setFile(outputFile);
            delete.execute();
        }
    }

    
    protected Resource getStylesheet() {
        String xslname = ""junit-frames.xsl"";
        if (NOFRAMES.equals(format)) {
            xslname = ""junit-noframes.xsl"";
        }
        if (styleDir == null) {
            
            
            URLResource stylesheet = new URLResource();
            URL stylesheetURL = getClass().getClassLoader().getResource(
                    ""org/apache/tools/ant/taskdefs/optional/junit/xsl/"" + xslname);
            stylesheet.setURL(stylesheetURL);
            return stylesheet;
        }
        
        
        FileResource stylesheet = new FileResource();
        File stylesheetFile = new File(styleDir, xslname);
        stylesheet.setFile(stylesheetFile);
        return stylesheet;
    }


    
    protected void checkOptions() throws BuildException {
        
        if (toDir == null) {
            toDir = task.getProject().resolveFile(""."");
        } else if (!toDir.isAbsolute()) {
            toDir = task.getProject().resolveFile(toDir.getPath());
        }
    }

    
    protected String getStylesheetSystemId() throws IOException {
        String xslname = ""junit-frames.xsl"";
        if (NOFRAMES.equals(format)) {
            xslname = ""junit-noframes.xsl"";
        }
        if (styleDir == null) {
            URL url = getClass().getResource(""xsl/"" + xslname);
            if (url == null) {
                throw new FileNotFoundException(""Could not find jar resource "" + xslname);
            }
            return url.toExternalForm();
        }
        File file = new File(styleDir, xslname);
        if (!file.exists()) {
            throw new FileNotFoundException(""Could not find file '"" + file + ""'"");
        }
        return JAXPUtils.getSystemId(file);
    }

}
"
org.apache.tools.ant.util.depend.bcel.FullAnalyzer,3,2,0,6,32,3,0,6,1,2.0,185,0.0,0,0.882352941,0.666666667,1,2,60.66666667,12,4.3333,0,"
package org.apache.tools.ant.util.depend.bcel;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.bcel.classfile.ClassParser;
import org.apache.bcel.classfile.DescendingVisitor;
import org.apache.bcel.classfile.JavaClass;
import org.apache.tools.ant.util.depend.AbstractAnalyzer;


public class FullAnalyzer extends AbstractAnalyzer {
    
    public FullAnalyzer() {
        
        try {
            new ClassParser(""force"");
        } catch (IOException e) {
            
        }
    }

    
    protected void determineDependencies(Vector files, Vector classes) {
        
        
        Hashtable dependencies = new Hashtable();
        Hashtable containers = new Hashtable();
        Hashtable toAnalyze = new Hashtable();
        for (Enumeration e = getRootClasses(); e.hasMoreElements();) {
            String classname = (String) e.nextElement();
            toAnalyze.put(classname, classname);
        }

        int count = 0;
        int maxCount = isClosureRequired() ? MAX_LOOPS : 2;
        while (toAnalyze.size() != 0 && count++ < maxCount) {
            DependencyVisitor dependencyVisitor = new DependencyVisitor();
            for (Enumeration e = toAnalyze.keys(); e.hasMoreElements();) {
                String classname = (String) e.nextElement();
                dependencies.put(classname, classname);
                try {
                    File container = getClassContainer(classname);
                    if (container == null) {
                        continue;
                    }
                    containers.put(container, container);

                    ClassParser parser = null;
                    if (container.getName().endsWith("".class"")) {
                        parser = new ClassParser(container.getPath());
                    } else {
                        parser = new ClassParser(container.getPath(),
                            classname.replace('.', '/') + "".class"");
                    }

                    JavaClass javaClass = parser.parse();
                    DescendingVisitor traverser
                         = new DescendingVisitor(javaClass, dependencyVisitor);
                    traverser.visit();
                } catch (IOException ioe) {
                    
                }
            }

            toAnalyze.clear();

            
            Enumeration depsEnum = dependencyVisitor.getDependencies();
            while (depsEnum.hasMoreElements()) {
                String className = (String) depsEnum.nextElement();
                if (!dependencies.containsKey(className)) {
                    toAnalyze.put(className, className);
                }
            }
        }

        files.removeAllElements();
        for (Enumeration e = containers.keys(); e.hasMoreElements();) {
            files.addElement((File) e.nextElement());
        }

        classes.removeAllElements();
        for (Enumeration e = dependencies.keys(); e.hasMoreElements();) {
            classes.addElement((String) e.nextElement());
        }
    }

    
    protected boolean supportsFileDependencies() {
        return true;
    }
}

"
org.apache.tools.ant.taskdefs.optional.ssh.LogListener,1,1,0,4,1,0,4,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.tools.ant.taskdefs.optional.ssh;


public interface LogListener {
    
    void log(String message);
}
"
org.apache.tools.ant.taskdefs.ProcessDestroyer,7,1,0,2,36,0,2,1,5,0.555555556,335,0.666666667,1,0.0,0.642857143,0,0,45.57142857,9,3.2857,0,"

package org.apache.tools.ant.taskdefs;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Vector;


class ProcessDestroyer implements Runnable {

    private Vector processes = new Vector();
    
    private Method addShutdownHookMethod;
    private Method removeShutdownHookMethod;
    private ProcessDestroyerImpl destroyProcessThread = null;

    
    
    private boolean added = false;
    
    
    private boolean running = false;

    private class ProcessDestroyerImpl extends Thread {
        private boolean shouldDestroy = true;

        public ProcessDestroyerImpl() {
            super(""ProcessDestroyer Shutdown Hook"");
        }
        public void run() {
            if (shouldDestroy) {
                ProcessDestroyer.this.run();
            }
        }

        public void setShouldDestroy(boolean shouldDestroy) {
            this.shouldDestroy = shouldDestroy;
        }
    }

    
    public ProcessDestroyer() {
        try {
            
            
            Class[] paramTypes = {Thread.class};
            addShutdownHookMethod =
                Runtime.class.getMethod(""addShutdownHook"", paramTypes);

            removeShutdownHookMethod =
                Runtime.class.getMethod(""removeShutdownHook"", paramTypes);
            
        } catch (NoSuchMethodException e) {
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    
    private void addShutdownHook() {
        if (addShutdownHookMethod != null && !running) {
            destroyProcessThread = new ProcessDestroyerImpl();
            Object[] args = {destroyProcessThread};
            try {
                addShutdownHookMethod.invoke(Runtime.getRuntime(), args);
                added = true;
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                Throwable t = e.getTargetException();
                if (t != null && t.getClass() == IllegalStateException.class) {
                    
                    running = true;
                } else {
                    e.printStackTrace();
                }
            }
        }
    }

    
    private void removeShutdownHook() {
        if (removeShutdownHookMethod != null && added && !running) {
            Object[] args = {destroyProcessThread};
            try {
                Boolean removed =
                    (Boolean) removeShutdownHookMethod.invoke(
                        Runtime.getRuntime(),
                        args);
                if (!removed.booleanValue()) {
                    System.err.println(""Could not remove shutdown hook"");
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                Throwable t = e.getTargetException();
                if (t != null && t.getClass() == IllegalStateException.class) {
                    
                    running = true;
                } else {
                    e.printStackTrace();
                }
            }
            
            
            
            destroyProcessThread.setShouldDestroy(false);
            if (!destroyProcessThread.getThreadGroup().isDestroyed()) {
                
                
                destroyProcessThread.start();
            }
            
            try {
                destroyProcessThread.join(20000);
            } catch (InterruptedException ie) {
                
                
            }
            destroyProcessThread = null;
            added = false;
        }
    }

    
    public boolean isAddedAsShutdownHook() {
        return added;
    }

    
    public boolean add(Process process) {
        synchronized (processes) {
            
            if (processes.size() == 0) {
                addShutdownHook();
            }
            processes.addElement(process);
            return processes.contains(process);
        }
    }

    
    public boolean remove(Process process) {
        synchronized (processes) {
            boolean processRemoved = processes.removeElement(process);
            if (processRemoved && processes.size() == 0) {
                removeShutdownHook();
            }
            return processRemoved;
        }
    }

    
    public void run() {
        synchronized (processes) {
            running = true;
            Enumeration e = processes.elements();
            while (e.hasMoreElements()) {
                ((Process) e.nextElement()).destroy();
            }
        }
    }
}
"
org.apache.tools.ant.types.resources.comparators.Name,2,4,0,2,5,1,0,2,1,2.0,11,0.0,0,0.971428571,0.75,1,1,4.5,1,0.5,0,"
package org.apache.tools.ant.types.resources.comparators;

import org.apache.tools.ant.types.Resource;


public class Name extends ResourceComparator {
    
    protected int resourceCompare(Resource foo, Resource bar) {
        return foo.getName().compareTo(bar.getName());
    }

}
"
org.apache.tools.ant.filters.EscapeUnicode,5,5,0,3,19,4,1,2,4,0.25,107,1.0,0,0.903225806,0.7,2,5,20.2,1,0.6,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;


public class EscapeUnicode
    extends BaseParamFilterReader
    implements ChainableReader {
    
    
    private StringBuffer unicodeBuf;

    
    public EscapeUnicode() {
        super();
        unicodeBuf = new StringBuffer();
    }

    
    public EscapeUnicode(final Reader in) {
        super(in);
        unicodeBuf = new StringBuffer();
    }

    
    public final int read() throws IOException {
        if (!getInitialized()) {
            initialize();
            setInitialized(true);
        }

        int ch = -1;
        if (unicodeBuf.length() == 0) {
            ch = in.read();
            if (ch != -1) {
                char achar = (char) ch;
                if (achar >= '\u0080') {
                    unicodeBuf = new StringBuffer(""u0000"");
                    String s = Integer.toHexString(ch);
                    
                    for (int i = 0; i < s.length(); i++) {
                        unicodeBuf.setCharAt(unicodeBuf.length()
                                             - s.length() + i,
                                             s.charAt(i));
                    }
                    ch = '\\';
                }
            }
        } else {
            ch = (int) unicodeBuf.charAt(0);
            unicodeBuf.deleteCharAt(0);
        }
        return ch;
    }

    
    public final Reader chain(final Reader rdr) {
        EscapeUnicode newFilter = new EscapeUnicode(rdr);
        newFilter.setInitialized(true);
        return newFilter;
    }

    
    private void initialize() {
    }
}

"
org.apache.tools.ant.taskdefs.optional.native2ascii.DefaultNative2Ascii,5,1,2,8,13,10,2,6,2,2.0,53,0.0,0,0.0,0.56,0,0,9.6,1,0.8,0,"
package org.apache.tools.ant.taskdefs.optional.native2ascii;

import java.io.File;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.taskdefs.optional.Native2Ascii;
import org.apache.tools.ant.types.Commandline;


public abstract class DefaultNative2Ascii implements Native2AsciiAdapter {

    
    public DefaultNative2Ascii() {
    }

    
    public final boolean convert(Native2Ascii args, File srcFile,
                                 File destFile) throws BuildException {
        Commandline cmd = new Commandline();
        setup(cmd, args);
        addFiles(cmd, args, srcFile, destFile);
        return run(cmd, args);
    }

    
    protected void setup(Commandline cmd, Native2Ascii args)
        throws BuildException {
        if (args.getEncoding() != null) {
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(args.getEncoding());
        }
        cmd.addArguments(args.getCurrentArgs());
    }

    
    protected void addFiles(Commandline cmd, ProjectComponent log, File src,
                            File dest) throws BuildException {
        cmd.createArgument().setFile(src);
        cmd.createArgument().setFile(dest);
    }

    
    protected abstract boolean run(Commandline cmd, ProjectComponent log)
        throws BuildException;
}
"
org.apache.tools.ant.util.regexp.RegexpUtil,3,1,0,6,4,3,6,0,3,2.0,20,0.0,0,0.0,0.5,0,0,5.666666667,2,1.0,0,"
package org.apache.tools.ant.util.regexp;




public class RegexpUtil {

    
    public static boolean hasFlag(int options, int flag) {
        return ((options & flag) > 0);
    }

    
    public static int removeFlag(int options, int flag) {
        return (options & (0xFFFFFFFF - flag));
    }
}
"
org.apache.tools.ant.taskdefs.PumpStreamHandler,16,1,3,14,26,82,12,2,9,0.733333333,183,1.0,1,0.0,0.546875,0,0,10.0625,2,1.0,1,"

package org.apache.tools.ant.taskdefs;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;


public class PumpStreamHandler implements ExecuteStreamHandler {

    private Thread outputThread;
    private Thread errorThread;
    private StreamPumper inputPump;

    private OutputStream out;
    private OutputStream err;
    private InputStream input;

    
    public PumpStreamHandler(OutputStream out, OutputStream err,
                             InputStream input) {
        this.out = out;
        this.err = err;
        this.input = input;
    }

    
    public PumpStreamHandler(OutputStream out, OutputStream err) {
        this(out, err, null);
    }

    
    public PumpStreamHandler(OutputStream outAndErr) {
        this(outAndErr, outAndErr);
    }

    
    public PumpStreamHandler() {
        this(System.out, System.err);
    }

    
    public void setProcessOutputStream(InputStream is) {
        createProcessOutputPump(is, out);
    }

    
    public void setProcessErrorStream(InputStream is) {
        if (err != null) {
            createProcessErrorPump(is, err);
        }
    }

    
    public void setProcessInputStream(OutputStream os) {
        if (input != null) {
            inputPump = createInputPump(input, os, true);
        } else {
            try {
                os.close();
            } catch (IOException e) {
                
            }
        }
    }

    
    public void start() {
        outputThread.start();
        errorThread.start();
        if (inputPump != null) {
            Thread inputThread = new Thread(inputPump);
            inputThread.setDaemon(true);
            inputThread.start();
        }
    }

    
    public void stop() {
        try {
            outputThread.join();
        } catch (InterruptedException e) {
            
        }
        try {
            errorThread.join();
        } catch (InterruptedException e) {
            
        }

        if (inputPump != null) {
            inputPump.stop();
        }

        try {
            err.flush();
        } catch (IOException e) {
            
        }
        try {
            out.flush();
        } catch (IOException e) {
            
        }
    }

    
    protected OutputStream getErr() {
        return err;
    }

    
    protected OutputStream getOut() {
        return out;
    }

    
    protected void createProcessOutputPump(InputStream is, OutputStream os) {
        outputThread = createPump(is, os);
    }

    
    protected void createProcessErrorPump(InputStream is, OutputStream os) {
        errorThread = createPump(is, os);
    }

    
    protected Thread createPump(InputStream is, OutputStream os) {
        return createPump(is, os, false);
    }

    
    protected Thread createPump(InputStream is, OutputStream os,
                                boolean closeWhenExhausted) {
        final Thread result
            = new Thread(new StreamPumper(is, os, closeWhenExhausted));
        result.setDaemon(true);
        return result;
    }

    
     StreamPumper createInputPump(InputStream is, OutputStream os,
                                boolean closeWhenExhausted) {
        StreamPumper pumper = new StreamPumper(is, os, closeWhenExhausted);
        pumper.setAutoflush(true);
        return pumper;
    }

}
"
org.apache.tools.ant.taskdefs.Parallel,18,3,0,8,52,101,2,8,9,0.861344538,519,0.928571429,2,0.685185185,0.194444444,0,0,27.05555556,7,1.5,1,"
package org.apache.tools.ant.taskdefs;

import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.util.StringUtils;


public class Parallel extends Task
                      implements TaskContainer {

    
    public static class TaskList implements TaskContainer {
        
        private List tasks = new ArrayList();

        
        public void addTask(Task nestedTask) {
            tasks.add(nestedTask);
        }
    }

    
    private Vector nestedTasks = new Vector();

    
    private final Object semaphore = new Object();

    
    private int numThreads = 0;

    
    private int numThreadsPerProcessor = 0;

    
    private long timeout;

    
    private volatile boolean stillRunning;

    
    private boolean timedOut;

    
    private boolean failOnAny;

    
    private TaskList daemonTasks;

    
    private StringBuffer exceptionMessage;

    
    private int numExceptions = 0;

    
    private Throwable firstException;

    
    private Location firstLocation;

    
    public void addDaemons(TaskList daemonTasks) {
        if (this.daemonTasks != null) {
            throw new BuildException(""Only one daemon group is supported"");
        }
        this.daemonTasks = daemonTasks;
    }

    
    public void setPollInterval(int pollInterval) {
    }

    
    public void setFailOnAny(boolean failOnAny) {
        this.failOnAny = failOnAny;
    }

    
    public void addTask(Task nestedTask) {
        nestedTasks.addElement(nestedTask);
    }

    
    public void setThreadsPerProcessor(int numThreadsPerProcessor) {
        this.numThreadsPerProcessor = numThreadsPerProcessor;
    }

    
    public void setThreadCount(int numThreads) {
        this.numThreads = numThreads;
    }

    
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }



    
    public void execute() throws BuildException {
        updateThreadCounts();
        if (numThreads == 0) {
            numThreads = nestedTasks.size();
        }
        spinThreads();
    }

    
    private void updateThreadCounts() {
        if (numThreadsPerProcessor != 0) {
            int numProcessors = getNumProcessors();
            if (numProcessors != 0) {
                numThreads = numProcessors * numThreadsPerProcessor;
            }
        }
    }

    private void processExceptions(TaskRunnable[] runnables) {
        if (runnables == null) {
            return;
        }
        for (int i = 0; i < runnables.length; ++i) {
            Throwable t = runnables[i].getException();
            if (t != null) {
                numExceptions++;
                if (firstException == null) {
                    firstException = t;
                }
                if (t instanceof BuildException
                    && firstLocation == Location.UNKNOWN_LOCATION) {
                    firstLocation = ((BuildException) t).getLocation();
                }
                exceptionMessage.append(StringUtils.LINE_SEP);
                exceptionMessage.append(t.getMessage());
            }
        }
    }

    
    private void spinThreads() throws BuildException {
        final int numTasks = nestedTasks.size();
        TaskRunnable[] runnables = new TaskRunnable[numTasks];
        stillRunning = true;
        timedOut = false;

        int threadNumber = 0;
        for (Enumeration e = nestedTasks.elements(); e.hasMoreElements();
             threadNumber++) {
            Task nestedTask = (Task) e.nextElement();
            runnables[threadNumber]
                = new TaskRunnable(nestedTask);
        }

        final int maxRunning = numTasks < numThreads ? numTasks : numThreads;
        TaskRunnable[] running = new TaskRunnable[maxRunning];

        threadNumber = 0;
        ThreadGroup group = new ThreadGroup(""parallel"");

        TaskRunnable[] daemons = null;
        if (daemonTasks != null && daemonTasks.tasks.size() != 0) {
            daemons = new TaskRunnable[daemonTasks.tasks.size()];
        }

        synchronized (semaphore) {
            
            
            
            
            
        }

        synchronized (semaphore) {
            
            if (daemons != null) {
                for (int i = 0; i < daemons.length; ++i) {
                    daemons[i] = new TaskRunnable((Task) daemonTasks.tasks.get(i));
                    Thread daemonThread =  new Thread(group, daemons[i]);
                    daemonThread.setDaemon(true);
                    daemonThread.start();
                }
            }

            
            
            for (int i = 0; i < maxRunning; ++i) {
                running[i] = runnables[threadNumber++];
                Thread thread =  new Thread(group, running[i]);
                thread.start();
            }

            if (timeout != 0) {
                
                Thread timeoutThread = new Thread() {
                    public synchronized void run() {
                        try {
                            wait(timeout);
                            synchronized (semaphore) {
                                stillRunning = false;
                                timedOut = true;
                                semaphore.notifyAll();
                            }
                        } catch (InterruptedException e) {
                            
                        }
                    }
                };
                timeoutThread.start();
            }

            
            outer:
            while (threadNumber < numTasks && stillRunning) {
                for (int i = 0; i < maxRunning; i++) {
                    if (running[i] == null || running[i].isFinished()) {
                        running[i] = runnables[threadNumber++];
                        Thread thread =  new Thread(group, running[i]);
                        thread.start();
                        
                        
                        continue outer;
                    }
                }

                
                
                try {
                    semaphore.wait();
                } catch (InterruptedException ie) {
                    
                    
                    
                }
            }

            
            outer2:
            while (stillRunning) {
                for (int i = 0; i < maxRunning; ++i) {
                    if (running[i] != null && !running[i].isFinished()) {
                        
                        
                        try {
                            semaphore.wait();
                        } catch (InterruptedException ie) {
                            
                        }
                        continue outer2;
                    }
                }
                stillRunning = false;
            }
        }

        if (timedOut) {
            throw new BuildException(""Parallel execution timed out"");
        }

        
        exceptionMessage = new StringBuffer();
        numExceptions = 0;
        firstException = null;
        firstLocation = Location.UNKNOWN_LOCATION;
        processExceptions(daemons);
        processExceptions(runnables);

        if (numExceptions == 1) {
            if (firstException instanceof BuildException) {
                throw (BuildException) firstException;
            } else {
                throw new BuildException(firstException);
            }
        } else if (numExceptions > 1) {
            throw new BuildException(exceptionMessage.toString(),
                                     firstLocation);
        }
    }

    
    private int getNumProcessors() {
        try {
            Class[] paramTypes = {};
            Method availableProcessors =
                Runtime.class.getMethod(""availableProcessors"", paramTypes);

            Object[] args = {};
            Integer ret = (Integer) availableProcessors.invoke(Runtime.getRuntime(), args);
            return ret.intValue();
        } catch (Exception e) {
            
            return 0;
        }
    }

    
    private class TaskRunnable implements Runnable {
        private Throwable exception;
        private Task task;
        private boolean finished;

        
        TaskRunnable(Task task) {
            this.task = task;
        }

        
        public void run() {
            try {
                task.perform();
            } catch (Throwable t) {
                exception = t;
                if (failOnAny) {
                    stillRunning = false;
                }
            } finally {
                synchronized (semaphore) {
                    finished = true;
                    semaphore.notifyAll();
                }
            }
        }

        
        public Throwable getException() {
            return exception;
        }

        
        boolean isFinished() {
            return finished;
        }
    }

}
"
org.apache.tools.ant.util.PropertyOutputStream,3,3,0,3,8,1,2,1,3,0.0,49,1.0,1,0.9375,0.666666667,0,0,14.33333333,4,1.3333,0,"

package org.apache.tools.ant.util;

import java.io.ByteArrayOutputStream;

import org.apache.tools.ant.Project;


public class PropertyOutputStream extends ByteArrayOutputStream {
    private Project project;
    private String property;
    private boolean trim;

    
    public PropertyOutputStream(Project p, String s) {
        this(p, s, true);
    }

    
    public PropertyOutputStream(Project p, String s, boolean b) {
        project = p;
        property = s;
        trim = b;
    }

    
    public void close() {
        if (project != null && property != null) {
            String s = new String(toByteArray());
            project.setNewProperty(property, trim ? s.trim() : s);
        }
    }

}

"
org.apache.tools.ant.taskdefs.email.PlainMailer,3,2,1,8,43,3,2,6,1,2.0,250,0.0,0,0.9,0.555555556,1,1,82.33333333,9,3.3333,1,"
package org.apache.tools.ant.taskdefs.email;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Enumeration;
import org.apache.tools.ant.BuildException;
import org.apache.tools.mail.MailMessage;


class PlainMailer extends Mailer {
    
    public void send() {
        try {
            MailMessage mailMessage = new MailMessage(host, port);

            mailMessage.from(from.toString());

            Enumeration e;

            e = replyToList.elements();
            while (e.hasMoreElements()) {
                mailMessage.replyto(e.nextElement().toString());
            }
            e = toList.elements();
            while (e.hasMoreElements()) {
                mailMessage.to(e.nextElement().toString());
            }
            e = ccList.elements();
            while (e.hasMoreElements()) {
                mailMessage.cc(e.nextElement().toString());
            }
            e = bccList.elements();
            while (e.hasMoreElements()) {
                mailMessage.bcc(e.nextElement().toString());
            }
            if (subject != null) {
                mailMessage.setSubject(subject);
            }
            mailMessage.setHeader(""Date"", getDate());
            if (message.getCharset() != null) {
                mailMessage.setHeader(""Content-Type"", message.getMimeType()
                    + ""; charset=\"""" + message.getCharset() + ""\"""");
            } else {
                mailMessage.setHeader(""Content-Type"", message.getMimeType());
            }
            e = headers.elements();
            while (e.hasMoreElements()) {
                Header h = (Header) e.nextElement();
                mailMessage.setHeader(h.getName(), h.getValue());
            }
            PrintStream out = mailMessage.getPrintStream();
            message.print(out);

            e = files.elements();
            while (e.hasMoreElements()) {
                attach((File) e.nextElement(), out);
            }
            mailMessage.sendAndClose();
        } catch (IOException ioe) {
            throw new BuildException(""IO error sending mail"", ioe);
        }

    }

    
    protected void attach(File file, PrintStream out)
         throws IOException {
        if (!file.exists() || !file.canRead()) {
            throw new BuildException(""File \"""" + file.getName()
                 + ""\"" does not exist or is not ""
                 + ""readable."");
        }

        if (includeFileNames) {
            out.println();

            String filename = file.getName();
            int filenamelength = filename.length();

            out.println(filename);
            for (int star = 0; star < filenamelength; star++) {
                out.print('=');
            }
            out.println();
        }

        int length;
        final int maxBuf = 1024;
        byte[] buf = new byte[maxBuf];
        FileInputStream finstr = new FileInputStream(file);

        try {
            BufferedInputStream in = new BufferedInputStream(finstr, buf.length);

            while ((length = in.read(buf)) != -1) {
                out.write(buf, 0, length);
            }
        } finally {
            finstr.close();
        }
    }
}

"
org.apache.tools.ant.taskdefs.optional.extension.resolvers.AntResolver,7,1,0,6,25,1,1,5,6,0.611111111,104,1.0,0,0.0,0.342857143,0,0,13.42857143,3,1.1429,0,"
package org.apache.tools.ant.taskdefs.optional.extension.resolvers;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Ant;
import org.apache.tools.ant.taskdefs.optional.extension.Extension;
import org.apache.tools.ant.taskdefs.optional.extension.ExtensionResolver;


public class AntResolver implements ExtensionResolver {
    private File antfile;
    private File destfile;
    private String target;

    
    public void setAntfile(final File antfile) {
        this.antfile = antfile;
    }

    
    public void setDestfile(final File destfile) {
        this.destfile = destfile;
    }

    
    public void setTarget(final String target) {
        this.target = target;
    }

    
    public File resolve(final Extension extension,
                         final Project project) throws BuildException {
        validate();

        final Ant ant = new Ant();
        ant.setProject(project);
        ant.setInheritAll(false);
        ant.setAntfile(antfile.getName());

        try {
            final File dir =
                antfile.getParentFile().getCanonicalFile();
            ant.setDir(dir);
        } catch (final IOException ioe) {
            throw new BuildException(ioe.getMessage(), ioe);
        }

        if (null != target) {
            ant.setTarget(target);
        }

        ant.execute();

        return destfile;
    }

    
    private void validate() {
        if (null == antfile) {
            final String message = ""Must specify Buildfile"";
            throw new BuildException(message);
        }

        if (null == destfile) {
            final String message = ""Must specify destination file"";
            throw new BuildException(message);
        }
    }

    
    public String toString() {
        return ""Ant["" + antfile + ""==>"" + destfile + ""]"";
    }
}
"
org.apache.tools.ant.taskdefs.compilers.DefaultCompilerAdapter,25,1,10,26,103,134,10,16,3,0.77173913,1167,1.0,9,0.0,0.226190476,0,0,44.76,29,4.68,2,"

package org.apache.tools.ant.taskdefs.compilers;




import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Location;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.Javac;
import org.apache.tools.ant.taskdefs.LogStreamHandler;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.StringUtils;
import org.apache.tools.ant.util.JavaEnvUtils;
import org.apache.tools.ant.taskdefs.condition.Os;


public abstract class DefaultCompilerAdapter implements CompilerAdapter {
    

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    protected Path src;
    protected File destDir;
    protected String encoding;
    protected boolean debug = false;
    protected boolean optimize = false;
    protected boolean deprecation = false;
    protected boolean depend = false;
    protected boolean verbose = false;
    protected String target;
    protected Path bootclasspath;
    protected Path extdirs;
    protected Path compileClasspath;
    protected Path compileSourcepath;
    protected Project project;
    protected Location location;
    protected boolean includeAntRuntime;
    protected boolean includeJavaRuntime;
    protected String memoryInitialSize;
    protected String memoryMaximumSize;

    protected File[] compileList;
    protected Javac attributes;

    
    
    protected static final String lSep = StringUtils.LINE_SEP;

    
    

    
    public void setJavac(Javac attributes) {
        this.attributes = attributes;
        src = attributes.getSrcdir();
        destDir = attributes.getDestdir();
        encoding = attributes.getEncoding();
        debug = attributes.getDebug();
        optimize = attributes.getOptimize();
        deprecation = attributes.getDeprecation();
        depend = attributes.getDepend();
        verbose = attributes.getVerbose();
        target = attributes.getTarget();
        bootclasspath = attributes.getBootclasspath();
        extdirs = attributes.getExtdirs();
        compileList = attributes.getFileList();
        compileClasspath = attributes.getClasspath();
        compileSourcepath = attributes.getSourcepath();
        project = attributes.getProject();
        location = attributes.getLocation();
        includeAntRuntime = attributes.getIncludeantruntime();
        includeJavaRuntime = attributes.getIncludejavaruntime();
        memoryInitialSize = attributes.getMemoryInitialSize();
        memoryMaximumSize = attributes.getMemoryMaximumSize();
    }

    
    public Javac getJavac() {
        return attributes;
    }

    
    protected Project getProject() {
        return project;
    }

    
    protected Path getCompileClasspath() {
        Path classpath = new Path(project);

        
        

        if (destDir != null) {
            classpath.setLocation(destDir);
        }

        
        

        Path cp = compileClasspath;
        if (cp == null) {
            cp = new Path(project);
        }
        if (includeAntRuntime) {
            classpath.addExisting(cp.concatSystemClasspath(""last""));
        } else {
            classpath.addExisting(cp.concatSystemClasspath(""ignore""));
        }

        if (includeJavaRuntime) {
            classpath.addJavaRuntime();
        }

        return classpath;
    }

    
    protected Commandline setupJavacCommandlineSwitches(Commandline cmd) {
        return setupJavacCommandlineSwitches(cmd, false);
    }

    
    protected Commandline setupJavacCommandlineSwitches(Commandline cmd,
                                                        boolean useDebugLevel) {
        Path classpath = getCompileClasspath();
        
        
        Path sourcepath = null;
        if (compileSourcepath != null) {
            sourcepath = compileSourcepath;
        } else {
            sourcepath = src;
        }

        String memoryParameterPrefix = assumeJava11() ? ""-J-"" : ""-J-X"";
        if (memoryInitialSize != null) {
            if (!attributes.isForkedJavac()) {
                attributes.log(""Since fork is false, ignoring ""
                               + ""memoryInitialSize setting."",
                               Project.MSG_WARN);
            } else {
                cmd.createArgument().setValue(memoryParameterPrefix
                                              + ""ms"" + memoryInitialSize);
            }
        }

        if (memoryMaximumSize != null) {
            if (!attributes.isForkedJavac()) {
                attributes.log(""Since fork is false, ignoring ""
                               + ""memoryMaximumSize setting."",
                               Project.MSG_WARN);
            } else {
                cmd.createArgument().setValue(memoryParameterPrefix
                                              + ""mx"" + memoryMaximumSize);
            }
        }

        if (attributes.getNowarn()) {
            cmd.createArgument().setValue(""-nowarn"");
        }

        if (deprecation) {
            cmd.createArgument().setValue(""-deprecation"");
        }

        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);
        }

        cmd.createArgument().setValue(""-classpath"");

        
        
        if (assumeJava11()) {
            Path cp = new Path(project);

            Path bp = getBootClassPath();
            if (bp.size() > 0) {
                cp.append(bp);
            }

            if (extdirs != null) {
                cp.addExtdirs(extdirs);
            }
            cp.append(classpath);
            cp.append(sourcepath);
            cmd.createArgument().setPath(cp);
        } else {
            cmd.createArgument().setPath(classpath);
            
            
            if (sourcepath.size() > 0) {
                cmd.createArgument().setValue(""-sourcepath"");
                cmd.createArgument().setPath(sourcepath);
            }
            if (target != null) {
                cmd.createArgument().setValue(""-target"");
                cmd.createArgument().setValue(target);
            }

            Path bp = getBootClassPath();
            if (bp.size() > 0) {
                cmd.createArgument().setValue(""-bootclasspath"");
                cmd.createArgument().setPath(bp);
            }

            if (extdirs != null && extdirs.size() > 0) {
                cmd.createArgument().setValue(""-extdirs"");
                cmd.createArgument().setPath(extdirs);
            }
        }

        if (encoding != null) {
            cmd.createArgument().setValue(""-encoding"");
            cmd.createArgument().setValue(encoding);
        }
        if (debug) {
            if (useDebugLevel && !assumeJava11()) {
                String debugLevel = attributes.getDebugLevel();
                if (debugLevel != null) {
                    cmd.createArgument().setValue(""-g:"" + debugLevel);
                } else {
                    cmd.createArgument().setValue(""-g"");
                }
            } else {
                cmd.createArgument().setValue(""-g"");
            }
        } else if (getNoDebugArgument() != null) {
            cmd.createArgument().setValue(getNoDebugArgument());
        }
        if (optimize) {
            cmd.createArgument().setValue(""-O"");
        }

        if (depend) {
            if (assumeJava11()) {
                cmd.createArgument().setValue(""-depend"");
            } else if (assumeJava12()) {
                cmd.createArgument().setValue(""-Xdepend"");
            } else {
                attributes.log(""depend attribute is not supported by the ""
                               + ""modern compiler"", Project.MSG_WARN);
            }
        }

        if (verbose) {
            cmd.createArgument().setValue(""-verbose"");
        }

        addCurrentCompilerArgs(cmd);

        return cmd;
    }

    
    protected Commandline setupModernJavacCommandlineSwitches(Commandline cmd) {
        setupJavacCommandlineSwitches(cmd, true);
        if (attributes.getSource() != null && !assumeJava13()) {
            cmd.createArgument().setValue(""-source"");
            String source = attributes.getSource();
            if ((assumeJava14() || assumeJava15())
                && (source.equals(""1.1"") || source.equals(""1.2""))) {
                
                
                cmd.createArgument().setValue(""1.3"");
            } else {
                cmd.createArgument().setValue(source);
            }
        } else if ((assumeJava15() || assumeJava16())
                   && attributes.getTarget() != null) {
            String t = attributes.getTarget();
            if (t.equals(""1.1"") || t.equals(""1.2"") || t.equals(""1.3"")
                || t.equals(""1.4"")) {
                String s = t;
                if (t.equals(""1.1"")) {
                    
                    s = ""1.2"";
                }
                attributes.log("""", Project.MSG_WARN);
                attributes.log(""          WARNING"", Project.MSG_WARN);
                attributes.log("""", Project.MSG_WARN);
                attributes.log(""The -source switch defaults to 1.5 in JDK 1.5 and 1.6."",
                               Project.MSG_WARN);
                attributes.log(""If you specify -target "" + t
                               + "" you now must also specify -source "" + s
                               + ""."", Project.MSG_WARN);
                attributes.log(""Ant will implicitly add -source "" + s
                               + "" for you.  Please change your build file."",
                               Project.MSG_WARN);
                cmd.createArgument().setValue(""-source"");
                cmd.createArgument().setValue(s);
            }
        }
        return cmd;
    }

    
    protected Commandline setupModernJavacCommand() {
        Commandline cmd = new Commandline();
        setupModernJavacCommandlineSwitches(cmd);

        logAndAddFilesToCompile(cmd);
        return cmd;
    }

    
    protected Commandline setupJavacCommand() {
        return setupJavacCommand(false);
    }

    
    protected Commandline setupJavacCommand(boolean debugLevelCheck) {
        Commandline cmd = new Commandline();
        setupJavacCommandlineSwitches(cmd, debugLevelCheck);
        logAndAddFilesToCompile(cmd);
        return cmd;
    }

    
    protected void logAndAddFilesToCompile(Commandline cmd) {
        attributes.log(""Compilation "" + cmd.describeArguments(),
                       Project.MSG_VERBOSE);

        StringBuffer niceSourceList = new StringBuffer(""File"");
        if (compileList.length != 1) {
            niceSourceList.append(""s"");
        }
        niceSourceList.append("" to be compiled:"");

        niceSourceList.append(StringUtils.LINE_SEP);

        for (int i = 0; i < compileList.length; i++) {
            String arg = compileList[i].getAbsolutePath();
            cmd.createArgument().setValue(arg);
            niceSourceList.append(""    "");
            niceSourceList.append(arg);
            niceSourceList.append(StringUtils.LINE_SEP);
        }

        attributes.log(niceSourceList.toString(), Project.MSG_VERBOSE);
    }

    
    protected int executeExternalCompile(String[] args, int firstFileName) {
        return executeExternalCompile(args, firstFileName, true);
    }

    
    protected int executeExternalCompile(String[] args, int firstFileName,
                                         boolean quoteFiles) {
        String[] commandArray = null;
        File tmpFile = null;

        try {
            
            if (Commandline.toString(args).length() > 4096
                && firstFileName >= 0) {
                PrintWriter out = null;
                try {
                    tmpFile = FILE_UTILS.createTempFile(
                        ""files"", """", getJavac().getTempdir());
                    tmpFile.deleteOnExit();
                    out = new PrintWriter(new FileWriter(tmpFile));
                    for (int i = firstFileName; i < args.length; i++) {
                        if (quoteFiles && args[i].indexOf("" "") > -1) {
                            args[i] = args[i].replace(File.separatorChar, '/');
                            out.println(""\"""" + args[i] + ""\"""");
                        } else {
                            out.println(args[i]);
                        }
                    }
                    out.flush();
                    commandArray = new String[firstFileName + 1];
                    System.arraycopy(args, 0, commandArray, 0, firstFileName);
                    commandArray[firstFileName] = ""@"" + tmpFile;
                } catch (IOException e) {
                    throw new BuildException(""Error creating temporary file"",
                                             e, location);
                } finally {
                    FileUtils.close(out);
                }
            } else {
                commandArray = args;
            }

            try {
                Execute exe = new Execute(
                                  new LogStreamHandler(attributes,
                                                       Project.MSG_INFO,
                                                       Project.MSG_WARN));
                if (Os.isFamily(""openvms"")) {
                    
                    
                    exe.setVMLauncher(true);
                }
                exe.setAntRun(project);
                exe.setWorkingDirectory(project.getBaseDir());
                exe.setCommandline(commandArray);
                exe.execute();
                return exe.getExitValue();
            } catch (IOException e) {
                throw new BuildException(""Error running "" + args[0]
                        + "" compiler"", e, location);
            }
        } finally {
            if (tmpFile != null) {
                tmpFile.delete();
            }
        }
    }

    
    protected void addExtdirsToClasspath(Path classpath) {
        classpath.addExtdirs(extdirs);
    }

    
    protected void addCurrentCompilerArgs(Commandline cmd) {
        cmd.addArguments(getJavac().getCurrentCompilerArgs());
    }

    
    protected boolean assumeJava11() {
        return ""javac1.1"".equals(attributes.getCompilerVersion());
    }

    
    protected boolean assumeJava12() {
        return ""javac1.2"".equals(attributes.getCompilerVersion())
            || (""classic"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2))
            || (""extJavac"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2));
    }

    
    protected boolean assumeJava13() {
        return ""javac1.3"".equals(attributes.getCompilerVersion())
            || (""classic"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3))
            || (""modern"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3))
            || (""extJavac"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3));
    }

    
    protected boolean assumeJava14() {
        return ""javac1.4"".equals(attributes.getCompilerVersion())
            || (""classic"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4))
            || (""modern"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4))
            || (""extJavac"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4));
    }

    
    protected boolean assumeJava15() {
        return ""javac1.5"".equals(attributes.getCompilerVersion())
            || (""classic"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_5))
            || (""modern"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_5))
            || (""extJavac"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_5));
    }

    
    protected boolean assumeJava16() {
        return ""javac1.6"".equals(attributes.getCompilerVersion())
            || (""classic"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6))
            || (""modern"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6))
            || (""extJavac"".equals(attributes.getCompilerVersion())
                && JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6));
    }

    
    protected Path getBootClassPath() {
        Path bp = new Path(project);
        if (bootclasspath != null) {
            bp.append(bootclasspath);
        }
        return bp.concatSystemBootClasspath(""ignore"");
    }

    
    protected String getNoDebugArgument() {
        return assumeJava11() ? null : ""-g:none"";
    }
}

"
org.apache.tools.ant.taskdefs.optional.ssh.SSHBase,18,3,2,10,43,61,2,8,16,0.857142857,184,1.0,1,0.685185185,0.388888889,0,0,8.833333333,1,0.9444,0,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.JSch;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public abstract class SSHBase extends Task implements LogListener {

    
    private static final int SSH_PORT = 22;

    private String host;
    private String knownHosts;
    private int port = SSH_PORT;
    private boolean failOnError = true;
    private boolean verbose;
    private SSHUserInfo userInfo;

    
    public SSHBase() {
        super();
        userInfo = new SSHUserInfo();
    }

    
    public void setHost(String host) {
        this.host = host;
    }

    
    public String getHost() {
        return host;
    }

    
    public void setFailonerror(boolean failure) {
        failOnError = failure;
    }

    
    public boolean getFailonerror() {
        return failOnError;
    }

    
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    
    public boolean getVerbose() {
        return verbose;
    }

    
    public void setUsername(String username) {
        userInfo.setName(username);
    }


    
    public void setPassword(String password) {
        userInfo.setPassword(password);
    }

    
    public void setKeyfile(String keyfile) {
        userInfo.setKeyfile(keyfile);
    }

    
    public void setPassphrase(String passphrase) {
        userInfo.setPassphrase(passphrase);
    }

    
    public void setKnownhosts(String knownHosts) {
        this.knownHosts = knownHosts;
    }

    
    public void setTrust(boolean yesOrNo) {
        userInfo.setTrust(yesOrNo);
    }

    
    public void setPort(int port) {
        this.port = port;
    }

    
    public int getPort() {
        return port;
    }

    
    public void init() throws BuildException {
        super.init();
        this.knownHosts = System.getProperty(""user.home"") + ""/.ssh/known_hosts"";
        this.port = SSH_PORT;
    }

    
    protected Session openSession() throws JSchException {
        JSch jsch = new JSch();
        if (null != userInfo.getKeyfile()) {
            jsch.addIdentity(userInfo.getKeyfile());
        }

        if (!userInfo.getTrust() && knownHosts != null) {
            log(""Using known hosts: "" + knownHosts, Project.MSG_DEBUG);
            jsch.setKnownHosts(knownHosts);
        }

        Session session = jsch.getSession(userInfo.getName(), host, port);
        session.setUserInfo(userInfo);
        log(""Connecting to "" + host + "":"" + port);
        session.connect();
        return session;
    }

    
    protected SSHUserInfo getUserInfo() {
        return userInfo;
    }
}
"
org.apache.tools.ant.taskdefs.optional.dotnet.DotnetResource,16,1,0,9,39,82,4,5,14,0.766666667,297,1.0,0,0.0,0.2109375,0,0,17.1875,8,2.125,0,"
package org.apache.tools.ant.taskdefs.optional.dotnet;

import org.apache.tools.ant.BuildException;

import java.io.File;
import java.util.ArrayList;
import org.apache.tools.ant.types.FileSet;
import java.util.Iterator;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.DirectoryScanner;


public class DotnetResource {

    
    private File file;

    
    private boolean embed = true;

    
    private Boolean isPublic = null;

    
    private String name = null;

    
    private ArrayList fileSets = new ArrayList();

    
    private String namespace = null;

    
    public boolean isEmbed() {
        return embed;
    }

    
    public void setEmbed(boolean embed) {
        this.embed = embed;
    }

    
    public File getFile() {
        return file;
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public Boolean getPublic() {
        return isPublic;
    }

    
    public void setPublic(Boolean aPublic) {
        isPublic = aPublic;
    }

    
    public String getName() {
        return name;
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public String getNamespace() {
        return namespace;
    }

    
    public void setNamespace(String namespace) {
        if (namespace == null) {
            this.namespace = null;
        } else {
            this.namespace = (namespace.length() == 0 || namespace.endsWith(""."") ? namespace
                    : namespace + '.');
        }
    }

    private void checkParameters() {
        if (hasFilesets()) {
            if (getName() != null) {
                throw new BuildException(
                        ""Cannot use <resource name=\""...\""> attribute with filesets"");
            }
            if (getFile() != null) {
                throw new BuildException(
                        ""Cannot use <resource file=\""...\""> attribute with filesets"");
            }
        } else {
            if (getNamespace() != null) {
                throw new BuildException(
                        ""Cannot use <resource namespace=\""...\""> attribute without filesets"");
            }
        }
    }

    
    public void getParameters(Project p, NetCommand command, boolean csharpStyle) {
        checkParameters();
        if (hasFilesets()) {
            for (Iterator listIter = fileSets.iterator(); listIter.hasNext();) {
                FileSet fs = (FileSet) listIter.next();
                String baseDirectory = fs.getDir(p).toString();
                String namespace = getNamespace(); 
                DirectoryScanner ds = fs.getDirectoryScanner(p);
                String[] files = ds.getIncludedFiles();
                for (int i = 0; i < files.length; i++) {
                    String file = files[i];
                    command.addArgument(getParameter(baseDirectory + File.separatorChar + file,
                            (namespace == null ? null : namespace
                                    + file.replace(File.separatorChar, '.')), csharpStyle));
                }
            }
        } else {
            command.addArgument(getParameter(getFile().toString(), getName(), csharpStyle));
        }
    }

    private String getParameter(String fileName, String name, boolean csharpStyle) {
        StringBuffer buffer = new StringBuffer();
        buffer.append(isEmbed() ? ""/resource"" : ""/linkresource"");
        buffer.append(':');
        buffer.append(fileName);
        if (name != null) {
            buffer.append(',');
            buffer.append(name);
            if (csharpStyle) {
                if (getPublic() != null) {
                    throw new BuildException(""This compiler does not support the ""
                            + ""public/private option."");
                } else {
                    if (getPublic() != null) {
                        buffer.append(',');
                        buffer.append(getPublic().booleanValue() ? ""public"" : ""private"");

                    }
                }
            } else if (getPublic() != null) {
                throw new BuildException(""You cannot have a public or private ""
                        + ""option without naming the resource"");
            }
        }
        return buffer.toString();
    }

    
    public void addFileset(FileSet fileset) {
        fileSets.add(fileset);
    }

    
    public boolean hasFilesets() {
        return fileSets.size() > 0;
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.LongCPInfo,3,3,0,2,11,3,1,1,3,2.0,25,0.0,0,0.8,0.666666667,2,2,7.333333333,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class LongCPInfo extends ConstantCPInfo {

    
    public LongCPInfo() {
        super(CONSTANT_LONG, 2);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        setValue(new Long(cpStream.readLong()));
    }

    
    public String toString() {
        return ""Long Constant Pool Entry: "" + getValue();
    }

}

"
org.apache.tools.ant.taskdefs.BZip2,3,4,0,6,22,3,0,6,1,1.0,82,0.0,0,0.961538462,1.0,2,4,26.0,3,1.6667,0,"

package org.apache.tools.ant.taskdefs;


import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.bzip2.CBZip2OutputStream;



public class BZip2 extends Pack {
    
    protected void pack() {
        CBZip2OutputStream zOut = null;
        try {
            BufferedOutputStream bos =
                new BufferedOutputStream(new FileOutputStream(zipFile));
            bos.write('B');
            bos.write('Z');
            zOut = new CBZip2OutputStream(bos);
            zipResource(getSrcResource(), zOut);
        } catch (IOException ioe) {
            String msg = ""Problem creating bzip2 "" + ioe.getMessage();
            throw new BuildException(msg, ioe, getLocation());
        } finally {
            FileUtils.close(zOut);
        }
    }

    
    protected boolean supportsNonFileResources() {
        return getClass().equals(BZip2.class);
    }
}
"
org.apache.tools.ant.taskdefs.Property,35,3,0,13,93,519,4,9,25,0.909090909,807,1.0,3,0.536231884,0.171428571,0,0,21.74285714,7,1.4,1,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.PropertyHelper;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;


public class Property extends Task {

    
    protected String name;
    protected String value;
    protected File file;
    protected URL url;
    protected String resource;
    protected Path classpath;
    protected String env;
    protected Reference ref;
    protected String prefix;
    private Project fallback;

    protected boolean userProperty; 
    

    
    public Property() {
        this(false);
    }

    
    protected Property(boolean userProperty) {
        this(userProperty, null);
    }

    
    protected Property(boolean userProperty, Project fallback) {
        this.userProperty = userProperty;
        this.fallback = fallback;
    }

    
    public void setName(String name) {
        this.name = name;
    }

    
    public String getName() {
        return name;
    }

    
    public void setLocation(File location) {
        setValue(location.getAbsolutePath());
    }

    
    public void setValue(String value) {
        this.value = value;
    }

    
    public String getValue() {
        return value;
    }

    
    public void setFile(File file) {
        this.file = file;
    }

    
    public File getFile() {
        return file;
    }

    
    public void setUrl(URL url) {
        this.url = url;
    }

    
    public URL getUrl() {
        return url;
    }

    
    public void setPrefix(String prefix) {
        this.prefix = prefix;
        if (!prefix.endsWith(""."")) {
            this.prefix += ""."";
        }
    }

    
    public String getPrefix() {
        return prefix;
    }

    
    public void setRefid(Reference ref) {
        this.ref = ref;
    }

    
    public Reference getRefid() {
        return ref;
    }

    
    public void setResource(String resource) {
        this.resource = resource;
    }

    
    public String getResource() {
        return resource;
    }

    
    public void setEnvironment(String env) {
        this.env = env;
    }

    
    public String getEnvironment() {
        return env;
    }

    
    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    
    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public Path getClasspath() {
        return classpath;
    }

    
    public void setUserProperty(boolean userProperty) {
        log(""DEPRECATED: Ignoring request to set user property in Property""
            + "" task."", Project.MSG_WARN);
    }

    
    public String toString() {
        return value == null ? """" : value;
    }

    
    public void execute() throws BuildException {
        if (getProject() == null) {
            throw new IllegalStateException(""project has not been set"");
        }

        if (name != null) {
            if (value == null && ref == null) {
                throw new BuildException(""You must specify value, location or ""
                                         + ""refid with the name attribute"",
                                         getLocation());
            }
        } else {
            if (url == null && file == null && resource == null && env == null) {
                throw new BuildException(""You must specify url, file, resource or ""
                                         + ""environment when not using the ""
                                         + ""name attribute"", getLocation());
            }
        }

        if (url == null && file == null && resource == null && prefix != null) {
            throw new BuildException(""Prefix is only valid when loading from ""
                                     + ""a url, file or resource"", getLocation());
        }

        if ((name != null) && (value != null)) {
            addProperty(name, value);
        }

        if (file != null) {
            loadFile(file);
        }

        if (url != null) {
            loadUrl(url);
        }

        if (resource != null) {
            loadResource(resource);
        }

        if (env != null) {
            loadEnvironment(env);
        }

        if ((name != null) && (ref != null)) {
            try {
                addProperty(name,
                            ref.getReferencedObject(getProject()).toString());
            } catch (BuildException be) {
                if (fallback != null) {
                    addProperty(name,
                                ref.getReferencedObject(fallback).toString());
                } else {
                    throw be;
                }
            }
        }
    }

    
    protected void loadUrl(URL url) throws BuildException {
        Properties props = new Properties();
        log(""Loading "" + url, Project.MSG_VERBOSE);
        try {
            InputStream is = url.openStream();
            try {
                props.load(is);
            } finally {
                if (is != null) {
                    is.close();
                }
            }
            addProperties(props);
        } catch (IOException ex) {
            throw new BuildException(ex, getLocation());
        }
    }


    
    protected void loadFile(File file) throws BuildException {
        Properties props = new Properties();
        log(""Loading "" + file.getAbsolutePath(), Project.MSG_VERBOSE);
        try {
            if (file.exists()) {
                FileInputStream fis = new FileInputStream(file);
                try {
                    props.load(fis);
                } finally {
                    if (fis != null) {
                        fis.close();
                    }
                }
                addProperties(props);
            } else {
                log(""Unable to find property file: "" + file.getAbsolutePath(),
                    Project.MSG_VERBOSE);
            }
        } catch (IOException ex) {
            throw new BuildException(ex, getLocation());
        }
    }

    
    protected void loadResource(String name) {
        Properties props = new Properties();
        log(""Resource Loading "" + name, Project.MSG_VERBOSE);
        InputStream is = null;
        try {
            ClassLoader cL = null;

            if (classpath != null) {
                cL = getProject().createClassLoader(classpath);
            } else {
                cL = this.getClass().getClassLoader();
            }

            if (cL == null) {
                is = ClassLoader.getSystemResourceAsStream(name);
            } else {
                is = cL.getResourceAsStream(name);
            }

            if (is != null) {
                props.load(is);
                addProperties(props);
            } else {
                log(""Unable to find resource "" + name, Project.MSG_WARN);
            }
        } catch (IOException ex) {
            throw new BuildException(ex, getLocation());
        } finally {
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    
                }
            }
        }

    }

    
    protected void loadEnvironment(String prefix) {
        Properties props = new Properties();
        if (!prefix.endsWith(""."")) {
            prefix += ""."";
        }
        log(""Loading Environment "" + prefix, Project.MSG_VERBOSE);
        Vector osEnv = Execute.getProcEnvironment();
        for (Enumeration e = osEnv.elements(); e.hasMoreElements();) {
            String entry = (String) e.nextElement();
            int pos = entry.indexOf('=');
            if (pos == -1) {
                log(""Ignoring: "" + entry, Project.MSG_WARN);
            } else {
                props.put(prefix + entry.substring(0, pos),
                entry.substring(pos + 1));
            }
        }
        addProperties(props);
    }

    
    protected void addProperties(Properties props) {
        resolveAllProperties(props);
        Enumeration e = props.keys();
        while (e.hasMoreElements()) {
            String propertyName = (String) e.nextElement();
            String propertyValue = props.getProperty(propertyName);

            String v = getProject().replaceProperties(propertyValue);

            if (prefix != null) {
                propertyName = prefix + propertyName;
            }

            addProperty(propertyName, v);
        }
    }

    
    protected void addProperty(String n, String v) {
        if (userProperty) {
            if (getProject().getUserProperty(n) == null) {
                getProject().setInheritedProperty(n, v);
            } else {
                log(""Override ignored for "" + n, Project.MSG_VERBOSE);
            }
        } else {
            getProject().setNewProperty(n, v);
        }
    }

    
    private void resolveAllProperties(Properties props) throws BuildException {
        for (Enumeration e = props.keys(); e.hasMoreElements();) {
            String propertyName = (String) e.nextElement();
            Stack referencesSeen = new Stack();
            resolve(props, propertyName, referencesSeen);
        }
    }

    
    private void resolve(Properties props, String name, Stack referencesSeen)
        throws BuildException {
        if (referencesSeen.contains(name)) {
            throw new BuildException(""Property "" + name + "" was circularly ""
                                     + ""defined."");
        }

        String propertyValue = props.getProperty(name);
        Vector fragments = new Vector();
        Vector propertyRefs = new Vector();
        PropertyHelper.getPropertyHelper(
            this.getProject()).parsePropertyString(
                propertyValue, fragments, propertyRefs);

        if (propertyRefs.size() != 0) {
            referencesSeen.push(name);
            StringBuffer sb = new StringBuffer();
            Enumeration i = fragments.elements();
            Enumeration j = propertyRefs.elements();
            while (i.hasMoreElements()) {
                String fragment = (String) i.nextElement();
                if (fragment == null) {
                    String propertyName = (String) j.nextElement();
                    fragment = getProject().getProperty(propertyName);
                    if (fragment == null) {
                        if (props.containsKey(propertyName)) {
                            resolve(props, propertyName, referencesSeen);
                            fragment = props.getProperty(propertyName);
                        } else {
                            fragment = ""${"" + propertyName + ""}"";
                        }
                    }
                }
                sb.append(fragment);
            }
            propertyValue = sb.toString();
            props.put(name, propertyValue);
            referencesSeen.pop();
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.depend.constantpool.StringCPInfo,4,3,0,4,16,0,1,4,4,0.333333333,46,1.0,0,0.727272727,0.5,2,3,10.25,1,0.75,0,"
package org.apache.tools.ant.taskdefs.optional.depend.constantpool;

import java.io.DataInputStream;
import java.io.IOException;


public class StringCPInfo extends ConstantCPInfo {

    
    public StringCPInfo() {
        super(CONSTANT_STRING, 1);
    }

    
    public void read(DataInputStream cpStream) throws IOException {
        index = cpStream.readUnsignedShort();

        setValue(""unresolved"");
    }

    
    public String toString() {
        return ""String Constant Pool Entry for ""
            + getValue() + ""["" + index + ""]"";
    }

    
    public void resolve(ConstantPool constantPool) {
        setValue(((Utf8CPInfo) constantPool.getEntry(index)).getValue());
        super.resolve(constantPool);
    }

    
    private int index;
}

"
org.apache.tools.ant.taskdefs.cvslib.RedirectingOutputStream,2,3,0,3,4,0,1,2,1,0.0,14,1.0,1,0.916666667,0.666666667,1,1,5.5,1,0.5,0,"
package org.apache.tools.ant.taskdefs.cvslib;

import org.apache.tools.ant.util.LineOrientedOutputStream;


class RedirectingOutputStream extends LineOrientedOutputStream {
    private final ChangeLogParser parser;

    
    public RedirectingOutputStream(final ChangeLogParser parser) {
        this.parser = parser;
    }

    
    protected void processLine(final String line) {
        parser.stdout(line);
    }
}

"
org.apache.tools.ant.filters.BaseFilterReader,10,3,6,9,20,21,7,2,5,0.814814815,146,1.0,1,0.692307692,0.228571429,1,2,13.3,1,0.8,0,"
package org.apache.tools.ant.filters;

import java.io.FilterReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.util.FileUtils;


public abstract class BaseFilterReader extends FilterReader {
    
    private static final int BUFFER_SIZE = 8192;

    
    private boolean initialized = false;

    
    private Project project = null;

    
    public BaseFilterReader() {
        super(new StringReader(""""));
        FileUtils.close(this);
    }

    
    public BaseFilterReader(final Reader in) {
        super(in);
    }

    
    public final int read(final char[] cbuf, final int off,
                          final int len) throws IOException {
        for (int i = 0; i < len; i++) {
            final int ch = read();
            if (ch == -1) {
                if (i == 0) {
                    return -1;
                } else {
                    return i;
                }
            }
            cbuf[off + i] = (char) ch;
        }
        return len;
    }

    
    public final long skip(final long n)
        throws IOException, IllegalArgumentException {
        if (n < 0L) {
            throw new IllegalArgumentException(""skip value is negative"");
        }

        for (long i = 0; i < n; i++) {
            if (read() == -1) {
                return i;
            }
        }
        return n;
    }

    
    protected final void setInitialized(final boolean initialized) {
        this.initialized = initialized;
    }

    
    protected final boolean getInitialized() {
        return initialized;
    }

    
    public final void setProject(final Project project) {
        this.project = project;
    }

    
    protected final Project getProject() {
        return project;
    }

    
    protected final String readLine() throws IOException {
        int ch = in.read();

        if (ch == -1) {
            return null;
        }

        StringBuffer line = new StringBuffer();

        while (ch != -1) {
            line.append ((char) ch);
            if (ch == '\n') {
                break;
            }
            ch = in.read();
        }
        return line.toString();
    }

    
    protected final String readFully() throws IOException {
        return FileUtils.readFully(in, BUFFER_SIZE);
    }
}
"
org.apache.tools.ant.types.DirSet,7,4,0,9,22,21,4,5,6,2.0,103,0.0,0,0.945652174,0.571428571,3,5,13.71428571,3,1.4286,0,"

package org.apache.tools.ant.types;

import java.util.Iterator;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.types.resources.FileResourceIterator;


public class DirSet extends AbstractFileSet implements ResourceCollection {

    
    public DirSet() {
        super();
    }

    
    protected DirSet(DirSet dirset) {
        super(dirset);
    }

    
    public Object clone() {
        if (isReference()) {
            return ((DirSet) getRef(getProject())).clone();
        } else {
            return super.clone();
        }
    }

    
    public Iterator iterator() {
        if (isReference()) {
            return ((DirSet) getRef(getProject())).iterator();
        }
        return new FileResourceIterator(getDir(getProject()),
            getDirectoryScanner(getProject()).getIncludedDirectories());
    }

    
    public int size() {
        if (isReference()) {
            return ((DirSet) getRef(getProject())).size();
        }
        return getDirectoryScanner(getProject()).getIncludedDirsCount();
    }

    
    public boolean isFilesystemOnly() {
        return true;
    }

    
    public String toString() {
        DirectoryScanner ds = getDirectoryScanner(getProject());
        String[] dirs = ds.getIncludedDirectories();
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < dirs.length; i++) {
            if (i > 0) {
                sb.append(';');
            }
            sb.append(dirs[i]);
        }
        return sb.toString();
    }

}
"
org.apache.tools.ant.taskdefs.optional.native2ascii.SunNative2Ascii,3,2,0,7,18,3,1,6,1,1.25,82,0.0,0,0.666666667,0.583333333,1,2,25.66666667,1,0.6667,0,"
package org.apache.tools.ant.taskdefs.optional.native2ascii;

import java.lang.reflect.Method;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.taskdefs.optional.Native2Ascii;
import org.apache.tools.ant.types.Commandline;


public final class SunNative2Ascii extends DefaultNative2Ascii {

    
    public static final String IMPLEMENTATION_NAME = ""sun"";

    
    protected void setup(Commandline cmd, Native2Ascii args)
        throws BuildException {
        if (args.getReverse()) {
            cmd.createArgument().setValue(""-reverse"");
        }
        super.setup(cmd, args);
    }

    
    protected boolean run(Commandline cmd, ProjectComponent log)
        throws BuildException {
        try {
            Class n2aMain = Class.forName(""sun.tools.native2ascii.Main"");
            Class[] param = new Class[] {String[].class};
            Method convert = n2aMain.getMethod(""convert"", param);
            if (convert == null) {
                throw new BuildException(""Could not find convert() method in ""
                                         + ""sun.tools.native2ascii.Main"");
            }
            Object o = n2aMain.newInstance();
            return ((Boolean) convert.invoke(o,
                                             new Object[] {cmd.getArguments()})
                    ).booleanValue();
        } catch (BuildException ex) {
            
            throw ex;
        } catch (Exception ex) {
            
           throw new BuildException(""Error starting Sun's native2ascii: "", ex);
        }
    }
}
"
org.apache.tools.ant.taskdefs.PreSetDef,4,4,0,10,20,2,0,10,4,0.666666667,112,1.0,1,0.931818182,0.5,1,1,26.5,4,2.0,0,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.AntTypeDefinition;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ComponentHelper;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.TaskContainer;
import org.apache.tools.ant.UnknownElement;


public class PreSetDef extends AntlibDefinition implements TaskContainer {
    private UnknownElement nestedTask;
    private String         name;

    
     public void setName(String name) {
        this.name = name;
    }

    
    public void addTask(Task nestedTask) {
        if (this.nestedTask != null) {
            throw new BuildException(""Only one nested element allowed"");
        }
        if (!(nestedTask instanceof UnknownElement)) {
            throw new BuildException(
                ""addTask called with a task that is not an unknown element"");
        }
        this.nestedTask = (UnknownElement) nestedTask;
    }


    
    public void execute() {
        if (nestedTask == null) {
            throw new BuildException(""Missing nested element"");
        }
        if (name == null) {
            throw new BuildException(""Name not specified"");
        }
        name = ProjectHelper.genComponentName(getURI(), name);

        ComponentHelper helper = ComponentHelper.getComponentHelper(
            getProject());

        String componentName = ProjectHelper.genComponentName(
            nestedTask.getNamespace(), nestedTask.getTag());

        AntTypeDefinition def = helper.getDefinition(componentName);
        if (def == null) {
            throw new BuildException(
                ""Unable to find typedef "" + componentName);
        }
        PreSetDefinition newDef = new PreSetDefinition(def, nestedTask);

        newDef.setName(name);

        helper.addDataTypeDefinition(newDef);
        log(""defining preset "" + name, Project.MSG_VERBOSE);
    }

    
    public static class PreSetDefinition extends AntTypeDefinition {
        private AntTypeDefinition parent;
        private UnknownElement    element;

        
        public PreSetDefinition(AntTypeDefinition parent, UnknownElement el) {
            if (parent instanceof PreSetDefinition) {
                PreSetDefinition p = (PreSetDefinition) parent;
                el.applyPreSet(p.element);
                parent = p.parent;
            }
            this.parent = parent;
            this.element = el;
        }

        
        public void setClass(Class clazz) {
            throw new BuildException(""Not supported"");
        }

        
        public void setClassName(String className) {
            throw new BuildException(""Not supported"");
        }

        
        public String getClassName() {
            return parent.getClassName();
        }

        
        public void setAdapterClass(Class adapterClass) {
            throw new BuildException(""Not supported"");
        }

        
        public void setAdaptToClass(Class adaptToClass) {
            throw new BuildException(""Not supported"");
        }

        
        public void setClassLoader(ClassLoader classLoader) {
            throw new BuildException(""Not supported"");
        }

        
        public ClassLoader getClassLoader() {
            return parent.getClassLoader();
        }

        
        public Class getExposedClass(Project project) {
            return parent.getExposedClass(project);
        }

        
        public Class getTypeClass(Project project) {
            return parent.getTypeClass(project);
        }


        
        public void checkClass(Project project) {
            parent.checkClass(project);
        }

        
        public Object createObject(Project project) {
            return parent.create(project);
        }

        
        public UnknownElement getPreSets() {
            return element;
        }

        
        public Object create(Project project) {
            return this;
        }

        
        public boolean sameDefinition(AntTypeDefinition other, Project project) {
            return (other != null && other.getClass() == getClass() && parent != null
                && parent.sameDefinition(((PreSetDefinition) other).parent, project)
                && element.similar(((PreSetDefinition) other).element));
        }

        
        public boolean similarDefinition(
            AntTypeDefinition other, Project project) {
            return (other != null && other.getClass().getName().equals(
                getClass().getName()) && parent != null
                && parent.similarDefinition(((PreSetDefinition) other).parent, project)
                && element.similar(((PreSetDefinition) other).element));
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.javah.JavahAdapterFactory,4,1,0,8,14,6,1,7,3,0.666666667,79,0.0,0,0.0,0.333333333,0,0,18.25,2,1.0,0,"
package org.apache.tools.ant.taskdefs.optional.javah;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.util.ClasspathUtils;
import org.apache.tools.ant.util.JavaEnvUtils;


public class JavahAdapterFactory {

    
    public static String getDefault() {
        if (JavaEnvUtils.isKaffe()) {
            return Kaffeh.IMPLEMENTATION_NAME;
        }
        return SunJavah.IMPLEMENTATION_NAME;
    }

    
    public static JavahAdapter getAdapter(String choice,
                                          ProjectComponent log)
        throws BuildException {
        if ((JavaEnvUtils.isKaffe() && choice == null)
            || Kaffeh.IMPLEMENTATION_NAME.equals(choice)) {
            return new Kaffeh();
        } else if (SunJavah.IMPLEMENTATION_NAME.equals(choice)) {
            return new SunJavah();
        } else if (choice != null) {
            return resolveClassName(choice);
        }

        
        
        return new SunJavah();
    }

    
    private static JavahAdapter resolveClassName(String className)
            throws BuildException {
        return (JavahAdapter) ClasspathUtils.newInstance(className,
                JavahAdapterFactory.class.getClassLoader(), JavahAdapter.class);
    }
}
"
org.apache.tools.ant.types.optional.AbstractScriptComponent,12,2,2,8,25,0,2,6,10,0.363636364,91,1.0,2,0.45,0.277777778,1,1,6.416666667,2,1.0,1,"
package org.apache.tools.ant.types.optional;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.ScriptRunnerBase;
import org.apache.tools.ant.util.ScriptRunnerHelper;


import java.io.File;


public abstract class AbstractScriptComponent extends ProjectComponent {
    
    private ScriptRunnerHelper helper = new ScriptRunnerHelper();

    
    private ScriptRunnerBase   runner = null;

    
    public void setProject(Project project) {
        super.setProject(project);
        helper.setProjectComponent(this);
    }

    
    public ScriptRunnerBase getRunner() {
        initScriptRunner();
        return runner;
    }

    
    public void setSrc(File file) {
        helper.setSrc(file);
    }

    
    public void addText(String text) {
        helper.addText(text);
    }

    
    public void setManager(String manager) {
        helper.setManager(manager);
    }

    
    public void setLanguage(String language) {
        helper.setLanguage(language);
    }

    
    protected void initScriptRunner() {
        if (runner != null) {
            return;
        }
        helper.setProjectComponent(this);
        runner = helper.getScriptRunner();
    }
    
    public void setClasspath(Path classpath) {
        helper.setClasspath(classpath);
    }

    
    public Path createClasspath() {
        return helper.createClasspath();
    }

    
    public void setClasspathRef(Reference r) {
        helper.setClasspathRef(r);
    }

    
    protected void executeScript(String execName) {
        getRunner().executeScript(execName);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.WeblogicDeploymentTool,32,2,1,16,140,400,3,14,23,0.970588235,1196,0.852941176,2,0.516129032,0.218637993,1,5,35.3125,28,2.625,1,"
package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.apache.tools.ant.AntClassLoader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.util.FileUtils;
import org.xml.sax.InputSource;


public class WeblogicDeploymentTool extends GenericDeploymentTool {
    
    public static final String PUBLICID_EJB11
         = ""-
    
    public static final String PUBLICID_EJB20
         = ""-
    
    public static final String PUBLICID_WEBLOGIC_EJB510
         = ""-
    
    public static final String PUBLICID_WEBLOGIC_EJB600
         = ""-
    
    public static final String PUBLICID_WEBLOGIC_EJB700
         = ""-

    
    protected static final String DEFAULT_WL51_EJB11_DTD_LOCATION
         = ""/weblogic/ejb/deployment/xml/ejb-jar.dtd"";
    
    protected static final String DEFAULT_WL60_EJB11_DTD_LOCATION
         = ""/weblogic/ejb20/dd/xml/ejb11-jar.dtd"";
    
    protected static final String DEFAULT_WL60_EJB20_DTD_LOCATION
         = ""/weblogic/ejb20/dd/xml/ejb20-jar.dtd"";

    protected static final String DEFAULT_WL51_DTD_LOCATION
         = ""/weblogic/ejb/deployment/xml/weblogic-ejb-jar.dtd"";
    protected static final String DEFAULT_WL60_51_DTD_LOCATION
         = ""/weblogic/ejb20/dd/xml/weblogic510-ejb-jar.dtd"";
    protected static final String DEFAULT_WL60_DTD_LOCATION
         = ""/weblogic/ejb20/dd/xml/weblogic600-ejb-jar.dtd"";
    protected static final String DEFAULT_WL70_DTD_LOCATION
         = ""/weblogic/ejb20/dd/xml/weblogic700-ejb-jar.dtd"";

    protected static final String DEFAULT_COMPILER = ""default"";

    protected static final String WL_DD = ""weblogic-ejb-jar.xml"";
    protected static final String WL_CMP_DD = ""weblogic-cmp-rdbms-jar.xml"";

    protected static final String COMPILER_EJB11 = ""weblogic.ejbc"";
    protected static final String COMPILER_EJB20 = ""weblogic.ejbc20"";

    
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private String jarSuffix = "".jar"";

    
    private String weblogicDTD;

    
    private String ejb11DTD;

    
    private boolean keepgenerated = false;

    
    private String ejbcClass = null;

    private String additionalArgs = """";

    
    private String additionalJvmArgs = """";

    private boolean keepGeneric = false;

    private String compiler = null;

    private boolean alwaysRebuild = true;

    
    private boolean noEJBC = false;

    
    private boolean newCMP = false;

    
    private Path wlClasspath = null;

    
    private Vector sysprops = new Vector();

    
    private Integer jvmDebugLevel = null;

    private File outputDir;

    
    public void addSysproperty(Environment.Variable sysp) {
        sysprops.add(sysp);
    }


    
    public Path createWLClasspath() {
        if (wlClasspath == null) {
            wlClasspath = new Path(getTask().getProject());
        }
        return wlClasspath.createPath();
    }

    
    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }


    
    public void setWLClasspath(Path wlClasspath) {
        this.wlClasspath = wlClasspath;
    }


    
    public void setCompiler(String compiler) {
        this.compiler = compiler;
    }


    
    public void setRebuild(boolean rebuild) {
        this.alwaysRebuild = rebuild;
    }


    
    public void setJvmDebugLevel(Integer jvmDebugLevel) {
        this.jvmDebugLevel = jvmDebugLevel;
    }


    
    public Integer getJvmDebugLevel() {
        return jvmDebugLevel;
    }



    
    public void setSuffix(String inString) {
        this.jarSuffix = inString;
    }


    
    public void setKeepgeneric(boolean inValue) {
        this.keepGeneric = inValue;
    }


    
    public void setKeepgenerated(String inValue) {
        this.keepgenerated = Boolean.valueOf(inValue).booleanValue();
    }


    
    public void setArgs(String args) {
        this.additionalArgs = args;
    }


    
    public void setJvmargs(String args) {
        this.additionalJvmArgs = args;
    }

    
    public void setEjbcClass(String ejbcClass) {
        this.ejbcClass = ejbcClass;
    }


    
    public String getEjbcClass() {
        return ejbcClass;
    }


    
    public void setWeblogicdtd(String inString) {
        setEJBdtd(inString);
    }


    
    public void setWLdtd(String inString) {
        this.weblogicDTD = inString;
    }


    
    public void setEJBdtd(String inString) {
        this.ejb11DTD = inString;
    }


    
    public void setOldCMP(boolean oldCMP) {
        this.newCMP = !oldCMP;
    }


    
    public void setNewCMP(boolean newCMP) {
        this.newCMP = newCMP;
    }


    
    public void setNoEJBC(boolean noEJBC) {
        this.noEJBC = noEJBC;
    }


    
    protected void registerKnownDTDs(DescriptorHandler handler) {
        
        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL51_EJB11_DTD_LOCATION);
        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL60_EJB11_DTD_LOCATION);
        handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
        handler.registerDTD(PUBLICID_EJB20, DEFAULT_WL60_EJB20_DTD_LOCATION);
    }


    
    protected DescriptorHandler getWeblogicDescriptorHandler(final File srcDir) {
        DescriptorHandler handler =
            new DescriptorHandler(getTask(), srcDir) {
                protected void processElement() {
                    if (currentElement.equals(""type-storage"")) {
                        
                        String fileNameWithMETA = currentText;
                        
                        String fileName
                             = fileNameWithMETA.substring(META_DIR.length(),
                            fileNameWithMETA.length());
                        File descriptorFile = new File(srcDir, fileName);

                        ejbFiles.put(fileNameWithMETA, descriptorFile);
                    }
                }
            };

        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL51_DTD_LOCATION);
        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL60_51_DTD_LOCATION);
        handler.registerDTD(PUBLICID_WEBLOGIC_EJB600, DEFAULT_WL60_DTD_LOCATION);
        handler.registerDTD(PUBLICID_WEBLOGIC_EJB700, DEFAULT_WL70_DTD_LOCATION);
        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, weblogicDTD);
        handler.registerDTD(PUBLICID_WEBLOGIC_EJB600, weblogicDTD);

        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();

            handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
        }
        return handler;
    }


    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
        File weblogicDD = new File(getConfig().descriptorDir, ddPrefix + WL_DD);

        if (weblogicDD.exists()) {
            ejbFiles.put(META_DIR + WL_DD,
                weblogicDD);
        } else {
            log(""Unable to locate weblogic deployment descriptor. ""
                + ""It was expected to be in ""
                + weblogicDD.getPath(), Project.MSG_WARN);
            return;
        }

        if (!newCMP) {
            log(""The old method for locating CMP files has been DEPRECATED."", Project.MSG_VERBOSE);
            log(""Please adjust your weblogic descriptor and set ""
                + ""newCMP=\""true\"" to use the new CMP descriptor ""
                + ""inclusion mechanism. "", Project.MSG_VERBOSE);
            
            File weblogicCMPDD = new File(getConfig().descriptorDir, ddPrefix + WL_CMP_DD);

            if (weblogicCMPDD.exists()) {
                ejbFiles.put(META_DIR + WL_CMP_DD,
                    weblogicCMPDD);
            }
        } else {
            
            
            
            
            try {
                File ejbDescriptor = (File) ejbFiles.get(META_DIR + EJB_DD);
                SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();

                saxParserFactory.setValidating(true);

                SAXParser saxParser = saxParserFactory.newSAXParser();
                DescriptorHandler handler
                    = getWeblogicDescriptorHandler(ejbDescriptor.getParentFile());

                saxParser.parse(new InputSource
                    (new FileInputStream(weblogicDD)),
                        handler);

                Hashtable ht = handler.getFiles();
                Enumeration e = ht.keys();

                while (e.hasMoreElements()) {
                    String key = (String) e.nextElement();

                    ejbFiles.put(key, ht.get(key));
                }
            } catch (Exception e) {
                String msg = ""Exception while adding Vendor specific files: "" + e.toString();

                throw new BuildException(msg, e);
            }
        }
    }


    
    File getVendorOutputJarFile(String baseName) {
        return new File(getDestDir(), baseName + jarSuffix);
    }


    
    private void buildWeblogicJar(File sourceJar, File destJar, String publicId) {
        Java javaTask = null;

        if (noEJBC) {
            try {
                FILE_UTILS.copyFile(sourceJar, destJar);
                if (!keepgenerated) {
                    sourceJar.delete();
                }
                return;
            } catch (IOException e) {
                throw new BuildException(""Unable to write EJB jar"", e);
            }
        }

        String ejbcClassName = ejbcClass;

        try {
            javaTask = new Java(getTask());
            javaTask.setTaskName(""ejbc"");

            javaTask.createJvmarg().setLine(additionalJvmArgs);
            if (!(sysprops.isEmpty())) {
                for (Enumeration en = sysprops.elements(); en.hasMoreElements();) {
                    Environment.Variable entry
                        = (Environment.Variable) en.nextElement();
                    javaTask.addSysproperty(entry);
                }
            }

            if (getJvmDebugLevel() != null) {
                javaTask.createJvmarg().setLine("" -Dweblogic.StdoutSeverityLevel="" + jvmDebugLevel);
            }

            if (ejbcClassName == null) {
                
                if (PUBLICID_EJB11.equals(publicId)) {
                    ejbcClassName = COMPILER_EJB11;
                } else if (PUBLICID_EJB20.equals(publicId)) {
                    ejbcClassName = COMPILER_EJB20;
                } else {
                    log(""Unrecognized publicId "" + publicId
                        + "" - using EJB 1.1 compiler"", Project.MSG_WARN);
                    ejbcClassName = COMPILER_EJB11;
                }
            }

            javaTask.setClassname(ejbcClassName);
            javaTask.createArg().setLine(additionalArgs);
            if (keepgenerated) {
                javaTask.createArg().setValue(""-keepgenerated"");
            }
            if (compiler == null) {
                
                
                String buildCompiler
                    = getTask().getProject().getProperty(""build.compiler"");

                if (buildCompiler != null && buildCompiler.equals(""jikes"")) {
                    javaTask.createArg().setValue(""-compiler"");
                    javaTask.createArg().setValue(""jikes"");
                }
            } else {
                if (!compiler.equals(DEFAULT_COMPILER)) {
                    javaTask.createArg().setValue(""-compiler"");
                    javaTask.createArg().setLine(compiler);
                }
            }

            Path combinedClasspath = getCombinedClasspath();
            if (wlClasspath != null && combinedClasspath != null
                 && combinedClasspath.toString().trim().length() > 0) {
                javaTask.createArg().setValue(""-classpath"");
                javaTask.createArg().setPath(combinedClasspath);
            }

            javaTask.createArg().setValue(sourceJar.getPath());
            if (outputDir == null) {
                javaTask.createArg().setValue(destJar.getPath());
            } else {
                javaTask.createArg().setValue(outputDir.getPath());
            }

            Path classpath = wlClasspath;

            if (classpath == null) {
                classpath = getCombinedClasspath();
            }

            javaTask.setFork(true);
            if (classpath != null) {
                javaTask.setClasspath(classpath);
            }

            log(""Calling "" + ejbcClassName + "" for "" + sourceJar.toString(),
                Project.MSG_VERBOSE);

            if (javaTask.executeJava() != 0) {
                throw new BuildException(""Ejbc reported an error"");
            }
        } catch (Exception e) {
            
            String msg = ""Exception while calling "" + ejbcClassName
                + "". Details: "" + e.toString();

            throw new BuildException(msg, e);
        }
    }


    
    protected void writeJar(String baseName, File jarFile, Hashtable files,
                            String publicId) throws BuildException {
        
        File genericJarFile = super.getVendorOutputJarFile(baseName);

        super.writeJar(baseName, genericJarFile, files, publicId);

        if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
            buildWeblogicJar(genericJarFile, jarFile, publicId);
        }
        if (!keepGeneric) {
            log(""deleting generic jar "" + genericJarFile.toString(),
                Project.MSG_VERBOSE);
            genericJarFile.delete();
        }
    }


    
    public void validateConfigured() throws BuildException {
        super.validateConfigured();
    }


    
    protected boolean isRebuildRequired(File genericJarFile, File weblogicJarFile) {
        boolean rebuild = false;

        JarFile genericJar = null;
        JarFile wlJar = null;
        File newWLJarFile = null;
        JarOutputStream newJarStream = null;
        ClassLoader genericLoader = null;

        try {
            log(""Checking if weblogic Jar needs to be rebuilt for jar "" + weblogicJarFile.getName(),
                Project.MSG_VERBOSE);
            
            if (genericJarFile.exists() && genericJarFile.isFile()
                 && weblogicJarFile.exists() && weblogicJarFile.isFile()) {
                
                genericJar = new JarFile(genericJarFile);
                wlJar = new JarFile(weblogicJarFile);

                Hashtable genericEntries = new Hashtable();
                Hashtable wlEntries = new Hashtable();
                Hashtable replaceEntries = new Hashtable();

                
                for (Enumeration e = genericJar.entries(); e.hasMoreElements();) {
                    JarEntry je = (JarEntry) e.nextElement();

                    genericEntries.put(je.getName().replace('\\', '/'), je);
                }
                
                for (Enumeration e = wlJar.entries(); e.hasMoreElements();) {
                    JarEntry je = (JarEntry) e.nextElement();

                    wlEntries.put(je.getName(), je);
                }

                
                genericLoader = getClassLoaderFromJar(genericJarFile);

                for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) {
                    String filepath = (String) e.nextElement();

                    if (wlEntries.containsKey(filepath)) {
                        

                        
                        JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
                        JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);

                        if ((genericEntry.getCrc() != wlEntry.getCrc())
                            || (genericEntry.getSize() != wlEntry.getSize())) {

                            if (genericEntry.getName().endsWith("".class"")) {
                                
                                String classname
                                    = genericEntry.getName().replace(File.separatorChar, '.');

                                classname = classname.substring(0, classname.lastIndexOf("".class""));

                                Class genclass = genericLoader.loadClass(classname);

                                if (genclass.isInterface()) {
                                    
                                    log(""Interface "" + genclass.getName()
                                        + "" has changed"", Project.MSG_VERBOSE);
                                    rebuild = true;
                                    break;
                                } else {
                                    
                                    replaceEntries.put(filepath, genericEntry);
                                }
                            } else {
                                
                                if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
                                    
                                    log(""Non class file "" + genericEntry.getName()
                                        + "" has changed"", Project.MSG_VERBOSE);
                                    rebuild = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        

                        log(""File "" + filepath + "" not present in weblogic jar"",
                            Project.MSG_VERBOSE);
                        rebuild = true;
                        break;
                    }
                }

                if (!rebuild) {
                    log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
                    newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + "".temp"");
                    if (newWLJarFile.exists()) {
                        newWLJarFile.delete();
                    }

                    newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile));
                    newJarStream.setLevel(0);

                    
                    for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) {
                        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                        int bytesRead;
                        InputStream is;
                        JarEntry je = (JarEntry) e.nextElement();

                        if (je.getCompressedSize() == -1
                            || je.getCompressedSize() == je.getSize()) {
                            newJarStream.setLevel(0);
                        } else {
                            newJarStream.setLevel(JAR_COMPRESS_LEVEL);
                        }

                        
                        if (replaceEntries.containsKey(je.getName())) {
                            log(""Updating Bean class from generic Jar ""
                                + je.getName(), Project.MSG_VERBOSE);
                            
                            je = (JarEntry) replaceEntries.get(je.getName());
                            is = genericJar.getInputStream(je);
                        } else {
                            

                            is = wlJar.getInputStream(je);
                        }
                        newJarStream.putNextEntry(new JarEntry(je.getName()));

                        while ((bytesRead = is.read(buffer)) != -1) {
                            newJarStream.write(buffer, 0, bytesRead);
                        }
                        is.close();
                    }
                } else {
                    log(""Weblogic Jar rebuild needed due to changed ""
                         + ""interface or XML"", Project.MSG_VERBOSE);
                }
            } else {
                rebuild = true;
            }
        } catch (ClassNotFoundException cnfe) {
            String cnfmsg = ""ClassNotFoundException while processing ejb-jar file""
                 + "". Details: ""
                 + cnfe.getMessage();

            throw new BuildException(cnfmsg, cnfe);
        } catch (IOException ioe) {
            String msg = ""IOException while processing ejb-jar file ""
                 + "". Details: ""
                 + ioe.getMessage();

            throw new BuildException(msg, ioe);
        } finally {
            
            if (genericJar != null) {
                try {
                    genericJar.close();
                } catch (IOException closeException) {
                    
                }
            }

            if (wlJar != null) {
                try {
                    wlJar.close();
                } catch (IOException closeException) {
                    
                }
            }

            if (newJarStream != null) {
                try {
                    newJarStream.close();
                } catch (IOException closeException) {
                    
                }

                try {
                    FILE_UTILS.rename(newWLJarFile, weblogicJarFile);
                } catch (IOException renameException) {
                    log(renameException.getMessage(), Project.MSG_WARN);
                    rebuild = true;
                }
            }
            if (genericLoader != null
                && genericLoader instanceof AntClassLoader) {
                AntClassLoader loader = (AntClassLoader) genericLoader;
                loader.cleanup();
            }
        }

        return rebuild;
    }


    
    protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
        Path lookupPath = new Path(getTask().getProject());

        lookupPath.setLocation(classjar);

        Path classpath = getCombinedClasspath();

        if (classpath != null) {
            lookupPath.append(classpath);
        }

        return getTask().getProject().createClassLoader(lookupPath);
    }
}
"
org.apache.tools.ant.types.resources.comparators.DelegatedResourceComparator,6,4,0,7,27,0,2,5,4,0.0,169,1.0,0,0.871794872,0.305555556,3,7,27.0,6,3.1667,0,"
package org.apache.tools.ant.types.resources.comparators;

import java.util.Stack;
import java.util.Vector;
import java.util.Iterator;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.DataType;
import org.apache.tools.ant.types.Resource;


public class DelegatedResourceComparator extends ResourceComparator {

    private Vector v = null;

    
    public synchronized void add(ResourceComparator c) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (c == null) {
            return;
        }
        v = (v == null) ? new Vector() : v;
        v.add(c);
    }

    
    public synchronized boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (isReference()) {
            return getCheckedRef().equals(o);
        }
        if (!(o instanceof DelegatedResourceComparator)) {
            return false;
        }
        Vector ov = ((DelegatedResourceComparator) o).v;
        return v == null ? ov == null : v.equals(ov);
    }

    
    public synchronized int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        return v == null ? 0 : v.hashCode();
    }

    
    protected synchronized int resourceCompare(Resource foo, Resource bar) {
        
        if (v == null || v.isEmpty()) {
            return foo.compareTo(bar);
        }
        int result = 0;
        for (Iterator i = v.iterator(); result == 0 && i.hasNext();) {
            result = ((ResourceComparator) i.next()).resourceCompare(foo, bar);
        }
        return result;
    }

    
    protected void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            if (!(v == null || v.isEmpty())) {
                for (Iterator i = v.iterator(); i.hasNext();) {
                    Object o = i.next();
                    if (o instanceof DataType) {
                        stk.push(o);
                        invokeCircularReferenceCheck((DataType) o, stk, p);
                    }
                }
            }
            setChecked(true);
        }
    }
}
"
org.apache.tools.ant.util.DeweyDecimal,10,1,1,4,23,0,4,0,10,0.0,298,1.0,0,0.0,0.36,0,0,28.7,6,2.6,0,"
package org.apache.tools.ant.util;

import java.util.StringTokenizer;


public class DeweyDecimal {

    
    private int[] components;

    
    public DeweyDecimal(final int[] components) {
        this.components = new int[components.length];

        for (int i = 0; i < components.length; i++) {
            this.components[i] = components[i];
        }
    }

    
    public DeweyDecimal(final String string)
        throws NumberFormatException {
        final StringTokenizer tokenizer = new StringTokenizer(string, ""."", true);
        final int size = tokenizer.countTokens();

        components = new int[ (size + 1) / 2 ];

        for (int i = 0; i < components.length; i++) {
            final String component = tokenizer.nextToken();
            if (component.equals("""")) {
                throw new NumberFormatException(""Empty component in string"");
            }

            components[ i ] = Integer.parseInt(component);

            
            if (tokenizer.hasMoreTokens()) {
                tokenizer.nextToken();

                
                if (!tokenizer.hasMoreTokens()) {
                    throw new NumberFormatException(""DeweyDecimal ended in a '.'"");
                }
            }
        }
    }

    
    public int getSize() {
        return components.length;
    }

    
    public int get(final int index) {
        return components[ index ];
    }

    
    public boolean isEqual(final DeweyDecimal other) {
        final int max = Math.max(other.components.length, components.length);

        for (int i = 0; i < max; i++) {
            final int component1 = (i < components.length) ? components[ i ] : 0;
            final int component2 = (i < other.components.length) ? other.components[ i ] : 0;

            if (component2 != component1) {
                return false;
            }
        }

        return true; 
    }

    
    public boolean isLessThan(final DeweyDecimal other) {
        return !isGreaterThanOrEqual(other);
    }

    
    public boolean isLessThanOrEqual(final DeweyDecimal other) {
        return !isGreaterThan(other);
    }

    
    public boolean isGreaterThan(final DeweyDecimal other) {
        final int max = Math.max(other.components.length, components.length);

        for (int i = 0; i < max; i++) {
            final int component1 = (i < components.length) ? components[ i ] : 0;
            final int component2 = (i < other.components.length) ? other.components[ i ] : 0;

            if (component2 > component1) {
                return false;
            }
            if (component2 < component1) {
                return true;
            }
        }

        return false; 
    }

    
    public boolean isGreaterThanOrEqual(final DeweyDecimal other) {
        final int max = Math.max(other.components.length, components.length);

        for (int i = 0; i < max; i++) {
            final int component1 = (i < components.length) ? components[ i ] : 0;
            final int component2 = (i < other.components.length) ? other.components[ i ] : 0;

            if (component2 > component1) {
                return false;
            }
            if (component2 < component1) {
                return true;
            }
        }

        return true; 
    }

    
    public String toString() {
        final StringBuffer sb = new StringBuffer();

        for (int i = 0; i < components.length; i++) {
            if (i != 0) {
                sb.append('.');
            }
            sb.append(components[ i ]);
        }

        return sb.toString();
    }
}
"
org.apache.tools.ant.filters.ChainableReader,1,1,0,23,1,0,23,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.tools.ant.filters;

import java.io.Reader;


public interface ChainableReader {
    
    Reader chain(Reader rdr);
}
"
org.apache.tools.ant.types.resources.URLResource,23,4,0,6,64,213,2,4,18,0.738636364,409,1.0,1,0.746478873,0.194805195,2,13,16.60869565,6,1.9565,0,"

package org.apache.tools.ant.types.resources;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.net.JarURLConnection;
import java.util.jar.JarFile;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.util.FileUtils;


public class URLResource extends Resource {
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
    private static final int NULL_URL
        = Resource.getMagicNumber(""null URL"".getBytes());

    private URL url;
    private URLConnection conn;

    
    public URLResource() {
    }

    
    public URLResource(URL u) {
        setURL(u);
    }

    
    public URLResource(File f) {
        setFile(f);
    }

    
    public URLResource(String u) {
        this(newURL(u));
    }

    
    public synchronized void setURL(URL u) {
        checkAttributesAllowed();
        url = u;
    }

    
    public synchronized void setFile(File f) {
        try {
            setURL(FILE_UTILS.getFileURL(f));
        } catch (MalformedURLException e) {
            throw new BuildException(e);
        }
    }

    
    public synchronized URL getURL() {
        if (isReference()) {
            return ((URLResource) getCheckedRef()).getURL();
        }
        return url;
     }

    
    public synchronized void setRefid(Reference r) {
        
        if (url != null) {
            throw tooManyAttributes();
        }
        super.setRefid(r);
    }

    
    public synchronized String getName() {
        return isReference() ? ((Resource) getCheckedRef()).getName()
            : getURL().getFile().substring(1);
    }

    
    public synchronized String toString() {
        return isReference()
            ? getCheckedRef().toString() : String.valueOf(getURL());
    }

    
    public synchronized boolean isExists() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).isExists();
        }
        return isExists(false);
    }

    
    private synchronized boolean isExists(boolean closeConnection) {
        if (getURL() == null) {
            return false;
        }
        try {
            connect();
            return true;
        } catch (IOException e) {
            return false;
        } finally {
            if (closeConnection) {
                close();
            }
        }
    }


    
    public synchronized long getLastModified() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getLastModified();
        }
        if (!isExists(false)) {
            return 0L;
        }
        return conn.getLastModified();
    }

    
    public synchronized boolean isDirectory() {
        return isReference()
            ? ((Resource) getCheckedRef()).isDirectory()
            : getName().endsWith(""/"");
    }

    
    public synchronized long getSize() {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getSize();
        }
        if (!isExists(false)) {
            return 0L;
        }
        try {
            connect();
            long contentlength = conn.getContentLength();
            close();
            return contentlength;
        } catch (IOException e) {
            return UNKNOWN_SIZE;
        }
    }

    
    public synchronized boolean equals(Object another) {
        if (this == another) {
            return true;
        }
        if (isReference()) {
            return getCheckedRef().equals(another);
        }
        if (!(another.getClass().equals(getClass()))) {
            return false;
        }
        URLResource otheru = (URLResource) another;
        return getURL() == null
            ? otheru.getURL() == null
            : getURL().equals(otheru.getURL());
    }

    
    public synchronized int hashCode() {
        if (isReference()) {
            return getCheckedRef().hashCode();
        }
        return MAGIC * ((getURL() == null) ? NULL_URL : getURL().hashCode());
    }

    
    public synchronized InputStream getInputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getInputStream();
        }
        connect();
        try {
            return conn.getInputStream();
        } finally {
            conn = null;
        }
    }

    
    public synchronized OutputStream getOutputStream() throws IOException {
        if (isReference()) {
            return ((Resource) getCheckedRef()).getOutputStream();
        }
        connect();
        try {
            return conn.getOutputStream();
        } finally {
            conn = null;
        }
    }

    
    protected synchronized void connect() throws IOException {
        URL u = getURL();
        if (u == null) {
            throw new BuildException(""URL not set"");
        }
        if (conn == null) {
            try {
                conn = u.openConnection();
                conn.connect();
            } catch (IOException e) {
                log(e.toString(), Project.MSG_ERR);
                conn = null;
                throw e;
            }
        }
    }

    
    private synchronized void close() {
        if (conn != null) {
            try {
                if (conn instanceof JarURLConnection) {
                    JarURLConnection juc = (JarURLConnection) conn;
                    JarFile jf = juc.getJarFile();
                    jf.close();
                    jf = null;
                } else if (conn instanceof HttpURLConnection) {
                    ((HttpURLConnection) conn).disconnect();
                }
            } catch (IOException exc) {
                
            } finally {
                conn = null;
            }
        }
    }

    private static URL newURL(String u) {
        try {
            return new URL(u);
        } catch (MalformedURLException e) {
            throw new BuildException(e);
        }
    }

}
"
org.apache.tools.ant.taskdefs.Untar,6,4,0,9,32,9,0,9,3,0.2,182,1.0,1,0.910714286,0.357142857,1,1,29.16666667,3,1.5,2,"

package org.apache.tools.ant.taskdefs;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.GZIPInputStream;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.util.FileNameMapper;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.bzip2.CBZip2InputStream;
import org.apache.tools.tar.TarEntry;
import org.apache.tools.tar.TarInputStream;




public class Untar extends Expand {
    
    private UntarCompressionMethod compression = new UntarCompressionMethod();

    
    public void setCompression(UntarCompressionMethod method) {
        compression = method;
    }

    
    public void setEncoding(String encoding) {
        throw new BuildException(""The "" + getTaskName()
                                 + "" task doesn't support the encoding""
                                 + "" attribute"", getLocation());
    }

    
    
    protected void expandFile(FileUtils fileUtils, File srcF, File dir) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(srcF);
            expandStream(srcF.getPath(), fis, dir);
        } catch (IOException ioe) {
            throw new BuildException(""Error while expanding "" + srcF.getPath(),
                                     ioe, getLocation());
        } finally {
            FileUtils.close(fis);
        }
    }

    
    protected void expandResource(Resource srcR, File dir) {
        InputStream i = null;
        try {
            i = srcR.getInputStream();
            expandStream(srcR.getName(), i, dir);
        } catch (IOException ioe) {
            throw new BuildException(""Error while expanding "" + srcR.getName(),
                                     ioe, getLocation());
        } finally {
            FileUtils.close(i);
        }
    }

    
    private void expandStream(String name, InputStream stream, File dir)
        throws IOException {
        TarInputStream tis = null;
        try {
            tis =
                new TarInputStream(compression.decompress(name,
                                                          new BufferedInputStream(stream)));
            log(""Expanding: "" + name + "" into "" + dir, Project.MSG_INFO);
            TarEntry te = null;
            FileNameMapper mapper = getMapper();
            while ((te = tis.getNextEntry()) != null) {
                extractFile(FileUtils.getFileUtils(), null, dir, tis,
                            te.getName(), te.getModTime(),
                            te.isDirectory(), mapper);
            }
            log(""expand complete"", Project.MSG_VERBOSE);
        } finally {
            FileUtils.close(tis);
        }
    }

    
    public static final class UntarCompressionMethod
        extends EnumeratedAttribute {

        
        
        private static final String NONE = ""none"";
        
        private static final String GZIP = ""gzip"";
        
        private static final String BZIP2 = ""bzip2"";


        
        public UntarCompressionMethod() {
            super();
            setValue(NONE);
        }

        
        public String[] getValues() {
            return new String[] {NONE, GZIP, BZIP2};
        }

        
        public InputStream decompress(final String name,
                                       final InputStream istream)
            throws IOException, BuildException {
            final String v = getValue();
            if (GZIP.equals(v)) {
                return new GZIPInputStream(istream);
            } else {
                if (BZIP2.equals(v)) {
                    final char[] magic = new char[] {'B', 'Z'};
                    for (int i = 0; i < magic.length; i++) {
                        if (istream.read() != magic[i]) {
                            throw new BuildException(
                                                     ""Invalid bz2 file."" + name);
                        }
                    }
                    return new CBZip2InputStream(istream);
                }
            }
            return istream;
        }
    }
}
"
org.apache.tools.ant.listener.CommonsLoggingListener,14,1,0,10,45,3,0,10,12,0.576923077,459,0.333333333,0,0.0,0.267857143,0,0,31.35714286,6,2.7143,0,"

package org.apache.tools.ant.listener;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogConfigurationException;
import org.apache.commons.logging.LogFactory;

import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.BuildLogger;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.UnknownElement;

import java.io.PrintStream;


public class CommonsLoggingListener implements BuildListener, BuildLogger {

    
    private boolean initialized = false;

    private LogFactory logFactory;

    
    public static final String TARGET_LOG = ""org.apache.tools.ant.Target"";
    
    public static final String PROJECT_LOG = ""org.apache.tools.ant.Project"";

    
    public CommonsLoggingListener() {
    }

    private Log getLog(String cat, String suffix) {
        if (suffix != null) {
            suffix = suffix.replace('.', '-');
            suffix = suffix.replace(' ', '-');
            cat = cat + ""."" + suffix;
        }
        PrintStream tmpOut = System.out;
        PrintStream tmpErr = System.err;
        System.setOut(out);
        System.setErr(err);

        if (!initialized) {
            try {
                logFactory = LogFactory.getFactory();
            } catch (LogConfigurationException e) {
                e.printStackTrace(System.err);
                return null;
            }
        }

        initialized = true;
        Log log = logFactory.getInstance(cat);
        System.setOut(tmpOut);
        System.setErr(tmpErr);
        return log;
    }

    
    public void buildStarted(BuildEvent event) {
        String categoryString = PROJECT_LOG;
        Log log = getLog(categoryString, null);

        if (initialized) {
            realLog(log, ""Build started."", Project.MSG_INFO, null);
        }
    }

    
    public void buildFinished(BuildEvent event) {
        if (initialized) {
            String categoryString = PROJECT_LOG;
            Log log = getLog(categoryString, event.getProject().getName());

            if (event.getException() == null) {
                realLog(log, ""Build finished."", Project.MSG_INFO, null);
            } else {
                realLog(log, ""Build finished with error."", Project.MSG_ERR,
                        event.getException());
            }
        }
    }

    
    
    public void targetStarted(BuildEvent event) {
        if (initialized) {
            Log log = getLog(TARGET_LOG,
                    event.getTarget().getName());
            
            
            realLog(log, ""Start: "" + event.getTarget().getName(),
                    Project.MSG_VERBOSE, null);
        }
    }

    
    
    public void targetFinished(BuildEvent event) {
        if (initialized) {
            String targetName = event.getTarget().getName();
            Log log = getLog(TARGET_LOG,
                    event.getTarget().getName());
            if (event.getException() == null) {
                realLog(log, ""Target end: "" + targetName, Project.MSG_DEBUG, null);
            } else {
                realLog(log, ""Target \"""" + targetName
                        + ""\"" finished with error."", Project.MSG_ERR,
                        event.getException());
            }
        }
    }

    
    
    public void taskStarted(BuildEvent event) {
        if (initialized) {
            Task task = event.getTask();
            Object real = task;
            if (task instanceof UnknownElement) {
                Object realObj = ((UnknownElement) task).getTask();
                if (realObj != null) {
                    real = realObj;
                }
            }
            Log log = getLog(real.getClass().getName(), null);
            if (log.isTraceEnabled()) {
                realLog(log, ""Task \"""" + task.getTaskName() + ""\"" started "",
                        Project.MSG_VERBOSE, null);
            }
        }
    }

    
    
    public void taskFinished(BuildEvent event) {
        if (initialized) {
            Task task = event.getTask();
            Object real = task;
            if (task instanceof UnknownElement) {
                Object realObj = ((UnknownElement) task).getTask();
                if (realObj != null) {
                    real = realObj;
                }
            }
            Log log = getLog(real.getClass().getName(), null);
            if (event.getException() == null) {
                if (log.isTraceEnabled()) {
                    realLog(log, ""Task \"""" + task.getTaskName() + ""\"" finished."",
                            Project.MSG_VERBOSE, null);
                }
            } else {
                realLog(log, ""Task \"""" + task.getTaskName()
                        + ""\"" finished with error."", Project.MSG_ERR,
                        event.getException());
            }
        }
    }


    
    
    public void messageLogged(BuildEvent event) {
        if (initialized) {
            Object categoryObject = event.getTask();
            String categoryString = null;
            String categoryDetail = null;

            if (categoryObject == null) {
                categoryObject = event.getTarget();
                if (categoryObject == null) {
                    categoryObject = event.getProject();
                    categoryString = PROJECT_LOG;
                    categoryDetail = event.getProject().getName();
                } else {
                    categoryString = TARGET_LOG;
                    categoryDetail = event.getTarget().getName();
                }
            } else {
                
                if (event.getTarget() != null) {
                    categoryString = categoryObject.getClass().getName();
                    categoryDetail = event.getTarget().getName();
                } else {
                    categoryString = categoryObject.getClass().getName();
                }

            }

            Log log = getLog(categoryString, categoryDetail);
            int priority = event.getPriority();
            String message = event.getMessage();
            realLog(log, message, priority , null);
        }
    }

    private void realLog(Log log, String message, int priority, Throwable t) {
        PrintStream tmpOut = System.out;
        PrintStream tmpErr = System.err;
        System.setOut(out);
        System.setErr(err);
        switch (priority) {
            case Project.MSG_ERR:
                if (t == null) {
                    log.error(message);
                } else {
                    log.error(message, t);
                }
                break;
            case Project.MSG_WARN:
                if (t == null) {
                    log.warn(message);
                } else {
                    log.warn(message, t);
                }
                break;
            case Project.MSG_INFO:
                if (t == null) {
                    log.info(message);
                } else {
                    log.info(message, t);
                }
                break;
            case Project.MSG_VERBOSE:
                log.debug(message);
                break;
            case Project.MSG_DEBUG:
                log.debug(message);
                break;
            default:
                log.error(message);
                break;
        }
        System.setOut(tmpOut);
        System.setErr(tmpErr);
    }

    
    PrintStream out = System.out;
    PrintStream err = System.err;
    

    
    public void setMessageOutputLevel(int level) {
        
    }

    
    public void setOutputPrintStream(PrintStream output) {
        this.out = output;
    }

    
    public void setEmacsMode(boolean emacsMode) {
        
    }

    
    public void setErrorPrintStream(PrintStream err) {
        this.err = err;
    }

}
"
org.apache.tools.ant.ComponentHelper,39,1,0,26,154,449,13,16,26,0.878446115,1711,0.714285714,3,0.0,0.178947368,0,0,42.33333333,13,2.5641,0,"

package org.apache.tools.ant;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;
import java.io.InputStream;
import java.io.IOException;
import java.io.File;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;

import org.apache.tools.ant.taskdefs.Typedef;
import org.apache.tools.ant.taskdefs.Definer;
import org.apache.tools.ant.launch.Launcher;
import org.apache.tools.ant.util.FileUtils;


public class ComponentHelper  {
    
    private AntTypeTable antTypeTable;

    
    private Hashtable taskClassDefinitions = new Hashtable();
    
    private boolean rebuildTaskClassDefinitions = true;

    
    private Hashtable typeClassDefinitions = new Hashtable();
    
    private boolean rebuildTypeClassDefinitions = true;

    
    private Set checkedNamespaces = new HashSet();

    
    private Stack antLibStack = new Stack();
    
    private String antLibCurrentUri = null;

    
    private ComponentHelper next;

    
    private Project project;

    
    private static final String ERROR_NO_TASK_LIST_LOAD = ""Can't load default task list"";
    
    private static final String ERROR_NO_TYPE_LIST_LOAD = ""Can't load default type list"";

    
    public static final String COMPONENT_HELPER_REFERENCE = ""ant.ComponentHelper"";

    
    private static final String BUILD_SYSCLASSPATH_ONLY = ""only"";

    
    private static final String ANT_PROPERTY_TASK = ""property"";

    
    private static Properties[] defaultDefinitions = new Properties[2];


    
    public static ComponentHelper getComponentHelper(Project project) {
        if (project == null) {
            return null;
        }
        
        ComponentHelper ph = (ComponentHelper) project.getReference(
                COMPONENT_HELPER_REFERENCE);
        if (ph != null) {
            return ph;
        }
        ph = new ComponentHelper();
        ph.setProject(project);

        project.addReference(COMPONENT_HELPER_REFERENCE, ph);
        return ph;
    }

    
    protected ComponentHelper() {
    }

    
    public void setNext(ComponentHelper next) {
        this.next = next;
    }

    
    public ComponentHelper getNext() {
        return next;
    }

    
    public void setProject(Project project) {
        this.project = project;
        antTypeTable = new AntTypeTable(project);
    }

    
    public void initSubProject(ComponentHelper helper) {
        
        AntTypeTable typeTable = helper.antTypeTable;
        for (Iterator i = typeTable.values().iterator(); i.hasNext();) {
            AntTypeDefinition def = (AntTypeDefinition) i.next();
            antTypeTable.put(def.getName(), def);
        }
        
        for (Iterator i = helper.checkedNamespaces.iterator(); i.hasNext();) {
            checkedNamespaces.add(i.next());
        }
    }

    
    public Object createComponent(UnknownElement ue,
                                  String ns,
                                  String componentType)
        throws BuildException {
        Object component = createComponent(componentType);
        if (component instanceof Task) {
            Task task = (Task) component;
            task.setLocation(ue.getLocation());
            task.setTaskType(componentType);
            task.setTaskName(ue.getTaskName());
            task.setOwningTarget(ue.getOwningTarget());
            task.init();
        }
        return component;
    }

    
    public Object createComponent(String componentName) {
        AntTypeDefinition def = getDefinition(componentName);
        return (def == null) ? null : def.create(project);
    }

    
    public Class getComponentClass(String componentName) {
        AntTypeDefinition def = getDefinition(componentName);
        return (def == null) ? null : def.getExposedClass(project);
    }

    
    public AntTypeDefinition getDefinition(String componentName) {
        checkNamespace(componentName);
        return antTypeTable.getDefinition(componentName);
    }

    
    public void initDefaultDefinitions() {
        initTasks();
        initTypes();
    }

    
    public void addTaskDefinition(String taskName, Class taskClass) {
        checkTaskClass(taskClass);
        AntTypeDefinition def = new AntTypeDefinition();
        def.setName(taskName);
        def.setClassLoader(taskClass.getClassLoader());
        def.setClass(taskClass);
        def.setAdapterClass(TaskAdapter.class);
        def.setClassName(taskClass.getName());
        def.setAdaptToClass(Task.class);
        updateDataTypeDefinition(def);
    }

    
    public void checkTaskClass(final Class taskClass) throws BuildException {
        if (!Modifier.isPublic(taskClass.getModifiers())) {
            final String message = taskClass + "" is not public"";
            project.log(message, Project.MSG_ERR);
            throw new BuildException(message);
        }
        if (Modifier.isAbstract(taskClass.getModifiers())) {
            final String message = taskClass + "" is abstract"";
            project.log(message, Project.MSG_ERR);
            throw new BuildException(message);
        }
        try {
            taskClass.getConstructor((Class[]) null);
            
            
        } catch (NoSuchMethodException e) {
            final String message = ""No public no-arg constructor in ""
                    + taskClass;
            project.log(message, Project.MSG_ERR);
            throw new BuildException(message);
        }
        if (!Task.class.isAssignableFrom(taskClass)) {
            TaskAdapter.checkTaskClass(taskClass, project);
        }
    }

    
    public Hashtable getTaskDefinitions() {
        synchronized (taskClassDefinitions) {
            synchronized (antTypeTable) {
                if (rebuildTaskClassDefinitions) {
                    taskClassDefinitions.clear();
                    for (Iterator i = antTypeTable.keySet().iterator();
                         i.hasNext();) {
                        String name = (String) i.next();
                        Class clazz = antTypeTable.getExposedClass(name);
                        if (clazz == null) {
                            continue;
                        }
                        if (Task.class.isAssignableFrom(clazz)) {
                            taskClassDefinitions.put(
                                name, antTypeTable.getTypeClass(name));
                        }
                    }
                    rebuildTaskClassDefinitions = false;
                }
            }
        }
        return taskClassDefinitions;
    }


    
    public Hashtable getDataTypeDefinitions() {
        synchronized (typeClassDefinitions) {
            synchronized (antTypeTable) {
                if (rebuildTypeClassDefinitions) {
                    typeClassDefinitions.clear();
                    for (Iterator i = antTypeTable.keySet().iterator();
                         i.hasNext();) {
                        String name = (String) i.next();
                        Class clazz = antTypeTable.getExposedClass(name);
                        if (clazz == null) {
                            continue;
                        }
                        if (!(Task.class.isAssignableFrom(clazz))) {
                            typeClassDefinitions.put(
                                name, antTypeTable.getTypeClass(name));
                        }
                    }
                    rebuildTypeClassDefinitions = false;
                }
            }
        }
        return typeClassDefinitions;
    }

    
    public void addDataTypeDefinition(String typeName, Class typeClass) {
        AntTypeDefinition def = new AntTypeDefinition();
        def.setName(typeName);
        def.setClass(typeClass);
        updateDataTypeDefinition(def);
        project.log("" +User datatype: "" + typeName + ""     ""
                + typeClass.getName(), Project.MSG_DEBUG);
    }

    
    public void addDataTypeDefinition(AntTypeDefinition def) {
        updateDataTypeDefinition(def);
    }

    
    public Hashtable getAntTypeTable() {
        return antTypeTable;
    }

    
    public Task createTask(String taskType) throws BuildException {
        Task task = createNewTask(taskType);
        if (task == null && taskType.equals(ANT_PROPERTY_TASK)) {
            
            
            addTaskDefinition(ANT_PROPERTY_TASK,
                              org.apache.tools.ant.taskdefs.Property.class);
            task = createNewTask(taskType);
        }
        return task;
    }

    
    private Task createNewTask(String taskType) throws BuildException {
        Class c = getComponentClass(taskType);
        if (c == null || !(Task.class.isAssignableFrom(c))) {
            return null;
        }
        Object obj = createComponent(taskType);
        if (obj == null) {
            return null;
        }
        if (!(obj instanceof Task)) {
            throw new BuildException(
                ""Expected a Task from '"" + taskType
                + ""' but got an instance of "" + obj.getClass().getName()
                + "" instead"");
        }
        Task task = (Task) obj;
        task.setTaskType(taskType);

        
        task.setTaskName(taskType);

        project.log(""   +Task: "" + taskType, Project.MSG_DEBUG);
        return task;
    }

    
    public Object createDataType(String typeName) throws BuildException {
        return createComponent(typeName);
    }

    
    public String getElementName(Object element) {
        return getElementName(element, false);
    }

    
    public String getElementName(Object o, boolean brief) {
        
        
        
        Class elementClass = o.getClass();
        String elementClassname = elementClass.getName();
        for (Iterator i = antTypeTable.values().iterator(); i.hasNext();) {
            AntTypeDefinition def = (AntTypeDefinition) i.next();
            if (elementClassname.equals(def.getClassName())
                    && (elementClass == def.getExposedClass(project))) {
                String name = def.getName();
                return brief ? name : ""The <"" + name + ""> type"";
            }
        }
        return getUnmappedElementName(o.getClass(), brief);
    }

    
    public static String getElementName(Project p, Object o, boolean brief) {
        if (p == null) {
            p = getProject(o);
        }
        return p == null ? getUnmappedElementName(o.getClass(), brief)
                : getComponentHelper(p).getElementName(o, brief);
    }

    private static String getUnmappedElementName(Class c, boolean brief) {
        if (brief) {
            String name = c.getName();
            return name.substring(name.lastIndexOf('.') + 1);
        }
        return c.toString();
    }

    private static Project getProject(Object o) {
        if (o instanceof ProjectComponent) {
            return ((ProjectComponent) o).getProject();
        }
        try {
            Method m = o.getClass().getMethod(""getProject"", (Class[]) null);
            if (Project.class == m.getReturnType()) {
                return (Project) m.invoke(o, (Object[]) null);
            }
        } catch (Exception e) {
            
        }
        return null;
    }

    
    private boolean validDefinition(AntTypeDefinition def) {
        return !(def.getTypeClass(project) == null
            || def.getExposedClass(project) == null);
    }

    
    private boolean sameDefinition(
        AntTypeDefinition def, AntTypeDefinition old) {
        boolean defValid = validDefinition(def);
        boolean sameValidity = (defValid == validDefinition(old));
        
        return sameValidity && (!defValid || def.sameDefinition(old, project));
    }

    
    private void updateDataTypeDefinition(AntTypeDefinition def) {
        String name = def.getName();
        synchronized (antTypeTable) {
            rebuildTaskClassDefinitions = true;
            rebuildTypeClassDefinitions = true;
            AntTypeDefinition old = antTypeTable.getDefinition(name);
            if (old != null) {
                if (sameDefinition(def, old)) {
                    return;
                }
                Class oldClass = antTypeTable.getExposedClass(name);
                boolean isTask =
                    (oldClass != null && Task.class.isAssignableFrom(oldClass));
                project.log(""Trying to override old definition of ""
                    + (isTask ? ""task "" : ""datatype "") + name,
                    (def.similarDefinition(old, project))
                    ? Project.MSG_VERBOSE : Project.MSG_WARN);
            }
            project.log("" +Datatype "" + name + "" "" + def.getClassName(),
                        Project.MSG_DEBUG);
            antTypeTable.put(name, def);
        }
    }

    
    public void enterAntLib(String uri) {
        antLibCurrentUri = uri;
        antLibStack.push(uri);
    }

    
    public String getCurrentAntlibUri() {
        return antLibCurrentUri;
    }

    
    public void exitAntLib() {
        antLibStack.pop();
        antLibCurrentUri = (antLibStack.size() == 0)
            ? null : (String) antLibStack.peek();
    }

    
    private void initTasks() {
        ClassLoader classLoader = getClassLoader(null);
        Properties props = getDefaultDefinitions(false);
        Enumeration e = props.propertyNames();
        while (e.hasMoreElements()) {
            String name = (String) e.nextElement();
            String className = props.getProperty(name);
            AntTypeDefinition def = new AntTypeDefinition();
            def.setName(name);
            def.setClassName(className);
            def.setClassLoader(classLoader);
            def.setAdaptToClass(Task.class);
            def.setAdapterClass(TaskAdapter.class);
            antTypeTable.put(name, def);
        }
    }

    private ClassLoader getClassLoader(ClassLoader classLoader) {
        String buildSysclasspath = project.getProperty(MagicNames.BUILD_SYSCLASSPATH);
        if (project.getCoreLoader() != null
            && !(BUILD_SYSCLASSPATH_ONLY.equals(buildSysclasspath))) {
            classLoader = project.getCoreLoader();
        }
        return classLoader;
    }

    
    private static synchronized Properties getDefaultDefinitions(boolean type)
        throws BuildException {
        int idx = type ? 1 : 0;
        if (defaultDefinitions[idx] == null) {
            String resource = type
                ? MagicNames.TYPEDEFS_PROPERTIES_RESOURCE
                : MagicNames.TASKDEF_PROPERTIES_RESOURCE;
            String errorString = type
                ? ERROR_NO_TYPE_LIST_LOAD
                : ERROR_NO_TASK_LIST_LOAD;
            InputStream in = null;
            try {
                in = ComponentHelper.class.getResourceAsStream(
                    resource);
                if (in == null) {
                    throw new BuildException(errorString);
                }
                Properties p = new Properties();
                p.load(in);
                defaultDefinitions[idx] = p;
            } catch (IOException e) {
                throw new BuildException(errorString, e);
            } finally {
                FileUtils.close(in);
            }
        }
        return defaultDefinitions[idx];
    }

    
    private void initTypes() {
        ClassLoader classLoader = getClassLoader(null);
        Properties props = getDefaultDefinitions(true);
        Enumeration e = props.propertyNames();
        while (e.hasMoreElements()) {
            String name = (String) e.nextElement();
            String className = props.getProperty(name);
            AntTypeDefinition def = new AntTypeDefinition();
            def.setName(name);
            def.setClassName(className);
            def.setClassLoader(classLoader);
            antTypeTable.put(name, def);
        }
    }

    
    private synchronized void checkNamespace(String componentName) {
        String uri = ProjectHelper.extractUriFromComponentName(componentName);
        if ("""".equals(uri)) {
            uri = ProjectHelper.ANT_CORE_URI;
        }
        if (!uri.startsWith(ProjectHelper.ANTLIB_URI)) {
            return; 
        }
        if (checkedNamespaces.contains(uri)) {
            return; 
        }
        checkedNamespaces.add(uri);
        Typedef definer = new Typedef();
        definer.setProject(project);
        definer.init();
        definer.setURI(uri);
        
        definer.setTaskName(uri);
        
        
        definer.setResource(Definer.makeResourceFromURI(uri));
        
        definer.setOnError(new Typedef.OnError(Typedef.OnError.POLICY_IGNORE));
        definer.execute();
    }

    
    public String diagnoseCreationFailure(String componentName, String type) {
        StringWriter errorText = new StringWriter();
        PrintWriter out = new PrintWriter(errorText);
        out.println(""Problem: failed to create "" + type + "" "" + componentName);
        
        boolean lowlevel = false;
        boolean jars = false;
        boolean definitions = false;
        boolean antTask;
        String home = System.getProperty(Launcher.USER_HOMEDIR);
        File libDir = new File(home, Launcher.USER_LIBDIR);
        String antHomeLib;
        boolean probablyIDE = false;
        String anthome = System.getProperty(MagicNames.ANT_HOME);
        if (anthome != null) {
            File antHomeLibDir = new File(anthome, ""lib"");
            antHomeLib = antHomeLibDir.getAbsolutePath();
        } else {
            
            probablyIDE = true;
            antHomeLib = ""ANT_HOME"" + File.separatorChar + ""lib"";
        }
        StringBuffer dirListingText = new StringBuffer();
        final String tab = ""        -"";
        dirListingText.append(tab);
        dirListingText.append(antHomeLib);
        dirListingText.append('\n');
        if (probablyIDE) {
            dirListingText.append(tab);
            dirListingText.append(""the IDE Ant configuration dialogs"");
        } else {
            dirListingText.append(tab);
            dirListingText.append(libDir);
            dirListingText.append('\n');
            dirListingText.append(tab);
            dirListingText.append(
                    ""a directory added on the command line with the -lib argument"");
        }

        String dirListing = dirListingText.toString();

        
        AntTypeDefinition def = getDefinition(componentName);
        if (def == null) {
            
            boolean isAntlib = componentName.indexOf(MagicNames.ANTLIB_PREFIX) == 0;
            out.println(""Cause: The name is undefined."");
            out.println(""Action: Check the spelling."");
            out.println(""Action: Check that any custom tasks/types have been declared."");
            out.println(""Action: Check that any <presetdef>/<macrodef>""
                        + "" declarations have taken place."");
            if (isAntlib) {
                out.println();
                out.println(""This appears to be an antlib declaration. "");
                out.println(""Action: Check that the implementing library exists in one of:"");
                out.println(dirListing);
            }
            definitions = true;
        } else {
            
            final String classname = def.getClassName();
            antTask = classname.startsWith(""org.apache.tools.ant."");
            boolean optional = classname.startsWith(""org.apache.tools.ant.taskdefs.optional"");
            optional |= classname.startsWith(""org.apache.tools.ant.types.optional"");

            
            Class clazz = null;
            try {
                clazz = def.innerGetTypeClass();
            } catch (ClassNotFoundException e) {
                out.println(""Cause: the class "" + classname + "" was not found."");
                jars = true;
                if (optional) {
                    out.println(""        This looks like one of Ant's optional components."");
                    out.println(""Action: Check that the appropriate optional JAR exists in"");
                    out.println(dirListing);
                } else {
                    out.println(""Action: Check that the component has been correctly declared"");
                    out.println(""        and that the implementing JAR is in one of:"");
                    out.println(dirListing);
                    definitions = true;
                }
            } catch (NoClassDefFoundError ncdfe) {
                jars = true;
                out.println(""Cause: Could not load a dependent class ""
                        +  ncdfe.getMessage());
                if (optional) {
                    out.println(""       It is not enough to have Ant's optional JARs"");
                    out.println(""       you need the JAR files that the""
                                + "" optional tasks depend upon."");
                    out.println(""       Ant's optional task dependencies are""
                                + "" listed in the manual."");
                } else {
                    out.println(""       This class may be in a separate JAR""
                                + "" that is not installed."");
                }
                out.println(""Action: Determine what extra JAR files are""
                            + "" needed, and place them in one of:"");
                out.println(dirListing);
            }
            
            if (clazz != null) {
                
                try {
                    def.innerCreateAndSet(clazz, project);
                    
                    out.println(""The component could be instantiated."");
                } catch (NoSuchMethodException e) {
                    lowlevel = true;
                    out.println(""Cause: The class "" + classname
                            + "" has no compatible constructor."");

                } catch (InstantiationException e) {
                    lowlevel = true;
                    out.println(""Cause: The class "" + classname
                            + "" is abstract and cannot be instantiated."");
                } catch (IllegalAccessException e) {
                    lowlevel = true;
                    out.println(""Cause: The constructor for "" + classname
                            + "" is private and cannot be invoked."");
                } catch (InvocationTargetException ex) {
                    lowlevel = true;
                    Throwable t = ex.getTargetException();
                    out.println(""Cause: The constructor threw the exception"");
                    out.println(t.toString());
                    t.printStackTrace(out);
                }  catch (NoClassDefFoundError ncdfe) {
                    jars = true;
                    out.println(""Cause:  A class needed by class ""
                            + classname + "" cannot be found: "");
                    out.println(""       "" + ncdfe.getMessage());
                    out.println(""Action: Determine what extra JAR files are""
                                + "" needed, and place them in:"");
                    out.println(dirListing);
                }
            }
            out.println();
            out.println(""Do not panic, this is a common problem."");
            if (definitions) {
                out.println(""It may just be a typographical error in the build file ""
                        + ""or the task/type declaration."");
            }
            if (jars) {
                out.println(""The commonest cause is a missing JAR."");
            }
            if (lowlevel) {
                out.println(""This is quite a low level problem, which may need ""
                        + ""consultation with the author of the task."");
                if (antTask) {
                    out.println(""This may be the Ant team. Please file a ""
                            + ""defect or contact the developer team."");
                } else {
                    out.println(""This does not appear to be a task bundled with Ant."");
                    out.println(""Please take it up with the supplier of the third-party ""
                            + type + ""."");
                    out.println(""If you have written it yourself, you probably have a bug to fix."");
                }
            } else {
                out.println();
                out.println(""This is not a bug; it is a configuration problem"");
            }
        }
        out.flush();
        out.close();
        return errorText.toString();
    }

    
    private static class AntTypeTable extends Hashtable {
        private Project project;

        AntTypeTable(Project project) {
            this.project = project;
        }

        AntTypeDefinition getDefinition(String key) {
            return (AntTypeDefinition) (super.get(key));
        }

        public Object get(Object key) {
            return getTypeClass((String) key);
        }

        Object create(String name) {
            AntTypeDefinition def = getDefinition(name);
            return (def == null) ? null : def.create(project);
        }

        Class getTypeClass(String name) {
            AntTypeDefinition def = getDefinition(name);
            return (def == null) ? null : def.getTypeClass(project);
        }

        Class getExposedClass(String name) {
            AntTypeDefinition def = getDefinition(name);
            return (def == null) ? null : def.getExposedClass(project);
        }

        public boolean contains(Object clazz) {
            boolean found = false;
            if (clazz instanceof Class) {
                for (Iterator i = values().iterator(); i.hasNext() && !found;) {
                    found |= (((AntTypeDefinition) (i.next())).getExposedClass(
                        project) == clazz);
                }
            }
            return found;
        }

        public boolean containsValue(Object value) {
            return contains(value);
        }
    }

}
"
org.apache.tools.ant.RuntimeConfigurable,25,1,0,20,71,182,12,9,22,0.819444444,515,1.0,1,0.0,0.179166667,0,0,19.12,11,1.84,1,"

package org.apache.tools.ant;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Iterator;

import org.apache.tools.ant.util.CollectionUtils;
import org.xml.sax.AttributeList;
import org.xml.sax.helpers.AttributeListImpl;


public class RuntimeConfigurable implements Serializable {

    
    private static final Hashtable EMPTY_HASHTABLE = new Hashtable(0);

    
    private String elementTag = null;

    
    private List children = null;

    
    private transient Object wrappedObject = null;

    
    private transient IntrospectionHelper.Creator creator;

    
    private transient AttributeList attributes;

    
    private List attributeNames = null;

    
    private Map attributeMap = null;

    
    private StringBuffer characters = null;

    
    private boolean proxyConfigured = false;

    
    private String polyType = null;

    
    private String id = null;

    
    public RuntimeConfigurable(Object proxy, String elementTag) {
        setProxy(proxy);
        setElementTag(elementTag);
        
        if (proxy instanceof Task) {
            ((Task) proxy).setRuntimeConfigurableWrapper(this);
        }
    }

    
    public synchronized void setProxy(Object proxy) {
        wrappedObject = proxy;
        proxyConfigured = false;
    }

    
    synchronized void setCreator(IntrospectionHelper.Creator creator) {
        this.creator = creator;
    }

    
    public synchronized Object getProxy() {
        return wrappedObject;
    }

    
    public synchronized String getId() {
        return id;
    }

    
    public synchronized String getPolyType() {
        return polyType;
    }

    
    public synchronized void setPolyType(String polyType) {
        this.polyType = polyType;
    }

    
    public synchronized void setAttributes(AttributeList attributes) {
        this.attributes = new AttributeListImpl(attributes);
        for (int i = 0; i < attributes.getLength(); i++) {
            setAttribute(attributes.getName(i), attributes.getValue(i));
        }
    }

    
    public synchronized void setAttribute(String name, String value) {
        if (name.equalsIgnoreCase(ProjectHelper.ANT_TYPE)) {
            this.polyType = value;
        } else {
            if (attributeNames == null) {
                attributeNames = new ArrayList();
                attributeMap = new HashMap();
            }
            if (name.toLowerCase(Locale.US).equals(""refid"")) {
                attributeNames.add(0, name);
            } else {
                attributeNames.add(name);
            }
            attributeMap.put(name, value);
            if (name.equals(""id"")) {
                this.id = value;
            }
        }
    }

    
    public synchronized void removeAttribute(String name) {
        attributeNames.remove(name);
        attributeMap.remove(name);
    }

    
    public synchronized Hashtable getAttributeMap() {
        return (attributeMap == null)
            ? EMPTY_HASHTABLE : new Hashtable(attributeMap);
    }

    
    public synchronized AttributeList getAttributes() {
        return attributes;
    }

    
    public synchronized void addChild(RuntimeConfigurable child) {
        children = (children == null) ? new ArrayList() : children;
        children.add(child);
    }

    
    synchronized RuntimeConfigurable getChild(int index) {
        return (RuntimeConfigurable) children.get(index);
    }

    
    public synchronized Enumeration getChildren() {
        return (children == null) ? new CollectionUtils.EmptyEnumeration()
            : Collections.enumeration(children);
    }

    
    public synchronized void addText(String data) {
        if (data.length() == 0) {
            return;
        }
        characters = (characters == null)
            ? new StringBuffer(data) : characters.append(data);
    }

    
    public synchronized void addText(char[] buf, int start, int count) {
        if (count == 0) {
            return;
        }
        characters = ((characters == null)
            ? new StringBuffer(count) : characters).append(buf, start, count);
    }

    
    public synchronized StringBuffer getText() {
        return (characters == null) ? new StringBuffer(0) : characters;
    }

    
    public synchronized void setElementTag(String elementTag) {
        this.elementTag = elementTag;
    }

    
    public synchronized String getElementTag() {
        return elementTag;
    }

    
    public void maybeConfigure(Project p) throws BuildException {
        maybeConfigure(p, true);
    }

    
    public synchronized void maybeConfigure(Project p, boolean configureChildren)
        throws BuildException {

        if (proxyConfigured) {
            return;
        }

        
        Object target = (wrappedObject instanceof TypeAdapter)
            ? ((TypeAdapter) wrappedObject).getProxy() : wrappedObject;

        IntrospectionHelper ih =
            IntrospectionHelper.getHelper(p, target.getClass());

        if (attributeNames != null) {
            for (int i = 0; i < attributeNames.size(); i++) {
                String name = (String) attributeNames.get(i);
                String value = (String) attributeMap.get(name);

                
                value = p.replaceProperties(value);
                try {
                    ih.setAttribute(p, target, name, value);
                } catch (UnsupportedAttributeException be) {
                    
                    if (name.equals(""id"")) {
                        
                    } else  if (getElementTag() == null) {
                        throw be;
                    } else {
                        throw new BuildException(
                            getElementTag() +  "" doesn't support the \""""
                            + be.getAttribute() + ""\"" attribute"", be);
                    }
                } catch (BuildException be) {
                    if (name.equals(""id"")) {
                        
                        
                        
                    } else {
                        throw be;
                    }
                }
            }
        }

        if (characters != null) {
            ProjectHelper.addText(p, wrappedObject, characters.substring(0));
        }

        if (id != null) {
            p.addReference(id, wrappedObject);
        }
        proxyConfigured = true;
    }

    
    public void reconfigure(Project p) {
        proxyConfigured = false;
        maybeConfigure(p);
    }


    
    public void applyPreSet(RuntimeConfigurable r) {
        
        if (r.attributeMap != null) {
            for (Iterator i = r.attributeMap.keySet().iterator(); i.hasNext();) {
                String name = (String) i.next();
                if (attributeMap == null || attributeMap.get(name) == null) {
                    setAttribute(name, (String) r.attributeMap.get(name));
                }
            }
        }
        

        polyType = (polyType == null) ? r.polyType : polyType;

        
        if (r.children != null) {
            List newChildren = new ArrayList();
            newChildren.addAll(r.children);
            if (children != null) {
                newChildren.addAll(children);
            }
            children = newChildren;
        }

        
        if (r.characters != null) {
            if (characters == null
                || characters.toString().trim().length() == 0) {
                characters = new StringBuffer(r.characters.toString());
            }
        }
    }
}
"
org.apache.tools.mail.SmtpResponseReader,5,1,0,1,19,0,1,0,3,0.5,108,1.0,0,0.0,0.533333333,0,0,20.2,3,1.4,0,"

package org.apache.tools.mail;

import java.io.InputStream;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;


public class SmtpResponseReader {
    
    protected BufferedReader reader = null;
    
    private StringBuffer result = new StringBuffer();

    
    public SmtpResponseReader(InputStream in) {
        reader = new BufferedReader(new InputStreamReader(in));
    }

    
    public String getResponse() throws IOException {
        result.setLength(0);
        String line = reader.readLine();
        if (line != null && line.length() >= 3) {
            result.append(line.substring(0, 3));
            result.append("" "");
        }

        while (line != null) {
            append(line);
            if (!hasMoreLines(line)) {
                break;
            }
            line = reader.readLine();
        }
        return result.toString().trim();
    }

    
    public void close() throws IOException {
        reader.close();
    }

    
    protected boolean hasMoreLines(String line) {
        return line.length() > 3 && line.charAt(3) == '-';
    }

    
    private void append(String line) {
        if (line.length() > 4) {
            result.append(line.substring(4));
            result.append("" "");
        }
    }
}
"
org.apache.tools.ant.taskdefs.VerifyJar,4,4,0,9,36,0,0,9,3,0.866666667,179,0.6,1,0.952380952,0.5,0,0,42.5,6,2.0,1,"

package org.apache.tools.ant.taskdefs;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.filters.ChainableReader;
import org.apache.tools.ant.types.RedirectorElement;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.resources.FileResource;

import java.util.Iterator;
import java.io.File;
import java.io.Reader;
import java.io.IOException;



public class VerifyJar extends AbstractJarSignerTask {
    
    public static final String ERROR_NO_FILE = ""Not found :"";

    
    private static final String VERIFIED_TEXT = ""jar verified."";

    
    private boolean certificates = false;
    private BufferingOutputFilter outputCache = new BufferingOutputFilter();
    
    public static final String ERROR_NO_VERIFY = ""Failed to verify "";

    
    public void setCertificates(boolean certificates) {
        this.certificates = certificates;
    }

    
    public void execute() throws BuildException {
        
        final boolean hasJar = jar != null;

        if (!hasJar && !hasResources()) {
            throw new BuildException(ERROR_NO_SOURCE);
        }

        beginExecution();

        
        RedirectorElement redirector = getRedirector();
        redirector.setAlwaysLog(true);
        FilterChain outputFilterChain = redirector.createOutputFilterChain();
        outputFilterChain.add(outputCache);

        try {
            Path sources = createUnifiedSourcePath();
            Iterator iter = sources.iterator();
            while (iter.hasNext()) {
                FileResource fr = (FileResource) iter.next();
                verifyOneJar(fr.getFile());
            }

        } finally {
            endExecution();
        }

    }

    
    private void verifyOneJar(File jar) {
        if (!jar.exists()) {
            throw new BuildException(ERROR_NO_FILE + jar);
        }
        final ExecTask cmd = createJarSigner();

        setCommonOptions(cmd);
        bindToKeystore(cmd);

        
        addValue(cmd, ""-verify"");

        if (certificates) {
            addValue(cmd, ""-certs"");
        }

        
        addValue(cmd, jar.getPath());

        log(""Verifying JAR: "" + jar.getAbsolutePath());
        outputCache.clear();
        BuildException ex = null;
        try {
            cmd.execute();
        } catch (BuildException e) {
            ex = e;
        }
        String results = outputCache.toString();
        
        if (ex != null) {
            if (results.indexOf(""zip file closed"") >= 0) {
                log(""You are running "" + JARSIGNER_COMMAND + "" against a JVM with""
                    + "" a known bug that manifests as an IllegalStateException."",
                    Project.MSG_WARN);
            } else {
                throw ex;
            }
        }
        if (results.indexOf(VERIFIED_TEXT) < 0) {
            throw new BuildException(ERROR_NO_VERIFY + jar);
        }
    }

    
    private static class BufferingOutputFilter implements ChainableReader {

        private BufferingOutputFilterReader buffer;

        public Reader chain(Reader rdr) {
            buffer = new BufferingOutputFilterReader(rdr);
            return buffer;
        }

        public String toString() {
            return buffer.toString();
        }

        public void clear() {
            if (buffer != null) {
                buffer.clear();
            }
        }
    }

    
    private static class BufferingOutputFilterReader extends Reader {

        private Reader next;

        private StringBuffer buffer = new StringBuffer();

        public BufferingOutputFilterReader(Reader next) {
            this.next = next;
        }

        public int read(char[] cbuf, int off, int len) throws IOException {
            
            int result = next.read(cbuf, off, len);
            
            buffer.append(cbuf, off, len);
            
            return result;
        }

        public void close() throws IOException {
            next.close();
        }

        public String toString() {
            return buffer.toString();
        }

        public void clear() {
            buffer = new StringBuffer();
        }
    }
}
"
org.apache.tools.ant.taskdefs.optional.ssh.ScpToMessage,15,2,1,7,49,75,2,5,9,0.75,402,1.0,0,0.578947368,0.325925926,1,1,25.53333333,1,0.5333,1,"

package org.apache.tools.ant.taskdefs.optional.ssh;

import com.jcraft.jsch.Channel;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.JSchException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.Iterator;


public class ScpToMessage extends AbstractSshMessage {

    private static final int BUFFER_SIZE = 1024;

    private File localFile;
    private String remotePath;
    private List directoryList;

    
    public ScpToMessage(Session session) {
        super(session);
    }

    
    public ScpToMessage(boolean verbose, Session session) {
        super(verbose, session);
    }

    
    public ScpToMessage(boolean verbose,
                        Session session,
                        File aLocalFile,
                        String aRemotePath) {
        this(verbose, session, aRemotePath);

        this.localFile = aLocalFile;
    }

    
    public ScpToMessage(boolean verbose,
                        Session session,
                        List aDirectoryList,
                        String aRemotePath) {
        this(verbose, session, aRemotePath);

        this.directoryList = aDirectoryList;
    }

    
    private ScpToMessage(boolean verbose,
                         Session session,
                         String aRemotePath) {
        super(verbose, session);
        this.remotePath = aRemotePath;
    }

    
    public ScpToMessage(Session session,
                        File aLocalFile,
                        String aRemotePath) {
        this(false, session, aLocalFile, aRemotePath);
    }

    
    public ScpToMessage(Session session,
                         List aDirectoryList,
                         String aRemotePath) {
        this(false, session, aDirectoryList, aRemotePath);
    }

    
    public void execute() throws IOException, JSchException {
        if (directoryList != null) {
            doMultipleTransfer();
        }
        if (localFile != null) {
            doSingleTransfer();
        }
        log(""done.\n"");
    }

    private void doSingleTransfer() throws IOException, JSchException {
        String cmd = ""scp -t "" + remotePath;
        Channel channel = openExecChannel(cmd);
        try {

            OutputStream out = channel.getOutputStream();
            InputStream in = channel.getInputStream();

            channel.connect();

            waitForAck(in);
            sendFileToRemote(localFile, in, out);
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
        }
    }

    private void doMultipleTransfer() throws IOException, JSchException {
        Channel channel = openExecChannel(""scp -r -d -t "" + remotePath);
        try {
            OutputStream out = channel.getOutputStream();
            InputStream in = channel.getInputStream();

            channel.connect();

            waitForAck(in);
            for (Iterator i = directoryList.iterator(); i.hasNext();) {
                Directory current = (Directory) i.next();
                sendDirectory(current, in, out);
            }
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
        }
    }

    private void sendDirectory(Directory current,
                               InputStream in,
                               OutputStream out) throws IOException {
        for (Iterator fileIt = current.filesIterator(); fileIt.hasNext();) {
            sendFileToRemote((File) fileIt.next(), in, out);
        }
        for (Iterator dirIt = current.directoryIterator(); dirIt.hasNext();) {
            Directory dir = (Directory) dirIt.next();
            sendDirectoryToRemote(dir, in, out);
        }
    }

    private void sendDirectoryToRemote(Directory directory,
                                        InputStream in,
                                        OutputStream out) throws IOException {
        String command = ""D0755 0 "";
        command += directory.getDirectory().getName();
        command += ""\n"";

        out.write(command.getBytes());
        out.flush();

        waitForAck(in);
        sendDirectory(directory, in, out);
        out.write(""E\n"".getBytes());
        waitForAck(in);
    }

    private void sendFileToRemote(File localFile,
                                   InputStream in,
                                   OutputStream out) throws IOException {
        
        long filesize = localFile.length();
        String command = ""C0644 "" + filesize + "" "";
        command += localFile.getName();
        command += ""\n"";

        out.write(command.getBytes());
        out.flush();

        waitForAck(in);

        
        FileInputStream fis = new FileInputStream(localFile);
        byte[] buf = new byte[BUFFER_SIZE];
        long startTime = System.currentTimeMillis();
        long totalLength = 0;

        
        boolean trackProgress = getVerbose() && filesize > 102400;
        
        
        long initFilesize = filesize;
        int percentTransmitted = 0;

        try {
            if (this.getVerbose()) {
                log(""Sending: "" + localFile.getName() + "" : "" + localFile.length());
            }
            while (true) {
                int len = fis.read(buf, 0, buf.length);
                if (len <= 0) {
                    break;
                }
                out.write(buf, 0, len);
                totalLength += len;

                if (trackProgress) {
                    percentTransmitted = trackProgress(initFilesize,
                                                       totalLength,
                                                       percentTransmitted);
                }
            }
            out.flush();
            sendAck(out);
            waitForAck(in);
        } finally {
            if (this.getVerbose()) {
                long endTime = System.currentTimeMillis();
                logStats(startTime, endTime, totalLength);
            }
            fis.close();
        }
    }

    
    public File getLocalFile() {
        return localFile;
    }

    
    public String getRemotePath() {
        return remotePath;
    }
}
"
org.apache.tools.ant.taskdefs.optional.unix.Symlink,23,4,0,13,96,181,0,13,16,0.715909091,856,1.0,1,0.655737705,0.227272727,0,0,35.86956522,5,1.2609,5,"



package org.apache.tools.ant.taskdefs.optional.unix;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;

import java.util.Vector;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Hashtable;
import java.util.Properties;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.dispatch.DispatchTask;
import org.apache.tools.ant.dispatch.DispatchUtils;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.LogOutputStream;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.util.FileUtils;


public class Symlink extends DispatchTask {
    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    private String resource;
    private String link;
    private Vector fileSets = new Vector();
    private String linkFileName;
    private boolean overwrite;
    private boolean failonerror;
    private boolean executing = false;

    
    public void init() throws BuildException {
        super.init();
        setDefaults();
    }

    
    public synchronized void execute() throws BuildException {
        if (executing) {
            throw new BuildException(
                ""Infinite recursion detected in Symlink.execute()"");
        }
        try {
            executing = true;
            DispatchUtils.execute(this);
        } finally {
            executing = false;
        }
    }

    
    public void single() throws BuildException {
        try {
            if (resource == null) {
                handleError(""Must define the resource to symlink to!"");
                return;
            }
            if (link == null) {
                handleError(""Must define the link name for symlink!"");
                return;
            }
            doLink(resource, link);
        } finally {
            setDefaults();
        }
    }

    
    public void delete() throws BuildException {
        try {
            if (link == null) {
                handleError(""Must define the link name for symlink!"");
                return;
            }
            log(""Removing symlink: "" + link);
            deleteSymlink(link);
        } catch (FileNotFoundException fnfe) {
            handleError(fnfe.toString());
        } catch (IOException ioe) {
            handleError(ioe.toString());
        } finally {
            setDefaults();
        }
    }

    
    public void recreate() throws BuildException {
        try {
            if (fileSets.isEmpty()) {
                handleError(""File set identifying link file(s) ""
                            + ""required for action recreate"");
                return;
            }
            Properties links = loadLinks(fileSets);

            for (Iterator kitr = links.keySet().iterator(); kitr.hasNext();) {
                String lnk = (String) kitr.next();
                String res = links.getProperty(lnk);
                
                try {
                    File test = new File(lnk);
                    if (!FILE_UTILS.isSymbolicLink(null, lnk)) {
                        doLink(res, lnk);
                    } else if (!test.getCanonicalPath().equals(
                        new File(res).getCanonicalPath())) {
                        deleteSymlink(lnk);
                        doLink(res, lnk);
                    } 
                } catch (IOException ioe) {
                    handleError(""IO exception while creating link"");
                }
            }
        } finally {
            setDefaults();
        }
    }

    
    public void record() throws BuildException {
        try {
            if (fileSets.isEmpty()) {
                handleError(""Fileset identifying links to record required"");
                return;
            }
            if (linkFileName == null) {
                handleError(""Name of file to record links in required"");
                return;
            }
            
            Hashtable byDir = new Hashtable();

            
            for (Iterator litr = findLinks(fileSets).iterator();
                litr.hasNext();) {
                File thisLink = (File) litr.next();
                File parent = thisLink.getParentFile();
                Vector v = (Vector) byDir.get(parent);
                if (v == null) {
                    v = new Vector();
                    byDir.put(parent, v);
                }
                v.addElement(thisLink);
            }
            
            for (Iterator dirs = byDir.keySet().iterator(); dirs.hasNext();) {
                File dir = (File) dirs.next();
                Vector linksInDir = (Vector) byDir.get(dir);
                Properties linksToStore = new Properties();

                
                for (Iterator dlnk = linksInDir.iterator(); dlnk.hasNext();) {
                    File lnk = (File) dlnk.next();
                    try {
                        linksToStore.put(lnk.getName(), lnk.getCanonicalPath());
                    } catch (IOException ioe) {
                        handleError(""Couldn't get canonical name of parent link"");
                    }
                }
                writePropertyFile(linksToStore, dir);
            }
        } finally {
            setDefaults();
        }
    }

    
    private void setDefaults() {
        resource = null;
        link = null;
        linkFileName = null;
        failonerror = true;   
        overwrite = false;    
        setAction(""single"");      
        fileSets.clear();
    }

    
    public void setOverwrite(boolean owrite) {
        this.overwrite = owrite;
    }

    
    public void setFailOnError(boolean foe) {
        this.failonerror = foe;
    }

    
    public void setAction(String action) {
        super.setAction(action);
    }

    
    public void setLink(String lnk) {
        this.link = lnk;
    }

    
    public void setResource(String src) {
        this.resource = src;
    }

    
    public void setLinkfilename(String lf) {
        this.linkFileName = lf;
    }

    
    public void addFileset(FileSet set) {
        fileSets.addElement(set);
    }

    
    public static void deleteSymlink(String path)
        throws IOException, FileNotFoundException {
        deleteSymlink(new File(path));
    }

    
    public static void deleteSymlink(File linkfil)
        throws IOException, FileNotFoundException {
        if (!linkfil.exists()) {
            throw new FileNotFoundException(""No such symlink: "" + linkfil);
        }
        
        File canfil = linkfil.getCanonicalFile();

        
        File temp = FILE_UTILS.createTempFile(""symlink"", "".tmp"",
                                              canfil.getParentFile());
        try {
            try {
                FILE_UTILS.rename(canfil, temp);
            } catch (IOException e) {
                throw new IOException(
                    ""Couldn't rename resource when attempting to delete ""
                    + linkfil);
            }
            
            if (!linkfil.delete()) {
                throw new IOException(""Couldn't delete symlink: "" + linkfil
                    + "" (was it a real file? is this not a UNIX system?)"");
            }
        } finally {
            
            try {
                FILE_UTILS.rename(temp, canfil);
            } catch (IOException e) {
                throw new IOException(""Couldn't return resource "" + temp
                    + "" to its original name: "" + canfil.getAbsolutePath()
                    + ""\n THE RESOURCE'S NAME ON DISK HAS ""
                    + ""BEEN CHANGED BY THIS ERROR!\n"");
            }
        }
    }

    
    private void writePropertyFile(Properties properties, File dir)
        throws BuildException {
        BufferedOutputStream bos = null;
        try {
            bos = new BufferedOutputStream(
                new FileOutputStream(new File(dir, linkFileName)));
            properties.store(bos, ""Symlinks from "" + dir);
        } catch (IOException ioe) {
            throw new BuildException(ioe, getLocation());
        } finally {
            FileUtils.close(bos);
        }
    }

    
    private void handleError(String msg) {
        if (failonerror) {
            throw new BuildException(msg);
        }
        log(msg);
    }

    
    private void doLink(String res, String lnk) throws BuildException {
        File linkfil = new File(lnk);
        if (overwrite && linkfil.exists()) {
            try {
                deleteSymlink(linkfil);
            } catch (FileNotFoundException fnfe) {
                handleError(""Symlink disappeared before it was deleted: "" + lnk);
            } catch (IOException ioe) {
                handleError(""Unable to overwrite preexisting link: "" + lnk);
            }
        }
        String[] cmd = new String[] {""ln"", ""-s"", res, lnk};
        log(Commandline.toString(cmd));
        Execute.runCommand(this, cmd);
    }

    
    private HashSet findLinks(Vector v) {
        HashSet result = new HashSet();
        for (int i = 0; i < v.size(); i++) {
            FileSet fs = (FileSet) v.get(i);
            DirectoryScanner ds = fs.getDirectoryScanner(getProject());
            String[][] fnd = new String[][]
                {ds.getIncludedFiles(), ds.getIncludedDirectories()};
            File dir = fs.getDir(getProject());
            for (int j = 0; j < fnd.length; j++) {
                for (int k = 0; k < fnd[j].length; k++) {
                    try {
                        File f = new File(dir, fnd[j][k]);
                        File pf = f.getParentFile();
                        String name = f.getName();
                        if (FILE_UTILS.isSymbolicLink(pf, name)) {
                            result.add(new File(pf.getCanonicalFile(), name));
                        }
                    } catch (IOException e) {
                        handleError(""IOException: "" + fnd[j][k] + "" omitted"");
                    }
                }
            }
        }
        return result;
    }

    
    private Properties loadLinks(Vector v) {
        Properties finalList = new Properties();
        
        for (int i = 0; i < v.size(); i++) {
            FileSet fs = (FileSet) v.elementAt(i);
            DirectoryScanner ds = new DirectoryScanner();
            fs.setupDirectoryScanner(ds, getProject());
            ds.setFollowSymlinks(false);
            ds.scan();
            String[] incs = ds.getIncludedFiles();
            File dir = fs.getDir(getProject());

            
            for (int j = 0; j < incs.length; j++) {
                File inc = new File(dir, incs[j]);
                File pf = inc.getParentFile();
                Properties lnks = new Properties();
                try {
                    lnks.load(new BufferedInputStream(new FileInputStream(inc)));
                    pf = pf.getCanonicalFile();
                } catch (FileNotFoundException fnfe) {
                    handleError(""Unable to find "" + incs[j] + ""; skipping it."");
                    continue;
                } catch (IOException ioe) {
                    handleError(""Unable to open "" + incs[j]
                                + "" or its parent dir; skipping it."");
                    continue;
                }
                lnks.list(new PrintStream(
                    new LogOutputStream(this, Project.MSG_INFO)));
                
                
                
                
                for (Iterator kitr = lnks.keySet().iterator(); kitr.hasNext();) {
                    String key = (String) kitr.next();
                    finalList.put(new File(pf, key).getAbsolutePath(),
                        lnks.getProperty(key));
                }
            }
        }
        return finalList;
    }
}
"
org.apache.tools.ant.ProjectHelper,18,1,2,24,68,151,18,8,17,1.044117647,386,0.125,0,0.0,0.152777778,0,0,20.0,4,1.5,1,"

package org.apache.tools.ant;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Vector;
import org.apache.tools.ant.helper.ProjectHelper2;
import org.apache.tools.ant.util.LoaderUtils;
import org.xml.sax.AttributeList;


public class ProjectHelper {
    
    public static final String ANT_CORE_URI    = ""antlib:org.apache.tools.ant"";

    
    public static final String ANT_CURRENT_URI      = ""ant:current"";

    
    public static final String ANTLIB_URI     = ""antlib:"";

    
    public static final String ANT_TYPE = ""ant-type"";

    
    public static final String HELPER_PROPERTY =
        ""org.apache.tools.ant.ProjectHelper"";

    
    public static final String SERVICE_ID =
        ""META-INF/services/org.apache.tools.ant.ProjectHelper"";

    
    public static final String PROJECTHELPER_REFERENCE = ""ant.projectHelper"";

    
    public static void configureProject(Project project, File buildFile)
        throws BuildException {
        ProjectHelper helper = ProjectHelper.getProjectHelper();
        project.addReference(PROJECTHELPER_REFERENCE, helper);
        helper.parse(project, buildFile);
    }

    
    public ProjectHelper() {
    }

    
    
    

    
    
    
    
    
    

    private Vector importStack = new Vector();

    
    




    
    public Vector getImportStack() {
        return importStack;
    }


    
    
    public void parse(Project project, Object source) throws BuildException {
        throw new BuildException(""ProjectHelper.parse() must be implemented ""
            + ""in a helper plugin "" + this.getClass().getName());
    }


    
    public static ProjectHelper getProjectHelper()
        throws BuildException {
        
        
        ProjectHelper helper = null;

        
        String helperClass = System.getProperty(HELPER_PROPERTY);
        try {
            if (helperClass != null) {
                helper = newHelper(helperClass);
            }
        } catch (SecurityException e) {
            System.out.println(""Unable to load ProjectHelper class \""""
                + helperClass + "" specified in system property ""
                + HELPER_PROPERTY);
        }

        
        
        if (helper == null) {
            try {
                ClassLoader classLoader = LoaderUtils.getContextClassLoader();
                InputStream is = null;
                if (classLoader != null) {
                    is = classLoader.getResourceAsStream(SERVICE_ID);
                }
                if (is == null) {
                    is = ClassLoader.getSystemResourceAsStream(SERVICE_ID);
                }

                if (is != null) {
                    
                    
                    InputStreamReader isr;
                    try {
                        isr = new InputStreamReader(is, ""UTF-8"");
                    } catch (java.io.UnsupportedEncodingException e) {
                        isr = new InputStreamReader(is);
                    }
                    BufferedReader rd = new BufferedReader(isr);

                    String helperClassName = rd.readLine();
                    rd.close();

                    if (helperClassName != null
                        && !"""".equals(helperClassName)) {

                        helper = newHelper(helperClassName);
                    }
                }
            } catch (Exception ex) {
                System.out.println(""Unable to load ProjectHelper ""
                    + ""from service \"""" + SERVICE_ID);
            }
        }

        if (helper != null) {
            return helper;
        } else {
            return new ProjectHelper2();
        }
    }

    
    private static ProjectHelper newHelper(String helperClass)
        throws BuildException {
        ClassLoader classLoader = LoaderUtils.getContextClassLoader();
        try {
            Class clazz = null;
            if (classLoader != null) {
                try {
                    clazz = classLoader.loadClass(helperClass);
                } catch (ClassNotFoundException ex) {
                    
                }
            }
            if (clazz == null) {
                clazz = Class.forName(helperClass);
            }
            return ((ProjectHelper) clazz.newInstance());
        } catch (Exception e) {
            throw new BuildException(e);
        }
    }

    
    public static ClassLoader getContextClassLoader() {
        if (!LoaderUtils.isContextLoaderAvailable()) {
            return null;
        }

        return LoaderUtils.getContextClassLoader();
    }

    

    
    public static void configure(Object target, AttributeList attrs,
                                 Project project) throws BuildException {
        if (target instanceof TypeAdapter) {
            target = ((TypeAdapter) target).getProxy();
        }

        IntrospectionHelper ih =
            IntrospectionHelper.getHelper(project, target.getClass());

        for (int i = 0; i < attrs.getLength(); i++) {
            
            String value = replaceProperties(project, attrs.getValue(i),
                                             project.getProperties());
            try {
                ih.setAttribute(project, target,
                                attrs.getName(i).toLowerCase(Locale.US), value);

            } catch (BuildException be) {
                
                if (!attrs.getName(i).equals(""id"")) {
                    throw be;
                }
            }
        }
    }

    
    public static void addText(Project project, Object target, char[] buf,
        int start, int count) throws BuildException {
        addText(project, target, new String(buf, start, count));
    }

    
    public static void addText(Project project, Object target, String text)
        throws BuildException {

        if (text == null) {
            return;
        }

        if (target instanceof TypeAdapter) {
            target = ((TypeAdapter) target).getProxy();
        }

        IntrospectionHelper.getHelper(project, target.getClass()).addText(project,
            target, text);
    }

    
    public static void storeChild(Project project, Object parent,
         Object child, String tag) {
        IntrospectionHelper ih
            = IntrospectionHelper.getHelper(project, parent.getClass());
        ih.storeElement(project, parent, child, tag);
    }

    
     public static String replaceProperties(Project project, String value)
            throws BuildException {
        
         return project.replaceProperties(value);
     }

    
     public static String replaceProperties(Project project, String value,
         Hashtable keys) throws BuildException {
        PropertyHelper ph = PropertyHelper.getPropertyHelper(project);
        return ph.replaceProperties(null, value, keys);
    }

    
    public static void parsePropertyString(String value, Vector fragments,
                                           Vector propertyRefs)
        throws BuildException {
        PropertyHelper.parsePropertyStringDefault(value, fragments,
                propertyRefs);
    }
    
    public static String genComponentName(String uri, String name) {
        if (uri == null || uri.equals("""") || uri.equals(ANT_CORE_URI)) {
            return name;
        }
        return uri + "":"" + name;
    }

    
    public static String extractUriFromComponentName(String componentName) {
        if (componentName == null) {
            return """";
        }
        int index = componentName.lastIndexOf(':');
        if (index == -1) {
            return """";
        }
        return componentName.substring(0, index);
    }

    
    public static String extractNameFromComponentName(String componentName) {
        int index = componentName.lastIndexOf(':');
        if (index == -1) {
            return componentName;
        }
        return componentName.substring(index + 1);
    }

    
    public static BuildException addLocationToBuildException(
        BuildException ex, Location newLocation) {
        if (ex.getLocation() == null || ex.getMessage() == null) {
            return ex;
        }
        String errorMessage
            = ""The following error occurred while executing this line:""
            + System.getProperty(""line.separator"")
            + ex.getLocation().toString()
            + ex.getMessage();
        if (newLocation == null) {
            return new BuildException(errorMessage, ex);
        } else {
            return new BuildException(
                errorMessage, ex, newLocation);
        }
    }
}
"
org.apache.tools.ant.listener.Log4jListener,8,1,0,7,33,0,0,7,8,0.714285714,305,0.25,0,0.0,0.9375,0,0,36.625,5,3.0,1,"

package org.apache.tools.ant.listener;

import org.apache.log4j.Logger;
import org.apache.log4j.helpers.NullEnumeration;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Target;
import org.apache.tools.ant.Task;



public class Log4jListener implements BuildListener {

    
    private boolean initialized = false;

    
    public static final String LOG_ANT = ""org.apache.tools.ant"";

    
    public Log4jListener() {
        initialized = false;
        Logger log = Logger.getLogger(LOG_ANT);
        Logger rootLog = Logger.getRootLogger();
        if (!(rootLog.getAllAppenders() instanceof NullEnumeration)) {
            initialized = true;
        } else {
            log.error(""No log4j.properties in build area"");
        }
    }

    
    
    public void buildStarted(BuildEvent event) {
        if (initialized) {
            Logger log = Logger.getLogger(Project.class.getName());
            log.info(""Build started."");
        }
    }

    
    
    public void buildFinished(BuildEvent event) {
        if (initialized) {
            Logger log = Logger.getLogger(Project.class.getName());
            if (event.getException() == null) {
                log.info(""Build finished."");
            } else {
                log.error(""Build finished with error."", event.getException());
            }
        }
    }

    
    
    public void targetStarted(BuildEvent event) {
        if (initialized) {
            Logger log = Logger.getLogger(Target.class.getName());
            log.info(""Target \"""" + event.getTarget().getName() + ""\"" started."");
        }
    }

    
    
    public void targetFinished(BuildEvent event) {
        if (initialized) {
            String targetName = event.getTarget().getName();
            Logger cat = Logger.getLogger(Target.class.getName());
            if (event.getException() == null) {
                cat.info(""Target \"""" + targetName + ""\"" finished."");
            } else {
                cat.error(""Target \"""" + targetName
                    + ""\"" finished with error."", event.getException());
            }
        }
    }

    
    
    public void taskStarted(BuildEvent event) {
        if (initialized) {
            Task task = event.getTask();
            Logger log = Logger.getLogger(task.getClass().getName());
            log.info(""Task \"""" + task.getTaskName() + ""\"" started."");
        }
    }

    
    
    public void taskFinished(BuildEvent event) {
        if (initialized) {
            Task task = event.getTask();
            Logger log = Logger.getLogger(task.getClass().getName());
            if (event.getException() == null) {
                log.info(""Task \"""" + task.getTaskName() + ""\"" finished."");
            } else {
                log.error(""Task \"""" + task.getTaskName()
                    + ""\"" finished with error."", event.getException());
            }
        }
    }

    
    
    public void messageLogged(BuildEvent event) {
        if (initialized) {
            Object categoryObject = event.getTask();
            if (categoryObject == null) {
                categoryObject = event.getTarget();
                if (categoryObject == null) {
                    categoryObject = event.getProject();
                }
            }

            Logger log
                = Logger.getLogger(categoryObject.getClass().getName());
            switch (event.getPriority()) {
                case Project.MSG_ERR:
                    log.error(event.getMessage());
                    break;
                case Project.MSG_WARN:
                    log.warn(event.getMessage());
                    break;
                case Project.MSG_INFO:
                    log.info(event.getMessage());
                    break;
                case Project.MSG_VERBOSE:
                    log.debug(event.getMessage());
                    break;
                case Project.MSG_DEBUG:
                    log.debug(event.getMessage());
                    break;
                default:
                    log.error(event.getMessage());
                    break;
            }
        }
    }
}
"
org.apache.tools.ant.filters.FixCrLfFilter,18,5,0,14,44,77,2,12,16,0.713235294,331,1.0,3,0.636363636,0.240740741,2,8,16.94444444,6,1.4444,0,"
package org.apache.tools.ant.filters;

import java.io.IOException;
import java.io.Reader;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.EnumeratedAttribute;


public final class FixCrLfFilter extends BaseParamFilterReader implements ChainableReader {
    private static final char CTRLZ = '\u001A';

    private int tabLength = 8;

    private CrLf eol;

    private AddAsisRemove ctrlz;

    private AddAsisRemove tabs;

    private boolean javafiles = false;

    private boolean fixlast = true;

    private boolean initialized = false;

    
    public FixCrLfFilter() {
        super();
    }

    
    public FixCrLfFilter(final Reader in) throws IOException {
        super(in);
    }

    
    
    {
        tabs = AddAsisRemove.ASIS;
        if (Os.isFamily(""mac"") && !Os.isFamily(""unix"")) {
            ctrlz = AddAsisRemove.REMOVE;
            setEol(CrLf.MAC);
        } else if (Os.isFamily(""dos"")) {
            ctrlz = AddAsisRemove.ASIS;
            setEol(CrLf.DOS);
        } else {
            ctrlz = AddAsisRemove.REMOVE;
            setEol(CrLf.UNIX);
        }
    }

    
    public Reader chain(final Reader rdr) {
        try {
            FixCrLfFilter newFilter = new FixCrLfFilter(rdr);

            newFilter.setJavafiles(getJavafiles());
            newFilter.setEol(getEol());
            newFilter.setTab(getTab());
            newFilter.setTablength(getTablength());
            newFilter.setEof(getEof());
            newFilter.setFixlast(getFixlast());
            newFilter.initInternalFilters();

            return newFilter;
        } catch (IOException e) {
            throw new BuildException(e);
        }
    }

    
    public AddAsisRemove getEof() {
        
        
        return ctrlz.newInstance();
    }

    
    public CrLf getEol() {
        
        
        return eol.newInstance();
    }

    
    public boolean getFixlast() {
        return fixlast;
    }

    
    public boolean getJavafiles() {
        return javafiles;
    }

    
    public AddAsisRemove getTab() {
        
        
        return tabs.newInstance();
    }

    
    public int getTablength() {
        return tabLength;
    }

    private static String calculateEolString(CrLf eol) {
        
        if (eol == CrLf.ASIS) {
            return System.getProperty(""line.separator"");
        }
        if (eol == CrLf.CR || eol == CrLf.MAC) {
            return ""\r"";
        }
        if (eol == CrLf.CRLF || eol == CrLf.DOS) {
            return ""\r\n"";
        }
        
        return ""\n"";
    }

    
    private void initInternalFilters() {

        
        
        in = (ctrlz == AddAsisRemove.REMOVE) ? new RemoveEofFilter(in) : in;

        
        
        
        in = new NormalizeEolFilter(in, calculateEolString(eol), getFixlast());

        if (tabs != AddAsisRemove.ASIS) {
            
            
            if (getJavafiles()) {
                in = new MaskJavaTabLiteralsFilter(in);
            }
            
            in = (tabs == AddAsisRemove.ADD) ? (Reader) new AddTabFilter(in, getTablength())
                    : (Reader) new RemoveTabFilter(in, getTablength());
        }
        
        in = (ctrlz == AddAsisRemove.ADD) ? new AddEofFilter(in) : in;
        initialized = true;
    }

    
    public synchronized int read() throws IOException {
        if (!initialized) {
            initInternalFilters();
        }
        return in.read();
    }

    
    public void setEof(AddAsisRemove attr) {
        ctrlz = attr.resolve();
    }

    
    public void setEol(CrLf attr) {
        eol = attr.resolve();
    }

    
    public void setFixlast(boolean fixlast) {
        this.fixlast = fixlast;
    }

    
    public void setJavafiles(boolean javafiles) {
        this.javafiles = javafiles;
    }

    
    public void setTab(AddAsisRemove attr) {
        tabs = attr.resolve();
    }

    
    public void setTablength(int tabLength) throws IOException {
        if (tabLength < 2 || tabLength > 80) {
            throw new IOException(""tablength must be between 2 and 80"");
        }
        this.tabLength = tabLength;
    }

    
    private static class SimpleFilterReader extends Reader {
        private Reader in;

        private int[] preempt = new int[16];

        private int preemptIndex = 0;

        public SimpleFilterReader(Reader in) {
            this.in = in;
        }

        public void push(char c) {
            push((int) c);
        }

        public void push(int c) {
            try {
                preempt[preemptIndex++] = c;
            } catch (ArrayIndexOutOfBoundsException e) {
                int[] p2 = new int[preempt.length * 2];
                System.arraycopy(preempt, 0, p2, 0, preempt.length);
                preempt = p2;
                push(c);
            }
        }

        public void push(char[] cs, int start, int length) {
            for (int i = start + length - 1; i >= start;) {
                push(cs[i--]);
            }
        }

        public void push(char[] cs) {
            push(cs, 0, cs.length);
        }

        public void push(String s) {
            push(s.toCharArray());
        }

        
        public boolean editsBlocked() {
            return in instanceof SimpleFilterReader && ((SimpleFilterReader) in).editsBlocked();
        }

        public int read() throws java.io.IOException {
            return preemptIndex > 0 ? preempt[--preemptIndex] : in.read();
        }

        public void close() throws java.io.IOException {
            in.close();
        }

        public void reset() throws IOException {
            in.reset();
        }

        public boolean markSupported() {
            return in.markSupported();
        }

        public boolean ready() throws java.io.IOException {
            return in.ready();
        }

        public void mark(int i) throws java.io.IOException {
            in.mark(i);
        }

        public long skip(long i) throws java.io.IOException {
            return in.skip(i);
        }

        public int read(char[] buf) throws java.io.IOException {
            return read(buf, 0, buf.length);
        }

        public int read(char[] buf, int start, int length) throws java.io.IOException {
            int count = 0;
            int c = 0;

            while (length-- > 0 && (c = this.read()) != -1) {
                buf[start++] = (char) c;
                count++;
            }
            
            return (count == 0 && c == -1) ? -1 : count;
        }
    }

    private static class MaskJavaTabLiteralsFilter extends SimpleFilterReader {
        private boolean editsBlocked = false;

        private static final int JAVA = 1;

        private static final int IN_CHAR_CONST = 2;

        private static final int IN_STR_CONST = 3;

        private static final int IN_SINGLE_COMMENT = 4;

        private static final int IN_MULTI_COMMENT = 5;

        private static final int TRANS_TO_COMMENT = 6;

        private static final int TRANS_FROM_MULTI = 8;

        private int state;

        public MaskJavaTabLiteralsFilter(Reader in) {
            super(in);
            state = JAVA;
        }

        public boolean editsBlocked() {
            return editsBlocked || super.editsBlocked();
        }

        public int read() throws IOException {
            int thisChar = super.read();
            
            editsBlocked = (state == IN_CHAR_CONST || state == IN_STR_CONST);

            switch (state) {
            case JAVA:
                
                switch (thisChar) {
                case '\'':
                    state = IN_CHAR_CONST;
                    break;
                case '""':
                    state = IN_STR_CONST;
                    break;
                case '/':
                    state = TRANS_TO_COMMENT;
                    break;
                default:
                    
                }
                break;
            case IN_CHAR_CONST:
                switch (thisChar) {
                case '\'':
                    state = JAVA;
                    break;
                default:
                    
                }
                break;
            case IN_STR_CONST:
                switch (thisChar) {
                case '""':
                    state = JAVA;
                    break;
                default:
                    
                }
                break;
            case IN_SINGLE_COMMENT:
                
                switch (thisChar) {
                case '\n':
                case '\r': 
                    state = JAVA;
                    break;
                default:
                    
                }
                break;
            case IN_MULTI_COMMENT:
                
                switch (thisChar) {
                case '*':
                    state = TRANS_FROM_MULTI;
                    break;
                default:
                    
                }
                break;
            case TRANS_TO_COMMENT:
                
                switch (thisChar) {
                case '*':
                    state = IN_MULTI_COMMENT;
                    break;
                case '/':
                    state = IN_SINGLE_COMMENT;
                    break;
                case '\'':
                    state = IN_CHAR_CONST;
                    break;
                case '""':
                    state = IN_STR_CONST;
                    break;
                default:
                    state = JAVA;
                }
                break;
            case TRANS_FROM_MULTI:
                
                switch (thisChar) {
                case '/':
                    state = JAVA;
                    break;
                default:
                    
                }
                break;
            default:
                
            }
            return thisChar;
        }
    }

    private static class NormalizeEolFilter extends SimpleFilterReader {
        private boolean previousWasEOL;

        private boolean fixLast;

        private int normalizedEOL = 0;

        private char[] eol = null;

        public NormalizeEolFilter(Reader in, String eolString, boolean fixLast) {
            super(in);
            eol = eolString.toCharArray();
            this.fixLast = fixLast;
        }

        public int read() throws IOException {
            int thisChar = super.read();

            if (normalizedEOL == 0) {
                int numEOL = 0;
                boolean atEnd = false;
                switch (thisChar) {
                case CTRLZ:
                    int c = super.read();
                    if (c == -1) {
                        atEnd = true;
                        if (fixLast && !previousWasEOL) {
                            numEOL = 1;
                            push(thisChar);
                        }
                    } else {
                        push(c);
                    }
                    break;
                case -1:
                    atEnd = true;
                    if (fixLast && !previousWasEOL) {
                        numEOL = 1;
                    }
                    break;
                case '\n':
                    
                    numEOL = 1;
                    break;
                case '\r':
                    numEOL = 1;
                    int c1 = super.read();
                    int c2 = super.read();

                    if (c1 == '\r' && c2 == '\n') {
                        
                    } else if (c1 == '\r') {
                        
                        
                        numEOL = 2;
                        push(c2);
                    } else if (c1 == '\n') {
                        
                        push(c2);
                    } else {
                        
                        push(c2);
                        push(c1);
                    }
                default:
                    
                }
                if (numEOL > 0) {
                    while (numEOL-- > 0) {
                        push(eol);
                        normalizedEOL += eol.length;
                    }
                    previousWasEOL = true;
                    thisChar = read();
                } else if (!atEnd) {
                    previousWasEOL = false;
                }
            } else {
                normalizedEOL--;
            }
            return thisChar;
        }
    }

    private static class AddEofFilter extends SimpleFilterReader {
        private int lastChar = -1;

        public AddEofFilter(Reader in) {
            super(in);
        }

        public int read() throws IOException {
            int thisChar = super.read();

            
            if (thisChar == -1) {
                if (lastChar != CTRLZ) {
                    lastChar = CTRLZ;
                    return lastChar;
                }
            } else {
                lastChar = thisChar;
            }
            return thisChar;
        }
    }

    private static class RemoveEofFilter extends SimpleFilterReader {
        private int lookAhead = -1;

        public RemoveEofFilter(Reader in) {
            super(in);

            try {
                lookAhead = in.read();
            } catch (IOException e) {
                lookAhead = -1;
            }
        }

        public int read() throws IOException {
            int lookAhead2 = super.read();

            
            if (lookAhead2 == -1 && lookAhead == CTRLZ) {
                return -1;
            }
            
            int i = lookAhead;
            lookAhead = lookAhead2;
            return i;
        }
    }

    private static class AddTabFilter extends SimpleFilterReader {
        private int columnNumber = 0;

        private int tabLength = 0;

        public AddTabFilter(Reader in, int tabLength) {
            super(in);
            this.tabLength = tabLength;
        }

        public int read() throws IOException {
            int c = super.read();

            switch (c) {
            case '\r':
            case '\n':
                columnNumber = 0;
                break;
            case ' ':
                columnNumber++;
                if (!editsBlocked()) {
                    int colNextTab = ((columnNumber + tabLength - 1) / tabLength) * tabLength;
                    int countSpaces = 1;
                    int numTabs = 0;

                    scanWhitespace: while ((c = super.read()) != -1) {
                        switch (c) {
                        case ' ':
                            if (++columnNumber == colNextTab) {
                                numTabs++;
                                countSpaces = 0;
                                colNextTab += tabLength;
                            } else {
                                countSpaces++;
                            }
                            break;
                        case '\t':
                            columnNumber = colNextTab;
                            numTabs++;
                            countSpaces = 0;
                            colNextTab += tabLength;
                            break;
                        default:
                            push(c);
                            break scanWhitespace;
                        }
                    }
                    while (countSpaces-- > 0) {
                        push(' ');
                        columnNumber--;
                    }
                    while (numTabs-- > 0) {
                        push('\t');
                        columnNumber -= tabLength;
                    }
                    c = super.read();
                    switch (c) {
                    case ' ':
                        columnNumber++;
                        break;
                    case '\t':
                        columnNumber += tabLength;
                        break;
                    default:
                        
                    }
                }
                break;
            case '\t':
                columnNumber = ((columnNumber + tabLength - 1) / tabLength) * tabLength;
                break;
            default:
                columnNumber++;
            }
            return c;
        }
    }

    private static class RemoveTabFilter extends SimpleFilterReader {
        private int columnNumber = 0;

        private int tabLength = 0;

        public RemoveTabFilter(Reader in, int tabLength) {
            super(in);

            this.tabLength = tabLength;
        }

        public int read() throws IOException {
            int c = super.read();

            switch (c) {
            case '\r':
            case '\n':
                columnNumber = 0;
                break;
            case '\t':
                int width = tabLength - columnNumber % tabLength;

                if (!editsBlocked()) {
                    for (; width > 1; width--) {
                        push(' ');
                    }
                    c = ' ';
                }
                columnNumber += width;
                break;
            default:
                columnNumber++;
            }
            return c;
        }
    }

    
    public static class AddAsisRemove extends EnumeratedAttribute {
        private static final AddAsisRemove ASIS = newInstance(""asis"");

        private static final AddAsisRemove ADD = newInstance(""add"");

        private static final AddAsisRemove REMOVE = newInstance(""remove"");

        
        public String[] getValues() {
            return new String[] {""add"", ""asis"", ""remove""};
        }

        
        public boolean equals(Object other) {
            return other instanceof AddAsisRemove
                    && getIndex() == ((AddAsisRemove) other).getIndex();
        }

        
        public int hashCode() {
            return getIndex();
        }

        AddAsisRemove resolve() throws IllegalStateException {
            if (this.equals(ASIS)) {
                return ASIS;
            }
            if (this.equals(ADD)) {
                return ADD;
            }
            if (this.equals(REMOVE)) {
                return REMOVE;
            }
            throw new IllegalStateException(""No replacement for "" + this);
        }

        
        private AddAsisRemove newInstance() {
            return newInstance(getValue());
        }

        
        public static AddAsisRemove newInstance(String value) {
            AddAsisRemove a = new AddAsisRemove();
            a.setValue(value);
            return a;
        }
    }

    
    public static class CrLf extends EnumeratedAttribute {
        private static final CrLf ASIS = newInstance(""asis"");

        private static final CrLf CR = newInstance(""cr"");

        private static final CrLf CRLF = newInstance(""crlf"");

        private static final CrLf DOS = newInstance(""dos"");

        private static final CrLf LF = newInstance(""lf"");

        private static final CrLf MAC = newInstance(""mac"");

        private static final CrLf UNIX = newInstance(""unix"");

        
        
        public String[] getValues() {
            return new String[] {""asis"", ""cr"", ""lf"", ""crlf"", ""mac"", ""unix"", ""dos""};
        }

        
        public boolean equals(Object other) {
            return other instanceof CrLf && getIndex() == ((CrLf) other).getIndex();
        }

        
        public int hashCode() {
            return getIndex();
        }

        CrLf resolve() {
            if (this.equals(ASIS)) {
                return ASIS;
            }
            if (this.equals(CR) || this.equals(MAC)) {
                return CR;
            }
            if (this.equals(CRLF) || this.equals(DOS)) {
                return CRLF;
            }
            if (this.equals(LF) || this.equals(UNIX)) {
                return LF;
            }
            throw new IllegalStateException(""No replacement for "" + this);
        }

        
        private CrLf newInstance() {
            return newInstance(getValue());
        }

        
        public static CrLf newInstance(String value) {
            CrLf c = new CrLf();
            c.setValue(value);
            return c;
        }
    }
}
"
org.apache.tools.ant.taskdefs.AbstractJarSignerTask,24,3,2,14,65,222,2,12,13,0.937888199,348,0.928571429,3,0.616666667,0.238095238,0,0,12.91666667,4,1.5417,0,"

package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.RedirectorElement;
import org.apache.tools.ant.util.JavaEnvUtils;



public abstract class AbstractJarSignerTask extends Task {
    
    
    protected File jar;
    
    protected String alias;
    
    protected String keystore;
    
    protected String storepass;
    
    protected String storetype;
    
    protected String keypass;
    
    protected boolean verbose;
    
    protected String maxMemory;
    
    protected Vector filesets = new Vector();
    
    protected static final String JARSIGNER_COMMAND = ""jarsigner"";

    

    
    private RedirectorElement redirector;

    
    private Environment sysProperties = new Environment();

    
    public static final String ERROR_NO_SOURCE = ""jar must be set through jar attribute ""
            + ""or nested filesets"";

    
    private Path path = null;

    
    public void setMaxmemory(String max) {
        maxMemory = max;
    }

    
    public void setJar(final File jar) {
        this.jar = jar;
    }

    
    public void setAlias(final String alias) {
        this.alias = alias;
    }

    
    public void setKeystore(final String keystore) {
        this.keystore = keystore;
    }

    
    public void setStorepass(final String storepass) {
        this.storepass = storepass;
    }

    
    public void setStoretype(final String storetype) {
        this.storetype = storetype;
    }

    
    public void setKeypass(final String keypass) {
        this.keypass = keypass;
    }

    
    public void setVerbose(final boolean verbose) {
        this.verbose = verbose;
    }

    
    public void addFileset(final FileSet set) {
        filesets.addElement(set);
    }

    
    public void addSysproperty(Environment.Variable sysp) {
        sysProperties.addVariable(sysp);
    }

    
    public Path createPath() {
        if (path == null) {
            path = new Path(getProject());
        }
        return path.createPath();
    }

    
    protected void beginExecution() {

        redirector = createRedirector();
    }

    
    protected void endExecution() {
        redirector = null;
    }

    
    private RedirectorElement createRedirector() {
        RedirectorElement result = new RedirectorElement();
        if (storepass != null) {
            StringBuffer input = new StringBuffer(storepass).append('\n');
            if (keypass != null) {
                input.append(keypass).append('\n');
            }
            result.setInputString(input.toString());
            result.setLogInputString(false);
        }
        return result;
    }

    
    public RedirectorElement getRedirector() {
        return redirector;
    }

    
    protected void setCommonOptions(final ExecTask cmd) {
        if (maxMemory != null) {
            addValue(cmd, ""-J-Xmx"" + maxMemory);
        }

        if (verbose) {
            addValue(cmd, ""-verbose"");
        }

        
        Vector props = sysProperties.getVariablesVector();
        Enumeration e = props.elements();
        while (e.hasMoreElements()) {
            Environment.Variable variable = (Environment.Variable) e.nextElement();
            declareSysProperty(cmd, variable);
        }
    }

    
    protected void declareSysProperty(
        ExecTask cmd, Environment.Variable property) throws BuildException {
        addValue(cmd, ""-J-D"" + property.getContent());
    }


    
    protected void bindToKeystore(final ExecTask cmd) {
        if (null != keystore) {
            
            addValue(cmd, ""-keystore"");
            String loc;
            File keystoreFile = getProject().resolveFile(keystore);
            if (keystoreFile.exists()) {
                loc = keystoreFile.getPath();
            } else {
                
                loc = keystore;
            }
            addValue(cmd, loc);
        }
        if (null != storetype) {
            addValue(cmd, ""-storetype"");
            addValue(cmd, storetype);
        }
    }

    
    protected ExecTask createJarSigner() {
        final ExecTask cmd = new ExecTask(this);
        cmd.setExecutable(JavaEnvUtils.getJdkExecutable(JARSIGNER_COMMAND));
        cmd.setTaskType(JARSIGNER_COMMAND);
        cmd.setFailonerror(true);
        cmd.addConfiguredRedirector(redirector);
        return cmd;
    }

    
    protected Vector createUnifiedSources() {
        Vector sources = (Vector) filesets.clone();
        if (jar != null) {
            
            
            
            FileSet sourceJar = new FileSet();
            sourceJar.setProject(getProject());
            sourceJar.setFile(jar);
            sourceJar.setDir(jar.getParentFile());
            sources.add(sourceJar);
        }
        return sources;
    }

    
    protected Path createUnifiedSourcePath() {
        Path p = path == null ? new Path(getProject()) : (Path) path.clone();
        Vector s = createUnifiedSources();
        Enumeration e = s.elements();
        while (e.hasMoreElements()) {
            p.add((FileSet) e.nextElement());
        }
        return p;
    }

    
    protected boolean hasResources() {
        return path != null || filesets.size() > 0;
    }

    
    protected void addValue(final ExecTask cmd, String value) {
        cmd.createArg().setValue(value);
    }
}
"
org.apache.tools.ant.taskdefs.optional.ejb.JbossDeploymentTool,6,2,0,5,23,9,1,5,3,1.05,160,1.0,0,0.864864865,0.555555556,2,3,25.0,4,1.8333,0,"
package org.apache.tools.ant.taskdefs.optional.ejb;

import java.io.File;
import java.util.Hashtable;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;


public class JbossDeploymentTool extends GenericDeploymentTool {
    protected static final String JBOSS_DD = ""jboss.xml"";
    protected static final String JBOSS_CMP10D = ""jaws.xml"";
    protected static final String JBOSS_CMP20D = ""jbosscmp-jdbc.xml"";

    
    private String jarSuffix = "".jar"";

    
    public void setSuffix(String inString) {
        jarSuffix = inString;
    }

    
    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
        File jbossDD = new File(getConfig().descriptorDir, ddPrefix + JBOSS_DD);
        if (jbossDD.exists()) {
            ejbFiles.put(META_DIR + JBOSS_DD, jbossDD);
        } else {
            log(""Unable to locate jboss deployment descriptor. ""
                + ""It was expected to be in "" + jbossDD.getPath(),
                Project.MSG_WARN);
            return;
        }
        String descriptorFileName = JBOSS_CMP10D;
        if (EjbJar.CMPVersion.CMP2_0.equals(getParent().getCmpversion())) {
            descriptorFileName = JBOSS_CMP20D;
        }
        File jbossCMPD
            = new File(getConfig().descriptorDir, ddPrefix + descriptorFileName);

        if (jbossCMPD.exists()) {
            ejbFiles.put(META_DIR + descriptorFileName, jbossCMPD);
        } else {
            log(""Unable to locate jboss cmp descriptor. ""
                + ""It was expected to be in ""
                + jbossCMPD.getPath(), Project.MSG_VERBOSE);
            return;
        }
    }

    
    File getVendorOutputJarFile(String baseName) {
        if (getDestDir() == null && getParent().getDestdir() == null) {
            throw new BuildException(""DestDir not specified"");
        }
        if (getDestDir() == null) {
            return new File(getParent().getDestdir(), baseName + jarSuffix);
        } else {
            return new File(getDestDir(), baseName + jarSuffix);
        }
    }

    
    public void validateConfigured() throws BuildException {
    }

    private EjbJar getParent() {
        return (EjbJar) this.getTask();
    }
}
"
org.apache.tools.ant.taskdefs.ManifestClassPath,6,3,0,6,33,3,0,6,6,0.75,292,1.0,1,0.880952381,0.333333333,0,0,47.0,14,3.1667,2,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.UnsupportedEncodingException;

import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.launch.Locator;
import org.apache.tools.ant.util.FileUtils;


public class ManifestClassPath extends Task {

    
    private String name;

    
    private File dir;

    
    private int maxParentLevels = 2;

    
    private Path path;

    
    public void execute() {
        if (name == null) {
          throw new BuildException(""Missing 'property' attribute!"");
        }
        if (dir == null) {
          throw new BuildException(""Missing 'jarfile' attribute!"");
        }
        if (getProject().getProperty(name) != null) {
          throw new BuildException(""Property '"" + name + ""' already set!"");
        }
        if (path == null) {
            throw new BuildException(""Missing nested <classpath>!"");
        }

        
        final FileUtils fileUtils = FileUtils.getFileUtils();
        dir = fileUtils.normalize(dir.getAbsolutePath());

        
        
        File currDir = dir;
        String[] dirs = new String[maxParentLevels + 1];
        for (int i = 0; i < maxParentLevels + 1; ++i) {
            dirs[i] = currDir.getAbsolutePath() + File.separatorChar;
            currDir = currDir.getParentFile();
            if (currDir == null) {
                maxParentLevels = i + 1;
                break;
            }
        }

        String[] elements = path.list();
        StringBuffer buffer = new StringBuffer();
        StringBuffer element = new StringBuffer();
        for (int i = 0; i < elements.length; ++i) {
            
            File pathEntry = new File(elements[i]);
            pathEntry = fileUtils.normalize(pathEntry.getAbsolutePath());
            String fullPath = pathEntry.getAbsolutePath();

            
            
            String relPath = null;
            for (int j = 0; j <= maxParentLevels; ++j) {
                String dir = dirs[j];
                if (!fullPath.startsWith(dir)) {
                    continue;
                }

                
                
                element.setLength(0);
                for (int k = 0; k < j; ++k) {
                    element.append("".."");
                    element.append(File.separatorChar);
                }
                element.append(fullPath.substring(dir.length()));
                relPath = element.toString();
                break;
            }

            
            if (relPath == null) {
                throw new BuildException(
                    ""No suitable relative path from ""
                    + dir + "" to "" + fullPath);
            }

            
            
            
            if (File.separatorChar != '/') {
                relPath = relPath.replace(File.separatorChar, '/');
            }
            if (pathEntry.isDirectory()) {
                relPath = relPath + '/';
            }
            try {
                relPath = Locator.encodeURI(relPath);
            } catch (UnsupportedEncodingException exc) {
                throw new BuildException(exc);
            }
            buffer.append(relPath);
            buffer.append(' ');
        }

        
        getProject().setNewProperty(name, buffer.toString().trim());
    }

    
    public void setProperty(String name) {
        this.name = name;
    }

    
    public void setJarFile(File jarfile) {
        File parent = jarfile.getParentFile();
        if (!parent.isDirectory()) {
            throw new BuildException(""Jar's directory not found: "" + parent);
        }
        this.dir = parent;
    }

    
    public void setMaxParentLevels(int levels) {
        this.maxParentLevels = levels;
    }

    
    public void addClassPath(Path path) {
        this.path = path;
    }

}
"
org.apache.tools.ant.taskdefs.optional.perforce.P4Reopen,3,4,0,4,11,0,0,4,3,0.0,53,1.0,0,0.962264151,0.666666667,1,1,16.33333333,1,0.6667,0,"


package org.apache.tools.ant.taskdefs.optional.perforce;

import org.apache.tools.ant.BuildException;


public class P4Reopen extends P4Base {

    private String toChange = """";

    
    public void setToChange(String toChange) throws BuildException {
        if (toChange == null || toChange.equals("""")) {
            throw new BuildException(""P4Reopen: tochange cannot be null or empty"");
        }

        this.toChange = toChange;
    }

    
    public void execute() throws BuildException {
        if (P4View == null) {
            throw new BuildException(""No view specified to reopen"");
        }
        execP4Command(""-s reopen -c "" + toChange + "" "" + P4View, new SimpleP4OutputHandler(this));
    }
}
"
org.apache.tools.ant.taskdefs.Javadoc,92,3,0,34,261,3726,8,34,81,0.960245637,2704,0.970588235,11,0.291338583,0.11247576,2,2,28.02173913,15,1.5543,4,"
package org.apache.tools.ant.taskdefs;

import java.io.File;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Locale;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.MagicNames;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectComponent;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.DirSet;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.PatternSet;
import org.apache.tools.ant.types.Reference;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.util.JavaEnvUtils;


public class Javadoc extends Task {
    
    public class DocletParam {
        
        private String name;

        
        private String value;

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }

        
        public void setValue(String value) {
            this.value = value;
        }

        
        public String getValue() {
            return value;
        }
    }

    
    public static class ExtensionInfo extends ProjectComponent {
        
        private String name;

        
        private Path path;

        
        public void setName(String name) {
            this.name = name;
        }

        
        public String getName() {
            return name;
        }

        
        public void setPath(Path path) {
            if (this.path == null) {
                this.path = path;
            } else {
                this.path.append(path);
            }
        }

        
        public Path getPath() {
            return path;
        }

        
        public Path createPath() {
            if (path == null) {
                path = new Path(getProject());
            }
            return path.createPath();
        }

        
        public void setPathRef(Reference r) {
            createPath().setRefid(r);
        }
    }

    
    public class DocletInfo extends ExtensionInfo {

        
        private Vector params = new Vector();

        
        public DocletParam createParam() {
            DocletParam param = new DocletParam();
            params.addElement(param);

            return param;
        }

        
        public Enumeration getParams() {
            return params.elements();
        }
    }

    
    public static class PackageName {
        
        private String name;

        
        public void setName(String name) {
            this.name = name.trim();
        }

        
        public String getName() {
            return name;
        }

        
        public String toString() {
            return getName();
        }
    }

    
    public static class SourceFile {
        
        private File file;

        
        public SourceFile() {
            
        }

        
        public SourceFile(File file) {
            this.file = file;
        }

        
        public void setFile(File file) {
            this.file = file;
        }

        
        public File getFile() {
            return file;
        }
    }

    
    public static class Html {
        
        private StringBuffer text = new StringBuffer();

        
        public void addText(String t) {
            text.append(t);
        }

        
        public String getText() {
            return text.substring(0);
        }
    }

    
    public static class AccessType extends EnumeratedAttribute {
        
        public String[] getValues() {
            
            
            return new String[] {""protected"", ""public"", ""package"", ""private""};
        }
    }

    
    public class ResourceCollectionContainer {
        private ArrayList rcs = new ArrayList();
        
        public void add(ResourceCollection rc) {
            rcs.add(rc);
        }

        
        private Iterator iterator() {
            return rcs.iterator();
        }
    }

    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();

    
    private Commandline cmd = new Commandline();

    
    private void addArgIf(boolean b, String arg) {
        if (b) {
            cmd.createArgument().setValue(arg);
        }
    }

    
    private void addArgIfNotEmpty(String key, String value) {
        if (value != null && value.length() != 0) {
            cmd.createArgument().setValue(key);
            cmd.createArgument().setValue(value);
        } else {
            log(""Warning: Leaving out empty argument '"" + key + ""'"",
                Project.MSG_WARN);
        }
    }

    
    private boolean failOnError = false;
    private Path sourcePath = null;
    private File destDir = null;
    private Vector sourceFiles = new Vector();
    private Vector packageNames = new Vector();
    private Vector excludePackageNames = new Vector(1);
    private boolean author = true;
    private boolean version = true;
    private DocletInfo doclet = null;
    private Path classpath = null;
    private Path bootclasspath = null;
    private String group = null;
    private String packageList = null;
    private Vector links = new Vector();
    private Vector groups = new Vector();
    private Vector tags = new Vector();
    private boolean useDefaultExcludes = true;
    private Html doctitle = null;
    private Html header = null;
    private Html footer = null;
    private Html bottom = null;
    private boolean useExternalFile = false;
    private String source = null;
    private boolean linksource = false;
    private boolean breakiterator = false;
    private String noqualifier;
    private boolean includeNoSourcePackages = false;
    private boolean old = false;
    private String executable = null;

    private ResourceCollectionContainer nestedSourceFiles
        = new ResourceCollectionContainer();
    private Vector packageSets = new Vector();

    
    public void setUseExternalFile(boolean b) {
        useExternalFile = b;
    }

    
    public void setDefaultexcludes(boolean useDefaultExcludes) {
        this.useDefaultExcludes = useDefaultExcludes;
    }

    
    public void setMaxmemory(String max) {
        cmd.createArgument().setValue(""-J-Xmx"" + max);
    }

    
    public void setAdditionalparam(String add) {
        cmd.createArgument().setLine(add);
    }

    
    public Commandline.Argument createArg() {
        return cmd.createArgument();
    }

    
    public void setSourcepath(Path src) {
        if (sourcePath == null) {
            sourcePath = src;
        } else {
            sourcePath.append(src);
        }
    }

    
    public Path createSourcepath() {
        if (sourcePath == null) {
            sourcePath = new Path(getProject());
        }
        return sourcePath.createPath();
    }

    
    public void setSourcepathRef(Reference r) {
        createSourcepath().setRefid(r);
    }

    
    public void setDestdir(File dir) {
        destDir = dir;
        cmd.createArgument().setValue(""-d"");
        cmd.createArgument().setFile(destDir);
    }

    
    public void setSourcefiles(String src) {
        StringTokenizer tok = new StringTokenizer(src, "","");
        while (tok.hasMoreTokens()) {
            String f = tok.nextToken();
            SourceFile sf = new SourceFile();
            sf.setFile(getProject().resolveFile(f.trim()));
            addSource(sf);
        }
    }

    
    public void addSource(SourceFile sf) {
        sourceFiles.addElement(sf);
    }

    
    public void setPackagenames(String packages) {
        StringTokenizer tok = new StringTokenizer(packages, "","");
        while (tok.hasMoreTokens()) {
            String p = tok.nextToken();
            PackageName pn = new PackageName();
            pn.setName(p);
            addPackage(pn);
        }
    }

    
    public void addPackage(PackageName pn) {
        packageNames.addElement(pn);
    }

    
    public void setExcludePackageNames(String packages) {
        StringTokenizer tok = new StringTokenizer(packages, "","");
        while (tok.hasMoreTokens()) {
            String p = tok.nextToken();
            PackageName pn = new PackageName();
            pn.setName(p);
            addExcludePackage(pn);
        }
    }

    
    public void addExcludePackage(PackageName pn) {
        excludePackageNames.addElement(pn);
    }

    
    public void setOverview(File f) {
        cmd.createArgument().setValue(""-overview"");
        cmd.createArgument().setFile(f);
    }

    
    public void setPublic(boolean b) {
        addArgIf(b, ""-public"");
    }

    
    public void setProtected(boolean b) {
        addArgIf(b, ""-protected"");
    }

    
    public void setPackage(boolean b) {
        addArgIf(b, ""-package"");
    }

    
    public void setPrivate(boolean b) {
        addArgIf(b, ""-private"");
    }

    
    public void setAccess(AccessType at) {
        cmd.createArgument().setValue(""-"" + at.getValue());
    }

    
    public void setDoclet(String docletName) {
        if (doclet == null) {
            doclet = new DocletInfo();
            doclet.setProject(getProject());
        }
        doclet.setName(docletName);
    }

    
    public void setDocletPath(Path docletPath) {
        if (doclet == null) {
            doclet = new DocletInfo();
            doclet.setProject(getProject());
        }
        doclet.setPath(docletPath);
    }

    
    public void setDocletPathRef(Reference r) {
        if (doclet == null) {
            doclet = new DocletInfo();
            doclet.setProject(getProject());
        }
        doclet.createPath().setRefid(r);
    }

    
    public DocletInfo createDoclet() {
        if (doclet == null) {
            doclet = new DocletInfo();
        }
        return doclet;
    }

    
    public void addTaglet(ExtensionInfo tagletInfo) {
        tags.addElement(tagletInfo);
    }

    
    public void setOld(boolean b) {
        old = b;
    }

    
    public void setClasspath(Path path) {
        if (classpath == null) {
            classpath = path;
        } else {
            classpath.append(path);
        }
    }

    
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(getProject());
        }
        return classpath.createPath();
    }

    
    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

    
    public void setBootclasspath(Path path) {
        if (bootclasspath == null) {
            bootclasspath = path;
        } else {
            bootclasspath.append(path);
        }
    }

    
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(getProject());
        }
        return bootclasspath.createPath();
    }

    
    public void setBootClasspathRef(Reference r) {
        createBootclasspath().setRefid(r);
    }

    
    public void setExtdirs(String path) {
        cmd.createArgument().setValue(""-extdirs"");
        cmd.createArgument().setValue(path);
    }

    
    public void setExtdirs(Path path) {
        cmd.createArgument().setValue(""-extdirs"");
        cmd.createArgument().setPath(path);
    }

    
    public void setVerbose(boolean b) {
        addArgIf(b, ""-verbose"");
    }

    
    public void setLocale(String locale) {
        
        
        cmd.createArgument(true).setValue(locale);
        cmd.createArgument(true).setValue(""-locale"");
    }

    
    public void setEncoding(String enc) {
        cmd.createArgument().setValue(""-encoding"");
        cmd.createArgument().setValue(enc);
    }

    
    public void setVersion(boolean b) {
        this.version = b;
    }

    
    public void setUse(boolean b) {
        addArgIf(b, ""-use"");
    }


    
    public void setAuthor(boolean b) {
        author = b;
    }

    
    public void setSplitindex(boolean b) {
        addArgIf(b, ""-splitindex"");
    }

    
    public void setWindowtitle(String title) {
        addArgIfNotEmpty(""-windowtitle"", title);
    }

    
    public void setDoctitle(String doctitle) {
        Html h = new Html();
        h.addText(doctitle);
        addDoctitle(h);
    }

    
    public void addDoctitle(Html text) {
        doctitle = text;
    }

    
    public void setHeader(String header) {
        Html h = new Html();
        h.addText(header);
        addHeader(h);
    }

    
    public void addHeader(Html text) {
        header = text;
    }

    
    public void setFooter(String footer) {
        Html h = new Html();
        h.addText(footer);
        addFooter(h);
    }

    
    public void addFooter(Html text) {
        footer = text;
    }

    
    public void setBottom(String bottom) {
        Html h = new Html();
        h.addText(bottom);
        addBottom(h);
    }

    
    public void addBottom(Html text) {
        bottom = text;
    }

    
    public void setLinkoffline(String src) {
        LinkArgument le = createLink();
        le.setOffline(true);
        String linkOfflineError = ""The linkoffline attribute must include""
            + "" a URL and a package-list file location separated by a""
            + "" space"";
        if (src.trim().length() == 0) {
            throw new BuildException(linkOfflineError);
        }
        StringTokenizer tok = new StringTokenizer(src, "" "", false);
        le.setHref(tok.nextToken());

        if (!tok.hasMoreTokens()) {
            throw new BuildException(linkOfflineError);
        }
        le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
    }

    
    public void setGroup(String src) {
        group = src;
    }

    
    public void setLink(String src) {
        createLink().setHref(src);
    }

    
    public void setNodeprecated(boolean b) {
        addArgIf(b, ""-nodeprecated"");
    }

    
    public void setNodeprecatedlist(boolean b) {
        addArgIf(b, ""-nodeprecatedlist"");
    }

    
    public void setNotree(boolean b) {
        addArgIf(b, ""-notree"");
    }

    
    public void setNoindex(boolean b) {
        addArgIf(b, ""-noindex"");
    }

    
    public void setNohelp(boolean b) {
        addArgIf(b, ""-nohelp"");
    }

    
    public void setNonavbar(boolean b) {
        addArgIf(b, ""-nonavbar"");
    }

    
    public void setSerialwarn(boolean b) {
        addArgIf(b, ""-serialwarn"");
    }

    
    public void setStylesheetfile(File f) {
        cmd.createArgument().setValue(""-stylesheetfile"");
        cmd.createArgument().setFile(f);
    }

    
    public void setHelpfile(File f) {
        cmd.createArgument().setValue(""-helpfile"");
        cmd.createArgument().setFile(f);
    }

    
    public void setDocencoding(String enc) {
        cmd.createArgument().setValue(""-docencoding"");
        cmd.createArgument().setValue(enc);
    }

    
    public void setPackageList(String src) {
        packageList = src;
    }

    
    public LinkArgument createLink() {
        LinkArgument la = new LinkArgument();
        links.addElement(la);
        return la;
    }

    
    public class LinkArgument {
        private String href;
        private boolean offline = false;
        private File packagelistLoc;
        private boolean resolveLink = false;

        
        public LinkArgument() {
            
        }

        
        public void setHref(String hr) {
            href = hr;
        }

        
        public String getHref() {
            return href;
        }

        
        public void setPackagelistLoc(File src) {
            packagelistLoc = src;
        }

        
        public File getPackagelistLoc() {
            return packagelistLoc;
        }

        
        public void setOffline(boolean offline) {
            this.offline = offline;
        }

        
        public boolean isLinkOffline() {
            return offline;
        }

        
        public void setResolveLink(boolean resolve) {
            this.resolveLink = resolve;
        }

        
        public boolean shouldResolveLink() {
            return resolveLink;
        }

    }

    
    public TagArgument createTag() {
        TagArgument ta = new TagArgument();
        tags.addElement (ta);
        return ta;
    }

    
    static final String[] SCOPE_ELEMENTS = {
        ""overview"", ""packages"", ""types"", ""constructors"",
        ""methods"", ""fields""
    };

    
    public class TagArgument extends FileSet {
        
        private String name = null;
        
        private boolean enabled = true;
        
        private String scope = ""a"";

        
        public TagArgument () {
            
        }

        
        public void setName (String name) {
            this.name = name;
        }

        
        public void setScope (String verboseScope) throws BuildException {
            verboseScope = verboseScope.toLowerCase(Locale.US);

            boolean[] elements = new boolean[SCOPE_ELEMENTS.length];

            boolean gotAll = false;
            boolean gotNotAll = false;

            
            
            StringTokenizer tok = new StringTokenizer (verboseScope, "","");
            while (tok.hasMoreTokens()) {
                String next = tok.nextToken().trim();
                if (next.equals(""all"")) {
                    if (gotAll) {
                        getProject().log (""Repeated tag scope element: all"",
                                          Project.MSG_VERBOSE);
                    }
                    gotAll = true;
                } else {
                    int i;
                    for (i = 0; i < SCOPE_ELEMENTS.length; i++) {
                        if (next.equals (SCOPE_ELEMENTS[i])) {
                            break;
                        }
                    }
                    if (i == SCOPE_ELEMENTS.length) {
                        throw new BuildException (""Unrecognised scope element: ""
                                                  + next);
                    } else {
                        if (elements[i]) {
                            getProject().log (""Repeated tag scope element: ""
                                              + next, Project.MSG_VERBOSE);
                        }
                        elements[i] = true;
                        gotNotAll = true;
                    }
                }
            }

            if (gotNotAll && gotAll) {
                throw new BuildException (""Mixture of \""all\"" and other scope ""
                                          + ""elements in tag parameter."");
            }
            if (!gotNotAll && !gotAll) {
                throw new BuildException (""No scope elements specified in tag ""
                                          + ""parameter."");
            }
            if (gotAll) {
                this.scope = ""a"";
            } else {
                StringBuffer buff = new StringBuffer (elements.length);
                for (int i = 0; i < elements.length; i++) {
                    if (elements[i]) {
                        buff.append (SCOPE_ELEMENTS[i].charAt(0));
                    }
                }
                this.scope = buff.toString();
            }
        }

        
        public void setEnabled (boolean enabled) {
            this.enabled = enabled;
        }

        
        public String getParameter() throws BuildException {
            if (name == null || name.equals("""")) {
                throw new BuildException (""No name specified for custom tag."");
            }
            if (getDescription() != null) {
                return name + "":"" + (enabled ? """" : ""X"")
                    + scope + "":"" + getDescription();
            } else {
                return name + "":"" + (enabled ? """" : ""X"")
                    + scope + "":"" + name;
            }
        }
    }

    
    public GroupArgument createGroup() {
        GroupArgument ga = new GroupArgument();
        groups.addElement(ga);
        return ga;
    }


    
    public class GroupArgument {
        private Html title;
        private Vector packages = new Vector();

        
        public GroupArgument() {
            
        }

        
        public void setTitle(String src) {
            Html h = new Html();
            h.addText(src);
            addTitle(h);
        }
        
        public void addTitle(Html text) {
            title = text;
        }

        
        public String getTitle() {
            return title != null ? title.getText() : null;
        }

        
        public void setPackages(String src) {
            StringTokenizer tok = new StringTokenizer(src, "","");
            while (tok.hasMoreTokens()) {
                String p = tok.nextToken();
                PackageName pn = new PackageName();
                pn.setName(p);
                addPackage(pn);
            }
        }
        
        public void addPackage(PackageName pn) {
            packages.addElement(pn);
        }

        
        public String getPackages() {
            StringBuffer p = new StringBuffer();
            for (int i = 0; i < packages.size(); i++) {
                if (i > 0) {
                    p.append("":"");
                }
                p.append(packages.elementAt(i).toString());
            }
            return p.toString();
        }
    }

    
    public void setCharset(String src) {
        this.addArgIfNotEmpty(""-charset"", src);
    }

    
    public void setFailonerror(boolean b) {
        failOnError = b;
    }

    
    public void setSource(String source) {
        this.source = source;
    }

    
    public void setExecutable(String executable) {
        this.executable = executable;
    }

    
    public void addPackageset(DirSet packageSet) {
        packageSets.addElement(packageSet);
    }

    
    public void addFileset(FileSet fs) {
        createSourceFiles().add(fs);
    }

    
    public ResourceCollectionContainer createSourceFiles() {
        return nestedSourceFiles;
    }

    
    public void setLinksource(boolean b) {
        this.linksource = b;
    }

    
    public void setBreakiterator(boolean b) {
        this.breakiterator = b;
    }

    
    public void setNoqualifier(String noqualifier) {
        this.noqualifier = noqualifier;
    }

    
    public void setIncludeNoSourcePackages(boolean b) {
        this.includeNoSourcePackages = b;
    }

    
    public void execute() throws BuildException {
        if (""javadoc2"".equals(getTaskType())) {
            log(""Warning: the task name <javadoc2> is deprecated. Use <javadoc> instead."",
                Project.MSG_WARN);
        }

        
        boolean javadoc4 =
            !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2)
            && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3);
        boolean javadoc5 = javadoc4
            && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4);

        Vector packagesToDoc = new Vector();
        Path sourceDirs = new Path(getProject());

        if (packageList != null && sourcePath == null) {
            String msg = ""sourcePath attribute must be set when ""
                + ""specifying packagelist."";
            throw new BuildException(msg);
        }

        if (sourcePath != null) {
            sourceDirs.addExisting(sourcePath);
        }

        parsePackages(packagesToDoc, sourceDirs);

        if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
            String msg = ""sourcePath attribute must be set when ""
                + ""specifying package names."";
            throw new BuildException(msg);
        }

        Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
        addSourceFiles(sourceFilesToDoc);

        if (packageList == null && packagesToDoc.size() == 0
            && sourceFilesToDoc.size() == 0) {
            throw new BuildException(""No source files and no packages have ""
                                     + ""been specified."");
        }

        log(""Generating Javadoc"", Project.MSG_INFO);

        Commandline toExecute = (Commandline) cmd.clone();
        if (executable != null) {
            toExecute.setExecutable(executable);
        } else {
            toExecute.setExecutable(JavaEnvUtils.getJdkExecutable(""javadoc""));
        }

        
        if (doctitle != null) {
            toExecute.createArgument().setValue(""-doctitle"");
            toExecute.createArgument().setValue(expand(doctitle.getText()));
        }
        if (header != null) {
            toExecute.createArgument().setValue(""-header"");
            toExecute.createArgument().setValue(expand(header.getText()));
        }
        if (footer != null) {
            toExecute.createArgument().setValue(""-footer"");
            toExecute.createArgument().setValue(expand(footer.getText()));
        }
        if (bottom != null) {
            toExecute.createArgument().setValue(""-bottom"");
            toExecute.createArgument().setValue(expand(bottom.getText()));
        }

        if (classpath == null) {
            classpath = (new Path(getProject())).concatSystemClasspath(""last"");
        } else {
            classpath = classpath.concatSystemClasspath(""ignore"");
        }

        if (classpath.size() > 0) {
            toExecute.createArgument().setValue(""-classpath"");
            toExecute.createArgument().setPath(classpath);
        }
        if (sourceDirs.size() > 0) {
            toExecute.createArgument().setValue(""-sourcepath"");
            toExecute.createArgument().setPath(sourceDirs);
        }

        if (version && doclet == null) {
            toExecute.createArgument().setValue(""-version"");
        }
        if (author && doclet == null) {
            toExecute.createArgument().setValue(""-author"");
        }

        if (doclet == null && destDir == null) {
            throw new BuildException(""destdir attribute must be set!"");
        }

        

        if (doclet != null) {
            if (doclet.getName() == null) {
                throw new BuildException(""The doclet name must be ""
                                         + ""specified."", getLocation());
            } else {
                toExecute.createArgument().setValue(""-doclet"");
                toExecute.createArgument().setValue(doclet.getName());
                if (doclet.getPath() != null) {
                    Path docletPath
                        = doclet.getPath().concatSystemClasspath(""ignore"");
                    if (docletPath.size() != 0) {
                        toExecute.createArgument().setValue(""-docletpath"");
                        toExecute.createArgument().setPath(docletPath);
                    }
                }
                for (Enumeration e = doclet.getParams();
                     e.hasMoreElements();) {
                    DocletParam param = (DocletParam) e.nextElement();
                    if (param.getName() == null) {
                        throw new BuildException(""Doclet parameters must ""
                                                 + ""have a name"");
                    }

                    toExecute.createArgument().setValue(param.getName());
                    if (param.getValue() != null) {
                        toExecute.createArgument()
                            .setValue(param.getValue());
                    }
                }
            }
        }
        Path bcp = new Path(getProject());
        if (bootclasspath != null) {
            bcp.append(bootclasspath);
        }
        bcp = bcp.concatSystemBootClasspath(""ignore"");
        if (bcp.size() > 0) {
            toExecute.createArgument().setValue(""-bootclasspath"");
            toExecute.createArgument().setPath(bcp);
        }

        
        if (links.size() != 0) {
            for (Enumeration e = links.elements(); e.hasMoreElements();) {
                LinkArgument la = (LinkArgument) e.nextElement();

                if (la.getHref() == null || la.getHref().length() == 0) {
                    log(""No href was given for the link - skipping"",
                        Project.MSG_VERBOSE);
                    continue;
                }
                String link = null;
                if (la.shouldResolveLink()) {
                    File hrefAsFile =
                        getProject().resolveFile(la.getHref());
                    if (hrefAsFile.exists()) {
                        try {
                            link = FILE_UTILS.getFileURL(hrefAsFile)
                                .toExternalForm();
                        } catch (MalformedURLException ex) {
                            
                            log(""Warning: link location was invalid ""
                                + hrefAsFile, Project.MSG_WARN);
                        }
                    }
                }
                if (link == null) {
                    
                    try {
                        URL base = new URL(""file:
                        new URL(base, la.getHref());
                        link = la.getHref();
                    } catch (MalformedURLException mue) {
                        
                        log(""Link href \"""" + la.getHref()
                            + ""\"" is not a valid url - skipping link"",
                            Project.MSG_WARN);
                        continue;
                    }
                }

                if (la.isLinkOffline()) {
                    File packageListLocation = la.getPackagelistLoc();
                    if (packageListLocation == null) {
                        throw new BuildException(""The package list""
                                                 + "" location for link ""
                                                 + la.getHref()
                                                 + "" must be provided ""
                                                 + ""because the link is ""
                                                 + ""offline"");
                    }
                    File packageListFile =
                        new File(packageListLocation, ""package-list"");
                    if (packageListFile.exists()) {
                        try {
                            String packageListURL =
                                FILE_UTILS.getFileURL(packageListLocation)
                                .toExternalForm();
                            toExecute.createArgument()
                                .setValue(""-linkoffline"");
                            toExecute.createArgument()
                                .setValue(link);
                            toExecute.createArgument()
                                .setValue(packageListURL);
                        } catch (MalformedURLException ex) {
                            log(""Warning: Package list location was ""
                                + ""invalid "" + packageListLocation,
                                Project.MSG_WARN);
                        }
                    } else {
                        log(""Warning: No package list was found at ""
                            + packageListLocation, Project.MSG_VERBOSE);
                    }
                } else {
                    toExecute.createArgument().setValue(""-link"");
                    toExecute.createArgument().setValue(link);
                }
            }
        }

        
        
        
        
        
        

        
        
        
        
        
        if (group != null) {
            StringTokenizer tok = new StringTokenizer(group, "","", false);
            while (tok.hasMoreTokens()) {
                String grp = tok.nextToken().trim();
                int space = grp.indexOf("" "");
                if (space > 0) {
                    String name = grp.substring(0, space);
                    String pkgList = grp.substring(space + 1);
                    toExecute.createArgument().setValue(""-group"");
                    toExecute.createArgument().setValue(name);
                    toExecute.createArgument().setValue(pkgList);
                }
            }
        }

        
        if (groups.size() != 0) {
            for (Enumeration e = groups.elements(); e.hasMoreElements();) {
                GroupArgument ga = (GroupArgument) e.nextElement();
                String title = ga.getTitle();
                String packages = ga.getPackages();
                if (title == null || packages == null) {
                    throw new BuildException(""The title and packages must ""
                                             + ""be specified for group ""
                                             + ""elements."");
                }
                toExecute.createArgument().setValue(""-group"");
                toExecute.createArgument().setValue(expand(title));
                toExecute.createArgument().setValue(packages);
            }
        }

        
        if (javadoc4 || executable != null) {
            for (Enumeration e = tags.elements(); e.hasMoreElements();) {
                Object element = e.nextElement();
                if (element instanceof TagArgument) {
                    TagArgument ta = (TagArgument) element;
                    File tagDir = ta.getDir(getProject());
                    if (tagDir == null) {
                        
                        
                        toExecute.createArgument().setValue (""-tag"");
                        toExecute.createArgument()
                            .setValue (ta.getParameter());
                    } else {
                        
                        
                        
                        DirectoryScanner tagDefScanner =
                            ta.getDirectoryScanner(getProject());
                        String[] files = tagDefScanner.getIncludedFiles();
                        for (int i = 0; i < files.length; i++) {
                            File tagDefFile = new File(tagDir, files[i]);
                            try {
                                BufferedReader in
                                    = new BufferedReader(
                                          new FileReader(tagDefFile)
                                          );
                                String line = null;
                                while ((line = in.readLine()) != null) {
                                    toExecute.createArgument()
                                        .setValue(""-tag"");
                                    toExecute.createArgument()
                                        .setValue(line);
                                }
                                in.close();
                            } catch (IOException ioe) {
                                throw new BuildException(""Couldn't read ""
                                    + "" tag file from ""
                                    + tagDefFile.getAbsolutePath(), ioe);
                            }
                        }
                    }
                } else {
                    ExtensionInfo tagletInfo = (ExtensionInfo) element;
                    toExecute.createArgument().setValue(""-taglet"");
                    toExecute.createArgument().setValue(tagletInfo
                                                        .getName());
                    if (tagletInfo.getPath() != null) {
                        Path tagletPath = tagletInfo.getPath()
                            .concatSystemClasspath(""ignore"");
                        if (tagletPath.size() != 0) {
                            toExecute.createArgument()
                                .setValue(""-tagletpath"");
                            toExecute.createArgument().setPath(tagletPath);
                        }
                    }
                }
            }

            String sourceArg = source != null ? source
                : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
            if (sourceArg != null) {
                toExecute.createArgument().setValue(""-source"");
                toExecute.createArgument().setValue(sourceArg);
            }

            if (linksource && doclet == null) {
                toExecute.createArgument().setValue(""-linksource"");
            }
            if (breakiterator && (doclet == null || javadoc5)) {
                toExecute.createArgument().setValue(""-breakiterator"");
            }
            if (noqualifier != null && doclet == null) {
                toExecute.createArgument().setValue(""-noqualifier"");
                toExecute.createArgument().setValue(noqualifier);
            }
        } else {
            
            if (!tags.isEmpty()) {
                log(""-tag and -taglet options not supported on Javadoc < 1.4"",
                     Project.MSG_VERBOSE);
            }
            if (source != null) {
                log(""-source option not supported on Javadoc < 1.4"",
                     Project.MSG_VERBOSE);
            }
            if (linksource) {
                log(""-linksource option not supported on Javadoc < 1.4"",
                     Project.MSG_VERBOSE);
            }
            if (breakiterator) {
                log(""-breakiterator option not supported on Javadoc < 1.4"",
                     Project.MSG_VERBOSE);
            }
            if (noqualifier != null) {
                log(""-noqualifier option not supported on Javadoc < 1.4"",
                     Project.MSG_VERBOSE);
            }
        }
        
        if (!javadoc4 || executable != null) {
            if (old) {
                toExecute.createArgument().setValue(""-1.1"");
            }
        } else {
            if (old) {
                log(""Javadoc 1.4 doesn't support the -1.1 switch anymore"",
                    Project.MSG_WARN);
            }
        }
        
        if (useExternalFile && javadoc4) {
            writeExternalArgs(toExecute);
        }

        File tmpList = null;
        PrintWriter srcListWriter = null;

        try {

            
            if (useExternalFile) {
                if (tmpList == null) {
                    tmpList = FILE_UTILS.createTempFile(""javadoc"", """", null);
                    tmpList.deleteOnExit();
                    toExecute.createArgument()
                        .setValue(""@"" + tmpList.getAbsolutePath());
                }
                srcListWriter = new PrintWriter(
                                    new FileWriter(tmpList.getAbsolutePath(),
                                                   true));
            }

            Enumeration e = packagesToDoc.elements();
            while (e.hasMoreElements()) {
                String packageName = (String) e.nextElement();
                if (useExternalFile) {
                    srcListWriter.println(packageName);
                } else {
                    toExecute.createArgument().setValue(packageName);
                }
            }

            e = sourceFilesToDoc.elements();
            while (e.hasMoreElements()) {
                SourceFile sf = (SourceFile) e.nextElement();
                String sourceFileName = sf.getFile().getAbsolutePath();
                if (useExternalFile) {
                    
                    
                    if (javadoc4 && sourceFileName.indexOf("" "") > -1) {
                        String name = sourceFileName;
                        if (File.separatorChar == '\\') {
                            name = sourceFileName.replace(File.separatorChar, '/');
                        }
                        srcListWriter.println(""\"""" + name + ""\"""");
                    } else {
                        srcListWriter.println(sourceFileName);
                    }
                } else {
                    toExecute.createArgument().setValue(sourceFileName);
                }
            }

        } catch (IOException e) {
            tmpList.delete();
            throw new BuildException(""Error creating temporary file"",
                                     e, getLocation());
        } finally {
            if (srcListWriter != null) {
                srcListWriter.close();
            }
        }

        if (packageList != null) {
            toExecute.createArgument().setValue(""@"" + packageList);
        }
        log(toExecute.describeCommand(), Project.MSG_VERBOSE);

        log(""Javadoc execution"", Project.MSG_INFO);

        JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
        JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
        Execute exe = new Execute(new PumpStreamHandler(out, err));
        exe.setAntRun(getProject());

        
        exe.setWorkingDirectory(null);
        try {
            exe.setCommandline(toExecute.getCommandline());
            int ret = exe.execute();
            if (ret != 0 && failOnError) {
                throw new BuildException(""Javadoc returned "" + ret,
                                         getLocation());
            }
        } catch (IOException e) {
            throw new BuildException(""Javadoc failed: "" + e, e, getLocation());
        } finally {
            if (tmpList != null) {
                tmpList.delete();
                tmpList = null;
            }

            out.logFlush();
            err.logFlush();
            try {
                out.close();
                err.close();
            } catch (IOException e) {
                
            }
        }
    }

    private void writeExternalArgs(Commandline toExecute) {
        
        File optionsTmpFile = null;
        PrintWriter optionsListWriter = null;
        try {
            optionsTmpFile = FILE_UTILS.createTempFile(
                ""javadocOptions"", """", null);
            optionsTmpFile.deleteOnExit();
            String[] listOpt = toExecute.getArguments();
            toExecute.clearArgs();
            toExecute.createArgument().setValue(
                ""@"" + optionsTmpFile.getAbsolutePath());
            optionsListWriter = new PrintWriter(
                new FileWriter(optionsTmpFile.getAbsolutePath(), true));
            for (int i = 0; i < listOpt.length; i++) {
                String string = listOpt[i];
                if (string.startsWith(""-J-"")) {
                    toExecute.createArgument().setValue(string);
                } else  {
                    if (string.startsWith(""-"")) {
                        optionsListWriter.print(string);
                        optionsListWriter.print("" "");
                    } else {
                        optionsListWriter.println(quoteString(string));
                    }
                }
            }
            optionsListWriter.close();
        } catch (IOException ex) {
            if (optionsTmpFile != null) {
                optionsTmpFile.delete();
            }
            throw new BuildException(
                ""Error creating or writing temporary file for javadoc options"",
                ex, getLocation());
        } finally {
            FILE_UTILS.close(optionsListWriter);
        }
    }

    
    private String quoteString(String str) {
        if (str.indexOf(' ') == -1
            && str.indexOf('\'') == -1
            && str.indexOf('""') == -1) {
            return str;
        }
        if (str.indexOf('\'') == -1) {
            return quoteString(str, '\'');
        } else {
            return quoteString(str, '""');
        }
    }

    private String quoteString(String str, char delim) {
        StringBuffer buf = new StringBuffer(str.length() * 2);
        buf.append(delim);
        if (str.indexOf('\\') != -1) {
            str = replace(str, '\\', ""\\\\"");
        }
        if (str.indexOf(delim) != -1) {
            str = replace(str, delim, ""\\"" + delim);
        }
        buf.append(str);
        buf.append(delim);
        return buf.toString();
    }

    private String replace(String str, char fromChar, String toString) {
        StringBuffer buf = new StringBuffer(str.length() * 2);
        for (int i = 0; i < str.length(); ++i) {
            char ch = str.charAt(i);
            if (ch == fromChar) {
                buf.append(toString);
            } else {
                buf.append(ch);
            }
        }
        return buf.toString();
    }

    
    private void addSourceFiles(Vector sf) {
        Iterator e = nestedSourceFiles.iterator();
        while (e.hasNext()) {
            ResourceCollection rc = (ResourceCollection) e.next();
            if (!rc.isFilesystemOnly()) {
                throw new BuildException(""only file system based resources are""
                                         + "" supported by javadoc"");
            }
            if (rc instanceof FileSet) {
                FileSet fs = (FileSet) rc;
                if (!fs.hasPatterns() && !fs.hasSelectors()) {
                    fs = (FileSet) fs.clone();
                    fs.createInclude().setName(""**package.html"");
                    }
                }
            }
            Iterator iter = rc.iterator();
            while (iter.hasNext()) {
                sf.addElement(new SourceFile(((FileResource) iter.next())
                                             .getFile()));
            }
        }
    }

    
    private void parsePackages(Vector pn, Path sp) {
        Vector addedPackages = new Vector();
        Vector dirSets = (Vector) packageSets.clone();

        
        
        
        
        if (sourcePath != null) {
            PatternSet ps = new PatternSet();
            if (packageNames.size() > 0) {
                Enumeration e = packageNames.elements();
                while (e.hasMoreElements()) {
                    PackageName p = (PackageName) e.nextElement();
                    String pkg = p.getName().replace('.', '/');
                    if (pkg.endsWith(""*"")) {
                        pkg += ""*"";
                    }
                    ps.createInclude().setName(pkg);
                }
            } else {
                ps.createInclude().setName(""**"");
            }

            Enumeration e = excludePackageNames.elements();
            while (e.hasMoreElements()) {
                PackageName p = (PackageName) e.nextElement();
                String pkg = p.getName().replace('.', '/');
                if (pkg.endsWith(""*"")) {
                    pkg += ""*"";
                }
                ps.createExclude().setName(pkg);
            }


            String[] pathElements = sourcePath.list();
            for (int i = 0; i < pathElements.length; i++) {
                File dir = new File(pathElements[i]);
                if (dir.isDirectory()) {
                    DirSet ds = new DirSet();
                    ds.setDefaultexcludes(useDefaultExcludes);
                    ds.setDir(dir);
                    ds.createPatternSet().addConfiguredPatternset(ps);
                    dirSets.addElement(ds);
                } else {
                    log(""Skipping "" + pathElements[i]
                        + "" since it is no directory."", Project.MSG_WARN);
                }
            }
        }

        Enumeration e = dirSets.elements();
        while (e.hasMoreElements()) {
            DirSet ds = (DirSet) e.nextElement();
            File baseDir = ds.getDir(getProject());
            log(""scanning "" + baseDir + "" for packages."", Project.MSG_DEBUG);
            DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
            String[] dirs = dsc.getIncludedDirectories();
            boolean containsPackages = false;
            for (int i = 0; i < dirs.length; i++) {
                
                File pd = new File(baseDir, dirs[i]);
                String[] files = pd.list(new FilenameFilter () {
                        public boolean accept(File dir1, String name) {
                            return name.endsWith("".java"")
                                || (includeNoSourcePackages
                                    && name.equals(""package.html""));
                        }
                    });

                if (files.length > 0) {
                    if ("""".equals(dirs[i])) {
                        log(baseDir
                            + "" contains source files in the default package,""
                            + "" you must specify them as source files""
                            + "" not packages."",
                            Project.MSG_WARN);
                    } else {
                        containsPackages = true;
                        String packageName =
                            dirs[i].replace(File.separatorChar, '.');
                        if (!addedPackages.contains(packageName)) {
                            addedPackages.addElement(packageName);
                            pn.addElement(packageName);
                        }
                    }
                }
            }
            if (containsPackages) {
                
                
                sp.createPathElement().setLocation(baseDir);
            } else {
                log(baseDir + "" doesn\'t contain any packages, dropping it."",
                    Project.MSG_VERBOSE);
            }
        }
    }

    private class JavadocOutputStream extends LogOutputStream {
        JavadocOutputStream(int level) {
            super(Javadoc.this, level);
        }

        
        
        
        
        
        private String queuedLine = null;
        protected void processLine(String line, int messageLevel) {
            if (messageLevel == Project.MSG_INFO
                && line.startsWith(""Generating "")) {
                if (queuedLine != null) {
                    super.processLine(queuedLine, Project.MSG_VERBOSE);
                }
                queuedLine = line;
            } else {
                if (queuedLine != null) {
                    if (line.startsWith(""Building "")) {
                        super.processLine(queuedLine, Project.MSG_VERBOSE);
                    } else {
                        super.processLine(queuedLine, Project.MSG_INFO);
                    }
                    queuedLine = null;
                }
                super.processLine(line, messageLevel);
            }
        }


        protected void logFlush() {
            if (queuedLine != null) {
                super.processLine(queuedLine, Project.MSG_VERBOSE);
                queuedLine = null;
            }
        }
    }

    
    protected String expand(String content) {
        return getProject().replaceProperties(content);
    }

}
"
org.apache.tools.ant.types.selectors.BaseSelector,6,3,6,10,10,3,7,3,6,0.4,46,1.0,0,0.857142857,0.5,0,0,6.5,3,1.5,0,"

package org.apache.tools.ant.types.selectors;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;


public abstract class BaseSelector extends DataType implements FileSelector {

    private String errmsg = null;


    
    public BaseSelector() {
    }

    
    public void setError(String msg) {
        if (errmsg == null) {
            errmsg = msg;
        }
    }

    
    public String getError() {
        return errmsg;
    }


    
    public void verifySettings() {
        if (isReference()) {
            ((BaseSelector) getCheckedRef()).verifySettings();
        }
    }


    
    public void validate() {
        if (getError() == null) {
            verifySettings();
        }
        if (getError() != null) {
            throw new BuildException(errmsg);
        }
    }

    
    public abstract boolean isSelected(File basedir, String filename,
                                       File file);

}


"
org.apache.tools.ant.types.resources.selectors.ResourceSelectorContainer,7,3,5,9,26,0,5,4,6,0.0,141,1.0,0,0.857142857,0.314285714,1,3,19.0,3,1.5714,0,"
package org.apache.tools.ant.types.resources.selectors;

import java.util.Stack;
import java.util.Vector;
import java.util.Iterator;
import java.util.Collections;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.DataType;


public class ResourceSelectorContainer extends DataType {

    private Vector v = new Vector();

    
    public ResourceSelectorContainer() {
    }

    
    public ResourceSelectorContainer(ResourceSelector[] r) {
        for (int i = 0; i < r.length; i++) {
            add(r[i]);
        }
    }

    
    public void add(ResourceSelector s) {
        if (isReference()) {
            throw noChildrenAllowed();
        }
        if (s == null) {
            return;
        }
        v.add(s);
        setChecked(false);
    }

    
    public boolean hasSelectors() {
        if (isReference()) {
            return ((ResourceSelectorContainer) getCheckedRef()).hasSelectors();
        }
        dieOnCircularReference();
        return !v.isEmpty();
    }

    
    public int selectorCount() {
        if (isReference()) {
            return ((ResourceSelectorContainer) getCheckedRef()).selectorCount();
        }
        dieOnCircularReference();
        return v.size();
    }

    
    public Iterator getSelectors() {
        if (isReference()) {
            return ((ResourceSelectorContainer) getCheckedRef()).getSelectors();
        }
        dieOnCircularReference();
        return Collections.unmodifiableList(v).iterator();
    }

    
    protected void dieOnCircularReference(Stack stk, Project p)
        throws BuildException {
        if (isChecked()) {
            return;
        }
        if (isReference()) {
            super.dieOnCircularReference(stk, p);
        } else {
            for (Iterator i = v.iterator(); i.hasNext();) {
                Object o = i.next();
                if (o instanceof DataType) {
                    stk.push(o);
                    invokeCircularReferenceCheck((DataType) o, stk, p);
                }
            }
            setChecked(true);
        }
    }

}
"
org.apache.tools.ant.taskdefs.compilers.Gcj,5,2,0,8,34,8,1,7,3,0.5,216,1.0,0,0.884615385,1.0,0,0,42.0,11,3.4,1,"

package org.apache.tools.ant.taskdefs.compilers;


import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Path;


public class Gcj extends DefaultCompilerAdapter {

    
    public boolean execute() throws BuildException {
        Commandline cmd;
        attributes.log(""Using gcj compiler"", Project.MSG_VERBOSE);
        cmd = setupGCJCommand();

        int firstFileName = cmd.size();
        logAndAddFilesToCompile(cmd);

        return
            executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
    }

    
    protected Commandline setupGCJCommand() {
        Commandline cmd = new Commandline();
        Path classpath = new Path(project);

        
        
        Path p = getBootClassPath();
        if (p.size() > 0) {
            classpath.append(p);
        }

        
        
        classpath.addExtdirs(extdirs);

        classpath.append(getCompileClasspath());

        
        
        if (compileSourcepath != null) {
            classpath.append(compileSourcepath);
        } else {
            classpath.append(src);
        }

        String exec = getJavac().getExecutable();
        cmd.setExecutable(exec == null ? ""gcj"" : exec);

        if (destDir != null) {
            cmd.createArgument().setValue(""-d"");
            cmd.createArgument().setFile(destDir);

            if (!destDir.exists() && !destDir.mkdirs()) {
                throw new BuildException(""Can't make output directories. ""
                                         + ""Maybe permission is wrong. "");
            }
        }

        cmd.createArgument().setValue(""-classpath"");
        cmd.createArgument().setPath(classpath);

        if (encoding != null) {
            cmd.createArgument().setValue(""--encoding="" + encoding);
        }
        if (debug) {
            cmd.createArgument().setValue(""-g1"");
        }
        if (optimize) {
            cmd.createArgument().setValue(""-O"");
        }

        
        if (!isNativeBuild()) {
            cmd.createArgument().setValue(""-C"");
        }

        addCurrentCompilerArgs(cmd);

        return cmd;
    }

    
    public boolean isNativeBuild() {
        boolean nativeBuild = false;
        String[] additionalArguments = getJavac().getCurrentCompilerArgs();
        int argsLength = 0;
        while (!nativeBuild && argsLength < additionalArguments.length) {
            int conflictLength = 0;
            while (!nativeBuild
                   && conflictLength < CONFLICT_WITH_DASH_C.length) {
                nativeBuild = (additionalArguments[argsLength].startsWith
                               (CONFLICT_WITH_DASH_C[conflictLength]));
                conflictLength++;
            }
            argsLength++;
        }
        return nativeBuild;
    }

    private static final String [] CONFLICT_WITH_DASH_C = {
        ""-o"" , ""--main="", ""-D"", ""-fjni"", ""-L""
    };

}
"
org.apache.tools.ant.taskdefs.optional.depend.JarFileIterator,2,1,0,2,18,0,0,2,2,0.0,83,1.0,0,0.0,0.75,0,0,40.0,6,3.0,0,"
package org.apache.tools.ant.taskdefs.optional.depend;

import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;


public class JarFileIterator implements ClassFileIterator {
    
    private ZipInputStream jarStream;

    
    public JarFileIterator(InputStream stream) throws IOException {
        super();

        jarStream = new ZipInputStream(stream);
    }

    
    public ClassFile getNextClassFile() {
        ZipEntry jarEntry;
        ClassFile nextElement = null;

        try {
            jarEntry = jarStream.getNextEntry();

            while (nextElement == null && jarEntry != null) {
                String entryName = jarEntry.getName();

                if (!jarEntry.isDirectory() && entryName.endsWith("".class"")) {

                    
                    ClassFile javaClass = new ClassFile();

                    javaClass.read(jarStream);

                    nextElement = javaClass;
                } else {

                    jarEntry = jarStream.getNextEntry();
                }
            }
        } catch (IOException e) {
            String message = e.getMessage();
            String text = e.getClass().getName();

            if (message != null) {
                text += "": "" + message;
            }

            throw new RuntimeException(""Problem reading JAR file: "" + text);
        }

        return nextElement;
    }

}

"
