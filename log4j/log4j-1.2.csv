name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
log4j,1.2,org.apache.log4j.chainsaw.XMLFileHandler,8,2,0,4,22,4,1,3,4,0.767857143,273,1.0,2,0.708333333,0.291666667,1,2,31.125,6,2.375,3,"
package org.apache.log4j.chainsaw;

import java.util.StringTokenizer;
import org.apache.log4j.Level;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;


class XMLFileHandler
    extends DefaultHandler
{
    
    private static final String TAG_EVENT = ""log4j:event"";
    
    private static final String TAG_MESSAGE = ""log4j:message"";
    
    private static final String TAG_NDC = ""log4j:NDC"";
    
    private static final String TAG_THROWABLE = ""log4j:throwable"";
    
    private static final String TAG_LOCATION_INFO = ""log4j:locationInfo"";

    
    private final MyTableModel mModel;
    
    private int mNumEvents;

    
    private long mTimeStamp;
    
    private Level mLevel;
    
    private String mCategoryName;
    
    private String mNDC;
    
    private String mThreadName;
    
    private String mMessage;
    
    private String[] mThrowableStrRep;
    
    private String mLocationDetails;
    
    private final StringBuffer mBuf = new StringBuffer();

    
    XMLFileHandler(MyTableModel aModel) {
        mModel = aModel;
    }

    
    public void startDocument()
        throws SAXException
    {
        mNumEvents = 0;
    }

    
    public void characters(char[] aChars, int aStart, int aLength) {
        mBuf.append(String.valueOf(aChars, aStart, aLength));
    }

    
    public void endElement(String aNamespaceURI,
                           String aLocalName,
                           String aQName)
    {
        if (TAG_EVENT.equals(aQName)) {
            addEvent();
            resetData();
        } else if (TAG_NDC.equals(aQName)) {
            mNDC = mBuf.toString();
        } else if (TAG_MESSAGE.equals(aQName)) {
            mMessage = mBuf.toString();
        } else if (TAG_THROWABLE.equals(aQName)) {
            final StringTokenizer st =
                new StringTokenizer(mBuf.toString(), ""\n\t"");
            mThrowableStrRep = new String[st.countTokens()];
            if (mThrowableStrRep.length > 0) {
                mThrowableStrRep[0] = st.nextToken();
                for (int i = 1; i < mThrowableStrRep.length; i++) {
                    mThrowableStrRep[i] = ""\t"" + st.nextToken();
                }
            }
        }
    }

    
    public void startElement(String aNamespaceURI,
                             String aLocalName,
                             String aQName,
                             Attributes aAtts)
    {
        mBuf.setLength(0);

        if (TAG_EVENT.equals(aQName)) {
            mThreadName = aAtts.getValue(""thread"");
            mTimeStamp = Long.parseLong(aAtts.getValue(""timestamp""));
            mCategoryName = aAtts.getValue(""logger"");
            mLevel = Level.toLevel(aAtts.getValue(""level""));
        } else if (TAG_LOCATION_INFO.equals(aQName)) {
            mLocationDetails = aAtts.getValue(""class"") + "".""
                + aAtts.getValue(""method"")
                + ""("" + aAtts.getValue(""file"") + "":"" + aAtts.getValue(""line"")
                + "")"";
        }
    }

    
    int getNumEvents() {
        return mNumEvents;
    }

    
    
    

    
    private void addEvent() {
        mModel.addEvent(new EventDetails(mTimeStamp,
                                         mLevel,
                                         mCategoryName,
                                         mNDC,
                                         mThreadName,
                                         mMessage,
                                         mThrowableStrRep,
                                         mLocationDetails));
        mNumEvents++;
    }

    
    private void resetData() {
        mTimeStamp = 0;
        mLevel = null;
        mCategoryName = null;
        mNDC = null;
        mThreadName = null;
        mMessage = null;
        mThrowableStrRep = null;
        mLocationDetails = null;
    }
}
"
log4j,1.2,org.apache.log4j.spi.Configurator,1,1,0,7,1,0,6,1,1,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;

import java.io.InputStream;
import java.net.URL;


public interface Configurator {

  
  public static final String INHERITED = ""inherited"";

  
  public static final String NULL = ""null"";



  
  void doConfigure(InputStream inputStream, LoggerRepository repository);

  
  void doConfigure(URL url, LoggerRepository repository);
}
"
log4j,1.2,org.apache.log4j.or.DefaultRenderer,2,1,0,2,4,1,1,1,1,2.0,8,0.0,0,0.0,0.75,0,0,3.0,1,0.5,2,"

package org.apache.log4j.or;


class DefaultRenderer implements ObjectRenderer {
  
  DefaultRenderer() {
  }

  
  public
  String doRender(final Object o) {
          try {
            return o.toString();
          } catch(Exception ex) {
            return ex.toString();
          }
  }
}  
"
log4j,1.2,org.apache.log4j.varia.FallbackErrorHandler,8,1,0,6,22,22,0,6,8,0.714285714,157,0.0,2,0.0,0.339285714,0,0,18.25,2,1.125,3,"
 
package org.apache.log4j.varia;

import  org.apache.log4j.spi.ErrorHandler;
import  org.apache.log4j.spi.LoggingEvent;
import  org.apache.log4j.Appender;
import  org.apache.log4j.Logger;
import  org.apache.log4j.helpers.LogLog;
import java.util.Vector;
import java.io.InterruptedIOException;


public class FallbackErrorHandler implements ErrorHandler {


  Appender backup;
  Appender primary;
  Vector loggers;

  public FallbackErrorHandler() {
  }
  

  
  public 
  void setLogger(Logger logger) {
    LogLog.debug(""FB: Adding logger ["" + logger.getName() + ""]."");
    if(loggers == null) {
      loggers = new Vector();
    }
    loggers.addElement(logger);
  }


  
  public 
  void activateOptions() {
  }


  
  public
  void error(String message, Exception e, int errorCode) { 
    error(message, e, errorCode, null);
  }

  
  public
  void error(String message, Exception e, int errorCode, LoggingEvent event) {
    if (e instanceof InterruptedIOException) {
        Thread.currentThread().interrupt();
    }
    LogLog.debug(""FB: The following error reported: "" + message, e);
    LogLog.debug(""FB: INITIATING FALLBACK PROCEDURE."");
    if (loggers != null) {
    	for(int i = 0; i < loggers.size(); i++) {
      		Logger l = (Logger) loggers.elementAt(i);
      		LogLog.debug(""FB: Searching for [""+primary.getName()+""] in logger [""
		   		+l.getName() + ""]."");
      		LogLog.debug(""FB: Replacing [""+primary.getName()+""] by [""
		   		+ backup.getName() + ""] in logger [""+ l.getName() +""]."");
      		l.removeAppender(primary);
      		LogLog.debug(""FB: Adding appender [""+backup.getName()+""] to logger ""
		   		+  l.getName());
      		l.addAppender(backup);
        }
    }    
  }


  
  public 
  void error(String message) {
    
    
    
    
  }
  
  
  public
  void setAppender(Appender primary) {
    LogLog.debug(""FB: Setting primary appender to ["" + primary.getName() + ""]."");
    this.primary = primary;
  }

  
  public
  void setBackupAppender(Appender backup) {
    LogLog.debug(""FB: Setting backup appender to ["" + backup.getName() + ""]."");
    this.backup = backup;
  }
  
}
"
log4j,1.2,org.apache.log4j.chainsaw.EventDetails,10,1,0,9,16,29,6,3,0,0.777777778,94,1.0,1,0.0,0.25,0,0,7.6,1,0.8,2,"
package org.apache.log4j.chainsaw;

import org.apache.log4j.Priority;
import org.apache.log4j.spi.LoggingEvent;


class EventDetails {

    
    private final long mTimeStamp;
    
    private final Priority mPriority;
    
    private final String mCategoryName;
    
    private final String mNDC;
    
    private final String mThreadName;
    
    private final String mMessage;
    
    private final String[] mThrowableStrRep;
    
    private final String mLocationDetails;

    
    EventDetails(long aTimeStamp,
                 Priority aPriority,
                 String aCategoryName,
                 String aNDC,
                 String aThreadName,
                 String aMessage,
                 String[] aThrowableStrRep,
                 String aLocationDetails)
    {
        mTimeStamp = aTimeStamp;
        mPriority = aPriority;
        mCategoryName = aCategoryName;
        mNDC = aNDC;
        mThreadName = aThreadName;
        mMessage = aMessage;
        mThrowableStrRep = aThrowableStrRep;
        mLocationDetails = aLocationDetails;
    }

    
    EventDetails(LoggingEvent aEvent) {

        this(aEvent.timeStamp,
             aEvent.getLevel(),
             aEvent.getLoggerName(),
             aEvent.getNDC(),
             aEvent.getThreadName(),
             aEvent.getRenderedMessage(),
             aEvent.getThrowableStrRep(),
             (aEvent.getLocationInformation() == null)
             ? null : aEvent.getLocationInformation().fullInfo);
    }

    
    long getTimeStamp() {
        return mTimeStamp;
    }

    
    Priority getPriority() {
        return mPriority;
    }

    
    String getCategoryName() {
        return mCategoryName;
    }

    
    String getNDC() {
        return mNDC;
    }

    
    String getThreadName() {
        return mThreadName;
    }

    
    String getMessage() {
        return mMessage;
    }

    
    String getLocationDetails(){
        return mLocationDetails;
    }

    
    String[] getThrowableStrRep() {
        return mThrowableStrRep;
    }
}
"
log4j,1.2,org.apache.log4j.nt.NTEventLogAppender,17,2,0,8,30,114,1,7,13,0.828125,200,1.0,0,0.642857143,0.3625,1,1,10.29411765,4,0.8235,4,"

package org.apache.log4j.nt;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.TTCCLayout;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;



public class NTEventLogAppender extends AppenderSkeleton {
  private int _handle = 0;

  private String source = null;
  private String server = null;


  public NTEventLogAppender() {
    this(null, null, null);
  }

  public NTEventLogAppender(String source) {
    this(null, source, null);
  }

  public NTEventLogAppender(String server, String source) {
    this(server, source, null);
  }

  public NTEventLogAppender(Layout layout) {
    this(null, null, layout);
  }

  public NTEventLogAppender(String source, Layout layout) {
    this(null, source, layout);
  }

  public NTEventLogAppender(String server, String source, Layout layout) {
    if (source == null) {
      source = ""Log4j"";
    }
    if (layout == null) {
      this.layout = new TTCCLayout();
    } else {
      this.layout = layout;
    }

    try {
      _handle = registerEventSource(server, source);
    } catch (Exception e) {
      e.printStackTrace();
      _handle = 0;
    }
  }

  public
  void close() {
    
  }

  public
  void activateOptions() {
    if (source != null) {
      try {
   _handle = registerEventSource(server, source);
      } catch (Exception e) {
   LogLog.error(""Could not register event source."", e);
   _handle = 0;
      }
    }
  }


  public void append(LoggingEvent event) {

    StringBuffer sbuf = new StringBuffer();

    sbuf.append(layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
   int len = s.length;
   for(int i = 0; i < len; i++) {
     sbuf.append(s[i]);
   }
      }
    }
    
    int nt_category = event.getLevel().toInt();

    
    
    
    
    reportEvent(_handle, sbuf.toString(), nt_category);
  }


  public
  void finalize() {
    deregisterEventSource(_handle);
    _handle = 0;
  }

  
  public
  void setSource(String source) {
    this.source = source.trim();
  }

  public
  String getSource() {
    return source;
  }


  public
  boolean requiresLayout() {
    return true;
  }

  native private int registerEventSource(String server, String source);
  native private void reportEvent(int handle, String message, int level);
  native private void deregisterEventSource(int handle);

  static {
    String[] archs;
    try {
        archs = new String[] { System.getProperty(""os.arch"")};
    } catch(SecurityException e) {
        archs = new String[] { ""amd64"", ""ia64"", ""x86""};
    }
    boolean loaded = false;
    for(int i = 0; i < archs.length; i++) {
        try {
            System.loadLibrary(""NTEventLogAppender."" + archs[i]);
            loaded = true;
            break;
        } catch(java.lang.UnsatisfiedLinkError e) {
            loaded = false;
        }
    }
    if (!loaded) {
        System.loadLibrary(""NTEventLogAppender"");
    }
}
}
"
log4j,1.2,org.apache.log4j.or.jms.MessageRenderer,2,1,0,3,22,1,1,2,2,2.0,128,0.0,0,0.0,0.75,0,0,63.0,5,2.5,2,"

package org.apache.log4j.or.jms;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.or.ObjectRenderer;

import javax.jms.Message;
import javax.jms.JMSException;
import javax.jms.DeliveryMode;


public class MessageRenderer implements ObjectRenderer {

  public
  MessageRenderer() {
  }


  
  public
  String  doRender(Object o) {
    if(o instanceof Message) {
      StringBuffer sbuf = new StringBuffer();
      Message m = (Message) o;
      try {
	sbuf.append(""DeliveryMode="");
	switch(m.getJMSDeliveryMode()) {
	case DeliveryMode.NON_PERSISTENT :
	  sbuf.append(""NON_PERSISTENT"");
	  break;
	case DeliveryMode.PERSISTENT :
	  sbuf.append(""PERSISTENT"");
	  break;
	default: sbuf.append(""UNKNOWN"");
	}
	sbuf.append("", CorrelationID="");
	sbuf.append(m.getJMSCorrelationID());

	sbuf.append("", Destination="");
	sbuf.append(m.getJMSDestination());

	sbuf.append("", Expiration="");
	sbuf.append(m.getJMSExpiration());

	sbuf.append("", MessageID="");
	sbuf.append(m.getJMSMessageID());

	sbuf.append("", Priority="");
	sbuf.append(m.getJMSPriority());

	sbuf.append("", Redelivered="");
	sbuf.append(m.getJMSRedelivered());

	sbuf.append("", ReplyTo="");
	sbuf.append(m.getJMSReplyTo());

	sbuf.append("", Timestamp="");
	sbuf.append(m.getJMSTimestamp());

	sbuf.append("", Type="");
	sbuf.append(m.getJMSType());

	
	
	
	
	
	

      } catch(JMSException e) {
	LogLog.error(""Could not parse Message."", e);
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
log4j,1.2,org.apache.log4j.lf5.util.LogMonitorAdapter,19,1,0,4,40,159,0,4,14,0.819444444,198,0.5,2,0.0,0.203947368,0,0,9.210526316,2,1.1053,2,"
package org.apache.log4j.lf5.util;

import java.awt.Toolkit;
import java.util.Arrays;
import java.util.List;

import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;





public class LogMonitorAdapter {
  
  
  
  public static final int LOG4J_LOG_LEVELS = 0;
  public static final int JDK14_LOG_LEVELS = 1;
  
  
  

  
  
  
  private LogBrokerMonitor _logMonitor;
  private LogLevel _defaultLevel = null;

  
  
  
  private LogMonitorAdapter(List userDefinedLevels) {
    super();
    
    _defaultLevel = (LogLevel) userDefinedLevels.get(0);
    _logMonitor = new LogBrokerMonitor(userDefinedLevels);

    _logMonitor.setFrameSize(getDefaultMonitorWidth(),
        getDefaultMonitorHeight());
    _logMonitor.setFontSize(12);
    _logMonitor.show();
  }
  
  
  
  
  public static LogMonitorAdapter newInstance(int loglevels) {
    LogMonitorAdapter adapter;
    if (loglevels == JDK14_LOG_LEVELS) {
      adapter = newInstance(LogLevel.getJdk14Levels());
      adapter.setDefaultLevel(LogLevel.FINEST);
      adapter.setSevereLevel(LogLevel.SEVERE);
    } else {
      adapter = newInstance(LogLevel.getLog4JLevels());
      adapter.setDefaultLevel(LogLevel.DEBUG);
      adapter.setSevereLevel(LogLevel.FATAL);
    }
    return adapter;
  }

  
  public static LogMonitorAdapter newInstance(LogLevel[] userDefined) {
    if (userDefined == null) {
      return null;
    }
    return newInstance(Arrays.asList(userDefined));
  }

  
  public static LogMonitorAdapter newInstance(List userDefinedLevels) {
    return new LogMonitorAdapter(userDefinedLevels);
  }

  
  public void addMessage(LogRecord record) {
    _logMonitor.addMessage(record);
  }

  
  public void setMaxNumberOfRecords(int maxNumberOfRecords) {
    _logMonitor.setMaxNumberOfLogRecords(maxNumberOfRecords);
  }

  
  public void setDefaultLevel(LogLevel level) {
    _defaultLevel = level;
  }

  
  public LogLevel getDefaultLevel() {
    return _defaultLevel;
  }

  
  public void setSevereLevel(LogLevel level) {
    AdapterLogRecord.setSevereLevel(level);
  }

  
  public LogLevel getSevereLevel() {
    return AdapterLogRecord.getSevereLevel();
  }

  
  public void log(String category, LogLevel level, String message,
      Throwable t, String NDC) {
    AdapterLogRecord record = new AdapterLogRecord();
    record.setCategory(category);
    record.setMessage(message);
    record.setNDC(NDC);
    record.setThrown(t);

    if (level == null) {
      record.setLevel(getDefaultLevel());
    } else {
      record.setLevel(level);
    }

    addMessage(record);
  }

  
  public void log(String category, String message) {
    log(category, null, message);
  }

  
  public void log(String category, LogLevel level, String message, String NDC) {
    log(category, level, message, null, NDC);
  }

  
  public void log(String category, LogLevel level, String message,
      Throwable t) {
    log(category, level, message, t, null);
  }

  
  public void log(String category, LogLevel level, String message) {
    log(category, level, message, null, null);
  }

  
  
  
  
  protected static int getScreenWidth() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().width;
    } catch (Throwable t) {
      return 800;
    }
  }

  
  protected static int getScreenHeight() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().height;
    } catch (Throwable t) {
      return 600;
    }
  }

  protected static int getDefaultMonitorWidth() {
    return (3 * getScreenWidth()) / 4;
  }

  protected static int getDefaultMonitorHeight() {
    return (3 * getScreenHeight()) / 4;
  }
  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.helpers.PatternConverter,6,1,6,10,10,7,8,2,2,0.72,174,0.0,1,0.0,0.44,0,0,27.16666667,6,1.8333,2,"

package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;


public abstract class PatternConverter {
  public PatternConverter next;
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;

  protected
  PatternConverter() {  }
  
  protected
  PatternConverter(FormattingInfo fi) {
    min = fi.min;
    max = fi.max;
    leftAlign = fi.leftAlign;
  }

  
  abstract
  protected
  String convert(LoggingEvent event);

  
  public
  void format(StringBuffer sbuf, LoggingEvent e) {
    String s = convert(e);

    if(s == null) {
      if(0 < min)
	spacePad(sbuf, min);
      return;
    }

    int len = s.length();

    if(len > max)
      sbuf.append(s.substring(len-max));
    else if(len < min) {
      if(leftAlign) {	
	sbuf.append(s);
	spacePad(sbuf, min-len);
      }
      else {
	spacePad(sbuf, min-len);
	sbuf.append(s);
      }
    }
    else
      sbuf.append(s);
  }	

  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", 
			    ""                "", 
			    ""                                "" }; 

  
  public
  void spacePad(StringBuffer sbuf, int length) {
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
log4j,1.2,org.apache.log4j.varia.ReloadingPropertyConfigurator,2,1,0,3,4,1,0,3,2,1.0,12,0.0,1,0.0,0.666666667,0,0,4.5,1,0.5,2,"

package org.apache.log4j.varia;

import java.io.InputStream;
import java.net.URL;

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggerRepository;

public class ReloadingPropertyConfigurator implements Configurator {

    PropertyConfigurator delegate = new PropertyConfigurator();

    public ReloadingPropertyConfigurator() {
    }

   
    public void doConfigure(InputStream inputStream, LoggerRepository repository) {
    }

    public void doConfigure(URL url, LoggerRepository repository) {
    }

}
"
log4j,1.2,org.apache.log4j.DailyRollingFileAppender,10,3,0,8,42,0,0,8,5,0.866666667,435,0.2,1,0.825,0.311111111,1,1,41.0,6,1.6,4,"



package org.apache.log4j;

import java.io.IOException;
import java.io.File;
import java.io.InterruptedIOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Locale;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;


public class DailyRollingFileAppender extends FileAppender {


  
  
  static final int TOP_OF_TROUBLE=-1;
  static final int TOP_OF_MINUTE = 0;
  static final int TOP_OF_HOUR   = 1;
  static final int HALF_DAY      = 2;
  static final int TOP_OF_DAY    = 3;
  static final int TOP_OF_WEEK   = 4;
  static final int TOP_OF_MONTH  = 5;


  
  private String datePattern = ""'.'yyyy-MM-dd"";

  
  private String scheduledFilename;

  
  private long nextCheck = System.currentTimeMillis () - 1;

  Date now = new Date();

  SimpleDateFormat sdf;

  RollingCalendar rc = new RollingCalendar();

  int checkPeriod = TOP_OF_TROUBLE;

  
  static final TimeZone gmtTimeZone = TimeZone.getTimeZone(""GMT"");


  
  public DailyRollingFileAppender() {
  }

  
  public DailyRollingFileAppender (Layout layout, String filename,
				   String datePattern) throws IOException {
    super(layout, filename, true);
    this.datePattern = datePattern;
    activateOptions();
  }

  
  public void setDatePattern(String pattern) {
    datePattern = pattern;
  }

  
  public String getDatePattern() {
    return datePattern;
  }

  public void activateOptions() {
    super.activateOptions();
    if(datePattern != null && fileName != null) {
      now.setTime(System.currentTimeMillis());
      sdf = new SimpleDateFormat(datePattern);
      int type = computeCheckPeriod();
      printPeriodicity(type);
      rc.setType(type);
      File file = new File(fileName);
      scheduledFilename = fileName+sdf.format(new Date(file.lastModified()));

    } else {
      LogLog.error(""Either File or DatePattern options are not set for appender [""
		   +name+""]."");
    }
  }

  void printPeriodicity(int type) {
    switch(type) {
    case TOP_OF_MINUTE:
      LogLog.debug(""Appender [""+name+""] to be rolled every minute."");
      break;
    case TOP_OF_HOUR:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled on top of every hour."");
      break;
    case HALF_DAY:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at midday and midnight."");
      break;
    case TOP_OF_DAY:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at midnight."");
      break;
    case TOP_OF_WEEK:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at start of week."");
      break;
    case TOP_OF_MONTH:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at start of every month."");
      break;
    default:
      LogLog.warn(""Unknown periodicity for appender [""+name+""]."");
    }
  }


  
  
  
  
  
  
  
  

  int computeCheckPeriod() {
    RollingCalendar rollingCalendar = new RollingCalendar(gmtTimeZone, Locale.getDefault());
    
    Date epoch = new Date(0);
    if(datePattern != null) {
      for(int i = TOP_OF_MINUTE; i <= TOP_OF_MONTH; i++) {
	SimpleDateFormat simpleDateFormat = new SimpleDateFormat(datePattern);
	simpleDateFormat.setTimeZone(gmtTimeZone); 
	String r0 = simpleDateFormat.format(epoch);
	rollingCalendar.setType(i);
	Date next = new Date(rollingCalendar.getNextCheckMillis(epoch));
	String r1 =  simpleDateFormat.format(next);
	
	if(r0 != null && r1 != null && !r0.equals(r1)) {
	  return i;
	}
      }
    }
    return TOP_OF_TROUBLE; 
  }

  
  void rollOver() throws IOException {

    
    if (datePattern == null) {
      errorHandler.error(""Missing DatePattern option in rollOver()."");
      return;
    }

    String datedFilename = fileName+sdf.format(now);
    
    
    
    if (scheduledFilename.equals(datedFilename)) {
      return;
    }

    
    this.closeFile();

    File target  = new File(scheduledFilename);
    if (target.exists()) {
      target.delete();
    }

    File file = new File(fileName);
    boolean result = file.renameTo(target);
    if(result) {
      LogLog.debug(fileName +"" -> ""+ scheduledFilename);
    } else {
      LogLog.error(""Failed to rename [""+fileName+""] to [""+scheduledFilename+""]."");
    }

    try {
      
      
      this.setFile(fileName, true, this.bufferedIO, this.bufferSize);
    }
    catch(IOException e) {
      errorHandler.error(""setFile(""+fileName+"", true) call failed."");
    }
    scheduledFilename = datedFilename;
  }

  
  protected void subAppend(LoggingEvent event) {
    long n = System.currentTimeMillis();
    if (n >= nextCheck) {
      now.setTime(n);
      nextCheck = rc.getNextCheckMillis(now);
      try {
	rollOver();
      }
      catch(IOException ioe) {
          if (ioe instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	      LogLog.error(""rollOver() failed."", ioe);
      }
    }
    super.subAppend(event);
   }
}


class RollingCalendar extends GregorianCalendar {
  private static final long serialVersionUID = -3560331770601814177L;

  int type = DailyRollingFileAppender.TOP_OF_TROUBLE;

  RollingCalendar() {
    super();
  }  

  RollingCalendar(TimeZone tz, Locale locale) {
    super(tz, locale);
  }  

  void setType(int type) {
    this.type = type;
  }

  public long getNextCheckMillis(Date now) {
    return getNextCheckDate(now).getTime();
  }

  public Date getNextCheckDate(Date now) {
    this.setTime(now);

    switch(type) {
    case DailyRollingFileAppender.TOP_OF_MINUTE:
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.MINUTE, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_HOUR:
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.HOUR_OF_DAY, 1);
	break;
    case DailyRollingFileAppender.HALF_DAY:
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	int hour = get(Calendar.HOUR_OF_DAY);
	if(hour < 12) {
	  this.set(Calendar.HOUR_OF_DAY, 12);
	} else {
	  this.set(Calendar.HOUR_OF_DAY, 0);
	  this.add(Calendar.DAY_OF_MONTH, 1);
	}
	break;
    case DailyRollingFileAppender.TOP_OF_DAY:
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.DATE, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_WEEK:
	this.set(Calendar.DAY_OF_WEEK, getFirstDayOfWeek());
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.WEEK_OF_YEAR, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_MONTH:
	this.set(Calendar.DATE, 1);
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.MINUTE, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.MONTH, 1);
	break;
    default:
	throw new IllegalStateException(""Unknown periodicity type."");
    }
    return getTime();
  }
}
"
log4j,1.2,org.apache.log4j.net.JMSSink,5,1,0,9,31,10,0,9,2,0.875,151,0.0,0,0.0,0.3,0,0,28.8,4,1.6,3,"

package org.apache.log4j.net;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.xml.DOMConfigurator;

import javax.jms.JMSException;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.Topic;
import javax.jms.TopicConnection;
import javax.jms.TopicConnectionFactory;
import javax.jms.TopicSession;
import javax.jms.TopicSubscriber;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
import java.io.BufferedReader;
import java.io.InputStreamReader;


public class JMSSink implements javax.jms.MessageListener {

  static Logger logger = Logger.getLogger(JMSSink.class);

  static public void main(String[] args) throws Exception {
    if(args.length != 5) {
      usage(""Wrong number of arguments."");
    }
    
    String tcfBindingName = args[0];
    String topicBindingName = args[1];
    String username = args[2];
    String password = args[3];
    
    
    String configFile = args[4];

    if(configFile.endsWith("".xml"")) {
      DOMConfigurator.configure(configFile);
    } else {
      PropertyConfigurator.configure(configFile);
    }
    
    new JMSSink(tcfBindingName, topicBindingName, username, password);

    BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
    
    System.out.println(""Type \""exit\"" to quit JMSSink."");
    while(true){
      String s = stdin.readLine( );
      if (s.equalsIgnoreCase(""exit"")) {
	System.out.println(""Exiting. Kill the application if it does not exit ""
			   + ""due to daemon threads."");
	return; 
      }
    } 
  }

  public JMSSink( String tcfBindingName, String topicBindingName, String username,
		  String password) {
    
    try {
      Context ctx = new InitialContext();
      TopicConnectionFactory topicConnectionFactory;
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx,
                                                               tcfBindingName);

      TopicConnection topicConnection =
	                        topicConnectionFactory.createTopicConnection(username,
									     password);
      topicConnection.start();

      TopicSession topicSession = topicConnection.createTopicSession(false,
                                                       Session.AUTO_ACKNOWLEDGE);

      Topic topic = (Topic)ctx.lookup(topicBindingName);

      TopicSubscriber topicSubscriber = topicSession.createSubscriber(topic);
    
      topicSubscriber.setMessageListener(this);

    } catch(JMSException e) {
      logger.error(""Could not read JMS message."", e);
    } catch(NamingException e) {
      logger.error(""Could not read JMS message."", e);
    } catch(RuntimeException e) {
      logger.error(""Could not read JMS message."", e);
    }
  }

  public void onMessage(javax.jms.Message message) {
    LoggingEvent event;
    Logger remoteLogger;

    try {
      if(message instanceof  ObjectMessage) {
	ObjectMessage objectMessage = (ObjectMessage) message;
	event = (LoggingEvent) objectMessage.getObject();
	remoteLogger = Logger.getLogger(event.getLoggerName());
	remoteLogger.callAppenders(event);
      } else {
	logger.warn(""Received message is of type ""+message.getJMSType()
		    +"", was expecting ObjectMessage."");
      }      
    } catch(JMSException jmse) {
      logger.error(""Exception thrown while processing incoming message."", 
		   jmse);
    }
  }


  protected static Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      logger.error(""Could not find name [""+name+""]."");
      throw e;
    }
  }

  static void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + JMSSink.class.getName()
            + "" TopicConnectionFactoryBindingName TopicBindingName username password configFile"");
    System.exit(1);
  }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogFactor5InputDialog,4,7,0,5,25,0,4,4,3,0.666666667,125,0.5,0,0.996865204,0.45,0,0,29.75,3,1.0,2,"
package org.apache.log4j.lf5.viewer;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;





public class LogFactor5InputDialog extends LogFactor5Dialog {
  
  
  
  public static final int SIZE = 30;
  
  
  

  
  
  
  private JTextField _textField;
  
  
  

  
  public LogFactor5InputDialog(JFrame jframe, String title, String label) {
    this(jframe, title, label, SIZE);
  }

  
  public LogFactor5InputDialog(JFrame jframe, String title, String label,
      int size) {
    super(jframe, title, true);

    JPanel bottom = new JPanel();
    bottom.setLayout(new FlowLayout());

    JPanel main = new JPanel();
    main.setLayout(new FlowLayout());
    main.add(new JLabel(label));
    _textField = new JTextField(size);
    main.add(_textField);

    addKeyListener(new KeyAdapter() {
      public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_ENTER) {
          hide();
        }
      }
    });

    JButton ok = new JButton(""Ok"");
    ok.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        hide();
      }
    });

    JButton cancel = new JButton(""Cancel"");
    cancel.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        hide();
        
        
        
        _textField.setText("""");
      }
    });

    bottom.add(ok);
    bottom.add(cancel);
    getContentPane().add(main, BorderLayout.CENTER);
    getContentPane().add(bottom, BorderLayout.SOUTH);
    pack();
    centerWindow(this);
    show();
  }

  
  
  
  public String getText() {
    String s = _textField.getText();

    if (s != null && s.trim().length() == 0) {
      return null;
    }

    return s;

  }

  
  
  

  
  
  

  
  
  
}"
log4j,1.2,org.apache.log4j.helpers.BoundedFIFO,10,1,0,3,17,0,2,1,9,0.555555556,249,0.0,1,0.0,0.466666667,0,0,23.4,5,2.1,2,"




package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;


public class BoundedFIFO {
  
  LoggingEvent[] buf;
  int numElements = 0;
  int first = 0;
  int next = 0;
  int maxSize;

  
  public
  BoundedFIFO(int maxSize) {
   if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    buf = new LoggingEvent[maxSize];
  }
  
  
  public
  LoggingEvent get() {
    if(numElements == 0) 
      return null;
    
    LoggingEvent r = buf[first];
    buf[first] = null; 

    if(++first == maxSize) {
	first = 0;
    }
    numElements--;    
    return r;    
  }

  
  public 
  void put(LoggingEvent o) {
    if(numElements != maxSize) {      
      buf[next] = o;    
      if(++next == maxSize) {
	next = 0;
      }
      numElements++;
    }
  }

  
  public 
  int getMaxSize() {
    return maxSize;
  }

  
  public 
  boolean isFull() {
    return numElements == maxSize;
  }

  
  public
  int length() {
    return numElements;
  } 


  int min(int a, int b) {
    return a < b ? a : b;
  }


  
  synchronized
  public 
  void resize(int newSize) {
    if(newSize == maxSize) 
      return;


   LoggingEvent[] tmp = new LoggingEvent[newSize];

   
   int len1 = maxSize - first;

   
   len1 = min(len1, newSize);

   
   
   len1 = min(len1, numElements);

   
   System.arraycopy(buf, first, tmp, 0, len1);
   
   
   int len2 = 0;
   if((len1 < numElements) && (len1 < newSize)) {
     len2 = numElements - len1;
     len2 = min(len2, newSize - len1);
     System.arraycopy(buf, 0, tmp, len1, len2);
   }
   
   this.buf = tmp;
   this.maxSize = newSize;    
   this.first=0;   
   this.numElements = len1+len2;
   this.next = this.numElements;
   if(this.next == this.maxSize) 
     this.next = 0;
  }

  
  
  public
  boolean wasEmpty() {
    return numElements == 1;
  }

  
  public
  boolean wasFull() {
    return (numElements+1 == maxSize);
  }

}
"
log4j,1.2,org.apache.log4j.spi.LoggingEvent,18,1,0,62,55,99,52,11,12,0.885154062,395,0.476190476,4,0.0,0.209150327,0,0,19.77777778,5,1.5556,5,"

package org.apache.log4j.spi;

import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Category;
import org.apache.log4j.Level;
import org.apache.log4j.MDC;
import org.apache.log4j.NDC;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.LogLog;






public class LoggingEvent implements java.io.Serializable {

  private static long startTime = System.currentTimeMillis();

  
  transient public final String fqnOfCategoryClass;

  
  transient private Category logger;

  
  final public String categoryName;

  
  transient public Priority level;

  
  private String ndc;

  
  private Hashtable mdcCopy;


  
  private boolean ndcLookupRequired = true;


  
  private boolean mdcCopyLookupRequired = true;

  
  transient private Object message;

  
  private String renderedMessage;

  
  private String threadName;


  
  private ThrowableInformation throwableInfo;

  
  public final long timeStamp;
  
  private LocationInfo locationInfo;

  
  static final long serialVersionUID = -868428216207166145L;

  static final Integer[] PARAM_ARRAY = new Integer[1];
  static final String TO_LEVEL = ""toLevel"";
  static final Class[] TO_LEVEL_PARAMS = new Class[] {int.class};
  static final Hashtable methodCache = new Hashtable(3); 

  
  public LoggingEvent(String fqnOfCategoryClass, Category logger,
		      Priority level, Object message, Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.logger = logger;
    this.categoryName = logger.getName();
    this.level = level;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable, logger);
    }
    timeStamp = System.currentTimeMillis();
  }

  
  public LoggingEvent(String fqnOfCategoryClass, Category logger,
		      long timeStamp, Priority level, Object message,
		      Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.logger = logger;
    this.categoryName = logger.getName();
    this.level = level;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable, logger);
    }

    this.timeStamp = timeStamp;
  }

    
    public LoggingEvent(final String fqnOfCategoryClass,
                        final Category logger,
                        final long timeStamp,
                        final Level level,
                        final Object message,
                        final String threadName,
                        final ThrowableInformation throwable,
                        final String ndc,
                        final LocationInfo info,
                        final java.util.Map properties) {
      super();
      this.fqnOfCategoryClass = fqnOfCategoryClass;
      this.logger = logger;
      if (logger != null) {
          categoryName = logger.getName();
      } else {
          categoryName = null;
      }
      this.level = level;
      this.message = message;
      if(throwable != null) {
        this.throwableInfo = throwable;
      }

      this.timeStamp = timeStamp;
      this.threadName = threadName;
      ndcLookupRequired = false;
      this.ndc = ndc;
      this.locationInfo = info;
      mdcCopyLookupRequired = false;
      if (properties != null) {
        mdcCopy = new java.util.Hashtable(properties);
      }
    }


  
  public LocationInfo getLocationInformation() {
    if(locationInfo == null) {
      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);
    }
    return locationInfo;
  }

  
  public Level getLevel() {
    return (Level) level;
  }

  
  public String getLoggerName() {
    return categoryName;
  }

    
    public Category getLogger() {
      return logger;
    }

  
  public
  Object getMessage() {
    if(message != null) {
      return message;
    } else {
      return getRenderedMessage();
    }
  }

  
  public
  String getNDC() {
    if(ndcLookupRequired) {
      ndcLookupRequired = false;
      ndc = NDC.get();
    }
    return ndc;
  }


  
  public
  Object getMDC(String key) {
    Object r;
    
    
    if(mdcCopy != null) {
      r = mdcCopy.get(key);
      if(r != null) {
        return r;
      }
    }
    return MDC.get(key);
  }

  
  public
  void getMDCCopy() {
    if(mdcCopyLookupRequired) {
      mdcCopyLookupRequired = false;
      
      
      Hashtable t = (Hashtable) MDC.getContext();
      if(t != null) {
	mdcCopy = (Hashtable) t.clone();
      }
    }
  }

  public
  String getRenderedMessage() {
     if(renderedMessage == null && message != null) {
       if(message instanceof String)
	 renderedMessage = (String) message;
       else {
	 LoggerRepository repository = logger.getLoggerRepository();

	 if(repository instanceof RendererSupport) {
	   RendererSupport rs = (RendererSupport) repository;
	   renderedMessage= rs.getRendererMap().findAndRender(message);
	 } else {
	   renderedMessage = message.toString();
	 }
       }
     }
     return renderedMessage;
  }

  
  public static long getStartTime() {
    return startTime;
  }

  public
  String getThreadName() {
    if(threadName == null)
      threadName = (Thread.currentThread()).getName();
    return threadName;
  }

  
  public
  ThrowableInformation getThrowableInformation() {
    return throwableInfo;
  }

  
  public
  String[] getThrowableStrRep() {

    if(throwableInfo ==  null)
      return null;
    else
      return throwableInfo.getThrowableStrRep();
  }


  private
  void readLevel(ObjectInputStream ois)
                      throws java.io.IOException, ClassNotFoundException {

    int p = ois.readInt();
    try {
      String className = (String) ois.readObject();
      if(className == null) {
	level = Level.toLevel(p);
      } else {
	Method m = (Method) methodCache.get(className);
	if(m == null) {
	  Class clazz = Loader.loadClass(className);
	  
	  
	  
	  
	  
	  
	  m = clazz.getDeclaredMethod(TO_LEVEL, TO_LEVEL_PARAMS);
	  methodCache.put(className, m);
	}
	level = (Level) m.invoke(null,  new Integer[] { new Integer(p) } );
      }
    } catch(InvocationTargetException e) {
        if (e.getTargetException() instanceof InterruptedException
                || e.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
    LogLog.warn(""Level deserialization failed, reverting to default."", e);
	level = Level.toLevel(p);
    } catch(NoSuchMethodException e) {
	LogLog.warn(""Level deserialization failed, reverting to default."", e);
	level = Level.toLevel(p);
    } catch(IllegalAccessException e) {
	LogLog.warn(""Level deserialization failed, reverting to default."", e);
	level = Level.toLevel(p);
    } catch(RuntimeException e) {
	LogLog.warn(""Level deserialization failed, reverting to default."", e);
	level = Level.toLevel(p);
    }
  }

  private void readObject(ObjectInputStream ois)
                        throws java.io.IOException, ClassNotFoundException {
    ois.defaultReadObject();
    readLevel(ois);

    
    if(locationInfo == null)
      locationInfo = new LocationInfo(null, null);
  }

  private
  void writeObject(ObjectOutputStream oos) throws java.io.IOException {
    
    
    this.getThreadName();

    
    this.getRenderedMessage();

    
    
    this.getNDC();

    
    
    this.getMDCCopy();

    
    this.getThrowableStrRep();

    oos.defaultWriteObject();

    
    writeLevel(oos);
  }

  private
  void writeLevel(ObjectOutputStream oos) throws java.io.IOException {

    oos.writeInt(level.toInt());

    Class clazz = level.getClass();
    if(clazz == Level.class) {
      oos.writeObject(null);
    } else {
      
      
      
      oos.writeObject(clazz.getName());
    }
  }

    
  public final void setProperty(final String propName,
                          final String propValue) {
        if (mdcCopy == null) {
            getMDCCopy();
        }
        if (mdcCopy == null) {
            mdcCopy = new Hashtable();
        }
        mdcCopy.put(propName, propValue);      
  }

    
    public final String getProperty(final String key) {
        Object value = getMDC(key);
        String retval = null;
        if (value != null) {
            retval = value.toString();
        }
        return retval;
    }

    
    public final boolean locationInformationExists() {
      return (locationInfo != null);
    }

    
    public final long getTimeStamp() {
      return timeStamp;
    }

    
    public Set getPropertyKeySet() {
      return getProperties().keySet();
    }

    
    public Map getProperties() {
      getMDCCopy();
      Map properties;
      if (mdcCopy == null) {
         properties = new HashMap();
      } else {
         properties = mdcCopy;
      }
      return Collections.unmodifiableMap(properties);
    }

    
    public String getFQNOfLoggerClass() {
      return fqnOfCategoryClass;
    }


    
    public Object removeProperty(String propName) {
        if (mdcCopy == null) {
            getMDCCopy();
        }
        if (mdcCopy == null) {
            mdcCopy = new Hashtable();
        }
        return mdcCopy.remove(propName);
    }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogTableRowRenderer,3,6,0,4,13,1,1,3,2,0.75,59,1.0,0,0.996992481,0.444444444,1,1,18.0,2,1.0,3,"
package org.apache.log4j.lf5.viewer;

import java.awt.Color;
import java.awt.Component;

import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;

import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;





public class LogTableRowRenderer extends DefaultTableCellRenderer {
  private static final long serialVersionUID = -3951639953706443213L;
  
  
  

  
  
  
  protected boolean _highlightFatal = true;
  protected Color _color = new Color(230, 230, 230);

  
  
  

  
  
  

  
  
  

  public Component getTableCellRendererComponent(JTable table,
      Object value,
      boolean isSelected,
      boolean hasFocus,
      int row,
      int col) {

    if ((row % 2) == 0) {
      setBackground(_color);
    } else {
      setBackground(Color.white);
    }

    FilteredLogTableModel model = (FilteredLogTableModel) table.getModel();
    LogRecord record = model.getFilteredRecord(row);

    setForeground(getLogLevelColor(record.getLevel()));

    return (super.getTableCellRendererComponent(table,
        value,
        isSelected,
        hasFocus,
        row, col));
  }


  
  
  
  protected Color getLogLevelColor(LogLevel level) {
    return (Color) LogLevel.getLogLevelColorMap().get(level);
  }

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.spi.RootCategory,4,3,0,6,7,6,2,4,4,2.0,30,0.0,0,0.945454545,0.875,1,1,6.5,2,1.0,2,"

package org.apache.log4j.spi;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.helpers.LogLog;




final public class RootCategory extends Logger {

  
  public
  RootCategory(Level level) {
    super(""root"");
    setLevel(level);
  }

  
  
  final
  public 
  Level getChainedLevel() {
    return level;
  }

  
  final  
  public
  void setLevel(Level level) {
    if(level == null) {
      LogLog.error(""You have tried to set a null level to root."",
		   new Throwable());
    }
    else {
      this.level = level;
    }
  }

  final  
  public
  void setPriority(Level level) {
    setLevel(level);
  }

  
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogFactor5ErrorDialog,1,7,0,4,14,0,3,2,1,2.0,56,0.0,0,1.0,1.0,0,0,55.0,0,0.0,2,"
package org.apache.log4j.lf5.viewer;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;





public class LogFactor5ErrorDialog extends LogFactor5Dialog {
  
  
  

  
  
  

  
  
  

  
  
  
  public LogFactor5ErrorDialog(JFrame jframe, String message) {
    super(jframe, ""Error"", true);

    JButton ok = new JButton(""Ok"");
    ok.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        hide();
      }
    });

    JPanel bottom = new JPanel();
    bottom.setLayout(new FlowLayout());
    bottom.add(ok);

    JPanel main = new JPanel();
    main.setLayout(new GridBagLayout());
    wrapStringOnPanel(message, main);

    getContentPane().add(main, BorderLayout.CENTER);
    getContentPane().add(bottom, BorderLayout.SOUTH);
    show();

  }
  
  
  

  
  
  

  
  
  

  
  
  
}"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryImmediateEditor,5,2,0,4,20,8,1,3,3,0.75,121,1.0,1,0.870967742,0.333333333,1,3,22.8,2,1.4,2,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.util.EventObject;

import javax.swing.Icon;
import javax.swing.JTree;
import javax.swing.tree.DefaultTreeCellEditor;
import javax.swing.tree.TreePath;





public class CategoryImmediateEditor extends DefaultTreeCellEditor {
  
  
  

  
  
  
  private CategoryNodeRenderer renderer;
  protected Icon editingIcon = null;

  
  
  

  
  
  
  public CategoryImmediateEditor(JTree tree,
      CategoryNodeRenderer renderer,
      CategoryNodeEditor editor) {
    super(tree, renderer, editor);
    this.renderer = renderer;
    renderer.setIcon(null);
    renderer.setLeafIcon(null);
    renderer.setOpenIcon(null);
    renderer.setClosedIcon(null);

    super.editingIcon = null;
  }

  
  
  
  public boolean shouldSelectCell(EventObject e) {
    boolean rv = false;  

    if (e instanceof MouseEvent) {
      MouseEvent me = (MouseEvent) e;
      TreePath path = tree.getPathForLocation(me.getX(),
          me.getY());
      CategoryNode node = (CategoryNode)
          path.getLastPathComponent();

      rv = node.isLeaf() ;
    }
    return rv;
  }

  public boolean inCheckBoxHitRegion(MouseEvent e) {
    TreePath path = tree.getPathForLocation(e.getX(),
        e.getY());
    if (path == null) {
      return false;
    }
    CategoryNode node = (CategoryNode) path.getLastPathComponent();
    boolean rv = false;

    if (true) {
      
      

      Rectangle bounds = tree.getRowBounds(lastRow);
      Dimension checkBoxOffset =
          renderer.getCheckBoxOffset();

      bounds.translate(offset + checkBoxOffset.width,
          checkBoxOffset.height);

      rv = bounds.contains(e.getPoint());
    }
    return true;
  }

  
  
  

  protected boolean canEditImmediately(EventObject e) {
    boolean rv = false;

    if (e instanceof MouseEvent) {
      MouseEvent me = (MouseEvent) e;
      rv = inCheckBoxHitRegion(me);
    }

    return rv;
  }

  protected void determineOffset(JTree tree, Object value,
      boolean isSelected, boolean expanded,
      boolean leaf, int row) {
    
    offset = 0;
  }

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.helpers.Transform,2,1,0,2,9,1,2,0,2,2.0,59,0.0,0,0.0,0.5,0,0,28.5,6,3.0,3,"

package org.apache.log4j.helpers;


public class Transform {

   private static final String CDATA_START  = ""<![CDATA["";
   private static final String CDATA_END    = ""]]>"";
   private static final String CDATA_PSEUDO_END = ""]]&gt;"";
   private static final String CDATA_EMBEDED_END = CDATA_END + CDATA_PSEUDO_END + CDATA_START;
   private static final int CDATA_END_LEN = CDATA_END.length();

  
  static public String escapeTags(final String input) {
    
    

    if(input == null
       || input.length() == 0
       || (input.indexOf('""') == -1 &&
           input.indexOf('&') == -1 &&
           input.indexOf('<') == -1 &&
           input.indexOf('>') == -1)) {
      return input;
    }

    
    

    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';

    int len = input.length();
    for(int i=0; i < len; i++) {
      ch = input.charAt(i);
      if (ch > '>') {
          buf.append(ch);
      } else if(ch == '<') {
	      buf.append(""&lt;"");
      } else if(ch == '>') {
	      buf.append(""&gt;"");
      } else if(ch == '&') {
	      buf.append(""&amp;"");
      } else if(ch == '""') {
	      buf.append(""&quot;"");
      } else {
	      buf.append(ch);
      }
    }
    return buf.toString();
  }

  
  static public void appendEscapingCDATA(final StringBuffer buf,
                                         final String str) {
      if (str != null) {
          int end = str.indexOf(CDATA_END);
          if (end < 0) {
              buf.append(str);
          } else {
              int start = 0;
              while (end > -1) {
                  buf.append(str.substring(start, end));
                  buf.append(CDATA_EMBEDED_END);
                  start = end + CDATA_END_LEN;
                  if (start < str.length()) {
                      end = str.indexOf(CDATA_END, start);
                  } else {
                      return;
                  }
              }
              buf.append(str.substring(start));
          }
      }
  }
}
"
log4j,1.2,org.apache.log4j.helpers.CyclicBuffer,7,1,0,2,13,0,1,1,7,0.333333333,246,0.0,1,0.0,0.523809524,0,0,33.42857143,7,2.7143,2,"
     
package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;


public class CyclicBuffer {
  
  LoggingEvent[] ea;
  int first; 
  int last; 
  int numElems;
  int maxSize;

  
  public CyclicBuffer(int maxSize) throws IllegalArgumentException {
    if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    ea = new LoggingEvent[maxSize];
    first = 0;
    last = 0;
    numElems = 0;
  }
    
  
  public
  void add(LoggingEvent event) {    
    ea[last] = event;    
    if(++last == maxSize)
      last = 0;

    if(numElems < maxSize)
      numElems++;
    else if(++first == maxSize)
      first = 0;
  }


  
  public
  LoggingEvent get(int i) {
    if(i < 0 || i >= numElems)
      return null;

    return ea[(first + i) % maxSize];
  }

  public 
  int getMaxSize() {
    return maxSize;
  }

  
  public
  LoggingEvent get() {
    LoggingEvent r = null;
    if(numElems > 0) {
      numElems--;
      r = ea[first];
      ea[first] = null;
      if(++first == maxSize)
	first = 0;
    } 
    return r;
  }
  
  
  public
  int length() {
    return numElems;
  } 

  
  public 
  void resize(int newSize) {
    if(newSize < 0) {
      throw new IllegalArgumentException(""Negative array size [""+newSize+
					 ""] not allowed."");
    }
    if(newSize == numElems)
      return; 
    
    LoggingEvent[] temp = new  LoggingEvent[newSize];

    int loopLen = newSize < numElems ? newSize : numElems;
    
    for(int i = 0; i < loopLen; i++) {
      temp[i] = ea[first];
      ea[first] = null;
      if(++first == numElems) 
	first = 0;
    }
    ea = temp;
    first = 0;
    numElems = loopLen;
    maxSize = newSize;
    if (loopLen == newSize) {
      last = 0;
    } else {
      last = loopLen;
    }
  }
}
"
log4j,1.2,org.apache.log4j.WriterAppender,20,2,2,10,40,112,4,6,13,0.684210526,296,1.0,1,0.514285714,0.19375,1,3,13.65,5,1.85,3,"

package org.apache.log4j;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;





public class WriterAppender extends AppenderSkeleton {


  
  protected boolean immediateFlush = true;

  
  protected String encoding;

  
  protected QuietWriter qw;


  
  public
  WriterAppender() {
  }

  
  public
  WriterAppender(Layout layout, OutputStream os) {
    this(layout, new OutputStreamWriter(os));
  }

  
  public
  WriterAppender(Layout layout, Writer writer) {
    this.layout = layout;
    this.setWriter(writer);
  }

  
  public
  void setImmediateFlush(boolean value) {
    immediateFlush = value;
  }

  
  public
  boolean getImmediateFlush() {
    return immediateFlush;
  }

  
  public
  void activateOptions() {
  }


  
  public
  void append(LoggingEvent event) {

    
    
    
    
    
    
    
    

    if(!checkEntryConditions()) {
      return;
    }
    subAppend(event);
   }

  
  protected
  boolean checkEntryConditions() {
    if(this.closed) {
      LogLog.warn(""Not allowed to write to a closed appender."");
      return false;
    }

    if(this.qw == null) {
      errorHandler.error(""No output stream or file set for the appender named [""+
			name+""]."");
      return false;
    }

    if(this.layout == null) {
      errorHandler.error(""No layout set for the appender named [""+ name+""]."");
      return false;
    }
    return true;
  }


  
  public
  synchronized
  void close() {
    if(this.closed)
      return;
    this.closed = true;
    writeFooter();
    reset();
  }

  
  protected void closeWriter() {
    if(qw != null) {
      try {
	qw.close();
      } catch(IOException e) {
          if (e instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	
	
	LogLog.error(""Could not close "" + qw, e);
      }
    }
  }

  
  protected
  OutputStreamWriter createWriter(OutputStream os) {
    OutputStreamWriter retval = null;

    String enc = getEncoding();
    if(enc != null) {
      try {
	retval = new OutputStreamWriter(os, enc);
      } catch(IOException e) {
          if (e instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	      LogLog.warn(""Error initializing output writer."");
	      LogLog.warn(""Unsupported encoding?"");
      }
    }
    if(retval == null) {
      retval = new OutputStreamWriter(os);
    }
    return retval;
  }

  public String getEncoding() {
    return encoding;
  }

  public void setEncoding(String value) {
    encoding = value;
  }




  
  public synchronized void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
      if(this.qw != null) {
	this.qw.setErrorHandler(eh);
      }
    }
  }

  
  public synchronized void setWriter(Writer writer) {
    reset();
    this.qw = new QuietWriter(writer, errorHandler);
    
    writeHeader();
  }


  
  protected
  void subAppend(LoggingEvent event) {
    this.qw.write(this.layout.format(event));

    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  this.qw.write(s[i]);
	  this.qw.write(Layout.LINE_SEP);
	}
      }
    }

    if(shouldFlush(event)) {
      this.qw.flush();
    }
  }



  
  public
  boolean requiresLayout() {
    return true;
  }

  
  protected
  void reset() {
    closeWriter();
    this.qw = null;
    
  }


  
  protected
  void writeFooter() {
    if(layout != null) {
      String f = layout.getFooter();
      if(f != null && this.qw != null) {
	this.qw.write(f);
	this.qw.flush();
      }
    }
  }

  
  protected
  void writeHeader() {
    if(layout != null) {
      String h = layout.getHeader();
      if(h != null && this.qw != null)
	this.qw.write(h);
    }
  }
  
  
  protected boolean shouldFlush(final LoggingEvent event) {
     return immediateFlush;
  }
}
"
log4j,1.2,org.apache.log4j.helpers.SyslogQuietWriter,4,4,0,3,10,0,1,2,4,0.5,41,0.0,0,0.875,0.5,2,2,8.75,1,0.75,2,"

package org.apache.log4j.helpers;



import java.io.Writer;
import org.apache.log4j.spi.ErrorHandler;


public class SyslogQuietWriter extends QuietWriter {

  int syslogFacility;
  int level;

  public
  SyslogQuietWriter(Writer writer, int syslogFacility, ErrorHandler eh) {
    super(writer, eh);
    this.syslogFacility = syslogFacility;
  }

  public
  void setLevel(int level) {
    this.level = level;
  }

  public
  void setSyslogFacility(int syslogFacility) {
    this.syslogFacility = syslogFacility;
  }

  public
  void write(String string) {
    super.write(""<""+(syslogFacility | level)+"">"" + string);
  }
}
"
log4j,1.2,org.apache.log4j.helpers.SyslogWriter,5,2,0,2,18,8,1,1,5,0.75,88,0.5,0,0.764705882,0.45,1,2,15.8,1,0.8,7,"

package org.apache.log4j.helpers;


import java.io.Writer;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import java.io.IOException;
import java.net.URL;
import java.net.MalformedURLException;


public class SyslogWriter extends Writer {

  final int SYSLOG_PORT = 514;
  
  static String syslogHost;
  
  private InetAddress address;
  private final int port;
  private DatagramSocket ds;

  
  public
  SyslogWriter(final String syslogHost) {
    SyslogWriter.syslogHost = syslogHost;
    if (syslogHost == null) {
        throw new NullPointerException(""syslogHost"");
    }
    
    String host = syslogHost;
    int urlPort = -1;
    
    
    
    
    
    if (host.indexOf(""["") != -1 || host.indexOf(':') == host.lastIndexOf(':')) {
        try {
            URL url = new URL(""http:
            if (url.getHost() != null) {
                host = url.getHost();
                
                if(host.startsWith(""["") && host.charAt(host.length() - 1) == ']') {
                    host = host.substring(1, host.length() - 1);
                }
                urlPort = url.getPort();
            }
        } catch(MalformedURLException e) {
      		LogLog.error(""Malformed URL: will attempt to interpret as InetAddress."", e);
        }
    }
    
    if (urlPort == -1) {
        urlPort = SYSLOG_PORT;
    }
    port = urlPort;

    try {      
      this.address = InetAddress.getByName(host);
    }
    catch (UnknownHostException e) {
      LogLog.error(""Could not find "" + host +
			 "". All logging will FAIL."", e);
    }

    try {
      this.ds = new DatagramSocket();
    }
    catch (SocketException e) {
      e.printStackTrace();
      LogLog.error(""Could not instantiate DatagramSocket to "" + host +
			 "". All logging will FAIL."", e);
    }
    
  }


  public
  void write(char[] buf, int off, int len) throws IOException {
    this.write(new String(buf, off, len));
  }
  
  public
  void write(final String string) throws IOException {

    if(this.ds != null && this.address != null) {
        byte[] bytes = string.getBytes();
        
        
        
        int bytesLength = bytes.length;
        if (bytesLength >= 1024) {
            bytesLength = 1024;
        }
        DatagramPacket packet = new DatagramPacket(bytes, bytesLength,
                               address, port);
        ds.send(packet);
    }
    
  }

  public
  void flush() {}

  public void close() {
      if (ds != null) {
          ds.close();
      }
  }
}
"
log4j,1.2,org.apache.log4j.chainsaw.LoggingReceiver,6,2,0,5,25,5,2,4,1,0.8,94,0.75,2,0.938461538,0.24,1,1,14.0,1,0.6667,3,"
package org.apache.log4j.chainsaw;

import java.io.EOFException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import org.apache.log4j.Logger;
import org.apache.log4j.spi.LoggingEvent;


class LoggingReceiver extends Thread {
    
    private static final Logger LOG = Logger.getLogger(LoggingReceiver.class);

    
    private class Slurper implements Runnable {
        
        private final Socket mClient;

        
        Slurper(Socket aClient) {
            mClient = aClient;
        }

        
        public void run() {
            LOG.debug(""Starting to get data"");
            try {
                final ObjectInputStream ois =
                    new ObjectInputStream(mClient.getInputStream());
                while (true) {
                    final LoggingEvent event = (LoggingEvent) ois.readObject();
                    mModel.addEvent(new EventDetails(event));
                }
            } catch (EOFException e) {
                LOG.info(""Reached EOF, closing connection"");
            } catch (SocketException e) {
                LOG.info(""Caught SocketException, closing connection"");
            } catch (IOException e) {
                LOG.warn(""Got IOException, closing connection"", e);
            } catch (ClassNotFoundException e) {
                LOG.warn(""Got ClassNotFoundException, closing connection"", e);
            }

            try {
                mClient.close();
            } catch (IOException e) {
                LOG.warn(""Error closing connection"", e);
            }
        }
    }

    
    private MyTableModel mModel;

    
    private ServerSocket mSvrSock;
    
    
    LoggingReceiver(MyTableModel aModel, int aPort) throws IOException {
        setDaemon(true);
        mModel = aModel;
        mSvrSock = new ServerSocket(aPort);
    }

    
    public void run() {
        LOG.info(""Thread started"");
        try {
            while (true) {
                LOG.debug(""Waiting for a connection"");
                final Socket client = mSvrSock.accept();
                LOG.debug(""Got a connection from "" +
                          client.getInetAddress().getHostName());
                final Thread t = new Thread(new Slurper(client));
                t.setDaemon(true);
                t.start();
            }
        } catch (IOException e) {
            LOG.error(""Error in accepting connections, stopping."", e);
        }
    }
}
"
log4j,1.2,org.apache.log4j.spi.ErrorCode,0,1,0,0,0,0,0,0,0,2.0,7,0.0,0,0.0,0.0,0,0,0.0,0,0.0,2,"

package org.apache.log4j.spi;



public interface ErrorCode {

  public final int GENERIC_FAILURE = 0;
  public final int WRITE_FAILURE = 1;
  public final int FLUSH_FAILURE = 2;
  public final int CLOSE_FAILURE = 3;
  public final int FILE_OPEN_FAILURE = 4;
  public final int MISSING_LAYOUT = 5;
  public final int ADDRESS_PARSE_FAILURE = 6;
}
"
log4j,1.2,org.apache.log4j.lf5.AppenderFinalizer,2,1,0,2,5,0,1,1,1,0.0,19,1.0,1,0.0,0.75,0,0,8.0,1,0.5,2,"
package org.apache.log4j.lf5;

import org.apache.log4j.lf5.viewer.LogBrokerMonitor;





public class AppenderFinalizer {
  
  
  

  
  
  

  protected LogBrokerMonitor _defaultMonitor = null;

  
  
  

  
  
  

  public AppenderFinalizer(LogBrokerMonitor defaultMonitor) {
    _defaultMonitor = defaultMonitor;
  }
  
  
  

  
  
  

  
  protected void finalize() throws Throwable {
    System.out.println(""Disposing of the default LogBrokerMonitor instance"");
    _defaultMonitor.dispose();
  }

  
  
  

  
  
  

}"
log4j,1.2,org.apache.log4j.helpers.AppenderAttachableImpl,9,1,0,6,23,0,3,3,9,0.125,208,1.0,0,0.0,0.416666667,0,0,22.0,5,3.3333,2,"

package org.apache.log4j.helpers;

import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;

import org.apache.log4j.Appender;
import java.util.Vector;
import java.util.Enumeration;


public class AppenderAttachableImpl implements AppenderAttachable {
  
  
  protected Vector  appenderList;

  
  public
  void addAppender(Appender newAppender) {
    
    if(newAppender == null)
      return;
    
    if(appenderList == null) {
      appenderList = new Vector(1);
    }
    if(!appenderList.contains(newAppender))
      appenderList.addElement(newAppender);
  }

  
  public
  int appendLoopOnAppenders(LoggingEvent event) {
    int size = 0;
    Appender appender;

    if(appenderList != null) {
      size = appenderList.size();
      for(int i = 0; i < size; i++) {
	appender = (Appender) appenderList.elementAt(i);
	appender.doAppend(event);
      }
    }    
    return size;
  }


  
  public
  Enumeration getAllAppenders() {
    if(appenderList == null)
      return null;
    else 
      return appenderList.elements();    
  }

  
  public
  Appender getAppender(String name) {
     if(appenderList == null || name == null)
      return null;

     int size = appenderList.size();
     Appender appender;
     for(int i = 0; i < size; i++) {
       appender = (Appender) appenderList.elementAt(i);
       if(name.equals(appender.getName()))
	  return appender;
     }
     return null;    
  }


  
  public 
  boolean isAttached(Appender appender) {
    if(appenderList == null || appender == null)
      return false;

     int size = appenderList.size();
     Appender a;
     for(int i = 0; i < size; i++) {
       a  = (Appender) appenderList.elementAt(i);
       if(a == appender)
	  return true;
     }
     return false;    
  }



  
  public
  void removeAllAppenders() {
    if(appenderList != null) {
      int len = appenderList.size();      
      for(int i = 0; i < len; i++) {
	Appender a = (Appender) appenderList.elementAt(i);
	a.close();
      }
      appenderList.removeAllElements();
      appenderList = null;      
    }
  }


  
  public
  void removeAppender(Appender appender) {
    if(appender == null || appenderList == null) 
      return;
    appenderList.removeElement(appender);    
  }


 
  public
  void removeAppender(String name) {
    if(name == null || appenderList == null) return;
    int size = appenderList.size();
    for(int i = 0; i < size; i++) {
      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {
	 appenderList.removeElementAt(i);
	 break;
      }
    }
  }

}
"
log4j,1.2,org.apache.log4j.lf5.util.Resource,7,1,0,3,11,15,3,1,7,0.666666667,49,1.0,0,0.0,0.642857143,0,0,5.857142857,2,0.8571,2,"
package org.apache.log4j.lf5.util;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;





public class Resource {
  
  
  

  
  
  
  protected String _name;

  
  
  

  
  
  

  
  public Resource() {
    super();
  }

  
  public Resource(String name) {
    _name = name;
  }

  
  
  

  
  public void setName(String name) {
    _name = name;
  }

  
  public String getName() {
    return (_name);
  }

  
  public InputStream getInputStream() {
    InputStream in = ResourceUtils.getResourceAsStream(this, this);

    return (in);
  }

  
  public InputStreamReader getInputStreamReader() {
    InputStream in = ResourceUtils.getResourceAsStream(this, this);

    if (in == null) {
      return null;
    }

    InputStreamReader reader = new InputStreamReader(in);

    return reader;
  }

  
  public URL getURL() {
    return (ResourceUtils.getResourceAsURL(this, this));
  }

  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.lf5.LogRecord,28,1,2,17,46,306,16,1,26,0.912457912,236,1.0,1,0.0,0.259259259,0,0,7.035714286,4,1.1429,2,"
package org.apache.log4j.lf5;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;





public abstract class LogRecord implements java.io.Serializable {
  
  
  

  
  
  
  protected static long _seqCount = 0;

  protected LogLevel _level;
  protected String _message;
  protected long _sequenceNumber;
  protected long _millis;
  protected String _category;
  protected String _thread;
  protected String _thrownStackTrace;
  protected Throwable _thrown;
  protected String _ndc;
  protected String _location;

  
  
  

  
  
  

  public LogRecord() {
    super();

    _millis = System.currentTimeMillis();
    _category = ""Debug"";
    _message = """";
    _level = LogLevel.INFO;
    _sequenceNumber = getNextId();
    _thread = Thread.currentThread().toString();
    _ndc = """";
    _location = """";
  }

  
  
  

  
  public LogLevel getLevel() {
    return (_level);
  }

  
  public void setLevel(LogLevel level) {
    _level = level;
  }

  
  public abstract boolean isSevereLevel();

  
  public boolean hasThrown() {
    Throwable thrown = getThrown();
    if (thrown == null) {
      return false;
    }
    String thrownString = thrown.toString();
    return thrownString != null && thrownString.trim().length() != 0;
  }

  
  public boolean isFatal() {
    return isSevereLevel() || hasThrown();
  }

  
  public String getCategory() {
    return (_category);
  }

  
  public void setCategory(String category) {
    _category = category;
  }

  
  public String getMessage() {
    return (_message);
  }

  
  public void setMessage(String message) {
    _message = message;
  }

  
  public long getSequenceNumber() {
    return (_sequenceNumber);
  }

  
  public void setSequenceNumber(long number) {
    _sequenceNumber = number;
  }

  
  public long getMillis() {
    return _millis;
  }

  
  public void setMillis(long millis) {
    _millis = millis;
  }

  
  public String getThreadDescription() {
    return (_thread);
  }

  
  public void setThreadDescription(String threadDescription) {
    _thread = threadDescription;
  }

  
  public String getThrownStackTrace() {
    return (_thrownStackTrace);
  }

  
  public void setThrownStackTrace(String trace) {
    _thrownStackTrace = trace;
  }

  
  public Throwable getThrown() {
    return (_thrown);
  }

  
  public void setThrown(Throwable thrown) {
    if (thrown == null) {
      return;
    }
    _thrown = thrown;
    StringWriter sw = new StringWriter();
    PrintWriter out = new PrintWriter(sw);
    thrown.printStackTrace(out);
    out.flush();
    _thrownStackTrace = sw.toString();
    try {
      out.close();
      sw.close();
    } catch (IOException e) {
      
    }
    out = null;
    sw = null;
  }

  
  public String toString() {
    StringBuffer buf = new StringBuffer();
    buf.append(""LogRecord: ["" + _level + "", "" + _message + ""]"");
    return (buf.toString());
  }

  
  public String getNDC() {
    return _ndc;
  }

  
  public void setNDC(String ndc) {
    _ndc = ndc;
  }

  
  public String getLocation() {
    return _location;
  }

  
  public void setLocation(String location) {
    _location = location;
  }

  
  public static synchronized void resetSequenceNumber() {
    _seqCount = 0;
  }

  
  
  

  protected static synchronized long getNextId() {
    _seqCount++;
    return _seqCount;
  }
  
  
  

  
  
  

}



"
log4j,1.2,org.apache.log4j.helpers.AbsoluteTimeDateFormat,5,3,2,4,17,8,4,0,4,1.1,148,0.4,0,0.951219512,0.357142857,1,3,27.6,7,1.6,3,"

package org.apache.log4j.helpers;

import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;



public class AbsoluteTimeDateFormat extends DateFormat {
   private static final long serialVersionUID = -388856345976723342L;

  
  public final static String ABS_TIME_DATE_FORMAT = ""ABSOLUTE"";

  
  public final static String DATE_AND_TIME_DATE_FORMAT = ""DATE"";

  
  public final static String ISO8601_DATE_FORMAT = ""ISO8601"";

  public
  AbsoluteTimeDateFormat() {
    setCalendar(Calendar.getInstance());
  }
  
  public
  AbsoluteTimeDateFormat(TimeZone timeZone) {
    setCalendar(Calendar.getInstance(timeZone));
  }

  private static long   previousTime;
  private static char[] previousTimeWithoutMillis = new char[9]; 

  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    long now = date.getTime();
    int millis = (int)(now % 1000);

    if ((now - millis) != previousTime || previousTimeWithoutMillis[0] == 0) {
      
      
      

      calendar.setTime(date);

      int start = sbuf.length();
      
      int hour = calendar.get(Calendar.HOUR_OF_DAY);
      if(hour < 10) {
	sbuf.append('0');
      }
      sbuf.append(hour);
      sbuf.append(':');
      
      int mins = calendar.get(Calendar.MINUTE);
      if(mins < 10) {
	sbuf.append('0');
      }
      sbuf.append(mins);
      sbuf.append(':');
      
      int secs = calendar.get(Calendar.SECOND);
      if(secs < 10) {
	sbuf.append('0');
      }
      sbuf.append(secs);
      sbuf.append(',');      

      
      sbuf.getChars(start, sbuf.length(), previousTimeWithoutMillis, 0);
      
      previousTime = now - millis;
    }
    else {
      sbuf.append(previousTimeWithoutMillis);
    }
    

    
    if(millis < 100) 
      sbuf.append('0');
    if(millis < 10) 
      sbuf.append('0');
    
    sbuf.append(millis);
    return sbuf;
  }

  
  public
  Date parse(String s, ParsePosition pos) {
    return null;
  }  
}
"
log4j,1.2,org.apache.log4j.helpers.ThreadLocalMap,2,3,0,1,4,1,1,0,2,2.0,15,0.0,0,0.933333333,0.75,0,0,6.5,2,1.0,2,"

package org.apache.log4j.helpers;

import java.util.Hashtable;


final public class ThreadLocalMap extends InheritableThreadLocal {

  public
  final
  Object childValue(Object parentValue) {
    Hashtable ht = (Hashtable) parentValue;
    if(ht != null) {
      return ht.clone();
    } else {
      return null;
    }
  }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.configure.MRUFileManager,17,1,0,1,51,84,1,0,11,0.864583333,344,0.666666667,0,0.0,0.305882353,0,0,18.88235294,4,1.5294,2,"
package org.apache.log4j.lf5.viewer.configure;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.URL;
import java.util.Iterator;
import java.util.LinkedList;






public class MRUFileManager {
  
  
  
  private static final String CONFIG_FILE_NAME = ""mru_file_manager"";
  private static final int DEFAULT_MAX_SIZE = 3;

  
  
  

  
  
  
  private int _maxSize = 0;
  private LinkedList _mruFileList;

  
  
  
  public MRUFileManager() {
    load();
    setMaxSize(DEFAULT_MAX_SIZE);
  }

  public MRUFileManager(int maxSize) {
    load();
    setMaxSize(maxSize);
  }
  
  
  

  
  public void save() {
    File file = new File(getFilename());

    try {
      ObjectOutputStream oos = new ObjectOutputStream(new
          FileOutputStream(file));
      oos.writeObject(_mruFileList);
      oos.flush();
      oos.close();
    } catch (Exception e) {
      
      e.printStackTrace();
    }
  }

  
  public int size() {
    return _mruFileList.size();
  }

  
  public Object getFile(int index) {
    if (index < size()) {
      return _mruFileList.get(index);
    }

    return null;
  }

  
  public InputStream getInputStream(int index) throws IOException,
      FileNotFoundException {
    if (index < size()) {
      Object o = getFile(index);
      if (o instanceof File) {
        return getInputStream((File) o);
      } else {
        return getInputStream((URL) o);
      }
    }
    return null;
  }

  
  public void set(File file) {
    setMRU(file);
  }

  
  public void set(URL url) {
    setMRU(url);
  }

  
  public String[] getMRUFileList() {
    if (size() == 0) {
      return null;
    }

    String[] ss = new String[size()];

    for (int i = 0; i < size(); i++) {
      Object o = getFile(i);
      if (o instanceof File) {
        ss[i] = ((File) o).getAbsolutePath();
      } else 
      {
        ss[i] = o.toString();
      }

    }

    return ss;
  }

  
  public void moveToTop(int index) {
    _mruFileList.add(0, _mruFileList.remove(index));
  }

  
  public static void createConfigurationDirectory() {
    String home = System.getProperty(""user.home"");
    String sep = System.getProperty(""file.separator"");
    File f = new File(home + sep + ""lf5"");
    if (!f.exists()) {
      try {
        f.mkdir();
      } catch (SecurityException e) {
        e.printStackTrace();
      }
    }

  }
  
  
  
  
  protected InputStream getInputStream(File file) throws IOException,
      FileNotFoundException {
    BufferedInputStream reader =
        new BufferedInputStream(new FileInputStream(file));

    return reader;
  }

  
  protected InputStream getInputStream(URL url) throws IOException {
    return url.openStream();
  }

  
  protected void setMRU(Object o) {
    int index = _mruFileList.indexOf(o);

    if (index == -1) {
      _mruFileList.add(0, o);
      setMaxSize(_maxSize);
    } else {
      moveToTop(index);
    }
  }

  
  protected void load() {
    createConfigurationDirectory();
    File file = new File(getFilename());
    if (file.exists()) {
      try {
        ObjectInputStream ois = new ObjectInputStream(
            new FileInputStream(file));
        _mruFileList = (LinkedList) ois.readObject();
        ois.close();

        
        Iterator it = _mruFileList.iterator();
        while (it.hasNext()) {
          Object o = it.next();
          if (!(o instanceof File) && !(o instanceof URL)) {
            it.remove();
          }
        }
      } catch (Exception e) {
        _mruFileList = new LinkedList();
      }
    } else {
      _mruFileList = new LinkedList();
    }

  }

  protected String getFilename() {
    String home = System.getProperty(""user.home"");
    String sep = System.getProperty(""file.separator"");

    return home + sep + ""lf5"" + sep + CONFIG_FILE_NAME;
  }

  
  protected void setMaxSize(int maxSize) {
    if (maxSize < _mruFileList.size()) {
      for (int i = 0; i < _mruFileList.size() - maxSize; i++) {
        _mruFileList.removeLast();
      }
    }

    _maxSize = maxSize;
  }
  
  
  

  
  
  
}"
log4j,1.2,org.apache.log4j.or.ObjectRenderer,1,1,0,8,1,0,8,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"

package org.apache.log4j.or;


public interface ObjectRenderer {

  
  public
  String doRender(Object o);
}
"
log4j,1.2,org.apache.log4j.net.SocketNode,4,1,0,9,25,0,3,6,2,0.733333333,126,0.0,2,0.0,0.416666667,0,0,29.25,2,0.75,2,"

package org.apache.log4j.net;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.net.Socket;

import org.apache.log4j.Logger;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.LoggingEvent;




public class SocketNode implements Runnable {

  Socket socket;
  LoggerRepository hierarchy;
  ObjectInputStream ois;

  static Logger logger = Logger.getLogger(SocketNode.class);

  public SocketNode(Socket socket, LoggerRepository hierarchy) {
    this.socket = socket;
    this.hierarchy = hierarchy;
    try {
      ois = new ObjectInputStream(
                         new BufferedInputStream(socket.getInputStream()));
    } catch(InterruptedIOException e) {
      Thread.currentThread().interrupt();
      logger.error(""Could not open ObjectInputStream to ""+socket, e);
    } catch(IOException e) {
      logger.error(""Could not open ObjectInputStream to ""+socket, e);
    } catch(RuntimeException e) {
      logger.error(""Could not open ObjectInputStream to ""+socket, e);
    }
  }

  
  
  
  
  

  public void run() {
    LoggingEvent event;
    Logger remoteLogger;

    try {
      if (ois != null) {
          while(true) {
	        
	        event = (LoggingEvent) ois.readObject();
	        
	        remoteLogger = hierarchy.getLogger(event.getLoggerName());
	        
	        
	        if(event.getLevel().isGreaterOrEqual(remoteLogger.getEffectiveLevel())) {
	        
	        remoteLogger.callAppenders(event);
	      }
        }
      }
    } catch(java.io.EOFException e) {
      logger.info(""Caught java.io.EOFException closing conneciton."");
    } catch(java.net.SocketException e) {
      logger.info(""Caught java.net.SocketException closing conneciton."");
    } catch(InterruptedIOException e) {
      Thread.currentThread().interrupt();
      logger.info(""Caught java.io.InterruptedIOException: ""+e);
      logger.info(""Closing connection."");
    } catch(IOException e) {
      logger.info(""Caught java.io.IOException: ""+e);
      logger.info(""Closing connection."");
    } catch(Exception e) {
      logger.error(""Unexpected exception. Closing conneciton."", e);
    } finally {
      if (ois != null) {
         try {
            ois.close();
         } catch(Exception e) {
            logger.info(""Could not close connection."", e);
         }
      }
      if (socket != null) {
        try {
          socket.close();
        } catch(InterruptedIOException e) {
            Thread.currentThread().interrupt();
        } catch(IOException ex) {
        }
      }
    }
  }
}
"
log4j,1.2,org.apache.log4j.spi.TriggeringEventEvaluator,1,1,0,3,1,0,2,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;


public interface TriggeringEventEvaluator {
  
  
  public boolean isTriggeringEvent(LoggingEvent event);
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogTable,10,5,0,20,41,25,16,5,8,0.930555556,311,1.0,2,0.989130435,0.28,3,3,28.5,3,1.5,3,"
package org.apache.log4j.lf5.viewer;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;

import org.apache.log4j.lf5.util.DateFormatManager;





public class LogTable extends JTable {
  private static final long serialVersionUID = 4867085140195148458L;
  
  
  

  
  
  
  protected int _rowHeight = 30;
  protected JTextArea _detailTextArea;

  
  protected int _numCols = 9;
  protected TableColumn[] _tableColumns = new TableColumn[_numCols];
  protected int[] _colWidths = {40, 40, 40, 70, 70, 360, 440, 200, 60};
  protected LogTableColumn[] _colNames = LogTableColumn.getLogTableColumnArray();
  protected int _colDate = 0;
  protected int _colThread = 1;
  protected int _colMessageNum = 2;
  protected int _colLevel = 3;
  protected int _colNDC = 4;
  protected int _colCategory = 5;
  protected int _colMessage = 6;
  protected int _colLocation = 7;
  protected int _colThrown = 8;

  protected DateFormatManager _dateFormatManager = null;

  
  
  

  
  
  

  public LogTable(JTextArea detailTextArea) {
    super();

    init();

    _detailTextArea = detailTextArea;

    setModel(new FilteredLogTableModel());

    Enumeration columns = getColumnModel().getColumns();
    int i = 0;
    while (columns.hasMoreElements()) {
      TableColumn col = (TableColumn) columns.nextElement();
      col.setCellRenderer(new LogTableRowRenderer());
      col.setPreferredWidth(_colWidths[i]);

      _tableColumns[i] = col;
      i++;
    }

    ListSelectionModel rowSM = getSelectionModel();
    rowSM.addListSelectionListener(new LogTableListSelectionListener(this));

    
  }

  
  
  

  
  public DateFormatManager getDateFormatManager() {
    return _dateFormatManager;
  }

  
  public void setDateFormatManager(DateFormatManager dfm) {
    _dateFormatManager = dfm;
  }

  public synchronized void clearLogRecords() {
    
    

    
    getFilteredLogTableModel().clear();
  }

  public FilteredLogTableModel getFilteredLogTableModel() {
    return (FilteredLogTableModel) getModel();
  }

  
  public void setDetailedView() {
    
    TableColumnModel model = getColumnModel();
    
    for (int f = 0; f < _numCols; f++) {
      model.removeColumn(_tableColumns[f]);
    }
    
    for (int i = 0; i < _numCols; i++) {
      model.addColumn(_tableColumns[i]);
    }
    
    sizeColumnsToFit(-1);
  }

  public void setView(List columns) {
    TableColumnModel model = getColumnModel();

    
    for (int f = 0; f < _numCols; f++) {
      model.removeColumn(_tableColumns[f]);
    }
    Iterator selectedColumns = columns.iterator();
    Vector columnNameAndNumber = getColumnNameAndNumber();
    while (selectedColumns.hasNext()) {
      
      model.addColumn(_tableColumns[columnNameAndNumber.indexOf(selectedColumns.next())]);
    }

    
    sizeColumnsToFit(-1);
  }

  public void setFont(Font font) {
    super.setFont(font);
    Graphics g = this.getGraphics();
    if (g != null) {
      FontMetrics fm = g.getFontMetrics(font);
      int height = fm.getHeight();
      _rowHeight = height + height / 3;
      setRowHeight(_rowHeight);
    }


  }


  
  
  

  protected void init() {
    setRowHeight(_rowHeight);
    setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  }

  
  protected Vector getColumnNameAndNumber() {
    Vector columnNameAndNumber = new Vector();
    for (int i = 0; i < _colNames.length; i++) {
      columnNameAndNumber.add(i, _colNames[i]);
    }
    return columnNameAndNumber;
  }

  
  
  

  
  
  

  class LogTableListSelectionListener implements ListSelectionListener {
    protected JTable _table;

    public LogTableListSelectionListener(JTable table) {
      _table = table;
    }

    public void valueChanged(ListSelectionEvent e) {
      
      if (e.getValueIsAdjusting()) {
        return;
      }

      ListSelectionModel lsm = (ListSelectionModel) e.getSource();
      if (lsm.isSelectionEmpty()) {
        
      } else {
        StringBuffer buf = new StringBuffer();
        int selectedRow = lsm.getMinSelectionIndex();

        for (int i = 0; i < _numCols - 1; i++) {
          String value = """";
          Object obj = _table.getModel().getValueAt(selectedRow, i);
          if (obj != null) {
            value = obj.toString();
          }

          buf.append(_colNames[i] + "":"");
          buf.append(""\t"");

          if (i == _colThread || i == _colMessage || i == _colLevel) {
            buf.append(""\t""); 
          }

          if (i == _colDate || i == _colNDC) {
            buf.append(""\t\t""); 
          }






          buf.append(value);
          buf.append(""\n"");
        }
        buf.append(_colNames[_numCols - 1] + "":\n"");
        Object obj = _table.getModel().getValueAt(selectedRow, _numCols - 1);
        if (obj != null) {
          buf.append(obj.toString());
        }

        _detailTextArea.setText(buf.toString());
      }
    }
  }
}






"
log4j,1.2,org.apache.log4j.AppenderSkeleton,20,1,12,27,31,140,18,9,19,0.879699248,175,1.0,5,0.0,0.2,0,0,7.4,4,1.35,4,"

package org.apache.log4j;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.helpers.LogLog;



public abstract class AppenderSkeleton implements Appender, OptionHandler {

  
  protected Layout layout;

  
  protected String name;

  
  protected Priority threshold;

  
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();

  
  protected Filter headFilter;
  
  protected Filter tailFilter;

  
  protected boolean closed = false;

    
    public AppenderSkeleton() {
        super();
    }

    
    protected AppenderSkeleton(final boolean isActive) {
        super();
    }



  
  public
  void activateOptions() {
  }


  
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.setNext(newFilter);
      tailFilter = newFilter;    
    }
  }

  
  abstract
  protected
  void append(LoggingEvent event);


  
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }

  
  public
  void finalize() {
    
    
    if(this.closed) 
      return;

    LogLog.debug(""Finalizing appender named [""+name+""]."");
    close();
  }


  
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }


  
  public
  Filter getFilter() {
    return headFilter;
  }

  
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }

  
  public
  Layout getLayout() {
    return layout;
  }


  
  public
  final
  String getName() {
    return this.name;
  }

  
  public
  Priority getThreshold() {
    return threshold;
  }


  
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }


  
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error(""Attempted to append to closed appender named [""+name+""]."");
      return;
    }
    
    if(!isAsSevereAsThreshold(event.getLevel())) {
      return;
    }

    Filter f = this.headFilter;
    
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.getNext();
      }
    }
    
    this.append(event);    
  }

  
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      
      
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
    }
  }

  
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }

  
  
  public
  void setName(String name) {
    this.name = name;
  }


  
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }  
}
"
log4j,1.2,org.apache.log4j.Level,6,2,0,24,9,0,24,1,4,0.2,146,0.0,7,0.666666667,0.45,0,0,22.16666667,9,3.3333,5,"




package org.apache.log4j;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.Serializable;


public class Level extends Priority implements Serializable {

   
  public static final int TRACE_INT = 5000;

  
  final static public Level OFF = new Level(OFF_INT, ""OFF"", 0);

  
  final static public Level FATAL = new Level(FATAL_INT, ""FATAL"", 0);

  
  final static public Level ERROR = new Level(ERROR_INT, ""ERROR"", 3);

  
  final static public Level WARN  = new Level(WARN_INT, ""WARN"",  4);

  
  final static public Level INFO  = new Level(INFO_INT, ""INFO"",  6);

  
  final static public Level DEBUG = new Level(DEBUG_INT, ""DEBUG"", 7);

  
  public static final Level TRACE = new Level(TRACE_INT, ""TRACE"", 7);


  
  final static public Level ALL = new Level(ALL_INT, ""ALL"", 7);

  
  static final long serialVersionUID = 3491141966387921974L;

  
  protected
  Level(int level, String levelStr, int syslogEquivalent) {
    super(level, levelStr, syslogEquivalent);
  }


  
  public
  static
  Level toLevel(String sArg) {
    return (Level) toLevel(sArg, Level.DEBUG);
  }

  
  public
  static
  Level toLevel(int val) {
    return (Level) toLevel(val, Level.DEBUG);
  }

  
  public
  static
  Level toLevel(int val, Level defaultLevel) {
    switch(val) {
    case ALL_INT: return ALL;
    case DEBUG_INT: return Level.DEBUG;
    case INFO_INT: return Level.INFO;
    case WARN_INT: return Level.WARN;
    case ERROR_INT: return Level.ERROR;
    case FATAL_INT: return Level.FATAL;
    case OFF_INT: return OFF;
    case TRACE_INT: return Level.TRACE;
    default: return defaultLevel;
    }
  }

  
  public
  static
  Level toLevel(String sArg, Level defaultLevel) {                  
    if(sArg == null)
       return defaultLevel;
    
    String s = sArg.toUpperCase();

    if(s.equals(""ALL"")) return Level.ALL; 
    if(s.equals(""DEBUG"")) return Level.DEBUG; 
    if(s.equals(""INFO""))  return Level.INFO;
    if(s.equals(""WARN""))  return Level.WARN;  
    if(s.equals(""ERROR"")) return Level.ERROR;
    if(s.equals(""FATAL"")) return Level.FATAL;
    if(s.equals(""OFF"")) return Level.OFF;
    if(s.equals(""TRACE"")) return Level.TRACE;
    
    
    
    if(s.equals(""\u0130NFO"")) return Level.INFO;
    return defaultLevel;
  }

    
    private void readObject(final ObjectInputStream s) throws IOException, ClassNotFoundException {
      s.defaultReadObject();
      level = s.readInt();
      syslogEquivalent = s.readInt();
      levelStr = s.readUTF();
      if (levelStr == null) {
          levelStr = """";
      }
    }

    
    private void writeObject(final ObjectOutputStream s) throws IOException {
        s.defaultWriteObject();
        s.writeInt(level);
        s.writeInt(syslogEquivalent);
        s.writeUTF(levelStr);
    }

    
    private Object readResolve() throws ObjectStreamException {
        
        
        
        if (getClass() == Level.class) {
            return toLevel(level);
        }
        
        
        
        return this;
    }

}
"
log4j,1.2,org.apache.log4j.helpers.QuietWriter,4,3,2,6,12,0,5,1,4,0.0,57,1.0,1,0.857142857,0.5,2,2,13.0,2,1.0,2,"

package org.apache.log4j.helpers;

import java.io.Writer;
import java.io.FilterWriter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;



public class QuietWriter extends FilterWriter {

  protected ErrorHandler errorHandler;

  public
  QuietWriter(Writer writer, ErrorHandler errorHandler) {
    super(writer);
    setErrorHandler(errorHandler);
  }

  public
  void write(String string) {
    if (string != null) {
    	try {
      		out.write(string);
    	} catch(Exception e) {
      		errorHandler.error(""Failed to write [""+string+""]."", e, 
			 	ErrorCode.WRITE_FAILURE);
	    }
    }
  }

  public
  void flush() {
    try {
      out.flush();
    } catch(Exception e) {
      errorHandler.error(""Failed to flush writer,"", e, 
			 ErrorCode.FLUSH_FAILURE);
    }	
  }


  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      
      throw new IllegalArgumentException(""Attempted to set null ErrorHandler."");
    } else { 
      this.errorHandler = eh;
    }
  }
}
"
log4j,1.2,org.apache.log4j.spi.DefaultRepositorySelector,2,1,0,3,3,0,1,2,2,0.0,12,0.0,1,0.0,0.75,0,0,4.5,1,0.5,2,"



package org.apache.log4j.spi;


public class DefaultRepositorySelector implements RepositorySelector {

  final LoggerRepository repository;

  public
  DefaultRepositorySelector(LoggerRepository repository) {
    this.repository = repository;
  }

  public
  LoggerRepository getLoggerRepository() {
    return repository;
  }
}

"
log4j,1.2,org.apache.log4j.lf5.util.DateFormatManager,23,1,0,2,32,9,2,0,22,0.420454545,325,1.0,0,0.0,0.326086957,0,0,12.95652174,2,0.8261,3,"
package org.apache.log4j.lf5.util;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;




public class DateFormatManager {
  
  
  

  
  
  

  
  
  
  private TimeZone _timeZone = null;
  private Locale _locale = null;

  private String _pattern = null;
  private DateFormat _dateFormat = null;

  
  
  
  public DateFormatManager() {
    super();
    configure();
  }

  public DateFormatManager(TimeZone timeZone) {
    super();

    _timeZone = timeZone;
    configure();
  }

  public DateFormatManager(Locale locale) {
    super();

    _locale = locale;
    configure();
  }

  public DateFormatManager(String pattern) {
    super();

    _pattern = pattern;
    configure();
  }

  public DateFormatManager(TimeZone timeZone, Locale locale) {
    super();

    _timeZone = timeZone;
    _locale = locale;
    configure();
  }

  public DateFormatManager(TimeZone timeZone, String pattern) {
    super();

    _timeZone = timeZone;
    _pattern = pattern;
    configure();
  }

  public DateFormatManager(Locale locale, String pattern) {
    super();

    _locale = locale;
    _pattern = pattern;
    configure();
  }

  public DateFormatManager(TimeZone timeZone, Locale locale, String pattern) {
    super();

    _timeZone = timeZone;
    _locale = locale;
    _pattern = pattern;
    configure();
  }

  
  
  

  public synchronized TimeZone getTimeZone() {
    if (_timeZone == null) {
      return TimeZone.getDefault();
    } else {
      return _timeZone;
    }
  }

  public synchronized void setTimeZone(TimeZone timeZone) {
    _timeZone = timeZone;
    configure();
  }

  public synchronized Locale getLocale() {
    if (_locale == null) {
      return Locale.getDefault();
    } else {
      return _locale;
    }
  }

  public synchronized void setLocale(Locale locale) {
    _locale = locale;
    configure();
  }

  public synchronized String getPattern() {
    return _pattern;
  }

  
  public synchronized void setPattern(String pattern) {
    _pattern = pattern;
    configure();
  }


  
  public synchronized String getOutputFormat() {
    return _pattern;
  }

  
  public synchronized void setOutputFormat(String pattern) {
    _pattern = pattern;
    configure();
  }

  public synchronized DateFormat getDateFormatInstance() {
    return _dateFormat;
  }

  public synchronized void setDateFormatInstance(DateFormat dateFormat) {
    _dateFormat = dateFormat;
    
  }

  public String format(Date date) {
    return getDateFormatInstance().format(date);
  }

  public String format(Date date, String pattern) {
    DateFormat formatter = null;
    formatter = getDateFormatInstance();
    if (formatter instanceof SimpleDateFormat) {
      formatter = (SimpleDateFormat) (formatter.clone());
      ((SimpleDateFormat) formatter).applyPattern(pattern);
    }
    return formatter.format(date);
  }

  
  public Date parse(String date) throws ParseException {
    return getDateFormatInstance().parse(date);
  }

  
  public Date parse(String date, String pattern) throws ParseException {
    DateFormat formatter = null;
    formatter = getDateFormatInstance();
    if (formatter instanceof SimpleDateFormat) {
      formatter = (SimpleDateFormat) (formatter.clone());
      ((SimpleDateFormat) formatter).applyPattern(pattern);
    }
    return formatter.parse(date);
  }

  
  
  

  
  
  
  private synchronized void configure() {
    _dateFormat = SimpleDateFormat.getDateTimeInstance(DateFormat.FULL,
        DateFormat.FULL,
        getLocale());
    _dateFormat.setTimeZone(getTimeZone());

    if (_pattern != null) {
      ((SimpleDateFormat) _dateFormat).applyPattern(_pattern);
    }
  }

  
  
  

}
"
log4j,1.2,org.apache.log4j.varia.StringMatchFilter,8,2,0,3,13,0,0,3,8,0.821428571,87,0.0,0,0.363636364,0.375,0,0,9.375,5,1.625,3,"

package org.apache.log4j.varia;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;


public class StringMatchFilter extends Filter {
  
  
  public static final String STRING_TO_MATCH_OPTION = ""StringToMatch"";

  
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
  
  boolean acceptOnMatch = true;
  String stringToMatch;
  
  
  public
  String[] getOptionStrings() {
    return new String[] {STRING_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};
  }

  
  public
  void setOption(String key, String value) { 
    
    if(key.equalsIgnoreCase(STRING_TO_MATCH_OPTION)) {
      stringToMatch = value;
    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
  
  public
  void setStringToMatch(String s) {
    stringToMatch = s;
  }
  
  public
  String getStringToMatch() {
    return stringToMatch;
  }
  
  public
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }

  
  public
  int decide(LoggingEvent event) {
    String msg = event.getRenderedMessage();

    if(msg == null ||  stringToMatch == null)
      return Filter.NEUTRAL;
    

    if( msg.indexOf(stringToMatch) == -1 ) {
      return Filter.NEUTRAL;
    } else { 
      if(acceptOnMatch) {
	return Filter.ACCEPT;
      } else {
	return Filter.DENY;
      }
    }
  }
}
"
log4j,1.2,org.apache.log4j.Logger,7,2,2,25,15,21,25,3,4,1.0,47,0.5,0,0.903846154,0.291666667,1,1,5.428571429,1,0.7143,5,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggerFactory;



public class Logger extends Category {

  
  private static final String FQCN = Logger.class.getName();


  protected
  Logger(String name) {
    super(name);
  }

  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  

  
  static
  public
  Logger getLogger(String name) {
    return LogManager.getLogger(name);
  }

  
  static
  public
  Logger getLogger(Class clazz) {
    return LogManager.getLogger(clazz.getName());
  }


  
  public
  static
  Logger getRootLogger() {
    return LogManager.getRootLogger();
  }

  
  public
  static
  Logger getLogger(String name, LoggerFactory factory) {
    return LogManager.getLogger(name, factory);
  }

    
    public void trace(Object message) {
      if (repository.isDisabled(Level.TRACE_INT)) {
        return;
      }

      if (Level.TRACE.isGreaterOrEqual(this.getEffectiveLevel())) {
        forcedLog(FQCN, Level.TRACE, message, null);
      }
    }

    
    public void trace(Object message, Throwable t) {
      if (repository.isDisabled(Level.TRACE_INT)) {
        return;
      }

      if (Level.TRACE.isGreaterOrEqual(this.getEffectiveLevel())) {
        forcedLog(FQCN, Level.TRACE, message, t);
      }
    }

    
    public boolean isTraceEnabled() {
        if (repository.isDisabled(Level.TRACE_INT)) {
            return false;
          }

          return Level.TRACE.isGreaterOrEqual(this.getEffectiveLevel());
    }

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.configure.ConfigurationManager,28,1,0,10,105,268,1,10,4,1.002178649,962,1.0,2,0.0,0.173076923,0,0,32.75,5,1.7857,3,"
package org.apache.log4j.lf5.viewer.configure;

import java.awt.Color;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.swing.JCheckBoxMenuItem;
import javax.swing.tree.TreePath;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogLevelFormatException;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import org.apache.log4j.lf5.viewer.LogTable;
import org.apache.log4j.lf5.viewer.LogTableColumn;
import org.apache.log4j.lf5.viewer.LogTableColumnFormatException;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerModel;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNode;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;





public class ConfigurationManager extends Object {
  
  
  
  private static final String CONFIG_FILE_NAME = ""lf5_configuration.xml"";
  private static final String NAME = ""name"";
  private static final String PATH = ""path"";
  private static final String SELECTED = ""selected"";
  private static final String EXPANDED = ""expanded"";
  private static final String CATEGORY = ""category"";
  private static final String FIRST_CATEGORY_NAME = ""Categories"";
  private static final String LEVEL = ""level"";
  private static final String COLORLEVEL = ""colorlevel"";
  private static final String RED = ""red"";
  private static final String GREEN = ""green"";
  private static final String BLUE = ""blue"";
  private static final String COLUMN = ""column"";
  private static final String NDCTEXTFILTER = ""searchtext"";
  
  
  

  
  
  
  private LogBrokerMonitor _monitor = null;
  private LogTable _table = null;

  
  
  
  public ConfigurationManager(LogBrokerMonitor monitor, LogTable table) {
    super();
    _monitor = monitor;
    _table = table;
    load();
  }
  
  
  

  public void save() {
    CategoryExplorerModel model = _monitor.getCategoryExplorerTree().getExplorerModel();
    CategoryNode root = model.getRootCategoryNode();

    StringBuffer xml = new StringBuffer(2048);
    openXMLDocument(xml);
    openConfigurationXML(xml);
    processLogRecordFilter(_monitor.getNDCTextFilter(), xml);
    processLogLevels(_monitor.getLogLevelMenuItems(), xml);
    processLogLevelColors(_monitor.getLogLevelMenuItems(),
        LogLevel.getLogLevelColorMap(), xml);
    processLogTableColumns(LogTableColumn.getLogTableColumns(), xml);
    processConfigurationNode(root, xml);
    closeConfigurationXML(xml);
    store(xml.toString());
  }

  public void reset() {
    deleteConfigurationFile();
    collapseTree();
    selectAllNodes();
  }

  public static String treePathToString(TreePath path) {
    
    StringBuffer sb = new StringBuffer();
    CategoryNode n = null;
    Object[] objects = path.getPath();
    for (int i = 1; i < objects.length; i++) {
      n = (CategoryNode) objects[i];
      if (i > 1) {
        sb.append(""."");
      }
      sb.append(n.getTitle());
    }
    return sb.toString();
  }

  
  
  
  protected void load() {
    File file = new File(getFilename());
    if (file.exists()) {
      try {
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.
            newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        Document doc = docBuilder.parse(file);
        processRecordFilter(doc);
        processCategories(doc);
        processLogLevels(doc);
        processLogLevelColors(doc);
        processLogTableColumns(doc);
      } catch (Exception e) {
        
        
        System.err.println(""Unable process configuration file at "" +
            getFilename() + "". Error Message="" + e.getMessage());
      }
    }

  }

  
  
  
  
  
  protected void processRecordFilter(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(NDCTEXTFILTER);

    
    Node n = nodeList.item(0);
    
    
    if (n == null) {
      return;
    }

    NamedNodeMap map = n.getAttributes();
    String text = getValue(map, NAME);

    if (text == null || text.equals("""")) {
      return;
    }
    _monitor.setNDCLogRecordFilter(text);
  }

  protected void processCategories(Document doc) {
    CategoryExplorerTree tree = _monitor.getCategoryExplorerTree();
    CategoryExplorerModel model = tree.getExplorerModel();
    NodeList nodeList = doc.getElementsByTagName(CATEGORY);

    
    NamedNodeMap map = nodeList.item(0).getAttributes();
    int j = (getValue(map, NAME).equalsIgnoreCase(FIRST_CATEGORY_NAME)) ? 1 : 0;
    
    
    for (int i = nodeList.getLength() - 1; i >= j; i--) {
      Node n = nodeList.item(i);
      map = n.getAttributes();
      CategoryNode chnode = model.addCategory(new CategoryPath(getValue(map, PATH)));
      chnode.setSelected((getValue(map, SELECTED).equalsIgnoreCase(""true"")) ? true : false);
      if (getValue(map, EXPANDED).equalsIgnoreCase(""true"")) ;
      tree.expandPath(model.getTreePathToRoot(chnode));
    }

  }

  protected void processLogLevels(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(LEVEL);
    Map menuItems = _monitor.getLogLevelMenuItems();

    for (int i = 0; i < nodeList.getLength(); i++) {
      Node n = nodeList.item(i);
      NamedNodeMap map = n.getAttributes();
      String name = getValue(map, NAME);
      try {
        JCheckBoxMenuItem item =
            (JCheckBoxMenuItem) menuItems.get(LogLevel.valueOf(name));
        item.setSelected(getValue(map, SELECTED).equalsIgnoreCase(""true""));
      } catch (LogLevelFormatException e) {
        
      }
    }
  }

  protected void processLogLevelColors(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(COLORLEVEL);
    LogLevel.getLogLevelColorMap();

    for (int i = 0; i < nodeList.getLength(); i++) {
      Node n = nodeList.item(i);
      
      
      if (n == null) {
        return;
      }

      NamedNodeMap map = n.getAttributes();
      String name = getValue(map, NAME);
      try {
        LogLevel level = LogLevel.valueOf(name);
        int red = Integer.parseInt(getValue(map, RED));
        int green = Integer.parseInt(getValue(map, GREEN));
        int blue = Integer.parseInt(getValue(map, BLUE));
        Color c = new Color(red, green, blue);
        if (level != null) {
          level.setLogLevelColorMap(level, c);
        }

      } catch (LogLevelFormatException e) {
        
      }
    }
  }

  protected void processLogTableColumns(Document doc) {
    NodeList nodeList = doc.getElementsByTagName(COLUMN);
    Map menuItems = _monitor.getLogTableColumnMenuItems();
    List selectedColumns = new ArrayList();
    for (int i = 0; i < nodeList.getLength(); i++) {
      Node n = nodeList.item(i);
      
      
      if (n == null) {
        return;
      }
      NamedNodeMap map = n.getAttributes();
      String name = getValue(map, NAME);
      try {
        LogTableColumn column = LogTableColumn.valueOf(name);
        JCheckBoxMenuItem item =
            (JCheckBoxMenuItem) menuItems.get(column);
        item.setSelected(getValue(map, SELECTED).equalsIgnoreCase(""true""));

        if (item.isSelected()) {
          selectedColumns.add(column);
        }
      } catch (LogTableColumnFormatException e) {
        
      }

      if (selectedColumns.isEmpty()) {
        _table.setDetailedView();
      } else {
        _table.setView(selectedColumns);
      }

    }
  }

  protected String getValue(NamedNodeMap map, String attr) {
    Node n = map.getNamedItem(attr);
    return n.getNodeValue();
  }

  protected void collapseTree() {
    
    CategoryExplorerTree tree = _monitor.getCategoryExplorerTree();
    for (int i = tree.getRowCount() - 1; i > 0; i--) {
      tree.collapseRow(i);
    }
  }

  protected void selectAllNodes() {
    CategoryExplorerModel model = _monitor.getCategoryExplorerTree().getExplorerModel();
    CategoryNode root = model.getRootCategoryNode();
    Enumeration all = root.breadthFirstEnumeration();
    CategoryNode n = null;
    while (all.hasMoreElements()) {
      n = (CategoryNode) all.nextElement();
      n.setSelected(true);
    }
  }

  protected void store(String s) {

    try {
      PrintWriter writer = new PrintWriter(new FileWriter(getFilename()));
      writer.print(s);
      writer.close();
    } catch (IOException e) {
      
      e.printStackTrace();
    }

  }

  protected void deleteConfigurationFile() {
    try {
      File f = new File(getFilename());
      if (f.exists()) {
        f.delete();
      }
    } catch (SecurityException e) {
      System.err.println(""Cannot delete "" + getFilename() +
          "" because a security violation occured."");
    }
  }

  protected String getFilename() {
    String home = System.getProperty(""user.home"");
    String sep = System.getProperty(""file.separator"");

    return home + sep + ""lf5"" + sep + CONFIG_FILE_NAME;
  }

  
  
  
  private void processConfigurationNode(CategoryNode node, StringBuffer xml) {
    CategoryExplorerModel model = _monitor.getCategoryExplorerTree().getExplorerModel();

    Enumeration all = node.breadthFirstEnumeration();
    CategoryNode n = null;
    while (all.hasMoreElements()) {
      n = (CategoryNode) all.nextElement();
      exportXMLElement(n, model.getTreePathToRoot(n), xml);
    }

  }

  private void processLogLevels(Map logLevelMenuItems, StringBuffer xml) {
    xml.append(""\t<loglevels>\r\n"");
    Iterator it = logLevelMenuItems.keySet().iterator();
    while (it.hasNext()) {
      LogLevel level = (LogLevel) it.next();
      JCheckBoxMenuItem item = (JCheckBoxMenuItem) logLevelMenuItems.get(level);
      exportLogLevelXMLElement(level.getLabel(), item.isSelected(), xml);
    }

    xml.append(""\t</loglevels>\r\n"");
  }

  private void processLogLevelColors(Map logLevelMenuItems, Map logLevelColors, StringBuffer xml) {
    xml.append(""\t<loglevelcolors>\r\n"");
    
    Iterator it = logLevelMenuItems.keySet().iterator();
    while (it.hasNext()) {
      LogLevel level = (LogLevel) it.next();
      
      Color color = (Color) logLevelColors.get(level);
      exportLogLevelColorXMLElement(level.getLabel(), color, xml);
    }

    xml.append(""\t</loglevelcolors>\r\n"");
  }


  private void processLogTableColumns(List logTableColumnMenuItems, StringBuffer xml) {
    xml.append(""\t<logtablecolumns>\r\n"");
    Iterator it = logTableColumnMenuItems.iterator();
    while (it.hasNext()) {
      LogTableColumn column = (LogTableColumn) it.next();
      JCheckBoxMenuItem item = _monitor.getTableColumnMenuItem(column);
      exportLogTableColumnXMLElement(column.getLabel(), item.isSelected(), xml);
    }

    xml.append(""\t</logtablecolumns>\r\n"");
  }

  
  
  private void processLogRecordFilter(String text, StringBuffer xml) {
    xml.append(""\t<"").append(NDCTEXTFILTER).append("" "");
    xml.append(NAME).append(""=\"""").append(text).append(""\"""");
    xml.append(""/>\r\n"");
  }

  private void openXMLDocument(StringBuffer xml) {
    xml.append(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\r\n"");
  }

  private void openConfigurationXML(StringBuffer xml) {
    xml.append(""<configuration>\r\n"");
  }

  private void closeConfigurationXML(StringBuffer xml) {
    xml.append(""</configuration>\r\n"");
  }

  private void exportXMLElement(CategoryNode node, TreePath path, StringBuffer xml) {
    CategoryExplorerTree tree = _monitor.getCategoryExplorerTree();

    xml.append(""\t<"").append(CATEGORY).append("" "");
    xml.append(NAME).append(""=\"""").append(node.getTitle()).append(""\"" "");
    xml.append(PATH).append(""=\"""").append(treePathToString(path)).append(""\"" "");
    xml.append(EXPANDED).append(""=\"""").append(tree.isExpanded(path)).append(""\"" "");
    xml.append(SELECTED).append(""=\"""").append(node.isSelected()).append(""\""/>\r\n"");
  }

  private void exportLogLevelXMLElement(String label, boolean selected, StringBuffer xml) {
    xml.append(""\t\t<"").append(LEVEL).append("" "").append(NAME);
    xml.append(""=\"""").append(label).append(""\"" "");
    xml.append(SELECTED).append(""=\"""").append(selected);
    xml.append(""\""/>\r\n"");
  }

  private void exportLogLevelColorXMLElement(String label, Color color, StringBuffer xml) {
    xml.append(""\t\t<"").append(COLORLEVEL).append("" "").append(NAME);
    xml.append(""=\"""").append(label).append(""\"" "");
    xml.append(RED).append(""=\"""").append(color.getRed()).append(""\"" "");
    xml.append(GREEN).append(""=\"""").append(color.getGreen()).append(""\"" "");
    xml.append(BLUE).append(""=\"""").append(color.getBlue());
    xml.append(""\""/>\r\n"");
  }

  private void exportLogTableColumnXMLElement(String label, boolean selected, StringBuffer xml) {
    xml.append(""\t\t<"").append(COLUMN).append("" "").append(NAME);
    xml.append(""=\"""").append(label).append(""\"" "");
    xml.append(SELECTED).append(""=\"""").append(selected);
    xml.append(""\""/>\r\n"");
  }
  
  
  

}






"
log4j,1.2,org.apache.log4j.Priority,12,1,1,35,17,44,35,1,10,0.981818182,150,0.0,5,0.0,0.290909091,0,0,10.25,3,1.0833,3,"



package org.apache.log4j;


public class Priority {

  transient int level;
  transient String levelStr;
  transient int syslogEquivalent;

  public final static int OFF_INT = Integer.MAX_VALUE;
  public final static int FATAL_INT = 50000;
  public final static int ERROR_INT = 40000;
  public final static int WARN_INT  = 30000;
  public final static int INFO_INT  = 20000;
  public final static int DEBUG_INT = 10000;
    
  public final static int ALL_INT = Integer.MIN_VALUE;

  
  final static public Priority FATAL = new Level(FATAL_INT, ""FATAL"", 0);

  
  final static public Priority ERROR = new Level(ERROR_INT, ""ERROR"", 3);

  
  final static public Priority WARN  = new Level(WARN_INT, ""WARN"",  4);

  
  final static public Priority INFO  = new Level(INFO_INT, ""INFO"",  6);

  
  final static public Priority DEBUG = new Level(DEBUG_INT, ""DEBUG"", 7);


  
  protected Priority() {
      level = DEBUG_INT;
      levelStr = ""DEBUG"";
      syslogEquivalent = 7;
  }

  
  protected
  Priority(int level, String levelStr, int syslogEquivalent) {
    this.level = level;
    this.levelStr = levelStr;
    this.syslogEquivalent = syslogEquivalent;
  }

  
  public
  boolean equals(Object o) {
    if(o instanceof Priority) {
      Priority r = (Priority) o;
      return (this.level == r.level);
    } else {
      return false;
    }
  }

  
  public
  final
  int getSyslogEquivalent() {
    return syslogEquivalent;
  }


   
  
  public
  boolean isGreaterOrEqual(Priority r) {
    return level >= r.level;
  }

  
  public
  static
  Priority[] getAllPossiblePriorities() {
    return new Priority[] {Priority.FATAL, Priority.ERROR, Level.WARN, 
			   Priority.INFO, Priority.DEBUG};
  }


  
  final
  public
  String toString() {
    return levelStr;
  }

  
  public
  final
  int toInt() {
    return level;
  }

  
  public
  static
  Priority toPriority(String sArg) {
    return Level.toLevel(sArg);
  }

  
  public
  static
  Priority toPriority(int val) {
    return toPriority(val, Priority.DEBUG);
  }

  
  public
  static
  Priority toPriority(int val, Priority defaultPriority) {
    return Level.toLevel(val, (Level) defaultPriority);
  }

  
  public
  static
  Priority toPriority(String sArg, Priority defaultPriority) {                  
    return Level.toLevel(sArg, (Level) defaultPriority);
  }
}
"
log4j,1.2,org.apache.log4j.spi.ErrorHandler,6,1,0,20,6,15,17,4,6,2.0,6,0.0,0,0.0,0.404761905,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;

import org.apache.log4j.Appender;
import org.apache.log4j.Logger;



public interface ErrorHandler extends OptionHandler {

  
  void setLogger(Logger logger);


  
  void error(String message, Exception e, int errorCode);

  
  void error(String message);

  
  void error(String message, Exception e, int errorCode, LoggingEvent event);
  
  
  void setAppender(Appender appender);

  
  void setBackupAppender(Appender appender);
}
"
log4j,1.2,org.apache.log4j.varia.ExternallyRolledFileAppender,4,4,0,4,10,0,2,3,4,0.916666667,48,0.0,1,0.931818182,0.625,0,0,10.0,3,1.25,3,"

package org.apache.log4j.varia;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.ServerSocket;
import java.net.Socket;

import org.apache.log4j.RollingFileAppender;
import org.apache.log4j.helpers.LogLog;


public class ExternallyRolledFileAppender extends RollingFileAppender {

  
  static final public String ROLL_OVER = ""RollOver"";

  
  static final public String OK = ""OK"";

  int port = 0;
  HUP hup;

  
  public
  ExternallyRolledFileAppender() {
  }

  
  public
  void setPort(int port) {
    this.port = port;
  }

  
  public
  int getPort() {
    return port;
  }

  
  public
  void activateOptions() {
    super.activateOptions();
    if(port != 0) {
      if(hup != null) {
	hup.interrupt();
      }
      hup = new HUP(this, port);
      hup.setDaemon(true);
      hup.start();
    }
  }
}


class HUP extends Thread {

  int port;
  ExternallyRolledFileAppender er;

  HUP(ExternallyRolledFileAppender er, int port) {
    this.er = er;
    this.port = port;
  }

  public
  void run() {
    while(!isInterrupted()) {
      try {
	ServerSocket serverSocket = new ServerSocket(port);
	while(true) {
	  Socket socket = serverSocket.accept();
	  LogLog.debug(""Connected to client at "" + socket.getInetAddress());
	  new Thread(new HUPNode(socket, er), ""ExternallyRolledFileAppender-HUP"").start();
	}
      } catch(InterruptedIOException e) {
        Thread.currentThread().interrupt();
	    e.printStackTrace();
      } catch(IOException e) {
	    e.printStackTrace();
      } catch(RuntimeException e) {
	    e.printStackTrace();
      }
    }
  }
}

class HUPNode implements Runnable {

  Socket socket;
  DataInputStream dis;
  DataOutputStream dos;
  ExternallyRolledFileAppender er;

  public
  HUPNode(Socket socket, ExternallyRolledFileAppender er) {
    this.socket = socket;
    this.er = er;
    try {
      dis = new DataInputStream(socket.getInputStream());
      dos = new DataOutputStream(socket.getOutputStream());
    } catch(InterruptedIOException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } catch(IOException e) {
      e.printStackTrace();
    } catch(RuntimeException e) {
      e.printStackTrace();
    }
  }

  public void run() {
    try {
      String line = dis.readUTF();
      LogLog.debug(""Got external roll over signal."");
      if(ExternallyRolledFileAppender.ROLL_OVER.equals(line)) {
	synchronized(er) {
	  er.rollOver();
	}
	dos.writeUTF(ExternallyRolledFileAppender.OK);
      }
      else {
	dos.writeUTF(""Expecting [RollOver] string."");
      }
      dos.close();
    } catch(InterruptedIOException e) {
      Thread.currentThread().interrupt();
      LogLog.error(""Unexpected exception. Exiting HUPNode."", e);
    } catch(IOException e) {
      LogLog.error(""Unexpected exception. Exiting HUPNode."", e);
    } catch(RuntimeException e) {
      LogLog.error(""Unexpected exception. Exiting HUPNode."", e);
    }
  }
}

"
log4j,1.2,org.apache.log4j.chainsaw.ControlPanel,3,5,0,12,35,3,8,11,0,1.0,407,0.5,1,0.998394864,0.5,0,0,134.0,1,0.3333,3,"
package org.apache.log4j.chainsaw;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.apache.log4j.Logger;
import org.apache.log4j.Priority;
import org.apache.log4j.Level;


class ControlPanel extends JPanel {
    
    private static final Logger LOG = 
                                  Logger.getLogger(ControlPanel.class);

    
    ControlPanel(final MyTableModel aModel) {
        setBorder(BorderFactory.createTitledBorder(""Controls: ""));
        final GridBagLayout gridbag = new GridBagLayout();
        final GridBagConstraints c = new GridBagConstraints();
        setLayout(gridbag);

        
        c.ipadx = 5;
        c.ipady = 5;

        
        c.gridx = 0;
        c.anchor = GridBagConstraints.EAST;

        c.gridy = 0;
        JLabel label = new JLabel(""Filter Level:"");
        gridbag.setConstraints(label, c);
        add(label);

        c.gridy++;
        label = new JLabel(""Filter Thread:"");
        gridbag.setConstraints(label, c);
        add(label);

        c.gridy++;
        label = new JLabel(""Filter Logger:"");
        gridbag.setConstraints(label, c);
        add(label);

        c.gridy++;
        label = new JLabel(""Filter NDC:"");
        gridbag.setConstraints(label, c);
        add(label);

        c.gridy++;
        label = new JLabel(""Filter Message:"");
        gridbag.setConstraints(label, c);
        add(label);

        
        c.weightx = 1;
        
        c.gridx = 1;
        c.anchor = GridBagConstraints.WEST;

        c.gridy = 0;
        final Level[] allPriorities = new Level[] {Level.FATAL, 
               Level.ERROR, 
               Level.WARN, 
			   Level.INFO, 
			   Level.DEBUG, 
			   Level.TRACE };
        
        final JComboBox priorities = new JComboBox(allPriorities);
        final Level lowest = allPriorities[allPriorities.length - 1];
        priorities.setSelectedItem(lowest);
        aModel.setPriorityFilter(lowest);
        gridbag.setConstraints(priorities, c);
        add(priorities);
        priorities.setEditable(false);
        priorities.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent aEvent) {
                    aModel.setPriorityFilter(
                        (Priority) priorities.getSelectedItem());
                }
            });


        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridy++;
        final JTextField threadField = new JTextField("""");
        threadField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setThreadFilter(threadField.getText());
                }
                public void removeUpdate(DocumentEvent aEvente) {
                    aModel.setThreadFilter(threadField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setThreadFilter(threadField.getText());
                }
            });
        gridbag.setConstraints(threadField, c);
        add(threadField);

        c.gridy++;
        final JTextField catField = new JTextField("""");
        catField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setCategoryFilter(catField.getText());
                }
                public void removeUpdate(DocumentEvent aEvent) {
                    aModel.setCategoryFilter(catField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setCategoryFilter(catField.getText());
                }
            });
        gridbag.setConstraints(catField, c);
        add(catField);

        c.gridy++;
        final JTextField ndcField = new JTextField("""");
        ndcField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setNDCFilter(ndcField.getText());
                }
                public void removeUpdate(DocumentEvent aEvent) {
                    aModel.setNDCFilter(ndcField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setNDCFilter(ndcField.getText());
                }
            });
        gridbag.setConstraints(ndcField, c);
        add(ndcField);

        c.gridy++;
        final JTextField msgField = new JTextField("""");
        msgField.getDocument().addDocumentListener(new DocumentListener () {
                public void insertUpdate(DocumentEvent aEvent) {
                    aModel.setMessageFilter(msgField.getText());
                }
                public void removeUpdate(DocumentEvent aEvent) {
                    aModel.setMessageFilter(msgField.getText());
                }
                public void changedUpdate(DocumentEvent aEvent) {
                    aModel.setMessageFilter(msgField.getText());
                }
            });


        gridbag.setConstraints(msgField, c);
        add(msgField);

        
        c.weightx = 0;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.EAST;
        c.gridx = 2;

        c.gridy = 0;
        final JButton exitButton = new JButton(""Exit"");
        exitButton.setMnemonic('x');
        exitButton.addActionListener(ExitAction.INSTANCE);
        gridbag.setConstraints(exitButton, c);
        add(exitButton);

        c.gridy++;
        final JButton clearButton = new JButton(""Clear"");
        clearButton.setMnemonic('c');
        clearButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent aEvent) {
                    aModel.clear();
                }
            });
        gridbag.setConstraints(clearButton, c);
        add(clearButton);

        c.gridy++;
        final JButton toggleButton = new JButton(""Pause"");
        toggleButton.setMnemonic('p');
        toggleButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent aEvent) {
                    aModel.toggle();
                    toggleButton.setText(
                        aModel.isPaused() ? ""Resume"" : ""Pause"");
                }
            });
        gridbag.setConstraints(toggleButton, c);
        add(toggleButton);
    }
}
"
log4j,1.2,org.apache.log4j.lf5.util.LogFileParser,20,1,0,8,60,178,2,8,4,1.004048583,387,0.230769231,2,0.0,0.270676692,0,0,17.7,7,1.45,2,"
package org.apache.log4j.lf5.util;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.swing.SwingUtilities;

import org.apache.log4j.lf5.Log4JLogRecord;
import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogLevelFormatException;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import org.apache.log4j.lf5.viewer.LogFactor5ErrorDialog;
import org.apache.log4j.lf5.viewer.LogFactor5LoadingDialog;





public class LogFileParser implements Runnable {
  
  
  
  public static final String RECORD_DELIMITER = ""[slf5s.start]"";
  public static final String ATTRIBUTE_DELIMITER = ""[slf5s."";
  public static final String DATE_DELIMITER = ATTRIBUTE_DELIMITER + ""DATE]"";
  public static final String THREAD_DELIMITER = ATTRIBUTE_DELIMITER + ""THREAD]"";
  public static final String CATEGORY_DELIMITER = ATTRIBUTE_DELIMITER + ""CATEGORY]"";
  public static final String LOCATION_DELIMITER = ATTRIBUTE_DELIMITER + ""LOCATION]"";
  public static final String MESSAGE_DELIMITER = ATTRIBUTE_DELIMITER + ""MESSAGE]"";
  public static final String PRIORITY_DELIMITER = ATTRIBUTE_DELIMITER + ""PRIORITY]"";
  public static final String NDC_DELIMITER = ATTRIBUTE_DELIMITER + ""NDC]"";

  
  
  

  
  
  
  private static SimpleDateFormat _sdf = new SimpleDateFormat(""dd MMM yyyy HH:mm:ss,S"");
  private LogBrokerMonitor _monitor;
  LogFactor5LoadingDialog _loadDialog;
  private InputStream _in = null;

  
  
  
  public LogFileParser(File file) throws IOException,
      FileNotFoundException {
    this(new FileInputStream(file));
  }

  public LogFileParser(InputStream stream) throws IOException {
    _in = stream;
  }
  
  
  

  
  public void parse(LogBrokerMonitor monitor) throws RuntimeException {
    _monitor = monitor;
    Thread t = new Thread(this);
    t.start();
  }

  
  public void run() {

    int index = 0;
    int counter = 0;
    LogRecord temp;
    boolean isLogFile = false;

    _loadDialog = new LogFactor5LoadingDialog(
        _monitor.getBaseFrame(), ""Loading file..."");


    try {
      String logRecords = loadLogFile(_in);

      while ((counter = logRecords.indexOf(RECORD_DELIMITER, index)) != -1) {
        temp = createLogRecord(logRecords.substring(index, counter));
        isLogFile = true;

        if (temp != null) {
          _monitor.addMessage(temp);
        }

        index = counter + RECORD_DELIMITER.length();
      }

      if (index < logRecords.length() && isLogFile) {
        temp = createLogRecord(logRecords.substring(index));

        if (temp != null) {
          _monitor.addMessage(temp);
        }
      }

      if (isLogFile == false) {
        throw new RuntimeException(""Invalid log file format"");
      }
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          destroyDialog();
        }
      });

    } catch (RuntimeException e) {
      destroyDialog();
      displayError(""Error - Invalid log file format.\nPlease see documentation""
          + "" on how to load log files."");
    } catch (IOException e) {
      destroyDialog();
      displayError(""Error - Unable to load log file!"");
    }

    _in = null;
  }

  
  
  
  protected void displayError(String message) {
    LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
        _monitor.getBaseFrame(), message);

  }

  
  
  
  private void destroyDialog() {
    _loadDialog.hide();
    _loadDialog.dispose();
  }

  
  private String loadLogFile(InputStream stream) throws IOException {
    BufferedInputStream br = new BufferedInputStream(stream);

    int count = 0;
    int size = br.available();

    StringBuffer sb = null;
    if (size > 0) {
      sb = new StringBuffer(size);
    } else {
      sb = new StringBuffer(1024);
    }

    while ((count = br.read()) != -1) {
      sb.append((char) count);
    }

    br.close();
    br = null;
    return sb.toString();

  }

  private String parseAttribute(String name, String record) {

    int index = record.indexOf(name);

    if (index == -1) {
      return null;
    }

    return getAttribute(index, record);
  }

  private long parseDate(String record) {
    try {
      String s = parseAttribute(DATE_DELIMITER, record);

      if (s == null) {
        return 0;
      }

      Date d = _sdf.parse(s);

      return d.getTime();
    } catch (ParseException e) {
      return 0;
    }
  }

  private LogLevel parsePriority(String record) {
    String temp = parseAttribute(PRIORITY_DELIMITER, record);

    if (temp != null) {
      try {
        return LogLevel.valueOf(temp);
      } catch (LogLevelFormatException e) {
        return LogLevel.DEBUG;
      }

    }

    return LogLevel.DEBUG;
  }

  private String parseThread(String record) {
    return parseAttribute(THREAD_DELIMITER, record);
  }

  private String parseCategory(String record) {
    return parseAttribute(CATEGORY_DELIMITER, record);
  }

  private String parseLocation(String record) {
    return parseAttribute(LOCATION_DELIMITER, record);
  }

  private String parseMessage(String record) {
    return parseAttribute(MESSAGE_DELIMITER, record);
  }

  private String parseNDC(String record) {
    return parseAttribute(NDC_DELIMITER, record);
  }

  private String parseThrowable(String record) {
    return getAttribute(record.length(), record);
  }

  private LogRecord createLogRecord(String record) {
    if (record == null || record.trim().length() == 0) {
      return null;
    }

    LogRecord lr = new Log4JLogRecord();
    lr.setMillis(parseDate(record));
    lr.setLevel(parsePriority(record));
    lr.setCategory(parseCategory(record));
    lr.setLocation(parseLocation(record));
    lr.setThreadDescription(parseThread(record));
    lr.setNDC(parseNDC(record));
    lr.setMessage(parseMessage(record));
    lr.setThrownStackTrace(parseThrowable(record));

    return lr;
  }


  private String getAttribute(int index, String record) {
    int start = record.lastIndexOf(ATTRIBUTE_DELIMITER, index - 1);

    if (start == -1) {
      return record.substring(0, index);
    }

    start = record.indexOf(""]"", start);

    return record.substring(start + 1, index).trim();
  }
  
  
  

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerLogRecordFilter,4,1,0,5,14,0,0,5,3,0.0,45,1.0,1,0.0,0.5,0,0,10.0,2,1.0,2,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.LogRecordFilter;

import java.util.Enumeration;





public class CategoryExplorerLogRecordFilter implements LogRecordFilter {
  
  
  

  
  
  

  protected CategoryExplorerModel _model;

  
  
  

  
  
  

  public CategoryExplorerLogRecordFilter(CategoryExplorerModel model) {
    _model = model;
  }

  
  
  

  
  public boolean passes(LogRecord record) {
    CategoryPath path = new CategoryPath(record.getCategory());
    return _model.isCategoryPathActive(path);
  }

  
  public void reset() {
    resetAllNodes();
  }

  
  
  

  protected void resetAllNodes() {
    Enumeration nodes = _model.getRootCategoryNode().depthFirstEnumeration();
    CategoryNode current;
    while (nodes.hasMoreElements()) {
      current = (CategoryNode) nodes.nextElement();
      current.resetNumberOfContainedRecords();
      _model.nodeChanged(current);
    }
  }
  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.helpers.OptionConverter,15,1,0,19,60,103,16,5,12,0.918367347,760,0.0,0,0.0,0.160714286,0,0,49.2,11,3.2,4,"

package org.apache.log4j.helpers;

import java.io.InputStream;
import java.io.InterruptedIOException;
import java.net.URL;
import java.util.Properties;

import org.apache.log4j.Level;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggerRepository;






public class OptionConverter {

  static String DELIM_START = ""${"";
  static char   DELIM_STOP  = '}';
  static int DELIM_START_LEN = 2;
  static int DELIM_STOP_LEN  = 1;

  
  private OptionConverter() {}

  public
  static
  String[] concatanateArrays(String[] l, String[] r) {
    int len = l.length + r.length;
    String[] a = new String[len];

    System.arraycopy(l, 0, a, 0, l.length);
    System.arraycopy(r, 0, a, l.length, r.length);

    return a;
  }

  public
  static
  String convertSpecialChars(String s) {
    char c;
    int len = s.length();
    StringBuffer sbuf = new StringBuffer(len);

    int i = 0;
    while(i < len) {
      c = s.charAt(i++);
      if (c == '\\') {
	c =  s.charAt(i++);
	if(c == 'n')      c = '\n';
	else if(c == 'r') c = '\r';
	else if(c == 't') c = '\t';
	else if(c == 'f') c = '\f';
	else if(c == '\b') c = '\b';
	else if(c == '\""') c = '\""';
	else if(c == '\'') c = '\'';
	else if(c == '\\') c = '\\';
      }
      sbuf.append(c);
    }
    return sbuf.toString();
  }


  
  public
  static
  String getSystemProperty(String key, String def) {
    try {
      return System.getProperty(key, def);
    } catch(Throwable e) { 
      LogLog.debug(""Was not allowed to read system property \""""+key+""\""."");
      return def;
    }
  }


  public
  static
  Object instantiateByKey(Properties props, String key, Class superClass,
				Object defaultValue) {

    
    String className = findAndSubst(key, props);
    if(className == null) {
      LogLog.error(""Could not find value for key "" + key);
      return defaultValue;
    }
    
    return OptionConverter.instantiateByClassName(className.trim(), superClass,
						  defaultValue);
  }

  
  public
  static
  boolean toBoolean(String value, boolean dEfault) {
    if(value == null)
      return dEfault;
    String trimmedVal = value.trim();
    if(""true"".equalsIgnoreCase(trimmedVal))
      return true;
    if(""false"".equalsIgnoreCase(trimmedVal))
      return false;
    return dEfault;
  }

  public
  static
  int toInt(String value, int dEfault) {
    if(value != null) {
      String s = value.trim();
      try {
	return Integer.valueOf(s).intValue();
      }
      catch (NumberFormatException e) {
	 LogLog.error(""["" + s + ""] is not in proper int form."");
	e.printStackTrace();
      }
    }
    return dEfault;
  }

  
  public
  static
  Level toLevel(String value, Level defaultValue) {
    if(value == null)
      return defaultValue;
      
    value = value.trim();

    int hashIndex = value.indexOf('#');
    if (hashIndex == -1) {
      if(""NULL"".equalsIgnoreCase(value)) {
	return null;
      } else {
	
	return(Level) Level.toLevel(value, defaultValue);
      }
    }

    Level result = defaultValue;

    String clazz = value.substring(hashIndex+1);
    String levelName = value.substring(0, hashIndex);

    
    if(""NULL"".equalsIgnoreCase(levelName)) {
	return null;
    }

    LogLog.debug(""toLevel"" + "":class=["" + clazz + ""]""
		 + "":pri=["" + levelName + ""]"");

    try {
      Class customLevel = Loader.loadClass(clazz);

      
      
      Class[] paramTypes = new Class[] { String.class,
					 org.apache.log4j.Level.class
                                       };
      java.lang.reflect.Method toLevelMethod =
                      customLevel.getMethod(""toLevel"", paramTypes);

      
      Object[] params = new Object[] {levelName, defaultValue};
      Object o = toLevelMethod.invoke(null, params);

      result = (Level) o;
    } catch(ClassNotFoundException e) {
      LogLog.warn(""custom level class ["" + clazz + ""] not found."");
    } catch(NoSuchMethodException e) {
      LogLog.warn(""custom level class ["" + clazz + ""]""
        + "" does not have a class function toLevel(String, Level)"", e);
    } catch(java.lang.reflect.InvocationTargetException e) {
        if (e.getTargetException() instanceof InterruptedException
                || e.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
      LogLog.warn(""custom level class ["" + clazz + ""]""
		   + "" could not be instantiated"", e);
    } catch(ClassCastException e) {
      LogLog.warn(""class ["" + clazz
        + ""] is not a subclass of org.apache.log4j.Level"", e);
    } catch(IllegalAccessException e) {
      LogLog.warn(""class [""+clazz+
		   ""] cannot be instantiated due to access restrictions"", e);
    } catch(RuntimeException e) {
      LogLog.warn(""class [""+clazz+""], level [""+levelName+
		   ""] conversion failed."", e);
    }
    return result;
   }

  public
  static
  long toFileSize(String value, long dEfault) {
    if(value == null)
      return dEfault;

    String s = value.trim().toUpperCase();
    long multiplier = 1;
    int index;

    if((index = s.indexOf(""KB"")) != -1) {
      multiplier = 1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""MB"")) != -1) {
      multiplier = 1024*1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""GB"")) != -1) {
      multiplier = 1024*1024*1024;
      s = s.substring(0, index);
    }
    if(s != null) {
      try {
	return Long.valueOf(s).longValue() * multiplier;
      }
      catch (NumberFormatException e) {
	LogLog.error(""["" + s + ""] is not in proper int form."");
	LogLog.error(""["" + value + ""] not in expected format."", e);
      }
    }
    return dEfault;
  }

  
  public
  static
  String findAndSubst(String key, Properties props) {
    String value = props.getProperty(key);
    if(value == null)
      return null;

    try {
      return substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.error(""Bad option value [""+value+""]."", e);
      return value;
    }
  }

  
  public
  static
  Object instantiateByClassName(String className, Class superClass,
				Object defaultValue) {
    if(className != null) {
      try {
	Class classObj = Loader.loadClass(className);
	if(!superClass.isAssignableFrom(classObj)) {
	  LogLog.error(""A \""""+className+""\"" object is not assignable to a \""""+
		       superClass.getName() + ""\"" variable."");
	  LogLog.error(""The class \""""+ superClass.getName()+""\"" was loaded by "");
	  LogLog.error(""[""+superClass.getClassLoader()+""] whereas object of type "");
	  LogLog.error(""\"""" +classObj.getName()+""\"" was loaded by [""
		       +classObj.getClassLoader()+""]."");
	  return defaultValue;
	}
	return classObj.newInstance();
      } catch (ClassNotFoundException e) {
	    LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      } catch (IllegalAccessException e) {
	    LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      } catch (InstantiationException e) {
        LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      } catch (RuntimeException e) {
	    LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      }
    }
    return defaultValue;
  }


  
  public static
  String substVars(String val, Properties props) throws
                        IllegalArgumentException {

    StringBuffer sbuf = new StringBuffer();

    int i = 0;
    int j, k;

    while(true) {
      j=val.indexOf(DELIM_START, i);
      if(j == -1) {
	
	if(i==0) { 
	  return val;
	} else { 
	  sbuf.append(val.substring(i, val.length()));
	  return sbuf.toString();
	}
      } else {
	sbuf.append(val.substring(i, j));
	k = val.indexOf(DELIM_STOP, j);
	if(k == -1) {
	  throw new IllegalArgumentException('""'+val+
		      ""\"" has no closing brace. Opening brace at position "" + j
					     + '.');
	} else {
	  j += DELIM_START_LEN;
	  String key = val.substring(j, k);
	  
	  String replacement = getSystemProperty(key, null);
	  
	  if(replacement == null && props != null) {
	    replacement =  props.getProperty(key);
	  }

	  if(replacement != null) {
	    
	    
            
	    
            
	    String recursiveReplacement = substVars(replacement, props);
	    sbuf.append(recursiveReplacement);
	  }
	  i = k + DELIM_STOP_LEN;
	}
      }
    }
  }

    

static
public
void selectAndConfigure(InputStream inputStream, String clazz, LoggerRepository hierarchy) {
Configurator configurator = null;

if(clazz != null) {
  LogLog.debug(""Preferred configurator class: "" + clazz);
  configurator = (Configurator) instantiateByClassName(clazz,
                           Configurator.class,
                           null);
  if(configurator == null) {
   LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
   return;
  }
} else {
  configurator = new PropertyConfigurator();
}

configurator.doConfigure(inputStream, hierarchy);
}


  

  static
  public
  void selectAndConfigure(URL url, String clazz, LoggerRepository hierarchy) {
   Configurator configurator = null;
   String filename = url.getFile();

   if(clazz == null && filename != null && filename.endsWith("".xml"")) {
     clazz = ""org.apache.log4j.xml.DOMConfigurator"";
   }

   if(clazz != null) {
     LogLog.debug(""Preferred configurator class: "" + clazz);
     configurator = (Configurator) instantiateByClassName(clazz,
							  Configurator.class,
							  null);
     if(configurator == null) {
   	  LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
   	  return;
     }
   } else {
     configurator = new PropertyConfigurator();
   }

   configurator.doConfigure(url, hierarchy);
  }
}
"
log4j,1.2,org.apache.log4j.spi.ThrowableInformation,3,1,0,6,9,0,5,1,3,0.833333333,41,0.666666667,0,0.0,0.666666667,0,0,11.66666667,2,1.0,5,"

package org.apache.log4j.spi;

import org.apache.log4j.Category;
import org.apache.log4j.DefaultThrowableRenderer;


public class ThrowableInformation implements java.io.Serializable {

  static final long serialVersionUID = -4748765566864322735L;

  private transient Throwable throwable;
  private transient Category category;
  private String[] rep;

  public
  ThrowableInformation(Throwable throwable) {
    this.throwable = throwable;
  }

    
  public ThrowableInformation(Throwable throwable, Category category) {
      this.throwable = throwable;
      this.category = category;
  }

    
  public ThrowableInformation(final String[] r) {
      if (r != null) {
        rep = (String[]) r.clone();
      }
  }


  public
  Throwable getThrowable() {
    return throwable;
  }

  public synchronized String[] getThrowableStrRep() {
    if(rep == null) {
      ThrowableRenderer renderer = null;
      if (category != null) {
          LoggerRepository repo = category.getLoggerRepository();
          if (repo instanceof ThrowableRendererSupport) {
              renderer = ((ThrowableRendererSupport) repo).getThrowableRenderer();
          }
      }
      if (renderer == null) {
          rep = DefaultThrowableRenderer.render(throwable);
      } else {
          rep = renderer.doRender(throwable);
      }
    }
    return (String[]) rep.clone();
  }
}


"
log4j,1.2,org.apache.log4j.xml.XMLLayout,6,2,0,5,24,3,0,5,6,0.8,239,1.0,0,0.615384615,0.444444444,0,0,38.16666667,6,1.6667,6,"



package org.apache.log4j.xml;

import org.apache.log4j.Layout;
import org.apache.log4j.helpers.Transform;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.spi.LoggingEvent;

import java.util.Set;
import java.util.Arrays;


public class XMLLayout extends Layout {

  private  final int DEFAULT_SIZE = 256;
  private final int UPPER_LIMIT = 2048;

  private StringBuffer buf = new StringBuffer(DEFAULT_SIZE);
  private boolean locationInfo = false;
  private boolean properties = false;
 
  
  public void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  
  
  public boolean getLocationInfo() {
    return locationInfo;
  }

    
  public void setProperties(final boolean flag) {
      properties = flag;
  }

    
  public boolean getProperties() {
      return properties;
  }

  
  public void activateOptions() {
  }


  
  public String format(final LoggingEvent event) {

    
    
    if(buf.capacity() > UPPER_LIMIT) {
      buf = new StringBuffer(DEFAULT_SIZE);
    } else {
      buf.setLength(0);
    }
    
    

    buf.append(""<log4j:event logger=\"""");
    buf.append(Transform.escapeTags(event.getLoggerName()));
    buf.append(""\"" timestamp=\"""");
    buf.append(event.timeStamp);
    buf.append(""\"" level=\"""");
    buf.append(Transform.escapeTags(String.valueOf(event.getLevel())));
    buf.append(""\"" thread=\"""");
    buf.append(Transform.escapeTags(event.getThreadName()));
    buf.append(""\"">\r\n"");

    buf.append(""<log4j:message><![CDATA["");
    
    
    Transform.appendEscapingCDATA(buf, event.getRenderedMessage());
    buf.append(""]]></log4j:message>\r\n"");       
    
    String ndc = event.getNDC();
    if(ndc != null) {
      buf.append(""<log4j:NDC><![CDATA["");
      Transform.appendEscapingCDATA(buf, ndc);
      buf.append(""]]></log4j:NDC>\r\n"");       
    }
    
    String[] s = event.getThrowableStrRep();
    if(s != null) {
      buf.append(""<log4j:throwable><![CDATA["");
      for(int i = 0; i < s.length; i++) {
          Transform.appendEscapingCDATA(buf, s[i]);
	      buf.append(""\r\n"");
      }
      buf.append(""]]></log4j:throwable>\r\n"");
    }
    
    if(locationInfo) { 
      LocationInfo locationInfo = event.getLocationInformation();	
      buf.append(""<log4j:locationInfo class=\"""");
      buf.append(Transform.escapeTags(locationInfo.getClassName()));
      buf.append(""\"" method=\"""");
      buf.append(Transform.escapeTags(locationInfo.getMethodName()));
      buf.append(""\"" file=\"""");
      buf.append(Transform.escapeTags(locationInfo.getFileName()));
      buf.append(""\"" line=\"""");
      buf.append(locationInfo.getLineNumber());
      buf.append(""\""/>\r\n"");
    }

    if (properties) {
        Set keySet = event.getPropertyKeySet();
        if (keySet.size() > 0) {
            buf.append(""<log4j:properties>\r\n"");
            Object[] keys = keySet.toArray();
            Arrays.sort(keys);
            for (int i = 0; i < keys.length; i++) {
                String key = keys[i].toString();
                Object val = event.getMDC(key);
                if (val != null) {
                    buf.append(""<log4j:data name=\"""");
                    buf.append(Transform.escapeTags(key));
                    buf.append(""\"" value=\"""");
                    buf.append(Transform.escapeTags(String.valueOf(val)));
                    buf.append(""\""/>\r\n"");
                }
            }
            buf.append(""</log4j:properties>\r\n"");
        }
    }
    
    buf.append(""</log4j:event>\r\n\r\n"");
    
    return buf.toString();
  }
  
  
  public boolean ignoresThrowable() {
    return false;
  }
}
"
log4j,1.2,org.apache.log4j.or.RendererMap,11,1,0,9,32,29,5,5,8,0.666666667,197,0.0,1,0.0,0.283333333,0,0,16.63636364,4,1.7273,2,"

package org.apache.log4j.or;

import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.OptionConverter;
import java.util.Hashtable;


public class RendererMap {

  Hashtable map;

  static ObjectRenderer defaultRenderer = new DefaultRenderer();

  public
  RendererMap() {
    map = new Hashtable();
  }

  
  static
  public
  void addRenderer(RendererSupport repository, String renderedClassName,
		   String renderingClassName) {
    LogLog.debug(""Rendering class: [""+renderingClassName+""], Rendered class: [""+
		 renderedClassName+""]."");
    ObjectRenderer renderer = (ObjectRenderer)
             OptionConverter.instantiateByClassName(renderingClassName,
						    ObjectRenderer.class,
						    null);
    if(renderer == null) {
      LogLog.error(""Could not instantiate renderer [""+renderingClassName+""]."");
      return;
    } else {
      try {
	Class renderedClass = Loader.loadClass(renderedClassName);
	repository.setRenderer(renderedClass, renderer);
      } catch(ClassNotFoundException e) {
	LogLog.error(""Could not find class [""+renderedClassName+""]."", e);
      }
    }
  }


  
  public
  String findAndRender(Object o) {
    if(o == null)
      return null;
    else
      return get(o.getClass()).doRender(o);
  }


  
  public
  ObjectRenderer get(Object o) {
    if(o == null)
      return null;
    else
      return get(o.getClass());
  }


  
  public
  ObjectRenderer get(Class clazz) {
    
    ObjectRenderer r = null;
    for(Class c = clazz; c != null; c = c.getSuperclass()) {
      
      r = (ObjectRenderer) map.get(c);
      if(r != null) {
	return r;
      }
      r = searchInterfaces(c);
      if(r != null)
	return r;
    }
    return defaultRenderer;
  }

  ObjectRenderer searchInterfaces(Class c) {
    

    ObjectRenderer r = (ObjectRenderer) map.get(c);
    if(r != null) {
      return r;
    } else {
      Class[] ia = c.getInterfaces();
      for(int i = 0; i < ia.length; i++) {
	r = searchInterfaces(ia[i]);
	if(r != null)
	  return r;
      }
    }
    return null;
  }


  public
  ObjectRenderer getDefaultRenderer() {
    return defaultRenderer;
  }


  public
  void clear() {
    map.clear();
  }

  
  public
  void put(Class clazz, ObjectRenderer or) {
    map.put(clazz, or);
  }
}
"
log4j,1.2,org.apache.log4j.chainsaw.Main,6,6,0,9,52,9,1,9,1,0.95,279,0.5,1,0.993660856,0.25,0,0,44.83333333,2,0.8333,2,"
package org.apache.log4j.chainsaw;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import java.util.Properties;
import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;


public class Main
    extends JFrame
{
    
    private static final int DEFAULT_PORT = 4445;

    
    public static final String PORT_PROP_NAME = ""chainsaw.port"";

    
    private static final Logger LOG = Logger.getLogger(Main.class);


    
    private Main() {
        super(""CHAINSAW - Log4J Log Viewer"");
        
        final MyTableModel model = new MyTableModel();

        
        final JMenuBar menuBar = new JMenuBar();
        setJMenuBar(menuBar);
        final JMenu menu = new JMenu(""File"");
        menuBar.add(menu);

        try {
            final LoadXMLAction lxa = new LoadXMLAction(this, model);
            final JMenuItem loadMenuItem = new JMenuItem(""Load file..."");
            menu.add(loadMenuItem);
            loadMenuItem.addActionListener(lxa);
        } catch (NoClassDefFoundError e) {
            LOG.info(""Missing classes for XML parser"", e);
            JOptionPane.showMessageDialog(
                this,
                ""XML parser not in classpath - unable to load XML events."",
                ""CHAINSAW"",
                JOptionPane.ERROR_MESSAGE);
        } catch (Exception e) {
            LOG.info(""Unable to create the action to load XML files"", e);
            JOptionPane.showMessageDialog(
                this,
                ""Unable to create a XML parser - unable to load XML events."",
                ""CHAINSAW"",
                JOptionPane.ERROR_MESSAGE);
        }

        final JMenuItem exitMenuItem = new JMenuItem(""Exit"");
        menu.add(exitMenuItem);
        exitMenuItem.addActionListener(ExitAction.INSTANCE);

        
        final ControlPanel cp = new ControlPanel(model);
        getContentPane().add(cp, BorderLayout.NORTH);

        
        final JTable table = new JTable(model);
        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        final JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setBorder(BorderFactory.createTitledBorder(""Events: ""));
        scrollPane.setPreferredSize(new Dimension(900, 300));

        
        final JPanel details = new DetailPanel(table, model);
        details.setPreferredSize(new Dimension(900, 300));

        
        final JSplitPane jsp =
            new JSplitPane(JSplitPane.VERTICAL_SPLIT, scrollPane, details);
        getContentPane().add(jsp, BorderLayout.CENTER);

        addWindowListener(new WindowAdapter() {
                public void windowClosing(WindowEvent aEvent) {
                    ExitAction.INSTANCE.actionPerformed(null);
                }
            });

        pack();
        setVisible(true);

        setupReceiver(model);
    }

    
    private void setupReceiver(MyTableModel aModel) {
        int port = DEFAULT_PORT;
        final String strRep = System.getProperty(PORT_PROP_NAME);
        if (strRep != null) {
            try {
                port = Integer.parseInt(strRep);
            } catch (NumberFormatException nfe) {
                LOG.fatal(""Unable to parse "" + PORT_PROP_NAME +
                          "" property with value "" + strRep + ""."");
                JOptionPane.showMessageDialog(
                    this,
                    ""Unable to parse port number from '"" + strRep +
                    ""', quitting."",
                    ""CHAINSAW"",
                    JOptionPane.ERROR_MESSAGE);
                System.exit(1);
            }
        }

        try {
            final LoggingReceiver lr = new LoggingReceiver(aModel, port);
            lr.start();
        } catch (IOException e) {
            LOG.fatal(""Unable to connect to socket server, quiting"", e);
            JOptionPane.showMessageDialog(
                this,
                ""Unable to create socket on port "" + port + "", quitting."",
                ""CHAINSAW"",
                JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
    }


    
    
    


    
    private static void initLog4J() {
        final Properties props = new Properties();
        props.setProperty(""log4j.rootLogger"", ""DEBUG, A1"");
        props.setProperty(""log4j.appender.A1"",
                          ""org.apache.log4j.ConsoleAppender"");
        props.setProperty(""log4j.appender.A1.layout"",
                          ""org.apache.log4j.TTCCLayout"");
        PropertyConfigurator.configure(props);
    }

    
    public static void main(String[] aArgs) {
        initLog4J();
        new Main();
    }
}
"
log4j,1.2,org.apache.log4j.jmx.Agent,4,1,0,3,15,4,1,2,2,0.833333333,68,0.0,1,0.0,0.5,0,0,15.5,1,0.5,2,"

package org.apache.log4j.jmx;

import org.apache.log4j.Logger;

import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.ObjectName;
import java.lang.reflect.InvocationTargetException;
import java.io.InterruptedIOException;



public class Agent {

    
  static Logger log = Logger.getLogger(Agent.class);

    
  public Agent() {
  }

    
  private static Object createServer() {
      Object newInstance = null;
      try {
        newInstance = Class.forName(
                ""com.sun.jdmk.comm.HtmlAdapterServer"").newInstance();
      } catch (ClassNotFoundException ex) {
          throw new RuntimeException(ex.toString());
      } catch (InstantiationException ex) {
          throw new RuntimeException(ex.toString());
      } catch (IllegalAccessException ex) {
          throw new RuntimeException(ex.toString());
      }
      return newInstance;
  }

    
  private static void startServer(final Object server) {
      try {
          server.getClass().getMethod(""start"", new Class[0]).
                  invoke(server, new Object[0]);
      } catch(InvocationTargetException ex) {
          Throwable cause = ex.getTargetException();
          if (cause instanceof RuntimeException) {
              throw (RuntimeException) cause;
          } else if (cause != null) {
              if (cause instanceof InterruptedException
                      || cause instanceof InterruptedIOException) {
                  Thread.currentThread().interrupt();
              }
              throw new RuntimeException(cause.toString());
          } else {
              throw new RuntimeException();
          }
      } catch(NoSuchMethodException ex) {
          throw new RuntimeException(ex.toString());
      } catch(IllegalAccessException ex) {
        throw new RuntimeException(ex.toString());
    }
  }


    
  public void start() {

    MBeanServer server = MBeanServerFactory.createMBeanServer();
    Object html = createServer();

    try {
      log.info(""Registering HtmlAdaptorServer instance."");
      server.registerMBean(html, new ObjectName(""Adaptor:name=html,port=8082""));
      log.info(""Registering HierarchyDynamicMBean instance."");
      HierarchyDynamicMBean hdm = new HierarchyDynamicMBean();
      server.registerMBean(hdm, new ObjectName(""log4j:hiearchy=default""));
    } catch(JMException e) {
      log.error(""Problem while registering MBeans instances."", e);
      return;
    } catch(RuntimeException e) {
      log.error(""Problem while registering MBeans instances."", e);
      return;
    }
    startServer(html);
  }
}
"
log4j,1.2,org.apache.log4j.spi.LoggerRepository,15,1,0,27,15,105,22,6,15,2.0,15,0.0,0,0.0,0.216666667,0,0,0.0,1,1.0,3,"

package org.apache.log4j.spi;

import java.util.Enumeration;

import org.apache.log4j.Appender;
import org.apache.log4j.Category;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;


public interface LoggerRepository {

  
  public
  void addHierarchyEventListener(HierarchyEventListener listener);

  
  boolean isDisabled(int level);

  
  public
  void setThreshold(Level level);

  
  public
  void setThreshold(String val);

  public
  void emitNoAppenderWarning(Category cat);

  
  public
  Level getThreshold();

  public
  Logger getLogger(String name);

  public
  Logger getLogger(String name, LoggerFactory factory);

  public
  Logger getRootLogger();

  public
  abstract
  Logger exists(String name);

  public
  abstract
  void shutdown();

  public
  Enumeration getCurrentLoggers();

  
  public
  Enumeration getCurrentCategories();


  public
  abstract
  void fireAddAppenderEvent(Category logger, Appender appender);

  public
  abstract
  void resetConfiguration();

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryAbstractCellEditor,16,1,1,3,28,78,3,0,13,0.733333333,213,0.8,0,0.0,0.208333333,0,0,12.0,5,1.875,2,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.awt.Component;
import java.awt.event.MouseEvent;
import java.util.EventObject;

import javax.swing.JTable;
import javax.swing.JTree;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.EventListenerList;
import javax.swing.table.TableCellEditor;
import javax.swing.tree.TreeCellEditor;





public class CategoryAbstractCellEditor implements TableCellEditor, TreeCellEditor {
  
  
  

  
  
  
  protected EventListenerList _listenerList = new EventListenerList();
  protected Object _value;
  protected ChangeEvent _changeEvent = null;
  protected int _clickCountToStart = 1;

  
  
  

  
  
  

  
  
  

  public Object getCellEditorValue() {
    return _value;
  }

  public void setCellEditorValue(Object value) {
    _value = value;
  }

  public void setClickCountToStart(int count) {
    _clickCountToStart = count;
  }

  public int getClickCountToStart() {
    return _clickCountToStart;
  }

  public boolean isCellEditable(EventObject anEvent) {
    if (anEvent instanceof MouseEvent) {
      if (((MouseEvent) anEvent).getClickCount() < _clickCountToStart) {
        return false;
      }
    }
    return true;
  }

  public boolean shouldSelectCell(EventObject anEvent) {
    if (this.isCellEditable(anEvent)) {
      if (anEvent == null ||
          ((MouseEvent) anEvent).getClickCount() >= _clickCountToStart) {
        return true;
      }
    }
    return false;
  }

  public boolean stopCellEditing() {
    fireEditingStopped();
    return true;
  }

  public void cancelCellEditing() {
    fireEditingCanceled();
  }

  public void addCellEditorListener(CellEditorListener l) {
    _listenerList.add(CellEditorListener.class, l);
  }

  public void removeCellEditorListener(CellEditorListener l) {
    _listenerList.remove(CellEditorListener.class, l);
  }

  public Component getTreeCellEditorComponent(
      JTree tree, Object value,
      boolean isSelected,
      boolean expanded,
      boolean leaf, int row) {
    return null;
  }

  public Component getTableCellEditorComponent(
      JTable table, Object value,
      boolean isSelected,
      int row, int column) {
    return null;
  }

  
  
  
  protected void fireEditingStopped() {
    Object[] listeners = _listenerList.getListenerList();

    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CellEditorListener.class) {
        if (_changeEvent == null) {
          _changeEvent = new ChangeEvent(this);
        }

        ((CellEditorListener) listeners[i + 1]).editingStopped(_changeEvent);
      }
    }
  }

  protected void fireEditingCanceled() {
    Object[] listeners = _listenerList.getListenerList();

    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CellEditorListener.class) {
        if (_changeEvent == null) {
          _changeEvent = new ChangeEvent(this);
        }

        ((CellEditorListener) listeners[i + 1]).editingCanceled(_changeEvent);
      }
    }
  }

  
  
  

  
  
  

}
"
log4j,1.2,org.apache.log4j.AsyncAppender,15,2,0,9,43,19,1,9,15,0.821428571,279,0.0,3,0.5625,0.255555556,1,2,17.2,5,1.2667,5,"



package org.apache.log4j;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;



public class AsyncAppender extends AppenderSkeleton
  implements AppenderAttachable {
  
  public static final int DEFAULT_BUFFER_SIZE = 128;

  
  private final List buffer = new ArrayList();

  
  private final Map discardMap = new HashMap();

  
  private int bufferSize = DEFAULT_BUFFER_SIZE;

  
  AppenderAttachableImpl aai;

  
  private final AppenderAttachableImpl appenders;

  
  private final Thread dispatcher;

  
  private boolean locationInfo = false;

  
  private boolean blocking = true;

  
  public AsyncAppender() {
    appenders = new AppenderAttachableImpl();

    
    
    aai = appenders;

    dispatcher =
      new Thread(new Dispatcher(this, buffer, discardMap, appenders));

    
    
    dispatcher.setDaemon(true);

    
    
    dispatcher.setName(""AsyncAppender-Dispatcher-"" + dispatcher.getName());
    dispatcher.start();
  }

  
  public void addAppender(final Appender newAppender) {
    synchronized (appenders) {
      appenders.addAppender(newAppender);
    }
  }

  
  public void append(final LoggingEvent event) {
    
    
    
    
    if ((dispatcher == null) || !dispatcher.isAlive() || (bufferSize <= 0)) {
      synchronized (appenders) {
        appenders.appendLoopOnAppenders(event);
      }

      return;
    }

    
    
    event.getNDC();
    event.getThreadName();
    
    event.getMDCCopy();
    if (locationInfo) {
      event.getLocationInformation();
    }
    event.getRenderedMessage();
    event.getThrowableStrRep();

    synchronized (buffer) {
      while (true) {
        int previousSize = buffer.size();

        if (previousSize < bufferSize) {
          buffer.add(event);

          
          
          
          
          
          if (previousSize == 0) {
            buffer.notifyAll();
          }

          break;
        }

        
        
        
        
        
        
        
        boolean discard = true;
        if (blocking
                && !Thread.interrupted()
                && Thread.currentThread() != dispatcher) {
          try {
            buffer.wait();
            discard = false;
          } catch (InterruptedException e) {
            
            
            
            
            Thread.currentThread().interrupt();
          }
        }

        
        
        
        
        if (discard) {
          String loggerName = event.getLoggerName();
          DiscardSummary summary = (DiscardSummary) discardMap.get(loggerName);

          if (summary == null) {
            summary = new DiscardSummary(event);
            discardMap.put(loggerName, summary);
          } else {
            summary.add(event);
          }

          break;
        }
      }
    }
  }

  
  public void close() {
    
    synchronized (buffer) {
      closed = true;
      buffer.notifyAll();
    }

    try {
      dispatcher.join();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      org.apache.log4j.helpers.LogLog.error(
        ""Got an InterruptedException while waiting for the ""
        + ""dispatcher to finish."", e);
    }

    
    
    
    synchronized (appenders) {
      Enumeration iter = appenders.getAllAppenders();

      if (iter != null) {
        while (iter.hasMoreElements()) {
          Object next = iter.nextElement();

          if (next instanceof Appender) {
            ((Appender) next).close();
          }
        }
      }
    }
  }

  
  public Enumeration getAllAppenders() {
    synchronized (appenders) {
      return appenders.getAllAppenders();
    }
  }

  
  public Appender getAppender(final String name) {
    synchronized (appenders) {
      return appenders.getAppender(name);
    }
  }

  
  public boolean getLocationInfo() {
    return locationInfo;
  }

  
  public boolean isAttached(final Appender appender) {
    synchronized (appenders) {
      return appenders.isAttached(appender);
    }
  }

  
  public boolean requiresLayout() {
    return false;
  }

  
  public void removeAllAppenders() {
    synchronized (appenders) {
      appenders.removeAllAppenders();
    }
  }

  
  public void removeAppender(final Appender appender) {
    synchronized (appenders) {
      appenders.removeAppender(appender);
    }
  }

  
  public void removeAppender(final String name) {
    synchronized (appenders) {
      appenders.removeAppender(name);
    }
  }

  
  public void setLocationInfo(final boolean flag) {
    locationInfo = flag;
  }

  
  public void setBufferSize(final int size) {
    
    
    
    
    if (size < 0) {
      throw new java.lang.NegativeArraySizeException(""size"");
    }

    synchronized (buffer) {
      
      
      
      bufferSize = (size < 1) ? 1 : size;
      buffer.notifyAll();
    }
  }

  
  public int getBufferSize() {
    return bufferSize;
  }

  
  public void setBlocking(final boolean value) {
    synchronized (buffer) {
      blocking = value;
      buffer.notifyAll();
    }
  }

  
  public boolean getBlocking() {
    return blocking;
  }

  
  private static final class DiscardSummary {
    
    private LoggingEvent maxEvent;

    
    private int count;

    
    public DiscardSummary(final LoggingEvent event) {
      maxEvent = event;
      count = 1;
    }

    
    public void add(final LoggingEvent event) {
      if (event.getLevel().toInt() > maxEvent.getLevel().toInt()) {
        maxEvent = event;
      }

      count++;
    }

    
    public LoggingEvent createEvent() {
      String msg =
        MessageFormat.format(
          ""Discarded {0} messages due to full event buffer including: {1}"",
          new Object[] { new Integer(count), maxEvent.getMessage() });

      return new LoggingEvent(
              ""org.apache.log4j.AsyncAppender.DONT_REPORT_LOCATION"",
              Logger.getLogger(maxEvent.getLoggerName()),
              maxEvent.getLevel(),
              msg,
              null);
    }
  }

  
  private static class Dispatcher implements Runnable {
    
    private final AsyncAppender parent;

    
    private final List buffer;

    
    private final Map discardMap;

    
    private final AppenderAttachableImpl appenders;

    
    public Dispatcher(
      final AsyncAppender parent, final List buffer, final Map discardMap,
      final AppenderAttachableImpl appenders) {

      this.parent = parent;
      this.buffer = buffer;
      this.appenders = appenders;
      this.discardMap = discardMap;
    }

    
    public void run() {
      boolean isActive = true;

      
      
      
      try {
        
        
        
        while (isActive) {
          LoggingEvent[] events = null;

          
          
          
          
          synchronized (buffer) {
            int bufferSize = buffer.size();
            isActive = !parent.closed;

            while ((bufferSize == 0) && isActive) {
              buffer.wait();
              bufferSize = buffer.size();
              isActive = !parent.closed;
            }

            if (bufferSize > 0) {
              events = new LoggingEvent[bufferSize + discardMap.size()];
              buffer.toArray(events);

              
              
              
              int index = bufferSize;

              for (
                Iterator iter = discardMap.values().iterator();
                  iter.hasNext();) {
                events[index++] = ((DiscardSummary) iter.next()).createEvent();
              }

              
              
              
              buffer.clear();
              discardMap.clear();

              
              
              buffer.notifyAll();
            }
          }

          
          
          
          if (events != null) {
            for (int i = 0; i < events.length; i++) {
              synchronized (appenders) {
                appenders.appendLoopOnAppenders(events[i]);
              }
            }
          }
        }
      } catch (InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
"
log4j,1.2,org.apache.log4j.helpers.DateTimeDateFormat,4,4,0,3,15,4,2,1,4,0.333333333,80,0.0,0,0.953488372,0.357142857,1,3,18.75,2,0.75,4,"

package org.apache.log4j.helpers;

import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormatSymbols;


public class DateTimeDateFormat extends AbsoluteTimeDateFormat {
  private static final long serialVersionUID = 5547637772208514971L;

  String[] shortMonths;

  public
  DateTimeDateFormat() {
    super();
    shortMonths = new DateFormatSymbols().getShortMonths();
  }

  public
  DateTimeDateFormat(TimeZone timeZone) {
    this();
    setCalendar(Calendar.getInstance(timeZone));
  }

  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    calendar.setTime(date);

    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10)
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');
    sbuf.append(shortMonths[calendar.get(Calendar.MONTH)]);
    sbuf.append(' ');

    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    sbuf.append(' ');

    return super.format(date, sbuf, fieldPosition);
  }

  
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }
}
"
log4j,1.2,org.apache.log4j.Category,55,1,1,65,90,831,58,10,48,0.766666667,733,0.7,4,0.0,0.143874644,0,0,12.14545455,5,2.0545,5,"















package org.apache.log4j;

import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.HierarchyEventListener;
import org.apache.log4j.helpers.NullEnumeration;
import org.apache.log4j.helpers.AppenderAttachableImpl;

import java.util.Enumeration;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Vector;



public class Category implements AppenderAttachable {

  
  
  
  
  

  
  protected String   name;

  
  volatile protected Level level;

  
  volatile protected Category parent;

  
  private static final String FQCN = Category.class.getName();

  protected ResourceBundle resourceBundle;

  
  protected LoggerRepository repository;


  AppenderAttachableImpl aai;

  
  protected boolean additive = true;

  
  protected
  Category(String name) {
    this.name = name;
  }

  
  synchronized
  public
  void addAppender(Appender newAppender) {
    if(aai == null) {
      aai = new AppenderAttachableImpl();
    }
    aai.addAppender(newAppender);
    repository.fireAddAppenderEvent(this, newAppender);
  }

  
  public
  void assertLog(boolean assertion, String msg) {
    if(!assertion)
      this.error(msg);
  }


  
  public
  void callAppenders(LoggingEvent event) {
    int writes = 0;

    for(Category c = this; c != null; c=c.parent) {
      
      synchronized(c) {
	if(c.aai != null) {
	  writes += c.aai.appendLoopOnAppenders(event);
	}
	if(!c.additive) {
	  break;
	}
      }
    }

    if(writes == 0) {
      repository.emitNoAppenderWarning(this);
    }
  }

  
  synchronized
  void closeNestedAppenders() {
    Enumeration enumeration = this.getAllAppenders();
    if(enumeration != null) {
      while(enumeration.hasMoreElements()) {
	Appender a = (Appender) enumeration.nextElement();
	if(a instanceof AppenderAttachable) {
	  a.close();
	}
      }
    }
  }

  
  public
  void debug(Object message) {
    if(repository.isDisabled(Level.DEBUG_INT))
      return;
    if(Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel())) {
      forcedLog(FQCN, Level.DEBUG, message, null);
    }
  }


  
  public
  void debug(Object message, Throwable t) {
    if(repository.isDisabled(Level.DEBUG_INT))
      return;
    if(Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.DEBUG, message, t);
  }

  
  public
  void error(Object message) {
    if(repository.isDisabled(Level.ERROR_INT))
      return;
    if(Level.ERROR.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.ERROR, message, null);
  }

  
  public
  void error(Object message, Throwable t) {
    if(repository.isDisabled(Level.ERROR_INT))
      return;
    if(Level.ERROR.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.ERROR, message, t);

  }


  
  public
  static
  Logger exists(String name) {
    return LogManager.exists(name);
  }

  
  public
  void fatal(Object message) {
    if(repository.isDisabled(Level.FATAL_INT))
      return;
    if(Level.FATAL.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.FATAL, message, null);
  }

  
  public
  void fatal(Object message, Throwable t) {
    if(repository.isDisabled(Level.FATAL_INT))
      return;
    if(Level.FATAL.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.FATAL, message, t);
  }


  
  protected
  void forcedLog(String fqcn, Priority level, Object message, Throwable t) {
    callAppenders(new LoggingEvent(fqcn, this, level, message, t));
  }


  
  public
  boolean getAdditivity() {
    return additive;
  }

  
  synchronized
  public
  Enumeration getAllAppenders() {
    if(aai == null)
      return NullEnumeration.getInstance();
    else
      return aai.getAllAppenders();
  }

  
  synchronized
  public
  Appender getAppender(String name) {
     if(aai == null || name == null)
      return null;

     return aai.getAppender(name);
  }

  
  public
  Level getEffectiveLevel() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.level != null)
	return c.level;
    }
    return null; 
  }

  
  public
  Priority getChainedPriority() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.level != null)
	return c.level;
    }
    return null; 
  }


  
  public
  static
  Enumeration getCurrentCategories() {
    return LogManager.getCurrentLoggers();
  }


  
  public
  static
  LoggerRepository getDefaultHierarchy() {
    return LogManager.getLoggerRepository();
  }

  
  public
  LoggerRepository  getHierarchy() {
    return repository;
  }

  
  public
  LoggerRepository  getLoggerRepository() {
    return repository;
  }


 
  public
  static
  Category getInstance(String name) {
    return LogManager.getLogger(name);
  }

  
  public
  static
  Category getInstance(Class clazz) {
    return LogManager.getLogger(clazz);
  }


  
  public
  final
  String getName() {
    return name;
  }


  
  final
  public
  Category getParent() {
    return this.parent;
  }


  
  final
  public
  Level getLevel() {
    return this.level;
  }

  
  final
  public
  Level getPriority() {
    return this.level;
  }


  
  final
  public
  static
  Category getRoot() {
    return LogManager.getRootLogger();
  }

  
  public
  ResourceBundle getResourceBundle() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.resourceBundle != null)
	return c.resourceBundle;
    }
    
    return null;
  }

  
  protected
  String getResourceBundleString(String key) {
    ResourceBundle rb = getResourceBundle();
    
    
    if(rb == null) {
      
      
      
      
      return null;
    }
    else {
      try {
	return rb.getString(key);
      }
      catch(MissingResourceException mre) {
	error(""No resource is associated with key \""""+key+""\""."");
	return null;
      }
    }
  }

  
  public
  void info(Object message) {
    if(repository.isDisabled(Level.INFO_INT))
      return;
    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.INFO, message, null);
  }

  
  public
  void info(Object message, Throwable t) {
    if(repository.isDisabled(Level.INFO_INT))
      return;
    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.INFO, message, t);
  }

  
  public
  boolean isAttached(Appender appender) {
    if(appender == null || aai == null)
      return false;
    else {
      return aai.isAttached(appender);
    }
  }

  
  public
  boolean isDebugEnabled() {
    if(repository.isDisabled( Level.DEBUG_INT))
      return false;
    return Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel());
  }

  
  public
  boolean isEnabledFor(Priority level) {
    if(repository.isDisabled(level.level))
      return false;
    return level.isGreaterOrEqual(this.getEffectiveLevel());
  }

  
  public
  boolean isInfoEnabled() {
    if(repository.isDisabled(Level.INFO_INT))
      return false;
    return Level.INFO.isGreaterOrEqual(this.getEffectiveLevel());
  }


  
  public
  void l7dlog(Priority priority, String key, Throwable t) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {
      String msg = getResourceBundleString(key);
      
      
      if(msg == null) {
	msg = key;
      }
      forcedLog(FQCN, priority, msg, t);
    }
  }
  
  public
  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {
      String pattern = getResourceBundleString(key);
      String msg;
      if(pattern == null)
	msg = key;
      else
	msg = java.text.MessageFormat.format(pattern, params);
      forcedLog(FQCN, priority, msg, t);
    }
  }

  
  public
  void log(Priority priority, Object message, Throwable t) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, priority, message, t);
  }

 
  public
  void log(Priority priority, Object message) {
    if(repository.isDisabled(priority.level)) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, priority, message, null);
  }

  
  public
  void log(String callerFQCN, Priority level, Object message, Throwable t) {
    if(repository.isDisabled(level.level)) {
      return;
    }
    if(level.isGreaterOrEqual(this.getEffectiveLevel())) {
      forcedLog(callerFQCN, level, message, t);
    }
  }

    
   private void fireRemoveAppenderEvent(final Appender appender) {
       if (appender != null) {
         if (repository instanceof Hierarchy) {
           ((Hierarchy) repository).fireRemoveAppenderEvent(this, appender);
         } else if (repository instanceof HierarchyEventListener) {
             ((HierarchyEventListener) repository).removeAppenderEvent(this, appender);
         }
       }
   }

  
  synchronized
  public
  void removeAllAppenders() {
    if(aai != null) {
      Vector appenders = new Vector();
      for (Enumeration iter = aai.getAllAppenders(); iter != null && iter.hasMoreElements();) {
          appenders.add(iter.nextElement());
      }
      aai.removeAllAppenders();
      for(Enumeration iter = appenders.elements(); iter.hasMoreElements();) {
          fireRemoveAppenderEvent((Appender) iter.nextElement());
      }
      aai = null;
    }
  }


  
  synchronized
  public
  void removeAppender(Appender appender) {
    if(appender == null || aai == null)
      return;
    boolean wasAttached = aai.isAttached(appender);
    aai.removeAppender(appender);
    if (wasAttached) {
        fireRemoveAppenderEvent(appender);
    }
  }

  
  synchronized
  public
  void removeAppender(String name) {
    if(name == null || aai == null) return;
    Appender appender = aai.getAppender(name);
    aai.removeAppender(name);
    if (appender != null) {
        fireRemoveAppenderEvent(appender);
    }
  }

  
  public
  void setAdditivity(boolean additive) {
    this.additive = additive;
  }

  
  final
  void setHierarchy(LoggerRepository repository) {
    this.repository = repository;
  }

  
  public
  void setLevel(Level level) {
    this.level = level;
  }


  
  public
  void setPriority(Priority priority) {
    this.level = (Level) priority;
  }


  
  public
  void setResourceBundle(ResourceBundle bundle) {
    resourceBundle = bundle;
  }

  
  public
  static
  void shutdown() {
    LogManager.shutdown();
  }


  
  public
  void warn(Object message) {
    if(repository.isDisabled( Level.WARN_INT))
      return;

    if(Level.WARN.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.WARN, message, null);
  }

  
  public
  void warn(Object message, Throwable t) {
    if(repository.isDisabled(Level.WARN_INT))
      return;
    if(Level.WARN.isGreaterOrEqual(this.getEffectiveLevel()))
      forcedLog(FQCN, Level.WARN, message, t);
  }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNode,20,2,0,15,30,142,15,0,16,0.8,191,1.0,0,0.736111111,0.3125,2,3,8.3,3,1.25,3,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import java.util.Enumeration;





public class CategoryNode extends DefaultMutableTreeNode {
  private static final long serialVersionUID = 5958994817693177319L;
  
  
  

  
  
  
  protected boolean _selected = true;
  protected int _numberOfContainedRecords = 0;
  protected int _numberOfRecordsFromChildren = 0;
  protected boolean _hasFatalChildren = false;
  protected boolean _hasFatalRecords = false;

  
  
  

  
  
  

  
  public CategoryNode(String title) {
    setUserObject(title);
  }

  
  
  
  public String getTitle() {
    return (String) getUserObject();
  }

  public void setSelected(boolean s) {
    if (s != _selected) {
      _selected = s;
    }
  }

  public boolean isSelected() {
    return _selected;
  }

  
  public void setAllDescendantsSelected() {
    Enumeration children = children();
    while (children.hasMoreElements()) {
      CategoryNode node = (CategoryNode) children.nextElement();
      node.setSelected(true);
      node.setAllDescendantsSelected();
    }
  }

  
  public void setAllDescendantsDeSelected() {
    Enumeration children = children();
    while (children.hasMoreElements()) {
      CategoryNode node = (CategoryNode) children.nextElement();
      node.setSelected(false);
      node.setAllDescendantsDeSelected();
    }
  }

  public String toString() {
    return (getTitle());
  }

  public boolean equals(Object obj) {
    if (obj instanceof CategoryNode) {
      CategoryNode node = (CategoryNode) obj;
      String tit1 = getTitle().toLowerCase();
      String tit2 = node.getTitle().toLowerCase();

      if (tit1.equals(tit2)) {
        return (true);
      }
    }
    return (false);
  }

  public int hashCode() {
    return (getTitle().hashCode());
  }

  public void addRecord() {
    _numberOfContainedRecords++;
    addRecordToParent();
  }

  public int getNumberOfContainedRecords() {
    return _numberOfContainedRecords;
  }

  public void resetNumberOfContainedRecords() {
    _numberOfContainedRecords = 0;
    _numberOfRecordsFromChildren = 0;
    _hasFatalRecords = false;
    _hasFatalChildren = false;
  }

  public boolean hasFatalRecords() {
    return _hasFatalRecords;
  }

  public boolean hasFatalChildren() {
    return _hasFatalChildren;
  }

  public void setHasFatalRecords(boolean flag) {
    _hasFatalRecords = flag;
  }

  public void setHasFatalChildren(boolean flag) {
    _hasFatalChildren = flag;
  }

  
  
  

  protected int getTotalNumberOfRecords() {
    return getNumberOfRecordsFromChildren() + getNumberOfContainedRecords();
  }

  
  protected void addRecordFromChild() {
    _numberOfRecordsFromChildren++;
    addRecordToParent();
  }

  protected int getNumberOfRecordsFromChildren() {
    return _numberOfRecordsFromChildren;
  }

  protected void addRecordToParent() {
    TreeNode parent = getParent();
    if (parent == null) {
      return;
    }
    ((CategoryNode) parent).addRecordFromChild();
  }
  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.varia.Roller,7,1,0,2,32,15,0,2,1,0.625,168,0.0,1,0.0,0.277777778,0,0,22.42857143,2,1.1429,2,"

package org.apache.log4j.varia;

import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;


public class Roller {

  static Logger cat = Logger.getLogger(Roller.class);
  

  static String host;
  static int port;

  
  Roller() {
  }

  
  public 
  static 
  void main(String argv[]) {

    BasicConfigurator.configure();

    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    
    roll();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Roller.class.getName() +
			""host_name port_number"");
    System.exit(1);
  }

  static 
  void init(String hostArg, String portArg) {
    host = hostArg;
    try {
      port =  Integer.parseInt(portArg);
    }
    catch(java.lang.NumberFormatException e) {
      usage(""Second argument ""+portArg+"" is not a valid integer."");
    }
  }

  static
  void roll() {
    try {
      Socket socket = new Socket(host, port);
      DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
      DataInputStream dis = new DataInputStream(socket.getInputStream());
      dos.writeUTF(ExternallyRolledFileAppender.ROLL_OVER);
      String rc = dis.readUTF();
      if(ExternallyRolledFileAppender.OK.equals(rc)) {
	cat.info(""Roll over signal acknowledged by remote appender."");
      } else {
	cat.warn(""Unexpected return code ""+rc+"" from remote entity."");
	System.exit(2);
      }
    } catch(IOException e) {
      cat.error(""Could not send roll signal on host ""+host+"" port ""+port+"" ."",
		e);
      System.exit(2);
    }
    System.exit(0);
  }
}
"
log4j,1.2,org.apache.log4j.lf5.util.AdapterLogRecord,9,2,0,3,24,22,1,2,5,0.708333333,113,1.0,1,0.787878788,0.34375,2,3,11.22222222,2,1.0,2,"
package org.apache.log4j.lf5.util;

import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;

import java.io.PrintWriter;
import java.io.StringWriter;





public class AdapterLogRecord extends LogRecord {
  
  
  

  
  
  

  
  
  
  private static LogLevel severeLevel = null;

  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);

  
  
  
  public AdapterLogRecord() {
    super();
  }

  
  
  
  public void setCategory(String category) {
    super.setCategory(category);
    super.setLocation(getLocationInfo(category));
  }

  public boolean isSevereLevel() {
    if (severeLevel == null) return false;
    return severeLevel.equals(getLevel());
  }

  public static void setSevereLevel(LogLevel level) {
    severeLevel = level;
  }

  public static LogLevel getSevereLevel() {
    return severeLevel;
  }

  
  
  
  protected String getLocationInfo(String category) {
    String stackTrace = stackTraceToString(new Throwable());
    String line = parseLine(stackTrace, category);
    return line;
  }

  protected String stackTraceToString(Throwable t) {
    String s = null;

    synchronized (sw) {
      t.printStackTrace(pw);
      s = sw.toString();
      sw.getBuffer().setLength(0);
    }

    return s;
  }

  protected String parseLine(String trace, String category) {
    int index = trace.indexOf(category);
    if (index == -1) return null;
    trace = trace.substring(index);
    trace = trace.substring(0, trace.indexOf("")"") + 1);
    return trace;
  }
  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.net.SyslogAppender,16,2,0,7,35,58,0,7,15,1.002380952,460,0.071428571,1,0.580645161,0.260416667,1,3,26.0,22,4.0625,10,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.SyslogQuietWriter;
import org.apache.log4j.helpers.SyslogWriter;
import org.apache.log4j.spi.LoggingEvent;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.io.IOException;





public class SyslogAppender extends AppenderSkeleton {
  
  
  

  
  final static public int LOG_KERN     = 0;
  
  final static public int LOG_USER     = 1<<3;
  
  final static public int LOG_MAIL     = 2<<3;
  
  final static public int LOG_DAEMON   = 3<<3;
  
  final static public int LOG_AUTH     = 4<<3;
  
  final static public int LOG_SYSLOG   = 5<<3;

  
  final static public int LOG_LPR      = 6<<3;
  
  final static public int LOG_NEWS     = 7<<3;
  
  final static public int LOG_UUCP     = 8<<3;
  
  final static public int LOG_CRON     = 9<<3;
  
  final static public int LOG_AUTHPRIV = 10<<3;
  
  final static public int LOG_FTP      = 11<<3;

  
  
  final static public int LOG_LOCAL0 = 16<<3;
  
  final static public int LOG_LOCAL1 = 17<<3;
  
  final static public int LOG_LOCAL2 = 18<<3;
  
  final static public int LOG_LOCAL3 = 19<<3;
  
  final static public int LOG_LOCAL4 = 20<<3;
  
  final static public int LOG_LOCAL5 = 21<<3;
  
  final static public int LOG_LOCAL6 = 22<<3;
  
  final static public int LOG_LOCAL7 = 23<<3;

  protected static final int SYSLOG_HOST_OI = 0;
  protected static final int FACILITY_OI = 1;

  static final String TAB = ""    "";

  
  int syslogFacility = LOG_USER;
  String facilityStr;
  boolean facilityPrinting = false;

  
  SyslogQuietWriter sqw;
  String syslogHost;

    
  private boolean header = false;
    
  private final SimpleDateFormat dateFormat = new SimpleDateFormat(""MMM dd HH:mm:ss "", Locale.ENGLISH);
    
  private String localHostname;

    
  private boolean layoutHeaderChecked = false;

  public
  SyslogAppender() {
    this.initSyslogFacilityStr();
  }

  public
  SyslogAppender(Layout layout, int syslogFacility) {
    this.layout = layout;
    this.syslogFacility = syslogFacility;
    this.initSyslogFacilityStr();
  }

  public
  SyslogAppender(Layout layout, String syslogHost, int syslogFacility) {
    this(layout, syslogFacility);
    setSyslogHost(syslogHost);
  }

  
  synchronized
  public
  void close() {
    closed = true;
    if (sqw != null) {
        try {
            if (layoutHeaderChecked && layout != null && layout.getFooter() != null) {
                sendLayoutMessage(layout.getFooter());
            }
            sqw.close();
            sqw = null;
        } catch(java.io.InterruptedIOException e) {
            Thread.currentThread().interrupt();
            sqw = null;
        } catch(IOException e) {
            sqw = null;
        }
    }
  }

  private
  void initSyslogFacilityStr() {
    facilityStr = getFacilityString(this.syslogFacility);

    if (facilityStr == null) {
      System.err.println(""\"""" + syslogFacility +
                  ""\"" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
      facilityStr = ""user:"";
    } else {
      facilityStr += "":"";
    }
  }

  
  public
  static
  String getFacilityString(int syslogFacility) {
    switch(syslogFacility) {
    case LOG_KERN:      return ""kern"";
    case LOG_USER:      return ""user"";
    case LOG_MAIL:      return ""mail"";
    case LOG_DAEMON:    return ""daemon"";
    case LOG_AUTH:      return ""auth"";
    case LOG_SYSLOG:    return ""syslog"";
    case LOG_LPR:       return ""lpr"";
    case LOG_NEWS:      return ""news"";
    case LOG_UUCP:      return ""uucp"";
    case LOG_CRON:      return ""cron"";
    case LOG_AUTHPRIV:  return ""authpriv"";
    case LOG_FTP:       return ""ftp"";
    case LOG_LOCAL0:    return ""local0"";
    case LOG_LOCAL1:    return ""local1"";
    case LOG_LOCAL2:    return ""local2"";
    case LOG_LOCAL3:    return ""local3"";
    case LOG_LOCAL4:    return ""local4"";
    case LOG_LOCAL5:    return ""local5"";
    case LOG_LOCAL6:    return ""local6"";
    case LOG_LOCAL7:    return ""local7"";
    default:            return null;
    }
  }

  
  public
  static
  int getFacility(String facilityName) {
    if(facilityName != null) {
      facilityName = facilityName.trim();
    }
    if(""KERN"".equalsIgnoreCase(facilityName)) {
      return LOG_KERN;
    } else if(""USER"".equalsIgnoreCase(facilityName)) {
      return LOG_USER;
    } else if(""MAIL"".equalsIgnoreCase(facilityName)) {
      return LOG_MAIL;
    } else if(""DAEMON"".equalsIgnoreCase(facilityName)) {
      return LOG_DAEMON;
    } else if(""AUTH"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTH;
    } else if(""SYSLOG"".equalsIgnoreCase(facilityName)) {
      return LOG_SYSLOG;
    } else if(""LPR"".equalsIgnoreCase(facilityName)) {
      return LOG_LPR;
    } else if(""NEWS"".equalsIgnoreCase(facilityName)) {
      return LOG_NEWS;
    } else if(""UUCP"".equalsIgnoreCase(facilityName)) {
      return LOG_UUCP;
    } else if(""CRON"".equalsIgnoreCase(facilityName)) {
      return LOG_CRON;
    } else if(""AUTHPRIV"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTHPRIV;
    } else if(""FTP"".equalsIgnoreCase(facilityName)) {
      return LOG_FTP;
    } else if(""LOCAL0"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL0;
    } else if(""LOCAL1"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL1;
    } else if(""LOCAL2"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL2;
    } else if(""LOCAL3"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL3;
    } else if(""LOCAL4"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL4;
    } else if(""LOCAL5"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL5;
    } else if(""LOCAL6"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL6;
    } else if(""LOCAL7"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL7;
    } else {
      return -1;
    }
  }


  private void splitPacket(final String header, final String packet) {
      int byteCount = packet.getBytes().length;
      
      
      
      
      
      if (byteCount <= 1019) {
          sqw.write(packet);
      } else {
          int split = header.length() + (packet.length() - header.length())/2;
          splitPacket(header, packet.substring(0, split) + ""..."");
          splitPacket(header, header + ""..."" + packet.substring(split));
      }      
  }

  public
  void append(LoggingEvent event) {

    if(!isAsSevereAsThreshold(event.getLevel()))
      return;

    
    if(sqw == null) {
      errorHandler.error(""No syslog host is set for SyslogAppedender named \""""+
			this.name+""\""."");
      return;
    }

    if (!layoutHeaderChecked) {
        if (layout != null && layout.getHeader() != null) {
            sendLayoutMessage(layout.getHeader());
        }
        layoutHeaderChecked = true;
    }

    String hdr = getPacketHeader(event.timeStamp);
    String packet;
    if (layout == null) {
        packet = String.valueOf(event.getMessage());
    } else {
        packet = layout.format(event);
    }
    if(facilityPrinting || hdr.length() > 0) {
        StringBuffer buf = new StringBuffer(hdr);
        if(facilityPrinting) {
            buf.append(facilityStr);
        }
        buf.append(packet);
        packet = buf.toString();
    }

    sqw.setLevel(event.getLevel().getSyslogEquivalent());
    
    
    
    if (packet.length() > 256) {
        splitPacket(hdr, packet);
    } else {
        sqw.write(packet);
    }

    if (layout == null || layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
        for(int i = 0; i < s.length; i++) {
            if (s[i].startsWith(""\t"")) {
               sqw.write(hdr+TAB+s[i].substring(1));
            } else {
               sqw.write(hdr+s[i]);
            }
        }
      }
    }
  }

  
  public
  void activateOptions() {
      if (header) {
        getLocalHostname();
      }
      if (layout != null && layout.getHeader() != null) {
          sendLayoutMessage(layout.getHeader());
      }
      layoutHeaderChecked = true;
  }

  
  public
  boolean requiresLayout() {
    return true;
  }

  
  public
  void setSyslogHost(final String syslogHost) {
    this.sqw = new SyslogQuietWriter(new SyslogWriter(syslogHost),
				     syslogFacility, errorHandler);
    
    this.syslogHost = syslogHost;
  }

  
  public
  String getSyslogHost() {
    return syslogHost;
  }

  
  public
  void setFacility(String facilityName) {
    if(facilityName == null)
      return;

    syslogFacility = getFacility(facilityName);
    if (syslogFacility == -1) {
      System.err.println(""[""+facilityName +
                  ""] is an unknown syslog facility. Defaulting to [USER]."");
      syslogFacility = LOG_USER;
    }

    this.initSyslogFacilityStr();

    
    if(sqw != null) {
      sqw.setSyslogFacility(this.syslogFacility);
    }
  }

  
  public
  String getFacility() {
    return getFacilityString(syslogFacility);
  }

  
  public
  void setFacilityPrinting(boolean on) {
    facilityPrinting = on;
  }

  
  public
  boolean getFacilityPrinting() {
    return facilityPrinting;
  }

  
  public final boolean getHeader() {
      return header;
  }

    
  public final void setHeader(final boolean val) {
      header = val;
  }

    
  private String getLocalHostname() {
      if (localHostname == null) {
          try {
            InetAddress addr = InetAddress.getLocalHost();
            localHostname = addr.getHostName();
          } catch (UnknownHostException uhe) {
            localHostname = ""UNKNOWN_HOST"";
          }
      }
      return localHostname;
  }

    
  private String getPacketHeader(final long timeStamp) {
      if (header) {
        StringBuffer buf = new StringBuffer(dateFormat.format(new Date(timeStamp)));
        
        if (buf.charAt(4) == '0') {
          buf.setCharAt(4, ' ');
        }
        buf.append(getLocalHostname());
        buf.append(' ');
        return buf.toString();
      }
      return """";
  }

    
  private void sendLayoutMessage(final String msg) {
      if (sqw != null) {
          String packet = msg;
          String hdr = getPacketHeader(new Date().getTime());
          if(facilityPrinting || hdr.length() > 0) {
              StringBuffer buf = new StringBuffer(hdr);
              if(facilityPrinting) {
                  buf.append(facilityStr);
              }
              buf.append(msg);
              packet = buf.toString();
          }
          sqw.setLevel(6);
          sqw.write(packet);
      }
  }
}
"
log4j,1.2,org.apache.log4j.SimpleLayout,4,2,0,5,11,4,2,3,4,0.666666667,48,0.0,0,0.727272727,0.625,0,0,10.75,1,0.75,2,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;


public class SimpleLayout extends Layout {

  StringBuffer sbuf = new StringBuffer(128);

  public SimpleLayout() {
  }

  public
  void activateOptions() {
  }
  
  
  public
  String format(LoggingEvent event) {

    sbuf.setLength(0);
    sbuf.append(event.getLevel().toString());
    sbuf.append("" - "");
    sbuf.append(event.getRenderedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }


  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
log4j,1.2,org.apache.log4j.or.sax.AttributesRenderer,2,1,0,1,11,1,0,1,2,2.0,58,0.0,0,0.0,0.75,0,0,28.0,4,2.0,2,"

package org.apache.log4j.or.sax;

import org.apache.log4j.or.ObjectRenderer;

import org.xml.sax.Attributes;


public class AttributesRenderer implements ObjectRenderer {

  public
  AttributesRenderer() {
  }


  
  public
  String  doRender(Object o) {
    if(o instanceof Attributes) {
      StringBuffer sbuf = new StringBuffer();
      Attributes a = (Attributes) o;
      int len = a.getLength();
      boolean first = true;
      for(int i = 0; i < len; i++) {
	if(first) {
	  first = false;
	} else {
	  sbuf.append("", "");
	}
	sbuf.append(a.getQName(i));
	sbuf.append('=');
	sbuf.append(a.getValue(i));
      }
      return sbuf.toString();
    } else {
      try {
        return o.toString();
      } catch(Exception ex) {
          return ex.toString();
      }
    }
  }
}

"
log4j,1.2,org.apache.log4j.lf5.LogRecordFilter,1,1,0,8,1,0,7,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"
package org.apache.log4j.lf5;






public interface LogRecordFilter {
  
  
  

  
  
  

  
  public boolean passes(LogRecord record);

}

"
log4j,1.2,org.apache.log4j.helpers.OnlyOnceErrorHandler,8,1,0,6,11,22,1,5,8,0.857142857,53,0.0,0,0.0,0.339285714,0,0,5.25,2,1.125,2,"

package org.apache.log4j.helpers;

import  org.apache.log4j.spi.ErrorHandler;
import  org.apache.log4j.spi.LoggingEvent;
import  org.apache.log4j.Logger;
import  org.apache.log4j.Appender;

import java.io.InterruptedIOException;


public class OnlyOnceErrorHandler implements ErrorHandler {


  final String WARN_PREFIX = ""log4j warning: "";
  final String ERROR_PREFIX = ""log4j error: "";

  boolean firstTime = true;


  
  public 
  void setLogger(Logger logger) {
  }


  
  public 
  void activateOptions() {
  }


  
  public
  void error(String message, Exception e, int errorCode) { 
    error(message, e, errorCode, null);
  }

  
  public
  void error(String message, Exception e, int errorCode, LoggingEvent event) {
    if (e instanceof InterruptedIOException || e instanceof InterruptedException) {
        Thread.currentThread().interrupt();
    }
    if(firstTime) {
      LogLog.error(message, e);
      firstTime = false;
    }
  }


  
  public 
  void error(String message) {
    if(firstTime) {
      LogLog.error(message);
      firstTime = false;
    }
  }
  
  
  public
  void setAppender(Appender appender) {
  }

  
  public
  void setBackupAppender(Appender appender) {
  }
}
"
log4j,1.2,org.apache.log4j.TTCCLayout,10,3,0,5,23,0,1,4,10,0.611111111,172,1.0,0,0.652173913,0.375,1,1,15.8,5,1.2,2,"




package org.apache.log4j;

import org.apache.log4j.helpers.DateLayout;
import org.apache.log4j.spi.LoggingEvent;


public class TTCCLayout extends DateLayout {

  
  private boolean threadPrinting    = true;
  private boolean categoryPrefixing = true;
  private boolean contextPrinting   = true;


  protected final StringBuffer buf = new StringBuffer(256);


  
  public TTCCLayout() {
    this.setDateFormat(RELATIVE_TIME_DATE_FORMAT, null);
  }


  
  public TTCCLayout(String dateFormatType) {
    this.setDateFormat(dateFormatType);
  }


  
  public
  void setThreadPrinting(boolean threadPrinting) {
    this.threadPrinting = threadPrinting;
  }

  
  public
  boolean getThreadPrinting() {
    return threadPrinting;
  }

  
  public
  void setCategoryPrefixing(boolean categoryPrefixing) {
    this.categoryPrefixing = categoryPrefixing;
  }

  
  public
  boolean getCategoryPrefixing() {
    return categoryPrefixing;
  }

  
  public
  void setContextPrinting(boolean contextPrinting) {
    this.contextPrinting = contextPrinting;
  }

  
  public
  boolean getContextPrinting() {
    return contextPrinting;
  }

  
  public
  String format(LoggingEvent event) {

    
    buf.setLength(0);

    dateFormat(buf, event);

    if(this.threadPrinting) {
      buf.append('[');
      buf.append(event.getThreadName());
      buf.append(""] "");
    }
    buf.append(event.getLevel().toString());
    buf.append(' ');

    if(this.categoryPrefixing) {
      buf.append(event.getLoggerName());
      buf.append(' ');
    }

    if(this.contextPrinting) {
       String ndc = event.getNDC();

      if(ndc != null) {
	buf.append(ndc);
	buf.append(' ');
      }
    }
    buf.append(""- "");
    buf.append(event.getRenderedMessage());
    buf.append(LINE_SEP);
    return buf.toString();
  }

 
  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
log4j,1.2,org.apache.log4j.BasicConfigurator,4,1,0,13,10,6,6,7,3,2.0,27,0.0,0,0.0,0.25,0,0,5.75,1,0.75,2,"





package org.apache.log4j;



public class BasicConfigurator {

  protected BasicConfigurator() {
  }

  
  static
  public
  void configure() {
    Logger root = Logger.getRootLogger();
    root.addAppender(new ConsoleAppender(
           new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
  }

  
  static
  public
  void configure(Appender appender) {
    Logger root = Logger.getRootLogger();
    root.addAppender(appender);
  }

  
  public
  static
  void resetConfiguration() {
    LogManager.resetConfiguration();
  }
}
"
log4j,1.2,org.apache.log4j.helpers.CountingQuietWriter,4,4,0,3,8,0,1,2,4,0.333333333,38,1.0,0,0.875,0.4,2,2,8.25,1,0.75,2,"

package org.apache.log4j.helpers;

import java.io.Writer;
import java.io.IOException;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;


public class CountingQuietWriter extends QuietWriter {

  protected long count;

  public
  CountingQuietWriter(Writer writer, ErrorHandler eh) {
    super(writer, eh);
  }

  public
  void write(String string) {
    try {
      out.write(string);
      count += string.length();
    }
    catch(IOException e) {
      errorHandler.error(""Write failure."", e, ErrorCode.WRITE_FAILURE);
    }
  }

  public
  long getCount() {
    return count;
  }

  public
  void setCount(long count) {
    this.count = count;
  }

}
"
log4j,1.2,org.apache.log4j.lf5.util.ResourceUtils,3,1,0,2,11,3,2,1,3,2.0,46,0.0,0,0.0,0.555555556,0,0,14.33333333,2,1.3333,2,"
package org.apache.log4j.lf5.util;

import java.io.InputStream;
import java.net.URL;





public class ResourceUtils {
  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  public static InputStream getResourceAsStream(Object object, Resource resource) {
    ClassLoader loader = object.getClass().getClassLoader();

    InputStream in = null;

    if (loader != null) {
      in = loader.getResourceAsStream(resource.getName());
    } else {
      in = ClassLoader.getSystemResourceAsStream(resource.getName());
    }

    return in;
  }

  
  public static URL getResourceAsURL(Object object, Resource resource) {
    ClassLoader loader = object.getClass().getClassLoader();

    URL url = null;

    if (loader != null) {
      url = loader.getResource(resource.getName());
    } else {
      url = ClassLoader.getSystemResource(resource.getName());
    }

    return (url);
  }

  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.spi.RepositorySelector,1,1,0,3,1,0,2,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"



package org.apache.log4j.spi;



public interface RepositorySelector {

  
  public
  LoggerRepository getLoggerRepository();
}

"
log4j,1.2,org.apache.log4j.helpers.PatternParser,8,1,0,16,42,8,4,15,2,0.956043956,708,0.461538462,3,0.0,0.375,0,0,84.25,21,4.75,3,"
package org.apache.log4j.helpers;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.Arrays;






public class PatternParser {

  private static final char ESCAPE_CHAR = '%';

  private static final int LITERAL_STATE = 0;
  private static final int CONVERTER_STATE = 1;
  private static final int DOT_STATE = 3;
  private static final int MIN_STATE = 4;
  private static final int MAX_STATE = 5;

  static final int FULL_LOCATION_CONVERTER = 1000;
  static final int METHOD_LOCATION_CONVERTER = 1001;
  static final int CLASS_LOCATION_CONVERTER = 1002;
  static final int LINE_LOCATION_CONVERTER = 1003;
  static final int FILE_LOCATION_CONVERTER = 1004;

  static final int RELATIVE_TIME_CONVERTER = 2000;
  static final int THREAD_CONVERTER = 2001;
  static final int LEVEL_CONVERTER = 2002;
  static final int NDC_CONVERTER = 2003;
  static final int MESSAGE_CONVERTER = 2004;

  int state;
  protected StringBuffer currentLiteral = new StringBuffer(32);
  protected int patternLength;
  protected int i;
  PatternConverter head;
  PatternConverter tail;
  protected FormattingInfo formattingInfo = new FormattingInfo();
  protected String pattern;

  public
  PatternParser(String pattern) {
    this.pattern = pattern;
    patternLength =  pattern.length();
    state = LITERAL_STATE;
  }

  private
  void  addToList(PatternConverter pc) {
    if(head == null) {
      head = tail = pc;
    } else {
      tail.next = pc;
      tail = pc;
    }
  }

  protected
  String extractOption() {
    if((i < patternLength) && (pattern.charAt(i) == '{')) {
      int end = pattern.indexOf('}', i);
      if (end > i) {
	String r = pattern.substring(i + 1, end);
	i = end+1;
	return r;
      }
    }
    return null;
  }


  
  protected
  int extractPrecisionOption() {
    String opt = extractOption();
    int r = 0;
    if(opt != null) {
      try {
	r = Integer.parseInt(opt);
	if(r <= 0) {
	    LogLog.error(
	        ""Precision option ("" + opt + "") isn't a positive integer."");
	    r = 0;
	}
      }
      catch (NumberFormatException e) {
	LogLog.error(""Category option \""""+opt+""\"" not a decimal integer."", e);
      }
    }
    return r;
  }

  public
  PatternConverter parse() {
    char c;
    i = 0;
    while(i < patternLength) {
      c = pattern.charAt(i++);
      switch(state) {
      case LITERAL_STATE:
        
        if(i == patternLength) {
          currentLiteral.append(c);
          continue;
        }
        if(c == ESCAPE_CHAR) {
          
          switch(pattern.charAt(i)) {
          case ESCAPE_CHAR:
            currentLiteral.append(c);
            i++; 
            break;
          case 'n':
            currentLiteral.append(Layout.LINE_SEP);
            i++; 
            break;
          default:
            if(currentLiteral.length() != 0) {
              addToList(new LiteralPatternConverter(
                                                  currentLiteral.toString()));
              
              
            }
            currentLiteral.setLength(0);
            currentLiteral.append(c); 
            state = CONVERTER_STATE;
            formattingInfo.reset();
          }
        }
        else {
          currentLiteral.append(c);
        }
        break;
      case CONVERTER_STATE:
	currentLiteral.append(c);
	switch(c) {
	case '-':
	  formattingInfo.leftAlign = true;
	  break;
	case '.':
	  state = DOT_STATE;
	  break;
	default:
	  if(c >= '0' && c <= '9') {
	    formattingInfo.min = c - '0';
	    state = MIN_STATE;
	  }
	  else
	    finalizeConverter(c);
	} 
	break;
      case MIN_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9')
	  formattingInfo.min = formattingInfo.min*10 + (c - '0');
	else if(c == '.')
	  state = DOT_STATE;
	else {
	  finalizeConverter(c);
	}
	break;
      case DOT_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') {
	  formattingInfo.max = c - '0';
	   state = MAX_STATE;
	}
	else {
	  LogLog.error(""Error occured in position ""+i
		     +"".\n Was expecting digit, instead got char \""""+c+""\""."");
	  state = LITERAL_STATE;
	}
	break;
      case MAX_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9')
	  formattingInfo.max = formattingInfo.max*10 + (c - '0');
	else {
	  finalizeConverter(c);
	  state = LITERAL_STATE;
	}
	break;
      } 
    } 
    if(currentLiteral.length() != 0) {
      addToList(new LiteralPatternConverter(currentLiteral.toString()));
      
    }
    return head;
  }

  protected
  void finalizeConverter(char c) {
    PatternConverter pc = null;
    switch(c) {
    case 'c':
      pc = new CategoryPatternConverter(formattingInfo,
					extractPrecisionOption());
      
      
      currentLiteral.setLength(0);
      break;
    case 'C':
      pc = new ClassNamePatternConverter(formattingInfo,
					 extractPrecisionOption());
      
      
      currentLiteral.setLength(0);
      break;
    case 'd':
      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;
      DateFormat df;
      String dOpt = extractOption();
      if(dOpt != null)
	dateFormatStr = dOpt;

      if(dateFormatStr.equalsIgnoreCase(
                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT))
	df = new  ISO8601DateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
	df = new AbsoluteTimeDateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
	df = new DateTimeDateFormat();
      else {
	try {
	  df = new SimpleDateFormat(dateFormatStr);
	}
	catch (IllegalArgumentException e) {
	  LogLog.error(""Could not instantiate SimpleDateFormat with "" +
		       dateFormatStr, e);
	  df = (DateFormat) OptionConverter.instantiateByClassName(
			           ""org.apache.log4j.helpers.ISO8601DateFormat"",
				   DateFormat.class, null);
	}
      }
      pc = new DatePatternConverter(formattingInfo, df);
      
      
      currentLiteral.setLength(0);
      break;
    case 'F':
      pc = new LocationPatternConverter(formattingInfo,
					FILE_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'l':
      pc = new LocationPatternConverter(formattingInfo,
					FULL_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'L':
      pc = new LocationPatternConverter(formattingInfo,
					LINE_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'm':
      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'M':
      pc = new LocationPatternConverter(formattingInfo,
					METHOD_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'p':
      pc = new BasicPatternConverter(formattingInfo, LEVEL_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'r':
      pc = new BasicPatternConverter(formattingInfo,
					 RELATIVE_TIME_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 't':
      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
      
    case 'x':
      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);
      
      currentLiteral.setLength(0);
      break;
    case 'X':
      String xOpt = extractOption();
      pc = new MDCPatternConverter(formattingInfo, xOpt);
      currentLiteral.setLength(0);
      break;
    default:
      LogLog.error(""Unexpected char ["" +c+""] at position ""+i
		   +"" in conversion patterrn."");
      pc = new LiteralPatternConverter(currentLiteral.toString());
      currentLiteral.setLength(0);
    }

    addConverter(pc);
  }

  protected
  void addConverter(PatternConverter pc) {
    currentLiteral.setLength(0);
    
    addToList(pc);
    
    state = LITERAL_STATE;
    
    formattingInfo.reset();
  }

  
  
  

  private static class BasicPatternConverter extends PatternConverter {
    int type;

    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }

    public
    String convert(LoggingEvent event) {
      switch(type) {
      case RELATIVE_TIME_CONVERTER:
	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));
      case THREAD_CONVERTER:
	return event.getThreadName();
      case LEVEL_CONVERTER:
	return event.getLevel().toString();
      case NDC_CONVERTER:
	return event.getNDC();
      case MESSAGE_CONVERTER: {
	return event.getRenderedMessage();
      }
      default: return null;
      }
    }
  }

  private static class LiteralPatternConverter extends PatternConverter {
    private String literal;

    LiteralPatternConverter(String value) {
      literal = value;
    }

    public
    final
    void format(StringBuffer sbuf, LoggingEvent event) {
      sbuf.append(literal);
    }

    public
    String convert(LoggingEvent event) {
      return literal;
    }
  }

  private static class DatePatternConverter extends PatternConverter {
    private DateFormat df;
    private Date date;

    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
      super(formattingInfo);
      date = new Date();
      this.df = df;
    }

    public
    String convert(LoggingEvent event) {
      date.setTime(event.timeStamp);
      String converted = null;
      try {
        converted = df.format(date);
      }
      catch (Exception ex) {
        LogLog.error(""Error occured while converting date."", ex);
      }
      return converted;
    }
  }

  private static class MDCPatternConverter extends PatternConverter {
    private String key;

    MDCPatternConverter(FormattingInfo formattingInfo, String key) {
      super(formattingInfo);
      this.key = key;
    }

    public
    String convert(LoggingEvent event) {
      if (key == null) {
          StringBuffer buf = new StringBuffer(""{"");
          Map properties = event.getProperties();
          if (properties.size() > 0) {
            Object[] keys = properties.keySet().toArray();
            Arrays.sort(keys);
            for (int i = 0; i < keys.length; i++) {
                buf.append('{');
                buf.append(keys[i]);
                buf.append(',');
                buf.append(properties.get(keys[i]));
                buf.append('}');
            }
          }
          buf.append('}');
          return buf.toString();
      } else {
        Object val = event.getMDC(key);
        if(val == null) {
	        return null;
        } else {
	        return val.toString();
        }
      }
    }
  }


  private class LocationPatternConverter extends PatternConverter {
    int type;

    LocationPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }

    public
    String convert(LoggingEvent event) {
      LocationInfo locationInfo = event.getLocationInformation();
      switch(type) {
      case FULL_LOCATION_CONVERTER:
	return locationInfo.fullInfo;
      case METHOD_LOCATION_CONVERTER:
	return locationInfo.getMethodName();
      case LINE_LOCATION_CONVERTER:
	return locationInfo.getLineNumber();
      case FILE_LOCATION_CONVERTER:
	return locationInfo.getFileName();
      default: return null;
      }
    }
  }

  private static abstract class NamedPatternConverter extends PatternConverter {
    int precision;

    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo);
      this.precision =  precision;
    }

    abstract
    String getFullyQualifiedName(LoggingEvent event);

    public
    String convert(LoggingEvent event) {
      String n = getFullyQualifiedName(event);
      if(precision <= 0)
	return n;
      else {
	int len = n.length();

	
	
	
	int end = len -1 ;
	for(int i = precision; i > 0; i--) {
	  end = n.lastIndexOf('.', end-1);
	  if(end == -1)
	    return n;
	}
	return n.substring(end+1, len);
      }
    }
  }

  private class ClassNamePatternConverter extends NamedPatternConverter {

    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }

    String getFullyQualifiedName(LoggingEvent event) {
      return event.getLocationInformation().getClassName();
    }
  }

  private class CategoryPatternConverter extends NamedPatternConverter {

    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }

    String getFullyQualifiedName(LoggingEvent event) {
      return event.getLoggerName();
    }
  }
}

"
log4j,1.2,org.apache.log4j.config.PropertySetter,10,1,0,8,49,13,2,6,6,0.694444444,395,0.5,0,0.0,0.35,0,0,38.1,11,2.9,2,"



package org.apache.log4j.config;

import org.apache.log4j.Appender;
import org.apache.log4j.Level;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.ErrorHandler;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.InterruptedIOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Properties;


public class PropertySetter {
  protected Object obj;
  protected PropertyDescriptor[] props;
  
  
  public
  PropertySetter(Object obj) {
    this.obj = obj;
  }
  
  
  protected
  void introspect() {
    try {
      BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
      props = bi.getPropertyDescriptors();
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect ""+obj+"": "" + ex.getMessage());
      props = new PropertyDescriptor[0];
    }
  }
  

  
  public
  static
  void setProperties(Object obj, Properties properties, String prefix) {
    new PropertySetter(obj).setProperties(properties, prefix);
  }
  

  
  public
  void setProperties(Properties properties, String prefix) {
    int len = prefix.length();
    
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      
      
      if (key.startsWith(prefix)) {

	
	
        if (key.indexOf('.', len + 1) > 0) {
	  
	  
	  continue;
	}
        
	String value = OptionConverter.findAndSubst(key, properties);
        key = key.substring(len);
        if ((""layout"".equals(key) || ""errorhandler"".equals(key)) && obj instanceof Appender) {
          continue;
        }
        
        
        
        PropertyDescriptor prop = getPropertyDescriptor(Introspector.decapitalize(key));
        if (prop != null
                && OptionHandler.class.isAssignableFrom(prop.getPropertyType())
                && prop.getWriteMethod() != null) {
            OptionHandler opt = (OptionHandler)
                    OptionConverter.instantiateByKey(properties, prefix + key,
                                  prop.getPropertyType(),
                                  null);
            PropertySetter setter = new PropertySetter(opt);
            setter.setProperties(properties, prefix + key + ""."");
            try {
                prop.getWriteMethod().invoke(this.obj, new Object[] { opt });
            } catch(IllegalAccessException ex) {
                LogLog.warn(""Failed to set property ["" + key +
                            ""] to value \"""" + value + ""\"". "", ex);
            } catch(InvocationTargetException ex) {
                if (ex.getTargetException() instanceof InterruptedException
                        || ex.getTargetException() instanceof InterruptedIOException) {
                    Thread.currentThread().interrupt();
                }
                LogLog.warn(""Failed to set property ["" + key +
                            ""] to value \"""" + value + ""\"". "", ex);
            } catch(RuntimeException ex) {
                LogLog.warn(""Failed to set property ["" + key +
                            ""] to value \"""" + value + ""\"". "", ex);
            }
            continue;
        }

        setProperty(key, value);
      }
    }
    activate();
  }
  
  
  public
  void setProperty(String name, String value) {
    if (value == null) return;
    
    name = Introspector.decapitalize(name);
    PropertyDescriptor prop = getPropertyDescriptor(name);
    
    

    if (prop == null) {
      LogLog.warn(""No such property ["" + name + ""] in ""+
		  obj.getClass().getName()+""."" );
    } else {
      try {
        setProperty(prop, name, value);
      } catch (PropertySetterException ex) {
        LogLog.warn(""Failed to set property ["" + name +
                    ""] to value \"""" + value + ""\"". "", ex.rootCause);
      }
    }
  }
  
  
  public
  void setProperty(PropertyDescriptor prop, String name, String value)
    throws PropertySetterException {
    Method setter = prop.getWriteMethod();
    if (setter == null) {
      throw new PropertySetterException(""No setter for property [""+name+""]."");
    }
    Class[] paramTypes = setter.getParameterTypes();
    if (paramTypes.length != 1) {
      throw new PropertySetterException(""#params for setter != 1"");
    }
    
    Object arg;
    try {
      arg = convertArg(value, paramTypes[0]);
    } catch (Throwable t) {
      throw new PropertySetterException(""Conversion to type [""+paramTypes[0]+
					""] failed. Reason: ""+t);
    }
    if (arg == null) {
      throw new PropertySetterException(
          ""Conversion to type [""+paramTypes[0]+""] failed."");
    }
    LogLog.debug(""Setting property ["" + name + ""] to ["" +arg+""]."");
    try {
      setter.invoke(obj, new Object[]  { arg });
    } catch (IllegalAccessException ex) {
      throw new PropertySetterException(ex);
    } catch (InvocationTargetException ex) {
        if (ex.getTargetException() instanceof InterruptedException
                || ex.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }        
        throw new PropertySetterException(ex);
    } catch (RuntimeException ex) {
      throw new PropertySetterException(ex);
    }
  }
  

  
  protected
  Object convertArg(String val, Class type) {
    if(val == null)
      return null;

    String v = val.trim();
    if (String.class.isAssignableFrom(type)) {
      return val;
    } else if (Integer.TYPE.isAssignableFrom(type)) {
      return new Integer(v);
    } else if (Long.TYPE.isAssignableFrom(type)) {
      return new Long(v);
    } else if (Boolean.TYPE.isAssignableFrom(type)) {
      if (""true"".equalsIgnoreCase(v)) {
        return Boolean.TRUE;
      } else if (""false"".equalsIgnoreCase(v)) {
        return Boolean.FALSE;
      }
    } else if (Priority.class.isAssignableFrom(type)) {
      return OptionConverter.toLevel(v, (Level) Level.DEBUG);
    } else if (ErrorHandler.class.isAssignableFrom(type)) {
      return OptionConverter.instantiateByClassName(v, 
	  ErrorHandler.class, null);
    }
    return null;
  }
  
  
  protected
  PropertyDescriptor getPropertyDescriptor(String name) {
    if (props == null) introspect();
    
    for (int i = 0; i < props.length; i++) {
      if (name.equals(props[i].getName())) {
	return props[i];
      }
    }
    return null;
  }
  
  public
  void activate() {
    if (obj instanceof OptionHandler) {
      ((OptionHandler) obj).activateOptions();
    }
  }
}
"
log4j,1.2,org.apache.log4j.jmx.AbstractDynamicMBean,12,1,4,6,31,64,4,2,11,0.954545455,167,0.0,0,0.0,0.203703704,0,0,12.75,4,1.4167,2,"

package org.apache.log4j.jmx;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

import javax.management.Attribute;
import javax.management.AttributeList;
import javax.management.DynamicMBean;
import javax.management.InstanceAlreadyExistsException;
import javax.management.InstanceNotFoundException;
import javax.management.JMException;
import javax.management.MBeanRegistration;
import javax.management.MBeanRegistrationException;
import javax.management.MBeanServer;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectName;
import javax.management.RuntimeOperationsException;

import org.apache.log4j.Logger;
import org.apache.log4j.Appender;

public abstract class AbstractDynamicMBean implements DynamicMBean,
                                                      MBeanRegistration {

  String dClassName;
  MBeanServer server;
  private final Vector mbeanList = new Vector();

    
  static protected String getAppenderName(final Appender appender){
      String name = appender.getName();
      if (name == null || name.trim().length() == 0) {
          
          name = appender.toString();
      }
      return name;
  }
      

  
  public
  AttributeList getAttributes(String[] attributeNames) {

    
    if (attributeNames == null) {
      throw new RuntimeOperationsException(
			   new IllegalArgumentException(""attributeNames[] cannot be null""),
			   ""Cannot invoke a getter of "" + dClassName);
    }

    AttributeList resultList = new AttributeList();

    
    if (attributeNames.length == 0)
      return resultList;

    
    for (int i=0 ; i<attributeNames.length ; i++){
      try {
	Object value = getAttribute((String) attributeNames[i]);
	resultList.add(new Attribute(attributeNames[i],value));
      } catch (JMException e) {
	     e.printStackTrace();
      } catch (RuntimeException e) {
	     e.printStackTrace();
      }
    }
    return(resultList);
  }

  
  public AttributeList setAttributes(AttributeList attributes) {

    
    if (attributes == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""AttributeList attributes cannot be null""),
		    ""Cannot invoke a setter of "" + dClassName);
    }
    AttributeList resultList = new AttributeList();

    
    if (attributes.isEmpty())
      return resultList;

    
    for (Iterator i = attributes.iterator(); i.hasNext();) {
      Attribute attr = (Attribute) i.next();
      try {
	setAttribute(attr);
	String name = attr.getName();
	Object value = getAttribute(name);
	resultList.add(new Attribute(name,value));
      } catch(JMException e) {
	    e.printStackTrace();
      } catch(RuntimeException e) {
	    e.printStackTrace();
      }
    }
    return(resultList);
  }

  protected
  abstract
  Logger getLogger();

  public
  void postDeregister() {
    getLogger().debug(""postDeregister is called."");
  }

  public
  void postRegister(java.lang.Boolean registrationDone) {
  }



  public
  ObjectName preRegister(MBeanServer server, ObjectName name) {
    getLogger().debug(""preRegister called. Server=""+server+ "", name=""+name);
    this.server = server;
    return name;
  }
  
  protected
  void registerMBean(Object mbean, ObjectName objectName)
  throws InstanceAlreadyExistsException, MBeanRegistrationException,
                   NotCompliantMBeanException {
    server.registerMBean(mbean, objectName);
    mbeanList.add(objectName);
  }

  
   public
   void preDeregister() {
     getLogger().debug(""preDeregister called."");
     
    Enumeration iterator = mbeanList.elements();
    while (iterator.hasMoreElements()) {
      ObjectName name = (ObjectName) iterator.nextElement();
      try {
        server.unregisterMBean(name);
      } catch (InstanceNotFoundException e) {
   getLogger().warn(""Missing MBean "" + name.getCanonicalName());
      } catch (MBeanRegistrationException e) {
   getLogger().warn(""Failed unregistering "" + name.getCanonicalName());
      }
    }
   }


}
"
log4j,1.2,org.apache.log4j.lf5.Log4JLogRecord,3,2,0,5,10,3,2,3,3,2.0,57,0.0,0,0.928571429,0.666666667,2,3,18.0,3,1.6667,2,"

package org.apache.log4j.lf5;

import org.apache.log4j.spi.ThrowableInformation;





public class Log4JLogRecord extends LogRecord {
  
  
  

  
  
  

  
  
  

  
  
  

  
  public Log4JLogRecord() {
  }

  
  
  
  
  public boolean isSevereLevel() {
    boolean isSevere = false;

    if (LogLevel.ERROR.equals(getLevel()) ||
        LogLevel.FATAL.equals(getLevel())) {
      isSevere = true;
    }

    return isSevere;
  }

  
  public void setThrownStackTrace(ThrowableInformation throwableInfo) {
    String[] stackTraceArray = throwableInfo.getThrowableStrRep();

    StringBuffer stackTrace = new StringBuffer();
    String nextLine;

    for (int i = 0; i < stackTraceArray.length; i++) {
      nextLine = stackTraceArray[i] + ""\n"";
      stackTrace.append(nextLine);
    }

    _thrownStackTrace = stackTrace.toString();
  }

  
  
  

  
  
  

  
  
  

}



"
log4j,1.2,org.apache.log4j.Layout,8,1,5,36,11,28,34,2,7,1.0,26,0.0,0,0.0,0.571428571,0,0,2.0,1,0.75,2,"

package org.apache.log4j;

import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;


  
public abstract class Layout implements OptionHandler {

  
  
  public final static String LINE_SEP = System.getProperty(""line.separator"");
  public final static int LINE_SEP_LEN  = LINE_SEP.length();


  
  abstract
  public
  String format(LoggingEvent event);

  
  public
  String getContentType() {
    return ""text/plain"";
  }

  
  public
  String getHeader() {
    return null;
  }

  
  public
  String getFooter() {
    return null;
  }



  
  abstract
  public
  boolean ignoresThrowable();

}
"
log4j,1.2,org.apache.log4j.xml.DOMConfigurator,29,1,0,24,115,356,6,19,11,0.992277992,1589,0.0,1,0.0,0.163265306,0,0,52.51724138,18,3.2069,8,"

package org.apache.log4j.xml;

import org.apache.log4j.Appender;
import org.apache.log4j.Layout;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.config.PropertySetter;
import org.apache.log4j.helpers.FileWatchdog;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.spi.ThrowableRenderer;
import org.apache.log4j.spi.ThrowableRendererSupport;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.Reader;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Hashtable;
import java.util.Properties;





public class DOMConfigurator implements Configurator {

  static final String CONFIGURATION_TAG = ""log4j:configuration"";
  static final String OLD_CONFIGURATION_TAG = ""configuration"";
  static final String RENDERER_TAG      = ""renderer"";
  private static final String THROWABLE_RENDERER_TAG = ""throwableRenderer"";
  static final String APPENDER_TAG 	= ""appender"";
  static final String APPENDER_REF_TAG 	= ""appender-ref"";  
  static final String PARAM_TAG    	= ""param"";
  static final String LAYOUT_TAG	= ""layout"";
  static final String CATEGORY		= ""category"";
  static final String LOGGER		= ""logger"";
  static final String LOGGER_REF	= ""logger-ref"";
  static final String CATEGORY_FACTORY_TAG  = ""categoryFactory"";
  static final String LOGGER_FACTORY_TAG  = ""loggerFactory"";
  static final String NAME_ATTR		= ""name"";
  static final String CLASS_ATTR        = ""class"";
  static final String VALUE_ATTR	= ""value"";
  static final String ROOT_TAG		= ""root"";
  static final String ROOT_REF		= ""root-ref"";
  static final String LEVEL_TAG	        = ""level"";
  static final String PRIORITY_TAG      = ""priority"";
  static final String FILTER_TAG	= ""filter"";
  static final String ERROR_HANDLER_TAG	= ""errorHandler"";
  static final String REF_ATTR		= ""ref"";
  static final String ADDITIVITY_ATTR    = ""additivity"";  
  static final String THRESHOLD_ATTR       = ""threshold"";
  static final String CONFIG_DEBUG_ATTR  = ""configDebug"";
  static final String INTERNAL_DEBUG_ATTR  = ""debug"";
  private static final String RESET_ATTR  = ""reset"";
  static final String RENDERING_CLASS_ATTR = ""renderingClass"";
  static final String RENDERED_CLASS_ATTR = ""renderedClass"";

  static final String EMPTY_STR = """";
  static final Class[] ONE_STRING_PARAM = new Class[] {String.class};

  final static String dbfKey = ""javax.xml.parsers.DocumentBuilderFactory"";

  
  
  Hashtable appenderBag;

  Properties props;
  LoggerRepository repository;

  protected LoggerFactory catFactory = null;

  
  public
  DOMConfigurator () { 
    appenderBag = new Hashtable();
  }

  
  protected
  Appender findAppenderByName(Document doc, String appenderName)  {      
    Appender appender = (Appender) appenderBag.get(appenderName);

    if(appender != null) {
      return appender;
    } else {
      
      
                        
      
      Element element = null;
      NodeList list = doc.getElementsByTagName(""appender"");
      for (int t=0; t < list.getLength(); t++) {
	Node node = list.item(t);
	NamedNodeMap map= node.getAttributes();
	Node attrNode = map.getNamedItem(""name"");
	if (appenderName.equals(attrNode.getNodeValue())) {
	  element = (Element) node;
	  break;
	}
      }
      

      if(element == null) {
	LogLog.error(""No appender named [""+appenderName+""] could be found.""); 
	return null;
      } else {
	      appender = parseAppender(element);
          if (appender != null) {
            appenderBag.put(appenderName, appender);
          }
    return appender;
      }
    } 
  }
  
  protected
  Appender findAppenderByReference(Element appenderRef) {    
    String appenderName = subst(appenderRef.getAttribute(REF_ATTR));    
    Document doc = appenderRef.getOwnerDocument();
    return findAppenderByName(doc, appenderName);
  }

    
  private static void parseUnrecognizedElement(final Object instance,
                                        final Element element,
                                        final Properties props) throws Exception {
      boolean recognized = false;
      if (instance instanceof UnrecognizedElementHandler) {
          recognized = ((UnrecognizedElementHandler) instance).parseUnrecognizedElement(
                  element, props);
      }
      if (!recognized) {
          LogLog.warn(""Unrecognized element "" + element.getNodeName());
      }
  }

    
   private static void quietParseUnrecognizedElement(final Object instance,
                                          final Element element,
                                          final Properties props) {
      try {
          parseUnrecognizedElement(instance, element, props);
      } catch (Exception ex) {
          if (ex instanceof InterruptedException || ex instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
          LogLog.error(""Error in extension content: "", ex);
      }
  }

  
  protected
  Appender parseAppender (Element appenderElement) {
    String className = subst(appenderElement.getAttribute(CLASS_ATTR));
    LogLog.debug(""Class name: ["" + className+']');    
    try {
      Object instance 	= Loader.loadClass(className).newInstance();
      Appender appender	= (Appender)instance;
      PropertySetter propSetter = new PropertySetter(appender);

      appender.setName(subst(appenderElement.getAttribute(NAME_ATTR)));
      
      NodeList children	= appenderElement.getChildNodes();
      final int length 	= children.getLength();

      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);

	
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element)currentNode;

	  
	  if (currentElement.getTagName().equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	  
	  else if (currentElement.getTagName().equals(LAYOUT_TAG)) {
	    appender.setLayout(parseLayout(currentElement));
	  }
	  
	  else if (currentElement.getTagName().equals(FILTER_TAG)) {
	    parseFilters(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {
	    parseErrorHandler(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {
	    String refName = subst(currentElement.getAttribute(REF_ATTR));
	    if(appender instanceof AppenderAttachable) {
	      AppenderAttachable aa = (AppenderAttachable) appender;
	      LogLog.debug(""Attaching appender named [""+ refName+
			   ""] to appender named [""+ appender.getName()+""]."");
	      aa.addAppender(findAppenderByReference(currentElement));
	    } else {
	      LogLog.error(""Requesting attachment of appender named [""+
			   refName+ ""] to appender named [""+ appender.getName()+
                ""] which does not implement org.apache.log4j.spi.AppenderAttachable."");
	    }
	  } else {
          parseUnrecognizedElement(instance, currentElement, props);
      }
	}
      }
      propSetter.activate();
      return appender;
    }
    
    catch (Exception oops) {
        if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
      LogLog.error(""Could not create an Appender. Reported error follows."",
		   oops);
      return null;
    }
  }

  
  protected
  void parseErrorHandler(Element element, Appender appender) {
    ErrorHandler eh = (ErrorHandler) OptionConverter.instantiateByClassName(
                                       subst(element.getAttribute(CLASS_ATTR)),
                                       org.apache.log4j.spi.ErrorHandler.class, 
 				       null);
    
    if(eh != null) {
      eh.setAppender(appender);

      PropertySetter propSetter = new PropertySetter(eh);
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();

      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  } else if(tagName.equals(APPENDER_REF_TAG)) {
	    eh.setBackupAppender(findAppenderByReference(currentElement));
	  } else if(tagName.equals(LOGGER_REF)) {
	    String loggerName = currentElement.getAttribute(REF_ATTR);	    
	    Logger logger = (catFactory == null) ? repository.getLogger(loggerName)
                : repository.getLogger(loggerName, catFactory);
	    eh.setLogger(logger);
	  } else if(tagName.equals(ROOT_REF)) {
	    Logger root = repository.getRootLogger();
	    eh.setLogger(root);
	  } else {
          quietParseUnrecognizedElement(eh, currentElement, props);
      }
	}
      }
      propSetter.activate();
      appender.setErrorHandler(eh);
    }
  }
  
  
  protected
  void parseFilters(Element element, Appender appender) {
    String clazz = subst(element.getAttribute(CLASS_ATTR));
    Filter filter = (Filter) OptionConverter.instantiateByClassName(clazz,
                                                Filter.class, null);
    
    if(filter != null) {
      PropertySetter propSetter = new PropertySetter(filter);
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();

      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  } else {
            quietParseUnrecognizedElement(filter, currentElement, props);
      }
	}
      }
      propSetter.activate();
      LogLog.debug(""Adding filter of type [""+filter.getClass()
		   +""] to appender named [""+appender.getName()+""]."");
      appender.addFilter(filter);
    }    
  }
  
  
  protected
  void parseCategory (Element loggerElement) {
    
    String catName = subst(loggerElement.getAttribute(NAME_ATTR));

    Logger cat;    

    String className = subst(loggerElement.getAttribute(CLASS_ATTR));


    if(EMPTY_STR.equals(className)) {
      LogLog.debug(""Retreiving an instance of org.apache.log4j.Logger."");
      cat = (catFactory == null) ? repository.getLogger(catName) : repository.getLogger(catName, catFactory);
    }
    else {
      LogLog.debug(""Desired logger sub-class: [""+className+']');
       try {	 
	 Class clazz = Loader.loadClass(className);
	 Method getInstanceMethod = clazz.getMethod(""getLogger"", 
						    ONE_STRING_PARAM);
	 cat = (Logger) getInstanceMethod.invoke(null, new Object[] {catName});
       } catch (InvocationTargetException oops) {
          if (oops.getTargetException() instanceof InterruptedException
                  || oops.getTargetException() instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
          LogLog.error(""Could not retrieve category [""+catName+
		      ""]. Reported error follows."", oops);
	      return;
       } catch (Exception oops) {
	      LogLog.error(""Could not retrieve category [""+catName+
		      ""]. Reported error follows."", oops);
	      return;
       }
    }

    
    
    
    synchronized(cat) {
      boolean additivity = OptionConverter.toBoolean(
                           subst(loggerElement.getAttribute(ADDITIVITY_ATTR)),
			   true);
    
      LogLog.debug(""Setting [""+cat.getName()+""] additivity to [""+additivity+""]."");
      cat.setAdditivity(additivity);
      parseChildrenOfLoggerElement(loggerElement, cat, false);
    }
  }


  
  protected
  void parseCategoryFactory(Element factoryElement) {
    String className = subst(factoryElement.getAttribute(CLASS_ATTR));

    if(EMPTY_STR.equals(className)) {
      LogLog.error(""Category Factory tag "" + CLASS_ATTR + "" attribute not found."");
      LogLog.debug(""No Category Factory configured."");
    }
    else {
      LogLog.debug(""Desired category factory: [""+className+']');
      Object factory = OptionConverter.instantiateByClassName(className,
                                                                 LoggerFactory.class, 
                                                                 null);
      if (factory instanceof LoggerFactory) {
          catFactory = (LoggerFactory) factory;
      } else {
          LogLog.error(""Category Factory class "" + className + "" does not implement org.apache.log4j.LoggerFactory"");
      }
      PropertySetter propSetter = new PropertySetter(factory);

      Element  currentElement = null;
      Node     currentNode    = null;
      NodeList children       = factoryElement.getChildNodes();
      final int length        = children.getLength();

      for (int loop=0; loop < length; loop++) {
        currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  currentElement = (Element)currentNode;
	  if (currentElement.getTagName().equals(PARAM_TAG)) {
	    setParameter(currentElement, propSetter);
	  } else {
           quietParseUnrecognizedElement(factory, currentElement, props);
      }
	}
      }
    }
  }


  
  protected
  void parseRoot (Element rootElement) {
    Logger root = repository.getRootLogger();
    
    synchronized(root) {    
      parseChildrenOfLoggerElement(rootElement, root, true);
    }
  }


  
  protected
  void parseChildrenOfLoggerElement(Element catElement,
				      Logger cat, boolean isRoot) {
    
    PropertySetter propSetter = new PropertySetter(cat);
    
    
    
    cat.removeAllAppenders();


    NodeList children 	= catElement.getChildNodes();
    final int length 	= children.getLength();
    
    for (int loop = 0; loop < length; loop++) {
      Node currentNode = children.item(loop);

      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	Element currentElement = (Element) currentNode;
	String tagName = currentElement.getTagName();
	
	if (tagName.equals(APPENDER_REF_TAG)) {
	  Element appenderRef = (Element) currentNode;
	  Appender appender = findAppenderByReference(appenderRef);
	  String refName =  subst(appenderRef.getAttribute(REF_ATTR));
	  if(appender != null)
	    LogLog.debug(""Adding appender named [""+ refName+ 
			 ""] to category [""+cat.getName()+""]."");
	  else 
	    LogLog.debug(""Appender named [""+ refName + ""] not found."");
	    
	  cat.addAppender(appender);
	  
	} else if(tagName.equals(LEVEL_TAG)) {
	  parseLevel(currentElement, cat, isRoot);	
	} else if(tagName.equals(PRIORITY_TAG)) {
	  parseLevel(currentElement, cat, isRoot);
	} else if(tagName.equals(PARAM_TAG)) {
          setParameter(currentElement, propSetter);
	} else {
        quietParseUnrecognizedElement(cat, currentElement, props);
    }
      }
    }
    propSetter.activate();
  }

    
  protected
  Layout parseLayout (Element layout_element) {
    String className = subst(layout_element.getAttribute(CLASS_ATTR));
    LogLog.debug(""Parsing layout of class: \""""+className+""\"""");		 
    try {
      Object instance 	= Loader.loadClass(className).newInstance();
      Layout layout   	= (Layout)instance;
      PropertySetter propSetter = new PropertySetter(layout);
      
      NodeList params 	= layout_element.getChildNodes();
      final int length 	= params.getLength();

      for (int loop = 0; loop < length; loop++) {
	Node currentNode = (Node)params.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  } else {
          parseUnrecognizedElement(instance, currentElement, props);
      }
	}
      }
      
      propSetter.activate();
      return layout;
    }
    catch (Exception oops) {
        if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
      LogLog.error(""Could not create the Layout. Reported error follows."",
		   oops);
      return null;
    }
  }

  protected 
  void parseRenderer(Element element) {
    String renderingClass = subst(element.getAttribute(RENDERING_CLASS_ATTR));
    String renderedClass = subst(element.getAttribute(RENDERED_CLASS_ATTR));
    if(repository instanceof RendererSupport) {
      RendererMap.addRenderer((RendererSupport) repository, renderedClass, 
			      renderingClass);
    }
  }

    
    protected ThrowableRenderer parseThrowableRenderer(final Element element) {
        String className = subst(element.getAttribute(CLASS_ATTR));
        LogLog.debug(""Parsing throwableRenderer of class: \""""+className+""\"""");
        try {
          Object instance 	= Loader.loadClass(className).newInstance();
          ThrowableRenderer tr   	= (ThrowableRenderer)instance;
          PropertySetter propSetter = new PropertySetter(tr);

          NodeList params 	= element.getChildNodes();
          final int length 	= params.getLength();

          for (int loop = 0; loop < length; loop++) {
                Node currentNode = (Node)params.item(loop);
                if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element currentElement = (Element) currentNode;
                    String tagName = currentElement.getTagName();
                    if(tagName.equals(PARAM_TAG)) {
                        setParameter(currentElement, propSetter);
                    } else {
                        parseUnrecognizedElement(instance, currentElement, props);
                    }
                }
          }

          propSetter.activate();
          return tr;
        }
        catch (Exception oops) {
            if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {
                Thread.currentThread().interrupt();
            }
            LogLog.error(""Could not create the ThrowableRenderer. Reported error follows."",
               oops);
          return null;
        }
    }

  
  protected
  void parseLevel(Element element, Logger logger, boolean isRoot) {
    String catName = logger.getName();
    if(isRoot) {
      catName = ""root"";
    }

    String priStr = subst(element.getAttribute(VALUE_ATTR));
    LogLog.debug(""Level value for ""+catName+"" is  [""+priStr+""]."");
    
    if(INHERITED.equalsIgnoreCase(priStr) || NULL.equalsIgnoreCase(priStr)) {
      if(isRoot) {
	LogLog.error(""Root level cannot be inherited. Ignoring directive."");
      } else {
	logger.setLevel(null);
      }
    } else {
      String className = subst(element.getAttribute(CLASS_ATTR));      
      if(EMPTY_STR.equals(className)) {	
	logger.setLevel(OptionConverter.toLevel(priStr, Level.DEBUG));
      } else {
	LogLog.debug(""Desired Level sub-class: [""+className+']');
	try {	 
	  Class clazz = Loader.loadClass(className);
	  Method toLevelMethod = clazz.getMethod(""toLevel"", 
						    ONE_STRING_PARAM);
	  Level pri = (Level) toLevelMethod.invoke(null, 
						    new Object[] {priStr});
	  logger.setLevel(pri);
	} catch (Exception oops) {
        if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
	  LogLog.error(""Could not create level [""+priStr+
		       ""]. Reported error follows."", oops);
	  return;
	}
      }
    }
    LogLog.debug(catName + "" level set to "" + logger.getLevel());    
  }

  protected
  void setParameter(Element elem, PropertySetter propSetter) {
      String name = subst(elem.getAttribute(NAME_ATTR));
      String value = (elem.getAttribute(VALUE_ATTR));
      value = subst(OptionConverter.convertSpecialChars(value));
      propSetter.setProperty(name, value);
  }


  
  static
  public
  void configure (Element element) {
    DOMConfigurator configurator = new DOMConfigurator();
    configurator.doConfigure(element,  LogManager.getLoggerRepository());
  }

 
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }

  
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    XMLWatchdog xdog = new XMLWatchdog(configFilename);
    xdog.setDelay(delay);
    xdog.start();
  }
  
  private interface ParseAction {
      Document parse(final DocumentBuilder parser) throws SAXException, IOException;
  }


  public
  void doConfigure(final String filename, LoggerRepository repository) {
    ParseAction action = new ParseAction() {
          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
              return parser.parse(new File(filename));
          }
          public String toString() { 
              return ""file ["" + filename + ""]""; 
          }
    };
    doConfigure(action, repository);
  }
  

  public
  void doConfigure(final URL url, LoggerRepository repository) {
      ParseAction action = new ParseAction() {
          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
              URLConnection uConn = url.openConnection();
              uConn.setUseCaches(false);
              InputStream stream = uConn.getInputStream();
              try {
                InputSource src = new InputSource(stream);
                src.setSystemId(url.toString());
                return parser.parse(src);
              } finally {
                stream.close();
              }
          }
          public String toString() { 
              return ""url ["" + url.toString() + ""]""; 
          }
      };
      doConfigure(action, repository);
  }

  
  public
  void doConfigure(final InputStream inputStream, LoggerRepository repository) 
                                          throws FactoryConfigurationError {
      ParseAction action = new ParseAction() {
          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
              InputSource inputSource = new InputSource(inputStream);
              inputSource.setSystemId(""dummy:
              return parser.parse(inputSource);
          }
          public String toString() { 
              return ""input stream ["" + inputStream.toString() + ""]""; 
          }
      };
      doConfigure(action, repository);
  }

  
  public
  void doConfigure(final Reader reader, LoggerRepository repository) 
                                          throws FactoryConfigurationError {
      ParseAction action = new ParseAction() {
          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
              InputSource inputSource = new InputSource(reader);
              inputSource.setSystemId(""dummy:
              return parser.parse(inputSource);
          }
          public String toString() { 
              return ""reader ["" + reader.toString() + ""]""; 
          }
      };
    doConfigure(action, repository);
  }

  
  protected
  void doConfigure(final InputSource inputSource, LoggerRepository repository) 
                                          throws FactoryConfigurationError {
      if (inputSource.getSystemId() == null) {
          inputSource.setSystemId(""dummy:
      }
      ParseAction action = new ParseAction() {
          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
              return parser.parse(inputSource);
          }
          public String toString() { 
              return ""input source ["" + inputSource.toString() + ""]""; 
          }
      };
      doConfigure(action, repository);
    }
    
    
  private final void doConfigure(final ParseAction action, final LoggerRepository repository)
         throws FactoryConfigurationError {
    DocumentBuilderFactory dbf = null;
    this.repository = repository;
    try { 
      LogLog.debug(""System property is :""+
  	                        OptionConverter.getSystemProperty(dbfKey, 
								  null)); 
      dbf = DocumentBuilderFactory.newInstance();
      LogLog.debug(""Standard DocumentBuilderFactory search succeded."");
      LogLog.debug(""DocumentBuilderFactory is: ""+dbf.getClass().getName());
    } catch(FactoryConfigurationError fce) {
      Exception e = fce.getException();
      LogLog.debug(""Could not instantiate a DocumentBuilderFactory."", e);
      throw fce;
    }
      
    try {
      dbf.setValidating(true);

      DocumentBuilder docBuilder = dbf.newDocumentBuilder();

      docBuilder.setErrorHandler(new SAXErrorHandler());      
      docBuilder.setEntityResolver(new Log4jEntityResolver());
         
      Document doc = action.parse(docBuilder);     
      parse(doc.getDocumentElement());
    } catch (Exception e) {
        if (e instanceof InterruptedException || e instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
      
      LogLog.error(""Could not parse ""+ action.toString() + ""."", e);
    }
  }

  
  public void doConfigure(Element element, LoggerRepository repository) {
    this.repository = repository;
    parse(element);
  }

  
  
  static
  public
  void configure(String filename) throws FactoryConfigurationError {
    new DOMConfigurator().doConfigure(filename, 
				      LogManager.getLoggerRepository());
  }

  
  static
  public
  void configure(URL url) throws FactoryConfigurationError {
    new DOMConfigurator().doConfigure(url, LogManager.getLoggerRepository());
  }

  
  protected
  void parse(Element element) {

    String rootElementName = element.getTagName();

    if (!rootElementName.equals(CONFIGURATION_TAG)) {
      if(rootElementName.equals(OLD_CONFIGURATION_TAG)) {
	LogLog.warn(""The <""+OLD_CONFIGURATION_TAG+
		     ""> element has been deprecated."");
	LogLog.warn(""Use the <""+CONFIGURATION_TAG+""> element instead."");
      } else {
	LogLog.error(""DOM element is - not a <""+CONFIGURATION_TAG+""> element."");
	return;
      }
    }


    String debugAttrib = subst(element.getAttribute(INTERNAL_DEBUG_ATTR));
      
    LogLog.debug(""debug attribute= \"""" + debugAttrib +""\""."");
    
    
    if(!debugAttrib.equals("""") && !debugAttrib.equals(""null"")) {      
      LogLog.setInternalDebugging(OptionConverter.toBoolean(debugAttrib, true));
    } else {
      LogLog.debug(""Ignoring "" + INTERNAL_DEBUG_ATTR + "" attribute."");
    }

      
      
      
      
    String resetAttrib = subst(element.getAttribute(RESET_ATTR));
    LogLog.debug(""reset attribute= \"""" + resetAttrib +""\""."");
    if(!("""".equals(resetAttrib))) {
         if (OptionConverter.toBoolean(resetAttrib, false)) {
             repository.resetConfiguration();
         }
    }



    String confDebug = subst(element.getAttribute(CONFIG_DEBUG_ATTR));
    if(!confDebug.equals("""") && !confDebug.equals(""null"")) {      
      LogLog.warn(""The \""""+CONFIG_DEBUG_ATTR+""\"" attribute is deprecated."");
      LogLog.warn(""Use the \""""+INTERNAL_DEBUG_ATTR+""\"" attribute instead."");
      LogLog.setInternalDebugging(OptionConverter.toBoolean(confDebug, true));
    }

    String thresholdStr = subst(element.getAttribute(THRESHOLD_ATTR));
    LogLog.debug(""Threshold =\"""" + thresholdStr +""\""."");
    if(!"""".equals(thresholdStr) && !""null"".equals(thresholdStr)) {
      repository.setThreshold(thresholdStr);
    }

    

    

    
    
    
    
    String   tagName = null;
    Element  currentElement = null;
    Node     currentNode = null;
    NodeList children = element.getChildNodes();
    final int length = children.getLength();

    for (int loop = 0; loop < length; loop++) {
      currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	currentElement = (Element) currentNode;
	tagName = currentElement.getTagName();

	if (tagName.equals(CATEGORY_FACTORY_TAG) || tagName.equals(LOGGER_FACTORY_TAG)) {
	  parseCategoryFactory(currentElement);
	}
      }
    }
    
    for (int loop = 0; loop < length; loop++) {
      currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	currentElement = (Element) currentNode;
	tagName = currentElement.getTagName();

	if (tagName.equals(CATEGORY) || tagName.equals(LOGGER)) {
	  parseCategory(currentElement);
	} else if (tagName.equals(ROOT_TAG)) {
	  parseRoot(currentElement);
	} else if(tagName.equals(RENDERER_TAG)) {
	  parseRenderer(currentElement);
    } else if(tagName.equals(THROWABLE_RENDERER_TAG)) {
        if (repository instanceof ThrowableRendererSupport) {
            ThrowableRenderer tr = parseThrowableRenderer(currentElement);
            if (tr != null) {
                ((ThrowableRendererSupport) repository).setThrowableRenderer(tr);
            }
        }
    } else if (!(tagName.equals(APPENDER_TAG)
            || tagName.equals(CATEGORY_FACTORY_TAG)
            || tagName.equals(LOGGER_FACTORY_TAG))) {
        quietParseUnrecognizedElement(repository, currentElement, props);
    }
      }
    }
  }

  
  protected
  String subst(final String value) {
      return subst(value, props);
  }

    
    public static String subst(final String value, final Properties props) {
        try {
            return OptionConverter.substVars(value, props);
        } catch (IllegalArgumentException e) {
            LogLog.warn(""Could not perform variable substitution."", e);
            return value;
        }
    }


    
    public static void setParameter(final Element elem,
                                    final PropertySetter propSetter,
                                    final Properties props) {
        String name = subst(elem.getAttribute(""name""), props);
        String value = (elem.getAttribute(""value""));
        value = subst(OptionConverter.convertSpecialChars(value), props);
        propSetter.setProperty(name, value);
    }

    
    public static Object parseElement(final Element element,
                                             final Properties props,
                                             final Class expectedClass) throws Exception {
        String clazz = subst(element.getAttribute(""class""), props);
        Object instance = OptionConverter.instantiateByClassName(clazz,
                expectedClass, null);

        if (instance != null) {
            PropertySetter propSetter = new PropertySetter(instance);
            NodeList children = element.getChildNodes();
            final int length = children.getLength();

            for (int loop = 0; loop < length; loop++) {
                Node currentNode = children.item(loop);
                if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element currentElement = (Element) currentNode;
                    String tagName = currentElement.getTagName();
                    if (tagName.equals(""param"")) {
                        setParameter(currentElement, propSetter, props);
                    } else {
                         parseUnrecognizedElement(instance, currentElement, props);
                    }
                }
            }
            return instance;
        }
        return null;
    }

}


class XMLWatchdog extends FileWatchdog {

    XMLWatchdog(String filename) {
    super(filename);
  }

  
  public
  void doOnChange() {
    new DOMConfigurator().doConfigure(filename, 
				      LogManager.getLoggerRepository());
  }
}
"
log4j,1.2,org.apache.log4j.spi.NullWriter,4,2,0,1,5,6,1,0,3,2.0,10,0.0,0,0.8125,0.5,1,1,1.5,1,0.75,1,"
package org.apache.log4j.spi;
import java.io.Writer;


class NullWriter extends Writer {

  public void close() {
    
  }

  public void flush() {
    
  }

  public void write(char[] cbuf, int off, int len) {
    
  }
}
"
log4j,1.2,org.apache.log4j.chainsaw.LoadXMLAction,5,2,0,4,32,4,1,3,1,0.708333333,200,0.833333333,2,0.85,0.4,0,0,37.8,2,0.8,2,"
package org.apache.log4j.chainsaw;

import java.awt.event.ActionEvent;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import javax.swing.AbstractAction;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import org.apache.log4j.Logger;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;


class LoadXMLAction
    extends AbstractAction
{
    
    private static final Logger LOG = Logger.getLogger(LoadXMLAction.class);

    
    private final JFrame mParent;

    
    private final JFileChooser mChooser = new JFileChooser();
    {
        mChooser.setMultiSelectionEnabled(false);
        mChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
    }

    
    private final XMLReader mParser;
    
    private final XMLFileHandler mHandler;


    
    LoadXMLAction(JFrame aParent, MyTableModel aModel)
        throws SAXException, ParserConfigurationException
    {
        mParent = aParent;
        mHandler = new XMLFileHandler(aModel);
        mParser = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
        mParser.setContentHandler(mHandler);
    }

    
    public void actionPerformed(ActionEvent aIgnore) {
        LOG.info(""load file called"");
        if (mChooser.showOpenDialog(mParent) == JFileChooser.APPROVE_OPTION) {
            LOG.info(""Need to load a file"");
            final File chosen = mChooser.getSelectedFile();
            LOG.info(""loading the contents of "" + chosen.getAbsolutePath());
            try {
                final int num = loadFile(chosen.getAbsolutePath());
                JOptionPane.showMessageDialog(
                    mParent,
                    ""Loaded "" + num + "" events."",
                    ""CHAINSAW"",
                    JOptionPane.INFORMATION_MESSAGE);
            } catch (Exception e) {
                LOG.warn(""caught an exception loading the file"", e);
                JOptionPane.showMessageDialog(
                    mParent,
                    ""Error parsing file - "" + e.getMessage(),
                    ""CHAINSAW"",
                    JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    
    private int loadFile(String aFile)
        throws SAXException, IOException
    {
        synchronized (mParser) {
            
            final StringBuffer buf = new StringBuffer();
            buf.append(""<?xml version=\""1.0\"" standalone=\""yes\""?>\n"");
            buf.append(""<!DOCTYPE log4j:eventSet "");
            buf.append(""[<!ENTITY data SYSTEM \""file:
            buf.append(aFile);
            buf.append(""\"">]>\n"");
            buf.append(""<log4j:eventSet xmlns:log4j=\""Claira\"">\n"");
            buf.append(""&data;\n"");
            buf.append(""</log4j:eventSet>\n"");

            final InputSource is =
                new InputSource(new StringReader(buf.toString()));
            mParser.parse(is);
            return mHandler.getNumEvents();
        }
    }
}
"
log4j,1.2,org.apache.log4j.NDC,13,1,0,12,42,0,10,2,10,0.666666667,295,0.0,0,0.0,0.083333333,0,0,21.46153846,6,2.3077,3,"




package org.apache.log4j;

import java.util.Hashtable;
import java.util.Stack;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.log4j.helpers.LogLog;


 
public class NDC {

  
  
  
  
  

  
  
  

  static Hashtable ht = new Hashtable();

  static int pushCounter = 0; 
                              

  
  
  
  
  
  static final int REAP_THRESHOLD = 5;
  
  
  private NDC() {}
  
  
  private static Stack getCurrentStack() {
      if (ht != null) {
          return (Stack) ht.get(Thread.currentThread());
      }
      return null;
  }


  
  public
  static
  void clear() {
    Stack stack = getCurrentStack();    
    if(stack != null) 
      stack.setSize(0);    
  }

  
  
  public
  static
  Stack cloneStack() {
    Stack stack = getCurrentStack();
    if(stack == null)
      return null;
    else {
      return (Stack) stack.clone();
    }
  }

  
  
  public
  static
  void inherit(Stack stack) {
    if(stack != null)
      ht.put(Thread.currentThread(), stack);
  }


  
  static
  public
  String get() {
    Stack s = getCurrentStack();
    if(s != null && !s.isEmpty()) 
      return ((DiagnosticContext) s.peek()).fullMessage;
    else
      return null;
  }
  
  
  public
  static
  int getDepth() {
    Stack stack = getCurrentStack();          
    if(stack == null)
      return 0;
    else
      return stack.size();      
  }

  private
  static
  void lazyRemove() {
    if (ht == null) return;
     
    
    
    
    Vector v;
    
    synchronized(ht) {
      
      if(++pushCounter <= REAP_THRESHOLD) {
	return; 
      } else {
	pushCounter = 0; 
      }

      int misses = 0;
      v = new Vector(); 
      Enumeration enumeration = ht.keys();
      
      
      
      
      while(enumeration.hasMoreElements() && (misses <= 4)) {
	Thread t = (Thread) enumeration.nextElement();
	if(t.isAlive()) {
	  misses++;
	} else {
	  misses = 0;
	  v.addElement(t);
	}
      }
    } 

    int size = v.size();
    for(int i = 0; i < size; i++) {
      Thread t = (Thread) v.elementAt(i);
      LogLog.debug(""Lazy NDC removal for thread ["" + t.getName() + ""] (""+ 
		   ht.size() + "")."");
      ht.remove(t);
    }
  }

  
  public
  static
  String pop() {
    Stack stack = getCurrentStack();
    if(stack != null && !stack.isEmpty()) 
      return ((DiagnosticContext) stack.pop()).message;
    else
      return """";
  }

  
  public
  static
  String peek() {
    Stack stack = getCurrentStack();
    if(stack != null && !stack.isEmpty())
      return ((DiagnosticContext) stack.peek()).message;
    else
      return """";
  }
  
  
  public
  static
  void push(String message) {
    Stack stack = getCurrentStack();
      
    if(stack == null) {
      DiagnosticContext dc = new DiagnosticContext(message, null);      
      stack = new Stack();
      Thread key = Thread.currentThread();
      ht.put(key, stack);
      stack.push(dc);
    } else if (stack.isEmpty()) {
      DiagnosticContext dc = new DiagnosticContext(message, null);            
      stack.push(dc);
    } else {
      DiagnosticContext parent = (DiagnosticContext) stack.peek();
      stack.push(new DiagnosticContext(message, parent));
    }    
  }

  
  static
  public
  void remove() {
    if (ht != null) {
        ht.remove(Thread.currentThread());
    
        
        lazyRemove();
    }
  }

  
  static
  public
  void setMaxDepth(int maxDepth) {
    Stack stack = getCurrentStack();    
    if(stack != null && maxDepth < stack.size()) 
      stack.setSize(maxDepth);
  }
  
  
   private static class DiagnosticContext {

    String fullMessage;
    String message;
    
    DiagnosticContext(String message, DiagnosticContext parent) {
      this.message = message;
      if(parent != null) {
	fullMessage = parent.fullMessage + ' ' + message;
      } else {
	fullMessage = message;
      }
    }
  }
}

"
log4j,1.2,org.apache.log4j.chainsaw.ExitAction,4,2,0,4,11,4,3,1,1,0.888888889,41,0.333333333,2,0.894736842,0.444444444,0,0,8.5,1,0.5,2,"
package org.apache.log4j.chainsaw;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import org.apache.log4j.Logger;


class ExitAction
    extends AbstractAction
{
    
    private static final Logger LOG = Logger.getLogger(ExitAction.class);
    
    public static final ExitAction INSTANCE = new ExitAction();

    
    private ExitAction() {}

    
    public void actionPerformed(ActionEvent aIgnore) {
        LOG.info(""shutting down"");
        System.exit(0);
    }
}
"
log4j,1.2,org.apache.log4j.PatternLayout,8,2,0,10,16,18,6,4,7,0.875,103,0.75,1,0.571428571,0.5,0,0,10.875,3,1.0,5,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.PatternParser;
import org.apache.log4j.helpers.PatternConverter;






public class PatternLayout extends Layout {


  
  public final static String DEFAULT_CONVERSION_PATTERN =""%m%n"";

  
  public final static String TTCC_CONVERSION_PATTERN
                                             = ""%r [%t] %p %c %x - %m%n"";


  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;


  
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);

  private String pattern;

  private PatternConverter head;

  
  public PatternLayout() {
    this(DEFAULT_CONVERSION_PATTERN);
  }

  
  public PatternLayout(String pattern) {
    this.pattern = pattern;
    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN :
			     pattern).parse();
  }

   
  public
  void setConversionPattern(String conversionPattern) {
    pattern = conversionPattern;
    head = createPatternParser(conversionPattern).parse();
  }

  
  public
  String getConversionPattern() {
    return pattern;
  }

  
  public
  void activateOptions() {
    
  }

 
  public
  boolean ignoresThrowable() {
    return true;
  }

  
  protected PatternParser createPatternParser(String pattern) {
    return new PatternParser(pattern);
  }


  
  public String format(LoggingEvent event) {
    
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }

    PatternConverter c = head;

    while(c != null) {
      c.format(sbuf, event);
      c = c.next;
    }
    return sbuf.toString();
  }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogTableColumn,9,1,0,5,20,16,4,1,8,0.916666667,207,0.25,10,0.0,0.333333333,1,1,20.66666667,3,1.0,3,"
package org.apache.log4j.lf5.viewer;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;





public class LogTableColumn implements java.io.Serializable {
  private static final long serialVersionUID = -4275827753626456547L;

  
  public final static LogTableColumn DATE = new LogTableColumn(""Date"");
  public final static LogTableColumn THREAD = new LogTableColumn(""Thread"");
  public final static LogTableColumn MESSAGE_NUM = new LogTableColumn(""Message #"");
  public final static LogTableColumn LEVEL = new LogTableColumn(""Level"");
  public final static LogTableColumn NDC = new LogTableColumn(""NDC"");
  public final static LogTableColumn CATEGORY = new LogTableColumn(""Category"");
  public final static LogTableColumn MESSAGE = new LogTableColumn(""Message"");
  public final static LogTableColumn LOCATION = new LogTableColumn(""Location"");
  public final static LogTableColumn THROWN = new LogTableColumn(""Thrown"");


  
  
  
  protected String _label;

  
  
  
  private static LogTableColumn[] _log4JColumns;
  private static Map _logTableColumnMap;

  
  
  
  static {
    _log4JColumns = new LogTableColumn[]{DATE, THREAD, MESSAGE_NUM, LEVEL, NDC, CATEGORY,
                                         MESSAGE, LOCATION, THROWN};

    _logTableColumnMap = new HashMap();

    for (int i = 0; i < _log4JColumns.length; i++) {
      _logTableColumnMap.put(_log4JColumns[i].getLabel(), _log4JColumns[i]);
    }
  }


  public LogTableColumn(String label) {
    _label = label;
  }

  
  
  

  
  public String getLabel() {
    return _label;
  }

  
  public static LogTableColumn valueOf(String column)
      throws LogTableColumnFormatException {
    LogTableColumn tableColumn = null;
    if (column != null) {
      column = column.trim();
      tableColumn = (LogTableColumn) _logTableColumnMap.get(column);
    }

    if (tableColumn == null) {
      StringBuffer buf = new StringBuffer();
      buf.append(""Error while trying to parse ("" + column + "") into"");
      buf.append("" a LogTableColumn."");
      throw new LogTableColumnFormatException(buf.toString());
    }
    return tableColumn;
  }


  public boolean equals(Object o) {
    boolean equals = false;

    if (o instanceof LogTableColumn) {
      if (this.getLabel() ==
          ((LogTableColumn) o).getLabel()) {
        equals = true;
      }
    }

    return equals;
  }

  public int hashCode() {
    return _label.hashCode();
  }

  public String toString() {
    return _label;
  }

  
  public static List getLogTableColumns() {
    return Arrays.asList(_log4JColumns);
  }

  public static LogTableColumn[] getLogTableColumnArray() {
    return _log4JColumns;
  }

  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.Hierarchy,25,1,0,17,69,200,2,15,22,0.856481481,586,0.222222222,4,0.0,0.16,0,0,22.08,6,1.92,2,"











package org.apache.log4j;


import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.HierarchyEventListener;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.ThrowableRendererSupport;
import org.apache.log4j.spi.ThrowableRenderer;


public class Hierarchy implements LoggerRepository, RendererSupport, ThrowableRendererSupport {

  private LoggerFactory defaultFactory;
  private Vector listeners;

  Hashtable ht;
  Logger root;
  RendererMap rendererMap;

  int thresholdInt;
  Level threshold;

  boolean emittedNoAppenderWarning = false;
  boolean emittedNoResourceBundleWarning = false;

  private ThrowableRenderer throwableRenderer = null;

  
  public
  Hierarchy(Logger root) {
    ht = new Hashtable();
    listeners = new Vector(1);
    this.root = root;
    
    setThreshold(Level.ALL);
    this.root.setHierarchy(this);
    rendererMap = new RendererMap();
    defaultFactory = new DefaultCategoryFactory();
  }

  
  public
  void addRenderer(Class classToRender, ObjectRenderer or) {
    rendererMap.put(classToRender, or);
  }

  public
  void addHierarchyEventListener(HierarchyEventListener listener) {
    if(listeners.contains(listener)) {
      LogLog.warn(""Ignoring attempt to add an existent listener."");
    } else {
      listeners.addElement(listener);
    }
  }

  
  public
  void clear() {
    
    ht.clear();
  }

  public
  void emitNoAppenderWarning(Category cat) {
    
    if(!this.emittedNoAppenderWarning) {
      LogLog.warn(""No appenders could be found for logger ("" +
		   cat.getName() + "")."");
      LogLog.warn(""Please initialize the log4j system properly."");
      LogLog.warn(""See http:
      this.emittedNoAppenderWarning = true;
    }
  }

  
  public
  Logger exists(String name) {
    Object o = ht.get(new CategoryKey(name));
    if(o instanceof Logger) {
      return (Logger) o;
    } else {
      return null;
    }
  }

  
  public
  void setThreshold(String levelStr) {
    Level l = (Level) Level.toLevel(levelStr, null);
    if(l != null) {
      setThreshold(l);
    } else {
      LogLog.warn(""Could not convert [""+levelStr+""] to Level."");
    }
  }


  
  public
  void setThreshold(Level l) {
    if(l != null) {
      thresholdInt = l.level;
      threshold = l;
    }
  }

  public
  void fireAddAppenderEvent(Category logger, Appender appender) {
    if(listeners != null) {
      int size = listeners.size();
      HierarchyEventListener listener;
      for(int i = 0; i < size; i++) {
	listener = (HierarchyEventListener) listeners.elementAt(i);
	listener.addAppenderEvent(logger, appender);
      }
    }
  }

  void fireRemoveAppenderEvent(Category logger, Appender appender) {
    if(listeners != null) {
      int size = listeners.size();
      HierarchyEventListener listener;
      for(int i = 0; i < size; i++) {
	listener = (HierarchyEventListener) listeners.elementAt(i);
	listener.removeAppenderEvent(logger, appender);
      }
    }
  }

  
  public
  Level getThreshold() {
    return threshold;
  }

  
  
  
  
  


  
  public
  Logger getLogger(String name) {
    return getLogger(name, defaultFactory);
  }

 
  public
  Logger getLogger(String name, LoggerFactory factory) {
    
    CategoryKey key = new CategoryKey(name);
    
    
    
    Logger logger;

    synchronized(ht) {
      Object o = ht.get(key);
      if(o == null) {
	logger = factory.makeNewLoggerInstance(name);
	logger.setHierarchy(this);
	ht.put(key, logger);
	updateParents(logger);
	return logger;
      } else if(o instanceof Logger) {
	return (Logger) o;
      } else if (o instanceof ProvisionNode) {
	
	logger = factory.makeNewLoggerInstance(name);
	logger.setHierarchy(this);
	ht.put(key, logger);
	updateChildren((ProvisionNode) o, logger);
	updateParents(logger);
	return logger;
      }
      else {
	
	return null;  
      }
    }
  }

  
  public
  Enumeration getCurrentLoggers() {
    
    
    
    Vector v = new Vector(ht.size());

    Enumeration elems = ht.elements();
    while(elems.hasMoreElements()) {
      Object o = elems.nextElement();
      if(o instanceof Logger) {
	v.addElement(o);
      }
    }
    return v.elements();
  }

  
  public
  Enumeration getCurrentCategories() {
    return getCurrentLoggers();
  }


  
  public
  RendererMap getRendererMap() {
    return rendererMap;
  }


  
  public
  Logger getRootLogger() {
    return root;
  }

  
  public
  boolean isDisabled(int level) {
    return thresholdInt > level;
  }

  
  public
  void overrideAsNeeded(String override) {
    LogLog.warn(""The Hiearchy.overrideAsNeeded method has been deprecated."");
  }

  
  public
  void resetConfiguration() {

    getRootLogger().setLevel((Level) Level.DEBUG);
    root.setResourceBundle(null);
    setThreshold(Level.ALL);

    
    
    synchronized(ht) {
      shutdown(); 

      Enumeration cats = getCurrentLoggers();
      while(cats.hasMoreElements()) {
	Logger c = (Logger) cats.nextElement();
	c.setLevel(null);
	c.setAdditivity(true);
	c.setResourceBundle(null);
      }
    }
    rendererMap.clear();
    throwableRenderer = null;
  }

  
  public
  void setDisableOverride(String override) {
    LogLog.warn(""The Hiearchy.setDisableOverride method has been deprecated."");
  }



  
  public
  void setRenderer(Class renderedClass, ObjectRenderer renderer) {
    rendererMap.put(renderedClass, renderer);
  }

    
  public void setThrowableRenderer(final ThrowableRenderer renderer) {
      throwableRenderer = renderer;
  }

    
  public ThrowableRenderer getThrowableRenderer() {
      return throwableRenderer;
  }


  
  public
  void shutdown() {
    Logger root = getRootLogger();

    
    root.closeNestedAppenders();

    synchronized(ht) {
      Enumeration cats = this.getCurrentLoggers();
      while(cats.hasMoreElements()) {
	Logger c = (Logger) cats.nextElement();
	c.closeNestedAppenders();
      }

      
      root.removeAllAppenders();
      cats = this.getCurrentLoggers();
      while(cats.hasMoreElements()) {
	Logger c = (Logger) cats.nextElement();
	c.removeAllAppenders();
      }
    }
  }


  
  final
  private
  void updateParents(Logger cat) {
    String name = cat.name;
    int length = name.length();
    boolean parentFound = false;

    

    
    for(int i = name.lastIndexOf('.', length-1); i >= 0;
	                                 i = name.lastIndexOf('.', i-1))  {
      String substr = name.substring(0, i);

      
      CategoryKey key = new CategoryKey(substr); 
      Object o = ht.get(key);
      
      if(o == null) {
	
	ProvisionNode pn = new ProvisionNode(cat);
	ht.put(key, pn);
      } else if(o instanceof Category) {
	parentFound = true;
	cat.parent = (Category) o;
	
	break; 
      } else if(o instanceof ProvisionNode) {
	((ProvisionNode) o).addElement(cat);
      } else {
	Exception e = new IllegalStateException(""unexpected object type "" +
					o.getClass() + "" in ht."");
	e.printStackTrace();
      }
    }
    
    if(!parentFound)
      cat.parent = root;
  }

  
  final
  private
  void updateChildren(ProvisionNode pn, Logger logger) {
    
    final int last = pn.size();

    for(int i = 0; i < last; i++) {
      Logger l = (Logger) pn.elementAt(i);
      

      
      
      if(!l.parent.name.startsWith(logger.name)) {
	logger.parent = l.parent;
	l.parent = logger;
      }
    }
  }

}


"
log4j,1.2,org.apache.log4j.net.SMTPAppender,25,2,0,10,73,226,0,10,20,0.8875,436,0.9,2,0.43902439,0.24,1,2,16.04,7,1.56,9,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.Level;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.TriggeringEventEvaluator;
import org.apache.log4j.xml.UnrecognizedElementHandler;
import org.w3c.dom.Element;

import javax.mail.Authenticator;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.InternetHeaders;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeUtility;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.Date;
import java.util.Properties;


public class SMTPAppender extends AppenderSkeleton
        implements UnrecognizedElementHandler {
  private String to;
  
  private String cc;  
  
  private String bcc;  
  private String from;
  
  private String replyTo;
  private String subject;
  private String smtpHost;
  private String smtpUsername;
  private String smtpPassword;
  private String smtpProtocol;
  private int smtpPort = -1;
  private boolean smtpDebug = false;
  private int bufferSize = 512;
  private boolean locationInfo = false;
  private boolean sendOnClose = false;

  protected CyclicBuffer cb = new CyclicBuffer(bufferSize);
  protected Message msg;

  protected TriggeringEventEvaluator evaluator;



  
  public
  SMTPAppender() {
    this(new DefaultEvaluator());
  }


  
  public
  SMTPAppender(TriggeringEventEvaluator evaluator) {
    this.evaluator = evaluator;
  }


  
  public
  void activateOptions() {
    Session session = createSession();
    msg = new MimeMessage(session);

     try {
        addressMessage(msg);
        if(subject != null) {
           try {
                msg.setSubject(MimeUtility.encodeText(subject, ""UTF-8"", null));
           } catch(UnsupportedEncodingException ex) {
                LogLog.error(""Unable to encode SMTP subject"", ex);
           }
        }
     } catch(MessagingException e) {
       LogLog.error(""Could not activate SMTPAppender options."", e );
     }

     if (evaluator instanceof OptionHandler) {
         ((OptionHandler) evaluator).activateOptions();
     }
  }
  
  
  protected void addressMessage(final Message msg) throws MessagingException {
       if (from != null) {
	 		msg.setFrom(getAddress(from));
       } else {
	 		msg.setFrom();
	   }

      
         if (replyTo != null && replyTo.length() > 0) {
               msg.setReplyTo(parseAddress(replyTo));
         }

       if (to != null && to.length() > 0) {
             msg.setRecipients(Message.RecipientType.TO, parseAddress(to));
       }

      
	  if (cc != null && cc.length() > 0) {
		msg.setRecipients(Message.RecipientType.CC, parseAddress(cc));
	  }

      
	  if (bcc != null && bcc.length() > 0) {
		msg.setRecipients(Message.RecipientType.BCC, parseAddress(bcc));
	  }
  }
  
  
  protected Session createSession() {
    Properties props = null;
    try {
        props = new Properties (System.getProperties());
    } catch(SecurityException ex) {
        props = new Properties();
    }

    String prefix = ""mail.smtp"";
    if (smtpProtocol != null) {
        props.put(""mail.transport.protocol"", smtpProtocol);
        prefix = ""mail."" + smtpProtocol;
    }
    if (smtpHost != null) {
      props.put(prefix + "".host"", smtpHost);
    }
    if (smtpPort > 0) {
        props.put(prefix + "".port"", String.valueOf(smtpPort));
    }
    
    Authenticator auth = null;
    if(smtpPassword != null && smtpUsername != null) {
      props.put(prefix + "".auth"", ""true"");
      auth = new Authenticator() {
        protected PasswordAuthentication getPasswordAuthentication() {
          return new PasswordAuthentication(smtpUsername, smtpPassword);
        }
      };
    }
    Session session = Session.getInstance(props, auth);
    if (smtpProtocol != null) {
        session.setProtocolForAddress(""rfc822"", smtpProtocol);
    }
    if (smtpDebug) {
        session.setDebug(smtpDebug);
    }
    return session;
  }

  
  public
  void append(LoggingEvent event) {

    if(!checkEntryConditions()) {
      return;
    }

    event.getThreadName();
    event.getNDC();
    event.getMDCCopy();
    if(locationInfo) {
      event.getLocationInformation();
    }
    event.getRenderedMessage();
    event.getThrowableStrRep();
    cb.add(event);
    if(evaluator.isTriggeringEvent(event)) {
      sendBuffer();
    }
  }

 
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error(""Message object not configured."");
      return false;
    }

    if(this.evaluator == null) {
      errorHandler.error(""No TriggeringEventEvaluator is set for appender [""+
			 name+""]."");
      return false;
    }


    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+name+""]."");
      return false;
    }
    return true;
  }


  synchronized
  public
  void close() {
    this.closed = true;
    if (sendOnClose && cb.length() > 0) {
        sendBuffer();
    }
  }

  InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

  InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

  
  public
  String getTo() {
    return to;
  }


  
  public
  boolean requiresLayout() {
    return true;
  }

  
  protected String formatBody() {
	  
	  
	  
	  
      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length();
      for(int i = 0; i < len; i++) {
	
	LoggingEvent event = cb.get();
	sbuf.append(layout.format(event));
	if(layout.ignoresThrowable()) {
	  String[] s = event.getThrowableStrRep();
	  if (s != null) {
	    for(int j = 0; j < s.length; j++) {
	      sbuf.append(s[j]);
	      sbuf.append(Layout.LINE_SEP);
	    }
	  }
	}
      }
      t = layout.getFooter();
      if(t != null) {
	    sbuf.append(t);
      }
      
      return sbuf.toString();
  }
  
  
  protected
  void sendBuffer() {

    try {
      String s = formatBody();
      boolean allAscii = true;
      for(int i = 0; i < s.length() && allAscii; i++) {
          allAscii = s.charAt(i) <= 0x7F;
      }
      MimeBodyPart part;
      if (allAscii) {
          part = new MimeBodyPart();
          part.setContent(s, layout.getContentType());
      } else {
          try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Writer writer = new OutputStreamWriter(
                    MimeUtility.encode(os, ""quoted-printable""), ""UTF-8"");
            writer.write(s);
            writer.close();
            InternetHeaders headers = new InternetHeaders();
            headers.setHeader(""Content-Type"", layout.getContentType() + ""; charset=UTF-8"");
            headers.setHeader(""Content-Transfer-Encoding"", ""quoted-printable"");
            part = new MimeBodyPart(headers, os.toByteArray());
          } catch(Exception ex) {
              StringBuffer sbuf = new StringBuffer(s);
              for (int i = 0; i < sbuf.length(); i++) {
                  if (sbuf.charAt(i) >= 0x80) {
                      sbuf.setCharAt(i, '?');
                  }
              }
              part = new MimeBodyPart();
              part.setContent(sbuf.toString(), layout.getContentType());
          }
      }



      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);

      msg.setSentDate(new Date());
      Transport.send(msg);
    } catch(MessagingException e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    } catch(RuntimeException e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    }
  }



  
  public
  String getEvaluatorClass() {
    return evaluator == null ? null : evaluator.getClass().getName();
  }

  
  public
  String getFrom() {
    return from;
  }

  
  public
  String getReplyTo() {
    return replyTo;
  }

  
  public
  String getSubject() {
    return subject;
  }

  
  public
  void setFrom(String from) {
    this.from = from;
  }

  
  public
  void setReplyTo(final String addresses) {
    this.replyTo = addresses;
  }


  
  public
  void setSubject(String subject) {
    this.subject = subject;
  }


  
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
    cb.resize(bufferSize);
  }

  
  public
  void setSMTPHost(String smtpHost) {
    this.smtpHost = smtpHost;
  }

  
  public
  String getSMTPHost() {
    return smtpHost;
  }

  
  public
  void setTo(String to) {
    this.to = to;
  }



  
  public
  int getBufferSize() {
    return bufferSize;
  }

  
  public
  void setEvaluatorClass(String value) {
      evaluator = (TriggeringEventEvaluator)
                OptionConverter.instantiateByClassName(value,
					   TriggeringEventEvaluator.class,
						       evaluator);
  }


  
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }

  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  
   
   public void setCc(final String addresses) {
     this.cc = addresses;
   }

   
    public String getCc() {
     return cc;
    }

   
   public void setBcc(final String addresses) {
     this.bcc = addresses;
   }

   
    public String getBcc() {
     return bcc;
    }

  
  public void setSMTPPassword(final String password) {
    this.smtpPassword = password;
  }
 
  
  public void setSMTPUsername(final String username) {
    this.smtpUsername = username;
  }

  
  public void setSMTPDebug(final boolean debug) {
    this.smtpDebug = debug;
  }
  
  
  public String getSMTPPassword() {
    return smtpPassword;
  }
 
  
  public String getSMTPUsername() {
    return smtpUsername;
  }

  
  public boolean getSMTPDebug() {
    return smtpDebug;
  }

    
  public final void setEvaluator(final TriggeringEventEvaluator trigger) {
      if (trigger == null) {
          throw new NullPointerException(""trigger"");
      }
      this.evaluator = trigger;
  }

    
  public final TriggeringEventEvaluator getEvaluator() {
      return evaluator;
  }

  
  public boolean parseUnrecognizedElement(final Element element,
                                          final Properties props) throws Exception {
      if (""triggeringPolicy"".equals(element.getNodeName())) {
          Object triggerPolicy =
                  org.apache.log4j.xml.DOMConfigurator.parseElement(
                          element, props, TriggeringEventEvaluator.class);
          if (triggerPolicy instanceof TriggeringEventEvaluator) {
              setEvaluator((TriggeringEventEvaluator) triggerPolicy);
          }
          return true;
      }

      return false;
  }

    
  public final String getSMTPProtocol() {
      return smtpProtocol;
  }

    
  public final void setSMTPProtocol(final String val) {
      smtpProtocol = val;
  }

    
  public final int getSMTPPort() {
        return smtpPort;
  }

    
  public final void setSMTPPort(final int val) {
        smtpPort = val;
  }

    
  public final boolean getSendOnClose() {
        return sendOnClose;
  }

    
  public final void setSendOnClose(final boolean val) {
        sendOnClose = val;
  }

}

class DefaultEvaluator implements TriggeringEventEvaluator {
  
  public
  boolean isTriggeringEvent(LoggingEvent event) {
    return event.getLevel().isGreaterOrEqual(Level.ERROR);
  }
}
"
log4j,1.2,org.apache.log4j.lf5.PassingLogRecordFilter,3,1,0,3,4,3,1,2,3,2.0,9,0.0,0,0.0,0.666666667,0,0,2.0,1,0.6667,2,"
package org.apache.log4j.lf5;






public class PassingLogRecordFilter implements LogRecordFilter {
  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  public boolean passes(LogRecord record) {
    return true;
  }

  
  public void reset() {
    
  }
  
  
  

  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.ProvisionNode,1,4,0,2,3,0,1,1,0,2.0,7,0.0,0,1.0,1.0,0,0,6.0,0,0.0,3,"

package org.apache.log4j;

import java.util.Vector;

class ProvisionNode extends Vector {
  private static final long serialVersionUID = -4479121426311014469L;

  ProvisionNode(Logger logger) {
    super();
    this.addElement(logger);
  }
}
"
log4j,1.2,org.apache.log4j.PropertyConfigurator,18,1,0,35,79,135,19,18,9,0.966911765,762,0.1875,1,0.0,0.277777778,0,0,40.44444444,10,2.6667,4,"






package org.apache.log4j;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.net.URLConnection;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Iterator;
import java.util.Map;

import org.apache.log4j.config.PropertySetter;
import org.apache.log4j.helpers.FileWatchdog;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.RendererSupport;
import org.apache.log4j.spi.ThrowableRenderer;
import org.apache.log4j.spi.ThrowableRendererSupport;
import org.apache.log4j.spi.ErrorHandler;


public class PropertyConfigurator implements Configurator {

  
  protected Hashtable registry = new Hashtable(11);  
  private LoggerRepository repository;
  protected LoggerFactory loggerFactory = new DefaultCategoryFactory();

  static final String      CATEGORY_PREFIX = ""log4j.category."";
  static final String      LOGGER_PREFIX   = ""log4j.logger."";
  static final String       FACTORY_PREFIX = ""log4j.factory"";
  static final String    ADDITIVITY_PREFIX = ""log4j.additivity."";
  static final String ROOT_CATEGORY_PREFIX = ""log4j.rootCategory"";
  static final String ROOT_LOGGER_PREFIX   = ""log4j.rootLogger"";
  static final String      APPENDER_PREFIX = ""log4j.appender."";
  static final String      RENDERER_PREFIX = ""log4j.renderer."";
  static final String      THRESHOLD_PREFIX = ""log4j.threshold"";
  private static final String      THROWABLE_RENDERER_PREFIX = ""log4j.throwableRenderer"";
  private static final String LOGGER_REF	= ""logger-ref"";
  private static final String ROOT_REF		= ""root-ref"";
  private static final String APPENDER_REF_TAG 	= ""appender-ref"";  
  

  
  public static final String LOGGER_FACTORY_KEY = ""log4j.loggerFactory"";

    
  private static final String RESET_KEY = ""log4j.reset"";

  static final private String INTERNAL_ROOT_NAME = ""root"";

  
  public
  void doConfigure(String configFileName, LoggerRepository hierarchy) {
    Properties props = new Properties();
    FileInputStream istream = null;
    try {
      istream = new FileInputStream(configFileName);
      props.load(istream);
      istream.close();
    }
    catch (Exception e) {
      if (e instanceof InterruptedIOException || e instanceof InterruptedException) {
          Thread.currentThread().interrupt();
      }
      LogLog.error(""Could not read configuration file [""+configFileName+""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configFileName+""]."");
      return;
    } finally {
        if(istream != null) {
            try {
                istream.close();
            } catch(InterruptedIOException ignore) {
                Thread.currentThread().interrupt();
            } catch(Throwable ignore) {
            }

        }
    }
    
    doConfigure(props, hierarchy);
  }

  
  static
  public
  void configure(String configFilename) {
    new PropertyConfigurator().doConfigure(configFilename,
					   LogManager.getLoggerRepository());
  }

  
public
static
void configure(java.net.URL configURL) {
 new PropertyConfigurator().doConfigure(configURL,
                    LogManager.getLoggerRepository());
}


public
static
void configure(InputStream inputStream) {
new PropertyConfigurator().doConfigure(inputStream,
                  LogManager.getLoggerRepository());
}


  
  static
  public
  void configure(Properties properties) {
    new PropertyConfigurator().doConfigure(properties,
					   LogManager.getLoggerRepository());
  }

  
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }


  
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    PropertyWatchdog pdog = new PropertyWatchdog(configFilename);
    pdog.setDelay(delay);
    pdog.start();
  }


  
  public
  void doConfigure(Properties properties, LoggerRepository hierarchy) {
	repository = hierarchy;
    String value = properties.getProperty(LogLog.DEBUG_KEY);
    if(value == null) {
      value = properties.getProperty(""log4j.configDebug"");
      if(value != null)
	LogLog.warn(""[log4j.configDebug] is deprecated. Use [log4j.debug] instead."");
    }

    if(value != null) {
      LogLog.setInternalDebugging(OptionConverter.toBoolean(value, true));
    }

      
      
      
    String reset = properties.getProperty(RESET_KEY);
    if (reset != null && OptionConverter.toBoolean(reset, false)) {
          hierarchy.resetConfiguration();
    }

    String thresholdStr = OptionConverter.findAndSubst(THRESHOLD_PREFIX,
						       properties);
    if(thresholdStr != null) {
      hierarchy.setThreshold(OptionConverter.toLevel(thresholdStr,
						     (Level) Level.ALL));
      LogLog.debug(""Hierarchy threshold set to [""+hierarchy.getThreshold()+""]."");
    }
    
    configureRootCategory(properties, hierarchy);
    configureLoggerFactory(properties);
    parseCatsAndRenderers(properties, hierarchy);

    LogLog.debug(""Finished configuring."");
    
    
    registry.clear();
  }

    
    public void doConfigure(InputStream inputStream, LoggerRepository hierarchy) {
        Properties props = new Properties();
        try {
            props.load(inputStream);
        } catch (IOException e) {
            if (e instanceof InterruptedIOException) {
                Thread.currentThread().interrupt();
            }
            LogLog.error(""Could not read configuration file from InputStream ["" + inputStream
                 + ""]."", e);
            LogLog.error(""Ignoring configuration InputStream ["" + inputStream +""]."");
            return;
          }
        this.doConfigure(props, hierarchy);
    }

  
  public
  void doConfigure(java.net.URL configURL, LoggerRepository hierarchy) {
    Properties props = new Properties();
    LogLog.debug(""Reading configuration from URL "" + configURL);
    InputStream istream = null;
    URLConnection uConn = null;
    try {
      uConn = configURL.openConnection();
      uConn.setUseCaches(false);
      istream = uConn.getInputStream();
      props.load(istream);
    }
    catch (Exception e) {
      if (e instanceof InterruptedIOException || e instanceof InterruptedException) {
          Thread.currentThread().interrupt();
      }
      LogLog.error(""Could not read configuration file from URL ["" + configURL
		   + ""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configURL +""]."");
      return;
    }
    finally {
        if (istream != null) {
            try {
                istream.close();
            } catch(InterruptedIOException ignore) {
                Thread.currentThread().interrupt();
            } catch(IOException ignore) {
            } catch(RuntimeException ignore) {
            }
        }
    }
    doConfigure(props, hierarchy);
  }


  
  
  

  
  protected void configureLoggerFactory(Properties props) {
    String factoryClassName = OptionConverter.findAndSubst(LOGGER_FACTORY_KEY,
							   props);
    if(factoryClassName != null) {
      LogLog.debug(""Setting category factory to [""+factoryClassName+""]."");
      loggerFactory = (LoggerFactory)
	          OptionConverter.instantiateByClassName(factoryClassName,
							 LoggerFactory.class,
							 loggerFactory);
      PropertySetter.setProperties(loggerFactory, props, FACTORY_PREFIX + ""."");
    }
  }

  


  void configureRootCategory(Properties props, LoggerRepository hierarchy) {
    String effectiveFrefix = ROOT_LOGGER_PREFIX;
    String value = OptionConverter.findAndSubst(ROOT_LOGGER_PREFIX, props);

    if(value == null) {
      value = OptionConverter.findAndSubst(ROOT_CATEGORY_PREFIX, props);
      effectiveFrefix = ROOT_CATEGORY_PREFIX;
    }

    if(value == null)
      LogLog.debug(""Could not find root logger information. Is this OK?"");
    else {
      Logger root = hierarchy.getRootLogger();
      synchronized(root) {
	parseCategory(props, root, effectiveFrefix, INTERNAL_ROOT_NAME, value);
      }
    }
  }


  
  protected
  void parseCatsAndRenderers(Properties props, LoggerRepository hierarchy) {
    Enumeration enumeration = props.propertyNames();
    while(enumeration.hasMoreElements()) {
      String key = (String) enumeration.nextElement();
      if(key.startsWith(CATEGORY_PREFIX) || key.startsWith(LOGGER_PREFIX)) {
	String loggerName = null;
	if(key.startsWith(CATEGORY_PREFIX)) {
	  loggerName = key.substring(CATEGORY_PREFIX.length());
	} else if(key.startsWith(LOGGER_PREFIX)) {
	  loggerName = key.substring(LOGGER_PREFIX.length());
	}
	String value =  OptionConverter.findAndSubst(key, props);
	Logger logger = hierarchy.getLogger(loggerName, loggerFactory);
	synchronized(logger) {
	  parseCategory(props, logger, key, loggerName, value);
	  parseAdditivityForLogger(props, logger, loggerName);
	}
      } else if(key.startsWith(RENDERER_PREFIX)) {
	String renderedClass = key.substring(RENDERER_PREFIX.length());
	String renderingClass = OptionConverter.findAndSubst(key, props);
	if(hierarchy instanceof RendererSupport) {
	  RendererMap.addRenderer((RendererSupport) hierarchy, renderedClass,
				  renderingClass);
	}
      } else if (key.equals(THROWABLE_RENDERER_PREFIX)) {
          if (hierarchy instanceof ThrowableRendererSupport) {
            ThrowableRenderer tr = (ThrowableRenderer)
                  OptionConverter.instantiateByKey(props,
                          THROWABLE_RENDERER_PREFIX,
                          org.apache.log4j.spi.ThrowableRenderer.class,
                          null);
            if(tr == null) {
                LogLog.error(
                    ""Could not instantiate throwableRenderer."");
            } else {
                PropertySetter setter = new PropertySetter(tr);
                setter.setProperties(props, THROWABLE_RENDERER_PREFIX + ""."");
                ((ThrowableRendererSupport) hierarchy).setThrowableRenderer(tr);

            }
          }
      }
    }
  }

  
  void parseAdditivityForLogger(Properties props, Logger cat,
				  String loggerName) {
    String value = OptionConverter.findAndSubst(ADDITIVITY_PREFIX + loggerName,
					     props);
    LogLog.debug(""Handling ""+ADDITIVITY_PREFIX + loggerName+""=[""+value+""]"");
    
    if((value != null) && (!value.equals(""""))) {
      boolean additivity = OptionConverter.toBoolean(value, true);
      LogLog.debug(""Setting additivity for \""""+loggerName+""\"" to ""+
		   additivity);
      cat.setAdditivity(additivity);
    }
  }

  
  void parseCategory(Properties props, Logger logger, String optionKey,
		     String loggerName, String value) {

    LogLog.debug(""Parsing for ["" +loggerName +""] with value=["" + value+""]."");
    
    StringTokenizer st = new StringTokenizer(value, "","");

    
    

    if(!(value.startsWith("","") || value.equals(""""))) {

      
      if(!st.hasMoreTokens())
	return;

      String levelStr = st.nextToken();
      LogLog.debug(""Level token is ["" + levelStr + ""]."");

      
      
      
      if(INHERITED.equalsIgnoreCase(levelStr) || 
 	                                  NULL.equalsIgnoreCase(levelStr)) {
	if(loggerName.equals(INTERNAL_ROOT_NAME)) {
	  LogLog.warn(""The root logger cannot be set to null."");
	} else {
	  logger.setLevel(null);
	}
      } else {
	logger.setLevel(OptionConverter.toLevel(levelStr, (Level) Level.DEBUG));
      }
      LogLog.debug(""Category "" + loggerName + "" set to "" + logger.getLevel());
    }

    
    logger.removeAllAppenders();

    Appender appender;
    String appenderName;
    while(st.hasMoreTokens()) {
      appenderName = st.nextToken().trim();
      if(appenderName == null || appenderName.equals("",""))
	continue;
      LogLog.debug(""Parsing appender named \"""" + appenderName +""\""."");
      appender = parseAppender(props, appenderName);
      if(appender != null) {
	logger.addAppender(appender);
      }
    }
  }

  Appender parseAppender(Properties props, String appenderName) {
    Appender appender = registryGet(appenderName);
    if((appender != null)) {
      LogLog.debug(""Appender \"""" + appenderName + ""\"" was already parsed."");
      return appender;
    }
    
    String prefix = APPENDER_PREFIX + appenderName;
    String layoutPrefix = prefix + "".layout"";

    appender = (Appender) OptionConverter.instantiateByKey(props, prefix,
					      org.apache.log4j.Appender.class,
					      null);
    if(appender == null) {
      LogLog.error(
              ""Could not instantiate appender named \"""" + appenderName+""\""."");
      return null;
    }
    appender.setName(appenderName);

    if(appender instanceof OptionHandler) {
      if(appender.requiresLayout()) {
	Layout layout = (Layout) OptionConverter.instantiateByKey(props,
								  layoutPrefix,
								  Layout.class,
								  null);
	if(layout != null) {
	  appender.setLayout(layout);
	  LogLog.debug(""Parsing layout options for \"""" + appenderName +""\""."");
	  
          PropertySetter.setProperties(layout, props, layoutPrefix + ""."");
	  LogLog.debug(""End of parsing for \"""" + appenderName +""\""."");
	}
      }
      final String errorHandlerPrefix = prefix + "".errorhandler"";
      String errorHandlerClass = OptionConverter.findAndSubst(errorHandlerPrefix, props);
      if (errorHandlerClass != null) {
    		ErrorHandler eh = (ErrorHandler) OptionConverter.instantiateByKey(props,
					  errorHandlerPrefix,
					  ErrorHandler.class,
					  null);
    		if (eh != null) {
    			  appender.setErrorHandler(eh);
    			  LogLog.debug(""Parsing errorhandler options for \"""" + appenderName +""\""."");
    			  parseErrorHandler(eh, errorHandlerPrefix, props, repository);
    			  final Properties edited = new Properties();
    			  final String[] keys = new String[] { 
    					  errorHandlerPrefix + ""."" + ROOT_REF,
    					  errorHandlerPrefix + ""."" + LOGGER_REF,
    					  errorHandlerPrefix + ""."" + APPENDER_REF_TAG
    			  };
    			  for(Iterator iter = props.entrySet().iterator();iter.hasNext();) {
    				  Map.Entry entry = (Map.Entry) iter.next();
    				  int i = 0;
    				  for(; i < keys.length; i++) {
    					  if(keys[i].equals(entry.getKey())) break;
    				  }
    				  if (i == keys.length) {
    					  edited.put(entry.getKey(), entry.getValue());
    				  }
    			  }
    		      PropertySetter.setProperties(eh, edited, errorHandlerPrefix + ""."");
    			  LogLog.debug(""End of errorhandler parsing for \"""" + appenderName +""\""."");
    		}
    	  
      }
      
      PropertySetter.setProperties(appender, props, prefix + ""."");
      LogLog.debug(""Parsed \"""" + appenderName +""\"" options."");
    }
    parseAppenderFilters(props, appenderName, appender);
    registryPut(appender);
    return appender;
  }
  
  private void parseErrorHandler(
		  final ErrorHandler eh,
		  final String errorHandlerPrefix,
		  final Properties props, 
		  final LoggerRepository hierarchy) {
		boolean rootRef = OptionConverter.toBoolean(
					  OptionConverter.findAndSubst(errorHandlerPrefix + ROOT_REF, props), false);
		if (rootRef) {
				  eh.setLogger(hierarchy.getRootLogger());
	    }
		String loggerName = OptionConverter.findAndSubst(errorHandlerPrefix + LOGGER_REF , props);
		if (loggerName != null) {
			Logger logger = (loggerFactory == null) ? hierarchy.getLogger(loggerName)
			                : hierarchy.getLogger(loggerName, loggerFactory);
			eh.setLogger(logger);
		}
		String appenderName = OptionConverter.findAndSubst(errorHandlerPrefix + APPENDER_REF_TAG, props);
		if (appenderName != null) {
			Appender backup = parseAppender(props, appenderName);
			if (backup != null) {
				eh.setBackupAppender(backup);
			}
		}
  }
				
  
  void parseAppenderFilters(Properties props, String appenderName, Appender appender) {
    
    
    
    final String filterPrefix = APPENDER_PREFIX + appenderName + "".filter."";
    int fIdx = filterPrefix.length();
    Hashtable filters = new Hashtable();
    Enumeration e = props.keys();
    String name = """";
    while (e.hasMoreElements()) {
      String key = (String) e.nextElement();
      if (key.startsWith(filterPrefix)) {
        int dotIdx = key.indexOf('.', fIdx);
        String filterKey = key;
        if (dotIdx != -1) {
          filterKey = key.substring(0, dotIdx);
          name = key.substring(dotIdx+1);
        }
        Vector filterOpts = (Vector) filters.get(filterKey);
        if (filterOpts == null) {
          filterOpts = new Vector();
          filters.put(filterKey, filterOpts);
        }
        if (dotIdx != -1) {
          String value = OptionConverter.findAndSubst(key, props);
          filterOpts.add(new NameValue(name, value));
        }
      }
    }

    
    
    Enumeration g = new SortedKeyEnumeration(filters);
    while (g.hasMoreElements()) {
      String key = (String) g.nextElement();
      String clazz = props.getProperty(key);
      if (clazz != null) {
        LogLog.debug(""Filter key: [""+key+""] class: [""+props.getProperty(key) +""] props: ""+filters.get(key));
        Filter filter = (Filter) OptionConverter.instantiateByClassName(clazz, Filter.class, null);
        if (filter != null) {
          PropertySetter propSetter = new PropertySetter(filter);
          Vector v = (Vector)filters.get(key);
          Enumeration filterProps = v.elements();
          while (filterProps.hasMoreElements()) {
            NameValue kv = (NameValue)filterProps.nextElement();
            propSetter.setProperty(kv.key, kv.value);
          }
          propSetter.activate();
          LogLog.debug(""Adding filter of type [""+filter.getClass()
           +""] to appender named [""+appender.getName()+""]."");
          appender.addFilter(filter);
        }
      } else {
        LogLog.warn(""Missing class definition for filter: [""+key+""]"");
      }
    }
  }


  void  registryPut(Appender appender) {
    registry.put(appender.getName(), appender);
  }

  Appender registryGet(String name) {
    return (Appender) registry.get(name);
  }
}

class PropertyWatchdog extends FileWatchdog {

  PropertyWatchdog(String filename) {
    super(filename);
  }

  
  public
  void doOnChange() {
    new PropertyConfigurator().doConfigure(filename,
					   LogManager.getLoggerRepository());
  }
}

class NameValue {
  String key, value;
  public NameValue(String key, String value) {
    this.key = key;
    this.value = value;
  }
  public String toString() {
    return key + ""="" + value;
  }
}

class SortedKeyEnumeration implements Enumeration {

  private Enumeration e;

  public SortedKeyEnumeration(Hashtable ht) {
    Enumeration f = ht.keys();
    Vector keys = new Vector(ht.size());
    for (int i, last = 0; f.hasMoreElements(); ++last) {
      String key = (String) f.nextElement();
      for (i = 0; i < last; ++i) {
        String s = (String) keys.get(i);
        if (key.compareTo(s) <= 0) break;
      }
      keys.add(i, key);
    }
    e = keys.elements();
  }

  public boolean hasMoreElements() {
    return e.hasMoreElements();
  }

  public Object nextElement() {
    return e.nextElement();
  }
}
"
log4j,1.2,org.apache.log4j.varia.DenyAllFilter,4,2,0,2,5,6,0,2,4,2.0,12,0.0,0,0.571428571,0.5,0,0,2.0,1,0.75,2,"

package org.apache.log4j.varia;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;



public class DenyAllFilter extends Filter {

  
  public
  String[] getOptionStrings() {
    return null;
  }

  
  
  public
  void setOption(String key, String value) {
  }
  
  
  public
  int decide(LoggingEvent event) {
    return Filter.DENY;
  }
}

"
log4j,1.2,org.apache.log4j.spi.AppenderAttachable,7,1,0,5,7,21,4,1,7,2.0,7,0.0,0,0.0,0.571428571,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;

import org.apache.log4j.Appender;
import java.util.Enumeration;


public interface AppenderAttachable {
  
  
  public
  void addAppender(Appender newAppender);

  
  public
  Enumeration getAllAppenders();

  
  public
  Appender getAppender(String name);

  
  
  public 
  boolean isAttached(Appender appender);

  
  void removeAllAppenders();


  
   void removeAppender(Appender appender);


 
 void
 removeAppender(String name);   
}

"
log4j,1.2,org.apache.log4j.net.SocketHubAppender,12,2,0,5,30,18,1,5,11,0.654545455,205,0.8,1,0.642857143,0.333333333,1,2,15.66666667,6,1.4167,2,"

package org.apache.log4j.net;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.Vector;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;



public class SocketHubAppender extends AppenderSkeleton {

  
  static final int DEFAULT_PORT = 4560;
  
  private int port = DEFAULT_PORT;
  private Vector oosList = new Vector();
  private ServerMonitor serverMonitor = null;
  private boolean locationInfo = false;
  private CyclicBuffer buffer = null;
  private String application;
  private boolean advertiseViaMulticastDNS;
  private ZeroConfSupport zeroConf;

  
  public static final String ZONE = ""_log4j_obj_tcpaccept_appender.local."";
  private ServerSocket serverSocket;


    public SocketHubAppender() { }

  
  public
  SocketHubAppender(int _port) {
    port = _port;
    startServer();
  }

  
  public
  void activateOptions() {
    if (advertiseViaMulticastDNS) {
      zeroConf = new ZeroConfSupport(ZONE, port, getName());
      zeroConf.advertise();
    }
    startServer();
  }

  
  synchronized
  public
  void close() {
    if(closed)
      return;

	LogLog.debug(""closing SocketHubAppender "" + getName());
    this.closed = true;
    if (advertiseViaMulticastDNS) {
      zeroConf.unadvertise();
    }
    cleanUp();

	LogLog.debug(""SocketHubAppender "" + getName() + "" closed"");
  }

  
  public 
  void cleanUp() {
    
	LogLog.debug(""stopping ServerSocket"");
    serverMonitor.stopMonitor();
    serverMonitor = null;

    
	LogLog.debug(""closing client connections"");
    while (oosList.size() != 0) {
      ObjectOutputStream oos = (ObjectOutputStream)oosList.elementAt(0);
      if(oos != null) {
        try {
        	oos.close();
        } catch(InterruptedIOException e) {
            Thread.currentThread().interrupt();
            LogLog.error(""could not close oos."", e);
        } catch(IOException e) {
            LogLog.error(""could not close oos."", e);
        }
        
        oosList.removeElementAt(0);     
      }
    }
  }

  
  public
  void append(LoggingEvent event) {
    if (event != null) {
      
      if (locationInfo) {
        event.getLocationInformation();
      }
      if (application != null) {
          event.setProperty(""application"", application);
        } 
        event.getNDC();
        event.getThreadName();
        event.getMDCCopy();
        event.getRenderedMessage();
        event.getThrowableStrRep();
        
      if (buffer != null) {
        buffer.add(event);
      }
    }

    
    if ((event == null) || (oosList.size() == 0)) {
      return;
    }

	
    for (int streamCount = 0; streamCount < oosList.size(); streamCount++) {    	

      ObjectOutputStream oos = null;
      try {
        oos = (ObjectOutputStream)oosList.elementAt(streamCount);
      }
      catch (ArrayIndexOutOfBoundsException e) {
        
        
        
      }
      
      
      if (oos == null)
        break;
        
      try {
      	oos.writeObject(event);
      	oos.flush();
    	
    	
    	
    	oos.reset();
      }
      catch(IOException e) {
        if (e instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
          
      	oosList.removeElementAt(streamCount);
      	LogLog.debug(""dropped connection"");
      	
      	
      	streamCount--;
      }
    }
  }
  
  
  public
  boolean requiresLayout() {
    return false;
  }
  
  
  public
  void setPort(int _port) {
    port = _port;
	}

  
  public 
  void setApplication(String lapp) {
    this.application = lapp;
  }

  
  public 
  String getApplication() {
    return application;
  }
  
  
  public
  int getPort() {
    return port;
  }

  
  public 
  void setBufferSize(int _bufferSize) {
    buffer = new CyclicBuffer(_bufferSize);
  }

  
  public 
  int getBufferSize() {
    if (buffer == null) {
      return 0;
    } else {
      return buffer.getMaxSize();
    }
  }
  
  
  public
  void setLocationInfo(boolean _locationInfo) {
    locationInfo = _locationInfo;
  }
  
  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  public void setAdvertiseViaMulticastDNS(boolean advertiseViaMulticastDNS) {
    this.advertiseViaMulticastDNS = advertiseViaMulticastDNS;
  }

  public boolean isAdvertiseViaMulticastDNS() {
    return advertiseViaMulticastDNS;
  }

  
  private
  void startServer() {
    serverMonitor = new ServerMonitor(port, oosList);
  }
  
  
  protected ServerSocket createServerSocket(final int socketPort) throws IOException {
      return new ServerSocket(socketPort);
  }

  
  private class ServerMonitor implements Runnable {
    private int port;
    private Vector oosList;
    private boolean keepRunning;
    private Thread monitorThread;
    
    
    public
    ServerMonitor(int _port, Vector _oosList) {
      port = _port;
      oosList = _oosList;
      keepRunning = true;
      monitorThread = new Thread(this);
      monitorThread.setDaemon(true);
      monitorThread.setName(""SocketHubAppender-Monitor-"" + port);
      monitorThread.start();
    }
    
    
    public synchronized void stopMonitor() {
      if (keepRunning) {
    	LogLog.debug(""server monitor thread shutting down"");
        keepRunning = false;
        try {
            if (serverSocket != null) {
                serverSocket.close();
                serverSocket = null;
            }
        } catch (IOException ioe) {}

        try {
          monitorThread.join();
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
          
        }
        
        
        monitorThread = null;
    	LogLog.debug(""server monitor thread shut down"");
      }
    }
    
    private 
    void sendCachedEvents(ObjectOutputStream stream) throws IOException {
      if (buffer != null) {
        for (int i = 0; i < buffer.length(); i++) {
          stream.writeObject(buffer.get(i));
        }
        stream.flush();
        stream.reset();
      }
    }

    
    public
    void run() {
      serverSocket = null;
      try {
        serverSocket = createServerSocket(port);
        serverSocket.setSoTimeout(1000);
      }
      catch (Exception e) {
        if (e instanceof InterruptedIOException || e instanceof InterruptedException) {
            Thread.currentThread().interrupt();
        }
        LogLog.error(""exception setting timeout, shutting down server socket."", e);
        keepRunning = false;
        return;
      }

      try {
    	try {
        	serverSocket.setSoTimeout(1000);
    	}
    	catch (SocketException e) {
          LogLog.error(""exception setting timeout, shutting down server socket."", e);
          return;
    	}
      
    	while (keepRunning) {
          Socket socket = null;
          try {
            socket = serverSocket.accept();
          }
          catch (InterruptedIOException e) {
            
          }
          catch (SocketException e) {
            LogLog.error(""exception accepting socket, shutting down server socket."", e);
            keepRunning = false;
          }
          catch (IOException e) {
            LogLog.error(""exception accepting socket."", e);
          }
	        
          
          if (socket != null) {
            try {
              InetAddress remoteAddress = socket.getInetAddress();
              LogLog.debug(""accepting connection from "" + remoteAddress.getHostName() 
			   + "" ("" + remoteAddress.getHostAddress() + "")"");
	        	
              
              ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
              if (buffer != null && buffer.length() > 0) {
                sendCachedEvents(oos);
              }
	            
              
              oosList.addElement(oos);
            } catch (IOException e) {
              if (e instanceof InterruptedIOException) {
                    Thread.currentThread().interrupt();
              }
              LogLog.error(""exception creating output stream on socket."", e);
            }
          }
        }
      }
      finally {
    	
    	try {
    		serverSocket.close();
    	} catch(InterruptedIOException e) {
            Thread.currentThread().interrupt();  
        } catch (IOException e) {
    		
    	}
      }
    }
  }
}

"
log4j,1.2,org.apache.log4j.jmx.AppenderDynamicMBean,12,2,0,11,66,0,1,10,6,0.75,681,0.666666667,2,0.523809524,0.190909091,1,1,54.75,6,1.3333,3,"

package org.apache.log4j.jmx;

import org.apache.log4j.Appender;
import org.apache.log4j.Layout;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;

import javax.management.Attribute;
import javax.management.AttributeNotFoundException;
import javax.management.InvalidAttributeValueException;
import javax.management.JMException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.MBeanServer;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import javax.management.ReflectionException;
import javax.management.RuntimeOperationsException;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Hashtable;
import java.util.Vector;
import java.io.InterruptedIOException;

public class AppenderDynamicMBean extends AbstractDynamicMBean {

  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private Vector dAttributes = new Vector();
  private String dClassName = this.getClass().getName();

  private Hashtable dynamicProps = new Hashtable(5);
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[2];
  private String dDescription =
     ""This MBean acts as a management facade for log4j appenders."";

  
  private static Logger cat = Logger.getLogger(AppenderDynamicMBean.class);

  
  private Appender appender;

  public  AppenderDynamicMBean(Appender appender) throws IntrospectionException {
    this.appender = appender;
    buildDynamicMBeanInfo();
  }

  private
  void buildDynamicMBeanInfo() throws IntrospectionException {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
             ""AppenderDynamicMBean(): Constructs a AppenderDynamicMBean instance"",
	     constructors[0]);


    BeanInfo bi = Introspector.getBeanInfo(appender.getClass());
    PropertyDescriptor[] pd = bi.getPropertyDescriptors();

    int size = pd.length;

    for(int i = 0; i < size; i++) {
      String name = pd[i].getName();
      Method readMethod =  pd[i].getReadMethod();
      Method writeMethod =  pd[i].getWriteMethod();
      if(readMethod != null) {
	Class returnClass = readMethod.getReturnType();
	if(isSupportedType(returnClass)) {
	  String returnClassName;
	  if(returnClass.isAssignableFrom(Priority.class)) {
	    returnClassName = ""java.lang.String"";
	  } else {
	    returnClassName = returnClass.getName();
	  }

	  dAttributes.add(new MBeanAttributeInfo(name,
						 returnClassName,
						 ""Dynamic"",
						 true,
						 writeMethod != null,
						 false));
	  dynamicProps.put(name, new MethodUnion(readMethod, writeMethod));
	}
      }
    }

    MBeanParameterInfo[] params = new MBeanParameterInfo[0];

    dOperations[0] = new MBeanOperationInfo(""activateOptions"",
					    ""activateOptions(): add an appender"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);

    params = new MBeanParameterInfo[1];
    params[0] = new MBeanParameterInfo(""layout class"", ""java.lang.String"",
				       ""layout class"");

    dOperations[1] = new MBeanOperationInfo(""setLayout"",
					    ""setLayout(): add a layout"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
  }

  private
  boolean isSupportedType(Class clazz) {
    if(clazz.isPrimitive()) {
      return true;
    }

    if(clazz == String.class) {
      return true;
    }


    if(clazz.isAssignableFrom(Priority.class)) {
      return true;
    }

    return false;


  }



  public
  MBeanInfo getMBeanInfo() {
    cat.debug(""getMBeanInfo called."");

    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[dAttributes.size()];
    dAttributes.toArray(attribs);

    return new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
  }

  public
  Object invoke(String operationName, Object params[], String signature[])
    throws MBeanException,
    ReflectionException {

    if(operationName.equals(""activateOptions"") &&
                     appender instanceof OptionHandler) {
      OptionHandler oh = (OptionHandler) appender;
      oh.activateOptions();
      return ""Options activated."";
    } else if (operationName.equals(""setLayout"")) {
      Layout layout = (Layout) OptionConverter.instantiateByClassName((String)
								      params[0],
								      Layout.class,
								      null);
      appender.setLayout(layout);
      registerLayoutMBean(layout);
    }
    return null;
  }

  void registerLayoutMBean(Layout layout) {
    if(layout == null)
      return;

    String name = getAppenderName(appender)+"",layout=""+layout.getClass().getName();
    cat.debug(""Adding LayoutMBean:""+name);
    ObjectName objectName = null;
    try {
      LayoutDynamicMBean appenderMBean = new LayoutDynamicMBean(layout);
      objectName = new ObjectName(""log4j:appender=""+name);
      if (!server.isRegistered(objectName)) {
        registerMBean(appenderMBean, objectName);
        dAttributes.add(new MBeanAttributeInfo(""appender="" + name, ""javax.management.ObjectName"",
                ""The "" + name + "" layout."", true, true, false));
      }

    } catch(JMException e) {
      cat.error(""Could not add DynamicLayoutMBean for [""+name+""]."", e);
    } catch(java.beans.IntrospectionException e) {
      cat.error(""Could not add DynamicLayoutMBean for [""+name+""]."", e);
    } catch(RuntimeException e) {
      cat.error(""Could not add DynamicLayoutMBean for [""+name+""]."", e);
    }
  }

  protected
  Logger getLogger() {
    return cat;
  }


  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                   MBeanException,
                                                   ReflectionException {

       
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }

    cat.debug(""getAttribute called with [""+attributeName+""]."");
    if(attributeName.startsWith(""appender=""+appender.getName()+"",layout"")) {
      try {
	    return new ObjectName(""log4j:""+attributeName );
      } catch(MalformedObjectNameException e) {
	    cat.error(""attributeName"", e);
      } catch(RuntimeException e) {
	    cat.error(""attributeName"", e);
      }
    }

    MethodUnion mu = (MethodUnion) dynamicProps.get(attributeName);

    

    if(mu != null && mu.readMethod != null) {
      try {
	return mu.readMethod.invoke(appender, null);
      } catch(IllegalAccessException e) {
	    return null;
      } catch(InvocationTargetException e) {
          if (e.getTargetException() instanceof InterruptedException
                  || e.getTargetException() instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	    return null;
      } catch(RuntimeException e) {
	    return null;
      }
    }



    
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));

  }


  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {

    
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
		  ""Cannot invoke a setter of "" + dClassName +
		  "" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();

    if (name == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""Attribute name cannot be null""),
		    ""Cannot invoke the setter of ""+dClassName+
		    "" with null attribute name"");
    }



    MethodUnion mu = (MethodUnion) dynamicProps.get(name);

    if(mu != null && mu.writeMethod != null) {
      Object[] o = new Object[1];

      Class[] params = mu.writeMethod.getParameterTypes();
      if(params[0] == org.apache.log4j.Priority.class) {
	value = OptionConverter.toLevel((String) value,
					(Level) getAttribute(name));
      }
      o[0] = value;

      try {
	mu.writeMethod.invoke(appender,  o);

      } catch(InvocationTargetException e) {
        if (e.getTargetException() instanceof InterruptedException
                || e.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
        cat.error(""FIXME"", e);
      } catch(IllegalAccessException e) {
	    cat.error(""FIXME"", e);
      } catch(RuntimeException e) {
	    cat.error(""FIXME"", e);
      }
    } else if(name.endsWith("".layout"")) {

    } else {
      throw(new AttributeNotFoundException(""Attribute "" + name +
					   "" not found in "" +
					   this.getClass().getName()));
    }
  }

  public
  ObjectName preRegister(MBeanServer server, ObjectName name) {
    cat.debug(""preRegister called. Server=""+server+ "", name=""+name);
    this.server = server;
    registerLayoutMBean(appender.getLayout());

    return name;
  }


}

"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath,8,1,0,6,23,0,5,1,8,0.0,154,1.0,0,0.0,0.34375,0,0,18.125,2,1.0,2,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.util.LinkedList;
import java.util.StringTokenizer;





public class CategoryPath {
  
  
  

  
  
  
  protected LinkedList _categoryElements = new LinkedList();

  
  
  

  
  
  

  public CategoryPath() {
    super();
  }

  
  public CategoryPath(String category) {
    String processedCategory = category;

    if (processedCategory == null) {
      processedCategory = ""Debug"";
    }

    processedCategory = processedCategory.replace('/', '.');
    processedCategory = processedCategory.replace('\\', '.');

    StringTokenizer st = new StringTokenizer(processedCategory, ""."");
    while (st.hasMoreTokens()) {
      String element = st.nextToken();
      addCategoryElement(new CategoryElement(element));
    }
  }

  
  
  

  
  public int size() {
    int count = _categoryElements.size();

    return (count);
  }

  public boolean isEmpty() {
    boolean empty = false;

    if (_categoryElements.size() == 0) {
      empty = true;
    }

    return (empty);
  }


  
  public void removeAllCategoryElements() {
    _categoryElements.clear();
  }

  
  public void addCategoryElement(CategoryElement categoryElement) {
    _categoryElements.addLast(categoryElement);
  }

  
  public CategoryElement categoryElementAt(int index) {
    return ((CategoryElement) _categoryElements.get(index));
  }


  public String toString() {
    StringBuffer out = new StringBuffer(100);

    out.append(""\n"");
    out.append(""===========================\n"");
    out.append(""CategoryPath:                   \n"");
    out.append(""---------------------------\n"");

    out.append(""\nCategoryPath:\n\t"");

    if (this.size() > 0) {
      for (int i = 0; i < this.size(); i++) {
        out.append(this.categoryElementAt(i).toString());
        out.append(""\n\t"");
      }
    } else {
      out.append(""<<NONE>>"");
    }

    out.append(""\n"");
    out.append(""===========================\n"");

    return (out.toString());
  }

  
  
  

  
  
  

  
  
  

}
"
log4j,1.2,org.apache.log4j.lf5.DefaultLF5Configurator,4,1,0,3,15,6,0,3,2,1.0,54,0.0,0,0.0,0.3125,0,0,12.25,1,0.75,2,"

package org.apache.log4j.lf5;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggerRepository;





public class DefaultLF5Configurator implements Configurator {
  
  
  

  
  
  

  
  
  

  
  
  
  
  private DefaultLF5Configurator() {

  }

  
  
  
  
  public static void configure() throws IOException {
    String resource =
        ""/org/apache/log4j/lf5/config/defaultconfig.properties"";
    URL configFileResource =
        DefaultLF5Configurator.class.getResource(resource);

    if (configFileResource != null) {
      PropertyConfigurator.configure(configFileResource);
    } else {
      throw new IOException(""Error: Unable to open the resource"" +
          resource);
    }

  }

  
  public void doConfigure(InputStream inputStream, LoggerRepository repository) {
    throw new IllegalStateException(""This class should NOT be instantiated!"");
  }

  
  public void doConfigure(URL configURL, LoggerRepository repository) {
    throw new IllegalStateException(""This class should NOT be instantiated!"");
  }

  
  
  

  
  
  

  
  
  

}"
log4j,1.2,org.apache.log4j.lf5.StartLogFactor5,2,1,0,3,10,1,0,3,2,2.0,20,0.0,0,0.0,0.5,0,0,9.0,1,0.5,2,"
package org.apache.log4j.lf5;

import org.apache.log4j.lf5.viewer.LogBrokerMonitor;





public class StartLogFactor5 {
  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  public final static void main(String[] args) {

    LogBrokerMonitor monitor = new LogBrokerMonitor(
        LogLevel.getLog4JLevels());

    monitor.setFrameSize(LF5Appender.getDefaultMonitorWidth(),
        LF5Appender.getDefaultMonitorHeight());
    monitor.setFontSize(12);
    monitor.show();

  }

  
  
  

  
  
  

  
  
  

}


"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNodeEditorRenderer,3,7,0,2,5,3,1,1,3,2.0,21,0.0,0,0.997122302,0.466666667,1,1,6.0,1,0.6667,3,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.awt.Component;

import javax.swing.JCheckBox;
import javax.swing.JTree;





public class CategoryNodeEditorRenderer extends CategoryNodeRenderer {
  private static final long serialVersionUID = -6094804684259929574L;

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  public Component getTreeCellRendererComponent(
      JTree tree, Object value,
      boolean selected, boolean expanded,
      boolean leaf, int row,
      boolean hasFocus) {
    Component c = super.getTreeCellRendererComponent(tree,
        value, selected, expanded,
        leaf, row, hasFocus);

    return c;
  }

  public JCheckBox getCheckBox() {
    return _checkBox;
  }

  
  
  

  
  
  

  
  
  

}
"
log4j,1.2,org.apache.log4j.MDC,10,1,0,4,19,5,2,2,4,0.416666667,123,0.0,1,0.0,0.481481481,0,0,10.9,3,1.5,3,"

package org.apache.log4j;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Hashtable;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.ThreadLocalMap;


public class MDC {
  
  final static MDC mdc = new MDC();
  
  static final int HT_SIZE = 7;

  boolean java1;
  
  Object tlm;

  private Method removeMethod;

  private
  MDC() {
    java1 = Loader.isJava1();
    if(!java1) {
      tlm = new ThreadLocalMap();
    }

    try {
      removeMethod = ThreadLocal.class.getMethod(""remove"", null);
    } catch (NoSuchMethodException e) {
      
    }
  }

  
  static
  public
  void put(String key, Object o) {
     if (mdc != null) {
         mdc.put0(key, o);
     }
  }
  
  
  static 
  public
  Object get(String key) {
    if (mdc != null) {
        return mdc.get0(key);
    }
    return null;
  }

  
  static 
  public
  void remove(String key) {
    if (mdc != null) {
        mdc.remove0(key);
    }
  }


  
  public static Hashtable getContext() {
    if (mdc != null) {
        return mdc.getContext0();
    } else {
        return null;
    }
  }

  
  public static void clear() {
    if (mdc != null) {
        mdc.clear0();
    }
  }


  private
  void put0(String key, Object o) {
    if(java1 || tlm == null) {
      return;
    } else {
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht == null) {
        ht = new Hashtable(HT_SIZE);
        ((ThreadLocalMap)tlm).set(ht);
      }    
      ht.put(key, o);
    }
  }
  
  private
  Object get0(String key) {
    if(java1 || tlm == null) {
      return null;
    } else {       
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht != null && key != null) {
        return ht.get(key);
      } else {
        return null;
      }
    }
  }

  private
  void remove0(String key) {
    if(!java1 && tlm != null) {
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht != null) {
        ht.remove(key);
        
        if (ht.isEmpty()) {
          clear0();
        }
      } 
    }
  }


  private
  Hashtable getContext0() {
     if(java1 || tlm == null) {
      return null;
    } else {       
      return (Hashtable) ((ThreadLocalMap)tlm).get();
    }
  }

  private
  void clear0() {
    if(!java1 && tlm != null) {
      Hashtable ht = (Hashtable) ((ThreadLocalMap)tlm).get();
      if(ht != null) {
        ht.clear();
      }
      if(removeMethod != null) {
          
          try {
            removeMethod.invoke(tlm, null);
          } catch (IllegalAccessException e) {
            
          } catch (InvocationTargetException e) {
            
          }
      }
    }
  }

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.TreeModelAdapter,5,1,1,1,6,10,1,0,5,2.0,12,0.0,0,0.0,0.9,0,0,1.4,1,0.8,2,"

package org.apache.log4j.lf5.viewer.categoryexplorer;

import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;





public class TreeModelAdapter implements TreeModelListener {
  
  
  

  
  
  

  
  
  

  
  
  

  
  
  
  public void treeNodesChanged(TreeModelEvent e) {
  }

  public void treeNodesInserted(TreeModelEvent e) {
  }

  public void treeNodesRemoved(TreeModelEvent e) {
  }

  public void treeStructureChanged(TreeModelEvent e) {
  }

  
  
  

  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.ConsoleAppender,8,3,0,11,18,8,7,4,6,0.857142857,116,0.333333333,0,0.871794872,0.541666667,2,5,13.125,3,1.0,7,"

package org.apache.log4j;

import java.io.IOException;
import java.io.OutputStream;
import org.apache.log4j.helpers.LogLog;


public class ConsoleAppender extends WriterAppender {

  public static final String SYSTEM_OUT = ""System.out"";
  public static final String SYSTEM_ERR = ""System.err"";

  protected String target = SYSTEM_OUT;

  
  private boolean follow = false;

  
  public ConsoleAppender() {
  }

    
  public ConsoleAppender(Layout layout) {
    this(layout, SYSTEM_OUT);
  }

    
  public ConsoleAppender(Layout layout, String target) {
    setLayout(layout);
    setTarget(target);
    activateOptions();
  }

  
  public
  void setTarget(String value) {
    String v = value.trim();

    if (SYSTEM_OUT.equalsIgnoreCase(v)) {
      target = SYSTEM_OUT;
    } else if (SYSTEM_ERR.equalsIgnoreCase(v)) {
      target = SYSTEM_ERR;
    } else {
      targetWarn(value);
    }
  }

  
  public
  String getTarget() {
    return target;
  }
  
  
  public final void setFollow(final boolean newValue) {
     follow = newValue;
  }
  
  
  public final boolean getFollow() {
      return follow;
  }

  void targetWarn(String val) {
    LogLog.warn(""[""+val+""] should be System.out or System.err."");
    LogLog.warn(""Using previously set target, System.out by default."");
  }

  
   public void activateOptions() {
        if (follow) {
            if (target.equals(SYSTEM_ERR)) {
               setWriter(createWriter(new SystemErrStream()));
            } else {
               setWriter(createWriter(new SystemOutStream()));
            }
        } else {
            if (target.equals(SYSTEM_ERR)) {
               setWriter(createWriter(System.err));
            } else {
               setWriter(createWriter(System.out));
            }
        }

        super.activateOptions();
  }
  
  
  protected
  final
  void closeWriter() {
     if (follow) {
        super.closeWriter();
     }
  }
  

    
    private static class SystemErrStream extends OutputStream {
        public SystemErrStream() {
        }

        public void close() {
        }

        public void flush() {
            System.err.flush();
        }

        public void write(final byte[] b) throws IOException {
            System.err.write(b);
        }

        public void write(final byte[] b, final int off, final int len)
            throws IOException {
            System.err.write(b, off, len);
        }

        public void write(final int b) throws IOException {
            System.err.write(b);
        }
    }

    
    private static class SystemOutStream extends OutputStream {
        public SystemOutStream() {
        }

        public void close() {
        }

        public void flush() {
            System.out.flush();
        }

        public void write(final byte[] b) throws IOException {
            System.out.write(b);
        }

        public void write(final byte[] b, final int off, final int len)
            throws IOException {
            System.out.write(b, off, len);
        }

        public void write(final int b) throws IOException {
            System.out.write(b);
        }
    }

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.FilteredLogTableModel,21,2,0,16,55,116,12,4,13,0.67,361,1.0,1,0.444444444,0.345238095,1,1,15.95238095,3,1.4762,2,"
package org.apache.log4j.lf5.viewer;

import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.LogRecordFilter;
import org.apache.log4j.lf5.PassingLogRecordFilter;

import javax.swing.table.AbstractTableModel;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;






public class FilteredLogTableModel
    extends AbstractTableModel {
  
  
  

  
  
  

  protected LogRecordFilter _filter = new PassingLogRecordFilter();
  protected List _allRecords = new ArrayList();
  protected List _filteredRecords;
  protected int _maxNumberOfLogRecords = 5000;
  protected String[] _colNames = {""Date"",
                                  ""Thread"",
                                  ""Message #"",
                                  ""Level"",
                                  ""NDC"",
                                  ""Category"",
                                  ""Message"",
                                  ""Location"",
                                  ""Thrown""};

  
  
  

  
  
  

  public FilteredLogTableModel() {
    super();
  }

  
  
  

  public void setLogRecordFilter(LogRecordFilter filter) {
    _filter = filter;
  }

  public LogRecordFilter getLogRecordFilter() {
    return _filter;
  }

  public String getColumnName(int i) {
    return _colNames[i];
  }

  public int getColumnCount() {
    return _colNames.length;
  }

  public int getRowCount() {
    return getFilteredRecords().size();
  }

  public int getTotalRowCount() {
    return _allRecords.size();
  }

  public Object getValueAt(int row, int col) {
    LogRecord record = getFilteredRecord(row);
    return getColumn(col, record);
  }

  public void setMaxNumberOfLogRecords(int maxNumRecords) {
    if (maxNumRecords > 0) {
      _maxNumberOfLogRecords = maxNumRecords;
    }

  }

  public synchronized boolean addLogRecord(LogRecord record) {

    _allRecords.add(record);

    if (_filter.passes(record) == false) {
      return false;
    }
    getFilteredRecords().add(record);
    fireTableRowsInserted(getRowCount(), getRowCount());
    trimRecords();
    return true;
  }

  
  public synchronized void refresh() {
    _filteredRecords = createFilteredRecordsList();
    fireTableDataChanged();
  }

  public synchronized void fastRefresh() {
    _filteredRecords.remove(0);
    fireTableRowsDeleted(0, 0);
  }


  
  public synchronized void clear() {
    _allRecords.clear();
    _filteredRecords.clear();
    fireTableDataChanged();
  }

  
  
  

  protected List getFilteredRecords() {
    if (_filteredRecords == null) {
      refresh();
    }
    return _filteredRecords;
  }

  protected List createFilteredRecordsList() {
    List result = new ArrayList();
    Iterator records = _allRecords.iterator();
    LogRecord current;
    while (records.hasNext()) {
      current = (LogRecord) records.next();
      if (_filter.passes(current)) {
        result.add(current);
      }
    }
    return result;
  }

  protected LogRecord getFilteredRecord(int row) {
    List records = getFilteredRecords();
    int size = records.size();
    if (row < size) {
      return (LogRecord) records.get(row);
    }
    
    
    
    
    return (LogRecord) records.get(size - 1);

  }

  protected Object getColumn(int col, LogRecord lr) {
    if (lr == null) {
      return ""NULL Column"";
    }
    String date = new Date(lr.getMillis()).toString();
    switch (col) {
      case 0:
        return date + "" ("" + lr.getMillis() + "")"";
      case 1:
        return lr.getThreadDescription();
      case 2:
        return new Long(lr.getSequenceNumber());
      case 3:
        return lr.getLevel();
      case 4:
        return lr.getNDC();
      case 5:
        return lr.getCategory();
      case 6:
        return lr.getMessage();
      case 7:
        return lr.getLocation();
      case 8:
        return lr.getThrownStackTrace();
      default:
        String message = ""The column number "" + col + ""must be between 0 and 8"";
        throw new IllegalArgumentException(message);
    }
  }

  
  
  

  
  
  protected void trimRecords() {
    if (needsTrimming()) {
      trimOldestRecords();
    }
  }

  protected boolean needsTrimming() {
    return (_allRecords.size() > _maxNumberOfLogRecords);
  }

  protected void trimOldestRecords() {
    synchronized (_allRecords) {
      int trim = numberOfRecordsToTrim();
      if (trim > 1) {
        List oldRecords =
            _allRecords.subList(0, trim);
        oldRecords.clear();
        refresh();
      } else {
        _allRecords.remove(0);
        fastRefresh();
      }
    }

  }

  
  
  
  private int numberOfRecordsToTrim() {
    return _allRecords.size() - _maxNumberOfLogRecords;
  }

  
  
  
}

"
log4j,1.2,org.apache.log4j.lf5.util.StreamUtils,5,1,0,1,14,10,1,0,5,1.25,57,0.0,0,0.0,0.45,0,0,10.2,1,0.8,2,"

package org.apache.log4j.lf5.util;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;





public abstract class StreamUtils {
  
  
  

  
  public static final int DEFAULT_BUFFER_SIZE = 2048;

  
  
  

  
  
  

  
  
  

  
  
  

  
  public static void copy(InputStream input, OutputStream output)
      throws IOException {
    copy(input, output, DEFAULT_BUFFER_SIZE);
  }

  
  public static void copy(InputStream input,
      OutputStream output,
      int bufferSize)
      throws IOException {
    byte[] buf = new byte[bufferSize];
    int bytesRead = input.read(buf);
    while (bytesRead != -1) {
      output.write(buf, 0, bytesRead);
      bytesRead = input.read(buf);
    }
    output.flush();
  }

  
  public static void copyThenClose(InputStream input, OutputStream output)
      throws IOException {
    copy(input, output);
    input.close();
    output.close();
  }

  
  public static byte[] getBytes(InputStream input)
      throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    copy(input, result);
    result.close();
    return result.toByteArray();
  }

  
  
  

  
  
  

  
  
  

}
"
log4j,1.2,org.apache.log4j.or.ThreadGroupRenderer,2,1,0,2,16,1,0,2,2,2.0,100,0.0,0,0.0,0.75,0,0,49.0,3,1.5,2,"

package org.apache.log4j.or;

import org.apache.log4j.Layout;



public class ThreadGroupRenderer implements ObjectRenderer {

  public
  ThreadGroupRenderer() {
  }
  
  
  public
  String  doRender(Object o) {
    if(o instanceof ThreadGroup) {
      StringBuffer sbuf = new StringBuffer();
      ThreadGroup tg = (ThreadGroup) o;
      sbuf.append(""java.lang.ThreadGroup[name="");
      sbuf.append(tg.getName());
      sbuf.append("", maxpri="");
      sbuf.append(tg.getMaxPriority());
      sbuf.append(""]"");
      Thread[] t = new Thread[tg.activeCount()];
      tg.enumerate(t);
      for(int i = 0; i < t.length; i++) {
	sbuf.append(Layout.LINE_SEP);	
	sbuf.append(""   Thread=["");
	sbuf.append(t[i].getName());
	sbuf.append("","");
	sbuf.append(t[i].getPriority());
	sbuf.append("","");
	sbuf.append(t[i].isDaemon());
	sbuf.append(""]"");
      }
      return sbuf.toString();
    } else {
      try {
        
        return o.toString();
      } catch(Exception ex) {
          return ex.toString();
      }
    }    
  }
}  
"
log4j,1.2,org.apache.log4j.helpers.RelativeTimeDateFormat,3,3,0,1,7,1,1,0,3,0.5,20,1.0,0,0.951219512,0.444444444,1,3,5.333333333,1,0.6667,4,"

package org.apache.log4j.helpers;

import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;


public class RelativeTimeDateFormat extends DateFormat {
  private static final long serialVersionUID = 7055751607085611984L;


  protected final long startTime;

  public
  RelativeTimeDateFormat() {
    this.startTime = System.currentTimeMillis();
  }
  
  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    
    return sbuf.append((date.getTime() - startTime));
  }

  
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
log4j,1.2,org.apache.log4j.helpers.ISO8601DateFormat,5,4,0,3,16,8,2,1,4,0.875,215,1.0,0,0.953488372,0.357142857,1,3,41.6,9,2.0,4,"

package org.apache.log4j.helpers;

import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;




public class ISO8601DateFormat extends AbsoluteTimeDateFormat {
  private static final long serialVersionUID = -759840745298755296L;

  public
  ISO8601DateFormat() {
  }

  public
  ISO8601DateFormat(TimeZone timeZone) {
    super(timeZone);
  }

  static private long   lastTime;
  static private char[] lastTimeString = new char[20];

  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    long now = date.getTime();
    int millis = (int)(now % 1000);

    if ((now - millis) != lastTime || lastTimeString[0] == 0) {
      
      
      

      calendar.setTime(date);

      int start = sbuf.length();

      int year =  calendar.get(Calendar.YEAR);
      sbuf.append(year);

      String month;
      switch(calendar.get(Calendar.MONTH)) {
      case Calendar.JANUARY: month = ""-01-""; break;
      case Calendar.FEBRUARY: month = ""-02-"";  break;
      case Calendar.MARCH: month = ""-03-""; break;
      case Calendar.APRIL: month = ""-04-"";  break;
      case Calendar.MAY: month = ""-05-""; break;
      case Calendar.JUNE: month = ""-06-"";  break;
      case Calendar.JULY: month = ""-07-""; break;
      case Calendar.AUGUST: month = ""-08-"";  break;
      case Calendar.SEPTEMBER: month = ""-09-""; break;
      case Calendar.OCTOBER: month = ""-10-""; break;
      case Calendar.NOVEMBER: month = ""-11-"";  break;
      case Calendar.DECEMBER: month = ""-12-"";  break;
      default: month = ""-NA-""; break;
      }
      sbuf.append(month);

      int day = calendar.get(Calendar.DAY_OF_MONTH);
      if(day < 10)
	sbuf.append('0');
      sbuf.append(day);

      sbuf.append(' ');

      int hour = calendar.get(Calendar.HOUR_OF_DAY);
      if(hour < 10) {
	sbuf.append('0');
      }
      sbuf.append(hour);
      sbuf.append(':');

      int mins = calendar.get(Calendar.MINUTE);
      if(mins < 10) {
	sbuf.append('0');
      }
      sbuf.append(mins);
      sbuf.append(':');

      int secs = calendar.get(Calendar.SECOND);
      if(secs < 10) {
	sbuf.append('0');
      }
      sbuf.append(secs);

      sbuf.append(',');

      
      sbuf.getChars(start, sbuf.length(), lastTimeString, 0);
      lastTime = now - millis;
    }
    else {
      sbuf.append(lastTimeString);
    }


    if (millis < 100)
      sbuf.append('0');
    if (millis < 10)
      sbuf.append('0');

    sbuf.append(millis);
    return sbuf;
  }

  
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }
}

"
log4j,1.2,org.apache.log4j.lf5.viewer.LogFactor5Dialog,7,6,3,3,28,19,3,0,1,0.833333333,202,1.0,0,0.992138365,0.291666667,2,3,27.71428571,3,1.5714,2,"
package org.apache.log4j.lf5.viewer;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Label;
import java.awt.Toolkit;
import java.awt.Window;

import javax.swing.JDialog;
import javax.swing.JFrame;





public abstract class LogFactor5Dialog extends JDialog {
  
  
  
  protected static final Font DISPLAY_FONT = new Font(""Arial"", Font.BOLD, 12);
  
  
  

  
  
  

  
  
  
  protected LogFactor5Dialog(JFrame jframe, String message, boolean modal) {
    super(jframe, message, modal);
  }

  
  
  
  public void show() {
    pack();
    minimumSizeDialog(this, 200, 100);
    centerWindow(this);
    super.show();
  }

  
  
  

  
  
  
  protected void centerWindow(Window win) {
    Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();

    
    if (screenDim.width < win.getSize().width) {
      win.setSize(screenDim.width, win.getSize().height);
    }

    if (screenDim.height < win.getSize().height) {
      win.setSize(win.getSize().width, screenDim.height);
    }

    
    int x = (screenDim.width - win.getSize().width) / 2;
    int y = (screenDim.height - win.getSize().height) / 2;
    win.setLocation(x, y);
  }

  protected void wrapStringOnPanel(String message,
      Container container) {
    GridBagConstraints c = getDefaultConstraints();
    c.gridwidth = GridBagConstraints.REMAINDER;
    
    c.insets = new Insets(0, 0, 0, 0);
    GridBagLayout gbLayout = (GridBagLayout) container.getLayout();


    while (message.length() > 0) {
      int newLineIndex = message.indexOf('\n');
      String line;
      if (newLineIndex >= 0) {
        line = message.substring(0, newLineIndex);
        message = message.substring(newLineIndex + 1);
      } else {
        line = message;
        message = """";
      }
      Label label = new Label(line);
      label.setFont(DISPLAY_FONT);
      gbLayout.setConstraints(label, c);
      container.add(label);
    }
  }

  protected GridBagConstraints getDefaultConstraints() {
    GridBagConstraints constraints = new GridBagConstraints();
    constraints.weightx = 1.0;
    constraints.weighty = 1.0;
    constraints.gridheight = 1; 
    
    constraints.insets = new Insets(4, 4, 4, 4);
    
    constraints.fill = GridBagConstraints.NONE;
    
    constraints.anchor = GridBagConstraints.WEST;

    return constraints;
  }

  protected void minimumSizeDialog(Component component,
      int minWidth,
      int minHeight) {
    
    if (component.getSize().width < minWidth)
      component.setSize(minWidth, component.getSize().height);
    
    if (component.getSize().height < minHeight)
      component.setSize(component.getSize().width, minHeight);
  }
  
  
  
}"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNodeRenderer,5,6,1,4,36,4,3,1,3,0.75,176,0.75,0,0.995670996,0.375,1,1,33.4,4,1.2,3,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import javax.swing.*;
import javax.swing.tree.DefaultTreeCellRenderer;
import java.awt.*;
import java.net.URL;





public class CategoryNodeRenderer extends DefaultTreeCellRenderer {
  private static final long serialVersionUID = -6046702673278595048L;

  
  
  

  public static final Color FATAL_CHILDREN = new Color(189, 113, 0);

  
  
  
  protected JCheckBox _checkBox = new JCheckBox();
  protected JPanel _panel = new JPanel();
  protected static ImageIcon _sat = null;


  
  
  

  
  
  
  public CategoryNodeRenderer() {
    _panel.setBackground(UIManager.getColor(""Tree.textBackground""));

    if (_sat == null) {
      
      String resource =
          ""/org/apache/log4j/lf5/viewer/images/channelexplorer_satellite.gif"";
      URL satURL = getClass().getResource(resource);

      _sat = new ImageIcon(satURL);
    }

    setOpaque(false);
    _checkBox.setOpaque(false);
    _panel.setOpaque(false);

    
    
    _panel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
    _panel.add(_checkBox);
    _panel.add(this);

    setOpenIcon(_sat);
    setClosedIcon(_sat);
    setLeafIcon(_sat);
  }

  
  
  
  public Component getTreeCellRendererComponent(
      JTree tree, Object value,
      boolean selected, boolean expanded,
      boolean leaf, int row,
      boolean hasFocus) {

    CategoryNode node = (CategoryNode) value;
    
    
    

    super.getTreeCellRendererComponent(
        tree, value, selected, expanded,
        leaf, row, hasFocus);

    if (row == 0) {
      
      _checkBox.setVisible(false);
    } else {
      _checkBox.setVisible(true);
      _checkBox.setSelected(node.isSelected());
    }
    String toolTip = buildToolTip(node);
    _panel.setToolTipText(toolTip);
    if (node.hasFatalChildren()) {
      this.setForeground(FATAL_CHILDREN);
    }
    if (node.hasFatalRecords()) {
      this.setForeground(Color.red);
    }

    return _panel;
  }

  public Dimension getCheckBoxOffset() {
    return new Dimension(0, 0);
  }

  
  
  

  protected String buildToolTip(CategoryNode node) {
    StringBuffer result = new StringBuffer();
    result.append(node.getTitle()).append("" contains a total of "");
    result.append(node.getTotalNumberOfRecords());
    result.append("" LogRecords."");
    result.append("" Right-click for more info."");
    return result.toString();
  }
  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.spi.VectorWriter,9,3,0,2,18,0,1,1,8,0.0,88,1.0,0,0.876923077,0.416666667,1,1,8.666666667,2,1.0,1,"
package org.apache.log4j.spi;

import java.io.PrintWriter;
import java.util.Vector;


class VectorWriter extends PrintWriter {

  private Vector v;

    
  VectorWriter() {
    super(new NullWriter());
    v = new Vector();
  }

  public void print(Object o) {
    v.addElement(String.valueOf(o));
  }

  public void print(char[] chars) {
    v.addElement(new String(chars));
  }

  public void print(String s) {
    v.addElement(s);
  }

  public void println(Object o) {
    v.addElement(String.valueOf(o));
  }

  
  
  public
  void println(char[] chars) {
    v.addElement(new String(chars));
  }

  public
  void println(String s) {
    v.addElement(s);
  }

  public void write(char[] chars) {
    v.addElement(new String(chars));
  }

  public void write(char[] chars, int off, int len) {
    v.addElement(new String(chars, off, len));
  }

  public void write(String s, int off, int len) {
    v.addElement(s.substring(off, off+len));
  }

  public void write(String s) {
     v.addElement(s);
  }

  public String[] toStringArray() {
    int len = v.size();
    String[] sa = new String[len];
    for(int i = 0; i < len; i++) {
      sa[i] = (String) v.elementAt(i);
    }
    return sa;
  }

}

"
log4j,1.2,org.apache.log4j.lf5.viewer.LogTableColumnFormatException,1,3,0,2,2,0,2,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,3,"
package org.apache.log4j.lf5.viewer;





public class LogTableColumnFormatException extends Exception {
  private static final long serialVersionUID = 6529165785030431653L;

  
  
  

  
  
  

  
  
  

  
  
  

  public LogTableColumnFormatException(String message) {
    super(message);
  }

  
  
  

  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.varia.LevelMatchFilter,6,2,0,5,10,0,0,5,6,0.5,62,0.0,1,0.444444444,0.375,1,1,9.0,5,1.6667,2,"

package org.apache.log4j.varia;

import org.apache.log4j.Level;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;


public class LevelMatchFilter extends Filter {
  
  
  boolean acceptOnMatch = true;

  
  Level levelToMatch;

 
  public
  void setLevelToMatch(String level) {
    levelToMatch = OptionConverter.toLevel(level, null);
  }
  
  public
  String getLevelToMatch() {
    return levelToMatch == null ? null : levelToMatch.toString();
  }
  
  public
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }
  

  
  public
  int decide(LoggingEvent event) {
    if(this.levelToMatch == null) {
      return Filter.NEUTRAL;
    }
    
    boolean matchOccured = false;
    if(this.levelToMatch.equals(event.getLevel())) {
      matchOccured = true;
    } 

    if(matchOccured) {  
      if(this.acceptOnMatch)
	  return Filter.ACCEPT;
      else
	  return Filter.DENY;
    } else {
      return Filter.NEUTRAL;
    }
  }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryElement,4,1,0,2,5,0,2,0,4,0.333333333,21,1.0,0,0.0,0.75,0,0,4.0,1,0.5,2,"
package org.apache.log4j.lf5.viewer.categoryexplorer;





public class CategoryElement {
  
  
  

  
  
  
  protected String _categoryTitle;

  
  
  

  
  
  

  public CategoryElement() {
    super();
  }

  public CategoryElement(String title) {
    _categoryTitle = title;
  }

  
  
  

  public String getTitle() {
    return (_categoryTitle);
  }

  public void setTitle(String title) {
    _categoryTitle = title;
  }

  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.chainsaw.MyTableModel,26,2,0,19,72,91,15,5,15,0.815555556,640,0.833333333,4,0.4,0.222857143,1,1,22.92307692,10,1.8462,2,"
package org.apache.log4j.chainsaw;

import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import javax.swing.table.AbstractTableModel;
import org.apache.log4j.Priority;
import org.apache.log4j.Logger;


class MyTableModel
    extends AbstractTableModel
{

    
    private static final Logger LOG = Logger.getLogger(MyTableModel.class);

    
    private static final Comparator MY_COMP = new Comparator()
    {
        
        public int compare(Object aObj1, Object aObj2) {
            if ((aObj1 == null) && (aObj2 == null)) {
                return 0; 
            } else if (aObj1 == null) {
                return -1; 
            } else if (aObj2 == null) {
                return 1; 
            }

            
            final EventDetails le1 = (EventDetails) aObj1;
            final EventDetails le2 = (EventDetails) aObj2;

            if (le1.getTimeStamp() < le2.getTimeStamp()) {
                return 1;
            }
            
            return -1;
        }
        };

    
    private class Processor
        implements Runnable
    {
        
        public void run() {
            while (true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    
                }

                synchronized (mLock) {
                    if (mPaused) {
                        continue;
                    }

                    boolean toHead = true; 
                    boolean needUpdate = false;
                    final Iterator it = mPendingEvents.iterator();
                    while (it.hasNext()) {
                        final EventDetails event = (EventDetails) it.next();
                        mAllEvents.add(event);
                        toHead = toHead && (event == mAllEvents.first());
                        needUpdate = needUpdate || matchFilter(event);
                    }
                    mPendingEvents.clear();

                    if (needUpdate) {
                        updateFilteredEvents(toHead);
                    }
                }
            }

        }
    }


    
    private static final String[] COL_NAMES = {
        ""Time"", ""Priority"", ""Trace"", ""Category"", ""NDC"", ""Message""};

    
    private static final EventDetails[] EMPTY_LIST =  new EventDetails[] {};

    
    private static final DateFormat DATE_FORMATTER =
        DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);

    
    private final Object mLock = new Object();
    
    private final SortedSet mAllEvents = new TreeSet(MY_COMP);
    
    private EventDetails[] mFilteredEvents = EMPTY_LIST;
    
    private final List mPendingEvents = new ArrayList();
    
    private boolean mPaused = false;

    
    private String mThreadFilter = """";
    
    private String mMessageFilter = """";
    
    private String mNDCFilter = """";
    
    private String mCategoryFilter = """";
    
    private Priority mPriorityFilter = Priority.DEBUG;


    
    MyTableModel() {
        final Thread t = new Thread(new Processor());
        t.setDaemon(true);
        t.start();
    }


    
    
    

    
    public int getRowCount() {
        synchronized (mLock) {
            return mFilteredEvents.length;
        }
    }

    
    public int getColumnCount() {
        
        return COL_NAMES.length;
    }

    
    public String getColumnName(int aCol) {
        
        return COL_NAMES[aCol];
    }

    
    public Class getColumnClass(int aCol) {
        
        return (aCol == 2) ? Boolean.class : Object.class;
    }

    
    public Object getValueAt(int aRow, int aCol) {
        synchronized (mLock) {
            final EventDetails event = mFilteredEvents[aRow];

            if (aCol == 0) {
                return DATE_FORMATTER.format(new Date(event.getTimeStamp()));
            } else if (aCol == 1) {
                return event.getPriority();
            } else if (aCol == 2) {
                return (event.getThrowableStrRep() == null)
                    ? Boolean.FALSE : Boolean.TRUE;
            } else if (aCol == 3) {
                return event.getCategoryName();
            } else if (aCol == 4) {
                return event.getNDC();
            }
            return event.getMessage();
        }
    }

    
    
    

    
    public void setPriorityFilter(Priority aPriority) {
        synchronized (mLock) {
            mPriorityFilter = aPriority;
            updateFilteredEvents(false);
        }
    }

    
    public void setThreadFilter(String aStr) {
        synchronized (mLock) {
            mThreadFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }

    
    public void setMessageFilter(String aStr) {
        synchronized (mLock) {
            mMessageFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }

    
    public void setNDCFilter(String aStr) {
        synchronized (mLock) {
            mNDCFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }

    
    public void setCategoryFilter(String aStr) {
        synchronized (mLock) {
            mCategoryFilter = aStr.trim();
            updateFilteredEvents(false);
        }
    }

    
    public void addEvent(EventDetails aEvent) {
        synchronized (mLock) {
            mPendingEvents.add(aEvent);
        }
    }

    
    public void clear() {
        synchronized (mLock) {
            mAllEvents.clear();
            mFilteredEvents = new EventDetails[0];
            mPendingEvents.clear();
            fireTableDataChanged();
        }
    }

    
    public void toggle() {
        synchronized (mLock) {
            mPaused = !mPaused;
        }
    }

    
    public boolean isPaused() {
        synchronized (mLock) {
            return mPaused;
        }
    }

    
    public EventDetails getEventDetails(int aRow) {
        synchronized (mLock) {
            return mFilteredEvents[aRow];
        }
    }

    
    
    

    
    private void updateFilteredEvents(boolean aInsertedToFront) {
        final long start = System.currentTimeMillis();
        final List filtered = new ArrayList();
        final int size = mAllEvents.size();
        final Iterator it = mAllEvents.iterator();

        while (it.hasNext()) {
            final EventDetails event = (EventDetails) it.next();
            if (matchFilter(event)) {
                filtered.add(event);
            }
        }

        final EventDetails lastFirst = (mFilteredEvents.length == 0)
            ? null
            : mFilteredEvents[0];
        mFilteredEvents = (EventDetails[]) filtered.toArray(EMPTY_LIST);

        if (aInsertedToFront && (lastFirst != null)) {
            final int index = filtered.indexOf(lastFirst);
            if (index < 1) {
                LOG.warn(""In strange state"");
                fireTableDataChanged();
            } else {
                fireTableRowsInserted(0, index - 1);
            }
        } else {
            fireTableDataChanged();
        }

        final long end = System.currentTimeMillis();
        LOG.debug(""Total time [ms]: "" + (end - start)
                  + "" in update, size: "" + size);
    }

    
    private boolean matchFilter(EventDetails aEvent) {
        if (aEvent.getPriority().isGreaterOrEqual(mPriorityFilter) &&
            (aEvent.getThreadName().indexOf(mThreadFilter) >= 0) &&
            (aEvent.getCategoryName().indexOf(mCategoryFilter) >= 0) &&
            ((mNDCFilter.length() == 0) ||
             ((aEvent.getNDC() != null) &&
              (aEvent.getNDC().indexOf(mNDCFilter) >= 0))))
        {
            final String rm = aEvent.getMessage();
            if (rm == null) {
                
                return (mMessageFilter.length() == 0);
            } else {
                return (rm.indexOf(mMessageFilter) >= 0);
            }
        }

        return false; 
    }
}
"
log4j,1.2,org.apache.log4j.jmx.LoggerDynamicMBean,14,2,0,9,63,27,1,8,7,0.752136752,530,0.777777778,2,0.47826087,0.184615385,2,4,36.21428571,2,1.0,4,"

package org.apache.log4j.jmx;

import org.apache.log4j.Appender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.helpers.OptionConverter;

import javax.management.Attribute;
import javax.management.AttributeNotFoundException;
import javax.management.InvalidAttributeValueException;
import javax.management.JMException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.MalformedObjectNameException;
import javax.management.Notification;
import javax.management.NotificationListener;
import javax.management.ObjectName;
import javax.management.ReflectionException;
import javax.management.RuntimeOperationsException;
import java.lang.reflect.Constructor;
import java.util.Enumeration;
import java.util.Vector;

public class LoggerDynamicMBean extends AbstractDynamicMBean
                                  implements NotificationListener {

  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[1];

  private Vector dAttributes = new Vector();
  private String dClassName = this.getClass().getName();

  private String dDescription =
     ""This MBean acts as a management facade for a org.apache.log4j.Logger instance."";

  
  private static Logger cat = Logger.getLogger(LoggerDynamicMBean.class);

  
  private Logger logger;

  public LoggerDynamicMBean(Logger logger) {
    this.logger = logger;
    buildDynamicMBeanInfo();
  }

  public
  void handleNotification(Notification notification, Object handback) {
    cat.debug(""Received notification: ""+notification.getType());
    registerAppenderMBean((Appender) notification.getUserData() );


  }

  private
  void buildDynamicMBeanInfo() {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
             ""HierarchyDynamicMBean(): Constructs a HierarchyDynamicMBean instance"",
	     constructors[0]);

    dAttributes.add(new MBeanAttributeInfo(""name"",
					   ""java.lang.String"",
					   ""The name of this Logger."",
					   true,
					   false,
					   false));

    dAttributes.add(new MBeanAttributeInfo(""priority"",
					   ""java.lang.String"",
					   ""The priority of this logger."",
					   true,
					   true,
					   false));





    MBeanParameterInfo[] params = new MBeanParameterInfo[2];
    params[0] = new MBeanParameterInfo(""class name"", ""java.lang.String"",
				       ""add an appender to this logger"");
    params[1] = new MBeanParameterInfo(""appender name"", ""java.lang.String"",
				       ""name of the appender"");

    dOperations[0] = new MBeanOperationInfo(""addAppender"",
					    ""addAppender(): add an appender"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
  }

  protected
  Logger getLogger() {
    return logger;
  }


  public
  MBeanInfo getMBeanInfo() {
    

    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[dAttributes.size()];
    dAttributes.toArray(attribs);

    MBeanInfo mb = new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
    
    return mb;
  }

  public
  Object invoke(String operationName, Object params[], String signature[])
    throws MBeanException,
    ReflectionException {

    if(operationName.equals(""addAppender"")) {
      addAppender((String) params[0], (String) params[1]);
      return ""Hello world."";
    }

    return null;
  }


  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                   MBeanException,
                                                   ReflectionException {

       
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }

    
    if (attributeName.equals(""name"")) {
      return logger.getName();
    }  else if(attributeName.equals(""priority"")) {
      Level l = logger.getLevel();
      if(l == null) {
	return null;
      } else {
	return l.toString();
      }
    } else if(attributeName.startsWith(""appender="")) {
      try {
	return new ObjectName(""log4j:""+attributeName );
      } catch(MalformedObjectNameException e) {
	    cat.error(""Could not create ObjectName"" + attributeName);
      } catch(RuntimeException e) {
	    cat.error(""Could not create ObjectName"" + attributeName);
      }
    }


    
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));

  }


  void addAppender(String appenderClass, String appenderName) {
    cat.debug(""addAppender called with ""+appenderClass+"", ""+appenderName);
    Appender appender = (Appender)
       OptionConverter.instantiateByClassName(appenderClass,
					      org.apache.log4j.Appender.class,
					      null);
    appender.setName(appenderName);
    logger.addAppender(appender);

    

  }


  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {

    
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
		  ""Cannot invoke a setter of "" + dClassName +
		  "" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();

    if (name == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""Attribute name cannot be null""),
		    ""Cannot invoke the setter of ""+dClassName+
		    "" with null attribute name"");
    }


    if(name.equals(""priority"")) {
      if (value instanceof String) {
	String s = (String) value;
	Level p = logger.getLevel();
	if(s.equalsIgnoreCase(""NULL"")) {
	  p = null;
	} else {
	  p = OptionConverter.toLevel(s, p);
	}
	logger.setLevel(p);
      }
    } else {
      throw(new AttributeNotFoundException(""Attribute "" + name +
					   "" not found in "" +
					   this.getClass().getName()));
    }
  }

  void appenderMBeanRegistration() {
    Enumeration enumeration = logger.getAllAppenders();
    while(enumeration.hasMoreElements()) {
      Appender appender = (Appender) enumeration.nextElement();
      registerAppenderMBean(appender);
    }
  }

  void registerAppenderMBean(Appender appender) {
    String name = getAppenderName(appender);
    cat.debug(""Adding AppenderMBean for appender named ""+name);
    ObjectName objectName = null;
    try {
      AppenderDynamicMBean appenderMBean = new AppenderDynamicMBean(appender);
      objectName = new ObjectName(""log4j"", ""appender"", name);
      if (!server.isRegistered(objectName)) {
        registerMBean(appenderMBean, objectName);
        dAttributes.add(new MBeanAttributeInfo(""appender="" + name, ""javax.management.ObjectName"",
                ""The "" + name + "" appender."", true, true, false));
      }

    } catch(JMException e) {
      cat.error(""Could not add appenderMBean for [""+name+""]."", e);
    } catch(java.beans.IntrospectionException e) {
      cat.error(""Could not add appenderMBean for [""+name+""]."", e);
    } catch(RuntimeException e) {
      cat.error(""Could not add appenderMBean for [""+name+""]."", e);
    }
  }

  public
  void postRegister(java.lang.Boolean registrationDone) {
    appenderMBeanRegistration();
  }
}
"
log4j,1.2,org.apache.log4j.spi.OptionHandler,1,1,0,8,1,0,8,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;



public interface OptionHandler {

  
  void activateOptions();

  
  

  
  
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerModel,16,2,0,17,49,106,13,5,14,0.8,426,1.0,0,0.673913043,0.285714286,0,0,25.4375,6,2.375,3,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.awt.AWTEventMulticaster;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Enumeration;

import javax.swing.SwingUtilities;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

import org.apache.log4j.lf5.LogRecord;





public class CategoryExplorerModel extends DefaultTreeModel {
  private static final long serialVersionUID = -3413887384316015901L;

  
  
  

  
  
  

  protected boolean _renderFatal = true;
  protected ActionListener _listener = null;
  protected ActionEvent _event = new ActionEvent(this,
      ActionEvent.ACTION_PERFORMED,
      ""Nodes Selection changed"");

  
  
  

  
  
  

  public CategoryExplorerModel(CategoryNode node) {
    super(node);
  }
  
  
  

  public void addLogRecord(LogRecord lr) {
    CategoryPath path = new CategoryPath(lr.getCategory());
    addCategory(path); 
    CategoryNode node = getCategoryNode(path);
    node.addRecord(); 
    if (_renderFatal && lr.isFatal()) {
      TreeNode[] nodes = getPathToRoot(node);
      int len = nodes.length;
      CategoryNode parent;

      
      
      for (int i = 1; i < len - 1; i++) {
        parent = (CategoryNode) nodes[i];
        parent.setHasFatalChildren(true);
        nodeChanged(parent);
      }
      node.setHasFatalRecords(true);
      nodeChanged(node);
    }
  }

  public CategoryNode getRootCategoryNode() {
    return (CategoryNode) getRoot();
  }

  public CategoryNode getCategoryNode(String category) {
    CategoryPath path = new CategoryPath(category);
    return (getCategoryNode(path));
  }

  
  public CategoryNode getCategoryNode(CategoryPath path) {
    CategoryNode root = (CategoryNode) getRoot();
    CategoryNode parent = root; 

    for (int i = 0; i < path.size(); i++) {
      CategoryElement element = path.categoryElementAt(i);

      
      Enumeration children = parent.children();

      boolean categoryAlreadyExists = false;
      while (children.hasMoreElements()) {
        CategoryNode node = (CategoryNode) children.nextElement();
        String title = node.getTitle().toLowerCase();

        String pathLC = element.getTitle().toLowerCase();
        if (title.equals(pathLC)) {
          categoryAlreadyExists = true;
          
          parent = node;
          break; 
        }
      }

      if (categoryAlreadyExists == false) {
        return null; 
      }
    }

    return (parent);
  }

  
  public boolean isCategoryPathActive(CategoryPath path) {
    CategoryNode root = (CategoryNode) getRoot();
    CategoryNode parent = root; 
    boolean active = false;

    for (int i = 0; i < path.size(); i++) {
      CategoryElement element = path.categoryElementAt(i);

      
      Enumeration children = parent.children();

      boolean categoryAlreadyExists = false;
      active = false;

      while (children.hasMoreElements()) {
        CategoryNode node = (CategoryNode) children.nextElement();
        String title = node.getTitle().toLowerCase();

        String pathLC = element.getTitle().toLowerCase();
        if (title.equals(pathLC)) {
          categoryAlreadyExists = true;
          
          parent = node;

          if (parent.isSelected()) {
            active = true;
          }

          break; 
        }
      }

      if (active == false || categoryAlreadyExists == false) {
        return false;
      }
    }

    return (active);
  }


  
  public CategoryNode addCategory(CategoryPath path) {
    CategoryNode root = (CategoryNode) getRoot();
    CategoryNode parent = root; 

    for (int i = 0; i < path.size(); i++) {
      CategoryElement element = path.categoryElementAt(i);

      
      Enumeration children = parent.children();

      boolean categoryAlreadyExists = false;
      while (children.hasMoreElements()) {
        CategoryNode node = (CategoryNode) children.nextElement();
        String title = node.getTitle().toLowerCase();

        String pathLC = element.getTitle().toLowerCase();
        if (title.equals(pathLC)) {
          categoryAlreadyExists = true;
          
          parent = node;
          break;
        }
      }

      if (categoryAlreadyExists == false) {
        
        CategoryNode newNode = new CategoryNode(element.getTitle());

        
        
        
        

        
        insertNodeInto(newNode, parent, parent.getChildCount());
        refresh(newNode);

        
        parent = newNode;

      }
    }

    return parent;
  }

  public void update(CategoryNode node, boolean selected) {
    if (node.isSelected() == selected) {
      return; 
    }
    
    if (selected) {
      setParentSelection(node, true);
    } else {
      setDescendantSelection(node, false);
    }
  }

  public void setDescendantSelection(CategoryNode node, boolean selected) {
    Enumeration descendants = node.depthFirstEnumeration();
    CategoryNode current;
    while (descendants.hasMoreElements()) {
      current = (CategoryNode) descendants.nextElement();
      
      if (current.isSelected() != selected) {
        current.setSelected(selected);
        nodeChanged(current);
      }
    }
    notifyActionListeners();
  }

  public void setParentSelection(CategoryNode node, boolean selected) {
    TreeNode[] nodes = getPathToRoot(node);
    int len = nodes.length;
    CategoryNode parent;

    
    
    for (int i = 1; i < len; i++) {
      parent = (CategoryNode) nodes[i];
      if (parent.isSelected() != selected) {
        parent.setSelected(selected);
        nodeChanged(parent);
      }
    }
    notifyActionListeners();
  }


  public synchronized void addActionListener(ActionListener l) {
    _listener = AWTEventMulticaster.add(_listener, l);
  }

  public synchronized void removeActionListener(ActionListener l) {
    _listener = AWTEventMulticaster.remove(_listener, l);
  }

  public void resetAllNodeCounts() {
    Enumeration nodes = getRootCategoryNode().depthFirstEnumeration();
    CategoryNode current;
    while (nodes.hasMoreElements()) {
      current = (CategoryNode) nodes.nextElement();
      current.resetNumberOfContainedRecords();
      nodeChanged(current);
    }
  }

  
  public TreePath getTreePathToRoot(CategoryNode node) {
    if (node == null) {
      return null;
    }
    return (new TreePath(getPathToRoot(node)));
  }

  
  
  
  protected void notifyActionListeners() {
    if (_listener != null) {
      _listener.actionPerformed(_event);
    }
  }

  
  protected void refresh(final CategoryNode node) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        nodeChanged(node); 
      }
    });
  }

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.spi.HierarchyEventListener,2,1,0,5,2,1,3,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;

import org.apache.log4j.Appender;
import org.apache.log4j.Category;


public interface HierarchyEventListener {

 
  
  


  public
  void addAppenderEvent(Category cat, Appender appender);

  public
  void removeAppenderEvent(Category cat, Appender appender);


}
"
log4j,1.2,org.apache.log4j.jdbc.JDBCAppender,21,2,0,6,45,150,0,6,17,0.78125,279,1.0,0,0.473684211,0.295238095,1,2,11.9047619,2,1.0952,4,"
package org.apache.log4j.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Iterator;

import org.apache.log4j.PatternLayout;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;



public class JDBCAppender extends org.apache.log4j.AppenderSkeleton
    implements org.apache.log4j.Appender {

  
  protected String databaseURL = ""jdbc:odbc:myDB"";

  
  protected String databaseUser = ""me"";

  
  protected String databasePassword = ""mypassword"";

  
  protected Connection connection = null;

  
  protected String sqlStatement = """";

  
  protected int bufferSize = 1;

  
  protected ArrayList buffer;

  
  protected ArrayList removes;
  
  private boolean locationInfo = false;

  public JDBCAppender() {
    super();
    buffer = new ArrayList(bufferSize);
    removes = new ArrayList(bufferSize);
  }

  
  public boolean getLocationInfo() {
    return locationInfo;
  }
  
  
  public void setLocationInfo(final boolean flag) {
    locationInfo = flag;
  }
  

  
  public void append(LoggingEvent event) {
    event.getNDC();
    event.getThreadName();
    
    event.getMDCCopy();
    if (locationInfo) {
      event.getLocationInformation();
    }
    event.getRenderedMessage();
    event.getThrowableStrRep();
    buffer.add(event);

    if (buffer.size() >= bufferSize)
      flushBuffer();
  }

  
  protected String getLogStatement(LoggingEvent event) {
    return getLayout().format(event);
  }

  
  protected void execute(String sql) throws SQLException {

    Connection con = null;
    Statement stmt = null;

    try {
        con = getConnection();

        stmt = con.createStatement();
        stmt.executeUpdate(sql);
    } finally {
        if(stmt != null) {
            stmt.close();
        }
        closeConnection(con);
    }

    
  }


  
  protected void closeConnection(Connection con) {
  }

  
  protected Connection getConnection() throws SQLException {
      if (!DriverManager.getDrivers().hasMoreElements())
	     setDriver(""sun.jdbc.odbc.JdbcOdbcDriver"");

      if (connection == null) {
        connection = DriverManager.getConnection(databaseURL, databaseUser,
					databasePassword);
      }

      return connection;
  }

  
  public void close()
  {
    flushBuffer();

    try {
      if (connection != null && !connection.isClosed())
          connection.close();
    } catch (SQLException e) {
        errorHandler.error(""Error closing connection"", e, ErrorCode.GENERIC_FAILURE);
    }
    this.closed = true;
  }

  
  public void flushBuffer() {
    
    removes.ensureCapacity(buffer.size());
    for (Iterator i = buffer.iterator(); i.hasNext();) {
      LoggingEvent logEvent = (LoggingEvent)i.next();
      try {
	    String sql = getLogStatement(logEvent);
	    execute(sql);
      }
      catch (SQLException e) {
	    errorHandler.error(""Failed to excute sql"", e,
			   ErrorCode.FLUSH_FAILURE);
      } finally {
        removes.add(logEvent);
      }
    }
    
    
    buffer.removeAll(removes);
    
    
    removes.clear();
  }


  
  public void finalize() {
    close();
  }


  
  public boolean requiresLayout() {
    return true;
  }


  
  public void setSql(String s) {
    sqlStatement = s;
    if (getLayout() == null) {
        this.setLayout(new PatternLayout(s));
    }
    else {
        ((PatternLayout)getLayout()).setConversionPattern(s);
    }
  }


  
  public String getSql() {
    return sqlStatement;
  }


  public void setUser(String user) {
    databaseUser = user;
  }


  public void setURL(String url) {
    databaseURL = url;
  }


  public void setPassword(String password) {
    databasePassword = password;
  }


  public void setBufferSize(int newBufferSize) {
    bufferSize = newBufferSize;
    buffer.ensureCapacity(bufferSize);
    removes.ensureCapacity(bufferSize);
  }


  public String getUser() {
    return databaseUser;
  }


  public String getURL() {
    return databaseURL;
  }


  public String getPassword() {
    return databasePassword;
  }


  public int getBufferSize() {
    return bufferSize;
  }


  
  public void setDriver(String driverClass) {
    try {
      Class.forName(driverClass);
    } catch (Exception e) {
      errorHandler.error(""Failed to load driver"", e,
			 ErrorCode.GENERIC_FAILURE);
    }
  }
}

"
log4j,1.2,org.apache.log4j.lf5.LogLevelFormatException,1,3,0,4,2,0,4,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,2,"
package org.apache.log4j.lf5;





public class LogLevelFormatException extends Exception {
  
  
  

  
  
  

  
  
  

  
  
  

  public LogLevelFormatException(String message) {
    super(message);
  }

  
  
  

  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.config.PropertySetterException,3,3,0,1,6,1,1,0,3,0.5,28,1.0,0,0.944444444,0.555555556,1,1,8.0,3,1.0,3,"

package org.apache.log4j.config;


public class PropertySetterException extends Exception {
  private static final long serialVersionUID = -1352613734254235861L;
  protected Throwable rootCause;
  
  public
  PropertySetterException(String msg) {
    super(msg);
  }
  
  public
  PropertySetterException(Throwable rootCause)
  {
    super();
    this.rootCause = rootCause;
  }
  
  
  public
  String getMessage() {
    String msg = super.getMessage();
    if (msg == null && rootCause != null) {
      msg = rootCause.getMessage();
    }
    return msg;
  }
}
"
log4j,1.2,org.apache.log4j.RollingFileAppender,12,3,1,12,36,0,2,10,10,0.454545455,291,1.0,0,0.785714286,0.260416667,1,6,23.08333333,5,1.25,4,"



package org.apache.log4j;

import java.io.IOException;
import java.io.Writer;
import java.io.File;
import java.io.InterruptedIOException;

import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.spi.LoggingEvent;


public class RollingFileAppender extends FileAppender {

  
  protected long maxFileSize = 10*1024*1024;

  
  protected int  maxBackupIndex  = 1;

  private long nextRollover = 0;

  
  public
  RollingFileAppender() {
    super();
  }

  
  public
  RollingFileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    super(layout, filename, append);
  }

  
  public
  RollingFileAppender(Layout layout, String filename) throws IOException {
    super(layout, filename);
  }

  
  public
  int getMaxBackupIndex() {
    return maxBackupIndex;
  }

 
  public
  long getMaximumFileSize() {
    return maxFileSize;
  }

  
  public 
  void rollOver() {
    File target;
    File file;

    if (qw != null) {
        long size = ((CountingQuietWriter) qw).getCount();
        LogLog.debug(""rolling over count="" + size);
        
        
        nextRollover = size + maxFileSize;
    }
    LogLog.debug(""maxBackupIndex=""+maxBackupIndex);

    boolean renameSucceeded = true;
    
    if(maxBackupIndex > 0) {
      
      file = new File(fileName + '.' + maxBackupIndex);
      if (file.exists())
       renameSucceeded = file.delete();

      
      for (int i = maxBackupIndex - 1; i >= 1 && renameSucceeded; i--) {
	file = new File(fileName + ""."" + i);
	if (file.exists()) {
	  target = new File(fileName + '.' + (i + 1));
	  LogLog.debug(""Renaming file "" + file + "" to "" + target);
	  renameSucceeded = file.renameTo(target);
	}
      }

    if(renameSucceeded) {
      
      target = new File(fileName + ""."" + 1);

      this.closeFile(); 

      file = new File(fileName);
      LogLog.debug(""Renaming file "" + file + "" to "" + target);
      renameSucceeded = file.renameTo(target);
      
      
      
      if (!renameSucceeded) {
          try {
            this.setFile(fileName, true, bufferedIO, bufferSize);
          }
          catch(IOException e) {
              if (e instanceof InterruptedIOException) {
                  Thread.currentThread().interrupt();
              }
              LogLog.error(""setFile(""+fileName+"", true) call failed."", e);
          }
      }
    }
    }

    
    
    
    if (renameSucceeded) {
    try {
      
      
      this.setFile(fileName, false, bufferedIO, bufferSize);
      nextRollover = 0;
    }
    catch(IOException e) {
        if (e instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
        LogLog.error(""setFile(""+fileName+"", false) call failed."", e);
    }
    }
  }

  public
  synchronized
  void setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize)
                                                                 throws IOException {
    super.setFile(fileName, append, this.bufferedIO, this.bufferSize);
    if(append) {
      File f = new File(fileName);
      ((CountingQuietWriter) qw).setCount(f.length());
    }
  }


  
  public
  void setMaxBackupIndex(int maxBackups) {
    this.maxBackupIndex = maxBackups;
  }

  
  public
  void setMaximumFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }


  
  public
  void setMaxFileSize(String value) {
    maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
  }

  protected
  void setQWForFiles(Writer writer) {
     this.qw = new CountingQuietWriter(writer, errorHandler);
  }

  
  protected
  void subAppend(LoggingEvent event) {
    super.subAppend(event);
    if(fileName != null && qw != null) {
        long size = ((CountingQuietWriter) qw).getCount();
        if (size >= maxFileSize && size >= nextRollover) {
            rollOver();
        }
    }
   }
}
"
log4j,1.2,org.apache.log4j.lf5.LogLevel,18,1,0,17,36,113,16,1,16,0.919504644,442,0.421052632,14,0.0,0.132352941,1,1,22.5,3,1.5,2,"
package org.apache.log4j.lf5;

import java.awt.Color;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;





public class LogLevel implements java.io.Serializable {
  
  
  

  
  public final static LogLevel FATAL = new LogLevel(""FATAL"", 0);
  public final static LogLevel ERROR = new LogLevel(""ERROR"", 1);
  public final static LogLevel WARN = new LogLevel(""WARN"", 2);
  public final static LogLevel INFO = new LogLevel(""INFO"", 3);
  public final static LogLevel DEBUG = new LogLevel(""DEBUG"", 4);

  
  public final static LogLevel SEVERE = new LogLevel(""SEVERE"", 1);
  public final static LogLevel WARNING = new LogLevel(""WARNING"", 2);
  public final static LogLevel CONFIG = new LogLevel(""CONFIG"", 4);
  public final static LogLevel FINE = new LogLevel(""FINE"", 5);
  public final static LogLevel FINER = new LogLevel(""FINER"", 6);
  public final static LogLevel FINEST = new LogLevel(""FINEST"", 7);

  
  
  
  protected String _label;
  protected int _precedence;
  
  
  
  private static LogLevel[] _log4JLevels;
  private static LogLevel[] _jdk14Levels;
  private static LogLevel[] _allDefaultLevels;
  private static Map _logLevelMap;
  private static Map _logLevelColorMap;
  private static Map _registeredLogLevelMap = new HashMap();

  
  
  
  static {
    _log4JLevels = new LogLevel[]{FATAL, ERROR, WARN, INFO, DEBUG};
    _jdk14Levels = new LogLevel[]{SEVERE, WARNING, INFO,
                                  CONFIG, FINE, FINER, FINEST};
    _allDefaultLevels = new LogLevel[]{FATAL, ERROR, WARN, INFO, DEBUG,
                                       SEVERE, WARNING, CONFIG, FINE, FINER, FINEST};

    _logLevelMap = new HashMap();
    for (int i = 0; i < _allDefaultLevels.length; i++) {
      _logLevelMap.put(_allDefaultLevels[i].getLabel(), _allDefaultLevels[i]);
    }

    
    _logLevelColorMap = new HashMap();
    for (int i = 0; i < _allDefaultLevels.length; i++) {
      _logLevelColorMap.put(_allDefaultLevels[i], Color.black);
    }
  }

  public LogLevel(String label, int precedence) {
    _label = label;
    _precedence = precedence;
  }

  
  
  

  
  public String getLabel() {
    return _label;
  }

  
  public boolean encompasses(LogLevel level) {
    if (level.getPrecedence() <= getPrecedence()) {
      return true;
    }

    return false;
  }

  
  public static LogLevel valueOf(String level)
      throws LogLevelFormatException {
    LogLevel logLevel = null;
    if (level != null) {
      level = level.trim().toUpperCase();
      logLevel = (LogLevel) _logLevelMap.get(level);
    }

    
    if (logLevel == null && _registeredLogLevelMap.size() > 0) {
      logLevel = (LogLevel) _registeredLogLevelMap.get(level);
    }

    if (logLevel == null) {
      StringBuffer buf = new StringBuffer();
      buf.append(""Error while trying to parse ("" + level + "") into"");
      buf.append("" a LogLevel."");
      throw new LogLevelFormatException(buf.toString());
    }
    return logLevel;
  }

  
  public static LogLevel register(LogLevel logLevel) {
    if (logLevel == null) return null;

    
    if (_logLevelMap.get(logLevel.getLabel()) == null) {
      return (LogLevel) _registeredLogLevelMap.put(logLevel.getLabel(), logLevel);
    }

    return null;
  }

  public static void register(LogLevel[] logLevels) {
    if (logLevels != null) {
      for (int i = 0; i < logLevels.length; i++) {
        register(logLevels[i]);
      }
    }
  }

  public static void register(List logLevels) {
    if (logLevels != null) {
      Iterator it = logLevels.iterator();
      while (it.hasNext()) {
        register((LogLevel) it.next());
      }
    }
  }

  public boolean equals(Object o) {
    boolean equals = false;

    if (o instanceof LogLevel) {
      if (this.getPrecedence() ==
          ((LogLevel) o).getPrecedence()) {
        equals = true;
      }

    }

    return equals;
  }

  public int hashCode() {
    return _label.hashCode();
  }

  public String toString() {
    return _label;
  }

  
  public void setLogLevelColorMap(LogLevel level, Color color) {
    
    _logLevelColorMap.remove(level);
    
    if (color == null) {
      color = Color.black;
    }
    _logLevelColorMap.put(level, color);
  }

  public static void resetLogLevelColorMap() {
    
    _logLevelColorMap.clear();

    
    for (int i = 0; i < _allDefaultLevels.length; i++) {
      _logLevelColorMap.put(_allDefaultLevels[i], Color.black);
    }
  }

  
  public static List getLog4JLevels() {
    return Arrays.asList(_log4JLevels);
  }

  public static List getJdk14Levels() {
    return Arrays.asList(_jdk14Levels);
  }

  public static List getAllDefaultLevels() {
    return Arrays.asList(_allDefaultLevels);
  }

  public static Map getLogLevelColorMap() {
    return _logLevelColorMap;
  }

  
  
  

  protected int getPrecedence() {
    return _precedence;
  }

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.lf5.viewer.LF5SwingUtils,8,1,0,3,20,28,1,2,4,2.0,89,0.0,0,0.0,0.203125,0,0,10.125,4,2.125,2,"
package org.apache.log4j.lf5.viewer;

import java.awt.Adjustable;

import javax.swing.JComponent;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.table.TableModel;





public class LF5SwingUtils {
  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  public static void selectRow(int row, JTable table, JScrollPane pane) {
    if (table == null || pane == null) {
      return;
    }
    if (contains(row, table.getModel()) == false) {
      return;
    }
    moveAdjustable(row * table.getRowHeight(), pane.getVerticalScrollBar());
    selectRow(row, table.getSelectionModel());
    
    
    
    repaintLater(table);
  }

  
  public static void makeScrollBarTrack(Adjustable scrollBar) {
    if (scrollBar == null) {
      return;
    }
    scrollBar.addAdjustmentListener(new TrackingAdjustmentListener());
  }

  
  public static void makeVerticalScrollBarTrack(JScrollPane pane) {
    if (pane == null) {
      return;
    }
    makeScrollBarTrack(pane.getVerticalScrollBar());
  }

  
  
  
  protected static boolean contains(int row, TableModel model) {
    if (model == null) {
      return false;
    }
    if (row < 0) {
      return false;
    }
    if (row >= model.getRowCount()) {
      return false;
    }
    return true;
  }

  protected static void selectRow(int row, ListSelectionModel model) {
    if (model == null) {
      return;
    }
    model.setSelectionInterval(row, row);
  }

  protected static void moveAdjustable(int location, Adjustable scrollBar) {
    if (scrollBar == null) {
      return;
    }
    scrollBar.setValue(location);
  }

  
  protected static void repaintLater(final JComponent component) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        component.repaint();
      }
    });
  }
  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.CategoryKey,4,1,0,1,11,2,1,0,2,0.777777778,61,0.0,0,0.0,0.5,1,1,13.5,6,2.0,3,"

package org.apache.log4j;


class CategoryKey {

  String   name;  
  int hashCache;

  CategoryKey(String name) {
    this.name = name;
    hashCache = name.hashCode();
  }

  final
  public  
  int hashCode() {
    return hashCache;
  }

  final
  public
  boolean equals(Object rArg) {
    if(this == rArg)
      return true;
    
    if(rArg != null && CategoryKey.class == rArg.getClass()) 
      return  name.equals(((CategoryKey)rArg ).name);
    else 
      return false;
  }
}
"
log4j,1.2,org.apache.log4j.helpers.FileWatchdog,5,2,2,5,17,0,4,1,2,0.607142857,120,0.285714286,0,0.938461538,0.466666667,1,1,21.6,3,1.4,3,"



package org.apache.log4j.helpers;

import java.io.File;


public abstract class FileWatchdog extends Thread {

  
  static final public long DEFAULT_DELAY = 60000; 
  
  protected String filename;
  
  
  protected long delay = DEFAULT_DELAY; 
  
  File file;
  long lastModif = 0; 
  boolean warnedAlready = false;
  boolean interrupted = false;

  protected
  FileWatchdog(String filename) {
    super(""FileWatchdog"");
    this.filename = filename;
    file = new File(filename);
    setDaemon(true);
    checkAndConfigure();
  }

  
  public
  void setDelay(long delay) {
    this.delay = delay;
  }

  abstract 
  protected 
  void doOnChange();

  protected
  void checkAndConfigure() {
    boolean fileExists;
    try {
      fileExists = file.exists();
    } catch(SecurityException  e) {
      LogLog.warn(""Was not allowed to read check file existance, file:[""+
		  filename+""]."");
      interrupted = true; 
      return;
    }

    if(fileExists) {
      long l = file.lastModified(); 
      if(l > lastModif) {           
	lastModif = l;              
	doOnChange();
	warnedAlready = false;
      }
    } else {
      if(!warnedAlready) {
	LogLog.debug(""[""+filename+""] does not exist."");
	warnedAlready = true;
      }
    }
  }

  public
  void run() {    
    while(!interrupted) {
      try {
	    Thread.sleep(delay);
      } catch(InterruptedException e) {
	
      }
      checkAndConfigure();
    }
  }
}
"
log4j,1.2,org.apache.log4j.jmx.HierarchyDynamicMBean,17,2,0,11,74,34,1,10,12,0.818181818,592,0.727272727,2,0.423076923,0.166666667,2,4,33.17647059,2,0.9412,5,"

package org.apache.log4j.jmx;


import org.apache.log4j.Appender;
import org.apache.log4j.Category;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.HierarchyEventListener;
import org.apache.log4j.spi.LoggerRepository;

import javax.management.Attribute;
import javax.management.AttributeNotFoundException;
import javax.management.InvalidAttributeValueException;
import javax.management.JMException;
import javax.management.ListenerNotFoundException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.Notification;
import javax.management.NotificationBroadcaster;
import javax.management.NotificationBroadcasterSupport;
import javax.management.NotificationFilter;
import javax.management.NotificationFilterSupport;
import javax.management.NotificationListener;
import javax.management.ObjectName;
import javax.management.ReflectionException;
import javax.management.RuntimeOperationsException;
import java.lang.reflect.Constructor;
import java.util.Vector;

public class HierarchyDynamicMBean extends AbstractDynamicMBean
                                   implements HierarchyEventListener,
                                              NotificationBroadcaster {

  static final String ADD_APPENDER = ""addAppender."";
  static final String THRESHOLD = ""threshold"";

  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[1];

  private Vector vAttributes = new Vector();
  private String dClassName = this.getClass().getName();
  private String dDescription =
     ""This MBean acts as a management facade for org.apache.log4j.Hierarchy."";

  private NotificationBroadcasterSupport nbs = new NotificationBroadcasterSupport();


  private LoggerRepository hierarchy;

  private static Logger log = Logger.getLogger(HierarchyDynamicMBean.class);

  public HierarchyDynamicMBean() {
    hierarchy = LogManager.getLoggerRepository();
    buildDynamicMBeanInfo();
  }

  private
  void buildDynamicMBeanInfo() {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
         ""HierarchyDynamicMBean(): Constructs a HierarchyDynamicMBean instance"",
	 constructors[0]);

    vAttributes.add(new MBeanAttributeInfo(THRESHOLD,
					   ""java.lang.String"",
					   ""The \""threshold\"" state of the hiearchy."",
					   true,
					   true,
					   false));

    MBeanParameterInfo[] params = new MBeanParameterInfo[1];
    params[0] = new MBeanParameterInfo(""name"", ""java.lang.String"",
				       ""Create a logger MBean"" );
    dOperations[0] = new MBeanOperationInfo(""addLoggerMBean"",
				    ""addLoggerMBean(): add a loggerMBean"",
				    params ,
				    ""javax.management.ObjectName"",
				    MBeanOperationInfo.ACTION);
  }


  public
  ObjectName addLoggerMBean(String name) {
    Logger cat = LogManager.exists(name);

    if(cat != null) {
      return addLoggerMBean(cat);
    } else {
      return null;
    }
  }

  ObjectName addLoggerMBean(Logger logger) {
    String name = logger.getName();
    ObjectName objectName = null;
    try {
      LoggerDynamicMBean loggerMBean = new LoggerDynamicMBean(logger);
      objectName = new ObjectName(""log4j"", ""logger"", name);
      
      if (!server.isRegistered(objectName)) {
        registerMBean(loggerMBean, objectName);
        NotificationFilterSupport nfs = new NotificationFilterSupport();
        nfs.enableType(ADD_APPENDER + logger.getName());
        log.debug(""---Adding logger ["" + name + ""] as listener."");
        nbs.addNotificationListener(loggerMBean, nfs, null);
        vAttributes.add(new MBeanAttributeInfo(""logger="" + name, ""javax.management.ObjectName"",
                ""The "" + name + "" logger."", true, true, 
                
                false));
        
      }

    } catch(JMException e) {
      log.error(""Could not add loggerMBean for [""+name+""]."", e);
    } catch(RuntimeException e) {
      log.error(""Could not add loggerMBean for [""+name+""]."", e);
    }
    return objectName;
  }

  public
  void addNotificationListener(NotificationListener listener,
			       NotificationFilter filter,
			       java.lang.Object handback) {
    nbs.addNotificationListener(listener, filter, handback);
  }

  protected
  Logger getLogger() {
    return log;
  }

  public
  MBeanInfo getMBeanInfo() {
    

    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[vAttributes.size()];
    vAttributes.toArray(attribs);

    return new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
  }

  public
  MBeanNotificationInfo[] getNotificationInfo(){
    return nbs.getNotificationInfo();
  }

  public
  Object invoke(String operationName,
		Object params[],
		String signature[]) throws MBeanException,
                                           ReflectionException {

    if (operationName == null) {
      throw new RuntimeOperationsException(
        new IllegalArgumentException(""Operation name cannot be null""),
	""Cannot invoke a null operation in "" + dClassName);
    }
    

    if(operationName.equals(""addLoggerMBean"")) {
      return addLoggerMBean((String)params[0]);
    } else {
      throw new ReflectionException(
	    new NoSuchMethodException(operationName),
	    ""Cannot find the operation "" + operationName + "" in "" + dClassName);
    }

  }


  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                    MBeanException,
                                                    ReflectionException {

    
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }

    log.debug(""Called getAttribute with [""+attributeName+""]."");

    
    if (attributeName.equals(THRESHOLD)) {
      return hierarchy.getThreshold();
    } else if(attributeName.startsWith(""logger"")) {
      int k = attributeName.indexOf(""%3D"");
      String val = attributeName;
      if(k > 0) {
	val = attributeName.substring(0, k)+'='+ attributeName.substring(k+3);
      }
      try {
	return new ObjectName(""log4j:""+val);
      } catch(JMException e) {
	    log.error(""Could not create ObjectName"" + val);
      } catch(RuntimeException e) {
	    log.error(""Could not create ObjectName"" + val);
      }
    }



    
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));

  }


  public
  void addAppenderEvent(Category logger, Appender appender) {
    log.debug(""addAppenderEvent called: logger=""+logger.getName()+
	      "", appender=""+appender.getName());
    Notification n = new Notification(ADD_APPENDER+logger.getName(), this, 0);
    n.setUserData(appender);
    log.debug(""sending notification."");
    nbs.sendNotification(n);
  }

 public
  void removeAppenderEvent(Category cat, Appender appender) {
    log.debug(""removeAppenderCalled: logger=""+cat.getName()+
	      "", appender=""+appender.getName());
  }

  public
  void postRegister(java.lang.Boolean registrationDone) {
    log.debug(""postRegister is called."");
    hierarchy.addHierarchyEventListener(this);
    Logger root = hierarchy.getRootLogger();
    addLoggerMBean(root);
  }

  public
  void removeNotificationListener(NotificationListener listener)
                                         throws ListenerNotFoundException {
    nbs.removeNotificationListener(listener);
  }

  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {

    
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
	  ""Cannot invoke a setter of ""+dClassName+"" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();

    if (name == null) {
      throw new RuntimeOperationsException(
               new IllegalArgumentException(""Attribute name cannot be null""),
	       ""Cannot invoke the setter of ""+dClassName+
	       "" with null attribute name"");
    }

    if(name.equals(THRESHOLD)) {
      Level l = OptionConverter.toLevel((String) value,
					   hierarchy.getThreshold());
      hierarchy.setThreshold(l);
    }


  }
}
"
log4j,1.2,org.apache.log4j.chainsaw.DetailPanel,6,5,0,5,46,11,1,4,1,0.88,251,0.8,2,0.993610224,0.3,0,0,40.0,8,2.5,2,"
package org.apache.log4j.chainsaw;

import java.awt.BorderLayout;
import java.text.MessageFormat;
import java.util.Date;
import javax.swing.BorderFactory;
import javax.swing.JEditorPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.apache.log4j.Logger;


class DetailPanel
    extends JPanel
    implements ListSelectionListener
{
    
    private static final Logger LOG =
        Logger.getLogger(DetailPanel.class);

    
    private static final MessageFormat FORMATTER = new MessageFormat(
        ""<b>Time:</b> <code>{0,time,medium}</code>"" +
        ""&nbsp;&nbsp;<b>Priority:</b> <code>{1}</code>"" +
        ""&nbsp;&nbsp;<b>Thread:</b> <code>{2}</code>"" +
        ""&nbsp;&nbsp;<b>NDC:</b> <code>{3}</code>"" +
        ""<br><b>Logger:</b> <code>{4}</code>"" +
        ""<br><b>Location:</b> <code>{5}</code>"" +
        ""<br><b>Message:</b>"" +
        ""<pre>{6}</pre>"" +
        ""<b>Throwable:</b>"" +
        ""<pre>{7}</pre>"");

    
    private final MyTableModel mModel;
    
    private final JEditorPane mDetails;

    
    DetailPanel(JTable aTable, final MyTableModel aModel) {
        mModel = aModel;
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder(""Details: ""));

        mDetails = new JEditorPane();
        mDetails.setEditable(false);
        mDetails.setContentType(""text/html"");
        add(new JScrollPane(mDetails), BorderLayout.CENTER);

        final ListSelectionModel rowSM = aTable.getSelectionModel();
        rowSM.addListSelectionListener(this);
    }

    
    public void valueChanged(ListSelectionEvent aEvent) {
        
        if (aEvent.getValueIsAdjusting()) {
            return;
        }

        final ListSelectionModel lsm = (ListSelectionModel) aEvent.getSource();
        if (lsm.isSelectionEmpty()) {
            mDetails.setText(""Nothing selected"");
        } else {
            final int selectedRow = lsm.getMinSelectionIndex();
            final EventDetails e = mModel.getEventDetails(selectedRow);
            final Object[] args =
            {
                new Date(e.getTimeStamp()),
                e.getPriority(),
                escape(e.getThreadName()),
                escape(e.getNDC()),
                escape(e.getCategoryName()),
                escape(e.getLocationDetails()),
                escape(e.getMessage()),
                escape(getThrowableStrRep(e))
            };
            mDetails.setText(FORMATTER.format(args));
            mDetails.setCaretPosition(0);
        }
    }

    
    
    

    
    private static String getThrowableStrRep(EventDetails aEvent) {
        final String[] strs = aEvent.getThrowableStrRep();
        if (strs == null) {
            return null;
        }

        final StringBuffer sb = new StringBuffer();
        for (int i = 0; i < strs.length; i++) {
            sb.append(strs[i]).append(""\n"");
        }

        return sb.toString();
    }

    
    private String escape(String aStr) {
        if (aStr == null) {
            return null;
        }

        final StringBuffer buf = new StringBuffer();
        for (int i = 0; i < aStr.length(); i++) {
            char c = aStr.charAt(i);
            switch (c) {
            case '<':
                buf.append(""&lt;"");
                break;
            case '>':
                buf.append(""&gt;"");
                break;
            case '\""':
                buf.append(""&quot;"");
                break;
            case '&':
                buf.append(""&amp;"");
                break;
            default:
                buf.append(c);
                break;
            }
        }
        return buf.toString();
    }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.TrackingAdjustmentListener,2,1,0,2,9,0,2,0,2,0.0,42,1.0,0,0.0,0.75,0,0,19.5,3,1.5,2,"
package org.apache.log4j.lf5.viewer;

import java.awt.Adjustable;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;





public class TrackingAdjustmentListener implements AdjustmentListener {
  
  
  

  
  
  

  protected int _lastMaximum = -1;

  
  
  

  
  
  

  
  
  

  public void adjustmentValueChanged(AdjustmentEvent e) {
    Adjustable bar = e.getAdjustable();
    int currentMaximum = bar.getMaximum();
    if (bar.getMaximum() == _lastMaximum) {
      return; 
    }
    int bottom = bar.getValue() + bar.getVisibleAmount();

    if (bottom + bar.getUnitIncrement() >= _lastMaximum) {
      bar.setValue(bar.getMaximum()); 
    }
    _lastMaximum = currentMaximum;
  }

  
  
  

  
  
  

  
  
  
}

"
log4j,1.2,org.apache.log4j.jmx.MethodUnion,1,1,0,2,2,0,2,0,0,2.0,12,0.0,0,0.0,1.0,0,0,9.0,0,0.0,2,"

package org.apache.log4j.jmx;

import java.lang.reflect.Method;

class MethodUnion {

  Method readMethod;
  Method writeMethod;

  MethodUnion( Method readMethod, Method writeMethod) {
    this.readMethod = readMethod;
    this.writeMethod = writeMethod;
  }

}
"
log4j,1.2,org.apache.log4j.spi.LoggerFactory,1,1,0,8,1,0,8,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,2,"

package org.apache.log4j.spi;

import org.apache.log4j.Logger;


public interface LoggerFactory {

  public
  Logger makeNewLoggerInstance(String name);

}
"
log4j,1.2,org.apache.log4j.config.PropertyGetter,6,1,0,3,25,11,1,2,3,0.68,154,0.6,0,0.0,0.44,0,0,23.83333333,8,2.3333,2,"

package org.apache.log4j.config;

import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.InterruptedIOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;



public class PropertyGetter {
  protected static final Object[] NULL_ARG = new Object[] {};
  protected Object obj;
  protected PropertyDescriptor[] props;

  public interface PropertyCallback {
    void foundProperty(Object obj, String prefix, String name, Object value);
  }

  
  public
  PropertyGetter(Object obj) throws IntrospectionException {
    BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
    props = bi.getPropertyDescriptors();
    this.obj = obj;
  }

  public
  static
  void getProperties(Object obj, PropertyCallback callback, String prefix) {
    try {
      new PropertyGetter(obj).getProperties(callback, prefix);
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect object "" + obj, ex);
    }
  }

  public
  void getProperties(PropertyCallback callback, String prefix) {
    for (int i = 0; i < props.length; i++) {
      Method getter = props[i].getReadMethod();
      if (getter == null) continue;
      if (!isHandledType(getter.getReturnType())) {
	
	continue;
      }
      String name = props[i].getName();
      try {
	Object result = getter.invoke(obj, NULL_ARG);
	
	if (result != null) {
	  callback.foundProperty(obj, prefix, name, result);
	}
      } catch (IllegalAccessException ex) {
	    LogLog.warn(""Failed to get value of property "" + name);
      } catch (InvocationTargetException ex) {
        if (ex.getTargetException() instanceof InterruptedException
                || ex.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
        LogLog.warn(""Failed to get value of property "" + name);
      } catch (RuntimeException ex) {
	    LogLog.warn(""Failed to get value of property "" + name);
      }
    }
  }

  protected
  boolean isHandledType(Class type) {
    return String.class.isAssignableFrom(type) ||
      Integer.TYPE.isAssignableFrom(type) ||
      Long.TYPE.isAssignableFrom(type)    ||
      Boolean.TYPE.isAssignableFrom(type) ||
      Priority.class.isAssignableFrom(type);
  }
}
"
log4j,1.2,org.apache.log4j.spi.LocationInfo,6,1,0,14,21,0,12,2,5,0.88,286,0.2,0,0.0,0.466666667,0,0,45.0,6,3.0,6,"



package org.apache.log4j.spi;

import org.apache.log4j.Layout;
import org.apache.log4j.helpers.LogLog;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.InterruptedIOException;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;


public class LocationInfo implements java.io.Serializable {

  
  transient String lineNumber;
  
  transient String fileName;
  
  transient String className;
  
  transient String methodName;
  
  public String fullInfo;

  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);

  private static Method getStackTraceMethod;
  private static Method getClassNameMethod;
  private static Method getMethodNameMethod;
  private static Method getFileNameMethod;
  private static Method getLineNumberMethod;


  
  public final static String NA = ""?"";

  static final long serialVersionUID = -1325822038990805636L;

    
    public static final LocationInfo NA_LOCATION_INFO =
            new LocationInfo(NA, NA, NA, NA);



  
  static boolean inVisualAge = false;
  static {
    try {
      inVisualAge = Class.forName(""com.ibm.uvm.tools.DebugSupport"") != null;
      LogLog.debug(""Detected IBM VisualAge environment."");
    } catch(Throwable e) {
      
    }
      try {
          Class[] noArgs = null;
          getStackTraceMethod = Throwable.class.getMethod(""getStackTrace"", noArgs);
          Class stackTraceElementClass = Class.forName(""java.lang.StackTraceElement"");
          getClassNameMethod = stackTraceElementClass.getMethod(""getClassName"", noArgs);
          getMethodNameMethod = stackTraceElementClass.getMethod(""getMethodName"", noArgs);
          getFileNameMethod = stackTraceElementClass.getMethod(""getFileName"", noArgs);
          getLineNumberMethod = stackTraceElementClass.getMethod(""getLineNumber"", noArgs);
      } catch(ClassNotFoundException ex) {
          LogLog.debug(""LocationInfo will use pre-JDK 1.4 methods to determine location."");
      } catch(NoSuchMethodException ex) {
          LogLog.debug(""LocationInfo will use pre-JDK 1.4 methods to determine location."");
      }
  }

  
    public LocationInfo(Throwable t, String fqnOfCallingClass) {
      if(t == null || fqnOfCallingClass == null)
	return;
      if (getLineNumberMethod != null) {
          try {
              Object[] noArgs = null;
              Object[] elements =  (Object[]) getStackTraceMethod.invoke(t, noArgs);
              String prevClass = NA;
              for(int i = elements.length - 1; i >= 0; i--) {
                  String thisClass = (String) getClassNameMethod.invoke(elements[i], noArgs);
                  if(fqnOfCallingClass.equals(thisClass)) {
                      int caller = i + 1;
                      if (caller < elements.length) {
                          className = prevClass;
                          methodName = (String) getMethodNameMethod.invoke(elements[caller], noArgs);
                          fileName = (String) getFileNameMethod.invoke(elements[caller], noArgs);
                          if (fileName == null) {
                              fileName = NA;
                          }
                          int line = ((Integer) getLineNumberMethod.invoke(elements[caller], noArgs)).intValue();
                          if (line < 0) {
                              lineNumber = NA;
                          } else {
                              lineNumber = String.valueOf(line);
                          }
                          StringBuffer buf = new StringBuffer();
                          buf.append(className);
                          buf.append(""."");
                          buf.append(methodName);
                          buf.append(""("");
                          buf.append(fileName);
                          buf.append("":"");
                          buf.append(lineNumber);
                          buf.append("")"");
                          this.fullInfo = buf.toString();
                      }
                      return;
                  }
                  prevClass = thisClass;
              }
              return;
          } catch(IllegalAccessException ex) {
              LogLog.debug(""LocationInfo failed using JDK 1.4 methods"", ex);
          } catch(InvocationTargetException ex) {
              if (ex.getTargetException() instanceof InterruptedException
                      || ex.getTargetException() instanceof InterruptedIOException) {
                  Thread.currentThread().interrupt();
              }
              LogLog.debug(""LocationInfo failed using JDK 1.4 methods"", ex);
          } catch(RuntimeException ex) {
              LogLog.debug(""LocationInfo failed using JDK 1.4 methods"", ex);
          }
      }

      String s;
      
      synchronized(sw) {
	t.printStackTrace(pw);
	s = sw.toString();
	sw.getBuffer().setLength(0);
      }
      
      int ibegin, iend;

      
      
      

      
      
      
      ibegin = s.lastIndexOf(fqnOfCallingClass);
      if(ibegin == -1)
	return;

      
      
      
      
      
      
      
      if (ibegin + fqnOfCallingClass.length() < s.length() &&
              s.charAt(ibegin + fqnOfCallingClass.length()) != '.') {
          int i = s.lastIndexOf(fqnOfCallingClass + ""."");
          if (i != -1) {
              ibegin = i;
          }
      }


      ibegin = s.indexOf(Layout.LINE_SEP, ibegin);
      if(ibegin == -1)
	return;
      ibegin+= Layout.LINE_SEP_LEN;

      
      iend = s.indexOf(Layout.LINE_SEP, ibegin);
      if(iend == -1)
	return;

      
      
      if(!inVisualAge) {
	
	ibegin = s.lastIndexOf(""at "", iend);
	if(ibegin == -1)
	  return;
	
	ibegin += 3;
      }
      
      this.fullInfo = s.substring(ibegin, iend);
    }

    
    private static final void appendFragment(final StringBuffer buf,
                                             final String fragment) {
          if (fragment == null) {
             buf.append(NA);
          } else {
             buf.append(fragment);
          }
    }

    
    public LocationInfo(
      final String file,
      final String classname,
      final String method,
      final String line) {
      this.fileName = file;
      this.className = classname;
      this.methodName = method;
      this.lineNumber = line;
      StringBuffer buf = new StringBuffer();
	  appendFragment(buf, classname);
	  buf.append(""."");
	  appendFragment(buf, method);
	  buf.append(""("");
	  appendFragment(buf, file);
	  buf.append("":"");
	  appendFragment(buf, line);
	  buf.append("")"");
	  this.fullInfo = buf.toString();
    }

    
    public
    String getClassName() {
      if(fullInfo == null) return NA;
      if(className == null) {
	
	
	int iend = fullInfo.lastIndexOf('(');
	if(iend == -1)
	  className = NA;
	else {
	  iend =fullInfo.lastIndexOf('.', iend);

	  

          
	  
	  
	  
	  
	  
	  
          int ibegin = 0;
	  if (inVisualAge) {
	    ibegin = fullInfo.lastIndexOf(' ', iend)+1;
          }

	  if(iend == -1)
	    className = NA;
	  else
	    className = this.fullInfo.substring(ibegin, iend);
	}
      }
      return className;
    }

    
    public
    String getFileName() {
      if(fullInfo == null) return NA;

      if(fileName == null) {
	int iend = fullInfo.lastIndexOf(':');
	if(iend == -1)
	  fileName = NA;
	else {
	  int ibegin = fullInfo.lastIndexOf('(', iend - 1);
	  fileName = this.fullInfo.substring(ibegin + 1, iend);
	}
      }
      return fileName;
    }

    
    public
    String getLineNumber() {
      if(fullInfo == null) return NA;

      if(lineNumber == null) {
	int iend = fullInfo.lastIndexOf(')');
	int ibegin = fullInfo.lastIndexOf(':', iend -1);
	if(ibegin == -1)
	  lineNumber = NA;
	else
	  lineNumber = this.fullInfo.substring(ibegin + 1, iend);
      }
      return lineNumber;
    }

    
    public
    String getMethodName() {
      if(fullInfo == null) return NA;
      if(methodName == null) {
	int iend = fullInfo.lastIndexOf('(');
	int ibegin = fullInfo.lastIndexOf('.', iend);
	if(ibegin == -1)
	  methodName = NA;
	else
	  methodName = this.fullInfo.substring(ibegin + 1, iend);
      }
      return methodName;
    }
}
"
log4j,1.2,org.apache.log4j.helpers.LogLog,10,1,0,43,19,0,43,1,9,0.920634921,146,0.714285714,0,0.0,0.333333333,0,0,12.9,4,1.9,2,"

package org.apache.log4j.helpers;


public class LogLog {

  
  public static final String DEBUG_KEY=""log4j.debug"";

 
  
  public static final String CONFIG_DEBUG_KEY=""log4j.configDebug"";

  protected static boolean debugEnabled = false;  

  
  private static boolean quietMode = false;

  private static final String PREFIX = ""log4j: "";
  private static final String ERR_PREFIX = ""log4j:ERROR "";
  private static final String WARN_PREFIX = ""log4j:WARN "";

  static {
    String key = OptionConverter.getSystemProperty(DEBUG_KEY, null);

    if(key == null) {
      key = OptionConverter.getSystemProperty(CONFIG_DEBUG_KEY, null);
    }

    if(key != null) { 
      debugEnabled = OptionConverter.toBoolean(key, true);
    }
  }

  
  static
  public
  void setInternalDebugging(boolean enabled) {
    debugEnabled = enabled;
  }

  
  public
  static
  void debug(String msg) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
    }
  }

  
  public
  static
  void debug(String msg, Throwable t) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
      if(t != null)
	t.printStackTrace(System.out);
    }
  }
  

  
  public
  static
  void error(String msg) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
  }  

  
  public
  static
  void error(String msg, Throwable t) {
    if(quietMode)
      return;

    System.err.println(ERR_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  

  
  public
  static
  void setQuietMode(boolean quietMode) {
    LogLog.quietMode = quietMode;
  }

  
  public
  static
  void warn(String msg) {
    if(quietMode)
      return;

    System.err.println(WARN_PREFIX+msg);
  }  

  
  public
  static
  void warn(String msg, Throwable t) {
    if(quietMode)
      return;

    System.err.println(WARN_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree,7,5,0,12,28,0,7,6,4,0.416666667,120,1.0,1,0.993506494,0.428571429,1,1,15.85714286,2,0.8571,3,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.awt.event.MouseEvent;

import javax.swing.JTree;
import javax.swing.event.TreeModelEvent;
import javax.swing.tree.TreePath;





public class CategoryExplorerTree extends JTree {
  private static final long serialVersionUID = 8066257446951323576L;
  
  
  

  
  
  
  protected CategoryExplorerModel _model;
  protected boolean _rootAlreadyExpanded = false;

  
  
  

  
  
  

  
  public CategoryExplorerTree(CategoryExplorerModel model) {
    super(model);

    _model = model;
    init();
  }

  
  public CategoryExplorerTree() {
    super();

    CategoryNode rootNode = new CategoryNode(""Categories"");

    _model = new CategoryExplorerModel(rootNode);

    setModel(_model);

    init();
  }

  
  
  

  public CategoryExplorerModel getExplorerModel() {
    return (_model);
  }

  public String getToolTipText(MouseEvent e) {

    try {
      return super.getToolTipText(e);
    } catch (Exception ex) {
      return """";
    }

  }

  
  
  

  protected void init() {
    
    putClientProperty(""JTree.lineStyle"", ""Angled"");

    

    CategoryNodeRenderer renderer = new CategoryNodeRenderer();
    setEditable(true);
    setCellRenderer(renderer);

    CategoryNodeEditor editor = new CategoryNodeEditor(_model);

    setCellEditor(new CategoryImmediateEditor(this,
        new CategoryNodeRenderer(),
        editor));
    setShowsRootHandles(true);

    setToolTipText("""");

    ensureRootExpansion();

  }

  protected void expandRootNode() {
    if (_rootAlreadyExpanded) {
      return;
    }
    _rootAlreadyExpanded = true;
    TreePath path = new TreePath(_model.getRootCategoryNode().getPath());
    expandPath(path);
  }

  protected void ensureRootExpansion() {
    _model.addTreeModelListener(new TreeModelAdapter() {
      public void treeNodesInserted(TreeModelEvent e) {
        expandRootNode();
      }
    });
  }

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.helpers.Loader,6,1,0,4,25,9,2,2,4,0.933333333,142,0.333333333,0,0.0,0.266666667,0,0,22.16666667,6,1.5,3,"

package org.apache.log4j.helpers;

import java.net.URL;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.io.InterruptedIOException;




public class Loader  { 

  static final String TSTR = ""Caught Exception while in Loader.getResource. This may be innocuous."";

  
  static private boolean java1 = true;
  
  static private boolean ignoreTCL = false;
  
  static {
    String prop = OptionConverter.getSystemProperty(""java.version"", null);
    
    if(prop != null) {
      int i = prop.indexOf('.');
      if(i != -1) {	
	if(prop.charAt(i+1) != '1')
	  java1 = false;
      } 
    }
    String ignoreTCLProp = OptionConverter.getSystemProperty(""log4j.ignoreTCL"", null);
    if(ignoreTCLProp != null) {
      ignoreTCL = OptionConverter.toBoolean(ignoreTCLProp, true);      
    }   
  }
  
  
  public static URL getResource(String resource, Class clazz) {
      return getResource(resource);
  }

  
  static public URL getResource(String resource) {
    ClassLoader classLoader = null;
    URL url = null;
    
    try {
  	if(!java1 && !ignoreTCL) {
  	  classLoader = getTCL();
  	  if(classLoader != null) {
  	    LogLog.debug(""Trying to find [""+resource+""] using context classloader ""
  			 +classLoader+""."");
  	    url = classLoader.getResource(resource);      
  	    if(url != null) {
  	      return url;
  	    }
  	  }
  	}
  	
  	
  	
  	classLoader = Loader.class.getClassLoader(); 
  	if(classLoader != null) {
  	  LogLog.debug(""Trying to find [""+resource+""] using ""+classLoader
  		       +"" class loader."");
  	  url = classLoader.getResource(resource);
  	  if(url != null) {
  	    return url;
  	  }
  	}
    } catch(IllegalAccessException t) {
        LogLog.warn(TSTR, t);
    } catch(InvocationTargetException t) {
        if (t.getTargetException() instanceof InterruptedException
                || t.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
        LogLog.warn(TSTR, t);
    } catch(Throwable t) {
      
      
      
      LogLog.warn(TSTR, t);
    }
    
    
    
    
    
    LogLog.debug(""Trying to find [""+resource+
  		   ""] using ClassLoader.getSystemResource()."");
    return ClassLoader.getSystemResource(resource);
  } 
  
  
  public
  static
  boolean isJava1() {
    return java1;
  }
  
  
  private static ClassLoader getTCL() throws IllegalAccessException, 
    InvocationTargetException {

    
    Method method = null;
    try {
      method = Thread.class.getMethod(""getContextClassLoader"", null);
    } catch (NoSuchMethodException e) {
      
      return null;
    }
    
    return (ClassLoader) method.invoke(Thread.currentThread(), null);
  }


  
  
  static public Class loadClass (String clazz) throws ClassNotFoundException {
    
    
    if(java1 || ignoreTCL) {
      return Class.forName(clazz);
    } else {
      try {
	    return getTCL().loadClass(clazz);
      }
      
      
      
      catch(InvocationTargetException e) {
          if (e.getTargetException() instanceof InterruptedException
                  || e.getTargetException() instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
      } catch(Throwable t) {
      }
    }
    return Class.forName(clazz);
  }
}
"
log4j,1.2,org.apache.log4j.config.PropertyPrinter,10,1,0,8,42,39,1,7,6,0.644444444,328,1.0,0,0.0,0.314285714,0,0,31.3,9,2.8,4,"

package org.apache.log4j.config;

import org.apache.log4j.Appender;
import org.apache.log4j.Category;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Hashtable;


public class PropertyPrinter implements PropertyGetter.PropertyCallback {
  protected int numAppenders = 0;
  protected Hashtable appenderNames = new Hashtable();
  protected Hashtable layoutNames   = new Hashtable();
  protected PrintWriter out;
  protected boolean doCapitalize;
  
  public
  PropertyPrinter(PrintWriter out) {
    this(out, false);
  }
  
  public
  PropertyPrinter(PrintWriter out, boolean doCapitalize) {
    this.out = out;
    this.doCapitalize = doCapitalize;
    
    print(out);
    out.flush();
  }
  
  protected
  String genAppName() {
    return ""A"" + numAppenders++;
  }
  
  
  protected
  boolean isGenAppName(String name) {
    if (name.length() < 2 || name.charAt(0) != 'A') return false;
    
    for (int i = 0; i < name.length(); i++) {
      if (name.charAt(i) < '0' || name.charAt(i) > '9') return false;
    }
    return true;
  }
  
  
  public
  void print(PrintWriter out) {
    printOptions(out, Logger.getRootLogger());
    
    Enumeration cats = LogManager.getCurrentLoggers();
    while (cats.hasMoreElements()) {
      printOptions(out, (Logger) cats.nextElement());
    }
  }
  
  
  protected
  void printOptions(PrintWriter out, Category cat) {
    Enumeration appenders = cat.getAllAppenders();
    Level prio = cat.getLevel();
    String appenderString = (prio == null ? """" : prio.toString());
    
    while (appenders.hasMoreElements()) {
      Appender app = (Appender) appenders.nextElement();
      String name;
      
      if ((name = (String) appenderNames.get(app)) == null) {
      
        
        if ((name = app.getName()) == null || isGenAppName(name)) {
            name = genAppName();
        }
        appenderNames.put(app, name);
        
        printOptions(out, app, ""log4j.appender.""+name);
        if (app.getLayout() != null) {
          printOptions(out, app.getLayout(), ""log4j.appender.""+name+"".layout"");
        }
      }
      appenderString += "", "" + name;
    }
    String catKey = (cat == Logger.getRootLogger())
        ? ""log4j.rootLogger""
        : ""log4j.logger."" + cat.getName();
    if (appenderString != """") {
      out.println(catKey + ""="" + appenderString);
    }
    if (!cat.getAdditivity() && cat != Logger.getRootLogger()) {
    	out.println(""log4j.additivity."" + cat.getName() + ""=false"");    
    }
  }

  protected void printOptions(PrintWriter out, Logger cat) {
      printOptions(out, (Category) cat);
  }
  
  protected
  void printOptions(PrintWriter out, Object obj, String fullname) {
    out.println(fullname + ""="" + obj.getClass().getName());
    PropertyGetter.getProperties(obj, this, fullname + ""."");
  }
  
  public void foundProperty(Object obj, String prefix, String name, Object value) {
    
    if (obj instanceof Appender && ""name"".equals(name)) {
      return;
    }
    if (doCapitalize) {
      name = capitalize(name);
    }
    out.println(prefix + name + ""="" + value.toString());
  }
  
  public static String capitalize(String name) {
    if (Character.isLowerCase(name.charAt(0))) {
      if (name.length() == 1 || Character.isLowerCase(name.charAt(1))) {
        StringBuffer newname = new StringBuffer(name);
        newname.setCharAt(0, Character.toUpperCase(name.charAt(0)));
        return newname.toString();
      }
    }
    return name;
  }
  
  
  public static void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out));
  }
}
"
log4j,1.2,org.apache.log4j.jmx.LayoutDynamicMBean,10,2,0,9,54,1,1,8,5,0.777777778,470,0.666666667,2,0.578947368,0.253968254,2,2,44.8,6,1.3,2,"

package org.apache.log4j.jmx;

import java.lang.reflect.Constructor;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;

import java.util.Vector;
import java.util.Hashtable;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanInfo;
import javax.management.Attribute;

import javax.management.MBeanException;
import javax.management.AttributeNotFoundException;
import javax.management.RuntimeOperationsException;
import javax.management.ReflectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;

import java.beans.Introspector;
import java.beans.BeanInfo;
import java.beans.PropertyDescriptor;
import java.beans.IntrospectionException;
import java.io.InterruptedIOException;

public class LayoutDynamicMBean extends AbstractDynamicMBean {

  private MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[1];
  private Vector dAttributes = new Vector();
  private String dClassName = this.getClass().getName();

  private Hashtable dynamicProps = new Hashtable(5);
  private MBeanOperationInfo[] dOperations = new MBeanOperationInfo[1];
  private String dDescription =
     ""This MBean acts as a management facade for log4j layouts."";

  
  private static Logger cat = Logger.getLogger(LayoutDynamicMBean.class);

  
  private Layout layout;

  public  LayoutDynamicMBean(Layout layout) throws IntrospectionException {
    this.layout = layout;
    buildDynamicMBeanInfo();
  }

  private
  void buildDynamicMBeanInfo() throws IntrospectionException {
    Constructor[] constructors = this.getClass().getConstructors();
    dConstructors[0] = new MBeanConstructorInfo(
             ""LayoutDynamicMBean(): Constructs a LayoutDynamicMBean instance"",
	     constructors[0]);


    BeanInfo bi = Introspector.getBeanInfo(layout.getClass());
    PropertyDescriptor[] pd = bi.getPropertyDescriptors();

    int size = pd.length;

    for(int i = 0; i < size; i++) {
      String name = pd[i].getName();
      Method readMethod =  pd[i].getReadMethod();
      Method writeMethod =  pd[i].getWriteMethod();
      if(readMethod != null) {
	Class returnClass = readMethod.getReturnType();
	if(isSupportedType(returnClass)) {
	  String returnClassName;
	  if(returnClass.isAssignableFrom(Level.class)) {
	    returnClassName = ""java.lang.String"";
	  } else {
	    returnClassName = returnClass.getName();
	  }

	  dAttributes.add(new MBeanAttributeInfo(name,
						 returnClassName,
						 ""Dynamic"",
						 true,
						 writeMethod != null,
						 false));
	  dynamicProps.put(name, new MethodUnion(readMethod, writeMethod));
	}
      }
    }

    MBeanParameterInfo[] params = new MBeanParameterInfo[0];

    dOperations[0] = new MBeanOperationInfo(""activateOptions"",
					    ""activateOptions(): add an layout"",
					    params,
					    ""void"",
					    MBeanOperationInfo.ACTION);
  }

  private
  boolean isSupportedType(Class clazz) {
    if(clazz.isPrimitive()) {
      return true;
    }

    if(clazz == String.class) {
      return true;
    }
    if(clazz.isAssignableFrom(Level.class)) {
      return true;
    }

    return false;
  }



  public
  MBeanInfo getMBeanInfo() {
    cat.debug(""getMBeanInfo called."");

    MBeanAttributeInfo[] attribs = new MBeanAttributeInfo[dAttributes.size()];
    dAttributes.toArray(attribs);

    return new MBeanInfo(dClassName,
			 dDescription,
			 attribs,
			 dConstructors,
			 dOperations,
			 new MBeanNotificationInfo[0]);
  }

  public
  Object invoke(String operationName, Object params[], String signature[])
    throws MBeanException,
    ReflectionException {

    if(operationName.equals(""activateOptions"") &&
                     layout instanceof OptionHandler) {
      OptionHandler oh = (OptionHandler) layout;
      oh.activateOptions();
      return ""Options activated."";
    }
    return null;
  }

  protected
  Logger  getLogger() {
    return cat;
  }


  public
  Object getAttribute(String attributeName) throws AttributeNotFoundException,
                                                   MBeanException,
                                                   ReflectionException {

       
    if (attributeName == null) {
      throw new RuntimeOperationsException(new IllegalArgumentException(
			""Attribute name cannot be null""),
       ""Cannot invoke a getter of "" + dClassName + "" with null attribute name"");
    }


    MethodUnion mu = (MethodUnion) dynamicProps.get(attributeName);

    cat.debug(""----name=""+attributeName+"", mu=""+mu);

    if(mu != null && mu.readMethod != null) {
      try {
	return mu.readMethod.invoke(layout, null);
      } catch(InvocationTargetException e) {
          if (e.getTargetException() instanceof InterruptedException
                  || e.getTargetException() instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	    return null;
      } catch(IllegalAccessException e) {
	    return null;
      } catch(RuntimeException e) {
	    return null;
      }
    }



    
    throw(new AttributeNotFoundException(""Cannot find "" + attributeName +
					 "" attribute in "" + dClassName));

  }


  public
  void setAttribute(Attribute attribute) throws AttributeNotFoundException,
                                                InvalidAttributeValueException,
                                                MBeanException,
                                                ReflectionException {

    
    if (attribute == null) {
      throw new RuntimeOperationsException(
                  new IllegalArgumentException(""Attribute cannot be null""),
		  ""Cannot invoke a setter of "" + dClassName +
		  "" with null attribute"");
    }
    String name = attribute.getName();
    Object value = attribute.getValue();

    if (name == null) {
      throw new RuntimeOperationsException(
                    new IllegalArgumentException(""Attribute name cannot be null""),
		    ""Cannot invoke the setter of ""+dClassName+
		    "" with null attribute name"");
    }



    MethodUnion mu = (MethodUnion) dynamicProps.get(name);

    if(mu != null && mu.writeMethod != null) {
      Object[] o = new Object[1];

      Class[] params = mu.writeMethod.getParameterTypes();
      if(params[0] == org.apache.log4j.Priority.class) {
	value = OptionConverter.toLevel((String) value,
					(Level) getAttribute(name));
      }
      o[0] = value;

      try {
	mu.writeMethod.invoke(layout,  o);

      } catch(InvocationTargetException e) {
          if (e.getTargetException() instanceof InterruptedException
                  || e.getTargetException() instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	    cat.error(""FIXME"", e);
      } catch(IllegalAccessException e) {
	    cat.error(""FIXME"", e);
      } catch(RuntimeException e) {
	    cat.error(""FIXME"", e);
      }
    } else {
      throw(new AttributeNotFoundException(""Attribute "" + name +
					   "" not found in "" +
					   this.getClass().getName()));
    }
  }
}


"
log4j,1.2,org.apache.log4j.net.TelnetAppender,7,2,0,4,16,3,1,4,6,0.583333333,81,1.0,1,0.75,0.428571429,1,1,10.28571429,4,1.2857,2,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.InterruptedIOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;



public class TelnetAppender extends AppenderSkeleton {

  private SocketHandler sh;
  private int port = 23;

  
  public boolean requiresLayout() {
    return true;
  }

  
  public void activateOptions() {
    try {
      sh = new SocketHandler(port);
      sh.start();
    }
    catch(InterruptedIOException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } catch(IOException e) {
      e.printStackTrace();
    } catch(RuntimeException e) {
      e.printStackTrace();
    }
    super.activateOptions();
  }

  public
  int getPort() {
    return port;
  }

  public
  void setPort(int port) {
    this.port = port;
  }


  
  public void close() {
    if (sh != null) {
        sh.close();
        try {
            sh.join();
        } catch(InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }
  }

  
  protected void append(LoggingEvent event) {
      if(sh != null) {
        sh.send(layout.format(event));
        if(layout.ignoresThrowable()) {
            String[] s = event.getThrowableStrRep();
            if (s != null) {
                StringBuffer buf = new StringBuffer();
                for(int i = 0; i < s.length; i++) {
                    buf.append(s[i]);
                    buf.append(""\r\n"");
                }
                sh.send(buf.toString());
            }
        }
      }
  }

  

  
  protected class SocketHandler extends Thread {

    private Vector writers = new Vector();
    private Vector connections = new Vector();
    private ServerSocket serverSocket;
    private int MAX_CONNECTIONS = 20;

    public void finalize() {
        close();
    }
      
    
    public void close() {
      synchronized(this) {
        for(Enumeration e = connections.elements();e.hasMoreElements();) {
            try {
                ((Socket)e.nextElement()).close();
            } catch(InterruptedIOException ex) {
                Thread.currentThread().interrupt();
            } catch(IOException ex) {
            } catch(RuntimeException ex) {
            }
        }
      }

      try {
        serverSocket.close();
      } catch(InterruptedIOException ex) {
          Thread.currentThread().interrupt();
      } catch(IOException ex) {
      } catch(RuntimeException ex) {
      }
    }

    
    public synchronized void send(final String message) {
      Iterator ce = connections.iterator();
      for(Iterator e = writers.iterator();e.hasNext();) {
        ce.next();
        PrintWriter writer = (PrintWriter)e.next();
        writer.print(message);
        if(writer.checkError()) {
          ce.remove();
          e.remove();
        }
      }
    }

    
    public void run() {
      while(!serverSocket.isClosed()) {
        try {
          Socket newClient = serverSocket.accept();
          PrintWriter pw = new PrintWriter(newClient.getOutputStream());
          if(connections.size() < MAX_CONNECTIONS) {
            synchronized(this) {
                connections.addElement(newClient);
                writers.addElement(pw);
                pw.print(""TelnetAppender v1.0 ("" + connections.size()
		            + "" active connections)\r\n\r\n"");
                pw.flush();
            }
          } else {
            pw.print(""Too many connections.\r\n"");
            pw.flush();
            newClient.close();
          }
        } catch(Exception e) {
          if (e instanceof InterruptedIOException || e instanceof InterruptedException) {
              Thread.currentThread().interrupt();
          }
          if (!serverSocket.isClosed()) {
            LogLog.error(""Encountered error while in SocketHandler loop."", e);
          }
          break;
        }
      }

      try {
          serverSocket.close();
      } catch(InterruptedIOException ex) {
          Thread.currentThread().interrupt();
      } catch(IOException ex) {
      }
    }

    public SocketHandler(int port) throws IOException {
      serverSocket = new ServerSocket(port);
      setName(""TelnetAppender-"" + getName() + ""-"" + port);
    }

  }
}
"
log4j,1.2,org.apache.log4j.FileAppender,17,3,2,9,36,14,3,6,14,0.546875,272,1.0,0,0.723404255,0.333333333,1,11,14.76470588,2,0.9412,4,"

package org.apache.log4j;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.Writer;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.spi.ErrorCode;





public class FileAppender extends WriterAppender {

  
  protected boolean fileAppend = true;

  
  protected String fileName = null;

  
  protected boolean bufferedIO = false;

  
  protected int bufferSize = 8*1024;


  
  public
  FileAppender() {
  }

  
  public
  FileAppender(Layout layout, String filename, boolean append, boolean bufferedIO,
	       int bufferSize) throws IOException {
    this.layout = layout;
    this.setFile(filename, append, bufferedIO, bufferSize);
  }

  
  public
  FileAppender(Layout layout, String filename, boolean append)
                                                             throws IOException {
    this.layout = layout;
    this.setFile(filename, append, false, bufferSize);
  }

  
  public
  FileAppender(Layout layout, String filename) throws IOException {
    this(layout, filename, true);
  }

  
  public void setFile(String file) {
    
    
    String val = file.trim();
    fileName = val;
  }

  
  public
  boolean getAppend() {
    return fileAppend;
  }


  
  public
  String getFile() {
    return fileName;
  }

  
  public
  void activateOptions() {
    if(fileName != null) {
      try {
	setFile(fileName, fileAppend, bufferedIO, bufferSize);
      }
      catch(java.io.IOException e) {
	errorHandler.error(""setFile(""+fileName+"",""+fileAppend+"") call failed."",
			   e, ErrorCode.FILE_OPEN_FAILURE);
      }
    } else {
      
      LogLog.warn(""File option not set for appender [""+name+""]."");
      LogLog.warn(""Are you using FileAppender instead of ConsoleAppender?"");
    }
  }

 
  protected
  void closeFile() {
    if(this.qw != null) {
      try {
	this.qw.close();
      }
      catch(java.io.IOException e) {
          if (e instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	
	
	LogLog.error(""Could not close "" + qw, e);
      }
    }
  }

  
  public
  boolean getBufferedIO() {
    return this.bufferedIO;
  }


  
  public
  int getBufferSize() {
    return this.bufferSize;
  }



  
  public
  void setAppend(boolean flag) {
    fileAppend = flag;
  }

  
  public
  void setBufferedIO(boolean bufferedIO) {
    this.bufferedIO = bufferedIO;
    if(bufferedIO) {
      immediateFlush = false;
    }
  }


  
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
  }

  
  public
  synchronized
  void setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize)
                                                            throws IOException {
    LogLog.debug(""setFile called: ""+fileName+"", ""+append);

    
    if(bufferedIO) {
      setImmediateFlush(false);
    }

    reset();
    FileOutputStream ostream = null;
    try {
          
          
          
          ostream = new FileOutputStream(fileName, append);
    } catch(FileNotFoundException ex) {
          
          
          
          
          
          String parentName = new File(fileName).getParent();
          if (parentName != null) {
             File parentDir = new File(parentName);
             if(!parentDir.exists() && parentDir.mkdirs()) {
                ostream = new FileOutputStream(fileName, append);
             } else {
                throw ex;
             }
          } else {
             throw ex;
          }
    }
    Writer fw = createWriter(ostream);
    if(bufferedIO) {
      fw = new BufferedWriter(fw, bufferSize);
    }
    this.setQWForFiles(fw);
    this.fileName = fileName;
    this.fileAppend = append;
    this.bufferedIO = bufferedIO;
    this.bufferSize = bufferSize;
    writeHeader();
    LogLog.debug(""setFile ended"");
  }


  
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new QuietWriter(writer, errorHandler);
  }


  
  protected
  void reset() {
    closeFile();
    this.fileName = null;
    super.reset();
  }
}

"
log4j,1.2,org.apache.log4j.DefaultCategoryFactory,2,1,0,4,4,1,2,2,1,2.0,10,0.0,0,0.0,0.75,0,0,4.0,1,0.5,2,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggerFactory;

class DefaultCategoryFactory implements LoggerFactory {
    
  DefaultCategoryFactory() {
  }    
    
  public
  Logger makeNewLoggerInstance(String name) {
    return new Logger(name);
  }    
}
"
log4j,1.2,org.apache.log4j.HTMLLayout,13,2,0,6,35,46,0,6,11,0.916666667,758,0.375,0,0.421052632,0.236111111,1,1,56.69230769,7,1.6154,3,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.Transform;


public class HTMLLayout extends Layout {

  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;

  static String TRACE_PREFIX = ""<br>&nbsp;&nbsp;&nbsp;&nbsp;"";

  
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);

  
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";

  
  public static final String TITLE_OPTION = ""Title"";

  
  boolean locationInfo = false;

  String title = ""Log4J Log Messages"";

  
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }

  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  
  public
  void setTitle(String title) {
    this.title = title;
  }

  
  public
  String getTitle() {
    return title;
  }

 
  public
  String getContentType() {
    return ""text/html"";
  }

  
  public
  void activateOptions() {
  }

  public
  String format(LoggingEvent event) {

    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }

    sbuf.append(Layout.LINE_SEP + ""<tr>"" + Layout.LINE_SEP);

    sbuf.append(""<td>"");
    sbuf.append(event.timeStamp - LoggingEvent.getStartTime());
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    String escapedThread = Transform.escapeTags(event.getThreadName());
    sbuf.append(""<td title=\"""" + escapedThread + "" thread\"">"");
    sbuf.append(escapedThread);
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\""Level\"">"");
    if (event.getLevel().equals(Level.DEBUG)) {
      sbuf.append(""<font color=\""#339933\"">"");
      sbuf.append(Transform.escapeTags(String.valueOf(event.getLevel())));
      sbuf.append(""</font>"");
    }
    else if(event.getLevel().isGreaterOrEqual(Level.WARN)) {
      sbuf.append(""<font color=\""#993300\""><strong>"");
      sbuf.append(Transform.escapeTags(String.valueOf(event.getLevel())));
      sbuf.append(""</strong></font>"");
    } else {
      sbuf.append(Transform.escapeTags(String.valueOf(event.getLevel())));
    }
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    String escapedLogger = Transform.escapeTags(event.getLoggerName());
    sbuf.append(""<td title=\"""" + escapedLogger + "" category\"">"");
    sbuf.append(escapedLogger);
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    if(locationInfo) {
      LocationInfo locInfo = event.getLocationInformation();
      sbuf.append(""<td>"");
      sbuf.append(Transform.escapeTags(locInfo.getFileName()));
      sbuf.append(':');
      sbuf.append(locInfo.getLineNumber());
      sbuf.append(""</td>"" + Layout.LINE_SEP);
    }

    sbuf.append(""<td title=\""Message\"">"");
    sbuf.append(Transform.escapeTags(event.getRenderedMessage()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);

    if (event.getNDC() != null) {
      sbuf.append(""<tr><td bgcolor=\""#EEEEEE\"" style=\""font-size : xx-small;\"" colspan=\""6\"" title=\""Nested Diagnostic Context\"">"");
      sbuf.append(""NDC: "" + Transform.escapeTags(event.getNDC()));
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }

    String[] s = event.getThrowableStrRep();
    if(s != null) {
      sbuf.append(""<tr><td bgcolor=\""#993300\"" style=\""color:White; font-size : xx-small;\"" colspan=\""6\"">"");
      appendThrowableAsHTML(s, sbuf);
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }

    return sbuf.toString();
  }

  void appendThrowableAsHTML(String[] s, StringBuffer sbuf) {
    if(s != null) {
      int len = s.length;
      if(len == 0)
	return;
      sbuf.append(Transform.escapeTags(s[0]));
      sbuf.append(Layout.LINE_SEP);
      for(int i = 1; i < len; i++) {
	sbuf.append(TRACE_PREFIX);
	sbuf.append(Transform.escapeTags(s[i]));
	sbuf.append(Layout.LINE_SEP);
      }
    }
  }

  
  public
  String getHeader() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-
    sbuf.append(""<html>"" + Layout.LINE_SEP);
    sbuf.append(""<head>"" + Layout.LINE_SEP);
    sbuf.append(""<title>"" + title + ""</title>"" + Layout.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">""  + Layout.LINE_SEP);
    sbuf.append(""<!--""  + Layout.LINE_SEP);
    sbuf.append(""body, table {font-family: arial,sans-serif; font-size: x-small;}"" + Layout.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"" + Layout.LINE_SEP);
    sbuf.append(""-->"" + Layout.LINE_SEP);
    sbuf.append(""</style>"" + Layout.LINE_SEP);
    sbuf.append(""</head>"" + Layout.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"" + Layout.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"" + Layout.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"" + Layout.LINE_SEP);
    sbuf.append(""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Time</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Thread</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Level</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Category</th>"" + Layout.LINE_SEP);
    if(locationInfo) {
      sbuf.append(""<th>File:Line</th>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    return sbuf.toString();
  }

  
  public
  String getFooter() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""</table>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""</body></html>"");
    return sbuf.toString();
  }

  
  public
  boolean ignoresThrowable() {
    return false;
  }
}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogBrokerMonitor,105,1,0,55,321,4900,40,51,22,0.959880637,2443,0.965517241,5,0.0,0.072380952,0,0,21.99047619,6,1.5238,2,"
package org.apache.log4j.lf5.viewer;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JColorChooser;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTextArea;
import javax.swing.JToolBar;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;

import org.apache.log4j.lf5.LogLevel;
import org.apache.log4j.lf5.LogRecord;
import org.apache.log4j.lf5.LogRecordFilter;
import org.apache.log4j.lf5.util.DateFormatManager;
import org.apache.log4j.lf5.util.LogFileParser;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;
import org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;
import org.apache.log4j.lf5.viewer.configure.ConfigurationManager;
import org.apache.log4j.lf5.viewer.configure.MRUFileManager;





public class LogBrokerMonitor {
  
  
  

  public static final String DETAILED_VIEW = ""Detailed"";


  
  
  
  protected JFrame _logMonitorFrame;
  protected int _logMonitorFrameWidth = 550;
  protected int _logMonitorFrameHeight = 500;
  protected LogTable _table;
  protected CategoryExplorerTree _categoryExplorerTree;
  protected String _searchText;
  protected String _NDCTextFilter = """";
  protected LogLevel _leastSevereDisplayedLogLevel = LogLevel.DEBUG;

  protected JScrollPane _logTableScrollPane;
  protected JLabel _statusLabel;
  protected Object _lock = new Object();
  protected JComboBox _fontSizeCombo;

  protected int _fontSize = 10;
  protected String _fontName = ""Dialog"";
  protected String _currentView = DETAILED_VIEW;

  protected boolean _loadSystemFonts = false;
  protected boolean _trackTableScrollPane = true;
  protected Dimension _lastTableViewportSize;
  protected boolean _callSystemExitOnClose = false;
  protected List _displayedLogBrokerProperties = new Vector();

  protected Map _logLevelMenuItems = new HashMap();
  protected Map _logTableColumnMenuItems = new HashMap();

  protected List _levels = null;
  protected List _columns = null;
  protected boolean _isDisposed = false;

  protected ConfigurationManager _configurationManager = null;
  protected MRUFileManager _mruFileManager = null;
  protected File _fileLocation = null;

  
  
  

  
  
  

  
  public LogBrokerMonitor(List logLevels) {

    _levels = logLevels;
    _columns = LogTableColumn.getLogTableColumns();
    
    

    String callSystemExitOnClose =
        System.getProperty(""monitor.exit"");
    if (callSystemExitOnClose == null) {
      callSystemExitOnClose = ""false"";
    }
    callSystemExitOnClose = callSystemExitOnClose.trim().toLowerCase();

    if (callSystemExitOnClose.equals(""true"")) {
      _callSystemExitOnClose = true;
    }

    initComponents();


    _logMonitorFrame.addWindowListener(
        new LogBrokerMonitorWindowAdaptor(this));

  }

  
  
  

  
  public void show(final int delay) {
    if (_logMonitorFrame.isVisible()) {
      return;
    }
    
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        Thread.yield();
        pause(delay);
        _logMonitorFrame.setVisible(true);
      }
    });
  }

  public void show() {
    show(0);
  }

  
  public void dispose() {
    _logMonitorFrame.dispose();
    _isDisposed = true;

    if (_callSystemExitOnClose == true) {
      System.exit(0);
    }
  }

  
  public void hide() {
    _logMonitorFrame.setVisible(false);
  }

  
  public DateFormatManager getDateFormatManager() {
    return _table.getDateFormatManager();
  }

  
  public void setDateFormatManager(DateFormatManager dfm) {
    _table.setDateFormatManager(dfm);
  }

  
  public boolean getCallSystemExitOnClose() {
    return _callSystemExitOnClose;
  }

  
  public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {
    _callSystemExitOnClose = callSystemExitOnClose;
  }

  
  public void addMessage(final LogRecord lr) {
    if (_isDisposed == true) {
      
      
      return;
    }

    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        _categoryExplorerTree.getExplorerModel().addLogRecord(lr);
        _table.getFilteredLogTableModel().addLogRecord(lr); 
        updateStatusLabel(); 
      }
    });
  }

  public void setMaxNumberOfLogRecords(int maxNumberOfLogRecords) {
    _table.getFilteredLogTableModel().setMaxNumberOfLogRecords(maxNumberOfLogRecords);
  }

  public JFrame getBaseFrame() {
    return _logMonitorFrame;
  }

  public void setTitle(String title) {
    _logMonitorFrame.setTitle(title + "" - LogFactor5"");
  }

  public void setFrameSize(int width, int height) {
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    if (0 < width && width < screen.width) {
      _logMonitorFrameWidth = width;
    }
    if (0 < height && height < screen.height) {
      _logMonitorFrameHeight = height;
    }
    updateFrameSize();
  }

  public void setFontSize(int fontSize) {
    changeFontSizeCombo(_fontSizeCombo, fontSize);
    
    
  }

  public void addDisplayedProperty(Object messageLine) {
    _displayedLogBrokerProperties.add(messageLine);
  }

  public Map getLogLevelMenuItems() {
    return _logLevelMenuItems;
  }

  public Map getLogTableColumnMenuItems() {
    return _logTableColumnMenuItems;
  }

  public JCheckBoxMenuItem getTableColumnMenuItem(LogTableColumn column) {
    return getLogTableColumnMenuItem(column);
  }

  public CategoryExplorerTree getCategoryExplorerTree() {
    return _categoryExplorerTree;
  }

  
  
  public String getNDCTextFilter() {
    return _NDCTextFilter;
  }

  
  
  
  public void setNDCLogRecordFilter(String textFilter) {
    _table.getFilteredLogTableModel().
        setLogRecordFilter(createNDCLogRecordFilter(textFilter));
  }
  
  
  

  protected void setSearchText(String text) {
    _searchText = text;
  }

  
  protected void setNDCTextFilter(String text) {
    
    
    if (text == null) {
      _NDCTextFilter = """";
    } else {
      _NDCTextFilter = text;
    }
  }

  
  
  
  protected void sortByNDC() {
    String text = _NDCTextFilter;
    if (text == null || text.length() == 0) {
      return;
    }

    
    _table.getFilteredLogTableModel().
        setLogRecordFilter(createNDCLogRecordFilter(text));
  }

  protected void findSearchText() {
    String text = _searchText;
    if (text == null || text.length() == 0) {
      return;
    }
    int startRow = getFirstSelectedRow();
    int foundRow = findRecord(
        startRow,
        text,
        _table.getFilteredLogTableModel().getFilteredRecords()
    );
    selectRow(foundRow);
  }

  protected int getFirstSelectedRow() {
    return _table.getSelectionModel().getMinSelectionIndex();
  }

  protected void selectRow(int foundRow) {
    if (foundRow == -1) {
      String message = _searchText + "" not found."";
      JOptionPane.showMessageDialog(
          _logMonitorFrame,
          message,
          ""Text not found"",
          JOptionPane.INFORMATION_MESSAGE
      );
      return;
    }
    LF5SwingUtils.selectRow(foundRow, _table, _logTableScrollPane);
  }

  protected int findRecord(
      int startRow,
      String searchText,
      List records
      ) {
    if (startRow < 0) {
      startRow = 0; 
    } else {
      startRow++; 
    }
    int len = records.size();

    for (int i = startRow; i < len; i++) {
      if (matches((LogRecord) records.get(i), searchText)) {
        return i; 
      }
    }
    
    len = startRow;
    for (int i = 0; i < len; i++) {
      if (matches((LogRecord) records.get(i), searchText)) {
        return i; 
      }
    }
    
    return -1;
  }

  
  protected boolean matches(LogRecord record, String text) {
    String message = record.getMessage();
    String NDC = record.getNDC();

    if (message == null && NDC == null || text == null) {
      return false;
    }
    if (message.toLowerCase().indexOf(text.toLowerCase()) == -1 &&
        NDC.toLowerCase().indexOf(text.toLowerCase()) == -1) {
      return false;
    }

    return true;
  }

  
  protected void refresh(JTextArea textArea) {
    String text = textArea.getText();
    textArea.setText("""");
    textArea.setText(text);
  }

  protected void refreshDetailTextArea() {
    refresh(_table._detailTextArea);
  }

  protected void clearDetailTextArea() {
    _table._detailTextArea.setText("""");
  }

  
  protected int changeFontSizeCombo(JComboBox box, int requestedSize) {
    int len = box.getItemCount();
    int currentValue;
    Object currentObject;
    Object selectedObject = box.getItemAt(0);
    int selectedValue = Integer.parseInt(String.valueOf(selectedObject));
    for (int i = 0; i < len; i++) {
      currentObject = box.getItemAt(i);
      currentValue = Integer.parseInt(String.valueOf(currentObject));
      if (selectedValue < currentValue && currentValue <= requestedSize) {
        selectedValue = currentValue;
        selectedObject = currentObject;
      }
    }
    box.setSelectedItem(selectedObject);
    return selectedValue;
  }

  
  protected void setFontSizeSilently(int fontSize) {
    _fontSize = fontSize;
    setFontSize(_table._detailTextArea, fontSize);
    selectRow(0);
    setFontSize(_table, fontSize);
  }

  protected void setFontSize(Component component, int fontSize) {
    Font oldFont = component.getFont();
    Font newFont =
        new Font(oldFont.getFontName(), oldFont.getStyle(), fontSize);
    component.setFont(newFont);
  }

  protected void updateFrameSize() {
    _logMonitorFrame.setSize(_logMonitorFrameWidth, _logMonitorFrameHeight);
    centerFrame(_logMonitorFrame);
  }

  protected void pause(int millis) {
    try {
      Thread.sleep(millis);
    } catch (InterruptedException e) {

    }
  }

  protected void initComponents() {
    
    
    
    _logMonitorFrame = new JFrame(""LogFactor5"");

    _logMonitorFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

    String resource =
        ""/org/apache/log4j/lf5/viewer/images/lf5_small_icon.gif"";
    URL lf5IconURL = getClass().getResource(resource);

    if (lf5IconURL != null) {
      _logMonitorFrame.setIconImage(new ImageIcon(lf5IconURL).getImage());
    }
    updateFrameSize();

    
    
    
    JTextArea detailTA = createDetailTextArea();
    JScrollPane detailTAScrollPane = new JScrollPane(detailTA);
    _table = new LogTable(detailTA);
    setView(_currentView, _table);
    _table.setFont(new Font(_fontName, Font.PLAIN, _fontSize));
    _logTableScrollPane = new JScrollPane(_table);

    if (_trackTableScrollPane) {
      _logTableScrollPane.getVerticalScrollBar().addAdjustmentListener(
          new TrackingAdjustmentListener()
      );
    }


    
    

    JSplitPane tableViewerSplitPane = new JSplitPane();
    tableViewerSplitPane.setOneTouchExpandable(true);
    tableViewerSplitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
    tableViewerSplitPane.setLeftComponent(_logTableScrollPane);
    tableViewerSplitPane.setRightComponent(detailTAScrollPane);
    
    
    
    
    
    
    
    tableViewerSplitPane.setDividerLocation(350);

    
    
    

    _categoryExplorerTree = new CategoryExplorerTree();

    _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());

    JScrollPane categoryExplorerTreeScrollPane =
        new JScrollPane(_categoryExplorerTree);
    categoryExplorerTreeScrollPane.setPreferredSize(new Dimension(130, 400));

    
    _mruFileManager = new MRUFileManager();

    
    
    

    JSplitPane splitPane = new JSplitPane();
    splitPane.setOneTouchExpandable(true);
    splitPane.setRightComponent(tableViewerSplitPane);
    splitPane.setLeftComponent(categoryExplorerTreeScrollPane);
    
    splitPane.setDividerLocation(130);
    
    
    
    
    _logMonitorFrame.getRootPane().setJMenuBar(createMenuBar());
    _logMonitorFrame.getContentPane().add(splitPane, BorderLayout.CENTER);
    _logMonitorFrame.getContentPane().add(createToolBar(),
        BorderLayout.NORTH);
    _logMonitorFrame.getContentPane().add(createStatusArea(),
        BorderLayout.SOUTH);

    makeLogTableListenToCategoryExplorer();
    addTableModelProperties();

    
    
    
    _configurationManager = new ConfigurationManager(this, _table);

  }

  protected LogRecordFilter createLogRecordFilter() {
    LogRecordFilter result = new LogRecordFilter() {
      public boolean passes(LogRecord record) {
        CategoryPath path = new CategoryPath(record.getCategory());
        return
            getMenuItem(record.getLevel()).isSelected() &&
            _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);
      }
    };
    return result;
  }

  
  
  protected LogRecordFilter createNDCLogRecordFilter(String text) {
    _NDCTextFilter = text;
    LogRecordFilter result = new LogRecordFilter() {
      public boolean passes(LogRecord record) {
        String NDC = record.getNDC();
        CategoryPath path = new CategoryPath(record.getCategory());
        if (NDC == null || _NDCTextFilter == null) {
          return false;
        } else if (NDC.toLowerCase().indexOf(_NDCTextFilter.toLowerCase()) == -1) {
          return false;
        } else {
          return getMenuItem(record.getLevel()).isSelected() &&
              _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);
        }
      }
    };

    return result;
  }


  protected void updateStatusLabel() {
    _statusLabel.setText(getRecordsDisplayedMessage());
  }

  protected String getRecordsDisplayedMessage() {
    FilteredLogTableModel model = _table.getFilteredLogTableModel();
    return getStatusText(model.getRowCount(), model.getTotalRowCount());
  }

  protected void addTableModelProperties() {
    final FilteredLogTableModel model = _table.getFilteredLogTableModel();

    addDisplayedProperty(new Object() {
      public String toString() {
        return getRecordsDisplayedMessage();
      }
    });
    addDisplayedProperty(new Object() {
      public String toString() {
        return ""Maximum number of displayed LogRecords: ""
            + model._maxNumberOfLogRecords;
      }
    });
  }

  protected String getStatusText(int displayedRows, int totalRows) {
    StringBuffer result = new StringBuffer();
    result.append(""Displaying: "");
    result.append(displayedRows);
    result.append("" records out of a total of: "");
    result.append(totalRows);
    result.append("" records."");
    return result.toString();
  }

  protected void makeLogTableListenToCategoryExplorer() {
    ActionListener listener = new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    };
    _categoryExplorerTree.getExplorerModel().addActionListener(listener);
  }

  protected JPanel createStatusArea() {
    JPanel statusArea = new JPanel();
    JLabel status =
        new JLabel(""No log records to display."");
    _statusLabel = status;
    status.setHorizontalAlignment(JLabel.LEFT);

    statusArea.setBorder(BorderFactory.createEtchedBorder());
    statusArea.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
    statusArea.add(status);

    return (statusArea);
  }

  protected JTextArea createDetailTextArea() {
    JTextArea detailTA = new JTextArea();
    detailTA.setFont(new Font(""Monospaced"", Font.PLAIN, 14));
    detailTA.setTabSize(3);
    detailTA.setLineWrap(true);
    detailTA.setWrapStyleWord(false);
    return (detailTA);
  }

  protected JMenuBar createMenuBar() {
    JMenuBar menuBar = new JMenuBar();
    menuBar.add(createFileMenu());
    menuBar.add(createEditMenu());
    menuBar.add(createLogLevelMenu());
    menuBar.add(createViewMenu());
    menuBar.add(createConfigureMenu());
    menuBar.add(createHelpMenu());

    return (menuBar);
  }

  protected JMenu createLogLevelMenu() {
    JMenu result = new JMenu(""Log Level"");
    result.setMnemonic('l');
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      result.add(getMenuItem((LogLevel) levels.next()));
    }

    result.addSeparator();
    result.add(createAllLogLevelsMenuItem());
    result.add(createNoLogLevelsMenuItem());
    result.addSeparator();
    result.add(createLogLevelColorMenu());
    result.add(createResetLogLevelColorMenuItem());

    return result;
  }

  protected JMenuItem createAllLogLevelsMenuItem() {
    JMenuItem result = new JMenuItem(""Show all LogLevels"");
    result.setMnemonic('s');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogLevels(true);
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    });
    return result;
  }

  protected JMenuItem createNoLogLevelsMenuItem() {
    JMenuItem result = new JMenuItem(""Hide all LogLevels"");
    result.setMnemonic('h');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogLevels(false);
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    });
    return result;
  }

  protected JMenu createLogLevelColorMenu() {
    JMenu colorMenu = new JMenu(""Configure LogLevel Colors"");
    colorMenu.setMnemonic('c');
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      colorMenu.add(createSubMenuItem((LogLevel) levels.next()));
    }

    return colorMenu;
  }

  protected JMenuItem createResetLogLevelColorMenuItem() {
    JMenuItem result = new JMenuItem(""Reset LogLevel Colors"");
    result.setMnemonic('r');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        
        LogLevel.resetLogLevelColorMap();

        
        _table.getFilteredLogTableModel().refresh();
      }
    });
    return result;
  }

  protected void selectAllLogLevels(boolean selected) {
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      getMenuItem((LogLevel) levels.next()).setSelected(selected);
    }
  }

  protected JCheckBoxMenuItem getMenuItem(LogLevel level) {
    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logLevelMenuItems.get(level));
    if (result == null) {
      result = createMenuItem(level);
      _logLevelMenuItems.put(level, result);
    }
    return result;
  }

  protected JMenuItem createSubMenuItem(LogLevel level) {
    final JMenuItem result = new JMenuItem(level.toString());
    final LogLevel logLevel = level;
    result.setMnemonic(level.toString().charAt(0));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        showLogLevelColorChangeDialog(result, logLevel);
      }
    });

    return result;

  }

  protected void showLogLevelColorChangeDialog(JMenuItem result, LogLevel level) {
    JMenuItem menuItem = result;
    Color newColor = JColorChooser.showDialog(
        _logMonitorFrame,
        ""Choose LogLevel Color"",
        result.getForeground());

    if (newColor != null) {
      
      level.setLogLevelColorMap(level, newColor);
      _table.getFilteredLogTableModel().refresh();
    }

  }

  protected JCheckBoxMenuItem createMenuItem(LogLevel level) {
    JCheckBoxMenuItem result = new JCheckBoxMenuItem(level.toString());
    result.setSelected(true);
    result.setMnemonic(level.toString().charAt(0));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        _table.getFilteredLogTableModel().refresh();
        updateStatusLabel();
      }
    });
    return result;
  }

  
  protected JMenu createViewMenu() {
    JMenu result = new JMenu(""View"");
    result.setMnemonic('v');
    Iterator columns = getLogTableColumns();
    while (columns.hasNext()) {
      result.add(getLogTableColumnMenuItem((LogTableColumn) columns.next()));
    }

    result.addSeparator();
    result.add(createAllLogTableColumnsMenuItem());
    result.add(createNoLogTableColumnsMenuItem());
    return result;
  }

  protected JCheckBoxMenuItem getLogTableColumnMenuItem(LogTableColumn column) {
    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logTableColumnMenuItems.get(column));
    if (result == null) {
      result = createLogTableColumnMenuItem(column);
      _logTableColumnMenuItems.put(column, result);
    }
    return result;
  }

  protected JCheckBoxMenuItem createLogTableColumnMenuItem(LogTableColumn column) {
    JCheckBoxMenuItem result = new JCheckBoxMenuItem(column.toString());

    result.setSelected(true);
    result.setMnemonic(column.toString().charAt(0));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        
        List selectedColumns = updateView();
        _table.setView(selectedColumns);
      }
    });
    return result;
  }

  protected List updateView() {
    ArrayList updatedList = new ArrayList();
    Iterator columnIterator = _columns.iterator();
    while (columnIterator.hasNext()) {
      LogTableColumn column = (LogTableColumn) columnIterator.next();
      JCheckBoxMenuItem result = getLogTableColumnMenuItem(column);
      
      if (result.isSelected()) {
        updatedList.add(column);
      }
    }

    return updatedList;
  }

  protected JMenuItem createAllLogTableColumnsMenuItem() {
    JMenuItem result = new JMenuItem(""Show all Columns"");
    result.setMnemonic('s');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogTableColumns(true);
        
        List selectedColumns = updateView();
        _table.setView(selectedColumns);
      }
    });
    return result;
  }

  protected JMenuItem createNoLogTableColumnsMenuItem() {
    JMenuItem result = new JMenuItem(""Hide all Columns"");
    result.setMnemonic('h');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        selectAllLogTableColumns(false);
        
        List selectedColumns = updateView();
        _table.setView(selectedColumns);
      }
    });
    return result;
  }

  protected void selectAllLogTableColumns(boolean selected) {
    Iterator columns = getLogTableColumns();
    while (columns.hasNext()) {
      getLogTableColumnMenuItem((LogTableColumn) columns.next()).setSelected(selected);
    }
  }

  protected JMenu createFileMenu() {
    JMenu fileMenu = new JMenu(""File"");
    fileMenu.setMnemonic('f');
    JMenuItem exitMI;
    fileMenu.add(createOpenMI());
    fileMenu.add(createOpenURLMI());
    fileMenu.addSeparator();
    fileMenu.add(createCloseMI());
    createMRUFileListMI(fileMenu);
    fileMenu.addSeparator();
    fileMenu.add(createExitMI());
    return fileMenu;
  }

  
  protected JMenuItem createOpenMI() {
    JMenuItem result = new JMenuItem(""Open..."");
    result.setMnemonic('o');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestOpen();
      }
    });
    return result;
  }

  
  protected JMenuItem createOpenURLMI() {
    JMenuItem result = new JMenuItem(""Open URL..."");
    result.setMnemonic('u');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestOpenURL();
      }
    });
    return result;
  }

  protected JMenuItem createCloseMI() {
    JMenuItem result = new JMenuItem(""Close"");
    result.setMnemonic('c');
    result.setAccelerator(KeyStroke.getKeyStroke(""control Q""));
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestClose();
      }
    });
    return result;
  }

  
  protected void createMRUFileListMI(JMenu menu) {

    String[] files = _mruFileManager.getMRUFileList();

    if (files != null) {
      menu.addSeparator();
      for (int i = 0; i < files.length; i++) {
        JMenuItem result = new JMenuItem((i + 1) + "" "" + files[i]);
        result.setMnemonic(i + 1);
        result.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            requestOpenMRU(e);
          }
        });
        menu.add(result);
      }
    }
  }

  protected JMenuItem createExitMI() {
    JMenuItem result = new JMenuItem(""Exit"");
    result.setMnemonic('x');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        requestExit();
      }
    });
    return result;
  }

  protected JMenu createConfigureMenu() {
    JMenu configureMenu = new JMenu(""Configure"");
    configureMenu.setMnemonic('c');
    configureMenu.add(createConfigureSave());
    configureMenu.add(createConfigureReset());
    configureMenu.add(createConfigureMaxRecords());

    return configureMenu;
  }

  protected JMenuItem createConfigureSave() {
    JMenuItem result = new JMenuItem(""Save"");
    result.setMnemonic('s');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        saveConfiguration();
      }
    });

    return result;
  }

  protected JMenuItem createConfigureReset() {
    JMenuItem result = new JMenuItem(""Reset"");
    result.setMnemonic('r');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        resetConfiguration();
      }
    });

    return result;
  }

  protected JMenuItem createConfigureMaxRecords() {
    JMenuItem result = new JMenuItem(""Set Max Number of Records"");
    result.setMnemonic('m');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        setMaxRecordConfiguration();
      }
    });

    return result;
  }


  protected void saveConfiguration() {
    _configurationManager.save();
  }

  protected void resetConfiguration() {
    _configurationManager.reset();
  }

  protected void setMaxRecordConfiguration() {
    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(
        getBaseFrame(), ""Set Max Number of Records"", """", 10);

    String temp = inputDialog.getText();

    if (temp != null) {
      try {
        setMaxNumberOfLogRecords(Integer.parseInt(temp));
      } catch (NumberFormatException e) {
        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
            getBaseFrame(),
            ""'"" + temp + ""' is an invalid parameter.\nPlease try again."");
        setMaxRecordConfiguration();
      }
    }
  }


  protected JMenu createHelpMenu() {
    JMenu helpMenu = new JMenu(""Help"");
    helpMenu.setMnemonic('h');
    helpMenu.add(createHelpProperties());
    return helpMenu;
  }

  protected JMenuItem createHelpProperties() {
    final String title = ""LogFactor5 Properties"";
    final JMenuItem result = new JMenuItem(title);
    result.setMnemonic('l');
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        showPropertiesDialog(title);
      }
    });
    return result;
  }

  protected void showPropertiesDialog(String title) {
    JOptionPane.showMessageDialog(
        _logMonitorFrame,
        _displayedLogBrokerProperties.toArray(),
        title,
        JOptionPane.PLAIN_MESSAGE
    );
  }

  protected JMenu createEditMenu() {
    JMenu editMenu = new JMenu(""Edit"");
    editMenu.setMnemonic('e');
    editMenu.add(createEditFindMI());
    editMenu.add(createEditFindNextMI());
    editMenu.addSeparator();
    editMenu.add(createEditSortNDCMI());
    editMenu.add(createEditRestoreAllNDCMI());
    return editMenu;
  }

  protected JMenuItem createEditFindNextMI() {
    JMenuItem editFindNextMI = new JMenuItem(""Find Next"");
    editFindNextMI.setMnemonic('n');
    editFindNextMI.setAccelerator(KeyStroke.getKeyStroke(""F3""));
    editFindNextMI.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        findSearchText();
      }
    });
    return editFindNextMI;
  }

  protected JMenuItem createEditFindMI() {
    JMenuItem editFindMI = new JMenuItem(""Find"");
    editFindMI.setMnemonic('f');
    editFindMI.setAccelerator(KeyStroke.getKeyStroke(""control F""));

    editFindMI.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            String inputValue =
                JOptionPane.showInputDialog(
                    _logMonitorFrame,
                    ""Find text: "",
                    ""Search Record Messages"",
                    JOptionPane.QUESTION_MESSAGE
                );
            setSearchText(inputValue);
            findSearchText();
          }
        }

    );
    return editFindMI;
  }

  
  
  
  protected JMenuItem createEditSortNDCMI() {
    JMenuItem editSortNDCMI = new JMenuItem(""Sort by NDC"");
    editSortNDCMI.setMnemonic('s');
    editSortNDCMI.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            String inputValue =
                JOptionPane.showInputDialog(
                    _logMonitorFrame,
                    ""Sort by this NDC: "",
                    ""Sort Log Records by NDC"",
                    JOptionPane.QUESTION_MESSAGE
                );
            setNDCTextFilter(inputValue);
            sortByNDC();
            _table.getFilteredLogTableModel().refresh();
            updateStatusLabel();
          }
        }

    );
    return editSortNDCMI;
  }

  
  
  protected JMenuItem createEditRestoreAllNDCMI() {
    JMenuItem editRestoreAllNDCMI = new JMenuItem(""Restore all NDCs"");
    editRestoreAllNDCMI.setMnemonic('r');
    editRestoreAllNDCMI.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());
            
            setNDCTextFilter("""");
            _table.getFilteredLogTableModel().refresh();
            updateStatusLabel();
          }
        }
    );
    return editRestoreAllNDCMI;
  }

  protected JToolBar createToolBar() {
    JToolBar tb = new JToolBar();
    tb.putClientProperty(""JToolBar.isRollover"", Boolean.TRUE);
    JComboBox fontCombo = new JComboBox();
    JComboBox fontSizeCombo = new JComboBox();
    _fontSizeCombo = fontSizeCombo;

    ClassLoader cl = this.getClass().getClassLoader();
    if(cl == null) {
        cl = ClassLoader.getSystemClassLoader();
    }
    URL newIconURL = cl.getResource(""org/apache/log4j/lf5/viewer/"" +
        ""images/channelexplorer_new.gif"");

    ImageIcon newIcon = null;

    if (newIconURL != null) {
      newIcon = new ImageIcon(newIconURL);
    }

    JButton newButton = new JButton(""Clear Log Table"");

    if (newIcon != null) {
      newButton.setIcon(newIcon);
    }

    newButton.setToolTipText(""Clear Log Table."");
    

    newButton.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _table.clearLogRecords();
            _categoryExplorerTree.getExplorerModel().resetAllNodeCounts();
            updateStatusLabel();
            clearDetailTextArea();
            LogRecord.resetSequenceNumber();
          }
        }
    );

    Toolkit tk = Toolkit.getDefaultToolkit();
    

    String[] fonts;

    if (_loadSystemFonts) {
      fonts = GraphicsEnvironment.
          getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
    } else {
      fonts = tk.getFontList();
    }

    for (int j = 0; j < fonts.length; j++) {
      fontCombo.addItem(fonts[j]);
    }

    fontCombo.setSelectedItem(_fontName);

    fontCombo.addActionListener(

        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            JComboBox box = (JComboBox) e.getSource();
            String font = (String) box.getSelectedItem();
            _table.setFont(new Font(font, Font.PLAIN, _fontSize));
            _fontName = font;
          }
        }
    );

    fontSizeCombo.addItem(""8"");
    fontSizeCombo.addItem(""9"");
    fontSizeCombo.addItem(""10"");
    fontSizeCombo.addItem(""12"");
    fontSizeCombo.addItem(""14"");
    fontSizeCombo.addItem(""16"");
    fontSizeCombo.addItem(""18"");
    fontSizeCombo.addItem(""24"");

    fontSizeCombo.setSelectedItem(String.valueOf(_fontSize));
    fontSizeCombo.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            JComboBox box = (JComboBox) e.getSource();
            String size = (String) box.getSelectedItem();
            int s = Integer.valueOf(size).intValue();

            setFontSizeSilently(s);
            refreshDetailTextArea();
            _fontSize = s;
          }
        }
    );

    tb.add(new JLabel("" Font: ""));
    tb.add(fontCombo);
    tb.add(fontSizeCombo);
    tb.addSeparator();
    tb.addSeparator();
    tb.add(newButton);

    newButton.setAlignmentY(0.5f);
    newButton.setAlignmentX(0.5f);

    fontCombo.setMaximumSize(fontCombo.getPreferredSize());
    fontSizeCombo.setMaximumSize(
        fontSizeCombo.getPreferredSize());

    return (tb);
  }















  protected void setView(String viewString, LogTable table) {
    if (DETAILED_VIEW.equals(viewString)) {
      table.setDetailedView();
    } else {
      String message = viewString + ""does not match a supported view."";
      throw new IllegalArgumentException(message);
    }
    _currentView = viewString;
  }

  protected JComboBox createLogLevelCombo() {
    JComboBox result = new JComboBox();
    Iterator levels = getLogLevels();
    while (levels.hasNext()) {
      result.addItem(levels.next());
    }
    result.setSelectedItem(_leastSevereDisplayedLogLevel);

    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        JComboBox box = (JComboBox) e.getSource();
        LogLevel level = (LogLevel) box.getSelectedItem();
        setLeastSevereDisplayedLogLevel(level);
      }
    });
    result.setMaximumSize(result.getPreferredSize());
    return result;
  }

  protected void setLeastSevereDisplayedLogLevel(LogLevel level) {
    if (level == null || _leastSevereDisplayedLogLevel == level) {
      return; 
    }
    _leastSevereDisplayedLogLevel = level;
    _table.getFilteredLogTableModel().refresh();
    updateStatusLabel();
  }

  
  protected void trackTableScrollPane() {
    
  }

  protected void centerFrame(JFrame frame) {
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    Dimension comp = frame.getSize();

    frame.setLocation(((screen.width - comp.width) / 2),
        ((screen.height - comp.height) / 2));

  }

  
  protected void requestOpen() {
    JFileChooser chooser;

    if (_fileLocation == null) {
      chooser = new JFileChooser();
    } else {
      chooser = new JFileChooser(_fileLocation);
    }

    int returnVal = chooser.showOpenDialog(_logMonitorFrame);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File f = chooser.getSelectedFile();
      if (loadLogFile(f)) {
        _fileLocation = chooser.getSelectedFile();
        _mruFileManager.set(f);
        updateMRUList();
      }
    }
  }

  
  protected void requestOpenURL() {
    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(
        getBaseFrame(), ""Open URL"", ""URL:"");
    String temp = inputDialog.getText();

    if (temp != null) {
      if (temp.indexOf("":
        temp = ""http:
      }

      try {
        URL url = new URL(temp);
        if (loadLogFile(url)) {
          _mruFileManager.set(url);
          updateMRUList();
        }
      } catch (MalformedURLException e) {
        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
            getBaseFrame(), ""Error reading URL."");
      }
    }
  }

  
  protected void updateMRUList() {
    JMenu menu = _logMonitorFrame.getJMenuBar().getMenu(0);
    menu.removeAll();
    menu.add(createOpenMI());
    menu.add(createOpenURLMI());
    menu.addSeparator();
    menu.add(createCloseMI());
    createMRUFileListMI(menu);
    menu.addSeparator();
    menu.add(createExitMI());
  }

  protected void requestClose() {
    setCallSystemExitOnClose(false);
    closeAfterConfirm();
  }

  
  protected void requestOpenMRU(ActionEvent e) {
    String file = e.getActionCommand();
    StringTokenizer st = new StringTokenizer(file);
    String num = st.nextToken().trim();
    file = st.nextToken(""\n"");

    try {
      int index = Integer.parseInt(num) - 1;

      InputStream in = _mruFileManager.getInputStream(index);
      LogFileParser lfp = new LogFileParser(in);
      lfp.parse(this);

      _mruFileManager.moveToTop(index);
      updateMRUList();

    } catch (Exception me) {
      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
          getBaseFrame(), ""Unable to load file "" + file);
    }

  }

  protected void requestExit() {
    _mruFileManager.save();
    setCallSystemExitOnClose(true);
    closeAfterConfirm();
  }

  protected void closeAfterConfirm() {
    StringBuffer message = new StringBuffer();

    if (_callSystemExitOnClose == false) {
      message.append(""Are you sure you want to close the logging "");
      message.append(""console?\n"");
      message.append(""(Note: This will not shut down the Virtual Machine,\n"");
      message.append(""or the Swing event thread.)"");
    } else {
      message.append(""Are you sure you want to exit?\n"");
      message.append(""This will shut down the Virtual Machine.\n"");
    }

    String title =
        ""Are you sure you want to dispose of the Logging Console?"";

    if (_callSystemExitOnClose == true) {
      title = ""Are you sure you want to exit?"";
    }
    int value = JOptionPane.showConfirmDialog(
        _logMonitorFrame,
        message.toString(),
        title,
        JOptionPane.OK_CANCEL_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null
    );

    if (value == JOptionPane.OK_OPTION) {
      dispose();
    }
  }

  protected Iterator getLogLevels() {
    return _levels.iterator();
  }

  protected Iterator getLogTableColumns() {
    return _columns.iterator();
  }

  
  protected boolean loadLogFile(File file) {
    boolean ok = false;
    try {
      LogFileParser lfp = new LogFileParser(file);
      lfp.parse(this);
      ok = true;
    } catch (IOException e) {
      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
          getBaseFrame(), ""Error reading "" + file.getName());
    }

    return ok;
  }

  
  protected boolean loadLogFile(URL url) {
    boolean ok = false;
    try {
      LogFileParser lfp = new LogFileParser(url.openStream());
      lfp.parse(this);
      ok = true;
    } catch (IOException e) {
      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(
          getBaseFrame(), ""Error reading URL:"" + url.getFile());
    }
    return ok;
  }
  
  
  

  
  
  

  class LogBrokerMonitorWindowAdaptor extends WindowAdapter {
    protected LogBrokerMonitor _monitor;

    public LogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor) {
      _monitor = monitor;
    }

    public void windowClosing(WindowEvent ev) {
      _monitor.requestClose();
    }
  }
}


"
log4j,1.2,org.apache.log4j.lf5.viewer.LogFactor5LoadingDialog,1,7,0,2,10,0,1,1,1,2.0,41,0.0,0,1.0,1.0,0,0,40.0,0,0.0,2,"
package org.apache.log4j.lf5.viewer;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridBagLayout;

import javax.swing.JFrame;
import javax.swing.JPanel;





public class LogFactor5LoadingDialog extends LogFactor5Dialog {
  
  
  

  
  
  

  
  
  

  
  
  

  public LogFactor5LoadingDialog(JFrame jframe, String message) {
    super(jframe, ""LogFactor5"", false);

    JPanel bottom = new JPanel();
    bottom.setLayout(new FlowLayout());

    JPanel main = new JPanel();
    main.setLayout(new GridBagLayout());
    wrapStringOnPanel(message, main);

    getContentPane().add(main, BorderLayout.CENTER);
    getContentPane().add(bottom, BorderLayout.SOUTH);
    show();

  }
  
  
  

  
  
  

  
  
  

  
  
  
}"
log4j,1.2,org.apache.log4j.LogManager,12,1,0,21,36,0,11,11,11,0.893939394,159,0.333333333,1,0.0,0.121212121,0,0,11.75,1,0.8333,2,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.LoggerFactory;
import org.apache.log4j.spi.RepositorySelector;
import org.apache.log4j.spi.DefaultRepositorySelector;
import org.apache.log4j.spi.RootLogger;
import org.apache.log4j.spi.NOPLoggerRepository;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;

import java.net.URL;
import java.net.MalformedURLException;


import java.util.Enumeration;
import java.io.StringWriter;
import java.io.PrintWriter;


public class LogManager {

  
  static public final String DEFAULT_CONFIGURATION_FILE = ""log4j.properties"";
  
  static final String DEFAULT_XML_CONFIGURATION_FILE = ""log4j.xml"";  
   
  
  static final public String DEFAULT_CONFIGURATION_KEY=""log4j.configuration"";

  
  static final public String CONFIGURATOR_CLASS_KEY=""log4j.configuratorClass"";

  
  public static final String DEFAULT_INIT_OVERRIDE_KEY = 
                                                 ""log4j.defaultInitOverride"";


  static private Object guard = null;
  static private RepositorySelector repositorySelector;

  static {
    
    Hierarchy h = new Hierarchy(new RootLogger((Level) Level.DEBUG));
    repositorySelector = new DefaultRepositorySelector(h);

    
    String override =OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,
						       null);

    
    
    if(override == null || ""false"".equalsIgnoreCase(override)) {

      String configurationOptionStr = OptionConverter.getSystemProperty(
							  DEFAULT_CONFIGURATION_KEY, 
							  null);

      String configuratorClassName = OptionConverter.getSystemProperty(
                                                   CONFIGURATOR_CLASS_KEY, 
						   null);

      URL url = null;

      
      
      
      if(configurationOptionStr == null) {	
	url = Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);
	if(url == null) {
	  url = Loader.getResource(DEFAULT_CONFIGURATION_FILE);
	}
      } else {
	try {
	  url = new URL(configurationOptionStr);
	} catch (MalformedURLException ex) {
	  
	  
	  url = Loader.getResource(configurationOptionStr); 
	}	
      }
      
      
      
      
      if(url != null) {
	    LogLog.debug(""Using URL [""+url+""] for automatic log4j configuration."");
        try {
            OptionConverter.selectAndConfigure(url, configuratorClassName,
					   LogManager.getLoggerRepository());
        } catch (NoClassDefFoundError e) {
            LogLog.warn(""Error during default initialization"", e);
        }
      } else {
	    LogLog.debug(""Could not find resource: [""+configurationOptionStr+""]."");
      }
    } else {
        LogLog.debug(""Default initialization of overridden by "" + 
            DEFAULT_INIT_OVERRIDE_KEY + ""property.""); 
    }  
  } 

  
  static
  public
  void setRepositorySelector(RepositorySelector selector, Object guard) 
                                                 throws IllegalArgumentException {
    if((LogManager.guard != null) && (LogManager.guard != guard)) {
      throw new IllegalArgumentException(
           ""Attempted to reset the LoggerFactory without possessing the guard."");
    }

    if(selector == null) {
      throw new IllegalArgumentException(""RepositorySelector must be non-null."");
    }

    LogManager.guard = guard;
    LogManager.repositorySelector = selector;
  }


    
  private static boolean isLikelySafeScenario(final Exception ex) {
      StringWriter stringWriter = new StringWriter();
      ex.printStackTrace(new PrintWriter(stringWriter));
      String msg = stringWriter.toString();
      return msg.indexOf(""org.apache.catalina.loader.WebappClassLoader.stop"") != -1;
  }

  static
  public
  LoggerRepository getLoggerRepository() {
    if (repositorySelector == null) {
        repositorySelector = new DefaultRepositorySelector(new NOPLoggerRepository());
        guard = null;
        Exception ex = new IllegalStateException(""Class invariant violation"");
        String msg =
                ""log4j called after unloading, see http:
        if (isLikelySafeScenario(ex)) {
            LogLog.debug(msg, ex);
        } else {
            LogLog.error(msg, ex);
        }
    }
    return repositorySelector.getLoggerRepository();
  }

  
  public
  static 
  Logger getRootLogger() {
     
    return getLoggerRepository().getRootLogger();
  }

  
  public
  static 
  Logger getLogger(final String name) {
     
    return getLoggerRepository().getLogger(name);
  }

 
  public
  static 
  Logger getLogger(final Class clazz) {
     
    return getLoggerRepository().getLogger(clazz.getName());
  }


  
  public
  static 
  Logger getLogger(final String name, final LoggerFactory factory) {
     
    return getLoggerRepository().getLogger(name, factory);
  }  

  public
  static
  Logger exists(final String name) {
    return getLoggerRepository().exists(name);
  }

  public
  static
  Enumeration getCurrentLoggers() {
    return getLoggerRepository().getCurrentLoggers();
  }

  public
  static
  void shutdown() {
    getLoggerRepository().shutdown();
  }

  public
  static
  void resetConfiguration() {
    getLoggerRepository().resetConfiguration();
  }
}

"
log4j,1.2,org.apache.log4j.lf5.LF5Appender,15,2,0,12,43,83,1,11,10,0.738095238,187,1.0,3,0.580645161,0.142857143,1,1,11.26666667,4,1.2,2,"

package org.apache.log4j.lf5;

import java.awt.Toolkit;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.lf5.viewer.LogBrokerMonitor;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.spi.LoggingEvent;





public class LF5Appender extends AppenderSkeleton {
  
  
  

  
  
  

  protected LogBrokerMonitor _logMonitor;
  protected static LogBrokerMonitor _defaultLogMonitor;
  protected static AppenderFinalizer _finalizer;

  
  
  

  
  
  

  
  public LF5Appender() {
    this(getDefaultInstance());
  }

  
  public LF5Appender(LogBrokerMonitor monitor) {

    if (monitor != null) {
      _logMonitor = monitor;
    }
  }

  
  
  

  
  public void append(LoggingEvent event) {
    
    String category = event.getLoggerName();
    String logMessage = event.getRenderedMessage();
    String nestedDiagnosticContext = event.getNDC();
    String threadDescription = event.getThreadName();
    String level = event.getLevel().toString();
    long time = event.timeStamp;
    LocationInfo locationInfo = event.getLocationInformation();

    
    Log4JLogRecord record = new Log4JLogRecord();

    record.setCategory(category);
    record.setMessage(logMessage);
    record.setLocation(locationInfo.fullInfo);
    record.setMillis(time);
    record.setThreadDescription(threadDescription);

    if (nestedDiagnosticContext != null) {
      record.setNDC(nestedDiagnosticContext);
    } else {
      record.setNDC("""");
    }

    if (event.getThrowableInformation() != null) {
      record.setThrownStackTrace(event.getThrowableInformation());
    }

    try {
      record.setLevel(LogLevel.valueOf(level));
    } catch (LogLevelFormatException e) {
      
      
      record.setLevel(LogLevel.WARN);
    }

    if (_logMonitor != null) {
      _logMonitor.addMessage(record);
    }
  }

  
  public void close() {
  }

  
  public boolean requiresLayout() {
    return false;
  }

  
  public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {
    _logMonitor.setCallSystemExitOnClose(callSystemExitOnClose);
  }

  
  public boolean equals(LF5Appender compareTo) {
    
    return _logMonitor == compareTo.getLogBrokerMonitor();
  }

  public LogBrokerMonitor getLogBrokerMonitor() {
    return _logMonitor;
  }

  public static void main(String[] args) {
    new LF5Appender();
  }

  public void setMaxNumberOfRecords(int maxNumberOfRecords) {
    _defaultLogMonitor.setMaxNumberOfLogRecords(maxNumberOfRecords);
  }
  
  
  

  
  protected static synchronized LogBrokerMonitor getDefaultInstance() {
    if (_defaultLogMonitor == null) {
      try {
        _defaultLogMonitor =
            new LogBrokerMonitor(LogLevel.getLog4JLevels());
        _finalizer = new AppenderFinalizer(_defaultLogMonitor);

        _defaultLogMonitor.setFrameSize(getDefaultMonitorWidth(),
            getDefaultMonitorHeight());
        _defaultLogMonitor.setFontSize(12);
        _defaultLogMonitor.show();

      } catch (SecurityException e) {
        _defaultLogMonitor = null;
      }
    }

    return _defaultLogMonitor;
  }

  
  protected static int getScreenWidth() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().width;
    } catch (Throwable t) {
      return 800;
    }
  }

  
  protected static int getScreenHeight() {
    try {
      return Toolkit.getDefaultToolkit().getScreenSize().height;
    } catch (Throwable t) {
      return 600;
    }
  }

  protected static int getDefaultMonitorWidth() {
    return (3 * getScreenWidth()) / 4;
  }

  protected static int getDefaultMonitorHeight() {
    return (3 * getScreenHeight()) / 4;
  }
  
  
  


  
  
  

}
"
log4j,1.2,org.apache.log4j.Appender,12,1,0,32,12,66,29,4,12,2.0,12,0.0,0,0.0,0.236111111,0,0,0.0,1,1.0,2,"

package org.apache.log4j;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;


public interface Appender {

  
  void addFilter(Filter newFilter);

  
  public
  Filter getFilter();

  
  public
  void clearFilters();

  
  public
  void close();
  
  
  public
  void doAppend(LoggingEvent event);


  
  public
  String getName();


  
  public
  void setErrorHandler(ErrorHandler errorHandler);

  
  public
  ErrorHandler getErrorHandler();

  
  public
  void setLayout(Layout layout);

  
  public
  Layout getLayout();
  

  
  public
  void setName(String name);

  
  public
  boolean requiresLayout();
}
"
log4j,1.2,org.apache.log4j.spi.RendererSupport,2,1,0,7,2,1,6,2,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,3,"


package org.apache.log4j.spi;

import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;


public interface RendererSupport {

  public
  RendererMap getRendererMap();

  public
  void setRenderer(Class renderedClass, ObjectRenderer renderer);

}
"
log4j,1.2,org.apache.log4j.Dispatcher,3,2,0,5,17,0,1,5,1,0.25,131,0.0,3,0.968253968,0.555555556,0,0,41.33333333,6,2.6667,2,"

package org.apache.log4j;

import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.spi.LoggingEvent;



class Dispatcher extends Thread {
    
  private org.apache.log4j.helpers.BoundedFIFO bf;
  private AppenderAttachableImpl aai;
  private boolean interrupted = false;
  AsyncAppender container;

    
  Dispatcher(org.apache.log4j.helpers.BoundedFIFO bf, AsyncAppender container) {
    this.bf = bf;
    this.container = container;
    this.aai = container.aai;

    
    
    this.setDaemon(true);

    
    this.setPriority(Thread.MIN_PRIORITY);
    this.setName(""Dispatcher-"" + getName());

    
    
    
  }

  void close() {
    synchronized (bf) {
      interrupted = true;

      
      
      if (bf.length() == 0) {
        bf.notify();
      }
    }
  }

  
  public void run() {
    
    LoggingEvent event;

    while (true) {
      synchronized (bf) {
        if (bf.length() == 0) {
          
          if (interrupted) {
            
            break;
          }

          try {
            
            bf.wait();
          } catch (InterruptedException e) {
            break;
          }
        }

        event = bf.get();

        if (bf.wasFull()) {
          
          bf.notify();
        }
      }

      
      synchronized (container.aai) {
        if ((aai != null) && (event != null)) {
          aai.appendLoopOnAppenders(event);
        }
      }
    }

    
    
    aai.removeAllAppenders();
  }
}
"
log4j,1.2,org.apache.log4j.spi.Filter,3,1,3,8,4,3,6,2,3,1.5,11,0.0,1,0.0,0.666666667,0,0,1.333333333,1,0.6667,4,"

package org.apache.log4j.spi;




public abstract class Filter implements OptionHandler {

  
  public Filter next;

  
  public static final int DENY    = -1;
  
  
  public static final int NEUTRAL = 0;

  
  public static final int ACCEPT  = 1;


  
  public
  void activateOptions() {
  }



  
  abstract
  public
  int decide(LoggingEvent event);

   
  public void setNext(Filter next) {
    this.next = next;
  }
 
   
  public Filter getNext() {
        return next;
  }

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.LogTableModel,2,3,0,0,3,1,0,0,2,2.0,9,0.0,0,0.98,0.833333333,0,0,3.5,1,0.5,3,"
package org.apache.log4j.lf5.viewer;

import javax.swing.table.DefaultTableModel;





public class LogTableModel extends DefaultTableModel {
  private static final long serialVersionUID = 3593300685868700894L;
  
  
  

  
  
  

  
  
  

  
  
  

  public LogTableModel(Object[] colNames, int numRows) {
    super(colNames, numRows);
  }

  
  
  

  public boolean isCellEditable(int row, int column) {
    return (false);
  }
  
  
  

  
  
  

  
  
  

}






"
log4j,1.2,org.apache.log4j.helpers.FormattingInfo,3,1,0,10,10,0,9,1,1,0.0,49,0.0,0,0.0,1.0,0,0,14.33333333,1,0.6667,2,"

package org.apache.log4j.helpers;



public class FormattingInfo {
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;

  void reset() {
    min = -1;
    max = 0x7FFFFFFF;
    leftAlign = false;      
  }

  void dump() {
    LogLog.debug(""min=""+min+"", max=""+max+"", leftAlign=""+leftAlign);
  }
}
 
"
log4j,1.2,org.apache.log4j.net.SocketAppender,20,2,0,8,43,82,3,6,16,0.837320574,334,0.181818182,1,0.514285714,0.2,1,2,15.15,6,1.35,7,"



package org.apache.log4j.net;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.InterruptedIOException;
import java.net.InetAddress;
import java.net.Socket;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;



public class SocketAppender extends AppenderSkeleton {

  
  static public final int DEFAULT_PORT                 = 4560;

  
  static final int DEFAULT_RECONNECTION_DELAY   = 30000;

  
  String remoteHost;

  
  public static final String ZONE = ""_log4j_obj_tcpconnect_appender.local."";

  InetAddress address;
  int port = DEFAULT_PORT;
  ObjectOutputStream oos;
  int reconnectionDelay = DEFAULT_RECONNECTION_DELAY;
  boolean locationInfo = false;
  private String application;

  private Connector connector;

  int counter = 0;

  
  
  private static final int RESET_FREQUENCY = 1;
  private boolean advertiseViaMulticastDNS;
  private ZeroConfSupport zeroConf;

  public SocketAppender() {
  }

  
  public SocketAppender(InetAddress address, int port) {
    this.address = address;
    this.remoteHost = address.getHostName();
    this.port = port;
    connect(address, port);
  }

  
  public SocketAppender(String host, int port) {
    this.port = port;
    this.address = getAddressByName(host);
    this.remoteHost = host;
    connect(address, port);
  }

  
  public void activateOptions() {
    if (advertiseViaMulticastDNS) {
      zeroConf = new ZeroConfSupport(ZONE, port, getName());
      zeroConf.advertise();
    }
    connect(address, port);
  }

  
  synchronized public void close() {
    if(closed)
      return;

    this.closed = true;
    if (advertiseViaMulticastDNS) {
      zeroConf.unadvertise();
    }

    cleanUp();
  }

  
  public void cleanUp() {
    if(oos != null) {
      try {
	oos.close();
      } catch(IOException e) {
          if (e instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	      LogLog.error(""Could not close oos."", e);
      }
      oos = null;
    }
    if(connector != null) {
      
      connector.interrupted = true;
      connector = null;  
    }
  }

  void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      
      cleanUp();
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    } catch(IOException e) {
      if (e instanceof InterruptedIOException) {
          Thread.currentThread().interrupt();
      }
      String msg = ""Could not connect to remote log4j server at [""
	+address.getHostName()+""]."";
      if(reconnectionDelay > 0) {
        msg += "" We will try again later."";
	fireConnector(); 
      } else {
          msg += "" We are not retrying."";
          errorHandler.error(msg, e, ErrorCode.GENERIC_FAILURE);
      } 
      LogLog.error(msg);
    }
  }


  public void append(LoggingEvent event) {
    if(event == null)
      return;

    if(address==null) {
      errorHandler.error(""No remote host is set for SocketAppender named \""""+
			this.name+""\""."");
      return;
    }

    if(oos != null) {
      try {
    	 
	if(locationInfo) {
	   event.getLocationInformation();
	}
    if (application != null) {
        event.setProperty(""application"", application);
    }
    event.getNDC();
    event.getThreadName();
    event.getMDCCopy();
    event.getRenderedMessage();
    event.getThrowableStrRep();
    
	oos.writeObject(event);
	
	oos.flush();
	if(++counter >= RESET_FREQUENCY) {
	  counter = 0;
	  
	  
	  
	  oos.reset();
	}
      } catch(IOException e) {
          if (e instanceof InterruptedIOException) {
              Thread.currentThread().interrupt();
          }
	      oos = null;
	      LogLog.warn(""Detected problem with connection: ""+e);
	      if(reconnectionDelay > 0) {
	         fireConnector();
	      } else {
	         errorHandler.error(""Detected problem with connection, not reconnecting."", e,
	               ErrorCode.GENERIC_FAILURE);
	      }
      }
    }
  }

  public void setAdvertiseViaMulticastDNS(boolean advertiseViaMulticastDNS) {
    this.advertiseViaMulticastDNS = advertiseViaMulticastDNS;
  }

  public boolean isAdvertiseViaMulticastDNS() {
    return advertiseViaMulticastDNS;
  }

  void fireConnector() {
    if(connector == null) {
      LogLog.debug(""Starting a new connector thread."");
      connector = new Connector();
      connector.setDaemon(true);
      connector.setPriority(Thread.MIN_PRIORITY);
      connector.start();
    }
  }

  static
  InetAddress getAddressByName(String host) {
    try {
      return InetAddress.getByName(host);
    } catch(Exception e) {
      if (e instanceof InterruptedIOException || e instanceof InterruptedException) {
          Thread.currentThread().interrupt();
      }
      LogLog.error(""Could not find address of [""+host+""]."", e);
      return null;
    }
  }

  
  public boolean requiresLayout() {
    return false;
  }

  
  public void setRemoteHost(String host) {
    address = getAddressByName(host);
    remoteHost = host;
  }

  
  public String getRemoteHost() {
    return remoteHost;
  }

  
  public void setPort(int port) {
    this.port = port;
  }

  
  public int getPort() {
    return port;
  }

  
  public void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }

  
  public boolean getLocationInfo() {
    return locationInfo;
  }

  
  public void setApplication(String lapp) {
    this.application = lapp;
  }

  
  public String getApplication() {
    return application;
  }

  
  public void setReconnectionDelay(int delay) {
    this.reconnectionDelay = delay;
  }

  
  public int getReconnectionDelay() {
    return reconnectionDelay;
  }

  
  class Connector extends Thread {

    boolean interrupted = false;

    public
    void run() {
      Socket socket;
      while(!interrupted) {
	try {
	  sleep(reconnectionDelay);
	  LogLog.debug(""Attempting connection to ""+address.getHostName());
	  socket = new Socket(address, port);
	  synchronized(this) {
	    oos = new ObjectOutputStream(socket.getOutputStream());
	    connector = null;
	    LogLog.debug(""Connection established. Exiting connector thread."");
	    break;
	  }
	} catch(InterruptedException e) {
	  LogLog.debug(""Connector interrupted. Leaving loop."");
	  return;
	} catch(java.net.ConnectException e) {
	  LogLog.debug(""Remote host ""+address.getHostName()
		       +"" refused connection."");
	} catch(IOException e) {
        if (e instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }
	    LogLog.debug(""Could not connect to "" + address.getHostName()+
		       "". Exception is "" + e);
	}
      }
      
    }

    
  }

}
"
log4j,1.2,org.apache.log4j.lf5.viewer.categoryexplorer.CategoryNodeEditor,18,2,0,14,64,131,10,12,3,0.894117647,386,1.0,3,0.46875,0.293650794,0,0,20.16666667,3,1.2778,2,"
package org.apache.log4j.lf5.viewer.categoryexplorer;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Enumeration;

import javax.swing.JCheckBox;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.tree.TreePath;





public class CategoryNodeEditor extends CategoryAbstractCellEditor {
  
  
  

  
  
  
  protected CategoryNodeEditorRenderer _renderer;
  protected CategoryNode _lastEditedNode;
  protected JCheckBox _checkBox;
  protected CategoryExplorerModel _categoryModel;
  protected JTree _tree;

  
  
  

  
  
  

  public CategoryNodeEditor(CategoryExplorerModel model) {
    _renderer = new CategoryNodeEditorRenderer();
    _checkBox = _renderer.getCheckBox();
    _categoryModel = model;

    _checkBox.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        _categoryModel.update(_lastEditedNode, _checkBox.isSelected());
        stopCellEditing();
      }
    });

    _renderer.addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent e) {
        if ((e.getModifiers() & MouseEvent.BUTTON3_MASK) != 0) {
          showPopup(_lastEditedNode, e.getX(), e.getY());
        }
        stopCellEditing();
      }
    });
  }

  
  
  

  public Component getTreeCellEditorComponent(JTree tree, Object value,
      boolean selected, boolean expanded,
      boolean leaf, int row) {
    _lastEditedNode = (CategoryNode) value;
    _tree = tree;

    return _renderer.getTreeCellRendererComponent(tree,
        value, selected, expanded,
        leaf, row, true);
    
  }

  public Object getCellEditorValue() {
    return _lastEditedNode.getUserObject();
  }
  
  
  

  protected JMenuItem createPropertiesMenuItem(final CategoryNode node) {
    JMenuItem result = new JMenuItem(""Properties"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        showPropertiesDialog(node);
      }
    });
    return result;
  }

  protected void showPropertiesDialog(CategoryNode node) {
    JOptionPane.showMessageDialog(
        _tree,
        getDisplayedProperties(node),
        ""Category Properties: "" + node.getTitle(),
        JOptionPane.PLAIN_MESSAGE
    );
  }

  protected Object getDisplayedProperties(CategoryNode node) {
    ArrayList result = new ArrayList();
    result.add(""Category: "" + node.getTitle());
    if (node.hasFatalRecords()) {
      result.add(""Contains at least one fatal LogRecord."");
    }
    if (node.hasFatalChildren()) {
      result.add(""Contains descendants with a fatal LogRecord."");
    }
    result.add(""LogRecords in this category alone: "" +
        node.getNumberOfContainedRecords());
    result.add(""LogRecords in descendant categories: "" +
        node.getNumberOfRecordsFromChildren());
    result.add(""LogRecords in this category including descendants: "" +
        node.getTotalNumberOfRecords());
    return result.toArray();
  }

  protected void showPopup(CategoryNode node, int x, int y) {
    JPopupMenu popup = new JPopupMenu();
    popup.setSize(150, 400);
    
    
    
    if (node.getParent() == null) {
      popup.add(createRemoveMenuItem());
      popup.addSeparator();
    }
    popup.add(createSelectDescendantsMenuItem(node));
    popup.add(createUnselectDescendantsMenuItem(node));
    popup.addSeparator();
    popup.add(createExpandMenuItem(node));
    popup.add(createCollapseMenuItem(node));
    popup.addSeparator();
    popup.add(createPropertiesMenuItem(node));
    popup.show(_renderer, x, y);
  }

  protected JMenuItem createSelectDescendantsMenuItem(final CategoryNode node) {
    JMenuItem selectDescendants =
        new JMenuItem(""Select All Descendant Categories"");
    selectDescendants.addActionListener(
        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _categoryModel.setDescendantSelection(node, true);
          }
        }
    );
    return selectDescendants;
  }

  protected JMenuItem createUnselectDescendantsMenuItem(final CategoryNode node) {
    JMenuItem unselectDescendants =
        new JMenuItem(""Deselect All Descendant Categories"");
    unselectDescendants.addActionListener(

        new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            _categoryModel.setDescendantSelection(node, false);
          }
        }

    );
    return unselectDescendants;
  }

  protected JMenuItem createExpandMenuItem(final CategoryNode node) {
    JMenuItem result = new JMenuItem(""Expand All Descendant Categories"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        expandDescendants(node);
      }
    });
    return result;
  }

  protected JMenuItem createCollapseMenuItem(final CategoryNode node) {
    JMenuItem result = new JMenuItem(""Collapse All Descendant Categories"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        collapseDescendants(node);
      }
    });
    return result;
  }

  
  protected JMenuItem createRemoveMenuItem() {
    JMenuItem result = new JMenuItem(""Remove All Empty Categories"");
    result.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        while (removeUnusedNodes() > 0) ;
      }
    });
    return result;
  }

  protected void expandDescendants(CategoryNode node) {
    Enumeration descendants = node.depthFirstEnumeration();
    CategoryNode current;
    while (descendants.hasMoreElements()) {
      current = (CategoryNode) descendants.nextElement();
      expand(current);
    }
  }

  protected void collapseDescendants(CategoryNode node) {
    Enumeration descendants = node.depthFirstEnumeration();
    CategoryNode current;
    while (descendants.hasMoreElements()) {
      current = (CategoryNode) descendants.nextElement();
      collapse(current);
    }
  }

  
  protected int removeUnusedNodes() {
    int count = 0;
    CategoryNode root = _categoryModel.getRootCategoryNode();
    Enumeration enumeration = root.depthFirstEnumeration();
    while (enumeration.hasMoreElements()) {
      CategoryNode node = (CategoryNode) enumeration.nextElement();
      if (node.isLeaf() && node.getNumberOfContainedRecords() == 0
          && node.getParent() != null) {
        _categoryModel.removeNodeFromParent(node);
        count++;
      }
    }

    return count;
  }

  protected void expand(CategoryNode node) {
    _tree.expandPath(getTreePath(node));
  }

  protected TreePath getTreePath(CategoryNode node) {
    return new TreePath(node.getPath());
  }

  protected void collapse(CategoryNode node) {
    _tree.collapsePath(getTreePath(node));
  }

  
  
  

  
  
  

}
"
log4j,1.2,org.apache.log4j.net.SimpleSocketServer,6,1,0,5,30,9,0,5,2,0.666666667,144,0.0,1,0.0,0.333333333,0,0,22.5,2,1.0,3,"

package org.apache.log4j.net;

import java.net.ServerSocket;
import java.net.Socket;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;



public class SimpleSocketServer  {

  static Logger cat = Logger.getLogger(SimpleSocketServer.class);

  static int port;

  public
  static
  void main(String argv[]) {
    if(argv.length == 2) {
      init(argv[0], argv[1]);
    } else {
      usage(""Wrong number of arguments."");
    }
    
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	cat.info(""Connected to client at "" + socket.getInetAddress());
	cat.info(""Starting new socket node."");
	new Thread(new SocketNode(socket,
				  LogManager.getLoggerRepository()),""SimpleSocketServer-"" + port).start();
      }
    } catch(Exception e) {
      e.printStackTrace();
    }
  }


  static void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SimpleSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }

  static void init(String portStr, String configFile) {
    try {
      port = Integer.parseInt(portStr);
    } catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
   
    if(configFile.endsWith("".xml"")) {
      DOMConfigurator.configure(configFile);
    } else {
      PropertyConfigurator.configure(configFile);
    }
  }
}
"
log4j,1.2,org.apache.log4j.net.JMSAppender,13,2,0,5,35,48,0,5,11,0.791666667,259,0.0,0,0.6,0.292307692,1,2,18.46153846,5,1.5385,3,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;

import javax.jms.JMSException;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.Topic;
import javax.jms.TopicConnection;
import javax.jms.TopicConnectionFactory;
import javax.jms.TopicPublisher;
import javax.jms.TopicSession;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
import java.util.Properties;


public class JMSAppender extends AppenderSkeleton {

  String securityPrincipalName;
  String securityCredentials;
  String initialContextFactoryName;
  String urlPkgPrefixes;
  String providerURL;
  String topicBindingName;
  String tcfBindingName;
  String userName;
  String password;
  boolean locationInfo;

  TopicConnection  topicConnection;
  TopicSession topicSession;
  TopicPublisher  topicPublisher;

  public
  JMSAppender() {
  }

  
  public
  void setTopicConnectionFactoryBindingName(String tcfBindingName) {
    this.tcfBindingName = tcfBindingName;
  }

  
  public
  String getTopicConnectionFactoryBindingName() {
    return tcfBindingName;
  }

  
  public
  void setTopicBindingName(String topicBindingName) {
    this.topicBindingName = topicBindingName;
  }

  
  public
  String getTopicBindingName() {
    return topicBindingName;
  }


  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  
  public void activateOptions() {
    TopicConnectionFactory  topicConnectionFactory;

    try {
      Context jndi;

      LogLog.debug(""Getting initial context."");
      if(initialContextFactoryName != null) {
	Properties env = new Properties( );
	env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactoryName);
	if(providerURL != null) {
	  env.put(Context.PROVIDER_URL, providerURL);
	} else {
	  LogLog.warn(""You have set InitialContextFactoryName option but not the ""
		     +""ProviderURL. This is likely to cause problems."");
	}
	if(urlPkgPrefixes != null) {
	  env.put(Context.URL_PKG_PREFIXES, urlPkgPrefixes);
	}
	
	if(securityPrincipalName != null) {
	  env.put(Context.SECURITY_PRINCIPAL, securityPrincipalName);
	  if(securityCredentials != null) {
	    env.put(Context.SECURITY_CREDENTIALS, securityCredentials);
	  } else {
	    LogLog.warn(""You have set SecurityPrincipalName option but not the ""
			+""SecurityCredentials. This is likely to cause problems."");
	  }
	}	
	jndi = new InitialContext(env);
      } else {
	jndi = new InitialContext();
      }

      LogLog.debug(""Looking up [""+tcfBindingName+""]"");
      topicConnectionFactory = (TopicConnectionFactory) lookup(jndi, tcfBindingName);
      LogLog.debug(""About to create TopicConnection."");
      if(userName != null) {
	topicConnection = topicConnectionFactory.createTopicConnection(userName, 
								       password); 
      } else {
	topicConnection = topicConnectionFactory.createTopicConnection();
      }

      LogLog.debug(""Creating TopicSession, non-transactional, ""
		   +""in AUTO_ACKNOWLEDGE mode."");
      topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);

      LogLog.debug(""Looking up topic name [""+topicBindingName+""]."");
      Topic topic = (Topic) lookup(jndi, topicBindingName);

      LogLog.debug(""Creating TopicPublisher."");
      topicPublisher = topicSession.createPublisher(topic);
      
      LogLog.debug(""Starting TopicConnection."");
      topicConnection.start();

      jndi.close();
    } catch(JMSException e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    } catch(NamingException e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    } catch(RuntimeException e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    }
  }

  protected Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }
  }

  protected boolean checkEntryConditions() {
    String fail = null;

    if(this.topicConnection == null) {
      fail = ""No TopicConnection"";
    } else if(this.topicSession == null) {
      fail = ""No TopicSession"";
    } else if(this.topicPublisher == null) {
      fail = ""No TopicPublisher"";
    }

    if(fail != null) {
      errorHandler.error(fail +"" for JMSAppender named [""+name+""]."");
      return false;
    } else {
      return true;
    }
  }

  
  public synchronized void close() {
    

    if(this.closed)
      return;

    LogLog.debug(""Closing appender [""+name+""]."");
    this.closed = true;

    try {
      if(topicSession != null)
	topicSession.close();
      if(topicConnection != null)
	topicConnection.close();
    } catch(JMSException e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);
    } catch(RuntimeException e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);
    }
    
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }

  
  public void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }

    try {
      ObjectMessage msg = topicSession.createObjectMessage();
      if(locationInfo) {
	event.getLocationInformation();
      }
      msg.setObject(event);
      topicPublisher.publish(msg);
    } catch(JMSException e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e,
			 ErrorCode.GENERIC_FAILURE);
    } catch(RuntimeException e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e,
			 ErrorCode.GENERIC_FAILURE);
    }
  }

  
  public String getInitialContextFactoryName() {
    return initialContextFactoryName;    
  }
  
  
  public void setInitialContextFactoryName(String initialContextFactoryName) {
    this.initialContextFactoryName = initialContextFactoryName;
  }

  public String getProviderURL() {
    return providerURL;    
  }

  public void setProviderURL(String providerURL) {
    this.providerURL = providerURL;
  }

  String getURLPkgPrefixes( ) {
    return urlPkgPrefixes;
  }

  public void setURLPkgPrefixes(String urlPkgPrefixes ) {
    this.urlPkgPrefixes = urlPkgPrefixes;
  }
  
  public String getSecurityCredentials() {
    return securityCredentials;    
  }

  public void setSecurityCredentials(String securityCredentials) {
    this.securityCredentials = securityCredentials;
  }
  
  
  public String getSecurityPrincipalName() {
    return securityPrincipalName;    
  }

  public void setSecurityPrincipalName(String securityPrincipalName) {
    this.securityPrincipalName = securityPrincipalName;
  }

  public String getUserName() {
    return userName;    
  }

  
  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;    
  }

  
  public void setPassword(String password) {
    this.password = password;
  }


  
  public void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }

  
  protected TopicConnection  getTopicConnection() {
    return topicConnection;
  }

  
  protected TopicSession  getTopicSession() {
    return topicSession;
  }

  
  protected TopicPublisher  getTopicPublisher() {
    return topicPublisher;
  }
  
  
  public boolean requiresLayout() {
    return false;
  }
}
"
log4j,1.2,org.apache.log4j.helpers.NullEnumeration,5,1,0,1,7,8,1,0,3,0.75,22,1.0,1,0.0,0.75,0,0,3.2,1,0.6,2,"

package org.apache.log4j.helpers;

import java.util.Enumeration;
import java.util.NoSuchElementException;


public class NullEnumeration implements Enumeration {
  private static final NullEnumeration instance = new NullEnumeration();
  
  private
  NullEnumeration() {
  }
  
  public static NullEnumeration getInstance() {
    return instance;
  }
  
  public
  boolean hasMoreElements() {
    return false;
  }
  
  public
  Object nextElement() {
    throw new NoSuchElementException();
  }
}
"
log4j,1.2,org.apache.log4j.net.SocketServer,8,1,0,10,48,6,0,10,2,0.666666667,358,0.0,3,0.0,0.257142857,0,0,42.625,3,1.75,3,"

package org.apache.log4j.net;

import java.io.File;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Hashtable;

import org.apache.log4j.Hierarchy;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.RootLogger;




public class SocketServer  {

  static String GENERIC = ""generic"";
  static String CONFIG_FILE_EXT = "".lcf"";

  static Logger cat = Logger.getLogger(SocketServer.class);
  static SocketServer server;
  static int port;

  
  Hashtable hierarchyMap;
  LoggerRepository genericHierarchy;
  File dir;

  public
  static
  void main(String argv[]) {
    if(argv.length == 3)
      init(argv[0], argv[1], argv[2]);
    else
      usage(""Wrong number of arguments."");

    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	InetAddress inetAddress =  socket.getInetAddress();
	cat.info(""Connected to client at "" + inetAddress);

	LoggerRepository h = (LoggerRepository) server.hierarchyMap.get(inetAddress);
	if(h == null) {
	  h = server.configureHierarchy(inetAddress);
	}

	cat.info(""Starting new socket node."");
	new Thread(new SocketNode(socket, h)).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }


  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SocketServer.class.getName() + "" port configFile directory"");
    System.exit(1);
  }

  static
  void init(String portStr, String configFile, String dirStr) {
    try {
      port = Integer.parseInt(portStr);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }

    PropertyConfigurator.configure(configFile);

    File dir = new File(dirStr);
    if(!dir.isDirectory()) {
      usage(""[""+dirStr+""] is not a directory."");
    }
    server = new SocketServer(dir);
  }


  public
  SocketServer(File directory) {
    this.dir = directory;
    hierarchyMap = new Hashtable(11);
  }

  
  
  LoggerRepository configureHierarchy(InetAddress inetAddress) {
    cat.info(""Locating configuration file for ""+inetAddress);
    
    
    String s = inetAddress.toString();
    int i = s.indexOf(""/"");
    if(i == -1) {
      cat.warn(""Could not parse the inetAddress [""+inetAddress+
	       ""]. Using default hierarchy."");
      return genericHierarchy();
    } else {
      String key = s.substring(0, i);

      File configFile = new File(dir, key+CONFIG_FILE_EXT);
      if(configFile.exists()) {
	Hierarchy h = new Hierarchy(new RootLogger(Level.DEBUG));
	hierarchyMap.put(inetAddress, h);

	new PropertyConfigurator().doConfigure(configFile.getAbsolutePath(), h);

	return h;
      } else {
	cat.warn(""Could not find config file [""+configFile+""]."");
	return genericHierarchy();
      }
    }
  }

  LoggerRepository  genericHierarchy() {
    if(genericHierarchy == null) {
      File f = new File(dir, GENERIC+CONFIG_FILE_EXT);
      if(f.exists()) {
	genericHierarchy = new Hierarchy(new RootLogger(Level.DEBUG));
	new PropertyConfigurator().doConfigure(f.getAbsolutePath(), genericHierarchy);
      } else {
	cat.warn(""Could not find config file [""+f+
		 ""]. Will use the default hierarchy."");
	genericHierarchy = LogManager.getLoggerRepository();
      }
    }
    return genericHierarchy;
  }
}
"
log4j,1.2,org.apache.log4j.helpers.DateLayout,11,2,1,7,27,19,1,6,11,0.911111111,198,0.555555556,0,0.444444444,0.303030303,0,0,16.18181818,7,2.0,2,"

package org.apache.log4j.helpers;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.text.FieldPosition;



abstract public class DateLayout extends Layout {

  
  public final static String NULL_DATE_FORMAT = ""NULL"";

  
  public final static String RELATIVE_TIME_DATE_FORMAT = ""RELATIVE"";

  protected FieldPosition pos = new FieldPosition(0);

  
  final static public String DATE_FORMAT_OPTION = ""DateFormat"";
  
  
  final static public String TIMEZONE_OPTION = ""TimeZone"";  

  private String timeZoneID;
  private String dateFormatOption;  

  protected DateFormat dateFormat;
  protected Date date = new Date();

  
  public
  String[] getOptionStrings() {
    return new String[] {DATE_FORMAT_OPTION, TIMEZONE_OPTION};
  }

  
  public
  void setOption(String option, String value) {
    if(option.equalsIgnoreCase(DATE_FORMAT_OPTION)) {
      dateFormatOption = value.toUpperCase();
    } else if(option.equalsIgnoreCase(TIMEZONE_OPTION)) {
      timeZoneID = value;
    }
  }
  

  
  public
  void setDateFormat(String dateFormat) {
    if (dateFormat != null) {
        dateFormatOption = dateFormat;
    }
    setDateFormat(dateFormatOption, TimeZone.getDefault());
  }

  
  public
  String getDateFormat() {
    return dateFormatOption;
  }
  
  
  public
  void setTimeZone(String timeZone) {
    this.timeZoneID = timeZone;
  }
  
  
  public
  String getTimeZone() {
    return timeZoneID;
  }
  
  public
  void activateOptions() {
    setDateFormat(dateFormatOption);
    if(timeZoneID != null && dateFormat != null) {
      dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneID));
    }
  }

  public
  void dateFormat(StringBuffer buf, LoggingEvent event) {
    if(dateFormat != null) {
      date.setTime(event.timeStamp);
      dateFormat.format(date, buf, this.pos);
      buf.append(' ');
    }
  }

  
  public
  void setDateFormat(DateFormat dateFormat, TimeZone timeZone) {
    this.dateFormat = dateFormat;    
    this.dateFormat.setTimeZone(timeZone);
  }
  
  
  public
  void setDateFormat(String dateFormatType, TimeZone timeZone) {
    if(dateFormatType == null) {
      this.dateFormat = null;
      return;
    } 

    if(dateFormatType.equalsIgnoreCase(NULL_DATE_FORMAT)) {
      this.dateFormat = null;
    } else if (dateFormatType.equalsIgnoreCase(RELATIVE_TIME_DATE_FORMAT)) {
      this.dateFormat =  new RelativeTimeDateFormat();
    } else if(dateFormatType.equalsIgnoreCase(
                             AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
      this.dateFormat =  new AbsoluteTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                        AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
      this.dateFormat =  new DateTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
      this.dateFormat =  new ISO8601DateFormat(timeZone);
    } else {
      this.dateFormat = new SimpleDateFormat(dateFormatType);
      this.dateFormat.setTimeZone(timeZone);
    }
  }
}
"
log4j,1.2,org.apache.log4j.xml.SAXErrorHandler,4,1,0,2,17,6,1,1,4,2.0,53,0.0,0,0.0,0.875,0,0,12.25,1,0.75,3,"

package org.apache.log4j.xml;

import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException;
import org.apache.log4j.helpers.LogLog;

public class SAXErrorHandler implements ErrorHandler {

  public
  void error(final SAXParseException ex) {
    emitMessage(""Continuable parsing error "", ex);
  }
  
  public
  void fatalError(final SAXParseException ex) {
    emitMessage(""Fatal parsing error "", ex);
  }
   
  public
  void warning(final SAXParseException ex) {
    emitMessage(""Parsing warning "", ex);
  }
  
  private static void emitMessage(final String msg, final SAXParseException ex) {
    LogLog.warn(msg +ex.getLineNumber()+"" and column ""
		 +ex.getColumnNumber());
    LogLog.warn(ex.getMessage(), ex.getException());
  }
}
"
