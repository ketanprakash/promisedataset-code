name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
log4j,1.1,org.apache.log4j.xml.examples.XCategory,14,2,0,9,33,53,1,9,11,0.876923077,188,0.4,1,0.796610169,0.442307692,1,3,12.07142857,3,1.6429,1,"

package org.apache.log4j.xml.examples;


import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.helpers.LogLog;

import org.apache.log4j.xml.examples.XPriority;


public class XCategory extends Category implements OptionHandler {

  final private static String FQCN = XCategory.class.getName();

  
  private static XFactory factory = new XFactory();
  
  public static final String SUFFIX_OPTION = ""Suffix"";

  String suffix = """";

  
  protected XCategory(String name) {
    super(name);
  }

  
  public
  void activateOptions() {
  }

  
  public 
  void debug(String message) {
    super.debug(message + "" "" + suffix);
  }

  
  public 
  static
  Category getInstance(String name) {
    return Category.getInstance(name, factory); 
  }


  
  public 
  static
  Category getInstance(Class clazz) {
    return getInstance(clazz.getName(), factory); 
  }

 
  public
  String[] getOptionStrings() {
    return (new String[] {SUFFIX_OPTION});
  }


  
  public
  void lethal(String message, Throwable t) { 
    
    if(hierarchy.isDisabled(XPriority.LETHAL_INT)) 
      return;
    if(XPriority.LETHAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.LETHAL, message, t);
  }

  
  public
  void lethal(String message) { 
    
    if(hierarchy.isDisabled(XPriority.LETHAL_INT)) 
      return;
    if(XPriority.LETHAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.LETHAL, message, null);
  }


 
  public
  void setOption(String option, String value) {
    if(option == null) {
      return;
    }
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      this.suffix = value;
      LogLog.debug(""Setting suffix to""+suffix);
    }
  }
  
  public
  String getOption(String option) {
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      return this.suffix;
    }
    return null;
  }

  
  public
  void trace(String message, Throwable t) { 
    
    if(hierarchy.isDisabled(XPriority.TRACE_INT))
      return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.TRACE, message, t);
  }

  
  public
  void trace(String message) { 
    
    if(hierarchy.isDisabled(XPriority.TRACE_INT))
      return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(FQCN, this, XPriority.TRACE, 
				     message, null));
  }



  
  
  public static class XFactory implements CategoryFactory {
    
    public XFactory() {
    }

    public
    Category makeNewCategoryInstance(String name) {
      return new XCategory(name);
    }
  }
}


"
log4j,1.1,org.apache.log4j.helpers.DateLayout,11,2,0,6,27,19,0,6,11,0.911111111,199,0.555555556,0,0.444444444,0.303030303,0,0,16.27272727,7,2.0,1,"

package org.apache.log4j.helpers;

import org.apache.log4j.Layout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.text.FieldPosition;



abstract public class DateLayout extends Layout {

  
  public final static String NULL_DATE_FORMAT = ""NULL"";

  
  public final static String RELATIVE_TIME_DATE_FORMAT = ""RELATIVE"";

  protected FieldPosition pos = new FieldPosition(0);

  
  final static public String DATE_FORMAT_OPTION = ""DateFormat"";
  
  
  final static public String TIMEZONE_OPTION = ""TimeZone"";  

  private String timeZoneID;
  private String dateFormatOption;  

  protected DateFormat dateFormat;
  protected Date date = new Date();

  
  public
  String[] getOptionStrings() {
    return new String[] {DATE_FORMAT_OPTION, TIMEZONE_OPTION};
  }

  
  public
  void setOption(String option, String value) {
    if(option.equalsIgnoreCase(DATE_FORMAT_OPTION)) {
      dateFormatOption = value.toUpperCase();
    } else if(option.equalsIgnoreCase(TIMEZONE_OPTION)) {
      timeZoneID = value;
    }
  }
  

  
  public
  void setDateFormat(String dateFormat) {
    if (dateFormat != null) {
        dateFormatOption = dateFormat;
    }
    setDateFormat(dateFormatOption, TimeZone.getDefault());
  }

  
  public
  String getDateFormat() {
    return dateFormatOption;
  }
  
  
  public
  void setTimeZone(String timeZone) {
    this.timeZoneID = timeZone;
  }
  
  
  public
  String getTimeZone() {
    return timeZoneID;
  }
  
  public
  void activateOptions() {
    setDateFormat(dateFormatOption);
    if(timeZoneID != null && dateFormat != null) {
      dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneID));
    }
  }

  public
  void dateFormat(StringBuffer buf, LoggingEvent event) {
    if(dateFormat != null) {
      date.setTime(event.timeStamp);
      dateFormat.format(date, buf, this.pos);
      buf.append(' ');
    }
  }

  
  public
  void setDateFormat(DateFormat dateFormat, TimeZone timeZone) {
    this.dateFormat = dateFormat;    
    this.dateFormat.setTimeZone(timeZone);
  }
  
  
  public
  void setDateFormat(String dateFormatType, TimeZone timeZone) {
    if(dateFormatType == null) {
      this.dateFormat = null;
      return;
    } 

    if(dateFormatType.equalsIgnoreCase(NULL_DATE_FORMAT)) {
      this.dateFormat = null;
    } else if (dateFormatType.equalsIgnoreCase(RELATIVE_TIME_DATE_FORMAT)) {
      this.dateFormat =  new RelativeTimeDateFormat();
    } else if(dateFormatType.equalsIgnoreCase(
                             AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
      this.dateFormat =  new AbsoluteTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                        AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
      this.dateFormat =  new DateTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
      this.dateFormat =  new ISO8601DateFormat(timeZone);
    } else {
      this.dateFormat = new SimpleDateFormat(dateFormatType);
      this.dateFormat.setTimeZone(timeZone);
    }
  }
}
"
log4j,1.1,org.apache.log4j.net.test.SocketMin,8,1,0,7,42,14,0,7,2,0.75,308,0.0,2,0.0,0.238095238,0,0,37.0,4,1.5,0,"

package org.apache.log4j.net.test;

import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
import java.io.InputStreamReader;

public class SocketMin {
  
  static Category cat = Category.getInstance(SyslogMin.class.getName());
  static SocketAppender s;

  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    
    NDC.push(""some context"");
    if(argv[2].equals(""true""))
      loop();
    else
      test();
    
    s.close();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SocketMin.class 
		       + "" host port true|false"");
    System.exit(1);
  }

  static
  void init(String host, String portStr) {
    Category root = Category.getRoot();
    BasicConfigurator.configure();
    try {
      int port   = Integer.parseInt(portStr);
      cat.info(""Creating socket appender (""+host+"",""+port+"")."");
      s = new SocketAppender(host, port);
      s.setName(""S"");
      root.addAppender(s);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    catch(Exception e) {
      System.err.println(""Could not start!"");
      e.printStackTrace();
      System.exit(1);
    }
  }

  static
  void loop() {
    Category root = Category.getRoot();
    InputStreamReader in = new InputStreamReader(System.in);
    System.out.println(""Type 'q' to quit"");
    int i;
    int k = 0;
    while (true) {
      cat.debug(""Message "" + k++);
      cat.info(""Message "" + k++);
      cat.warn(""Message "" + k++);
      cat.error(""Message "" + k++, new Exception(""Just testing""));
      try {i = in.read(); }
      catch(Exception e) { return; }
      if(i == -1) break;
      if(i == 'q') break;
      if(i == 'r') {
	System.out.println(""Removing appender S"");
	root.removeAppender(""S"");
      }
    }
  }

  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
log4j,1.1,org.apache.log4j.StressCategory,13,1,0,4,40,8,0,4,2,0.697916667,516,0.0,4,0.0,0.15,0,0,38.07692308,7,2.7692,2,"

package org.apache.log4j;


import org.apache.log4j.Priority;
import org.apache.log4j.Category;
import java.util.Random;



class StressCategory {

  static Priority[] priority = new Priority[] {Priority.DEBUG, 
					       Priority.INFO, 
					       Priority.WARN,
					       Priority.ERROR,
					       Priority.FATAL};

  static Priority defaultPriority = Category.getRoot().getPriority();
  
  static int LENGTH;
  static String[] names;
  static Category[] cat;
  static CT[] ct;

  static Random random = new Random(10);

  public static void main(String[] args) {
    
    LENGTH = args.length;

    if(LENGTH == 0) {
      System.err.println( ""Usage: java "" + StressCategory.class.getName() +
			  "" name1 ... nameN\n."");      
      System.exit(1);
    }
    if(LENGTH >= 7) {
      System.err.println(
        ""This stress test suffers from combinatorial explosion.\n""+
        ""Invoking with seven arguments takes about 90 minutes even on fast machines"");
    }

    names = new String[LENGTH];
    for(int i=0; i < LENGTH; i++) {
      names[i] = args[i];
    }    
    cat = new Category[LENGTH];
    ct = new CT[LENGTH]; 


    permute(0); 

    
  }

  
  
  static
  void permute(int n) {
    if(n == LENGTH)
      createLoop(0);
    else
      for(int i = n; i < LENGTH; i++) {
	swap(names, n, i);
	permute(n+1);
	swap(names, n, i);	
      }
  }

  static
  void swap(String[] names, int i, int j) {
    String t = names[i];
    names[i] = names[j];
    names[j] = t;
  }
  
  public
  static
  void permutationDump() {
    System.out.print(""Current permutation is - "");
    for(int i = 0; i < LENGTH; i++) {
      System.out.print(names[i] + "" "");
    }
    System.out.println();
  }


  
  

  static
  void createLoop(int n) {
    if(n == LENGTH) {  
      
      for(int i = 0; i < LENGTH; i++) {
	if(ct[i] == null)
	  cat[i] = null;
	else {
	  cat[i] = Category.getInstance(ct[i].catstr);
	  cat[i].setPriority(ct[i].priority);
	}
      }
      test();
      
      Category.defaultHierarchy.clear();
    }
    else {      
      ct[n]  = null;
      createLoop(n+1);  

      ct[n]  = new CT(names[n], null);
      createLoop(n+1);  
      
      int r = random.nextInt(); if(r < 0) r = -r;
      ct[n]  = new CT(names[n], priority[r%5]);
      createLoop(n+1);
    }
  }


  static
  void test() {    
    
    
    

    for(int i = 0; i < LENGTH; i++) {
      if(!checkCorrectness(i)) {
	System.out.println(""Failed stress test."");
	permutationDump();
	
	
	ctDump();
	catDump();
	System.exit(1);
      }
    }
  }
  
  static
  void ctDump() {
    for(int j = 0; j < LENGTH; j++) {
       if(ct[j] != null) 
	    System.out.println(""ct ["" + j + ""] = (""+ct[j].catstr+"","" + 
			       ct[j].priority + "")"");
       else 
	 System.out.println(""ct ["" + j + ""] = undefined"");
    }
  }
  
  static
  void catDump() {
    for(int j = 0; j < LENGTH; j++) {
      if(cat[j] != null)
	System.out.println(""cat["" + j + ""] = ("" + cat[j].name + "","" +
			   cat[j].getPriority() + "")"");
      else
	System.out.println(""cat["" + j + ""] = undefined""); 
    }
  }

  
  
  
  
  
  
  
  
  
  
  static
  boolean checkCorrectness(int i) {
    CT localCT = ct[i];

    
    if(localCT == null) 
      return true;
    
    
    Priority expected = getExpectedPrioriy(localCT);

			    
    Priority purported = cat[i].getChainedPriority();

    if(expected != purported) {
      System.out.println(""Expected priority for "" + localCT.catstr + "" is "" +
		       expected);
      System.out.println(""Purported priority for ""+ cat[i].name + "" is ""+purported);
      return false;
    }
    return true;
      
  }

  static
  Priority getExpectedPrioriy(CT ctParam) {
    Priority priority = ctParam.priority;
    if(priority != null) 
      return priority;

    
    String catstr = ctParam.catstr;    
    
    for(int i = catstr.lastIndexOf('.', catstr.length()-1); i >= 0; 
	                              i = catstr.lastIndexOf('.', i-1))  {
      String substr = catstr.substring(0, i);

      
      for(int j = 0; j < LENGTH; j++) {	
	if(ct[j] != null && substr.equals(ct[j].catstr)) {
	  Priority p = ct[j].priority;
	  if(p != null) 
	    return p;	  
	}
      }
    }
    return defaultPriority;
  }

  

  static class CT {
    public String   catstr;
    public Priority priority;

    CT(String catstr,  Priority priority) {
      this.catstr = catstr;
      this.priority = priority;
    }
  }
}
"
log4j,1.1,org.apache.log4j.test.DefaultInit,5,1,0,1,14,8,0,1,2,0.875,45,0.0,1,0.0,0.333333333,0,0,7.6,1,0.6,0,"
package org.apache.log4j.test;

import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
	
public class DefaultInit {

  static Category cat = Category.getInstance(DefaultInit.class.getName());

  public static void main( String[] argv) {

    cat.debug(""Hello world"");
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.DefaultInit "");
    System.exit(1);
  }

}
"
log4j,1.1,org.apache.log4j.spi.Filter,5,1,0,4,6,10,2,2,5,1.25,13,0.0,1,0.0,0.466666667,0,0,0.8,1,0.8,0,"

package org.apache.log4j.spi;

import org.apache.log4j.spi.LoggingEvent;



public abstract class Filter implements OptionHandler {

  
  public Filter next;

  
  public static final int DENY    = -1;
  
  
  public static final int NEUTRAL = 0;

  
  public static final int ACCEPT  = 1;


  
  public
  void activateOptions() {
  }



  
  abstract
  public
  int decide(LoggingEvent event);

}
"
log4j,1.1,org.apache.log4j.helpers.FormattingInfo,3,1,0,9,10,0,8,1,1,0.0,49,0.0,0,0.0,1.0,0,0,14.33333333,1,0.6667,0,"

package org.apache.log4j.helpers;



public class FormattingInfo {
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;

  void reset() {
    min = -1;
    max = 0x7FFFFFFF;
    leftAlign = false;      
  }

  void dump() {
    LogLog.debug(""min=""+min+"", max=""+max+"", leftAlign=""+leftAlign);
  }
}
 
"
log4j,1.1,org.apache.log4j.spi.Configurator,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"

package org.apache.log4j.spi;

import org.apache.log4j.Hierarchy;
import java.net.URL;


public interface Configurator {
  
  void doConfigure(URL url, Hierarchy hierarchy);
}
"
log4j,1.1,org.apache.log4j.or.DefaultRenderer,2,1,0,2,4,1,1,1,1,2.0,8,0.0,0,0.0,0.75,0,0,3.0,1,0.5,0,"

package org.apache.log4j.or;


class DefaultRenderer implements ObjectRenderer {
  
  DefaultRenderer() {
  }

  
  public
  String doRender(Object o) {
    return o.toString();
  }
}  
"
log4j,1.1,org.apache.log4j.test.StressNDC,9,2,0,4,37,8,0,4,7,0.822916667,314,0.0,1,0.897058824,0.21875,0,0,32.55555556,7,2.0,0,"


package org.apache.log4j.test;


import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;


import java.util.Random;
import java.util.Stack;


public class StressNDC extends Thread {

  static Category root = Category.getRoot();  

  static Random random = new Random(101);

  static final int LOOP_LENGTH = 24;
  static final int PUSH_MISS = LOOP_LENGTH/2;      
  static final int POP_MISS = PUSH_MISS*2;    

  static final int BRANCHING_FACTOR = 4 + 1; 
  
  static int maxThreads;  
  static int msgCounter = 0;
  static int threadCounter = 0;  

  static double LOG_2 = Math.log(2);

  static Object lock = new Object();

  
  public 
  static 
  void main(String args[]) {
    root.setPriority(Priority.DEBUG);
    BasicConfigurator.configure();

    if(args.length != 1) {
      usage();
    }

    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    
    root.debug( ""push(IP=127.0.0.1)"");
    
    NDC.push(""IP=127.0.0.1"");

    while(true) {
      synchronized(lock) {
	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);

	
	try {
	  root.debug( ""About to wait for notification."");
	  lock.wait();
	  root.debug( ""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }

  static
  void usage() {
    System.err.println( ""Usage: java org.apache.log4j.test.StressNDC "" +
			""MAX_THREADS"");
    System.exit(1);
  }


  Stack parentDC;
  
  public
  StressNDC(Stack parentDC) {
    this.setName(randomID());
    this.parentDC = parentDC;
  }

  public
  void run() {
    NDC.inherit(parentDC);
    
    int loopLength = StressNDC.randomInt(LOOP_LENGTH);
    root.debug(""In run loop.debug( loopLength = ""+loopLength);

    int createIndex = loopLength/2;
      
    for(int i = 0; i <= loopLength; i++) {

      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      
      if(randomInt(PUSH_MISS) == 0) {
	String id = randomID();
	root.debug( ""push(""+id+"")""); 
	NDC.push(id);
      }      
      root.debug( ""Message number "" + StressNDC.msgCounter++);	
      if(randomInt(POP_MISS) == 0) {
	root.debug( ""pop()"");
	NDC.pop();
      }
    }    

    synchronized(lock) {
      StressNDC.threadCounter--;
      root.debug( ""Exiting run loop. "" + threadCounter);
      if(StressNDC.threadCounter <= 0) {
	root.debug( ""Notifying [main] thread."");
	lock.notify(); 
      }
    }

    
    if((loopLength % 2) == 0) {
      root.debug(""Removing NDC for this thread."");
      NDC.remove();
    }
  }

  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;

    synchronized(lock) {
      n = maxThreadsConstained(n);    
      root.debug(""Creating "" + n+ "" child StressNDC threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressNDC, threadCounter = "" + (++threadCounter));
	new StressNDC(NDC.cloneStack()).start();
      }
    }
  }

  static
  public
  int maxThreadsConstained(int a) {
    int maxAllowed = StressNDC.maxThreads - StressNDC.threadCounter;      
    return a <= maxAllowed ? a : maxAllowed;
  }

  
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }

  public
  static
  String randomID() {
    return Integer.toHexString(random.nextInt()& 0xFFFFFF);
  }
}
"
log4j,1.1,org.apache.log4j.CategoryKey,4,1,0,1,11,2,1,0,2,0.777777778,61,0.0,0,0.0,0.5,1,1,13.5,6,2.0,0,"

package org.apache.log4j;


class CategoryKey {

  String   name;  
  int hashCache;

  CategoryKey(String name) {
    this.name = name.intern();
    hashCache = name.hashCode();
  }

  final
  public  
  int hashCode() {
    return hashCache;
  }

  final
  public
  boolean equals(Object rArg) {
    if(this == rArg)
      return true;
    
    if(rArg != null && CategoryKey.class == rArg.getClass()) 
      return  name == ((CategoryKey)rArg ).name;
    else 
      return false;
  }
}
"
log4j,1.1,org.apache.log4j.nt.NTEventLogAppender,19,2,0,8,36,141,1,7,15,0.864197531,229,0.888888889,0,0.6,0.355555556,1,1,10.57894737,4,0.9474,1,"

package org.apache.log4j.nt;

import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;

import java.io.*;



public class NTEventLogAppender extends AppenderSkeleton {
  private int _handle = 0;

  
  public static final String SOURCE_OPTION = ""Source"";
  
  private String source = null;
  private String server = null;

  private static final int FATAL  = Priority.FATAL.toInt();
  private static final int ERROR  = Priority.ERROR.toInt();
  private static final int WARN   = Priority.WARN.toInt();
  private static final int INFO   = Priority.INFO.toInt();
  private static final int DEBUG  = Priority.DEBUG.toInt();
  
  public NTEventLogAppender() {
    this(null, null, null);
  }
  
  public NTEventLogAppender(String source) {
    this(null, source, null);
  }
  
  public NTEventLogAppender(String server, String source) {
    this(server, source, null);
  }
  
  public NTEventLogAppender(Layout layout) {
    this(null, null, layout);
  }
  
  public NTEventLogAppender(String source, Layout layout) {
    this(null, source, layout);
  }
  
  public NTEventLogAppender(String server, String source, Layout layout) {
    if (source == null) {
      source = ""Log4j"";
    }
    if (layout == null) {
      this.layout = new TTCCLayout();
    } else {
      this.layout = layout;
    }
    
    try {
      _handle = registerEventSource(server, source);
    } catch (Exception e) {
      e.printStackTrace();
      _handle = 0;
    }
  }

  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {SOURCE_OPTION});
  }

  
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    

    if(key.equalsIgnoreCase(SOURCE_OPTION)) {
      
      source = value.trim();
    }
  }

  public
  void close() {
    
  }

  public
  void activateOptions() {    
    if (source != null) {
      try {
	_handle = registerEventSource(server, source);
      } catch (Exception e) {
	LogLog.error(""Could not register event source."", e);
	_handle = 0;
      }
    }
  }

  
  public void append(LoggingEvent event) {

    StringBuffer sbuf = new StringBuffer();    

    sbuf.append(layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {	
	  sbuf.append(s[i]);
	}	
      }
    }
    
    int nt_category = event.priority.toInt();

    
    
    
    
    reportEvent(_handle, sbuf.toString(), nt_category);
  }
  
  
  public 
  void finalize() {
    deregisterEventSource(_handle);
    _handle = 0;
  }
  
  
  public
  void setSource(String source) {
    this.source = source.trim();
  }
  
  public
  String getSource() {
    return source;
  }
  

  public
  boolean requiresLayout() {
    return true;
  }
  
  native private int registerEventSource(String server, String source);
  native private void reportEvent(int handle, String message, int priority);
  native private void deregisterEventSource(int handle);
  
  static {
    System.loadLibrary(""NTEventLogAppender"");
  }
}   
"
log4j,1.1,org.apache.log4j.performance.NotLogging,8,1,0,6,31,22,0,6,2,0.942857143,324,0.0,7,0.0,0.285714286,0,0,38.25,5,2.0,1,"


package org.apache.log4j.performance;


import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Layout;

import org.apache.log4j.Priority;


public class NotLogging {

  static int runLength;

  final static int INITIAL_HASH_SIZE = 101; 

  static String  SHORT_MSG = ""Hello World"";

  static Category SHORT_CAT = Category.getInstance(""A0123456789"");
  static Category MEDIUM_CAT= Category.getInstance(""A0123456789.B0123456789"");
  static Category LONG_CAT  = 
                   Category.getInstance(""A0123456789.B0123456789.C0123456789"");

  static Category INEXISTENT_SHORT_CAT = Category.getInstance(""I0123456789"");
  static Category INEXISTENT_MEDIUM_CAT=
                                Category.getInstance(""I0123456789.B0123456789"");
  static Category INEXISTENT_LONG_CAT= 
                     Category.getInstance(""I0123456789.B0123456789.C0123456789"");


  static Category[] CAT_ARRAY = new Category[] {SHORT_CAT, MEDIUM_CAT, 
						LONG_CAT, INEXISTENT_SHORT_CAT,
						INEXISTENT_MEDIUM_CAT,
						INEXISTENT_LONG_CAT};

  static
  void  Usage() {
    System.err.println(
      ""Usage: java org.apache.log4j.test.NotLogging true|false runLength\n"" +
      ""true indicates shipped code, false indicates code in development"" +
      ""  where runLength is an int representing the run length of loops\n""+
      ""We suggest that runLength be at least 100'000."");
    System.exit(1);
  }

  public static void main(String argv[]) {

    if(argv.length != 2) {
      Usage();
    }    
    ProgramInit(argv);
    double delta;

    
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = SimpleMessage(CAT_ARRAY[i], SHORT_MSG, runLength);
      System.out.println(""Simple argument,          "" + delta 
			 + "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }

    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = FullyOptimizedComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Fully optimized complex,  "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }

    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = ComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Complex message argument, "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    
  }
  
  
  static
  void ProgramInit(String[] args) {

    try {
      runLength = Integer.parseInt(args[1]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      

    
    ConsoleAppender appender = new ConsoleAppender(new SimpleLayout());
    
    if(""false"".equals(args[0])) {
      
    } else if (""true"".equals(args[0])) {
      System.out.println(""Flagging as shipped code."");
      Category.getDefaultHierarchy().disableInfo();
    } else 
      Usage();

    SHORT_CAT.setPriority(Priority.INFO);      
    Category.getRoot().setPriority(Priority.INFO);

  }    
  

  static
  double SimpleMessage(Category category, String msg, long runLength) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(msg);
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }

  static
  double FullyOptimizedComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      if(category.isDebugEnabled())
	category.debug(""Message"" + i + 
		  "" bottles of beer standing on the wall."");
    }    
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }

  static
  double ComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(""Message"" + i +
		"" bottles of beer standing on the wall."");
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
}
"
log4j,1.1,org.apache.log4j.performance.NullAppender,6,2,0,3,8,15,0,3,6,1.0,34,0.0,0,0.818181818,0.5,1,1,4.333333333,2,0.8333,0,"

package org.apache.log4j.performance;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;


public class NullAppender extends AppenderSkeleton {

  public static String s;
  public String t;	

  public
  NullAppender() {}
  
  public
  NullAppender(Layout layout) {
    this.layout = layout;
  }

  public
  void close() {}
  
  public
  void doAppend(LoggingEvent event) {
    if(layout != null) {
      t = layout.format(event);
      s = t;
    }
  }

  public
  void append(LoggingEvent event) {
  }

  
  public
  boolean requiresLayout() {
    return true;
  }  
}
"
log4j,1.1,org.apache.log4j.test.ROFile,7,1,0,2,21,17,0,2,2,0.666666667,90,0.0,1,0.0,0.277777778,0,0,11.57142857,2,1.0,0,"package org.apache.log4j.test; 

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;

public class ROFile {

  static Category cat = Category.getInstance(ROFile.class.getName());
  
  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");

    test();
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + ROFile.class.getName() +
			""configFile"");
    System.exit(1);
  }

  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }

  static
  void test() {
    int i = -1;
    cat.debug(""Message "" + ++i);
  }
}
"
log4j,1.1,org.apache.log4j.test.Shallow,8,1,0,5,39,24,0,5,2,0.714285714,328,0.0,1,0.0,0.214285714,0,0,39.75,2,1.125,1,"

package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.util.Enumeration;

public class Shallow {
  
  static Category cat = Category.getInstance(Shallow.class);
  
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName()+""configFile"");
    System.exit(1);
  }

  static 
  void init(String configFile) {
    if(configFile.endsWith("".xml""))
      DOMConfigurator.configure(configFile);
    else 
      PropertyConfigurator.configure(configFile);
  }

  static 
  void test() {
    int i = -1; 
    NDC.push(""NDC""); 
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        

    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        

    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        

    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    
    cat.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    

    cat.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    

    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    

    cat.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    


    
    
    Category.shutdown();
  }


  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
log4j,1.1,org.apache.log4j.ProvisionNode,1,4,0,2,3,0,1,1,0,2.0,7,0.0,0,1.0,1.0,0,0,6.0,0,0.0,0,"

package org.apache.log4j;

import java.util.Vector;

class ProvisionNode extends Vector {
    
  ProvisionNode(Category cat) {
    super();
    this.addElement(cat);
  }
}
"
log4j,1.1,org.apache.log4j.PropertyConfigurator,18,2,0,28,78,135,14,15,9,0.93627451,714,0.25,1,0.413793103,0.277777778,1,1,38.0,10,2.5,6,"






package org.apache.log4j;

import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.DefaultCategoryFactory;
import org.apache.log4j.config.PropertySetter;

import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.FileWatchdog;

import java.util.NoSuchElementException;
import java.util.Enumeration;
import java.util.Properties;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Hashtable;


public class PropertyConfigurator extends BasicConfigurator
           implements Configurator {

  
  protected Hashtable registry = new Hashtable(11);
  protected CategoryFactory categoryFactory = new DefaultCategoryFactory();
  
  static final String      CATEGORY_PREFIX = ""log4j.category."";
  static final String       FACTORY_PREFIX = ""log4j.factory"";
  static final String    ADDITIVITY_PREFIX = ""log4j.additivity."";
  static final String ROOT_CATEGORY_PREFIX = ""log4j.rootCategory"";
  static final String      APPENDER_PREFIX = ""log4j.appender."";  
  static final String      RENDERER_PREFIX = ""log4j.renderer."";

  
  public static final String CATEGORY_FACTORY_KEY = ""log4j.categoryFactory"";

  static final private String INTERNAL_ROOT_NAME = ""root"";
  
  
  public
  void doConfigure(String configFileName, Hierarchy hierarchy) {
    Properties props = new Properties();
    try {
      FileInputStream istream = new FileInputStream(configFileName);
      props.load(istream);
      istream.close();
    }
    catch (IOException e) {
      LogLog.error(""Could not read configuration file [""+configFileName+""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configFileName+""]."");
      return;
    }
    
    doConfigure(props, hierarchy);
  }

  
  static
  public 
  void configure(String configFilename) {
    new PropertyConfigurator().doConfigure(configFilename, 
					   Category.defaultHierarchy);
  }

  
  public
  static
  void configure(java.net.URL configURL) {
    new PropertyConfigurator().doConfigure(configURL, Category.defaultHierarchy);
  }


  
  static
  public
  void configure(Properties properties) {
    new PropertyConfigurator().doConfigure(properties, Category.defaultHierarchy);
  }

  
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }


  
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    PropertyWatchdog pdog = new PropertyWatchdog(configFilename);
    pdog.setDelay(delay);
    pdog.start();
  }


  
  public
  void doConfigure(Properties properties, Hierarchy hierarchy) {

    String value = properties.getProperty(LogLog.DEBUG_KEY);
    if(value == null) {
      value = properties.getProperty(LogLog.CONFIG_DEBUG_KEY);
      if(value != null)
	LogLog.warn(""[log4j.configDebug] is deprecated. Use [log4j.debug] instead."");
    }
    
    if(value != null) {
      LogLog.setInternalDebugging(OptionConverter.toBoolean(value, true));
    }

    
    String override = properties.getProperty(
                                    BasicConfigurator.DISABLE_OVERRIDE_KEY);
    hierarchy.overrideAsNeeded(override);

    if(override == null) {
      String disableStr = properties.getProperty(BasicConfigurator.DISABLE_KEY);
      if(disableStr != null)
	hierarchy.disable(disableStr);      
    }
    
    
    configureRootCategory(properties, hierarchy);
    configureCategoryFactory(properties);
    parseCatsAndRenderers(properties, hierarchy);

    LogLog.debug(""Finished configuring."");    
    
    
    registry.clear();
  }

  
  public
  void doConfigure(java.net.URL configURL, Hierarchy hierarchy) {
    Properties props = new Properties();
    LogLog.debug(""Reading configuration from URL "" + configURL);
    try {
      props.load(configURL.openStream());
    }
    catch (java.io.IOException e) {
      LogLog.error(""Could not read configuration file from URL ["" + configURL 
		   + ""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configURL +""]."");
      return;
    }
    doConfigure(props, hierarchy);
  }


  
  
  

  
  protected void configureCategoryFactory(Properties props) {
    String factoryClassName = OptionConverter.findAndSubst(CATEGORY_FACTORY_KEY,
							   props);    
    if(factoryClassName != null) {
      LogLog.debug(""Setting category factory to [""+factoryClassName+""]."");
      categoryFactory = (CategoryFactory) 
                  OptionConverter.instantiateByClassName(factoryClassName,
							 CategoryFactory.class, 
							 categoryFactory);
      PropertySetter.setProperties(categoryFactory, props, FACTORY_PREFIX + ""."");
      
      
      
      
      
    }
  }

  
  
    
  void configureRootCategory(Properties props, Hierarchy hierarchy) {
    String value = OptionConverter.findAndSubst(ROOT_CATEGORY_PREFIX, props);
    if(value == null) 
      LogLog.debug(""Could not find root category information. Is this OK?"");
    else {
      Category root = hierarchy.getRoot();
      synchronized(root) {
	parseCategory(props, root, ROOT_CATEGORY_PREFIX, INTERNAL_ROOT_NAME, 
		      value);
      }
    }        
  }


  
  protected
  void parseCatsAndRenderers(Properties props, Hierarchy hierarchy) {
    Enumeration enum = props.propertyNames();
    while(enum.hasMoreElements()) {      
      String key = (String) enum.nextElement();
      if(key.startsWith(CATEGORY_PREFIX)) {
	String categoryName = key.substring(CATEGORY_PREFIX.length());	
	String value =  OptionConverter.findAndSubst(key, props);
	Category cat = hierarchy.getInstance(categoryName, categoryFactory);
	synchronized(cat) {
	  parseCategory(props, cat, key, categoryName, value);
	  parseAdditivityForCategory(props, cat, categoryName);
	}
      } else if(key.startsWith(RENDERER_PREFIX)) {
	String renderedClass = key.substring(RENDERER_PREFIX.length());	
	String renderingClass = OptionConverter.findAndSubst(key, props);
	addRenderer(hierarchy, renderedClass, renderingClass);
      }      
    }
  }  

  
  void parseAdditivityForCategory(Properties props, Category cat,
				  String categoryName) {
    String value = OptionConverter.findAndSubst(ADDITIVITY_PREFIX + categoryName, 
					     props);
    LogLog.debug(""Handling ""+ADDITIVITY_PREFIX + categoryName+""=[""+value+""]"");
    
    if((value != null) && (!value.equals(""""))) {
      boolean additivity = OptionConverter.toBoolean(value, true);
      LogLog.debug(""Setting additivity for \""""+categoryName+""\"" to ""+
		   additivity); 
      cat.setAdditivity(additivity);
    }
  }
  
  
  void parseCategory(Properties props, Category cat, String optionKey,
		     String catName, String value) {

    LogLog.debug(""Parsing for ["" +catName +""] with value=["" + value+""]."");
    
    StringTokenizer st = new StringTokenizer(value, "","");
     
    
    
    
    if(!(value.startsWith("","") || value.equals(""""))) {

      
      if(!st.hasMoreTokens())
	return;
    
      String priorityStr = st.nextToken();
      LogLog.debug(""Priority token is ["" + priorityStr + ""]."");

      
      
      
      if(priorityStr.equalsIgnoreCase(BasicConfigurator.INHERITED) &&
                                	 !catName.equals(INTERNAL_ROOT_NAME)) {
	cat.setPriority(null);
      } else {
	cat.setPriority(OptionConverter.toPriority(priorityStr, 
						   Priority.DEBUG));
      }
      LogLog.debug(""Category "" + catName + "" set to "" + cat.getPriority());
    }

    
    cat.removeAllAppenders();
    
    Appender appender;    
    String appenderName;
    while(st.hasMoreTokens()) {
      appenderName = st.nextToken().trim();
      if(appenderName == null || appenderName.equals("",""))
	continue;
      LogLog.debug(""Parsing appender named \"""" + appenderName +""\""."");
      appender = parseAppender(props, appenderName);
      if(appender != null) {
	cat.addAppender(appender);
      }      
    }          
  }

  Appender parseAppender(Properties props, String appenderName) {
    Appender appender = registryGet(appenderName);
    if((appender != null)) {
      LogLog.debug(""Appender \"""" + appenderName + ""\"" was already parsed."");
      return appender;
    }
    
    String prefix = APPENDER_PREFIX + appenderName;
    String layoutPrefix = prefix + "".layout"";    

    appender = (Appender) OptionConverter.instantiateByKey(props, prefix,
					      org.apache.log4j.Appender.class,
					      null);
    if(appender == null) {
      LogLog.error(
              ""Could not instantiate appender named \"""" + appenderName+""\""."");
      return null;
    }
    appender.setName(appenderName);

    if(appender instanceof OptionHandler) {
      if(appender.requiresLayout()) {
	Layout layout = (Layout) OptionConverter.instantiateByKey(props, 
								  layoutPrefix,
								  Layout.class, 
								  null);
	if(layout != null) {
	  appender.setLayout(layout);
	  LogLog.debug(""Parsing layout options for \"""" + appenderName +""\""."");
	  
          PropertySetter.setProperties(layout, props, layoutPrefix + ""."");
	  LogLog.debug(""End of parsing for \"""" + appenderName +""\""."");      
	}
      }
      
      PropertySetter.setProperties(appender, props, prefix + ""."");
      LogLog.debug(""Parsed \"""" + appenderName +""\"" options."");
    }
    registryPut(appender);
    return appender;
  }

  
  void  registryPut(Appender appender) {
    registry.put(appender.getName(), appender);
  }
  
  Appender registryGet(String name) {
    return (Appender) registry.get(name);
  }
}

class PropertyWatchdog extends FileWatchdog {

  PropertyWatchdog(String filename) {
    super(filename);
  }

  
  public
  void doOnChange() {
    new PropertyConfigurator().doConfigure(filename, Category.defaultHierarchy);
  }
}
"
log4j,1.1,org.apache.log4j.test.ConfigurationFileParsing,4,1,0,3,20,6,0,3,2,0.666666667,69,0.0,0,0.0,0.333333333,0,0,16.0,2,1.25,0,"

package org.apache.log4j.test; 

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;

public class ConfigurationFileParsing {
  
  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) {
      NDC.push(""testing"");
      PropertyConfigurator.configure(argv[0]);
      Category root = Category.getRoot();
      root.debug(""Message 1"");
      root.debug(""Message 2"");      
      NDC.pop();
      Category.shutdown();
    }
    else {
      Usage(""Wrong number of arguments."");
    }
    
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ConfigurationFileParsing.class.getName()
		       + "" fileName"");
    System.exit(1);
  }

  
}
"
log4j,1.1,org.apache.log4j.Priority,11,1,0,31,14,15,31,0,9,0.792307692,174,0.0,5,0.0,0.35,0,0,13.63636364,7,2.0,5,"



package org.apache.log4j;


public class Priority {

  int level;
  String levelStr;
  int syslogEquivalent;

  public final static int FATAL_INT = 50000;
  public final static int ERROR_INT = 40000;
  public final static int WARN_INT  = 30000;
  public final static int INFO_INT  = 20000;
  public final static int DEBUG_INT = 10000;

  
  final static public Priority FATAL = new Priority(FATAL_INT, ""FATAL"", 0);

  
  final static public Priority ERROR = new Priority(ERROR_INT, ""ERROR"", 3);

  
  final static public Priority WARN  = new Priority(WARN_INT, ""WARN"",  4);

  
  final static public Priority INFO  = new Priority(INFO_INT, ""INFO"",  6);

  
  final static public Priority DEBUG = new Priority(DEBUG_INT, ""DEBUG"", 7);

  
  
  protected
  Priority(int level, String levelStr, int syslogEquivalent) {
    this.level = level;
    this.levelStr = levelStr;
    this.syslogEquivalent = syslogEquivalent;
  }

  
  public
  final
  int getSyslogEquivalent() {
    return syslogEquivalent;
  }


  
  final
  public
  String toString() {
    return levelStr;
  }

  
  public
  final
  int toInt() {
    return level;
  }

    
  
  public
  boolean isGreaterOrEqual(Priority r) {
    return level >= r.level;
  }

  
  public
  static
  Priority[] getAllPossiblePriorities() {
    return new Priority[] {Priority.FATAL, Priority.ERROR, Priority.WARN, 
			     Priority.INFO, Priority.DEBUG};
  }


  
  public
  static
  Priority toPriority(String sArg) {
    return toPriority(sArg, Priority.DEBUG);
  }

  
  public
  static
  Priority toPriority(int val) {
    return toPriority(val, Priority.DEBUG);
  }

  
  public
  static
  Priority toPriority(int val, Priority defaultPriority) {
    switch(val) {
    case DEBUG_INT: return DEBUG;
    case INFO_INT: return INFO;
    case WARN_INT: return WARN;
    case ERROR_INT: return ERROR;
    case FATAL_INT: return FATAL;
    default: return defaultPriority;
    }
  }

  
  public
  static
  Priority toPriority(String sArg, Priority defaultPriority) {                  
    if(sArg == null)
       return defaultPriority;
    
    String s = sArg.toUpperCase();

    if(s.equals(""DEBUG"")) return Priority.DEBUG; 
    if(s.equals(""INFO""))  return Priority.INFO;
    if(s.equals(""WARN""))  return Priority.WARN;  
    if(s.equals(""ERROR"")) return Priority.ERROR;
    if(s.equals(""FATAL"")) return Priority.FATAL;
    return defaultPriority;
  }


}
"
log4j,1.1,org.apache.log4j.spi.ErrorHandler,2,1,0,14,2,1,13,1,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.apache.log4j.spi;

import org.apache.log4j.Appender;


public interface ErrorHandler extends OptionHandler {


  
  void error(String message, Exception e, int errorCode);


  
  void error(String message);

}
"
log4j,1.1,org.apache.log4j.spi.LocationInfo,6,1,0,9,21,0,7,2,5,0.88,286,0.2,0,0.0,0.466666667,0,0,45.0,6,3.0,0,"



package org.apache.log4j.spi;

import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Layout;


public class LocationInfo implements java.io.Serializable {
    
  
  transient String lineNumber;
  
  transient String fileName;
  
  transient String className;
  
  transient String methodName;
  
  public String fullInfo;

  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);

  
  public final static String NA = ""?"";

  static final long serialVersionUID = -1325822038990805636L;


  
  static boolean inVisualAge = false;
  static {
    try {
      Class dummy = Class.forName(""com.ibm.uvm.tools.DebugSupport"");
      inVisualAge = true;
      LogLog.debug(""Detected IBM VisualAge environment."");
    } catch(Throwable e) { 
      
    }
  }

  
    public LocationInfo(Throwable t, String fqnOfCallingClass) {
      if(t == null)
	return;

      String s;
      
      synchronized(sw) {
	t.printStackTrace(pw);
	s = sw.toString();
	sw.getBuffer().setLength(0);
      }
      
      int ibegin, iend;

      
      
      

      
      
      
      ibegin = s.lastIndexOf(fqnOfCallingClass);
      if(ibegin == -1) 
	return;


      ibegin = s.indexOf(Layout.LINE_SEP, ibegin); 
      if(ibegin == -1) 
	return;
      ibegin+= Layout.LINE_SEP_LEN;
      
      
      iend = s.indexOf(Layout.LINE_SEP, ibegin); 
      if(iend == -1) 
	return;

      
      
      if(!inVisualAge) {
	
	ibegin = s.lastIndexOf(""at "", iend); 
	if(ibegin == -1) 
	  return;
	
	ibegin += 3;
      }
      
      this.fullInfo = s.substring(ibegin, iend);
    }

    
    public
    String getClassName() {      
      if(fullInfo == null) return NA;      
      if(className == null) {
	
	
	int iend = fullInfo.lastIndexOf('(');
	if(iend == -1) 
	  className = NA;
	else {
	  iend = fullInfo.lastIndexOf('.', iend);

	  

          
	  
	  
	  
	  
	  
	  
          int ibegin = 0;
	  if (inVisualAge) {
	    ibegin = fullInfo.lastIndexOf(' ', iend)+1;
          }

	  if(iend == -1) 
	    className = NA;
	  else
	    className = this.fullInfo.substring(ibegin, iend);
	}
      }
      return className;
    }

    
    public 
    String getFileName() {
      if(fullInfo == null) return NA;
      
      if(fileName == null) {
	int iend = fullInfo.lastIndexOf(':');	
	if(iend == -1)
	  fileName = NA;
	else {
	  int ibegin = fullInfo.lastIndexOf('(', iend - 1);
	  fileName = this.fullInfo.substring(ibegin + 1, iend);
	}	
      }
      return fileName;
    }

    
    public 
    String getLineNumber() {
      if(fullInfo == null) return NA;
      
      if(lineNumber == null) {
	int iend = fullInfo.lastIndexOf(')');	
	int ibegin = fullInfo.lastIndexOf(':', iend -1);
	if(ibegin == -1)
	  lineNumber = NA;
	else 
	  lineNumber = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return lineNumber;
    }

    
    public
    String getMethodName() {
      if(fullInfo == null) return NA;            
      if(methodName == null) {
	int iend = fullInfo.lastIndexOf('(');	
	int ibegin = fullInfo.lastIndexOf('.', iend);
	if(ibegin == -1)
	  methodName = NA;
	else
	  methodName = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return methodName;
    }
}
"
log4j,1.1,org.apache.log4j.helpers.BoundedFIFO,10,1,0,3,17,0,2,1,9,0.555555556,243,0.0,1,0.0,0.466666667,0,0,22.8,5,2.1,0,"



package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;


public class BoundedFIFO {
  
  LoggingEvent[] buf;
  int numElements = 0;
  int first = 0;
  int next = 0;
  int maxSize;

  
  public
  BoundedFIFO(int maxSize) {
   if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    buf = new LoggingEvent[maxSize];
  }
  
  
  public
  LoggingEvent get() {
    if(numElements == 0) 
      return null;
    
    LoggingEvent r = buf[first];
    if(++first == maxSize) {
	first = 0;
    }
    numElements--;    
    return r;    
  }

  
  public 
  void put(LoggingEvent o) {
    if(numElements != maxSize) {      
      buf[next] = o;    
      if(++next == maxSize) {
	next = 0;
      }
      numElements++;
    }
  }

  
  public 
  int getMaxSize() {
    return maxSize;
  }

  
  public 
  boolean isFull() {
    return numElements == maxSize;
  }

  
  public
  int length() {
    return numElements;
  } 


  int min(int a, int b) {
    return a < b ? a : b;
  }


  
  synchronized
  public 
  void resize(int newSize) {
    if(newSize == maxSize) 
      return;


   LoggingEvent[] tmp = new LoggingEvent[newSize];

   
   int len1 = maxSize - first;

   
   len1 = min(len1, newSize);

   
   
   len1 = min(len1, numElements);

   
   System.arraycopy(buf, first, tmp, 0, len1);
   
   
   int len2 = 0;
   if((len1 < numElements) && (len1 < newSize)) {
     len2 = numElements - len1;
     len2 = min(len2, newSize - len1);
     System.arraycopy(buf, 0, tmp, len1, len2);
   }
   
   this.buf = tmp;
   this.maxSize = newSize;    
   this.first=0;   
   this.numElements = len1+len2;
   this.next = this.numElements;
   if(this.next == this.maxSize) 
     this.next = 0;
  }

  
  
  public
  boolean wasEmpty() {
    return numElements == 1;
  }

  
  public
  boolean wasFull() {
    return (numElements+1 == maxSize);
  }

}
"
log4j,1.1,org.apache.log4j.spi.LoggingEvent,15,1,0,42,48,77,35,8,9,0.898496241,304,0.421052632,4,0.0,0.196428571,0,0,18.0,4,1.4,4,"

package org.apache.log4j.spi;

import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;

import org.apache.log4j.helpers.LogLog;

import java.io.StringWriter;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.util.Hashtable;






public class LoggingEvent implements java.io.Serializable {

  private static long startTime = System.currentTimeMillis();

  
  transient public final String fqnOfCategoryClass;

  
  transient public Category category;

  
  public final String categoryName;
  
  
  transient public Priority priority;

  
  private String ndc;

  
  private boolean ndcLookupRequired = true;


  
  transient private Object message;

  
  private String renderedMessage;

  
  private String threadName;


  
  private ThrowableInformation throwableInfo;

  
  public final long timeStamp;
  
  private LocationInfo locationInfo;

  
  static final long serialVersionUID = -868428216207166145L;

  static final Integer[] PARAM_ARRAY = new Integer[1];
  static final String TO_PRIORITY = ""toPriority"";
  static final Class[] TO_PRIORITY_PARAMS = new Class[] {int.class};
  static final Hashtable methodCache = new Hashtable(3); 

  
  public LoggingEvent(String fqnOfCategoryClass, Category category, 
		      Priority priority, Object message, Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.category = category;
    this.categoryName = category.getName();
    this.priority = priority;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable);
    }

    timeStamp = System.currentTimeMillis();
  }  


  
  public
  LocationInfo getLocationInformation() {
    if(locationInfo == null) {
      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);
    }
    return locationInfo;
  }


  
  public
  Object getMessage() {
    if(message != null) {
      return message;
    } else {
      return getRenderedMessage();
    }
  }

  public
  String getNDC() {
    if(ndcLookupRequired) {
      ndcLookupRequired = false;
      ndc = NDC.get();
    }
    return ndc; 
  }

  public
  String getRenderedMessage() {
     if(renderedMessage == null && message != null) {
       if(message instanceof String) 
	 renderedMessage = (String) message;
       else {
	 renderedMessage=
            category.getHierarchy().getRendererMap().findAndRender(message);
       }
     }
     return renderedMessage;
  }  

  
  public
  static 
  long getStartTime() {
    return startTime;
  }

  public
  String getThreadName() {
    if(threadName == null)
      threadName = (Thread.currentThread()).getName();
    return threadName;
  }

  
  public
  ThrowableInformation getThrowableInformation() {
    return throwableInfo;
  }

  
  public 
  String[] getThrowableStrRep() {

    if(throwableInfo ==  null)
      return null;
    else 
      return throwableInfo.getThrowableStrRep();
  }
	

  private 
  void readPriority(ObjectInputStream ois) 
                      throws java.io.IOException, ClassNotFoundException {

    int p = ois.readInt();
    try {
      String className = (String) ois.readObject();      
      if(className == null) {
	priority = Priority.toPriority(p);
      } else {
	Method m = (Method) methodCache.get(className);	
	if(m == null) {
	  Class clazz = Class.forName(className);
	  m = clazz.getDeclaredMethod(TO_PRIORITY, TO_PRIORITY_PARAMS);
	  methodCache.put(className, m);
	}      
	PARAM_ARRAY[0] = new Integer(p);
	priority = (Priority) m.invoke(null,  PARAM_ARRAY);
      }
    } catch(Exception e) {
	LogLog.warn(""Priority deserialization failed, reverting to default."", e);
	priority = Priority.toPriority(p);
    }
  }

  private void readObject(ObjectInputStream ois)
                        throws java.io.IOException, ClassNotFoundException {
    ois.defaultReadObject();    
    readPriority(ois);

    
    if(locationInfo == null)
      locationInfo = new LocationInfo(null, null);
  }

  private
  void writeObject(ObjectOutputStream oos) throws java.io.IOException {
    
    
    this.getThreadName();    

    
    this.getRenderedMessage();

    
    
    this.getNDC();

    
    this.getThrowableStrRep();

    oos.defaultWriteObject();
    
    
    writePriority(oos);
  }

  private 
  void writePriority(ObjectOutputStream oos) throws java.io.IOException {

    oos.writeInt(priority.toInt());

    Class clazz = priority.getClass();
    if(clazz == Priority.class) {
      oos.writeObject(null);
    } else {
      
      
      
      oos.writeObject(clazz.getName());
    }
  }

}
"
log4j,1.1,org.apache.log4j.helpers.Loader,4,1,0,2,19,4,1,1,2,0.666666667,139,0.0,0,0.0,0.555555556,0,0,33.5,3,1.25,1,"

package org.apache.log4j.helpers;

import java.net.URL;





public class Loader  { 

  static String TSTR = ""Caught Exception while in Loader.getResource. This may be innocuous."";
  
  
  static 
  public
  URL getResource(String resource, Class clazz) {
    
    URL url = null;


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ClassLoader loader = clazz.getClassLoader();
    if(loader != null) {
      try {
	LogLog.debug(""Trying to find [""+resource+""] using ""+loader
		     +"" class loader."");
	url = loader.getResource(resource); 
	if(url != null) 
	  return url;
      } catch(Throwable t) {
	LogLog.warn(TSTR, t);
      }
    }
    
    
    
    
    
    LogLog.debug(""Trying to find [""+resource+""] using ClassLoader.getSystemResource()."");
    url = ClassLoader.getSystemResource(resource);
    return url;
  }

  
  static
  String resolveName(String resource, Class clazz) {
    String fqcn = clazz.getName();
    int index = fqcn.lastIndexOf('.');
    if (index != -1) {
      fqcn = fqcn.substring(0, index).replace('.', '/');
      resource = fqcn+""/""+resource;
    }
    return resource;
  }


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}
"
log4j,1.1,org.apache.log4j.config.PropertyPrinter,10,1,0,7,42,39,1,6,6,0.644444444,328,1.0,0,0.0,0.314285714,0,0,31.3,9,2.8,0,"

package org.apache.log4j.config;

import java.io.*;
import java.util.*;
import org.apache.log4j.*;


public class PropertyPrinter implements PropertyGetter.PropertyCallback {
  protected int numAppenders = 0;
  protected Hashtable appenderNames = new Hashtable();
  protected Hashtable layoutNames   = new Hashtable();
  protected PrintWriter out;
  protected boolean doCapitalize;
  
  public
  PropertyPrinter(PrintWriter out) {
    this(out, false);
  }
  
  public
  PropertyPrinter(PrintWriter out, boolean doCapitalize) {
    this.out = out;
    this.doCapitalize = doCapitalize;
    
    print(out);
    out.flush();
  }
  
  protected
  String genAppName() {
    return ""A"" + numAppenders++;
  }
  
  
  protected
  boolean isGenAppName(String name) {
    if (name.length() < 2 || name.charAt(0) != 'A') return false;
    
    for (int i = 0; i < name.length(); i++) {
      if (name.charAt(i) < '0' || name.charAt(i) > '9') return false;
    }
    return true;
  }
  
  
  public
  void print(PrintWriter out) {
    printOptions(out, Category.getRoot());
    
    Enumeration cats = Category.getCurrentCategories();
    while (cats.hasMoreElements()) {
      printOptions(out, (Category) cats.nextElement());
    }
  }
  
  protected
  void printOptions(PrintWriter out, Category cat) {
    Enumeration appenders = cat.getAllAppenders();
    Priority prio = cat.getPriority();
    String appenderString = (prio == null ? """" : prio.toString());
    
    while (appenders.hasMoreElements()) {
      Appender app = (Appender) appenders.nextElement();
      String name;
      
      if ((name = (String) appenderNames.get(app)) == null) {
      
        
        if ((name = app.getName()) == null || isGenAppName(name)) {
            name = genAppName();
        }
        appenderNames.put(app, name);
        
        printOptions(out, app, ""log4j.appender.""+name);
        if (app.getLayout() != null) {
          printOptions(out, app.getLayout(), ""log4j.appender.""+name+"".layout"");
        }
      }
      appenderString += "", "" + name;
    }
    String catKey = (cat == Category.getRoot())
        ? ""log4j.rootCategory""
        : ""log4j.category."" + cat.getName();
    if (appenderString != """") {
      out.println(catKey + ""="" + appenderString);
    }
  }
  
  protected
  void printOptions(PrintWriter out, Object obj, String fullname) {
    out.println(fullname + ""="" + obj.getClass().getName());
    PropertyGetter.getProperties(obj, this, fullname + ""."");
  }
  
  public void foundProperty(Object obj, String prefix, String name, Object value) {
    
    if (obj instanceof Appender && ""name"".equals(name)) {
      return;
    }
    if (doCapitalize) {
      name = capitalize(name);
    }
    out.println(prefix + name + ""="" + value.toString());
  }
  
  public static String capitalize(String name) {
    if (Character.isLowerCase(name.charAt(0))) {
      if (name.length() == 1 || Character.isLowerCase(name.charAt(1))) {
        StringBuffer newname = new StringBuffer(name);
        newname.setCharAt(0, Character.toUpperCase(name.charAt(0)));
        return newname.toString();
      }
    }
    return name;
  }
  
  
  public static void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out));
  }
}"
log4j,1.1,org.apache.log4j.test.SpacePad,4,1,0,0,10,4,0,0,3,0.333333333,114,0.0,0,0.0,0.333333333,0,0,27.25,4,1.5,0,"package org.apache.log4j.test;

public class SpacePad {

  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", 
			    ""                "", 
			    ""                                "" }; 

  static public void main(String[] args) {
    StringBuffer sbuf = new StringBuffer();

    for(int i = 0; i < 35; i++) {
      sbuf.setLength(0);
      sbuf.append(""\"""");
      spacePad(sbuf, i);
      sbuf.append(""\"""");
      System.out.println(sbuf.toString());
    }
    
    sbuf.setLength(0);
    sbuf.append(""\"""");
    spacePad(sbuf, 67);
    sbuf.append(""\"""");
    System.out.println(sbuf.toString());
    
  }
  static
  public
  void spacePad(StringBuffer sbuf, int length) {
    
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
log4j,1.1,org.apache.log4j.or.RendererMap,9,1,0,5,19,10,3,2,7,0.375,120,0.0,1,0.0,0.4375,0,0,12.11111111,4,1.6667,0,"

package org.apache.log4j.or;

import java.util.Hashtable;


public class RendererMap {

  Hashtable map;

  static ObjectRenderer defaultRenderer = new DefaultRenderer();

  public
  RendererMap() {
    map = new Hashtable();
  }

  
  public
  String findAndRender(Object o) {
    if(o == null)
      return null;
    else 
      return get(o.getClass()).doRender(o);
  }


  
  public 
  ObjectRenderer get(Object o) {
    if(o == null) 
      return null;
    else
      return get(o.getClass());
  }
  

  
  public
  ObjectRenderer get(Class clazz) {
    
    ObjectRenderer r = null;
    for(Class c = clazz; c != null; c = c.getSuperclass()) {
      
      r = (ObjectRenderer) map.get(c);
      if(r != null) {
	return r;
      }      
      r = searchInterfaces(c);
      if(r != null)
	return r;
    }
    return defaultRenderer;
  }  
  
  ObjectRenderer searchInterfaces(Class c) {
    
    
    ObjectRenderer r = (ObjectRenderer) map.get(c);
    if(r != null) {
      return r;
    } else {
      Class[] ia = c.getInterfaces();
      for(int i = 0; i < ia.length; i++) {
	r = searchInterfaces(ia[i]);
	if(r != null)
	  return r; 
      }
    }
    return null;
  }


  public
  ObjectRenderer getDefaultRenderer() {
    return defaultRenderer;
  }


  public
  void clear() {
    map.clear();
  }

  
  public
  void put(Class clazz, ObjectRenderer or) {
    map.put(clazz, or);
  }
}
"
log4j,1.1,org.apache.log4j.test.SysoutConfigurator,2,1,0,7,7,1,0,7,2,2.0,15,0.0,0,0.0,0.666666667,0,0,6.5,1,0.5,1,"package org.apache.log4j.test;

import java.util.Properties;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;


public class SysoutConfigurator implements Configurator {
  public
  void
  doConfigure(java.net.URL url, Hierarchy hierarchy) {
    Category.getRoot().addAppender(
        new ConsoleAppender(
            new SimpleLayout(), ConsoleAppender.SYSTEM_OUT));
  }
}
"
log4j,1.1,org.apache.log4j.helpers.CyclicBuffer,7,1,0,2,13,0,1,1,7,0.333333333,246,0.0,1,0.0,0.523809524,0,0,33.42857143,7,2.7143,0,"
     
package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;


public class CyclicBuffer {
  
  LoggingEvent[] ea;
  int first; 
  int last; 
  int numElems;
  int maxSize;

  
  public CyclicBuffer(int maxSize) throws IllegalArgumentException {
    if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    ea = new LoggingEvent[maxSize];
    first = 0;
    last = 0;
    numElems = 0;
  }
    
  
  public
  void add(LoggingEvent event) {    
    ea[last] = event;    
    if(++last == maxSize)
      last = 0;

    if(numElems < maxSize)
      numElems++;
    else if(++first == maxSize)
      first = 0;
  }


  
  public
  LoggingEvent get(int i) {
    if(i < 0 || i >= numElems)
      return null;

    return ea[(first + i) % maxSize];
  }

  public 
  int getMaxSize() {
    return maxSize;
  }

  
  public
  LoggingEvent get() {
    LoggingEvent r = null;
    if(numElems > 0) {
      numElems--;
      r = ea[first];
      ea[first] = null;
      if(++first == maxSize)
	first = 0;
    } 
    return r;
  }
  
  
  public
  int length() {
    return numElems;
  } 

  
  public 
  void resize(int newSize) {
    if(newSize < 0) {
      throw new IllegalArgumentException(""Negative array size [""+newSize+
					 ""] not allowed."");
    }
    if(newSize == numElems)
      return; 
    
    LoggingEvent[] temp = new  LoggingEvent[newSize];

    int loopLen = newSize < numElems ? newSize : numElems;
    
    for(int i = 0; i < loopLen; i++) {
      temp[i] = ea[first];
      ea[first] = null;
      if(++first == numElems) 
	first = 0;
    }
    ea = temp;
    first = 0;
    numElems = loopLen;
    maxSize = newSize;
    if (loopLen == newSize) {
      last = 0;
    } else {
      last = loopLen;
    }
  }
}
"
log4j,1.1,org.apache.log4j.DefaultCategoryFactory,2,1,0,4,4,1,2,2,1,2.0,10,0.0,0,0.0,0.75,0,0,4.0,1,0.5,0,"

package org.apache.log4j;

import org.apache.log4j.spi.CategoryFactory;

class DefaultCategoryFactory implements CategoryFactory {
    
  DefaultCategoryFactory() {
  }    
    
  public
  Category makeNewCategoryInstance(String name) {
    return new Category(name);
  }    
}
"
log4j,1.1,org.apache.log4j.test.StressAsyncAppender,10,2,0,2,37,23,0,2,7,0.833333333,301,0.0,1,0.884057971,0.2,0,0,28.1,4,1.7,0,"


package org.apache.log4j.test;


import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;


import java.util.Random;
import java.util.Stack;


public class StressAsyncAppender extends Thread {

  static Category root = Category.getRoot();  

  static Random random = new Random(101);

  static final int LOOP_LENGTH = 24;
  static final int BRANCHING_FACTOR = 4;
  
  static int maxThreads;  
  static long msgCounter = 0;
  static int threadCounter = 0;  

  static double LOG_2 = Math.log(2);

  static Object lock = new Object();

  
  public 
  static 
  void main(String args[]) {
    if(args.length != 1) {
      usage();
    }

    DOMConfigurator.configure(""xml/stressAsyncAppender.xml"");

    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    
    while(true) {
      synchronized(lock) {
	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);

	
	try {
	  root.debug(""About to wait for notification."");
	  lock.wait();
	  root.debug(""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }


  static
  void usage() {
    System.err.println(""Usage: java ""+ StressAsyncAppender.class.getName() +
			"" MAX_THREADS"");
    System.exit(1);
  }


  public
  StressAsyncAppender() {
  }

  public
  void run() {
    int loopLength = StressAsyncAppender.randomInt(LOOP_LENGTH);
    root.debug(""In run loop, loopLength = ""+loopLength);

    
    int createIndex = loopLength/2;
      
    for(int i = 0; i <= loopLength; i++) {

      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      
      synchronized(lock) {      
	root.debug(""Message number "" + msgCounter++);	
      }
      
    }    

    synchronized(lock) {
      StressAsyncAppender.threadCounter--;
      root.debug(""Exiting run loop. "" + threadCounter);
      if(StressAsyncAppender.threadCounter <= 0) {
	root.debug(""Notifying [main] thread."");
	lock.notify(); 
      }
    }

  }

  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;

    synchronized(lock) {
      n = maxThreadsConstrained(n);    
      root.debug(""Creating "" + n+ "" child StressAsyncAppender threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressAsyncAppender, threadCounter = "" + (++threadCounter));
	new StressAsyncAppender().start();
      }
    }
  }

  static
  public
  int maxThreadsConstrained(int a) {
    int maxAllowed = StressAsyncAppender.maxThreads - 
                                                 StressAsyncAppender.threadCounter;
    return a <= maxAllowed ? a : maxAllowed;
  }

  
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }

  
  public
  void delay(long millis) {
    try {
      Thread.currentThread().sleep(millis);
    } catch(Exception e) {}
  }
  
}
"
log4j,1.1,org.apache.log4j.AsyncAppender,16,2,0,10,48,34,1,10,16,0.883333333,320,0.0,3,0.545454545,0.25,2,3,18.5,5,1.4375,5,"



package org.apache.log4j;

import org.apache.log4j.Category;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.BoundedFIFO;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.LogLog;
import java.util.Enumeration;


public class AsyncAppender extends AppenderSkeleton 
                                            implements AppenderAttachable {
  
  
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";


  
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";

  
  public static final int DEFAULT_BUFFER_SIZE = 128;

  

  BoundedFIFO bf = new BoundedFIFO(DEFAULT_BUFFER_SIZE);

  AppenderAttachableImpl aai;
  Dispatcher dispatcher;
  boolean locationInfo = false;

  boolean interruptedWarningMessage = false;

  public
  AsyncAppender() {
    
    
    aai = new AppenderAttachableImpl();
    dispatcher = new Dispatcher(bf, this);
    dispatcher.start();
  }
  

  public 
  void addAppender(Appender newAppender) {
    synchronized(aai) {
      aai.addAppender(newAppender);
    }
  } 

  public
  void append(LoggingEvent event) {
    
    
    event.getNDC();
    event.getThreadName();
    if(locationInfo) {
      event.getLocationInformation();	
    }
    synchronized(bf) {
      while(bf.isFull()) {
	try {
	  
	  bf.wait();
	} catch(InterruptedException e) {
	  if(!interruptedWarningMessage) {
	    interruptedWarningMessage = true;
	    LogLog.warn(""AsyncAppender interrupted."", e);
	  } else {
	    LogLog.warn(""AsyncAppender interrupted again."");
	  }
	}
      }
 
      
      bf.put(event);
      if(bf.wasEmpty()) {
	
	bf.notify();
      }
    }
  }

  
  public 
  void close() {
    synchronized(this) {
      if(closed) 
	return; 
      closed = true;
    }
    
    
    
    
    
    dispatcher.close();
    try {
      dispatcher.join();
    } catch(InterruptedException e) {
      LogLog.error(""Got an InterruptedException while waiting for the ""+
		   ""dispatcher to finish."", e);
    }
    dispatcher = null;
    bf = null;
  }

  public
  Enumeration getAllAppenders() {
    synchronized(aai) {
      return aai.getAllAppenders();
    }
  }

  public
  Appender getAppender(String name) {
    synchronized(aai) {
      return aai.getAppender(name);
    }
  }

  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  
  
  public 
  boolean requiresLayout() {
    return false;
  }

  public
  void removeAllAppenders() {
    synchronized(aai) {
      aai.removeAllAppenders();
    }
  }
  

  public
  void removeAppender(Appender appender) {
    synchronized(aai) {
      aai.removeAppender(appender);
    }
  }

  public
  void removeAppender(String name) {
    synchronized(aai) {
      aai.removeAppender(name);
    }
  }

  
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  
  
  
  public
  void setBufferSize(int size) {
    bf.resize(size);
  }
  
  
  public
  int getBufferSize() {
    return bf.getMaxSize();
  }

 
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {LOCATION_INFO_OPTION, BUFFER_SIZE_OPTION});
  }

 
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);

    if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    else if (option.equals(BUFFER_SIZE_OPTION)) {
      int newSize = OptionConverter.toInt(value, DEFAULT_BUFFER_SIZE);
      bf.resize(newSize);
    }
  }
  
  
}



class Dispatcher extends Thread {

  BoundedFIFO bf;
  AppenderAttachableImpl aai;
  boolean interrupted = false;
  AsyncAppender container;

  Dispatcher(BoundedFIFO bf, AsyncAppender container) {
    this.bf = bf;
    this.container = container;
    this.aai = container.aai;
    
    this.setPriority(Thread.MIN_PRIORITY);
    this.setName(""Dispatcher-""+getName());
    
    
    

  }

  void close() {
    synchronized(bf) {
      interrupted = true;   
      
      
      if(bf.length() == 0) {
	bf.notify();
      }
    }
  }



  
  public
  void run() {

    

    LoggingEvent event;
    
    while(true) {
      synchronized(bf) {
	if(bf.length() == 0) {
	  
	  if(interrupted) { 
	    
	    return;
	  }
	  try {
	    
	    bf.wait();
	  } catch(InterruptedException e) {
	    LogLog.error(""The dispathcer should not be interrupted."");
	    break;
	  }
	}
	event = bf.get();
	if(bf.wasFull()) {
	  
	  bf.notify();
	}
      } 
  
      
      
      synchronized(container.aai) {
	if(aai != null && event != null) {
	  aai.appendLoopOnAppenders(event);
	}
      }
    } 
  }
}
"
log4j,1.1,org.apache.log4j.helpers.DateTimeDateFormat,4,4,0,3,15,4,2,1,4,0.333333333,80,0.0,0,0.953488372,0.357142857,1,3,18.75,2,0.75,0,"

package org.apache.log4j.helpers;

import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;


public class DateTimeDateFormat extends AbsoluteTimeDateFormat {

  String[] shortMonths;

  public
  DateTimeDateFormat() {
    super();
    shortMonths = new DateFormatSymbols().getShortMonths();
  }
  
  public
  DateTimeDateFormat(TimeZone timeZone) {
    this();
    setCalendar(Calendar.getInstance(timeZone));
  }
  
  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    calendar.setTime(date);      

    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');        
    sbuf.append(shortMonths[calendar.get(Calendar.MONTH)]);
    sbuf.append(' ');    

    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    sbuf.append(' ');

    return super.format(date, sbuf, fieldPosition);
  }

  
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
log4j,1.1,org.apache.log4j.net.test.Loop,4,1,0,7,27,4,0,7,2,0.666666667,134,0.0,0,0.0,0.333333333,0,0,32.25,3,1.5,0,"

package org.apache.log4j.net.test;

import org.apache.log4j.*;
import org.apache.log4j.net.SocketAppender;

public class Loop {

  public static void main(String[] args) {
    
    
    Category root = Category.getRoot();
    Category cat = Category.getInstance(Loop.class.getName());

    if(args.length != 2) 
      usage(""Wrong number of arguments."");     

    String host = args[0];
    int port = 0;

    try {
      port = Integer.valueOf(args[1]).intValue();
    }
    catch (NumberFormatException e) {
        usage(""Argument ["" + args[1]  + ""] is not in proper int form."");
    }

    SocketAppender sa = new SocketAppender(host, port);
    Layout layout = new PatternLayout(""%5p [%t] %x %c - %m\n"");
    Appender so = new ConsoleAppender(layout, ""System.out"");
    root.addAppender(sa);
    root.addAppender(so);

    int i = 0;

    while(true) {
      NDC.push(""""+ (i++));
      cat.debug(""Debug message."");
      root.info(""Info message."");
      NDC.pop();
    }

  }

  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +Loop.class.getName() + "" host port"");
    System.exit(1);
  }
    

}
"
log4j,1.1,org.apache.log4j.or.ThreadGroupRenderer,2,1,0,2,16,1,0,2,2,2.0,100,0.0,0,0.0,0.75,0,0,49.0,3,1.5,0,"

package org.apache.log4j.or;

import org.apache.log4j.Layout;



public class ThreadGroupRenderer implements ObjectRenderer {

  public
  ThreadGroupRenderer() {
  }
  
  
  public
  String  doRender(Object o) {
    if(o instanceof ThreadGroup) {
      StringBuffer sbuf = new StringBuffer();
      ThreadGroup tg = (ThreadGroup) o;
      sbuf.append(""java.lang.ThreadGroup[name="");
      sbuf.append(tg.getName());
      sbuf.append("", maxpri="");
      sbuf.append(tg.getMaxPriority());
      sbuf.append(""]"");
      Thread[] t = new Thread[tg.activeCount()];
      tg.enumerate(t);
      for(int i = 0; i < t.length; i++) {
	sbuf.append(Layout.LINE_SEP);	
	sbuf.append(""   Thread=["");
	sbuf.append(t[i].getName());
	sbuf.append("","");
	sbuf.append(t[i].getPriority());
	sbuf.append("","");
	sbuf.append(t[i].isDaemon());
	sbuf.append(""]"");
      }
      return sbuf.toString();
    } else {
      
      return o.toString();
    }    
  }
}  
"
log4j,1.1,org.apache.log4j.net.test.SyslogMin,7,1,0,4,29,17,0,4,2,0.666666667,154,0.0,1,0.0,0.333333333,0,0,20.71428571,2,1.0,0,"


package org.apache.log4j.net.test;

import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;


public class SyslogMin {
  
  static Category CAT = Category.getInstance(SyslogMin.class.getName());
				     
  public 
  static 
  void main(String argv[]) {

      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test(""someHost"");
  }

  
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SyslogMin.class + "" configFile"");
    System.exit(1);
  }

  
  static
  void ProgramInit(String configFile) {
    int port = 0;
    PropertyConfigurator.configure(configFile);
  }

  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    CAT.debug( ""Message "" + i++);
    CAT.info( ""Message "" + i++);
    CAT.warn( ""Message "" + i++);
    CAT.error( ""Message "" + i++);
    CAT.log(Priority.FATAL, ""Message "" + i++);
    CAT.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
log4j,1.1,org.apache.log4j.spi.ErrorCode,0,1,0,0,0,0,0,0,0,2.0,7,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.log4j.spi;



public interface ErrorCode {

  public final int GENERIC_FAILURE = 0;
  public final int WRITE_FAILURE = 1;
  public final int FLUSH_FAILURE = 2;
  public final int CLOSE_FAILURE = 3;
  public final int FILE_OPEN_FAILURE = 4;
  public final int MISSING_LAYOUT = 5;
  public final int ADDRESS_PARSE_FAILURE = 6;
}
"
log4j,1.1,org.apache.log4j.helpers.RelativeTimeDateFormat,3,3,0,1,7,1,1,0,3,0.5,20,1.0,0,0.951219512,0.444444444,1,3,5.333333333,1,0.6667,0,"

package org.apache.log4j.helpers;

import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;


public class RelativeTimeDateFormat extends DateFormat {

  protected final long startTime;

  public
  RelativeTimeDateFormat() {
    this.startTime = System.currentTimeMillis();
  }
  
  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    
    return sbuf.append((date.getTime() - startTime));
  }

  
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
log4j,1.1,org.apache.log4j.RollingFileAppenderBeanInfo,3,2,0,1,15,1,0,1,2,0.833333333,105,0.333333333,0,0.818181818,0.5,0,0,33.0,1,0.6667,0,"

 

package org.apache.log4j;

import java.beans.*;
import org.apache.log4j.helpers.LogLog;
import java.lang.reflect.Method;

public class RollingFileAppenderBeanInfo extends SimpleBeanInfo {

  private PropertyDescriptor[] props;

  public
  RollingFileAppenderBeanInfo() {
    Class clazz = RollingFileAppender.class;
    try {
      
      BeanInfo bi = Introspector.getBeanInfo(clazz,
					     Introspector.IGNORE_ALL_BEANINFO);

      props = bi.getPropertyDescriptors();
      if(props != null) {
	for(int i = 0; i < props.length; i++) {
	  if(props[i].getName().equals(""maxFileSize"")) {
	    Method m = clazz.getMethod(""setMaxFileSize"", 
				       new Class[] {String.class});
	    props[i] = new PropertyDescriptor(""maxFileSize"", null, m);
	  }
	}
      }
      
      
      Introspector.flushFromCaches(RollingFileAppender.class);
    } catch(IntrospectionException e) {
      LogLog.error(""Could not inspect RollingFileAppender."", e);
    } catch(NoSuchMethodException e) {
      LogLog.error(""Could not find setter method for RollingFileAppender."", e);
    }
  }

  public
  PropertyDescriptor[] getPropertyDescriptors() {
    return props;
  }
}
"
log4j,1.1,org.apache.log4j.helpers.AbsoluteTimeDateFormat,4,3,2,4,12,6,4,0,4,1.333333333,111,0.0,0,0.951219512,0.357142857,1,3,26.0,6,1.75,0,"

package org.apache.log4j.helpers;

import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;

 


public class AbsoluteTimeDateFormat extends DateFormat {

  
  public final static String ABS_TIME_DATE_FORMAT = ""ABSOLUTE"";

  
  public final static String DATE_AND_TIME_DATE_FORMAT = ""DATE"";

  
  public final static String ISO8601_DATE_FORMAT = ""ISO8601"";

  public
  AbsoluteTimeDateFormat() {
    setCalendar(Calendar.getInstance());
  }
  
  public
  AbsoluteTimeDateFormat(TimeZone timeZone) {
    setCalendar(Calendar.getInstance(timeZone));
  }
  
  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    
    
    calendar.setTime(date); 
    
    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    if(hour < 10) {
      sbuf.append('0');
    }
    sbuf.append(hour);
    sbuf.append(':');

    int mins = calendar.get(Calendar.MINUTE);
    if(mins < 10) {
      sbuf.append('0');
    }
    sbuf.append(mins);
    sbuf.append(':');
    
    int secs = calendar.get(Calendar.SECOND);
    if(secs < 10) {
      sbuf.append('0');
    }
    sbuf.append(secs);
    sbuf.append(',');
    
    int millis = calendar.get(Calendar.MILLISECOND);
    if(millis < 100) 
      sbuf.append('0');
    if(millis < 10) 
      sbuf.append('0');
    
    sbuf.append(millis);
    return sbuf;
  }

  
  public
  Date parse(String s, ParsePosition pos) {
    return null;
  }  
}
"
log4j,1.1,org.apache.log4j.test.DelayedLoop,7,1,0,3,25,17,0,3,2,0.833333333,105,0.0,1,0.0,0.277777778,0,0,13.57142857,2,1.1429,0,"

package org.apache.log4j.test; 

import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;


public class DelayedLoop {

  static Category cat = Category.getInstance(DelayedLoop.class);
  static int loopLength;

  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }


  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DelayedLoop.class.getName() +
			""configFile"");
    System.exit(1);
  }

  
  static
  void init(String configFile) {
    if(configFile.endsWith(""xml"")) {
      DOMConfigurator.configureAndWatch(configFile, 3000);
    } else {
      PropertyConfigurator.configureAndWatch(configFile, 3000);
    }
  }

  static
  void test() {
    int i = 0;
    while(true) {
      cat.debug(""MSG ""+i++);
      try {
	Thread.currentThread().sleep(1000);
      } catch(Exception e) {}
    }
  }
}
"
log4j,1.1,org.apache.log4j.or.ObjectRenderer,1,1,0,7,1,0,7,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.log4j.or;


public interface ObjectRenderer {

  
  public
  String doRender(Object o);
}
"
log4j,1.1,org.apache.log4j.net.SimpleSocketServer,6,1,0,4,30,9,0,4,2,0.666666667,144,0.0,1,0.0,0.333333333,0,0,22.5,2,1.0,1,"

package org.apache.log4j.net;

import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;

import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;




public class SimpleSocketServer  {

  static Category cat = Category.getInstance(SimpleSocketServer.class.getName());

  static int port;
  
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	cat.info(""Connected to client at "" + socket.getInetAddress());
	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, 
				  Category.getDefaultHierarchy())).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }

  
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SimpleSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
    
  static
  void init(String portStr, String configFile) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
log4j,1.1,org.apache.log4j.net.SocketNode,4,1,0,7,25,0,3,4,2,0.733333333,109,0.0,2,0.0,0.416666667,0,0,25.0,2,0.75,3,"







package org.apache.log4j.net;

import java.net.InetAddress;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.InputStream;
import java.io.IOException;
import java.io.ObjectInputStream;


import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;




public class SocketNode implements Runnable {

  Socket socket;
  Hierarchy hierarchy;
  ObjectInputStream ois;

  static Category cat = Category.getInstance(SocketNode.class.getName());

  public 
  SocketNode(Socket socket, Hierarchy hierarchy) {
    this.socket = socket;
    this.hierarchy = hierarchy;
    try {
      ois = new ObjectInputStream(socket.getInputStream());
    }
    catch(Exception e) {
      cat.error(""Could not open ObjectInputStream to ""+socket, e);
    }
  }

  
  
  
  
  

  public void run() {
    LoggingEvent event;
    Category remoteCategory;

    try {
      while(true) {	
	event = (LoggingEvent) ois.readObject();	
	remoteCategory = hierarchy.getInstance(event.categoryName);
	event.category = remoteCategory;
	if(event.priority.isGreaterOrEqual(remoteCategory.getChainedPriority())) {
	  remoteCategory.callAppenders(event);	
	}
      }
    }
    catch(java.io.EOFException e) {
      cat.info(""Caught java.io.EOFException closing conneciton."");
    }
    catch(java.net.SocketException e) {
      cat.info(""Caught java.net.SocketException closing conneciton."");
    }
    catch(Exception e) {
      cat.error(""Unexpected exception. Closing conneciton."", e);
    }
    
    try {
      ois.close();
    }
    catch(Exception e) {
      cat.info(""Could not close connection."", e);	
    }  
  }
}
"
log4j,1.1,org.apache.log4j.performance.ListVsVector,5,1,0,1,17,0,0,1,2,0.5,163,0.0,1,0.0,0.25,0,0,30.8,3,1.4,0,"

package org.apache.log4j.performance;


import java.util.Vector;


public class ListVsVector {

  static int RUN_LENGTH = 1000000;
  static Vector v = new Vector();
  static Chain head;
  static String tmp;

  static
  public 
  void main(String[] args) {

    v.addElement(""aaa"");
    v.addElement(""bbb"");
    v.addElement(""ccc"");
    v.addElement(""ddd"");
    v.addElement(""eee"");
    
    Chain c = new Chain(""aaa"");
    head = c;
    c.next = new Chain(""bbb""); c = c.next;
    c.next = new Chain(""ccc""); c = c.next;
    c.next = new Chain(""ddd""); c = c.next;
    c.next = new Chain(""eee"");
    double t;
    t = loopChain();
    System.out.println(""Looping thourgh the chain took "" + t);

    t = loopVector();
    System.out.println(""Looping thourgh the vector took "" + t);

  }

  static
  double loopChain() {
    long before = System.currentTimeMillis();
    Chain c;
    for(int i = 0; i < RUN_LENGTH; i++) {
      c = head;
      while(c != null) {
	tmp = c.s;
	c = c.next;
      }
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static
  double loopVector() {
    long before = System.currentTimeMillis();
    int size = v.size();
    for(int i = 0; i < RUN_LENGTH; i++) {
      for(int j = 0; j < size; j++)
	tmp = (String) v.elementAt(j);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static class Chain {
    public String s;
    public Chain next;

    Chain(String s) {
      this.s = s;
    }
    
    void setNext(Chain c) {
      next = c;
    }
  }
}
"
log4j,1.1,org.apache.log4j.test.Finalize,9,1,0,3,34,34,0,3,2,0.875,167,0.0,1,0.0,0.175,0,0,17.33333333,3,1.4444,0,"

package org.apache.log4j.test; 

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Enumeration;

public class Finalize {

  static Category CAT = Category.getInstance(Finalize.class.getName());

  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");

    test();
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Finalize.class.getName() +
			"" configFile"");
    System.exit(1);
  }

  
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }

  static
  void test() {
    int i = -1;

    InputStreamReader in = new InputStreamReader(System.in);	    
    Category root = Category.getRoot();

    System.out.println(""Type 'q' to quit"");
    int j = 0;
    while (true) {
      System.gc();      
      try {i = in.read(); }
      catch(Exception e) { return; }
      System.gc();
      System.out.println(""Read [""+i+""]."");
      if(i == -1)
	break;
      else if(i == 'q')
	break;
      else 
	root.debug(""Hello "" + (++j));
    } 

    
    root.removeAllAppenders();
    System.gc(); delay(3000);
    System.gc(); delay(3000);    
    System.gc(); delay(3000);  System.gc();
  }
  
  static
  void foo(Category cat) {    
    Enumeration enum = cat.getAllAppenders();
    while(enum != null && enum.hasMoreElements()) {
      ((org.apache.log4j.Appender) enum.nextElement()).close();
    }
  }
    

  
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
  
}
"
log4j,1.1,org.apache.log4j.test.MultipleAppenders,2,1,0,3,20,1,0,3,2,2.0,85,0.0,0,0.0,0.5,0,0,41.5,6,3.0,0,"

package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Appender;
import java.util.Enumeration;
import java.util.Vector;

public class MultipleAppenders {

  public 
  static 
  void main(String argv[]) {

    
    PropertyConfigurator.configure(argv[0]);

    Category root = Category.getRoot();

    Enumeration e1 = root.getAllAppenders();
    Vector v = new Vector(1);
    
    while(e1.hasMoreElements()) {
      Appender a = (Appender) e1.nextElement();
      v.addElement(a);
      String appenderName = a.getName();	
      if(a != root.getAppender(appenderName)) {
	System.out.println(appenderName + "" lookup failed. Exiting."");
	System.exit(1);
      }
      
      root.addAppender(a);
    }

    
    root.addAppender(null);

    Enumeration e2 = root.getAllAppenders();

    for(int i = 0; i < v.size(); i++) {
      if(v.elementAt(i) != e2.nextElement()) {
      }
    }

    if(e2.hasMoreElements()){
      System.out.println(""Failure, e2 has remaining elements. Exiting."");
      System.exit(1);      
    }
    System.out.println(""OK"");
  }

  
}
"
log4j,1.1,org.apache.log4j.spi.CategoryFactory,1,1,0,6,1,0,6,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.log4j.spi;

import org.apache.log4j.Category;


public interface CategoryFactory {

 
  public
  Category makeNewCategoryInstance(String name);

}
"
log4j,1.1,org.apache.log4j.helpers.PatternParser,8,1,0,15,41,8,4,14,2,0.956043956,693,0.461538462,3,0.0,0.375,0,0,82.375,21,6.25,0,"
package org.apache.log4j.helpers;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.Layout;
import org.apache.log4j.NDC;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;






public class PatternParser {

  private static final char ESCAPE_CHAR = '%';
  
  private static final int LITERAL_STATE = 0;
  private static final int CONVERTER_STATE = 1;
  private static final int MINUS_STATE = 2;
  private static final int DOT_STATE = 3;
  private static final int MIN_STATE = 4;
  private static final int MAX_STATE = 5;

  static final int FULL_LOCATION_CONVERTER = 1000;
  static final int METHOD_LOCATION_CONVERTER = 1001;
  static final int CLASS_LOCATION_CONVERTER = 1002;
  static final int LINE_LOCATION_CONVERTER = 1003;
  static final int FILE_LOCATION_CONVERTER = 1004;    

  static final int RELATIVE_TIME_CONVERTER = 2000;
  static final int THREAD_CONVERTER = 2001;
  static final int PRIORITY_CONVERTER = 2002;
  static final int NDC_CONVERTER = 2003;
  static final int MESSAGE_CONVERTER = 2004;

  int state;
  protected StringBuffer currentLiteral = new StringBuffer(32);
  protected int patternLength;
  protected int i;
  PatternConverter head;
  PatternConverter tail;
  protected FormattingInfo formattingInfo = new FormattingInfo();
  protected String pattern;

  public
  PatternParser(String pattern) {
    this.pattern = pattern;
    patternLength =  pattern.length();    
    state = LITERAL_STATE;
  }

  private
  void  addToList(PatternConverter pc) {
    if(head == null) {
      head = tail = pc;
    } else {
      tail.next = pc;
      tail = pc;    
    }
  }

  private
  String extractOption() {
    if((i < patternLength) && (pattern.charAt(i) == '{')) {
      int end = pattern.indexOf('}', i);	
      if (end > i) {
	String r = pattern.substring(i + 1, end);
	i = end+1;
	return r;
      }
    }
    return null;
  }


  
  private
  int extractPrecisionOption() {
    String opt = extractOption();
    int r = 0;
    if(opt != null) {
      try {
	r = Integer.parseInt(opt);
	if(r <= 0) {
	    LogLog.error(
	        ""Precision option ("" + opt + "") isn't a positive integer."");
	    r = 0;
	}
      }      
      catch (NumberFormatException e) {
	LogLog.error(""Category option \""""+opt+""\"" not a decimal integer."", e);
      }      
    }
    return r;    
  }
      
  public 
  PatternConverter parse() {
    char c;
    i = 0;
    while(i < patternLength) {
      c = pattern.charAt(i++);
      switch(state) {
      case LITERAL_STATE: 
        
        if(i == patternLength) {
          currentLiteral.append(c);
          continue;
        }
        if(c == ESCAPE_CHAR) {      
          
          switch(pattern.charAt(i)) {
          case ESCAPE_CHAR:
            currentLiteral.append(c);
            i++; 
            break;
          case 'n':
            currentLiteral.append(Layout.LINE_SEP);
            i++; 
            break;
          default:
            if(currentLiteral.length() != 0) {
              addToList(new LiteralPatternConverter(
                                                  currentLiteral.toString()));
              
              
            }
            currentLiteral.setLength(0); 
            currentLiteral.append(c); 
            state = CONVERTER_STATE;
            formattingInfo.reset();
          }
        }
        else {
          currentLiteral.append(c);
        }
        break;
      case CONVERTER_STATE:
	currentLiteral.append(c);
	switch(c) {
	case '-':
	  formattingInfo.leftAlign = true;
	  break;
	case '.':
	  state = DOT_STATE;
	  break;
	default:
	  if(c >= '0' && c <= '9') {
	    formattingInfo.min = c - '0';
	    state = MIN_STATE;
	  }
	  else 
	    finalizeConverter(c);	    
	} 
	break;
      case MIN_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.min = formattingInfo.min*10 + (c - '0');
	else if(c == '.')
	  state = DOT_STATE;
	else {
	  finalizeConverter(c);
	}
	break;
      case DOT_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') {
	  formattingInfo.max = c - '0';
	   state = MAX_STATE;
	}
	else {
	  LogLog.error(""Error occured in position ""+i
		     +"".\n Was expecting digit, instead got char \""""+c+""\""."");
	  state = LITERAL_STATE;
	}
	break;
      case MAX_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.max = formattingInfo.max*10 + (c - '0');
	else {
	  finalizeConverter(c);
	  state = LITERAL_STATE;
	}
	break;
      } 
    } 
    if(currentLiteral.length() != 0) {
      addToList(new LiteralPatternConverter(currentLiteral.toString()));
      
    }
    return head;
  }

  protected
  void finalizeConverter(char c) {
    PatternConverter pc = null;
    switch(c) {
    case 'c':
      pc = new CategoryPatternConverter(formattingInfo,
					extractPrecisionOption());	
      
      
      currentLiteral.setLength(0);
      break;     
    case 'C':
      pc = new ClassNamePatternConverter(formattingInfo,
					 extractPrecisionOption());
      
      
      currentLiteral.setLength(0);
      break;
    case 'd':
      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;
      DateFormat df;
      String dOpt = extractOption();
      if(dOpt != null)
	dateFormatStr = dOpt;
      
      if(dateFormatStr.equalsIgnoreCase(
                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) 
	df = new  ISO8601DateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
	df = new AbsoluteTimeDateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
	df = new DateTimeDateFormat();
      else {
	try {
	  df = new SimpleDateFormat(dateFormatStr);
	}
	catch (IllegalArgumentException e) {
	  LogLog.error(""Could not instantiate SimpleDateFormat with "" +
		       dateFormatStr, e);
	  df = (DateFormat) OptionConverter.instantiateByClassName(
			           ""org.apache.log4j.helpers.ISO8601DateFormat"",
				   DateFormat.class, null);
	}	
      }
      pc = new DatePatternConverter(formattingInfo, df);
      
      
      currentLiteral.setLength(0);
      break;
    case 'F':
      pc = new LocationPatternConverter(formattingInfo,
					FILE_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'l':
      pc = new LocationPatternConverter(formattingInfo,
					FULL_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'L':
      pc = new LocationPatternConverter(formattingInfo,
					LINE_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'm':
      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'M':
      pc = new LocationPatternConverter(formattingInfo,
					METHOD_LOCATION_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'p':
      pc = new BasicPatternConverter(formattingInfo, PRIORITY_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 'r':
      pc = new BasicPatternConverter(formattingInfo, 
					 RELATIVE_TIME_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
    case 't':
      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);
      
      
      currentLiteral.setLength(0);
      break;
      
    case 'x':
      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);
      
      currentLiteral.setLength(0);
      break;
    default:
      LogLog.error(""Unexpected char ["" +c+""] at position ""+i
		   +"" in conversion patterrn."");
      pc = new LiteralPatternConverter(currentLiteral.toString());
      currentLiteral.setLength(0);
    }
    
    addConverter(pc);
  }

  protected
  void addConverter(PatternConverter pc) {
    currentLiteral.setLength(0);
    
    addToList(pc);
    
    state = LITERAL_STATE;
    
    formattingInfo.reset();
  }

  
  
  
    
  private static class BasicPatternConverter extends PatternConverter {
    int type;
    
    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);     
      this.type = type;
    }

    public
    String convert(LoggingEvent event) {
      switch(type) {
      case RELATIVE_TIME_CONVERTER: 
	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));
      case THREAD_CONVERTER:
	return event.getThreadName();
      case PRIORITY_CONVERTER:
	return event.priority.toString();
      case NDC_CONVERTER:  
	return event.getNDC();
      case MESSAGE_CONVERTER: {
	return event.getRenderedMessage();
      }
      default: return null;
      }
    }
  }
  
  private static class LiteralPatternConverter extends PatternConverter {
    private String literal;
  
    LiteralPatternConverter(String value) {
      literal = value;
    }

    public
    final
    void format(StringBuffer sbuf, LoggingEvent event) {
      sbuf.append(literal);
    }
    
    public    
    String convert(LoggingEvent event) {
      return literal;
    }
  }

  private static class DatePatternConverter extends PatternConverter {
    private DateFormat df;
    private Date date;
    
    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
      super(formattingInfo);
      date = new Date();
      this.df = df;      
    }

    public
    String convert(LoggingEvent event) {
      date.setTime(event.timeStamp);
      String converted = null;
      try {
        converted = df.format(date);
      }
      catch (Exception ex) {
        LogLog.error(""Error occured while converting date."", ex);
      }
      return converted;
    }
  }

  private class LocationPatternConverter extends PatternConverter {
    int type;
    
    LocationPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }
    
    public
    String convert(LoggingEvent event) {
      LocationInfo locationInfo = event.getLocationInformation();
      switch(type) {
      case FULL_LOCATION_CONVERTER: 
	return locationInfo.fullInfo;
      case METHOD_LOCATION_CONVERTER: 
	return locationInfo.getMethodName();
      case LINE_LOCATION_CONVERTER: 
	return locationInfo.getLineNumber();
      case FILE_LOCATION_CONVERTER: 
	return locationInfo.getFileName();
      default: return null;
      }
    }
  }

  private static abstract class NamedPatternConverter extends PatternConverter {
    int precision;
    
    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo);
      this.precision =  precision;      
    }

    abstract
    String getFullyQualifiedName(LoggingEvent event);
    
    public
    String convert(LoggingEvent event) {
      String n = getFullyQualifiedName(event);
      if(precision <= 0)
	return n;
      else {
	int len = n.length();

	
	
	
	int end = len -1 ;
	for(int i = precision; i > 0; i--) {	  
	  end = n.lastIndexOf('.', end-1);
	  if(end == -1)
	    return n;
	}
	return n.substring(end+1, len);
      }      
    }
  }
  
  private class ClassNamePatternConverter extends NamedPatternConverter {

    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    
    String getFullyQualifiedName(LoggingEvent event) {
      return event.getLocationInformation().getClassName();
    }
  }
  
  private class CategoryPatternConverter extends NamedPatternConverter {

    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    
    String getFullyQualifiedName(LoggingEvent event) {
      return event.categoryName;
    }
  }  
}

"
log4j,1.1,org.apache.log4j.net.SocketServer,8,1,0,6,48,6,0,6,2,0.666666667,356,0.0,3,0.0,0.257142857,0,0,42.375,3,1.75,1,"

package org.apache.log4j.net;

import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.io.IOException;
import java.io.File;
import java.util.Hashtable;

import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.RootCategory;




public class SocketServer  {

  static String GENERIC = ""generic"";
  static String CONFIG_FILE_EXT = "".lcf"";

  static Category cat = Category.getInstance(SocketServer.class);  
  static SocketServer server;
  static int port;

  
  Hashtable hierarchyMap;
  Hierarchy genericHierarchy;
  File dir;

  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1], argv[2]);
    else 
      usage(""Wrong number of arguments."");     
    
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	InetAddress inetAddress =  socket.getInetAddress();
	cat.info(""Connected to client at "" + inetAddress);

	Hierarchy h = (Hierarchy) server.hierarchyMap.get(inetAddress);
	if(h == null) {
	  h = server.configureHierarchy(inetAddress);
	} 

	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, h)).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }

  
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SocketServer.class.getName() + "" port configFile directory"");
    System.exit(1);
  }
    
  static
  void init(String portStr, String configFile, String dirStr) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    
    PropertyConfigurator.configure(configFile);
    
    File dir = new File(dirStr);    
    if(!dir.isDirectory()) {
      usage(""[""+dirStr+""] is not a directory."");
    }
    server = new SocketServer(dir);
  }


  public
  SocketServer(File directory) {
    this.dir = directory;
    hierarchyMap = new Hashtable(11);
  }

  
  
  Hierarchy configureHierarchy(InetAddress inetAddress) {
    cat.info(""Locating configuration file for ""+inetAddress);
    
    
    String s = inetAddress.toString();
    int i = s.indexOf(""/"");
    if(i == -1) {
      cat.warn(""Could not parse the inetAddress [""+inetAddress+
	       ""]. Using default hierarchy."");
      return genericHierarchy();
    } else {
      String key = s.substring(0, i);
      
      File configFile = new File(dir, key+CONFIG_FILE_EXT);
      if(configFile.exists()) {
	Hierarchy h = new Hierarchy(new RootCategory(Priority.DEBUG));
	hierarchyMap.put(inetAddress, h);
	
	new PropertyConfigurator().doConfigure(configFile.getAbsolutePath(), h);

	return h;	
      } else {
	cat.warn(""Could not find config file [""+configFile+""]."");
	return genericHierarchy();
      }
    }
  }

  Hierarchy genericHierarchy() {
    if(genericHierarchy == null) {
      File f = new File(dir, GENERIC+CONFIG_FILE_EXT);
      if(f.exists()) {
	genericHierarchy = new Hierarchy(new RootCategory(Priority.DEBUG));
	new PropertyConfigurator().doConfigure(f.getAbsolutePath(), genericHierarchy);
      } else {
	cat.warn(""Could not find config file [""+f+
		 ""]. Will use the default hierarchy."");
	genericHierarchy = Category.getDefaultHierarchy();
      }
    }
    return genericHierarchy;
  }
}
"
log4j,1.1,org.apache.log4j.config.PropertySetter,10,1,0,7,49,13,1,6,6,0.694444444,386,0.5,0,0.0,0.35,0,0,37.2,11,2.9,2,"

package org.apache.log4j.config;

import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.*;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;


public class PropertySetter {
  protected Object obj;
  protected PropertyDescriptor[] props;
  
  
  public
  PropertySetter(Object obj) {
    this.obj = obj;
  }
  
  
  protected
  void introspect() {
    try {
      BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
      props = bi.getPropertyDescriptors();
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect ""+obj+"": "" + ex.getMessage());
      props = new PropertyDescriptor[0];
    }
  }
  

  
  public
  static
  void setProperties(Object obj, Properties properties, String prefix) {
    new PropertySetter(obj).setProperties(properties, prefix);
  }
  

  
  public
  void setProperties(Properties properties, String prefix) {
    int len = prefix.length();
    
    for (Enumeration e = properties.keys(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      
      
      if (key.startsWith(prefix)) {

	
	
        if (key.indexOf('.', len + 1) > 0) {
	  
	  
	  continue;
	}
        
	String value = OptionConverter.findAndSubst(key, properties);
        key = key.substring(len);
        if (""layout"".equals(key) && obj instanceof Appender) {
          continue;
        }        
        setProperty(key, value);
      }
    }
    activate();
  }
  
  
  public
  void setProperty(String name, String value) {
    if (value == null) return;
    
    name = Introspector.decapitalize(name);
    PropertyDescriptor prop = getPropertyDescriptor(name);
    
    

    if (prop == null) {
      LogLog.warn(""No such property ["" + name + ""] in ""+
		  obj.getClass().getName()+""."" );
    } else {
      try {
        setProperty(prop, name, value);
      } catch (PropertySetterException ex) {
        LogLog.warn(""Failed to set property "" + name +
                    "" to value \"""" + value + ""\"". "" + ex.getMessage());
      }
    }
  }
  
  
  public
  void setProperty(PropertyDescriptor prop, String name, String value)
    throws PropertySetterException {
    Method setter = prop.getWriteMethod();
    if (setter == null) {
      throw new PropertySetterException(""No setter for property"");
    }
    Class[] paramTypes = setter.getParameterTypes();
    if (paramTypes.length != 1) {
      throw new PropertySetterException(""#params for setter != 1"");
    }
    
    Object arg;
    try {
      arg = convertArg(value, paramTypes[0]);
    } catch (Throwable t) {
      throw new PropertySetterException(""Conversion to type [""+paramTypes[0]+
					""] failed. Reason: ""+t);
    }
    if (arg == null) {
      throw new PropertySetterException(
          ""Conversion to type [""+paramTypes[0]+""] failed."");
    }
    LogLog.debug(""Setting property ["" + name + ""] to ["" +arg+""]."");
    try {
      setter.invoke(obj, new Object[]  { arg });
    } catch (Exception ex) {
      throw new PropertySetterException(ex);
    }
  }
  

  
  protected
  Object convertArg(String val, Class type) {
    if(val == null)
      return null;

    String v = val.trim();
    if (String.class.isAssignableFrom(type)) {
      return val;
    } else if (Integer.TYPE.isAssignableFrom(type)) {
      return new Integer(v);
    } else if (Long.TYPE.isAssignableFrom(type)) {
      return new Long(v);
    } else if (Boolean.TYPE.isAssignableFrom(type)) {
      if (""true"".equalsIgnoreCase(v)) {
        return Boolean.TRUE;
      } else if (""false"".equalsIgnoreCase(v)) {
        return Boolean.FALSE;
      }
    } else if (Priority.class.isAssignableFrom(type)) {
      return OptionConverter.toPriority(v, Priority.DEBUG);
    }
    return null;
  }
  
  
  protected
  PropertyDescriptor getPropertyDescriptor(String name) {
    if (props == null) introspect();
    
    for (int i = 0; i < props.length; i++) {
      if (name.equals(props[i].getName())) {
	return props[i];
      }
    }
    return null;
  }
  
  public
  void activate() {
    if (obj instanceof OptionHandler) {
      ((OptionHandler) obj).activateOptions();
    }
  }
}
"
log4j,1.1,org.apache.log4j.helpers.ISO8601DateFormat,4,4,0,3,12,6,2,1,4,2.0,99,0.0,0,0.953488372,0.357142857,1,3,23.75,3,1.0,0,"

package org.apache.log4j.helpers;

import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;




public class ISO8601DateFormat extends AbsoluteTimeDateFormat {

  public
  ISO8601DateFormat() {
  }
      
  public
  ISO8601DateFormat(TimeZone timeZone) {
    super(timeZone);
  }
  
  
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    calendar.setTime(date);      

    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);

    String month;
    switch(calendar.get(Calendar.MONTH)) {
    case Calendar.JANUARY: month = ""-01-""; break;      
    case Calendar.FEBRUARY: month = ""-02-"";  break;     
    case Calendar.MARCH: month = ""-03-""; break;      
    case Calendar.APRIL: month = ""-04-"";  break;     
    case Calendar.MAY: month = ""-05-""; break;      
    case Calendar.JUNE: month = ""-06-"";  break;     
    case Calendar.JULY: month = ""-07-""; break;      
    case Calendar.AUGUST: month = ""-08-"";  break;     
    case Calendar.SEPTEMBER: month = ""-09-""; break;      
    case Calendar.OCTOBER: month = ""-10-""; break;      
    case Calendar.NOVEMBER: month = ""-11-"";  break;           
    case Calendar.DECEMBER: month = ""-12-"";  break;
    default: month = ""-NA-""; break;
    }
    sbuf.append(month);

    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);

    sbuf.append(' ');    
    return super.format(date, sbuf, fieldPosition);
  }

  
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
log4j,1.1,org.apache.log4j.helpers.AppenderAttachableImpl,8,1,0,6,22,0,3,3,8,0.142857143,176,1.0,0,0.0,0.40625,0,0,20.875,5,3.125,0,"

package org.apache.log4j.helpers;

import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;

import org.apache.log4j.Appender;
import java.util.Vector;
import java.util.Enumeration;


public class AppenderAttachableImpl implements AppenderAttachable {
  
  
  protected Vector  appenderList;

  
  public
  void addAppender(Appender newAppender) {
    
    if(newAppender == null)
      return;
    
    if(appenderList == null) {
      appenderList = new Vector(1);
    }
    if(!appenderList.contains(newAppender))
      appenderList.addElement(newAppender);
  }

  
  public
  int appendLoopOnAppenders(LoggingEvent event) {
    int size = 0;
    Appender appender;

    if(appenderList != null) {
      size = appenderList.size();
      for(int i = 0; i < size; i++) {
	appender = (Appender) appenderList.elementAt(i);
	appender.doAppend(event);
      }
    }    
    return size;
  }


  
  public
  Enumeration getAllAppenders() {
    if(appenderList == null)
      return null;
    else 
      return appenderList.elements();    
  }

  
  public
  Appender getAppender(String name) {
     if(appenderList == null || name == null)
      return null;

     int size = appenderList.size();
     Appender appender;
     for(int i = 0; i < size; i++) {
       appender = (Appender) appenderList.elementAt(i);
       if(name.equals(appender.getName()))
	  return appender;
     }
     return null;    
  }

  
  public
  void removeAllAppenders() {
    if(appenderList != null) {
      int len = appenderList.size();      
      for(int i = 0; i < len; i++) {
	Appender a = (Appender) appenderList.elementAt(i);
	a.close();
      }
      appenderList.removeAllElements();
      appenderList = null;      
    }
  }


  
  public
  void removeAppender(Appender appender) {
    if(appender == null || appenderList == null) 
      return;
    appenderList.removeElement(appender);    
  }


 
  public
  void removeAppender(String name) {
    if(name == null || appenderList == null) return;
    int size = appenderList.size();
    for(int i = 0; i < size; i++) {
      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {
	 appenderList.removeElementAt(i);
	 break;
      }
    }
  }

}
"
log4j,1.1,org.apache.log4j.Layout,10,1,4,26,13,45,24,2,9,1.0,28,0.0,0,0.0,0.407407407,0,0,1.6,1,0.8,0,"

package org.apache.log4j;

import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;


  
public abstract class Layout implements OptionHandler {

  
  
  public final static String LINE_SEP = System.getProperty(""line.separator"");
  public final static int LINE_SEP_LEN  = LINE_SEP.length();


  
  abstract
  public
  String format(LoggingEvent event);

  
  public
  String getContentType() {
    return ""text/plain"";
  }

  
  public
  String getHeader() {
    return null;
  }

  
  public
  String getFooter() {
    return null;
  }



  
  abstract
  public
  boolean ignoresThrowable();

}
"
log4j,1.1,org.apache.log4j.test.Base64,5,1,0,0,15,8,0,0,1,0.833333333,479,0.0,0,0.0,0.3125,0,0,94.2,7,2.0,0,"



package org.apache.log4j.test;

class Base64 {

  final static int MAX_LINE = 76;
  
  static byte[] asciiEncoding =
    
    {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
    
    82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,
    
    104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
    
    118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47}; 

  static char[] charEnc = new char[64];

  static {
    for(int i = 0; i < 26; i ++) {
      charEnc[i] = (char) ('A' + i);
      charEnc[i+26] = (char) ('a' + i);
    }
    for(int i = 0; i < 10; i ++) {
      charEnc[i+52] = (char) ('0' + i);
    }
    charEnc[62] = '+';
    charEnc[63] = '/';
  }

  
  
  static
  String toString(byte[] inbuf) {
    return toString(inbuf, 0, inbuf.length);
  }
  
  static
  String toString(byte[] inbuf, int offset, int length) {
    
    StringBuffer output = new StringBuffer((length)*4/3 + 1);

    int in;
    char[] out = new char[4];
    
    int i = offset;
    boolean ended = false;
    int last = offset + length;
    int j;
    int bitsRead;
        
    while(!ended) {
      in = 0;
      bitsRead = 0;
      for(j = 0; j < 3; j++) {
	if(i == last) {
	  ended = true;
	  break;
	}
	in = (in << 8) | (inbuf[i++] & 0xFF);
	bitsRead += 8;
      }

      while(bitsRead >= 6) {
	bitsRead -= 6;
	output.append(charEnc[(in >>> bitsRead) & 0x3F]);
      }

      if(bitsRead == 4) {
	output.append(charEnc[(in & 0x0F) << 2]);
	output.append(""="");
      }
      else if (bitsRead == 2) {
	output.append(charEnc[(in & 0x03) << 4]);
	output.append(""=="");
      }
    }
    return output.toString();
  }


  public static void main(String[] args) {

    byte[] inbuf = new byte[MAX_LINE];

    while(true) {
      try {
	int read = System.in.read(inbuf, 0, MAX_LINE);
	if(read == -1) break;
	System.out.println(""Read "" + read + "" chars."");
	System.out.println(Base64.toString(inbuf, 0, read));
      }
      catch (Exception e) {
	System.out.println(""Exception "" + e);
      }

    }
  }
}
"
log4j,1.1,org.apache.log4j.net.SyslogAppender,18,2,0,8,42,81,0,8,17,1.0,517,0.064516129,1,0.545454545,0.259259259,2,4,26.0,22,3.9444,1,"

package org.apache.log4j.net;

import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;

import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.SyslogWriter;
import org.apache.log4j.helpers.SyslogQuietWriter;





public class SyslogAppender extends AppenderSkeleton {
  
  
  
  
  
  final static public int LOG_KERN     = 0; 
  
  final static public int LOG_USER     = 1<<3; 
  
  final static public int LOG_MAIL     = 2<<3; 
  
  final static public int LOG_DAEMON   = 3<<3; 
  
  final static public int LOG_AUTH     = 4<<3; 
  
  final static public int LOG_SYSLOG   = 5<<3; 
                                               
    
  final static public int LOG_LPR      = 6<<3; 
  
  final static public int LOG_NEWS     = 7<<3; 
  
  final static public int LOG_UUCP     = 8<<3; 
  
  final static public int LOG_CRON     = 9<<3; 
  
  final static public int LOG_AUTHPRIV = 10<<3; 
  
  final static public int LOG_FTP      = 11<<3; 

  
  
  final static public int LOG_LOCAL0 = 16<<3; 
  
  final static public int LOG_LOCAL1 = 17<<3; 
  
  final static public int LOG_LOCAL2 = 18<<3; 
  
  final static public int LOG_LOCAL3 = 19<<3; 
  
  final static public int LOG_LOCAL4 = 20<<3; 
  
  final static public int LOG_LOCAL5 = 21<<3; 
  
  final static public int LOG_LOCAL6 = 22<<3; 
  
  final static public int LOG_LOCAL7 = 23<<3; 

   
  public static final String SYSLOG_HOST_OPTION = ""SyslogHost"";

   
  public static final String FACILITY_OPTION = ""Facility"";  

   
  public static final String FACILITY_PRINTING_OPTION = ""FacilityPrinting"";  

  protected static final int SYSLOG_HOST_OI = 0;
  protected static final int FACILITY_OI = 1;
  
  static final String TAB = ""    "";

  
  int syslogFacility = LOG_USER;
  String facilityStr;  
  boolean facilityPrinting = false;
  
  
  SyslogQuietWriter sqw;  
  String syslogHost;
  
  public
  SyslogAppender() {
    this.initSyslogFacilityStr();
  }
  
  public
  SyslogAppender(Layout layout, int syslogFacility) {
    this.layout = layout;
    this.syslogFacility = syslogFacility;    
    this.initSyslogFacilityStr();
  }
		 
  public
  SyslogAppender(Layout layout, String syslogHost, int syslogFacility) {
    this(layout, syslogFacility);
    setSyslogHost(syslogHost);
  }

  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		      new String[] {SYSLOG_HOST_OPTION, FACILITY_OPTION,
			            FACILITY_PRINTING_OPTION});
  }
  
  
  public
  void setOption(String option, String value) {
    if(value == null) return;
    
    super.setOption(option, value);    
    
    if(option.equals(SYSLOG_HOST_OPTION)) 
      this.setSyslogHost(value);
    else if(option.equals(FACILITY_PRINTING_OPTION))
      facilityPrinting = OptionConverter.toBoolean(value, facilityPrinting);
    else if(option.equals(FACILITY_OPTION)) {
      this.setFacility(value);
    }
  }
  

  
  synchronized
  public
  void close() {
    closed = true;
    
    
    sqw = null;
  }
  
  private
  void initSyslogFacilityStr() {
    facilityStr = getFacilityString(this.syslogFacility);
    
    if (facilityStr == null) {
      System.err.println(""\"""" + syslogFacility +
                  ""\"" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
      facilityStr = ""user:"";
    } else {
      facilityStr += "":"";
    }
  }	   

  
  public
  static
  String getFacilityString(int syslogFacility) {
    switch(syslogFacility) {
    case LOG_KERN:      return ""kern"";
    case LOG_USER:      return ""user"";
    case LOG_MAIL:      return ""mail"";
    case LOG_DAEMON:    return ""daemon"";
    case LOG_AUTH:      return ""auth"";
    case LOG_SYSLOG:    return ""syslog"";
    case LOG_LPR:       return ""lpr"";
    case LOG_NEWS:      return ""news"";
    case LOG_UUCP:      return ""uucp"";
    case LOG_CRON:      return ""cron"";
    case LOG_AUTHPRIV:  return ""authpriv"";
    case LOG_FTP:       return ""ftp"";
    case LOG_LOCAL0:    return ""local0"";
    case LOG_LOCAL1:    return ""local1"";
    case LOG_LOCAL2:    return ""local2"";
    case LOG_LOCAL3:    return ""local3"";
    case LOG_LOCAL4:    return ""local4"";
    case LOG_LOCAL5:    return ""local5"";
    case LOG_LOCAL6:    return ""local6"";
    case LOG_LOCAL7:    return ""local7"";
    default:            return null;
    }	   
  }	   

  
  public
  static
  int getFacility(String facilityName) {
    if(facilityName != null) {
      facilityName = facilityName.trim();
    }
    if(""KERN"".equalsIgnoreCase(facilityName)) {
      return LOG_KERN;
    } else if(""USER"".equalsIgnoreCase(facilityName)) {
      return LOG_USER;
    } else if(""MAIL"".equalsIgnoreCase(facilityName)) {
      return LOG_MAIL;
    } else if(""DAEMON"".equalsIgnoreCase(facilityName)) {
      return LOG_DAEMON;
    } else if(""AUTH"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTH;
    } else if(""SYSLOG"".equalsIgnoreCase(facilityName)) {
      return LOG_SYSLOG;
    } else if(""LPR"".equalsIgnoreCase(facilityName)) {
      return LOG_LPR;
    } else if(""NEWS"".equalsIgnoreCase(facilityName)) {
      return LOG_NEWS;
    } else if(""UUCP"".equalsIgnoreCase(facilityName)) {
      return LOG_UUCP;
    } else if(""CRON"".equalsIgnoreCase(facilityName)) {
      return LOG_CRON;
    } else if(""AUTHPRIV"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTHPRIV;
    } else if(""FTP"".equalsIgnoreCase(facilityName)) {
      return LOG_FTP;
    } else if(""LOCAL0"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL0;
    } else if(""LOCAL1"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL1;
    } else if(""LOCAL2"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL2;
    } else if(""LOCAL3"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL3;
    } else if(""LOCAL4"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL4;
    } else if(""LOCAL5"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL5;
    } else if(""LOCAL6"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL6;
    } else if(""LOCAL7"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL7;
    } else {
      return -1;
    }
  }
  
  public
  void append(LoggingEvent event) {

    if(!isAsSevereAsThreshold(event.priority))
      return;
    
    
    if(sqw == null) {
      errorHandler.error(""No syslog host is set for SyslogAppedender named \""""+
			this.name+""\""."");
      return;
    }

    String buffer = (facilityPrinting? facilityStr : """") +
                          layout.format(event);

    sqw.setPriority(event.priority.getSyslogEquivalent());    
    sqw.write(buffer);

    String[] s = event.getThrowableStrRep();
    if (s != null) {
      int len = s.length;
      if(len > 0) {
	sqw.write(s[0]);
      
	for(int i = 1; i < len; i++) {
	    sqw.write(TAB+s[i].substring(1));
	}	
      }

    }
  }

  
  public
  void activateOptions() {
  }

  
  public
  boolean requiresLayout() {
    return true;
  }
  
  
  public
  void setSyslogHost(String syslogHost) {
    this.sqw = new SyslogQuietWriter(new SyslogWriter(syslogHost), 
				     syslogFacility, errorHandler);
    
    this.syslogHost = syslogHost;
  }
  
  
  public
  String getSyslogHost() {
    return syslogHost;
  }
  
  
  public
  void setFacility(String facilityName) {
    if(facilityName == null)
      return;
    
    syslogFacility = getFacility(facilityName);
    if (syslogFacility == -1) {
      System.err.println(""[""+facilityName +
                  ""] is an unknown syslog facility. Defaulting to [USER]."");
      syslogFacility = LOG_USER;
    }
    
    this.initSyslogFacilityStr();

    
    if(sqw != null) {
      sqw.setSyslogFacility(this.syslogFacility);
    }
  }
  
  
  public
  String getFacility() {
    return getFacilityString(syslogFacility);
  }
  
  
  public
  void setFacilityPrinting(boolean on) {
    facilityPrinting = on;
  }
  
  
  public
  boolean getFacilityPrinting() {
    return facilityPrinting;
  }
}
"
log4j,1.1,org.apache.log4j.SimpleLayout,6,2,0,6,13,13,3,3,6,0.8,54,0.0,0,0.615384615,0.444444444,0,0,7.833333333,1,0.8333,0,"



package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;


public class SimpleLayout extends Layout {

  StringBuffer sbuf = new StringBuffer(128);

  public SimpleLayout() {
  }

  public
  String[] getOptionStrings() {
    return new String[0];
  }

  public
  void setOption(String option, String value) {
  }
  
  public
  void activateOptions() {
  }
  
  
  public
  String format(LoggingEvent event) {

    sbuf.setLength(0);
    sbuf.append(event.priority.toString());
    sbuf.append("" - "");
    sbuf.append(event.getRenderedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }


  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
log4j,1.1,org.apache.log4j.performance.ConcatVsArray,3,1,0,0,14,3,0,0,2,2.0,133,0.0,0,0.0,0.333333333,0,0,43.33333333,4,1.6667,0,"


package org.apache.log4j.performance;

import java.util.Date;


public class ConcatVsArray {


  static
  void  Usage() {
    System.err.println(""Usage: java org.apache.log4j.performance.ConcatVsArray "" +
		       ""string1 string2 runLength\n"" +
		       ""       where runLength is an integer."");
    System.exit(1);
  }

  public static void main(String args[]) {

    if(args.length != 3) {
      Usage();
    }    

    String s1 = args[0];
    String s2 = args[1];
    int runLength = 0;
    try {
      runLength = Integer.parseInt(args[2]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      

    double micros;

    String[] sa;
    long before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      sa = new String[]{s1, s2};
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The anonymous array loop took around "" + micros + "" microseconds."");

    String s;    
    before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      s = s1 + s2;
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The append loop took around "" + micros + "" microseconds."");

  }
}
"
log4j,1.1,org.apache.log4j.nt.test.NTMin,7,1,0,6,30,17,0,6,2,0.75,144,0.0,1,0.0,0.277777778,0,0,19.28571429,2,0.8571,0,"

package org.apache.log4j.nt.test;


import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.nt.NTEventLogAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;


public class NTMin {
  
  static Category cat = Category.getInstance(NTMin.class.getName());
				     
  public 
  static 
  void main(String argv[]) {

    
    init();
    
    
    
    
      test(""someHost"");
  }

  
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + NTMin.class + """");
    System.exit(1);
  }

  
  static
  void init() {

    BasicConfigurator.configure(new NTEventLogAppender());
  }

  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
log4j,1.1,org.apache.log4j.NDC,12,1,0,12,41,0,10,2,9,0.666666667,275,0.0,0,0.0,0.090909091,0,0,21.66666667,6,2.25,2,"




package org.apache.log4j;

import java.util.Hashtable;
import java.util.Stack;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.log4j.helpers.LogLog;


 
public class NDC {

  
  
  
  
  

  
  
  

  static Hashtable ht = new Hashtable();

  static int pushCounter = 0; 
                              

  
  
  
  
  
  static final int REAP_THRESHOLD = 5;
  
  
  private NDC() {}


  
  public
  static
  void clear() {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null) 
      stack.setSize(0);    
  }

  
  
  public
  static
  Stack cloneStack() {
    Object o = ht.get(Thread.currentThread());
    if(o == null)
      return null;
    else {
      Stack stack = (Stack) o;
      return (Stack) stack.clone();
    }
  }

  
  
  public
  static
  void inherit(Stack stack) {
    if(stack != null)
      ht.put(Thread.currentThread(), stack);
  }


  
  static
  public
  String get() {
    Stack s = (Stack) ht.get(Thread.currentThread());
    if(s != null && !s.isEmpty()) 
      return ((DiagnosticContext) s.peek()).fullMessage;
    else
      return null;
  }
  
  
  public
  static
  int getDepth() {
    Stack stack = (Stack) ht.get(Thread.currentThread());          
    if(stack == null)
      return 0;
    else
      return stack.size();      
  }

  private
  static
  void lazyRemove() {
     
    
    
    
    Vector v;
    
    synchronized(ht) {
      
      if(++pushCounter >= REAP_THRESHOLD) {
	return; 
      } else {
	pushCounter = 0; 
      }

      int misses = 0;
      v = new Vector(); 
      Enumeration enum = ht.keys();
      
      
      
      
      while(enum.hasMoreElements() && (misses <= 4)) {
	Thread t = (Thread) enum.nextElement();
	if(t.isAlive()) {
	  misses++;
	} else {
	  misses = 0;
	  v.addElement(t);
	}
      }
    } 

    int size = v.size();
    for(int i = 0; i < size; i++) {
      Thread t = (Thread) v.elementAt(i);
      LogLog.debug(""Lazy NDC removal for thread ["" + t.getName() + ""] (""+ 
		   ht.size() + "")."");
      ht.remove(t);
    }
  }

  
  public
  static
  String pop() {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack != null && !stack.isEmpty()) 
      return ((DiagnosticContext) stack.pop()).message;
    else
      return """";
  }

  
  public
  static
  String peek() {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack != null && !stack.isEmpty())
      return ((DiagnosticContext) stack.peek()).message;
    else
      return """";
  }
  
  
  public
  static
  void push(String message) {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
      
    if(stack == null) {
      DiagnosticContext dc = new DiagnosticContext(message, null);      
      stack = new Stack();
      ht.put(key, stack);
      stack.push(dc);
    } else if (stack.isEmpty()) {
      DiagnosticContext dc = new DiagnosticContext(message, null);            
      stack.push(dc);
    } else {
      DiagnosticContext parent = (DiagnosticContext) stack.peek();
      stack.push(new DiagnosticContext(message, parent));
    }    
  }

  
  static
  public
  void remove() {
    ht.remove(Thread.currentThread());
    
    
    lazyRemove();    
  }

  
  static
  public
  void setMaxDepth(int maxDepth) {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null && maxDepth < stack.size()) 
      stack.setSize(maxDepth);
  }
  
  
   private static class DiagnosticContext {

    String fullMessage;
    String message;
    
    DiagnosticContext(String message, DiagnosticContext parent) {
      this.message = message;
      if(parent != null) {
	fullMessage = parent.fullMessage + ' ' + message;
      } else {
	fullMessage = message;
      }
    }
  }
}

"
log4j,1.1,org.apache.log4j.helpers.QuietWriter,4,3,2,6,12,0,5,1,4,0.0,57,1.0,1,0.857142857,0.5,2,2,13.0,2,1.0,0,"

package org.apache.log4j.helpers;

import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;



public class QuietWriter extends FilterWriter {

  protected ErrorHandler errorHandler;

  public
  QuietWriter(Writer writer, ErrorHandler errorHandler) {
    super(writer);
    setErrorHandler(errorHandler);
  }

  public
  void write(String string) {
    try {
      out.write(string);
    } catch(IOException e) {
      errorHandler.error(""Failed to write [""+string+""]."", e, 
			 ErrorCode.WRITE_FAILURE);
    }
  }

  public
  void flush() {
    try {
      out.flush();
    } catch(IOException e) {
      errorHandler.error(""Failed to flush writer,"", e, 
			 ErrorCode.FLUSH_FAILURE);
    }	
  }


  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      
      throw new IllegalArgumentException(""Attempted to set null ErrorHandler."");
    } else { 
      this.errorHandler = eh;
    }
  }
}
"
log4j,1.1,org.apache.log4j.PatternLayout,10,2,0,7,19,27,3,4,9,0.901234568,130,0.666666667,1,0.5,0.5,0,0,11.1,3,1.2,1,"

package org.apache.log4j;

import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.NDC;
import org.apache.log4j.helpers.PatternParser;
import org.apache.log4j.helpers.PatternConverter;
import org.apache.log4j.helpers.OptionConverter;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.Vector;
import java.text.FieldPosition;





public class PatternLayout extends Layout {

   
  final static public String CONVERSION_PATTERN_OPTION = ""ConversionPattern"";

  
  public final static String DEFAULT_CONVERSION_PATTERN =""%m%n"";

    
  public final static String TTCC_CONVERSION_PATTERN
                                             = ""%r [%t] %p %c %x - %m%n"";

  
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  

  
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  
  private String pattern;
  
  private PatternConverter head;

  private String timezone;
  
  
  public PatternLayout() {
    this(DEFAULT_CONVERSION_PATTERN);
  }

  
  public PatternLayout(String pattern) {
    this.pattern = pattern;
    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN : 
			     pattern).parse();
  }
  
  
  public
  String[] getOptionStrings() {
    return new String[] {CONVERSION_PATTERN_OPTION};
  }	

  
  public
  void setOption(String option, String value) {
    if(value == null)
      return;
    if(option.equalsIgnoreCase(CONVERSION_PATTERN_OPTION)) {
      pattern = value;
      head = createPatternParser(value).parse();
    }
    
    
    
    
    
    
    
    
  }
  
  
  public
  void setConversionPattern(String conversionPattern) {
    pattern = conversionPattern;
    head = createPatternParser(conversionPattern).parse();
  }
  
  
  public
  String getConversionPattern() {
    return pattern;
  }
  
  
  public
  void activateOptions() {
    
  }
  
 
  public
  boolean ignoresThrowable() {
    return true;
  }

  
  protected PatternParser createPatternParser(String pattern) {
    return new PatternParser(pattern);
  }


  
  public String format(LoggingEvent event) {
    
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    
    PatternConverter c = head;

    while(c != null) {
      c.format(sbuf, event);
      c = c.next;
    }
    return sbuf.toString();
  }
}
"
log4j,1.1,org.apache.log4j.helpers.FileWatchdog,5,2,0,2,17,0,1,1,2,0.607142857,120,0.285714286,0,0.938461538,0.466666667,1,1,21.6,3,1.4,0,"



package org.apache.log4j.helpers;

import java.io.File;
import org.apache.log4j.helpers.LogLog;


public abstract class FileWatchdog extends Thread {

  
  static final public long DEFAULT_DELAY = 60000; 
  
  protected String filename;
  
  
  protected long delay = DEFAULT_DELAY; 
  
  File file;
  long lastModif = 0; 
  boolean warnedAlready = false;
  boolean interrupted = false;

  protected
  FileWatchdog(String filename) {
    this.filename = filename;
    file = new File(filename);
    setDaemon(true);
    checkAndConfigure();
  }

  
  public
  void setDelay(long delay) {
    this.delay = delay;
  }

  abstract 
  protected 
  void doOnChange();

  protected
  void checkAndConfigure() {
    boolean fileExists;
    try {
      fileExists = file.exists();
    } catch(SecurityException  e) {
      LogLog.warn(""Was not allowed to read check file existance, file:[""+
		  filename+""]."");
      interrupted = true; 
      return;
    }

    if(fileExists) {
      long l = file.lastModified(); 
      if(l > lastModif) {           
	lastModif = l;              
	doOnChange();
	warnedAlready = false;
      }
    } else {
      if(!warnedAlready) {
	LogLog.debug(""[""+filename+""] does not exist."");
	warnedAlready = true;
      }
    }
  }

  public
  void run() {    
    while(!interrupted) {
      try {
	Thread.currentThread().sleep(delay);
      } catch(InterruptedException e) {
	
      }
      checkAndConfigure();
    }
  }
}
"
log4j,1.1,org.apache.log4j.Hierarchy,23,1,0,23,65,125,15,10,20,0.873737374,530,0.111111111,3,0.0,0.186868687,0,0,21.65217391,6,1.913,3,"










 
package org.apache.log4j;


import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;


public class Hierarchy {

  
  
  static final int DISABLE_OFF = -1;
  static final int DISABLE_OVERRIDE = -2;  
  
  private CategoryFactory defaultFactory;


  Hashtable ht;
  Category root;
  RendererMap rendererMap;
  
  int disable;

  boolean emittedNoAppenderWarning = false;
  boolean emittedNoResourceBundleWarning = false;  

  
  public
  Hierarchy(Category root) {
    ht = new Hashtable();
    this.root = root;
    
    disable = DISABLE_OFF;
    this.root.setHierarchy(this);
    rendererMap = new RendererMap();
    defaultFactory = new DefaultCategoryFactory();
  }

  
  public
  void addRenderer(Class classToRender, ObjectRenderer or) {
    rendererMap.put(classToRender, or);
  }
  

  
  public
  void clear() {
    
    ht.clear();
  }

  
  public
  Category exists(String name) {    
    Object o = ht.get(new CategoryKey(name));
    if(o instanceof Category) {
      return (Category) o;
    } else {
      return null;
    }
  }


  
  public
  void disable(String priorityStr) {
    if(disable != DISABLE_OVERRIDE) {  
      Priority p = Priority.toPriority(priorityStr, null);
      if(p != null) {
	disable = p.level;
      } else {
	LogLog.warn(""Could not convert [""+priorityStr+""] to Priority."");
      }
    }
  }


  
  public
  void disable(Priority p) {
    if((disable != DISABLE_OVERRIDE) && (p != null)) {
      disable = p.level;
    }
  }
  
  
  public
  void disableAll() {
    disable(Priority.FATAL);
  }


  
  public
  void disableDebug() {
    disable(Priority.DEBUG);
  }


  
  public
  void disableInfo() {
    disable(Priority.INFO);
  }  

  
  public
  void enableAll() {
    disable = DISABLE_OFF;
  }
  
  
  public
  void overrideAsNeeded(String override) {
    
    
    if(override != null) {
      LogLog.debug(""Handling non-null disable override directive: \""""+
		   override +""\""."");
      if(OptionConverter.toBoolean(override, true)) {
	LogLog.debug(""Overriding all disable methods."");
	disable = DISABLE_OVERRIDE;
      }
    }
  }


  
  public
  Category getInstance(String name) {
    return getInstance(name, defaultFactory);
  }

 
  public
  Category getInstance(String name, CategoryFactory factory) {
    
    CategoryKey key = new CategoryKey(name);    
    
    
    
    Category category;
    
    synchronized(ht) {
      Object o = ht.get(key);
      if(o == null) {
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this);
	ht.put(key, category);      
	updateParents(category);
	return category;
      } else if(o instanceof Category) {
	return (Category) o;
      } else if (o instanceof ProvisionNode) {
	
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this); 
	ht.put(key, category);
	updateChildren((ProvisionNode) o, category);
	updateParents(category);	
	return category;
      }
      else {
	
	return null;  
      }
    }
  }


  
  public
  Enumeration getCurrentCategories() {
    
    
    
    Vector v = new Vector(ht.size());
    
    Enumeration elems = ht.elements();
    while(elems.hasMoreElements()) {
      Object o = elems.nextElement();
      if(o instanceof Category) {
	v.addElement(o);
      }
    }
    return v.elements();
  }


  public
  boolean isDisabled(int level) {
    return disable >=  level;
  }

  
  public
  RendererMap getRendererMap() {
    return rendererMap;
  }


  
  public
  Category getRoot() {
    return root;
  }


  
  public
  void resetConfiguration() {

    getRoot().setPriority(Priority.DEBUG);
    root.setResourceBundle(null);
    disable = Hierarchy.DISABLE_OFF;
    
    
    
    synchronized(ht) {    
      shutdown(); 
    
      Enumeration cats = getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.setPriority(null);
	c.setAdditivity(true);
	c.setResourceBundle(null);
      }
    }
    rendererMap.clear();
  }

  
  public void setCategoryFactory(CategoryFactory factory) {
    if (factory != null) {
      defaultFactory = factory;
    }
  }

  
  public
  void setDisableOverride(String override) {
    if(OptionConverter.toBoolean(override, true)) {
      LogLog.debug(""Overriding disable."");
      disable =  DISABLE_OVERRIDE;
    }
  }



  
  public 
  void shutdown() {
    Category root = getRoot();    

    
    root.closeNestedAppenders();

    synchronized(ht) {
      Enumeration cats = this.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.closeNestedAppenders();
      }

      
      root.removeAllAppenders();
      cats = this.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.removeAllAppenders();
      }      
    }
  }


  
  final
  private
  void updateParents(Category cat) {
    String name = cat.name;
    int length = name.length();
    boolean parentFound = false;
    
    
    
    
    for(int i = name.lastIndexOf('.', length-1); i >= 0; 
	                                 i = name.lastIndexOf('.', i-1))  {
      String substr = name.substring(0, i);

      
      CategoryKey key = new CategoryKey(substr); 
      Object o = ht.get(key);
      
      if(o == null) {
	
	ProvisionNode pn = new ProvisionNode(cat);
	ht.put(key, pn);
      } else if(o instanceof Category) {
	parentFound = true;
	cat.parent = (Category) o;
	
	break; 
      } else if(o instanceof ProvisionNode) {
	((ProvisionNode) o).addElement(cat);
      } else {
	Exception e = new IllegalStateException(""unexpected object type "" + 
					o.getClass() + "" in ht."");
	e.printStackTrace();			   
      }
    }
    
    if(!parentFound) 
      cat.parent = root;
  }

  
  final
  private
  void updateChildren(ProvisionNode pn, Category cat) {
    
    final int last = pn.size();

    for(int i = 0; i < last; i++) {
      Category c = (Category) pn.elementAt(i);
      

      
      
      if(!c.parent.name.startsWith(cat.name)) {
	cat.parent = c.parent;
	c.parent = cat;      
      }
    }
  }    

}


"
log4j,1.1,org.apache.log4j.net.SMTPAppender,27,2,0,10,80,239,0,10,22,0.938034188,565,0.055555556,2,0.418604651,0.240740741,2,3,19.25925926,10,1.8519,3,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.TriggeringEventEvaluator;
import java.util.Properties;
import java.util.Date;

import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.AddressException;
import javax.mail.internet.MimeUtility;


public class SMTPAppender extends AppenderSkeleton {
  private String to;
  private String from;
  private String subject;
  private String smtpHost;
  private int bufferSize = 512;
  private boolean locationInfo = false;

  protected CyclicBuffer cb = new CyclicBuffer(bufferSize);
  protected Message msg;



 
  public static final String TO_OPTION = ""To"";

 
  public static final String FROM_OPTION = ""From"";

 
  public static final String SUBJECT_OPTION = ""Subject"";


 
  public static final String SMTP_HOST_OPTION = ""SMTPHost"";

 
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";


 
  public static final String EVALUATOR_CLASS_OPTION = ""EvaluatorClass"";


  
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  
  protected TriggeringEventEvaluator evaluator;



  
  public
  SMTPAppender() {
    this(new DefaultEvaluator());
  }

  
  
  public 
  SMTPAppender(TriggeringEventEvaluator evaluator) {
    this.evaluator = evaluator;
  }

 
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TO_OPTION, FROM_OPTION, SUBJECT_OPTION, 
			  SMTP_HOST_OPTION, BUFFER_SIZE_OPTION,  
			  EVALUATOR_CLASS_OPTION, LOCATION_INFO_OPTION });
  }
  

  
  public
  void activateOptions() {
    Properties props = System.getProperties();
    if (smtpHost != null)
      props.put(""mail.smtp.host"", smtpHost);

    
    Session session = Session.getDefaultInstance(props, null);
    
    msg = new MimeMessage(session);
     
     try {
       if (from != null)
	 msg.setFrom(getAddress(from));
       else
	 msg.setFrom();

       msg.setRecipients(Message.RecipientType.TO, parseAddress(to));
       if(subject != null)
	 msg.setSubject(subject);
     } catch(MessagingException e) {
       LogLog.error(""Could not activate SMTPAppender options."", e );
     }
  }
  
  
  public
  void append(LoggingEvent event) {

    if(!checkEntryConditions()) {
      return;
    }

    event.getThreadName();
    event.getNDC();
    if(locationInfo) {
      event.getLocationInformation();	
    }
    cb.add(event);    
    if(evaluator.isTriggeringEvent(event)) {
      sendBuffer();
    }
  }

 
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error(""Message object not configured."");
      return false;
    }

    if(this.evaluator == null) {
      errorHandler.error(""No TriggeringEventEvaluator is set for appender [""+
			 name+""]."");
      return false;
    }

    
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+name+""]."");
      return false;
    }
    return true;
  }


  synchronized
  public
  void close() {
    this.closed = true;
  }

  InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

  InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

  
  public
  String getTo() {
    return to;
  }


  
  public
  boolean requiresLayout() {
    return true;
  }

  
  protected
  void sendBuffer() {

    
    
    try {      
      MimeBodyPart part = new MimeBodyPart();

      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length(); 
      for(int i = 0; i < len; i++) {
	
	LoggingEvent event = cb.get();
	sbuf.append(layout.format(event));
	if(layout.ignoresThrowable()) {
	  String[] s = event.getThrowableStrRep();
	  if (s != null) {
	    for(int j = 0; j < s.length; j++) {
	      sbuf.append(s[j]);
	    }
	  }
	}
      }
      t = layout.getFooter();
      if(t != null)
	sbuf.append(t);
      part.setContent(sbuf.toString(), layout.getContentType());      

      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);

      msg.setSentDate(new Date());
      Transport.send(msg);      
    } catch(Exception e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    }
  }
  


  
  public
  String getEvaluatorClass() {
    return evaluator == null ? null : evaluator.getClass().getName();
  }
  
  
  public
  String getFrom() {
    return from;
  }

  
  public
  String getSubject() {
    return subject;
  }



  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    

    if(option.equals(TO_OPTION)) 
      to = value;
    else if (option.equals(FROM_OPTION))
      from = value;
    else if (option.equals(SMTP_HOST_OPTION)) 
      smtpHost = value;
    else if (option.equals(SUBJECT_OPTION)) 
      subject = value;
    else if (option.equals(EVALUATOR_CLASS_OPTION)) {      
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
                                           TriggeringEventEvaluator.class,
                                                       evaluator);    
    } else if (option.equals(BUFFER_SIZE_OPTION)) {
      bufferSize = OptionConverter.toInt(value, bufferSize);    
      cb.resize(bufferSize);
    } else if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
  }


  
  public
  void setFrom(String from) {
    this.from = from;
  }
  
  
  public
  void setSubject(String subject) {
    this.subject = subject;
  }
  

  
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
    cb.resize(bufferSize);
  }
  
  
  public
  void setSMTPHost(String smtpHost) {
    this.smtpHost = smtpHost;
  }
  
  
  public
  String getSMTPHost() {
    return smtpHost;
  }

  
  public
  void setTo(String to) {
    this.to = to;
  }

  

  
  public
  int getBufferSize() {
    return bufferSize;
  }
  
  
  public
  void setEvaluatorClass(String value) {
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
					   TriggeringEventEvaluator.class,
						       evaluator);    
  }
  
  
  
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  
  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
}

class DefaultEvaluator implements TriggeringEventEvaluator {
  
  public 
  boolean isTriggeringEvent(LoggingEvent event) {
    return event.priority.isGreaterOrEqual(Priority.ERROR); 
  }
}
"
log4j,1.1,org.apache.log4j.net.test.SMTPMin,7,1,0,4,32,17,0,4,2,0.666666667,155,0.0,1,0.0,0.277777778,0,0,20.85714286,2,1.0,0,"

package org.apache.log4j.net.test;

import org.apache.log4j.*;
import java.io.IOException;
import java.io.InputStreamReader;

public class SMTPMin {
  
  static Category cat = Category.getInstance(SMTPMin.class);

  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");     
    
    NDC.push(""some context"");
    test();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SMTPMin.class.getName()
		       + "" configFile"");
    System.exit(1);
  }

  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }


  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    Category.shutdown();
    Thread.currentThread().getThreadGroup().list();
  }
  
}
"
log4j,1.1,org.apache.log4j.performance.NewVsSetLen,5,1,0,0,16,0,0,0,2,0.208333333,268,0.0,0,0.0,0.333333333,0,0,51.4,4,2.0,0,"

package org.apache.log4j.performance;


public class NewVsSetLen {

  static String s;

  static int BIGBUF_LEN = 1048576;
  static int SBUF_LEN = 256;
  static int RUN_LENGTH = BIGBUF_LEN/4;

  static char[] sbuf = new char[SBUF_LEN];
  static char[] bigbuf = new char[BIGBUF_LEN];

  {
    for(int i = 0; i < SBUF_LEN; i++) {
      sbuf[i] = (char) (i);
    }

    for(int i = 0; i < BIGBUF_LEN; i++) {
      bigbuf[i] = (char) (i);
    }
  }


  static
  public 
  void main(String[] args) {    
 
    int t;

    for(int len = SBUF_LEN; len <= BIGBUF_LEN; len*=4, RUN_LENGTH /= 4) {
      System.out.println(""<td>""+len+""\n"");
      for(int second = 0; second < 16;) {
	System.out.println(""SECOND loop=""+second +"", RUN_LENGTH=""
			   +RUN_LENGTH+"", len=""+len);
	t = (int)newBuffer(len, second);;

	System.out.print(""<td>"" + t);
	t = (int)setLen(len, second);
	System.out.println("" <td>"" + t + "" \n"");
	if(second == 0) {
	  second = 1;
	} else {
	  second *= 2;
	}
      }
    }
    
  }

  static
  double newBuffer(int size, int second) {    
    long before = System.currentTimeMillis();

    for(int i = 0; i < RUN_LENGTH; i++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
    }

    for(int x = 0; x <  second; x++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static
  double setLen(int size, int second) {
    long before = System.currentTimeMillis();

    StringBuffer buf = new StringBuffer(SBUF_LEN);

    for(int i = 0; i < RUN_LENGTH; i++) {
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
      buf.setLength(0);
    }

    for(int x = 0; x < second; x++) {
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
      buf.setLength(0);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
log4j,1.1,org.apache.log4j.helpers.PatternConverter,6,1,5,9,10,7,7,2,2,0.72,174,0.0,1,0.0,0.44,0,0,27.16666667,6,1.8333,0,"

package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;


public abstract class PatternConverter {
  public PatternConverter next;
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;

  protected
  PatternConverter() {  }
  
  protected
  PatternConverter(FormattingInfo fi) {
    min = fi.min;
    max = fi.max;
    leftAlign = fi.leftAlign;
  }

  
  abstract
  protected
  String convert(LoggingEvent event);

  
  public
  void format(StringBuffer sbuf, LoggingEvent e) {
    String s = convert(e);

    if(s == null) {
      if(0 < min)
	spacePad(sbuf, min);
      return;
    }

    int len = s.length();

    if(len > max)
      sbuf.append(s.substring(len-max));
    else if(len < min) {
      if(leftAlign) {	
	sbuf.append(s);
	spacePad(sbuf, min-len);
      }
      else {
	spacePad(sbuf, min-len);
	sbuf.append(s);
      }
    }
    else
      sbuf.append(s);
  }	

  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", 
			    ""                "", 
			    ""                                "" }; 

  
  public
  void spacePad(StringBuffer sbuf, int length) {
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
log4j,1.1,org.apache.log4j.test.PrintProperties,2,1,0,1,5,1,0,1,2,2.0,15,0.0,0,0.0,0.5,0,0,6.5,1,0.5,0,"

package org.apache.log4j.test;

import java.io.*;
import org.apache.log4j.config.PropertyPrinter;


public class PrintProperties {
  public
  static
  void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out), true);
  }
}"
log4j,1.1,org.apache.log4j.spi.AppenderAttachable,6,1,0,4,6,15,3,1,6,2.0,6,0.0,0,0.0,0.555555556,0,0,0.0,1,1.0,0,"

package org.apache.log4j.spi;

import org.apache.log4j.Appender;
import java.util.Enumeration;


public interface AppenderAttachable {
  
  
  public
  void addAppender(Appender newAppender);

  
  public
  Enumeration getAllAppenders();

  
  public
  Appender getAppender(String name);

  
  void removeAllAppenders();


  
   void removeAppender(Appender appender);


 
 void
 removeAppender(String name);   
}

"
log4j,1.1,org.apache.log4j.config.PropertyGetter,6,1,0,3,25,11,1,2,3,0.68,154,0.6,0,0.0,0.44,0,0,23.83333333,8,2.3333,1,"

package org.apache.log4j.config;

import java.beans.*;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.Appender;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;



public class PropertyGetter {
  protected static final Object[] NULL_ARG = new Object[] {};
  protected Object obj;
  protected PropertyDescriptor[] props;
  
  public interface PropertyCallback {
    void foundProperty(Object obj, String prefix, String name, Object value);
  }
  
  
  public
  PropertyGetter(Object obj) throws IntrospectionException {
    BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
    props = bi.getPropertyDescriptors();
    this.obj = obj;
  }
  
  public
  static
  void getProperties(Object obj, PropertyCallback callback, String prefix) {
    try {
      new PropertyGetter(obj).getProperties(callback, prefix);
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect object "" + obj, ex);
    }
  }
  
  public
  void getProperties(PropertyCallback callback, String prefix) {
    for (int i = 0; i < props.length; i++) {
        Method getter = props[i].getReadMethod();
        if (getter == null) continue;
        if (!isHandledType(getter.getReturnType())) {
          
          continue;
        }
        String name = props[i].getName();
        try {
          Object result = getter.invoke(obj, NULL_ARG);
          
          if (result != null) {
            callback.foundProperty(obj, prefix, name, result);
          }
        } catch (Exception ex) {
          LogLog.warn(""Failed to get value of property "" + name);
        }
    }
  }
  
  protected
  boolean isHandledType(Class type) {
    return String.class.isAssignableFrom(type) ||
           Integer.TYPE.isAssignableFrom(type) ||
           Long.TYPE.isAssignableFrom(type)    ||
           Boolean.TYPE.isAssignableFrom(type) ||
           Priority.class.isAssignableFrom(type);
  }
}
"
log4j,1.1,org.apache.log4j.net.JMSSink,5,1,0,7,31,10,0,7,2,0.875,145,0.0,0,0.0,0.3,0,0,27.6,3,1.4,3,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.or.MessageRenderer;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;

import javax.jms.*;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;


public class JMSSink  {

  static public void main(String[] args) {
    if(args.length != 3) {
      usage(""Wrong number of arguments."");     
    }

    String tcfBindingName = args[0];
    String topicBindingName = args[1];
    PropertyConfigurator.configure(args[2]);

    Category.getDefaultHierarchy().addRenderer(Message.class, 
					       new MessageRenderer());

    try {
      Context ctx = new InitialContext();      
      TopicConnectionFactory topicConnectionFactory;
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, 
							       tcfBindingName);

      TopicConnection topicConnection = 
	                        topicConnectionFactory.createTopicConnection(); 
      topicConnection.start();
    
      TopicSession topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);

      Topic topic = (Topic)ctx.lookup(topicBindingName);

      
      TopicSubscriber topicSubscriber = 
           topicSession.createDurableSubscriber(topic, ""x"");

      
      LoggingEvent event;
      Category remoteCategory;    

      while(true) {
	ObjectMessage msg = (ObjectMessage)topicSubscriber.receive();      
	event = (LoggingEvent) msg.getObject();
	remoteCategory = Category.getInstance(event.categoryName);
	remoteCategory.callAppenders(event);	
	
	
	

      }
    } catch(Exception e) {
      LogLog.error(""Could not read JMS message."", e);
    }
  }


  protected
  static
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }  


  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + JMSSink.class.getName()
            + "" TopicConnectionFactoryBindingName TopicBindingName configFile"");
    System.exit(1);
  }
}
"
log4j,1.1,org.apache.log4j.helpers.LogLog,10,1,0,34,19,0,34,1,9,0.920634921,146,0.714285714,0,0.0,0.333333333,0,0,12.9,4,1.9,0,"

package org.apache.log4j.helpers;


public class LogLog {

  
  public static final String DEBUG_KEY=""log4j.debug"";

 
  
  public static final String CONFIG_DEBUG_KEY=""log4j.configDebug"";

  protected static boolean debugEnabled = false;  

  
  private static boolean quietMode = false;

  private static final String PREFIX = ""log4j: "";
  private static final String ERR_PREFIX = ""log4j:ERROR "";
  private static final String WARN_PREFIX = ""log4j:WARN "";

  static {
    String key = OptionConverter.getSystemProperty(DEBUG_KEY, null);

    if(key == null) {
      key = OptionConverter.getSystemProperty(CONFIG_DEBUG_KEY, null);
    }

    if(key != null) { 
      debugEnabled = OptionConverter.toBoolean(key, true);
    }
  }

  
  static
  public
  void setInternalDebugging(boolean enabled) {
    debugEnabled = enabled;
  }

  
  public
  static
  void debug(String msg) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
    }
  }

  
  public
  static
  void debug(String msg, Throwable t) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
      if(t != null)
	t.printStackTrace(System.out);
    }
  }
  

  
  public
  static
  void error(String msg) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
  }  

  
  public
  static
  void error(String msg, Throwable t) {
    if(quietMode)
      return;

    System.err.println(ERR_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  

  
  public
  static
  void setQuietMode(boolean quietMode) {
    LogLog.quietMode = quietMode;
  }

  
  public
  static
  void warn(String msg) {
    if(quietMode)
      return;

    System.err.println(WARN_PREFIX+msg);
  }  

  
  public
  static
  void warn(String msg, Throwable t) {
    if(quietMode)
      return;

    System.err.println(WARN_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
}
"
log4j,1.1,org.apache.log4j.performance.Logging,8,1,0,3,30,12,0,3,2,0.666666667,228,0.0,1,0.0,0.321428571,0,0,26.75,4,1.75,1,"






package org.apache.log4j.performance;

import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.FileAppender;

import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.NDC;
import org.apache.log4j.performance.NOPWriter;

import java.util.Enumeration;


public class Logging {

  static int runLength;
  static int delay = -1;
  
  static  int burstLen = 100;
  static int DELAY_MULT = 1000/burstLen;
  
  static Category cat = Category.getInstance(""A0123456789.B0123456789.C0123456789"");

  static
  void  Usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java ""+Logging.class.getName()+"" confFile runLength [delay] [burstLen]\n""+
      ""        confFile is an XML configuration file and\n""+
      ""        runLength (integer) is the length of test loop.\n""+
      ""        delay is the time in millisecs to wait every bustLen log requests."");
    System.exit(1);
  }

  
  public static void main(String argv[]) {

    if(argv.length == 2)
      init(argv[0], argv[1], null, null);
    else if( argv.length == 4)
      init(argv[0], argv[1], argv[2], argv[3]);
    else
      Usage(""Wrong number of arguments."");

    
    NDC.push(""some context"");

    double delta;
    String msg = ""ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890"";
     if(delay <= 0) 
      delta = NoDelayLoop(cat, msg);
    else
      delta = DelayedLoop(cat, msg);
		
    System.out.print((int)delta); 

    Category.shutdown();

  }
  
  
  static
  void init(String configFile, String runLengthStr, String delayStr, 
	    String burstLenStr) {
    try {
      runLength   = Integer.parseInt(runLengthStr);
      if(delayStr != null) {
	delay = Integer.parseInt(delayStr);
      }
      if(delayStr != null) {
	burstLen = Integer.parseInt(burstLenStr);
	DELAY_MULT = 1000/burstLen;	
      }      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
    }      
    DOMConfigurator.configure(configFile);
  }
  
  static
  double NoDelayLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
    }
    return ((System.currentTimeMillis() - before)*1000.0)/runLength;    
  }

  static
  double DelayedLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    int j = 0;
    Thread currentThread = Thread.currentThread();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
      if(j++ == burstLen) {
	j = 0;
	try{currentThread.sleep(delay);}catch(Exception e){}
      }
      
    }
    double actualTime = ((System.currentTimeMillis()-before)*1000.0/runLength);
    System.out.println(""actual time: ""+actualTime);
    return (actualTime - delay*DELAY_MULT); 
  }  
}
"
log4j,1.1,org.apache.log4j.test.Min,5,1,0,8,26,10,0,8,2,2.0,508,0.0,0,0.0,0.266666667,0,0,100.6,3,1.4,0,"

package org.apache.log4j.test; 

import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.Appender;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.TTCCLayout;
import org.apache.log4j.Priority;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import java.io.IOException;


public class Min {

  public 
  static 
  void main(String argv[]) {

      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test1();
  }


  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.Min "" +
			""simple|ttcc"");
    System.exit(1);
  }


  

  static
  void ProgramInit(String layoutType) {

    Appender appender = null;	
    Layout layout = null;
        
    if(layoutType.equals(""simple"")) 
      layout = new SimpleLayout();
    else if(layoutType.equals(""ttcc"")) {
      layout = new TTCCLayout(AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT);
    }
    else 
      Usage(""Wrong layoutType ["" + layoutType +""]."");


    appender = new ConsoleAppender(layout, ""System.out"");
    BasicConfigurator.configure(appender);
  }

  
  static
  void test1() {

    int i = 0;

    
    
    
    
    Category ERR = Category.getInstance(""ERR"");
    ERR.setPriority(Priority.ERROR);
    Category INF = Category.getInstance(""INF"");
    INF.setPriority(Priority.INFO);
    Category INF_ERR = Category.getInstance(""INF.ERR"");
    INF_ERR.setPriority(Priority.ERROR);
    Category DEB = Category.getInstance(""DEB"");
    DEB.setPriority(Priority.DEBUG);
    
    
    Category INF_UNDEF = Category.getInstance(""INF.UNDEF"");
    Category INF_ERR_UNDEF = Category.getInstance(""INF.ERR.UNDEF"");    
    Category UNDEF = Category.getInstance(""UNDEF"");   


    
    ERR.log(Priority.FATAL, ""Message "" + i); i++;  
    ERR.error( ""Message "" + i); i++;          

    INF.log(Priority.FATAL, ""Message "" + i); i++; 
    INF.error( ""Message "" + i); i++;         
    INF.warn ( ""Message "" + i); i++; 
    INF.info ( ""Message "" + i); i++;

    INF_UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  
    INF_UNDEF.error( ""Message "" + i); i++;         
    INF_UNDEF.warn ( ""Message "" + i); i++; 
    INF_UNDEF.info ( ""Message "" + i); i++; 
    
    
    INF_ERR.log(Priority.FATAL, ""Message "" + i); i++;  
    INF_ERR.error( ""Message "" + i); i++;  

     INF_ERR_UNDEF.log(Priority.FATAL, ""Message "" + i); i++; 
    INF_ERR_UNDEF.error( ""Message "" + i); i++;             

    DEB.log(Priority.FATAL, ""Message "" + i); i++;  
    DEB.error( ""Message "" + i); i++;         
    DEB.warn ( ""Message "" + i); i++; 
    DEB.info ( ""Message "" + i); i++; 
    DEB.debug( ""Message "" + i); i++; 

    
    
    UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  
    UNDEF.error(""Message "" + i); i++;         
    UNDEF.warn (""Message "" + i); i++; 
    UNDEF.info (""Message "" + i); i++; 
    UNDEF.debug(""Message "" + i, new Exception(""Just testing."")); i++;    

    
    
    ERR.warn(""Message "" + i);  i++; 
    ERR.info(""Message "" + i);  i++; 
    ERR.debug(""Message "" + i);  i++; 
      
    INF.debug(""Message "" + i);  i++; 
    INF_UNDEF.debug(""Message "" + i); i++; 


    INF_ERR.warn(""Message "" + i);  i++; 
    INF_ERR.info(""Message "" + i);  i++; 
    INF_ERR.debug(""Message "" + i); i++; 
    INF_ERR_UNDEF.warn(""Message "" + i);  i++; 
    INF_ERR_UNDEF.info(""Message "" + i);  i++; 
    INF_ERR_UNDEF.debug(""Message "" + i); i++; 
    
      
    INF.info(""Messages should bear numbers 0 through 23."");
  }     
}
"
log4j,1.1,org.apache.log4j.helpers.OptionConverter,15,1,0,20,63,103,17,6,12,0.910714286,757,0.0,0,0.0,0.154761905,0,0,48.93333333,11,3.0,3,"

package org.apache.log4j.helpers;

import java.util.Properties;
import java.net.URL;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.PropertyConfigurator;






	
public class OptionConverter {

  static String DELIM_START = ""${"";
  static char   DELIM_STOP  = '}';
  static int DELIM_START_LEN = 2;
  static int DELIM_STOP_LEN  = 1;
  
  static StringBuffer sbuf = new StringBuffer();

  
  private OptionConverter() {}
  
  public
  static
  String[] concatanateArrays(String[] l, String[] r) {
    int len = l.length + r.length;
    String[] a = new String[len];

    System.arraycopy(l, 0, a, 0, l.length);
    System.arraycopy(r, 0, a, l.length, r.length);

    return a;
  }
  
  public
  static
  String convertSpecialChars(String s) {
    char c;
    int len = s.length();
    StringBuffer sbuf = new StringBuffer(len);
    
    int i = 0;
    while(i < len) {
      c = s.charAt(i++);
      if (c == '\\') {
	c =  s.charAt(i++);
	if(c == 'n')      c = '\n';
	else if(c == 'r') c = '\r';
	else if(c == 't') c = '\t';
	else if(c == 'f') c = '\f';
	else if(c == '\b') c = '\b';					
	else if(c == '\""') c = '\""';				
	else if(c == '\'') c = '\'';			
	else if(c == '\\') c = '\\';			
      }
      sbuf.append(c);      
    }
    return sbuf.toString();
  }


  
  public
  static
  String getSystemProperty(String key, String def) {
    try {
      return System.getProperty(key, def);
    } catch(Throwable e) { 
      LogLog.debug(""Was not allowed to read system property \""""+key+""\""."");
      return def;
    }
  }

  
  public
  static
  Object instantiateByKey(Properties props, String key, Class superClass,
				Object defaultValue) {

    
    String className = findAndSubst(key, props);
    if(className == null) {
      LogLog.error(""Could not find value for key "" + key);
      return defaultValue;
    }
    
    return OptionConverter.instantiateByClassName(className.trim(), superClass,
						  defaultValue);
  }

  
  public
  static
  boolean toBoolean(String value, boolean dEfault) {
    if(value == null)
      return dEfault;
    String trimmedVal = value.trim();
    if(""true"".equalsIgnoreCase(trimmedVal)) 
      return true;
    if(""false"".equalsIgnoreCase(trimmedVal))
      return false;
    return dEfault;
  }

  public
  static
  int toInt(String value, int dEfault) {
    if(value != null) {
      String s = value.trim();
      try {
	return Integer.valueOf(s).intValue();
      }
      catch (NumberFormatException e) {
	 LogLog.error(""["" + s + ""] is not in proper int form."");
	e.printStackTrace();
      }
    }
    return dEfault;
  }

  
  public
  static
  Priority toPriority(String value, Priority defaultValue) {
    if(value == null)
      return defaultValue;

    int hashIndex = value.indexOf('#');
    if (hashIndex == -1) {
      
      return Priority.toPriority(value, defaultValue);
    }

    Priority result = defaultValue;

    String clazz = value.substring(hashIndex+1);
    String priorityName = value.substring(0, hashIndex);

    LogLog.debug(""toPriority"" + "":class=["" + clazz + ""]"" 
		 + "":pri=["" + priorityName + ""]"");

    try {
      Class customPriority = Class.forName(clazz);

      
      
      Class[] paramTypes = new Class[] { String.class,
					 org.apache.log4j.Priority.class
                                       };
      java.lang.reflect.Method toPriorityMethod =
                      customPriority.getMethod(""toPriority"", paramTypes);

      
      Object[] params = new Object[] {priorityName, defaultValue};
      Object o = toPriorityMethod.invoke(null, params);

      result = (Priority) o;
    } catch(ClassNotFoundException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""] not found."");
    } catch(NoSuchMethodException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""]""
        + "" does not have a constructor which takes one string parameter"", e);
    } catch(java.lang.reflect.InvocationTargetException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""]""
		   + "" could not be instantiated"", e);
    } catch(ClassCastException e) {
      LogLog.warn(""class ["" + clazz
        + ""] is not a subclass of org.apache.log4j.Priority"", e);
    } catch(IllegalAccessException e) {
      LogLog.warn(""class [""+clazz+
		   ""] cannot be instantiated due to access restrictions"", e);
    } catch(Exception e) {
      LogLog.warn(""class [""+clazz+""], priority [""+priorityName+
		   ""] conversion failed."", e);
    }
    return result;
   }
 
  public
  static
  long toFileSize(String value, long dEfault) {
    if(value == null)
      return dEfault;
    
    String s = value.trim().toUpperCase();
    long multiplier = 1;
    int index;
    
    if((index = s.indexOf(""KB"")) != -1) {      
      multiplier = 1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""MB"")) != -1) {
      multiplier = 1024*1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""GB"")) != -1) {
      multiplier = 1024*1024*1024;
      s = s.substring(0, index);
    }    
    if(s != null) {
      try {
	return Long.valueOf(s).longValue() * multiplier;
      }
      catch (NumberFormatException e) {
	LogLog.error(""["" + s + ""] is not in proper int form."");
	LogLog.error(""["" + value + ""] not in expected format."", e);
      }
    }
    return dEfault;
  }

  
  public
  static
  String findAndSubst(String key, Properties props) {
    String value = props.getProperty(key);
    if(value == null) 
      return null;      
    
    try {
      return substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.error(""Bad option value [""+value+""]."", e);
      return value;
    }    
  }
   
  
  public
  static
  Object instantiateByClassName(String className, Class superClass,
				Object defaultValue) {
    if(className != null) {
      try {
	Class classObj = Class.forName(className);
	if(!superClass.isAssignableFrom(classObj)) {
	  LogLog.error(""A \""""+className+""\"" object is not assignable to a \""""+
		       superClass.getName() + ""\"" variable."");
	  return defaultValue;	  
	}
	return classObj.newInstance();
      }
      catch (Exception e) {
	LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      }
    }
    return defaultValue;    
  }


  
  public static
  String substVars(String val, Properties props) throws
                        IllegalArgumentException {
    sbuf.setLength(0);

    int i = 0;
    int j, k;
    
    while(true) {
      j=val.indexOf(DELIM_START, i);
      if(j == -1) {
	if(i==0)
	  return val;
	else {
	  sbuf.append(val.substring(i, val.length()));
	  return sbuf.toString();
	}
      }
      else {
	sbuf.append(val.substring(i, j));
	k = val.indexOf(DELIM_STOP, j);
	if(k == -1) {
	  throw new IllegalArgumentException('""'+val+
		      ""\"" has no closing brace. Opening brace at position "" + j 
					     + '.');
	}
	else {
	  j += DELIM_START_LEN;
	  String key = val.substring(j, k);
	  
	  String replacement = getSystemProperty(key, null);
	  
	  if(replacement == null && props != null) {
	    replacement =  props.getProperty(key);
	  }

	  if(replacement != null) 
	    sbuf.append(replacement);
	  i = k + DELIM_STOP_LEN;	    
	}
      }
    }
  }


  
  static
  public
  void selectAndConfigure(URL url, Hierarchy hierarchy) {
    String clazz = url.getRef();

    Configurator configurator = null;

    if(clazz != null) {
      LogLog.debug(""Preferred configurator class: "" + clazz);
      configurator = (Configurator) instantiateByClassName(clazz, 
							   Configurator.class,
							   null);
      if(configurator == null) {
	LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
	return;
      }
    } else {
      String filename = url.getFile();
      if(filename != null && filename.endsWith("".xml"")) {
	try {
	  configurator = new DOMConfigurator();
	} catch(NoClassDefFoundError e) {
	  LogLog.warn(""Could not find DOMConfigurator!"", e);
	  return;
	}
      } else {
	configurator = new PropertyConfigurator();
      }
    }

    configurator.doConfigure(url, hierarchy);
  }
}
"
log4j,1.1,org.apache.log4j.spi.ThrowableInformation,4,1,0,2,10,0,1,1,3,0.666666667,43,1.0,1,0.0,0.666666667,0,0,9.0,2,0.75,2,"

package org.apache.log4j.spi;

import java.io.Writer;
import java.io.PrintWriter;
import java.util.Vector;


public class ThrowableInformation implements java.io.Serializable {


  private transient Throwable throwable;
  private String[] rep;
  
  static private VectorWriter vw = new VectorWriter();
  
  public
  ThrowableInformation(Throwable throwable) {
    this.throwable = throwable;
  }

  public
  Throwable getThrowable() {
    return throwable;
  }
  
  public
  String[] getThrowableStrRep() {
    if(rep != null) {
      return (String[]) rep.clone();
    } else {
      throwable.printStackTrace(vw);
      rep = vw.toStringArray();
      vw.clear();
      return rep;
    }
  }
}

class VectorWriter extends PrintWriter {
    
  private Vector v;
  
  VectorWriter() {
    super(new NullWriter());
    v = new Vector();
  }
  
  public
  void println(Object o) {      
    v.addElement(o.toString());
  }
  
  
  
  public
  void println(char[] s) {
    v.addElement(new String(s));
  }
  
  public  
  void println(String s) {
    v.addElement(s);
  }

  public
  String[] toStringArray() {
    int len = v.size();
    String[] sa = new String[len];
    for(int i = 0; i < len; i++) {
      sa[i] = (String) v.elementAt(i);
    }
    return sa;
  }

  public
  void clear() {
    v.setSize(0);
  }
}  

class NullWriter extends Writer {    
  
  public 
  void close() {
  }

  public 
  void flush() {
  }

  public
  void write(char[] cbuf, int off, int len) {
  }
}

"
log4j,1.1,org.apache.log4j.spi.RootCategory,3,2,0,4,6,3,2,3,3,2.0,25,0.0,0,0.959183673,0.833333333,1,5,7.333333333,2,1.0,0,"

package org.apache.log4j.spi;

import  org.apache.log4j.Category;
import  org.apache.log4j.Priority;
import  org.apache.log4j.helpers.LogLog;




final public class RootCategory extends Category {

  
  public
  RootCategory(Priority priority) {
    super(""root"");
    setPriority(priority);
  }

  
  
  final
  public 
  Priority getChainedPriority() {
    return priority;
  }

  
  final  
  public
  void setPriority(Priority priority) {
    if(priority == null) {
      LogLog.error(""You have tried to set a null priority to root."",
		   new Throwable());
    }
    else {
      this.priority = priority;
    }
  }
}
"
log4j,1.1,org.apache.log4j.test.ShortSocketServer,6,1,0,5,32,9,0,5,2,0.666666667,148,0.0,1,0.0,0.333333333,0,0,23.16666667,2,1.0,0,"

package org.apache.log4j.test;

import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;

import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.net.SocketNode;
import org.apache.log4j.net.SocketServer;



public class ShortSocketServer  {

  static Category cat = Category.getInstance(ShortSocketServer.class.getName());

  static int port;
  
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) {
      init(argv[0], argv[1]);
    } else {
      usage(""Wrong number of arguments."");     
    }
    
    try {
      LogLog.debug(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      LogLog.debug(""Waiting to accept a new client."");
      Socket socket = serverSocket.accept();
      LogLog.debug(""Connected to client at "" + socket.getInetAddress());
      LogLog.debug(""Starting new socket node."");	
      SocketNode sn = new SocketNode(socket, Category.getDefaultHierarchy());
      Thread t = new Thread(sn);
      t.start(); 
      t.join();
    }
    catch(Exception e) {
      cat.error(""Error while in main."", e);
    }
  }

  
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +ShortSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
    
  static
  void init(String portStr, String configFile) {
    try {
      port   = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
log4j,1.1,org.apache.log4j.FileAppender,16,3,1,8,40,0,1,7,13,0.666666667,306,0.6,0,0.755555556,0.322916667,1,13,17.8125,6,1.375,3,"

package org.apache.log4j;

import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;





public class FileAppender extends WriterAppender {

 
  public static final String FILE_OPTION = ""File"";


  
  public static final String APPEND_OPTION = ""Append"";


  
  protected boolean fileAppend = true;

  
  protected String fileName = null;

  
  protected boolean qwIsOurs = false;

  
  public
  FileAppender() {
  }


  
  public
  FileAppender(Layout layout, OutputStream os) {
    super(layout, os);
  }
  
  
  public
  FileAppender(Layout layout, Writer writer) {
    super(layout, writer);
  }                    


  
  public
  FileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    this.layout = layout;
    this.setFile(filename, append);
  }

  
  public
  FileAppender(Layout layout, String filename) throws IOException {
    this(layout, filename, true);
  }

  
  public void setFile(String file) {
    
    
    String val = file.trim();
    if(val.equalsIgnoreCase(""System.out"")) {
      setWriter(new OutputStreamWriter(System.out));
    } else if(val.equalsIgnoreCase(""System.err"")) {
      setWriter(new OutputStreamWriter(System.err));
    } else {
      fileName = val;
    }
  }

  
  public
  boolean getAppend() {
    return fileAppend;
  }

  
  
  public
  String getFile() {
    return fileName;
  }
  
  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {FILE_OPTION, APPEND_OPTION});
  }


  
  public
  void setAppend(boolean flag) {
    fileAppend = flag;
  }
  

  
  public
  void activateOptions() {    
    if(fileName != null) {
      try {
	setFile(fileName, fileAppend);
      }
      catch(java.io.IOException e) {
	errorHandler.error(""setFile(""+fileName+"",""+fileAppend+"") call failed."",
			   e, ErrorCode.FILE_OPEN_FAILURE);
      }
    } else {
      
      LogLog.warn(""File option not set for appender [""+name+""]."");
      LogLog.warn(""Are you using FileAppender instead of ConsoleAppender?"");
    }
  }

 
  protected
  void closeFile() {
    
    if(this.qw != null && this.qwIsOurs) {
      try {
	this.qw.close();
      }
      catch(java.io.IOException e) {
	
	
	LogLog.error(""Could not close "" + qw, e);
      }
    }
  }

  
  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    reset();
    this.setQWForFiles(new FileWriter(fileName, append));
    
    this.fileName = fileName;
    this.fileAppend = append;
    this.qwIsOurs = true;
    writeHeader();
  }


  
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    
    if(key.equalsIgnoreCase(FILE_OPTION)) {
      
      
      String val = value.trim();
      if(val.equalsIgnoreCase(""System.out"")) {
	setWriter(new OutputStreamWriter(System.out));
      } else if(val.equalsIgnoreCase(""System.err"")) {
	setWriter(new OutputStreamWriter(System.err));
      } else {
	fileName = val;
      }
    }
    else if (key.equalsIgnoreCase(APPEND_OPTION)) {
      fileAppend = OptionConverter.toBoolean(value, fileAppend);
    }
  }

  
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new QuietWriter(writer, errorHandler);
  }


  
  protected
  void reset() {
    closeFile();
    this.fileName = null;
    if(qwIsOurs) {
      super.reset();    
    } else {
      this.qw = null;
      
    }
  }  
}

"
log4j,1.1,org.apache.log4j.WriterAppender,19,2,1,9,43,85,2,7,13,0.703703704,285,0.666666667,1,0.529411765,0.190789474,1,3,13.84210526,5,1.8947,4,"

package org.apache.log4j;

import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;




public class WriterAppender extends AppenderSkeleton {

  
  public static final String IMMEDIATE_FLUSH_OPTION = ""ImmediateFlush"";

  
  protected boolean immediateFlush = true;

  
  protected QuietWriter qw;

  
  
  public
  WriterAppender() {
  }

  
  public
  WriterAppender(Layout layout, OutputStream os) {
    this(layout, new OutputStreamWriter(os));
  }
  
  
  public
  WriterAppender(Layout layout, Writer writer) {
    this.layout = layout;
    this.setWriter(writer);
  }

  
  public
  void setImmediateFlush(boolean value) {
    immediateFlush = value;
  }

  
  public
  boolean getImmediateFlush() {
    return immediateFlush;
  }

  
  public
  void activateOptions() {    
  }


  
  public
  void append(LoggingEvent event) {

    
    
    
    
    
    
    
    

    if(!checkEntryConditions()) {
      return;
    }
    subAppend(event);
   } 

  
  protected
  boolean checkEntryConditions() {
    if(this.closed) {
      LogLog.warn(""Not allowed to write to a closed appender."");
      return false;
    }

    if(this.qw == null) {
      errorHandler.error(""No output stream or file set for the appender named [""+ 
			name+""]."");
      return false;
    }
    
    if(this.layout == null) {
      errorHandler.error(""No layout set for the appender named [""+ name+""]."");
      return false;
    }
    return true;
  }


  
  public
  synchronized
  void close() {
    if(this.closed)
      return;
    this.closed = true;
    writeFooter();
    reset();
  }

  
  protected 
  void closeWriter() {
    if(qw != null) {
      try {
	qw.close();
      } catch(IOException e) {
	LogLog.error(""Could not close "" + qw, e); 
	                                          
      }
    }
  }


  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
           new String[] {IMMEDIATE_FLUSH_OPTION});
  }

  
  
  public
  synchronized 
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
      if(this.qw != null) {
	this.qw.setErrorHandler(eh);
      }
    }    
  }

  
 public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    
    if (key.equalsIgnoreCase(IMMEDIATE_FLUSH_OPTION)) {
      immediateFlush = OptionConverter.toBoolean(value, immediateFlush);
    }
  }  
  
  
  public
  synchronized
  void setWriter(Writer writer) {
    reset();
    this.qw = new QuietWriter(writer, errorHandler);
    
    writeHeader();
  }


  
  protected
  void subAppend(LoggingEvent event) {
    this.qw.write(this.layout.format(event));

    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  this.qw.write(s[i]);
	  this.qw.write(Layout.LINE_SEP);
	}
      }
    }
 
    if(this.immediateFlush) {
      this.qw.flush();
    } 
  }



  
  public
  boolean requiresLayout() {
    return true;
  }

  
  protected
  void reset() {
    closeWriter();
    this.qw = null;
    
  }


  
  protected
  void writeFooter() {
    if(layout != null) {
      String f = layout.getFooter();
      if(f != null && this.qw != null)
	this.qw.write(f);
    }
  }


  protected 
  void writeHeader() {
    if(layout != null) {
      String h = layout.getHeader();
      if(h != null && this.qw != null)
	this.qw.write(h);
    }
  }
}
"
log4j,1.1,org.apache.log4j.helpers.SyslogQuietWriter,4,4,0,3,10,0,1,2,4,0.5,41,0.0,0,0.875,0.5,2,2,8.75,1,0.75,0,"

package org.apache.log4j.helpers;



import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;


public class SyslogQuietWriter extends QuietWriter {

  int syslogFacility;
  int priority;

  public
  SyslogQuietWriter(Writer writer, int syslogFacility, ErrorHandler eh) {
    super(writer, eh);
    this.syslogFacility = syslogFacility;
  }

  public
  void setPriority(int priority) {
    this.priority = priority;
  }

  public
  void setSyslogFacility(int syslogFacility) {
    this.syslogFacility = syslogFacility;
  }
  
  public
  void write(String string) {
    super.write(""<""+(syslogFacility | priority)+"">"" + string);
  }
}
"
log4j,1.1,org.apache.log4j.HTMLLayout,16,2,0,5,41,74,0,5,13,0.916666667,853,0.375,0,0.363636364,0.244444444,1,1,51.8125,7,2.0,2,"

package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.OptionConverter;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.Writer;


public class HTMLLayout extends Layout {

  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;

  static String TRACE_PREFIX = ""<br>&nbsp;&nbsp;&nbsp;&nbsp;"";

  
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);

  
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";

  
  public static final String TITLE_OPTION = ""Title"";

  
  boolean locationInfo = false;

  String title = ""Log4J Log Messages"";

  
  public
  String[] getOptionStrings() {
    return new String[] {LOCATION_INFO_OPTION, TITLE_OPTION};
  }

  
  public
  void setOption(String key, String value) {
    if(value == null) return;

    if (key.equalsIgnoreCase(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    }
    else if (key.equalsIgnoreCase(TITLE_OPTION)) {
      title = value;
    }
  }
  
  
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  
  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  
  public
  void setTitle(String title) {
    this.title = title;
  }

  
  public
  String getTitle() {
    return title;
  }
  
 
  public
  String getContentType() {
    return ""text/html"";
  }

  
  public
  void activateOptions() {
  }
  
  public 
  String format(LoggingEvent event) {
    
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    
    sbuf.append(Layout.LINE_SEP + ""<tr>"" + Layout.LINE_SEP);
 
    sbuf.append(""<td>"");
    sbuf.append(event.timeStamp - event.getStartTime());
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\"""" + event.getThreadName() + "" thread\"">"");
    sbuf.append(escapeHTMLTags(event.getThreadName()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\""Priority\"">"");
    if (event.priority.equals(Priority.DEBUG)) {
      sbuf.append(""<font color=\""#339933\"">"");
      sbuf.append(event.priority);      
      sbuf.append(""</font>"");
    }
    else if(event.priority.isGreaterOrEqual(Priority.WARN)) {
      sbuf.append(""<font color=\""#993300\""><strong>"");
      sbuf.append(event.priority);      
      sbuf.append(""</strong></font>"");
    } else {
      sbuf.append(event.priority);      
    }
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\"""" + event.categoryName + "" category\"">"");
    sbuf.append(escapeHTMLTags(event.categoryName));
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    if(locationInfo) {
      LocationInfo locInfo = event.getLocationInformation();
      sbuf.append(""<td>"");
      sbuf.append(escapeHTMLTags(locInfo.getFileName()));
      sbuf.append(':');
      sbuf.append(locInfo.getLineNumber());
      sbuf.append(""</td>"" + Layout.LINE_SEP);
    }

    sbuf.append(""<td title=\""Message\"">"");
    sbuf.append(escapeHTMLTags(event.getRenderedMessage()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);

    if (event.getNDC() != null) {
      sbuf.append(""<tr><td bgcolor=\""#EEEEEE\"" style=\""font-size : xx-small;\"" colspan=\""6\"" title=\""Nested Diagnostic Context\"">"");
      sbuf.append(""NDC: "" + escapeHTMLTags(event.getNDC()));
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }

    String[] s = event.getThrowableStrRep(); 
    if(s != null) {
      sbuf.append(""<tr><td bgcolor=\""#993300\"" style=\""color:White; font-size : xx-small;\"" colspan=\""6\"">"");
      appendThrowableAsHTML(s, sbuf);
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }

    return sbuf.toString();
  }

  void appendThrowableAsHTML(String[] s, StringBuffer sbuf) {
    if(s != null) {
      int len = s.length;
      if(len == 0) 
	return;
      sbuf.append(escapeHTMLTags(s[0]));
      sbuf.append(Layout.LINE_SEP);
      for(int i = 1; i < len; i++) {
	sbuf.append(TRACE_PREFIX);
	sbuf.append(escapeHTMLTags(s[i]));
	sbuf.append(Layout.LINE_SEP);
      }
    }
  }

  
  public
  String getHeader() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-
    sbuf.append(""<html>"" + Layout.LINE_SEP);
    sbuf.append(""<head>"" + Layout.LINE_SEP);
    sbuf.append(""<title>"" + title + ""</title>"" + Layout.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">""  + Layout.LINE_SEP);
    sbuf.append(""<!--""  + Layout.LINE_SEP);
    sbuf.append(""body, table {font-family: arial,sans-serif; font-size: x-small;}"" + Layout.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"" + Layout.LINE_SEP);
    sbuf.append(""-->"" + Layout.LINE_SEP);
    sbuf.append(""</style>"" + Layout.LINE_SEP);
    sbuf.append(""</head>"" + Layout.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"" + Layout.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"" + Layout.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"" + Layout.LINE_SEP);
    sbuf.append(""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Time</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Thread</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Priority</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Category</th>"" + Layout.LINE_SEP);
    if(locationInfo) {
      sbuf.append(""<th>File:Line</th>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    return sbuf.toString();
  }

  
  public
  String getFooter() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""</table>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""</body></html>"");
    return sbuf.toString();
  }
 
  
  public
  boolean ignoresThrowable() {
    return false;
  }

  
  private String escapeHTMLTags(String input) {
    
    
    
    if( input == null || input.length() == 0 ) {
        return input;
    }
    
    
    
    
    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';
    
    for(int i=0; i < input.length(); i++) {
        ch = input.charAt(i);
        if(ch == '<') {
            buf.append(""&lt;"");
        }
        else if(ch == '>') {
            buf.append(""&gt;"");
        }
        else {
            buf.append(ch);
        }
    }

    return buf.toString();
  }
}
"
log4j,1.1,org.apache.log4j.performance.SystemTime,5,1,0,0,14,4,0,0,2,0.25,80,0.0,0,0.0,0.25,0,0,14.8,2,1.0,0,"

package org.apache.log4j.performance;


public class SystemTime {

  static int RUN_LENGTH = 1000000;

  static
  public 
  void main(String[] args) {    
    double t = systemCurrentTimeLoop();
    System.out.println(""Average System.currentTimeMillis() call took "" + t);

    t = currentThreadNameloop();
    System.out.println(""Average Thread.currentThread().getName() call took "" 
		       + t);
    
  }

  static
  double systemCurrentTimeLoop() {
    long before = System.currentTimeMillis();
    long l;
    for(int i = 0; i < RUN_LENGTH; i++) {
      l = System.currentTimeMillis();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static
  double currentThreadNameloop() {
    long before = System.currentTimeMillis();
    String t;
    for(int i = 0; i < RUN_LENGTH; i++) {
      t = Thread.currentThread().getName();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
log4j,1.1,org.apache.log4j.or.MessageRenderer,2,1,0,3,22,1,1,2,2,2.0,128,0.0,0,0.0,0.75,0,0,63.0,5,2.5,0,"

package org.apache.log4j.or;

import org.apache.log4j.Layout;
import org.apache.log4j.helpers.LogLog;

import javax.jms.Message;
import javax.jms.JMSException;
import javax.jms.DeliveryMode;
import java.util.Enumeration;


public class MessageRenderer implements ObjectRenderer {

  public
  MessageRenderer() {
  }

   
  
  public
  String  doRender(Object o) {
    if(o instanceof Message) {  
      StringBuffer sbuf = new StringBuffer();
      Message m = (Message) o;
      try {
	sbuf.append(""DeliveryMode="");
	switch(m.getJMSDeliveryMode()) {
	case DeliveryMode.NON_PERSISTENT : 	
	  sbuf.append(""NON_PERSISTENT"");
	  break;
	case DeliveryMode.PERSISTENT : 	
	  sbuf.append(""PERSISTENT"");
	  break;
	default: sbuf.append(""UNKNOWN"");
	}
	sbuf.append("", CorrelationID="");
	sbuf.append(m.getJMSCorrelationID());

	sbuf.append("", Destination="");
	sbuf.append(m.getJMSDestination());

	sbuf.append("", Expiration="");
	sbuf.append(m.getJMSExpiration());

	sbuf.append("", MessageID="");
	sbuf.append(m.getJMSMessageID());

	sbuf.append("", Priority="");
	sbuf.append(m.getJMSPriority());

	sbuf.append("", Redelivered="");
	sbuf.append(m.getJMSRedelivered());

	sbuf.append("", ReplyTo="");
	sbuf.append(m.getJMSReplyTo());

	sbuf.append("", Timestamp="");
	sbuf.append(m.getJMSTimestamp());

	sbuf.append("", Type="");
	sbuf.append(m.getJMSType());

	
	
	
	
	
	

      } catch(JMSException e) {
	LogLog.error(""Could not parse Message."", e);
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
log4j,1.1,org.apache.log4j.helpers.SyslogWriter,5,2,0,2,18,8,1,1,5,0.75,88,0.5,0,0.764705882,0.45,1,2,15.8,1,0.8,0,"

package org.apache.log4j.helpers;


import java.io.Writer;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import java.io.IOException;


public class SyslogWriter extends Writer {

  final int SYSLOG_PORT = 514;
  static String syslogHost;
  
  private InetAddress address;
  private DatagramSocket ds;

  public
  SyslogWriter(String syslogHost) {
    this.syslogHost = syslogHost;

    try {      
      this.address = InetAddress.getByName(syslogHost);
    }
    catch (UnknownHostException e) {
      LogLog.error(""Could not find "" + syslogHost +
			 "". All logging will FAIL."", e);
    }

    try {
      this.ds = new DatagramSocket();
    }
    catch (SocketException e) {
      e.printStackTrace(); 
      LogLog.error(""Could not instantiate DatagramSocket to "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
  }


  public
  void write(char[] buf, int off, int len) throws IOException {
    this.write(new String(buf, off, len));
  }
  
  public
  void write(String string) throws IOException {
    DatagramPacket packet = new DatagramPacket(string.getBytes(),
					       string.length(), 
					       address, SYSLOG_PORT);

    if(this.ds != null)
      ds.send(packet);
    
  }

  public
  void flush() {}

  public
  void close() {}
}
"
log4j,1.1,org.apache.log4j.Category,50,1,2,46,90,637,38,12,43,0.814868805,778,0.5,5,0.0,0.149136578,0,0,14.28,6,2.08,9,"













package org.apache.log4j;

import org.apache.log4j.Priority;
import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.NullEnumeration;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;

import java.util.Enumeration;
import java.util.Vector;
import java.util.MissingResourceException;
import java.text.MessageFormat;
import java.util.ResourceBundle;
import java.net.URL;
import java.net.MalformedURLException;



public class Category implements AppenderAttachable {

  
  static 
  public 
  final Hierarchy defaultHierarchy = new Hierarchy(new 
						   RootCategory(Priority.DEBUG));


  
     static public final String DEFAULT_CONFIGURATION_FILE = ""log4j.properties"";
     
  
     static final public String DEFAULT_CONFIGURATION_KEY=""log4j.configuration"";

  
  public static final String DEFAULT_INIT_OVERRIDE_KEY = 
                                                 ""log4j.defaultInitOverride"";

  
  static {

    String override =OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,
						       null);

    
    
    if(override == null || ""false"".equalsIgnoreCase(override)) {
      String resource = OptionConverter.getSystemProperty(
                                                   DEFAULT_CONFIGURATION_KEY, 
						   DEFAULT_CONFIGURATION_FILE);
      URL url = null;
      try {
	
	
	url = new URL(resource);
      } catch (MalformedURLException ex) {
	url = Loader.getResource(resource, Category.class); 
      }	
      
      
      
      
      if(url != null) {
	LogLog.debug(""Using URL [""+url+""] for automatic log4j configuration."");
	OptionConverter.selectAndConfigure(url, defaultHierarchy);
      } else {
	LogLog.debug(""Could not find resource: [""+resource+""]."");
      }
    }  
  } 

  
  protected String   name;  

  
  volatile protected Priority priority;

  
  volatile protected Category parent;

  
  private static final String FQCN = Category.class.getName();
  
  protected ResourceBundle resourceBundle;
  
  
  protected Hierarchy hierarchy;


  AppenderAttachableImpl aai;

  
  protected boolean additive = true;
  
  
  protected 
  Category(String name) {
    this.name = name;
  }

  
  synchronized  
  public 
  void addAppender(Appender newAppender) {
    if(aai == null) {
      aai = new AppenderAttachableImpl();
    }
    aai.addAppender(newAppender);
  }

  
  public
  void assert(boolean assertion, String msg) {
    if(!assertion)
      this.error(msg);
  }
  

  
  public
  void callAppenders(LoggingEvent event) {
    int writes = 0;

    for(Category c = this; c != null; c=c.parent) {
      
      synchronized(c) {
	if(c.aai != null) {
	  writes += c.aai.appendLoopOnAppenders(event);
	}
	if(!c.additive) {
	  break;
	}
      }
    }
    
    if(!hierarchy.emittedNoAppenderWarning && writes == 0) {
      LogLog.error(""No appenders could be found for category ("" +
		    this.getName() + "")."");
      LogLog.error(""Please initialize the log4j system properly."");
      hierarchy.emittedNoAppenderWarning = true;
    }
  }

  
  synchronized
  void closeNestedAppenders() {
    Enumeration enum = this.getAllAppenders();
    if(enum != null) {
      while(enum.hasMoreElements()) {
	Appender a = (Appender) enum.nextElement();
	if(a instanceof AppenderAttachable) {
	  a.close();
	}
      }
    }
  }

  
  public
  void debug(Object message) {
    if(hierarchy.disable >=  Priority.DEBUG_INT) 
      return;    
    if(Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority())) {
      forcedLog(FQCN, Priority.DEBUG, message, null);
    }
  }
  

    
  public
  void debug(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.DEBUG_INT) return;
    if(this.isEnabledFor(Priority.DEBUG))
      forcedLog(FQCN, Priority.DEBUG, message, t);    
  }

  
  
  
  
  
  
  
  
  
  
  public
  void error(Object message) {
    if(hierarchy.disable >=  Priority.ERROR_INT) return;
    if(this.isEnabledFor(Priority.ERROR))
      forcedLog(FQCN, Priority.ERROR, message, null);
  }

    
  public
  void error(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.ERROR_INT) return;
    if(this.isEnabledFor(Priority.ERROR))
      forcedLog(FQCN, Priority.ERROR, message, t);
    
  }


  
  public
  static
  Category exists(String name) {    
    return defaultHierarchy.exists(name);
  }

  
  public
  void fatal(Object message) {
    if(hierarchy.disable >=  Priority.FATAL_INT) return;    
    if(Priority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.FATAL, message, null);
  }
  
  
  public
  void fatal(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.FATAL_INT) return;   
    if(Priority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.FATAL, message, t);
  }


  
  protected
  void forcedLog(String fqcn, Priority priority, Object message, Throwable t) {
    callAppenders(new LoggingEvent(fqcn, this, priority, message, t));
  }


  
  public
  boolean getAdditivity() {
    return additive;
  }

  
  synchronized
  public
  Enumeration getAllAppenders() {
    if(aai == null)
      return NullEnumeration.getInstance();
    else 
      return aai.getAllAppenders();
  }

  
  synchronized
  public
  Appender getAppender(String name) {
     if(aai == null || name == null)
      return null;

     return aai.getAppender(name);
  }
  
  
  public 
  Priority getChainedPriority() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.priority != null) 
	return c.priority;
    }
    return null; 
  }

  
  public
  static
  Enumeration getCurrentCategories() {
    return defaultHierarchy.getCurrentCategories();
  }


  
  public 
  static 
  Hierarchy getDefaultHierarchy() {
    return defaultHierarchy;
  }


  
  public  
  Hierarchy getHierarchy() {
    return hierarchy;
  }

  
 
  public
  static
  Category getInstance(String name) {
    return defaultHierarchy.getInstance(name);
  }	

 
  public
  static
  Category getInstance(Class clazz) {
    return getInstance(clazz.getName());
  }	


  
  public
  static
  Category getInstance(String name, CategoryFactory factory) {
    return defaultHierarchy.getInstance(name, factory);
  }	

  
  
  public
  final
  String getName() {
    return name;
  }
    
  
  final
  public
  Priority getPriority() {
    return this.priority;
  }

  
  final
  public
  static
  Category getRoot() {
    return defaultHierarchy.getRoot();
  }

  
  public
  ResourceBundle getResourceBundle() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.resourceBundle != null) 
	return c.resourceBundle;
    }
    
    return null;
  }

  
  protected
  String getResourceBundleString(String key) {
    ResourceBundle rb = getResourceBundle();
    
    
    if(rb == null) {
      if(!hierarchy.emittedNoResourceBundleWarning) {
	error(""No resource bundle has been set for category ""+name);
	hierarchy.emittedNoResourceBundleWarning = true;
      }
      return null;
    }
    else {
      try {
	return rb.getString(key);
      }
      catch(MissingResourceException mre) {
	error(""No resource is associated with key \""""+key+""\""."");
	return null;
      }
    }
  }
  
  
  public
  void info(Object message) {
    if(hierarchy.disable >=  Priority.INFO_INT) return;    
    if(Priority.INFO.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.INFO, message, null);
  }
  
  
  public
  void info(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.INFO_INT) return;   
    if(Priority.INFO.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.INFO, message, t);
  }

  
  public
  boolean isDebugEnabled() {
    if(hierarchy.disable >=  Priority.DEBUG_INT)
      return false;   
    return Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority());
  }
  
  
  public
  boolean isEnabledFor(Priority priority) {
    if(hierarchy.disable >= priority.level) {
      return false;
    }
    return priority.isGreaterOrEqual(this.getChainedPriority());
  }

  
  public
  boolean isInfoEnabled() {
    if(hierarchy.disable >= Priority.INFO_INT)
      return false;   
    return Priority.INFO.isGreaterOrEqual(this.getChainedPriority());
  }


  
  public
  void l7dlog(Priority priority, String key, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      String msg = getResourceBundleString(key);
      
      
      if(msg == null) {
	msg = key;
      }
      forcedLog(FQCN, priority, msg, t);
    }
  }
  
  public
  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }    
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      String pattern = getResourceBundleString(key);
      String msg;
      if(pattern == null) 
	msg = key;
      else 
	msg = java.text.MessageFormat.format(pattern, params);
      forcedLog(FQCN, priority, msg, t);
    }
  }
  
  
  public
  void log(Priority priority, Object message, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) 
      forcedLog(FQCN, priority, message, t);
  }
  
 
  public
  void log(Priority priority, Object message) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, priority, message, null);
  }

  
  public
  void log(String callerFQCN, Priority priority, Object message, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      forcedLog(callerFQCN, priority, message, t);
    }
  }


  
  synchronized
  public
  void removeAllAppenders() {
    if(aai != null) {
      aai.removeAllAppenders();
      aai = null;
    }
  }

  
  synchronized
  public
  void removeAppender(Appender appender) {
    if(appender == null || aai == null) 
      return;
    aai.removeAppender(appender);
  }

  
  synchronized
  public
  void removeAppender(String name) {
    if(name == null || aai == null) return;
    aai.removeAppender(name);
  }
  
  
  public
  void setAdditivity(boolean additive) {
    this.additive = additive;
  }

  
  final
  void setHierarchy(Hierarchy hierarchy) {
    this.hierarchy = hierarchy;
  }
  
  
  public
  void setPriority(Priority priority) {
    this.priority = priority;
  }


  
  public
  void setResourceBundle(ResourceBundle bundle) {
    resourceBundle = bundle;
  }

  
  public
  static
  void shutdown() {
    defaultHierarchy.shutdown();
  }

  
  
  public
  void warn(Object message) {
    if(this.isEnabledFor(Priority.WARN))
      forcedLog(FQCN, Priority.WARN, message, null);
  }
  
  
  public
  void warn(Object message, Throwable t) {
    if(this.isEnabledFor(Priority.WARN))
      forcedLog(FQCN, Priority.WARN, message, t);
  }
}
"
log4j,1.1,org.apache.log4j.performance.NOPWriter,8,2,0,0,10,28,0,0,8,2.0,21,0.0,0,0.65,0.46875,1,2,1.625,1,0.875,0,"


package org.apache.log4j.performance;

import java.io.Writer;
import java.io.IOException;


public class NOPWriter extends Writer {

  
  
  
  

  public
  void write(char[] cbuf) throws IOException {}

  public
  void write(char[] cbuf, int off, int len) throws IOException {}


  public
  void write(int b) throws IOException {}

  public 
  void write(String s) throws IOException {} 

  public 
  void write(String s, int off, int len) throws IOException {} 

  public 
  void flush() throws IOException {
  }

  public 
  void close() throws IOException {
    System.err.println(""Close called."");
  }
}
"
log4j,1.1,org.apache.log4j.Appender,12,1,0,21,12,66,17,4,12,2.0,12,0.0,0,0.0,0.236111111,0,0,0.0,1,1.0,0,"

package org.apache.log4j;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;


public interface Appender {

  
  void addFilter(Filter newFilter);

  
  public
  Filter getFilter();

  
  public
  void clearFilters();

  
  public
  void close();
  
  
  public
  void doAppend(LoggingEvent event);


  
  public
  String getName();


  
  public
  void setErrorHandler(ErrorHandler errorHandler);

  
  public
  ErrorHandler getErrorHandler();

  
  public
  void setLayout(Layout layout);

  
  public
  Layout getLayout();
  

  
  public
  void setName(String name);

  
  public
  boolean requiresLayout();
}
"
log4j,1.1,org.apache.log4j.test.CategoryWrapper,7,1,0,6,22,11,0,6,3,0.666666667,107,0.0,1,0.0,0.375,0,0,13.85714286,2,0.8571,0,"
package org.apache.log4j.test;

import org.apache.log4j.*;



public class CategoryWrapper {


  Category c;
  static String FQCN = CategoryWrapper.class.getName();

  CategoryWrapper(String name) {
    c = Category.getInstance(name);
  }

  public 
  static 
  void main(String argv[]) {    
    Layout layout = new PatternLayout(""%p [%t] %C %F - %m\n"");
    Appender out = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_OUT);
    CategoryWrapper w1 = new CategoryWrapper(""c1"");
    w1.addAppender(out);
    w1.print(""hello"");
  }


  public 
  void addAppender(Appender appender) {
    c.addAppender(appender);
  }

  public 
  void print(String msg) {

    
    
    

    
    
    
    

    c.log(FQCN+"".print"", Priority.DEBUG, msg, null);
  }
  
  
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+CategoryWrapper.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
log4j,1.1,org.apache.log4j.helpers.OnlyOnceErrorHandler,6,1,0,3,9,9,1,2,6,0.866666667,44,0.0,0,0.0,0.458333333,0,0,5.833333333,2,1.1667,0,"

package org.apache.log4j.helpers;

import  org.apache.log4j.spi.ErrorHandler;


public class OnlyOnceErrorHandler implements ErrorHandler {


  final String WARN_PREFIX = ""log4j warning: "";
  final String ERROR_PREFIX = ""log4j error: "";

  boolean firstTime = true;

  
  public
  String[] getOptionStrings() {
    return null;
  }

  
  public
  void setOption(String key, String value) {
  }

  
  public
  void activateOptions() {
  }


  
  public
  void error(String message, Exception e, int errorCode) { 
    if(firstTime) {
      LogLog.error(message, e);
      firstTime = false;
    }
  }

  

  

  

  
  public
  void error(String message) {
    if(firstTime) {
      LogLog.error(message);
      firstTime = false;
    }
  }
}
"
log4j,1.1,org.apache.log4j.net.SocketAppender,22,2,0,9,51,95,3,7,18,0.888888889,414,0.133333333,1,0.486486486,0.198863636,2,3,17.13636364,6,1.5455,1,"








package org.apache.log4j.net;

import java.net.InetAddress;
import java.net.Socket;
import java.io.OutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.PrintWriter;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;



public class SocketAppender extends AppenderSkeleton {
  
  public static final String REMOTE_HOST_OPTION = ""RemoteHost"";

 
  public static final String PORT_OPTION = ""Port"";

  
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";

  
  public static final String RECONNECTION_DELAY_OPTION = ""ReconnectionDelay"";

  
  static final int DEFAULT_PORT                 = 4560;
  
  
  static final int DEFAULT_RECONNECTION_DELAY   = 30000;

  
  String remoteHost;
  
  InetAddress address;
  int port = DEFAULT_PORT;
  ObjectOutputStream oos;
  int reconnectionDelay = DEFAULT_RECONNECTION_DELAY;
  boolean locationInfo = false;

  private Connector connector;

  int counter = 0; 
  

  
  
  private static final int RESET_FREQUENCY = 1;

  public SocketAppender() {
  }

  
  public
  SocketAppender(InetAddress address, int port) {
    this.address = address;
    this.remoteHost = address.getHostName();
    this.port = port;
    connect(address, port);
  }

  
  public
  SocketAppender(String host, int port) { 
    this.port = port;
    this.address = getAddressByName(host);
    this.remoteHost = host;
    connect(address, port);
  }
  
  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
                          new String[] {REMOTE_HOST_OPTION, PORT_OPTION, 
					LOCATION_INFO_OPTION,
					RECONNECTION_DELAY_OPTION});
  }

  
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    

    if(option.equals(REMOTE_HOST_OPTION)) {
      address = getAddressByName(value);
      remoteHost = value;
    } else if (option.equals(PORT_OPTION)) {
      port = OptionConverter.toInt(value, port);
    } else if (option.equals(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);    
    } else if (option.equals(RECONNECTION_DELAY_OPTION)) {
      reconnectionDelay = OptionConverter.toInt(value, reconnectionDelay);  
    }
  }
  
  
  public
  void activateOptions() {
    connect(address, port);
  }

  
  synchronized
  public
  void close() {
    if(closed)
      return;

    this.closed = true;
    cleanUp();
  }

  
  public 
  void cleanUp() {
    if(oos != null) {
      try {
	oos.close();
      }
      catch(IOException e) {
	LogLog.error(""Could not close oos."", e);
      }
      oos = null;      
    }
    if(connector != null) {
      
      connector.interrupted = true;
      connector = null;  
    }
  }

  void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      
      cleanUp();          
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    }
    catch(IOException e) {
      LogLog.error(""Could not connect to remote log4j server at [""
		   +address.getHostName()+""]. We will try again later."", e);
      fireConnector();
    }
  }


  public
  void append(LoggingEvent event) {
    if(event == null)
      return;

    if(address==null) {
      errorHandler.error(""No remote host is set for SocketAppender named \""""+
			this.name+""\""."");
      return;
    }

    if(oos != null) {
      try {
	if(locationInfo) {
	   event.getLocationInformation();	
	} 
	oos.writeObject(event);
	
	oos.flush();
	if(++counter >= RESET_FREQUENCY) {
	  counter = 0;
	  
	  
	  
	  oos.reset();
	}
      }
      catch(IOException e) {
	oos = null;
	LogLog.warn(""Detected problem with connection: ""+e);
	if(reconnectionDelay > 0) {
	  fireConnector();
	}
      }
    }
  }

  void fireConnector() {
    if(connector == null) {
      LogLog.debug(""Starting a new connector thread."");
      connector = new Connector();
      connector.setDaemon(true);
      connector.setPriority(Thread.MIN_PRIORITY);
      connector.start();      
    }
  }
  
  static
  InetAddress getAddressByName(String host) {
    try {
      return InetAddress.getByName(host);
    }	
    catch(Exception e) {
      LogLog.error(""Could not find address of [""+host+""]."", e);
      return null;
    }
  }

  
  public
  boolean requiresLayout() {
    return false;
  }

  
  public
  void setRemoteHost(String host) {
    address = getAddressByName(host);
    remoteHost = host;
  }
  
  
  public
  String getRemoteHost() {
    return remoteHost;
  }
  
  
  public
  void setPort(int port) {
    this.port = port;
  }
  
  
  public
  int getPort() {
    return port;
  }
  
  
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  
  
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  
  
  public
  void setReconnectionDelay(int delay) {
    this.reconnectionDelay = delay;
  }
  
  
  public
  int getReconnectionDelay() {
    return reconnectionDelay;
  }
  
  
  class Connector extends Thread {

    boolean interrupted = false;

    public
    void run() {
      Socket socket;      
      while(!interrupted) {
	try {
	  sleep(reconnectionDelay);
	  LogLog.debug(""Attempting connection to ""+address.getHostName());
	  socket = new Socket(address, port);
	  synchronized(this) {
	    oos = new ObjectOutputStream(socket.getOutputStream()); 
	    connector = null;
	    break;
	  }
	}
	catch(InterruptedException e) {
	  LogLog.debug(""Connector interrupted. Leaving loop."");
	  return;
	}
	catch(java.net.ConnectException e) {
	  LogLog.debug(""Remote host ""+address.getHostName()
		       +"" refused connection."");
	}
	catch(IOException e) {	  
	  LogLog.debug(""Could not connect to "" + address.getHostName()+
		       "". Exception is "" + e);
	}
      }
      
    }
    
    
  }

}
"
log4j,1.1,org.apache.log4j.test.Hello,4,1,0,2,12,4,0,2,2,0.833333333,38,0.0,1,0.0,0.333333333,0,0,8.0,1,0.5,0,"

package org.apache.log4j.test; 

import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;


public class Hello {

  static Category cat = Category.getInstance(Hello.class);

  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    cat.debug(""Hello world."");
    cat.info(""What a beatiful day."");
  }
}
"
log4j,1.1,org.apache.log4j.spi.OptionHandler,3,1,0,7,3,3,7,0,3,2.0,3,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,1,"

package org.apache.log4j.spi;

import org.apache.log4j.FileAppender;


public interface OptionHandler {

  
  void activateOptions();

  
  String[] getOptionStrings();

  
  void setOption(String option, String value);
}
"
log4j,1.1,org.apache.log4j.BasicConfigurator,14,1,1,17,36,91,6,11,10,1.057692308,161,0.0,0,0.0,0.138461538,0,0,10.21428571,3,1.0,2,"





package org.apache.log4j;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.util.Enumeration;


public class BasicConfigurator {

   
     public static final String DISABLE_OVERRIDE_KEY = ""log4j.disableOverride"";

  
     public static final String DISABLE_KEY = ""log4j.disable"";


  
  public static final String INHERITED = ""inherited"";


  
  
  
  static {    
    String override = OptionConverter.getSystemProperty(DISABLE_OVERRIDE_KEY, null);
    if(override != null) {
      Category.defaultHierarchy.setDisableOverride(override);
    } else { 
      String disableStr = OptionConverter.getSystemProperty(DISABLE_KEY, null);
      if(disableStr != null) {
	Category.defaultHierarchy.disable(disableStr);
      }
    }
  }


  protected BasicConfigurator() {
  }

  
  protected
  void addRenderer(Hierarchy hierarchy, String renderedClassName, 
		   String renderingClassName) {
    LogLog.debug(""Rendering class: [""+renderingClassName+""], Rendered class: [""+
		 renderedClassName+""]."");
    ObjectRenderer renderer = (ObjectRenderer) 
             OptionConverter.instantiateByClassName(renderingClassName, 
						    ObjectRenderer.class,
						    null);
    if(renderer == null) {
      LogLog.error(""Could not instantiate renderer [""+renderingClassName+""]."");
      return;
    } else {
      try {
	Class renderedClass = Class.forName(renderedClassName);
	hierarchy.rendererMap.put(renderedClass, renderer);
      } catch(ClassNotFoundException e) {
	LogLog.error(""Could not find class [""+renderedClassName+""]."", e);
      }
    }
  }

  
  public
  static
  void disable(String priorityStr) {
    Category.getDefaultHierarchy().disable(priorityStr);
  }

  
  public
  static
  void disable(Priority p) {
  
  }
  

    
  public
  static
  void disableAll() {
      Category.getDefaultHierarchy().disable(Priority.FATAL);
  }

  
  public
  static
  void disableDebug() {
    Category.getDefaultHierarchy().disable(Priority.DEBUG);
  }  

  
  public
  static
  void disableInfo() {
    Category.getDefaultHierarchy().disable(Priority.INFO);
  } 
  

  
  public
  static
  void enableAll() {
    Category.getDefaultHierarchy().disable(Priority.INFO);
  }

  
  static
  public
  void configure() {
    Category root = Category.getRoot();
    root.addAppender(new ConsoleAppender(
           new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
  }

  
  static
  public
  void configure(Appender appender) {
    Category root = Category.getRoot();
    root.addAppender(appender);
  }

  
  public
  static
  void resetConfiguration() {
    Category.defaultHierarchy.resetConfiguration();
  }

  
  public
  static
  void resetConfiguration(Hierarchy hierarchy) {
    hierarchy.resetConfiguration();
  }
}
"
log4j,1.1,org.apache.log4j.helpers.CountingQuietWriter,4,4,0,3,8,0,1,2,4,0.333333333,38,1.0,0,0.875,0.4,2,2,8.25,1,0.75,0,"

package org.apache.log4j.helpers;

import java.io.File;
import java.io.Writer;
import java.io.FileWriter;
import java.io.FilterWriter;
import java.io.IOException;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;


public class CountingQuietWriter extends QuietWriter {

  protected long count;

  public
  CountingQuietWriter(Writer writer, ErrorHandler eh) {
    super(writer, eh);
  }
  
  public
  void write(String string) {
    try {
      out.write(string);
      count += string.length();
    }
    catch(IOException e) {
      errorHandler.error(""Write failure."", e, ErrorCode.WRITE_FAILURE);
    }
  }

  public
  long getCount() {
    return count;
  }

  public
  void setCount(long count) {
    this.count = count;
  }
  
}
"
log4j,1.1,org.apache.log4j.test.L7D,6,1,0,3,25,13,0,3,2,0.7,202,0.0,0,0.0,0.277777778,0,0,32.33333333,2,1.3333,0,"






package org.apache.log4j.test; 

import org.apache.log4j.*;
import java.util.*;
import java.text.*;


public class L7D {
  static ResourceBundle[] bundles;
  

  public 
  static 
  void main(String args[]) {
    if(args.length == 3) 
      init(args[0], args[1], args[2]);
    else 
      Usage(""Wrong number of arguments."");

    test();
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + L7D.class.getName() +
			""configFile ISO639LanguageCode ISO2166CountryCode"");
    System.exit(1);
  }

  static
  void init(String configFile, String lanCode, String countryCode) {
    PropertyConfigurator.configure(configFile);
    bundles = new ResourceBundle[3];

    try {
      bundles[0] = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
      bundles[1] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
      bundles[2] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH"")); 
					 
    }
    catch(MissingResourceException e) {
      e.printStackTrace();
    }
  }

  static
  void test() { 
    Category root = Category.getRoot();
    
    for(int i = 0; i < bundles.length; i++) {
      root.setResourceBundle(bundles[i]);
      
      root.l7dlog(Priority.DEBUG, ""bogus1"", null);            
      root.l7dlog(Priority.INFO, ""test"", null);
      root.l7dlog(Priority.WARN, ""hello_world"", null);
      root.l7dlog(Priority.DEBUG, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.ERROR, ""bogusMsg"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);      
      root.l7dlog(Priority.ERROR, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.INFO, ""bogus2"", null);
    }
    
  }
  
}
"
log4j,1.1,org.apache.log4j.net.JMSAppender,13,2,0,5,38,44,0,5,11,0.845238095,284,0.0,0,0.6,0.365384615,2,3,20.30769231,5,1.6923,2,"

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;

import java.util.Properties;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;


public class JMSAppender extends AppenderSkeleton {
  
  public static final String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION 
                                                 = ""TopicConnectionFactoryBindingName"";

  
  public static final String TOPIC_BINDING_NAME_OPTION = ""TopicBindingName"";

  TopicConnection  topicConnection;
  TopicSession topicSession;
  TopicPublisher  topicPublisher;
  String topicBindingName;
  String tcfBindingName;

  public 
  JMSAppender() {
  }

 
  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TOPIC_BINDING_NAME_OPTION, 
			  TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION});
  }

 

  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);    
    
    if(key.equals(TOPIC_BINDING_NAME_OPTION)) 
      topicBindingName = value;
    else if(key.equals(TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION)) {
      tcfBindingName = value;
    }
  }
  
  
  public
  void setTopicConnectionFactoryBindingName(String tcfBindingName) {
    this.tcfBindingName = tcfBindingName;
  }
  
  
  public
  String getTopicConnectionFactoryBindingName() {
    return tcfBindingName;
  }
  
  
  public
  void setTopicBindingName(String topicBindingName) {
    this.topicBindingName = topicBindingName;
  }
  
  
  public
  String getTopicBindingName() {
    return topicBindingName;
  }
  
  public
  void activateOptions() {
    TopicConnectionFactory  topicConnectionFactory;

    try {
      Context ctx = new InitialContext();      
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, tcfBindingName);
      topicConnection = topicConnectionFactory.createTopicConnection();
      topicConnection.start();
    
      topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      
      Topic topic = (Topic) lookup(ctx, topicBindingName);
      topicPublisher = topicSession.createPublisher(topic);

      ctx.close();      
    } catch(Exception e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    }
  }
 
  protected
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }
  
  protected
  boolean checkEntryConditions() {
    String fail = null;

    if(this.topicConnection == null) {
      fail = ""No TopicConnection"";
    } else if(this.topicSession == null) {
      fail = ""No TopicSession"";
    } else if(this.topicPublisher == null) {
      fail = ""No TopicPublisher"";
    } 

    if(fail != null) {
      errorHandler.error(fail +"" for JMSAppender named [""+name+""]."");      
      return false;
    } else {
      return true;
    }
  }

  
  public 
  synchronized 
  void close() {
    if(this.closed) 
      return;

    LogLog.debug(""Closing appender [""+name+""]."");
    this.closed = true;    

    try {
      if(topicSession != null) 
	topicSession.close();	
      if(topicConnection != null) 
	topicConnection.close();
    } catch(Exception e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);	
    }   
    
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }

  
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }

    try {
      ObjectMessage msg = topicSession.createObjectMessage();
      msg.setObject(event);
      topicPublisher.publish(msg);
    } catch(Exception e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e, 
			 ErrorCode.GENERIC_FAILURE);
    }
  }

  public
  boolean requiresLayout() {
    return false;
  }  
}
"
log4j,1.1,org.apache.log4j.spi.TriggeringEventEvaluator,1,1,0,3,1,0,2,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.log4j.spi;


public interface TriggeringEventEvaluator {
  
  
  public boolean isTriggeringEvent(LoggingEvent event);
}
"
log4j,1.1,org.apache.log4j.config.PropertySetterException,3,3,0,1,6,1,1,0,3,0.5,28,1.0,0,0.944444444,0.555555556,1,1,8.0,3,1.0,0,"

package org.apache.log4j.config;


public class PropertySetterException extends Exception {
  protected Throwable rootCause;
  
  public
  PropertySetterException(String msg) {
    super(msg);
  }
  
  public
  PropertySetterException(Throwable rootCause)
  {
    super();
    this.rootCause = rootCause;
  }
  
  
  public
  String getMessage() {
    String msg = super.getMessage();
    if (msg == null && rootCause != null) {
      msg = rootCause.getMessage();
    }
    return msg;
  }
}"
log4j,1.1,org.apache.log4j.helpers.NullEnumeration,5,1,0,1,7,8,1,0,3,0.75,22,1.0,1,0.0,0.75,0,0,3.2,1,0.6,0,"

package org.apache.log4j.helpers;

import java.util.Enumeration;
import java.util.NoSuchElementException;


public class NullEnumeration implements Enumeration {
  private static final NullEnumeration instance = new NullEnumeration();
  
  private
  NullEnumeration() {
  }
  
  public
  static
  NullEnumeration getInstance() {
    return instance;
  }
  
  public
  boolean hasMoreElements() {
    return false;
  }
  
  public
  Object nextElement() {
    throw new NoSuchElementException();
  }
}
"
log4j,1.1,org.apache.log4j.RollingFileAppender,15,3,0,10,44,3,0,10,13,0.767857143,334,0.5,0,0.733333333,0.241666667,1,10,21.0,5,1.3333,1,"



package org.apache.log4j;

import java.beans.*;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.File;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.spi.LoggingEvent;


public class RollingFileAppender extends FileAppender {
  
  static final public String MAX_FILE_SIZE_OPTION = ""MaxFileSize"";
  
   
  static final public String MAX_BACKUP_INDEX_OPTION = ""MaxBackupIndex"";  

  
  protected long maxFileSize = 10*1024*1024; 

  
  protected int  maxBackupIndex  = 1;    

  
  public
  RollingFileAppender() {
    super();
  }
  
  
  public
  RollingFileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    super(layout, filename, append);
  }

  
  public
  RollingFileAppender(Layout layout, String filename) throws IOException {
    super(layout, filename);
  }

  
  public
  int getMaxBackupIndex() {
    return maxBackupIndex;
  }

 
  public
  long getMaximumFileSize() {
    return maxFileSize;
  }
  
  
  public
  String[] getOptionStrings() {

    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {MAX_FILE_SIZE_OPTION, MAX_BACKUP_INDEX_OPTION});
  }

  
  public 
  void rollOver() {
    File target;    
    File file;

    LogLog.debug(""rolling over count="" + ((CountingQuietWriter) qw).getCount());
    LogLog.debug(""maxBackupIndex=""+maxBackupIndex);
    
    
    if(maxBackupIndex > 0) {
      
      file = new File(fileName + '.' + maxBackupIndex);    
      if (file.exists())
       file.delete();
      
      
      for (int i = maxBackupIndex - 1; i >= 1; i--) {
	file = new File(fileName + ""."" + i);
	if (file.exists()) {
	  target = new File(fileName + '.' + (i + 1));
	  LogLog.debug(""Renaming file "" + file + "" to "" + target);
	  file.renameTo(target);
	}
      }

      
      target = new File(fileName + ""."" + 1);

      this.closeFile(); 

      file = new File(fileName);
      LogLog.debug(""Renaming file "" + file + "" to "" + target);
      file.renameTo(target);
    }
    
    try {
      
      
      this.setFile(fileName, false);
    }
    catch(IOException e) {
      LogLog.error(""setFile(""+fileName+"", false) call failed."", e);
    }
  }

  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    super.setFile(fileName, append);
    if(append) {
      File f = new File(fileName);
      ((CountingQuietWriter) qw).setCount(f.length());
    }
  }

  
  public
  void setOption(String key, String value) {
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(MAX_FILE_SIZE_OPTION)) {
      maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
    }
    else if(key.equalsIgnoreCase(MAX_BACKUP_INDEX_OPTION)) {
      maxBackupIndex = OptionConverter.toInt(value, maxBackupIndex);
    }
  }
  
  
  public
  void setMaxBackupIndex(int maxBackups) {
    this.maxBackupIndex = maxBackups;    
  }
  
  
  public
  void setMaxFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }

  
  public
  void setMaximumFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }


  
  public
  void setMaxFileSize(String value) {
    maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
  }

  protected
  void setQWForFiles(Writer writer) {
     this.qw = new CountingQuietWriter(writer, errorHandler);
  }

  
  protected
  void subAppend(LoggingEvent event) {
    super.subAppend(event);
    if((fileName != null) &&
                     ((CountingQuietWriter) qw).getCount() >= maxFileSize) 
      this.rollOver();
   }
}
"
log4j,1.1,org.apache.log4j.AppenderSkeleton,22,1,8,20,35,175,11,9,21,0.904761905,193,0.875,5,0.0,0.201298701,0,0,7.409090909,4,1.3636,4,"

package org.apache.log4j;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.helpers.LogLog;



public abstract class AppenderSkeleton implements Appender, OptionHandler {

  
  public static final String THRESHOLD_OPTION = ""Threshold"";


  
  protected Layout layout;

  
  protected String name;

  
  protected Priority threshold;

  
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();

  
  protected Filter headFilter;
  
  protected Filter tailFilter;

  
  protected boolean closed = false;


  
  public
  void activateOptions() {
  }


  
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.next = newFilter;
      tailFilter = newFilter;    
    }
  }

  
  abstract
  protected
  void append(LoggingEvent event);


  
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }

  
  public
  void finalize() {
    
    
    if(this.closed) 
      return;

    LogLog.debug(""Finalizing appender named [""+name+""]."");
    close();
  }


  
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }


  
  public
  Filter getFilter() {
    return headFilter;
  }

  
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }

  
  public
  Layout getLayout() {
    return layout;
  }


  
  public
  final
  String getName() {
    return this.name;
  }

  
  public
  String[] getOptionStrings() {
    return new String[] {THRESHOLD_OPTION};
  }

  

  
  public
  Priority getThreshold() {
    return threshold;
  }


  
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }


  
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error(""Attempted to append to closed appender named [""+name+""]."");
    }

    if(!isAsSevereAsThreshold(event.priority)) {
      return;
    }

    Filter f = this.headFilter;
    
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.next;
      }
    }
    
    this.append(event);    
  }

  
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      
      
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
    }
  }

  
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }

  
  
  public
  void setName(String name) {
    this.name = name;
  }


  
  public
  void setOption(String key, String value) {
    if(key.equalsIgnoreCase(THRESHOLD_OPTION)) {
      threshold = Priority.toPriority(value);
    }
  }
  
  
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }  
}
"
