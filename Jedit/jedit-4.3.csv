name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
jEdit,4.3,org.gjt.sp.jedit.bufferio.BufferAutosaveRequest,2,3,0,9,16,1,1,9,2,2.0,113,0.0,0,0.933333333,0.583333333,0,0,55.5,9,4.5,0,"

package org.gjt.sp.jedit.bufferio;


import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class BufferAutosaveRequest extends BufferIORequest
{
	
	
	public BufferAutosaveRequest(View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		super(view,buffer,session,vfs,path);
	} 

	
	public void run()
	{
		OutputStream out = null;

		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.autosave"",args));

			
			setAbortable(true);

			try
			{
				

				if(!buffer.isDirty())
				{
					
					
					return;
				}

				out = vfs._createOutputStream(session,path,view);
				if(out == null)
					return;

				write(buffer,out);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);

				
				if(out != null)
				{
					try
					{
						out.close();
						out = null;
						vfs._delete(session,path,view);
					}
					catch(IOException ioe)
					{
						Log.log(Log.ERROR,this,ioe);
					}
				}
			}
			
			
				
			
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			IOUtilities.closeQuietly(out);
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.CommandLineReader,4,3,0,1,8,4,1,0,4,1.0,82,0.0,0,0.857142857,0.35,2,2,18.5,1,0.75,0,"


package org.gjt.sp.jedit.bsh;

import java.io.*;


class CommandLineReader extends FilterReader {

    public CommandLineReader( Reader in ) {
		super(in);
    }

	static final int 
		normal = 0,
		lastCharNL = 1,
		sentSemi = 2;

	int state = lastCharNL;

    public int read() throws IOException {
		int b;

		if ( state == sentSemi ) {
			state = lastCharNL;
			return '\n';
		}

		
        while ( (b = in.read()) == '\r' );

		if ( b == '\n' )
			if ( state == lastCharNL ) {
				b = ';';
				state = sentSemi;
			} else
				state = lastCharNL;
		else
			state = normal;

		return b;
    }

	
    public int read(char buff[], int off, int len) throws IOException 
	{
		int b = read();
		if ( b == -1 )
			return -1;  
		else {
			buff[off]=(char)b;
			return 1;
		}
    }

	
	public static void main( String [] args ) throws Exception {
		Reader in = new CommandLineReader( new InputStreamReader(System.in) );
		while ( true )
			System.out.println( in.read() );
		
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bufferset.BufferSet,18,1,0,16,55,0,11,8,13,0.647058824,687,1.0,0,0.0,0.426470588,0,0,36.88888889,12,2.5,1,"
package org.gjt.sp.jedit.bufferset;


import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;

import javax.swing.event.EventListenerList;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;



public class BufferSet
{
	
	public enum Scope
	{
		global, view, editpane;

		public static Scope fromString(String s)
		{
			Scope[] scopes = values();
			for (Scope scope: scopes)
			{
				if (scope.toString().equals(s))
					return scope;
			}

			return global;
		}
	} 

	
	
	public BufferSet()
	{
		buffers = Collections.synchronizedList(new ArrayList<Buffer>());
		listeners = new EventListenerList();

		if (jEdit.getBooleanProperty(""sortBuffers""))
		{
			if (jEdit.getBooleanProperty(""sortByName""))
				sorter = nameSorter;
			else
				sorter = pathSorter;
		}
	} 

	
	public void addBufferAt(Buffer buffer, int position)
	{
		Log.log(Log.DEBUG, this, hashCode() + "" addBufferAt(""+buffer+','+position+')');

		Buffer untitledBuffer = null;
		synchronized (buffers)
		{
			if (buffers.size() == 1)
			{
				Buffer buf = buffers.get(0);
				if (buf.isUntitled() && !buf.isDirty())
				{
					untitledBuffer = buf;
				}
			}

			if (sorter != null)
			{
				if (buffers.contains(buffer))
					return;
				buffers.add(buffer);
				Collections.sort(buffers, sorter);
				position = buffers.indexOf(buffer);
			}
			else
			{
				int oldPos = buffers.indexOf(buffer);
				if (oldPos != -1)
				{
					if (position == -1)
					{
						return;
					}
					moveBuffer(oldPos, position);
					return;
				}
				int size = buffers.size();
				if (position == -1 || position > size)
				{
					position = size;
				}
				buffers.add(position, buffer);
			}
		}
		BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);
		Log.log(Log.DEBUG, this, hashCode() + "": Buffer added "" + buffer + "" at "" + position);
		for (BufferSetListener listener : listeners)
		{
			listener.bufferAdded(buffer, position);
		}

		
		if (untitledBuffer != null)
		{
			jEdit.getBufferSetManager().removeBuffer(this, untitledBuffer);
		}
	} 

	
	
	public Buffer getBuffer(int index)
	{
		return buffers.get(index);
	} 

	
	public Buffer getPreviousBuffer(int index)
	{
		if (buffers.isEmpty())
			return null;
		if (buffers.size() < 2)
			return buffers.get(0);
		if (index <= 0)
			return buffers.get(buffers.size() - 1);
		return buffers.get(index - 1);
	} 

	
	public Buffer getNextBuffer(int index)
	{
		if (buffers.isEmpty())
			return null;
		if (buffers.size() < 2)
			return buffers.get(buffers.size()-1);
		if (index >= buffers.size() - 1)
			return buffers.get(0);
		return buffers.get(index + 1);
	} 

	
	public int indexOf(Buffer buffer)
	{
		return buffers.indexOf(buffer);
	} 

	
	public int size()
	{
		return buffers.size();
	} 

	
	public void getAllBuffers(BufferSetListener listener)
	{
		synchronized (buffers)
		{
			for (int i = 0;i<buffers.size();i++)
			{
				Buffer buffer = buffers.get(i);
				Log.log(Log.DEBUG, this, hashCode() + "": Buffer added "" + buffer + "" at "" + i);
				listener.bufferAdded(buffer, i);
			}
		}
	}


	
	public Buffer[] getAllBuffers()
	{
		Buffer[] buffers = new Buffer[this.buffers.size()];
		return this.buffers.toArray(buffers);
	} 

	
	
	public void addBufferSetListener(BufferSetListener listener)
	{
		Log.log(Log.DEBUG, this, hashCode() + "": addBufferSetListener "" + listener);
		listeners.add(BufferSetListener.class, listener);
	} 

	
	
	public void removeBufferSetListener(BufferSetListener listener)
	{
		Log.log(Log.DEBUG, this, hashCode() + "": removeBufferSetListener "" + listener);
		listeners.remove(BufferSetListener.class, listener);
		if (!hasListeners())
		{
			
			Buffer[] buffers = getAllBuffers();
			BufferSetManager bufferSetManager = jEdit.getBufferSetManager();
			for (Buffer buffer : buffers)
			{
				bufferSetManager.removeBuffer(this, buffer);
			}
		}
	} 

	
	
	public boolean hasListeners()
	{
		return listeners.getListenerCount() != 0;
	} 

	
	@Override
	public String toString()
	{
		return ""BufferSet[nbBuffers=""+size()+']';
	} 

	

	
	void addBuffer(Buffer buffer)
	{
		addBufferAt(buffer,  -1);
	} 

	
	
	void handleMessage()
	{
		if (jEdit.getBooleanProperty(""sortBuffers""))
		{
			
			if (jEdit.getBooleanProperty(""sortByName""))
				sorter = nameSorter;
			else
				sorter = pathSorter;

			
			Collections.sort(buffers, sorter);

			
			BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);
			for (BufferSetListener listener : listeners)
			{
				listener.bufferSetSorted();
			}
		}
		else
		{
			
			sorter = null;
		}
	} 

	
	void moveBuffer(int oldPosition, int newPosition)
	{
		if (sorter != null)
		{
			
			return;
		}
		Buffer buffer;
		synchronized (buffers)
		{
			buffer = buffers.remove(oldPosition);
			int size = buffers.size();
			if (newPosition == -1 || newPosition > size)
			{
				newPosition = size;
			}
			buffers.add(newPosition, buffer);
		}
		BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);
		Log.log(Log.DEBUG, this, hashCode() + "": Buffer moved "" + buffer + "" from "" + oldPosition + "" to "" + newPosition);
		for (BufferSetListener listener : listeners)
		{
			listener.bufferMoved(buffer, oldPosition, newPosition);
		}
	} 

	
	void removeBuffer(Buffer buffer)
	{
		int index;
		synchronized (buffers)
		{
			index = buffers.indexOf(buffer);
			if (index == -1)
				return;

			buffers.remove(index);
		}
		BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);
		Log.log(Log.DEBUG, this, hashCode() + "": Buffer removed "" + buffer);
		for (BufferSetListener listener : listeners)
		{
			listener.bufferRemoved(buffer, index);
		}
	} 

	

	
	private final List<Buffer> buffers;
	private EventListenerList listeners;

	private static final Comparator<Buffer> nameSorter = new NameSorter();
	private static final Comparator<Buffer> pathSorter = new PathSorter();
	private Comparator<Buffer> sorter;
	


	
	private static class NameSorter implements Comparator<Buffer>
	{
		public int compare(Buffer o1, Buffer o2)
		{

			int ret = StandardUtilities.compareStrings(o1.getName(), o2.getName(), true);
			if (ret == 0)
			{
				ret = StandardUtilities.compareStrings(o1.getPath(), o2.getPath(), true);
			}
			return ret;
		}
	} 

	
	private static class PathSorter implements Comparator<Buffer>
	{
		public int compare(Buffer o1, Buffer o2)
		{
			return StandardUtilities.compareStrings(o1.getPath(), o2.getPath(), true);
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.options.GeneralOptionPane,6,6,0,4,36,1,1,4,1,0.8875,464,0.6875,0,0.992581602,0.5,3,5,73.66666667,7,2.1667,0,"

package org.gjt.sp.jedit.options;



import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.Log;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;




public class GeneralOptionPane extends AbstractOptionPane
{
	
	
	public static final int checkFileStatus_focus = 0;
	
	
	public static final int checkFileStatus_all = 1;
	
	public static final int checkFileStatus_operations = 2;
	
	public static final int checkFileStatus_focusBuffer = 3;
	
	public static final int checkFileStatus_none = 4;
	

	
	private JComboBox lineSeparator;
	private JComboBox checkModStatus;
	private JComboBox checkModStatusUpon;
	private JTextField recentFiles;
	private JTextField hypersearchResultsWarning;
	private JCheckBox saveCaret;
	private JCheckBox sortRecent;
	private JCheckBox persistentMarkers;
	private JCheckBox restore;
	private JCheckBox restoreRemote;
	private JCheckBox restoreCLI;
	

	
	public GeneralOptionPane()
	{
		super(""general"");
	} 

	
	@Override
	protected void _init()
	{

		
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = jEdit.getProperty(""buffer.""+ JEditBuffer.LINESEP,
			System.getProperty(""line.separator""));
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		addComponent(jEdit.getProperty(""options.general.lineSeparator""),
			lineSeparator);


		
		String[] modCheckOptions = {
			jEdit.getProperty(""options.general.checkModStatus.nothing""),
			jEdit.getProperty(""options.general.checkModStatus.prompt""),
			jEdit.getProperty(""options.general.checkModStatus.reload""),
			jEdit.getProperty(""options.general.checkModStatus.silentReload"")
		};
		checkModStatus = new JComboBox(modCheckOptions);
		if(jEdit.getBooleanProperty(""autoReload""))
		{
			if (jEdit.getBooleanProperty(""autoReloadDialog""))
				
				checkModStatus.setSelectedIndex(2);
			else	
				checkModStatus.setSelectedIndex(3);
		}
		else
		{
			if (jEdit.getBooleanProperty(""autoReloadDialog""))
				
				checkModStatus.setSelectedIndex(1);
			else	
				checkModStatus.setSelectedIndex(0);
		}
		addComponent(jEdit.getProperty(""options.general.checkModStatus""),
			checkModStatus);

		
		String[] modCheckUponOptions = {
			jEdit.getProperty(""options.general.checkModStatusUpon.focus""),
			jEdit.getProperty(""options.general.checkModStatusUpon.all""),
			jEdit.getProperty(""options.general.checkModStatusUpon.operations""),
			jEdit.getProperty(""options.general.checkModStatusUpon.focusBuffer""),
			jEdit.getProperty(""options.general.checkModStatusUpon.none"")
		};
		checkModStatusUpon = new JComboBox(modCheckUponOptions);
		checkModStatusUpon.setSelectedIndex(jEdit.getIntegerProperty(""checkFileStatus""));
		addComponent(jEdit.getProperty(""options.general.checkModStatusUpon""),
			checkModStatusUpon);

		
		recentFiles = new JTextField(jEdit.getProperty(
			""options.general.recentFiles""));
		recentFiles.setText(jEdit.getProperty(""recentFiles""));
		addComponent(jEdit.getProperty(""options.general.recentFiles""),
			recentFiles);

		
		sortRecent = new JCheckBox(jEdit.getProperty(
			""options.general.sortRecent""));
		sortRecent.setSelected(jEdit.getBooleanProperty(""sortRecent""));
		addComponent(sortRecent);

		
		saveCaret = new JCheckBox(jEdit.getProperty(
			""options.general.saveCaret""));
		saveCaret.setSelected(jEdit.getBooleanProperty(""saveCaret""));
		addComponent(saveCaret);

		
		persistentMarkers = new JCheckBox(jEdit.getProperty(
			""options.general.persistentMarkers""));
		persistentMarkers.setSelected(jEdit.getBooleanProperty(
			""persistentMarkers""));
		addComponent(persistentMarkers);

		
		restore = new JCheckBox(jEdit.getProperty(
			""options.general.restore""));

		restore.setSelected(jEdit.getBooleanProperty(""restore""));
		restore.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				restoreCLI.setEnabled(restore.isSelected());
				restoreRemote.setEnabled(restore.isSelected());
			}
		});

		addComponent(restore);

		restoreRemote = new JCheckBox(jEdit.getProperty(
			""options.general.restore.remote""));
		restoreRemote.setSelected(jEdit.getBooleanProperty(""restore.remote"", false));
		restoreRemote.setEnabled(restore.isSelected());
		addComponent(restoreRemote);

		restoreCLI = new JCheckBox(jEdit.getProperty(
			""options.general.restore.cli""));
		restoreCLI.setSelected(jEdit.getBooleanProperty(""restore.cli""));
		restoreCLI.setEnabled(restore.isSelected());
		addComponent(restoreCLI);

		
		hypersearchResultsWarning = new JTextField(jEdit.getProperty(""hypersearch.maxWarningResults""));
		addComponent(jEdit.getProperty(""options.general.hypersearch.maxWarningResults""),
			hypersearchResultsWarning);



	} 

	
	@Override
	protected void _save()
	{

		String lineSep = null;
		switch(lineSeparator.getSelectedIndex())
		{
		case 0:
			lineSep = ""\n"";
			break;
		case 1:
			lineSep = ""\r\n"";
			break;
		case 2:
			lineSep = ""\r"";
			break;
		}
		jEdit.setProperty(""buffer.""+ JEditBuffer.LINESEP,lineSep);
		switch(checkModStatus.getSelectedIndex())
		{
		case 0:
			jEdit.setBooleanProperty(""autoReloadDialog"",false);
			jEdit.setBooleanProperty(""autoReload"",false);
			break;
		case 1:
			jEdit.setBooleanProperty(""autoReloadDialog"",true);
			jEdit.setBooleanProperty(""autoReload"",false);
			break;
		case 2:
			jEdit.setBooleanProperty(""autoReloadDialog"",true);
			jEdit.setBooleanProperty(""autoReload"",true);
			break;
		case 3:
			jEdit.setBooleanProperty(""autoReloadDialog"",false);
			jEdit.setBooleanProperty(""autoReload"",true);
			break;
		}
		jEdit.setIntegerProperty(""checkFileStatus"",checkModStatusUpon.getSelectedIndex());
		jEdit.setProperty(""recentFiles"",recentFiles.getText());
		jEdit.setBooleanProperty(""sortRecent"",sortRecent.isSelected());
		jEdit.setBooleanProperty(""saveCaret"",saveCaret.isSelected());
		jEdit.setBooleanProperty(""persistentMarkers"",
			persistentMarkers.isSelected());
		jEdit.setBooleanProperty(""restore"",restore.isSelected());
		jEdit.setBooleanProperty(""restore.cli"",restoreCLI.isSelected());
		jEdit.setBooleanProperty(""restore.remote"", restoreRemote.isSelected());
		try
		{
			jEdit.setIntegerProperty(""hypersearch.maxWarningResults"", Integer.parseInt(hypersearchResultsWarning.getText()));
		}
		catch (NumberFormatException e)
		{
			Log.log(Log.WARNING, this, ""hypersearchResultsWarning: "" + hypersearchResultsWarning.getText() + "" is not a valid value for this option"");
		}
	} 


}
"
jEdit,4.3,org.gjt.sp.util.XMLUtilities,4,1,0,26,29,6,25,1,3,2.0,213,0.0,0,0.0,0.291666667,0,0,52.25,15,4.75,0,"

package org.gjt.sp.util;


import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;



public class XMLUtilities
{

	
	
	public static String charsToEntities(String str, boolean xml11)
	{
		StringBuilder buf = new StringBuilder(str.length());
		for(int i = 0; i < str.length(); i++)
		{
			char ch = str.charAt(i);

			
			
			if (((0x00 <= ch && ch <= 0x1F) || (0x7F <= ch && ch <= 0x9F))
				&& ch != '\r' && ch != '\n' && ch != '\t')
			{
				if (xml11 && ch != 0x00)
				{
					buf.append(""&#"").append((int)ch).append(';');
				}
				else
				{
					
					
					
					buf.append(""<?illegal-xml-character "")
						.append((int)ch)
						.append(""?>"");
				}
				continue;
			}

			switch(ch)
			{
			case '<':
				buf.append(""&lt;"");
				break;
			case '>':
				buf.append(""&gt;"");
				break;
			case '&':
				buf.append(""&amp;"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}
		return buf.toString();
	} 

	
	
	public static boolean parseXML(InputStream in, DefaultHandler handler)
		throws IOException
	{
		try
		{
			XMLReader parser = XMLReaderFactory.createXMLReader();
			InputSource isrc = new InputSource(
				new BufferedInputStream(in));
			isrc.setSystemId(""jedit.jar"");
			parser.setContentHandler(handler);
			parser.setDTDHandler(handler);
			parser.setEntityResolver(handler);
			parser.setErrorHandler(handler);
			parser.parse(isrc);
		}
		catch(SAXParseException se)
		{
			int line = se.getLineNumber();
			Log.log(Log.ERROR,XMLUtilities.class,
				""while parsing from "" + in + "": SAXParseException: line "" + line + "": "" , se);
			return true;
		}
		catch(SAXException e)
		{
			Log.log(Log.ERROR,XMLUtilities.class,e);
			return true;
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,XMLUtilities.class,io);
			}
		}
		return false;
	} 

	
	
	public static InputSource findEntity(String systemId, String test, Class where)
	{
		if (systemId != null && systemId.endsWith(test))
		{
			try
			{
				return new InputSource(new BufferedInputStream(
					where.getResourceAsStream(test)));
			}
			catch (Exception e)
			{
				Log.log(Log.ERROR,XMLUtilities.class,
					""Error while opening "" + test + ':');
				Log.log(Log.ERROR,XMLUtilities.class,e);
			}
		}

		return null;
	} 

	private XMLUtilities() { }
}

"
jEdit,4.3,org.gjt.sp.jedit.ActionContext,5,2,2,22,6,10,17,5,5,2.0,26,0.0,0,0.636363636,0.9,0,0,4.2,1,0.8,0,"

package org.gjt.sp.jedit;

import java.util.*;


public abstract class ActionContext extends JEditActionContext<EditAction, ActionSet>
{
	
	
	@Override
	public ActionSet getActionSetForAction(String action)
	{
		return super.getActionSetForAction(action);
	} 

	
	
	@Override
	public EditAction getAction(String name)
	{
		return super.getAction(name);
	} 
	
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ClassGenerator,5,1,1,14,13,10,4,10,5,1.0,34,1.0,1,0.0,0.292307692,0,0,5.6,1,0.8,0,"package org.gjt.sp.jedit.bsh;

import org.gjt.sp.jedit.bsh.Capabilities.Unavailable;
import java.lang.reflect.InvocationTargetException;

public abstract class ClassGenerator
{
	private static ClassGenerator cg;

	public static ClassGenerator getClassGenerator() 
		throws UtilEvalError
	{
		if ( cg == null ) 
		{
			try {
				Class clas = Class.forName( ""org.gjt.sp.jedit.bsh.ClassGeneratorImpl"" );
				cg = (ClassGenerator)clas.newInstance();
			} catch ( Exception e ) {
				throw new Unavailable(""ClassGenerator unavailable: ""+e);
			}
		}
	
		return cg;
	}

	
	public abstract Class generateClass( 
		String name, Modifiers modifiers, 
		Class [] interfaces, Class superClass, BSHBlock block, 
		boolean isInterface, CallStack callstack, Interpreter interpreter 
	)
		throws EvalError;

	
	public abstract Object invokeSuperclassMethod(
		BshClassManager bcm, Object instance, String methodName, Object [] args
	)
        throws UtilEvalError, ReflectError, InvocationTargetException;

	
	public abstract void setInstanceNameSpaceParent( 
		Object instance, String className, NameSpace parent );

}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.Gutter,51,4,0,22,125,1041,10,17,41,0.948333333,1243,0.833333333,6,0.92816092,0.100490196,3,20,22.66666667,30,2.1569,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;

import org.gjt.sp.jedit.buffer.BufferAdapter;
import org.gjt.sp.jedit.buffer.BufferListener;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.Log;



public class Gutter extends JComponent implements SwingConstants
{
	
	
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	

	
	
	public static final String FOLD_PAINTER_PROPERTY = ""foldPainter"";
	public static final String FOLD_PAINTER_SERVICE = ""org.gjt.sp.jedit.textarea.FoldPainter"";
	public static final String DEFAULT_FOLD_PAINTER_SERVICE = ""Triangle"";

	
	public void setFoldPainter(FoldPainter painter)
	{
		if (painter == null)
			foldPainter = new TriangleFoldPainter();
		else
			foldPainter = painter;
	}
	
	
	
	
	
	public Gutter(TextArea textArea)
	{
		this.textArea = textArea;
		enabled = true;
		selectionAreaEnabled = true;
		selectionAreaWidth = SELECTION_GUTTER_WIDTH;

		setAutoscrolls(true);
		setOpaque(true);
		setRequestFocusEnabled(false);

		extensionMgr = new ExtensionManager();

		mouseHandler = new MouseHandler();
		addMouseListener(mouseHandler);
		addMouseMotionListener(mouseHandler);

		bufferListener = new BufferAdapter()
		{
			public void bufferLoaded(JEditBuffer buffer)
			{
				updateLineNumberWidth();
			}

			public void contentInserted(JEditBuffer buffer, int startLine,
					int offset, int numLines, int length)
			{
				updateLineNumberWidth();
			}

			public void contentRemoved(JEditBuffer buffer, int startLine,
					int offset, int numLines, int length) 
			{
				updateLineNumberWidth();
			}
		};

		updateBorder();
		setFoldPainter(textArea.getFoldPainter());
	} 

	
	public void paintComponent(Graphics _gfx)
	{
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setRenderingHints(textArea.getPainter().renderingHints);
		
		Rectangle clip = gfx.getClipBounds();
		gfx.setColor(getBackground());
		int bgColorWidth = isSelectionAreaEnabled() ? FOLD_MARKER_SIZE :
			clip.width; 
		gfx.fillRect(clip.x, clip.y, bgColorWidth, clip.height);
		if (isSelectionAreaEnabled())
		{
			if (selectionAreaBgColor == null)
				selectionAreaBgColor = getBackground();
			gfx.setColor(selectionAreaBgColor);
			gfx.fillRect(clip.x + FOLD_MARKER_SIZE, clip.y,
				clip.width - FOLD_MARKER_SIZE, clip.height);
		}
		
		if (textArea.getBuffer().isLoading())
			return;

		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();

		if(lineHeight == 0)
			return;

		int firstLine = clip.y / lineHeight;
		int lastLine = (clip.y + clip.height - 1) / lineHeight;

		if(lastLine - firstLine > textArea.getVisibleLines())
		{
			Log.log(Log.ERROR,this,""BUG: firstLine="" + firstLine);
			Log.log(Log.ERROR,this,""     lastLine="" + lastLine);
			Log.log(Log.ERROR,this,""     visibleLines="" + textArea.getVisibleLines());
			Log.log(Log.ERROR,this,""     height="" + getHeight());
			Log.log(Log.ERROR,this,""     painter.height="" + textArea.getPainter().getHeight());
			Log.log(Log.ERROR,this,""     clip.y="" + clip.y);
			Log.log(Log.ERROR,this,""     clip.height="" + clip.height);
			Log.log(Log.ERROR,this,""     lineHeight="" + lineHeight);
		}
	
		int y = clip.y - clip.y % lineHeight;

		extensionMgr.paintScreenLineRange(textArea,gfx,
			firstLine,lastLine,y,lineHeight);

		for (int line = firstLine; line <= lastLine;
			line++, y += lineHeight)
		{
			paintLine(gfx,line,y);
		}
	} 

	
	
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} 

	
	
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} 

	
	
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} 

	
	
	public TextAreaExtension[] getExtensions()
	{
		return extensionMgr.getExtensions();
	} 

	
	
	public String getToolTipText(MouseEvent evt)
	{
		if(textArea.getBuffer().isLoading())
			return null;

		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} 

	
	
	public void setBorder(int width, Color color1, Color color2, Color color3)
	{
		borderWidth = width;

		focusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color1));
		noFocusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color2));
		updateBorder();
	} 

	
	
	public void updateBorder()
	{
		if (textArea.hasFocus())
			setBorder(focusBorder);
		else
			setBorder(noFocusBorder);
	} 

	
	
	public void setBorder(Border border)
	{
		super.setBorder(border);

		if (border == null)
		{
			collapsedSize.width = 0;
			collapsedSize.height = 0;
		}
		else
		{
			Insets insets = border.getBorderInsets(this);
			collapsedSize.width = FOLD_MARKER_SIZE + insets.right;
			if (isSelectionAreaEnabled())
				 collapsedSize.width += selectionAreaWidth;
			collapsedSize.height = gutterSize.height
				= insets.top + insets.bottom;
			lineNumberWidth = fm.charWidth('5') * getLineNumberDigitCount(); 
			gutterSize.width = FOLD_MARKER_SIZE + insets.right
				+ lineNumberWidth;
		}

		revalidate();
	} 

	
	public void setMinLineNumberDigitCount(int min)
	{
		if (min == minLineNumberDigits)
			return;
		minLineNumberDigits = min;
		if (textArea.getBuffer() != null)
			updateLineNumberWidth();
	} 

	
	private int getMinLineNumberDigitCount()
	{
		return minLineNumberDigits;
	} 

	
	private int getLineNumberDigitCount()
	{
		JEditBuffer buf = textArea.getBuffer();
		int minDigits = getMinLineNumberDigitCount();
		if (buf == null)
			return minDigits;
		int count = buf.getLineCount();
		int digits;
		for (digits = 0; count > 0; digits++)
			count /= 10;
		return (digits < minDigits) ? minDigits : digits;
	} 

	
	void setBuffer(JEditBuffer newBuffer)
	{
		if (buffer != null)
			buffer.removeBufferListener(bufferListener);
		buffer = newBuffer;
		if (buffer != null)
			buffer.addBufferListener(bufferListener);
		updateLineNumberWidth();
	} 

	
	private void updateLineNumberWidth()
	{
		Font f = getFont();
		if (f != null)
			setFont(getFont());
	} 

	
	void dispose()
	{
		if (buffer != null)
		{
			buffer.removeBufferListener(bufferListener);
			buffer = null;
		}
	} 

	
	
	public void setFont(Font font)
	{
		super.setFont(font);

		fm = getFontMetrics(font);

		Border border = getBorder();
		if(border != null)
		{
			lineNumberWidth = fm.charWidth('5') * getLineNumberDigitCount(); 
			gutterSize.width = FOLD_MARKER_SIZE
				+ border.getBorderInsets(this).right
				+ lineNumberWidth;
			revalidate();
		}
	} 

	

	
	
	public void setGutterEnabled(boolean enabled)
	{
		this.enabled = enabled;
		revalidate();
	} 

	
	public boolean isSelectionAreaEnabled()
	{
		return selectionAreaEnabled;
	} 

	
	public void setSelectionAreaEnabled(boolean enabled)
	{
		if (isSelectionAreaEnabled() == enabled)
			return;
		selectionAreaEnabled = enabled;
		if (enabled)
			collapsedSize.width += selectionAreaWidth;
		else
			collapsedSize.width -= selectionAreaWidth;
		revalidate();
	} 

	
	public void setSelectionAreaBackground(Color bgColor)
	{
		selectionAreaBgColor = bgColor;
		repaint();
	} 

	
	public void setSelectionAreaWidth(int width)
	{
		selectionAreaWidth = width;
		revalidate();
	} 

	
	
	public Color getHighlightedForeground()
	{
		return intervalHighlight;
	} 

	
	public void setHighlightedForeground(Color highlight)
	{
		intervalHighlight = highlight;
	} 

	
	public Color getCurrentLineForeground()
 	{
		return currentLineHighlight;
	} 

	
	public void setCurrentLineForeground(Color highlight)
	{
		currentLineHighlight = highlight;
 	} 

	
	public Color getFoldColor()
 	{
		return foldColor;
	} 

	
	public void setFoldColor(Color foldColor)
	{
		this.foldColor = foldColor;
 	} 

	
	
	public Dimension getPreferredSize()
	{
		if (! enabled)
			return disabledSize;
		if (expanded)
			return gutterSize;
		else
			return collapsedSize;
	} 

	
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} 

	
	
	public int getLineNumberAlignment()
	{
		return alignment;
	} 

	
	
	public void setLineNumberAlignment(int alignment)
	{
		if (this.alignment == alignment) return;

		this.alignment = alignment;

		repaint();
	} 

	
	
	public boolean isExpanded()
	{
		return expanded;
	} 

	
	
	public void setExpanded(boolean expanded)
	{
		if (this.expanded == expanded) return;

		this.expanded = expanded;

		textArea.revalidate();
	} 

	
	
	public void toggleExpanded()
	{
		setExpanded(!expanded);
	} 

	
	
	public int getHighlightInterval()
	{
		return interval;
	} 

	
	
	public void setHighlightInterval(int interval)
	{
		if (interval <= 1) interval = 0;
		this.interval = interval;
		repaint();
	} 

	
	public boolean isCurrentLineHighlightEnabled()
	{
		return currentLineHighlightEnabled;
	} 

	
	public void setCurrentLineHighlightEnabled(boolean enabled)
	{
		if (currentLineHighlightEnabled == enabled) return;

		currentLineHighlightEnabled = enabled;

		repaint();
	} 

	
	
	public final Color getStructureHighlightColor()
	{
		return structureHighlightColor;
	} 

	
	
	public final void setStructureHighlightColor(Color structureHighlightColor)
	{
		this.structureHighlightColor = structureHighlightColor;
		repaint();
	} 

	
	
	public final boolean isStructureHighlightEnabled()
	{
		return structureHighlight;
	} 

	
	
	public final void setStructureHighlightEnabled(boolean structureHighlight)
	{
		this.structureHighlight = structureHighlight;
		repaint();
	} 

	public void setSelectionPopupHandler(GutterPopupHandler handler)
	{
		mouseHandler.selectionPopupHandler = handler;
	}

	public void setMouseActionsProvider(MouseActionsProvider mouseActionsProvider)
	{
		mouseHandler.mouseActions = mouseActionsProvider;
	}
	

	

	
	private static final int FOLD_MARKER_SIZE = 12;
	private static final int SELECTION_GUTTER_WIDTH = 12;
		

	private boolean enabled;
	private final TextArea textArea;
	private MouseHandler mouseHandler;
	private ExtensionManager extensionMgr;

	private Dimension gutterSize = new Dimension(0,0);
	private Dimension collapsedSize = new Dimension(0,0);
	private int lineNumberWidth;
	private Dimension disabledSize = new Dimension(0,0);

	private Color intervalHighlight;
	private Color currentLineHighlight;
	private Color foldColor;
	private Color selectionAreaBgColor;

	private FontMetrics fm;

	private int alignment;

	private int interval;
	private boolean currentLineHighlightEnabled;
	private boolean expanded;
	private boolean selectionAreaEnabled;

	private boolean structureHighlight;
	private Color structureHighlightColor;

	private int borderWidth;
	private Border focusBorder, noFocusBorder;
	
	private FoldPainter foldPainter;
	private JEditBuffer buffer;
	private BufferListener bufferListener;
	private int minLineNumberDigits;
	private int selectionAreaWidth;
	

	
	private void paintLine(Graphics2D gfx, int line, int y)
	{
		JEditBuffer buffer = textArea.getBuffer();
		if(buffer.isLoading())
			return;

		FontMetrics textAreaFm = textArea.getPainter().getFontMetrics();
		int lineHeight = textAreaFm.getHeight();
		int baseline = textAreaFm.getAscent();

		ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(line);
		int physicalLine = info.physicalLine;

		
		if(physicalLine == -1)
			return;

		boolean drawFoldMiddle = true;
		
		if(info.firstSubregion && buffer.isFoldStart(physicalLine))
		{
			drawFoldMiddle = false;
			foldPainter.paintFoldStart(this, gfx, line, physicalLine,
					textArea.displayManager.isLineVisible(physicalLine+1),
					y, lineHeight, buffer);
		}
		else if(info.lastSubregion && buffer.isFoldEnd(physicalLine))
		{
			drawFoldMiddle = false;
			foldPainter.paintFoldEnd(this, gfx, line, physicalLine, y,
					lineHeight, buffer);
		} 
		
		else if(structureHighlight)
		{
			StructureMatcher.Match match = textArea.getStructureMatch();
			int caretLine = textArea.getCaretLine();

			if(textArea.isStructureHighlightVisible()
				&& physicalLine >= Math.min(caretLine,match.startLine)
				&& physicalLine <= Math.max(caretLine,match.startLine))
			{
				int caretScreenLine;
				if(caretLine > textArea.getLastPhysicalLine())
					caretScreenLine = Integer.MAX_VALUE;
				else if(textArea.displayManager.isLineVisible(
						textArea.getCaretLine()))
				{
					caretScreenLine = textArea
						.getScreenLineOfOffset(
						textArea.getCaretPosition());
				}
				else
				{
					caretScreenLine = -1;
				}

				int structScreenLine;
				if(match.startLine > textArea.getLastPhysicalLine())
					structScreenLine = Integer.MAX_VALUE;
				else if(textArea.displayManager.isLineVisible(
						match.startLine))
				{
					structScreenLine = textArea
						.getScreenLineOfOffset(
						match.start);
				}
				else
				{
					structScreenLine = -1;
				}

				if(caretScreenLine > structScreenLine)
				{
					int tmp = caretScreenLine;
					caretScreenLine = structScreenLine;
					structScreenLine = tmp;
				}

				gfx.setColor(structureHighlightColor);
				drawFoldMiddle = false;
				if(structScreenLine == caretScreenLine)
				{
					
					drawFoldMiddle = true;
				}
				
				else if(line == caretScreenLine)
				{
					gfx.fillRect(5,
						y
						+ lineHeight / 2,
						5,
						2);
					gfx.fillRect(5,
						y
						+ lineHeight / 2,
						2,
						lineHeight - lineHeight / 2);
				}
				
				else if(line == structScreenLine)
				{
					gfx.fillRect(5,
						y,
						2,
						lineHeight / 2);
					gfx.fillRect(5,
						y + lineHeight / 2,
						5,
						2);
				}
				
				else if(line > caretScreenLine
					&& line < structScreenLine)
				{
					gfx.fillRect(5,
						y,
						2,
						lineHeight);
				}
			}
		} 
		if(drawFoldMiddle && buffer.getFoldLevel(physicalLine) > 0)
		{
			foldPainter.paintFoldMiddle(this, gfx, line, physicalLine,
					y, lineHeight, buffer);
		}

		
		if(info.firstSubregion && expanded)
		{
			String number = Integer.toString(physicalLine + 1);

			int offset;
			switch (alignment)
			{
			case RIGHT:
				offset = lineNumberWidth - (fm.stringWidth(number) + 1);
				break;
			case CENTER:
				offset = (lineNumberWidth - fm.stringWidth(number)) / 2;
				break;
			case LEFT: default:
				offset = 0;
				break;
			}

			if (physicalLine == textArea.getCaretLine() && currentLineHighlightEnabled)
			{
				gfx.setColor(currentLineHighlight);
			}
			else if (interval > 1 && (physicalLine + 1) % interval == 0)
				gfx.setColor(intervalHighlight);
			else
				gfx.setColor(getForeground());

			gfx.drawString(number, FOLD_MARKER_SIZE + offset,
				baseline + y);
		} 
	} 

	

	
	class MouseHandler extends MouseInputAdapter
	{
		MouseActionsProvider mouseActions;
		boolean drag;
		int toolTipInitialDelay, toolTipReshowDelay;
		boolean selectLines;
		int selAnchorLine;
		GutterPopupHandler selectionPopupHandler;

		
		public void mouseEntered(MouseEvent e)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			toolTipInitialDelay = ttm.getInitialDelay();
			toolTipReshowDelay = ttm.getReshowDelay();
			ttm.setInitialDelay(0);
			ttm.setReshowDelay(0);
		} 

		
		public void mouseExited(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			ttm.setInitialDelay(toolTipInitialDelay);
			ttm.setReshowDelay(toolTipReshowDelay);
		} 

		
		public void mousePressed(MouseEvent e)
		{
			textArea.requestFocus();

			boolean outsideGutter =
				(e.getX() >= getWidth() - borderWidth * 2);
			if(TextAreaMouseHandler.isPopupTrigger(e) || outsideGutter)
			{
				if ((selectionPopupHandler != null) &&
					(! outsideGutter) &&
					(e.getX() > FOLD_MARKER_SIZE))
				{
					int screenLine = e.getY() / textArea.getPainter()
						.getFontMetrics().getHeight();
					int line = textArea.chunkCache.getLineInfo(screenLine)
						.physicalLine;
					if (line >= 0)
					{
						selectionPopupHandler.handlePopup(
							e.getX(), e.getY(), line);
						return;
					}
				}
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mousePressed(e);
				drag = true;
			}
			else
			{
				JEditBuffer buffer = textArea.getBuffer();

				int screenLine = e.getY() / textArea.getPainter()
					.getFontMetrics().getHeight();

				int line = textArea.chunkCache.getLineInfo(screenLine)
					.physicalLine;

				if(line == -1)
					return;

				if (e.getX() >= FOLD_MARKER_SIZE)
				{
					Selection s = new Selection.Range(
						textArea.getLineStartOffset(line),
						getFoldEndOffset(line));
					if(textArea.isMultipleSelectionEnabled())
						textArea.addToSelection(s);
					else
						textArea.setSelection(s);
					selectLines = true;
					selAnchorLine = line;
					return;
				}

				
				String defaultAction;
				String variant;
				if(buffer.isFoldStart(line))
				{
					defaultAction = ""toggle-fold"";
					variant = ""fold"";
				}
				else if(structureHighlight
					&& textArea.isStructureHighlightVisible()
					&& textArea.lineInStructureScope(line))
				{
					defaultAction = ""match-struct"";
					variant = ""struct"";
				}
				else
					return;

				String action = null;

				if (mouseActions != null)
					action = mouseActions.getActionForEvent(
						e,variant);

				if(action == null)
					action = defaultAction;
				

				
				StructureMatcher.Match match = textArea
					.getStructureMatch();

				if(action.equals(""select-fold""))
				{
					textArea.displayManager.expandFold(line,true);
					textArea.selectFold(line);
				}
				else if(action.equals(""narrow-fold""))
				{
					int[] lines = buffer.getFoldAtLine(line);
					textArea.displayManager.narrow(lines[0],lines[1]);
				}
				else if(action.startsWith(""toggle-fold""))
				{
					if(textArea.displayManager
						.isLineVisible(line + 1))
					{
						textArea.collapseFold(line);
					}
					else
					{
						if(action.endsWith(""-fully""))
						{
							textArea.displayManager
								.expandFold(line,
								true);
						}
						else
						{
							textArea.displayManager
								.expandFold(line,
								false);
						}
					}
				}
				else if(action.equals(""match-struct""))
				{
					if(match != null)
						textArea.setCaretPosition(match.end);
				}
				else if(action.equals(""select-struct""))
				{
					if(match != null)
					{
						match.matcher.selectMatch(
							textArea);
					}
				}
				else if(action.equals(""narrow-struct""))
				{
					if(match != null)
					{
						int start = Math.min(
							match.startLine,
							textArea.getCaretLine());
						int end = Math.max(
							match.endLine,
							textArea.getCaretLine());
						textArea.displayManager.narrow(start,end);
					}
				} 
			}
		} 

		
		public void mouseDragged(MouseEvent e)
		{
			if(drag )
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseDragged(e);
			}
			else if(selectLines)
			{
				int screenLine = e.getY() / textArea.getPainter()
					.getFontMetrics().getHeight();
				int line;
				if(e.getY() < 0)
				{
					textArea.scrollUpLine();
					line = textArea.getFirstPhysicalLine();
				}
				else if(e.getY() >= getHeight())
				{
					textArea.scrollDownLine();
					line = textArea.getLastPhysicalLine();
				}
				else
					line = textArea.chunkCache.getLineInfo(screenLine)
						.physicalLine;

				int selStart, selEnd;
				if(line < selAnchorLine)
				{
					selStart = textArea.getLineStartOffset(line);
					selEnd = getFoldEndOffset(selAnchorLine);
				}
				else
				{
					selStart = textArea.getLineStartOffset(selAnchorLine);
					selEnd = getFoldEndOffset(line);
				}

				textArea.resizeSelection(selStart, selEnd, 0, false);
			}
		} 

		
		private int getFoldEndOffset(int line)
		{
			JEditBuffer buffer = textArea.getBuffer();
			int endLine;
			if ((line == buffer.getLineCount() - 1) ||
				(textArea.displayManager.isLineVisible(line + 1)))
			{
				endLine = line;
			}
			else
			{
				int[] lines = buffer.getFoldAtLine(line);
				endLine = lines[1];
			}

			if(endLine == buffer.getLineCount() - 1)
				return buffer.getLineEndOffset(endLine) - 1;
			else
				return buffer.getLineEndOffset(endLine);
		} 

		
		public void mouseReleased(MouseEvent e)
		{
			if(drag && e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseReleased(e);
			}

			drag = false;
			selectLines = false;
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHArguments,2,2,0,11,11,1,5,6,1,2.0,53,0.0,0,0.944444444,0.625,0,0,25.5,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

class BSHArguments extends SimpleNode
{
    BSHArguments(int id) { super(id); }

	
	
    public Object[] getArguments( CallStack callstack, Interpreter interpreter)
		throws EvalError
    {
        
        Object[] args = new Object[jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
		{
            args[i] = ((SimpleNode)jjtGetChild(i)).eval(callstack, interpreter);
			if ( args[i] == Primitive.VOID )
				throw new EvalError( ""Undefined argument: "" + 
					((SimpleNode)jjtGetChild(i)).getText(), this, callstack );
		}

        return args;
    }
}

"
jEdit,4.3,org.gjt.sp.jedit.Buffer,89,2,0,141,269,3550,119,43,66,0.961229947,2699,0.588235294,2,0.570731707,0.103620474,1,10,28.94382022,35,3.2135,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.bufferio.BufferAutosaveRequest;
import org.gjt.sp.jedit.bufferio.BufferIORequest;
import org.gjt.sp.jedit.bufferio.MarkersSaveRequest;
import org.gjt.sp.jedit.bufferset.BufferSet;
import org.gjt.sp.jedit.gui.StyleEditor;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSFile;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.visitors.JEditVisitorAdapter;
import org.gjt.sp.jedit.visitors.SaveCaretInfoVisitor;
import org.gjt.sp.jedit.options.GeneralOptionPane;

import javax.swing.*;
import javax.swing.text.AttributeSet;
import javax.swing.text.Segment;
import java.io.File;
import java.io.IOException;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Vector;
import java.util.Map;



public class Buffer extends JEditBuffer
{
	
	
	public static final String BACKED_UP = ""Buffer__backedUp"";

	
	public static final String CARET = ""Buffer__caret"";
	public static final String CARET_POSITIONED = ""Buffer__caretPositioned"";

	
	public static final String SELECTION = ""Buffer__selection"";

	
	public static final String SCROLL_VERT = ""Buffer__scrollVert"";
	public static final String SCROLL_HORIZ = ""Buffer__scrollHoriz"";

	
	public static final String ENCODING_AUTODETECT = ""encodingAutodetect"";

	
	public static final String TRAILING_EOL = ""trailingEOL"";

	
	public static final String GZIPPED = ""gzipped"";
	

	

	
	
	public void reload(View view)
	{
		if (getFlag(UNTITLED))
			return;
		if(isDirty())
		{
			String[] args = { path };
			int result = GUIUtilities.confirm(view,""changedreload"",
				args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		view.visit(new SaveCaretInfoVisitor());
		load(view,true);
	} 

	
	
	public boolean load(final View view, final boolean reload)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		setLoading(true);

		
		
		
		if(!getFlag(TEMPORARY))
			EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));

		final boolean loadAutosave;

		if(reload || !getFlag(NEW_FILE))
		{
			if(file != null)
				modTime = file.lastModified();

			
			if(!reload && autosaveFile != null && autosaveFile.exists())
				loadAutosave = recoverAutosave(view);
			else
			{
				if(autosaveFile != null)
					autosaveFile.delete();
				loadAutosave = false;
			}

			if(!loadAutosave)
			{
				VFS vfs = VFSManager.getVFSForPath(path);

				if(!checkFileForLoad(view,vfs,path))
				{
					setLoading(false);
					return false;
				}

				
				
				if(reload || !getFlag(NEW_FILE))
				{
					if(!vfs.load(view,this,path))
					{
						setLoading(false);
						return false;
					}
				}
			}
		}
		else
			loadAutosave = false;

		
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				String newPath = getStringProperty(
					BufferIORequest.NEW_PATH);
				Segment seg = (Segment)getProperty(
					BufferIORequest.LOAD_DATA);
				IntegerArray endOffsets = (IntegerArray)
					getProperty(BufferIORequest.END_OFFSETS);

				loadText(seg,endOffsets);

				unsetProperty(BufferIORequest.LOAD_DATA);
				unsetProperty(BufferIORequest.END_OFFSETS);
				unsetProperty(BufferIORequest.NEW_PATH);

				undoMgr.clear();
				undoMgr.setLimit(jEdit.getIntegerProperty(
					""buffer.undoCount"",100));

				if(!getFlag(TEMPORARY))
					finishLoading();

				setLoading(false);

				
				if(reload)
					setDirty(false);

				if(!loadAutosave && newPath != null)
					setPath(newPath);

				
				

				
				
				
				
				
				
				if(loadAutosave)
					Buffer.super.setDirty(true);

				
				if(!getFlag(TEMPORARY))
				{
					fireBufferLoaded();
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.LOADED));
					
					
				}
			}
		}; 

		if(getFlag(TEMPORARY))
			runnable.run();
		else
			VFSManager.runInAWTThread(runnable);

		return true;
	} 

	
	
	public boolean insertFile(View view, String path)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		path = MiscUtilities.constructPath(this.path,path);

		Buffer buffer = jEdit.getBuffer(path);
		if(buffer != null)
		{
			view.getTextArea().setSelectedText(
				buffer.getText(0,buffer.getLength()));
			return true;
		}

		VFS vfs = VFSManager.getVFSForPath(path);

		
		
		
		return vfs.insert(view,this,path);
	} 

	
	
	public void autosave()
	{
		if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)
			|| !isDirty() || isPerformingIO() ||
			!autosaveFile.getParentFile().exists())
			return;

		setFlag(AUTOSAVE_DIRTY,false);

		VFSManager.runInWorkThread(new BufferAutosaveRequest(
			null,this,null,VFSManager.getFileVFS(),
			autosaveFile.getPath()));
	} 

	
	
	public boolean saveAs(View view, boolean rename)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,path,
			VFSBrowser.SAVE_DIALOG,false);

		
		
		if(files == null)
			return false;

		return save(view,files[0],rename);
	} 

	
	
	public boolean save(View view, String path)
	{
		return save(view,path,true,false);
	} 

	
	
	public boolean save(View view, String path, boolean rename)
	{
		return save(view,path,rename,false);
	} 

	
	
	public boolean save(final View view, String path, final boolean rename, boolean disableFileStatusCheck)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		if(path == null && getFlag(NEW_FILE))
			return saveAs(view,rename);

		if(path == null && file != null)
		{
			long newModTime = file.lastModified();

			if(newModTime != modTime
				&& jEdit.getBooleanProperty(""view.checkModStatus""))
			{
				Object[] args = { this.path };
				int result = GUIUtilities.confirm(view,
					""filechanged-save"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				if(result != JOptionPane.YES_OPTION)
					return false;
			}
		}

		EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));

		setPerformingIO(true);

		final String oldPath = this.path;
		final String oldSymlinkPath = symlinkPath;
		final String newPath = path == null ? this.path : path;

		VFS vfs = VFSManager.getVFSForPath(newPath);

		if(!checkFileForSave(view,vfs,newPath))
		{
			setPerformingIO(false);
			return false;
		}

		Object session = vfs.createVFSSession(newPath,view);
		if (session == null)
		{
			setPerformingIO(false);
			return false;
		}

		unsetProperty(""overwriteReadonly"");
		unsetProperty(""forbidTwoStageSave"");
		try
		{
			VFSFile file = vfs._getFile(session,newPath,view);
			if (file != null)
			{
				boolean vfsRenameCap = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0;
				if (!file.isWriteable())
				{
					Log.log(Log.WARNING, this, ""Buffer saving : File "" + file + "" is readOnly"");
					if (vfsRenameCap)
					{
						Log.log(Log.DEBUG, this, ""Buffer saving : VFS can rename files"");
						String savePath = vfs._canonPath(session,newPath,view);
						if(!MiscUtilities.isURL(savePath))
							savePath = MiscUtilities.resolveSymlinks(savePath);
						savePath = vfs.getTwoStageSaveName(savePath);
						if (savePath == null)
						{
							Log.log(Log.DEBUG, this, ""Buffer saving : two stage save impossible because path is null"");
							VFSManager.error(view,
								newPath,
								""ioerror.save-readonly-twostagefail"",
								null);
							setPerformingIO(false);
							return false;
						}
						else
						{
							int result = GUIUtilities.confirm(
								view, ""vfs.overwrite-readonly"",
								new Object[]{newPath},
								JOptionPane.YES_NO_OPTION,
								JOptionPane.WARNING_MESSAGE);
							if (result == JOptionPane.YES_OPTION)
							{
								Log.log(Log.WARNING, this, ""Buffer saving : two stage save will be used to save buffer"");
								setBooleanProperty(""overwriteReadonly"",true);
							}
							else
							{
								Log.log(Log.DEBUG,this, ""Buffer not saved"");
								setPerformingIO(false);
								return false;
							}
						}
					}
					else
					{
						Log.log(Log.WARNING, this, ""Buffer saving : file is readonly and vfs cannot do two stage save"");
						VFSManager.error(view,
							newPath,
							""ioerror.write-error-readonly"",
							null);
						setPerformingIO(false);
						return false;
					}
				}
				else
				{
					String savePath = vfs._canonPath(session,newPath,view);
					if(!MiscUtilities.isURL(savePath))
						savePath = MiscUtilities.resolveSymlinks(savePath);
					savePath = vfs.getTwoStageSaveName(savePath);
					if (jEdit.getBooleanProperty(""twoStageSave"") && (!vfsRenameCap || savePath == null))
					{
						
						


						int result = GUIUtilities.confirm(
								view, ""vfs.twostageimpossible"",
								new Object[]{newPath},
								JOptionPane.YES_NO_OPTION,
								JOptionPane.WARNING_MESSAGE);
						if (result == JOptionPane.YES_OPTION)
						{
							Log.log(Log.WARNING, this, ""Buffer saving : two stage save cannot be used"");
							setBooleanProperty(""forbidTwoStageSave"",true);
						}
						else
						{
							Log.log(Log.DEBUG,this, ""Buffer not saved"");
							setPerformingIO(false);
							return false;
						}

					}
				}
			}
		}
		catch(IOException io)
		{
			VFSManager.error(view,newPath,""ioerror"",
				new String[] { io.toString() });
			setPerformingIO(false);
			return false;
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				VFSManager.error(view,newPath,""ioerror"",
					new String[] { io.toString() });
				setPerformingIO(false);
				return false;
			}
		}

		if(!vfs.save(view,this,newPath))
		{
			setPerformingIO(false);
			return false;
		}

		
		VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					setPerformingIO(false);
					setProperty(""overwriteReadonly"",null);
					finishSaving(view,oldPath,oldSymlinkPath,
						newPath,rename,getBooleanProperty(
							BufferIORequest.ERROR_OCCURRED));
					updateMarkersFile(view);
				}
			});

		int check = jEdit.getIntegerProperty(""checkFileStatus"");
		if(!disableFileStatusCheck && (check == GeneralOptionPane.checkFileStatus_all ||
					       check == GeneralOptionPane.checkFileStatus_operations))
			jEdit.checkBufferStatus(view,false);

		return true;
	} 

	
	public static final int FILE_NOT_CHANGED = 0;
	public static final int FILE_CHANGED = 1;
	public static final int FILE_DELETED = 2;
	
	public int checkFileStatus(View view)
	{
		
		
		
		
		if(!isPerformingIO() && file != null && !getFlag(NEW_FILE))
		{
			boolean newReadOnly = file.exists() && !file.canWrite();
			if(newReadOnly != isFileReadOnly())
			{
				setFileReadOnly(newReadOnly);
				EditBus.send(new BufferUpdate(this,null,
					BufferUpdate.DIRTY_CHANGED));
			}

			long oldModTime = modTime;
			long newModTime = file.lastModified();

			if(newModTime != oldModTime)
			{
				modTime = newModTime;

				if(!file.exists())
				{
					setFlag(NEW_FILE,true);
					setDirty(true);
					return FILE_DELETED;
				}
				else
				{
					return FILE_CHANGED;
				}
			}
		}

		return FILE_NOT_CHANGED;
	} 

	

	

	
	
	public long getLastModified()
	{
		return modTime;
	} 

	
	
	public void setLastModified(long modTime)
	{
		this.modTime = modTime;
	} 

	
	
	public boolean getAutoReload()
	{
		return getFlag(AUTORELOAD);
	} 

	
	
	public void setAutoReload(boolean value)
	{
		setFlag(AUTORELOAD, value);
	} 

	
	
	public boolean getAutoReloadDialog()
	{
		return getFlag(AUTORELOAD_DIALOG);
	} 

	
	
	public void setAutoReloadDialog(boolean value)
	{
		setFlag(AUTORELOAD_DIALOG, value);
	} 

	
	
	public VFS getVFS()
	{
		return VFSManager.getVFSForPath(path);
	} 

	
	
	public File getAutosaveFile()
	{
		return autosaveFile;
	} 

	
	
	public void removeAutosaveFile()
	{
		if (autosaveFile != null)
		{
			autosaveFile.delete();
			setFlag(AUTOSAVE_DIRTY,true);
		}
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public String getPath()
	{
		return path;
	} 

	
	
	public String getPath(Boolean shortVersion)
	{
		return shortVersion ? MiscUtilities.abbreviate(path) : getPath();
	} 


	
	
	public String getSymlinkPath()
	{
		return symlinkPath;
	} 

	
	
	public String getDirectory()
	{
		return directory;
	} 

	
	
	public boolean isClosed()
	{
		return getFlag(CLOSED);
	} 

	
	
	public boolean isLoaded()
	{
		return !isLoading();
	} 

	
	
	public boolean isNewFile()
	{
		return getFlag(NEW_FILE);
	} 

	
	
	public void setNewFile(boolean newFile)
	{
		setFlag(NEW_FILE,newFile);
		if(!newFile)
			setFlag(UNTITLED,false);
	} 

	
	
	public boolean isUntitled()
	{
		return getFlag(UNTITLED);
	} 

	
	
	@Override
	public void setDirty(boolean d)
	{
		boolean old_d = isDirty();
		if (isUntitled() && jEdit.getBooleanProperty(""suppressNotSavedConfirmUntitled""))
			d = false;
		if (d && getLength() == initialLength)
		{
			if (jEdit.getBooleanProperty(""useMD5forDirtyCalculation""))
				d = !Arrays.equals(calculateHash(), md5hash);
		}
		super.setDirty(d);
		boolean editable = isEditable();

		if(d)
		{
			if(editable)
				setFlag(AUTOSAVE_DIRTY,true);
		}
		else
		{
			setFlag(AUTOSAVE_DIRTY,false);

			if(autosaveFile != null)
				autosaveFile.delete();
		}

		if(d != old_d && editable)
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.DIRTY_CHANGED));
		}
	} 

	
	
	public boolean isTemporary()
	{
		return getFlag(TEMPORARY);
	} 

	
	
	public Icon getIcon()
	{
		if(isDirty())
			return GUIUtilities.loadIcon(""dirty.gif"");
		else if(isReadOnly())
			return GUIUtilities.loadIcon(""readonly.gif"");
		else if(getFlag(NEW_FILE))
			return GUIUtilities.loadIcon(""new.gif"");
		else
			return GUIUtilities.loadIcon(""normal.gif"");
	} 

	

	

	
	
	@Deprecated
	public void addBufferChangeListener(BufferChangeListener listener,
		int priority)
	{
		addBufferListener(new BufferChangeListener.Adapter(listener),priority);
	} 

	
	
	@Deprecated
	public void addBufferChangeListener(BufferChangeListener listener)
	{
		addBufferListener(new BufferChangeListener.Adapter(listener), NORMAL_PRIORITY);
	} 

	
	
	@Deprecated
	public void removeBufferChangeListener(BufferChangeListener listener)
	{
		BufferListener[] listeners = getBufferListeners();

		for(int i = 0; i < listeners.length; i++)
		{
			BufferListener l = listeners[i];
			if(l instanceof BufferChangeListener.Adapter)
			{
				if(((BufferChangeListener.Adapter)l).getDelegate() == listener)
				{
					removeBufferListener(l);
					return;
				}
			}
		}
	} 

	

	

	
	
	@Override
	public void propertiesChanged()
	{
		super.propertiesChanged();
		setAutoReloadDialog(jEdit.getBooleanProperty(""autoReloadDialog""));
		setAutoReload(jEdit.getBooleanProperty(""autoReload""));
		if (!isTemporary())
			EditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));
	} 

	
	@Override
	public Object getDefaultProperty(String name)
	{
		Object retVal;

		if(mode != null)
		{
			retVal = mode.getProperty(name);
			if(retVal == null)
				return null;

			setDefaultProperty(name,retVal);
			return retVal;
		}
		
		String value = jEdit.getProperty(""buffer."" + name);
		if(value == null)
			return null;

		
		try
		{
			retVal = new Integer(value);
		}
		catch(NumberFormatException nf)
		{
			retVal = value;
		}

		return retVal;
	} 

	
	
	public void toggleWordWrap(View view)
	{
		String wrap = getStringProperty(""wrap"");
		if(wrap.equals(""none""))
			wrap = ""soft"";
		else if(wrap.equals(""soft""))
			wrap = ""hard"";
		else if(wrap.equals(""hard""))
			wrap = ""none"";
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.wrap-changed"",new String[] {
			wrap }));
		setProperty(""wrap"",wrap);
		propertiesChanged();
	} 

	
	
	public void toggleLineSeparator(View view)
	{
		String status = null;
		String lineSep = getStringProperty(LINESEP);
		if(""\n"".equals(lineSep))
		{
			status = ""windows"";
			lineSep = ""\r\n"";
		}
		else if(""\r\n"".equals(lineSep))
		{
			status = ""mac"";
			lineSep = ""\r"";
		}
		else if(""\r"".equals(lineSep))
		{
			status = ""unix"";
			lineSep = ""\n"";
		}
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.linesep-changed"",new String[] {
			jEdit.getProperty(""lineSep."" + status) }));
		setProperty(LINESEP, lineSep);
		setDirty(true);
		propertiesChanged();
	} 

	
	
	@Override
	public String getContextSensitiveProperty(int offset, String name)
	{
		Object value = super.getContextSensitiveProperty(offset,name);

		if(value == null)
		{
			ParserRuleSet rules = getRuleSetAtOffset(offset);

			value = jEdit.getMode(rules.getModeName())
				.getProperty(name);

			if(value == null)
				value = mode.getProperty(name);
		}

		if(value == null)
			return null;
		else
			return String.valueOf(value);
	} 

	

	

	
	
	public void setMode()
	{
		String userMode = getStringProperty(""mode"");
		if(userMode != null)
		{
			unsetProperty(""mode"");
			Mode m = ModeProvider.instance.getMode(userMode);
			if(m != null)
			{
				setMode(m);
				return;
			}
		}

		String firstLine = getLineText(0);

		Mode mode = ModeProvider.instance.getModeForFile(name, firstLine);
		if (mode != null)
		{
			setMode(mode);
			return;
		}

		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");

		if (defaultMode != null)
			setMode(defaultMode);
	} 

	

	

	
	
	@Deprecated
	public void putProperty(Object name, Object value)
	{
		
		if(!(name instanceof String))
			return;

		setProperty((String)name,value);
	} 

	
	
	@Deprecated
	public void putBooleanProperty(String name, boolean value)
	{
		setBooleanProperty(name,value);
	} 

	
	
	@Deprecated
	public static class TokenList extends DefaultTokenHandler
	{
		public Token getFirstToken()
		{
			return getTokens();
		}
	}

	
	@Deprecated
	public TokenList markTokens(int lineIndex)
	{
		TokenList list = new TokenList();
		markTokens(lineIndex,list);
		return list;
	} 

	
	
	@Deprecated
	public void insertString(int offset, String str, AttributeSet attr)
	{
		insert(offset,str);
	} 

	
	
	@Deprecated
	public File getFile()
	{
		return file;
	} 

	

	

	
	
	public Vector<Marker> getMarkers()
	{
		return markers;
	} 

	
	
	public String getMarkerStatusPrompt(String action)
	{
		return jEdit.getProperty(""view.status."" + action,
			new String[] { getMarkerNameString() });
	} 

	
	
	public String getMarkerNameString()
	{
		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = markers.get(i);
			if(marker.getShortcut() != '\0')
			{
				if(buf.length() != 0)
					buf.append(' ');
				buf.append(marker.getShortcut());
			}
		}

		if(buf.length() == 0)
			return jEdit.getProperty(""view.status.no-markers"");
		else
			return buf.toString();
	} 

	
	
	public void addOrRemoveMarker(char shortcut, int pos)
	{
		int line = getLineOfOffset(pos);
		if(getMarkerAtLine(line) != null)
			removeMarker(line);
		else
			addMarker(shortcut,pos);
	} 

	
	
	public void addMarker(char shortcut, int pos)
	{
		Marker markerN = new Marker(this,shortcut,pos);
		boolean added = false;

		
		if(isLoaded())
		{
			setFlag(MARKERS_CHANGED,true);

			markerN.createPosition();

			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = markers.get(i);
				if(shortcut != '\0' && marker.getShortcut() == shortcut)
					marker.setShortcut('\0');

				if(marker.getPosition() == pos)
				{
					markers.removeElementAt(i);
					i--;
				}
			}

			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = markers.get(i);
				if(marker.getPosition() > pos)
				{
					markers.insertElementAt(markerN,i);
					added = true;
					break;
				}
			}
		}

		if(!added)
			markers.addElement(markerN);

		if(isLoaded() && !getFlag(TEMPORARY))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} 

	
	
	public Marker getMarkerInRange(int start, int end)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = markers.get(i);
			int pos = marker.getPosition();
			if(pos >= start && pos < end)
				return marker;
		}

		return null;
	} 

	
	
	public Marker getMarkerAtLine(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = markers.get(i);
			if(getLineOfOffset(marker.getPosition()) == line)
				return marker;
		}

		return null;
	} 

	
	
	public void removeMarker(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = markers.get(i);
			if(getLineOfOffset(marker.getPosition()) == line)
			{
				setFlag(MARKERS_CHANGED,true);
				marker.removePosition();
				markers.removeElementAt(i);
				i--;
			}
		}

		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	} 

	
	
	public void removeAllMarkers()
	{
		setFlag(MARKERS_CHANGED,true);

		for(int i = 0; i < markers.size(); i++)
			markers.get(i).removePosition();

		markers.removeAllElements();

		if(isLoaded())
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} 

	
	
	public Marker getMarker(char shortcut)
	{
		for (Marker marker : markers)
		{
			if(marker.getShortcut() == shortcut)
				return marker;
		}
		return null;
	} 

	
	
	@Deprecated
	public String getMarkersPath(VFS vfs)
	{
		return getMarkersPath(vfs, path);
	} 

	
	
	public static String getMarkersPath(VFS vfs, String path)
	{
		return vfs.getParentOfPath(path)
			+ '.' + vfs.getFileName(path)
			+ "".marks"";
	} 

	
	
	public boolean updateMarkersFile(View view)
	{
		if(!markersChanged())
			return true;
		
		VFS vfs = VFSManager.getVFSForPath(getPath());
		if (((vfs.getCapabilities() & VFS.WRITE_CAP) == 0) ||
		    !vfs.isMarkersFileSupported())
		{
			VFSManager.error(view, path, ""vfs.not-supported.save"",
				new String[] { ""markers file"" });
			return false;
		}
		Object session = vfs.createVFSSession(path, view);
		if(session == null)
			return false;
		VFSManager.runInWorkThread(
			new MarkersSaveRequest(
				view, this, session, vfs, path));
		return true;
	} 

	
	
	public boolean markersChanged()
	{
		return getFlag(MARKERS_CHANGED);
	} 

	
	
	public void setMarkersChanged(boolean changed)
	{
		setFlag(MARKERS_CHANGED, changed);
	} 

	

	

	
	
	public void setWaitSocket(Socket waitSocket)
	{
		this.waitSocket = waitSocket;
	} 

	
	
	public Buffer getNext()
	{
		return next;
	} 

	
	
	public Buffer getPrev()
	{
		return prev;
	} 

	
	
	public int getIndex()
	{
		int count = 0;
		Buffer buffer = prev;
		while (true)
		{
			if(buffer == null)
				break;
			count++;
			buffer = buffer.prev;
		}
		return count;
	} 

	
	
	@Override
	public String toString()
	{
		return name + "" ("" + MiscUtilities.abbreviate(directory) + ')';
	} 

	
	
	public void addBufferUndoListener(BufferUndoListener listener)
	{
		undoListeners.add(listener);
	} 

	
	
	public void removeBufferUndoListener(BufferUndoListener listener)
	{
		undoListeners.remove(listener);
	} 

	

	
	
	Buffer prev;
	
	Buffer next;

	
	Buffer(String path, boolean newFile, boolean temp, Map props)
	{
		super(props);

		markers = new Vector<Marker>();

		setFlag(TEMPORARY,temp);

		
		setPath(path);

		
		setFlag(UNTITLED,newFile);
		setFlag(NEW_FILE,newFile);
		setFlag(AUTORELOAD,jEdit.getBooleanProperty(""autoReload""));
		setFlag(AUTORELOAD_DIALOG,jEdit.getBooleanProperty(""autoReloadDialog""));

		undoListeners = new Vector<BufferUndoListener>();
	} 

	
	void commitTemporary()
	{
		setFlag(TEMPORARY,false);

		finishLoading();
	} 

	
	void close()
	{
		setFlag(CLOSED,true);

		if(autosaveFile != null)
			autosaveFile.delete();

		
		if(waitSocket != null)
		{
			try
			{
				waitSocket.getOutputStream().write('\0');
				waitSocket.getOutputStream().flush();
				waitSocket.getInputStream().close();
				waitSocket.getOutputStream().close();
				waitSocket.close();
			}
			catch(IOException io)
			{
				
			}
		}
	} 

	

	

	
	protected void fireBeginUndo()
	{
		for (BufferUndoListener listener: undoListeners)
		{
			try
			{
				listener.beginUndo(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer undo event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireEndUndo()
	{
		for (BufferUndoListener listener: undoListeners)
		{
			try
			{
				listener.endUndo(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer undo event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireBeginRedo()
	{
		for (BufferUndoListener listener: undoListeners)
		{
			try
			{
				listener.beginRedo(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer begin redo event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 
	
	
	protected void fireEndRedo()
	{
		for (BufferUndoListener listener: undoListeners)
		{
			try
			{
				listener.endRedo(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer end redo event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 
	

	

	

	
	private void setFlag(int flag, boolean value)
	{
		if(value)
			flags |= 1 << flag;
		else
			flags &= ~(1 << flag);
	} 

	
	private boolean getFlag(int flag)
	{
		int mask = 1 << flag;
		return (flags & mask) == mask;
	} 

	
	private static final int CLOSED = 0;
	private static final int NEW_FILE = 3;
	private static final int UNTITLED = 4;
	private static final int AUTOSAVE_DIRTY = 5;
	private static final int AUTORELOAD = 6;
	private static final int AUTORELOAD_DIALOG = 7;
	private static final int TEMPORARY = 10;
	private static final int MARKERS_CHANGED = 12;
	

	private int flags;

	

	
	private String path;
	private String symlinkPath;
	private String name;
	private String directory;
	private File file;
	private File autosaveFile;
	private long modTime;
	private byte[] md5hash;
	private int initialLength;

	private final Vector<Marker> markers;

	private Socket waitSocket;
	private List<BufferUndoListener> undoListeners;
	

	
	private void setPath(final String path)
	{
		jEdit.visit(new JEditVisitorAdapter()
		{
			@Override
			public void visit(EditPane editPane)
			{
				editPane.bufferRenamed(Buffer.this.path, path);
			}
		});

		this.path = path;
		VFS vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
			setFileReadOnly(true);
		name = vfs.getFileName(path);
		directory = vfs.getParentOfPath(path);

		if(vfs instanceof FileVFS)
		{
			file = new File(path);
			symlinkPath = MiscUtilities.resolveSymlinks(path);

			
			
			if(autosaveFile != null)
				autosaveFile.delete();
			autosaveFile = new File(file.getParent(),'#' + name + '#');
		}
		else
		{
			
			
			file = null;
			autosaveFile = null;
			symlinkPath = path;
		}
	} 


	
	private boolean recoverAutosave(final View view)
	{
		if(!autosaveFile.canRead())
			return false;

		
		GUIUtilities.hideSplashScreen();

		final Object[] args = { autosaveFile.getPath() };
		int result = GUIUtilities.confirm(view,""autosave-found"",args,
			JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);

		if(result == JOptionPane.YES_OPTION)
		{
			VFSManager.getFileVFS().load(view,this,autosaveFile.getPath());

			
			
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					GUIUtilities.message(view,""autosave-loaded"",args);
				}
			});

			return true;
		}
		else
			return false;
	} 

	
	private boolean checkFileForLoad(View view, VFS vfs, String path)
	{
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
		{
			Object session = vfs.createVFSSession(path, view);
			if(session == null)
				return false;

			try
			{
				VFSFile file = vfs._getFile(session,path,view);
				if(file == null)
				{
					setNewFile(true);
					return true;
				}

				if(!file.isReadable())
				{
					VFSManager.error(view,path,""ioerror.no-read"",null);
					setNewFile(false);
					return false;
				}

				setFileReadOnly(!file.isWriteable());

				if(file.getType() != VFSFile.FILE)
				{
					VFSManager.error(view,path,
						""ioerror.open-directory"",null);
					setNewFile(false);
					return false;
				}
			}
			catch(IOException io)
			{
				VFSManager.error(view,path,""ioerror"",
					new String[] { io.toString() });
				return false;
			}
			finally
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					VFSManager.error(view,path,""ioerror"",
						new String[] { io.toString() });
					return false;
				}
			}
		}

		return true;
	} 

	
	private static boolean checkFileForSave(View view, VFS vfs, String path)
	{
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
		{
			Object session = vfs.createVFSSession(path,view);
			if(session == null)
				return false;

			try
			{
				VFSFile file = vfs._getFile(session,path,view);
				if(file == null)
					return true;

				if(file.getType() != VFSFile.FILE)
				{
					VFSManager.error(view,path,
						""ioerror.save-directory"",null);
					return false;
				}
			}
			catch(IOException io)
			{
				VFSManager.error(view,path,""ioerror"",
					new String[] { io.toString() });
				return false;
			}
			finally
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					VFSManager.error(view,path,""ioerror"",
						new String[] { io.toString() });
					return false;
				}
			}
		}

		return true;
	} 

	
	private byte[] calculateHash()
	{
		final byte[] dummy = new byte[1];
		if (!jEdit.getBooleanProperty(""useMD5forDirtyCalculation""))
			return dummy;
		ByteBuffer bb = null;
		readLock();
		try
		{
			
			int length = getLength();
			bb = ByteBuffer.allocate(length * 2);	
			CharBuffer cb = bb.asCharBuffer();
			cb.append( getSegment(0, length) );
		}
		finally
		{
			readUnlock();
		}
		try
		{
			MessageDigest digest = java.security.MessageDigest.getInstance(""MD5"");
			digest.update( bb );
			return digest.digest();
		}
		catch (NoSuchAlgorithmException nsae)
		{
			Log.log(Log.ERROR, this, ""Can't Calculate MD5 hash!"", nsae);
			return dummy;
		}

	}

	
	private void updateHash()
	{
		initialLength = getLength();
		md5hash = calculateHash();
	}

	
	private void finishLoading()
	{
		updateHash();

		parseBufferLocalProperties();
		
		
		FoldHandler oldFoldHandler = getFoldHandler();
		setMode();

		if(getFoldHandler() == oldFoldHandler)
		{
			
			
			
			invalidateFoldLevels();

			fireFoldHandlerChanged();
		}

		
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = markers.get(i);
			marker.removePosition();
			int pos = marker.getPosition();
			if(pos > getLength())
				marker.setPosition(getLength());
			else if(pos < 0)
				marker.setPosition(0);
			marker.createPosition();
		}
	} 

	
	private void finishSaving(View view, String oldPath,
		String oldSymlinkPath, String path,
		boolean rename, boolean error)
	{

		
		
		
		if(!error && !path.equals(oldPath))
		{
			Buffer buffer = jEdit.getBuffer(path);

			if(rename)
			{
				
				if(buffer != null && 
					!buffer.getPath().equals(oldPath))
				{
					buffer.setDirty(false);
					jEdit.closeBuffer(view,buffer);
				}

				setPath(path);
				final HashSet<BufferSet> bufferSets = new HashSet<BufferSet>();
				final HashSet<EditPane> editPanesCurrent = new HashSet<EditPane>();
				jEdit.visit(new JEditVisitorAdapter()
				{
					@Override
					public void visit(EditPane editPane)
					{
						BufferSet bufferSet = editPane.getBufferSet(); 
						if (bufferSet.indexOf(Buffer.this) != -1)
						{
							bufferSets.add(bufferSet);
							if (editPane.getBuffer() == Buffer.this)
								editPanesCurrent.add(editPane);
						}
					}
				});
				jEdit.getBufferSetManager().removeBuffer(this);
				for (BufferSet bufferSet: bufferSets)
					jEdit.getBufferSetManager().addBuffer(bufferSet, this);
				for (EditPane editPane: editPanesCurrent)
					editPane.setBuffer(this);
			}
			else
			{
				
				if(buffer != null && 
					!buffer.getPath().equals(oldPath))
				{
					buffer.load(view,true);
				}
			}
		} 

		
		if(rename)
		{
			if(file != null)
				modTime = file.lastModified();

			if(!error)
			{
				
				
				
				
				
				try
				{
					writeLock();

					if(autosaveFile != null)
						autosaveFile.delete();

					setFlag(AUTOSAVE_DIRTY,false);
					setFileReadOnly(false);
					setFlag(NEW_FILE,false);
					setFlag(UNTITLED,false);
					super.setDirty(false);
					if(jEdit.getBooleanProperty(""resetUndoOnSave""))
					{
						undoMgr.clear();
					}
				}
				finally
				{
					writeUnlock();
				}

				parseBufferLocalProperties();

				if(!getPath().equals(oldPath))
				{
					if (!isTemporary())
						jEdit.updatePosition(oldSymlinkPath,this);
					setMode();
				}
				else
				{
					
					String newMode = getStringProperty(""mode"");
					if(newMode != null &&
						!newMode.equals(getMode()
						.getName()))
						setMode();
					else
						propertiesChanged();
				}

				updateHash();

				if (!isTemporary())
				{
					EditBus.send(new BufferUpdate(this,
								      view,BufferUpdate.DIRTY_CHANGED));

					
					EditBus.send(new BufferUpdate(this,
								      view,BufferUpdate.SAVED));
				}
			}
		} 
	} 

	
	
	public void editSyntaxStyle(JEditTextArea textArea)
	{
		int lineNum = textArea.getCaretLine();
		int start = getLineStartOffset(lineNum);
		int position = textArea.getCaretPosition();

		DefaultTokenHandler tokenHandler = new DefaultTokenHandler();
		markTokens(lineNum,tokenHandler);
		Token token = tokenHandler.getTokens();

		while(token.id != Token.END)
		{
			int next = start + token.length;
			if (start <= position && next > position)
				break;
			start = next;
			token = token.next;
		}
		if (token.id == Token.END || token.id == Token.NULL)
		{
			JOptionPane.showMessageDialog(jEdit.getActiveView(),
				jEdit.getProperty(""syntax-style-no-token.message""),
				jEdit.getProperty(""syntax-style-no-token.title""),
				JOptionPane.PLAIN_MESSAGE);
			return;
		}
		String typeName = Token.tokenToString(token.id);
		String property = ""view.style."" + typeName.toLowerCase();
		SyntaxStyle currentStyle = GUIUtilities.parseStyle(
				jEdit.getProperty(property), ""Dialog"",12);
		SyntaxStyle style = new StyleEditor(jEdit.getActiveView(),
				currentStyle, typeName).getStyle();
		if(style != null)
		{
			jEdit.setProperty(property, GUIUtilities.getStyleString(style));
			jEdit.propertiesChanged();
		}
	} 
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHThrowStatement,2,2,0,7,7,1,1,6,1,2.0,32,0.0,0,0.944444444,0.625,1,1,15.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

class BSHThrowStatement extends SimpleNode
{
	BSHThrowStatement(int id) { super(id); }

	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);

		
		
		if(!(obj instanceof Exception))
			throw new EvalError(""Expression in 'throw' must be Exception type"",
				this, callstack );

		
		throw new TargetError( (Exception)obj, this, callstack );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.collection.CollectionIterator,4,1,0,2,15,0,1,1,3,0.333333333,54,1.0,0,0.0,0.75,0,0,12.25,4,1.5,0,"package org.gjt.sp.jedit.bsh.collection;

import java.util.Iterator;
import java.util.Collection;



public class CollectionIterator implements org.gjt.sp.jedit.bsh.BshIterator
{
    private Iterator iterator;

    
    public CollectionIterator(Object iterateOverMe) {
        iterator = createIterator(iterateOverMe);
    }

    
    protected Iterator createIterator(Object iterateOverMe)
    {
        if (iterateOverMe==null)
            throw new NullPointerException(""Object arguments passed to "" +
                ""the CollectionIterator constructor cannot be null."");

        if (iterateOverMe instanceof Iterator)
            return (Iterator)iterateOverMe;

        if (iterateOverMe instanceof Collection)
            return ((Collection)iterateOverMe).iterator();

        

        throw new IllegalArgumentException(
            ""Cannot enumerate object of type ""+iterateOverMe.getClass());
    }

    
    public Object next() {
        return iterator.next();
    }

    
    public boolean hasNext() {
        return iterator.hasNext();
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.FoldHandler,9,1,3,16,14,28,16,2,8,0.916666667,50,0.333333333,1,0.0,0.296296296,1,1,4.222222222,3,1.1111,0,"

package org.gjt.sp.jedit.buffer;

import java.util.List;

import javax.swing.text.Segment;


public abstract class FoldHandler
{
	
	@Deprecated
	public static final String SERVICE = ""org.gjt.sp.jedit.buffer.FoldHandler"";

	
	public static FoldHandlerProvider foldHandlerProvider;

	
	
	public String getName()
	{
		return name;
	}
	

	
	
	public abstract int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg);
	

	
	
	public List<Integer> getPrecedingFoldLevels(JEditBuffer buffer,
		int lineIndex, Segment seg, int lineFoldLevel)
	{
		return null;
	}
	

	
	
	public boolean equals(Object o)
	{
		
		if(o == null)
			return false;
		else
			return getClass() == o.getClass();
	} 

	
	public int hashCode()
	{
		return getClass().hashCode();
	} 

	
	
	public static FoldHandler getFoldHandler(String name)
	{
		return foldHandlerProvider.getFoldHandler(name);
	}
	

	
	
	public static String[] getFoldModes()
	{
		return foldHandlerProvider.getFoldModes();
	}
	

	
	protected FoldHandler(String name)
	{
		this.name = name;
	}
	

	
	public String toString()
	{
		return name;
	} 

	private String name;
}
"
jEdit,4.3,org.gjt.sp.util.StringList,11,4,0,0,26,55,0,0,11,1.1,173,1.0,0,0.886075949,0.257575758,1,1,14.63636364,4,1.4545,0,"

package org.gjt.sp.util;


import java.util.ArrayList;
import java.util.Collection;




public class StringList extends ArrayList<String>
{

 	
 	public StringList()
	{
	}


	public StringList(Object[] array)
	{
		addAll(array);
	} 

	
	public void addAll(Object[] array)
	{
		for (int i = 0; i < array.length; ++i)
		{
			add(array[i].toString());
		}
	}   

	
	
	public static StringList split(String orig, Object delim)
	{
		if ((orig == null) || (orig.length() == 0))
			return new StringList();
		return new StringList(orig.split(delim.toString()));
	} 

	
	
	@Override
	public String toString()
	{
		return join(""\n"");
	}  

	
	
	@Override
	public String[] toArray() 
	{
		int siz = size();
		String[] result = new String[siz];
		System.arraycopy(super.toArray(), 0, result, 0, siz);
		return result;
	}
	

	
	
	public static String join(Collection c, String delim)
	{
		StringList sl = new StringList();
		for (Object o: c) {
			String s = o.toString();
			sl.add(s);
		}
		return sl.join(delim);
	}

	
	public static String join(Object[] arr, String delim) 
	{
		StringList sl = new StringList();
		sl.addAll(arr);
		return sl.join(delim);
	}


	
	public String join(String delim) 
	{
		int s = size();
		if (s < 1)
			return """";
		if (s == 1)
			return get(0);
		else
		{
			StringBuilder retval = new StringBuilder();
			retval.append(get(0));
			for (int i = 1; i < s; ++i)
				retval.append(delim + get(i));
			return retval.toString();
		}

	}  

	
	public static void main(String args[])
	{
		String teststr = ""a,b,c,d,e,f"";
		StringList.split(teststr, "","");
		
		
		System.out.println(""Test Passed"");

	}
	private static final long serialVersionUID = -6408080298368668262L;
} 
"
jEdit,4.3,org.gjt.sp.jedit.io.GlobVFSFileFilter,7,1,0,8,15,1,4,4,7,0.416666667,62,1.0,0,0.0,0.523809524,0,0,7.571428571,3,1.2857,0,"

package org.gjt.sp.jedit.io;

import java.util.regex.Pattern;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.StandardUtilities;


public class GlobVFSFileFilter implements VFSFileFilter
{

	public GlobVFSFileFilter(String glob)
	{
		this.glob = glob;
	}

	public boolean accept(VFSFile file)
	{
		if (file.getType() == VFSFile.DIRECTORY
				|| file.getType() == VFSFile.FILESYSTEM)
		{
			return true;
		}
		else
		{
			return accept(file.getName());
		}
	}

	public boolean accept(String url)
	{
		if (pattern == null)
		{
			pattern = Pattern.compile(StandardUtilities.globToRE(glob),
						  Pattern.CASE_INSENSITIVE);
		}
		return pattern.matcher(url).matches();
	}

	public String getDescription()
	{
		return jEdit.getProperty(""vfs.browser.file_filter.glob"");
	}

	public String toString()
	{
		return glob;
	}

	public void setGlob(String glob)
	{
		this.glob = glob;
		pattern = null;
	}

	public String getGlob()
	{
		return glob;
	}

	private String glob;
	private Pattern pattern;

}

"
jEdit,4.3,org.gjt.sp.jedit.help.HelpViewerInterface,8,1,0,6,8,28,6,0,8,2.0,8,0.0,0,0.0,0.325,0,0,0.0,1,1.0,0,"package org.gjt.sp.jedit.help;

import java.awt.Component;
import java.beans.PropertyChangeListener;


public interface HelpViewerInterface 
{
	
	
	public void gotoURL(String url, boolean addToHistory, int scrollPos);
	
	public String getBaseURL();
	
	public void addPropertyChangeListener(PropertyChangeListener l);
	
	
	public void dispose();
	
	public Component getComponent();
	public String getShortURL();
	
	public void queueTOCReload();
	public void setTitle(String newTitle);
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchFolderNode,4,1,0,4,9,0,4,0,3,0.555555556,49,1.0,0,0.0,0.555555556,0,0,10.5,2,0.75,0,"
package org.gjt.sp.jedit.search;

import java.io.File;

public class HyperSearchFolderNode 
{
	private File nodeFile;
	private boolean showFullPath;
	private static String fileSep = System.getProperty(""file.separator"");
	static
	{
		if (fileSep.equals(""\\""))
			fileSep = ""\\\\"";
	}
	
	public File getNodeFile()
	{
		return nodeFile;
	}
	
	public HyperSearchFolderNode(File nodeFile, boolean showFullPath) 
	{
		this.nodeFile = nodeFile;
		this.showFullPath = showFullPath;
	}
	
	public String toString()
	{
		if (showFullPath)
			return nodeFile.getAbsolutePath();
		String paths[] = nodeFile.getAbsolutePath().split(fileSep);
		return paths[paths.length - 1];
		
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bufferio.BufferIORequest,9,2,4,16,56,24,6,11,3,1.0625,601,0.3,3,0.428571429,0.174603175,0,0,63.55555556,1,0.8889,0,"

package org.gjt.sp.jedit.bufferio;


import java.io.BufferedOutputStream;
import java.io.CharConversionException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.nio.charset.CharacterCodingException;

import javax.swing.text.Segment;

import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.Encoding;
import org.gjt.sp.jedit.io.EncodingServer;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.SegmentBuffer;
import org.gjt.sp.util.WorkRequest;



public abstract class BufferIORequest extends WorkRequest
{
	

	
	public static final int IOBUFSIZE = 32768;

	
	public static final int PROGRESS_INTERVAL = 300;

	public static final String LOAD_DATA = ""BufferIORequest__loadData"";
	public static final String END_OFFSETS = ""BufferIORequest__endOffsets"";
	public static final String NEW_PATH = ""BufferIORequest__newPath"";

	
	public static final String ERROR_OCCURRED = ""BufferIORequest__error"";

	
	@Deprecated public static final int UTF8_MAGIC_1 = 0xef;
	@Deprecated public static final int UTF8_MAGIC_2 = 0xbb;
	@Deprecated public static final int UTF8_MAGIC_3 = 0xbf;
	@Deprecated public static final int UNICODE_MAGIC_1 = 0xfe;
	@Deprecated public static final int UNICODE_MAGIC_2 = 0xff;
	@Deprecated public static final int XML_PI_LENGTH = 50;
	@Deprecated public static final int GZIP_MAGIC_1 = 0x1f;
	@Deprecated public static final int GZIP_MAGIC_2 = 0x8b;

	

	
	protected final View view;
	protected final Buffer buffer;
	protected final Object session;
	protected final VFS vfs;
	protected String path;
	protected final String markersPath;
	

	
	
	protected BufferIORequest(View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		this.view = view;
		this.buffer = buffer;
		this.session = session;
		this.vfs = vfs;
		this.path = path;

		markersPath = Buffer.getMarkersPath(vfs, path);
	} 

	
	public String toString()
	{
		return getClass().getName() + '[' + buffer + ']';
	} 

	
	
	public static int getCharIOBufferSize()
	{
		return IOBUFSIZE;
	} 

	
	
	public static int getByteIOBufferSize()
	{
		
		return IOBUFSIZE * 2;
	} 

	
	
	protected Reader autodetect(InputStream in) throws IOException
	{
		return MiscUtilities.autodetect(in, buffer);
	} 

	
	protected SegmentBuffer read(Reader in, long length,
		boolean insert) throws IOException
	{
		
		IntegerArray endOffsets = new IntegerArray(
			Math.max(1,(int)(length / 50)));

		
		boolean trackProgress = !buffer.isTemporary() && length != 0;

		if(trackProgress)
		{
			setMaximum(length);
			setValue(0);
		}

		
		
		if(length == 0)
			length = IOBUFSIZE;

		SegmentBuffer seg = new SegmentBuffer((int)length + 1);

		char[] buf = new char[IOBUFSIZE];

		
 		int len;

		
		
		boolean CRLF = false;

		
		boolean CROnly = false;

		
		
		
		boolean lastWasCR = false;

		
		
		int lineCount = 0;

		while((len = in.read(buf,0,buf.length)) != -1)
		{
			
			
			
			int lastLine = 0;

			for(int i = 0; i < len; i++)
			{
				
				switch(buf[i])
				{
				case '\r':
					
					
					
					
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
					}
					
					
					
					else
					{
						lastWasCR = true;
					}

					
					seg.append(buf,lastLine,i -
						lastLine);
					seg.append('\n');
					endOffsets.add(seg.count);
					if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
						setValue(seg.count);

					
					
					lastLine = i + 1;
					break;
				case '\n':
					
					if(lastWasCR)
					{
						CROnly = false;
						CRLF = true;
						lastWasCR = false;
						
						lastLine = i + 1;
					}
					
					else
					{
						CROnly = false;
						CRLF = false;
						seg.append(buf,lastLine,
							i - lastLine);
						seg.append('\n');
						endOffsets.add(seg.count);
						if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
							setValue(seg.count);
						lastLine = i + 1;
					}
					break;
				default:
					
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
						lastWasCR = false;
					}
					break;
				}
			}

			if(trackProgress)
				setValue(seg.count);

			
			seg.append(buf,lastLine,len - lastLine);
		}

		setAbortable(false);

		String lineSeparator;
		if(seg.count == 0)
		{
			
			
			lineSeparator = jEdit.getProperty(
				""buffer.lineSeparator"",
				System.getProperty(""line.separator""));
		}
		else if(CRLF)
			lineSeparator = ""\r\n"";
		else if(CROnly)
			lineSeparator = ""\r"";
		else
			lineSeparator = ""\n"";

		
		int bufferLength = seg.count;
		if(bufferLength != 0)
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == 0x1a )
				seg.count--;
		}

		buffer.setBooleanProperty(Buffer.TRAILING_EOL,false);
		if(bufferLength != 0 && jEdit.getBooleanProperty(""stripTrailingEOL""))
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == '\n')
			{
				buffer.setBooleanProperty(Buffer.TRAILING_EOL,true);
				seg.count--;
				endOffsets.setSize(endOffsets.getSize() - 1);
			}
		}

		
		
		endOffsets.add(seg.count + 1);

		
		
		
		if(!insert)
		{
			buffer.setProperty(LOAD_DATA,seg);
			buffer.setProperty(END_OFFSETS,endOffsets);
			buffer.setProperty(NEW_PATH,path);
			if(lineSeparator != null)
				buffer.setProperty(JEditBuffer.LINESEP,lineSeparator);
		}

		
		return seg;
	} 

	
	protected void write(Buffer buffer, OutputStream out)
		throws IOException
	{
		String encodingName
			= buffer.getStringProperty(JEditBuffer.ENCODING);
		Encoding encoding = EncodingServer.getEncoding(encodingName);
		Writer writer = encoding.getTextWriter(
			new BufferedOutputStream(out, getByteIOBufferSize()));

		Segment lineSegment = new Segment();
		String newline = buffer.getStringProperty(JEditBuffer.LINESEP);
		if(newline == null)
			newline = System.getProperty(""line.separator"");

		final int bufferLineCount = buffer.getLineCount();
		setMaximum(bufferLineCount / PROGRESS_INTERVAL);
		setValue(0);

		int i = 0;
		while(i < bufferLineCount)
		{
			buffer.getLineText(i,lineSegment);
			try
			{
				writer.write(lineSegment.array,
					lineSegment.offset,
					lineSegment.count);
				if(i < bufferLineCount - 1
					|| (jEdit.getBooleanProperty(""stripTrailingEOL"")
						&& buffer.getBooleanProperty(Buffer.TRAILING_EOL)))
				{
					writer.write(newline);
				}
			}
			catch(CharacterCodingException e)
			{
				String message = getWriteEncodingErrorMessage(
					encodingName, encoding,
					lineSegment, i);
				IOException wrapping = new CharConversionException(message);
				wrapping.initCause(e);
				throw wrapping;
			}

			if(++i % PROGRESS_INTERVAL == 0)
				setValue(i / PROGRESS_INTERVAL);
		}
		writer.flush();
	} 

	

	
	private static String getWriteEncodingErrorMessage(
		String encodingName, Encoding encoding,
		Segment line, int lineIndex)
	{
		String args[] = {
			encodingName,
			Integer.toString(lineIndex + 1),
			""UNKNOWN"", 
			""UNKNOWN""  
		};
		try
		{
			int charIndex = getFirstGuiltyCharacterIndex(encoding, line);
			if(0 <= charIndex && charIndex < line.count)
			{
				char c = line.array[line.offset + charIndex];
				args[2] = Integer.toString(charIndex + 1);
				args[3] = ""'"" + c + ""' (U+"" + Integer.toHexString(c).toUpperCase() + "")"";
			}
		}
		catch(Exception e)
		{
			
		}
		return jEdit.getProperty(""ioerror.write-encoding-error"", args);
	} 

	
	
	private static int getFirstGuiltyCharacterIndex(Encoding encoding,
		Segment line) throws IOException
	{
		if(line.count < 1)
		{
			return -1;
		}
		else if(line.count == 1)
		{
			return 0;
		}

		Writer tester = encoding.getTextWriter(
			new OutputStream()
			{
				public void write(int b) {}
			});
		for(int i = 0; i < line.count; ++i)
		{
			try
			{
				tester.write(line.array[line.offset + i]);
			}
			catch(CharacterCodingException e)
			{
				return i;
			}
		}
		return -1;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHFormalComment,18,2,0,6,36,153,1,5,18,1.058823529,84,0.0,0,0.5,0.268518519,1,5,3.611111111,1,0.9444,0,"

package org.gjt.sp.jedit.bsh;

public class BSHFormalComment extends SimpleNode 
{
	public String text;

	public BSHFormalComment(int id) {
		super(id);
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.visitors.JEditVisitor,3,1,0,7,3,3,5,3,3,2.0,3,0.0,0,0.0,0.5,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.visitors;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;



public interface JEditVisitor
{
	
	void visit(View view);
		   
	
	void visit(EditPane editPane);

	
	void visit(JEditTextArea textArea);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ClassGeneratorUtil,22,1,0,34,114,219,1,33,6,0.962406015,2003,0.0,5,0.0,0.159090909,0,0,89.18181818,18,5.4545,0,"

package org.gjt.sp.jedit.bsh;

import org.gjt.sp.jedit.bsh.org.objectweb.asm.*;
import org.gjt.sp.jedit.bsh.org.objectweb.asm.Type;

import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;



public class ClassGeneratorUtil implements Constants 
{
	
	static final String BSHSTATIC=""_bshStatic"";

	
	static final String BSHTHIS=""_bshThis"";

	
	static final String BSHSUPER=""_bshSuper"";

	
	static final String BSHINIT=""_bshInstanceInitializer"";

	
	static final String BSHCONSTRUCTORS=""_bshConstructors"";

	
	static final int DEFAULTCONSTRUCTOR = -1;

	static final String OBJECT= ""Ljava/lang/Object;"";

	String className;
	
	String fqClassName;
	Class superClass; 
	String superClassName;
	Class [] interfaces;
	Variable [] vars;
	Constructor [] superConstructors;
	DelayedEvalBshMethod [] constructors;
	DelayedEvalBshMethod [] methods;
	NameSpace classStaticNameSpace;
	Modifiers classModifiers;
	boolean isInterface;

	
	public ClassGeneratorUtil(
		Modifiers classModifiers, String className, String packageName, 
		Class superClass, Class [] interfaces, Variable [] vars, 
		DelayedEvalBshMethod [] bshmethods, NameSpace classStaticNameSpace,
		boolean isInterface
	) 
	{
		this.classModifiers = classModifiers;
		this.className = className;
		if ( packageName != null ) 
			this.fqClassName = packageName.replace('.','/') + ""/"" + className;
		else
			this.fqClassName = className;
		if ( superClass == null )
			superClass = Object.class;
		this.superClass = superClass;
		this.superClassName = Type.getInternalName( superClass );
		if ( interfaces == null )
			interfaces = new Class[0];
		this.interfaces = interfaces;
		this.vars = vars;
		this.classStaticNameSpace = classStaticNameSpace;
		this.superConstructors = superClass.getDeclaredConstructors();

		
		List consl = new ArrayList();
		List methodsl = new ArrayList();
		String classBaseName = getBaseName( className ); 
		for( int i=0; i< bshmethods.length; i++ )
			if ( bshmethods[i].getName().equals( classBaseName ) )
				consl.add( bshmethods[i] );
			else
				methodsl.add( bshmethods[i] );

		this.constructors = (DelayedEvalBshMethod [])consl.toArray( 
			new DelayedEvalBshMethod[0] );
		this.methods = (DelayedEvalBshMethod [])methodsl.toArray( 
			new DelayedEvalBshMethod[0] );

		try {
			classStaticNameSpace.setLocalVariable( 
				BSHCONSTRUCTORS, constructors, false );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError(""can't set cons var"");
		}

		this.isInterface = isInterface;
	}

	
	public byte [] generateClass() 
	{
		
		int classMods = getASMModifiers( classModifiers ) | ACC_PUBLIC;
		if ( isInterface )
			classMods |= ACC_INTERFACE;

		String [] interfaceNames = new String [interfaces.length];
		for(int i=0; i<interfaces.length; i++)
			interfaceNames[i]=Type.getInternalName( interfaces[i] );

		String sourceFile = ""BeanShell Generated via ASM (www.objectweb.org)"";
		ClassWriter cw = new ClassWriter(false);
		cw.visit( classMods, fqClassName, superClassName, 
			interfaceNames, sourceFile );

		if ( !isInterface )
		{
			
			generateField( 
				BSHTHIS+className, ""Lorg/gjt/sp/jedit/bsh/This;"", ACC_PUBLIC, cw);

			
			generateField( 
				BSHSTATIC+className, ""Lorg/gjt/sp/jedit/bsh/This;"", ACC_PUBLIC+ACC_STATIC, cw);
		}

		
		for( int i=0; i<vars.length; i++)
		{
			String type = vars[i].getTypeDescriptor();

			
			
			if ( vars[i].hasModifier(""private"") || type == null )
				continue;
		
			int modifiers;
			if ( isInterface )
				modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;
			else
				modifiers = getASMModifiers( vars[i].getModifiers() );

			generateField( vars[i].getName(), type, modifiers , cw );
		}

		
		boolean hasConstructor = false;
		for( int i=0; i<constructors.length; i++)
		{
			
			if ( constructors[i].hasModifier(""private"") )
				continue;

			int modifiers = getASMModifiers( constructors[i].getModifiers() );
			generateConstructor( 
				i, constructors[i].getParamTypeDescriptors(), modifiers, cw );
			hasConstructor = true;
		}

		
		if ( !isInterface && !hasConstructor )
			generateConstructor( 
				DEFAULTCONSTRUCTOR, new String [0], ACC_PUBLIC, cw );

		
		for( int i=0; i<methods.length; i++)
		{
			String returnType = methods[i].getReturnTypeDescriptor();

			
			if ( methods[i].hasModifier(""private"")  )
				continue;

			int modifiers = getASMModifiers( methods[i].getModifiers() );
			if ( isInterface )
				modifiers |= ( ACC_PUBLIC | ACC_ABSTRACT );

			generateMethod( className, fqClassName, 
				methods[i].getName(), returnType,
				methods[i].getParamTypeDescriptors(), modifiers, cw );

			boolean isStatic = (modifiers & ACC_STATIC) > 0 ;
			boolean overridden = classContainsMethod( 
				superClass, methods[i].getName(), 
				methods[i].getParamTypeDescriptors() ) ;
			if ( !isStatic && overridden )
				generateSuperDelegateMethod( superClassName,
					methods[i].getName(), returnType,
					methods[i].getParamTypeDescriptors(), modifiers, cw );
		}

		return cw.toByteArray();
	}

	
	static int getASMModifiers( Modifiers modifiers ) 
	{
		int mods = 0;
		if ( modifiers == null )
			return mods;

		if ( modifiers.hasModifier(""public"") )
			mods += ACC_PUBLIC;
		if ( modifiers.hasModifier(""protected"") )
			mods += ACC_PROTECTED;
		if ( modifiers.hasModifier(""static"") )
			mods += ACC_STATIC;
		if ( modifiers.hasModifier(""synchronized"") )
			mods += ACC_SYNCHRONIZED;
		if ( modifiers.hasModifier(""abstract"") )
			mods += ACC_ABSTRACT;

		return mods;
	}

	
	static void generateField( 
		String fieldName, String type, int modifiers, ClassWriter cw ) 
	{
		cw.visitField( modifiers, fieldName, type, null );
	}
	
	
	static void generateMethod( 
		String className, String fqClassName, String methodName, 
		String returnType, String[] paramTypes, int modifiers, ClassWriter cw ) 
	{
		String [] exceptions = null;
		boolean isStatic = (modifiers & ACC_STATIC) != 0 ;

		if ( returnType == null ) 
			returnType = OBJECT;

		String methodDescriptor = getMethodDescriptor( returnType, paramTypes );

		
		CodeVisitor cv = cw.visitMethod( 
			modifiers, methodName, methodDescriptor, exceptions );

		if ( (modifiers & ACC_ABSTRACT) != 0 )
			return;

		
		if ( isStatic )
		{
			cv.visitFieldInsn( 
				GETSTATIC, fqClassName, BSHSTATIC+className, ""Lorg/gjt/sp/jedit/bsh/This;"" );
		}else
		{
			
			cv.visitVarInsn( ALOAD, 0 );

			
			cv.visitFieldInsn( 
				GETFIELD, fqClassName, BSHTHIS+className, ""Lorg/gjt/sp/jedit/bsh/This;"" );
		}

		
    	cv.visitLdcInsn( methodName );

		
		generateParameterReifierCode( paramTypes, isStatic, cv );

		
		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ACONST_NULL); 

		
		cv.visitInsn(ICONST_1);

		
		cv.visitMethodInsn(
			INVOKEVIRTUAL, ""org/gjt/sp/jedit/bsh/This"", ""invokeMethod"",
			Type.getMethodDescriptor( 
				Type.getType(Object.class),
				new Type [] { 
					Type.getType(String.class), 
					Type.getType(Object [].class),
					Type.getType(Interpreter.class),
					Type.getType(CallStack.class),
					Type.getType(SimpleNode.class),
					Type.getType(Boolean.TYPE) 
				} 
			)
		);

		
		cv.visitMethodInsn(
		  INVOKESTATIC, ""org/gjt/sp/jedit/bsh/Primitive"", ""unwrap"",
		  ""(Ljava/lang/Object;)Ljava/lang/Object;"" );

		
		generateReturnCode( returnType, cv );

		
		cv.visitMaxs( 20, 20 );
	}

	
	void generateConstructor( 
		int index, String [] paramTypes, int modifiers, ClassWriter cw ) 
	{
		
		final int argsVar = paramTypes.length+1;
		
		final int consArgsVar = paramTypes.length+2;

		String [] exceptions = null;
		String methodDescriptor = getMethodDescriptor( ""V"", paramTypes );

		
		CodeVisitor cv = 
			cw.visitMethod( modifiers, ""<init>"", methodDescriptor, exceptions );

		
		generateParameterReifierCode( paramTypes, false, cv );
		cv.visitVarInsn( ASTORE, argsVar );

		
		generateConstructorSwitch( index, argsVar, consArgsVar, cv );

		

		
		cv.visitVarInsn( ALOAD, 0 );

		
    	cv.visitLdcInsn( className );

		
		cv.visitVarInsn( ALOAD, argsVar );

		
		cv.visitMethodInsn(
			INVOKESTATIC, ""org/gjt/sp/jedit/bsh/ClassGeneratorUtil"", ""initInstance"",
			""(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V"");

		cv.visitInsn( RETURN );

		
		cv.visitMaxs( 20, 20 );
	}

	
	void generateConstructorSwitch( 
		int consIndex, int argsVar, int consArgsVar, CodeVisitor cv )
	{
		Label defaultLabel = new Label();
		Label endLabel = new Label();
		int cases = superConstructors.length + constructors.length ;

		Label [] labels = new Label[ cases ];
		for(int i=0; i<cases; i++)
			labels[i]=new Label();

		
		

		
    	cv.visitLdcInsn( superClass.getName() ); 

		
		cv.visitFieldInsn( 
			GETSTATIC, fqClassName, BSHSTATIC+className, ""Lorg/gjt/sp/jedit/bsh/This;"" );

		
		cv.visitVarInsn( ALOAD, argsVar );

		
		cv.visitIntInsn( BIPUSH, consIndex );

		
		cv.visitMethodInsn(
			INVOKESTATIC, ""org/gjt/sp/jedit/bsh/ClassGeneratorUtil"", ""getConstructorArgs"",
			""(Ljava/lang/String;Lorg/gjt/sp/jedit/bsh/This;[Ljava/lang/Object;I)""
			+""Lorg/gjt/sp/jedit/bsh/ClassGeneratorUtil$ConstructorArgs;""
		);

		
		cv.visitVarInsn( ASTORE, consArgsVar );

		

		
		cv.visitVarInsn( ALOAD, consArgsVar );
		cv.visitFieldInsn( 
			GETFIELD, ""org/gjt/sp/jedit/bsh/ClassGeneratorUtil$ConstructorArgs"", ""selector"", ""I"" );

		
		cv.visitTableSwitchInsn( 
			0, cases-1, defaultLabel, labels );

		
		int index = 0;
		for( int i=0; i< superConstructors.length; i++, index++)
			doSwitchBranch( index, superClassName, 
				getTypeDescriptors( superConstructors[i].getParameterTypes() ), 
				endLabel, labels, consArgsVar, cv );
		for( int i=0; i< constructors.length; i++, index++)
			doSwitchBranch( index, fqClassName, 
				constructors[i].getParamTypeDescriptors(), 
				endLabel, labels, consArgsVar, cv );
	
		
		cv.visitLabel( defaultLabel );
		
		cv.visitVarInsn( ALOAD, 0 ); 
		cv.visitMethodInsn( INVOKESPECIAL, superClassName, ""<init>"", ""()V"" );

		
		cv.visitLabel( endLabel );
	}

	
	static void doSwitchBranch( 
		int index, String targetClassName, String [] paramTypes,
		Label endLabel, Label [] labels, int consArgsVar, CodeVisitor cv
	)
	{
		cv.visitLabel( labels[index] );
		
		cv.visitVarInsn( ALOAD, 0 ); 

		
		for (int i=0; i<paramTypes.length; i++)
		{
			String type = paramTypes[i];
			String method = null;
			if      ( type.equals(""Z"") )
				method = ""getBoolean"";
			else if ( type.equals(""B"") )
				method = ""getByte"";
			else if ( type.equals(""C"") )
				method = ""getChar"";
			else if ( type.equals(""S"") )
				method = ""getShort"";
			else if ( type.equals(""I"") )
				method = ""getInt"";
			else if ( type.equals(""J"") )
				method = ""getLong"";
			else if ( type.equals(""D"") )
				method = ""getDouble"";
			else if ( type.equals(""F"") )
				method = ""getFloat"";
			else 
				method = ""getObject"";

			
			cv.visitVarInsn( ALOAD, consArgsVar ); 
			String className = ""org/gjt/sp/jedit/bsh/ClassGeneratorUtil$ConstructorArgs"";
			String retType;
			if ( method.equals(""getObject"") )
				retType = OBJECT;
			else
				retType = type; 
			cv.visitMethodInsn(INVOKEVIRTUAL, className, method, ""()""+retType);
			
			if ( method.equals(""getObject"") )
				cv.visitTypeInsn( CHECKCAST, descriptorToClassName(type) ); 
		}

		
		String descriptor = getMethodDescriptor( ""V"", paramTypes );
		cv.visitMethodInsn( 
			INVOKESPECIAL, targetClassName, ""<init>"", descriptor );
		cv.visitJumpInsn( GOTO, endLabel );
	}
	
	static String getMethodDescriptor( String returnType, String [] paramTypes )
	{
		StringBuilder sb = new StringBuilder(""("");
		for(int i=0; i<paramTypes.length; i++)
			sb.append(paramTypes[i]);
		sb.append("")""+returnType);
		return sb.toString();
	}

	
	
	static void generateSuperDelegateMethod( String superClassName, String methodName,
											 String returnType, String[] paramTypes, int modifiers, ClassWriter cw )
	{
		String [] exceptions = null;

		if ( returnType == null ) 
			returnType = OBJECT;

		String methodDescriptor = getMethodDescriptor( returnType, paramTypes );

		
		CodeVisitor cv = cw.visitMethod( 
			modifiers, ""_bshSuper""+methodName, methodDescriptor, exceptions );

		cv.visitVarInsn(ALOAD, 0);
		
		int localVarIndex = 1;
		for (int i = 0; i < paramTypes.length; ++i) 
		{
			if ( isPrimitive( paramTypes[i]) )
				cv.visitVarInsn(ILOAD, localVarIndex);
			else
				cv.visitVarInsn(ALOAD, localVarIndex);
			localVarIndex += 
				( (paramTypes[i].equals(""D"") || paramTypes[i].equals(""J"")) 
					? 2 : 1 );
		}

		cv.visitMethodInsn( INVOKESPECIAL, 
			superClassName, methodName, methodDescriptor );

		generatePlainReturnCode( returnType, cv );

		
		cv.visitMaxs( 20, 20 );
	}

	boolean classContainsMethod(
		Class clas, String methodName, String [] paramTypes )
	{
		while( clas != null )
		{
			Method [] methods = clas.getDeclaredMethods();
			for( int i =0; i<methods.length; i++ )
			{
				if ( methods[i].getName().equals(methodName) )
				{
					String [] methodParamTypes = 
						getTypeDescriptors( methods[i].getParameterTypes() );
					boolean found = true;
					for( int j=0; j<methodParamTypes.length; j++)
					{
						if ( ! paramTypes[j].equals( methodParamTypes[j] ) ) {
							found = false;
							break;
						}
					}
					if ( found )
						return true;
				}
			}

			clas = clas.getSuperclass();
		}

		return false;
	}

	
	static void generatePlainReturnCode( String returnType, CodeVisitor cv )
	{
		if ( returnType.equals(""V"") )
			cv.visitInsn( RETURN );
		else 
		if ( isPrimitive( returnType ) )
		{
			int opcode = IRETURN;
			if ( returnType.equals(""D"") )
				opcode = DRETURN;
			else if ( returnType.equals(""F"") )
				opcode = FRETURN;
			else if ( returnType.equals(""J"") )  
				opcode = LRETURN;

			cv.visitInsn(opcode);
		}
		else {
			cv.visitTypeInsn( CHECKCAST, descriptorToClassName(returnType) );
			cv.visitInsn( ARETURN );
		}
	}

	
	public static void generateParameterReifierCode (
		String [] paramTypes, boolean isStatic, final CodeVisitor cv )
	{
		cv.visitIntInsn(SIPUSH, paramTypes.length);
		cv.visitTypeInsn(ANEWARRAY, ""java/lang/Object"");
		int localVarIndex = isStatic ? 0 : 1;
		for (int i = 0; i < paramTypes.length; ++i) 
		{
			String param = paramTypes[i];
			cv.visitInsn(DUP);
			cv.visitIntInsn(SIPUSH, i);
			if ( isPrimitive( param ) ) 
			{
                int opcode;
                if (param.equals(""F"")) {
                    opcode = FLOAD;
                } else if (param.equals(""D"")) {
                    opcode = DLOAD;
                } else if (param.equals(""J"")) {
                    opcode = LLOAD;
                } else {
                    opcode = ILOAD;
                }

				String type = ""org/gjt/sp/jedit/bsh/Primitive"";
				cv.visitTypeInsn( NEW, type );
				cv.visitInsn(DUP);
				cv.visitVarInsn(opcode, localVarIndex);
				String desc = param; 
				cv.visitMethodInsn(
					INVOKESPECIAL, type, ""<init>"", ""("" + desc + "")V"");
			} else {
				
				
				
				
				
				cv.visitVarInsn( ALOAD, localVarIndex );
			}
			cv.visitInsn(AASTORE);
			localVarIndex += 
				( (param.equals(""D"") || param.equals(""J"")) ? 2 : 1 );
		}
  }

  
	public static void generateReturnCode (
		String returnType, CodeVisitor cv ) 
	{
		if ( returnType.equals(""V"") ) 
		{
			cv.visitInsn(POP);
			cv.visitInsn(RETURN);
		} 
		else if ( isPrimitive( returnType ) ) 
		{
			int opcode = IRETURN;
			String type;
			String meth;
			if ( returnType.equals(""B"") ) {
				type = ""java/lang/Byte"";
				meth = ""byteValue"";
		 	} else if (returnType.equals(""I"") ) {
				type = ""java/lang/Integer"";
				meth = ""intValue"";
			} else if (returnType.equals(""Z"") ) {
				type = ""java/lang/Boolean"";
				meth = ""booleanValue"";
			} else if (returnType.equals(""D"") ) {
				opcode = DRETURN;
				type = ""java/lang/Double"";
				meth = ""doubleValue"";
		 	} else if (returnType.equals(""F"") ) {
				opcode = FRETURN;
				type = ""java/lang/Float"";
				meth = ""floatValue"";
			} else if (returnType.equals(""J"") ) {
				opcode = LRETURN;
				type = ""java/lang/Long"";
				meth = ""longValue"";
			} else if (returnType.equals(""C"") ) {
				type = ""java/lang/Character"";
				meth = ""charValue"";
			} else  {
				type = ""java/lang/Short"";
				meth = ""shortValue"";
			}

			String desc = returnType;
			cv.visitTypeInsn( CHECKCAST, type ); 
			cv.visitMethodInsn( INVOKEVIRTUAL, type, meth, ""()"" + desc );
			cv.visitInsn(opcode);
		} else 
		{
			cv.visitTypeInsn( CHECKCAST, descriptorToClassName(returnType) );
			cv.visitInsn(ARETURN);
		}
  }

	
	public static ConstructorArgs getConstructorArgs( 
		String superClassName, This classStaticThis, 
		Object [] consArgs, int index )
	{
		DelayedEvalBshMethod [] constructors;
		try {
			constructors = 
				(DelayedEvalBshMethod [])classStaticThis.getNameSpace()
				.getVariable( BSHCONSTRUCTORS );
		} catch ( Exception e ) {
			throw new InterpreterError(
				""unable to get instance initializer: ""+e );
		}

		if ( index == DEFAULTCONSTRUCTOR ) 
			return ConstructorArgs.DEFAULT; 

		DelayedEvalBshMethod constructor = constructors[index];

		if ( constructor.methodBody.jjtGetNumChildren() == 0 )
			return ConstructorArgs.DEFAULT; 

		
		String altConstructor = null;
		BSHArguments argsNode = null;
		SimpleNode firstStatement = 
			(SimpleNode)constructor.methodBody.jjtGetChild(0);
		if ( firstStatement instanceof BSHPrimaryExpression )
			firstStatement = (SimpleNode)firstStatement.jjtGetChild(0);
		if ( firstStatement instanceof BSHMethodInvocation )
		{
			BSHMethodInvocation methodNode = 
				(BSHMethodInvocation)firstStatement;
			BSHAmbiguousName methodName = methodNode.getNameNode();
			if ( methodName.text.equals(""super"") 
				|| methodName.text.equals(""this"") 
			) {
				altConstructor = methodName.text;
				argsNode = methodNode.getArgsNode();
			}
		}

		if ( altConstructor == null )
			return ConstructorArgs.DEFAULT; 

		
		
		NameSpace consArgsNameSpace = 
			new NameSpace( classStaticThis.getNameSpace(), ""consArgs"" );
		String [] consArgNames = constructor.getParameterNames();
		Class [] consArgTypes = constructor.getParameterTypes();
		for( int i=0; i<consArgs.length; i++ )
		{
			try {
				consArgsNameSpace.setTypedVariable( 
					consArgNames[i], consArgTypes[i], consArgs[i], 
					null);
			} catch ( UtilEvalError e ) {
				throw new InterpreterError(""err setting local cons arg:""+e);
			}
		}

		

		CallStack callstack = new CallStack();
		callstack.push( consArgsNameSpace);
		Object [] args = null;
		Interpreter interpreter = classStaticThis.declaringInterpreter;

		try {
			args = argsNode.getArguments( callstack, interpreter );
		} catch ( EvalError e ) {
			throw new InterpreterError(
				""Error evaluating constructor args: ""+e );
		}

		Class [] argTypes  = Types.getTypes( args );
		args = Primitive.unwrap( args );
		Class superClass = 
			interpreter.getClassManager().classForName( superClassName );
		if ( superClass == null )
			throw new InterpreterError(
				""can't find superclass: ""+superClassName );
		Constructor [] superCons = superClass.getDeclaredConstructors();

		
		if ( altConstructor.equals(""super"") )
		{
			int i = Reflect.findMostSpecificConstructorIndex( 
				argTypes , superCons );
			if ( i == -1 )
				throw new InterpreterError(""can't find constructor for args!"");
			return new ConstructorArgs( i, args );
		}

		
		Class [][] candidates = new Class [ constructors.length ] [];
		for(int i=0; i< candidates.length; i++ )
			candidates[i] = constructors[i].getParameterTypes();
		int i = Reflect.findMostSpecificSignature( argTypes, candidates );
		if ( i == -1 )
			throw new InterpreterError(""can't find constructor for args 2!"");
		

		int selector = i+superCons.length;
		int ourSelector = index+superCons.length;

		
		if ( selector == ourSelector )
			throw new InterpreterError( ""Recusive constructor call."");

		return new ConstructorArgs( selector, args );
	}
	
	
	public static void initInstance( 
		Object instance, String className, Object [] args )
	{
		Class [] sig = Types.getTypes( args );
		CallStack callstack = new CallStack();
		Interpreter interpreter;
		NameSpace instanceNameSpace;

		
		
		This instanceThis = getClassInstanceThis( instance, className );


		if ( instanceThis == null )
		{
			
			

			
			This classStaticThis = 
				getClassStaticThis( instance.getClass(), className );
			interpreter = classStaticThis.declaringInterpreter;

			
			BSHBlock instanceInitBlock;
			try {
				instanceInitBlock = (BSHBlock)classStaticThis.getNameSpace()
					.getVariable( BSHINIT );
			} catch ( Exception e ) {
				throw new InterpreterError(
					""unable to get instance initializer: ""+e );
			}

			
			instanceNameSpace = 
				new NameSpace( classStaticThis.getNameSpace(), className );
			instanceNameSpace.isClass = true;

			
			instanceThis = instanceNameSpace.getThis( interpreter );
			try {
				LHS lhs = 
					Reflect.getLHSObjectField( instance, BSHTHIS+className );
				lhs.assign( instanceThis, false );
			} catch ( Exception e ) {
				throw new InterpreterError(""Error in class gen setup: ""+e );
			}

			
			instanceNameSpace.setClassInstance( instance );

			
			callstack.push( instanceNameSpace );

			
			try { 
				instanceInitBlock.evalBlock( 
					callstack, interpreter, true, 
					ClassGeneratorImpl.ClassNodeFilter.CLASSINSTANCE );
			} catch ( Exception e ) {
				throw new InterpreterError(""Error in class initialization: ""+e);
			}

			callstack.pop();

		} else
		{
			
			
			interpreter = instanceThis.declaringInterpreter;
			instanceNameSpace = instanceThis.getNameSpace();
		}

		

		String constructorName = getBaseName( className );
		try {
			
			BshMethod constructor = instanceNameSpace.getMethod( 
				constructorName, sig, true );

			
			if ( args.length > 0 && constructor == null )
				throw new InterpreterError(
					""Can't find constructor: ""+ className );

			
			if ( constructor != null )
				constructor.invoke( args, interpreter, callstack,
					null, false ) ;
		} catch ( Exception e ) {
			if ( e instanceof TargetError )
				e =(Exception)((TargetError)e).getTarget();
			if ( e instanceof InvocationTargetException )
				e = (Exception)((InvocationTargetException)e)
					.getTargetException();
			e.printStackTrace( System.err );
			throw new InterpreterError(""Error in class initialization: ""+e );
		} 
	}

	
	static This getClassStaticThis( Class clas, String className )
	{
		try {
			return (This)Reflect.getStaticFieldValue(
				clas, BSHSTATIC + className );
		} catch ( Exception e ) {
			throw new InterpreterError(""Unable to get class static space: ""+e);
		}
	}

	
	static This getClassInstanceThis( Object instance, String className )
	{
		try {
			Object o = Reflect.getObjectFieldValue( instance, BSHTHIS+className );
			return (This)Primitive.unwrap(o); 
		} catch ( Exception e ) {
			throw new InterpreterError(
				""Generated class: Error getting This""+e );
		}
	}

	
	private static boolean isPrimitive( String typeDescriptor )
	{
		return typeDescriptor.length() == 1; 
	}

	static String[] getTypeDescriptors( Class [] cparams )
	{
		String [] sa = new String [cparams.length];
		for(int i=0; i<sa.length; i++)
			sa[i] = BSHType.getTypeDescriptor( cparams[i] );
		return sa;
	}

	
	
	
	private static String descriptorToClassName( String s ) 
	{
		if ( s.startsWith(""["") || !s.startsWith(""L"") )
			return s;
		return s.substring( 1, s.length()-1 );
	}

	private static String getBaseName( String className ) 
	{
		int i = className.indexOf(""$"");
		if ( i == -1 )
			return className;

		return className.substring(i+1);
	}

	
	public static class ConstructorArgs
	{
		
		public static ConstructorArgs DEFAULT = new ConstructorArgs();

		public int selector = DEFAULTCONSTRUCTOR;
		Object [] args;
		int arg = 0;
		

		ConstructorArgs() {  }

		ConstructorArgs( int selector, Object [] args ) { 
			this.selector = selector;
			this.args = args; 
		}

		Object next() { return args[arg++]; }

		public boolean getBoolean() { return ((Boolean)next()).booleanValue(); }
		public byte getByte() { return ((Byte)next()).byteValue(); }
		public char getChar() { return ((Character)next()).charValue(); }
		public short getShort() { return ((Short)next()).shortValue(); }
		public int getInt() { return ((Integer)next()).intValue(); }
		public long getLong() { return ((Long)next()).longValue(); }
		public double getDouble() { return ((Double)next()).doubleValue(); }
		public float getFloat() { return ((Float)next()).floatValue(); }
		public Object getObject() { return next(); }
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableWindowContainer,5,1,0,7,5,10,7,1,5,2.0,5,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui;


interface DockableWindowContainer
{
	void register(DockableWindowManagerImpl.Entry entry);
	void remove(DockableWindowManagerImpl.Entry entry);
	void unregister(DockableWindowManagerImpl.Entry entry);
	void show(DockableWindowManagerImpl.Entry entry);
	boolean isVisible(DockableWindowManagerImpl.Entry entry);
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.DefaultFoldHandlerProvider,4,1,0,3,12,0,1,2,4,0.0,37,1.0,0,0.0,0.5,0,0,8.0,1,0.75,0,"
package org.gjt.sp.jedit.buffer;

import java.util.Map;
import java.util.HashMap;


public class DefaultFoldHandlerProvider implements FoldHandlerProvider
{
	private final Map<String, FoldHandler> folds = new HashMap<String, FoldHandler>();
	
	public FoldHandler getFoldHandler(String name)
	{
		return folds.get(name);
	}

	
	public String[] getFoldModes()
	{
		return folds.keySet().toArray(new String[folds.size()]); 
	}
	
	
	public void addFoldHandler(FoldHandler foldHandler)
	{
		folds.put(foldHandler.getName(), foldHandler);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.VFSPathSelected,4,2,0,4,6,2,1,3,4,0.666666667,26,1.0,0,0.5,0.4375,0,0,5.0,1,0.75,0,"package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.View;


public class VFSPathSelected extends EBMessage
{
	
	public VFSPathSelected(View source, String path, boolean isDirectory)
	{
		super(source);
		this.path = path;
		this.isDir = isDirectory;
	}

	public View getView()
	{
		return (View) getSource();
	}

	
	public String getPath()
	{
		return path;
	}

	
	public boolean isDirectory()
	{
		return isDir;
	}

	private final String path;
	private boolean isDir;
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.Modifiers,8,1,0,16,17,22,16,0,4,1.0,160,0.0,0,0.0,0.5,0,0,18.5,8,2.125,0,"package org.gjt.sp.jedit.bsh;

import java.util.Hashtable;



public class Modifiers implements java.io.Serializable
{
	public static final int CLASS=0, METHOD=1, FIELD=2;
	Hashtable modifiers;

	
	public void addModifier( int context, String name ) 
	{
		if ( modifiers == null )
			modifiers = new Hashtable();

		Object existing = modifiers.put( name, Void.TYPE );
		if ( existing != null )
			throw new IllegalStateException(""Duplicate modifier: ""+ name );

		int count = 0;
		if ( hasModifier(""private"") ) ++count;
		if ( hasModifier(""protected"") ) ++count;
		if ( hasModifier(""public"") ) ++count;
		if ( count > 1 )
			throw new IllegalStateException(
				""public/private/protected cannot be used in combination."" );

		switch( context ) 
		{
		case CLASS:
			validateForClass();
			break;
		case METHOD:
			validateForMethod();
			break;
		case FIELD:
			validateForField();
			break;
		}
	}

	public boolean hasModifier( String name ) 
	{
		if ( modifiers == null )
			modifiers = new Hashtable();
		return modifiers.get(name) != null;
	}

	
	private void validateForMethod() 
	{ 
		insureNo(""volatile"", ""Method"");
		insureNo(""transient"", ""Method"");
	}
	private void validateForField() 
	{ 
		insureNo(""synchronized"", ""Variable"");
		insureNo(""native"", ""Variable"");
		insureNo(""abstract"", ""Variable"");
	}
	private void validateForClass() 
	{ 
		validateForMethod(); 
		insureNo(""native"", ""Class"");
		insureNo(""synchronized"", ""Class"");
	}

	private void insureNo( String modifier, String context )
	{
		if ( hasModifier( modifier ) )
			throw new IllegalStateException(
				context + "" cannot be declared '""+modifier+""'"");
	}

	public String toString()
	{
		return ""Modifiers: ""+modifiers;
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ReturnControl,1,1,0,12,2,0,10,2,1,2.0,16,0.0,1,0.0,1.0,0,0,12.0,0,0.0,0,"


package org.gjt.sp.jedit.bsh;


class ReturnControl implements ParserConstants {
	public int kind;
	public Object value;
	
	public SimpleNode returnPoint;

	public ReturnControl( int kind, Object value, SimpleNode returnPoint ) {
		this.kind = kind;
		this.value = value;
		this.returnPoint = returnPoint;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bufferset.BufferSetAdapter,5,1,1,3,6,10,1,2,5,2.0,12,0.0,0,0.0,0.733333333,0,0,1.4,1,0.8,0,"
package org.gjt.sp.jedit.bufferset;

import org.gjt.sp.jedit.Buffer;


public class BufferSetAdapter implements BufferSetListener
{
	public void bufferAdded(Buffer buffer, int index)
	{
	}

	public void bufferRemoved(Buffer buffer, int index)
	{
	}

	public void bufferMoved(Buffer buffer, int oldIndex, int newIndex)
	{
	}

	public void bufferSetSorted()
	{
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.search.PatternSearchMatcher,5,2,0,4,25,2,1,3,4,0.416666667,301,1.0,0,0.25,0.44,0,0,58.6,28,6.4,0,"

package org.gjt.sp.jedit.search;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.gjt.sp.util.ReverseCharSequence;


public class PatternSearchMatcher extends SearchMatcher
{
	
	
	public PatternSearchMatcher(String search, boolean ignoreCase)
	{
		pattern = search;
		flags = getFlag(ignoreCase);
	}
	
	
	public PatternSearchMatcher(Pattern re, boolean ignoreCase)
	{
		this(re.pattern(), ignoreCase);
		this.re = re;
	} 

	
	
	@Override
	public SearchMatcher.Match nextMatch(CharSequence text, boolean start,
		boolean end, boolean firstTime, boolean reverse)
	{
		
		
		
		
		
		
		
		
		
		
		if (text instanceof ReverseCharSequence)
			text = ((ReverseCharSequence)text).baseSequence();

		if (re == null)
			re = Pattern.compile(pattern, flags);

		
		
		int matchStart = 0;
		if (!start && re.pattern().charAt(0) == '^')
		{
			Matcher sol = Pattern.compile(""^"", flags).matcher(text);
			
			sol.find();
			
			
			if (!sol.find())
				return null;
			
			
			matchStart = sol.start();
		}

		Matcher match = re.matcher(text);
		if (!match.find(matchStart))
			return null;

		
		
		
		if (!reverse && !firstTime && match.start() == 0 && match.end() == 0)
		{
			if (!match.find())
				return null;
		}

		Match previous = null;
		while (true)
		{
			
			
			
			
			
			
			if ((!end || (text.charAt(text.length() - 1) == '\n'))
				&& match.end() == text.length()
				&& pattern.charAt(pattern.length() - 1) == '$')
			{
				if (previous != null)
				{
					returnValue.start = previous.start;
					returnValue.end = previous.end;
					returnValue.substitutions = previous.substitutions;
					break;
				}
				else
				{
					return null;
				}
			}

			returnValue.substitutions = new String[match.groupCount() + 1];
			for(int i = 0; i < returnValue.substitutions.length; i++)
			{
				returnValue.substitutions[i] = match.group(i);
			}
	
			int _start = match.start();
			int _end = match.end();
	
			returnValue.start = _start;
			returnValue.end = _end;
			
			
			
			
			if (!reverse || !match.find())
			{
				
				
				if (reverse && !firstTime && returnValue.start == text.length()
					&& returnValue.end == text.length())
				{
					if (previous != null)
					{
						returnValue.start = previous.start;
						returnValue.end = previous.end;
						returnValue.substitutions = previous.substitutions;
					}
					else
					{
						return null;
					}
				}
				break;
			}
			
			if (previous == null)
			{
				previous = new Match();
			}
			previous.start = returnValue.start;
			previous.end = returnValue.end;
			previous.substitutions = returnValue.substitutions;
		}

		if (reverse)
		{
			
			
			
			int len = returnValue.end - returnValue.start;
			returnValue.start = text.length() - returnValue.end;
			returnValue.end = returnValue.start + len;
		}

		return returnValue;
	} 

	
	@Override
	public String toString()
	{
		boolean ignoreCase = (flags & Pattern.CASE_INSENSITIVE) != 0;
		return ""PatternSearchMatcher["" + pattern + ',' + ignoreCase + ']';
	} 
	
	static int getFlag(boolean ignoreCase)
	{
		int flags = Pattern.MULTILINE;
		if (ignoreCase)
			flags |= Pattern.CASE_INSENSITIVE;
		return flags;
	}

	
	private int flags;
	private Pattern	re;
	private final String pattern;
	
}

"
jEdit,4.3,org.gjt.sp.jedit.io.VFS,43,1,4,52,116,805,40,23,35,0.977513228,962,0.277777778,0,0.0,0.215873016,0,0,20.95348837,7,1.4884,0,"

package org.gjt.sp.jedit.io;


import java.awt.Color;
import java.awt.Component;
import java.io.*;
import java.util.*;

import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.bufferio.BufferLoadRequest;
import org.gjt.sp.jedit.bufferio.BufferSaveRequest;
import org.gjt.sp.jedit.bufferio.BufferInsertRequest;
import org.gjt.sp.jedit.bufferio.BufferIORequest;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.ProgressObserver;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.WorkThread;



public abstract class VFS
{
	

	
	public static final int READ_CAP = 1 << 0;

	
	public static final int WRITE_CAP = 1 << 1;

	
	public static final int BROWSE_CAP = 1 << 2;

	
	public static final int DELETE_CAP = 1 << 3;

	
	public static final int RENAME_CAP = 1 << 4;

	
	public static final int MKDIR_CAP = 1 << 5;

	
	public static final int LOW_LATENCY_CAP = 1 << 6;

	
	public static final int CASE_INSENSITIVE_CAP = 1 << 7;

	

	
	
	public static final String EA_TYPE = ""type"";

	
	public static final String EA_STATUS = ""status"";

	
	public static final String EA_SIZE = ""size"";

	
	public static final String EA_MODIFIED = ""modified"";
	

	public static int IOBUFSIZE = 32678;

	
	
	@Deprecated
	protected VFS(String name)
	{
		this(name,0);
	}

	
	protected VFS(String name, int caps)
	{
		this.name = name;
		this.caps = caps;
		
		this.extAttrs = new String[] { EA_SIZE, EA_TYPE };
	}

	
	protected VFS(String name, int caps, String[] extAttrs)
	{
		this.name = name;
		this.caps = caps;
		this.extAttrs = extAttrs;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public int getCapabilities()
	{
		return caps;
	} 

	
	
	public boolean isMarkersFileSupported()
	{
		return true;
	} 

	
	
	public String[] getExtendedAttributes()
	{
		return extAttrs;
	} 

	
	
	@Deprecated
	public String showBrowseDialog(Object[] session, Component comp)
	{
		return null;
	} 

	
	
	public String getFileName(String path)
	{
		if(path.equals(""/""))
			return path;

		while(path.endsWith(""/"") || path.endsWith(File.separator))
			path = path.substring(0,path.length() - 1);

		int index = Math.max(path.lastIndexOf('/'),
			path.lastIndexOf(File.separatorChar));
		if(index == -1)
			index = path.indexOf(':');

		
		if(index == -1 || index == path.length() - 1)
			return path;

		return path.substring(index + 1);
	} 

	
	
	public String getParentOfPath(String path)
	{
		
		
		int lastIndex = path.length() - 1;
		while(lastIndex > 0
			&& (path.charAt(lastIndex) == File.separatorChar
			|| path.charAt(lastIndex) == '/'))
		{
			lastIndex--;
		}

		int count = Math.max(0,lastIndex);
		int index = path.lastIndexOf(File.separatorChar,count);
		if(index == -1)
			index = path.lastIndexOf('/',count);
		if(index == -1)
		{
			
			
			index = path.lastIndexOf(':');
		}

		return path.substring(0,index + 1);
	} 

	
	
	public String constructPath(String parent, String path)
	{
		return parent + path;
	} 

	
	
	public char getFileSeparator()
	{
		return '/';
	} 

	
	
	public String getTwoStageSaveName(String path)
	{
		return MiscUtilities.constructPath(getParentOfPath(path),
			'#' + getFileName(path) + ""#save#"");
	} 

	
	
	public void reloadDirectory(String path) {} 

	
	
	public Object createVFSSession(String path, Component comp)
	{
		return new Object();
	} 

	
	
	public boolean load(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		if((getCapabilities() & WRITE_CAP) == 0)
			buffer.setReadOnly(true);

		BufferIORequest request = new BufferLoadRequest(
			view,buffer,session,this,path);
		if(buffer.isTemporary())
			
			request.run();
		else
			VFSManager.runInWorkThread(request);

		return true;
	} 

	
	
	public boolean save(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & WRITE_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.save"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		
		if(!path.equals(buffer.getPath()))
			buffer.unsetProperty(Buffer.BACKED_UP);

		VFSManager.runInWorkThread(new BufferSaveRequest(
			view,buffer,session,this,path));
		return true;
	} 

	
	
	public static boolean copy(ProgressObserver progress, VFS sourceVFS, Object sourceSession,String sourcePath,
		VFS targetVFS, Object targetSession,String targetPath, Component comp, boolean canStop)
	throws IOException
	{
		if (progress != null)
			progress.setStatus(""Initializing"");

		InputStream in = null;
		OutputStream out = null;
		try
		{
			VFSFile sourceVFSFile = sourceVFS._getFile(sourceSession, sourcePath, comp);
			if (sourceVFSFile == null)
				throw new FileNotFoundException(sourcePath);
			if (progress != null)
			{
				progress.setMaximum(sourceVFSFile.getLength());
			}
			VFSFile targetVFSFile = targetVFS._getFile(targetSession, targetPath, comp);
			if (targetVFSFile.getType() == VFSFile.DIRECTORY)
			{
				if (targetVFSFile.getPath().equals(sourceVFSFile.getPath()))
					return false;
				targetPath = MiscUtilities.constructPath(targetPath, sourceVFSFile.getName());
			}
			in = new BufferedInputStream(sourceVFS._createInputStream(sourceSession, sourcePath, false, comp));
			out = new BufferedOutputStream(targetVFS._createOutputStream(targetSession, targetPath, comp));
			boolean copyResult = IOUtilities.copyStream(IOBUFSIZE, progress, in, out, canStop);
			VFSManager.sendVFSUpdate(targetVFS, targetPath, true);
			return copyResult;
		}
		finally
		{
			IOUtilities.closeQuietly(in);
			IOUtilities.closeQuietly(out);
		}
	}

	
	public static boolean copy(ProgressObserver progress, String sourcePath,String targetPath, Component comp, boolean canStop)
	throws IOException
	{
		VFS sourceVFS = VFSManager.getVFSForPath(sourcePath);
		Object sourceSession = sourceVFS.createVFSSession(sourcePath, comp);
		if (sourceSession == null)
		{
			Log.log(Log.WARNING, VFS.class, ""Unable to get a valid session from "" + sourceVFS + "" for path "" + sourcePath);
			return false;
		}
		VFS targetVFS = VFSManager.getVFSForPath(targetPath);
		Object targetSession = targetVFS.createVFSSession(targetPath, comp);
		if (targetSession == null)
		{
			Log.log(Log.WARNING, VFS.class, ""Unable to get a valid session from "" + targetVFS + "" for path "" + targetPath);
			return false;
		}
		return copy(progress, sourceVFS, sourceSession, sourcePath, targetVFS, targetSession, targetPath, comp,canStop);
	} 

	
	
	public boolean insert(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		VFSManager.runInWorkThread(new BufferInsertRequest(
			view,buffer,session,this,path));
		return true;
	} 

	

	
	
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return path;
	} 

	
	
	public String[] _listDirectory(Object session, String directory,
		String glob, boolean recursive, Component comp )
		throws IOException
	{
		String[] retval = _listDirectory(session, directory, glob, recursive, comp, true, false);
		return retval;
	} 


	
	
	public String[] _listDirectory(Object session, String directory,
		String glob, boolean recursive, Component comp,
		boolean skipBinary, boolean skipHidden)
		throws IOException
	{
		VFSFileFilter filter = new GlobVFSFileFilter(glob);
		return _listDirectory(session, directory, filter,
				      recursive, comp, skipBinary,
				      skipHidden);
	} 

	
	
	public String[] _listDirectory(Object session, String directory,
		VFSFileFilter filter, boolean recursive, Component comp,
		boolean skipBinary, boolean skipHidden)
		throws IOException
	{
		List<String> files = new ArrayList<String>(100);

		listFiles(session,new HashSet<String>(), files,directory,filter,
			recursive, comp, skipBinary, skipHidden);

		String[] retVal = files.toArray(new String[files.size()]);

		Arrays.sort(retVal,new StandardUtilities.StringCompare<String>(true));

		return retVal;
	} 

	
	
	public VFSFile[] _listFiles(Object session, String directory,
		Component comp)
		throws IOException
	{
		return _listDirectory(session,directory,comp);
	} 

	
	
	@Deprecated
	public DirectoryEntry[] _listDirectory(Object session, String directory,
		Component comp)
		throws IOException
	{
		VFSManager.error(comp,directory,""vfs.not-supported.list"",new String[] { name });
		return null;
	} 

	
	
	public VFSFile _getFile(Object session, String path,
		Component comp)
		throws IOException
	{
		return _getDirectoryEntry(session,path,comp);
	} 

	
	
	@Deprecated
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
		throws IOException
	{
		return null;
	} 

	
	
	@Deprecated
	public static class DirectoryEntry extends VFSFile
	{
		
		
		public DirectoryEntry()
		{
		} 

		
		public DirectoryEntry(String name, String path, String deletePath,
			int type, long length, boolean hidden)
		{
			this.name = name;
			this.path = path;
			this.deletePath = deletePath;
			this.symlinkPath = path;
			this.type = type;
			this.length = length;
			this.hidden = hidden;
			if(path != null)
			{
				
				VFS vfs = VFSManager.getVFSForPath(path);
				canRead = ((vfs.getCapabilities() & READ_CAP) != 0);
				canWrite = ((vfs.getCapabilities() & WRITE_CAP) != 0);
			}
		} 
	} 

	
	
	public boolean _delete(Object session, String path, Component comp)
		throws IOException
	{
		return false;
	} 

	
	
	public boolean _rename(Object session, String from, String to,
		Component comp) throws IOException
	{
		return false;
	} 

	
	
	public boolean _mkdir(Object session, String directory, Component comp)
		throws IOException
	{
		return false;
	} 

	
	
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
	} 

	
	
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.load"",new String[] { name });
		return null;
	} 

	
	
	public OutputStream _createOutputStream(Object session,
		String path, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.save"",new String[] { name });
		return null;
	} 

	
	
	public void _saveComplete(Object session, Buffer buffer, String path,
		Component comp) throws IOException {} 

	
	
	public void _finishTwoStageSave(Object session, Buffer buffer, String path,
		Component comp) throws IOException
	{
	} 

	
	
	public void _endVFSSession(Object session, Component comp)
		throws IOException
	{
	} 

	
	
	public static Color getDefaultColorFor(String name)
	{
		synchronized(lock)
		{
			if(colors == null)
				loadColors();

			for(int i = 0; i < colors.size(); i++)
			{
				ColorEntry entry = colors.get(i);
				if(entry.re.matcher(name).matches())
					return entry.color;
			}

			return null;
		}
	} 

	
	
	public static class DirectoryEntryCompare implements Comparator<VFSFile>
	{
		private boolean sortIgnoreCase, sortMixFilesAndDirs;

		
		public DirectoryEntryCompare(boolean sortMixFilesAndDirs,
			boolean sortIgnoreCase)
		{
			this.sortMixFilesAndDirs = sortMixFilesAndDirs;
			this.sortIgnoreCase = sortIgnoreCase;
		}

		public int compare(VFSFile file1, VFSFile file2)
		{
			if(!sortMixFilesAndDirs)
			{
				if(file1.getType() != file2.getType())
					return file2.getType() - file1.getType();
			}

			return StandardUtilities.compareStrings(file1.getName(),
				file2.getName(),sortIgnoreCase);
		}
	} 

	
	private String name;
	private int caps;
	private String[] extAttrs;
	private static List<ColorEntry> colors;
	private static final Object lock = new Object();

	
	static
	{
		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof PropertiesChanged)
				{
					synchronized(lock)
					{
						colors = null;
					}
				}
			}
		});
	} 

	
	private void listFiles(Object session, Collection<String> stack,
		List<String> files, String directory, VFSFileFilter filter, boolean recursive,
		Component comp, boolean skipBinary, boolean skipHidden) throws IOException
	{
		String resolvedPath = directory;
		if (recursive && !MiscUtilities.isURL(directory))
		{
			resolvedPath = MiscUtilities.resolveSymlinks(directory);
			
			if (!directory.equals(resolvedPath))
			{
				if (stack.contains(resolvedPath))
				{
					Log.log(Log.ERROR,this,
						""Recursion in listFiles(): ""
						+ directory);
					return;
				}
				stack.add(resolvedPath);
			}
		}

		Thread ct = Thread.currentThread();
		WorkThread wt = null;
		if (ct instanceof WorkThread) {
			wt = (WorkThread) ct;
		}


		VFSFile[] _files = _listFiles(session,directory,
			comp);
		if(_files == null || _files.length == 0)
			return;

		for(int i = 0; i < _files.length; i++)
		{
			if (wt != null && wt.isAborted()) break;
			VFSFile file = _files[i];
			if (skipHidden && (file.isHidden() || MiscUtilities.isBackup(file.getName())))
				continue;
			if(!filter.accept(file))
				continue;
			if(file.getType() == VFSFile.DIRECTORY
				|| file.getType() == VFSFile.FILESYSTEM)
			{
				if(recursive)
				{
					String canonPath = _canonPath(session,
						file.getPath(),comp);
					listFiles(session,stack,files,
						canonPath,filter,recursive,
						comp, skipBinary, skipHidden);
				}
			}
			else 
			{
				if (skipBinary)
				{
					try
					{
						if (file.isBinary(session))
						{
							Log.log(Log.NOTICE,this
								,file.getPath() + "": skipped as a binary file"");
							continue;
						}
					}
					catch(IOException e)
					{
						Log.log(Log.ERROR,this,e);
						
					}
				}
				files.add(file.getPath());
			}
		}
	} 

	
	private static void loadColors()
	{
		synchronized(lock)
		{
			colors = new ArrayList<ColorEntry>();

			if(!jEdit.getBooleanProperty(""vfs.browser.colorize""))
				return;

			String glob;
			int i = 0;
			while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
			{
				try
				{
					colors.add(new ColorEntry(
						Pattern.compile(StandardUtilities.globToRE(glob)),
						jEdit.getColorProperty(
						""vfs.browser.colors."" + i + "".color"",
						Color.black)));
				}
				catch(PatternSyntaxException e)
				{
					Log.log(Log.ERROR,VFS.class,""Invalid regular expression: ""
						+ glob);
					Log.log(Log.ERROR,VFS.class,e);
				}

				i++;
			}
		}
	} 

	
	private static class ColorEntry
	{
		Pattern re;
		Color color;

		ColorEntry(Pattern re, Color color)
		{
			this.re = re;
			this.color = color;
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.SquareFoldPainter,2,2,0,1,4,1,0,1,1,2.0,14,0.0,0,0.8,0.666666667,1,1,6.0,1,0.5,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;


public class SquareFoldPainter extends ShapedFoldPainter
{
	@Override
	protected void paintFoldShape(Graphics2D gfx, int top, int bottom)
	{
		gfx.drawRect(1,top,8,(bottom-top));
	}

} 
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Token,3,1,0,4,4,3,4,0,3,1.4375,23,0.0,2,0.0,0.5,0,0,4.0,2,1.0,0,"
package org.gjt.sp.jedit.bsh;




	
public class Token implements java.io.Serializable {
	

  
  public int kind;

  
  public int beginLine, beginColumn, endLine, endColumn;

  
  public String image;

  
  public Token next;

  
  public Token specialToken;

  
  public String toString()
  {
     return image;
  }

  
  public static final Token newToken(int ofKind)
  {
     switch(ofKind)
     {
       default : return new Token();
     }
  }

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ListModelEditor,4,1,0,3,22,6,2,2,2,2.0,105,0.0,0,0.0,0.666666667,0,0,25.25,4,2.0,0,"package org.gjt.sp.jedit.gui;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.table.DefaultTableModel;

import org.gjt.sp.jedit.jEdit;

public class ListModelEditor
{

	public void open(DefaultListModel listModel)
	{
		final DefaultTableModel tableModel = createTableModel(listModel);
		final JTable table = new JTable(tableModel);
		table
		    .setToolTipText(""Move: PgUp/PgDown; Edit: Double-Click or Insert/Delete"");

		table.addKeyListener(new KeyAdapter()
		{
			public void keyPressed(KeyEvent e)
			{
				int[] selRows = table.getSelectedRows();
				if (selRows.length == 0)
				{
					return;
				}
				int firstSelectedRow = selRows[0];
				int key = e.getKeyCode();
				ListSelectionModel selectionModel = table.getSelectionModel();
				switch (key)
				{
					case KeyEvent.VK_DELETE:
						for (int i = selRows.length - 1; i >= 0; i--)
						{
							tableModel.removeRow(selRows[i]);
						}
						if (firstSelectedRow >= 0
						    && firstSelectedRow < tableModel.getRowCount())
						{
							selectionModel.addSelectionInterval(firstSelectedRow,
							    firstSelectedRow);
						}
						e.consume();
						break;
					case KeyEvent.VK_INSERT:
						tableModel.insertRow(firstSelectedRow + 1, new String[] { """" });
						e.consume(); 
						break;
					case KeyEvent.VK_PAGE_UP:
					case KeyEvent.VK_PAGE_DOWN:
						boolean isUp = key == KeyEvent.VK_PAGE_UP;
						int direction = isUp ? -1 : 1;
						int min = selectionModel.getMinSelectionIndex() + direction;
						int max = selectionModel.getMaxSelectionIndex() + direction;
						if (min < 0 || max >= tableModel.getRowCount())
						{
							return; 
						}
						for (int i = 0; i < selRows.length; i++)
						{
							int row = selRows[isUp ? i : (selRows.length - 1 - i)];
							int to = row + direction;
							selectionModel.removeSelectionInterval(row, row);
							selectionModel.addSelectionInterval(to, to);
							tableModel.moveRow(row, row, to);
						}
						break;
				}
			}
		});
		int result = JOptionPane.showConfirmDialog(null, table, ""Change ""
		    + jEdit.getProperty(""history.caption""), JOptionPane.OK_CANCEL_OPTION);
		if (result == JOptionPane.OK_OPTION)
		{
			updatelistModel(listModel, tableModel);
		}
	}

	private DefaultTableModel createTableModel(DefaultListModel listModel)
	{
		Object[][] tableRowData = new String[listModel.size()][1];
		for (int i = 0; i < listModel.size(); i++)
		{
			tableRowData[i][0] = listModel.get(i);
		}
		return new DefaultTableModel(tableRowData, new String[] { """" });
	}

	private void updatelistModel(DefaultListModel listModel,
	    DefaultTableModel tableModel)
	{
		listModel.removeAllElements();
		for (int i = 0; i < tableModel.getRowCount(); i++)
		{
			Object cellText = tableModel.getValueAt(i, 0);
			if (cellText != null && !cellText.equals(""""))
			{
				listModel.addElement(cellText);
			}
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.LineManager,17,1,0,5,27,10,1,4,15,0.6796875,709,1.0,1,0.0,0.388235294,0,0,40.23529412,17,3.5294,0,"

package org.gjt.sp.jedit.buffer;


import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.Log;



public class LineManager
{
	
	public LineManager()
	{
		endOffsets = new int[1];
		endOffsets[0] = 1;
		foldLevels = new short[1];
		lineContext = new TokenMarker.LineContext[1];
		lineCount = 1;
	} 

	
	public final int getLineCount()
	{
		return lineCount;
	} 

	
	public int getLineOfOffset(int offset)
	{
		int start = 0;
		int end = lineCount - 1;

		for(;;)
		{
			switch(end - start)
			{
			case 0:
				if(getLineEndOffset(start) <= offset)
					return start + 1;
				else
					return start;
			case 1:
				if(getLineEndOffset(start) <= offset)
				{
					if(getLineEndOffset(end) <= offset)
						return end + 1;
					else
						return end;
				}
				else
					return start;
			default:
				int pivot = (end + start) / 2;
				int value = getLineEndOffset(pivot);
				if(value == offset)
					return pivot + 1;
				else if(value < offset)
					start = pivot + 1;
				else
					end = pivot - 1;
				break;
			}
		}
	} 

	
	public final int getLineEndOffset(int line)
	{
		if(gapLine != -1 && line >= gapLine)
			return endOffsets[line] + gapWidth;
		else
			return endOffsets[line];
	} 

	
	public final int getFoldLevel(int line)
	{
		return foldLevels[line];
	} 

	
	
	public final void setFoldLevel(int line, int level)
	{
		if(level > 0xffff)
		{
			
			level = 0xffff;
		}

		foldLevels[line] = (short)level;
	} 

	
	public void setFirstInvalidFoldLevel(int firstInvalidFoldLevel)
	{
		this.firstInvalidFoldLevel = firstInvalidFoldLevel;
	} 

	
	public int getFirstInvalidFoldLevel()
	{
		return firstInvalidFoldLevel;
	} 

	
	public final TokenMarker.LineContext getLineContext(int line)
	{
		return lineContext[line];
	} 

	
	public final void setLineContext(int line, TokenMarker.LineContext context)
	{
		lineContext[line] = context;
	} 

	
	public void setFirstInvalidLineContext(int firstInvalidLineContext)
	{
		this.firstInvalidLineContext = firstInvalidLineContext;
	} 

	
	public int getFirstInvalidLineContext()
	{
		return firstInvalidLineContext;
	} 

	
	public void _contentInserted(IntegerArray endOffsets)
	{
		gapLine = -1;
		gapWidth = 0;
		firstInvalidLineContext = firstInvalidFoldLevel = 0;
		lineCount = endOffsets.getSize();
		this.endOffsets = endOffsets.getArray();
		foldLevels = new short[lineCount];

		lineContext = new TokenMarker.LineContext[lineCount];
	} 

	
	public void contentInserted(int startLine, int offset,
		int numLines, int length, IntegerArray endOffsets)
	{
		int endLine = startLine + numLines;

		
		if(numLines > 0)
		{
			

			lineCount += numLines;

			if(this.endOffsets.length <= lineCount)
			{
				int[] endOffsetsN = new int[(lineCount + 1) * 2];
				System.arraycopy(this.endOffsets,0,endOffsetsN,0,
						 this.endOffsets.length);
				this.endOffsets = endOffsetsN;
			}

			if(foldLevels.length <= lineCount)
			{
				short[] foldLevelsN = new short[(lineCount + 1) * 2];
				System.arraycopy(foldLevels,0,foldLevelsN,0,
						 foldLevels.length);
				foldLevels = foldLevelsN;
			}

			if(lineContext.length <= lineCount)
			{
				TokenMarker.LineContext[] lineContextN
					= new TokenMarker.LineContext[(lineCount + 1) * 2];
				System.arraycopy(lineContext,0,lineContextN,0,
						 lineContext.length);
				lineContext = lineContextN;
			}

			System.arraycopy(this.endOffsets,startLine,
				this.endOffsets,endLine,lineCount - endLine);
			System.arraycopy(foldLevels,startLine,foldLevels,
				endLine,lineCount - endLine);
			System.arraycopy(lineContext,startLine,lineContext,
				endLine,lineCount - endLine);

			if(startLine <= gapLine)
				gapLine += numLines;
			else if(gapLine != -1)
				offset -= gapWidth;

			if(startLine < firstInvalidLineContext)
				firstInvalidLineContext += numLines;

			for(int i = 0; i < numLines; i++)
			{
				this.endOffsets[startLine + i] = (offset + endOffsets.get(i));
				foldLevels[startLine + i] = 0;
			}
		} 

		if(firstInvalidFoldLevel == -1 || firstInvalidFoldLevel > startLine)
			firstInvalidFoldLevel = startLine;
		moveGap(endLine,length,""contentInserted"");
	} 

	
	public void contentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		int endLine = startLine + numLines;

		
		if(numLines > 0)
		{
			

			if(startLine + numLines < gapLine)
				gapLine -= numLines;
			else if(startLine < gapLine)
				gapLine = startLine;

			if(startLine + numLines < firstInvalidLineContext)
				firstInvalidLineContext -= numLines;
			else if(startLine < firstInvalidLineContext)
				firstInvalidLineContext = startLine - 1;

			lineCount -= numLines;

			System.arraycopy(endOffsets,endLine,endOffsets,
				startLine,lineCount - startLine);
			System.arraycopy(foldLevels,endLine,foldLevels,
				startLine,lineCount - startLine);
			System.arraycopy(lineContext,endLine,lineContext,
				startLine,lineCount - startLine);
		} 

		if(firstInvalidFoldLevel == -1 || firstInvalidFoldLevel > startLine)
			firstInvalidFoldLevel = startLine;
		moveGap(startLine,-length,""contentRemoved"");
	} 

	

	
	private int[] endOffsets;
	private short[] foldLevels;
	private TokenMarker.LineContext[] lineContext;

	private int lineCount;

	
	private int gapLine;
	private int gapWidth;

	
	private int firstInvalidLineContext;

	
	private int firstInvalidFoldLevel;
	

	
	private final void setLineEndOffset(int line, int end)
	{
		endOffsets[line] = end;
	} 

	
	private final void moveGap(int newGapLine, int newGapWidth, String method)
	{
		if(gapLine == -1)
			gapWidth = newGapWidth;
		else if(newGapLine == -1)
		{
			if(gapWidth != 0)
			{
				if(Debug.OFFSET_DEBUG && gapLine != lineCount)
					Log.log(Log.DEBUG,this,method + "": update from "" + gapLine + "" to "" + lineCount + "" width "" + gapWidth);
				for(int i = gapLine; i < lineCount; i++)
					setLineEndOffset(i,getLineEndOffset(i));
			}

			gapWidth = newGapWidth;
		}
		else if(newGapLine < gapLine)
		{
			if(gapWidth != 0)
			{
				if(Debug.OFFSET_DEBUG && newGapLine != gapLine)
					Log.log(Log.DEBUG,this,method + "": update from "" + newGapLine + "" to "" + gapLine + "" width "" + gapWidth);
				for(int i = newGapLine; i < gapLine; i++)
					setLineEndOffset(i,getLineEndOffset(i) - gapWidth);
			}
			gapWidth += newGapWidth;
		}
		else 
		{
			if(gapWidth != 0)
			{
				if(Debug.OFFSET_DEBUG && gapLine != newGapLine)
					Log.log(Log.DEBUG,this,method + "": update from "" + gapLine + "" to "" + newGapLine + "" width "" + gapWidth);
				for(int i = gapLine; i < newGapLine; i++)
					setLineEndOffset(i,getLineEndOffset(i));
			}

			gapWidth += newGapWidth;
		}

		if(newGapLine == lineCount)
			gapLine = -1;
		else
			gapLine = newGapLine;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.PositionManager,6,1,0,3,20,0,3,3,4,0.6,120,0.666666667,1,0.0,0.416666667,0,0,18.5,3,1.6667,0,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.Position;
import java.util.*;
import org.gjt.sp.util.Log;



public class PositionManager
{
	
	public PositionManager(JEditBuffer buffer)
	{
		this.buffer = buffer;
	} 
	
	
	public synchronized Position createPosition(int offset)
	{
		PosBottomHalf bh = new PosBottomHalf(offset);
		PosBottomHalf existing = positions.get(bh);
		if(existing == null)
		{
			positions.put(bh,bh);
			existing = bh;
		}

		return new PosTopHalf(existing);
	} 

	
	public synchronized void contentInserted(int offset, int length)
	{
		if(positions.isEmpty())
			return;

		
		Iterator<PosBottomHalf> iter = positions.tailMap(new PosBottomHalf(offset))
			.keySet().iterator();

		iteration = true;
		while(iter.hasNext())
		{
			iter.next().contentInserted(offset,length);
		}
		iteration = false;
	} 

	
	public synchronized void contentRemoved(int offset, int length)
	{
		if(positions.isEmpty())
			return;

		
		Iterator<PosBottomHalf> iter = positions.tailMap(new PosBottomHalf(offset))
			.keySet().iterator();

		iteration = true;
		while(iter.hasNext())
		{
			iter.next().contentRemoved(offset,length);
		}
		iteration = false;

	} 

	boolean iteration;

	
	private JEditBuffer buffer;
	private SortedMap<PosBottomHalf, PosBottomHalf> positions = new TreeMap<PosBottomHalf, PosBottomHalf>();
	

	

	
	class PosTopHalf implements Position
	{
		final PosBottomHalf bh;

		
		PosTopHalf(PosBottomHalf bh)
		{
			this.bh = bh;
			bh.ref();
		} 

		
		public int getOffset()
		{
			return bh.offset;
		} 

		
		@Override
		protected void finalize()
		{
			synchronized(PositionManager.this)
			{
				bh.unref();
			}
		} 
	} 

	
	class PosBottomHalf implements Comparable<PosBottomHalf>
	{
		int offset;
		int ref;

		
		PosBottomHalf(int offset)
		{
			this.offset = offset;
		} 

		
		void ref()
		{
			ref++;
		} 

		
		void unref()
		{
			if(--ref == 0)
				positions.remove(this);
		} 

		
		void contentInserted(int offset, int length)
		{
			if(offset > this.offset)
				throw new ArrayIndexOutOfBoundsException();
			this.offset += length;
			checkInvariants();
		} 

		
		void contentRemoved(int offset, int length)
		{
			if(offset > this.offset)
				throw new ArrayIndexOutOfBoundsException();
			if(this.offset <= offset + length)
				this.offset = offset;
			else
				this.offset -= length;
			checkInvariants();
		} 

		
		@Override
		public boolean equals(Object o)
		{
			if(!(o instanceof PosBottomHalf))
				return false;

			return ((PosBottomHalf)o).offset == offset;
		} 

		
		public int compareTo(PosBottomHalf posBottomHalf)
		{
			if(iteration)
				Log.log(Log.ERROR,this,""Consistency failure"");
			return offset - posBottomHalf.offset;
		} 
		
		
		private void checkInvariants()
		{
			if(offset < 0 || offset > buffer.getLength())
				throw new ArrayIndexOutOfBoundsException();
		} 
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.NameSpace,75,1,2,58,156,2419,46,20,49,0.912483912,1888,0.666666667,5,0.0,0.106821107,0,0,23.89333333,6,1.72,0,"


package org.gjt.sp.jedit.bsh;

import java.util.*;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;

import java.lang.reflect.Method;
import java.lang.reflect.Field;



public class NameSpace
    implements java.io.Serializable, BshClassManager.Listener,
    NameSource
{
    public static final NameSpace JAVACODE =
        new NameSpace((BshClassManager)null, ""Called from compiled Java code."");
    static {
        JAVACODE.isMethod = true;
    }

    
    

    
    private String nsName;
    private NameSpace parent;
    private Hashtable variables;
    private Hashtable methods;

    protected Hashtable importedClasses;
    private Vector importedPackages;
    private Vector importedCommands;
    private Vector importedObjects;
    private Vector importedStatic;
    private String packageName;

    transient private BshClassManager classManager;

    
    private This thisReference;

    
    private Hashtable names;

    
    SimpleNode callerInfoNode;

    
    boolean isMethod;
    
    
    boolean isClass;
    Class classStatic;
    Object classInstance;

    void setClassStatic( Class clas ) {
        this.classStatic = clas;
        importStatic( clas );
    }
    void setClassInstance( Object instance ) {
        this.classInstance = instance;
        importObject( instance );
    }
    Object getClassInstance()
        throws UtilEvalError
    {
        if ( classInstance != null )
            return classInstance;

        if ( classStatic != null
            
        )
            throw new UtilEvalError(
                ""Can't refer to class instance from static context."");
        else
            throw new InterpreterError(
                ""Can't resolve class instance 'this' in: ""+this);
    }


    
    transient private Hashtable classCache;

    

    

    
    public NameSpace( NameSpace parent, String name )
    {
        
        this( parent, null, name );
    }

    public NameSpace( BshClassManager classManager, String name )
    {
        this( null, classManager, name );
    }

    public NameSpace(
        NameSpace parent, BshClassManager classManager, String name )
    {
        
        
        
            

        setName(name);
        setParent(parent);
        setClassManager( classManager );

        
        if ( classManager != null )
            classManager.addListener(this);
    }

    

    public void setName( String name ) {
        this.nsName = name;
    }

    
    public String getName() {
        return this.nsName;
    }

    
    void setNode( SimpleNode node ) {
        callerInfoNode = node;
    }

    
    SimpleNode getNode()
    {
        if ( callerInfoNode != null )
            return callerInfoNode;
        if ( parent != null )
            return parent.getNode();
        else
            return null;
    }

    
    public Object get( String name, Interpreter interpreter )
        throws UtilEvalError
    {
        CallStack callstack = new CallStack( this );
        return getNameResolver( name ).toObject( callstack, interpreter );
    }

    
    public void	setVariable( String name, Object value, boolean strictJava )
        throws UtilEvalError
    {
        
        boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;
        setVariable( name, value, strictJava, recurse );
    }

    
    void setLocalVariable(
        String name, Object value, boolean strictJava )
        throws UtilEvalError
    {
        setVariable( name, value, strictJava, false );
    }

    
    void setVariable(
        String name, Object value, boolean strictJava, boolean recurse )
        throws UtilEvalError
    {
        if ( variables == null )
            variables =	new Hashtable();

        
        
        
        

        if ( value == null ) {
            
            unsetVariable(name);
            return;
        }

        
        
        Variable existing = getVariableImpl( name, recurse );

        
        if ( existing != null )
        {
            try {
                existing.setValue( value, Variable.ASSIGNMENT );
            } catch ( UtilEvalError e ) {
                throw new UtilEvalError(
                    ""Variable assignment: "" + name + "": "" + e.getMessage());
            }
        } else
        
        {
            if ( strictJava )
                throw new UtilEvalError(
                    ""(Strict Java mode) Assignment to undeclared variable: ""
                    +name );

            
            
            
            NameSpace varScope = this;

            varScope.variables.put(
                name, new Variable( name, value, null ) );

            
            nameSpaceChanged();
        }
    }

    
    public void unsetVariable( String name )
    {
        if ( variables != null )
        {
            variables.remove( name );
            nameSpaceChanged();
        }
    }

    
    public String [] getVariableNames() {
        if ( variables == null )
            return new String [0];
        else
            return enumerationToStringArray( variables.keys() );
    }

    
    public String [] getMethodNames()
    {
        if ( methods == null )
            return new String [0];
        else
            return enumerationToStringArray( methods.keys() );
    }

    
    public BshMethod [] getMethods()
    {
        if ( methods == null )
            return new BshMethod [0];
        else
            return flattenMethodCollection( methods.elements() );
    }

    private String [] enumerationToStringArray( Enumeration e ) {
        Vector v = new Vector();
        while ( e.hasMoreElements() )
            v.addElement( e.nextElement() );
        String [] sa = new String [ v.size() ];
        v.copyInto( sa );
        return sa;
    }

    
    private BshMethod [] flattenMethodCollection( Enumeration e ) {
        Vector v = new Vector();
        while ( e.hasMoreElements() ) {
            Object o = e.nextElement();
            if ( o instanceof BshMethod )
                v.addElement( o );
            else {
                Vector ov = (Vector)o;
                for(int i=0; i<ov.size(); i++)
                    v.addElement( ov.elementAt( i ) );
            }
        }
        BshMethod [] bma = new BshMethod [ v.size() ];
        v.copyInto( bma );
        return bma;
    }

    
    public NameSpace getParent() {
        return parent;
    }

    
    public This getSuper( Interpreter declaringInterpreter )
    {
        if ( parent != null )
            return parent.getThis( declaringInterpreter );
        else
            return getThis( declaringInterpreter );
    }

    
    public This getGlobal( Interpreter declaringInterpreter )
    {
        if ( parent != null )
            return parent.getGlobal( declaringInterpreter );
        else
            return getThis( declaringInterpreter );
    }


    
    
    This getThis( Interpreter declaringInterpreter )
    {
        if ( thisReference == null )
            thisReference = This.getThis( this, declaringInterpreter );

        return thisReference;
    }

    public BshClassManager getClassManager()
    {
        if ( classManager != null )
            return classManager;
        if ( parent != null && parent != JAVACODE )
            return parent.getClassManager();

System.out.println(""experiment: creating class manager"");
        classManager = BshClassManager.createClassManager( null );

        
        return classManager;
    }

    void setClassManager( BshClassManager classManager ) {
        this.classManager = classManager;
    }

    
    public void prune()
    {
        
        
        
        

        if ( this.classManager == null )


            setClassManager(
                BshClassManager.createClassManager( null ) );

        setParent( null );
    }

    public void setParent( NameSpace parent )
    {
        this.parent = parent;

        
        if ( parent == null )
            loadDefaultImports();
    }

    
    public Object getVariable( String name )
        throws UtilEvalError
    {
        return getVariable( name, true );
    }

    
    public Object getVariable( String name, boolean recurse )
        throws UtilEvalError
    {
        Variable var = getVariableImpl( name, recurse );
        return unwrapVariable( var );
    }

    
    protected Variable getVariableImpl( String name, boolean recurse )
        throws UtilEvalError
    {
        Variable var = null;

        
        
        if ( var == null && isClass )
            var = getImportedVar( name );

        if ( var == null && variables != null )
            var	= (Variable)variables.get(name);

        
        if ( var == null && !isClass )
            var = getImportedVar( name );

        
        if ( recurse && (var == null) && (parent != null) )
            var	= parent.getVariableImpl( name, recurse );

        return var;
    }

    
    public Variable [] getDeclaredVariables()
    {
        if ( variables == null )
            return new Variable[0];
        Variable [] vars = new Variable [ variables.size() ];
        int i=0;
        for( Enumeration e = variables.elements(); e.hasMoreElements(); )
            vars[i++] = (Variable)e.nextElement();
        return vars;
    }

    
    protected Object unwrapVariable( Variable var )
        throws UtilEvalError
    {
        return (var == null) ? Primitive.VOID :	var.getValue();
    }

    
    public void	setTypedVariable(
        String	name, Class type, Object value,	boolean	isFinal )
        throws UtilEvalError
    {
        Modifiers modifiers = new Modifiers();
        if ( isFinal )
            modifiers.addModifier( Modifiers.FIELD, ""final"" );
        setTypedVariable( name, type, value, modifiers );
    }

    
    public void	setTypedVariable(
        String	name, Class type, Object value,	Modifiers modifiers )
        throws UtilEvalError
    {
        

        if ( variables == null )
            variables =	new Hashtable();

        
        Variable existing = getVariableImpl( name, false );


        
        
    

        
        if ( existing != null )
        {
            
            if ( existing.getType() != null )
            {
                
                
                
                if ( existing.getType() != type )
                {
                    throw new UtilEvalError( ""Typed variable: ""+name
                        +"" was previously declared with type: ""
                        + existing.getType() );
                } else
                {
                    
                    existing.setValue( value, Variable.DECLARATION );
                    return;
                }
            }
            
            
        }

        
        variables.put( name, new Variable( name, type, value, modifiers ) );
    }

    

    
    public void	setMethod( String name, BshMethod method )
        throws UtilEvalError
    {
        

        if ( methods == null )
            methods = new Hashtable();

        Object m = methods.get(name);

        
        if (m == null)
            methods.put(name, method);
        else if (m instanceof BshMethod)
        {
            
            if (Arrays.equals(((BshMethod)m).getParameterTypes(),
                              method.getParameterTypes()))
            {
                methods.put(name, method);
            }
            else
            {
                Vector v = new Vector();
                v.addElement( m );
                v.addElement( method );
                methods.put( name, v );
            }
        }
        else
        {
            Vector _methods = (Vector) m;
            for (int i = 0; i < _methods.size(); i++)
            {
                
                
                BshMethod _old_m = (BshMethod) _methods.get(i);
                if (Arrays.equals(_old_m.getParameterTypes(),
                                  method.getParameterTypes()))
                {
                    _methods.remove(i);
                    break;
                }
            }
            _methods.addElement( method );
        }
        

        
        
        
        
        
        
        
        
        
        
        
        
    }

    
    public BshMethod getMethod( String name, Class [] sig )
        throws UtilEvalError
    {
        return getMethod( name, sig, false );
    }

    
    public BshMethod getMethod(
        String name, Class [] sig, boolean declaredOnly )
        throws UtilEvalError
    {
        BshMethod method = null;

        
        
        if ( method == null && isClass && !declaredOnly )
            method = getImportedMethod( name, sig );

        Object m = null;
        if ( method == null && methods != null )
        {
            m = methods.get(name);

            
            if ( m != null )
            {
                
                BshMethod [] ma;
                if ( m instanceof Vector )
                {
                    Vector vm = (Vector)m;
                    ma = new BshMethod[ vm.size() ];
                    vm.copyInto( ma );
                } else
                    ma = new BshMethod[] { (BshMethod)m };

                
                Class [][] candidates = new Class[ ma.length ][];
                for( int i=0; i< ma.length; i++ )
                    candidates[i] = ma[i].getParameterTypes();

                int match =
                    Reflect.findMostSpecificSignature( sig, candidates );
                if ( match != -1 )
                    method = ma[match];
            }
        }

        if ( method == null && !isClass && !declaredOnly )
            method = getImportedMethod( name, sig );

        
        if ( !declaredOnly && (method == null) && (parent != null) )
            return parent.getMethod( name, sig );

        return method;
    }

    
    public void	importClass(String name)
    {
        if ( importedClasses == null )
            importedClasses = new Hashtable();

        importedClasses.put( Name.suffix(name, 1), name );
        nameSpaceChanged();
    }

    
    public void	importPackage(String name)
    {
        if(importedPackages == null)
            importedPackages = new Vector();

        
        if ( importedPackages.contains( name ) )
            importedPackages.remove( name );

        importedPackages.addElement(name);
        nameSpaceChanged();
    }

    
    public void	importCommands( String name )
    {
        if ( importedCommands == null )
            importedCommands = new Vector();

        
        name = name.replace('.','/');
        
        if ( !name.startsWith(""/"") )
            name = ""/""+name;
        
        if ( name.length() > 1 && name.endsWith(""/"") )
            name = name.substring( 0, name.length()-1 );

        
        if ( importedCommands.contains( name ) )
            importedCommands.remove( name );

        importedCommands.addElement(name);
        nameSpaceChanged();
    }

    
    
    public Object getCommand(
        String name, Class [] argTypes, Interpreter interpreter )
        throws UtilEvalError
    {
        if (Interpreter.DEBUG) Interpreter.debug(""getCommand: ""+name);
        BshClassManager bcm = interpreter.getClassManager();

        InputStream in = getCommand( name );

        if ( in != null )
            return loadScriptedCommand(
                in, name, argTypes, name, interpreter );

        

        if ( parent != null )
            return parent.getCommand( name, argTypes, interpreter );
        else
            return null;
    }


    
    
    protected BshMethod getImportedMethod( String name, Class [] sig )
        throws UtilEvalError
    {
        
        if ( importedObjects != null )
        for(int i=0; i<importedObjects.size(); i++)
        {
            Object object = importedObjects.elementAt(i);
            Class clas = object.getClass();
            Method method = Reflect.resolveJavaMethod(
                getClassManager(), clas, name, sig, false );
            if ( method != null )
                return new BshMethod( method, object );
        }

        
        if ( importedStatic!= null )
        for(int i=0; i<importedStatic.size(); i++)
        {
            Class clas = (Class)importedStatic.elementAt(i);
            Method method = Reflect.resolveJavaMethod(
                getClassManager(), clas, name, sig, true );
            if ( method != null )
                return new BshMethod( method, null );
        }

        return null;
    }

    protected Variable getImportedVar( String name )
        throws UtilEvalError
    {
        
        if ( importedObjects != null )
        for(int i=0; i<importedObjects.size(); i++)
        {
            Object object = importedObjects.elementAt(i);
            Class clas = object.getClass();
            Field field = Reflect.resolveJavaField(
                clas, name, false );
            if ( field != null )
                return new Variable(
                    name, field.getType(), new LHS( object, field ) );
        }

        
        if ( importedStatic!= null )
        for(int i=0; i<importedStatic.size(); i++)
        {
            Class clas = (Class)importedStatic.elementAt(i);
            Field field = Reflect.resolveJavaField(
                clas, name, true );
            if ( field != null )
                return new Variable( name, field.getType(), new LHS( field ) );
        }

        return null;
    }

    
    
    private BshMethod loadScriptedCommand(
        InputStream in, String name, Class [] argTypes, String resourcePath,
        Interpreter interpreter )
        throws UtilEvalError
    {
        try {
            interpreter.eval(
                new InputStreamReader(in), this, resourcePath );
        } catch ( EvalError e ) {
        
            Interpreter.debug( e.toString() );
            throw new UtilEvalError(
                ""Error loading script: ""+ e.getMessage());
        }

        
        BshMethod meth = getMethod( name, argTypes );
        

        return meth;
    }

    
    void cacheClass( String name, Class c ) {
        if ( classCache == null ) {
            classCache = new Hashtable();
            
        }

        classCache.put(name, c);
    }

    
    public Class getClass( String name )
        throws UtilEvalError
    {
        Class c = getClassImpl(name);
        if ( c != null )
            return c;
        else
            
            if ( parent != null )
                return parent.getClass( name );
            else
                return null;
    }

    
    private Class getClassImpl( String name )
        throws UtilEvalError
    {
        Class c = null;

        
        if (classCache != null) {
            c =	(Class)classCache.get(name);

            if ( c != null )
                return c;
        }

        
        boolean unqualifiedName = !Name.isCompound(name);

        
        if ( unqualifiedName )
        {
            
            if ( c == null )
                c = getImportedClassImpl( name );

            
            if ( c != null ) {
                cacheClass( name, c );
                return c;
            }
        }

        
        c = classForName( name );
        if ( c != null ) {
            
            if ( unqualifiedName )
                cacheClass( name, c );
            return c;
        }

        
        if ( Interpreter.DEBUG )
            Interpreter.debug(""getClass(): "" + name	+ "" not	found in ""+this);
        return null;
    }

    
    private Class getImportedClassImpl( String name )
        throws UtilEvalError
    {
        
        String fullname = null;
        if ( importedClasses != null )
            fullname = (String)importedClasses.get(name);

        
        

        if ( fullname != null )
        {
            
            
            Class clas=classForName(fullname);

            
            if ( clas == null )
            {
                
                
                

                if ( Name.isCompound( fullname ) )
                    try {
                        clas = getNameResolver( fullname ).toClass();
                    } catch ( ClassNotFoundException e ) {  }
                else
                    if ( Interpreter.DEBUG ) Interpreter.debug(
                        ""imported unpackaged name not found:"" +fullname);

                
                if ( clas != null ) {
                    
                    getClassManager().cacheClassInfo( fullname, clas );
                    return clas;
                }
            } else
                return clas;

            
            
            return null;
        }

        
        if ( importedPackages != null )
            for(int i=importedPackages.size()-1; i>=0; i--)
            {
                String s = ((String)importedPackages.elementAt(i)) + ""."" + name;
                Class c=classForName(s);
                if ( c != null )
                    return c;
            }

        BshClassManager bcm = getClassManager();
        
        if ( bcm.hasSuperImport() )
        {
            String s = bcm.getClassNameByUnqName( name );
            if ( s != null )
                return classForName( s );
        }

        return null;
    }

    private Class classForName( String name )
    {
        return getClassManager().classForName( name );
    }

    
    public String [] getAllNames()
    {
        Vector vec = new Vector();
        getAllNamesAux( vec );
        String [] names = new String [ vec.size() ];
        vec.copyInto( names );
        return names;
    }

    
    protected void getAllNamesAux( Vector vec )
    {
        Enumeration varNames = variables.keys();
        while( varNames.hasMoreElements() )
            vec.addElement( varNames.nextElement() );

        Enumeration methodNames = methods.keys();
        while( methodNames.hasMoreElements() )
            vec.addElement( methodNames.nextElement() );

        if ( parent != null )
            parent.getAllNamesAux( vec );
    }

    Vector nameSourceListeners;
    
    public void addNameSourceListener( NameSource.Listener listener ) {
        if ( nameSourceListeners == null )
            nameSourceListeners = new Vector();
        nameSourceListeners.addElement( listener );
    }

    
    public void doSuperImport()
        throws UtilEvalError
    {
        getClassManager().doSuperImport();
    }


    public String toString() {
        return ""NameSpace: ""
            + ( nsName==null
                ? super.toString()
                : nsName + "" ("" + super.toString() +"")"" )
            + ( isClass ? "" (isClass) "" : """" )
            + ( isMethod ? "" (method) "" : """" )
            + ( classStatic != null ? "" (class static) "" : """" )
            + ( classInstance != null ? "" (class instance) "" : """" );
    }

    
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
        
        names = null;

        s.defaultWriteObject();
    }

    
    public Object invokeMethod(
        String methodName, Object [] args, Interpreter interpreter )
        throws EvalError
    {
        return invokeMethod(
            methodName, args, interpreter, null, null );
    }

    
    public Object invokeMethod(
        String methodName, Object [] args, Interpreter interpreter,
        CallStack callstack, SimpleNode callerInfo )
        throws EvalError
    {
        return getThis( interpreter ).invokeMethod(
            methodName, args, interpreter, callstack, callerInfo,
            false );
    }

    
    public void classLoaderChanged() {
        nameSpaceChanged();
    }

    
    public void nameSpaceChanged() {
        classCache = null;
        names = null;
    }

    
    public void loadDefaultImports()
    {
        
        importClass(""org.gjt.sp.jedit.bsh.EvalError"");
        importClass(""org.gjt.sp.jedit.bsh.Interpreter"");
        importPackage(""javax.swing.event"");
        importPackage(""javax.swing"");
        importPackage(""java.awt.event"");
        importPackage(""java.awt"");
        importPackage(""java.net"");
        importPackage(""java.util"");
        importPackage(""java.io"");
        importPackage(""java.lang"");
        addCommandPath(""/org/gjt/sp/jedit/bsh/commands"",getClass());
    }

    
    Name getNameResolver( String ambigname )
    {
        if ( names == null )
            names = new Hashtable();

        Name name = (Name)names.get( ambigname );

        if ( name == null ) {
            name = new Name( this, ambigname );
            names.put( ambigname, name );
        }

        return name;
    }

    public int getInvocationLine() {
        SimpleNode node = getNode();
        if ( node != null )
            return node.getLineNumber();
        else
            return -1;
    }
    public String getInvocationText() {
        SimpleNode node = getNode();
        if ( node != null )
            return node.getText();
        else
            return ""<invoked from Java code>"";
    }

    
    public static Class identifierToClass( ClassIdentifier ci )
    {
        return ci.getTargetClass();
    }


    
    public void clear()
    {
        variables = null;
        methods = null;
        importedClasses = null;
        importedPackages = null;
        importedCommands = null;
        importedObjects = null;
        if ( parent == null )
            loadDefaultImports();
        classCache = null;
        names = null;
    }

    
    
    public void importObject( Object obj )
    {
        if ( importedObjects == null )
            importedObjects = new Vector();

        
        if ( importedObjects.contains( obj ) )
            importedObjects.remove( obj );

        importedObjects.addElement( obj );
        nameSpaceChanged();

    }

    
    public void importStatic( Class clas )
    {
        if ( importedStatic == null )
            importedStatic = new Vector();

        
        if ( importedStatic.contains( clas ) )
            importedStatic.remove( clas );

        importedStatic.addElement( clas );
        nameSpaceChanged();
    }

    
    void setPackage( String packageName )
    {
        this.packageName = packageName;
    }

    String getPackage()
    {
        if ( packageName != null )
            return packageName;

        if ( parent != null )
            return parent.getPackage();

        return null;
    }

    
    public void setVariable(String name, Object value) throws UtilEvalError
        {
                setVariable(name,value,false);
        }

    
    public void addCommandPath(String path, Class clas)
    {
        if(importedCommands == null)
            importedCommands = new Vector();

        if(!path.endsWith(""/""))
            path += '/';
        importedCommands.addElement(new CommandPathEntry(path,clas));
    }

    
    public void removeCommandPath(String path, Class clas)
    {
        if(importedCommands == null)
            return;

        for(int i = 0; i < importedCommands.size(); i++)
        {
            CommandPathEntry entry = (CommandPathEntry)importedCommands
                .elementAt(i);
            if(entry.path.equals(path) && entry.clas == clas)
            {
                importedCommands.removeElementAt(i);
                return;
            }
        }
    }

    
    public InputStream getCommand(String name)
    {
        if(importedCommands != null)
        {
            String extName = name + "".bsh"";
            for(int i = importedCommands.size() - 1; i >= 0; i--)
            {
                CommandPathEntry entry = (CommandPathEntry)importedCommands
                    .elementAt(i);
                InputStream in = entry.clas.getResourceAsStream(entry.path + extName);
                if(in != null)
                    return in;
            }
        }

        if(parent == null)
            return null;
        else
            return parent.getCommand(name);
    }

    static class CommandPathEntry
    {
        final String path;
        final Class clas;

        CommandPathEntry(String path, Class clas)
        {
            this.path = path;
            this.clas = clas;
        }
    }

    
}

"
jEdit,4.3,org.gjt.sp.jedit.browser.VFSFileNameField,5,7,0,11,57,0,2,9,2,0.0,438,1.0,1,0.995061728,0.44,4,10,86.4,21,8.4,0,"

package org.gjt.sp.jedit.browser;


import java.util.HashSet;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.HistoryTextField;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.MiscUtilities;

import org.gjt.sp.util.Log;



class VFSFileNameField extends HistoryTextField
{
	
	VFSFileNameField(VFSBrowser browser, String model)
	{
		super(model);
		setEnterAddsToHistory(false);

		this.browser = browser;

		Dimension dim = getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		setMaximumSize(dim);

		
		
		final int FORWARD = KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS;
		HashSet<AWTKeyStroke> keys = new HashSet<AWTKeyStroke>(
				getFocusTraversalKeys(FORWARD));
		keys.remove(AWTKeyStroke.getAWTKeyStroke(""pressed TAB""));
		setFocusTraversalKeys(FORWARD, keys);
	} 

	
	public void processKeyEvent(KeyEvent evt)
	{
		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			String path = getText();

			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_TAB:
				doComplete(path);
				break;
			case KeyEvent.VK_LEFT:
				if ((evt.getModifiers() & KeyEvent.ALT_MASK) > 0)
				{
					browser.previousDirectory();
					evt.consume();
				}
				else
				{
					
					super.processKeyEvent(evt);
				}
				break;
			case KeyEvent.VK_UP:
				if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)
				{
					String p = browser.getDirectory();
					browser.setDirectory(MiscUtilities.getParentOfPath(p));
					evt.consume();
				}
				else
				{
					browser.getBrowserView().getTable()
					.processKeyEvent(evt);
				}
				break;
			case KeyEvent.VK_RIGHT:
				if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)
				{
					evt.consume();
					browser.nextDirectory();
				}
				else
					super.processKeyEvent(evt);
				break;
			case KeyEvent.VK_DOWN:
			case KeyEvent.VK_PAGE_UP:
			case KeyEvent.VK_PAGE_DOWN:
				browser.getBrowserView().getTable()
					.processKeyEvent(evt);
				break;
			case KeyEvent.VK_ENTER:
				browser.filesActivated(
					(evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN),false);
				setText(null);
				evt.consume();
				break;
			default:
				super.processKeyEvent(evt);
				break;
			}
		}
		else if(evt.getID() == KeyEvent.KEY_TYPED)
		{
			char ch = evt.getKeyChar();
			if(ch > 0x20 && ch != 0x7f && ch != 0xff)
			{
				super.processKeyEvent(evt);
				String path = getText();
				BrowserView view = browser.getBrowserView();
				view.selectNone();

				if(MiscUtilities.getLastSeparatorIndex(path) == -1)
				{
					int mode = browser.getMode();
					
					
					
					
					view.getTable().doTypeSelect(path,
						mode == VFSBrowser
						.CHOOSE_DIRECTORY_DIALOG
						||
						mode == VFSBrowser
						.SAVE_DIALOG);
				}
			}
			else
				super.processKeyEvent(evt);
		}
	} 

	
	private VFSBrowser browser;

	
	public String doComplete(String path, String complete, boolean dirsOnly)
	{
		Log.log(Log.DEBUG,VFSFileNameField.class,
			""doComplete("" + path + "","" + complete
			+ "","" + dirsOnly);

		for(;;)
		{
			if(complete.length() == 0)
				return path;
			int index = MiscUtilities.getFirstSeparatorIndex(complete);
			if(index == -1)
				return path;

			
			String newPath = VFSFile.findCompletion(path,
				complete.substring(0,index),browser,true);
			if(newPath == null)
				return null;
			path = newPath;
			complete = complete.substring(index + 1);
		}
	} 

	
	private void doComplete(String currentText)
	{
		int index = MiscUtilities.getLastSeparatorIndex(currentText);
		String dir;
		if(index != -1)
			dir = currentText.substring(0,index + 1);
		else
			dir = """";

		if(MiscUtilities.isAbsolutePath(currentText))
		{
			if(dir.startsWith(""/""))
				dir = dir.substring(1);
			dir = doComplete(VFSBrowser.getRootDirectory(),dir,false);
			if(dir == null)
				return;
	
			browser.setDirectory(dir);
			VFSManager.waitForRequests();

			if(index == -1)
			{
				if(currentText.startsWith(""/""))
					currentText = currentText.substring(1);
			}
			else
				currentText = currentText.substring(index + 1);
		}
		else
		{
			if(dir.length() != 0)
			{
				dir = doComplete(browser.getDirectory(),dir,false);
				if(dir == null)
					return;
	
				browser.setDirectory(dir);
				VFSManager.waitForRequests();
	
				currentText = currentText.substring(index + 1);
			}
		}

		BrowserView view = browser.getBrowserView();
		view.selectNone();
		view.getTable().doTypeSelect(currentText,
			browser.getMode() == VFSBrowser
			.CHOOSE_DIRECTORY_DIALOG);

		String newText;

		VFSFile[] files = view.getSelectedFiles();
		if(files.length == 0)
			newText = currentText;
		else
		{
			String path = files[0].getPath();
			String name = files[0].getName();
			String parent = MiscUtilities.getParentOfPath(path);

			if(MiscUtilities.isAbsolutePath(currentText)
				&& !currentText.startsWith(browser.getDirectory()))
			{
				newText = path;
			}
			else
			{
				if(MiscUtilities.pathsEqual(parent,browser.getDirectory()))
					newText = name;
				else
					newText = path;
			}
		}

		setText(newText);
	} 

	
	private void goToParent()
	{
		String name = MiscUtilities.getFileName(browser.getDirectory());
		String parent = MiscUtilities.getParentOfPath(
			browser.getDirectory());
		browser.setDirectory(parent);

		VFS vfs = VFSManager.getVFSForPath(parent);
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
		{
			VFSManager.waitForRequests();
			setText(name);
			browser.getBrowserView().getTable().doTypeSelect(
				name,browser.getMode() == VFSBrowser
				.CHOOSE_DIRECTORY_DIALOG);
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Interpreter,59,1,0,73,163,1389,60,23,47,0.800862069,1844,0.25,5,0.0,0.117647059,0,0,29.91525424,25,1.4915,0,"

package org.gjt.sp.jedit.bsh;

import java.io.*;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;


public class Interpreter 
	implements Runnable, ConsoleInterface,Serializable
{
	

	public static final String VERSION = ""2.0b4-jedit"";
	
    public static boolean DEBUG, TRACE, LOCALSCOPING;

	
    transient static PrintStream debug;
	static String systemLineSeparator = ""\n""; 

	static {
		staticInit();
	}

	
	static This sharedObject;

	
	private boolean strictJava = false;

	

	

	transient Parser parser;
    NameSpace globalNameSpace;
    transient Reader in;
    transient PrintStream out;
    transient PrintStream err;
    ConsoleInterface console;

	
	Interpreter parent;

	
	String sourceFileInfo;

	
	private boolean exitOnEOF = true;

    protected boolean
		evalOnly, 		
		interactive;	

	
	private boolean showResults;

	

	
    public Interpreter(
		Reader in, PrintStream out, PrintStream err,
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
    {
		
		parser = new Parser( in );
		long t1=System.currentTimeMillis();
        this.in = in;
        this.out = out;
        this.err = err;
        this.interactive = interactive;
		debug = err;
		this.parent = parent;
		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;

		BshClassManager bcm = BshClassManager.createClassManager( this );
		if ( namespace == null )
        	this.globalNameSpace = new NameSpace( bcm, ""global"");
		else
			this.globalNameSpace = namespace;

		
		
		

		
		if ( ! ( getu(""bsh"") instanceof org.gjt.sp.jedit.bsh.This ) )
			initRootSystemObject();

		if ( interactive )
			loadRCFiles();

		long t2=System.currentTimeMillis();
		if ( Interpreter.DEBUG )
			Interpreter.debug(""Time to initialize interpreter: ""+(t2-t1));
    }

    public Interpreter(
		Reader in, PrintStream out, PrintStream err,
		boolean interactive, NameSpace namespace)
    {
		this( in, out, err, interactive, namespace, null, null );
	}

    public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
    {
        this(in, out, err, interactive, null);
    }

	
    public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {

        this( console.getIn(), console.getOut(), console.getErr(),
			true, globalNameSpace );

		setConsole( console );
    }

	
    public Interpreter(ConsoleInterface console) {
        this(console, null);
    }

	
    public Interpreter()
    {
		this( new StringReader(""""),
			System.out, System.err, false, null );
        evalOnly = true;
		setu( ""bsh.evalOnly"", new Primitive(true) );
    }

	

	
	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( ""bsh.console"", console );
		
		setOut( console.getOut() );
		setErr( console.getErr() );
		
	}

	private void initRootSystemObject()
	{
		BshClassManager bcm = getClassManager();
		
		setu(""bsh"", new NameSpace( bcm, ""Bsh Object"" ).getThis( this ) );

		
		if ( sharedObject == null )
			sharedObject = new NameSpace(
				bcm, ""Bsh Shared System Object"" ).getThis( this );
		
		setu( ""bsh.system"", sharedObject );
		setu( ""bsh.shared"", sharedObject ); 

		
		This helpText = new NameSpace(
			bcm, ""Bsh Command Help Text"" ).getThis( this );
		setu( ""bsh.help"", helpText );

		
		try {
			setu( ""bsh.cwd"", System.getProperty(""user.dir"") );
		} catch ( SecurityException e ) {
			
			setu( ""bsh.cwd"", ""."" );
		}

		
		setu( ""bsh.interactive"", new Primitive(interactive) );
		
		setu( ""bsh.evalOnly"", new Primitive(evalOnly) );
	}

	
	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}

	
	public NameSpace getNameSpace() {
		return globalNameSpace;
	}

	
    public static void main( String [] args )
	{
        if ( args.length > 0 ) {
			String filename = args[0];

			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];

            Interpreter interpreter = new Interpreter();
			
			interpreter.setu( ""bsh.args"", bshArgs );
			try {
				Object result =
					interpreter.source( filename, interpreter.globalNameSpace );
				if ( result instanceof Class )
					try {
						invokeMain( (Class)result, bshArgs );
					} catch ( Exception e )
					{
						Object o = e;
						if ( e instanceof InvocationTargetException )
							o = ((InvocationTargetException)e)
								.getTargetException();
						System.err.println(
							""Class: ""+result+"" main method threw exception:""+o);
					}
			} catch ( FileNotFoundException e ) {
				System.out.println(""File not found: ""+e);
			} catch ( TargetError e ) {
				System.out.println(""Script threw exception: ""+e);
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, System.err );
			} catch ( EvalError e ) {
				System.out.println(""Evaluation Error: ""+e);
			} catch ( IOException e ) {
				System.out.println(""I/O Error: ""+e);
			}
        } else
		{
			
			
			InputStream src;
			if ( System.getProperty(""os.name"").startsWith(""Windows"")
				&& System.getProperty(""java.version"").startsWith(""1.1.""))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;

            Reader in = new CommandLineReader( new InputStreamReader(src));
            Interpreter interpreter =
				new Interpreter( in, System.out, System.err, true );
        	interpreter.run();
        }
    }

	public static void invokeMain( Class clas, String [] args )
		throws Exception
	{
    	Method main = Reflect.resolveJavaMethod(
			null, clas, ""main"",
			new Class [] { String [].class }, true );
		if ( main != null )
			main.invoke( null, new Object [] { args } );
	}

	
    public void run()
	{
        if(evalOnly)
            throw new RuntimeException(""bsh Interpreter: No stream"");

        
        if ( interactive )
			try {
				eval(""printBanner();"");
			} catch ( EvalError e ) {
				println(
					""BeanShell ""+VERSION+"" - by Pat Niemeyer (pat@pat.net)"");
			}

		
		CallStack callstack = new CallStack( globalNameSpace );

        boolean eof = false;
        while( !eof )
        {
            try
            {
                
                System.out.flush();
                System.err.flush();
                Thread.yield();  

                if ( interactive )
                    print( getBshPrompt() );

                eof = Line();

                if( get_jjtree().nodeArity() > 0 )  
                {
                    SimpleNode node = (SimpleNode)(get_jjtree().rootNode());

                    if(DEBUG)
                        node.dump("">"");

                    Object ret = node.eval( callstack, this );

					
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							""Callstack growing: ""+callstack);

                    if(ret instanceof ReturnControl)
                        ret = ((ReturnControl)ret).value;

                    if( ret != Primitive.VOID )
                    {
                        setu(""$_"", ret);
						if ( showResults )
                            println(""<"" + ret + "">"");
                    }
                }
            }
            catch(ParseException e)
            {
                error(""Parser Error: "" + e.getMessage(DEBUG));
				if ( DEBUG )
                	e.printStackTrace();
                if(!interactive)
                    eof = true;

                parser.reInitInput(in);
            }
            catch(InterpreterError e)
            {
                error(""Internal Error: "" + e.getMessage());
                e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TargetError e)
            {
                error(""
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, err );
                if(!interactive)
                    eof = true;
				setu(""$_e"", e.getTarget());
            }
            catch (EvalError e)
            {
				if ( interactive )
					error( ""EvalError: ""+e.toString() );
				else
					error( ""EvalError: ""+e.getMessage() );

                if(DEBUG)
                    e.printStackTrace();

                if(!interactive)
                    eof = true;
            }
            catch(Exception e)
            {
                error(""Unknown error: "" + e);
				if ( DEBUG )
                	e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TokenMgrError e)
            {
				error(""Error parsing input: "" + e);

				
				parser.reInitTokenInput( in );

                if(!interactive)
                    eof = true;
            }
            finally
            {
                get_jjtree().reset();
				
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
            }
        }

		if ( interactive && exitOnEOF )
			System.exit(0);
    }

	

	
    public Object source( String filename, NameSpace nameSpace )
		throws FileNotFoundException, IOException, EvalError
	{
		File file = pathToFile( filename );
		if ( Interpreter.DEBUG ) debug(""Sourcing file: ""+file);
		Reader sourceIn = new BufferedReader( new FileReader(file) );
		try {
			return eval( sourceIn, nameSpace, filename );
		} finally {
			sourceIn.close();
		}
	}

	
    public Object source( String filename )
		throws FileNotFoundException, IOException, EvalError
	{
		return source( filename, globalNameSpace );
	}

    
	
	

    public Object eval(
		Reader in, NameSpace nameSpace, String sourceFileInfo
			 )
		throws EvalError
	{
		Object retVal = null;
		if ( Interpreter.DEBUG ) debug(""eval: nameSpace = ""+nameSpace);

		
        Interpreter localInterpreter =
			new Interpreter(
				in, out, err, false, nameSpace, this, sourceFileInfo  );

		CallStack callstack = new CallStack( nameSpace );

        boolean eof = false;
        while(!eof)
        {
			SimpleNode node = null;
            try
            {
                eof = localInterpreter.Line();
                if (localInterpreter.get_jjtree().nodeArity() > 0)
                {
                    node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
					
					node.setSourceFile( sourceFileInfo );

					if ( TRACE )
						println( ""

                    retVal = node.eval( callstack, localInterpreter );

					
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							""Callstack growing: ""+callstack);

                    if ( retVal instanceof ReturnControl ) {
                        retVal = ((ReturnControl)retVal).value;
						break; 
					}

					if ( localInterpreter.showResults
						&& retVal != Primitive.VOID )
						println(""<"" + retVal + "">"");
                }
            } catch(ParseException e) {
				
				if ( DEBUG )
					
					error( e.getMessage(DEBUG) );

				
				e.setErrorSourceFile( sourceFileInfo );
				throw e;

            } catch ( InterpreterError e ) {
                e.printStackTrace();
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" internal Error: ""
					+ e.getMessage(), node, callstack);
            } catch ( TargetError e ) {
				
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow(""Sourced file: ""+sourceFileInfo);
            } catch ( EvalError e) {
                if ( DEBUG)
                    e.printStackTrace();
				
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( ""Sourced file: ""+sourceFileInfo );
            } catch ( Exception e) {
                if ( DEBUG)
                	e.printStackTrace();
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" unknown error: ""
					+ e.getMessage(), node, callstack);
            } catch(TokenMgrError e) {
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" Token Parsing Error: ""
					+ e.getMessage(), node, callstack );
            } finally {
                localInterpreter.get_jjtree().reset();

				
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
            }
        }
		return Primitive.unwrap( retVal );
    }

	
    public Object eval( Reader in ) throws EvalError
	{
		return eval( in, globalNameSpace, ""eval stream"" );
	}

	
    public Object eval( String statements ) throws EvalError {
		if ( Interpreter.DEBUG ) debug(""eval(String): ""+statements);
		return eval(statements, globalNameSpace);
	}

	
    public Object eval( String statements, NameSpace nameSpace )
		throws EvalError
	{

		String s = ( statements.endsWith("";"") ? statements : statements+"";"" );
        return eval(
			new StringReader(s), nameSpace,
			""inline evaluation of: ``""+ showEvalString(s)+""''"" );
    }

	private String showEvalString( String s ) {
		s = s.replace('\n', ' ');
		s = s.replace('\r', ' ');
		if ( s.length() > 80 )
			s = s.substring( 0, 80 ) + "" . . . "";
		return s;
	}

	

	
    public final void error( Object o ) {
		if ( console != null )
				console.error( ""
		else {
			err.println(""
			err.flush();
		}
    }

	
	
	
	

	
	public Reader getIn() { return in; }

	
	public PrintStream getOut() { return out; }

	
	public PrintStream getErr() { return err; }

    public final void println( Object o )
    {
        print( String.valueOf(o) + systemLineSeparator );
    }

    public final void print( Object o )
    {
		if (console != null) {
            console.print(o);
        } else {
            out.print(o);
            out.flush();
        }
    }

	

	
    public final static void debug(String s)
    {
        if ( DEBUG )
            debug.println(""
    }

	

	
    public Object get( String name ) throws EvalError {
		try {
			Object ret = globalNameSpace.get( name, this );
			return Primitive.unwrap( ret );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() );
		}
	}

	
    Object getu( String name ) {
		try {
			return get( name );
		} catch ( EvalError e ) {
			throw new InterpreterError(""set: ""+e);
		}
	}

	
    public void set( String name, Object value )
		throws EvalError
	{
		
		if ( value == null )
			value = Primitive.NULL;

		CallStack callstack = new CallStack();
		try {
			if ( Name.isCompound( name ) )
			{
				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS(
					callstack, this );
				lhs.assign( value, false );
			} else 
				globalNameSpace.setVariable( name, value, false );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( SimpleNode.JAVACODE, callstack );
		}
	}

	
    void setu(String name, Object value) {
		try {
			set(name, value);
		} catch ( EvalError e ) {
			throw new InterpreterError(""set: ""+e);
		}
	}

    public void set(String name, long value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, int value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, double value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, float value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, boolean value) throws EvalError {
        set(name, new Primitive(value));
	}

	
    public void unset( String name )
		throws EvalError
	{
		
		CallStack callstack = new CallStack();
		try {
			LHS lhs = globalNameSpace.getNameResolver( name ).toLHS(
				callstack, this );

			if ( lhs.type != LHS.VARIABLE )
				throw new EvalError(""Can't unset, not a variable: ""+name,
					SimpleNode.JAVACODE, new CallStack() );

			
			lhs.nameSpace.unsetVariable( name );
		} catch ( UtilEvalError e ) {
			throw new EvalError( e.getMessage(),
				SimpleNode.JAVACODE, new CallStack() );
		}
	}

	

	
	public Object getInterface( Class interf ) throws EvalError
	{
		try {
			return globalNameSpace.getThis( this ).getInterface( interf );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() );
		}
	}

	

	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}

  	private JavaCharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}

  	private boolean Line() throws ParseException {
		return parser.Line();
	}

	

	void loadRCFiles() {
		try {
			String rcfile =
				
				System.getProperty(""user.home"") + File.separator + "".bshrc"";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) {
			
			if ( Interpreter.DEBUG ) debug(""Could not find rc file: ""+e);
		}
	}

	
    public File pathToFile( String fileName )
		throws IOException
	{
		File file = new File( fileName );

		
		if ( !file.isAbsolute() ) {
			String cwd = (String)getu(""bsh.cwd"");
			file = new File( cwd + File.separator + fileName );
		}

		
		
		return new File( file.getCanonicalPath() );
	}

	public static void redirectOutputToFile( String filename )
	{
		try {
			PrintStream pout = new PrintStream(
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println(""Can't redirect output to file: ""+filename );
		}
	}

	
	public void setClassLoader( ClassLoader externalCL ) {
		getClassManager().setClassLoader( externalCL );
	}

	
	public BshClassManager getClassManager()
	{
		return getNameSpace().getClassManager();
	}

	
	public void setStrictJava( boolean b ) {
		this.strictJava = b;
	}

	
	public boolean getStrictJava() {
		return this.strictJava;
	}

	static void staticInit()
	{
	
		try {
			systemLineSeparator = System.getProperty(""line.separator"");
    		debug = System.err;
    		DEBUG = Boolean.getBoolean(""debug"");
    		TRACE = Boolean.getBoolean(""trace"");
    		LOCALSCOPING = Boolean.getBoolean(""localscoping"");
			String outfilename = System.getProperty(""outfile"");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) {
			System.err.println(""Could not init static:""+e);
		} catch ( Exception e ) {
			System.err.println(""Could not init static(2):""+e);
		} catch ( Throwable e ) {
			System.err.println(""Could not init static(3):""+e);
		}
	}

	
	public String getSourceFileInfo() {
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return ""<unknown source>"";
	}

	
	public Interpreter getParent() {
		return parent;
	}

	public void setOut( PrintStream out ) {
		this.out = out;
	}
	public void setErr( PrintStream err ) {
		this.err = err;
	}

	
	private void readObject(ObjectInputStream stream)
		throws java.io.IOException, ClassNotFoundException
	{
		stream.defaultReadObject();

		
		if ( console != null ) {
			setOut( console.getOut() );
			setErr( console.getErr() );
		} else {
			setOut( System.out );
			setErr( System.err );
		}
	}

	
	private String getBshPrompt()
	{
		try {
			return (String)eval(""getBshPrompt()"");
		} catch ( Exception e ) {
			return ""bsh % "";
		}
	}

	
	public void setExitOnEOF( boolean value ) {
		exitOnEOF = value; 
	}

	
	public void setShowResults( boolean showResults ) {
		this.showResults = showResults;
	}
	
	public boolean getShowResults()  {
		return showResults;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bufferio.BufferLoadRequest,7,3,0,16,73,1,1,16,2,2.0,828,0.0,0,0.7,0.238095238,1,1,117.2857143,6,1.5714,0,"

package org.gjt.sp.jedit.bufferio;


import java.io.*;
import java.nio.charset.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.zip.GZIPInputStream;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.*;



public class BufferLoadRequest extends BufferIORequest
{
	
	
	public BufferLoadRequest(View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		super(view,buffer,session,vfs,path);
	} 
	
	
	public void run()
	{
		try
		{
			setAbortable(true);
			if(!buffer.isTemporary())
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setValue(0L);
			}

			path = vfs._canonPath(session,path,view);

			readContents();
			buffer.setNewFile(false);

			if (jEdit.getBooleanProperty(""persistentMarkers"") &&
			    (vfs.isMarkersFileSupported()))
			{
				InputStream markers = null;
				try
				{
					String[] args = { vfs.getFileName(path) };
					if(!buffer.isTemporary())
						setStatus(jEdit.getProperty(""vfs.status.load-markers"",args));
					setAbortable(true);

					markers = vfs._createInputStream(session,markersPath,true,view);
					if(markers != null)
						readMarkers(buffer,markers);
				}
				catch(Exception e)
				{
					
				}
				finally
				{
					IOUtilities.closeQuietly(markers);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			Object[] pp = { e.toString() };
			VFSManager.error(view,path,""ioerror.read-error"",pp);

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		catch(OutOfMemoryError oom)
		{
			Log.log(Log.ERROR,this,oom);
			VFSManager.error(view,path,""out-of-memory-error"",null);

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		catch(WorkThread.Abort a)
		{
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
	
	private InputStream getNakedStream() throws IOException
	{
		InputStream in = vfs._createInputStream(session,path,false,view);
		if(in != null)
		{
			return in;
		}
		throw new IOException(""Unable to get a Stream for "" + path);
	} 

	
	
	private long getContentLength() throws IOException
	{
		VFSFile entry = vfs._getFile(session,path,view);
		if(entry != null)
			return entry.getLength();
		else
			return 0L;
	} 

	
	
	private BufferedInputStream rewindContentsStream(BufferedInputStream markedStream, boolean gzipped)
		throws IOException
	{
		try
		{
			markedStream.reset();
			return markedStream;
		}
		catch(IOException e)
		{
			Log.log(Log.NOTICE, this
				, path + "": Reopening to rewind the stream"");
			
			
			markedStream.close();
			InputStream in = getNakedStream();
			try
			{
				if(gzipped)
				{
					in = new GZIPInputStream(in);
				}
				BufferedInputStream result
					= AutoDetection.getMarkedStream(in);
				in = null;
				return result;
			}
			finally
			{
				IOUtilities.closeQuietly(in);
			}
		}
	} 

	
	
	private void readContents() throws IOException
	{
		long length = getContentLength();

		BufferedInputStream markedStream
			= AutoDetection.getMarkedStream(getNakedStream());
		try
		{
			boolean gzipped = false;
			
			
			
			List<Object> encodingProviders
				= new ArrayList<Object>();

			boolean autodetect = buffer.getBooleanProperty(Buffer.ENCODING_AUTODETECT);
			if(autodetect)
			{
				gzipped = AutoDetection.isGzipped(markedStream);
				markedStream.reset();

				encodingProviders.addAll(AutoDetection.getEncodingDetectors());
				
				
				encodingProviders.add(buffer.getStringProperty(Buffer.ENCODING));

				String fallbackEncodings = jEdit.getProperty(""fallbackEncodings"");
				if(fallbackEncodings != null && fallbackEncodings.length() > 0)
				{
					for(String encoding: fallbackEncodings.split(""\\s+""))
					{
						encodingProviders.add(encoding);
					}
				}
			}
			else
			{
				gzipped = buffer.getBooleanProperty(Buffer.GZIPPED);
				encodingProviders.add(buffer.getStringProperty(Buffer.ENCODING));
			}

			if(gzipped)
			{
				Log.log(Log.DEBUG, this, path + "": Stream is gzipped."");
				markedStream = AutoDetection.getMarkedStream(
					new GZIPInputStream(markedStream));
			}

			Set<String> failedEncodings = new HashSet<String>();
			Exception encodingError = null;
			for(Object encodingProvider: encodingProviders)
			{
				String encoding = null;
				if (encodingProvider instanceof String)
				{
					encoding = (String)encodingProvider;
				}
				else if(encodingProvider instanceof EncodingDetector)
				{
					markedStream = rewindContentsStream(markedStream, gzipped);
					encoding = ((EncodingDetector)encodingProvider).detectEncoding(new BufferedInputStream(markedStream));
				}
				else
				{
					Log.log(Log.DEBUG, this, ""Strange encodingProvider: "" + encodingProvider);
				}

				if(encoding == null || encoding.length() <= 0
					|| failedEncodings.contains(encoding))
				{
					continue;
				}

				markedStream = rewindContentsStream(markedStream, gzipped);
				try
				{
					read(EncodingServer.getTextReader(markedStream, encoding)
						, length, false);
					if(autodetect)
					{
						
						if(gzipped)
						{
							buffer.setBooleanProperty(Buffer.GZIPPED,true);
						}
						buffer.setProperty(Buffer.ENCODING, encoding);
					}
					return;
				}
				catch(CharConversionException e)
				{
					encodingError = e;
				}
				catch(CharacterCodingException e)
				{
					encodingError = e;
				}
				catch(UnsupportedEncodingException e)
				{
					encodingError = e;
				}
				catch(UnsupportedCharsetException e)
				{
					encodingError = e;
				}
				Log.log(Log.NOTICE, this, path + "": "" + encoding
					+ "": "" + encodingError);
				failedEncodings.add(encoding);
			}
			
			Object[] pp = { TextUtilities.join(failedEncodings,"",""), """" };
			if(failedEncodings.size() < 2)
			{
				pp[1] = encodingError.toString();
			}
			else
			{
				pp[1] = ""See details in Activity Log"";
			}
			VFSManager.error(view,path,""ioerror.encoding-error"",pp);
			markedStream = rewindContentsStream(markedStream, gzipped);
			read(EncodingServer.getEncoding(
				buffer.getStringProperty(Buffer.ENCODING)
				).getPermissiveTextReader(markedStream)
				, length, false);
			if(autodetect && gzipped)
			{
				buffer.setBooleanProperty(Buffer.GZIPPED,true);
			}
		}
		finally
		{
			markedStream.close();
		}
	} 

	
	private static void readMarkers(Buffer buffer, InputStream _in)
		throws IOException
	{
		
		buffer.removeAllMarkers();

		BufferedReader in = new BufferedReader(new InputStreamReader(_in));

		try
		{
			String line;
			while((line = in.readLine()) != null)
			{
				
				if(line.length() == 0)
					continue;
				
				
				if(line.charAt(0) != '!')
					continue;


				char shortcut = line.charAt(1);
				int start = line.indexOf(';');
				int end = line.indexOf(';',start + 1);
				int position = Integer.parseInt(line.substring(start + 1,end));
				buffer.addMarker(shortcut,position);
			}
			buffer.setMarkersChanged(false);
		}
		finally
		{
			in.close();
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bufferio.BufferSaveRequest,4,3,0,10,43,4,1,10,2,2.0,405,0.0,0,0.823529412,0.375,1,1,100.25,26,7.75,0,"

package org.gjt.sp.jedit.bufferio;


import java.io.*;
import java.util.zip.*;

import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
import java.nio.charset.UnsupportedCharsetException;



public class BufferSaveRequest extends BufferIORequest
{
	
	
	public BufferSaveRequest(View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		super(view,buffer,session,vfs,path);
	} 

	
	public void run()
	{
		

		boolean vfsRenameCap = (vfs.getCapabilities() &
			VFS.RENAME_CAP) != 0;

		boolean wantTwoStage = wantTwoStageSave(buffer);
		boolean twoStageSave = vfsRenameCap && wantTwoStage;

		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.save"",args));

			
			setAbortable(true);

			path = vfs._canonPath(session,path,view);
			if(!MiscUtilities.isURL(path))
				path = MiscUtilities.resolveSymlinks(path);

			String savePath;
			if(twoStageSave)
			{
				savePath = vfs.getTwoStageSaveName(path);
				if (savePath == null)
				{
					throw new IOException(
						""Can't get a temporary path for two-stage save: ""
						+ path);
				}
			}
			else
			{
				makeBackup();
				savePath = path;
			}

			OutputStream out = vfs._createOutputStream(session,savePath,view);
			if(out == null)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
				return;
			}
			try
			{
				
				
				buffer.readLock();
				try
				{
					
					
					
					if(path.endsWith("".gz""))
						buffer.setBooleanProperty(Buffer.GZIPPED,true);
					else if (buffer.getName().endsWith("".gz""))
					{
						
						
						
						
						buffer.setBooleanProperty(Buffer.GZIPPED, false);
					}

					if(buffer.getBooleanProperty(Buffer.GZIPPED))
						out = new GZIPOutputStream(out);

					write(buffer,out);
				}
				finally
				{
					buffer.readUnlock();
				}
			}
			finally
			{
				IOUtilities.closeQuietly(out);
			}

			if(twoStageSave)
			{
				makeBackup();
				if(!vfs._rename(session,savePath,path,view))
					throw new IOException(""Rename failed: "" + savePath);
			}

			if(!twoStageSave)
				VFSManager.sendVFSUpdate(vfs,path,true);
		}
		catch(UnsupportedCharsetException e)
		{
			Log.log(Log.ERROR, this, e, e);
			String[] pp = { e.getCharsetName() };
			VFSManager.error(view,path,""ioerror.unsupported-encoding-error"",pp);

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			String[] pp = { e.toString() };
			VFSManager.error(view,path,""ioerror.write-error"",pp);

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		catch(WorkThread.Abort a)
		{
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._saveComplete(session,buffer,path,view);
				if( twoStageSave )
				{
					vfs._finishTwoStageSave(session,buffer,path,view);
				}
				
				if(!jEdit.getBooleanProperty(""persistentMarkers""))
					vfs._delete(session,Buffer.getMarkersPath(vfs, path),view);
				vfs._endVFSSession(session,view);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	

	
	
	private void makeBackup() throws IOException
	{
		
		if(buffer.getProperty(Buffer.BACKED_UP) == null
			|| jEdit.getBooleanProperty(""backupEverySave""))
		{
			vfs._backup(session,path,view);
			buffer.setBooleanProperty(Buffer.BACKED_UP,true);
		}
	} 

	
	private static boolean wantTwoStageSave(Buffer buffer)
	{
		return !buffer.getBooleanProperty(""forbidTwoStageSave"") &&
			(buffer.getBooleanProperty(""overwriteReadonly"") ||
			jEdit.getBooleanProperty(""twoStageSave""));
	}

	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.SelectionManager,14,1,0,9,63,0,4,6,1,0.269230769,721,0.5,1,0.0,0.30952381,0,0,50.35714286,19,4.1429,0,"

package org.gjt.sp.jedit.textarea;


import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.gjt.sp.jedit.buffer.*;


class SelectionManager
{
	
	
	List<Selection> selection;

	
	SelectionManager(TextArea textArea)
	{
		this.textArea = textArea;
		selection = new ArrayList<Selection>();
	} 

	
	
	int getSelectionCount()
	{
		return selection.size();
	} 

	
	
	public Selection[] getSelection()
	{
		return selection.toArray(
			new Selection[selection.size()]);
	} 

	
	
	void setSelection(Selection[] selection)
	{
		this.selection.clear();
		addToSelection(selection);
	} 

	
	
	void addToSelection(Selection[] selection)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s != null)
					addToSelection(s);
			}
		}
	} 

	
	void addToSelection(Selection addMe)
	{
		if(addMe.start > addMe.end)
		{
			throw new IllegalArgumentException(addMe.start
				+ "" > "" + addMe.end);
		}
		else if(addMe.start == addMe.end)
		{
			if(addMe instanceof Selection.Range)
				return;
			else if(addMe instanceof Selection.Rect)
			{
				if(((Selection.Rect)addMe).extraEndVirt == 0)
					return;
			}
		}

		Iterator<Selection> iter = selection.iterator();
		while(iter.hasNext())
		{
			
			
			Selection s = iter.next();
			if(s.overlaps(addMe))
			{
				addMe.start = Math.min(s.start,addMe.start);
				addMe.end = Math.max(s.end,addMe.end);
				iter.remove();
			}
		}

		addMe.startLine = textArea.getLineOfOffset(addMe.start);
		addMe.endLine = textArea.getLineOfOffset(addMe.end);

		boolean added = false;

		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = selection.get(i);
			if(addMe.start < s.start)
			{
				selection.add(i,addMe);
				added = true;
				break;
			}
		}

		if(!added)
			selection.add(addMe);

		textArea.invalidateLineRange(addMe.startLine,addMe.endLine);
	} 

	
	
	void setSelection(Selection selection)
	{
		this.selection.clear();

		if(selection != null)
			addToSelection(selection);
	} 

	
	
	Selection getSelectionAtOffset(int offset)
	{
		if(selection != null)
		{
			for (Selection s : selection)
			{
				if(offset >= s.start && offset <= s.end)
					return s;
			}
		}

		return null;
	} 

	
	
	void removeFromSelection(Selection sel)
	{
		selection.remove(sel);
	} 

	
	
	void resizeSelection(int offset, int end, int extraEndVirt,
		boolean rect)
	{
		boolean reversed = false;
		if(end < offset)
		{
			int tmp = offset;
			offset = end;
			end = tmp;
			reversed = true;
		}

		Selection newSel;
		if(rect)
		{
			Selection.Rect rectSel = new Selection.Rect(offset,end);
			if(reversed)
				rectSel.extraStartVirt = extraEndVirt;
			else
				rectSel.extraEndVirt = extraEndVirt;
			newSel = rectSel;
		}
		else
			newSel = new Selection.Range(offset,end);

		addToSelection(newSel);
	} 

	
	
	int[] getSelectedLines()
	{

		Set<Integer> set = new TreeSet<Integer>();
		for (Selection s : selection)
		{
			int endLine =
				s.end == textArea.getLineStartOffset(s.endLine)
				? s.endLine - 1
				: s.endLine;

			for(int j = s.startLine; j <= endLine; j++)
			{
				set.add(j);
			}
		}


		int[] returnValue = new int[set.size()];
		int i = 0;
		for (Integer line : set)
			returnValue[i++] = line;

		return returnValue;
	} 
	
	
	void invertSelection()
	{
		Selection[] newSelection = new Selection[selection.size() + 1];
		int lastOffset = 0;
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = selection.get(i);
			newSelection[i] = new Selection.Range(lastOffset,
				s.getStart());
			lastOffset = s.getEnd();
		}
		newSelection[selection.size()] = new Selection.Range(
			lastOffset,textArea.getBufferLength());
		setSelection(newSelection);
	} 

	
	
	int[] getSelectionStartAndEnd(int screenLine, int physicalLine,
		Selection s)
	{
		int start = textArea.getScreenLineStartOffset(screenLine);
		int end = textArea.getScreenLineEndOffset(screenLine);

		if(end <= s.start || start > s.end)
			return null;

		int selStartScreenLine;
		if(textArea.displayManager.isLineVisible(s.startLine))
			selStartScreenLine = textArea.getScreenLineOfOffset(s.start);
		else
			selStartScreenLine = -1;

		int selEndScreenLine;
		if(textArea.displayManager.isLineVisible(s.endLine))
			selEndScreenLine = textArea.getScreenLineOfOffset(s.end);
		else
			selEndScreenLine = -1;

		JEditBuffer buffer = textArea.getBuffer();

		int lineStart = buffer.getLineStartOffset(physicalLine);
		int x1, x2;

		if(s instanceof Selection.Rect)
		{
			start -= lineStart;
			end -= lineStart;

			Selection.Rect rect = (Selection.Rect)s;
			int _start = rect.getStartColumn(buffer);
			int _end = rect.getEndColumn(buffer);

			int lineLen = buffer.getLineLength(physicalLine);

			int[] total = new int[1];

			int rectStart = buffer.getOffsetOfVirtualColumn(
				physicalLine,_start,total);
			if(rectStart == -1)
			{
				x1 = (_start - total[0]) * textArea.charWidth;
				rectStart = lineLen;
			}
			else
				x1 = 0;

			int rectEnd = buffer.getOffsetOfVirtualColumn(
				physicalLine,_end,total);
			if(rectEnd == -1)
			{
				x2 = (_end - total[0]) * textArea.charWidth;
				rectEnd = lineLen;
			}
			else
				x2 = 0;

			if(end <= rectStart || start > rectEnd)
				return null;

			x1 = rectStart < start ? 0
				: x1 + textArea.offsetToXY(physicalLine,
				rectStart).x;
			x2 = rectEnd > end ? textArea.getWidth()
				: x2 + textArea.offsetToXY(physicalLine,
				rectEnd).x;
		}
		else if(selStartScreenLine == selEndScreenLine
			&& selStartScreenLine != -1)
		{
			x1 = textArea.offsetToXY(physicalLine,
				s.start - lineStart).x;
			x2 = textArea.offsetToXY(physicalLine,
				s.end - lineStart).x;
		}
		else if(screenLine == selStartScreenLine)
		{
			x1 = textArea.offsetToXY(physicalLine,
				s.start - lineStart).x;
			x2 = textArea.getWidth();
		}
		else if(screenLine == selEndScreenLine)
		{
			x1 = 0;
			x2 = textArea.offsetToXY(physicalLine,
				s.end - lineStart).x;
		}
		else
		{
			x1 = 0;
			x2 = textArea.getWidth();
		}

		if(x1 < 0)
			x1 = 0;
		if(x2 < 0)
			x2 = 0;

		if(x1 == x2)
			x2++;

		return new int[] { x1, x2 };
	} 

	
	
	boolean insideSelection(int x, int y)
	{
		int offset = textArea.xyToOffset(x,y);

		Selection s = textArea.getSelectionAtOffset(offset);
		if(s == null)
			return false;

		int screenLine = textArea.getScreenLineOfOffset(offset);
		if(screenLine == -1)
			return false;

		int[] selectionStartAndEnd = getSelectionStartAndEnd(
			screenLine,textArea.getLineOfOffset(offset),s);
		if(selectionStartAndEnd == null)
			return false;

		return x >= selectionStartAndEnd[0]
			&& x <= selectionStartAndEnd[1];
	} 

	private TextArea textArea;
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.ManagePanel,17,5,0,28,105,100,17,25,2,0.909722222,590,1.0,3,0.976083707,0.215686275,0,0,33.17647059,2,1.0,0,"

package org.gjt.sp.jedit.pluginmgr;


import java.awt.*;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import java.net.URL;

import java.util.*;
import java.util.List;

import javax.swing.*;

import javax.swing.border.EmptyBorder;

import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;

import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.PropertiesChanged;

import java.util.concurrent.ConcurrentHashMap;
import java.io.*;

import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.browser.VFSFileChooserDialog;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.help.*;

import org.gjt.sp.util.Log;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.StandardUtilities;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;



public class ManagePanel extends JPanel
{
	
	private final JCheckBox hideLibraries;
	private final JTable table;
	private final JScrollPane scrollpane;
	private final PluginDetailPanel pluginDetailPanel;
	private final PluginTableModel pluginModel;
	private final PluginManager window;
	private JPopupMenu popup;
	private Set<String> selectedPlugins;
	private Set<String> jarNames;
	

	
	public ManagePanel(PluginManager window)
	{
		super(new BorderLayout(12,12));

		this.window = window;

		setBorder(new EmptyBorder(12,12,12,12));

		Box topBox = new Box(BoxLayout.X_AXIS);
		topBox.add(hideLibraries = new HideLibrariesButton());
		add(BorderLayout.NORTH,topBox);

		
		table = new JTable(pluginModel = new PluginTableModel());
		table.setShowGrid(false);
		table.setIntercellSpacing(new Dimension(0,0));
		table.setRowHeight(table.getRowHeight() + 2);
		table.setPreferredScrollableViewportSize(new Dimension(500,300));
		table.setDefaultRenderer(Object.class, new TextRenderer(
			(DefaultTableCellRenderer)table.getDefaultRenderer(Object.class)));
		table.addFocusListener(new TableFocusHandler());
		table.getSelectionModel().addListSelectionListener(new TableSelectionListener());
		InputMap tableInputMap = table.getInputMap(JComponent.WHEN_FOCUSED);
		ActionMap tableActionMap = table.getActionMap();
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0),""tabOutForward"");
		tableActionMap.put(""tabOutForward"",new KeyboardAction(KeyboardCommand.TAB_OUT_FORWARD));
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,InputEvent.SHIFT_MASK),""tabOutBack"");
		tableActionMap.put(""tabOutBack"",new KeyboardAction(KeyboardCommand.TAB_OUT_BACK));
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,0),""editPlugin"");
		tableActionMap.put(""editPlugin"",new KeyboardAction(KeyboardCommand.EDIT_PLUGIN));
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""closePluginManager"");
		tableActionMap.put(""closePluginManager"",new KeyboardAction(KeyboardCommand.CLOSE_PLUGIN_MANAGER));

		TableColumn col1 = table.getColumnModel().getColumn(0);
		TableColumn col2 = table.getColumnModel().getColumn(1);
		TableColumn col3 = table.getColumnModel().getColumn(2);
		TableColumn col4 = table.getColumnModel().getColumn(3);

		col1.setPreferredWidth(30);
		col1.setMinWidth(30);
		col1.setMaxWidth(30);
		col1.setResizable(false);

		col2.setPreferredWidth(300);
		col3.setPreferredWidth(100);
		col4.setPreferredWidth(100);

		JTableHeader header = table.getTableHeader();
		header.setReorderingAllowed(false);
		HeaderMouseHandler mouseHandler = new HeaderMouseHandler();
		header.addMouseListener(mouseHandler);
		table.addMouseListener(mouseHandler);
		scrollpane = new JScrollPane(table);
		scrollpane.getViewport().setBackground(table.getBackground());
		pluginDetailPanel = new PluginDetailPanel();
		scrollpane.setPreferredSize(new Dimension(400,400));
		JSplitPane split = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
			true, scrollpane, pluginDetailPanel);
		add(BorderLayout.CENTER, split);
		split.setResizeWeight(0.75);
		
		Box buttons = new Box(BoxLayout.X_AXIS);

		buttons.add(new RemoveButton());
		buttons.add(new SaveButton());
		buttons.add(new RestoreButton());
		buttons.add(new FindOrphan());
		buttons.add(Box.createGlue());
		buttons.add(new HelpButton());

		add(BorderLayout.SOUTH,buttons);

		pluginModel.update();
	} 

	
	public void update()
	{
		pluginModel.update();
	} 

	
	
	private class ManagePanelRestoreHandler extends DefaultHandler
	{
		ManagePanelRestoreHandler()
		{
			selectedPlugins = new HashSet<String>();
			jarNames = new HashSet<String>();
		}



		@Override
		public void startElement(String uri, String localName,
							String qName, Attributes attrs) throws SAXException
		{
			if (localName.equals(""plugin""))
			{
				String jarName = attrs.getValue(""jar"");
				String name = attrs.getValue(""name"");
				Entry e = new Entry(jarName);
				e.name=name;
				selectedPlugins.add(name);
				jarNames.add(jarName);
			}
		}
	}

	
	boolean loadPluginSet(String path)
	{
		VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path, this);
		try
		{
			InputStream is = vfs._createInputStream(session, path, false, this);
			XMLUtilities.parseXML(is, new ManagePanelRestoreHandler());
			is.close();
			int rowCount = pluginModel.getRowCount();
			for (int i=0 ; i<rowCount ; i++)
			{
				Entry ent = pluginModel.getEntry(i);
				String name = ent.name;
				if (name != null)
				{
					pluginModel.setValueAt(selectedPlugins.contains(name), i, 0);
				}
				else
				{
					String jarPath = ent.jar;
					String jarName = jarPath.substring(1 + jarPath.lastIndexOf(File.separatorChar));
					try
					{
						pluginModel.setValueAt(jarNames.contains(jarName), i, 0);
					}
					catch (Exception e)
					{
						Log.log(Log.WARNING, this, ""Exception thrown loading: "" + jarName);
					}
				}
			}
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, this, ""Loading Pluginset Error"", e);
			return false;
		}
		pluginModel.update();
		return true;
	}

	
	
	private static Collection<String> getDeclaredJars(String jarName) throws IOException
	{
		Collection<String> jarList = new ArrayList<String>();
		PluginJAR pluginJAR = new PluginJAR(new File(jarName));
		PluginJAR.PluginCacheEntry pluginCacheEntry = PluginJAR.getPluginCache(pluginJAR);
		if (pluginCacheEntry == null)
		{
			pluginCacheEntry = pluginJAR.generateCache();
		}
		Properties cachedProperties = pluginCacheEntry.cachedProperties;

		String jars = cachedProperties.getProperty(""plugin."" + pluginCacheEntry.pluginClass + "".jars"");

		if (jars != null)
		{
			String dir = MiscUtilities.getParentOfPath(pluginJAR.getPath());
			StringTokenizer st = new StringTokenizer(jars);
			while (st.hasMoreTokens())
			{
				String _jarPath = MiscUtilities.constructPath(dir, st.nextToken());
				if (new File(_jarPath).exists())
					jarList.add(_jarPath);
			}
		}
		jarList.add(jarName);
		return jarList;
	}

	

	
	private enum KeyboardCommand
	{
		NONE,
		TAB_OUT_FORWARD,
		TAB_OUT_BACK,
		EDIT_PLUGIN,
		CLOSE_PLUGIN_MANAGER
	} 

	
	static class Entry
	{
		static final String ERROR = ""error"";
		static final String LOADED = ""loaded"";
		static final String NOT_LOADED = ""not-loaded"";

		final String status;
		
		final String jar;

		String clazz, name, version, author, docs;
		
		String description;
		EditPlugin plugin;
		
		final List<String> jars;

		
		String dataSize;

		
		Entry(String jar)
		{
			jars = new LinkedList<String>();
			this.jar = jar;
			jars.add(this.jar);
			status = NOT_LOADED;
		}

		
		Entry(PluginJAR jar)
		{
			jars = new LinkedList<String>();
			this.jar = jar.getPath();
			jars.add(this.jar);

			plugin = jar.getPlugin();
			if(plugin != null)
			{
				status = plugin instanceof EditPlugin.Broken
					? ERROR : LOADED;
				clazz = plugin.getClassName();
				name = jEdit.getProperty(""plugin.""+clazz+"".name"");
				version = jEdit.getProperty(""plugin.""+clazz+"".version"");
				author = jEdit.getProperty(""plugin.""+clazz+"".author"");
				docs = jEdit.getProperty(""plugin.""+clazz+"".docs"");
				description = jEdit.getProperty(""plugin.""+clazz+"".description"");
				String jarsProp = jEdit.getProperty(""plugin.""+clazz+"".jars"");

				if(jarsProp != null)
				{
					String directory = MiscUtilities.getParentOfPath(this.jar);

					StringTokenizer st = new StringTokenizer(jarsProp);
					while(st.hasMoreElements())
					{
						jars.add(MiscUtilities.constructPath(
							directory,st.nextToken()));
					}
				}

				String filesProp = jEdit.getProperty(""plugin.""+clazz+"".files"");

				if(filesProp != null)
				{
					String directory = MiscUtilities.getParentOfPath(this.jar);

					StringTokenizer st = new StringTokenizer(filesProp);
					while(st.hasMoreElements())
					{
						jars.add(MiscUtilities.constructPath(
							directory,st.nextToken()));
					}
				}
			}
			else
			{
				status = LOADED;
			}
		}
	} 

	
	private class PluginTableModel extends AbstractTableModel
	{
		private final List<Entry> entries;
		private int sortType = EntryCompare.NAME;
		private ConcurrentHashMap<String, Object> unloaded;
		

		
		PluginTableModel()
		{
			entries = new ArrayList<Entry>();
		} 

		
		public int getColumnCount()
		{
			return 5;
		} 

		
		@Override
		public Class getColumnClass(int columnIndex)
		{
			switch (columnIndex)
			{
				case 0: return Boolean.class;
				default: return Object.class;
			}
		} 

		
		@Override
		public String getColumnName(int column)
		{
			switch (column)
			{
				case 0:
					return "" "";
				case 1:
					return jEdit.getProperty(""manage-plugins.info.name"");
				case 2:
					return jEdit.getProperty(""manage-plugins.info.version"");
				case 3:
					return jEdit.getProperty(""manage-plugins.info.status"");
				case 4:
					return jEdit.getProperty(""manage-plugins.info.data"");
				default:
					throw new Error(""Column out of range"");
			}
		} 

		
		public Entry getEntry(int rowIndex)
		{
			return entries.get(rowIndex);
		} 

		
		public int getRowCount()
		{
			return entries.size();
		} 

		
		public Object getValueAt(int rowIndex,int columnIndex)
		{
			Entry entry = entries.get(rowIndex);
			switch (columnIndex)
			{
				case 0:
					return Boolean.valueOf(!entry.status.equals(Entry.NOT_LOADED));
				case 1:
					if(entry.name == null)
					{
						return MiscUtilities.getFileName(entry.jar);
					}
					else
					{
						return entry.name;
					}
				case 2:
					return entry.version;
				case 3:
					return jEdit.getProperty(""plugin-manager.status."" + entry.status);
				case 4:
					if (entry.dataSize == null && entry.plugin != null)
					{
						File pluginDirectory = entry.plugin.getPluginHome();
						if (null == pluginDirectory)
						{
							return null;
						}
						if (pluginDirectory.exists())
						{
							entry.dataSize = MiscUtilities.formatFileSize(IOUtilities.fileLength(pluginDirectory));
						}
						else
						{
							if (jEdit.getBooleanProperty(""plugin."" + entry.clazz + "".usePluginHome""))
							{
								entry.dataSize = MiscUtilities.formatFileSize(0);
							}
							else
							{
								entry.dataSize = jEdit.getProperty(""manage-plugins.data-size.unknown"");
							}

						}
					}
					return entry.dataSize;
				default:
					throw new Error(""Column out of range"");
			}
		} 

		
		@Override
		public boolean isCellEditable(int rowIndex, int columnIndex)
		{
			return columnIndex == 0;
		} 

		
		@Override
		public void setValueAt(Object value, int rowIndex,
			int columnIndex)
		{
			Entry entry = entries.get(rowIndex);
			if(columnIndex == 0)
			{
				PluginJAR jar = jEdit.getPluginJAR(entry.jar);
				if(jar == null)
				{
					if(value.equals(Boolean.FALSE))
						return;

					PluginJAR.load(entry.jar, true);
				}
				else
				{
					if(value.equals(Boolean.TRUE))
						return;

					unloadPluginJARWithDialog(jar);
				}
			}

			update();
		} 

		
		public void setSortType(int type)
		{
			sortType = type;
			sort(type);
		} 

		
		public void sort(int type)
		{
			List<String> savedSelection = new ArrayList<String>();
			saveSelection(savedSelection);
			Collections.sort(entries,new EntryCompare(type));
			fireTableChanged(new TableModelEvent(this));
			restoreSelection(savedSelection);
		}
		

		
		public void update()
		{
			List<String> savedSelection = new ArrayList<String>();
			saveSelection(savedSelection);
			entries.clear();

			String systemJarDir = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""jars"");
			String userJarDir;
			String settingsDirectory = jEdit.getSettingsDirectory();
			if(settingsDirectory == null)
				userJarDir = null;
			else
			{
				userJarDir = MiscUtilities.constructPath(
					settingsDirectory,""jars"");
			}

			PluginJAR[] plugins = jEdit.getPluginJARs();
			for(int i = 0; i < plugins.length; i++)
			{
				String path = plugins[i].getPath();
				if(path.startsWith(systemJarDir)
					|| (userJarDir != null
					&& path.startsWith(userJarDir)))
				{
					Entry e = new Entry(plugins[i]);
					if(!hideLibraries.isSelected()
						|| e.clazz != null)
					{
						entries.add(e);
					}
				}
			}

			String[] newPlugins = jEdit.getNotLoadedPluginJARs();
			for(int i = 0; i < newPlugins.length; i++)
			{
				Entry e = new Entry(newPlugins[i]);
				entries.add(e);
			}

			sort(sortType);
			restoreSelection(savedSelection);
		} 

		
		
		private void unloadPluginJARWithDialog(PluginJAR jar)
		{
			
			unloaded = new ConcurrentHashMap<String, Object>();
			String[] dependents = jar.getDependentPlugins();
			if(dependents.length == 0)
				unloadPluginJAR(jar);
			else
			{
				List<String> closureSet = new LinkedList<String>();
				PluginJAR.transitiveClosure(dependents, closureSet);
				List<String> listModel = new ArrayList<String>();
				listModel.addAll(closureSet);
				Collections.sort(listModel, new StandardUtilities.StringCompare<String>(true));

				int button = GUIUtilities.listConfirm(window,""plugin-manager.dependency"",
					new String[] { jar.getFile().getName() }, listModel.toArray());
				if(button == JOptionPane.YES_OPTION)
					unloadPluginJAR(jar);
			}
		} 

		
		private void unloadPluginJAR(PluginJAR jar)
		{
			String[] dependents = jar.getDependentPlugins();
			for (String dependent : dependents)
			{
				if (!unloaded.containsKey(dependent))
				{
					unloaded.put(dependent, Boolean.TRUE);
					PluginJAR _jar = jEdit.getPluginJAR(dependent);
					if(_jar != null)
						unloadPluginJAR(_jar);
				}
			}
			jEdit.removePluginJAR(jar,false);
			jEdit.setBooleanProperty(""plugin-blacklist.""+MiscUtilities.getFileName(jar.getPath()),true);
		} 

		
		
		public void saveSelection(List<String> savedSelection)
		{
			if (table != null)
			{
				int[] rows = table.getSelectedRows();
				for (int i=0 ; i<rows.length ; i++)
				{
					savedSelection.add(entries.get(rows[i]).jar);
				}
			}
		} 

		
		
		public void restoreSelection(List<String> savedSelection)
		{
			if (null != table)
			{
				table.setColumnSelectionInterval(0,0);
				if (!savedSelection.isEmpty())
				{
					int i = 0;
					int rowCount = getRowCount();
					for ( ; i<rowCount ; i++)
					{
						if (savedSelection.contains(entries.get(i).jar))
						{
							table.setRowSelectionInterval(i,i);
							break;
						}
					}
					ListSelectionModel lsm = table.getSelectionModel();
					for ( ; i<rowCount ; i++)
					{
						if (savedSelection.contains(entries.get(i).jar))
						{
							lsm.addSelectionInterval(i,i);
						}
					}
				}
				else
				{
					if (table.getRowCount() != 0)
						table.setRowSelectionInterval(0,0);
					JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
					scrollbar.setValue(scrollbar.getMinimum());
				}
			}
		} 
	} 

	
	private class TextRenderer extends DefaultTableCellRenderer
	{
		private final DefaultTableCellRenderer tcr;

		TextRenderer(DefaultTableCellRenderer tcr)
		{
			this.tcr = tcr;
		}

		@Override
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			Entry entry = pluginModel.getEntry(row);
			if (entry.status.equals(Entry.ERROR))
				tcr.setForeground(Color.red);
			else
				tcr.setForeground(UIManager.getColor(""Table.foreground""));
			return tcr.getTableCellRendererComponent(table,value,isSelected,false,row,column);
		}
	} 

	
	private class HideLibrariesButton extends JCheckBox implements ActionListener
	{
		HideLibrariesButton()
		{
			super(jEdit.getProperty(""plugin-manager.hide-libraries""));
			setSelected(jEdit.getBooleanProperty(
				""plugin-manager.hide-libraries.toggle""));
			addActionListener(this);
		}

		public void actionPerformed(ActionEvent evt)
		{
			jEdit.setBooleanProperty(
				""plugin-manager.hide-libraries.toggle"",
				isSelected());
			ManagePanel.this.update();
		}
	} 

	
	
	private class RestoreButton extends RolloverButton implements ActionListener
	{
		RestoreButton()
		{
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""manage-plugins.restore.icon"")));
			addActionListener(this);
			setToolTipText(""Choose a PluginSet, select/deselect plugins based on set."");
		}

		public void actionPerformed(ActionEvent e)
		{
			String path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET,
				jEdit.getSettingsDirectory() + File.separator);
			String[] selectedFiles = GUIUtilities.showVFSFileDialog(ManagePanel.this.window,
				jEdit.getActiveView(), path, VFSBrowser.OPEN_DIALOG, false);
			if (selectedFiles == null || selectedFiles.length != 1) return;
			path = selectedFiles[0];
			boolean success = loadPluginSet(path);
			if (success)
			{
				jEdit.setProperty(PluginManager.PROPERTY_PLUGINSET, path);
				EditBus.send(new PropertiesChanged(PluginManager.getInstance()));
			}

		}
	}

	
	
	private class SaveButton extends RolloverButton implements ActionListener
	{
		SaveButton()
		{
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""manage-plugins.save.icon"")));
			setToolTipText(""Save Currently Checked Plugins Set"");
			addActionListener(this);
			setEnabled(true);
		}

		void saveState(String vfsURL, List<Entry> pluginList)
		{
			StringBuilder sb = new StringBuilder(""<pluginset>\n "");

			for (Entry entry: pluginList)
			{
				String jarName = entry.jar.substring(1+entry.jar.lastIndexOf(File.separatorChar));
				sb.append(""   <plugin name=\"""").append(entry.name).append(""\"" jar=\"""");
				sb.append(jarName).append(""\"" />\n "");
			}
			sb.append(""</pluginset>\n"");

			VFS vfs = VFSManager.getVFSForPath(vfsURL);
			Object session = vfs.createVFSSession(vfsURL, ManagePanel.this);
			Writer writer = null;
			try
			{
				OutputStream os = vfs._createOutputStream(session, vfsURL, ManagePanel.this);
				writer = new BufferedWriter(new OutputStreamWriter(os));
				writer.write(sb.toString());
			}
			catch (Exception e)
			{
				Log.log(Log.ERROR, this, ""Saving State Error"", e);
			}
			finally
			{
				IOUtilities.closeQuietly(writer);
			}

		}

		public void actionPerformed(ActionEvent e)
		{
			String path = jEdit.getProperty(""plugin-manager.pluginset.path"", jEdit.getSettingsDirectory() + File.separator);
			VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
				ManagePanel.this.window, jEdit.getActiveView(),
				path, VFSBrowser.SAVE_DIALOG, false , true);
			String[] fileselections = fileChooser.getSelectedFiles();
			List<Entry> pluginSelections = new ArrayList<Entry>();
			if (fileselections == null || fileselections.length != 1) return;

			PluginJAR[] jars = jEdit.getPluginJARs();
			for (PluginJAR jar : jars)
			{
				if (jar.getPlugin() != null)
				{
					Entry entry = new Entry (jar);
					pluginSelections.add(entry);
				}
			}
			saveState(fileselections[0], pluginSelections);
			jEdit.setProperty(""plugin-manager.pluginset.path"", fileselections[0]);
			EditBus.send(new PropertiesChanged(PluginManager.getInstance()));
		}
	}

	
	
	private class RemoveButton extends JButton implements ListSelectionListener, ActionListener
	{
		RemoveButton()
		{
			super(jEdit.getProperty(""manage-plugins.remove""));
			table.getSelectionModel().addListSelectionListener(this);
			addActionListener(this);
			setEnabled(false);
		}

		public void actionPerformed(ActionEvent evt)
		{
			int[] selected = table.getSelectedRows();

			List<String> listModel = new LinkedList<String>();
			Roster roster = new Roster();
			Set<String> jarsToRemove = new HashSet<String>();
			
			
			
			Set<String> loadedJarsToRemove = new HashSet<String>();
			for(int i = 0; i < selected.length; i++)
			{
				Entry entry = pluginModel.getEntry(selected[i]);
				if (entry.status.equals(Entry.NOT_LOADED))
				{
					if (entry.jar != null)
					{
						try
						{
							Collection<String> jarList = getDeclaredJars(entry.jar);
							jarsToRemove.addAll(jarList);
						}
						catch (IOException e)
						{
							Log.log(Log.ERROR, this, e);
						}
					}
				}
				else
				{
					jarsToRemove.addAll(entry.jars);
					loadedJarsToRemove.addAll(entry.jars);
				}
				table.getSelectionModel().removeSelectionInterval(selected[i], selected[i]);
			}

			for (String jar : jarsToRemove)
			{
				listModel.add(jar);
				roster.addRemove(jar);
			}

			int button = GUIUtilities.listConfirm(window,
				""plugin-manager.remove-confirm"",
				null,listModel.toArray());
			if(button == JOptionPane.YES_OPTION)
			{

				List<String> closureSet = new ArrayList<String>();
				PluginJAR.transitiveClosure(loadedJarsToRemove.toArray(new String[loadedJarsToRemove.size()]), closureSet);
				closureSet.removeAll(listModel);
				if (closureSet.isEmpty())
				{
					button = JOptionPane.YES_OPTION;
				}
				else
				{
					button = GUIUtilities.listConfirm(window,""plugin-manager.remove-dependencies"",
						null, closureSet.toArray());
					Collections.sort(closureSet, new StandardUtilities.StringCompare<String>(true));
				}
				if(button == JOptionPane.YES_OPTION)
				{
					for (String jarName:closureSet)
					{
						PluginJAR pluginJAR = jEdit.getPluginJAR(jarName);
						jEdit.removePluginJAR(pluginJAR, false);
					}
					roster.performOperationsInAWTThread(window);
					pluginModel.update();
					if (table.getRowCount() != 0)
					{
						table.setRowSelectionInterval(0,0);
					}
					table.setColumnSelectionInterval(0,0);
					JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
					scrollbar.setValue(scrollbar.getMinimum());
				}
			}
		}

		public void valueChanged(ListSelectionEvent e)
		{
			if (table.getSelectedRowCount() == 0)
				setEnabled(false);
			else
				setEnabled(true);
		}
	} 

	
	private class FindOrphan extends JButton implements ActionListener
	{
		private FindOrphan()
		{
			super(jEdit.getProperty(""plugin-manager.findOrphan.label""));
			addActionListener(this);
		}

		public void actionPerformed(ActionEvent e)
		{
			PluginJAR[] pluginJARs = jEdit.getPluginJARs();
			Set<String> neededJars = new HashSet<String>();

			Map<String, String> jarlibs = new HashMap<String, String>();
			for (PluginJAR pluginJAR : pluginJARs)
			{
				EditPlugin plugin = pluginJAR.getPlugin();
				if (plugin == null)
				{
					jarlibs.put(new File(pluginJAR.getPath()).getName(), pluginJAR.getPath());
				}
				else
				{
					Set<String> strings = plugin.getPluginJAR().getRequiredJars();
					for (String string : strings)
					{
						neededJars.add(new File(string).getName());
					}
				}
			}

			String[] notLoadedJars = jEdit.getNotLoadedPluginJARs();
			for (int i = 0; i < notLoadedJars.length; i++)
			{
				PluginJAR pluginJAR = new PluginJAR(new File(notLoadedJars[i]));
				PluginJAR.PluginCacheEntry pluginCacheEntry = PluginJAR.getPluginCache(pluginJAR);
				try
				{
					if (pluginCacheEntry == null)
					{
						pluginCacheEntry = pluginJAR.generateCache();
					}
					if (pluginCacheEntry.pluginClass == null)
					{
						
						jarlibs.put(new File(notLoadedJars[i]).getName(), notLoadedJars[i]);
						continue;
					}


					Properties cachedProperties = pluginCacheEntry.cachedProperties;

					String jars = cachedProperties.getProperty(""plugin."" + pluginCacheEntry.pluginClass + "".jars"");

					if (jars != null)
					{
						StringTokenizer st = new StringTokenizer(jars);
						while (st.hasMoreTokens())
						{
							neededJars.add(st.nextToken());
						}
					}
				}
				catch (IOException e1)
				{
					Log.log(Log.ERROR, this, e);
				}
			}

			List<String> removingJars = new ArrayList<String>();
			Set<String> jarlibsKeys = jarlibs.keySet();
			for (String jar : jarlibsKeys)
			{
				if (!neededJars.contains(jar))
				{
					removingJars.add(jar);
					Log.log(Log.MESSAGE, this, ""It seems that this jar do not belong to any plugin "" +jar);
				}
			}
			if(removingJars.isEmpty())
			{
				GUIUtilities.message(ManagePanel.this, ""plugin-manager.noOrphan"", null);
				return;
			}

			String[] strings = removingJars.toArray(new String[removingJars.size()]);
			List<String> mustRemove = new ArrayList<String>();
			int ret = GUIUtilities.listConfirm(ManagePanel.this,
							   ""plugin-manager.findOrphan"",
							   null,
							   strings,
							   mustRemove);
			if (ret != JOptionPane.OK_OPTION || mustRemove.isEmpty())
				return;

			Roster roster = new Roster();
			for (int i = 0; i < mustRemove.size(); i++)
			{
				String entry = mustRemove.get(i);
				roster.addRemove(jarlibs.get(entry));
			}

			roster.performOperationsInAWTThread(window);
			pluginModel.update();
			if (table.getRowCount() != 0)
			{
				table.setRowSelectionInterval(0,0);
			}
			table.setColumnSelectionInterval(0,0);
			JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
			scrollbar.setValue(scrollbar.getMinimum());
			table.repaint();
		}
	} 

	
	private class HelpButton extends JButton implements ListSelectionListener, ActionListener
	{
		private URL docURL;

		HelpButton()
		{
			super(jEdit.getProperty(""manage-plugins.help""));
			table.getSelectionModel().addListSelectionListener(this);
			addActionListener(this);
			setEnabled(false);
		}

		public void actionPerformed(ActionEvent evt)
		{
			new HelpViewer(docURL);
		}

		public void valueChanged(ListSelectionEvent e)
		{
			if (table.getSelectedRowCount() == 1)
			{
				try
				{
					Entry entry = pluginModel.getEntry(table.getSelectedRow());
					String label = entry.clazz;
					String docs = entry.docs;
					if (label != null)
					{
						EditPlugin plug = jEdit.getPlugin(label, false);
						PluginJAR jar = null;
						if (plug != null) jar = plug.getPluginJAR();
						if(jar != null && docs != null)
						{
							URL url = jar.getClassLoader().getResource(docs);
							if(url != null)
							{
								docURL = url;
								setEnabled(true);
								return;
							}
						}
					}
				}
				catch (Exception ex)
				{
					Log.log(Log.ERROR, this, ""ManagePanel HelpButton Update"", ex);
				}
			}
			setEnabled(false);
		}
	} 

	
	private static class EntryCompare implements Comparator<Entry>
	{
		public static final int NAME = 1;
		public static final int STATUS = 2;

		private final int type;

		EntryCompare(int type)
		{
			this.type = type;
		}

		public int compare(Entry e1, Entry e2)
		{
			if (type == NAME)
				return compareNames(e1,e2);
			else
			{
				int result;
				if ((result = e1.status.compareToIgnoreCase(e2.status)) == 0)
					return compareNames(e1,e2);
				return result;
			}
		}

		private static int compareNames(Entry e1, Entry e2)
		{
			String s1;
			if(e1.name == null)
				s1 = MiscUtilities.getFileName(e1.jar);
			else
				s1 = e1.name;
			String s2;
			if(e2.name == null)
				s2 = MiscUtilities.getFileName(e2.jar);
			else
				s2 = e2.name;

			return s1.compareToIgnoreCase(s2);
		}
	} 

	
	private class HeaderMouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			if (evt.getSource() == table.getTableHeader())
			{
				switch(table.getTableHeader().columnAtPoint(evt.getPoint()))
				{
					case 1:
						pluginModel.setSortType(EntryCompare.NAME);
						break;
					case 3:
						pluginModel.setSortType(EntryCompare.STATUS);
						break;
					default:
						break;
				}
			}
			else
			{
				if (GUIUtilities.isPopupTrigger(evt))
				{
					int row = table.rowAtPoint(evt.getPoint());
					if (row != -1 &&
					    !table.isRowSelected(row))
					{
						table.setRowSelectionInterval(row,row);
					}
					if (popup == null)
					{
						popup = new JPopupMenu();
						JMenuItem item = GUIUtilities.loadMenuItem(""plugin-manager.cleanup"");
						item.addActionListener(new CleanupActionListener());
						popup.add(item);
					}
					GUIUtilities.showPopupMenu(popup, table, evt.getX(), evt.getY());
				}
			}
		}

		
		private class CleanupActionListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{

				int[] ints = table.getSelectedRows();
				List<String> list = new ArrayList<String>(ints.length);
				List<Entry> entries = new ArrayList<Entry>(ints.length);
				for (int i = 0; i < ints.length; i++)
				{
					Entry entry = pluginModel.getEntry(ints[i]);
					if (entry.plugin != null)
					{
						list.add(entry.name);
						entries.add(entry);
					}
				}

				String[] strings = list.toArray(new String[list.size()]);
				int ret = GUIUtilities.listConfirm(ManagePanel.this,
								   ""plugin-manager.cleanup"",
								   null,
								   strings);
				if (ret != JOptionPane.OK_OPTION)
					return;

				for (int i = 0; i < entries.size(); i++)
				{
					Entry entry = entries.get(i);
					File path = entry.plugin.getPluginHome();
					Log.log(Log.NOTICE, this, ""Removing data of plugin "" + entry.name + "" home=""+path);
					FileVFS.recursiveDelete(path);
					entry.dataSize = null;
				}
				table.repaint();
			}
		} 
	} 

	
	private class KeyboardAction extends AbstractAction
	{
		private KeyboardCommand command = KeyboardCommand.NONE;

		KeyboardAction(KeyboardCommand command)
		{
			this.command = command;
		}

		public void actionPerformed(ActionEvent evt)
		{
			switch (command)
			{
			case TAB_OUT_FORWARD:
				KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent();
				break;
			case TAB_OUT_BACK:
				KeyboardFocusManager.getCurrentKeyboardFocusManager().focusPreviousComponent();
				break;
			case EDIT_PLUGIN:
				int[] rows = table.getSelectedRows();
				for (int i = 0; i < rows.length; i++)
				{
					Object st = pluginModel.getValueAt(rows[i], 0);
					pluginModel.setValueAt(st.equals(Boolean.FALSE), rows[i], 0);
				}
				break;
			case CLOSE_PLUGIN_MANAGER:
				window.ok();
				break;
			default:
				throw new InternalError();
			}
		}
	} 

	
	private class TableFocusHandler extends FocusAdapter
	{
		@Override
		public void focusGained(FocusEvent fe)
		{
			if (table.getSelectedRow() == -1)
			{
				table.setRowSelectionInterval(0,0);
				JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
				scrollbar.setValue(scrollbar.getMinimum());
			}
			if (table.getSelectedColumn() == -1)
			{
				table.setColumnSelectionInterval(0,0);
			}
		}
	} 

	
	private class TableSelectionListener implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent e)
		{
			int row = table.getSelectedRow();
			if (row != -1)
			{
				Entry entry = pluginModel.getEntry(row);
				pluginDetailPanel.setPlugin(entry);
			}
		}
	} 
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.JEditHistoryModelSaver,4,1,0,7,54,4,1,7,3,1.0,318,1.0,0,0.0,0.5,0,0,77.75,9,4.5,0,"
package org.gjt.sp.jedit.gui;

import org.gjt.sp.util.Log;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.jEdit;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.CharacterCodingException;
import java.util.*;


public class JEditHistoryModelSaver implements HistoryModelSaver
{
	
	public Map<String, HistoryModel> load(Map<String, HistoryModel> models)
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return models;

		history = new File(MiscUtilities.constructPath(
			settingsDirectory,""history""));
		if(!history.exists())
			return models;

		historyModTime = history.lastModified();

		Log.log(Log.MESSAGE,HistoryModel.class,""Loading history"");

		if(models == null)
			models = Collections.synchronizedMap(new HashMap<String, HistoryModel>());

		BufferedReader in = null;
		try
		{
			
			
			
			try
			{
				
				
				in = new BufferedReader(new InputStreamReader(
					new FileInputStream(history),
					Charset.forName(""UTF-8"").newDecoder()));
				models.putAll(loadFromReader(in));
			}
			catch(CharacterCodingException e)
			{
				
				in.close();
				Log.log(Log.MESSAGE,HistoryModel.class,
					""Failed to load history with UTF-8."" +
					"" Fallbacking to the system default encoding."");

				in = new BufferedReader(new FileReader(history));
				models.putAll(loadFromReader(in));
			}
		}
		catch(FileNotFoundException fnf)
		{
			
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
		finally
		{
			IOUtilities.closeQuietly(in);
		}
		return models;
	} 

	
	public boolean save(Map<String, HistoryModel> models)
	{
		Log.log(Log.MESSAGE,HistoryModel.class,""Saving history"");
		File file1 = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(), ""#history#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(), ""history""));
		if(file2.exists() && file2.lastModified() != historyModTime)
		{
			Log.log(Log.WARNING,HistoryModel.class,file2
				+ "" changed on disk; will not save history"");
			return false;
		}

		jEdit.backupSettingsFile(file2);

		String lineSep = System.getProperty(""line.separator"");

		BufferedWriter out = null;

		try
		{
			out = new BufferedWriter(new OutputStreamWriter(
				new FileOutputStream(file1), ""UTF-8""));

			if(models != null)
			{
				Collection<HistoryModel> values = models.values();
				for (HistoryModel model : values)
				{
					if(model.getSize() == 0)
						continue;

					out.write('[');
					out.write(StandardUtilities.charsToEscapes(
						model.getName(),TO_ESCAPE));
					out.write(']');
					out.write(lineSep);

					for(int i = 0; i < model.getSize(); i++)
					{
						out.write(StandardUtilities.charsToEscapes(
							model.getItem(i),
							TO_ESCAPE));
						out.write(lineSep);
					}
				}
			}

			out.close();

			
			file2.delete();
			file1.renameTo(file2);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
		finally
		{
			IOUtilities.closeQuietly(out);
		}

		historyModTime = file2.lastModified();
		return true;
	} 

	
	private static final String TO_ESCAPE = ""\r\n\t\\\""'[]"";
	private static File history;
	private static long historyModTime;

	
	private static Map<String, HistoryModel> loadFromReader(BufferedReader in)
		throws IOException
	{
		Map<String, HistoryModel> result = new HashMap<String, HistoryModel>();

		HistoryModel currentModel = null;
		String line;

		while((line = in.readLine()) != null)
		{
			if(line.length() > 0 && line.charAt(0) == '[' && line.charAt(line.length() - 1) == ']')
			{
				if(currentModel != null)
				{
					result.put(currentModel.getName(),
						currentModel);
				}

				String modelName = MiscUtilities
					.escapesToChars(line.substring(
					1,line.length() - 1));
				currentModel = new HistoryModel(
					modelName);
			}
			else if(currentModel == null)
			{
				throw new IOException(""History data starts""
					+ "" before model name"");
			}
			else
			{
				currentModel.addElement(MiscUtilities
					.escapesToChars(line));
			}
		}

		if(currentModel != null)
		{
			result.put(currentModel.getName(),currentModel);
		}

		return result;
	} 

	

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.HistoryText,25,1,1,9,60,62,6,6,19,0.729166667,496,1.0,1,0.0,0.205714286,0,0,18.6,6,1.92,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.text.*;
import javax.swing.event.MouseInputAdapter;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;



public class HistoryText
{
	
	public HistoryText(JTextComponent text, String name)
	{
		this.text = text;
		setModel(name);
		index = -1;
	} 

	
	public void fireActionPerformed()
	{
	} 

	
	public int getIndex()
	{
		return index;
	} 

	
	public void setIndex(int index)
	{
		this.index = index;
	} 

	
	
	public HistoryModel getModel()
	{
		return historyModel;
	} 

	
	
	public void setModel(String name)
	{
		if(name == null)
			historyModel = null;
		else
			historyModel = HistoryModel.getModel(name);
		index = -1;
	} 

	
	
	public void setInstantPopups(boolean instantPopups)
	{
		this.instantPopups = instantPopups;
	} 

	
	
	public boolean getInstantPopups()
	{
		return instantPopups;
	} 

	
	
	public void addCurrentToHistory()
	{
		if(historyModel != null)
			historyModel.addItem(getText());
		index = 0;
	} 

	
	public void doBackwardSearch()
	{
		if(historyModel == null)
			return;

		if(text.getSelectionEnd() != getDocument().getLength())
		{
			text.setCaretPosition(getDocument().getLength());
		}

		int start = getInputStart();
		String t = getText().substring(0,
			text.getSelectionStart() - start);
		if(t == null)
		{
			historyPrevious();
			return;
		}

		for(int i = index + 1; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(t))
			{
				text.replaceSelection(item.substring(t.length()));
				text.select(getInputStart() + t.length(),
					getDocument().getLength());
				index = i;
				return;
			}
		}

		text.getToolkit().beep();
	} 

	
	public void doForwardSearch()
	{
		if(historyModel == null)
			return;

		if(text.getSelectionEnd() != getDocument().getLength())
		{
			text.setCaretPosition(getDocument().getLength());
		}

		int start = getInputStart();
		String t = getText().substring(0,
			text.getSelectionStart() - start);
		if(t == null)
		{
			historyNext();
			return;
		}

		for(int i = index - 1; i >= 0; i--)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(t))
			{
				text.replaceSelection(item.substring(t.length()));
				text.select(getInputStart() + t.length(),
					getDocument().getLength());
				index = i;
				return;
			}
		}

		text.getToolkit().beep();
	} 

	
	public void historyPrevious()
	{
		if(historyModel == null)
			return;

		if(index == historyModel.getSize() - 1)
			text.getToolkit().beep();
		else if(index == -1)
		{
			current = getText();
			setText(historyModel.getItem(0));
			index = 0;
		}
		else
		{
			
			int newIndex = index + 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} 

	
	public void historyNext()
	{
		if(historyModel == null)
			return;

		if(index == -1)
			text.getToolkit().beep();
		else if(index == 0)
			setText(current);
		else
		{
			
			int newIndex = index - 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} 
	
	
	public Document getDocument()
	{
		return text.getDocument();
	} 
	
	
	
	public String getText()
	{
		return text.getText();
	} 
	
	
	
	public void setText(String text)
	{
		this.index = -1;
		this.text.setText(text);
	} 

	
	
	public int getInputStart()
	{
		return 0;
	} 

	
	public void showPopupMenu(String t, int x, int y)
	{
		if(historyModel == null)
			return;

		text.requestFocus();

		if(popup != null && popup.isVisible())
		{
			popup.setVisible(false);
			popup = null;
			return;
		}

		popup = new JPopupMenu()
		{
			@Override
			public void setVisible(boolean b)
			{
				if (!b)
				{
					popup = null;
				}
				super.setVisible(b);
			}
		};
		JMenuItem caption = new JMenuItem(jEdit.getProperty(
			""history.caption""));
		caption.addActionListener(new ActionListener()
		{
		  public void actionPerformed(ActionEvent e) 
		  {
		    new ListModelEditor().open(historyModel);
		  }
		});		
 		popup.add(caption);
 		popup.addSeparator();

		for(int i = 0; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(t))
			{
				JMenuItem menuItem = new JMenuItem(item);
				menuItem.setActionCommand(String.valueOf(i));
				menuItem.addActionListener(
					new ActionHandler());
				popup.add(menuItem);
			}
		}

		GUIUtilities.showPopupMenu(popup,text,x,y,false);
	} 

	
	public void showPopupMenu(boolean search)
	{
		if(search)
			showPopupMenu(getText().substring(getInputStart(),
				text.getSelectionStart()),0,text.getHeight());
		else
			showPopupMenu("""",0,text.getHeight());
	} 

	
	private JTextComponent text;
	private HistoryModel historyModel;
	private int index;
	private String current;
	private JPopupMenu popup;
	private boolean instantPopups;
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			int ind = Integer.parseInt(evt.getActionCommand());
			if(ind == -1)
			{
				if(index != -1)
					setText(current);
			}
			else
			{
				setText(historyModel.getItem(ind));
				index = ind;
			}
			if(instantPopups)
			{
				addCurrentToHistory();
				fireActionPerformed();
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockingLayoutManager,19,1,0,17,56,157,2,17,7,0.977777778,401,1.0,2,0.0,0.342105263,0,0,19.57894737,12,2.8947,0,"package org.gjt.sp.jedit.gui;

import java.util.HashMap;
import java.util.Map;

import javax.swing.JOptionPane;

import org.gjt.sp.jedit.ActionSet;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.Mode;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.gui.DockableWindowManager.DockingLayout;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.msg.EditPaneUpdate;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.options.DockingOptionPane;


public class DockingLayoutManager implements EBComponent
{

	private static final String NO_SETTINGS_MESSAGE = ""no-settings.message"";
	private static final String SAVE_LAYOUT_FAILED = ""save-layout-failed.message"";
	private static final String LOAD_LAYOUT_TITLE = ""load-layout.title"";
	private static final String LOAD_LAYOUT_MESSAGE = ""load-layout.message"";
	private static final String SAVE_LAYOUT_TITLE = ""save-layout.title"";
	private static final String SAVE_LAYOUT_MESSAGE = ""save-layout.message"";
	private static ActionSet actions;
	private static DockingLayoutManager instance;
	private Map<View, String> currentMode;
	
	private DockingLayoutManager()
	{
		currentMode = new HashMap<View, String>();
	}
	private static boolean save(View view, String layoutName)
	{
		DockingLayout docking = view.getViewConfig().docking; 
		if (docking != null)
		{
			boolean ret = docking.saveLayout(layoutName, DockingLayout.NO_VIEW_INDEX);
			if (! ret)
				return false;
			addAction(layoutName);
		}
		return true;
	}
	
	public static void saveAs(View view)
	{
		if (jEdit.getSettingsDirectory() == null)
		{
			JOptionPane.showMessageDialog(view, jEdit.getProperty(NO_SETTINGS_MESSAGE));
			return;
		}
		String layoutName = JOptionPane.showInputDialog(view,
			jEdit.getProperty(SAVE_LAYOUT_MESSAGE),
			jEdit.getProperty(SAVE_LAYOUT_TITLE),
			JOptionPane.QUESTION_MESSAGE);
		if (layoutName == null)
			return;
		if (! save(view, layoutName))
			JOptionPane.showMessageDialog(view, jEdit.getProperty(SAVE_LAYOUT_FAILED));
	}
	
	private static void load(View view, String layoutName)
	{
		DockingLayout docking = View.getDockingFrameworkProvider().createDockingLayout();
		if (docking.loadLayout(layoutName, DockingLayout.NO_VIEW_INDEX))
			view.getDockableWindowManager().setDockingLayout(docking);
	}
	
	public static void load(View view)
	{
		if (jEdit.getSettingsDirectory() == null)
		{
			JOptionPane.showMessageDialog(view, jEdit.getProperty(NO_SETTINGS_MESSAGE));
			return;
		}
		String layoutName = (String) JOptionPane.showInputDialog(view,
			jEdit.getProperty(LOAD_LAYOUT_MESSAGE),
			jEdit.getProperty(LOAD_LAYOUT_TITLE),
			JOptionPane.QUESTION_MESSAGE,
			null,
			getSavedLayouts(),
			null);
		if (layoutName == null)
			return;
		load(view, layoutName);
	}

	private static String[] getSavedLayouts()
	{
		DockingLayout docking = View.getDockingFrameworkProvider().createDockingLayout();
		String[] layouts = null;
		if (docking != null)
			layouts = docking.getSavedLayouts();
		if (layouts == null)
			return new String[0];
		return layouts;
	}
	
	private static void addAction(String layoutName)
	{
		if ((actions != null) && (! actions.contains(layoutName)))
			actions.addAction(new LoadPerspectiveAction(layoutName));
	}
	
	public static void init()
	{
		createActions();
		instance = new DockingLayoutManager();
		EditBus.addToBus(instance);
	}
	
	private static void createActions()
	{
		actions = new ActionSet(""Docking Layouts"");
		String[] layouts = getSavedLayouts();
		for (String layout: layouts)
			addAction(layout);
		jEdit.addActionSet(actions);
		actions.initKeyBindings();
	}
	
	public static void removeActions()
	{
		jEdit.removeActionSet(actions);
	}

	private static class LoadPerspectiveAction extends EditAction
	{
		private static final String LOAD_PREFIX = ""load-"";

		public LoadPerspectiveAction(String layoutName)
		{
			super(LOAD_PREFIX + layoutName, new String[] { layoutName });
			jEdit.setTemporaryProperty(LOAD_PREFIX + layoutName + "".label"", LOAD_PREFIX + layoutName);
		}
		
		@Override
		public void invoke(View view)
		{
			DockingLayoutManager.load(view, (String) args[0]);
		}
	}

	private boolean canChangeEditMode(EBMessage message)
	{
		if (message instanceof BufferUpdate)
		{
			BufferUpdate bu = (BufferUpdate) message;
			Object what = bu.getWhat();
			if ((what == BufferUpdate.CLOSED) ||
				(what == BufferUpdate.CREATED) ||
				(what == BufferUpdate.PROPERTIES_CHANGED))
			{
				return true;
			}
		}
		else if (message instanceof EditPaneUpdate)
		{
			EditPaneUpdate ep = (EditPaneUpdate) message;
			Object what = ep.getWhat();
			if ((what == EditPaneUpdate.BUFFER_CHANGED) ||
				(what == EditPaneUpdate.CREATED))
			{
				return true;
			}
		}
		return false;
	}

	public void handleMessage(EBMessage message)
	{
		boolean autoLoadModeLayout = jEdit.getBooleanProperty(
			DockingOptionPane.AUTO_LOAD_MODE_LAYOUT_PROP, false);
		if (! autoLoadModeLayout)
			return;
		if (message instanceof ViewUpdate)
		{
			ViewUpdate vu = (ViewUpdate) message;
			if (vu.getWhat() == ViewUpdate.CLOSED)
			{
				View view = jEdit.getActiveView();
				String mode = currentMode.get(view);
				saveModeLayout(view, mode);
				return;
			}
		}
		
		View view = jEdit.getActiveView();
		if (view == null)
			return;
		if (! canChangeEditMode(message))
			return;
		String newMode = getCurrentEditMode(view);
		String mode = currentMode.get(view);
		boolean sameMode =
			(mode == null && newMode == null) ||
			(mode != null && mode.equals(newMode));
		if (! sameMode)
		{
			boolean autoSaveModeLayout = jEdit.getBooleanProperty(
				DockingOptionPane.AUTO_SAVE_MODE_LAYOUT_PROP, false);
			if (autoSaveModeLayout)
				saveModeLayout(view, mode);
			currentMode.put(view, newMode);
			loadModeLayout(view, newMode);
		}
	}

	private String getCurrentEditMode(View view)
	{
		Buffer buffer = view.getBuffer();
		if (buffer == null)
			return null;
		Mode bufferMode = buffer.getMode();
		if (bufferMode == null)
			return null;
		return bufferMode.getName();
	}

	private static final String GLOBAL_MODE = ""DEFAULT"";
	
	private void saveModeLayout(View view, String mode)
	{
		String modeLayout = getModePerspective(mode);
		if (modeLayout == null)
			return;
		save(view, modeLayout);
	}
	
	private void loadModeLayout(View view, String mode)
	{
		String modeLayout = getModePerspective(mode);
		if (modeLayout == null)
			return;
		load(view, modeLayout);
	}

	public static void loadCurrentModeLayout(View view)
	{
		if (view == null)
			return;
		String mode = instance.getCurrentEditMode(view);
		instance.loadModeLayout(view, mode);
	}
	
	public static void saveCurrentModeLayout(View view)
	{
		if (view == null)
			return;
		String mode = instance.getCurrentEditMode(view);
		instance.saveModeLayout(view, mode);
	}
	
	private String getModePerspective(String mode)
	{
		if (mode == null)
			mode = GLOBAL_MODE;
		return ""mode-"" + mode;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.EditPlugin,22,1,3,24,47,231,19,9,18,1.0,322,0.0,1,0.0,0.227272727,0,0,13.59090909,5,1.6818,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.menu.EnhancedMenu;
import org.gjt.sp.util.Log;

import javax.swing.*;
import java.io.*;
import java.util.Vector;


public abstract class EditPlugin
{
	
	
	public void start() {}
	

	
	
	public void stop() {} 

	
	
	public File getPluginHome()
	{
		return getPluginHome(getClassName());
	} 

	
	
	public static File getPluginHome(Class<? extends EditPlugin> clazz)
	{
		return getPluginHome(clazz.getName());
	} 

	
	
	public static File getPluginHome(EditPlugin plugin)
	{
		return getPluginHome(plugin.getClassName());
	} 

	
	
	private static File getPluginHome(String pluginClassName)
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if (settingsDirectory == null)
			return null;

		File file = new File(settingsDirectory, ""plugins"");
		if (!file.isDirectory()) 
		{
			if (!file.mkdir()) 
			{
				Log.log(Log.ERROR, EditPlugin.class, ""Can't create directory:"" + file.getAbsolutePath());
			}
		}
		return new File(file, pluginClassName);
	} 

	
	
	public static InputStream getResourceAsStream(Class<? extends EditPlugin> clazz, String path)
	{
		return getResourceAsStream(clazz.getName(), path);
	} 

	
	
	public static InputStream getResourceAsStream(EditPlugin plugin, String path)
	{
		return getResourceAsStream(plugin.getClassName(), path);
	} 

	
	
	private static InputStream getResourceAsStream(String pluginClassName, String path)
	{
		try 
		{
			File file = getResourcePath(pluginClassName, path);
			if (file == null || !file.exists())
				return null;
			return new FileInputStream(file);
		} 
		catch (IOException e)
		{
			return null;
		}
	} 

	
	
	public static OutputStream getResourceAsOutputStream(Class<? extends EditPlugin> clazz, String path)
	{
		return getResourceAsOutputStream(clazz.getName(), path);
	} 

	
	
	public static OutputStream getResourceAsOutputStream(EditPlugin plugin, String path)
	{
		return getResourceAsOutputStream(plugin.getClassName(), path);
	} 

	
	
	private static OutputStream getResourceAsOutputStream(String pluginClassName, String path)
	{
		try 
		{
			File file = getResourcePath(pluginClassName, path);
			if (file == null)
				return null;
			File parentFile = file.getParentFile();
			if (!parentFile.exists())
			{
				if (!parentFile.mkdirs())
				{
					Log.log(Log.ERROR, EditPlugin.class, ""Unable to create folder "" + parentFile.getPath());
					return null;
				}
			}
			return new FileOutputStream(file);
		}
		catch (IOException e)
		{
			return null;
		}
	} 

	
	
	public static File getResourcePath(Class<? extends EditPlugin> clazz, String path)
	{
		return getResourcePath(clazz.getName(), path);
	} 

	
	
	public static File getResourcePath(EditPlugin plugin, String path)
	{
		return getResourcePath(plugin.getClassName(), path);
	} 

	
	
	private static File getResourcePath(String pluginClassName, String path)
	{
		File home = getPluginHome(pluginClassName);
		if (home == null)
			return null;
		return new File(home, path);
	} 

	
	
	public String getClassName()
	{
		return getClass().getName();
	} 

	
	
	public PluginJAR getPluginJAR()
	{
		return jar;
	} 

	
	
	public final JMenuItem createMenuItems()
	{
		if(this instanceof Broken)
			return null;

		String menuItemName = jEdit.getProperty(""plugin."" +
			getClassName() + "".menu-item"");
		if(menuItemName != null)
			return GUIUtilities.loadMenuItem(menuItemName);

		String menuProperty = ""plugin."" + getClassName() + "".menu"";
		String codeProperty = ""plugin."" + getClassName() + "".menu.code"";
		if(jEdit.getProperty(menuProperty) != null
			|| jEdit.getProperty(codeProperty) != null)
		{
			String pluginName = jEdit.getProperty(""plugin."" +
				getClassName() + "".name"");
			return new EnhancedMenu(menuProperty,pluginName);
		}

		return null;
	} 

	
	
	public final JMenuItem createBrowserMenuItems()
	{
		if(this instanceof Broken)
			return null;

		String menuItemName = jEdit.getProperty(""plugin."" +
			getClassName() + "".browser-menu-item"");
		if(menuItemName != null)
		{
			return GUIUtilities.loadMenuItem(
				VFSBrowser.getActionContext(),
				menuItemName,
				false);
		}

		String menuProperty = ""plugin."" + getClassName() + "".browser-menu"";
		if(jEdit.getProperty(menuProperty) != null)
		{
			String pluginName = jEdit.getProperty(""plugin."" +
				getClassName() + "".name"");
			return new EnhancedMenu(menuProperty,pluginName,
				VFSBrowser.getActionContext());
		}

		return null;
	} 

	

	
	
	public void createMenuItems(Vector menuItems) {} 

	
	
	public void createOptionPanes(OptionsDialog optionsDialog) {} 

	

	
	PluginJAR jar;
	

	
	
	public static class Broken extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}

		
		Broken(PluginJAR jar, String clazz)
		{
			this.jar = jar;
			this.clazz = clazz;
		}

		
		private String clazz;
	} 

	
	
	public static class Deferred extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}

		
		Deferred(PluginJAR jar, String clazz)
		{
			this.jar = jar;
			this.clazz = clazz;
		}

		EditPlugin loadPluginClass()
		{
			return null;
		}

		public String toString()
		{
			return ""Deferred["" + clazz + ']';
		}

		
		private String clazz;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.VFSFile,33,1,4,47,67,444,41,10,31,0.929166667,529,0.2,0,0.0,0.215909091,0,0,14.57575758,9,1.8182,0,"

package org.gjt.sp.jedit.io;


import java.awt.Color;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.browser.FileCellRenderer;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.IOUtilities;

import javax.swing.*;



public class VFSFile implements Serializable
{
	
	
	public static int findCompletion(VFSFile[] files, int start, int end,
		String str, boolean dirsOnly)
	{
		for(int i = start; i < end; i++)
		{
			VFSFile file = files[i];
			String matchAgainst = (MiscUtilities.isAbsolutePath(str)
				? file.getPath() : file.getName());

			if(dirsOnly && file.getType() == FILE)
				continue;
			
			else if(matchAgainst.equals(str))
				return i;
			else if(matchAgainst.regionMatches(true,0,str,0,str.length()))
				return i;
		}

		return -1;
	} 

	
	public static String findCompletion(String path, String complete,
		VFSBrowser browser, boolean dirsOnly)
	{
		Log.log(Log.DEBUG,VFSFile.class,""findCompletion("" + path + ',' + complete
			+ ',' + dirsOnly + ')');

		if(complete.equals(""~""))
			return System.getProperty(""user.home"");
		else if(complete.equals(""-""))
			return browser.getView().getBuffer().getDirectory();
		else if(complete.equals(""..""))
			return MiscUtilities.getParentOfPath(path);

		if(MiscUtilities.isAbsolutePath(complete))
		{
			if(MiscUtilities.isURL(complete))
				return complete;
			else
				path = ""roots:"";
		}

		VFS vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) == 0)
			return null;
		Object session = vfs.createVFSSession(path,browser);
		if(session == null)
			return null;

		try
		{
			VFSFile[] files = vfs._listFiles(session,path,browser);
			int index = findCompletion(files,0,files.length,complete,dirsOnly);
			if(index != -1)
				return files[index].path;
		}
		catch(IOException e)
		{
			VFSManager.error(e,path,browser);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException e)
			{
				VFSManager.error(e,path,browser);
			}
		}
		
		return null;
	} 

	
	
	public final Icon getIcon(boolean expanded)
	{
		return getIcon(expanded, jEdit._getBuffer(getSymlinkPath()) != null);
	} 

	
	
	public Icon getIcon(boolean expanded, boolean openBuffer)
	{
		return getDefaultIcon(expanded, openBuffer);
	} 

	
	
	public final Icon getDefaultIcon(boolean expanded, boolean openBuffer)
	{
		if(getType() == DIRECTORY)
			return expanded ? FileCellRenderer.openDirIcon : FileCellRenderer.dirIcon;
		else if(getType() == FILESYSTEM)
			return FileCellRenderer.filesystemIcon;
		else if(openBuffer)
			return FileCellRenderer.openFileIcon;
		else
			return FileCellRenderer.fileIcon;
	} 

	
	
	public final Icon getDefaultIcon(boolean expanded)
	{
		return getDefaultIcon(expanded, jEdit._getBuffer(getSymlinkPath()) != null);
	} 

	
	public static final int FILE = 0;
	public static final int DIRECTORY = 1;
	public static final int FILESYSTEM = 2;
	

	
	
	public String name;
	
	public String path;
	
	public String symlinkPath;
	
	public String deletePath;
	
	public int type;
	
	public long length;
	
	public boolean hidden;
	
	public boolean canRead;
	
	public boolean canWrite;
	

	
	
	public VFSFile()
	{
	} 

	
	public VFSFile(String name, String path, String deletePath,
		int type, long length, boolean hidden)
	{
		this.name = name;
		this.path = path;
		this.deletePath = deletePath;
		this.symlinkPath = path;
		this.type = type;
		this.length = length;
		this.hidden = hidden;
		if(path != null)
		{
			
			VFS vfs = VFSManager.getVFSForPath(path);
			canRead = ((vfs.getCapabilities() & VFS.READ_CAP) != 0);
			canWrite = ((vfs.getCapabilities() & VFS.WRITE_CAP) != 0);
		}
	} 

	
	
	public VFS getVFS()
	{
		return VFSManager.getVFSForPath(path);
	} 
	
	
	public String getName()
	{
		return name;
	} 

	
	public void setName(String name)
	{
		this.name = name;
	} 

	
	
	public boolean isBinary(Object session)
		throws IOException
	{
		InputStream in = getVFS()._createInputStream(session,getPath(),
			false,jEdit.getActiveView());
		if(in == null)
			throw new IOException(""Unable to get a Stream for this file ""+this);

		try
		{
			return MiscUtilities.isBinary(in);
		}
		finally
		{
			IOUtilities.closeQuietly(in);
		}
	} 

	
	public String getPath()
	{
		return path;
	} 

	
	public void setPath(String path)
	{
		this.path = path;
	} 

	
	public String getSymlinkPath()
	{
		return symlinkPath;
	} 

	
	public void setSymlinkPath(String symlinkPath)
	{
		this.symlinkPath = symlinkPath;
	} 

	
	public String getDeletePath()
	{
		return deletePath;
	} 

	
	public void setDeletePath(String deletePath)
	{
		this.deletePath = deletePath;
	} 

	
	public int getType()
	{
		return type;
	} 

	
	public void setType(int type)
	{
		this.type = type;
	} 

	
	public long getLength()
	{
		return length;
	} 

	
	public void setLength(long length)
	{
		this.length = length;
	} 

	
	public boolean isHidden()
	{
		return hidden;
	} 

	
	public void setHidden(boolean hidden)
	{
		this.hidden = hidden;
	} 

	
	public boolean isReadable()
	{
		return canRead;
	} 

	
	public void setReadable(boolean canRead)
	{
		this.canRead = canRead;
	} 

	
	public boolean isWriteable()
	{
		return canWrite;
	} 

	
	public void setWriteable(boolean canWrite)
	{
		this.canWrite = canWrite;
	} 

	protected boolean colorCalculated;
	protected Color color;

	
	
	public String getExtendedAttribute(String name)
	{
		if(name.equals(VFS.EA_TYPE))
		{
			switch(getType())
			{
			case FILE:
				return jEdit.getProperty(""vfs.browser.type.file"");
			case DIRECTORY:
				return jEdit.getProperty(""vfs.browser.type.directory"");
			case FILESYSTEM:
				return jEdit.getProperty(""vfs.browser.type.filesystem"");
			default:
				throw new IllegalArgumentException();
			}
		}
		else if(name.equals(VFS.EA_STATUS))
		{
			if(isReadable())
			{
				if(isWriteable())
					return jEdit.getProperty(""vfs.browser.status.rw"");
				else
					return jEdit.getProperty(""vfs.browser.status.ro"");
			}
			else
			{
				if(isWriteable())
					return jEdit.getProperty(""vfs.browser.status.append"");
				else
					return jEdit.getProperty(""vfs.browser.status.no"");
			}
		}
		else if(name.equals(VFS.EA_SIZE))
		{
			if(getType() != FILE)
				return null;
			else
				return MiscUtilities.formatFileSize(getLength());
		}
		else
			return null;
	} 

	
	
	public Color getColor()
	{
		if(!colorCalculated)
		{
			colorCalculated = true;
			color = VFS.getDefaultColorFor(name);
		}

		return color;
	} 

	
	public String toString()
	{
		return name;
	} 
	
	
	
	protected boolean fetchedAttrs()
	{
		return fetchedAttrs;
	} 
	
	
	
	protected void fetchAttrs()
	{
		fetchedAttrs = true;
	} 

	
	private boolean fetchedAttrs;
}
"
jEdit,4.3,org.gjt.sp.util.Log,16,1,0,167,55,58,166,2,8,0.873684211,485,0.631578947,1,0.0,0.161904762,0,0,28.125,7,2.3125,0,"

package org.gjt.sp.util;


import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.Writer;

import java.text.DateFormat;

import java.util.*;

import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

import javax.swing.ListModel;
import javax.swing.SwingUtilities;

import static java.text.DateFormat.MEDIUM;



public class Log
{
	
	
	public static final int MAXLINES = 500;

	
	public static final int DEBUG = 1;

	
	public static final int MESSAGE = 3;

	
	public static final int NOTICE = 5;

	
	public static final int WARNING = 7;

	
	public static final int ERROR = 9;
	

	
	
	public static void init(boolean stdio, int level)
	{
		if(stdio)
		{
			if(System.out == realOut && System.err == realErr)
			{
				System.setOut(createPrintStream(NOTICE,null));
				System.setErr(createPrintStream(ERROR,null));
			}
		}

		Log.level = level;

		
		log(MESSAGE,Log.class,""When reporting bugs, please""
			+ "" include the following information:"");
		String[] props = {
			""java.version"", ""java.vm.version"", ""java.runtime.version"",
			""java.vendor"", ""java.compiler"", ""os.name"", ""os.version"",
			""os.arch"", ""user.home"", ""java.home"",
			""java.class.path"",
			};
		for(int i = 0; i < props.length; i++)
		{
			log(MESSAGE,Log.class,
				props[i] + '=' + System.getProperty(props[i]));
		}
	} 

	
	
	public static void setLogWriter(Writer stream)
	{
		if(Log.stream == null && stream != null)
		{
			try
			{
				if(wrap)
				{
					for(int i = logLineCount; i < log.length; i++)
					{
						stream.write(log[i]);
						stream.write(lineSep);
					}
				}
				for(int i = 0; i < logLineCount; i++)
				{
					stream.write(log[i]);
					stream.write(lineSep);
				}

				stream.flush();
			}
			catch(Exception e)
			{
				
			}
		}

		Log.stream = stream;
	} 

	
	
	public static void flushStream()
	{
		if(stream != null)
		{
			try
			{
				stream.flush();
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	} 

	
	
	public static void closeStream()
	{
		if(stream != null)
		{
			try
			{
				stream.close();
				stream = null;
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	} 

	
	
	public static ListModel getLogListModel()
	{
		return listModel;
	} 

	
	
	public static void log(int urgency, Object source, Object message,
		Throwable exception)
	{
		
		log(urgency,source,message);
		log(urgency,source,exception);
	} 

	
	
	public static void log(int urgency, Object source, Object message)
	{
		String _source;
		if(source == null)
		{
			_source = Thread.currentThread().getName();
			if(_source == null)
			{
				_source = Thread.currentThread().getClass().getName();
			}
		}
		else if(source instanceof Class)
			_source = ((Class)source).getName();
		else
			_source = source.getClass().getName();
		int index = _source.lastIndexOf('.');
		if(index != -1)
			_source = _source.substring(index+1);

		if(message instanceof Throwable)
		{
			_logException(urgency,source,(Throwable)message);
		}
		else
		{
			String _message = String.valueOf(message);
			
			
			synchronized(LOCK)
			{
				StringTokenizer st = new StringTokenizer(
					_message,""\r\n"");
				int lineCount = 0;
				boolean oldWrap = wrap;
				while(st.hasMoreTokens())
				{
					lineCount++;
					_log(urgency,_source,st.nextToken()
						.replace('\t',' '));
				}
				listModel.update(lineCount,oldWrap);
			}
		}
	} 

	

	
	private static final Object LOCK;
	private static final String[] log;
	private static int logLineCount;
	private static boolean wrap;
	private static int level;
	private static Writer stream;
	private static final String lineSep;
	private static final PrintStream realOut;
	private static final PrintStream realErr;
	private static final LogListModel listModel;
	private static final DateFormat timeFormat;
	private static final int MAX_THROWABLES = 10;
	public static final List<Throwable> throwables;
	

	
	static
	{
		LOCK = new Object();
		level = WARNING;

		realOut = System.out;
		realErr = System.err;

		log = new String[MAXLINES];
		lineSep = System.getProperty(""line.separator"");
		listModel = new LogListModel();
		
		timeFormat = DateFormat.getTimeInstance(MEDIUM);
		throwables = Collections.synchronizedList(new ArrayList<Throwable>(MAX_THROWABLES));
	} 

	
	private static PrintStream createPrintStream(final int urgency,
		final Object source)
	{
		return new LogPrintStream(urgency, source);
	} 

	
	private static void _logException(final int urgency,
		final Object source,
		final Throwable message)
	{
		PrintStream out = createPrintStream(urgency,source);
		if (urgency >= level)
		{
			synchronized (throwables)
			{
				if (throwables.size() == MAX_THROWABLES)
				{
					throwables.remove(0);
				}
				throwables.add(message);
			}
		}
		synchronized(LOCK)
		{
			message.printStackTrace(out);
		}
	} 

	
	private static void _log(int urgency, String source, String message)
	{
		String fullMessage = timeFormat.format(new Date()) + "" [""+Thread.currentThread().getName()+""] ["" + urgencyToString(urgency) + ""] "" + source
			+ "": "" + message;

		try
		{
			log[logLineCount] = fullMessage;
			if(++logLineCount >= log.length)
			{
				wrap = true;
				logLineCount = 0;
			}

			if(stream != null)
			{
				stream.write(fullMessage);
				stream.write(lineSep);
			}
		}
		catch(Exception e)
		{
			e.printStackTrace(realErr);
		}

		if(urgency >= level)
		{
			if(urgency == ERROR)
				realErr.println(fullMessage);
			else
				realOut.println(fullMessage);
		}
	} 

	
	private static String urgencyToString(int urgency)
	{
		switch(urgency)
		{
		case DEBUG:
			return ""debug"";
		case MESSAGE:
			return ""message"";
		case NOTICE:
			return ""notice"";
		case WARNING:
			return ""warning"";
		case ERROR:
			return ""error"";
		}

		throw new IllegalArgumentException(""Invalid urgency: "" + urgency);
	} 

	

	
	static class LogListModel implements ListModel
	{
		final List<ListDataListener> listeners = new ArrayList<ListDataListener>();

		
		private void fireIntervalAdded(int index1, int index2)
		{
			for(int i = 0; i < listeners.size(); i++)
			{
				ListDataListener listener = listeners.get(i);
				listener.intervalAdded(new ListDataEvent(this,
					ListDataEvent.INTERVAL_ADDED,
					index1,index2));
			}
		} 

		
		private void fireIntervalRemoved(int index1, int index2)
		{
			for(int i = 0; i < listeners.size(); i++)
			{
				ListDataListener listener = listeners.get(i);
				listener.intervalRemoved(new ListDataEvent(this,
					ListDataEvent.INTERVAL_REMOVED,
					index1,index2));
			}
		} 

		
		public void addListDataListener(ListDataListener listener)
		{
			listeners.add(listener);
		} 

		
		public void removeListDataListener(ListDataListener listener)
		{
			listeners.remove(listener);
		} 

		
		public Object getElementAt(int index)
		{
			if(wrap)
			{
				if(index < MAXLINES - logLineCount)
					return log[index + logLineCount];
				else
					return log[index - MAXLINES + logLineCount];
			}
			else
				return log[index];
		} 

		
		public int getSize()
		{
			if(wrap)
				return MAXLINES;
			else
				return logLineCount;
		} 

		
		void update(final int lineCount, final boolean oldWrap)
		{
			if(lineCount == 0 || listeners.isEmpty())
				return;

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(wrap)
					{
						if(oldWrap)
							fireIntervalRemoved(0,lineCount - 1);
						else
						{
							fireIntervalRemoved(0,
								logLineCount);
						}
						fireIntervalAdded(
							MAXLINES - lineCount + 1,
							MAXLINES);
					}
					else
					{
						fireIntervalAdded(
							logLineCount - lineCount + 1,
							logLineCount);
					}
				}
			});
		} 
	} 

	
	
	private static class LogPrintStream extends PrintStream {

		private final ByteArrayOutputStream buffer;
		private final OutputStream orig;

		
		LogPrintStream(int urgency, Object source)
		{
			super(new LogOutputStream(urgency, source));
			buffer = new ByteArrayOutputStream();
			orig = out;
		} 

		
		
		public PrintStream printf(String format, Object... args)
		{
			synchronized (orig)
			{
				buffer.reset();
				out = buffer;
				super.printf(format, args);

				try
				{
					byte[] data = buffer.toByteArray();
					orig.write(data, 0, data.length);
					out = orig;
				}
				catch (IOException ioe)
				{
					
				}
				finally
				{
					buffer.reset();
				}
			}
			return this;
		} 
	} 

	
	private static class LogOutputStream extends OutputStream
	{
		private final int 	urgency;
		private final Object 	source;

		
		LogOutputStream(int urgency, Object source)
		{
			this.urgency 	= urgency;
			this.source 	= source;
		} 

		
		public synchronized void write(int b)
		{
			byte[] barray = { (byte)b };
			write(barray,0,1);
		} 

		
		public synchronized void write(byte[] b, int off, int len)
		{
			String str = new String(b,off,len);
			log(urgency,source,str);
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.DummyTokenHandler,4,1,0,3,5,6,1,2,3,1.0,15,0.0,1,0.0,0.533333333,0,0,2.5,1,0.5,0,"

package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;


public class DummyTokenHandler implements TokenHandler
{
	
	public static final DummyTokenHandler INSTANCE = new DummyTokenHandler();

	
	
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context) {} 

	
	
	public void setLineContext(TokenMarker.LineContext lineContext)
	{
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.indent.IndentAction,3,1,0,13,4,3,12,3,2,1.0,16,0.0,2,0.0,0.666666667,0,0,3.666666667,1,0.6667,0,"

package org.gjt.sp.jedit.indent;

import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.StandardUtilities;


public interface IndentAction
{
	
	int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
		int newIndent);

	
	boolean keepChecking();

	
	class Collapse implements IndentAction
	{
		
		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
			int newIndent)
		{
			return newIndent;
		}

		public boolean keepChecking()
		{
			return true;
		}

		private Collapse()
		{
		}
	}

	class Reset implements IndentAction
	{
		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
			int newIndent)
		{
			return oldIndent;
		}

		public boolean keepChecking()
		{
			return true;
		}
	}

	class Increase implements IndentAction
	{
		private int amount;

		public Increase()
		{
			amount = 1;
		}

		public Increase(int amount)
		{
			this.amount = amount;
		}

		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
			int newIndent)
		{
			return newIndent + buffer.getIndentSize() * amount;
		}

		public boolean keepChecking()
		{
			return true;
		}

		public boolean equals(Object o)
		{
			if(o instanceof Increase)
				return ((Increase)o).amount == amount;
			else
				return false;
		}
	}

	class Decrease implements IndentAction
	{
		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
			int newIndent)
		{
			return newIndent - buffer.getIndentSize();
		}

		public boolean keepChecking()
		{
			return true;
		}
	}

	
	class AlignOffset implements IndentAction
	{
		private int offset;

		public AlignOffset(int offset)
		{
			this.offset = offset;
		}

		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
			int newIndent)
		{
			return offset;
		}

		public boolean keepChecking()
		{
			return false;
		}
	}

	
	class AlignParameter implements IndentAction
	{
		private int openParensColumn;

		public AlignParameter(int openParensColumn)
		{
			this.openParensColumn = openParensColumn;
		}

		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
				     int newIndent)
		{
			return openParensColumn + 1;
		}

		public boolean keepChecking()
		{
			return false;
		}
	}

	
	class NoIncrease implements IndentAction
	{
		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
				           int newIndent)
		{
			int current = StandardUtilities.getLeadingWhiteSpaceWidth(
					buffer.getLineSegment(line),buffer.getTabSize());
			return (current < newIndent) ? current : newIndent;
		}

		public boolean keepChecking()
		{
			return true;
		}
	}

	
	Collapse PrevCollapse		= new Collapse();
	
	Collapse PrevPrevCollapse	= new Collapse();
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.TextAreaDialog,7,7,1,7,41,21,3,5,6,2.0,220,0.0,0,0.995447648,0.5,2,2,30.42857143,1,0.4286,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;


public class TextAreaDialog extends EnhancedDialog
{
	
	public TextAreaDialog(Frame frame, String title, String caption,
		Icon icon, String text)
	{
		super(frame,title,true);

		init(caption,icon,text);
	} 

	
	public TextAreaDialog(Frame frame, String name, Throwable t)
	{
		this(frame,jEdit.getProperty(name + "".title""),
			jEdit.getProperty(name + "".message""),
			UIManager.getIcon(""OptionPane.errorIcon""),
			MiscUtilities.throwableToString(t));
	} 

	
	public TextAreaDialog(Dialog frame, String title, String caption,
		Icon icon, String text)
	{
		super(frame,title,true);

		init(caption,icon,text);
	} 

	
	public TextAreaDialog(Dialog frame, String name, Throwable t)
	{
		this(frame,jEdit.getProperty(name + "".title""),
			jEdit.getProperty(name + "".message""),
			UIManager.getIcon(""OptionPane.errorIcon""),
			MiscUtilities.throwableToString(t));
	} 

	
	private void init(String caption,
		Icon icon, String text)
	{
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(icon));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout(6,6));

		centerPanel.add(BorderLayout.NORTH,
			GUIUtilities.createMultilineLabel(caption));

		JTextArea textArea = new JTextArea(10,80);

		textArea.setText(text);
		textArea.setLineWrap(true);
		textArea.setCaretPosition(0);
		centerPanel.add(BorderLayout.CENTER,new JScrollPane(textArea));

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		JButton ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		buttons.add(ok);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		getRootPane().setDefaultButton(ok);

		pack();
		setLocationRelativeTo(getParent());
		setVisible(true);
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHWhileStatement,2,2,0,10,7,1,1,9,1,1.0,79,0.0,0,0.944444444,0.625,1,1,38.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;


class BSHWhileStatement extends SimpleNode implements ParserConstants
{
	public boolean isDoStatement;

    BSHWhileStatement(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		int numChild = jjtGetNumChildren();

		
        SimpleNode condExp, body = null;

		if ( isDoStatement ) {
			condExp = (SimpleNode)jjtGetChild(1);
			body =(SimpleNode)jjtGetChild(0);
		} else {
			condExp = (SimpleNode)jjtGetChild(0);
			if ( numChild > 1 )	
				body =(SimpleNode)jjtGetChild(1);
		}

		boolean doOnceFlag = isDoStatement;
        while( 
			doOnceFlag || 
			BSHIfStatement.evaluateCondition(condExp, callstack, interpreter )
		)
		{
			if ( body == null ) 
				continue;

			Object ret = body.eval(callstack, interpreter);

			boolean breakout = false;
			if(ret instanceof ReturnControl)
			{
				switch(((ReturnControl)ret).kind )
				{
					case RETURN:
						return ret;

					case CONTINUE:
						continue;

					case BREAK:
						breakout = true;
						break;
				}
			}
			if(breakout)
				break;

			doOnceFlag = false;
		}

        return Primitive.VOID;
    }

}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.JEditEmbeddedTextArea,1,5,0,10,10,0,1,10,1,2.0,23,0.0,0,1.0,1.0,0,0,22.0,0,0.0,0,"
package org.gjt.sp.jedit.textarea;


import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.jedit.syntax.ModeProvider;
import org.gjt.sp.jedit.buffer.JEditBuffer;



public class JEditEmbeddedTextArea extends TextArea
{
	
	
	public JEditEmbeddedTextArea()
	{
		super(jEdit.getPropertyManager(), null);
		initInputHandler();
		EditPane.initPainter(getPainter());
		JEditBuffer buffer = new JEditBuffer();
		buffer.setMode(ModeProvider.instance.getMode(""text""));
		setBuffer(buffer);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.input.DefaultInputHandlerProvider,2,1,0,3,3,0,1,2,2,0.0,12,1.0,1,0.0,0.75,0,0,4.5,1,0.5,0,"
package org.gjt.sp.jedit.input;


public class DefaultInputHandlerProvider implements InputHandlerProvider
{

	private AbstractInputHandler inputHandler;
	public DefaultInputHandlerProvider(AbstractInputHandler inputHandler)
	{
		this.inputHandler = inputHandler;
	}

	public AbstractInputHandler getInputHandler()
	{
		return inputHandler;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.PluginDetailPanel,2,5,0,4,24,0,2,2,0,0.333333333,148,1.0,1,0.998470948,0.75,0,0,71.5,4,2.0,0,"

package org.gjt.sp.jedit.pluginmgr;


import java.awt.BorderLayout;

import javax.swing.JEditorPane;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.pluginmgr.ManagePanel.Entry;



class PluginDetailPanel extends JPanel
{
	private final JEditorPane pluginDetail;
	private final JLabel title;
	
	
	private Entry entry;
	
	
	PluginDetailPanel()
	{
		setLayout(new BorderLayout());
		pluginDetail = new JEditorPane();
		pluginDetail.setEditable(false);
		pluginDetail.setContentType(""text/html"");
		pluginDetail.setBackground(jEdit.getColorProperty(""view.bgColor""));
		pluginDetail.setForeground(jEdit.getColorProperty(""view.fgColor""));
		pluginDetail.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, true);
		title = new JLabel();
		add(title, BorderLayout.NORTH);
		JScrollPane scroll = new JScrollPane(pluginDetail);
		scroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		add(scroll);
	} 

	
	void setPlugin(Entry entry)
	{
		if (entry != this.entry)
		{
			if (entry.status.equals(Entry.LOADED))
			{
				if (entry.name == null)
					title.setText(""<html><b>""+entry.jar+""</b></html>"");
				else
					title.setText(""<html><b>""+entry.name+""</b></html>"");
				
				StringBuilder builder = new StringBuilder();
				
				if (entry.version != null)
					builder.append(""<b>Version</b>: "").append(entry.version).append(""<br>"");
				if (entry.author != null)
					builder.append(""<b>Author</b>: "").append(entry.author).append(""<br>"");

				if (entry.description != null)
				{
					builder.append(""<br>"").append(entry.description);
				}
				pluginDetail.setText(builder.toString());
			}
			else
			{
				title.setText(""<html><b>""+entry.jar+""</b></html>"");
				pluginDetail.setText(null);
			}
			this.entry = entry;
		}
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHUnaryExpression,5,2,0,12,35,6,1,11,1,0.625,221,0.0,0,0.80952381,0.4,1,1,42.8,1,0.8,0,"


package org.gjt.sp.jedit.bsh;

class BSHUnaryExpression extends SimpleNode implements ParserConstants
{
    public int kind;
	public boolean postfix = false;

    BSHUnaryExpression(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        SimpleNode node = (SimpleNode)jjtGetChild(0);

		
		
		
		try {
			if ( kind == INCR || kind == DECR ) {
				LHS lhs = ((BSHPrimaryExpression)node).toLHS( 
					callstack, interpreter );
				return lhsUnaryOperation( lhs, interpreter.getStrictJava() );
			} else
				return 
					unaryOperation( node.eval(callstack, interpreter), kind );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
    }

    private Object lhsUnaryOperation( LHS lhs, boolean strictJava ) 
		throws UtilEvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug(""lhsUnaryOperation"");
        Object prevalue, postvalue;
        prevalue = lhs.getValue();
        postvalue = unaryOperation(prevalue, kind);

		Object retVal;
		if ( postfix )
			retVal = prevalue;
		else
			retVal = postvalue;

		lhs.assign( postvalue, strictJava );
		return retVal;
    }

    private Object unaryOperation( Object op, int kind ) throws UtilEvalError
    {
        if (op instanceof Boolean || op instanceof Character 
			|| op instanceof Number)
            return primitiveWrapperUnaryOperation( op, kind );

        if ( !(op instanceof Primitive) )
            throw new UtilEvalError( ""Unary operation "" + tokenImage[kind]
                + "" inappropriate for object"" );

		
        return Primitive.unaryOperation((Primitive)op, kind);
    }

    private Object primitiveWrapperUnaryOperation(Object val, int kind)
        throws UtilEvalError
    {
        Class operandType = val.getClass();
        Object operand = Primitive.promoteToInteger(val);

        if ( operand instanceof Boolean )
			return new Boolean(
				Primitive.booleanUnaryOperation((Boolean)operand, kind));
        else 
		if ( operand instanceof Integer )
        {
            int result = Primitive.intUnaryOperation((Integer)operand, kind);

            
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Byte((byte)result);
                if(operandType == Short.TYPE)
                    return new Short((short)result);
                if(operandType == Character.TYPE)
                    return new Character((char)result);
            }

            return new Integer(result);
        }
        else if(operand instanceof Long)
            return new Long(Primitive.longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Float(Primitive.floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Double(Primitive.doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(""An error occurred.  Please call technical support."");
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BshIterator,2,1,0,5,2,1,5,0,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.bsh;


public interface BshIterator
{
    
    public Object next();

    
    public boolean hasNext();
}
"
jEdit,4.3,org.gjt.sp.jedit.options.SyntaxHiliteOptionPane,8,6,0,6,31,20,3,5,1,0.761904762,121,0.666666667,1,0.991111111,0.428571429,4,12,13.75,1,0.75,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import java.util.Collections;

import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.gui.StyleEditor;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.StandardUtilities;




public class SyntaxHiliteOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);

	
	public SyntaxHiliteOptionPane()
	{
		super(""syntax"");
	}
	

	

	
	@Override
	protected void _init()
	{
		setLayout(new BorderLayout(6,6));

		add(BorderLayout.CENTER,createStyleTableScroller());
	} 

	
	@Override
	protected void _save()
	{
		styleModel.save();
	} 

	

	
	private StyleTableModel styleModel;
	private JTable styleTable;

	
	private JScrollPane createStyleTableScroller()
	{
		styleModel = createStyleTableModel();
		styleTable = new JTable(styleModel);
		styleTable.setRowSelectionAllowed(false);
		styleTable.setColumnSelectionAllowed(false);
		styleTable.setCellSelectionEnabled(false);
		styleTable.getTableHeader().setReorderingAllowed(false);
		styleTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = styleTable.getColumnModel();
 		TableColumn styleColumn = tcm.getColumn(1);
		styleColumn.setCellRenderer(new StyleTableModel.StyleRenderer());
		Dimension d = styleTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(styleTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private static StyleTableModel createStyleTableModel()
	{
		return new StyleTableModel();
	} 

	

	
	private class MouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			int row = styleTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;

			SyntaxStyle style;
			SyntaxStyle current = (SyntaxStyle)styleModel.getValueAt(row,1);
			String token = (String) styleModel.getValueAt(row, 0);
			JDialog dialog = GUIUtilities.getParentDialog(
					SyntaxHiliteOptionPane.this);
			if (dialog != null)
				style = new StyleEditor(dialog, current, token).getStyle();
			else
			{
				View view = GUIUtilities.getView(SyntaxHiliteOptionPane.this);
				style = new StyleEditor(view, current, token).getStyle();
			}
			if(style != null)
				styleModel.setValueAt(style,row,1);
		}
	} 

	
	private static class StyleTableModel extends AbstractTableModel
	{
		private final java.util.List<StyleChoice> styleChoices;

		
		StyleTableModel()
		{
			styleChoices = new Vector<StyleChoice>(Token.ID_COUNT + 4);
			
			for(int i = 1; i < Token.ID_COUNT; i++)
			{
				String tokenName = Token.tokenToString((byte)i);
				addStyleChoice(tokenName,""view.style."" + tokenName.toLowerCase());
			}

			addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.1""),
			               ""view.style.foldLine.1"");
			addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.2""),
			               ""view.style.foldLine.2"");
			addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.3""),
			               ""view.style.foldLine.3"");
			addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.0""),
			               ""view.style.foldLine.0"");

			Collections.sort(styleChoices,new StandardUtilities.StringCompare<StyleChoice>(true));
		} 

		
		public int getColumnCount()
		{
			return 2;
		} 

		
		public int getRowCount()
		{
			return styleChoices.size();
		} 

		
		public Object getValueAt(int row, int col)
		{
			StyleChoice ch = styleChoices.get(row);
			switch(col)
			{
				case 0:
					return ch.label;
				case 1:
					return ch.style;
				default:
					return null;
			}
		} 

		
		@Override
		public void setValueAt(Object value, int row, int col)
		{
			StyleChoice ch = styleChoices.get(row);
			if(col == 1)
				ch.style = (SyntaxStyle)value;
			fireTableRowsUpdated(row,row);
		} 

		
		@Override
		public String getColumnName(int index)
		{
			switch(index)
			{
				case 0:
					return jEdit.getProperty(""options.syntax.object"");
				case 1:
					return jEdit.getProperty(""options.syntax.style"");
				default:
					return null;
			}
		} 

		
		public void save()
		{
			for(int i = 0; i < styleChoices.size(); i++)
			{
				StyleChoice ch = styleChoices
					.get(i);
				jEdit.setProperty(ch.property,
				                  GUIUtilities.getStyleString(ch.style));
			}
		} 

		
		private void addStyleChoice(String label, String property)
		{
			styleChoices.add(new StyleChoice(label,
			                                 property,
			                                 GUIUtilities.parseStyle(jEdit.getProperty(property),
			                                                         ""Dialog"",12)));
		} 

		
		private static class StyleChoice
		{
			private String label;
			private String property;
			private SyntaxStyle style;

			StyleChoice(String label, String property, SyntaxStyle style)
			{
				this.label = label;
				this.property = property;
				this.style = style;
			}

			
			@Override
			public String toString()
			{
				return label;
			}
		} 

		
		static class StyleRenderer extends JLabel
			implements TableCellRenderer
		{
			
			StyleRenderer()
			{
				setOpaque(true);
				setBorder(SyntaxHiliteOptionPane.noFocusBorder);
				setText(""Hello World"");
			} 

			
			public Component getTableCellRendererComponent(
				JTable table,
				Object value,
				boolean isSelected,
				boolean cellHasFocus,
				int row,
				int col)
			{
				if (value != null)
				{
					SyntaxStyle style = (SyntaxStyle)value;
					setForeground(style.getForegroundColor());
					if (style.getBackgroundColor() != null)
						setBackground(style.getBackgroundColor());
					else
					{
						
						setBackground(jEdit.getColorProperty(
							""view.bgColor""));
					}
					setFont(style.getFont());
				}

				setBorder(cellHasFocus ? UIManager.getBorder(
					""Table.focusCellHighlightBorder"")
				                       : SyntaxHiliteOptionPane.noFocusBorder);
				return this;
			} 
		} 
	} 

} 

"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHFormalParameters,5,2,0,11,10,2,5,6,3,0.625,128,0.25,0,0.80952381,0.44,1,1,23.8,3,1.6,0,"

package org.gjt.sp.jedit.bsh;

class BSHFormalParameters extends SimpleNode
{
	private String [] paramNames;
	
	
	Class [] paramTypes;
	int numArgs;
	String [] typeDescriptors;

	BSHFormalParameters(int id) { super(id); }

	void insureParsed() 
	{
		if ( paramNames != null )
			return;

		this.numArgs = jjtGetNumChildren();
		String [] paramNames = new String[numArgs];

		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			paramNames[i] = param.name;
		}

		this.paramNames = paramNames;
	}

	public String [] getParamNames() { 
		insureParsed();
		return paramNames;
	}

	public String [] getTypeDescriptors( 
		CallStack callstack, Interpreter interpreter, String defaultPackage )
	{
		if ( typeDescriptors != null )
			return typeDescriptors;

		insureParsed();
		String [] typeDesc = new String[numArgs];

		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			typeDesc[i] = param.getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
		}

		this.typeDescriptors = typeDesc;
		return typeDesc;
	}

	
	public Object eval( CallStack callstack, Interpreter interpreter )  
		throws EvalError
	{
		if ( paramTypes != null )
			return paramTypes;

		insureParsed();
		Class [] paramTypes = new Class[numArgs];

		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			paramTypes[i] = (Class)param.eval( callstack, interpreter );
		}

		this.paramTypes = paramTypes;

		return paramTypes;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.search.SearchBar,21,5,0,20,99,130,6,19,5,0.816666667,596,1.0,3,0.971181556,0.323809524,2,5,26.66666667,10,1.7143,0,"

package org.gjt.sp.jedit.search;


import java.awt.event.*;
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class SearchBar extends JToolBar
{
	
	public SearchBar(final View view, boolean temp)
	{
		this.view = view;

		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));

		setFloatable(false);
		add(Box.createHorizontalStrut(2));

		JLabel label = new JLabel(jEdit.getProperty(""view.search.find""));
		add(label);
		
		add(Box.createHorizontalStrut(12));
		
		add(find = new HistoryTextField(""find""));
		find.setSelectAllOnFocus(true);

		SyntaxStyle style = GUIUtilities.parseStyle(jEdit.getProperty(""view.style.invalid""), ""Dialog"", 12);
		errorBackground = style.getBackgroundColor();
		errorForeground = style.getForegroundColor();
		defaultBackground = find.getBackground();
		defaultForeground = find.getForeground();
		Dimension max = find.getPreferredSize();
		max.width = Integer.MAX_VALUE;
		find.setMaximumSize(max);
		ActionHandler actionHandler = new ActionHandler();
		find.addKeyListener(new KeyHandler());
		find.addActionListener(actionHandler);
		find.getDocument().addDocumentListener(new DocumentHandler());

		Insets margin = new Insets(1,1,1,1);

		addSeparator(new Dimension(12, 12));
		
		add(ignoreCase = new JCheckBox(jEdit.getProperty(
			""search.case"")));
		ignoreCase.addActionListener(actionHandler);
		ignoreCase.setMargin(margin);
		ignoreCase.setOpaque(false);
		ignoreCase.setRequestFocusEnabled(false);
		add(Box.createHorizontalStrut(2));
		
		add(regexp = new JCheckBox(jEdit.getProperty(
			""search.regexp"")));
		regexp.addActionListener(actionHandler);
		regexp.setMargin(margin);
		regexp.setOpaque(false);
		regexp.setRequestFocusEnabled(false);
		add(Box.createHorizontalStrut(2));
		
		add(hyperSearch = new JCheckBox(jEdit.getProperty(
			""search.hypersearch"")));
		hyperSearch.addActionListener(actionHandler);
		hyperSearch.setMargin(margin);
		hyperSearch.setOpaque(false);
		hyperSearch.setRequestFocusEnabled(false);

		update();

		
		timer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(!incrementalSearch(searchStart,searchReverse))
				{
					if(!incrementalSearch(
						(searchReverse
						? view.getBuffer().getLength()
						: 0),searchReverse))
					{
						
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(
							""view.status.search-not-found""));
					}
				}
			}
		}); 

		
		this.isRemovable = temp;

		setCloseButtonVisibility();
	} 

	
	public HistoryTextField getField()
	{
		return find;
	} 

	
	public void setHyperSearch(boolean hyperSearch)
	{
		jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",hyperSearch);
		this.hyperSearch.setSelected(hyperSearch);
	} 

	
	public void update()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		hyperSearch.setSelected(jEdit.getBooleanProperty(
			""view.search.hypersearch.toggle""));
	} 

	
	public void propertiesChanged()
	{
		
		isRemovable = !(jEdit.getBooleanProperty(""view.showSearchbar""));
		
		Log.log(Log.DEBUG, this, ""in SearchBar.propertiesChanged(), isRemovable = "" + isRemovable);
		
		setCloseButtonVisibility();
		
	} 

	

	
	private View view;
	private HistoryTextField find;
	private JCheckBox ignoreCase, regexp, hyperSearch;
	private Timer timer;
	private boolean wasError;
	private Color defaultBackground;
	private Color defaultForeground;
	private Color errorForeground;
	private Color errorBackground;
	
	private RolloverButton close;

	private int searchStart;
	private boolean searchReverse;
	private boolean isRemovable;
	

	
	private void find(boolean reverse)
	{
		timer.stop();

		String text = find.getText();
		
		if(text.length() == 0)
		{
			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
			SearchDialog.showSearchDialog(view,null,SearchDialog.CURRENT_BUFFER);
		} 
		
		else if(hyperSearch.isSelected())
		{
			if(isRemovable)
			{
				view.removeToolBar(SearchBar.this);
			}
			else
				find.setText(null);

			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(view);
		} 
		
		else
		{
			
			
			int start;
			JEditTextArea textArea = view.getTextArea();
			Selection s = textArea.getSelectionAtOffset(
				textArea.getCaretPosition());
			if(s == null)
				start = textArea.getCaretPosition();
			else if(reverse)
				start = s.getStart();
			else
				start = s.getEnd();

			if(!incrementalSearch(start,reverse))
			{
				
				
				if(!incrementalSearch(reverse
					? view.getBuffer().getLength()
					: 0,reverse))
				{
					
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(
						""view.status.search-not-found""));
				}
				else
				{
					
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					
					if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
					{
						getToolkit().beep();
					}
				}
			}
		} 
	} 

	
	private boolean incrementalSearch(int start, boolean reverse)
	{
		
		SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
		SearchAndReplace.setSearchString(find.getText());
		SearchAndReplace.setReverseSearch(reverse);

		boolean ret = false;
		try
		{
			if(SearchAndReplace.find(view,view.getBuffer(),start,false,reverse))
				ret = true;
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,this,e);

			
			
			
			ret = true;
		}
		if (ret)
		{
			if (wasError)
			{
				find.setForeground(defaultForeground);
				find.setBackground(defaultBackground);
				wasError = false;
			}
		}
		else
		{
			if (!wasError)
			{
				find.setForeground(errorForeground);
				find.setBackground(errorBackground);
				wasError = true;
			}
		}


		return ret;
	} 

	
	private void timerIncrementalSearch(int start, boolean reverse)
	{
		searchStart = start;
		searchReverse = reverse;

		timer.stop();
		timer.setRepeats(false);
		timer.setInitialDelay(150);
		timer.start();
	} 
	
	
	private void setCloseButtonVisibility()
	{
		if(isRemovable)
		{
			if(close == null)
			{
				close = new RolloverButton(GUIUtilities.loadIcon(""closebox.gif""));
				close.addActionListener(new ActionHandler());
				close.setToolTipText(jEdit.getProperty(
					""view.search.close-tooltip""));
			}
			add(close);
		}
		else if(close != null)
			remove(close);
	}
	

	

	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == find)
				find(false);
			else if(source == hyperSearch)
			{
				jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",
					hyperSearch.isSelected());
				update();
			}
			else if(source == ignoreCase)
			{
				SearchAndReplace.setIgnoreCase(ignoreCase
					.isSelected());
			}
			else if(source == regexp)
			{
				SearchAndReplace.setRegexp(regexp
					.isSelected());
			}
			else if(source == close)
			{
				view.removeToolBar(SearchBar.this);
				view.getEditPane().focusOnTextArea();
			}
		} 
	} 

	
	class DocumentHandler implements DocumentListener
	{
		
		public void insertUpdate(DocumentEvent evt)
		{
			
			
			
			if(!hyperSearch.isSelected())
			{
				int start;
				JEditTextArea textArea = view.getTextArea();
				Selection s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s == null)
					start = textArea.getCaretPosition();
				else
					start = s.getStart();

				timerIncrementalSearch(start,false);
			}
		} 

		
		public void removeUpdate(DocumentEvent evt)
		{
			
			if(!hyperSearch.isSelected())
			{
				String text = find.getText();
				if(text.length() != 0)
				{
					
					
					
					
					if(regexp.isSelected())
					{
						
						
						
						timerIncrementalSearch(0,false);
					}
					else
					{
						int start;
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else
							start = s.getStart();
						timerIncrementalSearch(start,true);
					}
				}
			}
		} 

		
		public void changedUpdate(DocumentEvent evt) {}
		
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_ESCAPE:
				if(isRemovable)
				{
					view.removeToolBar(SearchBar.this);
				}
				evt.consume();
				view.getEditPane().focusOnTextArea();
				break;
			case KeyEvent.VK_ENTER:
				if(evt.isShiftDown())
				{
					evt.consume();
					find(true);
				}
				break;
			}
		}
	} 

	
	class FocusHandler extends FocusAdapter
	{
		public void focusLost(FocusEvent e)
		{
			getField().addCurrentToHistory();
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.PerspectiveManager,8,1,0,15,43,14,6,11,7,0.821428571,378,1.0,1,0.0,0.357142857,0,0,45.75,16,2.875,0,"

package org.gjt.sp.jedit;

import java.io.IOException;
import java.util.Collection;
import java.util.LinkedList;

import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;


public class PerspectiveManager
{
	private static final String PERSPECTIVE_FILENAME = ""perspective"";

	
	
	public static boolean isPerspectiveDirty()
	{
		return dirty;
	} 

	
	
	public static void setPerspectiveDirty(boolean dirty)
	{
		PerspectiveManager.dirty = dirty;
	} 

	
	
	public static boolean isPerspectiveEnabled()
	{
		return enabled;
	} 

	
	
	public static void setPerspectiveEnabled(boolean enabled)
	{
		PerspectiveManager.enabled = enabled;
	} 

	
	public static View loadPerspective(boolean restoreFiles)
	{
		if(perspectiveXML == null)
			return null;

		if(!perspectiveXML.fileExists())
			return null;

		Log.log(Log.MESSAGE,PerspectiveManager.class,""Loading "" + perspectiveXML);

		PerspectiveHandler handler = new PerspectiveHandler(restoreFiles);
		try
		{
			perspectiveXML.load(handler);
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,PerspectiveManager.class,e);
		}
		return handler.view;
	} 

	
	public static void savePerspective(boolean autosave)
	{
		if(!isPerspectiveEnabled() || !jEdit.isStartupDone())
			return;

		if(perspectiveXML == null)
			return;
		
		
		if(jEdit.getBufferCount() == 0)
			return;

		Buffer[] buffers = jEdit.getBuffers();
		Collection<Buffer> savedBuffers = new LinkedList<Buffer>();
		for (Buffer buffer: buffers)
		{
			if (!buffer.isNewFile())
			{
				savedBuffers.add(buffer);
			}
		}

		if(!autosave)
			Log.log(Log.MESSAGE,PerspectiveManager.class,""Saving "" + perspectiveXML);

		String lineSep = System.getProperty(""line.separator"");

		SettingsXML.Saver out = null;

		try
		{
			out = perspectiveXML.openSaver();
			out.writeXMLDeclaration();

			out.write(""<!DOCTYPE PERSPECTIVE SYSTEM \""perspective.dtd\"">"");
			out.write(lineSep);
			out.write(""<PERSPECTIVE>"");
			out.write(lineSep);

			for (Buffer buffer: savedBuffers)
			{
				out.write(""<BUFFER AUTORELOAD=\"""");
				out.write(buffer.getAutoReload() ? ""TRUE"" : ""FALSE"");
				out.write(""\"" AUTORELOAD_DIALOG=\"""");
				out.write(buffer.getAutoReloadDialog() ? ""TRUE"" : ""FALSE"");
				out.write(""\"">"");
				out.write(XMLUtilities.charsToEntities(buffer.getPath(), false));
				out.write(""</BUFFER>"");
				out.write(lineSep);
			}

			View[] views = jEdit.getViews();
			for(int i = 0; i < views.length; i++)
			{
				View view = views[i];
				
				
				
				if(view == jEdit.getActiveView()
					&& i != views.length - 1)
				{
					View last = views[views.length - 1];
					views[i] = last;
					views[views.length - 1] = view;
					view = last;
				}

				View.ViewConfig config = views[i].getViewConfig();
				out.write(""<VIEW PLAIN=\"""");
				out.write(config.plainView ? ""TRUE"" : ""FALSE"");
				out.write(""\"">"");

				out.write(""<PANES>"");
				out.write(lineSep);
				out.write(XMLUtilities.charsToEntities(
					config.splitConfig,false));
				out.write(lineSep);
				out.write(""</PANES>"");
				out.write(lineSep);

				out.write(""<GEOMETRY X=\"""");
				out.write(String.valueOf(config.x));
				out.write(""\"" Y=\"""");
				out.write(String.valueOf(config.y));
				out.write(""\"" WIDTH=\"""");
				out.write(String.valueOf(config.width));
				out.write(""\"" HEIGHT=\"""");
				out.write(String.valueOf(config.height));
				out.write(""\"" EXT_STATE=\"""");
				out.write(String.valueOf(config.extState));
				out.write(""\"" />"");
				out.write(lineSep);

				if (config.docking != null)
					config.docking.saveLayout(PERSPECTIVE_FILENAME, i);
				
				out.write(""</VIEW>"");
				out.write(lineSep);
			}

			out.write(""</PERSPECTIVE>"");
			out.write(lineSep);

			out.finish();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,PerspectiveManager.class,""Error saving "" + perspectiveXML);
			Log.log(Log.ERROR,PerspectiveManager.class,io);
		}
		finally
		{
			IOUtilities.closeQuietly(out);
		}
	} 

	
	private static boolean dirty, enabled = true;
	private static SettingsXML perspectiveXML;

	
	static
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			perspectiveXML = new SettingsXML(settingsDirectory, PERSPECTIVE_FILENAME);
		}
	} 

	
	private static class PerspectiveHandler extends DefaultHandler
	{
		View view;
		private StringBuilder charData;
		View.ViewConfig config;
		boolean restoreFiles;
		String autoReload, autoReloadDialog;
		
		PerspectiveHandler(boolean restoreFiles)
		{
			this.restoreFiles = restoreFiles;
			config = new View.ViewConfig();
			charData = new StringBuilder();
			config.docking = View.getDockingFrameworkProvider().createDockingLayout();
		}

		@Override
		public InputSource resolveEntity(String publicId, String systemId)
		{
			return XMLUtilities.findEntity(systemId, ""perspective.dtd"", getClass());
		}

		@Override
		public void startElement(String uri, String localName,
					 String qName, Attributes attrs)
		{
			charData.setLength(0);
			for (int i = 0; i < attrs.getLength(); i++)
			{
				String name = attrs.getQName(i);
				String value = attrs.getValue(i);
				attribute(name, value);
			}
		}

		private void attribute(String aname, String value)
		{
			if(aname.equals(""X""))
				config.x = Integer.parseInt(value);
			else if(aname.equals(""Y""))
				config.y = Integer.parseInt(value);
			else if(aname.equals(""WIDTH""))
				config.width = Integer.parseInt(value);
			else if(aname.equals(""HEIGHT""))
				config.height = Integer.parseInt(value);
			else if(aname.equals(""EXT_STATE""))
				config.extState = Integer.parseInt(value);
			else if(aname.equals(""PLAIN""))
				config.plainView = (""TRUE"".equals(value));
			else if(aname.equals(""AUTORELOAD""))
				autoReload = value;
			else if(aname.equals(""AUTORELOAD_DIALOG""))
				autoReloadDialog = value;
		}

		
		public static boolean skipRemote(String uri)
		{
			if (jEdit.getBooleanProperty(""restore.remote""))
				return false;
			if(MiscUtilities.isURL(uri))
			{
				String protocol = MiscUtilities.getProtocolOfURL(uri);
				if (!protocol.equals(""file"")) return true;
			}
			return false;
		}

		@Override
		public void endElement(String uri, String localName, String name)
		{
			if(name.equals(""BUFFER""))
			{
				if (restoreFiles && !skipRemote(charData.toString()))
				{
					Buffer restored = jEdit.openTemporary(null,null, charData.toString(), false);
					
					
					if (restored != null)
					{
						if(autoReload != null)
							restored.setAutoReload(""TRUE"".equals(autoReload));
						if(autoReloadDialog != null)
							restored.setAutoReloadDialog(""TRUE"".equals(autoReloadDialog));
						jEdit.commitTemporary(restored);
					}
				}
			}
			else if(name.equals(""PANES""))
				config.splitConfig = charData.toString();
			else if(name.equals(""VIEW""))
			{
				if (config.docking != null)
					config.docking.loadLayout(PERSPECTIVE_FILENAME, jEdit.getViewCount());
				view = jEdit.newView(view,null,config);
				config = new View.ViewConfig();
				config.docking = View.getDockingFrameworkProvider().createDockingLayout();
			}
		}

		@Override
		public void characters(char[] ch, int start, int length)
		{
			charData.append(ch,start,length);
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.util.IOUtilities,10,1,0,28,37,45,26,2,9,2.0,218,0.0,0,0.0,0.17,0,0,20.8,9,2.5,0,"

package org.gjt.sp.util;

import java.io.*;


public class IOUtilities
{
	
	
	public static boolean moveFile(File source, File dest)
	{
		boolean ok = false;

		if ((dest.exists() && dest.canWrite())
			|| (!dest.exists() && dest.getParentFile().canWrite()))
			{
				OutputStream fos = null;
				InputStream fis = null;
				try
				{
					fos = new FileOutputStream(dest);
					fis = new FileInputStream(source);
					ok = copyStream(32768,null,fis,fos,false);
				}
				catch (IOException ioe)
				{
					Log.log(Log.WARNING, IOUtilities.class,
							""Error moving file: "" + ioe + "" : "" + ioe.getMessage());
				}
				finally
				{
					closeQuietly(fos);
					closeQuietly(fis);
				}

				if(ok)
					source.delete();
			}
		return ok;
	} 

	
	
	public static boolean copyStream(int bufferSize, ProgressObserver progress,
					InputStream in, OutputStream out, boolean canStop)
		throws IOException
	{
		byte[] buffer = new byte[bufferSize];
		int n;
		long copied = 0L;
		while (-1 != (n = in.read(buffer)))
		{
			out.write(buffer, 0, n);
			copied += n;
			if(progress != null)
				progress.setValue(copied);
			if(canStop && Thread.interrupted()) return false;
		}
		return true;
	}

	
	public static boolean copyStream(ProgressObserver progress,
					 InputStream in, OutputStream out, boolean canStop)
		throws IOException
	{
		return copyStream(4096,progress, in, out, canStop);
	} 

	
	
	public static long fileLength(File file)
	{
		long length = 0L;
		if (file.isFile())
			length = file.length();
		else if (file.isDirectory())
		{
			File[] files = file.listFiles();
			for (int i = 0; i < files.length; i++)
			{
				length += fileLength(files[i]);
			}
		}
		return length;
	} 

	
	
	public static void closeQuietly(InputStream in)
	{
		if(in != null)
		{
			try
			{
				in.close();
			}
			catch (IOException e)
			{
				
			}
		}
	}

	
	public static void closeQuietly(OutputStream out)
	{
		if(out != null)
		{
			try {
				if (out instanceof Flushable)
				{
					((Flushable)out).flush();
				}
			}
			catch (IOException e)
			{
				
			}
			try
			{
				out.close();
			}
			catch (IOException e)
			{
				
			}
		}
	}

	
	public static void closeQuietly(Reader r)
	{
		if(r != null)
		{
			try
			{
				r.close();
			}
			catch (IOException e)
			{
				
			}
		}
	}

	
	public static void closeQuietly(Writer out)
	{
		if(out != null)
		{
			try {
				if (out instanceof Flushable)
				{
					((Flushable)out).flush();
				}
			}
			catch (IOException e)
			{
				
			}
			try
			{
				out.close();
			}
			catch (IOException e)
			{
				
			}
		}
	}

	
	public static void closeQuietly(Closeable closeable)
	{
		if(closeable != null)
		{
			try {
				if (closeable instanceof Flushable)
				{
					((Flushable)closeable).flush();
				}
			}
			catch (IOException e)
			{
				
			}
			try
			{
				closeable.close();
			}
			catch (IOException e)
			{
				
			}
		}
	} 

	
	private IOUtilities()
	{
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.InputMethodSupport,12,2,0,5,72,0,1,5,11,0.563636364,525,1.0,1,0.266666667,0.285714286,1,1,42.33333333,6,2.5833,0,"

package org.gjt.sp.jedit.textarea;


import java.text.AttributedString;
import java.text.AttributedCharacterIterator;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Graphics2D;
import java.awt.FontMetrics;
import java.awt.im.InputMethodRequests;
import java.awt.event.InputMethodListener;
import java.awt.event.InputMethodEvent;
import java.awt.font.TextLayout;
import java.awt.font.TextAttribute;
import java.awt.font.TextHitInfo;




class InputMethodSupport
	extends TextAreaExtension
	implements InputMethodRequests, InputMethodListener
{
	
	private TextArea owner;
	
	private TextLayout composedTextLayout = null;
	
	private int composedCaretX = 0;
	
	private int lastCommittedAt = 0;
	private String lastCommittedText = null;

	public InputMethodSupport(TextArea owner)
	{
		this.owner = owner;
		owner.addInputMethodListener(this);
		owner.getPainter().addExtension(TextAreaPainter.HIGHEST_LAYER, this);
	}


	
	
	private Rectangle getCaretRectangle(int x, int y)
	{
		TextAreaPainter painter = owner.getPainter();
		Point origin = painter.getLocationOnScreen();
		int height = painter.getFontMetrics().getHeight();
		return new Rectangle(origin.x + x, origin.y + y, 0, height);
	}
	


	
	public void paintValidLine(Graphics2D gfx, int screenLine,
				   int physicalLine, int start, int end, int y)
	{
		if(composedTextLayout != null)
		{
			int caret = owner.getCaretPosition();
			if(start <= caret && caret < end)
			{
				TextAreaPainter painter = owner.getPainter();
				
				
				
				
				FontMetrics fm = painter.getFontMetrics();
				int x = owner.offsetToXY(caret).x;
				int width = Math.round(composedTextLayout.getAdvance());
				int height = fm.getHeight();
				int offset_to_baseline = height
					- (fm.getLeading()+1) - fm.getDescent();
				int caret_x = x + composedCaretX;

				gfx.setColor(painter.getBackground());
				gfx.fillRect(x, y, width, height);
				gfx.setColor(painter.getForeground());
				composedTextLayout.draw(gfx, x, y + offset_to_baseline);
				gfx.setColor(painter.getCaretColor());
				gfx.drawLine(caret_x, y, caret_x, y + height - 1);
			}
		}
	}
	


	
	public Rectangle getTextLocation(TextHitInfo offset)
	{
		if(composedTextLayout != null)
		{
			
			Point caret = owner.offsetToXY(owner.getCaretPosition());
			return getCaretRectangle(caret.x + composedCaretX, caret.y);
		}
		else
		{
			
			Selection selection_on_caret = owner.getSelectionAtOffset(owner.getCaretPosition());
			if(selection_on_caret != null)
			{
				Point selection_start = owner.offsetToXY(selection_on_caret.getStart());
				return getCaretRectangle(selection_start.x, selection_start.y);
			}
		}
		return null;
	}

	public TextHitInfo getLocationOffset(int x, int y)
	{
		if(composedTextLayout != null)
		{
			Point origin = owner.getPainter().getLocationOnScreen();
			Point caret = owner.offsetToXY(owner.getCaretPosition());
			float local_x = x - origin.x - caret.x;
			float local_y = y - origin.y - caret.y
				- (composedTextLayout.getLeading()+1)
				- composedTextLayout.getAscent();
			return composedTextLayout.hitTestChar(local_x, local_y);
		}
		return null;
	}

	public int getInsertPositionOffset()
	{
		return owner.getCaretPosition();
	}

	public AttributedCharacterIterator getCommittedText(int beginIndex , int endIndex
		, AttributedCharacterIterator.Attribute[] attributes)
	{
		return (new AttributedString(owner.getText(beginIndex, endIndex - beginIndex))).getIterator();
	}

	public int getCommittedTextLength()
	{
		return owner.getBufferLength();
	}

	public AttributedCharacterIterator cancelLatestCommittedText(AttributedCharacterIterator.Attribute[] attributes)
	{
		if(lastCommittedText != null)
		{
			int offset = lastCommittedAt;
			int length = lastCommittedText.length();
			String sample = owner.getText(offset, length);
			if(sample != null && sample.equals(lastCommittedText))
			{
				AttributedCharacterIterator canceled = (new AttributedString(sample)).getIterator();
				owner.getBuffer().remove(offset, length);
				owner.setCaretPosition(offset);
				lastCommittedText = null;
				return canceled;
			}
			
			
			lastCommittedText = null;
		}
		return null;
	}

	public AttributedCharacterIterator getSelectedText(AttributedCharacterIterator.Attribute[] attributes)
	{
		Selection selection_on_caret = owner.getSelectionAtOffset(owner.getCaretPosition());
		if(selection_on_caret != null)
		{
			return (new AttributedString(owner.getSelectedText(selection_on_caret))).getIterator();
		}
		return null;
	}
	


	
	public void inputMethodTextChanged(InputMethodEvent event)
	{
		composedTextLayout = null;
		AttributedCharacterIterator text = event.getText();
		if(text != null)
		{
			int committed_count = event.getCommittedCharacterCount();
			if(committed_count > 0)
			{
				lastCommittedText = null;
				lastCommittedAt = owner.getCaretPosition();
				StringBuilder committed = new StringBuilder(committed_count);
				char c;
				int count;
				for(c = text.first(), count = committed_count
					; c != AttributedCharacterIterator.DONE && count > 0
					; c = text.next(), --count)
				{
					owner.userInput(c);
					committed.append(c);
				}
				lastCommittedText = committed.toString();
			}
			int end_index = text.getEndIndex();
			if(committed_count < end_index)
			{
				AttributedString composed = new AttributedString(text, committed_count, end_index);
				TextAreaPainter painter = owner.getPainter();
				composed.addAttribute(TextAttribute.FONT, painter.getFont());
				composedTextLayout = new TextLayout(composed.getIterator()
					, painter.getFontRenderContext());
			}
		}
		
		caretPositionChanged(event);
	}

	public void caretPositionChanged(InputMethodEvent event)
	{
		composedCaretX = 0;
		if(composedTextLayout != null)
		{
			TextHitInfo caret = event.getCaret();
			if(caret != null)
			{
				composedCaretX = Math.round(composedTextLayout.getCaretInfo(caret)[0]);
			}
			
			int insertion_x = owner.offsetToXY(owner.getCaretPosition()).x;
			TextHitInfo visible = event.getVisiblePosition();
			int composed_visible_x = (visible != null)
				? Math.round(composedTextLayout.getCaretInfo(visible)[0])
				: composedCaretX;
			int visible_x = insertion_x + composed_visible_x;
			int painter_width = owner.getPainter().getWidth();
			int adjustment = 0;
			if(visible_x < 0)
			{
				adjustment = visible_x;
			}
			if(visible_x >= painter_width)
			{
				adjustment = visible_x - (painter_width - 1);
			}
			if(adjustment != 0)
			{
				owner.setHorizontalOffset(owner.getHorizontalOffset() - adjustment);
			}
		}
		else
		{
			
			owner.scrollToCaret(false);
		}
		
		int caret_line = owner.getCaretLine();
		owner.invalidateLineRange(caret_line, caret_line + 1);
		event.consume();
	}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.AnimatedIcon,13,2,0,1,20,30,1,1,9,0.805555556,115,1.0,0,0.571428571,0.269230769,0,0,7.384615385,2,1.0769,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;



public class AnimatedIcon extends ImageIcon
{
	
	
	public AnimatedIcon(Image icon, Image[] frames, int rate, Component host)
	{
		super(icon);
		this.icon = icon;
		this.frames = frames;
		delay = 1000/rate;
		this.host = host;
	} 

	
	public Image[] getFrames()
	{
		return frames;
	} 

	
	public Image getIcon()
	{
		return icon;
	} 

	
	public int getRate()
	{
		return 1000/delay;
	} 

	
	public void setFrames(Image[] frames)
	{
		this.frames = frames;
	} 

	
	public void setIcon(Image icon)
	{
		this.icon = icon;
	} 

	
	public void setRate(int rate)
	{
		delay = 1000/rate;
	} 

	
	
	public void start()
	{
		if(timer != null)
			return;

		timer = new Timer(delay,new Animator());
		timer.start();
	} 

	
	
	public void stop()
	{
		current = 0;
		if(timer != null)
		{
			timer.stop();
			timer = null;
		}

		setImage(icon);
		host.repaint();
	} 

	
	private Image[] frames;
	private int current;
	private int delay;
	private Timer timer;
	private Component host;
	private Image icon;
	

	
	class Animator implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			current = (current + 1) % frames.length;
			setImage(frames[current]);
			host.repaint();
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.input.AbstractInputHandler,22,1,2,21,52,201,15,6,19,0.947619048,411,0.9,1,0.0,0.2,0,0,17.22727273,6,1.9545,0,"
package org.gjt.sp.jedit.input;

import org.gjt.sp.jedit.gui.KeyEventTranslator;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;

import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.JEditAbstractEditAction;
import org.gjt.sp.jedit.gui.ShortcutPrefixActiveEvent;


public abstract class AbstractInputHandler<E extends JEditAbstractEditAction>
{
	protected int lastActionCount;
	
	protected KeyListener keyEventInterceptor;
	protected String readNextChar;
	protected int repeatCount;
	protected E lastAction;


	protected static final int REPEAT_COUNT_THRESHOLD = 20;

	
	public AbstractInputHandler()
	{
		repeatCount = 1;
	} 
	
		
	
	public void addKeyBinding(String keyBinding, String action)
	{
		addKeyBinding(keyBinding,(Object)action);
	} 

	
	
	public void addKeyBinding(String keyBinding, E action)
	{
		addKeyBinding(keyBinding,(Object)action);
	} 

	
	
	public void addKeyBinding(String keyBinding, Object action)
	{
		Hashtable current = bindings;

		String prefixStr = null;

		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			String keyCodeStr = st.nextToken();
			if(prefixStr == null)
				prefixStr = keyCodeStr;
			else
				prefixStr = prefixStr + "" "" + keyCodeStr;

			KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(keyCodeStr);
			if(keyStroke == null)
				return;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
				{
					Hashtable hash = new Hashtable();
					hash.put(PREFIX_STR,prefixStr);
					o = hash;
					current.put(keyStroke,o);
					current = (Hashtable)o;
				}
			}
			else
				current.put(keyStroke,action);
		}
	} 

	
	
	public void removeKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;

		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			String keyCodeStr = st.nextToken();
			KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(keyCodeStr);
			if(keyStroke == null)
				return;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = ((Hashtable)o);
				else if(o != null)
				{
					
					
					current.remove(keyStroke);
					return;
				}
				else
				{
					
					return;
				}
			}
			else
				current.remove(keyStroke);
		}
	} 

	
	
	public void removeAllKeyBindings()
	{
		bindings.clear();
	} 

	
	
	public Object getKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);

		while(st.hasMoreTokens())
		{
			KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(
				st.nextToken());
			if(keyStroke == null)
				return null;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
				{
					if(!st.hasMoreTokens())
						return o;
					else
						current = (Hashtable)o;
				}
				else
					return o;
			}
			else
			{
				return current.get(keyStroke);
			}
		}

		return null;
	} 

	
	
	public int getLastActionCount()
	{
		return lastActionCount;
	} 

	
	
	public void resetLastActionCount()
	{
		lastActionCount = 0;
	} 

	
	public KeyListener getKeyEventInterceptor()
	{
		return keyEventInterceptor;
	} 

	
	
	public void setKeyEventInterceptor(KeyListener keyEventInterceptor)
	{
		this.keyEventInterceptor = keyEventInterceptor;
	} 

	
	
	public boolean isPrefixActive()
	{
		return readNextChar != null;
	} 
	
	
	
	public void setBindings(Hashtable bindings)
	{
		this.bindings = this.currentBindings = bindings;
	} 
	
	
	public void setCurrentBindings(Hashtable bindings)
	{
		currentBindings = bindings;
	} 

	
	
	public abstract boolean handleKey(KeyEventTranslator.Key keyStroke,boolean dryRun);
	

	

	
	public abstract void processKeyEvent(KeyEvent evt, int from, boolean global); 
	

	

	
	
	protected void sendShortcutPrefixOff()
	{
		if(shortcutOn)
		{
			ShortcutPrefixActiveEvent.firePrefixStateChange(null, false);
			shortcutOn = false;
		}
	} 
	
	public abstract void invokeAction(String action);
	
	public abstract void invokeAction(E action);

	
	
	public static String toString(KeyEvent evt)
	{
		String id;
		switch(evt.getID())
		{
		case KeyEvent.KEY_PRESSED:
			id = ""KEY_PRESSED"";
			break;
		case KeyEvent.KEY_RELEASED:
			id = ""KEY_RELEASED"";
			break;
		case KeyEvent.KEY_TYPED:
			id = ""KEY_TYPED"";
			break;
		default:
			id = ""unknown type"";
			break;
		}

		StringBuilder b = new StringBuilder(50);

		b.append(id);
		b.append("",keyCode=0x"").append(Integer.toString(evt.getKeyCode(), 16));
		b.append("",keyChar=0x"").append(Integer.toString(evt.getKeyChar(), 16));
		b.append("",modifiers=0x"").append(Integer.toString(evt.getModifiers(), 16));

		b.append("",consumed="");
		b.append(evt.isConsumed()?'1':'0');

		return b.toString();
	} 

	
	protected void processKeyEventKeyStrokeHandling(KeyEvent evt, int from, String mode, boolean global)
	{
		KeyEventTranslator.Key keyStroke = KeyEventTranslator.translateKeyEvent2(evt);

		if(keyStroke != null)
		{
			keyStroke.setIsFromGlobalContext(global);
			if(Debug.DUMP_KEY_EVENTS)
			{
				Log.log(Log.DEBUG,this,""Translated (key ""+mode+""): ""+keyStroke+"" from ""+from);
			}
			boolean consumed = false;
			if(handleKey(keyStroke,keyStroke.isPhantom()))
			{
				evt.consume();

				consumed = true;
			}
			if(Debug.DUMP_KEY_EVENTS)
			{
				Log.log(Log.DEBUG,this,""Translated (key ""+mode+""): ""+keyStroke+"" from ""+from+"": consumed=""+consumed+'.');
			}
		}
	} 
	
	

	
	public static Object PREFIX_STR = ""PREFIX_STR"";
	protected boolean shortcutOn = false;
	

	protected Hashtable bindings;
	protected Hashtable currentBindings;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.BeanShell,21,1,0,30,67,0,15,18,18,0.5,411,1.0,1,0.0,0.2875,0,0,18.47619048,6,1.3333,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.jedit.bsh.*;

import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class BeanShell
{
	private static final BeanShellFacade<View> bsh = new MyBeanShellFacade();
	
	static void init()
	{
		Log.log(Log.MESSAGE, BeanShell.class, ""Beanshell Init"");
	}

	
	
	public static void evalSelection(View view, JEditTextArea textArea)
	{
		bsh.evalSelection(view, textArea);
	} 

	
	
	public static void showEvaluateDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-input"",null);
		if(command != null)
		{
			if(!command.endsWith("";""))
				command = command + "";"";

			int repeat = view.getInputHandler().getRepeatCount();

			if(view.getMacroRecorder() != null)
			{
				view.getMacroRecorder().record(repeat,command);
			}

			Object returnValue = null;
			try
			{
				for(int i = 0; i < repeat; i++)
				{
					returnValue = bsh._eval(view,bsh.getNameSpace(),command);
				}
			}
			catch(Throwable e)
			{
				Log.log(Log.ERROR,BeanShell.class,e);

				bsh.handleException(view,null,e);
			}

			if(returnValue != null)
			{
				String[] args = { returnValue.toString() };
				GUIUtilities.message(view,""beanshell-eval"",args);
			}
		}
	} 

	
	
	public static void showEvaluateLinesDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-line"",null);

		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();

		if(command == null || command.length() == 0)
			return;

		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return;
		}

		if(!command.endsWith("";""))
			command = command + "";"";

		String script = ""int[] lines = textArea.getSelectedLines();\n""
			+ ""for(int i = 0; i < lines.length; i++)\n""
			+ ""{\n""
				+ ""line = lines[i];\n""
				+ ""index = line - lines[0];\n""
				+ ""start = buffer.getLineStartOffset(line);\n""
				+ ""end = buffer.getLineEndOffset(line);\n""
				+ ""text = buffer.getText(start,end - start - 1);\n""
				+ ""newText = "" + command + ""\n""
				+ ""if(newText != null)\n""
				+ ""{\n""
					+ ""buffer.remove(start,end - start - 1);\n""
					+ ""buffer.insert(start,String.valueOf(newText));\n""
				+ ""}\n""
			+ ""}\n"";

		if(view.getMacroRecorder() != null)
			view.getMacroRecorder().record(1,script);

		try
		{
			buffer.beginCompoundEdit();

			bsh.eval(view,script);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		textArea.selectNone();
	} 

	
	
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace)
	{
		try
		{
			_runScript(view,path,in,ownNamespace);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			bsh.handleException(view,path,e);
		}
	} 

	
	
	public static void runScript(View view, String path, Reader in,
		NameSpace namespace)
	{
		try
		{
			_runScript(view,path,in,namespace);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			bsh.handleException(view,path,e);
		}
	} 

	
	
	public static void _runScript(View view, String path, Reader in,
		boolean ownNamespace) throws Exception
	{
		_runScript(view,path,in,ownNamespace
			? new NameSpace(bsh.getNameSpace(),""namespace"")
			: bsh.getNameSpace());
	} 

	
	
	public static void _runScript(View view, String path, Reader in,
		NameSpace namespace) throws Exception
	{
		Log.log(Log.MESSAGE,BeanShell.class,""Running script "" + path);

		Interpreter interp = BeanShellFacade.createInterpreter(namespace);

		try
		{
			if(in == null)
			{
				Buffer buffer = jEdit.openTemporary(null,
					null,path,false);

				if(!buffer.isLoaded())
					VFSManager.waitForRequests();

				in = new StringReader(buffer.getText(0,
					buffer.getLength()));
			}

			bsh.setupDefaultVariables(namespace,view);
			interp.set(""scriptPath"",path);

			running = true;

			interp.eval(in,namespace,path);
		}
		catch(Exception e)
		{
			BeanShellFacade.unwrapException(e);
		}
		finally
		{
			running = false;
			try
			{
				
				if(namespace == bsh.getNameSpace())
				{
					bsh.resetDefaultVariables(namespace);
					interp.unset(""scriptPath"");
				}
			}
			catch(EvalError e)
			{
				
			}
		}
	} 

	
	
	public static Object eval(View view, NameSpace namespace, String command)
	{
		return bsh.eval(view, namespace, command);
	} 

	
	
	public static Object _eval(View view, NameSpace namespace, String command)
		throws Exception
	{
		return bsh._eval(view, namespace, command);
	} 

	
	
	public static BshMethod cacheBlock(String id, String code, boolean namespace)
		throws Exception
	{
		return bsh.cacheBlock(id, code, namespace);
	} 

	
	
	public static Object runCachedBlock(BshMethod method, View view,
		NameSpace namespace) throws Exception
	{
		return bsh.runCachedBlock(method, view, namespace);
	} 

	
	
	public static boolean isScriptRunning()
	{
		return running;
	} 

	
	
	public static NameSpace getNameSpace()
	{
		return bsh.getNameSpace();
	} 

	

	
	
	@Deprecated
	public static void runScript(View view, String path,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,null,ownNamespace);
	} 

	
	
	@Deprecated
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,in,ownNamespace);
	} 

	
	
	@Deprecated
	public static Object eval(View view, String command,
		boolean rethrowBshErrors)
	{
		return bsh.eval(view,command);
	} 

	
	
	@Deprecated
	public static Object eval(View view, NameSpace namespace,
		String command, boolean rethrowBshErrors)
	{
		return eval(view,namespace,command);
	} 

	

	

	
	
	static void resetClassManager()
	{
		bsh.resetClassManager();
	} 

	

	

	
	private static boolean running;
	

	

	
	private static class MyBeanShellFacade extends BeanShellFacade<View>
	{
		private MyBeanShellFacade()
		{
			classManager.setClassLoader(new JARClassLoader());
		}

		@Override
		protected void init()
		{
			super.init();
			global.importPackage(""org.gjt.sp.jedit.browser"");
			global.importPackage(""org.gjt.sp.jedit.bufferset"");
			global.importPackage(""org.gjt.sp.jedit.statusbar"");
			global.importPackage(""org.gjt.sp.jedit.gui"");
			global.importPackage(""org.gjt.sp.jedit.help"");
			global.importPackage(""org.gjt.sp.jedit.io"");
			global.importPackage(""org.gjt.sp.jedit.menu"");
			global.importPackage(""org.gjt.sp.jedit.msg"");
			global.importPackage(""org.gjt.sp.jedit.options"");
			global.importPackage(""org.gjt.sp.jedit.pluginmgr"");
			global.importPackage(""org.gjt.sp.jedit.print"");
			global.importPackage(""org.gjt.sp.jedit.search"");
		}
		
		@Override
		protected void setupDefaultVariables(NameSpace namespace, View view) throws UtilEvalError 
		{
			if(view != null)
			{
				EditPane editPane = view.getEditPane();
				namespace.setVariable(""view"",view, false);
				namespace.setVariable(""editPane"",editPane, false);
				namespace.setVariable(""buffer"",editPane.getBuffer(), false);
				namespace.setVariable(""textArea"",editPane.getTextArea(), false);
				namespace.setVariable(""wm"",view.getDockableWindowManager(), false);
			}
		}

		@Override
		protected void resetDefaultVariables(NameSpace namespace) throws UtilEvalError
		{
			namespace.setVariable(""view"",null, false);
			namespace.setVariable(""editPane"",null, false);
			namespace.setVariable(""buffer"",null, false);
			namespace.setVariable(""textArea"",null, false);
			namespace.setVariable(""wm"",null, false);
		}

		@Override
		protected void handleException(View view, String path, Throwable t)
		{
			if(t instanceof IOException)
			{
				VFSManager.error(view,path,""ioerror.read-error"",
					new String[] { t.toString() });
			}
			else
				new BeanShellErrorDialog(view,t);
		}
		
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHLiteral,5,2,0,7,22,4,1,6,2,0.5,155,0.0,0,0.80952381,0.366666667,0,0,29.8,10,4.0,0,"


package org.gjt.sp.jedit.bsh;

class BSHLiteral extends SimpleNode
{
    public Object value;

    BSHLiteral(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
    {
		if ( value == null )
			throw new InterpreterError(""Null in bsh literal: ""+value);

        return value;
    }

    private char getEscapeChar(char ch)
    {
        switch(ch)
        {
            case 'b':
                ch = '\b';
                break;

            case 't':
                ch = '\t';
                break;

            case 'n':
                ch = '\n';
                break;

            case 'f':
                ch = '\f';
                break;

            case 'r':
                ch = '\r';
                break;

            
            case '""':
            case '\'':
            case '\\':
                break;
        }

        return ch;
    }

    public void charSetup(String str)
    {
        char ch = str.charAt(0);
        if(ch == '\\')
        {
            
            ch = str.charAt(1);

            if(Character.isDigit(ch))
                ch = (char)Integer.parseInt(str.substring(1), 8);
            else
                ch = getEscapeChar(ch);
        }

        value = new Primitive(new Character(ch).charValue());
    }

    void stringSetup(String str)
    {
        StringBuilder buffer = new StringBuilder();
        for(int i = 0; i < str.length(); i++)
        {
            char ch = str.charAt(i);
            if(ch == '\\')
            {
                
                ch = str.charAt(++i);

                if(Character.isDigit(ch))
                {
                    int endPos = i;

                    
                    while(endPos < i + 2)
                    {
                        if(Character.isDigit(str.charAt(endPos + 1)))
                            endPos++;
                        else
                            break;
                    }

                    ch = (char)Integer.parseInt(str.substring(i, endPos + 1), 8);
                    i = endPos;
                }
                else
                    ch = getEscapeChar(ch);
            }

            buffer.append(ch);
        }

        value = buffer.toString().intern();
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.SyntaxUtilities,2,1,0,2,4,1,2,0,2,2.0,55,0.0,0,0.0,0.5,0,0,26.5,5,2.5,0,"
package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;


public class SyntaxUtilities
{
	
	
	public static boolean regionMatches(boolean ignoreCase, Segment text,
		int offset, char[] match)
	{
		int length = offset + match.length;
		if(length > text.offset + text.count)
			return false;
		char[] textArray = text.array;
		for(int i = offset, j = 0; i < length; i++, j++)
		{
			char c1 = textArray[i];
			char c2 = match[j];
			if(ignoreCase)
			{
				c1 = Character.toUpperCase(c1);
				c2 = Character.toUpperCase(c2);
			}
			if(c1 != c2)
				return false;
		}
		return true;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.Label,4,1,0,5,8,2,4,3,1,1.0,239,0.2,3,0.0,0.5,0,0,56.25,6,3.25,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



public class Label {

  

  CodeWriter owner;

  

  boolean resolved;

  

  int position;

  

  private int referenceCount;

  

  private int[] srcAndRefPositions;

  
  
  
  
  
  
  
  
  

  

  int beginStackSize;

  

  int maxStackSize;

  

  Edge successors;

  

  Label next;

  

  boolean pushed;

  
  
  

  

  public Label () {
  }

  
  
  

  

  void put (
    final CodeWriter owner,
    final ByteVector out,
    final int source,
    final boolean wideOffset)
  {
    if (CodeWriter.CHECK) {
      if (this.owner == null) {
        this.owner = owner;
      } else if (this.owner != owner) {
        throw new IllegalArgumentException();
      }
    }
    if (resolved) {
      if (wideOffset) {
        out.put4(position - source);
      } else {
        out.put2(position - source);
      }
    } else {
      if (wideOffset) {
        addReference(-1 - source, out.length);
        out.put4(-1);
      } else {
        addReference(source, out.length);
        out.put2(-1);
      }
    }
  }

  

  private void addReference (
    final int sourcePosition,
    final int referencePosition)
  {
    if (srcAndRefPositions == null) {
      srcAndRefPositions = new int[6];
    }
    if (referenceCount >= srcAndRefPositions.length) {
      int[] a = new int[srcAndRefPositions.length + 6];
      System.arraycopy(srcAndRefPositions, 0, a, 0, srcAndRefPositions.length);
      srcAndRefPositions = a;
    }
    srcAndRefPositions[referenceCount++] = sourcePosition;
    srcAndRefPositions[referenceCount++] = referencePosition;
  }

  

  boolean resolve (
    final CodeWriter owner,
    final int position,
    final byte[] data)
  {
    if (CodeWriter.CHECK) {
      if (this.owner == null) {
        this.owner = owner;
      }
      if (resolved || this.owner != owner) {
        throw new IllegalArgumentException();
      }
    }
    boolean needUpdate = false;
    this.resolved = true;
    this.position = position;
    int i = 0;
    while (i < referenceCount) {
      int source = srcAndRefPositions[i++];
      int reference = srcAndRefPositions[i++];
      int offset;
      if (source >= 0) {
        offset = position - source;
        if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
          
          
          
          
          
          
          int opcode = data[reference - 1] & 0xFF;
          if (opcode <= Constants.JSR) {
            
            data[reference - 1] = (byte)(opcode + 49);
          } else {
            
            data[reference - 1] = (byte)(opcode + 20);
          }
          needUpdate = true;
        }
        data[reference++] = (byte)(offset >>> 8);
        data[reference] = (byte)offset;
      } else {
        offset = position + source + 1;
        data[reference++] = (byte)(offset >>> 24);
        data[reference++] = (byte)(offset >>> 16);
        data[reference++] = (byte)(offset >>> 8);
        data[reference] = (byte)offset;
      }
    }
    return needUpdate;
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.Widget,3,1,0,28,3,3,28,0,3,2.0,3,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui.statusbar;

import javax.swing.JComponent;


public interface Widget 
{
	
	JComponent getComponent();
	
	
	void propertiesChanged();
	
	
	void update();
}
"
jEdit,4.3,org.gjt.sp.jedit.EditServer,8,2,0,11,55,12,4,9,4,0.771428571,388,1.0,0,0.897058824,0.3125,0,0,46.875,15,2.875,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.jedit.bsh.NameSpace;
import javax.swing.SwingUtilities;
import java.io.*;
import java.net.*;
import java.util.Random;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.util.Log;



public class EditServer extends Thread
{
	
	EditServer(String portFile)
	{
		super(""jEdit server daemon ["" + portFile + ""]"");
		setDaemon(true);
		this.portFile = portFile;

		try
		{
			
			
			
			
			
			if(OperatingSystem.isUnix())
			{
				new File(portFile).createNewFile();
				FileVFS.setPermissions(portFile,0600);
			}

			
			
			socket = new ServerSocket(0, 2,
				InetAddress.getByName(""127.0.0.1""));
			authKey = new Random().nextInt(Integer.MAX_VALUE);
			int port = socket.getLocalPort();

			FileWriter out = new FileWriter(portFile);

			try
			{
				out.write(""b\n"");
				out.write(String.valueOf(port));
				out.write(""\n"");
				out.write(String.valueOf(authKey));
				out.write(""\n"");
			}
			finally
			{
				out.close();
			}

			ok = true;

			Log.log(Log.DEBUG,this,""jEdit server started on port ""
				+ socket.getLocalPort());
			Log.log(Log.DEBUG,this,""Authorization key is ""
				+ authKey);
		}
		catch(IOException io)
		{
			
			Log.log(Log.NOTICE,this,io);
		}
	} 

	
	public void run()
	{
		for(;;)
		{
			if(abort)
				return;

			Socket client = null;
			try
			{
				client = socket.accept();

				
				
				
				client.setSoTimeout(1000);

				Log.log(Log.MESSAGE,this,client + "": connected"");

				DataInputStream in = new DataInputStream(
					client.getInputStream());

				if(!handleClient(client,in))
					abort = true;
			}
			catch(Exception e)
			{
				if(!abort)
					Log.log(Log.ERROR,this,e);
				abort = true;
			}
			finally
			{
				
			}
		}
	} 

	
	
	public static void handleClient(boolean restore, String parent,
		String[] args)
	{
		handleClient(restore,false,false,parent,args);
	} 

	
	
	public static Buffer handleClient(boolean restore,
		boolean newView, boolean newPlainView, String parent,
		String[] args)
	{
		
		if(jEdit.getFirstView() == null)
		{
			
			
			

			Buffer buffer = jEdit.openFiles(null,parent,args);

			if(jEdit.getBufferCount() == 0)
				jEdit.newFile((EditPane) null);

			boolean restoreFiles = restore
				&& jEdit.getBooleanProperty(""restore"")
				&& (buffer == null
				|| jEdit.getBooleanProperty(""restore.cli""));

			View view = PerspectiveManager.loadPerspective(
				restoreFiles);

			if(view == null)
			{
				if(buffer == null)
					buffer = jEdit.getFirstBuffer();
				view = jEdit.newView(null,buffer);
			}
			else if(buffer != null)
				view.setBuffer(buffer,false);

			return buffer;
		}
		else if(newPlainView)
		{
			
			Buffer buffer = jEdit.openFiles(null,parent,args);
			if(buffer == null)
				buffer = jEdit.getFirstBuffer();
			jEdit.newView(null,buffer,true);
			return buffer;
		}
		else if(newView)
		{
			
			Buffer buffer = jEdit.openFiles(null,parent,args);
			if(buffer == null)
				buffer = jEdit.getFirstBuffer();
			jEdit.newView(jEdit.getActiveView(),buffer,false);
			return buffer;
		}
		else
		{
			
			View view = jEdit.getActiveView();

			Buffer buffer = jEdit.openFiles(view,parent,args);

			
			
			
			
			if (jEdit.getBooleanProperty(""server.brokenToFront""))
				view.setState(java.awt.Frame.ICONIFIED);

			
			view.setState(java.awt.Frame.NORMAL);
			view.requestFocus();
			view.toFront();

			return buffer;
		}
	} 

	
	boolean isOK()
	{
		return ok;
	} 

	
	public int getPort()
	{
		return socket.getLocalPort();
	} 

	
	void stopServer()
	{
		abort = true;
		try
		{
			socket.close();
		}
		catch(IOException io)
		{
		}

		new File(portFile).delete();
	} 

	

	
	private String portFile;
	private ServerSocket socket;
	private int authKey;
	private boolean ok;
	private boolean abort;
	

	
	private boolean handleClient(final Socket client, DataInputStream in)
		throws Exception
	{
		int key = in.readInt();
		if(key != authKey)
		{
			Log.log(Log.ERROR,this,client + "": wrong""
				+ "" authorization key (got "" + key
				+ "", expected "" + authKey + "")"");
			in.close();
			client.close();

			return false;
		}
		else
		{
			
			client.setSoTimeout(0);

			Log.log(Log.DEBUG,this,client + "": authenticated""
				+ "" successfully"");

			final String script = in.readUTF();
			Log.log(Log.DEBUG,this,script);

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					try
					{
						NameSpace ns = new NameSpace(
							BeanShell.getNameSpace(),
							""EditServer namespace"");
						ns.setVariable(""socket"",client);
						BeanShell.eval(null,ns,script);
					}
					catch(org.gjt.sp.jedit.bsh.UtilEvalError e)
					{
						Log.log(Log.ERROR,this,e);
					}
					finally
					{
						try
						{
							BeanShell.getNameSpace().setVariable(""socket"",null);
						}
						catch(org.gjt.sp.jedit.bsh.UtilEvalError e)
						{
							Log.log(Log.ERROR,this,e);
						}
					}
				}
			});

			return true;
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.util.WorkThreadProgressListener,2,1,0,6,2,1,6,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.util;

import java.util.EventListener;


public interface WorkThreadProgressListener extends EventListener
{
	
	void statusUpdate(WorkThreadPool threadPool, int threadIndex);

	
	void progressUpdate(WorkThreadPool threadPool, int threadIndex);
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchOperationNode,10,1,0,10,44,23,7,3,10,0.805555556,421,1.0,1,0.0,0.257142857,0,0,40.7,13,2.9,0,"

package org.gjt.sp.jedit.search;


import java.io.File;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreePath;



public class HyperSearchOperationNode
{
	private boolean treeViewDisplayed;
	private final String searchString;
	private List<DefaultMutableTreeNode> resultNodes;
	private SearchMatcher searchMatcher;
	
	
	public HyperSearchOperationNode(String searchString, SearchMatcher searchMatcher)
	{
		this.searchString = searchString;
		this.searchMatcher = searchMatcher;
	}
	
	
	public String toString() 
	{
		return searchString;
	}
	
	
	public boolean isTreeViewDisplayed() 
	{
		return treeViewDisplayed;
	}
	
	
	public void setTreeViewDisplayed(boolean treeViewDisplayed) 
	{
		this.treeViewDisplayed = treeViewDisplayed;
	}
	
	
	public void restoreFlatNodes(JTree resultTree, DefaultMutableTreeNode operNode)
	{
		for (int i = 0; i < resultNodes.size(); i++)
		{
			DefaultMutableTreeNode element = resultNodes.get(i);
			if (element.getUserObject() instanceof HyperSearchFileNode)
				((HyperSearchFileNode)element.getUserObject()).showFullPath = true;

			operNode.insert(element, operNode.getChildCount());
		}

		((DefaultTreeModel)resultTree.getModel()).nodeStructureChanged(operNode);
		
		for (Enumeration e = operNode.children(); e.hasMoreElements();)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)e.nextElement();
			resultTree.expandPath(new TreePath(node.getPath()));
		}
		resultTree.scrollPathToVisible(
			new TreePath(operNode.getPath()));
	}
	
	
	public void cacheResultNodes(DefaultMutableTreeNode operNode) 
	{
		resultNodes = new ArrayList<DefaultMutableTreeNode>(operNode.getChildCount());
		for (Enumeration e = operNode.children(); e.hasMoreElements();)
			resultNodes.add((DefaultMutableTreeNode) e.nextElement());
	}
	
	
	public static void removeNodeFromCache(MutableTreeNode mnode)
	{
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)mnode;
		if (node.getUserObject() instanceof HyperSearchOperationNode)
			return;
		
		DefaultMutableTreeNode tmpNode = node;
		while ((tmpNode = (DefaultMutableTreeNode) tmpNode.getParent()) != null)
		{
			if (!(tmpNode.getUserObject() instanceof HyperSearchOperationNode))
				continue;
			HyperSearchOperationNode operNode = (HyperSearchOperationNode) tmpNode.getUserObject();
			if (operNode.resultNodes != null)
			{
				
				operNode.resultNodes.remove(node);
			}
			break;
		}
		
	}
	
	
	public void insertTreeNodes(JTree resultTree, DefaultMutableTreeNode operNode)
	{
		String fileSep = System.getProperty(""file.separator"");
		String fileSepRegex = System.getProperty(""file.separator"");
		if (fileSep.equals(""\\""))
			fileSepRegex = ""\\\\"";
		
		
		String[] topPathTmp = null;
		int topPathNdx = -1;

		for (int i = 0;i < resultNodes.size();i++)
		{
			DefaultMutableTreeNode fileTreeNode = resultNodes.get(i);
			Object obj = fileTreeNode.getUserObject();
			if (!(obj instanceof HyperSearchFileNode))
				continue;
			HyperSearchFileNode fileNode = (HyperSearchFileNode)obj;

			int pos = fileNode.path.lastIndexOf(fileSep);
			String pathName = fileNode.path.substring(0, pos);
			String[] paths = pathName.split(fileSepRegex);
			if (topPathNdx == -1)
			{
				topPathNdx = paths.length;
				topPathTmp = paths;
			}
			else if (paths.length < topPathNdx)
			{
				topPathNdx = paths.length;
				topPathTmp = paths;				
			}
			else
			{
				for (int ndx =0 ; ndx < topPathNdx; ndx++)
				{
					if (!paths[ndx].equals(topPathTmp[ndx]))
					{
						topPathNdx = ndx;
						break;
					}
				}
			}
		}
		String[] topPath = new String[topPathNdx];
		String topPathPath = """";
		for (int ndx = 0 ; ndx < topPathNdx; ndx++)
		{
			topPath[ndx] = topPathTmp[ndx];
			topPathPath = topPathPath.concat(topPath[ndx] + fileSep);
		}
		Map<String, DefaultMutableTreeNode> treeNodes = new HashMap<String, DefaultMutableTreeNode>();
		HyperSearchFolderNode folderNode = 
			new HyperSearchFolderNode(new File(topPathPath), true);
		DefaultMutableTreeNode folderTreeNode = new DefaultMutableTreeNode(folderNode);
		operNode.insert(folderTreeNode, operNode.getChildCount());
		treeNodes.put(topPathPath, folderTreeNode);
		
		for (int i = 0;i < resultNodes.size();i++)
		{
			DefaultMutableTreeNode fileTreeNode = resultNodes.get(i);
			Object obj = fileTreeNode.getUserObject();
			if (!(obj instanceof HyperSearchFileNode))
				continue;
			HyperSearchFileNode fileNode = (HyperSearchFileNode)obj;

			fileNode.showFullPath = false;
			int pos = fileNode.path.lastIndexOf(fileSep);
			String pathName = fileNode.path.substring(0, pos);
			String[] paths = pathName.split(fileSepRegex);
			
			DefaultMutableTreeNode insNode = folderTreeNode;
			String partialPath = topPathPath;
			for (int ndx = topPathNdx; ndx < paths.length; ndx++)
			{
				partialPath = partialPath.concat(paths[ndx] + fileSep);
				DefaultMutableTreeNode tmpNode = treeNodes.get(partialPath);
				if (tmpNode == null)
				{
					HyperSearchFolderNode tmpFolderNode = 
						new HyperSearchFolderNode(new File(partialPath), false);
					tmpNode = new DefaultMutableTreeNode(tmpFolderNode);
					insNode.insert(tmpNode, insNode.getChildCount());
					treeNodes.put(partialPath, tmpNode);
				}
				insNode = tmpNode;
			}
			insNode.insert(fileTreeNode, insNode.getChildCount());
			treeNodes.put(fileNode.path, insNode);
		}
		
	}

	
	public SearchMatcher getSearchMatcher()
	{
		return searchMatcher;
	}

	
	public String getSearchString()
	{
		return searchString;
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHMethodInvocation,4,2,0,15,22,6,2,13,1,2.0,119,0.0,0,0.85,0.4375,1,1,28.75,1,0.75,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.InvocationTargetException;

class BSHMethodInvocation extends SimpleNode
{
	BSHMethodInvocation (int id) { super(id); }

	BSHAmbiguousName getNameNode() {
		return (BSHAmbiguousName)jjtGetChild(0);
	}

	BSHArguments getArgsNode() {
		return (BSHArguments)jjtGetChild(1);
	}

	
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		BSHAmbiguousName nameNode = getNameNode();

		
		
		if ( namespace.getParent() != null && namespace.getParent().isClass
			&& ( nameNode.text.equals(""super"") || nameNode.text.equals(""this"") )
		)
			return Primitive.VOID;
 
		Name name = nameNode.getName(namespace);
		Object[] args = getArgsNode().getArguments(callstack, interpreter);




		try {
			return name.invokeMethod( interpreter, args, callstack, this);
		} catch ( ReflectError e ) {
			throw new EvalError(
				""Error in method invocation: "" + e.getMessage(), 
				this, callstack );
		} catch ( InvocationTargetException e ) 
		{
			String msg = ""Method Invocation ""+name;
			Throwable te = e.getTargetException();

			
			boolean isNative = true;
			if ( te instanceof EvalError ) 
				if ( te instanceof TargetError )
					isNative = ((TargetError)te).inNativeCode();
				else
					isNative = false;
			
			throw new TargetError( msg, te, this, callstack, isNative );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.io.Encoding,3,1,0,5,3,3,5,0,3,2.0,3,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.io;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;


public interface Encoding
{
	
	public Reader getTextReader(InputStream in) throws IOException;
	
	
	public Writer getTextWriter(OutputStream out) throws IOException;

	
	public Reader getPermissiveTextReader(InputStream in)
		throws IOException;
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ExtendedGridLayout,17,1,0,3,82,106,0,3,13,0.5625,2224,1.0,0,0.0,0.18487395,0,0,129.5882353,46,8.0,0,"

package org.gjt.sp.jedit.gui;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import static java.awt.Component.CENTER_ALIGNMENT;

import static org.gjt.sp.jedit.gui.ExtendedGridLayoutConstraints.REMAINDER;


public class ExtendedGridLayout implements LayoutManager2
{
	
	private final Hashtable<Component,ExtendedGridLayoutConstraints> comptable;
	
	
	private final int hgap;
	
	
	private final int vgap;
	
	
	private final Insets distanceToBorders;
	
	
	private static enum LayoutSize { MINIMUM, PREFERRED, MAXIMUM }
	
	
	public ExtendedGridLayout(int hgap, int vgap, Insets distanceToBorders)
	{
		if (hgap < 0)
		{
			throw new IllegalArgumentException(""hgap must be non-negative ("" + hgap + ')');
		}
		if (vgap < 0)
		{
			throw new IllegalArgumentException(""vgap must be non-negative ("" + vgap + ')');
		}
		this.hgap = hgap;
		this.vgap = vgap;
		this.distanceToBorders = (Insets)distanceToBorders.clone();
		comptable = new Hashtable<Component,ExtendedGridLayoutConstraints>();
	}
	
	
	public ExtendedGridLayout()
	{
		this(0,0,new Insets(0,0,0,0));
	}
	
	
	public void addLayoutComponent(String name, Component component)
	{
		addLayoutComponent(component,name);
	}
	
	
	public void addLayoutComponent(Component component, Object constraints)
	{
		if (null == constraints)
		{
			constraints = new ExtendedGridLayoutConstraints(component);
		}
		if (constraints instanceof ExtendedGridLayoutConstraints)
		{
			ExtendedGridLayoutConstraints eglConstraints = (ExtendedGridLayoutConstraints)constraints;
			if (eglConstraints.isPlaceholder())
			{
				throw new IllegalArgumentException(""constraints must not be a placeholder"");
			}
			else if (component != eglConstraints.getComponent())
			{
				throw new IllegalArgumentException(""constraints is not the right one for this component"");
			}
			comptable.put(component,eglConstraints);
		}
		else 
		{
			throw new IllegalArgumentException(""constraints must not be an ExtendedGridLayoutConstraints object"");
		}
	}
	
	
	private ExtendedGridLayoutConstraints lookupConstraints(Component component)
	{
		if (null == component)
		{
			throw new NullPointerException(""component must not be null"");
		}
		ExtendedGridLayoutConstraints constraints = comptable.get(component);
		if (null == constraints)
		{
			constraints = new ExtendedGridLayoutConstraints(component);
			comptable.put(component,constraints);
		}
		return constraints;
	}
	
	
	public void removeLayoutComponent(Component component)
	{
		comptable.remove(component);
	}
	
	
	public float getLayoutAlignmentX(Container container)
	{
		return CENTER_ALIGNMENT;
	}
	
	
	public float getLayoutAlignmentY(Container container)
	{
		return CENTER_ALIGNMENT;
	}
	
	
	public Dimension minimumLayoutSize(Container parent)
	{
		synchronized (parent.getTreeLock())
		{
			List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();
			Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();
			Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();
			Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);
			return getSize(parent,LayoutSize.MINIMUM,false,gridSize,gridRows,colspans,rowspans,new int[0][0]);
		}
	}
	
	
	public Dimension preferredLayoutSize(Container parent)
	{
		synchronized (parent.getTreeLock())
		{
			List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();
			Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();
			Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();
			Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);
			return getSize(parent,LayoutSize.PREFERRED,false,gridSize,gridRows,colspans,rowspans,new int[0][0]);
		}
	}
	
	
	public Dimension maximumLayoutSize(Container parent)
	{
		synchronized (parent.getTreeLock())
		{
			List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();
			Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();
			Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();
			Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);
			return getSize(parent,LayoutSize.MAXIMUM,false,gridSize,gridRows,colspans,rowspans,new int[0][0]);
		}
	}
	
	
	public void invalidateLayout(Container container)
	{
	}
	
	
	public void layoutContainer(Container parent)
	{
		synchronized (parent.getTreeLock())
		{
			
			List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();
			Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();
			Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();
			Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);
			
			
			int[][] layoutSizes = new int[6][];
			Dimension preferredSize = getSize(parent,LayoutSize.PREFERRED,true,gridSize,gridRows,colspans,rowspans,layoutSizes);
			int[] minimumColWidths = layoutSizes[0];
			int[] minimumRowHeights = layoutSizes[1];
			int[] preferredColWidths = layoutSizes[2];
			int[] preferredRowHeights = layoutSizes[3];
			int[] maximumColWidths = layoutSizes[4];
			int[] maximumRowHeights = layoutSizes[5];
			
			
			Dimension parentSize = parent.getSize();
			Insets insets = parent.getInsets();
			int freeWidth = parentSize.width
					- insets.left - insets.right
					- (gridSize.width - 1) * hgap
					- distanceToBorders.left - distanceToBorders.right;
			int freeHeight = parentSize.height
					 - insets.top - insets.bottom
					 - (gridSize.height - 1) * vgap
					 - distanceToBorders.top - distanceToBorders.bottom;
			redistributeSpace(preferredSize.width,
					  freeWidth,
					  0,gridSize.width,
					  preferredColWidths,
					  minimumColWidths,
					  maximumColWidths);
			redistributeSpace(preferredSize.height,
					  freeHeight,
					  0,gridSize.height,
					  preferredRowHeights,
					  minimumRowHeights,
					  maximumRowHeights);
			
			
			for (int row=0, y=insets.top+distanceToBorders.top ; row<gridSize.height ; y+=preferredRowHeights[row]+vgap, row++)
			{
				List<ExtendedGridLayoutConstraints> gridRow = gridRows.get(row);
				for (int col=0, x=insets.left+distanceToBorders.left ; col<gridSize.width; x+=preferredColWidths[col]+hgap, col++)
				{
					ExtendedGridLayoutConstraints cell = gridRow.get(col);
					if ((null != cell) && (null != cell.getComponent()) && !cell.isPlaceholder())
					{
						Component component = cell.getComponent();
						Dimension maxSize = component.getMaximumSize();
						int fromCol = cell.getCol();
						int colspan = cell.getEffectiveColspan();
						int toCol = fromCol + colspan;
						int width = 0;
						for (int col2=fromCol ; col2<toCol ; col2++)
						{
							width += preferredColWidths[col2];
						}
						width += (colspan - 1) * hgap;
						int fromRow = cell.getRow();
						int rowspan = cell.getEffectiveRowspan();
						int toRow = fromRow + rowspan;
						int height = 0;
						for (int row2=fromRow ; row2<toRow ; row2++)
						{
							height += preferredRowHeights[row2];
						}
						height += (rowspan - 1) * vgap;
						int xCorrection = 0;
						int yCorrection = 0;
						if (width > maxSize.width)
						{
							xCorrection = (int)((width - maxSize.width) * component.getAlignmentX());
							width = maxSize.width;
						}
						if (height > maxSize.height)
						{
							yCorrection = (int)((height-maxSize.height) * component.getAlignmentY());
							height = maxSize.height;
						}
						
						component.setBounds(x + xCorrection, y + yCorrection, width, height);
					}
				}
			}
		}
	}
	
	
	private void redistributeSpace(int totalSize, int freeSize,
				       int start, int stop,
				       int[] preferredElementSizes,
				       int[] minimumElementSizes,
				       int[] maximumElementSizes)
	{
		if (totalSize != freeSize)
		{
			boolean grow = totalSize < freeSize;
			
			freeSize = (freeSize - totalSize) * (grow ? 1 : -1);
			while (freeSize > 0)
			{
				
				
				int modifyableAmount = 0;
				long modifySize = 0;
				for (int i=start ; i<stop ; i++)
				{
					if ((grow && (preferredElementSizes[i] < maximumElementSizes[i])) ||
					    (!grow && (preferredElementSizes[i] > minimumElementSizes[i])))
					{
						modifyableAmount++;
						modifySize += preferredElementSizes[i];
					}
				}
				boolean checkBounds = true;
				
				if (0 == modifyableAmount)
				{
					for (int i=start ; i<stop ; i++)
					{
						modifySize += preferredElementSizes[i];
					}
					checkBounds = false;
					modifyableAmount = stop - start;
				}
				
				if (modifySize == 0)
				{
					break;
				}
				
				if (freeSize < modifyableAmount)
				{
					for (int i=start ; i<stop ; i++)
					{
						if ((freeSize != 0) &&
						    (!checkBounds ||
						     (checkBounds &&
						      (grow && (preferredElementSizes[i] < maximumElementSizes[i])) ||
						      (!grow && (preferredElementSizes[i] > minimumElementSizes[i])))))
						{
							preferredElementSizes[i] += (grow ? 1 : -1);
							if (0 > preferredElementSizes[i])
							{
								preferredElementSizes[i] = 0;
							}
							freeSize--;
						}
					}
				}
				else
				{
					long modifySizeAddition = 0;
					double factor = (double)(freeSize + modifySize) / (double)modifySize;
					for (int i=start ; i<stop ; i++)
					{
						long modifyableSize = (checkBounds ? (grow ? maximumElementSizes[i] - preferredElementSizes[i] : preferredElementSizes[i] - minimumElementSizes[i]) : Integer.MAX_VALUE - preferredElementSizes[i]);
						long elementModifySize = Math.abs(Math.round((factor * preferredElementSizes[i]) - preferredElementSizes[i]));
						if (elementModifySize <= modifyableSize)
						{
							preferredElementSizes[i] += (grow ? elementModifySize : -elementModifySize);
							modifySizeAddition += (grow ? elementModifySize : -elementModifySize);
							freeSize -= elementModifySize;
						}
						else
						{
							preferredElementSizes[i] += (grow ? modifyableSize : -modifyableSize);
							modifySizeAddition += (grow ? modifyableSize : -modifyableSize);
							freeSize -= modifyableSize;
						}
						if (0 > preferredElementSizes[i])
						{
							preferredElementSizes[i] = 0;
						}
					}
					modifySize += modifySizeAddition;
				}
			}
		}
	}
	
	
	private Dimension getSize(Container parent, LayoutSize layoutSize, boolean fillRawSizes,
				  Dimension gridSize, List<List<ExtendedGridLayoutConstraints>> gridRows,
				  Set<ExtendedGridLayoutConstraints> colspans,
				  Set<ExtendedGridLayoutConstraints> rowspans,
				  int[][] resultArrays)
	{
		if (fillRawSizes && (resultArrays.length < 6))
		{
			throw new IllegalArgumentException(""If fillRawSizes is true, resultArrays.length must be >= 6 ("" + resultArrays.length + ')');
		}
		int[] minimumColWidths = new int[gridSize.width];
		int[] minimumRowHeights = new int[gridSize.height];
		int[] preferredColWidths = new int[gridSize.width];
		int[] preferredRowHeights = new int[gridSize.height];
		int[] maximumColWidths = new int[gridSize.width];
		int[] maximumRowHeights = new int[gridSize.height];
		Arrays.fill(minimumColWidths,0);
		Arrays.fill(minimumRowHeights,0);
		Arrays.fill(preferredColWidths,0);
		Arrays.fill(preferredRowHeights,0);
		Arrays.fill(maximumColWidths,0);
		Arrays.fill(maximumRowHeights,0);
		
		
		
		
		
		
		for (int row=0 ; row<gridSize.height ; row++)
		{
			List<ExtendedGridLayoutConstraints> gridRow = gridRows.get(row);
			for (int col=0 ; col<gridSize.width ; col++)
			{
				ExtendedGridLayoutConstraints cell = gridRow.get(col);
				if ((null != cell) && (null != cell.getComponent()))
				{
					Component component = cell.getComponent();
					Dimension minimumSize = component.getMinimumSize();
					Dimension preferredSize = component.getPreferredSize();
					Dimension maximumSize = component.getMaximumSize();
					if (!colspans.contains(cell))
					{
						minimumColWidths[col] = Math.max(minimumColWidths[col],minimumSize.width);
						preferredColWidths[col] = Math.max(preferredColWidths[col],preferredSize.width);
						maximumColWidths[col] = Math.max(maximumColWidths[col],maximumSize.width);
					}
					if (!rowspans.contains(cell))
					{
						minimumRowHeights[row] = Math.max(minimumRowHeights[row],minimumSize.height);
						preferredRowHeights[row] = Math.max(preferredRowHeights[row],preferredSize.height);
						maximumRowHeights[row] = Math.max(maximumRowHeights[row],maximumSize.height);
					}
				}
			}
		}
		
		
		
		
		for (int col=0 ; col<gridSize.width ; col++)
		{
			if (minimumColWidths[col] >= maximumColWidths[col])
			{
				maximumColWidths[col] = minimumColWidths[col];
				preferredColWidths[col] = minimumColWidths[col];
			}
			else if (preferredColWidths[col] < minimumColWidths[col])
			{
				preferredColWidths[col] = minimumColWidths[col];
			}
			else if (preferredColWidths[col] > maximumColWidths[col])
			{
				preferredColWidths[col] = maximumColWidths[col];
			}
		}
		
		
		
		for (ExtendedGridLayoutConstraints cell : colspans)
		{
			int fromCol = cell.getCol();
			int colspan = cell.getEffectiveColspan();
			int toCol = fromCol + colspan;
			int currentMinimumColWidth = 0;
			int currentPreferredColWidth = 0;
			int currentMaximumColWidth = 0;
			for (int col=fromCol ; col<toCol ; col++)
			{
				int minimumColWidth = minimumColWidths[col];
				if ((Integer.MAX_VALUE-minimumColWidth) < currentMinimumColWidth)
				{
					currentMinimumColWidth = Integer.MAX_VALUE;
				}
				else
				{
					currentMinimumColWidth += minimumColWidth;
				}
				int preferredColWidth = preferredColWidths[col];
				if ((Integer.MAX_VALUE-preferredColWidth) < currentPreferredColWidth)
				{
					currentPreferredColWidth = Integer.MAX_VALUE;
				}
				else
				{
					currentPreferredColWidth += preferredColWidth;
				}
				int maximumColWidth = maximumColWidths[col];
				if ((Integer.MAX_VALUE-maximumColWidth) < currentMaximumColWidth)
				{
					currentMaximumColWidth = Integer.MAX_VALUE;
				}
				else
				{
					currentMaximumColWidth += maximumColWidth;
				}
			}
			Component component = cell.getComponent();
			int wantedMaximumColWidth = component.getMaximumSize().width - ((colspan - 1) * hgap);
			if (currentMaximumColWidth < wantedMaximumColWidth)
			{
				redistributeSpace(currentMaximumColWidth,
						  wantedMaximumColWidth,
						  fromCol,toCol,
						  maximumColWidths,
						  maximumColWidths,
						  maximumColWidths);
			}
			int wantedMinimumColWidth = component.getMinimumSize().width - ((colspan - 1) * hgap);
			if (currentMinimumColWidth < wantedMinimumColWidth)
			{
				redistributeSpace(currentMinimumColWidth,
						  wantedMinimumColWidth,
						  fromCol,toCol,
						  minimumColWidths,
						  minimumColWidths,
						  maximumColWidths);
			}
			int wantedPreferredColWidth = component.getPreferredSize().width - ((colspan - 1) * hgap);
			if (currentPreferredColWidth < wantedPreferredColWidth)
			{
				redistributeSpace(currentPreferredColWidth,
						  wantedPreferredColWidth,
						  fromCol,toCol,
						  preferredColWidths,
						  minimumColWidths,
						  maximumColWidths);
			}
		}
		
		
		
		
		for (int col=0 ; col<gridSize.width ; col++)
		{
			if (minimumColWidths[col] >= maximumColWidths[col])
			{
				maximumColWidths[col] = minimumColWidths[col];
				preferredColWidths[col] = minimumColWidths[col];
			}
			else if (preferredColWidths[col] < minimumColWidths[col])
			{
				preferredColWidths[col] = minimumColWidths[col];
			}
			else if (preferredColWidths[col] > maximumColWidths[col])
			{
				preferredColWidths[col] = maximumColWidths[col];
			}
		}
		
		
		
		
		for (int row=0 ; row<gridSize.height ; row++)
		{
			if (minimumRowHeights[row] >= maximumRowHeights[row])
			{
				maximumRowHeights[row] = minimumRowHeights[row];
				preferredRowHeights[row] = minimumRowHeights[row];
			}
			else if (preferredRowHeights[row] < minimumRowHeights[row])
			{
				preferredRowHeights[row] = minimumRowHeights[row];
			}
			else if (preferredRowHeights[row] > maximumRowHeights[row])
			{
				preferredRowHeights[row] = maximumRowHeights[row];
			}
		}
		
		
		
		for (ExtendedGridLayoutConstraints cell : rowspans)
		{
			int fromRow = cell.getRow();
			int rowspan = cell.getEffectiveRowspan();
			int toRow = fromRow + rowspan;
			int currentMinimumRowHeight = 0;
			int currentPreferredRowHeight = 0;
			int currentMaximumRowHeight = 0;
			for (int row=fromRow ; row<toRow ; row++)
			{
				int minimumRowHeight = minimumRowHeights[row];
				if ((Integer.MAX_VALUE-minimumRowHeight) < currentMinimumRowHeight)
				{
					currentMinimumRowHeight = Integer.MAX_VALUE;
				}
				else
				{
					currentMinimumRowHeight += minimumRowHeight;
				}
				int preferredRowHeight = preferredRowHeights[row];
				if ((Integer.MAX_VALUE-preferredRowHeight) < currentPreferredRowHeight)
				{
					currentPreferredRowHeight = Integer.MAX_VALUE;
				}
				else
				{
					currentPreferredRowHeight += preferredRowHeight;
				}
				int maximumRowHeight = maximumRowHeights[row];
				if ((Integer.MAX_VALUE-maximumRowHeight) < currentMaximumRowHeight)
				{
					currentMaximumRowHeight = Integer.MAX_VALUE;
				}
				else
				{
					currentMaximumRowHeight += maximumRowHeight;
				}
			}
			Component component = cell.getComponent();
			int wantedMaximumRowHeight = component.getMaximumSize().height - ((rowspan - 1) * vgap);
			if (currentMaximumRowHeight < wantedMaximumRowHeight)
			{
				redistributeSpace(currentMaximumRowHeight,
						  wantedMaximumRowHeight,
						  fromRow,toRow,
						  maximumRowHeights,
						  maximumRowHeights,
						  maximumRowHeights);
			}
			int wantedMinimumRowHeight = component.getMinimumSize().height - ((rowspan - 1) * vgap);
			if (currentMinimumRowHeight < wantedMinimumRowHeight)
			{
				redistributeSpace(currentMinimumRowHeight,
						  wantedMinimumRowHeight,
						  fromRow,toRow,
						  minimumRowHeights,
						  minimumRowHeights,
						  maximumRowHeights);
			}
			int wantedPreferredRowHeight = component.getPreferredSize().height - ((rowspan - 1) * vgap);
			if (currentPreferredRowHeight < wantedPreferredRowHeight)
			{
				redistributeSpace(currentPreferredRowHeight,
						  wantedPreferredRowHeight,
						  fromRow,toRow,
						  preferredRowHeights,
						  minimumRowHeights,
						  maximumRowHeights);
			}
		}
		
		
		
		
		for (int row=0 ; row<gridSize.height ; row++)
		{
			if (minimumRowHeights[row] >= maximumRowHeights[row])
			{
				maximumRowHeights[row] = minimumRowHeights[row];
				preferredRowHeights[row] = minimumRowHeights[row];
			}
			else if (preferredRowHeights[row] < minimumRowHeights[row])
			{
				preferredRowHeights[row] = minimumRowHeights[row];
			}
			else if (preferredRowHeights[row] > maximumRowHeights[row])
			{
				preferredRowHeights[row] = maximumRowHeights[row];
			}
		}
		
		
		if (fillRawSizes)
		{
			resultArrays[0] = minimumColWidths;
			resultArrays[1] = minimumRowHeights;
			resultArrays[2] = preferredColWidths;
			resultArrays[3] = preferredRowHeights;
			resultArrays[4] = maximumColWidths;
			resultArrays[5] = maximumRowHeights;
		}
		
		
		int[] colWidths;
		int[] rowHeights;
		switch (layoutSize)
		{
			case MINIMUM:
				colWidths = minimumColWidths;
				rowHeights = minimumRowHeights;
				break;
			
			case PREFERRED:
				colWidths = preferredColWidths;
				rowHeights = preferredRowHeights;
				break;
			
			case MAXIMUM:
				colWidths = maximumColWidths;
				rowHeights = maximumRowHeights;
				break;
			
			default:
				throw new InternalError(""Missing case branch for LayoutSize: "" + layoutSize);
		}
		long totalWidth = 0;
		long totalHeight = 0;
		for (int width : colWidths)
		{
			totalWidth += width;
		}
		for (int height : rowHeights)
		{
			totalHeight += height;
		}
		
		
		
		if (!fillRawSizes)
		{
			Insets insets = parent.getInsets();
			totalWidth += insets.left + insets.right + ((gridSize.width - 1) * hgap) + distanceToBorders.left + distanceToBorders.right;
			totalHeight += insets.top + insets.bottom + ((gridSize.height - 1) * vgap) + distanceToBorders.top + distanceToBorders.bottom;
		}
		
		
		if (totalWidth > Integer.MAX_VALUE)
		{
			totalWidth = Integer.MAX_VALUE;
		}
		if (totalHeight > Integer.MAX_VALUE)
		{
			totalHeight = Integer.MAX_VALUE;
		}
		
		return new Dimension((int)totalWidth,(int)totalHeight);
	}
	
	
	private Dimension buildGrid(Container parent, List<List<ExtendedGridLayoutConstraints>> gridRows,
				    Set<ExtendedGridLayoutConstraints> colspans, Set<ExtendedGridLayoutConstraints> rowspans)
	{
		
		List<List<ExtendedGridLayoutConstraints>> rows = new ArrayList<List<ExtendedGridLayoutConstraints>>();
		Component[] components = parent.getComponents();
		for (Component component : components)
		{
			if (component.isVisible())
			{
				ExtendedGridLayoutConstraints constraints = lookupConstraints(component).getWorkCopy();
				int rowNumber = constraints.getRow();
				for (int i=rowNumber, c=rows.size() ; i>=c ; i--)
				{
					rows.add(new ArrayList<ExtendedGridLayoutConstraints>());
				}
				List<ExtendedGridLayoutConstraints> row = rows.get(rowNumber);
				row.add(constraints);
			}
		}
		
		
		List<Iterator<ExtendedGridLayoutConstraints>> rowIterators = new ArrayList<Iterator<ExtendedGridLayoutConstraints>>();
		List<ListIterator<ExtendedGridLayoutConstraints>> gridRowIterators = new ArrayList<ListIterator<ExtendedGridLayoutConstraints>>();
		boolean haveNext = false;
		for (List<ExtendedGridLayoutConstraints> row : rows)
		{
			Iterator<ExtendedGridLayoutConstraints> rowIterator = row.iterator();
			rowIterators.add(rowIterator);
			if (rowIterator.hasNext())
			{
				haveNext = true;
			}
			List<ExtendedGridLayoutConstraints> gridRow = new ArrayList<ExtendedGridLayoutConstraints>();
			gridRows.add(gridRow);
			gridRowIterators.add(gridRow.listIterator());
		}
		
		
		int col = -1;
		while (haveNext)
		{
			col++;
			haveNext = false;
			for (int row=0, c=gridRows.size() ; row<c ; row++)
			{
				Iterator<ExtendedGridLayoutConstraints> rowIterator = rowIterators.get(row);
				ListIterator<ExtendedGridLayoutConstraints> gridRowIterator = gridRowIterators.get(row);
				
				
				if (row > 0)
				{
					ExtendedGridLayoutConstraints rowspanSource = gridRows.get(row-1).get(col);
					if (null != rowspanSource)
					{
						ExtendedGridLayoutConstraints rowspanPlaceholder = rowspanSource.getRowspanPlaceholder(true);
						if (null != rowspanPlaceholder)
						{
							rowspans.add(rowspanSource);
							gridRowIterator.add(rowspanPlaceholder);
							if (null != rowspanPlaceholder.getColspanPlaceholder(false))
							{
								switch (rowspanPlaceholder.getColspan())
								{
									case REMAINDER:
										break;
									
									default:
										haveNext = true;
								}
							}
							else if (rowIterator.hasNext())
							{
								haveNext = true;
							}
							continue;
						}
					}
				}
				
				
				if (gridRowIterator.hasPrevious())
				{
					ExtendedGridLayoutConstraints colspanSource = gridRowIterator.previous();
					gridRowIterator.next();
					if (null != colspanSource)
					{
						ExtendedGridLayoutConstraints colspanPlaceholder = colspanSource.getColspanPlaceholder(true);
						if (null != colspanPlaceholder)
						{
							colspans.add(colspanSource);
							gridRowIterator.add(colspanPlaceholder);
							if (null != colspanPlaceholder.getColspanPlaceholder(false))
							{
								switch (colspanPlaceholder.getColspan())
								{
									case REMAINDER:
										break;
									
									default:
										haveNext = true;
								}
							}
							else if (rowIterator.hasNext())
							{
								haveNext = true;
							}
							continue;
						}
					}
				}
				
				
				if (rowIterator.hasNext())
				{
					ExtendedGridLayoutConstraints newConstraints = rowIterator.next();
					newConstraints.setCol(col);
					gridRowIterator.add(newConstraints);
					if (null != newConstraints.getColspanPlaceholder(false))
					{
						switch (newConstraints.getColspan())
						{
							case REMAINDER:
								break;
							
							default:
								haveNext = true;
						}
					}
					else if (rowIterator.hasNext())
					{
						haveNext = true;
					}
				}
				else
				{
					gridRowIterator.add(null);
				}
			}
		}
		
		
		haveNext = false;
		int gridRowsSize = gridRows.size();
		if (gridRowsSize > 0)
		{
			ListIterator<ExtendedGridLayoutConstraints> gridRowIterator = gridRows.get(gridRows.size()-1).listIterator();
			while (gridRowIterator.hasNext())
			{
				ExtendedGridLayoutConstraints cell = gridRowIterator.next();
				if ((null != cell) &&
				    ((REMAINDER != cell.getRowspan()) &&
				     (null != cell.getRowspanPlaceholder(false))))
				{
					haveNext = true;
					break;
				}
			}
			while (haveNext)
			{
				haveNext = false;
				gridRowIterator = gridRows.get(gridRows.size()-1).listIterator();
				List<ExtendedGridLayoutConstraints> gridRow = new ArrayList<ExtendedGridLayoutConstraints>();
				gridRows.add(gridRow);
				ListIterator<ExtendedGridLayoutConstraints> newGridRowIterator = gridRow.listIterator();
				while (gridRowIterator.hasNext())
				{
					ExtendedGridLayoutConstraints cell = gridRowIterator.next();
					if ((null != cell) &&
					    (null != cell.getRowspanPlaceholder(false)))
					{
						rowspans.add(cell);
						ExtendedGridLayoutConstraints rowspanPlaceholder = cell.getRowspanPlaceholder(true);
						newGridRowIterator.add(rowspanPlaceholder);
					}
					else
					{
						newGridRowIterator.add(null);
					}
				}
				gridRowIterator = gridRow.listIterator();
				while (gridRowIterator.hasNext())
				{
					ExtendedGridLayoutConstraints cell = gridRowIterator.next();
					if ((null != cell) &&
					    ((REMAINDER != cell.getRowspan()) &&
					     (null != cell.getRowspanPlaceholder(false))))
					{
						haveNext = true;
						break;
					}
				}
			}
		}
		
		return new Dimension(col+1,gridRows.size());
	}
	
	
	public String toString()
	{
		return getClass().getName() + ""[hgap="" + hgap + "",vgap="" + vgap
			+ "",distanceToBorders="" + distanceToBorders
			+ "",comptable="" + comptable + ""]"";
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHTypedVariableDeclaration,6,2,0,14,16,15,3,11,2,1.0,113,0.0,1,0.772727273,0.466666667,0,0,17.66666667,2,1.0,0,"

package org.gjt.sp.jedit.bsh;

class BSHTypedVariableDeclaration extends SimpleNode
{
	public Modifiers modifiers;
	
    BSHTypedVariableDeclaration(int id) { super(id); }

	private BSHType getTypeNode() {
		return ((BSHType)jjtGetChild(0));
	}

	Class evalType( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		BSHType typeNode = getTypeNode();
		return typeNode.getType( callstack, interpreter );
	}

	BSHVariableDeclarator [] getDeclarators() 
	{
		int n = jjtGetNumChildren();
		int start=1;
		BSHVariableDeclarator [] bvda = new BSHVariableDeclarator[ n-start ];
		for (int i = start; i < n; i++)
		{
			bvda[i-start] = (BSHVariableDeclarator)jjtGetChild(i);
		}
		return bvda;
	}

	
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		try {
			NameSpace namespace = callstack.top();
			BSHType typeNode = getTypeNode();
			Class type = typeNode.getType( callstack, interpreter );

			BSHVariableDeclarator [] bvda = getDeclarators();
			for (int i = 0; i < bvda.length; i++)
			{
				BSHVariableDeclarator dec = bvda[i];

				
				
				Object value = dec.eval( typeNode, callstack, interpreter);

				try {
					namespace.setTypedVariable( 
						dec.name, type, value, modifiers );
				} catch ( UtilEvalError e ) { 
					throw e.toEvalError( this, callstack ); 
				}
			}
		} catch ( EvalError e ) {
			e.reThrow( ""Typed variable declaration"" );
		}

        return Primitive.VOID;
    }

	public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
	{ 
		return getTypeNode().getTypeDescriptor( 
			callstack, interpreter, defaultPackage );
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.AntiAlias,9,1,0,4,13,0,4,0,8,0.725,104,0.2,0,0.0,0.35,0,0,10.0,3,0.7778,0,"
package org.gjt.sp.jedit.textarea;


public class AntiAlias extends Object
{
	public static final Object NONE = ""none"";

	public static final Object STANDARD = ""standard"";

	public static final Object SUBPIXEL = ""subpixel"";

	public static final Object comboChoices[] = new Object[] { NONE, STANDARD, SUBPIXEL };

	public void set(int newValue)
	{
		m_val = newValue;
	}

	public AntiAlias(boolean isEnabled)
	{
		m_val = isEnabled ? 1 : 0;
	}

	public AntiAlias(int val)
	{
		m_val = val;
	}

	public AntiAlias(String v)
	{
		fromString(v);
	}

	public boolean equals(Object other)
	{
		return toString().equals(other.toString());

	}

	public void fromString(String v)
	{
		for (int i = 0; i < comboChoices.length; ++i)
		{
			if (comboChoices[i].equals(v))
			{
				m_val = i;
			}
		}
	}

	public String toString()
	{
		return comboChoices[m_val].toString();
	}

	public int val()
	{
		return m_val;
	}

	private int m_val = 0;
}
"
jEdit,4.3,org.gjt.sp.jedit.search.SearchFileSet,5,1,0,11,5,10,11,1,5,2.0,5,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.*;


public interface SearchFileSet
{
	
	String getFirstFile(View view);

	
	String getNextFile(View view, String path);

	
	String[] getFiles(View view);

	
	int getFileCount(View view);

	
	String getCode();
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchFileNode,8,1,0,12,16,12,6,6,7,0.75,88,0.5,0,0.0,0.285714286,0,0,9.5,2,1.125,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;


public class HyperSearchFileNode implements HyperSearchNode
{
	public String path;
	public boolean showFullPath = true;

	private static String fileSep = System.getProperty(""file.separator"");
	static
	{
		if (fileSep.equals(""\\""))
			fileSep = ""\\\\"";
	}

	
	public HyperSearchFileNode(String path)
	{
		this.path = path;
	} 

	
	public Buffer getBuffer(View view)
	{
		return jEdit.openFile(view,path);
	} 

	
	public void goTo(EditPane editPane)
	{
		Buffer buffer = getBuffer(editPane.getView());
		if(buffer == null)
			return;

		editPane.setBuffer(buffer);
	} 
	
	
	public String toString()
	{
		if (showFullPath)
			return path;
		String[] paths = path.split(fileSep);
		return paths[paths.length - 1];
	} 
	
	
	public boolean equals(Object compareObj)
	{
		if (!(compareObj instanceof HyperSearchFileNode))
			return false;
		HyperSearchFileNode otherResult = (HyperSearchFileNode)compareObj;
		
		return path.equals(MiscUtilities.resolveSymlinks(otherResult.path));
	}

	
	public int getCount()
	{
		return count;
	}

	
	public void setCount(int count)
	{
		this.count = count;
	}

	private int count;
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaException,1,3,0,2,2,0,2,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
package org.gjt.sp.jedit.textarea;


public class TextAreaException extends Exception
{
	public TextAreaException(String msg)
	{
		super(msg);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.PluginJAR,39,1,0,49,181,469,34,29,26,0.805555556,2302,1.0,4,0.0,0.150641026,0,0,57.56410256,17,3.1795,0,"

package org.gjt.sp.jedit;


import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.Enumeration;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.buffer.DummyFoldHandler;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.gui.DockableWindowFactory;
import org.gjt.sp.jedit.msg.PluginUpdate;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.IOUtilities;



public class PluginJAR
{
	
	private final String path;
	private String cachePath;
	private final File file;

	private final JARClassLoader classLoader;
	private ZipFile zipFile;
	private Properties properties;
	
	private String[] classes;
	
	private String[] resources;
	private ActionSet actions;
	private ActionSet browserActions;
	private EditPlugin plugin;
	private URL dockablesURI;
	private URL servicesURI;
	private boolean activated;

	
	private final Set<String> theseRequireMe = new LinkedHashSet<String>();
	
	private final Set<String> theseUseMe = new LinkedHashSet<String>();
	private final Set<String> weRequireThese = new LinkedHashSet<String>();
	private final Set<String> weUseThese = new LinkedHashSet<String>();
	

	
	
	public static PluginJAR load(String path, boolean loadDependents)
	{
		PluginJAR jar = jEdit.getPluginJAR(path);
		if (jar != null && jar.getPlugin() != null)
		{
			return jar;
		}
		jEdit.addPluginJAR(path);
		jar = jEdit.getPluginJAR(path);
		EditPlugin plugin = jar.getPlugin();
		if (plugin == null)
		{
			
			return jar;
		}
		String className = plugin.getClassName();
		if (loadDependents)
		{
			Set<String> pluginLoadList = getDependencySet(className);
			for (String jarName: pluginLoadList)
			{
				String jarPath = findPlugin(jarName);
				load(jarPath, true);
			}
		}
		
		String jars = jEdit.getProperty(""plugin."" + className + "".jars"");
		if(jars != null)
		{
			String dir = MiscUtilities.getParentOfPath(path);
			StringTokenizer st = new StringTokenizer(jars);
			while(st.hasMoreTokens())
			{
				String _jarPath = MiscUtilities.constructPath(dir,st.nextToken());
				PluginJAR _jar = jEdit.getPluginJAR(_jarPath);
				if(_jar == null)
				{
					jEdit.addPluginJAR(_jarPath);
				}
			}
		}
		jar.checkDependencies();
		jar.activatePluginIfNecessary();
		return jar;
	} 

	
	
	public String getPath()
	{
		return path;
	} 

	
	
	public static String findPlugin(String className)
	{
		EditPlugin ep = jEdit.getPlugin(className);
		if (ep != null) return ep.getPluginJAR().getPath();

		for (String JARpath: jEdit.getNotLoadedPluginJARs())
		{
			PluginJAR pjar = new PluginJAR(new File(JARpath));
			if (pjar.containsClass(className))
			{
				return JARpath;
			}
		}
		return null;
	} 

	
	
	boolean containsClass(String className)
	{
		try
		{
			getZipFile();
		}
		catch (IOException ioe)
		{
			throw new RuntimeException(ioe);
		}
		Enumeration<? extends ZipEntry> itr = zipFile.entries();
		while (itr.hasMoreElements())
		{
			String entry = itr.nextElement().toString();
			if (entry.endsWith("".class""))
			{
				String name = entry.substring(0, entry.length() - 6).replace('/', '.');
				if (name.equals(className))
					return true;
			}
		}
		return false;

	} 

	
	
	public String getCachePath()
	{
		return cachePath;
	} 

	
	
	public static Set<String> getDependencySet(String className)
	{
		String dep;
		Set<String> retval = new LinkedHashSet<String>();
		int i=0;
		while((dep = jEdit.getProperty(""plugin."" + className + "".depend."" + i++)) != null)
		{
			PluginDepends pluginDepends;
			try
			{
				pluginDepends = getPluginDepends(dep);
			}
			catch (IllegalArgumentException e)
			{
				Log.log(Log.ERROR, PluginJAR.class,
					className + "" has an invalid dependency: "" + dep);
				continue;
			}

			if(pluginDepends.what.equals(""plugin""))
			{
				int index2 = pluginDepends.arg.indexOf(' ');
				if ( index2 == -1)
				{
					Log.log(Log.ERROR, PluginJAR.class, className
						+ "" has an invalid dependency: ""
						+ dep + "" (version is missing)"");
					continue;
				}

				String pluginName = pluginDepends.arg.substring(0,index2);
				String needVersion = pluginDepends.arg.substring(index2 + 1);
				
				Set<String> loadTheseFirst = getDependencySet(pluginName);
				loadTheseFirst.add(pluginName);
				loadTheseFirst.addAll(retval);
				retval = loadTheseFirst;
			}
		}
		return retval;
	} 

	
	
	public File getFile()
	{
		return file;
	} 

	
	
	public JARClassLoader getClassLoader()
	{
		return classLoader;
	} 

	
	
	public synchronized ZipFile getZipFile() throws IOException
	{
		if(zipFile == null)
		{
			Log.log(Log.DEBUG,this,""Opening "" + path);
			zipFile = new ZipFile(path);
		}
		return zipFile;
	} 

	
	
	public ActionSet getActions()
	{
		return getActionSet();
	} 

	
	
	public ActionSet getActionSet()
	{
		return actions;
	} 

	
	
	public ActionSet getBrowserActionSet()
	{
		return browserActions;
	} 

	
	
	public boolean checkDependencies()
	{
		if(plugin == null)
			return true;
		int i = 0;
		boolean ok = true;

		String name = plugin.getClassName();

		String dep;
		while((dep = jEdit.getProperty(""plugin."" + name + "".depend."" + i++)) != null)
		{
			PluginDepends pluginDepends;
			try
			{
				pluginDepends = getPluginDepends(dep);
			}
			catch (IllegalArgumentException e)
			{
				Log.log(Log.ERROR,this,name + "" has an invalid""
					+ "" dependency: "" + dep);
				ok = false;
				continue;
			}

			if(pluginDepends.what.equals(""jdk""))
			{
				if(!pluginDepends.optional && StandardUtilities.compareStrings(
					System.getProperty(""java.version""),
					pluginDepends.arg,false) < 0)
				{
					String[] args = { pluginDepends.arg,
						System.getProperty(""java.version"") };
					jEdit.pluginError(path,""plugin-error.dep-jdk"",args);
					ok = false;
				}
			}
			else if(pluginDepends.what.equals(""jedit""))
			{
				if(pluginDepends.arg.length() != 11)
				{
					Log.log(Log.ERROR,this,""Invalid jEdit version""
						+ "" number: "" + pluginDepends.arg);
					ok = false;
				}

				if(!pluginDepends.optional && StandardUtilities.compareStrings(
					jEdit.getBuild(),pluginDepends.arg,false) < 0)
				{
					String needs = MiscUtilities.buildToVersion(pluginDepends.arg);
					String[] args = { needs,
						jEdit.getVersion() };
					jEdit.pluginError(path,
						""plugin-error.dep-jedit"",args);
					ok = false;
				}
			}
			else if(pluginDepends.what.equals(""plugin""))
			{
				int index2 = pluginDepends.arg.indexOf(' ');
				if(index2 == -1)
				{
					Log.log(Log.ERROR,this,name
						+ "" has an invalid dependency: ""
						+ dep + "" (version is missing)"");
					ok = false;
					continue;
				}

				String pluginName = pluginDepends.arg.substring(0,index2);
				String needVersion = pluginDepends.arg.substring(index2 + 1);
				String currVersion = jEdit.getProperty(""plugin.""
					+ pluginName + "".version"");

				EditPlugin editPlugin = jEdit.getPlugin(pluginName, false);
				if(editPlugin == null)
				{
					if(!pluginDepends.optional)
					{
						String[] args = { needVersion,
							pluginName };
						jEdit.pluginError(path,
							""plugin-error.dep-plugin.no-version"",
							args);
						ok = false;
					}
				}
				else if(StandardUtilities.compareStrings(
					currVersion,needVersion,false) < 0)
				{
					if(!pluginDepends.optional)
					{
						String[] args = { needVersion,
							pluginName, currVersion };
						jEdit.pluginError(path, ""plugin-error.dep-plugin"",args);
						ok = false;
					}
				}
				else if(editPlugin instanceof EditPlugin.Broken)
				{
					if(!pluginDepends.optional)
					{
						String[] args = { pluginName };
						jEdit.pluginError(path, ""plugin-error.dep-plugin.broken"",args);
						ok = false;
					}
				}
				else
				{
					PluginJAR jar = editPlugin.getPluginJAR();
					if (pluginDepends.optional)
					{
						jar.theseUseMe.add(path);
						weUseThese.add(jar.getPath());
					}
					else
					{
						jar.theseRequireMe.add(path);
						weRequireThese.add(jar.getPath());
					}
				}
			}
			else if(pluginDepends.what.equals(""class""))
			{
				if(!pluginDepends.optional)
				{
					try
					{
						classLoader.loadClass(pluginDepends.arg,false);
					}
					catch(Exception e)
					{
						String[] args = { pluginDepends.arg };
						jEdit.pluginError(path, ""plugin-error.dep-class"",args);
						ok = false;
					}
				}
			}
			else
			{
				Log.log(Log.ERROR,this,name + "" has unknown""
					+ "" dependency: "" + dep);
				ok = false;
			}
		}

		
		
		String jars = jEdit.getProperty(""plugin.""
			+ plugin.getClassName() + "".jars"");
		if(jars != null)
		{
			String dir = MiscUtilities.getParentOfPath(path);

			StringTokenizer st = new StringTokenizer(jars);
			while(st.hasMoreTokens())
			{
				String jarPath = MiscUtilities.constructPath(
					dir,st.nextToken());
				PluginJAR jar = jEdit.getPluginJAR(jarPath);
				if(jar == null)
				{
					String[] args = { jarPath };
					jEdit.pluginError(path, ""plugin-error.missing-jar"",args);
					ok = false;
				}
				else
				{
					weRequireThese.add(jarPath);
					jar.theseRequireMe.add(path);
				}
			}
		}

		if(!ok)
			breakPlugin();

		return ok;
	} 

	
	
	public Set<String> getRequiredJars()
	{
		return weRequireThese;
	} 

	
	private static PluginDepends getPluginDepends(String dep) throws IllegalArgumentException
	{
		boolean optional;
		if(dep.startsWith(""optional ""))
		{
			optional = true;
			dep = dep.substring(""optional "".length());
		}
		else
		{
			optional = false;
		}

		int index = dep.indexOf(' ');
		if(index == -1)
			throw new IllegalArgumentException(""wrong dependency"");

		String what = dep.substring(0,index);
		String arg = dep.substring(index + 1);
		PluginDepends depends = new PluginDepends();
		depends.what = what;
		depends.arg = arg;
		depends.optional = optional;
		return depends;
	} 

	
	private static class PluginDepends
	{
		String what;
		String arg;
		boolean optional;
	} 

	
	
	public static void transitiveClosure(String[] dependents, List<String> listModel)
	{
  		for(int i = 0; i < dependents.length; i++)
  		{
  			String jarPath = dependents[i];
  			if(!listModel.contains(jarPath))
  			{
  				listModel.add(jarPath);
  				PluginJAR jar = jEdit.getPluginJAR(
  					jarPath);
  				transitiveClosure(jar.getDependentPlugins(),
  					listModel);
  			}
  		}
  	} 

	
	  public String[] getDependentPlugins()
	  {
		  return theseRequireMe.toArray(new String[theseRequireMe.size()]);
	  } 

	
	
	public EditPlugin getPlugin()
	{
		return plugin;
	} 

	
	
	public void activatePlugin()
	{
		synchronized (this)
		{
			if (activated)
			{
				
				return;
			}

			activated = true;
		}

		if (!(plugin instanceof EditPlugin.Deferred))
		{
			return;
		}

		String className = plugin.getClassName();

		try
		{
			Class clazz = classLoader.loadClass(className,false);
			int modifiers = clazz.getModifiers();
			if(Modifier.isInterface(modifiers)
				|| Modifier.isAbstract(modifiers)
				|| !EditPlugin.class.isAssignableFrom(clazz))
			{
				Log.log(Log.ERROR,this,""Plugin has properties but does not extend EditPlugin: ""
					+ className);
				breakPlugin();
				return;
			}

			plugin = (EditPlugin)clazz.newInstance();
			plugin.jar = this;
		}
		catch (Throwable t)
		{
			breakPlugin();

			Log.log(Log.ERROR,this,""Error while starting plugin "" + className);
			Log.log(Log.ERROR,this,t);
			String[] args = { t.toString() };
			jEdit.pluginError(path,""plugin-error.start-error"",args);

			return;
		}

		if (jEdit.isMainThread()
			|| SwingUtilities.isEventDispatchThread())
		{
			startPlugin();
		}
		else
		{
			
			startPluginLater();
		}

		EditBus.send(new PluginUpdate(this,PluginUpdate.ACTIVATED,false));
	} 

	
	
	public void activatePluginIfNecessary()
	{
		String filename = MiscUtilities.getFileName(getPath());
		jEdit.setBooleanProperty(""plugin-blacklist."" + filename, false);
		if(!(plugin instanceof EditPlugin.Deferred && plugin != null))
		{
			return;
		}

		String className = plugin.getClassName();

		
		
		String activate = jEdit.getProperty(""plugin.""
			+ className + "".activate"");

		if(activate == null)
		{
			
			if(!jEdit.isMainThread())
			{
				breakPlugin();

				jEdit.pluginError(path,""plugin-error.not-42"",null);
			}
			else
			{
				activatePlugin();
			}
		}
		else
		{
			

			
			
			boolean load = false;

			StringTokenizer st = new StringTokenizer(activate);
			while(st.hasMoreTokens())
			{
				String prop = st.nextToken();
				boolean value = jEdit.getBooleanProperty(prop);
				if(value)
				{
					Log.log(Log.DEBUG,this,""Activating ""
						+ className + "" because of "" + prop);
					load = true;
					break;
				}
			}

			if(load)
			{
				activatePlugin();
			}
		}
	} 

	
	
	public void deactivatePlugin(boolean exit)
	{
		if(!activated)
			return;

		if(!exit)
		{
			
			
			
			Buffer buffer = jEdit.getFirstBuffer();
			while(buffer != null)
			{
				if(buffer.getFoldHandler() != null
					&& buffer.getFoldHandler().getClass()
					.getClassLoader() == classLoader)
				{
					buffer.setFoldHandler(
						new DummyFoldHandler());
				}
				buffer = buffer.getNext();
			}
		}

		if(plugin != null && !(plugin instanceof EditPlugin.Broken))
		{
			if(plugin instanceof EBPlugin)
				EditBus.removeFromBus((EBComponent)plugin);

			try
			{
				plugin.stop();
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error while ""
					+ ""stopping plugin:"");
				Log.log(Log.ERROR,this,t);
			}

			plugin = new EditPlugin.Deferred(this,
				plugin.getClassName());

			EditBus.send(new PluginUpdate(this,
				PluginUpdate.DEACTIVATED,exit));

			if(!exit)
			{
				
				String activate = jEdit.getProperty(""plugin.""
					+ plugin.getClassName() + "".activate"");

				if(activate == null)
				{
					breakPlugin();
					jEdit.pluginError(path,""plugin-error.not-42"",null);
				}
			}
		}

		activated = false;
	} 

	
	
	public URL getDockablesURI()
	{
		return dockablesURI;
	} 

	
	
	public URL getServicesURI()
	{
		return servicesURI;
	} 

	
	@Override
	public String toString()
	{
		if(plugin == null)
			return path;
		else
			return path + "",class="" + plugin.getClassName();
	} 

	

	

	
	public static PluginCacheEntry getPluginCache(PluginJAR plugin)
	{
		String jarCachePath = plugin.getCachePath();
		if(jarCachePath == null)
			return null;

		DataInputStream din = null;
		try
		{
			PluginCacheEntry cache = new PluginCacheEntry();
			cache.plugin = plugin;
			cache.modTime = plugin.getFile().lastModified();
			din = new DataInputStream(
				new BufferedInputStream(
				new FileInputStream(jarCachePath)));
			if(cache.read(din))
				return cache;
			else
			{
				
				return null;
			}
		}
		catch(FileNotFoundException fnf)
		{
			return null;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,PluginJAR.class,io);
			return null;
		}
		finally
		{
			IOUtilities.closeQuietly(din);
		}
	} 

	
	static void setPluginCache(PluginJAR plugin, PluginCacheEntry cache)
	{
		String jarCachePath = plugin.getCachePath();
		if(jarCachePath == null)
			return;

		Log.log(Log.DEBUG,PluginJAR.class,""Writing "" + jarCachePath);

		DataOutputStream dout = null;
		try
		{
			dout = new DataOutputStream(
				new BufferedOutputStream(
				new FileOutputStream(jarCachePath)));
			cache.write(dout);
			dout.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,PluginJAR.class,io);
			IOUtilities.closeQuietly(dout);
			new File(jarCachePath).delete();
		}
	} 

	

	
	
	public PluginJAR(File file)
	{
		path = file.getPath();
		String jarCacheDir = jEdit.getJARCacheDirectory();
		if(jarCacheDir != null)
		{
			cachePath = MiscUtilities.constructPath(
				jarCacheDir,file.getName() + "".summary"");
		}
		this.file = file;
		classLoader = new JARClassLoader(this);
		actions = new ActionSet();
	} 

	
	void init()
	{
		PluginCacheEntry cache = getPluginCache(this);
		if(cache != null)
		{
			loadCache(cache);
			classLoader.activate();
		}
		else
		{
			try
			{
				cache = generateCache();
				if(cache != null)
				{
					setPluginCache(this,cache);
					classLoader.activate();
				}
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,""Cannot load""
					+ "" plugin "" + path);
				Log.log(Log.ERROR,this,io);

				String[] args = { io.toString() };
				jEdit.pluginError(path,""plugin-error.load-error"",args);

				uninit(false);
			}
		}
	} 

	
	void uninit(boolean exit)
	{
		deactivatePlugin(exit);

		if(!exit)
		{
			for (String path : weRequireThese)
			{
				PluginJAR jar = jEdit.getPluginJAR(path);
				if(jar != null)
					jar.theseRequireMe.remove(this.path);
			}

			for (String path : weUseThese)
			{
				PluginJAR jar = jEdit.getPluginJAR(path);
				if(jar != null)
					jar.theseUseMe.remove(this.path);
			}

			classLoader.deactivate();
			BeanShell.resetClassManager();

			if(actions != null)
				jEdit.removeActionSet(actions);
			if(browserActions != null)
				VFSBrowser.getActionContext().removeActionSet(browserActions);

			DockableWindowFactory.getInstance()
				.unloadDockableWindows(this);
			ServiceManager.unloadServices(this);

			jEdit.removePluginProps(properties);

			try
			{
				if(zipFile != null)
				{
					zipFile.close();
					zipFile = null;
				}
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
			}
		}
	} 

	
	String[] getClasses()
	{
		return classes;
	} 

	
	public String[] getResources()
	{
		return resources;
	} 

	

	

	
	private void actionsPresentButNotCoreClass()
	{
		Log.log(Log.WARNING,this,getPath() + "" has an actions.xml but no plugin core class"");
		actions.setLabel(""MISSING PLUGIN CORE CLASS"");
	} 

	
	private void loadCache(PluginCacheEntry cache)
	{
		classes = cache.classes;
		resources = cache.resources;

		
		if(cache.cachedProperties != null)
		{
			properties = cache.cachedProperties;
			jEdit.addPluginProps(cache.cachedProperties);
		}

		if(cache.actionsURI != null
			&& cache.cachedActionNames != null)
		{
			actions = new ActionSet(this,
				cache.cachedActionNames,
				cache.cachedActionToggleFlags,
				cache.actionsURI);
		}

		if(cache.browserActionsURI != null
			&& cache.cachedBrowserActionNames != null)
		{
			browserActions = new ActionSet(this,
				cache.cachedBrowserActionNames,
				cache.cachedBrowserActionToggleFlags,
				cache.browserActionsURI);
			VFSBrowser.getActionContext().addActionSet(browserActions);
		}

		if(cache.dockablesURI != null
			&& cache.cachedDockableNames != null
			&& cache.cachedDockableActionFlags != null
			&& cache.cachedDockableMovableFlags != null)
		{
			dockablesURI = cache.dockablesURI;
			DockableWindowFactory.getInstance()
				.cacheDockableWindows(this,
				cache.cachedDockableNames,
				cache.cachedDockableActionFlags,
				cache.cachedDockableMovableFlags);
		}

		if(actions.size() != 0)
			jEdit.addActionSet(actions);

		if(cache.servicesURI != null
			&& cache.cachedServices != null)
		{
			servicesURI = cache.servicesURI;
			for(int i = 0; i < cache.cachedServices.length;
				i++)
			{
				ServiceManager.Descriptor d
					= cache.cachedServices[i];
				ServiceManager.registerService(d);
			}
		}

		if(cache.pluginClass != null)
		{
			
			
			if(jEdit.getPlugin(cache.pluginClass) != null)
			{
				jEdit.pluginError(path, ""plugin-error.already-loaded"",
					null);
				uninit(false);
			}
			else
			{
				String label = jEdit.getProperty(
					""plugin."" + cache.pluginClass
					+ "".name"");
				actions.setLabel(jEdit.getProperty(
					""action-set.plugin"",
					new String[] { label }));
				plugin = new EditPlugin.Deferred(this,
					cache.pluginClass);
			}
		}
		else
		{
			if(actions.size() != 0)
				actionsPresentButNotCoreClass();
		}
	} 

	
	public PluginCacheEntry generateCache() throws IOException
	{
		properties = new Properties();

		List<String> classes = new LinkedList<String>();
		List<String> resources = new LinkedList<String>();

		ZipFile zipFile = getZipFile();

		List<String> plugins = new LinkedList<String>();

		PluginCacheEntry cache = new PluginCacheEntry();
		cache.modTime = file.lastModified();
		cache.cachedProperties = new Properties();

		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		while(entries.hasMoreElements())
		{
			ZipEntry entry = entries.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.equals(""actions.xml""))
			{
				cache.actionsURI = classLoader.getResource(name);
			}
			else if(lname.equals(""browser.actions.xml""))
			{
				cache.browserActionsURI = classLoader.getResource(name);
			}
			else if(lname.equals(""dockables.xml""))
			{
				dockablesURI = classLoader.getResource(name);
				cache.dockablesURI = dockablesURI;
			}
			else if(lname.equals(""services.xml""))
			{
				servicesURI = classLoader.getResource(name);
				cache.servicesURI = servicesURI;
			}
			else if(lname.endsWith("".props""))
			{
				InputStream in = classLoader.getResourceAsStream(name);
				properties.load(in);
				in.close();
			}
			else if(name.endsWith("".class""))
			{
				String className = MiscUtilities
					.fileToClass(name);
				if(className.endsWith(""Plugin""))
				{
					plugins.add(className);
				}
				classes.add(className);
			}
			else
			{
				resources.add(name);
			}
		}

		cache.cachedProperties = properties;
		jEdit.addPluginProps(properties);

		this.classes = cache.classes =
			classes.toArray(
			new String[classes.size()]);
		this.resources = cache.resources =
			resources.toArray(
			new String[resources.size()]);

		String label = null;

		for (String className : plugins)
		{
			String _label = jEdit.getProperty(""plugin.""
				+ className + "".name"");
			String version = jEdit.getProperty(""plugin.""
				+ className + "".version"");
			if(_label == null || version == null)
			{
				Log.log(Log.WARNING,this,""Ignoring: ""
					+ className);
			}
			else
			{
				cache.pluginClass = className;

				
				
				if(jEdit.getPlugin(className) != null)
				{
					jEdit.pluginError(path, ""plugin-error.already-loaded"",
						null);
					return null;
				}
				plugin = new EditPlugin.Deferred(this,
				     className);
				label = _label;

				break;
			}
		}

		if(cache.actionsURI != null)
		{
			actions = new ActionSet(this,null,null,
				cache.actionsURI);
			actions.load();
			cache.cachedActionNames =
				actions.getCacheableActionNames();
			cache.cachedActionToggleFlags =
				new boolean[cache.cachedActionNames.length];
			for(int i = 0; i < cache.cachedActionNames.length; i++)
			{
				 cache.cachedActionToggleFlags[i] =
					 jEdit.getBooleanProperty(
						 cache.cachedActionNames[i] + "".toggle"");
			}
		}

		if(cache.browserActionsURI != null)
		{
			browserActions =
				new ActionSet(this,null,null, cache.browserActionsURI);
			browserActions.load();
			VFSBrowser.getActionContext().addActionSet(browserActions);
			cache.cachedBrowserActionNames =
				browserActions.getCacheableActionNames();
			cache.cachedBrowserActionToggleFlags = new boolean[
				cache.cachedBrowserActionNames.length];
			for(int i = 0;
				i < cache.cachedBrowserActionNames.length; i++)
			{
				 cache.cachedBrowserActionToggleFlags[i]
				 	= jEdit.getBooleanProperty(
				 		cache.cachedBrowserActionNames[i] + "".toggle"");
			}
		}

		if(dockablesURI != null)
		{
			DockableWindowFactory.getInstance()
				.loadDockableWindows(this, dockablesURI,cache);
		}

		if(actions.size() != 0)
		{
			if(label != null)
			{
				actions.setLabel(jEdit.getProperty(
					""action-set.plugin"", new String[] { label }));
			}
			else
				actionsPresentButNotCoreClass();

			jEdit.addActionSet(actions);
		}

		if(servicesURI != null)
		{
			ServiceManager.loadServices(this,servicesURI,cache);
		}

		return cache;
	} 

	
	private void startPlugin()
	{
		try
		{
			plugin.start();
		}
		catch(Throwable t)
		{
			breakPlugin();

			Log.log(Log.ERROR,PluginJAR.this,
				""Error while starting plugin "" + plugin.getClassName());
			Log.log(Log.ERROR,PluginJAR.this,t);
			String[] args = { t.toString() };
			jEdit.pluginError(path, ""plugin-error.start-error"",args);
		}

		if(plugin instanceof EBPlugin)
		{
			if(jEdit.getProperty(""plugin."" + plugin.getClassName()
				+ "".activate"") == null)
			{
				
				
				
				((EBComponent)plugin).handleMessage(
					new org.gjt.sp.jedit.msg.PropertiesChanged(null));
			}
			EditBus.addToBus((EBComponent)plugin);
		}

		
		
		
		Buffer buffer = jEdit.getFirstBuffer();
		while(buffer != null)
		{
			FoldHandler handler =
				FoldHandler.getFoldHandler(
				buffer.getStringProperty(""folding""));
			
			if(buffer.getFoldHandler() != null
				&& handler != null
				&& handler != buffer.getFoldHandler())
			{
				buffer.setFoldHandler(handler);
			}
			buffer = buffer.getNext();
		}
	} 

	
	private void startPluginLater()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(!activated)
					return;

				startPlugin();
			}
		});
	} 

	
	private void breakPlugin()
	{
		plugin = new EditPlugin.Broken(this,plugin.getClassName());

		
		
		uninit(false);
		
		jEdit.addPluginProps(properties);
	} 

	

	
	
	public static class PluginCacheEntry
	{
		public static final int MAGIC = 0xB7A2E422;

		
		public PluginJAR plugin;
		public long modTime;

		public String[] classes;
		public String[] resources;
		public URL actionsURI;
		public String[] cachedActionNames;
		public boolean[] cachedActionToggleFlags;
		public URL browserActionsURI;
		public String[] cachedBrowserActionNames;
		public boolean[] cachedBrowserActionToggleFlags;
		public URL dockablesURI;
		public String[] cachedDockableNames;
		public boolean[] cachedDockableActionFlags;
		public boolean[] cachedDockableMovableFlags;
		public URL servicesURI;
		ServiceManager.Descriptor[] cachedServices;

		public Properties cachedProperties;
		public String pluginClass;
		

		

		
		public boolean read(DataInputStream din) throws IOException
		{
			int cacheMagic = din.readInt();
			if(cacheMagic != MAGIC)
				return false;

			String cacheBuild = readString(din);
			if(!cacheBuild.equals(jEdit.getBuild()))
				return false;

			long cacheModTime = din.readLong();
			if(cacheModTime != modTime)
				return false;

			actionsURI = readURI(din);
			cachedActionNames = readStringArray(din);
			cachedActionToggleFlags = readBooleanArray(din);

			browserActionsURI = readURI(din);
			cachedBrowserActionNames = readStringArray(din);
			cachedBrowserActionToggleFlags = readBooleanArray(din);

			dockablesURI = readURI(din);
			cachedDockableNames = readStringArray(din);
			cachedDockableActionFlags = readBooleanArray(din);
			cachedDockableMovableFlags = readBooleanArray(din);

			servicesURI = readURI(din);
			int len = din.readInt();
			if(len == 0)
				cachedServices = null;
			else
			{
				cachedServices = new ServiceManager.Descriptor[len];
				for(int i = 0; i < len; i++)
				{
					ServiceManager.Descriptor d = new
						ServiceManager.Descriptor(
						readString(din),
						readString(din),
						null,
						plugin);
					cachedServices[i] = d;
				}
			}

			classes = readStringArray(din);
			resources = readStringArray(din);

			cachedProperties = readMap(din);

			pluginClass = readString(din);

			return true;
		} 

		
		public void write(DataOutputStream dout) throws IOException
		{
			dout.writeInt(MAGIC);
			writeString(dout,jEdit.getBuild());

			dout.writeLong(modTime);

			writeString(dout,actionsURI);
			writeStringArray(dout,cachedActionNames);
			writeBooleanArray(dout,cachedActionToggleFlags);

			writeString(dout,browserActionsURI);
			writeStringArray(dout,cachedBrowserActionNames);
			writeBooleanArray(dout,cachedBrowserActionToggleFlags);

			writeString(dout,dockablesURI);
			writeStringArray(dout,cachedDockableNames);
			writeBooleanArray(dout,cachedDockableActionFlags);
			writeBooleanArray(dout,cachedDockableMovableFlags);

			writeString(dout,servicesURI);
			if(cachedServices == null)
				dout.writeInt(0);
			else
			{
				dout.writeInt(cachedServices.length);
				for(int i = 0; i < cachedServices.length; i++)
				{
					writeString(dout,cachedServices[i].clazz);
					writeString(dout,cachedServices[i].name);
				}
			}

			writeStringArray(dout,classes);
			writeStringArray(dout,resources);

			writeMap(dout,cachedProperties);

			writeString(dout,pluginClass);
		} 

		

		
		private static String readString(DataInputStream din)
			throws IOException
		{
			int len = din.readInt();
			if(len == 0)
				return null;
			char[] str = new char[len];
			for(int i = 0; i < len; i++)
				str[i] = din.readChar();
			return new String(str);
		} 

		
		private static URL readURI(DataInputStream din)
			throws IOException
		{
			String str = readString(din);
			if(str == null)
				return null;
			else
				return new URL(str);
		} 

		
		private static String[] readStringArray(DataInputStream din)
			throws IOException
		{
			int len = din.readInt();
			if(len == 0)
				return null;
			String[] str = new String[len];
			for(int i = 0; i < len; i++)
			{
				str[i] = readString(din);
			}
			return str;
		} 

		
		private static boolean[] readBooleanArray(DataInputStream din)
			throws IOException
		{
			int len = din.readInt();
			if(len == 0)
				return null;
			boolean[] bools = new boolean[len];
			for(int i = 0; i < len; i++)
			{
				bools[i] = din.readBoolean();
			}
			return bools;
		} 

		
		private static Properties readMap(DataInputStream din)
			throws IOException
		{
			Properties returnValue = new Properties();
			int count = din.readInt();
			for(int i = 0; i < count; i++)
			{
				String key = readString(din);
				String value = readString(din);
				if(value == null)
					value = """";
				returnValue.put(key,value);
			}
			return returnValue;
		} 

		
		private static void writeString(DataOutputStream dout,
			Object obj) throws IOException
		{
			if(obj == null)
			{
				dout.writeInt(0);
			}
			else
			{
				String str = obj.toString();
				dout.writeInt(str.length());
				dout.writeChars(str);
			}
		} 

		
		private static void writeStringArray(DataOutputStream dout,
			String[] str) throws IOException
		{
			if(str == null)
			{
				dout.writeInt(0);
			}
			else
			{
				dout.writeInt(str.length);
				for(int i = 0; i < str.length; i++)
				{
					writeString(dout,str[i]);
				}
			}
		} 

		
		private static void writeBooleanArray(DataOutputStream dout,
			boolean[] bools) throws IOException
		{
			if(bools == null)
			{
				dout.writeInt(0);
			}
			else
			{
				dout.writeInt(bools.length);
				for(int i = 0; i < bools.length; i++)
				{
					dout.writeBoolean(bools[i]);
				}
			}
		} 

		
		private static void writeMap(DataOutputStream dout, Map map)
			throws IOException
		{
			dout.writeInt(map.size());
			Set<Map.Entry<Object, Object>> set = map.entrySet();
			for (Map.Entry<Object, Object> entry : set)
			{
				writeString(dout,entry.getKey());
				writeString(dout,entry.getValue());
			}
		} 

		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.RecentFilesProvider,3,1,0,13,38,3,4,13,3,2.0,191,0.0,0,0.0,0.666666667,0,0,62.66666667,9,3.3333,0,"

package org.gjt.sp.jedit.menu;



import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.FileCellRenderer;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;


public class RecentFilesProvider implements DynamicMenuProvider
{
	
	public boolean updateEveryTime()
	{
		return false;
	} 

	
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);

		
		ActionListener actionListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
				view.getStatus().setMessage(null);
			}
		}; 

		
		
		
		
		
		ChangeListener changeListener = new ChangeListener()
		{
			public void stateChanged(ChangeEvent e)
			{
				JMenuItem menuItem = (JMenuItem) e.getSource();
				
				view.getStatus().setMessage(menuItem.isArmed()?menuItem.getActionCommand():null);
			} 
		}; 

		List<BufferHistory.Entry> recentVector = BufferHistory.getHistory();

		if(recentVector.isEmpty())
		{
			JMenuItem menuItem = new JMenuItem(
				jEdit.getProperty(""no-recent-files.label""));
			menuItem.setEnabled(false);
			menu.add(menuItem);
			return;
		}

		final List<JMenuItem> menuItems = new ArrayList<JMenuItem>();
		final JTextField text = new JTextField();
		text.setToolTipText(jEdit.getProperty(""recent-files.textfield.tooltip""));
		menu.add(text);
		text.addKeyListener(new KeyAdapter()
		{
			public void keyReleased(KeyEvent e)
			{
				String typedText = text.getText();
				for (JMenuItem tempMenuItem : menuItems)
				{
					if (typedText.length() == 0)
					{
						tempMenuItem.setEnabled(true);
					}
					else
					{
						String fileName = tempMenuItem.getText();
						boolean matchesStart = fileName.toLowerCase().startsWith(typedText.toLowerCase());
						tempMenuItem.setEnabled(matchesStart);
					}
				}
			}
		});

		boolean sort = jEdit.getBooleanProperty(""sortRecent"");

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

		Iterator<BufferHistory.Entry> iter = recentVector.iterator();
		while(iter.hasNext())
		{
			String path = iter.next().path;
			JMenuItem menuItem = new JMenuItem(MiscUtilities
				.getFileName(path));
			menuItem.setActionCommand(path);
			menuItem.addActionListener(actionListener);

			menuItem.addChangeListener(changeListener);
			
			menuItem.setIcon(FileCellRenderer.fileIcon);

			menuItems.add(menuItem);
			if (!sort)
			{
				if (menu.getMenuComponentCount() >= maxItems
				    && iter.hasNext())
				{
					JMenu newMenu = new JMenu(
							jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}

				menu.add(menuItem);
			}
		}

		if(sort)
		{
			Collections.sort(menuItems, new MenuItemTextComparator());
			for(int i = 0; i < menuItems.size(); i++)
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& i != 0)
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}

				menu.add(menuItems.get(i));
			}
		}
		JMenuItem menuItem = new JMenuItem(jEdit.getProperty(""clear-recent-files.label""));
		menuItem.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent e)
			{
				BufferHistory.clear();
			}
		});
		menu.addSeparator();
		menu.add(menuItem);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.MirrorList,5,1,0,10,37,0,3,9,1,0.5,203,0.0,0,0.0,0.36,0,0,39.2,1,0.8,0,"

package org.gjt.sp.jedit.pluginmgr;

import java.io.*;
import java.net.*;
import java.util.*;

import org.xml.sax.XMLReader;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.XMLReaderFactory;

import org.gjt.sp.jedit.*;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.ProgressObserver;
import org.gjt.sp.util.Log;


public class MirrorList
{
	public List<Mirror> mirrors;
	
	public String xml;

	
	public MirrorList(boolean download, ProgressObserver observer) throws Exception
	{
		mirrors = new ArrayList<Mirror>();

		Mirror none = new Mirror();
		none.id = Mirror.NONE;
		none.description = none.location = none.country = none.continent = """";
		mirrors.add(none);

		String path = jEdit.getProperty(""plugin-manager.mirror-url"");
		MirrorListHandler handler = new MirrorListHandler(this,path);
		if (download)
		{
			Log.log(Log.NOTICE, this, ""Loading mirror list from internet"");
			downloadXml(path);
		}
		else
		{
			Log.log(Log.NOTICE, this, ""Loading mirror list from cache"");
			readXml();
		}
		observer.setValue(1);
		Reader in = new BufferedReader(new StringReader(xml));

		InputSource isrc = new InputSource(in);
		isrc.setSystemId(""jedit.jar"");
		XMLReader parser = XMLReaderFactory.createXMLReader();
		parser.setContentHandler(handler);
		parser.setDTDHandler(handler);
		parser.setEntityResolver(handler);
		parser.setErrorHandler(handler);
		parser.parse(isrc);
		observer.setValue(2);
	} 

	

	
	
	private void readXml() throws IOException
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;

		File mirrorList = new File(MiscUtilities.constructPath(
			settingsDirectory,""mirrorList.xml""));
		if(!mirrorList.exists())
			return;
		InputStream inputStream = null;
		try
		{
			inputStream = new BufferedInputStream(new FileInputStream(mirrorList));

			ByteArrayOutputStream out = new ByteArrayOutputStream();
			IOUtilities.copyStream(null,inputStream,out, false);
			xml = out.toString();
		}
		finally
		{
			IOUtilities.closeQuietly(inputStream);
		}
	} 

	
	
	private void downloadXml(String path) throws IOException
	{
		InputStream inputStream = null;
		try
		{
			inputStream = new URL(path).openStream();

			ByteArrayOutputStream out = new ByteArrayOutputStream();
			IOUtilities.copyStream(null,inputStream,out, false);
			xml = out.toString();
		}
		finally
		{
			IOUtilities.closeQuietly(inputStream);
		}
	} 

	
	void add(Mirror mirror)
	{
		mirrors.add(mirror);
	} 

	
	void finished()
	{
		Collections.sort(mirrors,new MirrorCompare());
	} 

	

	

	
	public static class Mirror
	{
		public static final String NONE = ""NONE"";

		public String id;
		public String description;
		public String location;
		public String country;
		public String continent;
	} 

	
	private class MirrorCompare implements Comparator<Mirror>
	{
		public int compare(Mirror m1,Mirror m2)
		{
			int result;
			if ((result = m1.continent.compareToIgnoreCase(m2.continent)) == 0)
				if ((result = m1.country.compareToIgnoreCase(m2.country)) == 0)
					if ((result = m1.location.compareToIgnoreCase(m2.location)) == 0)
						return m1.description.compareToIgnoreCase(m2.description);
			return result;
		}

		public boolean equals(Object obj)
		{
			return obj instanceof MirrorCompare;
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHReturnType,4,2,0,10,8,4,4,6,2,0.666666667,37,0.0,0,0.85,0.5,0,0,8.0,2,1.0,0,"


package org.gjt.sp.jedit.bsh;

class BSHReturnType extends SimpleNode
{
	public boolean isVoid;

	BSHReturnType(int id) { super(id); }

	BSHType getTypeNode() { 
		return (BSHType)jjtGetChild(0);
	}

	public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
	{
		if ( isVoid )
			return ""V"";
		else
			return getTypeNode().getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
	}

	public Class evalReturnType( 
		CallStack callstack, Interpreter interpreter ) throws EvalError
	{
		if ( isVoid )
			return Void.TYPE;
		else
			return getTypeNode().getType( callstack, interpreter );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.Reflect,41,1,0,25,120,820,15,17,14,2.0,1482,0.0,0,0.0,0.142276423,0,0,35.14634146,7,1.7073,0,"

package org.gjt.sp.jedit.bsh;

import java.lang.reflect.*;
import java.util.Vector;



class Reflect 
{
    
    public static Object invokeObjectMethod(
		Object object, String methodName, Object[] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo ) 
		throws ReflectError, EvalError, InvocationTargetException
	{
		
		if ( object instanceof This && !This.isExposedThisMethod(methodName) )
			return ((This)object).invokeMethod( 
				methodName, args, interpreter, callstack, callerInfo,
				false
			);

		
		try {
			BshClassManager bcm =
				interpreter == null ? null : interpreter.getClassManager();
			Class clas = object.getClass();

			Method method = resolveExpectedJavaMethod(
				bcm, clas, object, methodName, args, false );

			return invokeMethod( method, object, args );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( callerInfo, callstack );
		}
    }

    
    public static Object invokeStaticMethod(
		BshClassManager bcm, Class clas, String methodName, Object [] args )
        throws ReflectError, UtilEvalError, InvocationTargetException
    {
        Interpreter.debug(""invoke static Method"");
        Method method = resolveExpectedJavaMethod( 
			bcm, clas, null, methodName, args, true );
		return invokeMethod( method, null, args );
    }

	
	static Object invokeMethod(
		Method method, Object object, Object[] args ) 
		throws ReflectError, InvocationTargetException
	{
		if ( args == null )
			args = new Object[0];

		logInvokeMethod( ""Invoking method (entry): "", method, args );

		
		Object [] tmpArgs = new Object [ args.length ];
		Class [] types = method.getParameterTypes();
		try {
			for (int i=0; i<args.length; i++)
				tmpArgs[i] = Types.castObject(
					args[i], types[i], Types.ASSIGNMENT );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError(
				""illegal argument type in method invocation: ""+e );
		}

		
		tmpArgs = Primitive.unwrap( tmpArgs );

		logInvokeMethod( ""Invoking method (after massaging values): "",
			method, tmpArgs );

		try {
			Object returnValue = method.invoke( object, tmpArgs );
			if ( returnValue == null )
				returnValue = Primitive.NULL;
			Class returnType = method.getReturnType();

			return Primitive.wrap( returnValue, returnType );
		} catch( IllegalAccessException e ) {
			throw new ReflectError( ""Cannot access method "" 
				+ StringUtil.methodString(
					method.getName(), method.getParameterTypes() ) 
				+ "" in '"" + method.getDeclaringClass() + ""' :"" + e );
		}
	}

	public static Object getIndex(Object array, int index)
        throws ReflectError, UtilTargetError
    {
		if ( Interpreter.DEBUG ) 
			Interpreter.debug(""getIndex: ""+array+"", index=""+index);
        try {
            Object val = Array.get(array, index);
            return Primitive.wrap( val, array.getClass().getComponentType() );
        }
        catch( ArrayIndexOutOfBoundsException  e1 ) {
			throw new UtilTargetError( e1 );
        } catch(Exception e) {
            throw new ReflectError(""Array access:"" + e);
        }
    }

    public static void setIndex(Object array, int index, Object val)
        throws ReflectError, UtilTargetError
    {
        try {
            val = Primitive.unwrap(val);
            Array.set(array, index, val);
        }
        catch( ArrayStoreException e2 ) {
			throw new UtilTargetError( e2 );
        } catch( IllegalArgumentException e1 ) {
			throw new UtilTargetError( 
				new ArrayStoreException( e1.toString() ) );
        } catch(Exception e) {
            throw new ReflectError(""Array access:"" + e);
        }
    }

    public static Object getStaticFieldValue(Class clas, String fieldName)
        throws UtilEvalError, ReflectError
    {
        return getFieldValue( clas, null, fieldName, true);
    }

	
    public static Object getObjectFieldValue( Object object, String fieldName )
        throws UtilEvalError, ReflectError
    {
		if ( object instanceof This )
			return ((This)object).namespace.getVariable( fieldName );
		else {
			try {
				return getFieldValue(
					object.getClass(), object, fieldName, false);
			} catch ( ReflectError e ) {
				

				if ( hasObjectPropertyGetter( object.getClass(), fieldName ) )
					return getObjectProperty( object, fieldName );
				else
					throw e;
			}
		}
    }

    static LHS getLHSStaticField(Class clas, String fieldName)
        throws UtilEvalError, ReflectError
    {
        Field f = resolveExpectedJavaField( 
			clas, fieldName, true);
        return new LHS(f);
    }

	
    static LHS getLHSObjectField( Object object, String fieldName )
        throws UtilEvalError, ReflectError
    {
		if ( object instanceof This )
		{
			
			
			boolean recurse = false; 
			return new LHS( ((This)object).namespace, fieldName, recurse );
		}

		try {
			Field f = resolveExpectedJavaField( 
				object.getClass(), fieldName, false );
			return new LHS(object, f);
		} catch ( ReflectError e ) 
		{
			
			if ( hasObjectPropertySetter( object.getClass(), fieldName ) )
				return new LHS( object, fieldName );
			else
				throw e;
		}
    }

    private static Object getFieldValue(
		Class clas, Object object, String fieldName, boolean staticOnly )
		throws UtilEvalError, ReflectError
    {
        try {
            Field f = resolveExpectedJavaField( clas, fieldName, staticOnly );

            Object value = f.get(object);
            Class returnType = f.getType();
            return Primitive.wrap( value, returnType );

        } catch( NullPointerException e ) { 
            throw new ReflectError(
				""???"" + fieldName + "" is not a static field."");
        } catch(IllegalAccessException e) {
            throw new ReflectError(""Can't access field: "" + fieldName);
        }
    }

	
    protected static Field resolveJavaField( 
		Class clas, String fieldName, boolean staticOnly )
        throws UtilEvalError
    {
		try {
			return resolveExpectedJavaField( clas, fieldName, staticOnly );
		} catch ( ReflectError e ) { 
			return null;
		}
	}

	
	
    protected static Field resolveExpectedJavaField( 
		Class clas, String fieldName, boolean staticOnly
	)
        throws UtilEvalError, ReflectError
    {
		Field field;
        try {
			if ( Capabilities.haveAccessibility() )
				field = findAccessibleField( clas, fieldName );
			else
				
				field = clas.getField(fieldName);
        }
        catch( NoSuchFieldException e) {
            throw new ReflectError(""No such field: "" + fieldName );
		} catch ( SecurityException e ) {
			throw new UtilTargetError( 
			""Security Exception while searching fields of: ""+clas,
			e );
		}

		if ( staticOnly && !Modifier.isStatic( field.getModifiers() ) )
			throw new UtilEvalError(
				""Can't reach instance field: ""+fieldName
				+"" from static context: ""+clas.getName() );

		return field;
    }

	
	
	private static Field findAccessibleField( Class clas, String fieldName ) 
		throws UtilEvalError, NoSuchFieldException
	{
		Field field;

		
		try {
			field = clas.getField(fieldName);
			ReflectManager.RMSetAccessible( field );
			return field;
		} catch ( NoSuchFieldException e ) { }

		
		while ( clas != null )
		{
			try {
				field = clas.getDeclaredField(fieldName);
				ReflectManager.RMSetAccessible( field );
				return field;

				

			} catch(NoSuchFieldException e) { }

			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException( fieldName );
	}

	
    protected static Method resolveExpectedJavaMethod(
		BshClassManager bcm, Class clas, Object object, 
		String name, Object[] args, boolean staticOnly )
        throws ReflectError, UtilEvalError
    {
		if ( object == Primitive.NULL )
			throw new UtilTargetError( new NullPointerException(
				""Attempt to invoke method "" +name+"" on null value"" ) );

		Class [] types = Types.getTypes(args);
		Method method = resolveJavaMethod( bcm, clas, name, types, staticOnly );

		if ( method == null )
			throw new ReflectError(
				( staticOnly ? ""Static method "" : ""Method "" )
				+ StringUtil.methodString(name, types) +
				"" not found in class'"" + clas.getName() + ""'"");

		return method;
	}

    
    protected static Method resolveJavaMethod(
		BshClassManager bcm, Class clas, String name, 
		Class [] types, boolean staticOnly )
		throws UtilEvalError
    {
		if ( clas == null )
			throw new InterpreterError(""null class"");

		
		Method method = null;
		if ( bcm == null ) 
			Interpreter.debug(""resolveJavaMethod UNOPTIMIZED lookup"");
		else
			method = bcm.getResolvedMethod( clas, name, types, staticOnly );

		if ( method == null )
		{
			boolean publicOnly = !Capabilities.haveAccessibility();
			
			try {
				method = findOverloadedMethod( clas, name, types, publicOnly );
			} catch ( SecurityException e ) {
				throw new UtilTargetError( 
				""Security Exception while searching methods of: ""+clas,
				e );
			}

			checkFoundStaticMethod( method, staticOnly, clas );

			
			
			
			if ( method != null && !publicOnly ) {
				try {
					ReflectManager.RMSetAccessible( method );
				} catch ( UtilEvalError e ) {  }
			}

			
			if ( method != null && bcm != null )
				bcm.cacheResolvedMethod( clas, types, method );
		}

		return method;
	}

	
	private static Method findOverloadedMethod(
		Class baseClass, String methodName, Class[] types, boolean publicOnly )
	{
		if ( Interpreter.DEBUG )
			Interpreter.debug( ""Searching for method: ""+
				StringUtil.methodString(methodName, types)
				+ "" in '"" + baseClass.getName() + ""'"" );

		Method [] methods = getCandidateMethods(
			baseClass, methodName, types.length, publicOnly );

		if ( Interpreter.DEBUG )
			Interpreter.debug(""Looking for most specific method: ""+methodName);
		Method method = findMostSpecificMethod( types, methods );

		return method;
	}

	
	static Method[] getCandidateMethods(
		Class baseClass, String methodName, int numArgs,
		boolean publicOnly )
	{
		Vector  candidates = gatherMethodsRecursive(
			baseClass, methodName, numArgs, publicOnly, null);

		
		Method [] ma = new Method[ candidates.size() ];
		candidates.copyInto( ma );
		return ma;
	}

	
	private static Vector gatherMethodsRecursive(
		Class baseClass, String methodName, int numArgs,
		boolean publicOnly, Vector candidates )
	{
		if ( candidates == null )
			candidates = new Vector();

		
		
		
		
		if ( publicOnly ) {
			if ( isPublic(baseClass) )
				addCandidates( baseClass.getMethods(),
					methodName, numArgs, publicOnly, candidates );
		} else
			addCandidates( baseClass.getDeclaredMethods(),
				methodName, numArgs, publicOnly, candidates );

		
		Class [] intfs = baseClass.getInterfaces();
		for( int i=0; i< intfs.length; i++ )
			gatherMethodsRecursive(  intfs[i],
				methodName, numArgs, publicOnly, candidates );

		
		Class superclass = baseClass.getSuperclass();
		if ( superclass != null )
			gatherMethodsRecursive( superclass,
				methodName, numArgs, publicOnly, candidates );

		return candidates;
	}

	private static Vector addCandidates(
		Method [] methods, String methodName,
		int numArgs, boolean publicOnly, Vector candidates  )
	{
		for ( int i = 0; i < methods.length; i++ )
		{
			Method m = methods[i];
			if (  m.getName().equals( methodName )
				&& ( m.getParameterTypes().length == numArgs )
				&& ( !publicOnly || isPublic( m ) )
			)
				candidates.add( m );
		}
		return candidates;
	}

	
    static Object constructObject( Class clas, Object[] args )
        throws ReflectError, InvocationTargetException
    {
		if ( clas.isInterface() )
			throw new ReflectError(
				""Can't create instance of an interface: ""+clas);

        Object obj = null;
        Class[] types = Types.getTypes(args);
        Constructor con = null;

		
		
		Constructor[] constructors =
			Capabilities.haveAccessibility() ?
				clas.getDeclaredConstructors() : clas.getConstructors() ;

		if ( Interpreter.DEBUG )
			Interpreter.debug(""Looking for most specific constructor: ""+clas);
		con = findMostSpecificConstructor(types, constructors);
		if ( con == null )
			throw cantFindConstructor( clas, types );

		if ( !isPublic( con ) )
			try {
				ReflectManager.RMSetAccessible( con );
			} catch ( UtilEvalError e ) {  }

        args=Primitive.unwrap( args );
        try {
            obj = con.newInstance( args );
        } catch(InstantiationException e) {
            throw new ReflectError(""The class ""+clas+"" is abstract "");
        } catch(IllegalAccessException e) {
            throw new ReflectError(
				""We don't have permission to create an instance.""
				+""Use setAccessibility(true) to enable access."" );
        } catch(IllegalArgumentException e) {
            throw new ReflectError(""The number of arguments was wrong"");
        }
		if (obj == null)
            throw new ReflectError(""Couldn't construct the object"");

        return obj;
    }

    
    static Constructor findMostSpecificConstructor(
		Class[] idealMatch, Constructor[] constructors)
    {
		int match = findMostSpecificConstructorIndex(idealMatch, constructors );
		return ( match == -1 ) ? null : constructors[ match ];
    }

    static int findMostSpecificConstructorIndex(
		Class[] idealMatch, Constructor[] constructors)
    {
		Class [][] candidates = new Class [ constructors.length ] [];
		for(int i=0; i< candidates.length; i++ )
			candidates[i] = constructors[i].getParameterTypes();

		return findMostSpecificSignature( idealMatch, candidates );
    }

	
	static Method findMostSpecificMethod(
		Class[] idealMatch, Method[] methods )
	{
		
		Class [][] candidateSigs = new Class [ methods.length ][];
		for(int i=0; i<methods.length; i++)
			candidateSigs[i] = methods[i].getParameterTypes();

		int match = findMostSpecificSignature( idealMatch, candidateSigs );
		return match == -1 ? null : methods[match];
	}

	
	
	static int findMostSpecificSignature(
		Class [] idealMatch, Class [][] candidates )
	{
		for ( int round = Types.FIRST_ROUND_ASSIGNABLE;
			  round <= Types.LAST_ROUND_ASSIGNABLE; round++ )
		{
			Class [] bestMatch = null;
			int bestMatchIndex = -1;

			for (int i=0; i < candidates.length; i++)
			{
				Class[] targetMatch = candidates[i];

				
				
				
				if ( Types.isSignatureAssignable(
						idealMatch, targetMatch, round )
					&& ( (bestMatch == null) ||
						Types.isSignatureAssignable( targetMatch, bestMatch,
							Types.JAVA_BASE_ASSIGNABLE )
						)
				)
				{
					bestMatch = targetMatch;
					bestMatchIndex = i;
				}
			}

			if ( bestMatch != null )
				return bestMatchIndex;
		}

		return -1;
	}

	private static String accessorName( String getorset, String propName ) {
        return getorset
			+ String.valueOf(Character.toUpperCase(propName.charAt(0)))
			+ propName.substring(1);
	}

    public static boolean hasObjectPropertyGetter(
		Class clas, String propName )
	{
		String getterName = accessorName(""get"", propName );
		try {
			clas.getMethod( getterName, new Class [0] );
			return true;
		} catch ( NoSuchMethodException e ) {  }
		getterName = accessorName(""is"", propName );
		try {
			Method m = clas.getMethod( getterName, new Class [0] );
			return ( m.getReturnType() == Boolean.TYPE );
		} catch ( NoSuchMethodException e ) {
			return false;
		}
	}

    public static boolean hasObjectPropertySetter(
		Class clas, String propName )
	{
		String setterName = accessorName(""set"", propName );
		Method [] methods = clas.getMethods();

		
		
		for(int i=0; i<methods.length; i++)
			if ( methods[i].getName().equals( setterName ) )
				return true;
		return false;
	}

    public static Object getObjectProperty(
		Object obj, String propName )
        throws UtilEvalError, ReflectError
    {
        Object[] args = new Object[] { };

        Interpreter.debug(""property access: "");
		Method method = null;

		Exception e1=null, e2=null;
		try {
			String accessorName = accessorName( ""get"", propName );
			method = resolveExpectedJavaMethod(
				null, obj.getClass(), obj, accessorName, args, false );
		} catch ( Exception e ) {
			e1 = e;
		}
		if ( method == null )
			try {
				String accessorName = accessorName( ""is"", propName );
				method = resolveExpectedJavaMethod(
					null, obj.getClass(), obj,
					accessorName, args, false );
				if ( method.getReturnType() != Boolean.TYPE )
					method = null;
			} catch ( Exception e ) {
				e2 = e;
			}
		if ( method == null )
			throw new ReflectError(""Error in property getter: ""
				+e1 + (e2!=null?"" : ""+e2:"""") );

        try {
			return invokeMethod( method, obj, args );
        }
        catch(InvocationTargetException e)
        {
            throw new UtilEvalError(""Property accessor threw exception: ""
				+e.getTargetException() );
        }
    }

    public static void setObjectProperty(
		Object obj, String propName, Object value)
        throws ReflectError, UtilEvalError
    {
        String accessorName = accessorName( ""set"", propName );
        Object[] args = new Object[] { value };

        Interpreter.debug(""property access: "");
        try {
			Method method = resolveExpectedJavaMethod(
				null, obj.getClass(), obj, accessorName, args, false );
			invokeMethod( method, obj, args );
        }
        catch ( InvocationTargetException e )
        {
            throw new UtilEvalError(""Property accessor threw exception: ""
				+e.getTargetException() );
        }
    }

    
    public static String normalizeClassName(Class type)
    {
        if ( !type.isArray() )
            return type.getName();

        StringBuilder className = new StringBuilder();
        try {
            className.append( getArrayBaseType(type).getName() +"" "");
            for(int i = 0; i < getArrayDimensions(type); i++)
                className.append(""[]"");
        } catch( ReflectError e ) {  }

        return className.toString();
    }

	
    public static int getArrayDimensions(Class arrayClass)
    {
        if ( !arrayClass.isArray() )
            return 0;

        return arrayClass.getName().lastIndexOf('[') + 1;  
    }

    
    public static Class getArrayBaseType(Class arrayClass) throws ReflectError
    {
        if ( !arrayClass.isArray() )
            throw new ReflectError(""The class is not an array."");

		return arrayClass.getComponentType();

    }

	
	public static Object invokeCompiledCommand(
		Class commandClass, Object [] args, Interpreter interpreter,
		CallStack callstack )
		throws UtilEvalError
	{
        
        Object[] invokeArgs = new Object[args.length + 2];
        invokeArgs[0] = interpreter;
        invokeArgs[1] = callstack;
        System.arraycopy( args, 0, invokeArgs, 2, args.length );
		BshClassManager bcm = interpreter.getClassManager();
		try {
        	return Reflect.invokeStaticMethod(
				bcm, commandClass, ""invoke"", invokeArgs );
		} catch ( InvocationTargetException e ) {
			throw new UtilEvalError(
				""Error in compiled command: ""+e.getTargetException() );
		} catch ( ReflectError e ) {
			throw new UtilEvalError(""Error invoking compiled command: ""+e );
		}
	}

	private static void logInvokeMethod( 
		String msg, Method method, Object[] args )
	{
		if ( Interpreter.DEBUG )
		{
			Interpreter.debug( msg +method+"" with args:"" );
			for(int i=0; i<args.length; i++)
				Interpreter.debug(
					""args[""+i+""] = ""+args[i]
					+"" type = ""+args[i].getClass() );
		}
	}

	private static void checkFoundStaticMethod(
		Method method, boolean staticOnly, Class clas )
		throws UtilEvalError
	{
		
		if ( method != null && staticOnly && !isStatic( method ) )
			throw new UtilEvalError(
				""Cannot reach instance method: ""
				+ StringUtil.methodString(
					method.getName(), method.getParameterTypes() )
				+ "" from static context: ""+ clas.getName() );
	}

	private static ReflectError cantFindConstructor(
		Class clas, Class [] types )
	{
		if ( types.length == 0 )
			return new ReflectError(
				""Can't find default constructor for: ""+clas);
		else
			return new ReflectError(
				""Can't find constructor: ""
					+ StringUtil.methodString( clas.getName(), types )
					+"" in class: ""+ clas.getName() );
	}

	private static boolean isPublic( Class c ) {
		return Modifier.isPublic( c.getModifiers() );
	}
	private static boolean isPublic( Method m ) {
		return Modifier.isPublic( m.getModifiers() );
	}
	private static boolean isPublic( Constructor c ) {
		return Modifier.isPublic( c.getModifiers() );
	}
	private static boolean isStatic( Method m ) {
		return Modifier.isStatic( m.getModifiers() );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.ErrorsWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.util.Log;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.PrintStream;
import java.io.ByteArrayOutputStream;



public class ErrorsWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view)
	{
		Widget errorWidget = new ErrorWidget(view);
		return errorWidget;
	} 

	
	private static class ErrorWidget implements Widget
	{
		private final ErrorHighlight errorHighlight;

		ErrorWidget(View view)
		{
			errorHighlight = new ErrorHighlight(view);
		}

		public JComponent getComponent()
		{
			return errorHighlight;
		}

		public void update()
		{
			errorHighlight.update();
		}

		public void propertiesChanged()
		{
		}
	} 

	
	private static class ErrorHighlight extends JLabel implements ActionListener
	{
		private int currentSize;

		
		ErrorHighlight(View view)
		{
			setForeground(jEdit.getColorProperty(""view.status.foreground""));
			setBackground(jEdit.getColorProperty(""view.status.background""));
			addMouseListener(new MyMouseAdapter(view));
		} 

		
		@Override
		public void addNotify()
		{
			super.addNotify();
			update();
			int millisecondsPerMinute = 1000;

			timer = new Timer(millisecondsPerMinute, this);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} 


		
		@Override
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
			super.removeNotify();
		} 

		
		@Override
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(), -20);
		} 

		
		public void actionPerformed(ActionEvent e)
		{
			update();
		} 

		private Timer timer;

		
		private void update()
		{
			int size = Log.throwables.size();
			if (size != currentSize)
			{
				currentSize = size;
				if (size == 0)
				{
					setForeground(jEdit.getColorProperty(""view.status.foreground""));
					setText(null);
					setToolTipText(size + "" error"");
				}
				else
				{
					setForeground(Color.red);
					setText(Integer.toString(size) + "" error(s)"");
					setToolTipText(size + "" error(s)"");
				}
			}
		} 

		
		private class MyMouseAdapter extends MouseAdapter
		{
			private final View view;

			MyMouseAdapter(View view)
			{
				this.view = view;
			}

			@Override
				public void mouseClicked(MouseEvent e)
			{
				if (Log.throwables.isEmpty())
					return;
				if (GUIUtilities.isRightButton(e.getModifiers()))
				{
					JPopupMenu menu = GUIUtilities.loadPopupMenu(""errorwidget.popupmenu"");
					GUIUtilities.showPopupMenu(menu, ErrorHighlight.this, e.getX(), e.getY());

				}
				else if (e.getClickCount() == 2)
					new ErrorDialog(view);

			}
		} 

	} 

	
	private static class ErrorDialog extends EnhancedDialog
	{
		private final JTextArea textArea;
		private final ByteArrayOutputStream byteArrayOutputStream;
		private final PrintStream printStream;
		private final JButton removeThisError;
		private final JButton removeAllErrors;
		private final Object[] throwables;
		private final JComboBox combo;

		
		private ErrorDialog(Frame view)
		{
			super(view, ""Errors"", false);
			byteArrayOutputStream = new ByteArrayOutputStream();
			printStream = new PrintStream(byteArrayOutputStream);
			throwables = Log.throwables.toArray();
			textArea = new JTextArea();
			textArea.setEditable(false);
			if (throwables.length != 0)
			{
				Throwable throwable = (Throwable) throwables[0];
				setThrowable(throwable);
			}
			combo = new JComboBox(throwables);
			combo.addItemListener(new ItemListener()
			{
				public void itemStateChanged(ItemEvent e)
				{
					setThrowable((Throwable) combo.getSelectedItem());
				}
			});
			getContentPane().add(combo, BorderLayout.NORTH);
			getContentPane().add(new JScrollPane(textArea));



			Box buttons = new Box(BoxLayout.X_AXIS);
			buttons.add(Box.createGlue());

			buttons.add(removeThisError = new JButton(jEdit.getProperty(""grab-key.remove"")));
			buttons.add(Box.createHorizontalStrut(6));
			buttons.add(removeAllErrors = new JButton(jEdit.getProperty(""common.clearAll"")));

			ErrorDialog.MyActionListener actionListener = new MyActionListener();
			removeThisError.addActionListener(actionListener);
			removeAllErrors.addActionListener(actionListener);
			buttons.add(Box.createGlue());


			getContentPane().add(buttons, BorderLayout.SOUTH);
			pack();
			GUIUtilities.loadGeometry(this,""status.errorWidget"");
			setVisible(true);
		} 

		
		private void setThrowable(Throwable throwable)
		{
			if (throwable == null)
			{
				textArea.setText(null);
			}
			else
			{
				throwable.printStackTrace(printStream);
				textArea.setText(byteArrayOutputStream.toString());
				textArea.setCaretPosition(0);
				byteArrayOutputStream.reset();
			}
		} 

		
		@Override
		public void dispose()
		{
			GUIUtilities.saveGeometry(this, ""status.errorWidget"");
			super.dispose();
		} 

		
		@Override
		public void ok()
		{
			dispose();
		} 

		
		@Override
		public void cancel()
		{
			dispose();
		} 

		
		private class MyActionListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				Object source = e.getSource();
				if (source == removeThisError)
				{
					Throwable throwable = (Throwable) combo.getSelectedItem();
					if (throwable != null)
					{
						Log.throwables.remove(throwable);
						combo.removeItem(throwable);
						if (combo.getItemCount() == 0)
						{
							dispose();
						}
					}
				}
				else if (source == removeAllErrors)
				{
					for (Object throwable : throwables)
					{
						Log.throwables.remove(throwable);
					}
					dispose();
				}
			}
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.options.ViewOptionPane,14,6,0,7,56,51,2,7,1,0.890688259,557,1.0,0,0.980938416,0.5,3,5,37.42857143,5,1.4286,0,"

package org.gjt.sp.jedit.options;

import javax.swing.border.*;
import javax.swing.*;

import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.bufferset.BufferSet;
import org.gjt.sp.jedit.bufferset.BufferSetManager;

public class ViewOptionPane extends AbstractOptionPane
{
	
	public ViewOptionPane()
	{
		super(""view"");
	} 

	
	@Override
	protected void _init()
	{
		
		layoutIcon1 = GUIUtilities.loadIcon(""dock_layout1.png"");
		layoutIcon2 = GUIUtilities.loadIcon(""dock_layout2.png"");
		layoutIcon3 = GUIUtilities.loadIcon(""dock_layout3.png"");
		layoutIcon4 = GUIUtilities.loadIcon(""dock_layout4.png"");

		JPanel layoutPanel = new JPanel(new BorderLayout(12,12));

		if(jEdit.getBooleanProperty(""view.docking.alternateLayout""))
		{
			layout = new JLabel(jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"")
				? layoutIcon4 : layoutIcon2);
		}
		else
		{
			layout = new JLabel(jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"")
				? layoutIcon3 : layoutIcon1);
		}

		layout.setBorder(new EmptyBorder(12,12,12,12));
		layoutPanel.add(BorderLayout.CENTER,layout);

		JPanel buttons = new JPanel(new GridLayout(2,1,12,12));
		buttons.setBorder(new EmptyBorder(0,12,12,12));
		buttons.add(alternateDockingLayout = new JButton(jEdit.getProperty(
			""options.view.alternateDockingLayout"")));
		ActionHandler actionHandler = new ActionHandler();
		alternateDockingLayout.addActionListener(actionHandler);
		buttons.add(alternateToolBarLayout = new JButton(jEdit.getProperty(
			""options.view.alternateToolBarLayout"")));
		alternateToolBarLayout.addActionListener(actionHandler);
		layoutPanel.add(BorderLayout.SOUTH,buttons);

		TitledBorder border = new TitledBorder(jEdit.getProperty(
			""options.view.viewLayout""));
		border.setTitleJustification(TitledBorder.CENTER);
		layoutPanel.setBorder(border);

		addComponent(layoutPanel);

		
		showFullPath = new JCheckBox(jEdit.getProperty(
			""options.view.showFullPath""));
		showFullPath.setSelected(jEdit.getBooleanProperty(
			""view.showFullPath""));
		addComponent(showFullPath);

		
		showSearchbar = new JCheckBox(jEdit.getProperty(
			""options.view.showSearchbar""));
		showSearchbar.setSelected(jEdit.getBooleanProperty(
			""view.showSearchbar""));
		addComponent(showSearchbar);

		
		beepOnSearchAutoWrap = new JCheckBox(jEdit.getProperty(
			""options.view.beepOnSearchAutoWrap""));
		beepOnSearchAutoWrap.setSelected(jEdit.getBooleanProperty(
			""search.beepOnSearchAutoWrap""));
		addComponent(beepOnSearchAutoWrap);

		
		showBufferSwitcher = new JCheckBox(jEdit.getProperty(
			""options.view.showBufferSwitcher""));

		showBufferSwitcher.setSelected(jEdit.getBooleanProperty(
			""view.showBufferSwitcher""));
		addComponent(showBufferSwitcher);
		showBufferSwitcher.addActionListener(actionHandler);


		
		bufferSwitcherMaxRowCount = new JTextField(jEdit.getProperty(""bufferSwitcher.maxRowCount""));
		addComponent(jEdit.getProperty(""options.view.bufferSwitcherMaxRowsCount""),
			bufferSwitcherMaxRowCount);
		bufferSwitcherMaxRowCount.setEditable(showBufferSwitcher.isSelected());

		defaultBufferSet = new JComboBox();
		defaultBufferSet.addItem(BufferSet.Scope.global);
		defaultBufferSet.addItem(BufferSet.Scope.view);
		defaultBufferSet.addItem(BufferSet.Scope.editpane);
		defaultBufferSet.setSelectedItem(BufferSet.Scope.fromString(jEdit.getProperty(""editpane.bufferset.default"")));
		addComponent(jEdit.getProperty(""options.editpane.bufferset.default""), defaultBufferSet);

		newBufferSetBehavior = new JComboBox();
		newBufferSetBehavior.addItem(BufferSetManager.NewBufferSetAction.copy);
		newBufferSetBehavior.addItem(BufferSetManager.NewBufferSetAction.empty);
		newBufferSetBehavior.addItem(BufferSetManager.NewBufferSetAction.currentbuffer);
		newBufferSetBehavior.setSelectedItem(BufferSetManager.NewBufferSetAction.fromString(jEdit.getProperty(""editpane.bufferset.new"")));
		addComponent(new JLabel(jEdit.getProperty(""options.editpane.bufferset.contain"")),
					newBufferSetBehavior);


		
		sortBuffers = new JCheckBox(jEdit.getProperty(
			""options.view.sortBuffers""));
		sortBuffers.setSelected(jEdit.getBooleanProperty(""sortBuffers""));
		sortBuffers.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				sortByName.setEnabled(sortBuffers.isSelected());
			}
		});

		addComponent(sortBuffers);

		
		sortByName = new JCheckBox(jEdit.getProperty(
			""options.view.sortByName""));
		sortByName.setSelected(jEdit.getBooleanProperty(""sortByName""));
		sortByName.setEnabled(sortBuffers.isSelected());
		addComponent(sortByName);

		fullScreenIncludesMenu = new JCheckBox(jEdit.getProperty(
			""options.view.fullScreenIncludesMenu""));
		fullScreenIncludesMenu.setSelected(
			jEdit.getBooleanProperty(""fullScreenIncludesMenu""));
		addComponent(fullScreenIncludesMenu);

		fullScreenIncludesToolbar = new JCheckBox(jEdit.getProperty(
			""options.view.fullScreenIncludesToolbar""));
		fullScreenIncludesToolbar.setSelected(
			jEdit.getBooleanProperty(""fullScreenIncludesToolbar""));
		addComponent(fullScreenIncludesToolbar);

		fullScreenIncludesStatus = new JCheckBox(jEdit.getProperty(
				""options.view.fullScreenIncludesStatus""));
		fullScreenIncludesStatus.setSelected(
				jEdit.getBooleanProperty(""fullScreenIncludesStatus""));
		addComponent(fullScreenIncludesStatus);

	} 

	
	@Override
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.docking.alternateLayout"",
			layout.getIcon() == layoutIcon2
			|| layout.getIcon() == layoutIcon4);
		jEdit.setBooleanProperty(""view.toolbar.alternateLayout"",
			layout.getIcon() == layoutIcon3
			|| layout.getIcon() == layoutIcon4);
		jEdit.setBooleanProperty(""view.showFullPath"",showFullPath
			.isSelected());
		jEdit.setBooleanProperty(""view.showSearchbar"",showSearchbar
			.isSelected());
		jEdit.setBooleanProperty(""search.beepOnSearchAutoWrap"",beepOnSearchAutoWrap
			.isSelected());
		jEdit.setBooleanProperty(""view.showBufferSwitcher"",
			showBufferSwitcher.isSelected());
		jEdit.setProperty(""bufferSwitcher.maxRowCount"",
			bufferSwitcherMaxRowCount.getText());
		jEdit.setProperty(""editpane.bufferset.default"", defaultBufferSet.getSelectedItem().toString());
		jEdit.setProperty(""editpane.bufferset.new"",
						  ((BufferSetManager.NewBufferSetAction)newBufferSetBehavior.getSelectedItem()).getName());
		jEdit.setBooleanProperty(""sortBuffers"",sortBuffers.isSelected());
		jEdit.setBooleanProperty(""sortByName"",sortByName.isSelected());
		jEdit.setBooleanProperty(""fullScreenIncludesMenu"",fullScreenIncludesMenu.isSelected());
		jEdit.setBooleanProperty(""fullScreenIncludesToolbar"",fullScreenIncludesToolbar.isSelected());
		jEdit.setBooleanProperty(""fullScreenIncludesStatus"",fullScreenIncludesStatus.isSelected());

	} 

	
	private JLabel layout;
	private Icon layoutIcon1, layoutIcon2, layoutIcon3, layoutIcon4;
	private JButton alternateDockingLayout, alternateToolBarLayout;
	private JCheckBox showFullPath;
	private JCheckBox showSearchbar;
	private JCheckBox beepOnSearchAutoWrap;
	private JCheckBox showBufferSwitcher;
	private JTextField bufferSwitcherMaxRowCount;
	private JComboBox defaultBufferSet;
	private JComboBox newBufferSetBehavior;
	private JCheckBox sortBuffers;
	private JCheckBox sortByName;
	private JCheckBox fullScreenIncludesMenu;
	private JCheckBox fullScreenIncludesToolbar;
	private JCheckBox fullScreenIncludesStatus;

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == alternateDockingLayout)
			{
				if(layout.getIcon() == layoutIcon1)
					layout.setIcon(layoutIcon2);
				else if(layout.getIcon() == layoutIcon2)
					layout.setIcon(layoutIcon1);
				else if(layout.getIcon() == layoutIcon3)
					layout.setIcon(layoutIcon4);
				else if(layout.getIcon() == layoutIcon4)
					layout.setIcon(layoutIcon3);
			}
			else if(evt.getSource() == alternateToolBarLayout)
			{
				if(layout.getIcon() == layoutIcon1)
					layout.setIcon(layoutIcon3);
				else if(layout.getIcon() == layoutIcon3)
					layout.setIcon(layoutIcon1);
				else if(layout.getIcon() == layoutIcon2)
					layout.setIcon(layoutIcon4);
				else if(layout.getIcon() == layoutIcon4)
					layout.setIcon(layoutIcon2);
			}
			else if (evt.getSource() == showBufferSwitcher)
			{
				bufferSwitcherMaxRowCount.setEditable(showBufferSwitcher.isSelected());
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.AbbrevEditor,8,5,0,5,33,0,4,1,8,0.571428571,419,1.0,0,0.989393939,0.625,0,0,51.0,12,3.375,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class AbbrevEditor extends JPanel
{
	
	public AbbrevEditor()
	{
		GridBagLayout layout = new GridBagLayout();
		setLayout(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.anchor = cons.WEST;
		cons.fill = cons.BOTH;
		cons.weightx = 0.0f;
		cons.gridx = 1;
		cons.gridy = 1;

		JLabel label = new JLabel(jEdit.getProperty(""abbrev-editor.abbrev""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridx++;
		cons.weightx = 1.0f;
		abbrev = new JTextField();
		layout.setConstraints(abbrev,cons);
		add(abbrev);

		cons.gridx = 1;
		cons.weightx = 0.0f;
		cons.gridwidth = 2;

		cons.gridy++;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.before""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);

		cons.gridy++;
		cons.weighty = 1.0f;
		beforeCaret = new JTextArea(4,40);
		JScrollPane scroller = new JScrollPane(beforeCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);

		cons.gridy++;
		cons.weighty = 0.0f;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.after""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);

		cons.gridy++;
		cons.weighty = 1.0f;
		afterCaret = new JTextArea(4,40);
		scroller = new JScrollPane(afterCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
	} 

	
	public String getAbbrev()
	{
		return abbrev.getText();
	} 

	
	public void setAbbrev(String abbrev)
	{
		this.abbrev.setText(abbrev);
	} 

	
	public String getExpansion()
	{
		StringBuilder buf = new StringBuilder();

		String beforeCaretText = beforeCaret.getText();
		String afterCaretText = afterCaret.getText();

		for(int i = 0; i < beforeCaretText.length(); i++)
		{
			char ch = beforeCaretText.charAt(i);
			switch(ch)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}

		if(afterCaretText.length() != 0)
		{
			buf.append(""\\|"");

			for(int i = 0; i < afterCaretText.length(); i++)
			{
				char ch = afterCaretText.charAt(i);
				switch(ch)
				{
				case '\n':
					buf.append(""\\n"");
					break;
				case '\t':
					buf.append(""\\t"");
					break;
				case '\\':
					buf.append(""\\\\"");
					break;
				default:
					buf.append(ch);
					break;
				}
			}
		}

		return buf.toString();
	} 

	
	public void setExpansion(String expansion)
	{
		if(expansion == null)
		{
			beforeCaret.setText(null);
			afterCaret.setText(null);
			return;
		}

		String beforeCaretText = null;
		String afterCaretText = null;
		StringBuilder buf = new StringBuilder();

		for(int i = 0; i < expansion.length(); i++)
		{
			char ch = expansion.charAt(i);

			if(ch == '\\' && i != expansion.length() - 1)
			{
				ch = expansion.charAt(++i);
				switch(ch)
				{
				case 't':
					buf.append('\t');
					break;
				case 'n':
					buf.append('\n');
					break;
				case '|':
					beforeCaretText = buf.toString();
					buf.setLength(0);
					break;
				default:
					buf.append(ch);
					break;
				}
			}
			else
				buf.append(ch);
		}

		if(beforeCaretText == null)
			beforeCaretText = buf.toString();
		else
			afterCaretText = buf.toString();

		beforeCaret.setText(beforeCaretText);
		afterCaret.setText(afterCaretText);
	} 

	
	public JTextField getAbbrevField()
	{
		return abbrev;
	} 

	
	public JTextArea getBeforeCaretTextArea()
	{
		return beforeCaret;
	} 

	
	public JTextArea getAfterCaretTextArea()
	{
		return afterCaret;
	} 

	
	private JTextField abbrev;
	private JTextArea beforeCaret, afterCaret;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.ClassWriter,23,1,0,6,57,41,2,5,7,0.935992579,1257,0.306122449,10,0.0,0.222727273,0,0,51.52173913,12,3.0435,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



public class ClassWriter implements ClassVisitor {

  

  final static int CLASS = 7;

  

  final static int FIELD = 9;

  

  final static int METH = 10;

  

  final static int IMETH = 11;

  

  final static int STR = 8;

  

  final static int INT = 3;

  

  final static int FLOAT = 4;

  

  final static int LONG = 5;

  

  final static int DOUBLE = 6;

  

  final static int NAME_TYPE = 12;

  

  final static int UTF8 = 1;

  

  private short index;

  

  private ByteVector pool;

  

  private Item[] table;

  

  private int threshold;

  

  private int access;

  

  private int name;

  

  private int superName;

  

  private int interfaceCount;

  

  private int[] interfaces;

  

  private Item sourceFile;

  

  private int fieldCount;

  

  private ByteVector fields;

  

  private boolean computeMaxs;

  

  CodeWriter firstMethod;

  

  CodeWriter lastMethod;

  

  private int innerClassesCount;

  

  private ByteVector innerClasses;

  

  Item key;

  

  Item key2;

  

  Item key3;

  

  final static int NOARG_INSN = 0;

  

  final static int SBYTE_INSN = 1;

  

  final static int SHORT_INSN = 2;

  

  final static int VAR_INSN = 3;

  

  final static int IMPLVAR_INSN = 4;

  

  final static int TYPE_INSN = 5;

  

  final static int FIELDORMETH_INSN = 6;

  

  final static int ITFMETH_INSN = 7;

  

  final static int LABEL_INSN = 8;

  

  final static int LABELW_INSN = 9;

  

  final static int LDC_INSN = 10;

  

  final static int LDCW_INSN = 11;

  

  final static int IINC_INSN = 12;

  

  final static int TABL_INSN = 13;

  

  final static int LOOK_INSN = 14;

  

  final static int MANA_INSN = 15;

  

  final static int WIDE_INSN = 16;

  

  static byte[] TYPE;

  
  
  

  

  static {
    int i;
    byte[] b = new byte[220];
    String s =
      ""AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADDDDDEEEEEEEEE"" +
      ""EEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA"" +
      ""AAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAAAAAAGGGGGGGHAFBFAAFFAAQPIIJJII"" +
      ""IIIIIIIIIIIIIIII"";
    for (i = 0; i < b.length; ++i) {
      b[i] = (byte)(s.charAt(i) - 'A');
    }
    TYPE = b;

    
  }

  
  
  

  

  public ClassWriter (final boolean computeMaxs) {
    index = 1;
    pool = new ByteVector();
    table = new Item[64];
    threshold = (int)(0.75d*table.length);
    key = new Item();
    key2 = new Item();
    key3 = new Item();
    this.computeMaxs = computeMaxs;
  }

  
  
  

  public void visit (
    final int access,
    final String name,
    final String superName,
    final String[] interfaces,
    final String sourceFile)
  {
    this.access = access;
    this.name = newClass(name).index;
    this.superName = superName == null ? 0 : newClass(superName).index;
    if (interfaces != null && interfaces.length > 0) {
      interfaceCount = interfaces.length;
      this.interfaces = new int[interfaceCount];
      for (int i = 0; i < interfaceCount; ++i) {
        this.interfaces[i] = newClass(interfaces[i]).index;
      }
    }
    if (sourceFile != null) {
      newUTF8(""SourceFile"");
      this.sourceFile = newUTF8(sourceFile);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      newUTF8(""Deprecated"");
    }
  }

  public void visitInnerClass (
    final String name,
    final String outerName,
    final String innerName,
    final int access)
  {
    if (innerClasses == null) {
      newUTF8(""InnerClasses"");
      innerClasses = new ByteVector();
    }
    ++innerClassesCount;
    innerClasses.put2(name == null ? 0 : newClass(name).index);
    innerClasses.put2(outerName == null ? 0 : newClass(outerName).index);
    innerClasses.put2(innerName == null ? 0 : newUTF8(innerName).index);
    innerClasses.put2(access);
  }

  public void visitField (
    final int access,
    final String name,
    final String desc,
    final Object value)
  {
    ++fieldCount;
    if (fields == null) {
      fields = new ByteVector();
    }
    fields.put2(access).put2(newUTF8(name).index).put2(newUTF8(desc).index);
    int attributeCount = 0;
    if (value != null) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      ++attributeCount;
    }
    fields.put2(attributeCount);
    if (value != null) {
      fields.put2(newUTF8(""ConstantValue"").index);
      fields.put4(2).put2(newCst(value).index);
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      fields.put2(newUTF8(""Synthetic"").index).put4(0);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      fields.put2(newUTF8(""Deprecated"").index).put4(0);
    }
  }

  public CodeVisitor visitMethod (
    final int access,
    final String name,
    final String desc,
    final String[] exceptions)
  {
    CodeWriter cw = new CodeWriter(this, computeMaxs);
    cw.init(access, name, desc, exceptions);
    return cw;
  }

  public void visitEnd () {
  }

  
  
  

  

  public byte[] toByteArray () {
    
    int size = 24 + 2*interfaceCount;
    if (fields != null) {
      size += fields.length;
    }
    int nbMethods = 0;
    CodeWriter cb = firstMethod;
    while (cb != null) {
      ++nbMethods;
      size += cb.getSize();
      cb = cb.next;
    }
    size += pool.length;
    int attributeCount = 0;
    if (sourceFile != null) {
      ++attributeCount;
      size += 8;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      ++attributeCount;
      size += 6;
    }
    if (innerClasses != null) {
      ++attributeCount;
      size += 8 + innerClasses.length;
    }
    
    
    ByteVector out = new ByteVector(size);
    out.put4(0xCAFEBABE).put2(3).put2(45);
    out.put2(index).putByteArray(pool.data, 0, pool.length);
    out.put2(access).put2(name).put2(superName);
    out.put2(interfaceCount);
    for (int i = 0; i < interfaceCount; ++i) {
      out.put2(interfaces[i]);
    }
    out.put2(fieldCount);
    if (fields != null) {
      out.putByteArray(fields.data, 0, fields.length);
    }
    out.put2(nbMethods);
    cb = firstMethod;
    while (cb != null) {
      cb.put(out);
      cb = cb.next;
    }
    out.put2(attributeCount);
    if (sourceFile != null) {
      out.put2(newUTF8(""SourceFile"").index).put4(2).put2(sourceFile.index);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      out.put2(newUTF8(""Deprecated"").index).put4(0);
    }
    if (innerClasses != null) {
      out.put2(newUTF8(""InnerClasses"").index);
      out.put4(innerClasses.length + 2).put2(innerClassesCount);
      out.putByteArray(innerClasses.data, 0, innerClasses.length);
    }
    return out.data;
  }

  
  
  

  

  Item newCst (final Object cst) {
    if (cst instanceof Integer) {
      int val = ((Integer)cst).intValue();
      return newInteger(val);
    } else if (cst instanceof Float) {
      float val = ((Float)cst).floatValue();
      return newFloat(val);
    } else if (cst instanceof Long) {
      long val = ((Long)cst).longValue();
      return newLong(val);
    } else if (cst instanceof Double) {
      double val = ((Double)cst).doubleValue();
      return newDouble(val);
    } else if (cst instanceof String) {
      return newString((String)cst);
    } else {
      throw new IllegalArgumentException(""value "" + cst);
    }
  }

  

  Item newUTF8 (final String value) {
    key.set(UTF8, value, null, null);
    Item result = get(key);
    if (result == null) {
      pool.put1(UTF8).putUTF(value);
      result = new Item(index++, key);
      put(result);
    }
    return result;
  }

  

  Item newClass (final String value) {
    key2.set(CLASS, value, null, null);
    Item result = get(key2);
    if (result == null) {
      pool.put12(CLASS, newUTF8(value).index);
      result = new Item(index++, key2);
      put(result);
    }
    return result;
  }

  

  Item newField (
    final String owner,
    final String name,
    final String desc)
  {
    key3.set(FIELD, owner, name, desc);
    Item result = get(key3);
    if (result == null) {
      put122(FIELD, newClass(owner).index, newNameType(name, desc).index);
      result = new Item(index++, key3);
      put(result);
    }
    return result;
  }

  

  Item newMethod (
    final String owner,
    final String name,
    final String desc)
  {
    key3.set(METH, owner, name, desc);
    Item result = get(key3);
    if (result == null) {
      put122(METH, newClass(owner).index, newNameType(name, desc).index);
      result = new Item(index++, key3);
      put(result);
    }
    return result;
  }

  

  Item newItfMethod (
    final String ownerItf,
    final String name,
    final String desc)
  {
    key3.set(IMETH, ownerItf, name, desc);
    Item result = get(key3);
    if (result == null) {
      put122(IMETH, newClass(ownerItf).index, newNameType(name, desc).index);
      result = new Item(index++, key3);
      put(result);
    }
    return result;
  }

  

  private Item newInteger (final int value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(INT).put4(value);
      result = new Item(index++, key);
      put(result);
    }
    return result;
  }

  

  private Item newFloat (final float value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(FLOAT).put4(Float.floatToIntBits(value));
      result = new Item(index++, key);
      put(result);
    }
    return result;
  }

  

  private Item newLong (final long value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(LONG).put8(value);
      result = new Item(index, key);
      put(result);
      index += 2;
    }
    return result;
  }

  

  private Item newDouble (final double value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(DOUBLE).put8(Double.doubleToLongBits(value));
      result = new Item(index, key);
      put(result);
      index += 2;
    }
    return result;
  }

  

  private Item newString (final String value) {
    key2.set(STR, value, null, null);
    Item result = get(key2);
    if (result == null) {
      pool.put12(STR, newUTF8(value).index);
      result = new Item(index++, key2);
      put(result);
    }
    return result;
  }

  

  private Item newNameType (final String name, final String desc) {
    key2.set(NAME_TYPE, name, desc, null);
    Item result = get(key2);
    if (result == null) {
      put122(NAME_TYPE, newUTF8(name).index, newUTF8(desc).index);
      result = new Item(index++, key2);
      put(result);
    }
    return result;
  }

  

  private Item get (final Item key) {
    Item tab[] = table;
    int hashCode = key.hashCode;
    int index = (hashCode & 0x7FFFFFFF) % tab.length;
    for (Item i = tab[index]; i != null; i = i.next) {
      if (i.hashCode == hashCode && key.isEqualTo(i)) {
        return i;
      }
    }
    return null;
  }

  

  private void put (final Item i) {
    if (index > threshold) {
      int oldCapacity = table.length;
      Item oldMap[] = table;
      int newCapacity = oldCapacity * 2 + 1;
      Item newMap[] = new Item[newCapacity];
      threshold = (int)(newCapacity * 0.75);
      table = newMap;
      for (int j = oldCapacity; j-- > 0; ) {
        for (Item old = oldMap[j]; old != null; ) {
          Item e = old;
          old = old.next;
          int index = (e.hashCode & 0x7FFFFFFF) % newCapacity;
          e.next = newMap[index];
          newMap[index] = e;
        }
      }
    }
    int index = (i.hashCode & 0x7FFFFFFF) % table.length;
    i.next = table[index];
    table[index] = i;
  }

  

  private void put122 (final int b, final int s1, final int s2) {
    pool.put12(b, s1).put2(s2);
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.InstallPanel,15,5,0,27,107,67,17,25,2,0.907142857,564,0.8,4,0.98048048,0.183673469,0,0,35.93333333,3,1.0667,0,"

package org.gjt.sp.jedit.pluginmgr;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.XMLUtilities;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;
import javax.swing.text.html.HTMLEditorKit;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.InputStream;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;



class InstallPanel extends JPanel implements EBComponent
{

	
	private final JTable table;
	private JScrollPane scrollpane;
	private PluginTableModel pluginModel;
	private PluginManager window;
	private PluginInfoBox infoBox;
	private ChoosePluginSet chooseButton;
	private boolean updates;

	private final Set<String> pluginSet = new HashSet<String>();
	

	
	InstallPanel(PluginManager window, boolean updates)
	{
		super(new BorderLayout(12,12));

		this.window = window;
		this.updates = updates;

		setBorder(new EmptyBorder(12,12,12,12));

		final JSplitPane split = new JSplitPane(
			JSplitPane.VERTICAL_SPLIT, jEdit.getBooleanProperty(""appearance.continuousLayout""));
		split.setResizeWeight(0.75);
		
		table = new JTable(pluginModel = new PluginTableModel());
		table.setShowGrid(false);
		table.setIntercellSpacing(new Dimension(0,0));
		table.setRowHeight(table.getRowHeight() + 2);
		table.setPreferredScrollableViewportSize(new Dimension(500,200));
		table.setDefaultRenderer(Object.class, new TextRenderer(
			(DefaultTableCellRenderer)table.getDefaultRenderer(Object.class)));
		table.addFocusListener(new TableFocusHandler());
		InputMap tableInputMap = table.getInputMap(JComponent.WHEN_FOCUSED);
		ActionMap tableActionMap = table.getActionMap();
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0),""tabOutForward"");
		tableActionMap.put(""tabOutForward"",new KeyboardAction(KeyboardCommand.TAB_OUT_FORWARD));
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,InputEvent.SHIFT_MASK),""tabOutBack"");
		tableActionMap.put(""tabOutBack"",new KeyboardAction(KeyboardCommand.TAB_OUT_BACK));
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,0),""editPlugin"");
		tableActionMap.put(""editPlugin"",new KeyboardAction(KeyboardCommand.EDIT_PLUGIN));
		tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""closePluginManager"");
		tableActionMap.put(""closePluginManager"",new KeyboardAction(KeyboardCommand.CLOSE_PLUGIN_MANAGER));

		TableColumn col1 = table.getColumnModel().getColumn(0);
		TableColumn col2 = table.getColumnModel().getColumn(1);
		TableColumn col3 = table.getColumnModel().getColumn(2);
		TableColumn col4 = table.getColumnModel().getColumn(3);
		TableColumn col5 = table.getColumnModel().getColumn(4);

		col1.setPreferredWidth(30);
		col1.setMinWidth(30);
		col1.setMaxWidth(30);
		col1.setResizable(false);

		col2.setPreferredWidth(180);
		col3.setPreferredWidth(130);
		col4.setPreferredWidth(70);
		col5.setPreferredWidth(70);

		JTableHeader header = table.getTableHeader();
		header.setReorderingAllowed(false);
		header.addMouseListener(new HeaderMouseHandler());
		header.setDefaultRenderer(new HeaderRenderer(
			(DefaultTableCellRenderer)header.getDefaultRenderer()));

		scrollpane = new JScrollPane(table);
		scrollpane.getViewport().setBackground(table.getBackground());
		split.setTopComponent(scrollpane);

		
		JScrollPane infoPane = new JScrollPane(
			infoBox = new PluginInfoBox());
		infoPane.setPreferredSize(new Dimension(500,100));
		split.setBottomComponent(infoPane);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				split.setDividerLocation(0.75);
			}
		});

		add(BorderLayout.CENTER,split);

		
		Box buttons = new Box(BoxLayout.X_AXIS);

		buttons.add(new InstallButton());
		buttons.add(Box.createHorizontalStrut(12));
		buttons.add(new SelectallButton());
		buttons.add(chooseButton = new ChoosePluginSet());
		buttons.add(new ClearPluginSet());
		buttons.add(Box.createGlue());
		buttons.add(new SizeLabel());


		add(BorderLayout.SOUTH,buttons);
		String path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET, """");
		if (!path.equals(""""))
		{
			loadPluginSet(path);
		}
	} 

	
	
	boolean loadPluginSet(String path)
	{
		VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path, InstallPanel.this);
		try
		{
			InputStream is = vfs._createInputStream(session, path, false, InstallPanel.this);
			XMLUtilities.parseXML(is, new StringMapHandler());
		}
		catch (Exception e)
		{
			Log.log(Log.WARNING, this, ""Loading Pluginset failed:"" + e.getMessage());
			return false;
		}
		pluginModel.update();
		return true;
	} 

	
	public void updateModel()
	{
		final Set<String> savedChecked = new HashSet<String>();
		final Set<String> savedSelection = new HashSet<String>();
		pluginModel.saveSelection(savedChecked, savedSelection);
		pluginModel.clear();
		infoBox.setText(jEdit.getProperty(""plugin-manager.list-download""));

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				infoBox.setText(null);
				pluginModel.update();
				pluginModel.restoreSelection(savedChecked, savedSelection);
			}
		});
	} 

	
	public void handleMessage(EBMessage message)
	{
		 if (message.getSource() == PluginManager.getInstance())
		 {
			 chooseButton.path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET, """");
			 if (chooseButton.path.length() > 0)
			 {
				 loadPluginSet(chooseButton.path);
				 pluginModel.restoreSelection(new HashSet<String>(), new HashSet<String>());
				 chooseButton.updateUI();
			 }
		}
	} 

	

	
	private static String formatSize(int size)
	{
		NumberFormat df = NumberFormat.getInstance();
		df.setMaximumFractionDigits(1);
		df.setMinimumFractionDigits(0);
		String sizeText;
		if (size < 1048576)
			sizeText = (size >> 10) + ""KB"";
		else
			sizeText = df.format(size/ 1048576.0d) + ""MB"";
		return sizeText;
	} 

	

	

	
	public enum KeyboardCommand
	{
		NONE,
		TAB_OUT_FORWARD,
		TAB_OUT_BACK,
		EDIT_PLUGIN,
		CLOSE_PLUGIN_MANAGER
	} 

	
	private class PluginTableModel extends AbstractTableModel
	{
		
		private List entries = new ArrayList();
		private int sortType = EntryCompare.COLUMN_NAME;
		int sortDirection = 1;

		
		@Override
		public Class getColumnClass(int columnIndex)
		{
			switch (columnIndex)
			{
				case 0: return Boolean.class;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5: return Object.class;
				default: throw new Error(""Column out of range"");
			}
		} 

		
		public int getColumnCount()
		{
			return 6;
		} 

		
		@Override
		public String getColumnName(int column)
		{
			switch (column)
			{
				case 0: return "" "";
				case 1: return ' '+jEdit.getProperty(""install-plugins.info.name"");
				case 2: return ' '+jEdit.getProperty(""install-plugins.info.category"");
				case 3: return ' '+jEdit.getProperty(""install-plugins.info.version"");
				case 4: return ' '+jEdit.getProperty(""install-plugins.info.size"");
				case 5: return ' '+""Release date"";
				default: throw new Error(""Column out of range"");
			}
		} 

		
		public int getRowCount()
		{
			return entries.size();
		} 

		
		public Object getValueAt(int rowIndex,int columnIndex)
		{
			Object obj = entries.get(rowIndex);
			if(obj instanceof String)
			{
				if(columnIndex == 1)
					return obj;
				else
					return null;
			}
			else
			{
				Entry entry = (Entry)obj;

				switch (columnIndex)
				{
					case 0:
						return entry.install;
					case 1:
						return entry.name;
					case 2:
						return entry.set;
					case 3:
						if (updates)
							return entry.installedVersion + ""->"" + entry.version;
						return entry.version;
					case 4:
						return formatSize(entry.size);
					case 5:
						return entry.date;
					default:
						throw new Error(""Column out of range"");
				}
			}
		} 

		
		@Override
		public boolean isCellEditable(int rowIndex, int columnIndex)
		{
			return columnIndex == 0;
		} 

		
		public void setSelectAll(boolean b)
		{
			if(isDownloadingList())
				return;

			int length = getRowCount();
			for (int i = 0; i < length; i++)
			{
				if (b)
					setValueAt(Boolean.TRUE,i,0);
				else
				{
					Entry entry = (Entry)entries.get(i);
					entry.parents = new LinkedList<Entry>();
					entry.install = false;
				}
			}
			fireTableChanged(new TableModelEvent(this));
		} 

		
		public void setSortType(int type)
		{
			sortType = type;
			sort(type);
		} 

		
		private void deselectParents(Entry entry)
		{
			Entry[] parents = entry.getParents();

			if (parents.length == 0)
				return;

			String[] args = { entry.name };

			int result = GUIUtilities.listConfirm(
				window,""plugin-manager.dependency"",
				args,parents);
			if (result != JOptionPane.OK_OPTION)
			{
				entry.install = true;
				return;
			}

			for(int i = 0; i < parents.length; i++)
				 parents[i].install = false;

			fireTableRowsUpdated(0,getRowCount() - 1);
		} 

		
		@Override
		public void setValueAt(Object aValue, int row, int column)
		{
			if (column != 0) return;

			Object obj = entries.get(row);
			if(obj instanceof String)
				return;

			Entry entry = (Entry)obj;
			entry.install = Boolean.TRUE.equals(aValue);

			if (!entry.install)
				deselectParents(entry);

			List<PluginList.Dependency> deps = entry.plugin.getCompatibleBranch().deps;

			for (int i = 0; i < deps.size(); i++)
			{
				PluginList.Dependency dep = deps.get(i);
				if (dep.what.equals(""plugin""))
				{
					for (int j = 0; j < entries.size(); j++)
					{
						Entry temp = (Entry)entries.get(j);
						if (temp.plugin == dep.plugin)
						{
							if (entry.install)
							{
								temp.parents.add(entry);
								setValueAt(Boolean.TRUE,j,0);
							}
							else
								temp.parents.remove(entry);
						}
					}
				}
			}

			fireTableCellUpdated(row,column);
		} 

		
		public void sort(int type)
		{
			Set<String> savedChecked = new HashSet<String>();
			Set<String> savedSelection = new HashSet<String>();
			saveSelection(savedChecked,savedSelection);

			if (sortType != type)
			{
				sortDirection = 1;
			}
			sortType = type;

			if(isDownloadingList())
				return;

			Collections.sort(entries,new EntryCompare(type, sortDirection));
			fireTableChanged(new TableModelEvent(this));
			restoreSelection(savedChecked,savedSelection);
			table.getTableHeader().repaint();
		}
		

		
		private boolean isDownloadingList()
		{
			return entries.size() == 1 && entries.get(0) instanceof String;
		} 

		
		public void clear()
		{
			entries = new ArrayList();
			fireTableChanged(new TableModelEvent(this));
		} 

		
		public void update()
		{
			Set<String> savedChecked = new HashSet<String>();
			Set<String> savedSelection = new HashSet<String>();
			saveSelection(savedChecked,savedSelection);

			PluginList pluginList = window.getPluginList();

			if (pluginList == null) return;

			entries = new ArrayList();

			for(int i = 0; i < pluginList.pluginSets.size(); i++)
			{
				PluginList.PluginSet set = pluginList.pluginSets.get(i);
				for(int j = 0; j < set.plugins.size(); j++)
				{
					PluginList.Plugin plugin = pluginList.pluginHash.get(set.plugins.get(j));
					PluginList.Branch branch = plugin.getCompatibleBranch();
					String installedVersion =
						plugin.getInstalledVersion();
					if (updates)
					{
						if(branch != null
							&& branch.canSatisfyDependencies()
							&& installedVersion != null
							&& StandardUtilities.compareStrings(branch.version,
							installedVersion,false) > 0)
						{
							entries.add(new Entry(plugin, set.name));
						}
					}
					else
					{
						if(installedVersion == null && plugin.canBeInstalled())
							entries.add(new Entry(plugin,set.name));
					}
				}
			}

			sort(sortType);

			fireTableChanged(new TableModelEvent(this));
			restoreSelection(savedChecked, savedSelection);
		} 

		
		public void saveSelection(Set<String> savedChecked, Set<String> savedSelection)
		{
			if (entries.isEmpty())
				return;
			for (int i=0, c=getRowCount() ; i<c ; i++)
			{
				if ((Boolean)getValueAt(i,0))
				{
					savedChecked.add(entries.get(i).toString());
				}
			}
			int[] rows = table.getSelectedRows();
			for (int i=0 ; i<rows.length ; i++)
			{
				savedSelection.add(entries.get(rows[i]).toString());
			}
		} 

		
		public void restoreSelection(Set<String> savedChecked, Set<String> savedSelection)
		{
			for (int i=0, c=getRowCount() ; i<c ; i++)
			{
				String name = entries.get(i).toString();
				if (pluginSet.contains(name))
					setValueAt(true, i, 0);
				else setValueAt(savedChecked.contains(name), i, 0);
			}

			if (null != table)
			{
				table.setColumnSelectionInterval(0,0);
				if (!savedSelection.isEmpty())
				{
					int i = 0;
					int rowCount = getRowCount();
					for ( ; i<rowCount ; i++)
					{
						String name = entries.get(i).toString();
						if (savedSelection.contains(name))
						{
							table.setRowSelectionInterval(i,i);
							break;
						}
					}
					ListSelectionModel lsm = table.getSelectionModel();
					for ( ; i<rowCount ; i++)
					{
						String name = entries.get(i).toString();
						if (savedSelection.contains(name))
						{
							lsm.addSelectionInterval(i,i);
						}
					}
				}
				else
				{
					if (table.getRowCount() != 0)
						table.setRowSelectionInterval(0,0);
					JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
					scrollbar.setValue(scrollbar.getMinimum());
				}
			}
		} 
	} 

	
	private class Entry
	{
		String name, installedVersion, version, author, date, description, set;

		long timestamp;
		int size;
		boolean install;
		PluginList.Plugin plugin;
		List<Entry> parents = new LinkedList<Entry>();

		Entry(PluginList.Plugin plugin, String set)
		{
			PluginList.Branch branch = plugin.getCompatibleBranch();
			boolean downloadSource = jEdit.getBooleanProperty(""plugin-manager.downloadSource"");
			int size = downloadSource ? branch.downloadSourceSize : branch.downloadSize;

			this.name = plugin.name;
			this.author = plugin.author;
			this.installedVersion = plugin.getInstalledVersion();
			this.version = branch.version;
			this.size = size;
			this.date = branch.date;
			this.description = plugin.description;
			this.set = set;
			this.install = false;
			this.plugin = plugin;
			SimpleDateFormat format = new SimpleDateFormat(""d MMMM yyyy"", Locale.ENGLISH);
			try
			{
				timestamp = format.parse(date).getTime();
			}
			catch (ParseException e)
			{
				Log.log(Log.ERROR, this, e);
			}
		}

		private void getParents(List<Entry> list)
		{
			for (Entry entry : parents)
			{
				if (entry.install && !list.contains(entry))
				{
					list.add(entry);
					entry.getParents(list);
				}
			}
		}

		Entry[] getParents()
		{
			List<Entry> list = new ArrayList<Entry>();
			getParents(list);
			Entry[] array = list.toArray(new Entry[list.size()]);
			Arrays.sort(array,new StandardUtilities.StringCompare<Entry>(true));
			return array;
		}

		@Override
		public String toString()
		{
			return name;
		}
	} 

	
	
	private class PluginInfoBox extends JTextPane implements ListSelectionListener
	{
		private final String[] params;
		PluginInfoBox()
		{
			setBackground(jEdit.getColorProperty(""view.bgColor""));
			setForeground(jEdit.getColorProperty(""view.fgColor""));
			putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, true);
			setEditable(false);
			setEditorKit(new HTMLEditorKit());


			params = new String[3];
			table.getSelectionModel().addListSelectionListener(this);
		}


		public void valueChanged(ListSelectionEvent e)
		{
			String text = """";
			if (table.getSelectedRowCount() == 1)
			{
				Entry entry = (Entry) pluginModel.entries
					.get(table.getSelectedRow());
				params[0] = entry.author;
				params[1] = entry.date;
				params[2] = entry.description;
				text = jEdit.getProperty(""install-plugins.info"", params);
				text = text.replace(""\n"", ""<br>"");
				text = ""<html>"" + text + ""</html>"";
			}
			setText(text);
			setCaretPosition(0);
		}
	} 

	
	private class SizeLabel extends JLabel implements TableModelListener
	{
		private int size;

		SizeLabel()
		{
			size = 0;
			setText(jEdit.getProperty(""install-plugins.totalSize"")+formatSize(size));
			pluginModel.addTableModelListener(this);
		}

		public void tableChanged(TableModelEvent e)
		{
			if (e.getType() == TableModelEvent.UPDATE)
			{
				if(pluginModel.isDownloadingList())
					return;

				size = 0;
				int length = pluginModel.getRowCount();
				for (int i = 0; i < length; i++)
				{
					Entry entry = (Entry)pluginModel
						.entries.get(i);
					if (entry.install)
						size += entry.size;
				}
				setText(jEdit.getProperty(""install-plugins.totalSize"")+formatSize(size));
			}
		}
	} 

	
	private class SelectallButton extends JCheckBox implements ActionListener, TableModelListener
	{
		SelectallButton()
		{
			super(jEdit.getProperty(""install-plugins.select-all""));
			addActionListener(this);
			pluginModel.addTableModelListener(this);
			setEnabled(false);
		}

		public void actionPerformed(ActionEvent evt)
		{
			pluginModel.setSelectAll(isSelected());
		}

		public void tableChanged(TableModelEvent e)
		{
			if(pluginModel.isDownloadingList())
				return;

			setEnabled(pluginModel.getRowCount() != 0);
			if (e.getType() == TableModelEvent.UPDATE)
			{
				int length = pluginModel.getRowCount();
				for (int i = 0; i < length; i++)
					if (!((Boolean)pluginModel.getValueAt(i,0)).booleanValue())
					{
						setSelected(false);
						return;
					}
				if (length > 0)
					setSelected(true);
			}
		}
	} 

	
	
	private class StringMapHandler extends DefaultHandler
	{
		StringMapHandler()
		{
			pluginSet.clear();
		}

		@Override
		public void startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException
		{
			if (localName.equals(""plugin""))
			{
				pluginSet.add(attrs.getValue(""name""));
			}
		}
	} 

	
	private class ChoosePluginSet extends RolloverButton implements ActionListener
	{
		private String path;
		
		
		ChoosePluginSet()
		{
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""install-plugins.choose-plugin-set.icon"")));
			addActionListener(this);
			updateUI();
		} 

		
		@Override
		public void updateUI()
		{
			path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET, """");
			if (path.length()<1) setToolTipText (""Click here to choose a predefined plugin set"");
			else setToolTipText (""Choose pluginset ("" + path + ')');
			super.updateUI();
		}

		
		public void actionPerformed(ActionEvent ae)
		{
			path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET,
				jEdit.getSettingsDirectory() + File.separator);
			String[] selectedFiles = GUIUtilities.showVFSFileDialog(InstallPanel.this.window,
				jEdit.getActiveView(), path, VFSBrowser.OPEN_DIALOG, false);
			if (selectedFiles == null || selectedFiles.length != 1) return;
			path = selectedFiles[0];
			boolean success = loadPluginSet(path);
			if (success)
			{
				jEdit.setProperty(PluginManager.PROPERTY_PLUGINSET, path);
			}
			updateUI();
		} 
	}

	
	private class ClearPluginSet extends RolloverButton implements ActionListener
	{
		
		ClearPluginSet()
		{
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""install-plugins.clear-plugin-set.icon"")));
			setToolTipText(""clear plugin set"");
			addActionListener(this);
		} 
		
		
		public void actionPerformed(ActionEvent e)
		{
			pluginSet.clear();
			pluginModel.restoreSelection(new HashSet<String>(), new HashSet<String>());
			jEdit.unsetProperty(PluginManager.PROPERTY_PLUGINSET);
			chooseButton.updateUI();
		} 
	} 

	
	private class InstallButton extends JButton implements ActionListener, TableModelListener
	{
		InstallButton()
		{
			super(jEdit.getProperty(""install-plugins.install""));
			pluginModel.addTableModelListener(this);
			addActionListener(this);
			setEnabled(false);
		}

		public void actionPerformed(ActionEvent evt)
		{
			if(pluginModel.isDownloadingList())
				return;

			boolean downloadSource = jEdit.getBooleanProperty(
				""plugin-manager.downloadSource"");
			boolean installUser = jEdit.getBooleanProperty(
				""plugin-manager.installUser"");
			Roster roster = new Roster();
			String installDirectory;
			if(installUser)
			{
				installDirectory = MiscUtilities.constructPath(
					jEdit.getSettingsDirectory(),""jars"");
			}
			else
			{
				installDirectory = MiscUtilities.constructPath(
					jEdit.getJEditHome(),""jars"");
			}

			int length = pluginModel.getRowCount();
			int instcount = 0;
			for (int i = 0; i < length; i++)
			{
				Entry entry = (Entry)pluginModel.entries.get(i);
				if (entry.install)
				{
					entry.plugin.install(roster,installDirectory,downloadSource);
					if (updates)
						entry.plugin.getCompatibleBranch().satisfyDependencies(
						roster,installDirectory,downloadSource);
					instcount++;
				}
			}

			if(roster.isEmpty())
				return;

			boolean cancel = false;
			if (updates && roster.getOperationCount() > instcount)
				if (GUIUtilities.confirm(window,
					""install-plugins.depend"",
					null,
					JOptionPane.OK_CANCEL_OPTION,
					JOptionPane.WARNING_MESSAGE) == JOptionPane.CANCEL_OPTION)
					cancel = true;

			if (!cancel)
			{
				new PluginManagerProgress(window,roster);

				roster.performOperationsInAWTThread(window);
				pluginModel.update();
			}
		}

		public void tableChanged(TableModelEvent e)
		{
			if(pluginModel.isDownloadingList())
				return;

			if (e.getType() == TableModelEvent.UPDATE)
			{
				int length = pluginModel.getRowCount();
				for (int i = 0; i < length; i++)
					if (((Boolean)pluginModel.getValueAt(i,0)).booleanValue())
					{
						setEnabled(true);
						return;
					}
				setEnabled(false);
			}
		}
	} 

	
	private static class EntryCompare implements Comparator<Entry>
	{
		private static final int COLUMN_INSTALL = 0;
		private static final int COLUMN_NAME = 1;
		private static final int COLUMN_CATEGORY = 2;
		private static final int COLUMN_VERSION = 3;
		private static final int COLUMN_SIZE = 4;
		private static final int COLUMN_RELEASE = 5;

		private int type;

		
		private int sortDirection;

		EntryCompare(int type, int sortDirection)
		{
			this.type = type;
			this.sortDirection = sortDirection;
		}

		public int compare(Entry e1, Entry e2)
		{
			int result;

			switch (type)
			{
				case COLUMN_INSTALL:
					result = (e1.install == e2.install) ? 0 : (e1.install ? 1 : -1);
					break;
				case COLUMN_NAME:
					result = e1.name.compareToIgnoreCase(e2.name);
					break;
				case COLUMN_CATEGORY:
					result = e1.set.compareToIgnoreCase(e2.set);
					if (result == 0)
					{
						result = e1.name.compareToIgnoreCase(e2.name);
					}
					break;
				case COLUMN_VERSION:
					
					
					if (e1.version == e2.version)
					{
						result = 0;
					}
					else if (e1.version == null)
					{
						result = -1;
					}
					else if(e2.version == null)
					{
						result = 1;
					}
					else
					{
						result = StandardUtilities.compareStrings(e1.version,
											  e2.version,
											  true);
					}
					break;
				case COLUMN_SIZE:
					result = (e1.size < e2.size)
						 ? -1
						 : ((e1.size == e2.size)
						    ? 0
						    : 1);
					break;
				case COLUMN_RELEASE:
					result = (e1.timestamp < e2.timestamp)
						 ? -1
						 : ((e1.timestamp == e2.timestamp)
						    ? 0
						    : 1);
					break;
				default:
					result = 0;
			}
			return result * sortDirection;
		}
	} 

	
	private class HeaderMouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			int column = table.getTableHeader().columnAtPoint(evt.getPoint());
			pluginModel.sortDirection *= -1;
			pluginModel.sort(column);
		}
	} 

	
	private static class TextRenderer extends DefaultTableCellRenderer
	{
		private DefaultTableCellRenderer tcr;

		TextRenderer(DefaultTableCellRenderer tcr)
		{
			this.tcr = tcr;
		}

		@Override
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			if (column == 5)
				tcr.setHorizontalAlignment(TRAILING);
			else
				tcr.setHorizontalAlignment(LEADING);
			return tcr.getTableCellRendererComponent(table,value,isSelected,false,row,column);
		}
	} 

	
	private class KeyboardAction extends AbstractAction
	{
		private KeyboardCommand command = KeyboardCommand.NONE;

		KeyboardAction(KeyboardCommand command)
		{
			this.command = command;
		}

		public void actionPerformed(ActionEvent evt)
		{
			switch (command)
			{
			case TAB_OUT_FORWARD:
				KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent();
				break;
			case TAB_OUT_BACK:
				KeyboardFocusManager.getCurrentKeyboardFocusManager().focusPreviousComponent();
				break;
			case EDIT_PLUGIN:
				int[] rows = table.getSelectedRows();
				Object[] state = new Object[rows.length];
				for (int i=0 ; i<rows.length ; i++)
				{
					state[i] = pluginModel.getValueAt(rows[i],0);
				}
				for (int i=0 ; i<rows.length ; i++)
				{
					pluginModel.setValueAt(state[i].equals(Boolean.FALSE),rows[i],0);
				}
				break;
			case CLOSE_PLUGIN_MANAGER:
				window.ok();
				break;
			default:
				throw new InternalError();
			}
		}
	} 

	
	private class TableFocusHandler extends FocusAdapter
	{
		@Override
		public void focusGained(FocusEvent fe)
		{
			if (-1 == table.getSelectedRow() && table.getRowCount() > 0)
			{
				table.setRowSelectionInterval(0,0);
				JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
				scrollbar.setValue(scrollbar.getMinimum());
			}
			if (-1 == table.getSelectedColumn())
			{
				table.setColumnSelectionInterval(0,0);
			}
		}
	} 

	
	private static class HeaderRenderer extends DefaultTableCellRenderer
	{
		private DefaultTableCellRenderer tcr;

		HeaderRenderer(DefaultTableCellRenderer tcr)
		{
			this.tcr = tcr;
		}

		@Override
		public Component getTableCellRendererComponent(JTable table, Object value,
							       boolean isSelected, boolean hasFocus,
							       int row, int column)
		{
			JLabel l = (JLabel)tcr.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
			PluginTableModel model = (PluginTableModel) table.getModel();
			Icon icon = (column == model.sortType)
				? (model.sortDirection == 1) ? ASC_ICON : DESC_ICON
				: null;
			l.setIcon(icon);
			
			return l;
		}
	} 

	

	static final Icon ASC_ICON  = GUIUtilities.loadIcon(""arrow-asc.png"");
	static final Icon DESC_ICON = GUIUtilities.loadIcon(""arrow-desc.png"");	
}
"
jEdit,4.3,org.gjt.sp.jedit.print.BufferPrinter1_4,6,1,0,6,48,0,0,6,4,0.3,290,1.0,0,0.0,0.2,0,0,47.0,8,3.1667,0,"

package org.gjt.sp.jedit.print;


import javax.print.attribute.*;
import javax.print.attribute.standard.*;
import java.awt.print.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class BufferPrinter1_4
{
	
	private static PrinterJob getPrintJob(String jobName)
	{
		job = PrinterJob.getPrinterJob();

		format = new HashPrintRequestAttributeSet();

		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			String printSpecPath = MiscUtilities.constructPath(
				settings, ""printspec"");
			File filePrintSpec = new File(printSpecPath);

			if (filePrintSpec.exists())
			{
				try
				{
					FileInputStream fileIn = new FileInputStream(filePrintSpec);
					ObjectInputStream obIn = new ObjectInputStream(fileIn);
					format = (HashPrintRequestAttributeSet)obIn.readObject();
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,BufferPrinter1_4.class,e);
				}
				
				if(jEdit.getBooleanProperty(""print.color""))
					format.add(Chromaticity.COLOR);
				else
					format.add(Chromaticity.MONOCHROME);

				
				format.add(new JobName(jobName, null));
			}
		}

		return job;
	} 

	
	public static void pageSetup(View view)
	{
		PrinterJob prnJob = getPrintJob(""PageSetupOnly"");
		if(prnJob.pageDialog(format)!=null)
			savePrintSpec();
	} 

	
	public static void print(final View view, final Buffer buffer, boolean selection)
	{
		job = getPrintJob(buffer.getPath());

		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = jEdit.getFontProperty(""print.font"");

		BufferPrintable printable = new BufferPrintable(job,format,view,
			buffer,font,header,footer,lineNumbers,color);
		job.setPrintable(printable);

		if(!job.printDialog(format))
			return;

		savePrintSpec();

		printable.print();
	} 

	
	public static PageFormat getPageFormat()
	{
		
		PrinterJob prnJob=getPrintJob("" "");
		PageFormat pf=prnJob.defaultPage();
		Paper pap=pf.getPaper();

		MediaSizeName media=(MediaSizeName)format.get(
		                            Media.class);
		MediaSize ms=MediaSize.getMediaSizeForName(media);

		MediaPrintableArea mediaarea=(MediaPrintableArea)format.get(
		                                     MediaPrintableArea.class);
		if(mediaarea!=null)
			pap.setImageableArea((mediaarea.getX(MediaPrintableArea.INCH)*72),
			                     (mediaarea.getY(MediaPrintableArea.INCH)*72),
			                     (mediaarea.getWidth(MediaPrintableArea.INCH)*72),
			                     (mediaarea.getHeight(MediaPrintableArea.INCH)*72));
		if(ms!=null)
			pap.setSize((ms.getX(MediaSize.INCH)*72),
			            (ms.getY(MediaSize.INCH)*72));
		pf.setPaper(pap);

		OrientationRequested orientation=(OrientationRequested)format.get(
		                                         OrientationRequested.class);
		if(orientation!=null)
		{
			if(orientation.getValue()==OrientationRequested.LANDSCAPE.getValue())
			{
				pf.setOrientation(PageFormat.LANDSCAPE);
			}
			else if(orientation.getValue()==OrientationRequested.REVERSE_LANDSCAPE.getValue())
			{
				pf.setOrientation(PageFormat.REVERSE_LANDSCAPE);
			}
			else if(orientation.getValue()==OrientationRequested.PORTRAIT.getValue())
			{
				pf.setOrientation(PageFormat.PORTRAIT);
			}
			else if(orientation.getValue()==OrientationRequested.REVERSE_PORTRAIT.getValue())
			{
				
				
				
				pf.setOrientation(PageFormat.PORTRAIT);
			}
		}
		return pf;
	} 

	
	private static void savePrintSpec()
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
			return;

		String printSpecPath = MiscUtilities.constructPath(
			settings, ""printspec"");
		File filePrintSpec = new File(printSpecPath);

		try
		{
			FileOutputStream fileOut=new FileOutputStream(filePrintSpec);
			ObjectOutputStream obOut=new ObjectOutputStream(fileOut);
			obOut.writeObject(format);
			
			Chromaticity cc=(Chromaticity)format.get(Chromaticity.class);
			if (cc!=null)
				jEdit.setBooleanProperty(""print.color"",
					cc.getValue()==Chromaticity.COLOR.getValue());
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	

	
	private static PrintRequestAttributeSet format;
	private static PrinterJob job;
	
}

"
jEdit,4.3,org.gjt.sp.jedit.options.ToolBarOptionPane,16,6,0,10,72,74,2,10,1,0.833333333,557,1.0,6,0.978070175,0.375,2,4,33.1875,8,1.9375,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;




public class ToolBarOptionPane extends AbstractOptionPane
{
	
	public ToolBarOptionPane()
	{
		super(""toolbar"");
	} 

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JPanel panel = new JPanel(new GridLayout(2,1));

		
		showToolbar = new JCheckBox(jEdit.getProperty(
			""options.toolbar.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""view.showToolbar""));
		panel.add(showToolbar);

		panel.add(new JLabel(jEdit.getProperty(
			""options.toolbar.caption"")));

		add(BorderLayout.NORTH,panel);

		listModel = new DefaultListModel();
		reloadButtonList(jEdit.getProperty(""view.toolbar""));
		
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		list.setCellRenderer(new ButtonCellRenderer());

		add(BorderLayout.CENTER,new JScrollPane(list));

		
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.toolbar.add.icon"")));
		add.setToolTipText(jEdit.getProperty(""options.toolbar.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.toolbar.remove.icon"")));
		remove.setToolTipText(jEdit.getProperty(""options.toolbar.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.toolbar.moveUp.icon"")));
		moveUp.setToolTipText(jEdit.getProperty(""options.toolbar.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.toolbar.moveDown.icon"")));
		moveDown.setToolTipText(jEdit.getProperty(""options.toolbar.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createHorizontalStrut(6));
		edit = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.toolbar.edit.icon"")));
		edit.setToolTipText(jEdit.getProperty(""options.toolbar.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());
		
		
		reset = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.toolbar.reset.icon"")));
		reset.setToolTipText(jEdit.getProperty(""options.toolbar.reset""));
		reset.addActionListener(actionHandler);
		buttons.add(reset);
		

		updateButtons();
		add(BorderLayout.SOUTH,buttons);

		
		iconList = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""icons""));
		while(st.hasMoreElements())
		{
			String icon = st.nextToken();
			iconList.addElement(new IconListEntry(
				GUIUtilities.loadIcon(icon),icon));
		} 
	} 

	
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.showToolbar"",showToolbar
			.isSelected());

		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			Button button = (Button)listModel.elementAt(i);
			buf.append(button.actionName);
			jEdit.setProperty(button.actionName + "".icon"",button.iconName);
		}
		jEdit.setProperty(""view.toolbar"",buf.toString());
	} 

	

	
	private JCheckBox showToolbar;
	private DefaultListModel listModel;
	private JList list;
	private RolloverButton add;
	private RolloverButton remove;
	private RolloverButton moveUp, moveDown;
	private RolloverButton edit;
	private RolloverButton reset;

	private DefaultComboBoxModel iconList;
	

	
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
		edit.setEnabled(index != -1);
	} 
	
	
	private void reloadButtonList(String toolbar)
	{
		StringTokenizer st = new StringTokenizer(toolbar);
		listModel.clear();
		
		while(st.hasMoreTokens())
		{
			String actionName = st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ToolBarOptionPane.Button(""-"",null,null,""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;

				Icon icon;
				String iconName;
				if(actionName.equals(""-""))
				{
					iconName = null;
					icon = null;
				}
				else
				{
					iconName = jEdit.getProperty(actionName + "".icon"");
					if(iconName == null)
						icon = GUIUtilities.loadIcon(jEdit.getProperty(""broken-image.icon""));
					else
					{
						icon = GUIUtilities.loadIcon(iconName);
						if(icon == null)
							icon = GUIUtilities.loadIcon(jEdit.getProperty(""broken-image.icon""));
					}
				}
				listModel.addElement(new Button(actionName,iconName,icon,label));
			}
		}
	}
	
	
	

	

	
	static class ButtonCompare implements Comparator<Button>
	{
		public int compare(Button button1, Button button2)
		{
			return StandardUtilities.compareStrings(
				button1.label,
				button2.label,
				true);
		}
	} 

	
	static class Button
	{
		String actionName;
		String iconName;
		Icon icon;
		String label;

		Button(String actionName, String iconName, Icon icon, String label)
		{
			this.actionName = actionName;
			this.iconName = iconName;
			this.icon = icon;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}

		public String toString()
		{
			return label;
		}

		public boolean equals(Object o)
		{
			if(o instanceof Button)
				return ((Button)o).actionName.equals(actionName);
			else
				return false;
		}
	} 

	
	static class IconListEntry
	{
		Icon icon;
		String name;

		IconListEntry(Icon icon, String name)
		{
			this.icon = icon;
			this.name = name;
		}

		public String toString()
		{
			return name;
		}
	} 

	
	static class ButtonCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			Button button = (Button)value;
			setIcon(button.icon);

			return this;
		}
	} 

	
	static class IconCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			IconListEntry icon = (IconListEntry)value;
			setIcon(icon.icon);

			return this;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == add)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,null);
				Button selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;

				listModel.insertElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				if(listModel.getSize() != 0)
				{
					if(listModel.getSize() == index)
						list.setSelectedIndex(index-1);
					else
						list.setSelectedIndex(index);
				}
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
			else if(source == edit)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,
					(Button)list.getSelectedValue());
				Button selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();

				listModel.setElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == reset)
			{
				String dialogType = ""options.toolbar.reset.dialog"";
				int result = GUIUtilities.confirm(list,dialogType,null,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				
				if(result == JOptionPane.YES_OPTION)
				{
					
					
					
					
					String orgToolbar = jEdit.getProperty(""view.toolbar"");
					jEdit.resetProperty(""view.toolbar"");
					String defaultToolbar = jEdit.getProperty(""view.toolbar"");
					jEdit.setProperty(""view.toolbar"", orgToolbar);
					reloadButtonList(defaultToolbar);
					
					
					list.setSelectedIndex(0);
					list.ensureIndexIsVisible(0);
					updateButtons();
				}
			}
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	} 

	
} 


class ToolBarEditDialog extends EnhancedDialog
{
	
	public ToolBarEditDialog(Component comp,
		DefaultComboBoxModel iconListModel,
		ToolBarOptionPane.Button current)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""options.toolbar.edit.title""),
			true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();

		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.toolbar.edit.caption"")));

		separator = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);

		action = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		typePanel.add(action);

		content.add(BorderLayout.NORTH,typePanel);

		JPanel actionPanel = new JPanel(new BorderLayout(6,6));

		ActionSet[] actionsList = jEdit.getActionSets();
		String selectedActionSet = jEdit.getProperty(""options.toolbar.selectedActionSet"");
		ActionSet selectedItem = null;
		Vector<ActionSet> vec = new Vector<ActionSet>(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
			{
				vec.add(actionSet);
				if (actionSet.getLabel().equals(selectedActionSet))
				{
					selectedItem = actionSet;
				}
			}
		}
		combo = new JComboBox(vec);
		if (selectedItem != null)
			combo.setSelectedItem(selectedItem);
		else
			jEdit.unsetProperty(""options.toolbar.selectedActionSet"");
		combo.addActionListener(actionHandler);

		actionPanel.add(BorderLayout.NORTH,combo);

		list = new JList();
		list.setVisibleRowCount(8);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));

		
		JPanel iconPanel = new JPanel(new BorderLayout(0,3));
		JPanel labelPanel = new JPanel(new GridLayout(2,1));
		labelPanel.setBorder(new EmptyBorder(0,0,0,12));
		JPanel compPanel = new JPanel(new GridLayout(2,1));
		grp = new ButtonGroup();
		labelPanel.add(builtin = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.builtin"")));
		builtin.addActionListener(actionHandler);
		grp.add(builtin);
		labelPanel.add(file = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.file"")));
		grp.add(file);
		file.addActionListener(actionHandler);
		iconPanel.add(BorderLayout.WEST,labelPanel);
		builtinCombo = new JComboBox(iconListModel);
		builtinCombo.setRenderer(new ToolBarOptionPane.IconCellRenderer());
		compPanel.add(builtinCombo);

		fileButton = new JButton(jEdit.getProperty(""options.toolbar.edit.no-icon""));
		fileButton.setMargin(new Insets(1,1,1,1));
		fileButton.setIcon(GUIUtilities.loadIcon(""Blank24.gif""));
		fileButton.setHorizontalAlignment(SwingConstants.LEFT);
		fileButton.addActionListener(actionHandler);
		compPanel.add(fileButton);
		iconPanel.add(BorderLayout.CENTER,compPanel);
		actionPanel.add(BorderLayout.SOUTH,iconPanel);

		content.add(BorderLayout.CENTER,actionPanel);

		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,southPanel);

		if(current == null)
		{
			action.setSelected(true);
			builtin.setSelected(true);
			updateList();
		}
		else
		{
			if(current.actionName.equals(""-""))
			{
				separator.setSelected(true);
				builtin.setSelected(true);
			}
			else
			{
				action.setSelected(true);
				ActionSet set = jEdit.getActionSetForAction(
					current.actionName);
				combo.setSelectedItem(set);
				updateList();
				list.setSelectedValue(current,true);

				if(MiscUtilities.isURL(current.iconName))
				{
					file.setSelected(true);
					fileIcon = current.iconName;
					try
					{
						fileButton.setIcon(new ImageIcon(new URL(
							fileIcon)));
					}
					catch(MalformedURLException mf)
					{
						Log.log(Log.ERROR,this,mf);
					}
					fileButton.setText(MiscUtilities.getFileName(fileIcon));
				}
				else
				{
					builtin.setSelected(true);
					ListModel model = builtinCombo.getModel();
					for(int i = 0; i < model.getSize(); i++)
					{
						ToolBarOptionPane.IconListEntry entry
							= (ToolBarOptionPane.IconListEntry)
							model.getElementAt(i);
						if(entry.name.equals(current.iconName))
						{
							builtinCombo.setSelectedIndex(i);
							break;
						}
					}
				}
			}
		}

		updateEnabled();

		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		setVisible(true);
	} 

	
	public void ok()
	{
		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public ToolBarOptionPane.Button getSelection()
	{
		if(!isOK)
			return null;

		if(separator.isSelected())
			return new ToolBarOptionPane.Button(""-"",null,null,""-"");
		else
		{
			Icon icon;
			String iconName;
			if(builtin.isSelected())
			{
				ToolBarOptionPane.IconListEntry selectedIcon =
					(ToolBarOptionPane.IconListEntry)
					builtinCombo.getSelectedItem();
				icon = selectedIcon.icon;
				iconName = selectedIcon.name;
			}
			else
			{
				icon = fileButton.getIcon();
				iconName = fileIcon;
				if(iconName == null)
					iconName = ""Blank24.gif"";
			}

			String label;
			String actionName;
			if(action.isSelected())
			{
				ToolBarOptionPane.Button button =
					(ToolBarOptionPane.Button)list
					.getSelectedValue();
				label = button.label;
				actionName = button.actionName;
			}
			else
				throw new InternalError();

			return new ToolBarOptionPane.Button(actionName,
				iconName,icon,label);
		}
	} 

	

	
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JRadioButton builtin;
	private JComboBox builtinCombo;
	private JRadioButton file;
	private JButton fileButton;
	private String fileIcon;
	private JButton ok, cancel;
	

	
	private void updateEnabled()
	{
		combo.setEnabled(action.isSelected());
		list.setEnabled(action.isSelected());

		boolean iconControlsEnabled = !separator.isSelected();
		builtin.setEnabled(iconControlsEnabled);
		file.setEnabled(iconControlsEnabled);
		builtinCombo.setEnabled(iconControlsEnabled && builtin.isSelected());
		fileButton.setEnabled(iconControlsEnabled && file.isSelected());
	} 

	
	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		String actionSetLabel = actionSet.getLabel();
		jEdit.setProperty(""options.toolbar.selectedActionSet"", actionSetLabel);
		EditAction[] actions = actionSet.getActions();
		Vector<ToolBarOptionPane.Button> listModel = new Vector<ToolBarOptionPane.Button>(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;

			listModel.add(new ToolBarOptionPane.Button(
				action.getName(),null,null,label));
		}

		Collections.sort(listModel,new ToolBarOptionPane.ButtonCompare());
		list.setListData(listModel);
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
				updateEnabled();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
			else if(source == fileButton)
			{
				String directory;
				if(fileIcon == null)
					directory = null;
				else
					directory = MiscUtilities.getParentOfPath(fileIcon);
				String[] paths = GUIUtilities.showVFSFileDialog(null,directory,
					VFSBrowser.OPEN_DIALOG,false);
				if(paths == null)
					return;

				fileIcon = ""file:"" + paths[0];

				try
				{
					fileButton.setIcon(new ImageIcon(new URL(
						fileIcon)));
				}
				catch(MalformedURLException mf)
				{
					Log.log(Log.ERROR,this,mf);
				}
				fileButton.setText(MiscUtilities.getFileName(fileIcon));
			}
		}
	} 
} 
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableWindow,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"package org.gjt.sp.jedit.gui;



public interface DockableWindow {
	
	
	void move(String newPosition);
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Parser,351,1,0,51,443,41713,1,51,88,0.602857143,12535,0.538461538,8,0.0,0.126305793,0,0,34.67521368,18,2.8091,0,"
package org.gjt.sp.jedit.bsh;

import java.io.*;


public class Parserimplements ParserTreeConstants, ParserConstants {
  protected JJTParserState jjtree = new JJTParserState();boolean retainComments = false;

        public void setRetainComments( boolean b ) {
                retainComments = b;
        }

        void jjtreeOpenNodeScope(Node n) {
                ((SimpleNode)n).firstToken = getToken(1);
        }

        void jjtreeCloseNodeScope(Node n) {
                ((SimpleNode)n).lastToken = getToken(0);
        }

        
        void reInitInput( Reader in ) {
                ReInit(in);
        }

        public SimpleNode popNode()
        {
                if ( jjtree.nodeArity() > 0)  
                        return (SimpleNode)jjtree.popNode();
                else
                        return null;
        }

        
        void reInitTokenInput( Reader in ) {
                jj_input_stream.ReInit( in,
                        jj_input_stream.getEndLine(),
                        jj_input_stream.getEndColumn() );
        }

        public static void main( String [] args )
                throws IOException, ParseException
        {
                boolean print = false;
                int i=0;
                if ( args[0].equals(""-p"") ) {
                        i++;
                        print=true;
                }
                for(; i< args.length; i++) {
                        Reader in = new FileReader(args[i]);
                        Parser parser = new Parser(in);
                        parser.setRetainComments(true);
                        while( !parser.Line() )
                                if ( print )
                                        System.out.println( parser.popNode() );
                }
        }

        
        boolean isRegularForStatement()
        {
                int curTok = 1;
                Token tok;
                tok = getToken(curTok++);
                if ( tok.kind != FOR ) return false;
                tok = getToken(curTok++);
                if ( tok.kind != LPAREN ) return false;
                while (true)
                {
                        tok = getToken(curTok++);
                        switch (tok.kind) {
                                case COLON:
                                        return false;
                                case SEMICOLON:
                                        return true;
                                case EOF:
                                        return false;
                        }
                }
        }

        
        ParseException createParseException( String message )
        {
                Token errortok = token;
                int line = errortok.beginLine, column = errortok.beginColumn;
                String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
                return new ParseException( ""Parse error at line "" + line
                        + "", column "" + column + "" : "" + message );
        }


  final public boolean Line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
        Interpreter.debug(""End of File!"");
        {if (true) return true;}
      break;
    default:
      if (jj_2_1(1)) {
        BlockStatement();
        {if (true) return false;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error(""Missing return statement in function"");
  }




  final public Modifiers Modifiers(int context, boolean lookahead) throws ParseException {
        Modifiers mods = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                if ( !lookahead )
                        try {
                                if ( mods == null ) mods = new Modifiers();
                                mods.addModifier( context, getToken(0).image );
                        } catch ( IllegalStateException e ) {
                                {if (true) throw createParseException( e.getMessage() );}
                        }
    }
        {if (true) return mods;}
    throw new Error(""Missing return statement in function"");
  }


  final public void ClassDeclaration() throws ParseException {
 
        BSHClassDeclaration jjtn000 = new BSHClassDeclaration(JJTCLASSDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Modifiers mods;
        Token name;
        int numInterfaces;
    try {
      mods = Modifiers(Modifiers.CLASS, false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        jj_consume_token(CLASS);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
                                  jjtn000.isInterface=true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      name = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        AmbiguousName();
                                      jjtn000.extend = true;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLEMENTS:
        jj_consume_token(IMPLEMENTS);
        numInterfaces = NameList();
                  jjtn000.numInterfaces=numInterfaces;
        break;
      default:
        ;
      }
      Block();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.modifiers = mods;
                jjtn000.name = name.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void MethodDeclaration() throws ParseException {
 
        BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
        int count;
    try {
      mods = Modifiers(Modifiers.METHOD, false);
                                                      jjtn000.modifiers = mods;
      if (jj_2_2(2147483647)) {
        t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case VOID:
        case IDENTIFIER:
          ReturnType();
          t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        count = NameList();
                                      jjtn000.numThrows=count;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void PackageDeclaration() throws ParseException {
 
  BSHPackageDeclaration jjtn000 = new BSHPackageDeclaration(JJTPACKAGEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(PACKAGE);
      AmbiguousName();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void ImportDeclaration() throws ParseException {
 
    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token s = null;
        Token t = null;
    try {
      if (jj_2_3(3)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC:
          s = jj_consume_token(STATIC);
          break;
        default:
          ;
        }
        jj_consume_token(IMPORT);
        AmbiguousName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          t = jj_consume_token(DOT);
          jj_consume_token(STAR);
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
                if ( s != null ) jjtn000.staticImport = true;
                if ( t != null ) jjtn000.importPackage = true;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          jj_consume_token(IMPORT);
          jj_consume_token(STAR);
          jj_consume_token(SEMICOLON);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                jjtn000.superImport = true;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void VariableDeclarator() throws ParseException {
 
        BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        VariableInitializer();
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.name = t.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }


  final public void VariableInitializer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      Expression();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ArrayInitializer() throws ParseException {
 
  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        VariableInitializer();
        label_2:
        while (true) {
          if (jj_2_4(2)) {
            ;
          } else {
            break label_2;
          }
          jj_consume_token(COMMA);
          VariableInitializer();
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        ;
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void FormalParameters() throws ParseException {
 
  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        FormalParameter();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_3;
          }
          jj_consume_token(COMMA);
          FormalParameter();
        }
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void FormalParameter() throws ParseException {
 
  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      if (jj_2_5(2)) {
        Type();
        t = jj_consume_token(IDENTIFIER);
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                       jjtreeCloseNodeScope(jjtn000);
                                       jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                   jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }


  final public void Type() throws ParseException {
 
  BSHType jjtn000 = new BSHType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        PrimitiveType();
        break;
      case IDENTIFIER:
        AmbiguousName();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        if (jj_2_6(2)) {
          ;
        } else {
          break label_4;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                                 jjtn000.addArrayDimension();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }


  final public void ReturnType() throws ParseException {
 
  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        jj_consume_token(VOID);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.isVoid = true;
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        Type();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void PrimitiveType() throws ParseException {
 
  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtreeCloseNodeScope(jjtn000);
              jjtn000.type = Boolean.TYPE;
        break;
      case CHAR:
        jj_consume_token(CHAR);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Character.TYPE;
        break;
      case BYTE:
        jj_consume_token(BYTE);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Byte.TYPE;
        break;
      case SHORT:
        jj_consume_token(SHORT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Short.TYPE;
        break;
      case INT:
        jj_consume_token(INT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.type =  Integer.TYPE;
        break;
      case LONG:
        jj_consume_token(LONG);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Long.TYPE;
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Float.TYPE;
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.type =  Double.TYPE;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void AmbiguousName() throws ParseException {
 
    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t;
    StringBuilder s;
    try {
      t = jj_consume_token(IDENTIFIER);
        s = new StringBuilder(t.image);
      label_5:
      while (true) {
        if (jj_2_7(2)) {
          ;
        } else {
          break label_5;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
                                        s.append("".""+t.image);
      }
                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                      jjtc000 = false;
                                                                      jjtreeCloseNodeScope(jjtn000);
        jjtn000.text = s.toString();
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public int NameList() throws ParseException {
  int count = 0;
    AmbiguousName();
                    ++count;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_6;
      }
      jj_consume_token(COMMA);
      AmbiguousName();
                                                       ++count;
    }
    {if (true) return count;}
    throw new Error(""Missing return statement in function"");
  }


  final public void Expression() throws ParseException {
    if (jj_2_8(2147483647)) {
      Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ConditionalExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void Assignment() throws ParseException {
 
  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);int op ;
    try {
      PrimaryExpression();
      op = AssignmentOperator();
                                    jjtn000.operator = op;
      Expression();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public int AssignmentOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
      break;
    case MODASSIGN:
      jj_consume_token(MODASSIGN);
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
      break;
    case LSHIFTASSIGNX:
      jj_consume_token(LSHIFTASSIGNX);
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGNX:
      jj_consume_token(RSIGNEDSHIFTASSIGNX);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGNX:
      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        t = getToken(0);
        {if (true) return t.kind;}
    throw new Error(""Missing return statement in function"");
  }

  final public void ConditionalExpression() throws ParseException {
    ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      Expression();
      jj_consume_token(COLON);
                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
        ConditionalExpression();
      } catch (Throwable jjte001) {
                                                     if (jjtc001) {
                                                       jjtree.clearNodeScope(jjtn001);
                                                       jjtc001 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte001 instanceof RuntimeException) {
                                                       {if (true) throw (RuntimeException)jjte001;}
                                                     }
                                                     if (jjte001 instanceof ParseException) {
                                                       {if (true) throw (ParseException)jjte001;}
                                                     }
                                                     {if (true) throw (Error)jjte001;}
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  3);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
      break;
    default:
      ;
    }
  }

  final public void ConditionalOrExpression() throws ParseException {
  Token t=null;
    ConditionalAndExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
      case BOOL_ORX:
        ;
        break;
      default:
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
        t = jj_consume_token(BOOL_OR);
        break;
      case BOOL_ORX:
        t = jj_consume_token(BOOL_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ConditionalAndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }

  final public void ConditionalAndExpression() throws ParseException {
  Token t=null;
    InclusiveOrExpression();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
      case BOOL_ANDX:
        ;
        break;
      default:
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
        t = jj_consume_token(BOOL_AND);
        break;
      case BOOL_ANDX:
        t = jj_consume_token(BOOL_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }

  final public void InclusiveOrExpression() throws ParseException {
  Token t=null;
    ExclusiveOrExpression();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
      case BIT_ORX:
        ;
        break;
      default:
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_ORX:
        t = jj_consume_token(BIT_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ExclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }

  final public void ExclusiveOrExpression() throws ParseException {
  Token t=null;
    AndExpression();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        break label_10;
      }
      t = jj_consume_token(XOR);
      AndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }

  final public void AndExpression() throws ParseException {
  Token t=null;
    EqualityExpression();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
      case BIT_ANDX:
        ;
        break;
      default:
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        t = jj_consume_token(BIT_AND);
        break;
      case BIT_ANDX:
        t = jj_consume_token(BIT_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      EqualityExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }

  final public void EqualityExpression() throws ParseException {
  Token t = null;
    InstanceOfExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InstanceOfExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }

  final public void InstanceOfExpression() throws ParseException {
  Token t = null;
    RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      t = jj_consume_token(INSTANCEOF);
      Type();
                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                              jjtreeCloseNodeScope(jjtn001);
                              jjtn001.kind = t.kind;
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtreeCloseNodeScope(jjtn001);
                              }
      }
      break;
    default:
      ;
    }
  }

  final public void RelationalExpression() throws ParseException {
  Token t = null;
    ShiftExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GTX:
      case LT:
      case LTX:
      case LE:
      case LEX:
      case GE:
      case GEX:
        ;
        break;
      default:
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        break;
      case LTX:
        t = jj_consume_token(LTX);
        break;
      case GT:
        t = jj_consume_token(GT);
        break;
      case GTX:
        t = jj_consume_token(GTX);
        break;
      case LE:
        t = jj_consume_token(LE);
        break;
      case LEX:
        t = jj_consume_token(LEX);
        break;
      case GE:
        t = jj_consume_token(GE);
        break;
      case GEX:
        t = jj_consume_token(GEX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ShiftExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }

  final public void ShiftExpression() throws ParseException {
  Token t = null;
    AdditiveExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case LSHIFTX:
      case RSIGNEDSHIFT:
      case RSIGNEDSHIFTX:
      case RUNSIGNEDSHIFT:
      case RUNSIGNEDSHIFTX:
        ;
        break;
      default:
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        t = jj_consume_token(LSHIFT);
        break;
      case LSHIFTX:
        t = jj_consume_token(LSHIFTX);
        break;
      case RSIGNEDSHIFT:
        t = jj_consume_token(RSIGNEDSHIFT);
        break;
      case RSIGNEDSHIFTX:
        t = jj_consume_token(RSIGNEDSHIFTX);
        break;
      case RUNSIGNEDSHIFT:
        t = jj_consume_token(RUNSIGNEDSHIFT);
        break;
      case RUNSIGNEDSHIFTX:
        t = jj_consume_token(RUNSIGNEDSHIFTX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      AdditiveExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }

  final public void AdditiveExpression() throws ParseException {
  Token t = null;
    MultiplicativeExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      MultiplicativeExpression();
                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                     jjtreeCloseNodeScope(jjtn001);
                                                     jjtn001.kind = t.kind;
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
    }
  }

  final public void MultiplicativeExpression() throws ParseException {
  Token t = null;
    UnaryExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case MOD:
        ;
        break;
      default:
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        t = jj_consume_token(STAR);
        break;
      case SLASH:
        t = jj_consume_token(SLASH);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtreeOpenNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  2);
                      jjtc001 = false;
                      jjtreeCloseNodeScope(jjtn001);
                      jjtn001.kind = t.kind;
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                        jjtreeCloseNodeScope(jjtn001);
                      }
      }
    }
  }

  final public void UnaryExpression() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case INCR:
      PreIncrementExpression();
      break;
    case DECR:
      PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
      UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PreIncrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(INCR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }

  final public void PreDecrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(DECR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }

  final public void UnaryExpressionNotPlusMinus() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        t = jj_consume_token(TILDE);
        break;
      case BANG:
        t = jj_consume_token(BANG);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    default:
      if (jj_2_9(2147483647)) {
        CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          PostfixExpression();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }


  final public void CastLookahead() throws ParseException {
    if (jj_2_10(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_11(2147483647)) {
      jj_consume_token(LPAREN);
      AmbiguousName();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        AmbiguousName();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
          Literal();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void PostfixExpression() throws ParseException {
  Token t = null;
    if (jj_2_12(2147483647)) {
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        t = jj_consume_token(INCR);
        break;
      case DECR:
        t = jj_consume_token(DECR);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                                jjtreeOpenNodeScope(jjtn001);
      try {
                                jjtree.closeNodeScope(jjtn001,  1);
                                jjtc001 = false;
                                jjtreeCloseNodeScope(jjtn001);
                jjtn001.kind = t.kind; jjtn001.postfix = true;
      } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  1);
                                  jjtreeCloseNodeScope(jjtn001);
                                }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        PrimaryExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void CastExpression() throws ParseException {
 
  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_13(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        UnaryExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          UnaryExpressionNotPlusMinus();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void PrimaryExpression() throws ParseException {
                                               
  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      PrimaryPrefix();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case LBRACKET:
        case DOT:
          ;
          break;
        default:
          break label_17;
        }
        PrimarySuffix();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void MethodInvocation() throws ParseException {
                                             
  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      AmbiguousName();
      Arguments();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  final public void PrimaryPrefix() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      Literal();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      break;
    case NEW:
      AllocationExpression();
      break;
    default:
      if (jj_2_14(2147483647)) {
        MethodInvocation();
      } else if (jj_2_15(2147483647)) {
        Type();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          AmbiguousName();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void PrimarySuffix() throws ParseException {
 
    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_16(2)) {
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.CLASS;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.INDEX;
          break;
        case DOT:
          jj_consume_token(DOT);
          t = jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            Arguments();
            break;
          default:
            ;
          }
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.NAME;
        jjtn000.field = t.image;
          break;
        case LBRACE:
          jj_consume_token(LBRACE);
          Expression();
          jj_consume_token(RBRACE);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.PROPERTY;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void Literal() throws ParseException {
 
    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token x;
    boolean b;
    String literal;
    char ch;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        x = jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'l' || ch == 'L')
    {
        literal = literal.substring(0,literal.length()-1);

        
        
        jjtn000.value = new Primitive( new Long( literal ).longValue() );
    }
    else
                try {
                jjtn000.value = new Primitive(
                                Integer.decode( literal ).intValue() );
                } catch ( NumberFormatException e ) {
                        {if (true) throw createParseException(
                                ""Error or number too big for integer type: ""+ literal );}
                }
        break;
      case FLOATING_POINT_LITERAL:
        x = jj_consume_token(FLOATING_POINT_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'f' || ch == 'F')
    {
        literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Float( literal ).floatValue() );
    }
    else
    {
        if(ch == 'd' || ch == 'D')
            literal = literal.substring(0,literal.length()-1);

        jjtn000.value = new Primitive( new Double( literal ).doubleValue() );
    }
        break;
      case CHARACTER_LITERAL:
        x = jj_consume_token(CHARACTER_LITERAL);
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtreeCloseNodeScope(jjtn000);
                try {
                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException(""Error parsing character: ""+x.image);}
                }
        break;
      case STRING_LITERAL:
        x = jj_consume_token(STRING_LITERAL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException(""Error parsing string: ""+x.image);}
                }
        break;
      case FALSE:
      case TRUE:
        b = BooleanLiteral();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = new Primitive( b );
        break;
      case NULL:
        NullLiteral();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.NULL;
        break;
      case VOID:
        VoidLiteral();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.VOID;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public boolean BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
           {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return false;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error(""Missing return statement in function"");
  }

  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }

  final public void VoidLiteral() throws ParseException {
    jj_consume_token(VOID);
  }

  final public void Arguments() throws ParseException {
 
  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }


  final public void ArgumentList() throws ParseException {
    Expression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_18;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }

  final public void AllocationExpression() throws ParseException {
 
  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_18(2)) {
        jj_consume_token(NEW);
        PrimitiveType();
        ArrayDimensions();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          jj_consume_token(NEW);
          AmbiguousName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ArrayDimensions();
            break;
          case LPAREN:
            Arguments();
            if (jj_2_17(2)) {
              Block();
            } else {
              ;
            }
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ArrayDimensions() throws ParseException {
 
  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_21(2)) {
        label_19:
        while (true) {
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                                        jjtn000.addDefinedDimension();
          if (jj_2_19(2)) {
            ;
          } else {
            break label_19;
          }
        }
        label_20:
        while (true) {
          if (jj_2_20(2)) {
            ;
          } else {
            break label_20;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
                           jjtn000.addUndefinedDimension();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          label_21:
          while (true) {
            jj_consume_token(LBRACKET);
            jj_consume_token(RBRACKET);
              jjtn000.addUndefinedDimension();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACKET:
              ;
              break;
            default:
              break label_21;
            }
          }
          ArrayInitializer();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }


  final public void Statement() throws ParseException {
    if (jj_2_22(2)) {
      LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        EmptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpression();
        jj_consume_token(SEMICOLON);
        break;
      case SWITCH:
        SwitchStatement();
        break;
      case IF:
        IfStatement();
        break;
      case WHILE:
        WhileStatement();
        break;
      case DO:
        DoStatement();
        break;
      default:
        if (isRegularForStatement()) {
          ForStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FOR:
            EnhancedForStatement();
            break;
          case BREAK:
            BreakStatement();
            break;
          case CONTINUE:
            ContinueStatement();
            break;
          case RETURN:
            ReturnStatement();
            break;
          case SYNCHRONIZED:
            SynchronizedStatement();
            break;
          case THROW:
            ThrowStatement();
            break;
          case TRY:
            TryStatement();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }

  final public void LabeledStatement() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    Statement();
  }

  final public void Block() throws ParseException {
 
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      label_22:
      while (true) {
        if (jj_2_23(1)) {
          ;
        } else {
          break label_22;
        }
        BlockStatement();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void BlockStatement() throws ParseException {
    if (jj_2_24(2147483647)) {
      ClassDeclaration();
    } else if (jj_2_25(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_26(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_27(2147483647)) {
      TypedVariableDeclaration();
      jj_consume_token(SEMICOLON);
    } else if (jj_2_28(1)) {
      Statement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
      case STATIC:
        ImportDeclaration();
        break;
      case PACKAGE:
        PackageDeclaration();
        break;
      case FORMAL_COMMENT:
        FormalComment();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void FormalComment() throws ParseException {
 
        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FORMAL_COMMENT);
                              jjtree.closeNodeScope(jjtn000,  retainComments);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                jjtn000.text=t.image;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  retainComments);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void EmptyStatement() throws ParseException {
    jj_consume_token(SEMICOLON);
  }

  final public void StatementExpression() throws ParseException {
    Expression();
  }

  final public void SwitchStatement() throws ParseException {
 
  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(LBRACE);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
        case _DEFAULT:
          ;
          break;
        default:
          break label_23;
        }
        SwitchLabel();
        label_24:
        while (true) {
          if (jj_2_29(1)) {
            ;
          } else {
            break label_24;
          }
          BlockStatement();
        }
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void SwitchLabel() throws ParseException {
 
  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        jj_consume_token(CASE);
        Expression();
        jj_consume_token(COLON);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        jj_consume_token(COLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.isDefault = true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void IfStatement() throws ParseException {
 
  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        Statement();
        break;
      default:
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void WhileStatement() throws ParseException {
 
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }


  final public void DoStatement() throws ParseException {
 
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DO);
      Statement();
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.isDoStatement=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ForStatement() throws ParseException {
 
  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case TRUE:
      case VOID:
      case VOLATILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForInit();
                          jjtn000.hasForInit=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
                         jjtn000.hasExpression=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForUpdate();
                        jjtn000.hasForUpdate=true;
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }


  final public void EnhancedForStatement() throws ParseException {
 
  BSHEnhancedForStatement jjtn000 = new BSHEnhancedForStatement(JJTENHANCEDFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_30(4)) {
        jj_consume_token(FOR);
        jj_consume_token(LPAREN);
        t = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        Expression();
        jj_consume_token(RPAREN);
        Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
          jj_consume_token(FOR);
          jj_consume_token(LPAREN);
          Type();
          t = jj_consume_token(IDENTIFIER);
          jj_consume_token(COLON);
          Expression();
          jj_consume_token(RPAREN);
          Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ForInit() throws ParseException {
  Token t = null;
    if (jj_2_31(2147483647)) {
      TypedVariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpressionList();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }


  final public void TypedVariableDeclaration() throws ParseException {
 
        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
    try {
      mods = Modifiers(Modifiers.FIELD, false);
      Type();
      VariableDeclarator();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_25;
        }
        jj_consume_token(COMMA);
        VariableDeclarator();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        jjtn000.modifiers = mods;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void StatementExpressionList() throws ParseException {
 
  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      StatementExpression();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_26;
        }
        jj_consume_token(COMMA);
        StatementExpression();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ForUpdate() throws ParseException {
    StatementExpressionList();
  }

  final public void BreakStatement() throws ParseException {
 
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BREAK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtreeCloseNodeScope(jjtn000);
                                 jjtn000.kind = BREAK;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ContinueStatement() throws ParseException {
 
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CONTINUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtreeCloseNodeScope(jjtn000);
                                    jjtn000.kind = CONTINUE;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ReturnStatement() throws ParseException {
 
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                  jjtn000.kind = RETURN;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void SynchronizedStatement() throws ParseException {
 
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SYNCHRONIZED);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Block();
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                                jjtreeCloseNodeScope(jjtn000);
                jjtn000.isSynchronized=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ThrowStatement() throws ParseException {
 
  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(THROW);
      Expression();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void TryStatement() throws ParseException {
 
  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);boolean closed = false;
    try {
      jj_consume_token(TRY);
      Block();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CATCH:
          ;
          break;
        default:
          break label_27;
        }
        jj_consume_token(CATCH);
        jj_consume_token(LPAREN);
        FormalParameter();
        jj_consume_token(RPAREN);
        Block();
                                                      closed = true;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINALLY:
        jj_consume_token(FINALLY);
        Block();
                              closed = true;
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if ( !closed ) {if (true) throw generateParseException();}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  final private boolean jj_3R_46() {
    if (jj_3R_91()) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_3R_164()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_169()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_3R_161()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_167()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  final private boolean jj_3R_165() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) return true;
    }
    if (jj_3R_158()) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_3R_158()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_165()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_3R_123()) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_162() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    }
    if (jj_3R_153()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_162()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_119()) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) return true;
    }
    if (jj_3R_148()) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_3R_148()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_159()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_135()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_113()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_112()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = isRegularForStatement();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_3R_69()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_157() {
    Token xsp;
    if (jj_3R_160()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_160()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_33()) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_3R_33()) return true;
    if (jj_3R_34()) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    Token xsp;
    if (jj_3_19()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_150() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) return true;
    }
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_108()) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_107()) return true;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) return true;
    }
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_36()) return true;
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) return true;
    }
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_111()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_147()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) return true;
    }
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(57)) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(41)) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_3R_149()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_109()) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_109()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_109()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_110()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) return true;
    }
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_38()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_189()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_190()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_176()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_188()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_3R_129()) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_3R_205()) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_210()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_146()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) jj_scanpos = xsp;
    if (jj_scan_token(IMPORT)) return true;
    if (jj_3R_29()) return true;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) return true;
    }
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_3R_41()) return true;
    if (jj_3R_32()) return true;
    if (jj_3R_176()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_177()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(PACKAGE)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_76()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3_31() {
    if (jj_3R_41()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_42()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) return true;
    }
    if (jj_3R_43()) return true;
    xsp = jj_scanpos;
    if (jj_3R_174()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) return true;
    }
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_3R_205()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_93()) return true;
    return false;
  }

  final private boolean jj_3R_194() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    }
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_3R_130()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_76()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_129()) return true;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    }
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_3R_29()) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_3R_194()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_172()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) jj_scanpos = xsp;
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_3R_195()) return true;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_57()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_58()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_208()) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_191()) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_214() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) return true;
    }
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_33()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) return true;
    }
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_45()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_3R_33()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) return true;
    }
    return false;
  }

  final private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) return true;
    }
    return false;
  }

  final private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_72()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_3R_215()) return true;
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_3R_214()) return true;
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_211() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    if (jj_3R_191()) return true;
    return false;
  }

  final private boolean jj_3R_208() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_183()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) return true;
    }
    }
    if (jj_3R_191()) return true;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_3R_208()) return true;
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_3R_207()) return true;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_3R_206()) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) return true;
    }
    if (jj_3R_191()) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_76()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_3R_191()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_209()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_200() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) return true;
    }
    if (jj_3R_181()) return true;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_3R_181()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_200()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(FORMAL_COMMENT)) return true;
    return false;
  }

  final private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) return true;
    }
    }
    }
    }
    }
    if (jj_3R_178()) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    if (jj_3R_166()) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_3R_178()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_192()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_182() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_3R_41()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_3R_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_182()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_94()) return true;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_3R_41()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_168()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_41()) return true;
    if (jj_3R_42()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_93()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) return true;
    }
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_161()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_166()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_171()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) return true;
    }
    if (jj_3R_164()) return true;
    return false;
  }

  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;

  public Parser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException(""Parse error at line "" + line + "", column "" + column + "".  Encountered: "" + mess);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHAssignment,3,2,0,12,20,3,1,11,1,1.0,294,0.0,0,0.894736842,0.533333333,1,1,96.66666667,1,0.6667,0,"


package org.gjt.sp.jedit.bsh;

class BSHAssignment extends SimpleNode implements ParserConstants
{
    public int operator;

    BSHAssignment(int id) { super(id); }

    public Object eval(
		CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        BSHPrimaryExpression lhsNode = 
			(BSHPrimaryExpression)jjtGetChild(0);

		if ( lhsNode == null )
			throw new InterpreterError( ""Error, null LHSnode"" );

		boolean strictJava = interpreter.getStrictJava();
        LHS lhs = lhsNode.toLHS( callstack, interpreter);
        if ( lhs == null )
            throw new InterpreterError( ""Error, null LHS"" );

		
		
		
		Object lhsValue = null;
		if ( operator != ASSIGN ) 
			try {
				lhsValue = lhs.getValue();
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack );
			}

        SimpleNode rhsNode = (SimpleNode)jjtGetChild(1);

        Object rhs;
		
		
		
		
		
        rhs = rhsNode.eval(callstack, interpreter);

        if ( rhs == Primitive.VOID )
            throw new EvalError(""Void assignment."", this, callstack );

		try {
			switch(operator)
			{
				case ASSIGN:
					return lhs.assign( rhs, strictJava );

				case PLUSASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, PLUS), strictJava );

	            case MINUSASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, MINUS), strictJava );

				case STARASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, STAR), strictJava );

	            case SLASHASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, SLASH), strictJava );

	            case ANDASSIGN:
				case ANDASSIGNX:
					return lhs.assign( 
						operation(lhsValue, rhs, BIT_AND), strictJava );

	            case ORASSIGN:
	            case ORASSIGNX:
	                return lhs.assign( 
						operation(lhsValue, rhs, BIT_OR), strictJava );

	            case XORASSIGN:
	                return lhs.assign( 
						operation(lhsValue, rhs, XOR), strictJava );

	            case MODASSIGN:
	                return lhs.assign( 
						operation(lhsValue, rhs, MOD), strictJava );

	            case LSHIFTASSIGN:
	            case LSHIFTASSIGNX:
	                return lhs.assign( 
						operation(lhsValue, rhs, LSHIFT), strictJava );

	            case RSIGNEDSHIFTASSIGN:
	            case RSIGNEDSHIFTASSIGNX:
	                return lhs.assign( 
					operation(lhsValue, rhs, RSIGNEDSHIFT ), strictJava );

	            case RUNSIGNEDSHIFTASSIGN:
	            case RUNSIGNEDSHIFTASSIGNX:
	                return lhs.assign( 
						operation(lhsValue, rhs, RUNSIGNEDSHIFT), 
						strictJava );

				default:
					throw new InterpreterError(
						""unimplemented operator in assignment BSH"");
			}
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
    }

    private Object operation( Object lhs, Object rhs, int kind ) 
		throws UtilEvalError
    {
		
		if ( lhs instanceof String && rhs != Primitive.VOID ) {
			if ( kind != PLUS )
				throw new UtilEvalError(
					""Use of non + operator with String LHS"" );

			return (String)lhs + rhs;
		}

        if ( lhs instanceof Primitive || rhs instanceof Primitive )
            if(lhs == Primitive.VOID || rhs == Primitive.VOID)
                throw new UtilEvalError(
					""Illegal use of undefined object or 'void' literal"" );
            else if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                throw new UtilEvalError(
					""Illegal use of null object or 'null' literal"" );


        if( (lhs instanceof Boolean || lhs instanceof Character ||
             lhs instanceof Number || lhs instanceof Primitive) &&
            (rhs instanceof Boolean || rhs instanceof Character ||
             rhs instanceof Number || rhs instanceof Primitive) )
        {
            return Primitive.binaryOperation(lhs, rhs, kind);
        }

        throw new UtilEvalError(""Non primitive value in operator: "" +
            lhs.getClass() + "" "" + tokenImage[kind] + "" "" + rhs.getClass() );
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.options.ContextOptionPane,3,7,0,2,6,3,0,2,1,2.0,16,0.0,0,0.997088792,0.666666667,1,2,4.333333333,1,0.6667,0,"

package org.gjt.sp.jedit.options;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.StandardUtilities;


public class ContextOptionPane extends AbstractContextOptionPane
{

	public ContextOptionPane()
	{
		super(""context"", jEdit.getProperty(""options.context.caption""));
	}

    
    protected String getContextMenu()
    {
		return jEdit.getProperty(""view.context"");
	}

    
    protected void saveContextMenu(String menu)
    {
		jEdit.setProperty(""view.context"", menu);
    }

}
"
jEdit,4.3,org.gjt.sp.jedit.io.UrlVFS,4,2,0,4,17,6,2,3,4,2.0,86,0.0,0,0.928571429,0.6,1,1,20.5,2,1.0,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.io.*;
import java.net.*;
import org.gjt.sp.util.Log;



public class UrlVFS extends VFS
{
	
	public UrlVFS()
	{
		super(""url"",READ_CAP | WRITE_CAP);
	} 

	
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(""/""))
			return parent + path;
		else
			return parent + '/' + path;
	} 

	
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		try
		{
			return new URL(path).openStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} 

	
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		try
		{
			return new URL(path).openConnection()
				.getOutputStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Remote,7,1,0,0,48,21,0,0,3,2.0,333,0.0,0,0.0,0.285714286,0,0,46.57142857,3,1.2857,0,"

package org.gjt.sp.jedit.bsh;

import java.io.*;
import java.net.*;


public class Remote
{
    public static void main( String args[] )
		throws Exception
	{
		if ( args.length < 2 ) {
			System.out.println(
				""usage: Remote URL(http|bsh) file [ file ] ... "");
			System.exit(1);
		}
		String url = args[0];
		String text = getFile(args[1]);
		int ret = eval( url, text );
		System.exit( ret );
		}

	
	public static int eval( String url, String text )
		throws IOException
	{
		String returnValue = null;
		if ( url.startsWith( ""http:"" ) ) {
			returnValue = doHttp( url, text );
		} else if ( url.startsWith( ""bsh:"" ) ) {
			returnValue = doBsh( url, text );
		} else
			throw new IOException( ""Unrecognized URL type.""
				+""Scheme must be http:

		try {
			return Integer.parseInt( returnValue );
		} catch ( Exception e ) {
			
			return 0;
		}
	}

	static String doBsh( String url, String text ) 
	{ 
	    OutputStream out;
	    InputStream in;
	    String host = """";
	    String port = """";
	    String returnValue = ""-1"";
		String orgURL = url;
	    
		
	    try {
			url = url.substring(6); 
			
			int index = url.indexOf("":"");
			host = url.substring(0,index);
			port = url.substring(index+1,url.length());
		} catch ( Exception ex ) {
			System.err.println(""Bad URL: ""+orgURL+"": ""+ex  );
			return returnValue;
	    }

	    try {
			System.out.println(""Connecting to host : "" 
				+ host + "" at port : "" + port);
			Socket s = new Socket(host, Integer.parseInt(port) + 1);
			
			out = s.getOutputStream();
			in = s.getInputStream();
			
			sendLine( text, out );

			BufferedReader bin = new BufferedReader( 
				new InputStreamReader(in));
			  String line;
			  while ( (line=bin.readLine()) != null )
				System.out.println( line );

			
			returnValue=""1"";
			return returnValue;
	    } catch(Exception ex) {
			System.err.println(""Error communicating with server: ""+ex);
			return returnValue;
	    }
	}

    private static void sendLine( String line, OutputStream outPipe )
		throws IOException
	{
		outPipe.write( line.getBytes() );
		outPipe.flush();
    }


	
	static String doHttp( String postURL, String text )
	{
		String returnValue = null;
		StringBuilder sb = new StringBuilder();
		sb.append( ""bsh.client=Remote"" );
		sb.append( ""&bsh.script="" );
		sb.append( URLEncoder.encode( text ) );
		
		String formData = sb.toString(  );

		try {
		  URL url = new URL( postURL );
		  HttpURLConnection urlcon =
			  (HttpURLConnection) url.openConnection(  );
		  urlcon.setRequestMethod(""POST"");
		  urlcon.setRequestProperty(""Content-type"",
			  ""application/x-www-form-urlencoded"");
		  urlcon.setDoOutput(true);
		  urlcon.setDoInput(true);
		  PrintWriter pout = new PrintWriter( new OutputStreamWriter(
			  urlcon.getOutputStream(), ""8859_1""), true );
		  pout.print( formData );
		  pout.flush();

		  
		  int rc = urlcon.getResponseCode();
		  if ( rc != HttpURLConnection.HTTP_OK )
			System.out.println(""Error, HTTP response: ""+rc );

		  returnValue = urlcon.getHeaderField(""Bsh-Return"");

		  BufferedReader bin = new BufferedReader(
			new InputStreamReader( urlcon.getInputStream() ) );
		  String line;
		  while ( (line=bin.readLine()) != null )
			System.out.println( line );

		  System.out.println( ""Return Value: ""+returnValue );

		} catch (MalformedURLException e) {
		  System.out.println(e);     
		} catch (IOException e2) {
		  System.out.println(e2);    
		}

		return returnValue;
	}

	
	static String getFile( String name )
		throws FileNotFoundException, IOException
	{
		StringBuilder sb = new StringBuilder();
		BufferedReader bin = new BufferedReader( new FileReader( name ) );
		String line;
		while ( (line=bin.readLine()) != null )
			sb.append( line ).append( ""\n"" );
		return sb.toString();
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.msg.PropertiesChanged,1,2,0,18,2,0,16,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class PropertiesChanged extends EBMessage
{
	
	public PropertiesChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.AbstractOptionPane,17,5,23,25,39,102,23,2,14,0.734375,507,1.0,0,0.976083707,0.470588235,0,0,28.58823529,3,1.2353,0,"

package org.gjt.sp.jedit;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;






public class AbstractOptionPane extends JPanel implements OptionPane
{
	
	
	public AbstractOptionPane(String internalName)
	{
		this.name = internalName;
		setLayout(gridBag = new GridBagLayout());
	} 

	
	
	@Override
	public String getName()
	{
		return name;
	} 

	
	
	public Component getComponent()
	{
		return this;
	} 

	
	
	
	public void init()
	{
		if(!initialized)
		{
			initialized = true;
			_init();
		}
	} 

	
	
	
	public void save()
	{
		if(initialized)
			_save();
	} 

	
	
	public JLabel newLabel(String label, Component comp)
	{
		JLabel retval = new JLabel(label);
		try 
		{
			JComponent jc = (JComponent) comp;
			String tttext = jc.getToolTipText();
			retval.setToolTipText(tttext);
		}
		catch (Exception e)
		{
			
		}
		return retval;
	}

	
	
	public void addComponent(String label, Component comp)
	{
		JLabel l = newLabel(label, comp);
		l.setBorder(new EmptyBorder(0,0,0,12));
		addComponent(l,comp,GridBagConstraints.BOTH);
	} 

	
	
	public void addComponent(String label, Component comp, int fill)
	{
		JLabel l = newLabel(label, comp);
		l.setBorder(new EmptyBorder(0,0,0,12));
		addComponent(l,comp,fill);
	} 

	
	
	public void addComponent(Component comp1, Component comp2)
	{
		addComponent(comp1,comp2,GridBagConstraints.BOTH);
	} 

	
	
	public void addComponent(Component comp1, Component comp2, int fill)
	{
		copyToolTips(comp1, comp2);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = 1;
		cons.weightx = 0.0f;
		cons.insets = new Insets(1,0,1,0);
		cons.fill = GridBagConstraints.BOTH;

		gridBag.setConstraints(comp1,cons);
		add(comp1);

		cons.fill = fill;
		cons.gridx = 1;
		cons.weightx = 1.0f;
		gridBag.setConstraints(comp2,cons);
		add(comp2);
	} 

	
	
	public void addComponent(Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.NONE;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(comp,cons);
		add(comp);
	} 

	
	
	public void addComponent(Component comp, int fill)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		cons.fill = fill;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(comp,cons);
		add(comp);
	} 

	
	private static void copyToolTips(Component c1, Component c2)
	{
		int tooltips = 0;
		int jc = 0;
		String text = null;
		JComponent jc1 = null;
		try
		{
			jc1 = (JComponent) c1;
			text = jc1.getToolTipText();
			++jc;
			if (text != null && text.length() > 0)
				tooltips++;
		}
		catch (Exception e)
		{
		}

		JComponent jc2 = null;
		try
		{
			jc2 = (JComponent) c2;
			String text2 = jc2.getToolTipText();
			++jc;
			if (text2 != null && text2.length() > 0)
			{
				text = text2;
				tooltips++;
			}
		}
		catch (Exception e)
		{
		}

		if (tooltips == 1 && jc == 2)
		{
			jc1.setToolTipText(text);
			jc2.setToolTipText(text);
		}

	} 

	
	
	public void addSeparator()
	{
		addComponent(Box.createVerticalStrut(6));

		JSeparator sep = new JSeparator(SwingConstants.HORIZONTAL);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		

		gridBag.setConstraints(sep,cons);
		add(sep);

		addComponent(Box.createVerticalStrut(6));
	} 

	
	
	public void addSeparator(String label)
	{
		if(y != 0)
			addComponent(Box.createVerticalStrut(6));

		Box box = new Box(BoxLayout.X_AXIS);
		Box box2 = new Box(BoxLayout.Y_AXIS);
		box2.add(Box.createGlue());
		box2.add(new JSeparator(SwingConstants.HORIZONTAL));
		box2.add(Box.createGlue());
		box.add(box2);
		JLabel l = new JLabel(jEdit.getProperty(label));
		l.setMaximumSize(l.getPreferredSize());
		box.add(l);
		Box box3 = new Box(BoxLayout.Y_AXIS);
		box3.add(Box.createGlue());
		box3.add(new JSeparator(SwingConstants.HORIZONTAL));
		box3.add(Box.createGlue());
		box.add(box3);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(box,cons);
		add(box);
	} 

	
	
	protected boolean initialized;

	
	protected GridBagLayout gridBag;

	
	protected int y;

	
	protected void _init() {}

	
	protected void _save() {}
	

	
	private String name;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.Abbrevs,18,1,0,13,94,39,4,11,9,0.705882353,707,0.875,0,0.0,0.111111111,0,0,37.83333333,14,2.5556,0,"

package org.gjt.sp.jedit;


import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.gui.AddAbbrevDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class Abbrevs
{
	public static final String ENCODING = ""UTF8"";

	
	
	public static boolean getExpandOnInput()
	{
		return expandOnInput;
	} 

	
	
	public static void setExpandOnInput(boolean expandOnInput)
	{
		Abbrevs.expandOnInput = expandOnInput;
	} 

	
	
	public static boolean expandAbbrev(View view, boolean add)
	{
		
		Buffer buffer = view.getBuffer();
		JEditTextArea textArea = view.getTextArea();
		if(!buffer.isEditable())
		{
			view.getToolkit().beep();
			return false;
		}

		int line = textArea.getCaretLine();
		int lineStart = buffer.getLineStartOffset(line);
		int caret = textArea.getCaretPosition();

		String lineText = buffer.getLineText(line);
		if(lineText.length() == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		}

		int pos = caret - lineStart;
		if(pos == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		} 

		
		m_pp.removeAllElements();

		int wordStart;
		String abbrev;

		
		if(lineText.charAt(pos-1) == '#')
		{
			wordStart = lineText.indexOf('#');
			wordStart = TextUtilities.findWordStart(lineText,wordStart,
				buffer.getStringProperty(""noWordSep"") + '#');

			abbrev = lineText.substring(wordStart,pos - 1);

			
			

			int lastIndex = 0;
			for(int i = 0; i < abbrev.length(); i++)
			{
				if(abbrev.charAt(i) == '#')
				{
					m_pp.addElement(abbrev.substring(lastIndex,i));
					lastIndex = i + 1;
				}
			}

			m_pp.addElement(abbrev.substring(lastIndex));

			
			abbrev = m_pp.elementAt(0);
			m_pp.removeElementAt(0);
		} 
		
		else
		{
			wordStart = TextUtilities.findWordStart(lineText,pos - 1,
				buffer.getStringProperty(""noWordSep""));

			abbrev = lineText.substring(wordStart,pos);
		} 

		Expansion expand = expandAbbrev(buffer.getMode().getName(),
			abbrev,(buffer.getBooleanProperty(""noTabs"") ?
			buffer.getTabSize() : 0),m_pp);

		
		if(expand == null)
		{
			if(add)
				new AddAbbrevDialog(view,abbrev);

			return false;
		} 
		
		else
		{
			buffer.remove(lineStart + wordStart,
				pos - wordStart);

			int whitespace = buffer.insertIndented(
				lineStart + wordStart,
				expand.text);

			int newlines = countNewlines(expand.text,
				expand.caretPosition);

			if(expand.caretPosition != -1)
			{
				textArea.setCaretPosition(lineStart + wordStart
					+ expand.caretPosition
					+ newlines * whitespace);
			}
			if(expand.posParamCount != m_pp.size())
			{
				view.getStatus().setMessageAndClear(
					jEdit.getProperty(
					""view.status.incomplete-abbrev"",
					new Integer[] { Integer.valueOf(m_pp.size()),
					Integer.valueOf(expand.posParamCount) }));
			}

			return true;
		} 
	} 

	
	
	public static Hashtable<String,String> getGlobalAbbrevs()
	{
		if(!loaded)
			load();

		return globalAbbrevs;
	} 

	
	
	public static void setGlobalAbbrevs(Hashtable<String,String> globalAbbrevs)
	{
		abbrevsChanged = true;
		Abbrevs.globalAbbrevs = globalAbbrevs;
	} 

	
	
	public static Hashtable<String,Hashtable<String,String>> getModeAbbrevs()
	{
		if(!loaded)
			load();

		return modes;
	} 

	
	
	public static void setModeAbbrevs(Hashtable<String,Hashtable<String,String>> modes)
	{
		abbrevsChanged = true;
		Abbrevs.modes = modes;
	} 

	
	
	public static void addGlobalAbbrev(String abbrev, String expansion)
	{
		if(!loaded)
			load();

		globalAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} 

	
	
	public static void addModeAbbrev(String mode, String abbrev, String expansion)
	{
		if(!loaded)
			load();

		Hashtable<String,String> modeAbbrevs = modes.get(mode);
		if(modeAbbrevs == null)
		{
			modeAbbrevs = new Hashtable<String,String>();
			modes.put(mode,modeAbbrevs);
		}
		modeAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} 

	
	static void save()
	{
		jEdit.setBooleanProperty(""view.expandOnInput"",expandOnInput);

		String settings = jEdit.getSettingsDirectory();
		if(abbrevsChanged && settings != null)
		{
			File file1 = new File(MiscUtilities.constructPath(settings,""#abbrevs#save#""));
			File file2 = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			if(file2.exists() && file2.lastModified() != abbrevsModTime)
			{
				Log.log(Log.WARNING,Abbrevs.class,file2 + "" changed on disk;""
					+ "" will not save abbrevs"");
			}
			else
			{
				jEdit.backupSettingsFile(file2);

				try
				{
					saveAbbrevs(new OutputStreamWriter(
						new FileOutputStream(file1),
						ENCODING));
					file2.delete();
					file1.renameTo(file2);
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,Abbrevs.class,""Error while saving "" + file1);
					Log.log(Log.ERROR,Abbrevs.class,e);
				}
				abbrevsModTime = file2.lastModified();
			}
		}
	} 

	

	
	private static boolean loaded;
	private static boolean abbrevsChanged;
	private static long abbrevsModTime;
	private static boolean expandOnInput;
	private static Hashtable<String,String> globalAbbrevs;
	private static Hashtable<String,Hashtable<String,String>> modes;
	
	
	private static Vector<String> m_pp = new Vector<String>();
	

	private Abbrevs() {}

	static
	{
		expandOnInput = jEdit.getBooleanProperty(""view.expandOnInput"");
	}

	
	private static void load()
	{
		globalAbbrevs = new Hashtable<String,String>();
		modes = new Hashtable<String,Hashtable<String,String>>();

		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			File file = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			abbrevsModTime = file.lastModified();

			try
			{
				loadAbbrevs(new InputStreamReader(
					new FileInputStream(file),ENCODING));
				loaded = true;
			}
			catch(FileNotFoundException fnf)
			{
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading "" + file);
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
		}

		
		if(!loaded)
		{
			try
			{
				loadAbbrevs(new InputStreamReader(Abbrevs.class
					.getResourceAsStream(""default.abbrevs""),
					ENCODING));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading default.abbrevs"");
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
			loaded = true;
		}
	} 

	
	private static int countNewlines(String s, int end)
	{
		int counter = 0;

		for(int i = 0; i < end; i++)
		{
			if(s.charAt(i) == '\n')
				counter++;
		}

		return counter;
	} 

	
	private static Expansion expandAbbrev(String mode, String abbrev,
		int softTabSize, Vector<String> pp)
	{
		m_pp = pp;
		if(!loaded)
			load();

		
		String expand = null;
		Hashtable<String,String> modeAbbrevs = modes.get(mode);
		if(modeAbbrevs != null)
			expand = modeAbbrevs.get(abbrev);

		if(expand == null)
			expand = globalAbbrevs.get(abbrev);

		if(expand == null)
			return null;
		else
			return new Expansion(expand,softTabSize,m_pp);
	} 

	
	private static void loadAbbrevs(Reader _in) throws Exception
	{
		BufferedReader in = new BufferedReader(_in);

		try
		{
			Hashtable<String,String> currentAbbrevs = globalAbbrevs;

			String line;
			while((line = in.readLine()) != null)
			{
				int index = line.indexOf('|');

				if(line.length() == 0)
					continue;
				else if(line.startsWith(""["") && index == -1)
				{
					if(line.equals(""[global]""))
						currentAbbrevs = globalAbbrevs;
					else
					{
						String mode = line.substring(1,
							line.length() - 1);
						currentAbbrevs = modes.get(mode);
						if(currentAbbrevs == null)
						{
							currentAbbrevs = new Hashtable<String,String>();
							modes.put(mode,currentAbbrevs);
						}
					}
				}
				else if(index != -1)
				{
					currentAbbrevs.put(line.substring(0,index),
						line.substring(index + 1));
				}
			}
		}
		finally
		{
			in.close();
		}
	} 

	
	private static void saveAbbrevs(Writer _out) throws Exception
	{
		BufferedWriter out = new BufferedWriter(_out);
		String lineSep = System.getProperty(""line.separator"");

		
		out.write(""[global]"");
		out.write(lineSep);

		saveAbbrevs(out,globalAbbrevs);

		
		Enumeration<String> keys = modes.keys();
		Enumeration<Hashtable<String,String>> values = modes.elements();
		while(keys.hasMoreElements())
		{
			out.write('[');
			out.write(keys.nextElement());
			out.write(']');
			out.write(lineSep);
			saveAbbrevs(out,values.nextElement());
		}

		out.close();
	} 

	
	private static void saveAbbrevs(Writer out, Hashtable<String,String> abbrevs)
		throws Exception
	{
		String lineSep = System.getProperty(""line.separator"");

		Enumeration<String> keys = abbrevs.keys();
		Enumeration<String> values = abbrevs.elements();
		while(keys.hasMoreElements())
		{
			String abbrev = keys.nextElement();
			out.write(abbrev);
			out.write('|');
			out.write(values.nextElement());
			out.write(lineSep);
		}
	} 

	

	
	static class Expansion
	{
		String text;
		int caretPosition = -1;
		int lineCount;

		
		int posParamCount;

		
		Expansion(String text, int softTabSize, List<String> pp)
		{
			StringBuilder buf = new StringBuilder();
			boolean backslash = false;

			for(int i = 0; i < text.length(); i++)
			{
				char ch = text.charAt(i);
				
				if(backslash)
				{
					backslash = false;

					if(ch == '|')
						caretPosition = buf.length();
					else if(ch == 'n')
					{
						buf.append('\n');
						lineCount++;
					}
					else if(ch == 't')
					{
						if(softTabSize == 0)
							buf.append('\t');
						else
						{
							for(int j = 0; j < softTabSize; j++)
								buf.append(' ');
						}
					}
					else
						buf.append(ch);
				}
				else if(ch == '\\')
					backslash = true;
				
				
				else if(ch == '$')
				{
					if(i != text.length() - 1)
					{
						ch = text.charAt(i + 1);
						if(Character.isDigit(ch) && ch != '0')
						{
							i++;

							int pos = ch - '0';
							posParamCount = Math.max(pos,posParamCount);
							
							
							if(pos <= pp.size())
								buf.append(pp.get(pos - 1));
						}
						else
						{
							
							
							buf.append('$');
						}
					}
					else
						buf.append('$'); 
				} 
				else
					buf.append(ch);
			}

			this.text = buf.toString();
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ClassIdentifier,3,1,0,3,8,0,3,0,3,0.0,24,0.0,0,0.0,0.666666667,0,0,6.666666667,1,0.6667,0,"

package org.gjt.sp.jedit.bsh;

public class ClassIdentifier 
{
	Class clas;

	public ClassIdentifier( Class clas ) {
		this.clas = clas;
	}

	
	public Class getTargetClass() {
		return clas;
	}

	public String toString() {
		return ""Class Identifier: ""+clas.getName();
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.indent.CloseBracketIndentRule,3,2,0,6,16,1,1,5,3,0.5,97,1.0,0,0.666666667,0.428571429,0,0,31.0,8,3.3333,0,"

package org.gjt.sp.jedit.indent;

import java.util.List;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.util.StandardUtilities;


public class CloseBracketIndentRule extends BracketIndentRule
{
	
	public CloseBracketIndentRule(char closeBracket, boolean aligned)
	{
		super(TextUtilities.getComplementaryBracket(closeBracket,null),
			closeBracket);
		this.aligned = aligned;
	} 

	
	public void apply(JEditBuffer buffer, int thisLineIndex,
		int prevLineIndex, int prevPrevLineIndex,
		List<IndentAction> indentActions)
	{
		int index;
		if(aligned)
			index = thisLineIndex;
		else
			index = prevLineIndex;

		if(index == -1)
			return;

		CharSequence lineText = buffer.getLineSegment(index);
		int offset;
		for (offset = lineText.length() - 1; offset >= 0; offset--)
		{
			if (lineText.charAt(offset) == closeBracket)
				break;
		}
		if(offset == -1)
			return;

		int closeCount = getBrackets(buffer, index).closeCount;
		if(closeCount != 0)
		{
			AlignBracket alignBracket
				= new AlignBracket(buffer,index,offset);
			
			int openLine = alignBracket.getOpenBracketLine();
			if(openLine != -1)
			{
				int column = alignBracket.getOpenBracketColumn();
				alignBracket.setExtraIndent(
					getBrackets(buffer, openLine,
						0, column).openCount);
			}

			indentActions.add(alignBracket);
		}
	} 

	
	
	@Deprecated
	public boolean isMatch(String line)
	{
		return getBrackets(line).closeCount != 0;
	} 

	private boolean aligned;

	
	private static class AlignBracket implements IndentAction
	{
		private int line, offset;
		private int openBracketLine;
		private int openBracketColumn;
		private CharSequence openBracketLineText;
		private int extraIndent;

		public AlignBracket(JEditBuffer buffer, int line, int offset)
		{
			this.line = line;
			this.offset = offset;

			int openBracketIndex = TextUtilities.findMatchingBracket(
				buffer,this.line,this.offset);
			if(openBracketIndex == -1)
				openBracketLine = -1;
			else
			{
				openBracketLine = buffer.getLineOfOffset(openBracketIndex);
				openBracketColumn = openBracketIndex -
					buffer.getLineStartOffset(openBracketLine);
				openBracketLineText = buffer.getLineSegment(openBracketLine);
			}
		}

		public int getExtraIndent()
		{
			return extraIndent;
		}

		public void setExtraIndent(int extraIndent)
		{
			this.extraIndent = extraIndent;
		}

		public int getOpenBracketColumn()
		{
			return openBracketColumn;
		}

		public int getOpenBracketLine()
		{
			return openBracketLine;
		}

		public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,
			int newIndent)
		{
			if(openBracketLineText == null)
				return newIndent;
			else
			{
				return StandardUtilities.getLeadingWhiteSpaceWidth(
					openBracketLineText,buffer.getTabSize())
					+ (extraIndent * buffer.getIndentSize());
			}
		}

		public boolean keepChecking()
		{
			return false;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaDropHandler,5,2,0,4,17,0,1,4,4,0.416666667,109,1.0,2,0.5,0.4,0,0,20.2,4,1.6,0,"

package org.gjt.sp.jedit.textarea;


import javax.swing.*;
import java.awt.dnd.*;
import java.awt.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.Log;



class TextAreaDropHandler extends DropTargetAdapter
{
	private final TextArea textArea;
	private JEditBuffer savedBuffer;
	private int savedCaret;

	
	TextAreaDropHandler(TextArea textArea)
	{
		this.textArea = textArea;
	} 

	
	@Override
	public void dragEnter(DropTargetDragEvent dtde)
	{
		Log.log(Log.DEBUG,this,""Drag enter"");
		savedBuffer = textArea.getBuffer();
		textArea.setDragInProgress(true);
		
		savedCaret = textArea.getCaretPosition();
	} 

	
	@Override
	public void dragOver(DropTargetDragEvent dtde)
	{
		Point p = dtde.getLocation();
		p = SwingUtilities.convertPoint(textArea,p,
			textArea.getPainter());
		int pos = textArea.xyToOffset(p.x,p.y,
			!(textArea.getPainter().isBlockCaretEnabled()
			|| textArea.isOverwriteEnabled()));
		if(pos != -1)
		{
			textArea.moveCaretPosition(pos,
				TextArea.ELECTRIC_SCROLL);
		}
	} 

	
	@Override
	public void dragExit(DropTargetEvent dtde)
	{
		Log.log(Log.DEBUG,this,""Drag exit"");
		textArea.setDragInProgress(false);
		
		if(textArea.getBuffer() == savedBuffer)
		{
			textArea.moveCaretPosition(savedCaret,
				TextArea.ELECTRIC_SCROLL);
		}
		savedBuffer = null;
	} 

	
	public void drop(DropTargetDropEvent dtde)
	{
		Log.log(Log.DEBUG,this,""Drop"");
		textArea.setDragInProgress(false);
		
		savedBuffer = null;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.FontSelector,8,6,0,9,26,16,8,2,5,0.285714286,105,1.0,0,0.9921875,0.35,1,2,12.0,2,1.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;




public class FontSelector extends JButton
{
	
	
	public FontSelector(Font font)
	{
		this(font,false);
	} 

	
	
	public FontSelector(Font font, boolean antiAlias)
	{
		setFont(font);
		this.antiAlias = antiAlias;

		updateText();

		setRequestFocusEnabled(false);

		addActionListener(new ActionHandler());
	} 

	
	public void paintComponent(Graphics g)
	{
		setAntiAliasEnabled(g);
		super.paintComponent(g);
	} 

	
	public boolean isAntiAliasEnabled()
	{
		return antiAlias;
	} 

	
	public void setAntiAliasEnabled(boolean antiAlias)
	{
		this.antiAlias = antiAlias;
	} 

	
	private void updateText()
	{
		Font font = getFont();
		String styleString;
		switch(font.getStyle())
		{
		case Font.PLAIN:
			styleString = jEdit.getProperty(""font-selector.plain"");
			break;
		case Font.BOLD:
			styleString = jEdit.getProperty(""font-selector.bold"");
			break;
		case Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.italic"");
			break;
		case Font.BOLD | Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.bolditalic"");
			break;
		default:
			styleString = ""UNKNOWN!!!???"";
			break;
		}

		setText(font.getName() + ' ' + font.getSize() + ' ' + styleString);
	} 

	
	void setAntiAliasEnabled(Graphics g)
	{
		if (antiAlias)
		{
			Graphics2D g2 = (Graphics2D)g;
			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		}
	} 

	private boolean antiAlias;

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Font font;

			JDialog dialog = GUIUtilities.getParentDialog(FontSelector.this);
			if(dialog == null)
			{
				font = new FontSelectorDialog(
					JOptionPane.getFrameForComponent(
					FontSelector.this),getFont(),
					FontSelector.this)
					.getSelectedFont();
			}
			else
			{
				font = new FontSelectorDialog(dialog,getFont(),
					FontSelector.this)
					.getSelectedFont();
			}

			if(font != null)
			{
				setFont(font);
				updateText();
			}
		}
	} 
} 


class FontSelectorDialog extends EnhancedDialog
{
	
	FontSelectorDialog(Frame parent, Font font)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		init(font);
	} 

	
	FontSelectorDialog(Dialog parent, Font font)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		init(font);
	} 

	
	FontSelectorDialog(Frame parent, Font font,
		FontSelector fontSelector)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		this.fontSelector = fontSelector;
		init(font);
	} 

	
	FontSelectorDialog(Dialog parent, Font font,
		FontSelector fontSelector)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		this.fontSelector = fontSelector;
		init(font);
	} 

	
	public void ok()
	{
		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public Font getSelectedFont()
	{
		if(!isOK)
			return null;

		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}

		return new Font(familyField.getText(),styleList
			.getSelectedIndex(),size);
	} 

	

	
	private FontSelector fontSelector;
	private boolean isOK;
	private JTextField familyField;
	private JList familyList;
	private JTextField sizeField;
	private JList sizeList;
	private JTextField styleField;
	private JList styleList;
	private JLabel preview;
	private JButton ok;
	private JButton cancel;
	

	
	private static final String[] HIDEFONTS = {
		"".bold"",
		"".italic""
	};

	
	private void init(Font font)
	{
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel listPanel = new JPanel(new GridLayout(1,3,6,6));

		String[] fonts;
		try
		{
			fonts = getFontList();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Broken Java implementation!"");
			
			Log.log(Log.ERROR,this,e);

			
			fonts = new String[] { ""Broken Java implementation!"" };
		}

		JPanel familyPanel = createTextFieldAndListPanel(
			""font-selector.family"",
			familyField = new JTextField(),
			familyList = new JList(fonts));
		listPanel.add(familyPanel);

		String[] sizes = { ""9"", ""10"", ""12"", ""14"", ""16"", ""18"", ""24"" };
		JPanel sizePanel = createTextFieldAndListPanel(
			""font-selector.size"",
			sizeField = new JTextField(),
			sizeList = new JList(sizes));
		listPanel.add(sizePanel);

		String[] styles = {
			jEdit.getProperty(""font-selector.plain""),
			jEdit.getProperty(""font-selector.bold""),
			jEdit.getProperty(""font-selector.italic""),
			jEdit.getProperty(""font-selector.bolditalic"")
		};

		JPanel stylePanel = createTextFieldAndListPanel(
			""font-selector.style"",
			styleField = new JTextField(),
			styleList = new JList(styles));
		styleField.setEditable(false);
		listPanel.add(stylePanel);

		familyList.setSelectedValue(font.getFamily(),true);
		familyField.setText(font.getFamily());
		sizeList.setSelectedValue(String.valueOf(font.getSize()),true);
		sizeField.setText(String.valueOf(font.getSize()));
		styleList.setSelectedIndex(font.getStyle());
		styleField.setText((String)styleList.getSelectedValue());

		ListHandler listHandler = new ListHandler();
		familyList.addListSelectionListener(listHandler);
		sizeList.addListSelectionListener(listHandler);
		styleList.addListSelectionListener(listHandler);

		content.add(BorderLayout.NORTH,listPanel);

		preview = new JLabel(jEdit.getProperty(""font-selector.long-text""))
		{
			public void paintComponent(Graphics g)
			{
				if(fontSelector != null)
					fontSelector.setAntiAliasEnabled(g);
				super.paintComponent(g);
			}
		};
		preview.setBorder(new TitledBorder(jEdit.getProperty(
			""font-selector.preview"")));

		updatePreview();

		Dimension prefSize = preview.getPreferredSize();
		prefSize.height = 50;
		preview.setPreferredSize(prefSize);

		content.add(BorderLayout.CENTER,preview);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);

		buttons.add(Box.createHorizontalStrut(6));

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);

		buttons.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,buttons);

		pack();
		setLocationRelativeTo(getParent());
		setVisible(true);
	} 

	
	private static String[] getFontList()
	{
		String[] nameArray = GraphicsEnvironment
			.getLocalGraphicsEnvironment()
			.getAvailableFontFamilyNames();
		List<String> nameVector = new ArrayList<String>(nameArray.length);

		for(int i = 0, j; i < nameArray.length; i++)
		{
			for(j = 0; j < HIDEFONTS.length; j++)
			{
				if(nameArray[i].contains(HIDEFONTS[j]))
					break;
			}

			if(j == HIDEFONTS.length)
				nameVector.add(nameArray[i]);
		}

		String[] _array = new String[nameVector.size()];
		return nameVector.toArray(_array);
	} 

	
	private static JPanel createTextFieldAndListPanel(String label,
		JTextField textField, JList list)
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 1.0f;

		JLabel _label = new JLabel(jEdit.getProperty(label));
		layout.setConstraints(_label,cons);
		panel.add(_label);

		cons.gridy = 1;
		Component vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);

		cons.gridy = 2;
		layout.setConstraints(textField,cons);
		panel.add(textField);

		cons.gridy = 3;
		vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);

		cons.gridy = 4;
		cons.gridheight = GridBagConstraints.REMAINDER;
		cons.weighty = 1.0f;
		JScrollPane scroller = new JScrollPane(list);
		layout.setConstraints(scroller,cons);
		panel.add(scroller);

		return panel;
	} 

	
	private void updatePreview()
	{
		String family = familyField.getText();
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}
		int style = styleList.getSelectedIndex();

		preview.setFont(new Font(family,style,size));
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object source = evt.getSource();
			if(source == familyList)
			{
				String family = (String)familyList.getSelectedValue();
				if(family != null)
					familyField.setText(family);
			}
			else if(source == sizeList)
			{
				String size = (String)sizeList.getSelectedValue();
				if(size != null)
					sizeField.setText(size);
			}
			else if(source == styleList)
			{
				String style = (String)styleList.getSelectedValue();
				if(style != null)
					styleField.setText(style);
			}

			updatePreview();
		}
	} 
} 
"
jEdit,4.3,org.gjt.sp.jedit.menu.RecentDirectoriesProvider,3,1,0,10,29,3,2,10,3,2.0,157,0.0,0,0.0,0.666666667,0,0,51.33333333,10,3.6667,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import java.util.Collections;

import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.HistoryModel;
import org.gjt.sp.jedit.*;


public class RecentDirectoriesProvider implements DynamicMenuProvider
{
	
	public boolean updateEveryTime()
	{
		return true;
	} 

	
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);

		
		ActionListener actionListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,evt.getActionCommand());

				view.getStatus().setMessage(null);
			}
		}; 

		
		MouseListener mouseListener = new MouseAdapter()
		{
			public void mouseEntered(MouseEvent evt)
			{
				view.getStatus().setMessage(
					((JMenuItem)evt.getSource())
					.getActionCommand());
			}

			public void mouseExited(MouseEvent evt)
			{
				view.getStatus().setMessage(null);
			}
		}; 

		HistoryModel model = HistoryModel.getModel(""vfs.browser.path"");
		if(model.getSize() == 0)
		{
			JMenuItem menuItem = new JMenuItem(
				jEdit.getProperty(""no-recent-dirs.label""));
			menuItem.setEnabled(false);
			menu.add(menuItem);
			return;
		}

		boolean sort = jEdit.getBooleanProperty(""sortRecent"");

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

		Vector<JMenuItem> menuItems = new Vector<JMenuItem>();

		for(int i = 0; i < model.getSize(); i++)
		{
			String path = model.getItem(i);
			JMenuItem menuItem = new JMenuItem(MiscUtilities.getFileName(path));
			menuItem.setActionCommand(path);
			menuItem.addActionListener(actionListener);
			menuItem.addMouseListener(mouseListener);
			menuItem.setIcon(FileCellRenderer.dirIcon);

			if(sort)
				menuItems.addElement(menuItem);
			else
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& i != model.getSize() - 1)
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}

				menu.add(menuItem);
			}
		}

		if(sort)
		{
			Collections.sort(menuItems,
					new MenuItemTextComparator());
			for(int i = 0; i < menuItems.size(); i++)
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& i != 0)
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}

				menu.add(menuItems.elementAt(i));
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.AutoDetection,7,1,0,8,31,19,3,5,5,0.833333333,159,0.0,0,0.0,0.208333333,0,0,21.57142857,5,1.8571,0,"

package org.gjt.sp.jedit.io;


import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.zip.GZIPInputStream;

import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.ServiceManager;
import org.gjt.sp.jedit.bufferio.BufferIORequest;
import org.gjt.sp.util.Log;



public class AutoDetection
{
	
	
	public static BufferedInputStream getMarkedStream(InputStream in)
	{
		int bufferSize = BufferIORequest.getByteIOBufferSize();
		BufferedInputStream markable
			= new BufferedInputStream(in, bufferSize);
		assert(markable.markSupported());
		markable.mark(bufferSize);
		return markable;
	} 

	
	
	public static boolean isGzipped(InputStream sample)
		throws IOException
	{
		int magic1 = GZIPInputStream.GZIP_MAGIC & 0xff;
		int magic2 = (GZIPInputStream.GZIP_MAGIC >> 8) & 0xff;
		return sample.read() == magic1
			&& sample.read() == magic2;
	} 

	
	
	public static List<EncodingDetector> getEncodingDetectors()
	{
		List<EncodingDetector> detectors
			= new ArrayList<EncodingDetector>();
		String propName = ""encodingDetectors"";
		String selectedDetectors
			= jEdit.getProperty(propName, ""BOM XML-PI"");
		if (selectedDetectors != null
			&& selectedDetectors.length() > 0)
		{
			for (String name: selectedDetectors.split(""\\s+""))
			{
				EncodingDetector service
					= getEncodingDetectorService(name);
				if (service != null)
				{
					detectors.add(service);
				}
				else
				{
					Log.log(Log.ERROR, AutoDetection.class
						, ""getEncodingDetectors():""
							+ "" No EncodingDetector for the name""
							+ "" \"""" + name + ""\"""");
				}
			}
		}
		return detectors;
	} 

	
	
	public static String getDetectedEncoding(BufferedInputStream markedStream)
		throws IOException
	{
		List<EncodingDetector> detectors = getEncodingDetectors();
		for (EncodingDetector detector: detectors)
		{
			
			
			
			markedStream.reset();
			
			
			
			String detected = detector.detectEncoding(
				new BufferedInputStream(markedStream));
			if (detected != null)
			{
				return detected;
			}
		}
		return null;
	} 

	
	
	public static class Result
	{
		
		
		public Result(InputStream in) throws IOException
		{
			BufferedInputStream marked = getMarkedStream(in);

			gzipped = isGzipped(marked);
			if (gzipped)
			{
				marked.reset();
				marked = getMarkedStream(
					new GZIPInputStream(marked));
			}

			marked.reset();
			encoding = AutoDetection.getDetectedEncoding(marked);

			markedStream = marked;
		} 

		
		
		public BufferedInputStream getRewindedStream()
			throws IOException
		{
			markedStream.reset();
			return markedStream;
		} 

		
		
		public boolean streamIsGzipped()
		{
			return gzipped;
		} 

		
		
		public String getDetectedEncoding()
		{
			return encoding;
		} 

		
		private final BufferedInputStream markedStream;
		private final boolean gzipped;
		private final String encoding;
		
	} 

	
	
	private static EncodingDetector getEncodingDetectorService(String name)
	{
		String serviceClass = ""org.gjt.sp.jedit.io.EncodingDetector"";
		Object service = ServiceManager.getService(serviceClass, name);
		if (service != null && service instanceof EncodingDetector)
		{
			return (EncodingDetector)service;
		}
		else
		{
			return null;
		}
	}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.search.SearchAndReplace,44,1,0,49,156,632,15,39,32,0.773784355,1802,1.0,4,0.0,0.104651163,0,0,39.70454545,30,3.25,0,"

package org.gjt.sp.jedit.search;


import org.gjt.sp.jedit.bsh.*;
import java.awt.*;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.gui.TextAreaDialog;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.PositionChanging;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.util.ReverseCharSequence;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class SearchAndReplace
{
	

	
	
	public static void setSearchString(String search)
	{
		if(search.equals(SearchAndReplace.search))
			return;

		SearchAndReplace.search = search;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static String getSearchString()
	{
		return search;
	} 

	
	
	public static void setReplaceString(String replace)
	{
		if(replace.equals(SearchAndReplace.replace))
			return;

		SearchAndReplace.replace = replace;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static String getReplaceString()
	{
		return replace;
	} 

	
	
	public static void setIgnoreCase(boolean ignoreCase)
	{
		if(ignoreCase == SearchAndReplace.ignoreCase)
			return;

		SearchAndReplace.ignoreCase = ignoreCase;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	
	public static void setRegexp(boolean regexp)
	{
		if(regexp == SearchAndReplace.regexp)
			return;

		SearchAndReplace.regexp = regexp;
		if(regexp && reverse)
			reverse = false;

		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getRegexp()
	{
		return regexp;
	} 

	
	
	public static void setReverseSearch(boolean reverse)
	{
		if(reverse == SearchAndReplace.reverse)
			return;

		SearchAndReplace.reverse = reverse;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getReverseSearch()
	{
		return reverse;
	} 

	
	
	public static void setBeanShellReplace(boolean beanshell)
	{
		if(beanshell == SearchAndReplace.beanshell)
			return;

		SearchAndReplace.beanshell = beanshell;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getBeanShellReplace()
	{
		return beanshell;
	} 

	
	
	public static void setAutoWrapAround(boolean wrap)
	{
		if(wrap == SearchAndReplace.wrap)
			return;

		SearchAndReplace.wrap = wrap;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getAutoWrapAround()
	{
		return wrap;
	} 

	
	
	public static void setSearchMatcher(SearchMatcher matcher)
	{
		SearchAndReplace.matcher = matcher;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static SearchMatcher getSearchMatcher()
		throws Exception {
		if (matcher != null)
			return matcher;

		if (search == null || """".equals(search))
			return null;

		if (regexp)
		{
			Pattern re = Pattern.compile(search, 
				PatternSearchMatcher.getFlag(ignoreCase));
			matcher = new PatternSearchMatcher(re, ignoreCase);
		}
		else
			matcher = new BoyerMooreSearchMatcher(search, ignoreCase);

		return matcher;
	} 

	
	
	public static void setSearchFileSet(SearchFileSet fileset)
	{
		SearchAndReplace.fileset = fileset;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static SearchFileSet getSearchFileSet()
	{
		return fileset;
	} 

	
	
	public static boolean getSmartCaseReplace()
	{
		return (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);
	} 

	

	

	
	
	public static boolean hyperSearch(View view)
	{
		return hyperSearch(view,false);
	} 

	
	
	public static boolean hyperSearch(View view, boolean selection)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		record(view,""hyperSearch(view,"" + selection + ')',false,
			!selection);

		view.getDockableWindowManager().addDockableWindow(
			HyperSearchResults.NAME);
		HyperSearchResults results = (HyperSearchResults)
			view.getDockableWindowManager()
			.getDockable(HyperSearchResults.NAME);
		results.searchStarted();

		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
			{
				view.getToolkit().beep();
				results.searchFailed();
				return false;
			}

			Selection[] s;
			if(selection)
			{
				s = view.getTextArea().getSelection();
				if(s == null)
				{
					results.searchFailed();
					return false;
				}
			}
			else
				s = null;
			VFSManager.runInWorkThread(new HyperSearchRequest(view,
				matcher,results,s));
			return true;
		}
		catch(Exception e)
		{
			results.searchFailed();
			handleError(comp,e);
			return false;
		}
	} 

	
	
	public static boolean find(View view)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null || !comp.isShowing())
			comp = view;

		String path = fileset.getNextFile(view,null);
		if(path == null)
		{
			GUIUtilities.error(comp,""empty-fileset"",null);
			return false;
		}

		boolean _reverse = reverse && fileset instanceof CurrentBufferSet;

		try
		{
			view.showWaitCursor();

			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
			{
				view.getToolkit().beep();
				return false;
			}

			record(view,""find(view)"",false,true);

			boolean repeat = false;
loop:			for(;;)
			{
				while(path != null)
				{
					Buffer buffer = jEdit.openTemporary(
						view,null,path,false);

					
					path = fileset.getNextFile(view,path);

					if(buffer == null)
						continue loop;

					
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();

					int start;

					if(view.getBuffer() == buffer && !repeat)
					{
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else if(_reverse)
							start = s.getStart();
						else
							start = s.getEnd();
					}
					else if(_reverse)
						start = buffer.getLength();
					else
						start = 0;

					if(find(view,buffer,start,repeat,_reverse))
						return true;
				}

				if(repeat)
				{
					if(!BeanShell.isScriptRunning())
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(""view.status.search-not-found""));

						view.getToolkit().beep();
					}
					return false;
				}

				boolean restart;

				
				
				
				
				if(wrap)
				{
					if(!BeanShell.isScriptRunning())
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(""view.status.auto-wrap""));
						
						if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
						{
							view.getToolkit().beep();
						}
					}
					restart = true;
				}
				else if(BeanShell.isScriptRunning())
				{
					restart = false;
				}
				else
				{
					Integer[] args = {Integer.valueOf(_reverse ? 1 : 0)};
					int result = GUIUtilities.confirm(comp,
						""keepsearching"",args,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					restart = (result == JOptionPane.YES_OPTION);
				}

				if(restart)
				{
					
					path = fileset.getFirstFile(view);
					repeat = true;
				}
				else
					break loop;
			}
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			view.hideWaitCursor();
		}

		return false;
	} 

	
	
	public static boolean find(View view, Buffer buffer, int start)
		throws Exception
	{
		return find(view,buffer,start,false,false);
	} 

	
	
	public static boolean find(View view, Buffer buffer, int start,
		boolean firstTime, boolean reverse) throws Exception
	{
		
		EditBus.send(new PositionChanging(view.getEditPane()));
		
		SearchMatcher matcher = getSearchMatcher();
		if(matcher == null)
		{
			view.getToolkit().beep();
			return false;
		}

		CharSequence text;
		boolean startOfBuffer;
		boolean endOfBuffer;
		if(reverse)
		{
			text = new ReverseCharSequence(buffer.getSegment(0,start));
			startOfBuffer = true;
			endOfBuffer = (start == buffer.getLength());
		}
		else
		{
			text = buffer.getSegment(start,buffer.getLength() - start);
			startOfBuffer = (start == 0);
			endOfBuffer = true;
		}
		SearchMatcher.Match match = matcher.nextMatch(text,
			startOfBuffer,endOfBuffer,firstTime,reverse);
		if(match != null)
		{
			jEdit.commitTemporary(buffer);
			view.setBuffer(buffer,true);
			JEditTextArea textArea = view.getTextArea();

			if(reverse)
			{
				textArea.setSelection(new Selection.Range(
					start - match.end,
					start - match.start));
				
				textArea.scrollTo(start - match.start,false);
				textArea.moveCaretPosition(start - match.end);
			}
			else
			{
				textArea.setSelection(new Selection.Range(
					start + match.start,
					start + match.end));
				textArea.moveCaretPosition(start + match.end);
				
				textArea.scrollTo(start + match.start,false);
			}

			return true;
		}
		else
			return false;
	} 

	
	
	public static boolean replace(View view)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		JEditTextArea textArea = view.getTextArea();

		Buffer buffer = view.getBuffer();
		if(!buffer.isEditable())
			return false;

		boolean smartCaseReplace = getSmartCaseReplace();

		Selection[] selection = textArea.getSelection();
		if (selection.length == 0)
		{
			view.getToolkit().beep();
			return false;
		}

		record(view,""replace(view)"",true,false);

		
		int caret = textArea.getCaretPosition();
		Selection s = textArea.getSelectionAtOffset(caret);
		if(s != null)
			caret = s.getStart();

		try
		{
			buffer.beginCompoundEdit();

			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;

			initReplace();

			int retVal = 0;

			for(int i = 0; i < selection.length; i++)
			{
				s = selection[i];

				retVal += replaceInSelection(view,textArea,
					buffer,matcher,smartCaseReplace,s);
			}

			boolean _reverse = !regexp && reverse && fileset instanceof CurrentBufferSet;
			if(_reverse)
			{
				
				
				textArea.moveCaretPosition(caret);
			}
			else
			{
				s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s != null)
					textArea.moveCaretPosition(s.getEnd());
			}

			if(!BeanShell.isScriptRunning())
			{
				Object[] args = {Integer.valueOf(retVal),
				                 Integer.valueOf(1)};
				view.getStatus().setMessageAndClear(jEdit.getProperty(
					""view.status.replace-all"",args));
			}

			if(retVal == 0)
			{
				view.getToolkit().beep();
				return false;
			}

			return true;
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		return false;
	} 

	
	
	public static boolean replace(View view, Buffer buffer, int start, int end)
	{
		if(!buffer.isEditable())
			return false;

		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		boolean smartCaseReplace = getSmartCaseReplace();

		try
		{
			buffer.beginCompoundEdit();

			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;

			initReplace();

			int retVal = 0;

			retVal += _replace(view,buffer,matcher,start,end,
				smartCaseReplace);

			if(retVal != 0)
				return true;
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		return false;
	} 

	
	
	public static boolean replaceAll(View view)
	{
		return replaceAll(view,false);
	} 
	
	
	
	public static boolean replaceAll(View view, boolean dontOpenChangedFiles)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		if(fileset.getFileCount(view) == 0)
		{
			GUIUtilities.error(comp,""empty-fileset"",null);
			return false;
		}

		record(view,""replaceAll(view)"",true,true);

		view.showWaitCursor();

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		int fileCount = 0;
		int occurCount = 0;
		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;

			initReplace();

			String path = fileset.getFirstFile(view);
loop:			while(path != null)
			{
				Buffer buffer = jEdit.openTemporary(
					view,null,path,false);

				
				path = fileset.getNextFile(view,path);

				if(buffer == null)
					continue loop;

				
				if(buffer.isPerformingIO())
					VFSManager.waitForRequests();

				if(!buffer.isEditable())
					continue loop;

				
				
				int retVal = 0;

				try
				{
					buffer.beginCompoundEdit();
					retVal = _replace(view,buffer,matcher,
						0,buffer.getLength(),
						smartCaseReplace);
				}
				finally
				{
					buffer.endCompoundEdit();
				}

				if(retVal != 0)
				{
					fileCount++;
					occurCount += retVal;
					if (dontOpenChangedFiles)
					{
						buffer.save(null,null);
					}
					else
					{
						jEdit.commitTemporary(buffer);
						jEdit.getBufferSetManager().addBuffer(view, buffer);
					}
				}
			}
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			view.hideWaitCursor();
		}

		
		if(!BeanShell.isScriptRunning())
		{
			Object[] args = {Integer.valueOf(occurCount),
			                 Integer.valueOf(fileCount)};
			view.getStatus().setMessageAndClear(jEdit.getProperty(
				""view.status.replace-all"",args));
			if(occurCount == 0)
				view.getToolkit().beep();
		}

		return (fileCount != 0);
	} 

	

	
	
	public static String escapeRegexp(String str, boolean multiline)
	{
		return StandardUtilities.charsToEscapes(str,
			""\r\t\\()[]{}$^*+?|.""
			+ (multiline ? """" : ""\n""));
	} 

	
	
	public static void load()
	{
		search = jEdit.getProperty(""search.find.value"");
		replace = jEdit.getProperty(""search.replace.value"");
		ignoreCase = jEdit.getBooleanProperty(""search.ignoreCase.toggle"");
		regexp = jEdit.getBooleanProperty(""search.regexp.toggle"");
		beanshell = jEdit.getBooleanProperty(""search.beanshell.toggle"");
		wrap = jEdit.getBooleanProperty(""search.wrap.toggle"");

		fileset = new CurrentBufferSet();

		
		
		
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static void save()
	{
		jEdit.setProperty(""search.find.value"",search);
		jEdit.setProperty(""search.replace.value"",replace);
		jEdit.setBooleanProperty(""search.ignoreCase.toggle"",ignoreCase);
		jEdit.setBooleanProperty(""search.regexp.toggle"",regexp);
		jEdit.setBooleanProperty(""search.beanshell.toggle"",beanshell);
		jEdit.setBooleanProperty(""search.wrap.toggle"",wrap);
	} 

	
	static void handleError(Component comp, Exception e)
	{
		Log.log(Log.ERROR,SearchAndReplace.class,e);
		if(comp instanceof Dialog)
		{
			new TextAreaDialog((Dialog)comp,
				beanshell ? ""searcherror-bsh""
				: ""searcherror"",e);
		}
		else
		{
			new TextAreaDialog((Frame)comp,
				beanshell ? ""searcherror-bsh""
				: ""searcherror"",e);
		}
	} 

	

	
	private static String search;
	private static String replace;
	private static BshMethod replaceMethod;
	private static NameSpace replaceNS = new NameSpace(
		BeanShell.getNameSpace(),
		BeanShell.getNameSpace().getClassManager(),
		""search and replace"");
	private static boolean regexp;
	private static boolean ignoreCase;
	private static boolean reverse;
	private static boolean beanshell;
	private static boolean wrap;
	private static SearchMatcher matcher;
	private static SearchFileSet fileset;
	

	
	
	private static void initReplace() throws Exception
	{
		if(beanshell && replace.length() != 0)
		{
			replaceMethod = BeanShell.cacheBlock(""replace"",
				""return ("" + replace + "");"",true);
		}
		else
			replaceMethod = null;
	} 

	
	private static void record(View view, String action,
		boolean replaceAction, boolean recordFileSet)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null)
		{
			recorder.record(""SearchAndReplace.setSearchString(\""""
				+ StandardUtilities.charsToEscapes(search) + ""\"");"");

			if(replaceAction)
			{
				recorder.record(""SearchAndReplace.setReplaceString(\""""
					+ StandardUtilities.charsToEscapes(replace) + ""\"");"");
				recorder.record(""SearchAndReplace.setBeanShellReplace(""
					+ beanshell + "");"");
			}
			else
			{
				
				recorder.record(""SearchAndReplace.setAutoWrapAround(""
					+ wrap + "");"");
				recorder.record(""SearchAndReplace.setReverseSearch(""
					+ reverse + "");"");
			}

			recorder.record(""SearchAndReplace.setIgnoreCase(""
				+ ignoreCase + "");"");
			recorder.record(""SearchAndReplace.setRegexp(""
				+ regexp + "");"");

			if(recordFileSet)
			{
				recorder.record(""SearchAndReplace.setSearchFileSet(""
					+ fileset.getCode() + "");"");
			}

			recorder.record(""SearchAndReplace."" + action + ';');
		}
	} 

	
	private static int replaceInSelection(View view, TextArea textArea,
		Buffer buffer, SearchMatcher matcher, boolean smartCaseReplace,
		Selection s) throws Exception
	{
		
		int start = s.getStart();

		int returnValue;

		if(s instanceof Selection.Range)
		{
			returnValue = _replace(view,buffer,matcher,
				s.getStart(),s.getEnd(),
				smartCaseReplace);

			textArea.removeFromSelection(s);
			textArea.addToSelection(new Selection.Range(
				start,s.getEnd()));
		}
		else if(s instanceof Selection.Rect)
		{
			Selection.Rect rect = (Selection.Rect)s;
			int startCol = rect.getStartColumn(
				buffer);
			int endCol = rect.getEndColumn(
				buffer);

			returnValue = 0;
			for(int j = s.getStartLine(); j <= s.getEndLine(); j++)
			{
				returnValue += _replace(view,buffer,matcher,
					getColumnOnOtherLine(buffer,j,startCol),
					getColumnOnOtherLine(buffer,j,endCol),
					smartCaseReplace);
			}
			textArea.addToSelection(new Selection.Rect(
				start,s.getEnd()));
		}
		else
			throw new RuntimeException(""Unsupported: "" + s);

		return returnValue;
	} 

	
	
	private static int _replace(View view, JEditBuffer buffer,
		SearchMatcher matcher, int start, int end,
		boolean smartCaseReplace)
		throws Exception
	{
		int occurCount = 0;

		boolean endOfLine = (buffer.getLineEndOffset(
			buffer.getLineOfOffset(end)) - 1 == end);

		int offset = start;
loop:		for(int counter = 0; ; counter++)
		{
			boolean startOfLine = (buffer.getLineStartOffset(
				buffer.getLineOfOffset(offset)) == offset);

			CharSequence text = buffer.getSegment(offset,end - offset);
			SearchMatcher.Match occur = matcher.nextMatch(
				text,startOfLine,endOfLine,counter == 0,false);
			if(occur == null)
				break loop;

			String found = text.subSequence(
				occur.start, occur.end).toString();

			int length = replaceOne(view,buffer,occur,offset,
				found,smartCaseReplace);
			if(length == -1)
				offset += occur.end;
			else
			{
				offset += occur.start + length;
				end += (length - found.length());
				occurCount++;
			}
		}

		return occurCount;
	} 

	
	
	private static int replaceOne(View view, JEditBuffer buffer,
		SearchMatcher.Match occur, int offset, String found,
		boolean smartCaseReplace)
		throws Exception
	{
		String subst = replaceOne(view,occur,found);
		if(smartCaseReplace && ignoreCase)
		{
			int strCase = TextUtilities.getStringCase(found);
			if(strCase == TextUtilities.LOWER_CASE)
				subst = subst.toLowerCase();
			else if(strCase == TextUtilities.UPPER_CASE)
				subst = subst.toUpperCase();
			else if(strCase == TextUtilities.TITLE_CASE)
				subst = TextUtilities.toTitleCase(subst);
		}

		if(subst != null)
		{
			int start = offset + occur.start;
			int end = offset + occur.end;

			if (end - start > 0)
				buffer.remove(start,end - start);
			buffer.insert(start,subst);
			return subst.length();
		}
		else
			return -1;
	} 

	
	private static String replaceOne(View view,
		SearchMatcher.Match occur, String found)
		throws Exception
	{
		if(regexp)
		{
			if(replaceMethod != null)
				return regexpBeanShellReplace(view,occur);
			else
				return regexpReplace(occur,found);
		}
		else
		{
			if(replaceMethod != null)
				return literalBeanShellReplace(view,found);
			else
				return replace;
		}
	} 

	
	private static String regexpBeanShellReplace(View view,
		SearchMatcher.Match occur) throws Exception
	{
		for(int i = 0; i < occur.substitutions.length; i++)
		{
			replaceNS.setVariable(""_"" + i,
				occur.substitutions[i]);
		}

		Object obj = BeanShell.runCachedBlock(
			replaceMethod,view,replaceNS);
		if(obj == null)
			return """";
		else
			return obj.toString();
	} 

	
	private static String regexpReplace(SearchMatcher.Match occur,
		String found) throws Exception
	{
		StringBuilder buf = new StringBuilder();

		for(int i = 0; i < replace.length(); i++)
		{
			char ch = replace.charAt(i);
			switch(ch)
			{
			case '$':
				if(i == replace.length() - 1)
				{
					
					
					buf.append(ch);
					break;
				}

				ch = replace.charAt(++i);
				if(ch == '$')
				{
					
					buf.append('$');
				}
				else if(ch == '0')
				{
					
					
					buf.append(found);
				}
				else if(Character.isDigit(ch))
				{
					int n = ch - '0';
					while (i < replace.length() - 1)
					{
						ch = replace.charAt(++i);
						if (Character.isDigit(ch))
						{
							n = n * 10 + (ch - '0');
						}
						else
						{
							
							
							
							i--;
							break;
						}
					}
					if(n < occur
						.substitutions
						.length)
					{
						String subs = occur.substitutions[n];
						if (subs != null)
							buf.append(subs);
					}
				}
				break;
			case '\\':
				if(i == replace.length() - 1)
				{
					buf.append('\\');
					break;
				}
				ch = replace.charAt(++i);
				switch(ch)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(ch);
					break;
				}
				break;
			default:
				buf.append(ch);
				break;
			}
		}

		return buf.toString();
	} 

	
	private static String literalBeanShellReplace(View view, String found)
		throws Exception
	{
		replaceNS.setVariable(""_0"",found);
		Object obj = BeanShell.runCachedBlock(
			replaceMethod,
			view,replaceNS);
		if(obj == null)
			return """";
		else
			return obj.toString();
	} 

	
	
	private static int getColumnOnOtherLine(Buffer buffer, int line,
		int col)
	{
		int returnValue = buffer.getOffsetOfVirtualColumn(
			line,col,null);
		if(returnValue == -1)
			return buffer.getLineEndOffset(line) - 1;
		else
			return buffer.getLineStartOffset(line) + returnValue;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.KeyEventTranslator,11,1,0,10,47,41,5,5,9,0.7,551,0.5,0,0.0,0.1375,0,0,48.36363636,25,5.8182,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import java.util.HashMap;
import java.util.Map;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class KeyEventTranslator
{
	
	
	public static void addTranslation(Key key1, Key key2)
	{
		transMap.put(key1,key2);
	} 

	

	protected static KeyEvent lastKeyPressEvent;

	protected static boolean lastKeyPressAccepted;

	
	public static Key translateKeyEvent(KeyEvent evt)
	{
		Key key = translateKeyEvent2(evt);

		if (key!=null)
		{
			if (key.isPhantom())
			{
				key = null;
			}
		}

		return key;
	}

	
	public static Key translateKeyEvent2(KeyEvent evt)
	{
		int modifiers = evt.getModifiers();
		Key returnValue;

		switch(evt.getID())
		{
		case KeyEvent.KEY_PRESSED:
			int keyCode = evt.getKeyCode();
			if((keyCode >= KeyEvent.VK_0
				&& keyCode <= KeyEvent.VK_9)
				|| (keyCode >= KeyEvent.VK_A
				&& keyCode <= KeyEvent.VK_Z))
			{
				if(Debug.ALTERNATIVE_DISPATCHER)
					return null;
				else
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						'\0',Character.toLowerCase(
						(char)keyCode));
				}
			}
			else
			{
				if(keyCode == KeyEvent.VK_TAB)
				{
					evt.consume();
					returnValue = new Key(
						modifiersToString(modifiers),
						keyCode,'\0');
				}
				else if(keyCode == KeyEvent.VK_SPACE)
				{
					
					
					
					
					
					
					if((modifiers & ~InputEvent.SHIFT_MASK) == 0)
						returnValue = null;
					else
					{
						returnValue = new Key(
							modifiersToString(modifiers),
							0,' ');
					}
				}
				else
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						keyCode,'\0');
				}
			}
			break;
		case KeyEvent.KEY_TYPED:
			char ch = evt.getKeyChar();

			if(KeyEventWorkaround.isMacControl(evt))
				ch |= 0x60;

			switch(ch)
			{
			case '\n':
			case '\t':
			case '\b':
				return null;
			case ' ':
				if((modifiers & ~InputEvent.SHIFT_MASK) != 0)
					return null;
			}

			int ignoreMods;
			if(Debug.ALT_KEY_PRESSED_DISABLED)
			{
				
				ignoreMods = InputEvent.SHIFT_MASK
					| InputEvent.ALT_GRAPH_MASK
					| InputEvent.ALT_MASK;
			}
			else
			{
				
				ignoreMods = InputEvent.SHIFT_MASK
					| InputEvent.ALT_GRAPH_MASK;
			}

			if((modifiers & InputEvent.ALT_GRAPH_MASK) == 0
				&& (modifiers & ~ignoreMods) != 0)
			{
				if(Debug.ALTERNATIVE_DISPATCHER)
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						0,ch);
				}
				else
					return null;
			}
			else
			{
				if(ch == ' ')
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						0,ch);
				}
				else
					returnValue = new Key(null,0,ch);
			}
			break;
		default:
			return null;
		}

		
		Key trans = transMap.get(returnValue);
		if(trans == null)
			return returnValue;
		else
			return trans;
	} 

	
	
	public static Key parseKey(String keyStroke)
	{
		if(keyStroke == null)
			return null;
		int modifiers = 0;
		String key;
		int endOfModifiers = keyStroke.indexOf('+');
		if(endOfModifiers <= 0)	
		{
			key = keyStroke;
		}
		else
		{
			for(int i = 0; i < endOfModifiers; i++)
			{
				switch(Character.toUpperCase(keyStroke
					.charAt(i)))
				{
				case 'A':
					modifiers |= a;
					break;
				case 'C':
					modifiers |= c;
					break;
				case 'M':
					modifiers |= m;
					break;
				case 'S':
					modifiers |= s;
					break;
				}
			}
			key = keyStroke.substring(endOfModifiers + 1);
		}
		if(key.length() == 1)
		{
			return new Key(modifiersToString(modifiers),0,key.charAt(0));
		}
		else if(key.length() == 0)
		{
			Log.log(Log.ERROR,KeyEventTranslator.class,
				""Invalid key stroke: "" + keyStroke);
			return null;
		}
		else if(key.equals(""SPACE""))
		{
			return new Key(modifiersToString(modifiers),0,' ');
		}
		else
		{
			int ch;

			try
			{
				ch = KeyEvent.class.getField(""VK_"".concat(key))
					.getInt(null);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,KeyEventTranslator.class,
					""Invalid key stroke: ""
					+ keyStroke);
				return null;
			}

			return new Key(modifiersToString(modifiers),ch,'\0');
		}
	} 

	
	
	public static void setModifierMapping(int c, int a, int m, int s)
	{

		int duplicateMapping =
			(c & a) | (c & m) | (c & s) | (a & m) | (a & s) | (m & s);

		if((duplicateMapping & InputEvent.CTRL_MASK) != 0)
		{
			throw new IllegalArgumentException(
				""CTRL is mapped to more than one modifier"");
		}
		if((duplicateMapping & InputEvent.ALT_MASK) != 0)
		{
			throw new IllegalArgumentException(
				""ALT is mapped to more than one modifier"");
		}
		if((duplicateMapping & InputEvent.META_MASK) != 0)
		{
			throw new IllegalArgumentException(
				""META is mapped to more than one modifier"");
		}
		if((duplicateMapping & InputEvent.SHIFT_MASK) != 0)
		{
			throw new IllegalArgumentException(
				""SHIFT is mapped to more than one modifier"");
		}

		KeyEventTranslator.c = c;
		KeyEventTranslator.a = a;
		KeyEventTranslator.m = m;
		KeyEventTranslator.s = s;
	} 

	
	
	public static char getSymbolicModifierName(int mod)
	{
		if((mod & c) != 0)
			return 'C';
		else if((mod & a) != 0)
			return 'A';
		else if((mod & m) != 0)
			return 'M';
		else if((mod & s) != 0)
			return 'S';
		else
			return '\0';
	} 

	
	private static final int[] MODS = {
		InputEvent.CTRL_MASK,
		InputEvent.ALT_MASK,
		InputEvent.META_MASK,
		InputEvent.SHIFT_MASK
	};

	public static String modifiersToString(int mods)
	{
		StringBuilder buf = null;

		for(int i = 0; i < MODS.length; i++)
		{
			if((mods & MODS[i]) != 0)
				buf = lazyAppend(buf,getSymbolicModifierName(MODS[i]));
		}

		if(buf == null)
			return null;
		else
			return buf.toString();
	} 

	
	
	public static String getModifierString(InputEvent evt)
	{
		StringBuilder buf = new StringBuilder();
		if(evt.isControlDown())
			buf.append(getSymbolicModifierName(InputEvent.CTRL_MASK));
		if(evt.isAltDown())
			buf.append(getSymbolicModifierName(InputEvent.ALT_MASK));
		if(evt.isMetaDown())
			buf.append(getSymbolicModifierName(InputEvent.META_MASK));
		if(evt.isShiftDown())
			buf.append(getSymbolicModifierName(InputEvent.SHIFT_MASK));
		return buf.length() == 0 ? null : buf.toString();
	} 

	static int c, a, m, s;

	
	
	private static final Map<Key, Key> transMap = new HashMap<Key, Key>();

	private static StringBuilder lazyAppend(StringBuilder buf, char ch)
	{
		if(buf == null)
			buf = new StringBuilder();
		if(buf.indexOf(String.valueOf(ch)) == -1)
			buf.append(ch);
		return buf;
	} 

	static
	{
		if(OperatingSystem.isMacOS())
		{
			setModifierMapping(
				InputEvent.META_MASK,  
				InputEvent.CTRL_MASK,  
				
				InputEvent.ALT_MASK,   
				InputEvent.SHIFT_MASK  );
		}
		else
		{
			setModifierMapping(
				InputEvent.CTRL_MASK,
				InputEvent.ALT_MASK,
				InputEvent.META_MASK,
				InputEvent.SHIFT_MASK);
		}
	} 

	
	public static class Key
	{
		public final String modifiers;
		public final int key;
		public final char input;

		private final int hashCode;
		
		protected boolean isFromGlobalContext;

		
		protected boolean isPhantom;

		public Key(String modifiers, int key, char input)
		{
			this.modifiers = modifiers;
			this.key = key;
			this.input = input;
			hashCode = key + input;
		}

		@Override
		public int hashCode()
		{
			return hashCode;
		}

		@Override
		public boolean equals(Object o)
		{
			if(o instanceof Key)
			{
				Key k = (Key)o;
				if(StandardUtilities.objectsEqual(modifiers,
					k.modifiers) && key == k.key
					&& input == k.input)
				{
					return true;
				}
			}

			return false;
		}

		@Override
		public String toString()
		{
			return (modifiers == null ? """" : modifiers)
				+ '<'
				+ Integer.toString(key,16)
				+ ','
				+ Integer.toString(input,16)
				+ '>';
		}

		public void setIsFromGlobalContext(boolean to)
		{
			isFromGlobalContext = to;
		}

		public boolean isFromGlobalContext()
		{
			return isFromGlobalContext;
		}

		public void setIsPhantom(boolean to)
		{
			isPhantom = to;
		}

		public boolean isPhantom()
		{
			return isPhantom;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHPrimarySuffix,6,2,0,20,46,15,2,18,1,1.114285714,427,0.0,0,0.772727273,0.619047619,0,0,69.0,1,0.8333,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;

class BSHPrimarySuffix extends SimpleNode
{
	public static final int
		CLASS = 0,
		INDEX = 1,
		NAME = 2,
		PROPERTY = 3;

	public int operation;
	Object index;
	public String field;

	BSHPrimarySuffix(int id) { super(id); }

	
	public Object doSuffix(
		Object obj, boolean toLHS, 
		CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		
		
		if ( operation == CLASS )
			if ( obj instanceof BSHType ) {
				if ( toLHS )
					throw new EvalError(""Can't assign .class"", 
						this, callstack );
				NameSpace namespace = callstack.top();
				return ((BSHType)obj).getType( callstack, interpreter );
			} else
				throw new EvalError(
					""Attempt to use .class suffix on non class."", 
					this, callstack );

		
		if ( obj instanceof SimpleNode )
			if ( obj instanceof BSHAmbiguousName )
				obj = ((BSHAmbiguousName)obj).toObject(callstack, interpreter);
			else
				obj = ((SimpleNode)obj).eval(callstack, interpreter);	
		else
			if ( obj instanceof LHS )
				try {
					obj = ((LHS)obj).getValue();
				} catch ( UtilEvalError e ) {
					throw e.toEvalError( this, callstack );
				}

		try
		{
			switch(operation)
			{
				case INDEX:
					return doIndex( obj, toLHS, callstack, interpreter );

				case NAME:
					return doName( obj, toLHS, callstack, interpreter );

				case PROPERTY:
					return doProperty( toLHS, obj, callstack, interpreter );

				default:
					throw new InterpreterError( ""Unknown suffix type"" );
			} 
		}
		catch(ReflectError e)
		{
			throw new EvalError(""reflection error: "" + e, this, callstack );
		}
		catch(InvocationTargetException e)
		{
			throw new TargetError( ""target exception"", e.getTargetException(), 
				this, callstack, true);
		}
	}

	
	private Object doName(
		Object obj, boolean toLHS, 
		CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError, InvocationTargetException
	{
		try {
			
			if ( field.equals(""length"") && obj.getClass().isArray() )
				if ( toLHS )
					throw new EvalError(
						""Can't assign array length"", this, callstack );
				else
					return new Primitive(Array.getLength(obj));
			
			
			if ( jjtGetNumChildren() == 0 ) 
				if ( toLHS )
					return Reflect.getLHSObjectField(obj, field);
				else
					return Reflect.getObjectFieldValue( obj, field );

			
			
			Object[] oa = ((BSHArguments)jjtGetChild(0)).getArguments(
				callstack, interpreter);

		
		
		
		
		
			try {
				return Reflect.invokeObjectMethod( 
					obj, field, oa, interpreter, callstack, this );
			} catch ( ReflectError e ) {
				throw new EvalError(
					""Error in method invocation: "" + e.getMessage(), 
					this, callstack );
			} catch ( InvocationTargetException e ) 
			{
				String msg = ""Method Invocation ""+field;
				Throwable te = e.getTargetException();

				
				boolean isNative = true;
				if ( te instanceof EvalError ) 
					if ( te instanceof TargetError )
						isNative = ((TargetError)te).inNativeCode();
					else
						isNative = false;
				
				throw new TargetError( msg, te, this, callstack, isNative );
			} 

		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}

	
	static int getIndexAux(
		Object obj, CallStack callstack, Interpreter interpreter, 
		SimpleNode callerInfo ) 
		throws EvalError
	{
		if ( !obj.getClass().isArray() )
			throw new EvalError(""Not an array"", callerInfo, callstack );

		int index;
		try {
			Object indexVal = 
				((SimpleNode)callerInfo.jjtGetChild(0)).eval( 
					callstack, interpreter );
			if ( !(indexVal instanceof Primitive) )
				indexVal = Types.castObject(
					indexVal, Integer.TYPE, Types.ASSIGNMENT );
			index = ((Primitive)indexVal).intValue();
		} catch( UtilEvalError e ) {
			Interpreter.debug(""doIndex: ""+e);
			throw e.toEvalError( 
				""Arrays may only be indexed by integer types."", 
				callerInfo, callstack );
		}

		return index;
	}

	
	private Object doIndex( 
		Object obj, boolean toLHS, 
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError, ReflectError
	{
		int index = getIndexAux( obj, callstack, interpreter, this );
		if ( toLHS )
			return new LHS(obj, index);
		else
			try {
				return Reflect.getIndex(obj, index);
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack );
			}
	}

	
	private Object doProperty( boolean toLHS,
		Object obj, CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		if(obj == Primitive.VOID)
			throw new EvalError( 
			""Attempt to access property on undefined variable or class name"", 
				this, callstack );

		if ( obj instanceof Primitive )
			throw new EvalError(""Attempt to access property on a primitive"", 
				this, callstack );

		Object value = ((SimpleNode)jjtGetChild(0)).eval(
			callstack, interpreter);

		if ( !( value instanceof String ) )
			throw new EvalError(
				""Property expression must be a String or identifier."", 
				this, callstack );

		if ( toLHS )
			return new LHS(obj, (String)value);

		
		CollectionManager cm = CollectionManager.getCollectionManager();
		if ( cm.isMap( obj ) )
		{
			Object val = cm.getFromMap( obj, value );
			return ( val == null ?  val = Primitive.NULL : val );
		}

		try {
			return Reflect.getObjectProperty( obj, (String)value );
		}
		catch ( UtilEvalError e)  
		{
			throw e.toEvalError( ""Property: ""+value, this, callstack );
		}
		catch (ReflectError e) 
		{
			throw new EvalError(""No such property: "" + value, this, callstack );
		}
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.syntax.SyntaxStyle,4,1,0,21,5,0,21,0,4,0.666666667,28,1.0,0,0.0,0.5,0,0,5.25,1,0.75,0,"
package org.gjt.sp.jedit.syntax;

import java.awt.Font;
import java.awt.Color;


public class SyntaxStyle
{
	
	
	public SyntaxStyle(Color fgColor, Color bgColor, Font font)
	{
		this.fgColor = fgColor;
		this.bgColor = bgColor;
		this.font = font;
	} 

	
	
	public Color getForegroundColor()
	{
		return fgColor;
	} 

	
	
	public Color getBackgroundColor()
	{
		return bgColor;
	} 

	
	
	public Font getFont()
	{
		return font;
	} 

	
	private Color fgColor;
	private Color bgColor;
	private Font font;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.GutterOptionPane,11,6,0,11,70,47,3,10,8,0.911111111,672,1.0,11,0.985272459,0.272727273,3,5,57.63636364,3,1.3636,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import java.awt.*;

import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;

import org.gjt.sp.util.SyntaxUtilities;

public class GutterOptionPane extends AbstractOptionPane
{
	
	public GutterOptionPane()
	{
		super(""gutter"");
	} 

	
	public void _init()
	{
		
		gutterEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.enabled""));
		gutterEnabled.setSelected(isGutterEnabled());
		addComponent(gutterEnabled);

		
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridheight = 1;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.HORIZONTAL;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.ipadx = 0;
		cons.ipady = 0;
		cons.insets = new Insets(0,0,0,0);
		gutterComponents = new JPanel(new GridBagLayout());
		gutterComponents.setBorder(BorderFactory.createTitledBorder(
			jEdit.getProperty(""options.gutter.optionalComponents"")));

		
		lineNumbersEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.lineNumbers""));
		lineNumbersEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		gutterComponents.add(lineNumbersEnabled, cons);

		InputVerifier integerInputVerifier = new InputVerifier()
		{
			@Override
			public boolean verify(JComponent input)
			{
				if (! (input instanceof JTextField))
					return true;
				JTextField tf = (JTextField) input;
				int i;
				try
				{
					i = Integer.valueOf(tf.getText()).intValue();
				}
				catch (Exception e)
				{
					return false;
				}
				return (i >= 0);
			}
		};
		minLineNumberDigits = new JTextField(String.valueOf(
				getMinLineNumberDigits()),1);
		minLineNumberDigits.setInputVerifier(integerInputVerifier);
		JPanel minLineNumberDigitsPanel = new JPanel();
		minLineNumberDigitsPanel.add(new JLabel(
			jEdit.getProperty(""options.gutter.minLineNumberDigits"")));
		minLineNumberDigitsPanel.add(minLineNumberDigits);
		cons.gridy = 1;
		gutterComponents.add(minLineNumberDigitsPanel, cons);

		
		selectionAreaEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.selectionAreaEnabled""));
		selectionAreaEnabled.setSelected(isSelectionAreaEnabled());
		cons.gridy = 2;
		gutterComponents.add(selectionAreaEnabled, cons);

		addComponent(gutterComponents);
		
		setGutterComponentsEnabledState();
		gutterEnabled.addChangeListener(new ChangeListener()
		{
			public void stateChanged(ChangeEvent e)
			{
				setGutterComponentsEnabledState();
			}
		});

		
		addComponent(jEdit.getProperty(""options.gutter.selectionAreaBgColor""),
			selectionAreaBgColor = new ColorWellButton(
				getSelectionAreaBackground()), GridBagConstraints.VERTICAL);

		
		selectionAreaWidth = new JTextField(String.valueOf(
			getSelectionAreaWidth()),DEFAULT_SELECTION_GUTTER_WIDTH);
		selectionAreaWidth.setInputVerifier(integerInputVerifier);
		addComponent(jEdit.getProperty(""options.gutter.selectionAreaWidth""),
			selectionAreaWidth);

		
		gutterFont = new FontSelector(
			jEdit.getFontProperty(""view.gutter.font"",
			new Font(""Monospaced"",Font.PLAIN,10)));

		addComponent(jEdit.getProperty(""options.gutter.font""),gutterFont);

		
		addComponent(jEdit.getProperty(""options.gutter.foreground""),
			gutterForeground = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.fgColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.background""),
			gutterBackground = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.bgColor"")),
			GridBagConstraints.VERTICAL);

		
		

		
		

		
		gutterCurrentLineHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.currentLineHighlight""));
		gutterCurrentLineHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		addComponent(gutterCurrentLineHighlightEnabled,
			gutterCurrentLineHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.currentLineColor"")),
			GridBagConstraints.VERTICAL);

		
		gutterHighlightInterval = new JTextField(jEdit.getProperty(
			""view.gutter.highlightInterval""),3);

		Box gutterHighlightBox = new Box(BoxLayout.X_AXIS);
		gutterHighlightBox.add(new JLabel(jEdit.getProperty(
			""options.gutter.interval-1"")));
		gutterHighlightBox.add(Box.createHorizontalStrut(3));
		gutterHighlightBox.add(gutterHighlightInterval);
		gutterHighlightBox.add(Box.createHorizontalStrut(3));
		gutterHighlightBox.add(new JLabel(jEdit.getProperty(
			""options.gutter.interval-2"")));
		gutterHighlightBox.add(Box.createHorizontalStrut(12));

		addComponent(gutterHighlightBox,gutterHighlightColor
			= new ColorWellButton(jEdit.getColorProperty(
			""view.gutter.highlightColor"")),
			GridBagConstraints.VERTICAL);

		
		gutterStructureHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.structureHighlight""));
		gutterStructureHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.structureHighlight""));
		addComponent(gutterStructureHighlightEnabled,
			gutterStructureHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.structureHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		gutterMarkerHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.markerHighlight""));
		gutterMarkerHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		addComponent(gutterMarkerHighlightEnabled,
			gutterMarkerHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.markerColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.foldColor""),
			gutterFoldMarkers = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.foldColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.focusBorderColor""),
			gutterFocusBorder = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.focusBorderColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.noFocusBorderColor""),
			gutterNoFocusBorder = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor"")),
			GridBagConstraints.VERTICAL);
		
		addFoldStyleChooser();
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(""view.gutter.lineNumbers"", lineNumbersEnabled
			.isSelected());
		jEdit.setIntegerProperty(""view.gutter.minDigitCount"",
			Integer.valueOf(minLineNumberDigits.getText()));

		jEdit.setFontProperty(""view.gutter.font"",gutterFont.getFont());
		jEdit.setColorProperty(""view.gutter.fgColor"",gutterForeground
			.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.bgColor"",gutterBackground
			.getSelectedColor());

		

		jEdit.setBooleanProperty(""view.gutter.highlightCurrentLine"",
			gutterCurrentLineHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.currentLineColor"",
			gutterCurrentLineHighlight.getSelectedColor());
		jEdit.setProperty(""view.gutter.highlightInterval"",
			gutterHighlightInterval.getText());
		jEdit.setColorProperty(""view.gutter.highlightColor"",
			gutterHighlightColor.getSelectedColor());

		jEdit.setBooleanProperty(""view.gutter.structureHighlight"",
			gutterStructureHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.structureHighlightColor"",
			gutterStructureHighlight.getSelectedColor());
		jEdit.setBooleanProperty(""view.gutter.markerHighlight"",
			gutterMarkerHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.markerColor"",
			gutterMarkerHighlight.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.foldColor"",
			gutterFoldMarkers.getSelectedColor());
		jEdit.setProperty(JEditTextArea.FOLD_PAINTER_PROPERTY,
			painters[foldPainter.getSelectedIndex()]);
		jEdit.setColorProperty(""view.gutter.focusBorderColor"",
			gutterFocusBorder.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.noFocusBorderColor"",
			gutterNoFocusBorder.getSelectedColor());
		jEdit.setBooleanProperty(GUTTER_ENABLED_PROPERTY,
			gutterEnabled.isSelected());
		jEdit.setBooleanProperty(SELECTION_AREA_ENABLED_PROPERTY,
			selectionAreaEnabled.isSelected());
		jEdit.setColorProperty(SELECTION_AREA_BGCOLOR_PROPERTY,
			selectionAreaBgColor.getSelectedColor());
		jEdit.setIntegerProperty(""view.gutter.selectionAreaWidth"",
			Integer.valueOf(selectionAreaWidth.getText()));
	} 

	
	private void setGutterComponentsEnabledState()
	{
		GUIUtilities.setEnabledRecursively(gutterComponents,
			gutterEnabled.isSelected());
	} 

	
	private void addFoldStyleChooser()
	{
		painters = ServiceManager.getServiceNames(JEditTextArea.FOLD_PAINTER_SERVICE);
		foldPainter = new JComboBox();
		String current = JEditTextArea.getFoldPainterName();
		int selected = 0;
		for (int i = 0; i < painters.length; i++)
		{
			String painter = painters[i];
			foldPainter.addItem(jEdit.getProperty(
				""options.gutter.foldStyleNames."" + painter, painter));
			if (painter.equals(current))
				selected = i;
		}
		foldPainter.setSelectedIndex(selected);
		addComponent(new JLabel(jEdit.getProperty(""options.gutter.foldStyle.label"")), foldPainter);
	} 

	
	public static boolean isGutterEnabled()
	{
		return jEdit.getBooleanProperty(GUTTER_ENABLED_PROPERTY);
	} 

	
	public static int getMinLineNumberDigits()
	{
		int n = jEdit.getIntegerProperty(""view.gutter.minDigitCount"", 2);
		if (n < 0)
			n = 2;
		return n;
	} 

	
	public static boolean isSelectionAreaEnabled()
	{
		return jEdit.getBooleanProperty(SELECTION_AREA_ENABLED_PROPERTY);
	} 

	
	public static Color getSelectionAreaBackground()
	{
		String color = jEdit.getProperty(SELECTION_AREA_BGCOLOR_PROPERTY);
		if (color == null)
			return jEdit.getColorProperty(""view.gutter.bgColor"");
		return SyntaxUtilities.parseColor(color, Color.black);
	} 

	
	public static int getSelectionAreaWidth()
	{
		int n = jEdit.getIntegerProperty(""view.gutter.selectionAreaWidth"",
			DEFAULT_SELECTION_GUTTER_WIDTH);
		if (n < 0)
			n = DEFAULT_SELECTION_GUTTER_WIDTH;
		return n;
	} 

	
	private static final String GUTTER_ENABLED_PROPERTY =
		""view.gutter.enabled"";
	private static final String SELECTION_AREA_ENABLED_PROPERTY =
		""view.gutter.selectionAreaEnabled"";
	private static final String SELECTION_AREA_BGCOLOR_PROPERTY =
		""view.gutter.selectionAreaBgColor"";
	private static final int DEFAULT_SELECTION_GUTTER_WIDTH = 12;

	private FontSelector gutterFont;
	private ColorWellButton gutterForeground;
	private ColorWellButton gutterBackground;
	private JTextField gutterHighlightInterval;
	private ColorWellButton gutterHighlightColor;
	private JCheckBox lineNumbersEnabled;
	private JCheckBox gutterCurrentLineHighlightEnabled;
	private ColorWellButton gutterCurrentLineHighlight;
	private JCheckBox gutterStructureHighlightEnabled;
	private ColorWellButton gutterStructureHighlight;
	private JCheckBox gutterMarkerHighlightEnabled;
	private ColorWellButton gutterMarkerHighlight;
	private ColorWellButton gutterFoldMarkers;
	private JComboBox foldPainter;
	private ColorWellButton gutterFocusBorder;
	private ColorWellButton gutterNoFocusBorder;
	private String [] painters;
	private JCheckBox gutterEnabled;
	private JPanel gutterComponents;
	private JTextField minLineNumberDigits;
	private JCheckBox selectionAreaEnabled;
	private ColorWellButton selectionAreaBgColor;
	private JTextField selectionAreaWidth;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.ServiceManager,10,1,0,19,38,0,15,6,8,0.222222222,191,1.0,0,0.0,0.203703704,0,0,18.0,3,1.3,0,"

package org.gjt.sp.jedit;

import java.io.*;
import java.net.URL;
import java.util.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.jedit.buffer.FoldHandlerProvider;
import org.gjt.sp.jedit.buffer.FoldHandler;


public class ServiceManager
{
	
	
	public static void loadServices(PluginJAR plugin, URL uri,
		PluginJAR.PluginCacheEntry cache)
	{
		ServiceListHandler dh = new ServiceListHandler(plugin,uri);
		try
		{
			if (!XMLUtilities.parseXML(uri.openStream(), dh)
				&& cache != null)
			{
				cache.cachedServices = dh.getCachedServices();
			}
		}
		catch (IOException ioe)
		{
			Log.log(Log.ERROR, ServiceManager.class, ioe);
		}
	} 

	
	
	public static void unloadServices(PluginJAR plugin)
	{
		Iterator<Descriptor> descriptors = serviceMap.keySet().iterator();
		while(descriptors.hasNext())
		{
			Descriptor d = descriptors.next();
			if(d.plugin == plugin)
				descriptors.remove();
		}
	} 

	
	
	public static void registerService(String clazz, String name,
		String code, PluginJAR plugin)
	{
		Descriptor d = new Descriptor(clazz,name,code,plugin);
		serviceMap.put(d,d);
	} 

	
	
	public static void unregisterService(String clazz, String name)
	{
		Descriptor d = new Descriptor(clazz,name);
		serviceMap.remove(d);
	} 

	
	
	public static String[] getServiceTypes()
	{
		Set<String> returnValue = new HashSet<String>();

		Set<Descriptor> keySet = serviceMap.keySet();
		for (Descriptor d : keySet)
			returnValue.add(d.clazz);

		return returnValue.toArray(
			new String[returnValue.size()]);
	} 

	
	
	public static String[] getServiceNames(String clazz)
	{
		List<String> returnValue = new ArrayList<String>();

		Set<Descriptor> keySet = serviceMap.keySet();
		for (Descriptor d : keySet)
			if(d.clazz.equals(clazz))
				returnValue.add(d.name);


		return returnValue.toArray(
			new String[returnValue.size()]);
	} 

	
	
	public static Object getService(String clazz, String name)
	{
		
		Descriptor key = new Descriptor(clazz,name);
		Descriptor value = serviceMap.get(key);
		if(value == null)
		{
			
			return null;
		}
		else
		{
			if(value.code == null)
			{
				loadServices(value.plugin,
					value.plugin.getServicesURI(),
					null);
				value = serviceMap.get(key);
			}
			return value.getInstance();
		}
	} 

	

	
	
	static void registerService(Descriptor d)
	{
		serviceMap.put(d,d);
	} 

	

	
	private static final Map<Descriptor, Descriptor> serviceMap = new HashMap<Descriptor, Descriptor>();
	

	
	static class Descriptor
	{
		final String clazz;
		final String name;
		String code;
		PluginJAR plugin;
		Object instance;
		boolean instanceIsNull;

		
		Descriptor(String clazz, String name)
		{
			this.clazz = clazz;
			this.name  = name;
		}

		
		Descriptor(String clazz, String name, String code,
			PluginJAR plugin)
		{
			this.clazz  = clazz;
			this.name   = name;
			this.code   = code;
			this.plugin = plugin;
		}

		Object getInstance()
		{
			if(instanceIsNull)
				return null;
			else if(instance == null)
			{
				
				instance = BeanShell.eval(null,
					BeanShell.getNameSpace(),
					code);
				if(instance == null)
				{
					
					
					instanceIsNull = true;
				}
			}

			return instance;
		}
		public int hashCode()
		{
			return name.hashCode();
		}

		public boolean equals(Object o)
		{
			if(o instanceof Descriptor)
			{
				Descriptor d = (Descriptor)o;
				return d.clazz.equals(clazz)
					&& d.name.equals(name);
			}
			else
				return false;
		}
	} 

	
	public static class ServiceFoldHandlerProvider implements FoldHandlerProvider
	{
		
		public static final String SERVICE = ""org.gjt.sp.jedit.buffer.FoldHandler"";

		
		public FoldHandler getFoldHandler(String name)
		{
			FoldHandler handler = (FoldHandler) getService(SERVICE,name);
			return handler;
		}

		
		public String[] getFoldModes()
		{
			String[] handlers = getServiceNames(SERVICE);
			Arrays.sort(handlers,new StandardUtilities.StringCompare<String>());
			return handlers;
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.LHS,9,1,0,20,43,0,12,11,3,0.798076923,466,0.0,1,0.0,0.365079365,0,0,49.33333333,4,0.6667,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Field;


class LHS implements ParserConstants, java.io.Serializable
{
	NameSpace nameSpace;
	
	boolean localVar;

	
	static final int
		VARIABLE = 0,
		FIELD = 1,
		PROPERTY = 2,
		INDEX = 3,
		METHOD_EVAL = 4;

	int type;

	String varName;
	String propName;
	Field field;
	Object object;
	int index;


	LHS( NameSpace nameSpace, String varName )
	{
throw new Error(""namespace lhs"");

	}

	
	LHS( NameSpace nameSpace, String varName, boolean localVar )
	{
		type = VARIABLE;
		this.localVar = localVar;
		this.varName = varName;
		this.nameSpace = nameSpace;
	}

	
	LHS( Field field )
	{
		type = FIELD;
		this.object = null;
		this.field = field;
	}

	
	LHS( Object object, Field field )
	{
		if ( object == null)
			throw new NullPointerException(""constructed empty LHS"");

		type = FIELD;
		this.object = object;
		this.field = field;
	}

	
	LHS( Object object, String propName )
	{
		if(object == null)
			throw new NullPointerException(""constructed empty LHS"");

		type = PROPERTY;
		this.object = object;
		this.propName = propName;
	}

	
	LHS( Object array, int index )
	{
		if(array == null)
			throw new NullPointerException(""constructed empty LHS"");

		type = INDEX;
		this.object = array;
		this.index = index;
	}

	public Object getValue() throws UtilEvalError
	{
		if ( type == VARIABLE )
			return nameSpace.getVariable( varName );

		if (type == FIELD)
			try {
				Object o = field.get( object );
				return Primitive.wrap( o, field.getType() );
			} catch(IllegalAccessException e2) {
				throw new UtilEvalError(""Can't read field: "" + field);
			}

		if ( type == PROPERTY )
			try {
				return Reflect.getObjectProperty(object, propName);
			}
			catch(ReflectError e) {
				Interpreter.debug(e.getMessage());
				throw new UtilEvalError(""No such property: "" + propName);
			}

		if ( type == INDEX )
			try {
				return Reflect.getIndex(object, index);
			}
			catch(Exception e) {
				throw new UtilEvalError(""Array access: "" + e);
			}

		throw new InterpreterError(""LHS type"");
	}

	
	public Object assign( Object val, boolean strictJava ) 
		throws UtilEvalError
	{
		if ( type == VARIABLE )
		{
			
			if ( localVar )
				nameSpace.setLocalVariable( varName, val, strictJava );
			else
				nameSpace.setVariable( varName, val, strictJava );
		} else 
		if ( type == FIELD )
		{
			try {
				Object fieldVal = val instanceof Primitive ?  
					((Primitive)val).getValue() : val;

				
				ReflectManager.RMSetAccessible( field );
				field.set( object, fieldVal );
				return val;
			}
			catch( NullPointerException e) {   
    			throw new UtilEvalError(
					""LHS (""+field.getName()+"") not a static field."");
			}     
   			catch( IllegalAccessException e2) {   
				throw new UtilEvalError(
					""LHS (""+field.getName()+"") can't access field: ""+e2);
			}     
			catch( IllegalArgumentException e3) 
			{
				String type = val instanceof Primitive ?
					((Primitive)val).getType().getName()
					: val.getClass().getName();
				throw new UtilEvalError(
					""Argument type mismatch. "" + (val == null ? ""null"" : type )
					+ "" not assignable to field ""+field.getName());
			}
		}
		else 
		if ( type == PROPERTY )
		{
			
			CollectionManager cm = CollectionManager.getCollectionManager();
			if ( cm.isMap( object ) )
				cm.putInMap( object, propName, val );
			else
				try {
					Reflect.setObjectProperty(object, propName, val);
				}
				catch(ReflectError e) {
					Interpreter.debug(""Assignment: "" + e.getMessage());
					throw new UtilEvalError(""No such property: "" + propName);
				}
		} else 
		if ( type == INDEX )
			try {
				Reflect.setIndex(object, index, val);
			} catch ( UtilTargetError e1 ) { 
				throw e1;
			} catch ( Exception e ) {
				throw new UtilEvalError(""Assignment: "" + e.getMessage());
			}
		else
			throw new InterpreterError(""unknown lhs"");

		return val;
	}

	public String toString() { 
		return ""LHS: ""
			+((field!=null)? ""field = ""+field.toString():"""")
			+(varName!=null ? "" varName = ""+varName: """")
			+(nameSpace!=null ? "" nameSpace = ""+nameSpace.toString(): """");
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.msg.SearchSettingsChanged,1,2,0,5,2,0,3,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class SearchSettingsChanged extends EBMessage
{
	
	public SearchSettingsChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.PropertiesChanging,3,2,0,4,6,0,1,3,2,0.5,32,0.5,1,0.75,0.666666667,0,0,9.0,1,0.3333,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class PropertiesChanging extends EBMessage
{

	public enum State {
		LOADING,
		CANCELED
	}

	
	public PropertiesChanging(EBComponent source, State state)
	{
		super(source);
		assert (state != null) : ""state shouldn't be null"";
		this.state = state;
	}

	public State getState()
	{
		return state;
	}

	private final State state;

}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.BufferUndoListener,4,1,0,1,4,6,1,1,4,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.buffer;


public interface BufferUndoListener
{
	
	
	void beginUndo(JEditBuffer buffer);
	

	
	
	void endUndo(JEditBuffer buffer);
	

	
	
	void beginRedo(JEditBuffer buffer);
	

	
	
	void endRedo(JEditBuffer buffer);
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BshClassManager,34,1,1,21,70,507,14,9,20,0.868686869,589,1.0,1,0.0,0.127272727,0,0,16.05882353,5,1.5882,0,"

package org.gjt.sp.jedit.bsh;

import java.net.*;
import java.util.*;
import java.io.IOException;
import java.io.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;



public class BshClassManager
{
    
    private static Object NOVALUE = new Object();
    
    private Interpreter declaringInterpreter;

    
    protected ClassLoader externalClassLoader;

    
    protected transient Hashtable absoluteClassCache = new Hashtable();
    
    protected transient Hashtable absoluteNonClasses = new Hashtable();

    
    protected transient Hashtable resolvedObjectMethods = new Hashtable();
    protected transient Hashtable resolvedStaticMethods = new Hashtable();

    protected transient Hashtable definingClasses = new Hashtable();
    protected transient Hashtable definingClassesBaseNames = new Hashtable();

    
    public static BshClassManager createClassManager( Interpreter interpreter )
    {
        BshClassManager manager;

        
        if ( Capabilities.classExists(""java.lang.ref.WeakReference"")
            && Capabilities.classExists(""java.util.HashMap"")
            && Capabilities.classExists(""org.gjt.sp.jedit.bsh.classpath.ClassManagerImpl"")
        )
            try {
                
                
                Class clas = Class.forName( ""org.gjt.sp.jedit.bsh.classpath.ClassManagerImpl"" );
                manager = (BshClassManager)clas.newInstance();
            } catch ( Exception e ) {
                throw new InterpreterError(""Error loading classmanager: ""+e);
            }
        else
            manager = new BshClassManager();

        if ( interpreter == null )
            interpreter = new Interpreter();
        manager.declaringInterpreter = interpreter;
        return manager;
    }

    public boolean classExists( String name ) {
        return ( classForName( name ) != null );
    }

    
    public Class classForName( String name )
    {
        if ( isClassBeingDefined( name ) )
            throw new InterpreterError(
                ""Attempting to load class in the process of being defined: ""
                +name );

        Class clas = null;
        try {
            clas = plainClassForName( name );
        } catch ( ClassNotFoundException e ) {  }

        
        if ( clas == null )
            clas = loadSourceClass( name );

        return clas;
    }

    
    protected Class loadSourceClass( String name )
    {
        String fileName = ""/""+name.replace('.','/')+"".java"";
        InputStream in = getResourceAsStream( fileName );
        if ( in == null )
            return null;

        try {
            System.out.println(""Loading class from source file: ""+fileName);
            declaringInterpreter.eval( new InputStreamReader(in) );
        } catch ( EvalError e ) {
            
            System.err.println( e );
        }
        try {
            return plainClassForName( name );
        } catch ( ClassNotFoundException e ) {
            System.err.println(""Class not found in source file: ""+name );
            return null;
        }
    }

    
    public Class plainClassForName( String name )
        throws ClassNotFoundException
    {
        Class c = null;

        try {
            if ( externalClassLoader != null )
                c = externalClassLoader.loadClass( name );
            else
                c = Class.forName( name );

            cacheClassInfo( name, c );

        
        } catch ( NoClassDefFoundError e ) {
            throw noClassDefFound( name, e );
        }

        return c;
    }

    
    public URL getResource( String path )
    {
        URL url = null;
        if ( externalClassLoader != null )
        {
            
            url = externalClassLoader.getResource( path.substring(1) );
        }
        if ( url == null )
            url = Interpreter.class.getResource( path );

        return url;
    }
    
    public InputStream getResourceAsStream( String path )
    {
        InputStream in = null;
        if ( externalClassLoader != null )
        {
            
            in = externalClassLoader.getResourceAsStream( path.substring(1) );
        }
        if ( in == null )
            in = Interpreter.class.getResourceAsStream( path );

        return in;
    }

    
    public void cacheClassInfo( String name, Class value ) {
        if ( value != null )
            absoluteClassCache.put( name, value );
        else
            absoluteNonClasses.put( name, NOVALUE );
    }

    
    public void cacheResolvedMethod(
        Class clas, Class [] types, Method method )
    {
        if ( Interpreter.DEBUG )
            Interpreter.debug(
                ""cacheResolvedMethod putting: "" + clas +"" ""+ method );

        SignatureKey sk = new SignatureKey( clas, method.getName(), types );
        if ( Modifier.isStatic( method.getModifiers() ) )
            resolvedStaticMethods.put( sk, method );
        else
            resolvedObjectMethods.put( sk, method );
    }

    
    protected Method getResolvedMethod(
        Class clas, String methodName, Class [] types, boolean onlyStatic  )
    {
        SignatureKey sk = new SignatureKey( clas, methodName, types );

        
        
        Method method = (Method)resolvedStaticMethods.get( sk );
        if ( method == null && !onlyStatic)
            method = (Method)resolvedObjectMethods.get( sk );

        if ( Interpreter.DEBUG )
        {
            if ( method == null )
                Interpreter.debug(
                    ""getResolvedMethod cache MISS: "" + clas +"" - ""+methodName );
            else
                Interpreter.debug(
                    ""getResolvedMethod cache HIT: "" + clas +"" - "" +method );
        }
        return method;
    }

    
    protected void clearCaches()
    {
        absoluteNonClasses = new Hashtable();
        absoluteClassCache = new Hashtable();
        resolvedObjectMethods = new Hashtable();
        resolvedStaticMethods = new Hashtable();
    }

    
    public void setClassLoader( ClassLoader externalCL )
    {
        externalClassLoader = externalCL;
        classLoaderChanged();
    }

    public void addClassPath( URL path )
        throws IOException {
    }

    
    public void reset() {
        clearCaches();
    }

    
    public void setClassPath( URL [] cp )
        throws UtilEvalError
    {
        throw cmUnavailable();
    }

    
    public void reloadAllClasses() throws UtilEvalError {
        throw cmUnavailable();
    }

    
    public void reloadClasses( String [] classNames )
        throws UtilEvalError
    {
        throw cmUnavailable();
    }

    
    public void reloadPackage( String pack )
        throws UtilEvalError
    {
        throw cmUnavailable();
    }

    

    
    protected void doSuperImport()
        throws UtilEvalError
    {
        throw cmUnavailable();
    }

    
    protected boolean hasSuperImport()
    {
        return false;
    }

    
    protected String getClassNameByUnqName( String name )
        throws UtilEvalError
    {
        throw cmUnavailable();
    }

    public void addListener( Listener l ) { }

    public void removeListener( Listener l ) { }

    public void dump( PrintWriter pw ) {
        pw.println(""BshClassManager: no class manager."");
    }

    
    
    protected void definingClass( String className ) {
        String baseName = Name.suffix(className,1);
        int i = baseName.indexOf(""$"");
        if ( i != -1 )
            baseName = baseName.substring(i+1);
        String cur = (String)definingClassesBaseNames.get( baseName );
        if ( cur != null )
            throw new InterpreterError(""Defining class problem: ""+className
                +"": BeanShell cannot yet simultaneously define two or more ""
                +""dependant classes of the same name.  Attempt to define: ""
                + className +"" while defining: ""+cur
            );
        definingClasses.put( className, NOVALUE );
        definingClassesBaseNames.put( baseName, className );
    }

    protected boolean isClassBeingDefined( String className ) {
        return definingClasses.get( className ) != null;
    }

    
    protected String getClassBeingDefined( String className ) {
        String baseName = Name.suffix(className,1);
        return (String)definingClassesBaseNames.get( baseName );
    }

    
    protected void doneDefiningClass( String className ) {
        String baseName = Name.suffix(className,1);
        definingClasses.remove( className );
        definingClassesBaseNames.remove( baseName );
    }

    
    public Class defineClass( String name, byte [] code )
    {
        throw new InterpreterError(""Can't create class (""+name
            +"") without class manager package."");
    
    }

    protected void classLoaderChanged() { }

    
    protected static Error noClassDefFound( String className, Error e ) {
        return new NoClassDefFoundError(
            ""A class required by class: ""+className +"" could not be loaded:\n""
            +e.toString() );
    }

    protected static UtilEvalError cmUnavailable() {
        return new Capabilities.Unavailable(
            ""ClassLoading features unavailable."");
    }

    public static interface Listener
    {
        public void classLoaderChanged();
    }

    
    
    static class SignatureKey
    {
        Class clas;
        Class [] types;
        String methodName;
        int hashCode = 0;

        SignatureKey( Class clas, String methodName, Class [] types ) {
            this.clas = clas;
            this.methodName = methodName;
            this.types = types;
        }

        public int hashCode()
        {
            if ( hashCode == 0 )
            {
                hashCode = clas.hashCode() * methodName.hashCode();
                if ( types == null ) 
                    return hashCode;
                for( int i =0; i < types.length; i++ ) {
                    int hc = types[i] == null ? 21 : types[i].hashCode();
                    hashCode = hashCode*(i+1) + hc;
                }
            }
            return hashCode;
        }

        public boolean equals( Object o ) {
            SignatureKey target = (SignatureKey)o;
            if ( types == null )
                return target.types == null;
            if ( clas != target.clas )
                return false;
            if ( !methodName.equals( target.methodName ) )
                return false;
            if ( types.length != target.types.length )
                return false;
            for( int i =0; i< types.length; i++ )
            {
                if ( types[i]==null )
                {
                    if ( !(target.types[i]==null) )
                        return false;
                } else
                    if ( !types[i].equals( target.types[i] ) )
                        return false;
            }

            return true;
        }
    }
}
"
jEdit,4.3,org.gjt.sp.util.ReverseCharSequence,6,1,0,2,13,0,2,0,6,0.0,75,1.0,0,0.0,0.5,0,0,11.33333333,2,1.0,0,"

package org.gjt.sp.util;


public class ReverseCharSequence implements CharSequence
{
	public ReverseCharSequence(CharSequence base)
	{
		this.base = base;
	}

	public CharSequence baseSequence()
	{
		return base;
	}

	public char charAt(int index)
	{
		return base.charAt(base.length() - index - 1);
	}

	public int length()
	{
		return base.length();
	}

	public CharSequence subSequence(int start, int end)
	{
		int baseLength = base.length();
		return new ReverseCharSequence(
			base.subSequence(baseLength - end, baseLength - start));
	}

	public String toString()
	{
		int baseLength = base.length();
		StringBuilder builder = new StringBuilder(baseLength);
		for (int i = baseLength - 1; i >= 0; --i)
		{
			builder.append(base.charAt(i));
		}
		return builder.toString();
	}

	private final CharSequence base;
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.EditorStarted,1,2,0,3,2,0,1,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class EditorStarted extends EBMessage
{
	
	public EditorStarted(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.JEditTextArea,31,5,0,79,111,273,62,23,29,0.95,698,0.25,1,0.967948718,0.189516129,2,11,21.38709677,8,2.4516,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.AWTEvent;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import java.awt.Point;
import java.awt.event.MouseEvent;
import javax.swing.JMenuItem;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.options.GlobalOptions;

import org.gjt.sp.jedit.msg.PositionChanging;



public class JEditTextArea extends TextArea
{

	
	
	public JEditTextArea(View view)
	{
		super(jEdit.getPropertyManager(), view);
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);
		this.view = view;
	} 

	
	@Override
	public FoldPainter getFoldPainter()
	{
		FoldPainter foldPainter = (FoldPainter) ServiceManager.getService(
				FOLD_PAINTER_SERVICE, getFoldPainterName());
		if (foldPainter == null)
			foldPainter = (FoldPainter) ServiceManager.getService(
				FOLD_PAINTER_SERVICE,
				DEFAULT_FOLD_PAINTER_SERVICE);
		return foldPainter;
	} 

	
	
	
	@Override
	public void home(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();
		switch(getInputHandler().getLastActionCount() % 2)
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");"");			
			goToStartOfWhiteSpace(select);
			break;
		default:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfLine("" + select + "");"");			
			goToStartOfLine(select);
			break;
		}
	} 

	
	
	@Override
	public void end(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		switch(getInputHandler().getLastActionCount() % 2)
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");"");
			goToEndOfWhiteSpace(select);
			break;
		default:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfLine("" + select + "");"");
			goToEndOfLine(select);
			break;
		}
	} 

	
	
	@Override
	public void smartHome(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		switch(view.getInputHandler().getLastActionCount())
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");"");

			goToStartOfWhiteSpace(select);
			break;
		case 2:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfLine("" + select + "");"");

			goToStartOfLine(select);
			break;
		default: 
			if(recorder != null)
				recorder.record(""textArea.goToFirstVisibleLine("" + select + "");"");

			goToFirstVisibleLine(select);
			break;
		}
	} 

	
	
	@Override
	public void smartEnd(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		switch(view.getInputHandler().getLastActionCount())
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");"");

			goToEndOfWhiteSpace(select);
			break;
		case 2:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfLine("" + select + "");"");

			goToEndOfLine(select);
			break;
		default: 
			if(recorder != null)
				recorder.record(""textArea.goToLastVisibleLine("" + select + "");"");
			goToLastVisibleLine(select);
			break;
		}
	} 
	

	
	public void goToBufferEnd(boolean select)
	{
		EditBus.send(new PositionChanging(this));
		super.goToBufferEnd(select);
	}

	
	
	public void goToMatchingBracket()
	{
		if(getLineLength(caretLine) != 0)
		{
			int dot = caret - getLineStartOffset(caretLine);

			int bracket = TextUtilities.findMatchingBracket(
				buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1)
			{
				EditBus.send(new PositionChanging(this));
				selectNone();
				moveCaretPosition(bracket + 1,false);
				return;
			}
		}
		getToolkit().beep();
	} 


	public void goToBufferStart(boolean select)
	{
		EditBus.send(new PositionChanging(this));
		super.goToBufferStart(select);
	} 

	
	@Override
	public int replaceSelection(String selectedText)
	{
		EditBus.send(new PositionChanging(this));
		return super.replaceSelection(selectedText);
	}

	
	
	public void showGoToLineDialog()
	{
		String line = GUIUtilities.input(view,""goto-line"",null);
		if(line == null)
			return;

		try
		{
			int lineNumber = Integer.parseInt(line) - 1;
			EditBus.send(new PositionChanging(this));
			setCaretPosition(getLineStartOffset(lineNumber));
		}
		catch(Exception e)
		{
			getToolkit().beep();
		}
	} 

	
	
	@Override
	public void userInput(char ch)
	{
		if(ch == ' ' && Abbrevs.getExpandOnInput()
			&& Abbrevs.expandAbbrev(view,false))
			return;

		super.userInput(ch);
	} 

	
	
	@Override
	public void addExplicitFold()
	{
		try
		{
			super.addExplicitFold();
		}
		catch (TextAreaException e)
		{
			GUIUtilities.error(view,""folding-not-explicit"",null);
		}
	} 

	
	
	@Override
	public void formatParagraph()
	{
		try
		{
			super.formatParagraph();
		}
		catch (TextAreaException e)
		{
			GUIUtilities.error(view,""format-maxlinelen"",null);
		}
	} 

	
	protected static void doWordCount(View view, String text)
	{
		char[] chars = text.toCharArray();
		int characters = chars.length;
		int words = 0;
		int lines = 1;

		boolean word = true;
		for(int i = 0; i < chars.length; i++)
		{
			switch(chars[i])
			{
			case '\r': case '\n':
				lines++;
			case ' ': case '\t':
				word = true;
				break;
			default:
				if(word)
				{
					words++;
					word = false;
				}
				break;
			}
		}

		Object[] args = { characters, words, lines };
		GUIUtilities.message(view,""wordcount"",args);
	} 

	
	
	public void showWordCountDialog()
	{
		String selection = getSelectedText();
		if(selection != null)
		{
			doWordCount(view,selection);
			return;
		}

		doWordCount(view,buffer.getText(0,buffer.getLength()));
	} 

	

	
	
	public View getView()
	{
		return view;
	} 

	

	

	
	
	@Deprecated
	public final int getSelectionStart()
	{
		if(getSelectionCount() != 1)
			return caret;

		return getSelection(0).getStart();
	} 

	
	
	@Deprecated
	public int getSelectionStart(int line)
	{
		if(getSelectionCount() != 1)
			return caret;

		return getSelection(0).getStart(buffer,line);
	} 

	
	
	@Deprecated
	public final int getSelectionStartLine()
	{
		if(getSelectionCount() != 1)
			return caret;

		return getSelection(0).getStartLine();
	} 

	
	
	@Deprecated
	public final void setSelectionStart(int selectionStart)
	{
		int selectionEnd = getSelectionCount() == 1 ? getSelection(0).getEnd() : caret;
		setSelection(new Selection.Range(selectionStart, selectionEnd));
		moveCaretPosition(selectionEnd,true);
	} 

	
	
	@Deprecated
	public final int getSelectionEnd()
	{
		return getSelectionCount() == 1 ? getSelection(0).getEnd() : caret;

	} 

	
	
	@Deprecated
	public int getSelectionEnd(int line)
	{
		if(getSelectionCount() != 1)
			return caret;

		return getSelection(0).getEnd(buffer,line);
	} 

	
	
	@Deprecated
	public final int getSelectionEndLine()
	{
		if(getSelectionCount() != 1)
			return caret;

		return getSelection(0).getEndLine();
	} 

	
	
	@Deprecated
	public final void setSelectionEnd(int selectionEnd)
	{
		int selectionStart = getSelectionCount() == 1 ?	getSelection(0).getStart() : caret;
		setSelection(new Selection.Range(selectionStart, selectionEnd));
		moveCaretPosition(selectionEnd,true);
	} 

	
	
	@Deprecated
	public void select(int start, int end)
	{
		setSelection(new Selection.Range(start, end));
		moveCaretPosition(end,true);
	} 

	
	
	@Deprecated
	public void select(int start, int end, boolean doElectricScroll)
	{
		selectNone();

		int newStart, newEnd;
		if(start < end)
		{
			newStart = start;
			newEnd = end;
		}
		else
		{
			newStart = end;
			newEnd = start;
		}

		setSelection(new Selection.Range(newStart,newEnd));
		moveCaretPosition(end,doElectricScroll);
	} 

	
	
	@Deprecated
	public boolean isSelectionRectangular()
	{
		Selection s = getSelectionAtOffset(caret);
		return s != null && s instanceof Selection.Rect;
	} 

	

	

	
	private View view;
	
	

	
	
	public static final String FOLD_PAINTER_PROPERTY = ""foldPainter"";
	public static final String FOLD_PAINTER_SERVICE = ""org.gjt.sp.jedit.textarea.FoldPainter"";
	public static final String DEFAULT_FOLD_PAINTER_SERVICE = ""Triangle"";

	
	public static String getFoldPainterName()
	{
		return jEdit.getProperty(FOLD_PAINTER_PROPERTY, DEFAULT_FOLD_PAINTER_SERVICE);
	} 

	

	
	
	@Override
	public void handlePopupTrigger(MouseEvent evt)
	{

		if(popup.isVisible())
			popup.setVisible(false);
		else
		{
			
			createPopupMenu(evt);

			int x = evt.getX();
			int y = evt.getY();

			int dragStart = xyToOffset(x,y,
				!(painter.isBlockCaretEnabled()
				|| isOverwriteEnabled()));

			if(getSelectionCount() == 0 || multi)
				moveCaretPosition(dragStart,false);
			GUIUtilities.showPopupMenu(popup,painter,x,y);
		}
	} 

	
	
	@Override
	public void createPopupMenu(MouseEvent evt)
	{
		popup = GUIUtilities.loadPopupMenu(""view.context"", this, evt);
		JMenuItem customize = new JMenuItem(jEdit.getProperty(
			""view.context.customize""));
		customize.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				new GlobalOptions(view,""context"");
			}
		});
		popup.addSeparator();
		popup.add(customize);
	} 

	
	
	@Override
	public void showPopupMenu()
	{
		if (!popup.isVisible() && hasFocus())
		{
			Point caretPos = offsetToXY(getCaretPosition());
			if (caretPos != null)
			{
				
				int charHeight = getPainter().getFontMetrics().getHeight();
				GUIUtilities.showPopupMenu(popup,
					painter,caretPos.x,caretPos.y + charHeight,true);
			}
		}
	} 


}
"
jEdit,4.3,org.gjt.sp.jedit.EBComponent,1,1,0,48,1,0,48,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;


public interface EBComponent
{
	
	void handleMessage(EBMessage message);
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.PluginManager,23,6,0,29,73,201,21,16,7,0.870629371,403,0.923076923,5,0.967016492,0.173913043,2,3,15.95652174,6,1.5652,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.xml.sax.SAXParseException;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkRequest;



public class PluginManager extends JFrame implements EBComponent
{
	
	
	
	public static PluginManager getInstance()
	{
		return instance;
	} 

	
	public void dispose()
	{
		instance = null;
		EditBus.removeFromBus(this);
		EditBus.removeFromBus(installer);
		super.dispose();
	} 

	
	public void handleMessage(EBMessage message)
	{
		if (message instanceof PropertiesChanged)
		{
			if (shouldUpdatePluginList())
			{
				pluginList = null;
				updatePluginList();
				if(tabPane.getSelectedIndex() != 0)
				{
					installer.updateModel();
					updater.updateModel();
				}
			}
		}
		else if (message instanceof PluginUpdate)
		{
			if(!queuedUpdate)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						queuedUpdate = false;
						manager.update();
					}
				});
				queuedUpdate = true;
			}
		}
	} 

	
	public static void showPluginManager(Frame parent)
	{
		if (instance == null)
			instance = new PluginManager(parent);
		else
			instance.toFront();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	PluginList getPluginList()
	{
		return pluginList;
	} 

	
	private static PluginManager instance;

	
	private JTabbedPane tabPane;
	private JButton done;
	private JButton mgrOptions;
	private JButton pluginOptions;
	private InstallPanel installer;
	private InstallPanel updater;
	private ManagePanel manager;
	private PluginList pluginList;
	private boolean queuedUpdate;
	private boolean downloadingPluginList;
	private final Frame parent;
	

	static public final String PROPERTY_PLUGINSET = ""plugin-manager.pluginset.path"";

	
	private PluginManager(Frame parent)
	{
		super(jEdit.getProperty(""plugin-manager.title""));
		this.parent = parent;
		init();
	} 

	
	private void init()
	{
		EditBus.addToBus(this);
		

		
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		tabPane = new JTabbedPane();
		tabPane.addTab(jEdit.getProperty(""manage-plugins.title""),
			manager = new ManagePanel(this));
		tabPane.addTab(jEdit.getProperty(""update-plugins.title""),
			updater = new InstallPanel(this,true));
		tabPane.addTab(jEdit.getProperty(""install-plugins.title""),
			installer = new InstallPanel(this,false));
		EditBus.addToBus(installer);
		content.add(BorderLayout.CENTER,tabPane);

		tabPane.addChangeListener(new ListUpdater());

		
		Box buttons = new Box(BoxLayout.X_AXIS);

		ActionListener al = new ActionHandler();
		mgrOptions = new JButton(jEdit.getProperty(""plugin-manager.mgr-options""));
		mgrOptions.addActionListener(al);
		pluginOptions = new JButton(jEdit.getProperty(""plugin-manager.plugin-options""));
		pluginOptions.addActionListener(al);
		done = new JButton(jEdit.getProperty(""plugin-manager.done""));
		done.addActionListener(al);

		buttons.add(Box.createGlue());
		buttons.add(mgrOptions);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(pluginOptions);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(done);
		buttons.add(Box.createGlue());

		getRootPane().setDefaultButton(done);

		content.add(BorderLayout.SOUTH,buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		setIconImage(GUIUtilities.getPluginIcon());

		pack();
		GUIUtilities.loadGeometry(this, parent, ""plugin-manager"");
		GUIUtilities.addSizeSaver(this, parent, ""plugin-manager"");
		setVisible(true);
	} 

	
	
	private boolean shouldUpdatePluginList()
	{
		return (pluginList == null ||
			!pluginList.getMirrorId().equals(jEdit.getProperty(""plugin-manager.mirror.id""))) &&
			!downloadingPluginList;
	} 

	
	private void updatePluginList()
	{
		if(jEdit.getSettingsDirectory() == null
			&& jEdit.getJEditHome() == null)
		{
			GUIUtilities.error(this,""no-settings"",null);
			return;
		}
		if (!shouldUpdatePluginList())
		{
			return;
		}

		final Exception[] exception = new Exception[1];

		VFSManager.runInWorkThread(new WorkRequest()
		{
			public void run()
			{
				try
				{
					downloadingPluginList = true;
					setStatus(jEdit.getProperty(
						""plugin-manager.list-download-connect""));
					pluginList = new PluginList(this);
				}
				catch(Exception e)
				{
					exception[0] = e;
				}
				finally
				{
					downloadingPluginList = false;
				}
			}
		});

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				if(exception[0] instanceof SAXParseException)
				{
					SAXParseException se = (SAXParseException)
						exception[0];

					int line = se.getLineNumber();
					String path = jEdit.getProperty(
						""plugin-manager.export-url"");
					String message = se.getMessage();
					Log.log(Log.ERROR,this,path + ':' + line
						+ "": "" + message);
					String[] pp = { path,
						String.valueOf(line),
						message };
					GUIUtilities.error(PluginManager.this,
						""plugin-list.xmlerror"",pp);
				}
				else if(exception[0] != null)
				{
					Exception e = exception[0];

					Log.log(Log.ERROR,this,e);
					String[] pp = { e.toString() };

					String ok = jEdit.getProperty(
						""common.ok"");
					String proxyButton = jEdit.getProperty(
						""plugin-list.ioerror.proxy-servers"");
					int retVal =
						JOptionPane.showOptionDialog(
						PluginManager.this,
						jEdit.getProperty(""plugin-list.ioerror.message"",pp),
						jEdit.getProperty(""plugin-list.ioerror.title""),
						JOptionPane.YES_NO_OPTION,
						JOptionPane.ERROR_MESSAGE,
						null,
						new Object[] {
							proxyButton,
							ok
						},
						ok);

					if(retVal == 0)
					{
						new GlobalOptions(
							PluginManager.this,
							""firewall"");
					}
				}
			}
		});
	} 

	
	public void processKeyEvents(KeyEvent ke)
	{
		if ((ke.getID() == KeyEvent.KEY_PRESSED) &&
		    (ke.getKeyCode() == KeyEvent.VK_ESCAPE))
		{
			cancel();
			ke.consume();
		}
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == done)
				ok();
			else if (source == mgrOptions)
				new GlobalOptions(PluginManager.this,""plugin-manager"");
			else if (source == pluginOptions)
				new PluginOptions(PluginManager.this);
		}
	} 

	
	class ListUpdater implements ChangeListener
	{
		public void stateChanged(ChangeEvent e)
		{
			Component selected = tabPane.getSelectedComponent();
			if(selected == installer || selected == updater)
			{
				updatePluginList();
				installer.updateModel();
				updater.updateModel();
			}
			else if(selected == manager)
				manager.update();
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.FoldPainter,3,1,0,7,3,3,6,2,3,2.0,3,0.0,0,0.0,0.888888889,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;

import org.gjt.sp.jedit.buffer.JEditBuffer;


public interface FoldPainter {
	
	
	void paintFoldStart(Gutter gutter, Graphics2D gfx, int screenLine,
		int physicalLine, boolean nextLineVisible, int y, int lineHeight,
		JEditBuffer buffer);
	
	
	void paintFoldEnd(Gutter gutter, Graphics2D gfx, int screenLine,
		int physicalLine, int y, int lineHeight, JEditBuffer buffer);
	
	
	void paintFoldMiddle(Gutter gutter, Graphics2D gfx, int screenLine,
		int physicalLine, int y, int lineHeight, JEditBuffer buffer);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Variable,12,1,0,10,24,26,5,5,7,0.75,182,0.0,2,0.0,0.333333333,0,0,13.5,3,0.8333,0,"package org.gjt.sp.jedit.bsh;

public class Variable implements java.io.Serializable 
{
	static final int DECLARATION=0, ASSIGNMENT=1;
	
	String name;
	Class type = null;
	String typeDescriptor;
	Object value;
	Modifiers modifiers;
	LHS lhs;

	Variable( String name, Class type, LHS lhs ) 
	{
		this.name = name;
		this.lhs = lhs;
		this.type = type;
	}
	
	Variable( String name, Object value, Modifiers modifiers )
		throws UtilEvalError
	{
		this( name, (Class)null, value, modifiers );
	}

	
	Variable( 
		String name, String typeDescriptor, Object value, Modifiers modifiers 
	)
		throws UtilEvalError
	{
		this( name, (Class)null, value, modifiers );
		this.typeDescriptor = typeDescriptor;
	}

	
	Variable( String name, Class type, Object value, Modifiers modifiers )
		throws UtilEvalError
	{

		this.name=name;
		this.type =	type;
		this.modifiers = modifiers;
		setValue( value, DECLARATION );
	}

	
	public void setValue( Object value, int context ) 
		throws UtilEvalError
	{

		
		if ( hasModifier(""final"") && this.value != null )
			throw new UtilEvalError (""Final variable, can't re-assign."");

		if ( value == null )
			value = Primitive.getDefaultValue( type );

		if ( lhs != null )
		{
			lhs.assign( value, false );
			return;
		}

		
		
		if ( type != null )
			value = Types.castObject( value, type, 
				context == DECLARATION ? Types.CAST : Types.ASSIGNMENT
			);

		this.value= value;
	}

	
	Object getValue() 
		throws UtilEvalError
	{ 
		if ( lhs != null )
			return lhs.getValue();

		return value; 
	}

	
	public Class getType() { return type;	}

	public String getTypeDescriptor() { return typeDescriptor; }

	public Modifiers getModifiers() { return modifiers; }

	public String getName() { return name; }

	public boolean hasModifier( String name ) {
		return modifiers != null && modifiers.hasModifier(name);
	}

	public String toString() { 
		return ""Variable: ""+super.toString()+"" ""+name+"", type:""+type
			+"", value:""+value +"", lhs = ""+lhs;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHIfStatement,3,2,0,11,10,3,4,7,2,2.0,81,0.0,0,0.894736842,0.533333333,1,1,26.0,1,0.6667,0,"


package org.gjt.sp.jedit.bsh;

class BSHIfStatement extends SimpleNode
{
    BSHIfStatement(int id) { super(id); }

    public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        Object ret = null;

        if( evaluateCondition( 
			(SimpleNode)jjtGetChild(0), callstack, interpreter ) )
            ret = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
        else
            if(jjtGetNumChildren() > 2)
                ret = ((SimpleNode)jjtGetChild(2)).eval(callstack, interpreter);

        if(ret instanceof ReturnControl)
            return ret;
        else    
            return Primitive.VOID;
    }

    public static boolean evaluateCondition(
		SimpleNode condExp, CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        Object obj = condExp.eval(callstack, interpreter);
        if(obj instanceof Primitive) {
			if ( obj == Primitive.VOID )
				throw new EvalError(""Condition evaluates to void type"", 
					condExp, callstack );
            obj = ((Primitive)obj).getValue();
		}

        if(obj instanceof Boolean)
            return ((Boolean)obj).booleanValue();
        else
            throw new EvalError(
				""Condition must evaluate to a Boolean or boolean."", 
				condExp, callstack );
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BlockNameSpace,10,2,0,11,24,45,4,7,7,2.0,99,0.0,0,0.8875,0.328571429,1,5,8.9,2,1.1,0,"

package org.gjt.sp.jedit.bsh;



class BlockNameSpace extends NameSpace 
{
    public BlockNameSpace( NameSpace parent ) 
		throws EvalError
	{
		super( parent, parent.getName()+ ""/BlockNameSpace"" );
    }

	
	
    public void	setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		if ( weHaveVar( name ) ) 
			
			super.setVariable( name, value, strictJava, false );
		else
			
			getParent().setVariable( name, value, strictJava, recurse );
    }

	
    public void	setBlockVariable( String name, Object value ) 
		throws UtilEvalError 
	{
		super.setVariable( name, value, false, false );
	}

	
	private boolean weHaveVar( String name ) 
	{
		
		try {
			return super.getVariableImpl( name, false ) != null;
		} catch ( UtilEvalError e ) { return false; }
	}



	
	
	

	
	
	private NameSpace getNonBlockParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return ((BlockNameSpace)parent).getNonBlockParent();
		else
			return parent;
	}

	
    This getThis( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getThis( declaringInterpreter );
	}

	
    public This getSuper( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getSuper( declaringInterpreter );
	}

	
    public void	importClass(String name) {
		getParent().importClass( name );
	}

	
    public void	importPackage(String name) {
		getParent().importPackage( name );
	}

    public void	setMethod(String name, BshMethod method) 
		throws UtilEvalError
	{
		getParent().setMethod( name, method );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bufferset.BufferSetListener,4,1,0,5,4,6,4,1,4,2.0,4,0.0,0,0.0,0.833333333,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit.bufferset;

import org.gjt.sp.jedit.Buffer;

import java.util.EventListener;


public interface BufferSetListener extends EventListener
{
	
	void bufferAdded(Buffer buffer, int index);

	
	void bufferRemoved(Buffer buffer, int index);

	
	void bufferMoved(Buffer buffer, int oldIndex, int newIndex);

	
	void bufferSetSorted();

}
"
jEdit,4.3,org.gjt.sp.jedit.input.InputHandlerProvider,1,1,0,8,1,0,7,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit.input;


public interface InputHandlerProvider
{
	AbstractInputHandler getInputHandler();
}
"
jEdit,4.3,org.gjt.sp.util.SegmentBuffer,4,2,0,4,6,0,4,0,3,2.0,83,0.0,0,0.842105263,0.5625,1,11,19.75,3,1.25,0,"

package org.gjt.sp.util;

import javax.swing.text.Segment;


public class SegmentBuffer extends Segment
{
	
	public SegmentBuffer(int capacity)
	{
		ensureCapacity(capacity);
	} 

	
	public void append(char ch)
	{
		ensureCapacity(count + 1);
		array[offset + count] = ch;
		count++;
	} 

	
	public void append(char[] text, int off, int len)
	{
		ensureCapacity(count + len);
		System.arraycopy(text,off,array,count,len);
		count += len;
	} 

	

	
	private void ensureCapacity(int capacity)
	{
		if(array == null)
			array = new char[capacity];
		else if(capacity >= array.length)
		{
			char[] arrayN = new char[capacity * 2];
			System.arraycopy(array,0,arrayN,0,count);
			array = arrayN;
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.classpath.BshClassLoader,7,4,1,4,25,19,2,3,4,0.333333333,130,0.0,1,0.953488372,0.326530612,1,3,17.42857143,1,0.5714,0,"

package org.gjt.sp.jedit.bsh.classpath;

import java.net.*;

import org.gjt.sp.jedit.bsh.BshClassManager;


public class BshClassLoader extends URLClassLoader
{
    BshClassManager classManager;

    
    public BshClassLoader( BshClassManager classManager, URL [] bases ) {
        super( bases );
        this.classManager = classManager;
    }

    
    public BshClassLoader( BshClassManager classManager, BshClassPath bcp ) {
        this( classManager, bcp.getPathComponents() );
    }

    
    protected BshClassLoader( BshClassManager classManager ) {
        this( classManager, new URL [] { } );
    }

    
    public void addURL( URL url ) {
        super.addURL( url );
    }

    
    public Class loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        Class c = null;

        
        c = findLoadedClass(name);
        if ( c != null )
            return c;



        if ( name.startsWith( ClassManagerImpl.BSH_PACKAGE ) )
            try {
                return org.gjt.sp.jedit.bsh.Interpreter.class.getClassLoader().loadClass( name );
            } catch ( ClassNotFoundException e ) {}

        
        try {
            c = findClass( name );
        } catch ( ClassNotFoundException e ) { }

        if ( c == null )
            throw new ClassNotFoundException(""here in loaClass"");

        if ( resolve )
            resolveClass( c );

        return c;
    }

    
    
    protected Class findClass( String name )
        throws ClassNotFoundException
    {
        
        
        
        ClassManagerImpl bcm = (ClassManagerImpl)getClassManager();

        
        

        
        
        
        ClassLoader cl = bcm.getLoaderForClass( name );

        Class c;

        
        if ( cl != null && cl != this )
            try {
                return cl.loadClass( name );
            } catch ( ClassNotFoundException e ) {
                throw new ClassNotFoundException(
                    ""Designated loader could not find class: ""+e );
            }

        
        if ( getURLs().length > 0 )
            try {
                return super.findClass(name);
            } catch ( ClassNotFoundException e ) {
                
                
            }


        
        cl = bcm.getBaseLoader();

        if ( cl != null && cl != this )
            try {
                return cl.loadClass( name );
            } catch ( ClassNotFoundException e ) { }

        
        return bcm.plainClassForName( name );
    }

    

    BshClassManager getClassManager() { return classManager; }

}
"
jEdit,4.3,org.gjt.sp.jedit.menu.DynamicMenuProvider,2,1,0,9,2,1,9,0,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.menu;

import javax.swing.JMenu;


public interface DynamicMenuProvider
{
	
	boolean updateEveryTime();

	
	void update(JMenu menu);
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.SelectionLengthWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.jedit.textarea.Selection;

import javax.swing.*;
import javax.swing.event.CaretListener;
import javax.swing.event.CaretEvent;



public class SelectionLengthWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view)
	{
		Widget selectionLengthWidget = new SelectionLengthWidget(view);
		return selectionLengthWidget;
	} 

	
	private static class SelectionLengthWidget implements Widget, EBComponent
	{
		private final SelectionLength selectionLength;
		private final View view;
		private TextArea textArea;

		SelectionLengthWidget(View view)
		{
			this.view = view;
			textArea = view.getTextArea();
			selectionLength = new SelectionLength();
			selectionLength.setForeground(jEdit.getColorProperty(""view.status.foreground""));
			selectionLength.setBackground(jEdit.getColorProperty(""view.status.background""));
		}

		public JComponent getComponent()
		{
			return selectionLength;
		}

		public void update()
		{
		}

		public void propertiesChanged()
		{
		}

		public void handleMessage(EBMessage message)
		{
			if (message instanceof ViewUpdate)
			{
				ViewUpdate viewUpdate = (ViewUpdate) message;
				if (viewUpdate.getView() == view && viewUpdate.getWhat() == ViewUpdate.EDIT_PANE_CHANGED)
				{
					if (textArea != null)
					{
						textArea.removeCaretListener(selectionLength);
					}
					textArea = view.getTextArea();
					if (selectionLength.visible)
						textArea.addCaretListener(selectionLength);
				}
			}
		}

		private class SelectionLength extends JLabel implements CaretListener
		{
			boolean visible;
			
			@Override
			public void addNotify()
			{
				super.addNotify();
				visible = true;
				textArea.addCaretListener(this);
			} 


			
			@Override
			public void removeNotify()
			{
				visible = false;
				textArea.removeCaretListener(this);
				super.removeNotify();
			} 

			public void caretUpdate(CaretEvent e)
			{
				Selection selection = textArea.getSelectionAtOffset(textArea.getCaretPosition());
				if (selection == null)
				{
					setText("""");
				}
				else
				{
					int selectionEnd = selection.getEnd();
					int selectionStart = selection.getStart();
					int len;
					if (selection instanceof Selection.Rect)
					{
						int startLine = selection.getStartLine();
						int endLine = selection.getEndLine();
						JEditTextArea textArea = view.getTextArea();
						int startLineOffset = textArea.getLineStartOffset(startLine);
						int endLineOffset = textArea.getLineStartOffset(endLine);
						int lines = endLine - startLine + 1;
						int columns = (selectionEnd - endLineOffset) -
							(selectionStart - startLineOffset);
						len = lines * columns;
					}
					else
						len = selectionEnd - selectionStart;
					setText(Integer.toString(len));
				}
			}
		}
	} 
}"
jEdit,4.3,org.gjt.sp.jedit.indent.WhitespaceRule,2,1,0,4,9,1,1,3,2,2.0,57,0.0,0,0.0,0.625,0,0,27.5,7,3.5,0,"

package org.gjt.sp.jedit.indent;

import java.util.List;

import org.gjt.sp.jedit.buffer.JEditBuffer;


public class WhitespaceRule implements IndentRule
{

	public void apply(JEditBuffer buffer, int thisLineIndex,
			  int prevLineIndex, int prevPrevLineIndex,
			  List<IndentAction> indentActions)
	{
		
		CharSequence current = buffer.getLineSegment(thisLineIndex);
		boolean found = false;
		for (int i = 0; i < current.length(); i++)
		{
			if (!Character.isWhitespace(current.charAt(i)))
			{
				found = true;
				break;
			}
		}
		if (!found)
			return;

		
		if (prevLineIndex >= 0) {
			CharSequence previous = buffer.getLineSegment(prevLineIndex);
			for (int i = 0; i < previous.length(); i++)
			{
				if (!Character.isWhitespace(previous.charAt(i)))
					return;
			}
		}
		indentActions.add(new IndentAction.NoIncrease());
	}

}

"
jEdit,4.3,org.gjt.sp.jedit.search.AllBufferSet,4,2,0,7,21,0,2,5,3,0.0,79,1.0,0,0.7,0.5,1,1,18.5,3,1.25,0,"

package org.gjt.sp.jedit.search;


import java.awt.Component;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class AllBufferSet extends BufferListSet
{
	
	
	public AllBufferSet(String glob)
	{
		this.glob = glob;
	} 

	
	
	public String getFileFilter()
	{
		return glob;
	} 

	
	
	@Override
	public String getCode()
	{
		return ""new AllBufferSet(\"""" + StandardUtilities.charsToEscapes(glob)
			+ ""\"")"";
	} 

	
	private String glob;
	

	
	@Override
	protected String[] _getFiles(Component comp)
	{
		Buffer[] buffers = jEdit.getBuffers();
		List<String> returnValue = new ArrayList<String>(buffers.length);

		Pattern filter;
		try
		{
			filter = Pattern.compile(StandardUtilities.globToRE(glob),
				Pattern.CASE_INSENSITIVE);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			return null;
		}

		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(filter.matcher(buffer.getName()).matches())
				returnValue.add(buffer.getPath());
		}

		return returnValue.toArray(new String[returnValue.size()]);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.EncodingDetector,1,1,0,5,1,0,5,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.io;

import java.io.InputStream;
import java.io.IOException;


public interface EncodingDetector
{
	
	public String detectEncoding(InputStream sample) throws IOException;
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.UndoManager,21,1,0,10,36,96,5,8,14,0.754166667,559,1.0,8,0.0,0.204081633,0,0,25.04761905,8,2.5714,0,"

package org.gjt.sp.jedit.buffer;


import org.gjt.sp.util.Log;



public class UndoManager
{
	
	public UndoManager(JEditBuffer buffer)
	{
		this.buffer = buffer;
	} 

	
	public void setLimit(int limit)
	{
		this.limit = limit;
	} 

	
	public void clear()
	{
		undosFirst = undosLast = redosFirst = redosLast = null;
		undoCount = 0;
	} 

	
	public boolean canUndo()
	{
		return (undosLast != null);
	} 

	
	public int undo()
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");

		if(undosLast == null)
			return -1;
		else
		{
			reviseUndoId();
			undoCount--;

			int caret = undosLast.undo();
			redosFirst = undosLast;
			undosLast = undosLast.prev;
			if(undosLast == null)
				undosFirst = null;
			return caret;
		}
	} 

	
	public boolean canRedo()
	{
		return (redosFirst != null);
	} 

	
	public int redo()
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");

		if(redosFirst == null)
			return -1;
		else
		{
			reviseUndoId();
			undoCount++;

			int caret = redosFirst.redo();
			undosLast = redosFirst;
			if(undosFirst == null)
				undosFirst = undosLast;
			redosFirst = redosFirst.next;
			return caret;
		}
	} 

	
	public void beginCompoundEdit()
	{
		if(compoundEditCount == 0)
		{
			compoundEdit = new CompoundEdit();
			reviseUndoId();
		}

		compoundEditCount++;
	} 

	
	public void endCompoundEdit()
	{
		if(compoundEditCount == 0)
		{
			Log.log(Log.WARNING,this,new Exception(""Unbalanced begin/endCompoundEdit()""));
			return;
		}
		else if(compoundEditCount == 1)
		{
			if(compoundEdit.first == null)
				;
			else if(compoundEdit.first == compoundEdit.last)
				addEdit(compoundEdit.first);
			else
				addEdit(compoundEdit);

			compoundEdit = null;
		}

		compoundEditCount--;
	} 

	
	public boolean insideCompoundEdit()
	{
		return compoundEditCount != 0;
	} 

	
	public Object getUndoId()
	{
		return undoId;
	} 

	
	public void contentInserted(int offset, int length, String text, boolean clearDirty)
	{
		Edit last = getLastEdit();
		Edit toMerge = getMergeEdit();

		if(!clearDirty && toMerge instanceof Insert
			&& redosFirst == null)
		{
			Insert ins = (Insert)toMerge;
			if(ins.offset == offset)
			{
				ins.str = text.concat(ins.str);
				ins.length += length;
				return;
			}
			else if(ins.offset + ins.length == offset)
			{
				ins.str = ins.str.concat(text);
				ins.length += length;
				return;
			}
		}

		Insert ins = new Insert(this,offset,length,text);

		if(clearDirty)
		{
			redoClearDirty = last;
			undoClearDirty = ins;
		}

		if(compoundEdit != null)
			compoundEdit.add(ins);
		else
		{
			reviseUndoId();
			addEdit(ins);
		}
	} 

	
	public void contentRemoved(int offset, int length, String text, boolean clearDirty)
	{
		Edit last = getLastEdit();
		Edit toMerge = getMergeEdit();

		if(!clearDirty && toMerge instanceof Remove
			&& redosFirst == null)
		{
			Remove rem = (Remove)toMerge;
			if(rem.offset == offset)
			{
				rem.content.str = rem.content.str.concat(text);
				rem.content.hashcode = rem.content.str.hashCode();
				rem.length += length;
				KillRing.getInstance().changed(rem.content);
				return;
			}
			else if(offset + length == rem.offset)
			{
				rem.content.str = text.concat(rem.content.str);
				rem.content.hashcode = rem.content.str.hashCode();
				rem.length += length;
				rem.offset = offset;
				KillRing.getInstance().changed(rem.content);
				return;
			}
		}

		Remove rem = new Remove(this,offset,length,text);
		if(clearDirty)
		{
			redoClearDirty = last;
			undoClearDirty = rem;
		}

		if(compoundEdit != null)
			compoundEdit.add(rem);
		else
		{
			reviseUndoId();
			addEdit(rem);
		}

		KillRing.getInstance().add(rem.content);
	} 

	
	public void resetClearDirty()
	{
		redoClearDirty = getLastEdit();
		if(redosFirst instanceof CompoundEdit)
			undoClearDirty = ((CompoundEdit)redosFirst).first;
		else
			undoClearDirty = redosFirst;
	} 

	

	
	private JEditBuffer buffer;

	
	private Edit undosFirst;
	private Edit undosLast;

	
	private Edit redosFirst;
	private Edit redosLast;

	private int limit;
	private int undoCount;
	private int compoundEditCount;
	private CompoundEdit compoundEdit;
	private Edit undoClearDirty, redoClearDirty;
	private Object undoId;
	

	
	private void addEdit(Edit edit)
	{
		if(undosFirst == null)
			undosFirst = undosLast = edit;
		else
		{
			undosLast.next = edit;
			edit.prev = undosLast;
			undosLast = edit;
		}

		redosFirst = redosLast = null;

		undoCount++;

		while(undoCount > limit)
		{
			undoCount--;

			if(undosFirst == undosLast)
				undosFirst = undosLast = null;
			else
			{
				undosFirst.next.prev = null;
				undosFirst = undosFirst.next;
			}
		}
	} 

	
	private Edit getMergeEdit()
	{
		Edit last = getLastEdit();
		return (compoundEdit != null ? compoundEdit.last : last);
	} 

	
	private Edit getLastEdit()
	{
		if(undosLast instanceof CompoundEdit)
			return ((CompoundEdit)undosLast).last;
		else
			return undosLast;
	} 

	
	
	private void reviseUndoId()
	{
		undoId = new Object();
	} 

	

	

	
	abstract static class Edit
	{
		Edit prev, next;

		
		abstract int undo();
		

		
		abstract int redo();
		
	} 

	
	static class Insert extends Edit
	{
		
		Insert(UndoManager mgr, int offset, int length, String str)
		{
			this.mgr = mgr;
			this.offset = offset;
			this.length = length;
			this.str = str;
		} 

		
		int undo()
		{
			mgr.buffer.remove(offset,length);
			if(mgr.undoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset;
		} 

		
		int redo()
		{
			mgr.buffer.insert(offset,str);
			if(mgr.redoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset + length;
		} 

		UndoManager mgr;
		int offset;
		int length;
		String str;
	} 

	
	
	public static class RemovedContent
	{
		String str;
		int hashcode;
		boolean inKillRing;

		public RemovedContent(String str)
		{
			this.str = str;
			this.hashcode = str.hashCode();
		}

		public String toString()
		{
			return str;
		}
	}

	
	static class Remove extends Edit
	{
		
		Remove(UndoManager mgr, int offset, int length, String str)
		{
			this.mgr = mgr;
			this.offset = offset;
			this.length = length;
			this.content = new RemovedContent(str);
		} 

		
		int undo()
		{
			mgr.buffer.insert(offset,content.str);
			if(mgr.undoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset + length;
		} 

		
		int redo()
		{
			mgr.buffer.remove(offset,length);
			if(mgr.redoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset;
		} 

		UndoManager mgr;
		int offset;
		int length;
		final RemovedContent content;
	} 

	
	static class CompoundEdit extends Edit
	{
		
		public int undo()
		{
			int retVal = -1;
			Edit edit = last;
			while(edit != null)
			{
				retVal = edit.undo();
				edit = edit.prev;
			}
			return retVal;
		} 

		
		public int redo()
		{
			int retVal = -1;
			Edit edit = first;
			while(edit != null)
			{
				retVal = edit.redo();
				edit = edit.next;
			}
			return retVal;
		} 

		
		public void add(Edit edit)
		{
			if(first == null)
				first = last = edit;
			else
			{
				edit.prev = last;
				last.next = edit;
				last = edit;
			}
		} 

		Edit first, last;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.BufferSwitcher,4,5,0,9,23,0,6,7,2,0.5,82,1.0,1,0.995856354,0.416666667,0,0,19.0,2,1.0,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.bufferset.BufferSet;



public class BufferSwitcher extends JComboBox
{
    
	private EditPane editPane;
	private boolean updating;

	public BufferSwitcher(final EditPane editPane)
	{
		this.editPane = editPane;

		
		setRenderer(new BufferCellRenderer());
		setMaximumRowCount(jEdit.getIntegerProperty(""bufferSwitcher.maxRowCount"",10));
		addActionListener(new ActionHandler());
		addPopupMenuListener(new PopupMenuListener()
		{
			public void popupMenuWillBecomeVisible(
				PopupMenuEvent e) {}

			public void popupMenuWillBecomeInvisible(
				PopupMenuEvent e)
			{
				editPane.getTextArea().requestFocus();
			}

			public void popupMenuCanceled(PopupMenuEvent e)
			{
				editPane.getTextArea().requestFocus();
			}
		});
	}

	public void updateBufferList()
	{
		
		
		BufferSet bufferSet = editPane.getBufferSet();
		if(bufferSet.size() == 0)
			return;

		updating = true;
		setMaximumRowCount(jEdit.getIntegerProperty(""bufferSwitcher.maxRowCount"",10));
		setModel(new DefaultComboBoxModel(bufferSet.getAllBuffers()));
		setSelectedItem(editPane.getBuffer());
		setToolTipText(editPane.getBuffer().getPath(true));
		updating = false;
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(!updating)
			{
				Buffer buffer = (Buffer)getSelectedItem();
				if(buffer != null) 
					editPane.setBuffer(buffer);
			}
		}
	}

	class BufferCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Buffer buffer = (Buffer)value;
			
			if(buffer == null)
				setIcon(null);
			else
			{
				setIcon(buffer.getIcon());
				setToolTipText(buffer.getPath());
			}
			return this;
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.ClockWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,11,0.0,0,0.0,0.75,0,0,4.5,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.text.DateFormat;
import java.util.Date;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.Timer;
import javax.swing.ToolTipManager;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;



public class ClockWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view) 
	{
		Widget clock = new ClockWidget();
		return clock;
	} 

	
	private static class ClockWidget implements Widget
	{
		private final Clock clock;
		ClockWidget()
		{
			clock = new Clock();
		}
		
		public JComponent getComponent() 
		{
			return clock;
		}
		
		public void update() 
		{
		}
		
		public void propertiesChanged()
		{
		}
	} 

	
	private static class Clock extends JLabel implements ActionListener
	{
		
		Clock()
		{
			setForeground(jEdit.getColorProperty(""view.status.foreground""));
			setBackground(jEdit.getColorProperty(""view.status.background""));
		} 

		
		@Override
		public void addNotify()
		{
			super.addNotify();
			update();

			int millisecondsPerMinute = 1000 * 60;

			timer = new Timer(millisecondsPerMinute,this);
			timer.setInitialDelay((int)(
				millisecondsPerMinute
				- System.currentTimeMillis()
				% millisecondsPerMinute) + 500);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		@Override
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
			super.removeNotify();
		} 

		
		@Override
		public String getToolTipText()
		{
			return new Date().toString();
		} 

		
		@Override
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} 

		
		public void actionPerformed(ActionEvent e)
		{
			update();
		} 

		
		private Timer timer;

		
		private static String getTime()
		{
			return DateFormat.getTimeInstance(
				DateFormat.SHORT).format(new Date());
		} 

		
		private void update()
		{
			setText(getTime());
		} 

		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHArrayInitializer,4,2,0,12,24,6,3,9,2,2.0,190,0.0,0,0.85,0.625,1,1,46.5,1,0.75,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Array;

class BSHArrayInitializer extends SimpleNode
{
    BSHArrayInitializer(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError 
	{
		throw new EvalError( ""Array initializer has no base type."", 
			this, callstack );
	}

	
    public Object eval( Class baseType, int dimensions, 
						CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
        int numInitializers = jjtGetNumChildren();

		
		int [] dima = new int [dimensions]; 
		
		
		dima[0] = numInitializers;
        Object initializers =  Array.newInstance( baseType, dima );

		
        for (int i = 0; i < numInitializers; i++)
        {
			SimpleNode node = (SimpleNode)jjtGetChild(i);
            Object currentInitializer;
			if ( node instanceof BSHArrayInitializer ) {
				if ( dimensions < 2 )
					throw new EvalError(
						""Invalid Location for Intializer, position: ""+i, 
						this, callstack );
            	currentInitializer = 
					((BSHArrayInitializer)node).eval( 
						baseType, dimensions-1, callstack, interpreter);
			} else
            	currentInitializer = node.eval( callstack, interpreter);

			if ( currentInitializer == Primitive.VOID )
				throw new EvalError(
					""Void in array initializer, position""+i, this, callstack );

			
			
			
			
			
			
			
			
			
			Object value = currentInitializer;
			if ( dimensions == 1 )
			{
				
				
				try {
					value = Types.castObject(
						currentInitializer, baseType, Types.CAST );
				} catch ( UtilEvalError e ) {
					throw e.toEvalError(
						""Error in array initializer"", this, callstack );
				}
				
				value = Primitive.unwrap( value );
			}

				
            try {
				Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
				Interpreter.debug(""illegal arg""+e);
				throwTypeError( baseType, currentInitializer, i, callstack );
            } catch( ArrayStoreException e ) { 
				Interpreter.debug(""arraystore""+e);
				throwTypeError( baseType, currentInitializer, i, callstack );
            }
        }

        return initializers;
    }

	private void throwTypeError( 
		Class baseType, Object initializer, int argNum, CallStack callstack ) 
		throws EvalError
	{
		String rhsType;
		if (initializer instanceof Primitive)
			rhsType = 
				((Primitive)initializer).getType().getName();
		else
			rhsType = Reflect.normalizeClassName(
				initializer.getClass());

		throw new EvalError ( ""Incompatible type: "" + rhsType 
			+"" in initializer of array type: ""+ baseType
			+"" at position: ""+argNum, this, callstack );
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.JEditKillRing,3,2,0,9,26,0,1,9,2,0.0,172,1.0,1,0.888888889,1.0,1,2,56.0,7,3.3333,0,"
package org.gjt.sp.jedit;

import java.util.List;
import java.util.LinkedList;
import java.io.IOException;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.buffer.KillRing;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.IOUtilities;


class JEditKillRing extends KillRing
{
	
	JEditKillRing()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			killringXML = new SettingsXML(settingsDirectory, ""killring"");
		}
	} 

	
	@Override
	public void load()
	{
		if(killringXML == null)
			return;

		if(!killringXML.fileExists())
			return;

		Log.log(Log.MESSAGE,KillRing.class,""Loading "" + killringXML);

		KillRingHandler handler = new KillRingHandler();
		try
		{
			killringXML.load(handler);
		}
		catch (IOException ioe)
		{
			Log.log(Log.ERROR, this, ioe);
		}
		reset(handler.list);
	} 

	
	@Override
	public void save()
	{
		if(killringXML == null)
			return;

		if(killringXML.hasChangedOnDisk())
		{
			Log.log(Log.WARNING,KillRing.class,killringXML
				+ "" changed on disk; will not save killring""
				+ "" files"");
			return;
		}

		Log.log(Log.MESSAGE,KillRing.class,""Saving "" + killringXML);

		String lineSep = System.getProperty(""line.separator"");

		SettingsXML.Saver out = null;

		try
		{
			out = killringXML.openSaver();
			out.writeXMLDeclaration(""1.1"");

			out.write(""<!DOCTYPE KILLRING SYSTEM \""killring.dtd\"">"");
			out.write(lineSep);
			out.write(""<KILLRING>"");
			out.write(lineSep);

			int size = getSize();
			for(int i = size - 1; i >=0; i--)
			{
				out.write(""<ENTRY>"");
				out.write(XMLUtilities.charsToEntities(
					getElementAt(i).toString(),true));
				out.write(""</ENTRY>"");
				out.write(lineSep);
			}

			out.write(""</KILLRING>"");
			out.write(lineSep);

			out.finish();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,KillRing.class,e);
		}
		finally
		{
			IOUtilities.closeQuietly(out);
		}
	} 

	
	private SettingsXML killringXML;

	
	private static class KillRingHandler extends DefaultHandler
	{
		public List<String> list = new LinkedList<String>();

		@Override
		public InputSource resolveEntity(String publicId, String systemId)
		{
			return XMLUtilities.findEntity(systemId, ""killring.dtd"", getClass());
		}

		@Override
		public void startElement(String uri, String localName,
					 String qName, Attributes attrs)
		{
			inEntry = qName.equals(""ENTRY"");
		}

		@Override
		public void endElement(String uri, String localName, String name)
		{
			if(name.equals(""ENTRY""))
			{
				list.add(charData.toString());
				inEntry = false;
				charData.setLength(0);
			}
		}

		@Override
		public void characters(char[] ch, int start, int length)
		{
			if (inEntry)
				charData.append(ch, start, length);
		}

		@Override
		public void processingInstruction(String target, String data)
		{
			if (""illegal-xml-character"".equals(target))
			{
				char ch;
				try
				{
					ch = (char)Integer.parseInt(data.trim());
				}
				catch (Exception e)
				{
					Log.log(Log.ERROR, this,
						""Failed to get character from PI""
							+ ""\"""" + target + ""\""""
							+ "" with \"""" + data + ""\""""
							+ "": "" + e);
					return;
				}
				characters(new char[] {ch}, 0, 1);
			}
		}

		private final StringBuilder charData = new StringBuilder();
		private boolean inEntry;
	} 
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockingFrameworkProvider,2,1,0,8,2,1,4,5,2,2.0,2,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"package org.gjt.sp.jedit.gui;

import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.View.ViewConfig;
import org.gjt.sp.jedit.gui.DockableWindowManager.DockingLayout;



public interface DockingFrameworkProvider {
	DockableWindowManager create(View view, DockableWindowFactory instance,
			ViewConfig config);
	DockingLayout createDockingLayout();
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.EnhancedMenu,8,7,0,12,41,22,2,11,7,0.542857143,212,1.0,3,0.994206257,0.46875,1,1,24.875,8,1.5,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.event.*;
import javax.swing.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.*;


public class EnhancedMenu extends JMenu implements MenuListener
{
	
	public EnhancedMenu(String name)
	{
		this(name,jEdit.getProperty(name.concat("".label"")),
			jEdit.getActionContext());
	} 

	
	public EnhancedMenu(String name, String label)
	{
		this(name,label,jEdit.getActionContext());
	} 

	
	public EnhancedMenu(String name, String label, ActionContext context)
	{
		this.context = context;
		if(label == null)
			label = name;

		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';

		setText(label);
		if(!OperatingSystem.isMacOS())
			setMnemonic(mnemonic);

		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					addSeparator();
				else
					add(GUIUtilities.loadMenuItem(context,menuItemName,true));
			}
		}

		initialComponentCount = getMenuComponentCount();

		providerCode = jEdit.getProperty(name + "".code"");

		ebStub = new EditBusStub(name);
		ebStub.menuOutOfDate = true;

		addMenuListener(this);

		if(providerCode != null)
			EditBus.addToBus(ebStub);
	} 

	
	public void menuSelected(MenuEvent evt)
	{
		init();
	} 

	public void menuDeselected(MenuEvent e) {}

	public void menuCanceled(MenuEvent e) {}

	
	public void init()
	{
		if(providerCode == null)
			return;

		if(provider == null)
		{
			Object obj = BeanShell.eval(null,
				BeanShell.getNameSpace(),
				providerCode);
			provider = (DynamicMenuProvider)obj;
		}

		if(provider == null)
		{
			
			providerCode = null;
			return;
		}

		if(ebStub.menuOutOfDate || provider.updateEveryTime())
		{
			ebStub.menuOutOfDate = false;

			while(getMenuComponentCount() != initialComponentCount)
				remove(getMenuComponentCount() - 1);

			if(provider != null)
				provider.update(this);
		}
	} 

	
	protected int initialComponentCount;
	protected ActionContext context;

	protected String providerCode;
	protected DynamicMenuProvider provider;

	protected EditBusStub ebStub;

	
	protected void finalize() throws Exception
	{
		if(ebStub != null)
			EditBus.removeFromBus(ebStub);
	} 

	

	
	
	static class EditBusStub implements EBComponent
	{
		String name;
		boolean menuOutOfDate;

		EditBusStub(String name)
		{
			this.name = name;
			menuOutOfDate = true;
		}

		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof DynamicMenuChanged
				&& name.equals(((DynamicMenuChanged)msg)
				.getMenuName()))
			{
				menuOutOfDate = true;
			}
			else if(msg instanceof PropertiesChanged)
			{
				
				
				menuOutOfDate = true;
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.PluginUpdate,6,2,0,8,15,5,7,2,5,0.866666667,68,0.333333333,0,0.428571429,0.4,1,1,9.333333333,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class PluginUpdate extends EBMessage
{
	
	
	public static final Object LOADED = ""LOADED"";

	
	public static final Object ACTIVATED = ""ACTIVATED"";

	
	public static final Object DEACTIVATED = ""DEACTIVATED"";

	
	public static final Object UNLOADED = ""UNLOADED"";
	

	
	
	public PluginUpdate(PluginJAR jar, Object what, boolean exit)
	{
		super(jar);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
		this.exit = exit;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public boolean isExiting()
	{
		return exit;
	} 

	
	
	public PluginJAR getPluginJAR()
	{
		return (PluginJAR)getSource();
	} 

	
	public String paramString()
	{
		return ""what="" + what + "",exit="" + exit + "",""
			+ super.paramString();
	} 

	
	private Object what;
	private boolean exit;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.print.BufferPrintable,8,1,0,15,76,0,3,13,2,0.745341615,930,1.0,4,0.0,0.296703297,0,0,112.375,16,3.5,0,"

package org.gjt.sp.jedit.print;


import javax.swing.text.TabExpander;
import javax.swing.SwingUtilities;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.print.*;
import java.awt.*;
import java.lang.reflect.Method;
import java.util.*;
import java.util.List;

import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



class BufferPrintable implements Printable
{
	
	BufferPrintable(PrinterJob job, Object format,
		View view, Buffer buffer, Font font, boolean header,
		boolean footer, boolean lineNumbers, boolean color)
	{
		this.job = job;
		this.format = format;
		this.view = view;
		this.buffer = buffer;
		this.font = font;
		this.header = header;
		this.footer = footer;
		this.lineNumbers = lineNumbers;

		styles = org.gjt.sp.util.SyntaxUtilities.loadStyles(jEdit.getProperty(""print.font""),
			jEdit.getIntegerProperty(""print.fontsize"",10),color);
		styles[Token.NULL] = new SyntaxStyle(textColor,null,font);

		
		for(int i = 0; i < styles.length; i++)
		{
			SyntaxStyle s = styles[i];
			if(s.getForegroundColor().equals(Color.WHITE)
				&& s.getBackgroundColor() == null)
			{
				styles[i] = new SyntaxStyle(
					Color.BLACK,
					styles[i].getBackgroundColor(),
					styles[i].getFont());
			}
		}

		lineList = new ArrayList<Chunk>();

		tokenHandler = new DisplayTokenHandler();
	} 

	
	public void print()
	{
		try
		{
			

			if(format == null)
				job.print();
			else
			{
				Method method = PrinterJob.class.getMethod(
					""print"",new Class[] { Class.forName(
					""javax.print.attribute.PrintRequestAttributeSet"") });
				method.invoke(job,new Object[] { format });
			}
		}
		catch(PrinterAbortException ae)
		{
			Log.log(Log.DEBUG,this,ae);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			final String[] args = { e.toString() };
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""print-error"",args);
				}
			});
		}
		finally
		{
			
		}
	} 

	
	public int print(Graphics _gfx, PageFormat pageFormat, int pageIndex)
		throws PrinterException
	{
		
		
		if(frc == null)
		{
			frc = ((Graphics2D)_gfx).getFontRenderContext();
			Log.log(Log.DEBUG,this,""Font render context is "" + frc);
		}

		Log.log(Log.DEBUG,this,""Asked to print page "" + pageIndex);
		Log.log(Log.DEBUG,this,""Current page is "" + currentPage);

		if(pageIndex > currentPage)
		{
			for(int i = currentPage; i < pageIndex; i++)
			{
				Log.log(Log.DEBUG,this,""Current physical line is now "" + currentPageStart);
				currentPhysicalLine = currentPageStart;
				printPage(_gfx,pageFormat,i,true);
			}

			currentPage = pageIndex - 1;
			Log.log(Log.DEBUG,this,""Current page is now "" + currentPage);
		}

		if(pageIndex == currentPage + 1)
		{
			if(end)
			{
				Log.log(Log.DEBUG,this,""The end"");
				return NO_SUCH_PAGE;
			}

			currentPageStart = currentPhysicalLine;
			Log.log(Log.DEBUG,this,""#2 - Current physical line is now "" + currentPageStart);
			currentPage = pageIndex;
			Log.log(Log.DEBUG,this,""#2 - Current page is now "" + currentPage);
		}
		else if(pageIndex == currentPage)
		{
			currentPhysicalLine = currentPageStart;
			Log.log(Log.DEBUG,this,""#3 - Current physical line is now "" + currentPageStart);
		}

		printPage(_gfx,pageFormat,pageIndex,true);

		return PAGE_EXISTS;
	} 

	

	
	private static Color headerColor = Color.lightGray;
	private static Color headerTextColor = Color.black;
	private static Color footerColor = Color.lightGray;
	private static Color footerTextColor = Color.black;
	private static Color lineNumberColor = Color.gray;
	private static Color textColor = Color.black;
	

	
	private PrinterJob job;
	private Object format;

	private View view;
	private Buffer buffer;
	private Font font;
	private SyntaxStyle[] styles;
	private boolean header;
	private boolean footer;
	private boolean lineNumbers;

	private int currentPage;
	private int currentPageStart;
	private int currentPhysicalLine;
	private boolean end;

	private LineMetrics lm;
	private final List<Chunk> lineList;

	private FontRenderContext frc;

	private DisplayTokenHandler tokenHandler;
	

	
	private void printPage(Graphics _gfx, PageFormat pageFormat, int pageIndex,
		boolean actuallyPaint)
	{
		Log.log(Log.DEBUG,this,""printPage("" + pageIndex + ',' + actuallyPaint + ')');
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setFont(font);

		double pageX = pageFormat.getImageableX();
		double pageY = pageFormat.getImageableY();
		double pageWidth = pageFormat.getImageableWidth();
		double pageHeight = pageFormat.getImageableHeight();

		Log.log(Log.DEBUG,this,""#1 - Page dimensions: "" + pageWidth
			+ 'x' + pageHeight);

		if(header)
		{
			double headerHeight = paintHeader(gfx,pageX,pageY,pageWidth,
				actuallyPaint);
			pageY += headerHeight;
			pageHeight -= headerHeight;
		}

		if(footer)
		{
			double footerHeight = paintFooter(gfx,pageX,pageY,pageWidth,
				pageHeight,pageIndex,actuallyPaint);
			pageHeight -= footerHeight;
		}

		boolean glyphVector = jEdit.getBooleanProperty(""print.glyphVector"");
		double lineNumberWidth;

		
		if(lineNumbers)
		{
			
			
			int lineNumberDigits = (int)Math.ceil(Math.log(buffer.getLineCount() + 1)
				/ Math.log(10)) + 1;

			
			char[] chars = new char[lineNumberDigits];
			for(int i = 0; i < chars.length; i++)
				chars[i] = ' ';
			lineNumberWidth = font.getStringBounds(chars,
				0,lineNumberDigits,frc).getWidth();
		}
		else
			lineNumberWidth = 0.0;
		

		Log.log(Log.DEBUG,this,""#2 - Page dimensions: ""
			+ (pageWidth - lineNumberWidth)
			+ 'x' + pageHeight);

		
		int tabSize = jEdit.getIntegerProperty(""print.tabSize"",8);
		char[] chars = new char[tabSize];
		for(int i = 0; i < chars.length; i++)
			chars[i] = ' ';
		double tabWidth = font.getStringBounds(chars,
			0,tabSize,frc).getWidth();
		PrintTabExpander e = new PrintTabExpander(tabWidth);
		

		lm = font.getLineMetrics(""gGyYX"",frc);
		Log.log(Log.DEBUG,this,""Line height is "" + lm.getHeight());

		double y = 0.0;
print_loop:	for(;;)
		{
			if(currentPhysicalLine == buffer.getLineCount())
			{
				Log.log(Log.DEBUG,this,""Finished buffer"");
				end = true;
				break print_loop;
			}
			if (!jEdit.getBooleanProperty(""print.folds"",true) &&
				!view.getTextArea().getDisplayManager().isLineVisible(currentPhysicalLine))
			{
				
				Log.log(Log.DEBUG,this,""Skipping invisible line"");
				currentPhysicalLine++;
				continue;
			}
				
			lineList.clear();

			tokenHandler.init(styles,frc,e,lineList,
				(float)(pageWidth - lineNumberWidth));

			buffer.markTokens(currentPhysicalLine,tokenHandler);
			if(lineList.isEmpty())
				lineList.add(null);

			if(y + (lm.getHeight() * lineList.size()) >= pageHeight)
			{
				Log.log(Log.DEBUG,this,""Finished page before line "" + currentPhysicalLine);
				break print_loop;
			}

			if(lineNumbers && actuallyPaint)
			{
				gfx.setFont(font);
				gfx.setColor(lineNumberColor);
				gfx.drawString(String.valueOf(currentPhysicalLine + 1),
					(float)pageX,(float)(pageY + y + lm.getHeight()));
			}

			for(int i = 0; i < lineList.size(); i++)
			{
				y += lm.getHeight();
				Chunk chunks = lineList.get(i);
				if(chunks != null && actuallyPaint)
				{
					Chunk.paintChunkBackgrounds(chunks,gfx,
						(float)(pageX + lineNumberWidth),
						(float)(pageY + y));
					Chunk.paintChunkList(chunks,gfx,
						(float)(pageX + lineNumberWidth),
						(float)(pageY + y),glyphVector);
				}
			}

			currentPhysicalLine++;
		}
	} 

	
	private double paintHeader(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, boolean actuallyPaint)
	{
		String headerText = jEdit.getProperty(""print.headerText"",
			new String[] { buffer.getName() });
		FontRenderContext frc = gfx.getFontRenderContext();
		lm = font.getLineMetrics(headerText,frc);

		Rectangle2D bounds = font.getStringBounds(headerText,frc);
		Rectangle2D headerBounds = new Rectangle2D.Double(
			pageX,pageY,pageWidth,bounds.getHeight());

		if(actuallyPaint)
		{
			gfx.setColor(headerColor);
			gfx.fill(headerBounds);
			gfx.setColor(headerTextColor);
			gfx.drawString(headerText,
				(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
				(float)(pageY + lm.getAscent()));
		}

		return headerBounds.getHeight();
	}
	

	
	private double paintFooter(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, double pageHeight, int pageIndex,
		boolean actuallyPaint)
	{
		String footerText = jEdit.getProperty(""print.footerText"",
			new Object[] { new Date(), Integer.valueOf(pageIndex + 1)});
		FontRenderContext frc = gfx.getFontRenderContext();
		lm = font.getLineMetrics(footerText,frc);

		Rectangle2D bounds = font.getStringBounds(footerText,frc);
		Rectangle2D footerBounds = new Rectangle2D.Double(
			pageX,pageY + pageHeight - bounds.getHeight(),
			pageWidth,bounds.getHeight());

		if(actuallyPaint)
		{
			gfx.setColor(footerColor);
			gfx.fill(footerBounds);
			gfx.setColor(footerTextColor);
			gfx.drawString(footerText,
				(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
				(float)(pageY + pageHeight - bounds.getHeight()
				+ lm.getAscent()));
		}

		return footerBounds.getHeight();
	} 

	

	
	static class PrintTabExpander implements TabExpander
	{
		private double tabWidth;

		
		PrintTabExpander(double tabWidth)
		{
			this.tabWidth = tabWidth;
		} 

		
		public float nextTabStop(float x, int tabOffset)
		{
			int ntabs = (int)((x + 1) / tabWidth);
			return (float)((ntabs + 1) * tabWidth);
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.EditAbbrevDialog,10,6,0,7,47,19,4,5,4,0.592592593,254,1.0,1,0.987860395,0.271428571,2,2,23.8,4,1.3,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;


public class EditAbbrevDialog extends JDialog
{
	
	
	public EditAbbrevDialog(Frame frame, String abbrev, String expansion,
		Map abbrevs)
	{
		super(frame,jEdit.getProperty(""edit-abbrev.title""),true);
		init(abbrev, expansion, abbrevs);
	} 

	
	public EditAbbrevDialog(Dialog dialog, String abbrev, String expansion,
		Map abbrevs)
	{
		super(dialog,jEdit.getProperty(""edit-abbrev.title""),true);
		init(abbrev, expansion, abbrevs);
	} 

	
	public String getAbbrev()
	{
		if(!isOK)
			return null;

		return editor.getAbbrev();
	} 

	
	public String getExpansion()
	{
		if(!isOK)
			return null;

		return editor.getExpansion();
	} 

	
	private AbbrevEditor editor;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	private String originalAbbrev;
	private Map abbrevs;

	
	private void init(String abbrev, String expansion, Map abbrevs)
	{
		this.abbrevs = abbrevs;

		this.originalAbbrev = abbrev;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setExpansion(expansion);
		editor.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.CENTER,editor);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		box.add(ok);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);

		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(getParent());
		setVisible(true);
	} 

	
	private boolean checkForExistingAbbrev()
	{
		String abbrev = editor.getAbbrev();
		if(abbrevs.get(abbrev) != null)
		{
			if(abbrev.equals(originalAbbrev))
				return true;

			int result = GUIUtilities.confirm(this,
				""edit-abbrev.duplicate"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			return (result == JOptionPane.YES_OPTION);
		}

		return true;
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(editor.getAbbrev() == null
					|| editor.getAbbrev().length() == 0)
				{
					getToolkit().beep();
					return;
				}

				if(!checkForExistingAbbrev())
					return;

				isOK = true;
			}

			dispose();
		}
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.FavoritesVFS,10,2,0,11,38,13,4,8,9,0.694444444,294,0.75,1,0.829787234,0.377777778,2,3,28.0,3,1.6,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.util.*;
import org.gjt.sp.jedit.msg.DynamicMenuChanged;
import org.gjt.sp.jedit.*;



public class FavoritesVFS extends VFS
{
	public static final String PROTOCOL = ""favorites"";

	
	public FavoritesVFS()
	{
		super(""favorites"",DELETE_CAP | LOW_LATENCY_CAP,
			new String[] { EA_TYPE });

		
		instance = this;
	} 

	
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} 

	
	public VFSFile[] _listFiles(Object session, String url,
		Component comp)
	{
		return getFavorites();
	} 

	
	public VFSFile _getFile(Object session, String path,
		Component comp)
	{
		
		return new Favorite(path,VFSFile.DIRECTORY);
	} 

	
	public boolean _delete(Object session, String path, Component comp)
	{
		synchronized(lock)
		{
			path = path.substring(PROTOCOL.length() + 1);

			Iterator<Favorite> iter = favorites.iterator();
			while(iter.hasNext())
			{
				if(iter.next().getPath().equals(path))
				{
					iter.remove();
					VFSManager.sendVFSUpdate(this,PROTOCOL
						+ ':',false);
					EditBus.send(new DynamicMenuChanged(
						""favorites""));
					return true;
				}
			}
		}

		return false;
	} 

	
	public static void loadFavorites()
	{
		synchronized(lock)
		{
			favorites = new LinkedList<Favorite>();

			String favorite;
			int i = 0;
			while((favorite = jEdit.getProperty(""vfs.favorite."" + i)) != null)
			{
				favorites.add(new Favorite(favorite,
					jEdit.getIntegerProperty(""vfs.favorite.""
					+ i + "".type"",
					VFSFile.DIRECTORY)));
				i++;
			}
		}
	} 

	
	public static void addToFavorites(String path, int type)
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			for (Favorite favorite : favorites)
			{
				if (favorite.getPath().equals(path))
					return;
			}

			favorites.add(new Favorite(path,type));

			VFSManager.sendVFSUpdate(instance,PROTOCOL + ':',false);
			EditBus.send(new DynamicMenuChanged(""favorites""));
		}
	} 

	
	public static void saveFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				return;

			int i = 0;
			for (Favorite favorite : favorites)
			{
				jEdit.setProperty(""vfs.favorite."" + i,
					favorite.getPath());
				jEdit.setIntegerProperty(""vfs.favorite."" + i
					+ "".type"", favorite.getType());

				i++;
			}
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size());
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size()
				+ "".type"");
		}
	} 

	
	public static VFSFile[] getFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			return favorites.toArray(
				new VFSFile[favorites.size()]);
		}
	} 

	
	private static FavoritesVFS instance;
	private static final Object lock = new Object();
	private static List<Favorite> favorites;
	

	
	static class Favorite extends VFSFile
	{
		Favorite(String path, int type)
		{
			super(path,path,PROTOCOL + ':' + path,type,0,false);
		}

		public String getExtendedAttribute(String name)
		{
			if(name.equals(EA_TYPE))
				return super.getExtendedAttribute(name);
			else
			{
				
				
				return null;
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.ModeWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.gui.BufferOptions;
import org.gjt.sp.jedit.jEdit;



public class ModeWidgetFactory implements StatusWidgetFactory
{
    
    public Widget getWidget(View view) 
    {
	ModeWidget mode = new ModeWidget(view);
	return mode;
    } 

    
    private static class ModeWidget implements Widget
    {
	    private final JLabel mode;
	    private final View view;
	    public ModeWidget(final View view) 
	    {
		    mode = new ToolTipLabel();
		    this.view = view;
		    mode.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
		    mode.addMouseListener(new MouseAdapter() 
					  {
						  @Override
						  public void mouseClicked(MouseEvent evt)
						  {
							  if(evt.getClickCount() == 2)
								  new BufferOptions(view,view.getBuffer());
						  }
					  });
	    }
	    
	    public JComponent getComponent() 
	    {
		    return mode;
	    }
	    
	    public void update() 
	    {
		    Buffer buffer = view.getBuffer();
		    if (buffer.isLoaded())
			    mode.setText(buffer.getMode().toString());
	    }
	    
	    public void propertiesChanged()
	    {
	    }
	    
    } 

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.StringUtil,6,1,0,6,26,15,6,1,6,2.0,193,0.0,0,0.0,0.233333333,0,0,31.16666667,5,2.3333,0,"

package org.gjt.sp.jedit.bsh;

import java.util.*;

public class StringUtil {

	public static String [] split( String s, String delim) {
		Vector v = new Vector();
		StringTokenizer st = new StringTokenizer(s, delim);
		while ( st.hasMoreTokens() )
			v.addElement( st.nextToken() );
		String [] sa = new String [ v.size() ];
		v.copyInto( sa );
		return sa;
	}

	public static String [] bubbleSort( String [] in ) {
		Vector v = new Vector();
		for(int i=0; i<in.length; i++)
			v.addElement(in[i]);

		int n = v.size();
		boolean swap = true;
		while ( swap ) {
			swap = false;
			for(int i=0; i<(n-1); i++)
				if ( ((String)v.elementAt(i)).compareTo(
						((String)v.elementAt(i+1)) ) > 0 ) {
					String tmp = (String)v.elementAt(i+1);
					v.removeElementAt( i+1 );
					v.insertElementAt( tmp, i );
					swap = true;
				}
		}

		String [] out = new String [ n ];
		v.copyInto(out);
		return out;
	}


	public static String maxCommonPrefix( String one, String two ) {
		int i=0;
		while( one.regionMatches( 0, two, 0, i ) )
			i++;
		return one.substring(0, i-1);
	}

    public static String methodString(String name, Class[] types)
    {
    	StringBuilder sb = new StringBuilder(name + ""("");
        if ( types.length > 0 )
			sb.append("" "");
        for( int i=0; i<types.length; i++ )
        {
            Class c = types[i];
            sb.append( ( (c == null) ? ""null"" : c.getName() ) 
				+ ( i < (types.length-1) ? "", "" : "" "" ) );
        }
        sb.append("")"");
        return sb.toString();
    }

	

	
    public static String normalizeClassName( Class type )
	{
		return Reflect.normalizeClassName( type );
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ToolBarManager,5,1,0,2,17,4,1,1,3,0.5,133,1.0,0,0.0,0.433333333,0,0,24.8,3,2.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.util.*;
import java.util.List;

import org.gjt.sp.jedit.*;


public class ToolBarManager
{
	
	public ToolBarManager(Container top, Container bottom)
	{
		this.top = top;
		this.bottom = bottom;
	} 

	
	public void addToolBar(int group, int layer, Component toolbar)
	{
		Entry entry = new Entry(layer, toolbar);

		if (group == View.TOP_GROUP)
			addToolBar(top, topToolBars, entry);
		else if (group == View.BOTTOM_GROUP)
			addToolBar(bottom, bottomToolBars, entry);
		else
			throw new InternalError(""Invalid tool bar group"");
	} 

	
	public void removeToolBar(Component toolbar)
	{
		removeToolBar(top, topToolBars, toolbar);
		removeToolBar(bottom, bottomToolBars, toolbar);
	} 

	

	
	private Container top;
	private Container bottom;

	private List<Entry> topToolBars = new ArrayList<Entry>();
	private List<Entry> bottomToolBars = new ArrayList<Entry>();
	

	
	private static void addToolBar(Container group, List<Entry> toolbars,
		Entry entry)
	{
		
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(entry.layer > toolbars.get(i).layer)
			{
				toolbars.add(i,entry);
				group.add(entry.toolbar,i);
				return;
			}
		}

		
		toolbars.add(entry);
		group.add(entry.toolbar);
	} 

	
	private static void removeToolBar(Container group, List<Entry> toolbars,
		Component toolbar)
	{
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(toolbar == toolbars.get(i).toolbar)
			{
				group.remove(toolbar);
				toolbars.remove(i);

				return;
			}
		}
	} 

	

	
	private static class Entry
	{
		int layer;
		Component toolbar;

		Entry(int layer, Component toolbar)
		{
			this.layer = layer;
			this.toolbar = toolbar;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.EBPlugin,2,2,0,6,9,1,1,5,1,1.0,32,1.0,0,0.954545455,0.75,0,0,14.5,2,1.0,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.util.Log;


public abstract class EBPlugin extends EditPlugin implements EBComponent
{
	
	
	public void handleMessage(EBMessage message)
	{
		EditBus.removeFromBus(this);
		if(seenWarning)
			return;
		seenWarning = true;
		Log.log(Log.WARNING,this,getClassName() + "" should extend""
			+ "" EditPlugin not EBPlugin since it has an empty""
			+ "" handleMessage()"");
	}

	
	protected EBPlugin() {}

	
	private boolean seenWarning;
}
"
jEdit,4.3,org.gjt.sp.jedit.BeanShellFacade,16,1,2,17,39,74,4,13,7,0.85,360,1.0,3,0.0,0.266666667,0,0,21.25,3,1.0,0,"

package org.gjt.sp.jedit;


import java.lang.reflect.InvocationTargetException;
import org.gjt.sp.jedit.bsh.BshClassManager;
import org.gjt.sp.jedit.bsh.BshMethod;
import org.gjt.sp.jedit.bsh.CallStack;
import org.gjt.sp.jedit.bsh.Interpreter;
import org.gjt.sp.jedit.bsh.NameSpace;
import org.gjt.sp.jedit.bsh.Primitive;
import org.gjt.sp.jedit.bsh.TargetError;
import org.gjt.sp.jedit.bsh.UtilEvalError;
import org.gjt.sp.jedit.bsh.classpath.ClassManagerImpl;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.util.Log;



public abstract class BeanShellFacade<T>
{
	
	protected BeanShellFacade()
	{
		classManager = new ClassManagerImpl();
		global = new NameSpace(classManager,
			""jEdit embedded BeanShell interpreter"");

		interpForMethods = createInterpreter(global);
		init();
	} 

	
	
	protected void init()
	{
		global.importPackage(""org.gjt.sp.jedit"");
		global.importPackage(""org.gjt.sp.jedit.buffer"");
		global.importPackage(""org.gjt.sp.jedit.syntax"");
		global.importPackage(""org.gjt.sp.jedit.textarea"");
		global.importPackage(""org.gjt.sp.util"");
	} 

	
	
	public void evalSelection(T param, TextArea textArea)
	{
		String command = textArea.getSelectedText();
		if(command == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		Object returnValue = eval(param,global,command);
		if(returnValue != null)
			textArea.setSelectedText(returnValue.toString());
	} 

	
	
	public Object eval(T param, String command)
	{
		return eval(param, global, command);
	} 

	
	
	public Object eval(T param, NameSpace namespace, String command)
	{
		try
		{
			return _eval(param,namespace,command);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShellFacade.class,e);

			handleException(param,null,e);
		}

		return null;
	} 

	
	
	public Object _eval(T view, NameSpace namespace, String command)
		throws Exception
	{
		Interpreter interp = createInterpreter(namespace);

		try
		{
			setupDefaultVariables(namespace,view);
			if(Debug.BEANSHELL_DEBUG)
				Log.log(Log.DEBUG,BeanShellFacade.class,command);
			return interp.eval(command);
		}
		catch(Exception e)
		{
			unwrapException(e);
			
			return null;
		}
		finally
		{
			try
			{
				resetDefaultVariables(namespace);
			}
			catch(UtilEvalError e)
			{
				
			}
		}
	} 

	
	
	public BshMethod cacheBlock(String id, String code, boolean namespace)
		throws Exception
	{
		
		
		NameSpace local = new NameSpace(global, ""__internal_"" + id);
		
		
		String name = ""__runCachedMethod"";
		if(namespace)
		{
			_eval(null,local,name + ""(ns) {\nthis.callstack.set(0,ns);\n"" + code + ""\n}"");
			return local.getMethod(name,new Class[] { NameSpace.class });
		}
		else
		{
			_eval(null,local,name + ""() {\n"" + code + ""\n}"");
			return local.getMethod(name,new Class[0]);
		}
	} 

	
	
	public Object runCachedBlock(BshMethod method, T param,
		NameSpace namespace) throws Exception
	{
		boolean useNamespace;
		if(namespace == null)
		{
			useNamespace = false;
			namespace = global;
		}
		else
			useNamespace = true;

		try
		{
			setupDefaultVariables(namespace,param);

			Object retVal = method.invoke(useNamespace
				? new Object[] { namespace }
				: NO_ARGS,
				interpForMethods,new CallStack(), null);
			if(retVal instanceof Primitive)
			{
				if(retVal == Primitive.VOID)
					return null;
				else
					return ((Primitive)retVal).getValue();
			}
			else
				return retVal;
		}
		catch(Exception e)
		{
			unwrapException(e);
			
			return null;
		}
		finally
		{
			resetDefaultVariables(namespace);
		}
	} 

	
	
	public NameSpace getNameSpace()
	{
		return global;
	} 

	
	
	void resetClassManager()
	{
		classManager.reset();
	} 

	
	protected abstract void setupDefaultVariables(NameSpace namespace, T param)
		throws UtilEvalError;
	

	
	protected abstract void resetDefaultVariables(NameSpace namespace)
		throws UtilEvalError;
	

	
	protected abstract void handleException(T param, String path, Throwable t);
	

	
	protected static Interpreter createInterpreter(NameSpace nameSpace)
	{
		return new Interpreter(null,System.out,System.err,false,nameSpace);
	} 

	
	
	protected static void unwrapException(Exception e) throws Exception
	{
		if(e instanceof TargetError)
		{
			Throwable t = ((TargetError)e).getTarget();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}

		if(e instanceof InvocationTargetException)
		{
			Throwable t = ((InvocationTargetException)e).getTargetException();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}

		throw e;
	} 

	
	protected NameSpace global;
	protected BshClassManager classManager;
	private static Interpreter interpForMethods;
	private static final Object[] NO_ARGS = new Object[0];
	
}
"
jEdit,4.3,org.gjt.sp.jedit.MiscUtilities,70,1,0,77,187,2409,64,18,65,0.996376812,2017,0.0,1,0.0,0.05736715,0,0,27.7,21,3.1286,0,"

package org.gjt.sp.jedit;


import javax.swing.text.Segment;
import javax.swing.JMenuItem;
import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.MalformedInputException;
import java.text.DecimalFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.io.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.ProgressObserver;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.IOUtilities;

import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.jedit.menu.MenuItemTextComparator;
import org.gjt.sp.jedit.buffer.JEditBuffer;



public class MiscUtilities
{
	
	@Deprecated public static final String UTF_8_Y = ""UTF-8Y"";

	

	
	
	public static String canonPath(String path)
	{
		if(path.length() == 0)
			return path;

		if(path.startsWith(""file:
			path = path.substring(""file:
		else if(path.startsWith(""file:""))
			path = path.substring(""file:"".length());
		else if(isURL(path))
			return path;

		if(File.separatorChar == '\\')
		{
				
				path = path.replace('/','\\');
				
				int trim = path.length();
				while(path.charAt(trim - 1) == ' ')
					trim--;

				if (path.charAt(trim - 1) == '\\')
					while (trim > 1 && path.charAt(trim - 2) == '\\')
					{
						trim--;
					}
				path = path.substring(0,trim);
		}
		else if(OperatingSystem.isMacOS())
		{
			
			path = path.replace(':','/');
		}

		if(path.startsWith('~' + File.separator))
		{
			path = path.substring(2);
			String home = System.getProperty(""user.home"");

			if(home.endsWith(File.separator))
				return home + path;
			else
				return home + File.separator + path;
		}
		else if(""~"".equals(path))
			return System.getProperty(""user.home"");
		else if (""-"".equals(path))
			return getParentOfPath(jEdit.getActiveView().getBuffer().getPath());
		else
			return path;
	} 

	
	static final String varPatternString = ""(\\$([a-zA-Z0-9_]+))"";
	static final String varPatternString2 = ""(\\$\\{([^}]+)\\})"";
	static final Pattern varPattern = Pattern.compile(varPatternString);
	static final Pattern varPattern2 = Pattern.compile(varPatternString2);

	
	public static String expandVariables(String arg)
	{
		Pattern p = varPattern;
		Matcher m = p.matcher(arg);
		if (!m.find())
		{
			p = varPattern2;
			m = p.matcher(arg);
			if (!m.find()) 
				return arg;
		}
		String varName = m.group(2);
		String expansion = System.getenv(varName);
		if (expansion == null)
		{ 
			varName = varName.toUpperCase();
			String uparg = arg.toUpperCase();
			m = p.matcher(uparg);
			expansion = System.getenv(varName);
		}
		if (expansion != null)
		{
			expansion = expansion.replace(""\\"", ""\\\\"");
			return m.replaceFirst(expansion);
		}
		return arg;
	} 

	
	
	public static String abbreviate(String path)
	{
		if (svc == null)
			svc = new VarCompressor();
		return svc.compress(path);
	} 

	
	
	public static String resolveSymlinks(String path)
	{
		if(isURL(path))
			return path;

		
		if(OperatingSystem.isOS2())
			return path;
		
		
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 || path.length() == 3)
			{
				if(path.charAt(1) == ':')
					return path;
			}
		}
		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(IOException io)
		{
			return path;
		}
	} 

	
	
	public static boolean isAbsolutePath(String path)
	{
		if(isURL(path))
			return true;
		else if(path.startsWith(""~/"") || path.startsWith('~' + File.separator) || ""~"".equals(path))
			return true;
		else if (""-"".equals(path))
			return true;
		else if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return true;
			if(path.length() > 2 && path.charAt(1) == ':'
				&& (path.charAt(2) == '\\'
					|| path.charAt(2) == '/'))
				return true;
			if(path.startsWith(""\\\\"")
				|| path.startsWith(""
				return true;
		}
		
		else if(OperatingSystem.isUnix()
				|| OperatingSystem.isVMS())
		{
			
			if(path.length() > 0 && path.charAt(0) == '/')
				return true;
		}

		return false;
	} 

	
	
	public static String constructPath(String parent, String path)
	{
		if(isAbsolutePath(path))
			return canonPath(path);

		if (parent == null)
			parent = System.getProperty(""user.dir"");

		if (path == null || path.length() == 0)
			return parent;

		
		
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return path;
			else if(path.length() > 2 && path.charAt(1) == ':'
					&& path.charAt(2) != '\\')
			{
				path = path.substring(0,2) + '\\'
					+ path.substring(2);
				return canonPath(path);
			}
		}

		String dd = "".."" + File.separator;
		String d = '.' + File.separator;

		for(;;)
		{
			if(""."".equals(path))
				return parent;
			else if("".."".equals(path))
				return getParentOfPath(parent);
			else if(path.startsWith(dd) || path.startsWith(""../""))
			{
				parent = getParentOfPath(parent);
				path = path.substring(3);
			}
			else if(path.startsWith(d) || path.startsWith(""./""))
				path = path.substring(2);
			else
				break;
		}
		if(path.length() == 0)
			return parent;

		if(OperatingSystem.isDOSDerived()
			&& !isURL(parent)
		&& path.charAt(0) == '\\')
			parent = parent.substring(0,2);

		VFS vfs = VFSManager.getVFSForPath(parent);

		return canonPath(vfs.constructPath(parent,path));
	}

	
	public static String constructPath(String parent,
				    String path1, String path2)
	{
		return constructPath(constructPath(parent,path1),path2);
	} 

	
	
	public static String concatPath(String parent, String path)
	{
		parent = canonPath(parent);
		path = canonPath(path);

		
		if (path.startsWith(File.separator))
			path = path.substring(1);
		else if (path.length() >= 3 && path.charAt(1) == ':')
			path = path.replace(':', File.separatorChar);

		if (parent == null)
			parent = System.getProperty(""user.dir"");

		if (parent.endsWith(File.separator))
			return parent + path;
		else
			return parent + File.separator + path;
	} 

	
	
	public static int getFirstSeparatorIndex(String path)
	{
		int start = getPathStart(path);
		int index = path.indexOf('/',start);
		if(index == -1)
			index = path.indexOf(File.separatorChar,start);
		return index;
	} 

	
	
	public static int getLastSeparatorIndex(String path)
	{
		int start = getPathStart(path);
		if(start != 0)
			path = path.substring(start);
		int index = Math.max(
			path.lastIndexOf('/'), path.lastIndexOf(File.separatorChar));
		if(index == -1)
			return index;
		else
			return index + start;
	} 


	
	
	public static String getFileExtension(String path)
	{
		int fsIndex = getLastSeparatorIndex(path);
		int index = path.lastIndexOf('.');
		
		if(index == -1 || index < fsIndex )
			return """";
		else
			return path.substring(index);
	} 

	
	
	public static String getFileName(String path)
	{
		return VFSManager.getVFSForPath(path).getFileName(path);
	} 

	
	
	public static String getFileNameNoExtension(String path)
	{
		String name = getFileName(path);
		int index = name.indexOf('.');
		if(index == -1)
			return name;
		else
			return name.substring(0,index);
	} 

	
	
	@Deprecated
	public static String getFileParent(String path)
	{
		return getParentOfPath(path);
	} 

	
	
	public static String getParentOfPath(String path)
	{
		return VFSManager.getVFSForPath(path).getParentOfPath(path);
	} 

	
	
	@Deprecated
	public static String getFileProtocol(String url)
	{
		return getProtocolOfURL(url);
	} 

	
	
	public static String getProtocolOfURL(String url)
	{
		return url.substring(0,url.indexOf(':'));
	} 

	
	
	public static boolean isURL(String str)
	{
		int fsIndex = getLastSeparatorIndex(str);
		if(fsIndex == 0) 
			return false;
		else if(fsIndex == 2) 
			return false;

		int cIndex = str.indexOf(':');
		if(cIndex <= 1) 
			return false;

		String protocol = str.substring(0,cIndex);
		VFS vfs = VFSManager.getVFSForProtocol(protocol);
		if(vfs != null && !(vfs instanceof UrlVFS))
			return true;

		try
		{
			new URL(str);
			return true;
		}
		catch(MalformedURLException mf)
		{
			return false;
		}
	} 

	
	
	 public static void saveBackup(File file, int backups,
		 String backupPrefix, String backupSuffix,
		 String backupDirectory)
	{
		saveBackup(file,backups,backupPrefix,backupSuffix,backupDirectory,0);
	}

	
	public static void saveBackup(File file, int backups,
			       String backupPrefix, String backupSuffix,
			       String backupDirectory, int backupTimeDistance)
	{
		if(backupPrefix == null)
			backupPrefix = """";
		if(backupSuffix == null)
			backupSuffix = """";

		String name = file.getName();

		
		if(backups == 1)
		{
			File backupFile = new File(backupDirectory,
				backupPrefix + name + backupSuffix);
			long modTime = backupFile.lastModified();
			
			if(System.currentTimeMillis() - modTime
			   >= backupTimeDistance)
			{
				Log.log(Log.DEBUG,MiscUtilities.class,
					""Saving backup of file \"""" +
					file.getAbsolutePath() + ""\"" to \"""" +
					backupFile.getAbsolutePath() + '""');
				backupFile.delete();
				if (!file.renameTo(backupFile))
					IOUtilities.moveFile(file, backupFile);
			}
		}
		
		else
		{
			
			new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ backups + backupSuffix).delete();

			File firstBackup = new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ '1' + backupSuffix);
			long modTime = firstBackup.lastModified();
			
			if(System.currentTimeMillis() - modTime
			   >= backupTimeDistance)
			{
				for(int i = backups - 1; i > 0; i--)
				{
					File backup = new File(backupDirectory,
						backupPrefix + name
						+ backupSuffix + i
						+ backupSuffix);

					backup.renameTo(new File(backupDirectory,
						backupPrefix + name
						+ backupSuffix + (i + 1)
						+ backupSuffix));
				}

				File backupFile = new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ '1' + backupSuffix);
				Log.log(Log.DEBUG,MiscUtilities.class,
					""Saving backup of file \"""" +
					file.getAbsolutePath() + ""\"" to \"""" +
					backupFile.getAbsolutePath() + '""');
				if (!file.renameTo(backupFile))
					IOUtilities.moveFile(file, backupFile);
			}
		}
	} 

	
	
	@Deprecated
	public static boolean moveFile(File source, File dest)
	{
		return IOUtilities.moveFile(source, dest);
	} 

	
	
	@Deprecated
	public static boolean copyStream(int bufferSize, ProgressObserver progress,
		InputStream in, OutputStream out, boolean canStop)
		throws IOException
	{
		return IOUtilities.copyStream(bufferSize, progress, in, out, canStop);
	}

	
	@Deprecated
	public static boolean copyStream(ProgressObserver progress, InputStream in, OutputStream out, boolean canStop)
		throws IOException
	{
		return IOUtilities.copyStream(4096,progress, in, out, canStop);
	} 

	
	
	@Deprecated
	public static boolean isBinary(Reader reader) throws IOException
	{
		return containsNullCharacter(reader);
	}

	
	public static boolean isBinary(InputStream in) throws IOException
	{
		AutoDetection.Result detection = new AutoDetection.Result(in);
		
		if (detection.getDetectedEncoding() != null)
		{
			return false;
		}
		
		
		try
		{
			return containsNullCharacter(
				new InputStreamReader(detection.getRewindedStream()));
		}
		catch (MalformedInputException mie)
		{
			
			return true;
		}
	} 

	
	
	public static boolean isBackup(String filename)
	{
		if (filename.startsWith(""#"")) return true;
		if (filename.endsWith(""~"")) return true;
		if (filename.endsWith("".bak"")) return true;
		return false;
	} 


	
	
	public static Reader autodetect(InputStream in, Buffer buffer) throws IOException
	{
		String encoding;
		if (buffer == null)
			encoding = System.getProperty(""file.encoding"");
		else
			encoding = buffer.getStringProperty(JEditBuffer.ENCODING);
		boolean gzipped = false;

		if (buffer == null || buffer.getBooleanProperty(Buffer.ENCODING_AUTODETECT))
		{
			AutoDetection.Result detection = new AutoDetection.Result(in);
			gzipped = detection.streamIsGzipped();
			if (gzipped)
			{
				Log.log(Log.DEBUG, MiscUtilities.class
					, ""Stream is Gzipped"");
			}
			String detected = detection.getDetectedEncoding();
			if (detected != null)
			{
				encoding = detected;
				Log.log(Log.DEBUG, MiscUtilities.class
					, ""Stream encoding detected is "" + detected);
			}
			in = detection.getRewindedStream();
		}
		else
		{
			
			in = AutoDetection.getMarkedStream(in);
		}

		Reader result = EncodingServer.getTextReader(in, encoding);
		if (buffer != null)
		{
			
			if (gzipped)
			{
				buffer.setBooleanProperty(Buffer.GZIPPED,true);
			}
			buffer.setProperty(JEditBuffer.ENCODING, encoding);
		}
		return result;
	} 

	
	
	@Deprecated
	public static void closeQuietly(InputStream in)
	{
		IOUtilities.closeQuietly(in);
	} 

	
	
	@Deprecated
	public static void closeQuietly(OutputStream out)
	{
		IOUtilities.closeQuietly(out);
	} 

	
	
	public static String fileToClass(String name)
	{
		char[] clsName = name.toCharArray();
		for(int i = clsName.length - 6; i >= 0; i--)
			if(clsName[i] == '/')
				clsName[i] = '.';
		return new String(clsName,0,clsName.length - 6);
	} 

	
	
	public static String classToFile(String name)
	{
		return name.replace('.','/').concat("".class"");
	} 

	
	
	public static boolean pathsEqual(String p1, String p2)
	{
		VFS v1 = VFSManager.getVFSForPath(p1);
		VFS v2 = VFSManager.getVFSForPath(p2);

		if(v1 != v2)
			return false;

		if(p1.endsWith(""/"") || p1.endsWith(File.separator))
			p1 = p1.substring(0,p1.length() - 1);

		if(p2.endsWith(""/"") || p2.endsWith(File.separator))
			p2 = p2.substring(0,p2.length() - 1);

		if((v1.getCapabilities() & VFS.CASE_INSENSITIVE_CAP) != 0)
			return p1.equalsIgnoreCase(p2);
		else
			return p1.equals(p2);
	} 

	

	

	
	
	@Deprecated
	public static int getLeadingWhiteSpace(String str)
	{
		return StandardUtilities.getLeadingWhiteSpace(str);
	} 

	
	
	@Deprecated
	public static int getTrailingWhiteSpace(String str)
	{
		return StandardUtilities.getTrailingWhiteSpace(str);
	} 

	
	
	@Deprecated
	public static int getLeadingWhiteSpaceWidth(String str, int tabSize)
	{
		return StandardUtilities.getLeadingWhiteSpaceWidth(str, tabSize);
	} 

	
	
	@Deprecated
	public static int getVirtualWidth(Segment seg, int tabSize)
	{
		return StandardUtilities.getVirtualWidth(seg, tabSize);
	} 

	
	
	@Deprecated
	public static int getOffsetOfVirtualColumn(Segment seg, int tabSize,
					    int column, int[] totalVirtualWidth)
	{
		return StandardUtilities.getOffsetOfVirtualColumn(seg, tabSize, column, totalVirtualWidth);
	} 

	
	
	@Deprecated
	public static String createWhiteSpace(int len, int tabSize)
	{
		return StandardUtilities.createWhiteSpace(len,tabSize,0);
	}

	
	@Deprecated
	public static String createWhiteSpace(int len, int tabSize, int start)
	{
		return StandardUtilities.createWhiteSpace(len, tabSize, start);
	} 

	
	
	@Deprecated
	public static String globToRE(String glob)
	{
		return StandardUtilities.globToRE(glob);
	} 

	
	
	public static String escapesToChars(String str)
	{
		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\\':
				if(i == str.length() - 1)
				{
					buf.append('\\');
					break;
				}
				c = str.charAt(++i);
				switch(c)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(c);
					break;
				}
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	} 

	
	
	@Deprecated
	public static String charsToEscapes(String str)
	{
		return StandardUtilities.charsToEscapes(str);
	}

	
	@Deprecated
	public static String charsToEscapes(String str, String toEscape)
	{
		return StandardUtilities.charsToEscapes(str, toEscape);
	} 

	
	
	@Deprecated
	public static int compareVersions(String v1, String v2)
	{
		return StandardUtilities.compareStrings(v1,v2,false);
	} 

	
	
	@Deprecated
	public static int compareStrings(String str1, String str2, boolean ignoreCase)
	{
		return StandardUtilities.compareStrings(str1, str2, ignoreCase);
	} 

	
	
	@Deprecated
	public static boolean stringsEqual(String s1, String s2)
	{
		return StandardUtilities.objectsEqual(s1,s2);
	} 

	
	
	@Deprecated
	public static boolean objectsEqual(Object o1, Object o2)
	{
		return StandardUtilities.objectsEqual(o1, o2);
	} 

	
	
	@Deprecated
	public static String charsToEntities(String str)
	{
		return XMLUtilities.charsToEntities(str,false);
	} 

	
	public static final DecimalFormat KB_FORMAT = new DecimalFormat(""#.# kB"");
	public static final DecimalFormat MB_FORMAT = new DecimalFormat(""#.# MB"");

	
	public static String formatFileSize(long length)
	{
		if(length < 1024)
		{
			return length + "" Bytes"";
		}
		else if(length < 1024 << 10)
		{
			return KB_FORMAT.format((double)length / 1024);
		}
		else
		{
			return MB_FORMAT.format((double)length / 1024 / 1024);
		}
	} 

	
	
	public static String getLongestPrefix(List<String> str, boolean ignoreCase)
	{
		if(str.isEmpty())
			return """";

		int prefixLength = 0;

loop:		for(;;)
		{
			String s = str.get(0);
			if(prefixLength >= s.length())
				break loop;
			char ch = s.charAt(prefixLength);
			for(int i = 1; i < str.size(); i++)
			{
				s = str.get(i);
				if(prefixLength >= s.length())
					break loop;
				if(!compareChars(s.charAt(prefixLength),ch,ignoreCase))
					break loop;
			}
			prefixLength++;
		}

		return str.get(0).substring(0,prefixLength);
	}

	
	public static String getLongestPrefix(String[] str, boolean ignoreCase)
	{
		return getLongestPrefix((Object[])str,ignoreCase);
	}

	
	public static String getLongestPrefix(Object[] str, boolean ignoreCase)
	{
		if(str.length == 0)
			return """";

		int prefixLength = 0;

		String first = str[0].toString();

loop:		for(;;)
		{
			if(prefixLength >= first.length())
				break loop;
			char ch = first.charAt(prefixLength);
			for(int i = 1; i < str.length; i++)
			{
				String s = str[i].toString();
				if(prefixLength >= s.length())
					break loop;
				if(!compareChars(s.charAt(prefixLength),ch,ignoreCase))
					break loop;
			}
			prefixLength++;
		}

		return first.substring(0,prefixLength);
	} 

	

	
	
	@Deprecated
	public static void quicksort(Object[] obj, Comparator compare)
	{
		Arrays.sort(obj,compare);
	}


	
	@Deprecated
	public static void quicksort(Vector vector, Comparator compare)
	{
		Collections.sort(vector,compare);
	}

	
	@Deprecated
	public static void quicksort(List list, Comparator compare)
	{
		Collections.sort(list,compare);
	}

	
	@Deprecated
	public static void quicksort(Object[] obj, Compare compare)
	{
		Arrays.sort(obj,compare);
	}

	
	@Deprecated
	public static void quicksort(Vector vector, Compare compare)
	{
		Collections.sort(vector,compare);
	} 

	
	
	@Deprecated
	public interface Compare extends Comparator
	{
		int compare(Object obj1, Object obj2);
	} 

	
	
	@Deprecated
	public static class StringCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return StandardUtilities.compareStrings(obj1.toString(),
				obj2.toString(),false);
		}
	} 

	
	
	@Deprecated
	public static class StringICaseCompare implements Comparator<Object>
	{
		public int compare(Object obj1, Object obj2)
		{
			return StandardUtilities.compareStrings(obj1.toString(), obj2.toString(), true);
		}
	} 

	
	
	@Deprecated
	public static class MenuItemCompare implements Compare
	{
		private MenuItemTextComparator comparator = new MenuItemTextComparator();

		public int compare(Object obj1, Object obj2)
		{
			return comparator.compare((JMenuItem)obj1, (JMenuItem)obj2);
		}
	} 

	
	
	public static String buildToVersion(String build)
	{
		if(build.length() != 11)
			return ""<unknown version: "" + build + '>';
		
		int major = Integer.parseInt(build.substring(0,2));
		
		int minor = Integer.parseInt(build.substring(3,5));
		
		int beta = Integer.parseInt(build.substring(6,8));
		
		int bugfix = Integer.parseInt(build.substring(9,11));

		return major + ""."" + minor
			+ (beta != 99 ? ""rc"" + beta :
			(bugfix != 0 ? ""."" + bugfix : """"));
	} 

	
	
	public static boolean isToolsJarAvailable()
	{
		Log.log(Log.DEBUG, MiscUtilities.class,""Searching for tools.jar..."");

		Collection<String> paths = new LinkedList<String>();

		
		paths.add(""System classpath: ""
			+ System.getProperty(""java.class.path""));

		try
		{
			
			
			try
			{
				Class.forName(""sun.tools.javac.Main"");
			}
			catch(ClassNotFoundException e1)
			{
				Class.forName(""com.sun.tools.javac.Main"");
			}
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- is in classpath. Fine."");
			return true;
		}
		catch(ClassNotFoundException e)
		{
			
			
		} 

		
		String settingsDir = jEdit.getSettingsDirectory();
		if(settingsDir != null)
		{
			String toolsPath = constructPath(settingsDir, ""jars"",
				""tools.jar"");
			paths.add(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in the user's jars folder. Fine."");
				
				return true;
			}
		} 

		
		String jEditDir = jEdit.getJEditHome();
		if(jEditDir != null)
		{
			String toolsPath = constructPath(jEditDir, ""jars"", ""tools.jar"");
			paths.add(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in jEdit's system jars folder. Fine."");
				
				return true;
			}
		} 

		
		String toolsPath = System.getProperty(""java.home"");
		if(toolsPath.toLowerCase().endsWith(File.separator + ""jre""))
			toolsPath = toolsPath.substring(0, toolsPath.length() - 4);
		toolsPath = constructPath(toolsPath, ""lib"", ""tools.jar"");
		paths.add(toolsPath);

		if(!new File(toolsPath).exists())
		{
			Log.log(Log.WARNING, MiscUtilities.class,
				""Could not find tools.jar.\n""
				+ ""I checked the following locations:\n""
				+ paths.toString());
			return false;
		} 

		
		PluginJAR jar = jEdit.getPluginJAR(toolsPath);
		if(jar == null)
		{
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- adding "" + toolsPath + "" to jEdit plugins."");
			jEdit.addPluginJAR(toolsPath);
		}
		else
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- has been loaded before."");
		

		return true;
	} 

	
	
	public static int parsePermissions(String s)
	{
		int permissions = 0;

		if(s.length() == 9)
		{
			if(s.charAt(0) == 'r')
				permissions += 0400;
			if(s.charAt(1) == 'w')
				permissions += 0200;
			if(s.charAt(2) == 'x')
				permissions += 0100;
			else if(s.charAt(2) == 's')
				permissions += 04100;
			else if(s.charAt(2) == 'S')
				permissions += 04000;
			if(s.charAt(3) == 'r')
				permissions += 040;
			if(s.charAt(4) == 'w')
				permissions += 020;
			if(s.charAt(5) == 'x')
				permissions += 010;
			else if(s.charAt(5) == 's')
				permissions += 02010;
			else if(s.charAt(5) == 'S')
				permissions += 02000;
			if(s.charAt(6) == 'r')
				permissions += 04;
			if(s.charAt(7) == 'w')
				permissions += 02;
			if(s.charAt(8) == 'x')
				permissions += 01;
			else if(s.charAt(8) == 't')
				permissions += 01001;
			else if(s.charAt(8) == 'T')
				permissions += 01000;
		}

		return permissions;
	} 

	
	
	@Deprecated
	public static String[] getEncodings()
	{
		return getEncodings(false);
	}

	
	public static String[] getEncodings(boolean getSelected)
	{
		Set<String> set;
		if (getSelected)
		{
			set = EncodingServer.getSelectedNames();
		}
		else
		{
			set = EncodingServer.getAvailableNames();
		}
		return set.toArray(new String[set.size()]);
	} 

	
	
	public static String throwableToString(Throwable t)
	{
		StringWriter s = new StringWriter();
		t.printStackTrace(new PrintWriter(s));
		return s.toString();
	} 

	
	
	@Deprecated
	public static boolean parseXML(InputStream in, DefaultHandler handler)
		throws IOException
	{
		return XMLUtilities.parseXML(in, handler);
	} 

	
	
	@Deprecated
	public static InputSource findEntity(String systemId, String test, Class where)
	{
		return XMLUtilities.findEntity(systemId, test, where);
	} 

	
	private MiscUtilities() {}

	
	
	private static boolean compareChars(char ch1, char ch2, boolean ignoreCase)
	{
		if(ignoreCase)
			return Character.toUpperCase(ch1) == Character.toUpperCase(ch2);
		else
			return ch1 == ch2;
	} 

	
	private static int getPathStart(String path)
	{
		if(path.startsWith(""/""))
			return 0;
		else if(OperatingSystem.isDOSDerived()
			&& path.length() >= 3
			&& path.charAt(1) == ':'
			&& (path.charAt(2) == '/'
			|| path.charAt(2) == '\\'))
			return 3;
		else
			return 0;
	} 

	
	private static boolean containsNullCharacter(Reader reader)
		throws IOException
	{
		int nbChars = jEdit.getIntegerProperty(""vfs.binaryCheck.length"",100);
		int authorized = jEdit.getIntegerProperty(""vfs.binaryCheck.count"",1);
		for (long i = 0L;i < nbChars;i++)
		{
			int c = reader.read();
			if (c == -1)
				return false;
			if (c == 0)
			{
				authorized--;
				if (authorized == 0)
					return true;
			}
		}
		return false;
	} 

	

	static VarCompressor svc = null;

	
	
	static class VarCompressor
	{
		
		final Map<String, String> prefixMap = new HashMap<String, String>();
		
		final Map<String, String> previous = new HashMap<String, String>();

		
		VarCompressor()
		{
			ProcessBuilder pb = new ProcessBuilder();
			Map<String, String> env = pb.environment();
			if (OperatingSystem.isUnix())
				prefixMap.put(System.getProperty(""user.home""), ""~"");
			for (String k: env.keySet())
			{
				if (k.equalsIgnoreCase(""pwd"") || k.equalsIgnoreCase(""oldpwd"")) continue;
				if (!Character.isLetter(k.charAt(0))) continue;
				String v = env.get(k);
				
				if (!canBePathPrefix(v)) continue;
				
				if (v.endsWith(File.separator))
					v = v.substring(0, v.length()-1);
				
				if (OperatingSystem.isWindows())
					if (k.length()+2 > v.length()) continue; 
				else
					if (k.length()+1 > v.length()) continue; 
				if (OperatingSystem.isWindows())
				{
					
					v = v.toLowerCase();
					k = k.toLowerCase();
				}
				if (prefixMap.containsKey(v))
				{
					String otherKey = prefixMap.get(v);
					if (otherKey.length() < k.length()) continue;
				}
				prefixMap.put(v, k);
			}
		} 

		
		String compress(String path)
		{
			String original = path;
			if (previous.containsKey(path))
			{
				return previous.get(path);
			}
			String bestPrefix = ""/"";
			String verifiedPrefix = bestPrefix;
			for (String tryPrefix : prefixMap.keySet())
			{
				if (tryPrefix.length() < bestPrefix.length()) continue;
				if (OperatingSystem.isWindows() &&
				    path.toLowerCase().startsWith(tryPrefix))
					bestPrefix = tryPrefix;
				else if (path.startsWith(tryPrefix))
				{
					bestPrefix = tryPrefix;
				}
				
				if (!bestPrefix.equals(verifiedPrefix))
				{
					String remainder = original.substring(bestPrefix.length());
					if (remainder.length() < 1 || remainder.startsWith(File.separator))
						verifiedPrefix = bestPrefix;
					else bestPrefix = verifiedPrefix;
				}
			}
			if (bestPrefix.length() > 1)
			{
				String remainder = original.substring(bestPrefix.length());
				String envvar = prefixMap.get(bestPrefix);
				if (envvar.equals(""~""))
					path = envvar + remainder;
				else if (OperatingSystem.isWindows())
					path = '%' + envvar.toUpperCase() + '%' + remainder;
				else
					path = '$' + envvar + remainder;
			}
			previous.put(original, path);
			return path;
		} 

		
		
		
		private boolean canBePathPrefix(String s)
		{
			
			
			
			return !s.contains(File.pathSeparator)
				&& new File(s).isAbsolute();
		} 
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.MarkerViewer,12,5,0,16,73,6,2,16,6,0.618181818,445,1.0,4,0.983433735,0.25,1,7,35.66666667,11,2.5,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.msg.EditPaneUpdate;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.util.Log;


public class MarkerViewer extends JPanel implements EBComponent, ActionListener
{
	
	public MarkerViewer(View view)
	{
		super(new BorderLayout());
		this.view = view;
		Box toolBar = new Box(BoxLayout.X_AXIS);

		toolBar.add(new JLabel(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""markers.label""))));

		toolBar.add(Box.createGlue());

		RolloverButton addMarker = new RolloverButton(
			GUIUtilities.loadIcon(""Plus.png""));
		addMarker.setToolTipText(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""add-marker.label"")));
		addMarker.addActionListener(this);
		addMarker.setActionCommand(""add-marker"");
		toolBar.add(addMarker);

		previous = new RolloverButton(GUIUtilities.loadIcon(""ArrowL.png""));
		previous.setToolTipText(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""prev-marker.label"")));
		previous.addActionListener(this);
		previous.setActionCommand(""prev-marker"");
		toolBar.add(previous);

		next = new RolloverButton(GUIUtilities.loadIcon(""ArrowR.png""));
		next.setToolTipText(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""next-marker.label"")));
		next.addActionListener(this);
		next.setActionCommand(""next-marker"");
		toolBar.add(next);

		clear = new RolloverButton(GUIUtilities.loadIcon(""Clear.png""));
		clear.setToolTipText(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""remove-all-markers.label"")));
		clear.addActionListener(this);
		clear.setActionCommand(""clear"");
		toolBar.add(clear);


		add(BorderLayout.NORTH, toolBar);

		markerList = new JList();
		markerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		markerList.setCellRenderer(new Renderer());
		markerList.addMouseListener(new MouseHandler());

		add(BorderLayout.CENTER,new JScrollPane(markerList));

		refreshList();
	} 

	
	public boolean requestDefaultFocus()
	{
		markerList.requestFocus();
		return true;
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		String cmd = evt.getActionCommand();
		if (cmd.equals(""clear""))
			view.getBuffer().removeAllMarkers();
		else if (cmd.equals(""add-marker""))
			view.getEditPane().addMarker();
		else if (cmd.equals(""next-marker""))
		{
			view.getEditPane().goToNextMarker(false);
			updateSelection();
		}
		else if (cmd.equals(""prev-marker""))
		{
			view.getEditPane().goToPrevMarker(false);
			updateSelection();
		}
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if (msg instanceof EditPaneUpdate)
		{
			EditPaneUpdate epu = (EditPaneUpdate)msg;
			if (epu.getEditPane().getView().equals(view) &&
				epu.getWhat().equals(EditPaneUpdate.BUFFER_CHANGED))
				refreshList();
		}
		if (msg instanceof ViewUpdate)
		{
			ViewUpdate vu = (ViewUpdate)msg;
			if (vu.getView().equals(view) &&
				vu.getWhat().equals(ViewUpdate.EDIT_PANE_CHANGED))
				refreshList();
		}
		if (msg instanceof BufferUpdate)
		{
			BufferUpdate bu = (BufferUpdate)msg;
			if (view.getBuffer().equals(bu.getBuffer())
				&&
				(bu.getWhat().equals(BufferUpdate.MARKERS_CHANGED) || bu.getWhat().equals(BufferUpdate.LOADED)))
				refreshList();
		}
	}

	
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	} 

	

	
	private JList markerList;
	private View view;
	private RolloverButton previous;
	private RolloverButton next;
	private RolloverButton clear;
	

	
	private void refreshList()
	{
		java.util.Vector markers = view.getBuffer().getMarkers();
		if (markers.size() > 0)
		{
			markerList.setListData(markers);
			markerList.setEnabled(true);
			next.setEnabled(true);
			previous.setEnabled(true);
			clear.setEnabled(true);
		}
		else
		{
			markerList.setListData(new Object[] {
				jEdit.getProperty(""no-markers.label"") });
			markerList.setEnabled(false);
			next.setEnabled(false);
			previous.setEnabled(false);
			clear.setEnabled(false);
		}

	} 

	
	private void goToSelectedMarker()
	{
		Object value = markerList.getSelectedValue();
		if(!(value instanceof Marker))
			return;

		Marker mark = (Marker)value;
		view.getTextArea().setCaretPosition(mark.getPosition());
		view.toFront();
		view.requestFocus();
		view.getTextArea().requestFocus();
	} 

	
	private void updateSelection()
	{
		ListModel model = markerList.getModel();
		int currentLine = view.getTextArea().getCaretLine();
		Buffer buffer = view.getBuffer();
		for (int i = 0; i < model.getSize(); i++)
		{
			Object o = model.getElementAt(i);
			if (o instanceof Marker)
			{
				Marker mark = (Marker)model.getElementAt(i);
				if (buffer.getLineOfOffset(mark.getPosition()) == currentLine)
				{
					markerList.setSelectedIndex(i);
					break;
				}
			}
		}

	} 

	

	

	
	class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,
			index,isSelected,cellHasFocus);

			if(value instanceof Marker)
			{
				Marker mark = (Marker)value;
				JEditTextArea textArea = view.getTextArea();
				int pos = textArea.getLineOfOffset(mark.getPosition());
				String txt = view.getTextArea().getLineText(pos);
				if (txt.equals(""""))
					txt = jEdit.getProperty(""markers.blank-line"");
				char shortcut_char = mark.getShortcut();
				String shortcut = """";
				if (shortcut_char > 0)
					shortcut = ""[""+shortcut_char+""]"";
				setText((pos+1)+"" ""+shortcut+"": ""+txt);
			}
			return this;
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mousePressed(MouseEvent evt)
		{
			if(evt.isConsumed())
				return;

			int index = markerList.locationToIndex(evt.getPoint());
			markerList.setSelectedIndex(index);

			goToSelectedMarker();
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHForStatement,2,2,0,12,10,1,1,11,1,1.125,136,0.625,4,0.944444444,0.625,1,1,63.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;


class BSHForStatement extends SimpleNode implements ParserConstants
{
    public boolean hasForInit;
    public boolean hasExpression;
    public boolean hasForUpdate;

    private SimpleNode forInit;
    private SimpleNode expression;
    private SimpleNode forUpdate;
    private SimpleNode statement;

    private boolean parsed;

    BSHForStatement(int id) { super(id); }

    public Object eval(CallStack callstack , Interpreter interpreter)  
		throws EvalError
    {
        int i = 0;
        if(hasForInit)
            forInit = ((SimpleNode)jjtGetChild(i++));
        if(hasExpression)
            expression = ((SimpleNode)jjtGetChild(i++));
        if(hasForUpdate)
            forUpdate = ((SimpleNode)jjtGetChild(i++));
        if(i < jjtGetNumChildren()) 
            statement = ((SimpleNode)jjtGetChild(i));

		NameSpace enclosingNameSpace= callstack.top();
		BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );

		

		
		
		
		callstack.swap( forNameSpace );

        
        if ( hasForInit ) 
            forInit.eval( callstack, interpreter );

		Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( hasExpression ) 
			{
				boolean cond = BSHIfStatement.evaluateCondition(
					expression, callstack, interpreter );

				if ( !cond ) 
					break;
			}

            boolean breakout = false; 
            if ( statement != null ) 
            {
				
                Object ret = statement.eval( callstack, interpreter );

                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case RETURN:
							returnControl = ret;
							breakout = true;
                            break;

                        case CONTINUE:
                            break;

                        case BREAK:
                            breakout = true;
                            break;
                    }
                }
            }

            if ( breakout )
                break;

            if ( hasForUpdate )
                forUpdate.eval( callstack, interpreter );
        }

		callstack.swap( enclosingNameSpace );  
        return returnControl;
    }

}
"
jEdit,4.3,org.gjt.sp.jedit.Debug,2,1,0,27,4,1,26,1,1,1.0,72,0.0,0,0.0,1.0,0,0,24.0,0,0.0,0,"

package org.gjt.sp.jedit;


public class Debug
{
	
	public static boolean OFFSET_DEBUG = false;

	
	public static boolean SCROLL_DEBUG = false;

	
	public static boolean SCROLL_TO_DEBUG = false;

	
	public static boolean SCROLL_VERIFY = false;

	
	public static boolean SCREEN_LINES_DEBUG = false;

	
	public static boolean TOKEN_MARKER_DEBUG = false;

	
	public static boolean FOLD_DEBUG = false;

	
	public static boolean FOLD_VIS_DEBUG = false;

	
	public static boolean CHUNK_CACHE_DEBUG = false;

	
	public static boolean CHUNK_PAINT_DEBUG = false;

	
	public static boolean PAINT_TIMER = false;

	
	public static boolean EB_TIMER = false;

	
	public static boolean DISABLE_GLYPH_VECTOR = false;

	
	public static boolean BEANSHELL_DEBUG = false;

	
	public static boolean ALTERNATIVE_DISPATCHER = OperatingSystem.isMacOS();

	
	public static boolean ALT_KEY_PRESSED_DISABLED = OperatingSystem.isMacOS();

	
	public static boolean GEOMETRY_WORKAROUND = false;

	
	public static boolean DUMP_KEY_EVENTS = false;

	
	public static boolean INDENT_DEBUG = false;

	
	public static boolean PRINT_DEBUG = false;

	
	public static boolean DISABLE_SEARCH_DIALOG_POOL = false;

	
	public static boolean DISABLE_MULTIHEAD = false;
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.MouseActionsProvider,1,1,0,4,1,0,4,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit.textarea;

import java.awt.event.MouseEvent;


public interface MouseActionsProvider
{
	String getActionForEvent(MouseEvent evt, String variant);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.JavaCharStream,31,1,0,3,44,139,3,0,25,0.470588235,1283,0.705882353,0,0.0,0.301075269,0,0,39.83870968,7,1.4516,0,"
package org.gjt.sp.jedit.bsh;



public class JavaCharStream
{
  public static final boolean staticFlag = false;
  static final int hexval(char c) throws java.io.IOException {
    switch(c)
    {
       case '0' :
          return 0;
       case '1' :
          return 1;
       case '2' :
          return 2;
       case '3' :
          return 3;
       case '4' :
          return 4;
       case '5' :
          return 5;
       case '6' :
          return 6;
       case '7' :
          return 7;
       case '8' :
          return 8;
       case '9' :
          return 9;

       case 'a' :
       case 'A' :
          return 10;
       case 'b' :
       case 'B' :
          return 11;
       case 'c' :
       case 'C' :
          return 12;
       case 'd' :
       case 'D' :
          return 13;
       case 'e' :
       case 'E' :
          return 14;
       case 'f' :
       case 'F' :
          return 15;
    }

    throw new java.io.IOException(); 
  }

  public int bufpos = -1;
  int bufsize;
  int available;
  int tokenBegin;
  protected int bufline[];
  protected int bufcolumn[];

  protected int column = 0;
  protected int line = 1;

  protected boolean prevCharIsCR = false;
  protected boolean prevCharIsLF = false;

  protected java.io.Reader inputStream;

  protected char[] nextCharBuf;
  protected char[] buffer;
  protected int maxNextCharInd = 0;
  protected int nextCharInd = -1;
  protected int inBuf = 0;

  protected void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];

     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           bufpos += (bufsize - tokenBegin);
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;

           bufpos -= tokenBegin;
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }

     available = (bufsize += 2048);
     tokenBegin = 0;
  }

  protected void FillBuff() throws java.io.IOException
  {
     int i;
     if (maxNextCharInd == 4096)
        maxNextCharInd = nextCharInd = 0;

     try {
        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
                                            4096 - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        if (bufpos != 0)
        {
           --bufpos;
           backup(0);
        }
        else
        {
           bufline[bufpos] = line;
           bufcolumn[bufpos] = column;
        }
        throw e;
     }
  }

  protected char ReadByte() throws java.io.IOException
  {
     if (++nextCharInd >= maxNextCharInd)
        FillBuff();

     return nextCharBuf[nextCharInd];
  }

  public char BeginToken() throws java.io.IOException
  {     
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        tokenBegin = bufpos;
        return buffer[bufpos];
     }

     tokenBegin = 0;
     bufpos = -1;

     return readChar();
  }     

  protected void AdjustBuffSize()
  {
     if (available == bufsize)
     {
        if (tokenBegin > 2048)
        {
           bufpos = 0;
           available = tokenBegin;
        }
        else
           ExpandBuff(false);
     }
     else if (available > tokenBegin)
        available = bufsize;
     else if ((tokenBegin - available) < 2048)
        ExpandBuff(true);
     else
        available = tokenBegin;
  }

  protected void UpdateLineColumn(char c)
  {
     column++;

     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }

     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (8 - (column & 07));
           break;
        default :
           break;
     }

     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }

  public char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        return buffer[bufpos];
     }

     char c;

     if (++bufpos == available)
        AdjustBuffSize();

     if ((buffer[bufpos] = c = ReadByte()) == '\\')
     {
        UpdateLineColumn(c);

        int backSlashCnt = 1;

        for (;;) 
        {
           if (++bufpos == available)
              AdjustBuffSize();

           try
           {
              if ((buffer[bufpos] = c = ReadByte()) != '\\')
              {
                 UpdateLineColumn(c);
                 
                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
                 {
                    if (--bufpos < 0)
                       bufpos = bufsize - 1;

                    break;
                 }

                 backup(backSlashCnt);
                 return '\\';
              }
           }
           catch(java.io.IOException e)
           {
              if (backSlashCnt > 1)
                 backup(backSlashCnt);

              return '\\';
           }

           UpdateLineColumn(c);
           backSlashCnt++;
        }

        
        try
        {
           while ((c = ReadByte()) == 'u')
              ++column;

           buffer[bufpos] = c = (char)(hexval(c) << 12 |
                                       hexval(ReadByte()) << 8 |
                                       hexval(ReadByte()) << 4 |
                                       hexval(ReadByte()));

           column += 4;
        }
        catch(java.io.IOException e)
        {
           throw new Error(""Invalid escape character at line "" + line +
                                         "" column "" + column + ""."");
        }

        if (backSlashCnt == 1)
           return c;
        else
        {
           backup(backSlashCnt - 1);
           return '\\';
        }
     }
     else
     {
        UpdateLineColumn(c);
        return (c);
     }
  }

  

  public int getColumn() {
     return bufcolumn[bufpos];
  }

  

  public int getLine() {
     return bufline[bufpos];
  }

  public int getEndColumn() {
     return bufcolumn[bufpos];
  }

  public int getEndLine() {
     return bufline[bufpos];
  }

  public int getBeginColumn() {
     return bufcolumn[tokenBegin];
  }

  public int getBeginLine() {
     return bufline[tokenBegin];
  }

  public void backup(int amount) {

    inBuf += amount;
    if ((bufpos -= amount) < 0)
       bufpos += bufsize;
  }

  public JavaCharStream(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
    nextCharBuf = new char[4096];
  }

  public JavaCharStream(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.Reader dstream)
  {
     this(dstream, 1, 1, 4096);
  }
  public void ReInit(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
      nextCharBuf = new char[4096];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    nextCharInd = bufpos = -1;
  }

  public void ReInit(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }

  public void ReInit(java.io.Reader dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }
  public JavaCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.InputStream dstream)
  {
     this(dstream, 1, 1, 4096);
  }

  public void ReInit(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }

  public String GetImage()
  {
     if (bufpos >= tokenBegin)
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
     else
        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                              new String(buffer, 0, bufpos + 1);
  }

  public char[] GetSuffix(int len)
  {
     char[] ret = new char[len];

     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
     }

     return ret;
  }

  public void Done()
  {
     nextCharBuf = null;
     buffer = null;
     bufline = null;
     bufcolumn = null;
  }

  
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;

     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }

     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;

     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 

     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;

        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }

     line = bufline[j];
     column = bufcolumn[j];
  }

}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextArea,262,4,3,81,540,19801,54,49,218,0.935644157,9460,0.625,12,0.713024283,0.06248158,3,18,34.86259542,29,3.458,0,"
package org.gjt.sp.jedit.textarea;



import java.util.EventObject;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TooManyListenersException;

import javax.swing.*;
import javax.swing.event.*;
import java.awt.event.*;
import java.awt.*;
import java.awt.im.InputMethodRequests;

import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.text.Segment;

import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.IPropertyManager;
import org.gjt.sp.jedit.JEditActionContext;
import org.gjt.sp.jedit.JEditActionSet;
import org.gjt.sp.jedit.JEditBeanShellAction;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.jedit.input.DefaultInputHandlerProvider;
import org.gjt.sp.jedit.input.InputHandlerProvider;
import org.gjt.sp.jedit.input.TextAreaInputHandler;
import org.gjt.sp.jedit.syntax.Chunk;
import org.gjt.sp.jedit.syntax.DefaultTokenHandler;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;


public abstract class TextArea extends JComponent
{
	
	
	protected TextArea(IPropertyManager propertyManager, InputHandlerProvider inputHandlerProvider)
	{
		this.inputHandlerProvider = inputHandlerProvider;
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);

		
		selectionManager = new SelectionManager(this);
		chunkCache = new ChunkCache(this);
		painter = new TextAreaPainter(this);
		gutter = new Gutter(this);
		gutter.setMouseActionsProvider(new MouseActions(propertyManager, ""gutter""));
		listenerList = new EventListenerList();
		caretEvent = new MutableCaretEvent();
		blink = true;
		offsetXY = new Point();
		structureMatchers = new LinkedList<StructureMatcher>();
		structureMatchers.add(new StructureMatcher.BracketMatcher());
		

		
		setLayout(new ScrollLayout());
		add(ScrollLayout.CENTER,painter);
		add(ScrollLayout.LEFT,gutter);

		
		verticalBox = new Box(BoxLayout.X_AXIS);
		verticalBox.add(vertical = new JScrollBar(Adjustable.VERTICAL));
		vertical.setRequestFocusEnabled(false);
		add(ScrollLayout.RIGHT,verticalBox);
		add(ScrollLayout.BOTTOM,
			horizontal = new JScrollBar(Adjustable.HORIZONTAL));
		horizontal.setRequestFocusEnabled(false);

		horizontal.setValues(0,0,0,0);
		

		
		
		
		
		
		if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
		{
			setBorder(new TextAreaBorder());
			vertical.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			horizontal.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			
		}
		

		
		vertical.addAdjustmentListener(new AdjustHandler());
		horizontal.addAdjustmentListener(new AdjustHandler());


		addFocusListener(new FocusHandler());
		addMouseWheelListener(new MouseWheelHandler());

		

		
		
		
		focusedComponent = this;

		popupEnabled = true;
	} 

	
	public FoldPainter getFoldPainter()
	{
		return new TriangleFoldPainter();
	} 

	
	
	public void initInputHandler()
	{
		actionContext = new JEditActionContext<JEditBeanShellAction, JEditActionSet<JEditBeanShellAction>>()
		{
			@Override
			public void invokeAction(EventObject evt, JEditBeanShellAction action)
			{
				action.invoke(TextArea.this);
			}
		};

		setMouseHandler(new TextAreaMouseHandler(this));
		inputHandlerProvider = new DefaultInputHandlerProvider(new TextAreaInputHandler(this)
		{
			@Override
			protected JEditBeanShellAction getAction(String action)
			{
				return actionContext.getAction(action);
			}
		});
	} 

	
	public JEditActionContext<JEditBeanShellAction,JEditActionSet<JEditBeanShellAction>> getActionContext()
	{
		return actionContext;
	} 

	
	public void setMouseHandler(MouseInputAdapter mouseInputAdapter)
	{
		mouseHandler = mouseInputAdapter;
		painter.addMouseListener(mouseHandler);
		painter.addMouseMotionListener(mouseHandler);
	} 

	
	@Override
	public void setTransferHandler(TransferHandler newHandler)
	{
		super.setTransferHandler(newHandler);
		try
		{
			getDropTarget().addDropTargetListener(
				new TextAreaDropHandler(this));
		}
		catch(TooManyListenersException e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} 

	
	@Override
	public String toString()
	{
		StringBuilder builder = new StringBuilder();
		String baseVersion = super.toString();
		int len = baseVersion.length() - 1;
		builder.append(baseVersion);
		builder.setLength(len); 
		builder.append("",caret="").append(caret);
		builder.append("",caretLine="").append(caretLine);
		builder.append("",caretScreenLine="").append(caretScreenLine);
		builder.append("",electricScroll="").append(electricScroll);
		builder.append("",horizontalOffset="").append(horizontalOffset);
		builder.append("",magicCaret="").append(magicCaret);
		builder.append("",offsetXY="").append(offsetXY.toString());
		builder.append("",oldCaretLine="").append(oldCaretLine);
		builder.append("",screenLastLine="").append(screenLastLine);
		builder.append("",visibleLines="").append(visibleLines);
		builder.append("",firstPhysicalLine="").append(getFirstPhysicalLine());
		builder.append("",physLastLine="").append(physLastLine).append(""]"");
		return builder.toString();
	} 

	
	
	public void dispose()
	{
		DisplayManager.textAreaDisposed(this);
		gutter.dispose();
	} 

	
	
	public AbstractInputHandler getInputHandler()
	{

		return inputHandlerProvider.getInputHandler();
	} 

	
	
	public final TextAreaPainter getPainter()
	{
		return painter;
	} 

	
	
	public final Gutter getGutter()
	{
		return gutter;
	} 

	
	
	public DisplayManager getDisplayManager()
	{
		return displayManager;
	} 

	
	
	public final boolean isCaretBlinkEnabled()
	{
		return caretBlinks;
	} 

	
	
	public void setCaretBlinkEnabled(boolean caretBlinks)
	{
		this.caretBlinks = caretBlinks;
		if(!caretBlinks)
			blink = false;

		if(buffer != null)
			invalidateLine(caretLine);
	} 

	

	
	public final int getElectricScroll()
	{
		return electricScroll;
	} 

	
	
	public final void setElectricScroll(int electricScroll)
	{
		this.electricScroll = electricScroll;
	} 

	
	
	public final boolean isQuickCopyEnabled()
	{
		return quickCopy;
	} 

	
	
	public final void setQuickCopyEnabled(boolean quickCopy)
	{
		this.quickCopy = quickCopy;
	} 

	
	
	public final JEditBuffer getBuffer()
	{
		return buffer;
	} 

	
	
	public void setBuffer(JEditBuffer buffer)
	{
		if(this.buffer == buffer)
			return;

		try
		{
			bufferChanging = true;

			if(this.buffer != null)
			{
				
				

				if(!this.buffer.isLoading())
					selectNone();
				caretLine = caret = caretScreenLine = 0;
				match = null;
			}
			boolean inCompoundEdit = false;
			if (this.buffer != null)
				inCompoundEdit = this.buffer.insideCompoundEdit();
			if (inCompoundEdit)
				this.buffer.endCompoundEdit();
			this.buffer = buffer;
			if (inCompoundEdit)
				this.buffer.beginCompoundEdit();

			chunkCache.setBuffer(buffer);
			gutter.setBuffer(buffer);
			propertiesChanged();

			if(displayManager != null)
			{
				displayManager.release();
			}

			displayManager = DisplayManager.getDisplayManager(
				buffer,this);

			displayManager.init();

			if(buffer.isLoading())
				updateScrollBar();

			repaint();

			fireScrollEvent(true);
		}
		finally
		{
			bufferChanging = false;
		}
	} 

	
	
	public final boolean isEditable()
	{
		return buffer.isEditable();
	} 

	
	
	@Deprecated
	public boolean isDragInProgress()
	{
		return dndInProgress;
	} 

	
	
	@Deprecated
	public void setDragInProgress(boolean dndInProgress)
	{
		this.dndInProgress = dndInProgress;
	} 

	
	
	public boolean isDragEnabled()
	{
		return dndEnabled;
	} 

	
	
	public void setDragEnabled(boolean dndEnabled)
	{
		this.dndEnabled = dndEnabled;
	} 

	
	
	public boolean getJoinNonWordChars()
	{
		return joinNonWordChars;
	} 

	
	
	public void setJoinNonWordChars(boolean joinNonWordChars)
	{
		this.joinNonWordChars = joinNonWordChars;
	} 

	
	
	public boolean isCtrlForRectangularSelection()
	{
		return ctrlForRectangularSelection;
	} 

	
	
	public void setCtrlForRectangularSelection(boolean ctrlForRectangularSelection)
	{
		this.ctrlForRectangularSelection = ctrlForRectangularSelection;
	} 

	

	
	
	public final int getFirstLine()
	{
		return displayManager.firstLine.scrollLine
			+ displayManager.firstLine.skew;
	} 

	
	
	public void setFirstLine(int firstLine)
	{
		
		int max = displayManager.getScrollLineCount() - visibleLines
			+ (lastLinePartial ? 1 : 0);
		if(firstLine > max)
			firstLine = max;
		if(firstLine < 0)
			firstLine = 0;
		

		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""setFirstLine() from ""
				+ getFirstLine() + "" to "" + firstLine);
		}

		int oldFirstLine = getFirstLine();
		if(firstLine == oldFirstLine)
			return;

		displayManager.setFirstLine(oldFirstLine,firstLine);

		repaint();

		fireScrollEvent(true);
	} 

	
	
	public final int getFirstPhysicalLine()
	{
		return displayManager.firstLine.physicalLine;
	} 

	
	
	public void setFirstPhysicalLine(int physFirstLine)
	{
		setFirstPhysicalLine(physFirstLine,0);
	}

	
	public void setFirstPhysicalLine(int physFirstLine, int skew)
	{
		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""setFirstPhysicalLine(""
				+ physFirstLine + ',' + skew + ')');
		}

		int amount = physFirstLine - displayManager.firstLine.physicalLine;

		displayManager.setFirstPhysicalLine(amount,skew);

		repaint();

		fireScrollEvent(true);
	} 

	
	
	public final int getLastPhysicalLine()
	{
		return physLastLine;
	} 

	
	
	public int getLastScreenLine()
	{
		return screenLastLine;
	} 

	
	
	public final int getVisibleLines()
	{
		return visibleLines;
	} 

	
	
	public final int getHorizontalOffset()
	{
		return horizontalOffset;
	} 

	
	
	public void setHorizontalOffset(int horizontalOffset)
	{
		if(horizontalOffset > 0)
			horizontalOffset = 0;

		if(horizontalOffset == this.horizontalOffset)
			return;

		this.horizontalOffset = horizontalOffset;
		painter.repaint();

		fireScrollEvent(false);
	} 

	
	
	public void scrollUpLine()
	{
		setFirstLine(getFirstLine() - 1);
	} 

	
	
	public void scrollUpPage()
	{
		setFirstLine(getFirstLine() - getVisibleLines()
			+ (lastLinePartial ? 1 : 0));
	} 

	
	
	public void scrollDownLine()
	{
		setFirstLine(getFirstLine() + 1);
	} 

	
	
	public void scrollDownPage()
	{
		setFirstLine(getFirstLine() + getVisibleLines()
			- (lastLinePartial ? 1 : 0));
	} 

	
	
	public void scrollToCaret(boolean doElectricScroll)
	{
		scrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),
			doElectricScroll);
	} 

	
	
	public void scrollTo(int offset, boolean doElectricScroll)
	{
		int line = buffer.getLineOfOffset(offset);
		scrollTo(line,offset - buffer.getLineStartOffset(line),
			doElectricScroll);
	}

	
	public void scrollTo(int line, int offset, boolean doElectricScroll)
	{
		if(Debug.SCROLL_TO_DEBUG)
			Log.log(Log.DEBUG,this,""scrollTo(), lineCount=""
				+ getLineCount());

		if(visibleLines <= 1)
		{
			if(Debug.SCROLL_TO_DEBUG)
			Log.log(Log.DEBUG,this,""visibleLines <= 0"");
			
			
			
			ChunkCache.LineInfo[] infos = chunkCache
			.getLineInfosForPhysicalLine(line);
			int subregion = ChunkCache.getSubregionOfOffset(
				offset,infos);
			setFirstPhysicalLine(line,subregion);
			return;
		}

		
		int extraEndVirt;
		int lineLength = buffer.getLineLength(line);
		if(offset > lineLength)
		{
			extraEndVirt = charWidth * (offset - lineLength);
			offset = lineLength;
		}
		else
			extraEndVirt = 0;

		int _electricScroll = doElectricScroll
			&& visibleLines - 1 > (electricScroll << 1)
				      ? electricScroll : 0;
		

		
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		int visibleLines = getVisibleLines();
		if(screenLine == -1)
		{
			
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""screenLine == -1"");
			ChunkCache.LineInfo[] infos = chunkCache
				.getLineInfosForPhysicalLine(line);
			int subregion = ChunkCache.getSubregionOfOffset(
				offset,infos);
			int prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());
			int nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());
			if(line == getFirstPhysicalLine())
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + getFirstPhysicalLine());
				setFirstPhysicalLine(line,subregion
					- _electricScroll);
			}
			else if(line == prevLine)
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + prevLine);
				setFirstPhysicalLine(prevLine,subregion
					- _electricScroll);
			}
			else if(line == getLastPhysicalLine())
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + getLastPhysicalLine());
				setFirstPhysicalLine(line,
					subregion + _electricScroll
					- visibleLines
					+ (lastLinePartial ? 2 : 1));
			}
			else if(line == nextLine)
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + nextLine);
				setFirstPhysicalLine(nextLine,
					subregion + _electricScroll
					- visibleLines
					+ (lastLinePartial ? 2 : 1));
			}
			else
			{
				if(Debug.SCROLL_TO_DEBUG)
				{
					Log.log(Log.DEBUG,this,""neither"");
					Log.log(Log.DEBUG,this,""Last physical line is "" + getLastPhysicalLine());
				}
				setFirstPhysicalLine(line,subregion
					- (visibleLines >> 1));
				if(Debug.SCROLL_TO_DEBUG)
				{
					Log.log(Log.DEBUG,this,""Last physical line is "" + getLastPhysicalLine());
				}
			}
		}
		else if(screenLine < _electricScroll)
		{
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""electric up"");
			setFirstLine(getFirstLine() - _electricScroll + screenLine);
		}
		else if(screenLine > visibleLines - _electricScroll
			- (lastLinePartial ? 2 : 1))
		{
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""electric down"");
			setFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));
		} 

		
		if(!displayManager.isLineVisible(line))
			return;

		Point point = offsetToXY(line,offset,offsetXY);

		point.x += extraEndVirt;

		if(point.x < 0)
		{
			setHorizontalOffset(horizontalOffset
				- point.x + charWidth + 5);
		}
		else if(point.x >= painter.getWidth() - charWidth - 5)
		{
			setHorizontalOffset(horizontalOffset +
				(painter.getWidth() - point.x)
				- charWidth - 5);
		} 
	} 

	
	
	public final void addScrollListener(ScrollListener listener)
	{
		listenerList.add(ScrollListener.class,listener);
	} 

	
	
	public final void removeScrollListener(ScrollListener listener)
	{
		listenerList.remove(ScrollListener.class,listener);
	} 

	

	

	
	
	public int getPhysicalLineOfScreenLine(int screenLine)
	{
		return chunkCache.getLineInfo(screenLine).physicalLine;
	} 

	
	
	public int getScreenLineOfOffset(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		return chunkCache.getScreenLineOfOffset(line,offset);
	} 

	
	
	public int getScreenLineStartOffset(int line)
	{
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;

		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset;
	} 

	
	
	public int getScreenLineEndOffset(int line)
	{
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;

		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset + lineInfo.length;
	} 

	

	

	
	
	public int xyToOffset(int x, int y)
	{
		return xyToOffset(x,y,true);
	}

	
	public int xyToOffset(int x, int y, boolean round)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		int line = y / height;

		if(line < 0 || line >= visibleLines)
			return -1;

		return xToScreenLineOffset(line,x,round);
	} 

	
	
	public int xToScreenLineOffset(int screenLine, int x, boolean round)
	{
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);
		if(lineInfo.physicalLine == -1)
		{
			return getLineEndOffset(displayManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			int offset = Chunk.xToOffset(lineInfo.chunks,
				x - horizontalOffset,round);
			if(offset == -1 || offset == lineInfo.offset + lineInfo.length)
				offset = lineInfo.offset + lineInfo.length - 1;

			return getLineStartOffset(lineInfo.physicalLine) + offset;
		}
	} 

	
	
	public Point offsetToXY(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		Point retVal = new Point();
		return offsetToXY(line,offset,retVal);
	}

	
	public Point offsetToXY(int line, int offset)
	{
		return offsetToXY(line,offset,new Point());
	}

	
	public Point offsetToXY(int line, int offset, Point retVal)
	{
		if(!displayManager.isLineVisible(line))
			return null;
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		if(screenLine == -1)
			return null;

		FontMetrics fm = painter.getFontMetrics();

		retVal.y = screenLine * fm.getHeight();

		ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);

		retVal.x = (int)(horizontalOffset + Chunk.offsetToX(
			info.chunks,offset));

		return retVal;
	} 

	

	

	
	
	public void invalidateScreenLineRange(int start, int end)
	{
		if(buffer.isLoading())
			return;

		if(start > end)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}

		if(chunkCache.needFullRepaint())
			end = visibleLines;

		FontMetrics fm = painter.getFontMetrics();
		int y = start * fm.getHeight();
		int height = (end - start + 1) * fm.getHeight();
		painter.repaint(0,y,painter.getWidth(),height);
		gutter.repaint(0,y,gutter.getWidth(),height);
	} 

	
	
	public void invalidateLine(int line)
	{
		if(!isShowing()
			|| buffer.isLoading()
			|| line < getFirstPhysicalLine()
			|| line > physLastLine
			|| !displayManager.isLineVisible(line))
			return;

		int startLine = -1;
		int endLine = -1;

		for(int i = 0; i < visibleLines; i++)
		{
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);

			if((info.physicalLine >= line || info.physicalLine == -1)
				&& startLine == -1)
			{
				startLine = i;
			}

			if((info.physicalLine >= line && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endLine = i;
				break;
			}
		}

		if(chunkCache.needFullRepaint() || endLine == -1)
			endLine = visibleLines;

		invalidateScreenLineRange(startLine,endLine);
	} 

	
	
	public void invalidateLineRange(int start, int end)
	{
		if(!isShowing() || buffer.isLoading())
			return;

		if(end < start)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}

		if(end < getFirstPhysicalLine() || start > getLastPhysicalLine())
			return;

		int startScreenLine = -1;
		int endScreenLine = -1;

		for(int i = 0; i < visibleLines; i++)
		{
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);

			if((info.physicalLine >= start || info.physicalLine == -1)
				&& startScreenLine == -1)
			{
				startScreenLine = i;
			}

			if((info.physicalLine >= end && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endScreenLine = i;
				break;
			}
		}

		if(startScreenLine == -1)
			startScreenLine = 0;

		if(chunkCache.needFullRepaint() || endScreenLine == -1)
			endScreenLine = visibleLines;

		invalidateScreenLineRange(startScreenLine,endScreenLine);
	} 

	

	

	
	
	public final int getBufferLength()
	{
		return buffer.getLength();
	} 

	
	
	public final int getLineCount()
	{
		return buffer.getLineCount();
	} 

	
	
	public final int getLineOfOffset(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} 

	
	
	public int getLineStartOffset(int line)
	{
		return buffer.getLineStartOffset(line);
	} 

	
	
	public int getLineEndOffset(int line)
	{
		return buffer.getLineEndOffset(line);
	} 

	
	
	public int getLineLength(int line)
	{
		return buffer.getLineLength(line);
	} 

	
	
	public final String getText(int start, int len)
	{
		return buffer.getText(start,len);
	}

	
	public final void getText(int start, int len, Segment segment)
	{
		buffer.getText(start,len,segment);
	}

	
	public String getText()
	{
		return buffer.getText(0,buffer.getLength());
	} 

	
	
	public final String getLineText(int lineIndex)
	{
		return buffer.getLineText(lineIndex);
	}

	
	public final void getLineText(int lineIndex, Segment segment)
	{
		buffer.getLineText(lineIndex,segment);
	} 

	
	
	public void setText(String text)
	{
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(0,buffer.getLength());
			buffer.insert(0,text);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	

	

	
	
	public final void selectAll()
	{
		int firstLine = getFirstLine();
		int horizOffset = getHorizontalOffset();

		setSelection(new Selection.Range(0,buffer.getLength()));
		moveCaretPosition(buffer.getLength(),true);

		setFirstLine(firstLine);
		setHorizontalOffset(horizOffset);
	} 

	
	
	public void selectLine()
	{
		int caretLine = getCaretLine();
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine) - 1;
		Selection s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} 

	
	
	public void selectParagraph()
	{
		int caretLine = getCaretLine();

		if(getLineLength(caretLine) == 0)
		{
			getToolkit().beep();
			return;
		}

		int start = caretLine;
		int end = caretLine;

		while(start >= 0)
		{
			if(getLineLength(start) == 0)
				break;
			else
				start--;
		}

		while(end < getLineCount())
		{
			if(getLineLength(end) == 0)
				break;
			else
				end++;
		}

		int selectionStart = getLineStartOffset(start + 1);
		int selectionEnd = getLineEndOffset(end - 1) - 1;
		Selection s = new Selection.Range(selectionStart,selectionEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(selectionEnd);
	} 

	
	
	public void selectWord()
	{
		int line = getCaretLine();
		int lineStart = getLineStartOffset(line);
		int offset = getCaretPosition() - lineStart;

		if(getLineLength(line) == 0)
			return;

		String lineText = getLineText(line);
		String noWordSep = buffer.getStringProperty(""noWordSep"");

		if(offset == getLineLength(line))
			offset--;

		int wordStart = TextUtilities.findWordStart(lineText,offset,
					noWordSep,true,false,false);
		int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,
					noWordSep,true,false,false);

		Selection s = new Selection.Range(lineStart + wordStart,
			lineStart + wordEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(lineStart + wordEnd);
	} 

	
	
	public Selection selectToMatchingBracket(int position,
		boolean quickCopy)
	{
		int positionLine = buffer.getLineOfOffset(position);
		int lineOffset = position - buffer.getLineStartOffset(positionLine);
		if(getLineLength(positionLine) != 0)
		{
			int bracket = TextUtilities.findMatchingBracket(buffer,
				positionLine,Math.max(0,lineOffset - 1));

			if(bracket != -1)
			{
				Selection s;

				if(bracket < position)
				{
					if(!quickCopy)
						moveCaretPosition(position,false);
					s = new Selection.Range(bracket,position);
				}
				else
				{
					if(!quickCopy)
						moveCaretPosition(bracket + 1,false);
					s = new Selection.Range(position - 1,bracket + 1);
				}

				if(!multi && !quickCopy)
					selectNone();

				addToSelection(s);
				return s;
			}
		}

		return null;
	}

	
	public void selectToMatchingBracket()
	{
		selectToMatchingBracket(caret,false);
	} 

	
	
	public void selectBlock()
	{

		Selection s = getSelectionAtOffset(caret);
		int start, end;
		if(s == null)
			start = end = caret;
		else
		{
			start = s.start;
			end = s.end;
		}

		String text = getText(0,buffer.getLength());

		
		if(start == 0)
		{
			getToolkit().beep();
			return;
		}

		
		String openBrackets = ""([{"";
		String closeBrackets = "")]}"";
		int count = 1;
		char openBracket = '\0';
		char closeBracket = '\0';

backward_scan:	while(--start > 0)
		{
			char c = text.charAt(start);
			int index = openBrackets.indexOf(c);
			if(index != -1)
			{
				if(--count == 0)
				{
					openBracket = c;
					closeBracket = closeBrackets.charAt(index);
					break backward_scan;
				}
			}
			else if(closeBrackets.indexOf(c) != -1)
				count++;
		}

		
		count = 1;

		
		if(openBracket == '\0')
		{
			getToolkit().beep();
			return;
		}
forward_scan:	do
		{
			char c = text.charAt(end);
			if(c == closeBracket)
			{
				if(--count == 0)
				{
					end++;
					break forward_scan;
				}
			}
			else if(c == openBracket)
				count++;
		}
		while(++end < buffer.getLength());

		s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} 

	
	
	public boolean lineInStructureScope(int line)
	{
		if(match == null)
			return false;

		if(match.startLine < caretLine)
			return line >= match.startLine && line <= caretLine;
		else
			return line <= match.endLine && line >= caretLine;
	} 

	
	
	public final void invertSelection()
	{
		selectionManager.invertSelection();
	} 

	
	
	public int getSelectionCount()
	{
		return selectionManager.getSelectionCount();
	} 

	
	
	public Selection[] getSelection()
	{
		return selectionManager.getSelection();
	}

	
	public Selection getSelection(int index)
	{
		return selectionManager.selection.get(index);
	} 

	
	
	public Iterator<Selection> getSelectionIterator()
	{
		return selectionManager.selection.iterator();
	} 

	
	
	public void selectNone()
	{
		invalidateSelectedLines();
		setSelection((Selection)null);
	} 

	
	
	public void setSelection(Selection[] selection)
	{
		
		invalidateSelectedLines();
		selectionManager.setSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}

	
	public void setSelection(Selection selection)
	{
		invalidateSelectedLines();
		selectionManager.setSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	} 

	
	
	public void addToSelection(Selection[] selection)
	{
		invalidateSelectedLines();
		selectionManager.addToSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}

	
	public void addToSelection(Selection selection)
	{
		invalidateSelectedLines();
		selectionManager.addToSelection(selection);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	} 

	
	
	public Selection getSelectionAtOffset(int offset)
	{
		return selectionManager.getSelectionAtOffset(offset);
	} 

	
	
	public void removeFromSelection(Selection sel)
	{
		invalidateSelectedLines();
		selectionManager.removeFromSelection(sel);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	}

	
	public void removeFromSelection(int offset)
	{
		Selection sel = getSelectionAtOffset(offset);
		if(sel == null)
			return;

		invalidateSelectedLines();
		selectionManager.removeFromSelection(sel);
		finishCaretUpdate(caretLine,NO_SCROLL,true);
	} 

	
	
	public void resizeSelection(int offset, int end, int extraEndVirt,
		boolean rect)
	{
		Selection s = selectionManager.getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selectionManager.removeFromSelection(s);
		}

		selectionManager.resizeSelection(offset,end,extraEndVirt,rect);
		fireCaretEvent();
	} 

	
	
	public void extendSelection(int offset, int end)
	{
		extendSelection(offset,end,0,0);
	}

	
	public void extendSelection(int offset, int end,
		int extraStartVirt, int extraEndVirt)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selectionManager.removeFromSelection(s);

			if(offset == s.start)
			{
				offset = end;
				end = s.end;
			}
			else if(offset == s.end)
			{
				offset = s.start;
			}
		}

		if(end < offset)
		{
			int tmp = end;
			end = offset;
			offset = tmp;
		}

		if(rectangularSelectionMode)
		{
			s = new Selection.Rect(offset,end);
			((Selection.Rect)s).extraStartVirt = extraStartVirt;
			((Selection.Rect)s).extraEndVirt = extraEndVirt;
		}
		else
			s = new Selection.Range(offset,end);

		selectionManager.addToSelection(s);
		fireCaretEvent();

		if(rectangularSelectionMode && extraEndVirt != 0)
		{
			int line = getLineOfOffset(end);
			scrollTo(line,getLineLength(line) + extraEndVirt,false);
		}
	} 

	
	
	public String getSelectedText(Selection s)
	{
		StringBuilder buf = new StringBuilder(s.end - s.start);
		s.getText(buffer,buf);
		return buf.toString();
	}

	
	public String getSelectedText(String separator)
	{
		Selection[] sel = selectionManager.getSelection();
		if(sel.length == 0)
			return null;

		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < sel.length; i++)
		{
			if(i != 0)
				buf.append(separator);

			sel[i].getText(buffer,buf);
		}

		return buf.toString();
	}

	
	public String getSelectedText()
	{
		return getSelectedText(""\n"");
	} 

	
	
	public void setSelectedText(Selection s, String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}

		try
		{
			buffer.beginCompoundEdit();

			moveCaretPosition(s.setText(buffer,selectedText));
		}
		
		
		finally
		{
			buffer.endCompoundEdit();
		}

		
		
	}

	
	public void setSelectedText(String selectedText)
	{
		int newCaret = replaceSelection(selectedText);
		if(newCaret != -1)
			moveCaretPosition(newCaret);
		selectNone();
	}

	
	public void setSelectedText(String selectedText, boolean moveCaret)
	{
		int newCaret = replaceSelection(selectedText);
		if(moveCaret && newCaret != -1)
			moveCaretPosition(newCaret);
		selectNone();
	} 

	
	
	public int replaceSelection(String selectedText)
	{
		if(!isEditable())
			throw new RuntimeException(""Text component read only"");

		int newCaret = -1;
		if(getSelectionCount() == 0)
		{
			
			buffer.insert(caret,selectedText);
		}
		else
		{
			try
			{
				buffer.beginCompoundEdit();

				Selection[] selection = getSelection();
				for(int i = 0; i < selection.length; i++)
					newCaret = selection[i].setText(buffer,selectedText);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		return newCaret;
	} 

	
	
	public int[] getSelectedLines()
	{
		if(selectionManager.getSelectionCount() == 0)
			return new int[] { caretLine };

		return selectionManager.getSelectedLines();
	} 

	

	

	
	
	public boolean caretAutoScroll()
	{
		return focusedComponent == this;
	} 

	
	
	public void addStructureMatcher(StructureMatcher matcher)
	{
		structureMatchers.add(matcher);
	} 

	
	
	public void removeStructureMatcher(StructureMatcher matcher)
	{
		structureMatchers.remove(matcher);
	} 

	
	
	public StructureMatcher.Match getStructureMatch()
	{
		return match;
	} 

	
	
	public final void blinkCaret()
	{
		if(caretBlinks)
		{
			blink = !blink;
			invalidateLine(caretLine);
		}
		else
			blink = true;
	} 

	
	
	public void centerCaret()
	{
		int offset = getScreenLineStartOffset(visibleLines >> 1);
		if(offset == -1)
			getToolkit().beep();
		else
			setCaretPosition(offset);
	} 

	
	
	public void scrollAndCenterCaret()
	{
		if (!getDisplayManager().isLineVisible(getCaretLine()))
			getDisplayManager().expandFold(getCaretLine(),true);
		int physicalLine = getCaretLine();
		int midPhysicalLine = getPhysicalLineOfScreenLine(visibleLines >> 1);
		int diff = physicalLine -  midPhysicalLine;
		setFirstLine(getFirstLine() + diff);
		requestFocus();
	} 

	
	
	public void setCaretPosition(int newCaret)
	{
		selectNone();
		moveCaretPosition(newCaret,true);
	}

	
	public void setCaretPosition(int newCaret, boolean doElectricScroll)
	{
		selectNone();
		moveCaretPosition(newCaret,doElectricScroll);
	} 

	
	
	public void moveCaretPosition(int newCaret)
	{
		moveCaretPosition(newCaret,true);
	}

	
	public void moveCaretPosition(int newCaret, boolean doElectricScroll)
	{
		moveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL
			: NORMAL_SCROLL);
	}

	public static final int NO_SCROLL = 0;
	public static final int NORMAL_SCROLL = 1;
	public static final int ELECTRIC_SCROLL = 2;

	
	public void moveCaretPosition(int newCaret, int scrollMode)
	{
		if(newCaret < 0 || newCaret > buffer.getLength())
		{
			throw new IllegalArgumentException(""caret out of bounds: ""
				+ newCaret);
		}
		int oldCaretLine = caretLine;

		if(caret == newCaret)
			finishCaretUpdate(oldCaretLine,scrollMode,false);
		else
		{
			caret = newCaret;
			caretLine = getLineOfOffset(newCaret);

			magicCaret = -1;

			finishCaretUpdate(oldCaretLine,scrollMode,true);
		}
	} 

	
	
	public int getCaretPosition()
	{
		return caret;
	} 

	
	
	public int getCaretLine()
	{
		return caretLine;
	} 

	
	
	public int getMagicCaretPosition()
	{
		if(magicCaret == -1)
		{
			magicCaret = chunkCache.subregionOffsetToX(
				caretLine,caret - getLineStartOffset(caretLine));
		}

		return magicCaret;
	} 

	
	
	public void setMagicCaretPosition(int magicCaret)
	{
		this.magicCaret = magicCaret;
	} 

	
	
	public final void addCaretListener(CaretListener listener)
	{
		listenerList.add(CaretListener.class,listener);
	} 

	
	
	public final void removeCaretListener(CaretListener listener)
	{
		listenerList.remove(CaretListener.class,listener);
	} 

	
	
	public void goToNextBracket(boolean select)
	{
		int newCaret = -1;

		if(caret != buffer.getLength())
		{
			String text = getText(caret,buffer.getLength()
				- caret - 1);

loop:			for(int i = 0; i < text.length(); i++)
			{
				switch(text.charAt(i))
				{
				case ')': case ']': case '}':
					newCaret = caret + i + 1;
					break loop;
				}
			}
		}

		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} 

	
	
	public void goToNextCharacter(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);

		if(!select && s instanceof Selection.Range)
		{
			if(multi)
			{
				if(caret != s.end)
				{
					moveCaretPosition(s.end);
					return;
				}
			}
			else
			{
				setCaretPosition(s.end);
				return;
			}
		}

		int extraStartVirt, extraEndVirt;
		if(s instanceof Selection.Rect)
		{
			extraStartVirt = ((Selection.Rect)s).extraStartVirt;
			extraEndVirt = ((Selection.Rect)s).extraEndVirt;
		}
		else
		{
			extraStartVirt = 0;
			extraEndVirt = 0;
		}

		int newCaret = caret;

		if(caret == buffer.getLength())
		{
			if(select && (rectangularSelectionMode || s instanceof Selection.Rect))
			{
				if(s != null && caret == s.start)
					extraStartVirt++;
				else
					extraEndVirt++;
			}
			else
			{
				getToolkit().beep();
				return;
			}
		}
		else if(caret == getLineEndOffset(caretLine) - 1)
		{
			if(select && (rectangularSelectionMode || s instanceof Selection.Rect))
			{
				if(s != null && caret == s.start)
					extraStartVirt++;
				else
					extraEndVirt++;
			}
			else
			{
				int line = displayManager.getNextVisibleLine(caretLine);
				if(line == -1)
				{
					getToolkit().beep();
					return;
				}
				else
					newCaret = getLineStartOffset(line);
			}
		}
		else
			newCaret = caret + 1;

		if(select)
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
	} 

	
	
	public void goToNextLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		boolean rectSelect = s == null ? rectangularSelectionMode
			: s instanceof Selection.Rect;
		int magic = getMagicCaretPosition();
		int newCaret = chunkCache.getBelowPosition(caretLine,
			caret - buffer.getLineStartOffset(caretLine),magic + 1,
			rectSelect && select);
		if(newCaret == -1)
		{
			int end = getLineEndOffset(caretLine) - 1;
			if(caret == end)
			{
				getToolkit().beep();
				return;
			}
			else
				newCaret = end;
		}

		_changeLine(select, newCaret);

		setMagicCaretPosition(magic);
	}

	
	
	public void goToNextPage(boolean select)
	{
		scrollToCaret(false);
		int magic = getMagicCaretPosition();
		if(caretLine < displayManager.getFirstVisibleLine())
		{
			caretLine = displayManager.getNextVisibleLine(
				caretLine);
		}

		int newCaret;

		if(getFirstLine() + getVisibleLines() >= displayManager
			.getScrollLineCount())
		{
			int lastVisibleLine = displayManager
				.getLastVisibleLine();
			newCaret = getLineEndOffset(lastVisibleLine) - 1;
		}
		else
		{
			int caretScreenLine = getScreenLineOfOffset(caret);

			scrollDownPage();

			newCaret = xToScreenLineOffset(caretScreenLine,
				magic,true);
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret,false);

		setMagicCaretPosition(magic);
	} 

	
	
	public void goToNextParagraph(boolean select)
	{
		int lineNo = getCaretLine();

		int newCaret = getBufferLength();

		boolean foundBlank = false;

		final Segment lineSegment = new Segment();
loop:		for(int i = lineNo + 1; i < getLineCount(); i++)
		{
			if(!displayManager.isLineVisible(i))
				continue;

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineStartOffset(i);
						break loop;
					}
					else
						continue loop;
				}
			}

			foundBlank = true;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToNextWord(boolean select)
	{
		goToNextWord(select,false);
	}

	
	public void goToNextWord(boolean select, boolean eatWhitespace)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);

		if(newCaret == lineText.length())
		{
			int nextLine = displayManager.getNextVisibleLine(caretLine);
			if(nextLine == -1)
			{
				getToolkit().beep();
				return;
			}

			newCaret = getLineStartOffset(nextLine);
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			boolean camelCasedWords = buffer.getBooleanProperty(""camelCasedWords"");
			newCaret = TextUtilities.findWordEnd(lineText,
				newCaret + 1,noWordSep,true,camelCasedWords,
				eatWhitespace);

			newCaret += lineStart;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevBracket(boolean select)
	{
		String text = getText(0,caret);

		int newCaret = -1;

loop:		for(int i = getCaretPosition() - 1; i >= 0; i--)
		{
			switch(text.charAt(i))
			{
			case '(': case '[': case '{':
				newCaret = i;
				break loop;
			}
		}

		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} 

	
	
	public void goToPrevCharacter(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);

		if(caret == 0)
		{
			getToolkit().beep();
			return;
		}

		if(!select && s instanceof Selection.Range)
		{
			if(multi)
			{
				if(caret != s.start)
				{
					moveCaretPosition(s.start);
					return;
				}
			}
			else
			{
				setCaretPosition(s.start);
				return;
			}
		}

		int extraStartVirt = 0;
		int extraEndVirt = 0;
		int newCaret = caret;

		if(select && caret == getLineEndOffset(caretLine) - 1)
		{
			if(s instanceof Selection.Rect)
			{
				extraStartVirt = ((Selection.Rect)s).extraStartVirt;
				extraEndVirt = ((Selection.Rect)s).extraEndVirt;
				if(caret == s.start)
				{
					if(extraStartVirt == 0)
						newCaret = caret - 1;
					else
						extraStartVirt--;
				}
				else
				{
					if(extraEndVirt == 0)
						newCaret = caret - 1;
					else
						extraEndVirt--;
				}
			}
			else
				newCaret = caret - 1;
		}
		else if(caret == getLineStartOffset(caretLine))
		{
			int line = displayManager.getPrevVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineEndOffset(line) - 1;
		}
		else
			newCaret = caret - 1;

		if(select)
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		boolean rectSelect = s == null ? rectangularSelectionMode
			: s instanceof Selection.Rect;
		int magic = getMagicCaretPosition();

		int newCaret = chunkCache.getAbovePosition(caretLine,
			caret - buffer.getLineStartOffset(caretLine),magic + 1,
			rectSelect && select);
		if(newCaret == -1)
		{
			int start = getLineStartOffset(caretLine);
			if(caret == start)
			{
				getToolkit().beep();
				return;
			}
			else
				newCaret = start;
		}

		_changeLine(select, newCaret);

		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevPage(boolean select)
	{
		scrollToCaret(false);
		int magic = getMagicCaretPosition();

		if(caretLine < displayManager.getFirstVisibleLine())
		{
			caretLine = displayManager.getNextVisibleLine(
				caretLine);
		}

		int newCaret;

		if(getFirstLine() == 0)
		{
			int firstVisibleLine = displayManager
				.getFirstVisibleLine();
			newCaret = getLineStartOffset(firstVisibleLine);
		}
		else
		{
			int caretScreenLine = getScreenLineOfOffset(caret);

			scrollUpPage();

			newCaret = xToScreenLineOffset(caretScreenLine,
				magic,true);
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret,false);

		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevParagraph(boolean select)
	{
		int lineNo = caretLine;
		int newCaret = 0;

		boolean foundBlank = false;

		final Segment lineSegment = new Segment();
loop:		for(int i = lineNo - 1; i >= 0; i--)
		{
			if(!displayManager.isLineVisible(i))
				continue;

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineEndOffset(i) - 1;
						break loop;
					}
					else
						continue loop;
				}
			}

			foundBlank = true;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevWord(boolean select)
	{
		goToPrevWord(select,false);
	} 

	
	
	public void goToPrevWord(boolean select, boolean eatWhitespace)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);

		if(newCaret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			else
			{
				int prevLine = displayManager.getPrevVisibleLine(caretLine);
				if(prevLine == -1)
				{
					getToolkit().beep();
					return;
				}

				newCaret = getLineEndOffset(prevLine) - 1;
			}
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			boolean camelCasedWords = buffer.getBooleanProperty(""camelCasedWords"");
			newCaret = TextUtilities.findWordStart(lineText,
				newCaret - 1,noWordSep,true,camelCasedWords,eatWhitespace);

			newCaret += lineStart;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void home(boolean select)
	{
		switch(getInputHandler().getLastActionCount() % 2)
		{
		case 1:
			goToStartOfWhiteSpace(select);
			break;
		default:
			goToStartOfLine(select);
			break;
		}
	} 

	
	
	public void end(boolean select)
	{
		switch(getInputHandler().getLastActionCount() % 2)
		{
		case 1:
			goToEndOfWhiteSpace(select);
			break;
		default:
			goToEndOfLine(select);
			break;
		}
	} 

	
	
	public void smartHome(boolean select)
	{
		switch(getInputHandler().getLastActionCount())
		{
		case 1:
			goToStartOfWhiteSpace(select);
			break;
		case 2:
			goToStartOfLine(select);
			break;
		default: 
			goToFirstVisibleLine(select);
			break;
		}
	} 

	
	
	public void smartEnd(boolean select)
	{
		int pos = getCaretPosition();
		int npos = 0;
		switch(getInputHandler().getLastActionCount())
		{
		case 1:
			goToEndOfCode(select);
			npos = getCaretPosition();
			if (npos == pos) goToEndOfWhiteSpace(select);
			break;
		case 2:
			goToEndOfWhiteSpace(select);
			break;
		case 3:
			goToEndOfLine(select);
			break;
		default: 
			goToLastVisibleLine(select);
			break;
		}
	} 

	
	
	public void goToStartOfLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line = select || s == null ? caretLine : s.startLine;
		int newCaret = getLineStartOffset(line);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToEndOfLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line = select || s == null ? caretLine : s.endLine;
		int newCaret = getLineEndOffset(line) - 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);

		
		
		
	} 

	
	
	public void goToEndOfCode(boolean select)
	{
		int line = getCaretLine();

		
		DefaultTokenHandler tokenHandler = new DefaultTokenHandler();
		buffer.markTokens(line,tokenHandler);
		Token token = tokenHandler.getTokens();

		char[] txt = getLineText(line).toCharArray();

		
		while(true)
		{
			if( token.id == Token.COMMENT1 ||
				token.id == Token.COMMENT2 ||
				token.id == Token.COMMENT3 ||
				token.id == Token.COMMENT4)
			{
				for(int i=token.offset; i<token.offset+token.length; i++)
				{
					txt[i] = ' ';
				}
			}

			if(token.next == null)
				break;
			token = token.next;
		}

		int newCaret = getLineLength(line) - StandardUtilities.getTrailingWhiteSpace( new String(txt) );
		newCaret += getLineStartOffset(line);

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToStartOfWhiteSpace(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - buffer.getLineStartOffset(line);
		}
		else
		{
			line = s.startLine;
			offset = s.start - buffer.getLineStartOffset(line);
		}

		int firstIndent = chunkCache.getSubregionStartOffset(line,offset);
		if(firstIndent == getLineStartOffset(line))
		{
			firstIndent = StandardUtilities.getLeadingWhiteSpace(getLineText(line));
			if(firstIndent == getLineLength(line))
				firstIndent = 0;
			firstIndent += getLineStartOffset(line);
		}

		if(select)
			extendSelection(caret,firstIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstIndent);
	} 

	
	
	public void goToEndOfWhiteSpace(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - getLineStartOffset(line);
		}
		else
		{
			line = s.endLine;
			offset = s.end - getLineStartOffset(line);
		}

		int lastIndent = chunkCache.getSubregionEndOffset(line,offset);

		if(lastIndent == getLineEndOffset(line))
		{
			lastIndent = getLineLength(line) - StandardUtilities.getTrailingWhiteSpace(getLineText(line));
			if(lastIndent == 0)
				lastIndent = getLineLength(line);
			lastIndent += getLineStartOffset(line);
		}
		else
		{
			lastIndent--;
		}

		if(select)
			extendSelection(caret,lastIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastIndent);
	} 

	
	
	public void goToFirstVisibleLine(boolean select)
	{
		int firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;
		int firstVisible = getScreenLineStartOffset(firstVisibleLine);
		if(firstVisible == -1)
		{
			firstVisible = getLineStartOffset(displayManager
				.getFirstVisibleLine());
		}

		if(select)
			extendSelection(caret,firstVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstVisible);
	} 

	
	
	public void goToLastVisibleLine(boolean select)
	{
		int lastVisible;

		if(getFirstLine() + visibleLines >=
			displayManager.getScrollLineCount())
		{
			lastVisible = getLineEndOffset(displayManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			lastVisible = visibleLines - electricScroll - 1;
			if(lastLinePartial)
				lastVisible--;
			if(lastVisible < 0)
				lastVisible = 0;
			lastVisible = getScreenLineEndOffset(lastVisible) - 1;
			if(lastVisible == -1)
			{
				lastVisible = getLineEndOffset(displayManager
					.getLastVisibleLine()) - 1;
			}
		}

		if(select)
			extendSelection(caret,lastVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastVisible);
	} 

	
	
	public void goToBufferStart(boolean select)
	{
		int start = buffer.getLineStartOffset(
			displayManager.getFirstVisibleLine());
		if(select)
			extendSelection(caret,start);
		else if(!multi)
			selectNone();
		moveCaretPosition(start);
	} 

	
	
	public void goToBufferEnd(boolean select)
	{
		int end = buffer.getLineEndOffset(
			displayManager.getLastVisibleLine()) - 1;
		if(select)
			extendSelection(caret,end);
		else if(!multi)
			selectNone();
		moveCaretPosition(end);
	} 

	
	
	public void goToMatchingBracket()
	{
		if(getLineLength(caretLine) != 0)
		{
			int dot = caret - getLineStartOffset(caretLine);

			int bracket = TextUtilities.findMatchingBracket(
				buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1)
			{
				selectNone();
				moveCaretPosition(bracket + 1,false);
				return;
			}
		}

		getToolkit().beep();
	} 

	

	

	
	
	public void userInput(char ch)
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}

		
		if(hiddenCursor != null)
			getPainter().setCursor(hiddenCursor);

		switch(ch)
		{
		case '\t':
			userInputTab();
			break;
		case '\b':
			backspace();
			break;
		case '\u007F':
			delete();
			break;
		default:
			boolean indent = buffer.isElectricKey(ch, caretLine);
			String str = String.valueOf(ch);
			if(getSelectionCount() == 0)
			{
				if(!doWordWrap(ch == ' '))
					insert(str,indent);
			}
			else
				replaceSelection(str);
			break;
		}
	} 

	
	
	public final boolean isOverwriteEnabled()
	{
		return overwrite;
	} 

	
	
	public final void setOverwriteEnabled(boolean overwrite)
	{
		blink = true;
		caretTimer.restart();

		this.overwrite = overwrite;
		invalidateLine(caretLine);
		fireStatusChanged(StatusListener.OVERWRITE_CHANGED,overwrite);
	} 

	
	
	public final void toggleOverwriteEnabled()
	{
		setOverwriteEnabled(!overwrite);
	} 

	
	
	public void backspace()
	{
		delete(false);
	} 

	
	
	public void backspaceWord()
	{
		backspaceWord(false);
	}

	
	public void backspaceWord(boolean eatWhitespace)
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(getSelectionCount() != 0)
		{
			setSelectedText("""");
			return;
		}

		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;

		String lineText = getLineText(caretLine);

		if(_caret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			_caret--;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			boolean camelCasedWords = buffer.getBooleanProperty(""camelCasedWords"");
			_caret = TextUtilities.findWordStart(lineText,_caret-1,
				noWordSep,true,camelCasedWords,eatWhitespace);
		}

		buffer.remove(_caret + lineStart, caret - (_caret + lineStart));
	} 

	
	
	public void delete()
	{
		delete(true);
	} 

	
	
	public void deleteToEndOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.remove(caret,getLineEndOffset(caretLine)
			- caret - 1);
	} 

	
	
	public void deleteLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		int x = chunkCache.subregionOffsetToX(caretLine,caret - getLineStartOffset(caretLine));
		int[] lines = getSelectedLines();

		try
		{
			buffer.beginCompoundEdit();

			for (int i = lines.length - 1; i >= 0; i--)
			{
				int start = getLineStartOffset(lines[i]);
				int end = getLineEndOffset(lines[i]);
				if (end > buffer.getLength())
				{
					if (start != 0)
						start--;
					end--;
				}
				buffer.remove(start,end - start);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		int lastLine = displayManager.getLastVisibleLine();

		if(caretLine == lastLine)
		{
			int offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);
			setCaretPosition(buffer.getLineStartOffset(lastLine)
			+ offset);
		}
		else
		{
			int offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);
			setCaretPosition(getLineStartOffset(caretLine) + offset);
		}
	} 

	
	
	public void deleteParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		
		int start = 0;
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if (lineContainsSpaceAndTabs(i))
			{
				start = getLineStartOffset(i);
				break;
			}
		}

		
		int end = buffer.getLength();
		for(int i = caretLine + 1; i < getLineCount(); i++)
		{
			
			

			if (lineContainsSpaceAndTabs(i))
			{
				end = getLineEndOffset(i) - 1;
				break;
			}
		}

		buffer.remove(start,end - start);
	} 

	
	
	public void deleteToStartOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.remove(getLineStartOffset(caretLine),
			caret - getLineStartOffset(caretLine));
	} 

	
	
	public void deleteWord()
	{
		deleteWord(false);
	}

	
	public void deleteWord(boolean eatWhitespace)
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(getSelectionCount() != 0)
		{
			setSelectedText("""");
			return;
		}

		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;

		String lineText = getLineText(caretLine);

		if(_caret == lineText.length())
		{
			if(lineStart + _caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			_caret++;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			boolean camelCasedWords = buffer.getBooleanProperty(""camelCasedWords"");
			_caret = TextUtilities.findWordEnd(lineText,
				_caret+1,noWordSep,true,camelCasedWords,eatWhitespace);
		}

		buffer.remove(caret,(_caret + lineStart) - caret);
	} 

	
	
	public final boolean isMultipleSelectionEnabled()
	{
		return multi;
	} 

	
	
	public final void toggleMultipleSelectionEnabled()
	{
		setMultipleSelectionEnabled(!multi);
	} 

	
	
	public final void setMultipleSelectionEnabled(boolean multi)
	{
		this.multi = multi;
		fireStatusChanged(StatusListener.MULTI_SELECT_CHANGED,multi);
		painter.repaint();
	} 

	
	
	public final boolean isRectangularSelectionEnabled()
	{
		return rectangularSelectionMode;
	} 

	
	
	public final void toggleRectangularSelectionEnabled()
	{
		setRectangularSelectionEnabled(!rectangularSelectionMode);

		if(getSelectionCount() == 1)
		{
			Selection s = getSelection(0);
			removeFromSelection(s);
			if(rectangularSelectionMode)
			{
				addToSelection(new Selection.Rect(
					s.getStart(),s.getEnd()));
			}
			else
			{
				addToSelection(new Selection.Range(
					s.getStart(),s.getEnd()));
			}
		}
	} 

	
	
	public final void setRectangularSelectionEnabled(
		boolean rectangularSelectionMode)
	{
		this.rectangularSelectionMode = rectangularSelectionMode;
		fireStatusChanged(StatusListener.RECT_SELECT_CHANGED,
			rectangularSelectionMode);
		painter.repaint();
	} 

	

	

	
	
	public void goToParentFold()
	{
		int line = -1;
		int level = buffer.getFoldLevel(caretLine);
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.getFoldLevel(i) < level)
			{
				line = i;
				break;
			}
		}

		if(line == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(line)
			+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);
		if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToNextFold(boolean select)
	{
		int nextFold = -1;
		for(int i = caretLine + 1; i < buffer.getLineCount(); i++)
		{
			if(buffer.isFoldStart(i)
				&& displayManager.isLineVisible(i))
			{
				nextFold = i;
				break;
			}
		}

		if(nextFold == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(nextFold)
			+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevFold(boolean select)
	{
		int prevFold = -1;
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.isFoldStart(i)
				&& displayManager.isLineVisible(i))
			{
				prevFold = i;
				break;
			}
		}

		if(prevFold == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(prevFold)
			+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void collapseFold()
	{
		collapseFold(caretLine);
	}

	
	public void collapseFold(int line)
	{
		int x = chunkCache.subregionOffsetToX(caretLine,
			caret - getLineStartOffset(caretLine));

		displayManager.collapseFold(line);

		if(displayManager.isLineVisible(caretLine))
			return;

		line = displayManager.getPrevVisibleLine(caretLine);

		if(!multi)
		{
			
			invalidateSelectedLines();
			selectionManager.setSelection((Selection) null);
		}
		moveCaretPosition(buffer.getLineStartOffset(line)
			+ chunkCache.xToSubregionOffset(line,0,x,true));
	} 

	
	
	public void expandFold(boolean fully)
	{
		int x = chunkCache.subregionOffsetToX(caretLine,
			caret - getLineStartOffset(caretLine));

		int line = displayManager.expandFold(caretLine,fully);

		if(!fully && line != -1)
		{
			if(!multi)
				selectNone();
			moveCaretPosition(getLineStartOffset(line)
				+ chunkCache.xToSubregionOffset(line,0,x,true));
		}
	} 

	
	
	public void selectFold()
	{
		selectFold(caretLine);
	}

	
	public void selectFold(int line)
	{
		int[] lines = buffer.getFoldAtLine(line);

		int newCaret = getLineEndOffset(lines[1]) - 1;
		Selection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(newCaret);
	} 

	
	
	public void narrowToFold()
	{
		int[] lines = buffer.getFoldAtLine(caretLine);
		if(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)
			getToolkit().beep();
		else
			displayManager.narrow(lines[0],lines[1]);
	} 

	
	
	public void narrowToSelection()
	{
		if(getSelectionCount() != 1)
		{
			getToolkit().beep();
			return;
		}

		Selection sel = getSelection(0);
		displayManager.narrow(sel.getStartLine(),sel.getEndLine());

		selectNone();
	} 

	
	
	public void addExplicitFold() throws TextAreaException
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(!buffer.getStringProperty(""folding"").equals(""explicit""))
		{
			throw new TextAreaException(""folding-not-explicit"");
		}

		try
		{
			buffer.beginCompoundEdit();

			if (getSelectionCount() == 0)
			{
				addExplicitFold(caret, caret, caretLine, caretLine);
			}
			else
			{
				Selection[] selections = getSelection();
				Selection selection = null;
				int caretBack = 0;
				for (int i = 0; i < selections.length; i++)
				{
					selection = selections[i];
					caretBack = addExplicitFold(selection.start, selection.end, selection.startLine,selection.endLine);
				}
				
				assert selection != null;
				setCaretPosition(selection.start - caretBack, false);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 
	

	

	
	
	public void lineComment()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		String comment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		if(comment == null || comment.length() == 0)
		{
			rangeLineComment();
			return;
		}

		comment += ' ';

		buffer.beginCompoundEdit();

		int[] lines = getSelectedLines();

		try
		{
			for(int i = 0; i < lines.length; i++)
			{
				String text = getLineText(lines[i]);
				buffer.insert(getLineStartOffset(lines[i])
					+ StandardUtilities.getLeadingWhiteSpace(text),
					comment);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		selectNone();
	} 

	
	
	public void rangeComment()
	{
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null
			|| commentStart.length() == 0 || commentEnd.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		commentStart += ' ';
		commentEnd = ' ' + commentEnd;

		try
		{
			buffer.beginCompoundEdit();

			Selection[] selection = getSelection();

			if(selection.length == 0)
			{
				int oldCaret = caret;
				buffer.insert(caret,commentStart);
				buffer.insert(caret,commentEnd);
				setCaretPosition(oldCaret + commentStart.length());
			}

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Range)
				{
					buffer.insert(s.start,commentStart);
					buffer.insert(s.end,commentEnd);
				}
				else if(s instanceof Selection.Rect)
				{
					Selection.Rect rect = (Selection.Rect)s;
					int start = rect.getStartColumn(buffer);
					int end = rect.getEndColumn(buffer);

					for(int j = s.startLine; j <= s.endLine; j++)
					{
						buffer.insertAtColumn(j,end,
							commentEnd);
						buffer.insertAtColumn(j,start,
							commentStart);
					}
				}
			}

			selectNone();
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	
	
	public void formatParagraph() throws TextAreaException
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(maxLineLen <= 0)
		{
			throw new TextAreaException(""format-maxlinelen"");
		}

		Selection[] selection = getSelection();
		if(selection.length != 0)
		{
			buffer.beginCompoundEdit();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.format(
					getSelectedText(s),maxLineLen,
					buffer.getTabSize()));
			}

			buffer.endCompoundEdit();
		}
		else
		{
			int lineNo = getCaretLine();

			int start = 0, end = buffer.getLength();

			for(int i = lineNo - 1; i >= 0; i--)
			{
				if (lineContainsSpaceAndTabs(i))
				{
					start = getLineEndOffset(i);
					break;
				}
			}

			for(int i = lineNo + 1; i < getLineCount(); i++)
			{
				if (lineContainsSpaceAndTabs(i))
				{
					end = getLineStartOffset(i) - 1;
					break;
				}
			}

			try
			{
				buffer.beginCompoundEdit();

				String text = buffer.getText(start,end - start);
				int offset = getCaretPosition() - start;
				int noSpaceOffset = TextUtilities.indexIgnoringWhitespace(
					text,offset);
				buffer.remove(start,end - start);
				text = TextUtilities.format(
					text,maxLineLen,buffer.getTabSize());
				buffer.insert(start,text);
				int caretPos = start;
				if (text.length() != 0)
				{
					caretPos += Math.min(text.length(),
					TextUtilities.ignoringWhitespaceIndex(
					text,noSpaceOffset));
				}
				moveCaretPosition(caretPos);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	
	public void spacesToTabs()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		if(selection.length == 0)
		{
			setText(TextUtilities.spacesToTabs(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.spacesToTabs(
					getSelectedText(s),buffer.getTabSize()));
			}
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void tabsToSpaces()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		if(selection.length == 0)
		{
			setText(TextUtilities.tabsToSpaces(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s, TextUtilities.tabsToSpaces(
					getSelectedText(s),buffer.getTabSize()));
			}
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void toUpperCase()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		Selection[] selection = getSelection();
		int caret = -1;
		if (selection.length == 0)
		{
			caret = getCaretPosition();
			selectWord();
			selection = getSelection();
		}
		if (selection.length == 0)
		{
			if (caret != -1)
				setCaretPosition(caret);
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toUpperCase());
		}

		buffer.endCompoundEdit();
		if (caret != -1)
			setCaretPosition(caret);
	} 

	
	
	public void toLowerCase()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		Selection[] selection = getSelection();
		int caret = -1;
		if (selection.length == 0)
		{
			caret = getCaretPosition();
			selectWord();
			selection = getSelection();
		}
		if (selection.length == 0)
		{
			if (caret != -1)
				setCaretPosition(caret);
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		for (int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toLowerCase());
		}

		buffer.endCompoundEdit();
		if (caret != -1)
			setCaretPosition(caret);
	} 

	
	
	public void removeTrailingWhiteSpace()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.removeTrailingWhiteSpace(getSelectedLines());
		}
	} 

	
	public void insertEnterAndIndent()
	{
		if(!isEditable())
			getToolkit().beep();
		else
		{
			try
			{
				buffer.beginCompoundEdit();
				setSelectedText(""\n"");
				buffer.indentLine(caretLine,true);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	public void insertTabAndIndent()
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(getSelectionCount() == 0)
		{
			
			CharSequence text = buffer.getLineSegment(caretLine);
			int start = buffer.getLineStartOffset(caretLine);
			int whiteSpace = StandardUtilities.getLeadingWhiteSpace(text);

			if(caret - start <= whiteSpace
				&& buffer.indentLine(caretLine,false))
				return;
		}

		userInput('\t');
	} 

	
	
	public void indentSelectedLines()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.indentLines(getSelectedLines());
			selectNone();
		}
	} 

	
	
	public void shiftIndentLeft()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.shiftIndentLeft(getSelectedLines());
		}
	} 

	
	
	public void shiftIndentRight()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
			buffer.shiftIndentRight(getSelectedLines());
	} 

	
	
	public void joinLines()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		try
		{
			buffer.beginCompoundEdit();
			boolean doneForSelection = false;
			for (Selection selection: selectionManager.getSelection())
			{
				while (selection.startLine < selection.endLine)
				{
					
					
					
					
					joinLineAt(selection.endLine - 1);
					doneForSelection = true;
				}
			}
			
			
			if (!doneForSelection)
			{
				int end = getLineEndOffset(caretLine);

				
				if (end > buffer.getLength())
				{
					getToolkit().beep();
					return;
				}

				joinLineAt(caretLine);
				if(!multi)
					selectNone();
				moveCaretPosition(end - 1);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 
	

	

	
	
	public void addLeftOfScrollBar(Component comp)
	{
		verticalBox.add(comp, 0);
	} 

	
	
	public void removeLeftOfScrollBar(Component comp)
	{
		verticalBox.remove(comp);
	} 

	
	
	@Override
	public void addNotify()
	{
		super.addNotify();

		ToolTipManager.sharedInstance().registerComponent(painter);
		ToolTipManager.sharedInstance().registerComponent(gutter);

		recalculateVisibleLines();
		if(!buffer.isLoading())
			recalculateLastPhysicalLine();
		propertiesChanged();

		hiddenCursor = getToolkit().createCustomCursor(
			getGraphicsConfiguration()
			.createCompatibleImage(16,16,
			Transparency.BITMASK),
			new Point(0,0),""Hidden"");
	} 

	
	
	@Override
	public void removeNotify()
	{
		super.removeNotify();

		ToolTipManager.sharedInstance().unregisterComponent(painter);
		ToolTipManager.sharedInstance().unregisterComponent(gutter);

		if(focusedComponent == this)
			focusedComponent = null;

		caretTimer.stop();
	} 

	
	
	@Override
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	
	
	public boolean getFocusCycleRoot()
	{
		return true;
	} 

	
	@Override
	public void processKeyEvent(KeyEvent evt)
	{
		getInputHandler().processKeyEvent(evt, 1 , false);
		if(!evt.isConsumed())
			super.processKeyEvent(evt);

	} 

	
	
	public void addTopComponent(Component comp)
	{
		add(ScrollLayout.TOP,comp);
	} 

	
	
	public void removeTopComponent(Component comp)
	{
		remove(comp);
	} 

	
	@Override
	public InputMethodRequests getInputMethodRequests()
	{
		if(inputMethodSupport == null)
		{
			inputMethodSupport = new InputMethodSupport(this);
			Log.log(Log.DEBUG, this, ""InputMethodSupport is activated"");
		}
		return inputMethodSupport;
	} 
	

	
	
	public final void addStatusListener(StatusListener listener)
	{
		listenerList.add(StatusListener.class,listener);
	} 

	
	
	public final void removeStatusListener(StatusListener listener)
	{
		listenerList.remove(StatusListener.class,listener);
	} 

	
	
	public void propertiesChanged()
	{
		if(buffer == null)
			return;

		int _tabSize = buffer.getTabSize();
		char[] foo = new char[_tabSize];
		for(int i = 0; i < foo.length; i++)
			foo[i] = ' ';

		tabSize = painter.getStringWidth(new String(foo));

		charWidth = (int)Math.round(
			painter.getFont().getStringBounds(foo,0,1,
			painter.getFontRenderContext()).getWidth());

		String oldWrap = wrap;
		wrap = buffer.getStringProperty(""wrap"");
		hardWrap = wrap.equals(""hard"");
		softWrap = wrap.equals(""soft"");
		boolean oldWrapToWidth = wrapToWidth;
		int oldWrapMargin = wrapMargin;
		setMaxLineLength(buffer.getIntegerProperty(""maxLineLen"",0));

		boolean wrapSettingsChanged = !(wrap.equals(oldWrap)
			&& oldWrapToWidth == wrapToWidth
			&& oldWrapMargin == wrapMargin);

		if(displayManager != null && !bufferChanging
			&& !buffer.isLoading() && wrapSettingsChanged)
		{
			displayManager.invalidateScreenLineCounts();
			displayManager.notifyScreenLineChanges();
		}

		chunkCache.invalidateAll();
		gutter.repaint();
		painter.repaint();
	} 

	
	
	public void addActionSet(JEditActionSet<JEditBeanShellAction> actionSet)
	{
		actionContext.addActionSet(actionSet);
	} 

	
	
	@Deprecated
	public final int getMarkPosition()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return caret;

		if(s.start == caret)
			return s.end;
		else if(s.end == caret)
			return s.start;
		else
			return caret;
	} 

	
	
	@Deprecated
	public final int getMarkLine()
	{
		if(getSelectionCount() != 1)
			return caretLine;

		Selection s = getSelection(0);
		if(s.start == caret)
			return s.endLine;
		else if(s.end == caret)
			return s.startLine;
		else
			return caretLine;
	} 

	

	static TextArea focusedComponent;

	
	MouseInputAdapter mouseHandler;
	final ChunkCache chunkCache;
	DisplayManager displayManager;
	final SelectionManager selectionManager;
	
	private JEditActionContext<JEditBeanShellAction,JEditActionSet<JEditBeanShellAction>> actionContext;
	boolean bufferChanging;

	int maxHorizontalScrollWidth;

	String wrap;
	boolean hardWrap;
	boolean softWrap;
	boolean wrapToWidth;
	int maxLineLen;
	int wrapMargin;
	float tabSize;
	int charWidth;

	boolean scrollBarsInitialized;

	
	final Point offsetXY;

	boolean lastLinePartial;

	boolean blink;
	

	
	
	final boolean isCaretVisible()
	{
		return blink && hasFocus();
	} 

	
	
	final boolean isStructureHighlightVisible()
	{
		return match != null
			&& hasFocus()
			&& displayManager.isLineVisible(match.startLine)
			&& displayManager.isLineVisible(match.endLine);
	} 

	
	void updateMaxHorizontalScrollWidth()
	{
		int max = chunkCache.getMaxHorizontalScrollWidth();

		if(max != maxHorizontalScrollWidth)
		{
			maxHorizontalScrollWidth = max;
			horizontal.setValues(Math.max(0,
				Math.min(maxHorizontalScrollWidth + charWidth
				- painter.getWidth(),
				-horizontalOffset)),
				painter.getWidth(),
				0,maxHorizontalScrollWidth
				+ charWidth);
			horizontal.setUnitIncrement(10);
			horizontal.setBlockIncrement(painter.getWidth());
		}
		else if (horizontal.getValue() != -horizontalOffset)
		{
			horizontal.setValue(-horizontalOffset);
		}
	} 

	
	void recalculateVisibleLines()
	{
		if(painter == null)
			return;
		int height = painter.getHeight();
		int lineHeight = painter.getFontMetrics().getHeight();
		if(lineHeight == 0)
			visibleLines = 0;
		else if(height <= 0)
		{
			visibleLines = 0;
			lastLinePartial = false;
		}
		else
		{
			visibleLines = height / lineHeight;
			lastLinePartial = height % lineHeight != 0;
			if(lastLinePartial)
				visibleLines++;
		}

		chunkCache.recalculateVisibleLines();

		
		if(displayManager != null && buffer != null && !buffer.isLoading())
			setFirstLine(getFirstLine());

		updateScrollBar();
	} 

	
	void foldStructureChanged()
	{
		chunkCache.invalidateAll();
		recalculateLastPhysicalLine();
		repaint();
	} 

	
	
	void updateScrollBar()
	{
		if(buffer == null)
			return;

		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""updateScrollBar(), slc=""
				+ displayManager.getScrollLineCount());

		if(vertical != null && visibleLines != 0)
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""Vertical ok"");
			int lineCount = displayManager.getScrollLineCount();
			int firstLine = getFirstLine();
			int visible = visibleLines - (lastLinePartial ? 1 : 0);

			vertical.setValues(firstLine,visible,0,lineCount);
			vertical.setUnitIncrement(2);
			vertical.setBlockIncrement(visible);
		}
	} 

	
	
	void _finishCaretUpdate()
	{
		if(!queuedCaretUpdate)
			return;

		try
		{
			if(match != null)
			{
				if(oldCaretLine < match.startLine)
					invalidateLineRange(oldCaretLine,match.endLine);
				else
					invalidateLineRange(match.startLine,oldCaretLine);
				match = null;
			}

			int newCaretScreenLine = chunkCache.getScreenLineOfOffset(caretLine,
				caret - buffer.getLineStartOffset(caretLine));
			if(caretScreenLine == -1)
				invalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);
			else
				invalidateScreenLineRange(caretScreenLine,newCaretScreenLine);
			caretScreenLine = newCaretScreenLine;

			invalidateSelectedLines();

			
			
			blink = true;
			caretTimer.restart();

			if(!displayManager.isLineVisible(caretLine))
			{
				if(caretLine < displayManager.getFirstVisibleLine()
					|| caretLine > displayManager.getLastVisibleLine())
				{
					int collapseFolds = buffer.getIntegerProperty(
						""collapseFolds"",0);
					if(collapseFolds != 0)
					{
						displayManager.expandFolds(collapseFolds);
						displayManager.expandFold(caretLine,false);
					}
					else
						displayManager.expandAllFolds();
				}
				else
					displayManager.expandFold(caretLine,false);
			}

			if(queuedScrollMode == ELECTRIC_SCROLL)
				scrollToCaret(true);
			else if(queuedScrollMode == NORMAL_SCROLL)
				scrollToCaret(false);

			updateBracketHighlightWithDelay();
			if(queuedFireCaretEvent)
				fireCaretEvent();
		}
		
		
		finally
		{
			queuedCaretUpdate = queuedFireCaretEvent = false;
			queuedScrollMode = NO_SCROLL;
		}
	} 

	
	void invalidateStructureMatch()
	{
		if(match != null)
			invalidateLineRange(match.startLine,match.endLine);
	} 

	
	void startDragAndDrop(InputEvent evt, boolean copy)
	{
		TransferHandler transferHandler = getTransferHandler();
		if (transferHandler != null)
		{
			Log.log(Log.DEBUG,this,""Drag and drop callback"");
			transferHandler.exportAsDrag(this,evt,
				copy ? TransferHandler.COPY
				: TransferHandler.MOVE);
		}
	} 

	
	void fireNarrowActive()
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == StatusListener.class)
			{
				try
				{
					((StatusListener)listeners[i+1])
						.narrowActive(this);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	

	

	
	private static final Timer caretTimer;
	private static final Timer structureTimer;
	

	
	protected JPopupMenu popup;

	private boolean popupEnabled;
	protected Cursor hiddenCursor;

	private final Gutter gutter;
	protected final TextAreaPainter painter;

	private final EventListenerList listenerList;
	private final MutableCaretEvent caretEvent;

	private boolean caretBlinks;
	protected InputHandlerProvider inputHandlerProvider;

	private InputMethodSupport inputMethodSupport;

	
	private int physLastLine;

	
	private int screenLastLine;

	
	private int visibleLines;
	private int electricScroll;

	private int horizontalOffset;

	private boolean quickCopy;

	
	private final Box verticalBox;
	private final JScrollBar vertical;
	private final JScrollBar horizontal;

	protected JEditBuffer buffer;

	protected int caret;
	protected int caretLine;
	private int caretScreenLine;

	private final java.util.List<StructureMatcher> structureMatchers;
	private StructureMatcher.Match match;

	private int magicCaret;
	
	protected boolean multi;
	private boolean overwrite;
	private boolean rectangularSelectionMode;

	private boolean dndEnabled;
	private boolean dndInProgress;

	
	private boolean queuedCaretUpdate;
	private int queuedScrollMode;
	private boolean queuedFireCaretEvent;
	private int oldCaretLine;

	private boolean joinNonWordChars;
	private boolean ctrlForRectangularSelection;
	

	
	
	private void _setHorizontalOffset(int horizontalOffset)
	{
		if(horizontalOffset > 0)
			horizontalOffset = 0;

		if(horizontalOffset == this.horizontalOffset)
			return;

		
		int min = Math.min(-(maxHorizontalScrollWidth + charWidth - painter.getWidth()), 0);
		if(horizontalOffset < min)
			horizontalOffset = min;

		setHorizontalOffset(horizontalOffset);
	} 

	
	
	private void invalidateSelectedLines()
	{
		
		invalidateLine(caretLine);

		for (Selection s : selectionManager.selection)
			invalidateLineRange(s.startLine,s.endLine);
	} 

	
	
	private void finishCaretUpdate(int oldCaretLine,
		int scrollMode, boolean fireCaretEvent)
	{
		queuedFireCaretEvent |= fireCaretEvent;
		queuedScrollMode = Math.max(scrollMode,queuedScrollMode);

		if(queuedCaretUpdate)
			return;

		this.oldCaretLine = oldCaretLine;
		queuedCaretUpdate = true;

		if(!buffer.isTransactionInProgress())
			_finishCaretUpdate();
		
	} 

	
	private void fireCaretEvent()
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == CaretListener.class)
			{
				try
				{
					((CaretListener)listeners[i+1]).caretUpdate(caretEvent);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	
	private void fireScrollEvent(boolean vertical)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == ScrollListener.class)
			{
				try
				{
					if(vertical)
						((ScrollListener)listeners[i+1]).scrolledVertically(this);
					else
						((ScrollListener)listeners[i+1]).scrolledHorizontally(this);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	
	private void fireStatusChanged(int flag, boolean value)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == StatusListener.class)
			{
				try
				{
					((StatusListener)listeners[i+1])
						.statusChanged(this,flag,value);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	
	private void fireBracketSelected(int line, String text)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == StatusListener.class)
			{
				try
				{
					((StatusListener)listeners[i+1])
						.bracketSelected(this,line,text);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	
	private void _changeLine(boolean select, int newCaret)
	{
		if(select)
		{
			RectParams params = getRectParams(caret,newCaret);
			int extraStartVirt;
			int extraEndVirt;
			if(params == null)
			{
				extraStartVirt = 0;
				extraEndVirt = 0;
			}
			else
			{
				extraStartVirt = params.extraStartVirt;
				extraEndVirt = params.extraEndVirt;
				newCaret = params.newCaret;
			}
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		}
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
	}

	
	
	private boolean lineContainsSpaceAndTabs(int lineIndex)
	{
		final Segment lineSegment = new Segment();
		getLineText(lineIndex,lineSegment);

		for(int j = 0; j < lineSegment.count; j++)
		{
			switch(lineSegment.array[lineSegment.offset + j])
			{
			case ' ':
			case '\t':
				break;
			default:
				return false;
			}
		}
		return true;
	} 

	
	protected void insert(String str, boolean indent)
	{
		try
		{
			
			
			if(overwrite || indent)
				buffer.beginCompoundEdit();

			if(overwrite)
			{
				int caretLineEnd = getLineEndOffset(caretLine);
				if(caretLineEnd - caret > 1)
					buffer.remove(caret,1);
			}

			buffer.insert(caret,str);

			if(indent)
				buffer.indentLine(caretLine,true);
		}
		finally
		{
			if(overwrite || indent)
				buffer.endCompoundEdit();
		}
	} 

	
	private void insertTab()
	{
		int tabSize = buffer.getTabSize();
		if(buffer.getBooleanProperty(""noTabs""))
		{
			int lineStart = getLineStartOffset(caretLine);

			String line = getText(lineStart,caret - lineStart);

			int pos = 0;

			for(int i = 0; i < line.length(); i++)
			{
				switch(line.charAt(pos))
				{
				case '\t':
					pos = 0;
					break;
				default:
					if(++pos >= tabSize)
						pos = 0;
					break;
				}
			}

			replaceSelection(StandardUtilities.createWhiteSpace(
				tabSize - pos,0));
		}
		else
			replaceSelection(""\t"");
	} 

	
	protected void userInputTab()
	{
		if(getSelectionCount() == 1)
		{
			Selection sel = getSelection(0);
			if(sel instanceof Selection.Rect ||
				(sel.startLine == sel.endLine
				&& (sel.start != buffer.getLineStartOffset(sel.startLine)
				|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1)))
			{
				insertTab();
			}
			else
				shiftIndentRight();
		}
		else if(getSelectionCount() != 0)
			shiftIndentRight();
		else
			insertTab();
	} 

	
	
	protected boolean doWordWrap(boolean spaceInserted)
	{
		if(!hardWrap || maxLineLen <= 0)
			return false;

		final Segment lineSegment = new Segment();
		buffer.getLineText(caretLine,lineSegment);

		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		int len = end - start - 1;

		int caretPos = caret - start;

		
		
		for(int i = caretPos; i < len; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch != ' ' && ch != '\t')
				return false;
		}

		int tabSize = buffer.getTabSize();

		String wordBreakChars = buffer.getStringProperty(""wordBreakChars"");

		int lastInLine = 0; 
		int logicalLength = 0; 
		int lastWordOffset = -1;
		boolean lastWasSpace = true;
		for(int i = 0; i < caretPos; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch == '\t')
			{
				logicalLength += tabSize - (logicalLength % tabSize);
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(ch == ' ')
			{
				logicalLength++;
				if(!lastWasSpace &&
					logicalLength <= maxLineLen + 1)
				{
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)
			{
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else
			{
				lastInLine = i;
				logicalLength++;
				lastWasSpace = false;
			}
		}

		boolean returnValue;

		int insertNewLineAt;
		if(spaceInserted && logicalLength == maxLineLen
			&& lastInLine == caretPos - 1)
		{
			insertNewLineAt = caretPos;
			returnValue = true;
		}
		else if(logicalLength >= maxLineLen && lastWordOffset != -1)
		{
			insertNewLineAt = lastWordOffset;
			returnValue = false;
		}
		else
			return false;

		try
		{
			buffer.beginCompoundEdit();
			buffer.insert(start + insertNewLineAt,""\n"");
			
			
			buffer.indentLine(caretLine,true);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		
		return returnValue;
	} 

	
	private static void updateBracketHighlightWithDelay()
	{
		structureTimer.stop();
		structureTimer.start();
	} 

	
	private void updateStructureHighlight()
	{
		if(!painter.isStructureHighlightEnabled()
			&& !gutter.isStructureHighlightEnabled())
			return;

		for (StructureMatcher matcher : structureMatchers)
		{
			match = matcher.getMatch(this);
			if(match != null)
				break;
		}

		if(match != null)
		{
			if(caretLine < match.startLine)
				invalidateLineRange(caretLine,match.endLine);
			else
				invalidateLineRange(match.startLine,caretLine);

			if(!displayManager.isLineVisible(match.startLine)
				|| chunkCache.getScreenLineOfOffset(
				match.startLine,match.start - getLineStartOffset(match.startLine))
				== -1)
			{
				showStructureStatusMessage(match.startLine < caretLine);
			}
		}
	} 

	
	private void showStructureStatusMessage(boolean backward)
	{
		String text = buffer.getLineText(match.startLine).trim();
		if(backward && match.startLine != 0 && text.length() == 1)
		{
			switch(text.charAt(0))
			{
			case '{': case '}':
			case '[': case ']':
			case '(': case ')':
				text = buffer.getLineText(match.startLine - 1)
					.trim() + ' ' + text;
				break;
			}
		}

		
		fireBracketSelected(match.startLine + 1,text.replace('\t',' '));
	} 

	
	void recalculateLastPhysicalLine()
	{
		int oldScreenLastLine = screenLastLine;
		for(int i = visibleLines - 1; i >= 0; i--)
		{
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if(info.physicalLine != -1)
			{
				physLastLine = info.physicalLine;
				screenLastLine = i;
				break;
			}
		}
		invalidateScreenLineRange(oldScreenLastLine,screenLastLine);
	} 

	
	private static class RectParams
	{
		final int extraStartVirt;
		final int extraEndVirt;
		final int newCaret;

		RectParams(int extraStartVirt, int extraEndVirt, int newCaret)
		{
			this.extraStartVirt = extraStartVirt;
			this.extraEndVirt = extraEndVirt;
			this.newCaret = newCaret;
		}
	}

	
	private RectParams getRectParams(int caret, int newCaret)
	{
		Selection s = getSelectionAtOffset(caret);
		int virtualWidth;
		if(s instanceof Selection.Rect)
		{
			if(caret == s.end)
			{
				virtualWidth = buffer.getVirtualWidth(
					s.endLine,s.end - getLineStartOffset(
					s.endLine)) + ((Selection.Rect)s).extraEndVirt;
			}
			else
			{
				virtualWidth = buffer.getVirtualWidth(
					s.startLine,s.start - getLineStartOffset(
					s.startLine)) + ((Selection.Rect)s).extraStartVirt;
			}
		}
		else if(rectangularSelectionMode)
		{
			virtualWidth = buffer.getVirtualWidth(
				caretLine,caret - buffer.getLineStartOffset(caretLine));
		}
		else
			return null;

		int newLine = getLineOfOffset(newCaret);
		int[] totalVirtualWidth = new int[1];
		int newOffset = buffer.getOffsetOfVirtualColumn(newLine,
			virtualWidth,totalVirtualWidth);
		if(newOffset == -1)
		{
			int extraVirt = virtualWidth - totalVirtualWidth[0];
			newCaret = getLineEndOffset(newLine) - 1;

			boolean bias;
			if(s == null)
				bias = newCaret < caret;
			else if(s.start == caret)
				bias = newCaret <= s.end;
			else if(s.end == caret)
				bias = newCaret <= s.start;
			else
				bias = false;

			RectParams returnValue;
			if(bias)
				returnValue = new RectParams(extraVirt,0,newCaret);
			else
				returnValue = new RectParams(0,extraVirt,newCaret);
			return returnValue;
		}
		else
		{
			return new RectParams(0,0,getLineStartOffset(newLine)
				+ newOffset);
		}
	} 

	
	private void delete(boolean forward)
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(getSelectionCount() != 0)
		{
			Selection[] selections = getSelection();
			for(int i = 0; i < selections.length; i++)
			{
				Selection s = selections[i];
				if(s instanceof Selection.Rect)
				{
					Selection.Rect r = (Selection.Rect)s;
					int startColumn = r.getStartColumn(buffer);
					if(startColumn == r.getEndColumn(buffer))
					{
						if(!forward && startColumn == 0)
							getToolkit().beep();
						else
							tallCaretDelete(r,forward);
					}
					else
						setSelectedText(s,null);
				}
				else
					setSelectedText(s,null);
			}
		}
		else if(forward)
		{
			if(caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}

			buffer.remove(caret,1);
		}
		else
		{
			if(caret == 0)
			{
				getToolkit().beep();
				return;
			}

			buffer.remove(caret - 1,1);
		}
	} 

	
	private void tallCaretDelete(Selection.Rect s, boolean forward)
	{
		try
		{
			buffer.beginCompoundEdit();

			int[] width = new int[1];

			int startCol = s.getStartColumn(buffer);
			int startLine = s.startLine;
			int endLine = s.endLine;
			for(int i = startLine; i <= endLine; i++)
			{
				int offset = buffer.getOffsetOfVirtualColumn(
					i,startCol,width);
				if(offset == -1)
				{
					if(width[0] == startCol)
						offset = getLineLength(i);
					else
					{
						if(i == startLine && !forward)
							shiftTallCaretLeft(s);
						continue;
					}
				}
				offset += buffer.getLineStartOffset(i);
				if(forward)
				{
					if(offset != buffer.getLineEndOffset(i) - 1)
						buffer.remove(offset,1);
				}
				else
					buffer.remove(offset-1,1);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	
	private void shiftTallCaretLeft(Selection.Rect s)
	{
		removeFromSelection(s);
		addToSelection(new Selection.Rect(
			buffer,
			s.getStartLine(),s.getStartColumn(buffer) - 1,
			s.getEndLine(),s.getEndColumn(buffer) - 1));
	} 

	
	private void setMaxLineLength(int maxLineLen)
	{
		this.maxLineLen = maxLineLen;

		if(maxLineLen <= 0)
		{
			if(softWrap)
			{
				wrapToWidth = true;
				wrapMargin = painter.getWidth() - charWidth * 3;
			}
			else
			{
				wrapToWidth = false;
				wrapMargin = 0;
			}
		}
		else
		{
			
			char[] foo = new char[maxLineLen];
			for(int i = 0; i < foo.length; i++)
			{
				foo[i] = ' ';
			}
			wrapToWidth = false;
			wrapMargin = (int)painter.getFont().getStringBounds(
				foo,0,foo.length,
				painter.getFontRenderContext())
				.getWidth();
		}
	} 

	
	
	protected int addExplicitFold(int caretStart, int caretEnd, int lineStart, int lineEnd)
	{
		
		
		
		
		
		int startCaret = caretStart < buffer.getLength() ? caretStart + 1 : caretStart;
		int endCaret = caretEnd > 0 ? caretEnd - 1 : caretEnd;

		String startLineComment = buffer.getContextSensitiveProperty(startCaret,""lineComment"");
		String startCommentStart = buffer.getContextSensitiveProperty(startCaret,""commentStart"");
		String startCommentEnd = buffer.getContextSensitiveProperty(startCaret,""commentEnd"");
		String endLineComment = buffer.getContextSensitiveProperty(endCaret,""lineComment"");
		String endCommentStart = buffer.getContextSensitiveProperty(endCaret,""commentStart"");
		String endCommentEnd = buffer.getContextSensitiveProperty(endCaret,""commentEnd"");

		String start;
		int caretBack = 1;
		if(startLineComment != null)
			start = startLineComment + ""{{{ "";
		else if(startCommentStart != null && startCommentEnd != null)
		{
			start = startCommentStart + ""{{{  "" + startCommentEnd;
			caretBack = 2 + startCommentEnd.length();
		}
		else
			start = ""{{{ "";

		if (startLineComment != null)
		{
			
			
			if (buffer.getLineLength(lineStart) != caretStart)
			{
				start += '\n';
			}
		}
		else
		{
			
			start += ""\n"";
		}

		String end;
		if(endLineComment != null)
			end = endLineComment + ""}}}"";
		else if(endCommentStart != null && endCommentEnd != null)
			end = endCommentStart + ""}}}"" + endCommentEnd;
		else
			end = ""}}}"";

		String line = buffer.getLineText(lineStart);
		String whitespace = line.substring(0,
			StandardUtilities.getLeadingWhiteSpace(line));
		caretBack += whitespace.length(); 
		if (endLineComment != null)
		{
			
			
			
			if (buffer.getLineLength(lineEnd) != caretEnd)
			{
				end += '\n';
			}
		}
		else
		{
			
			end += ""\n"";
		}

		if(caretEnd == buffer.getLineStartOffset(lineEnd))
			buffer.insert(caretEnd,end);
		else
		{
			CharSequence lineText = buffer.getSegment(caretEnd - 1, 1);
			if (Character.isWhitespace(lineText.charAt(0)))
				buffer.insert(caretEnd, end);
			else
				buffer.insert(caretEnd,' ' + end);
		}

		buffer.insert(caretStart,start + whitespace);

		return caretBack;
	} 

	
	
	private void rangeLineComment()
	{
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null
			|| commentStart.length() == 0 || commentEnd.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		commentStart += ' ';
		commentEnd = ' ' + commentEnd;


		try
		{
			buffer.beginCompoundEdit();
			int[] lines = getSelectedLines();
			for(int i = 0; i < lines.length; i++)
			{
				String text = getLineText(lines[i]);
				if (text.trim().length() == 0)
					continue;
				buffer.insert(getLineEndOffset(lines[i]) - 1,
					commentEnd);
				buffer.insert(getLineStartOffset(lines[i])
					+ StandardUtilities.getLeadingWhiteSpace(text),
					commentStart);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	
	
	private void joinLineAt(int line)
	{
		if (line >= buffer.getLineCount() - 1)
			return;
		int end = getLineEndOffset(line);
		CharSequence nextLineText = buffer.getLineSegment(line + 1);
		buffer.remove(end - 1,StandardUtilities.getLeadingWhiteSpace(
			nextLineText) + 1);
		if (nextLineText.length() != 0)
			buffer.insert(end - 1, "" "");
	} 
	

	
	
	public boolean isRightClickPopupEnabled()
	{
		return popupEnabled;
	} 

	
	
	public void setRightClickPopupEnabled(boolean popupEnabled)
	{
		this.popupEnabled = popupEnabled;
	} 

	
	
	public final JPopupMenu getRightClickPopup()
	{
		return popup;
	} 

	
	
	public final void setRightClickPopup(JPopupMenu popup)
	{
		this.popup = popup;
	} 

	
	
	public void handlePopupTrigger(MouseEvent evt)
	{
		
		createPopupMenu(evt);

		int x = evt.getX();
		int y = evt.getY();

		int dragStart = xyToOffset(x,y,
			!(painter.isBlockCaretEnabled()
			|| isOverwriteEnabled()));

		if(getSelectionCount() == 0 || multi)
			moveCaretPosition(dragStart,false);
		showPopupMenu(popup,this,x,y,false);
	} 

	
	
	public void createPopupMenu(MouseEvent evt)
	{
		if (popup == null)
			popup = new JPopupMenu();
	} 

	
	
	public void showPopupMenu()
	{
		if (!popup.isVisible() && hasFocus())
		{
			Point caretPos = offsetToXY(getCaretPosition());
			if (caretPos != null)
			{
				
				int charHeight = getPainter().getFontMetrics().getHeight();
				showPopupMenu(popup,
					painter,caretPos.x,caretPos.y + charHeight,true);
			}
		}
	} 

	
	
	private static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y, boolean point)
	{
		int offsetX = 0;
		int offsetY = 0;

		int extraOffset = point ? 1 : 0;

		Component win = comp;
		while(!(win instanceof Window || win == null))
		{
			offsetX += win.getX();
			offsetY += win.getY();
			win = win.getParent();
		}

		if(win != null)
		{
			Dimension size = popup.getPreferredSize();

			Rectangle screenSize = GraphicsEnvironment
				.getLocalGraphicsEnvironment().getMaximumWindowBounds();

			if(x + offsetX + size.width + win.getX() > screenSize.width
				&& x + offsetX + win.getX() >= size.width)
			{
				
				if(point)
					x -= size.width + extraOffset;
				else
					x = win.getWidth() - size.width - offsetX + extraOffset;
			}
			else
			{
				x += extraOffset;
			}

			
			
			
			if(y + offsetY + size.height + win.getY() > screenSize.height
				&& y + offsetY + win.getY() >= size.height)
			{
				if(point)
					y = win.getHeight() - size.height - offsetY + extraOffset;
				else
					y = -size.height - 1;
			}
			else
			{
				y += extraOffset;
			}

			popup.show(comp,x,y);
		}
		else
			popup.show(comp,x + extraOffset,y + extraOffset);

	} 

	

	
	private static class CaretBlinker implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(focusedComponent != null && focusedComponent.hasFocus())
				focusedComponent.blinkCaret();
		} 
	} 

	
	private class MutableCaretEvent extends CaretEvent
	{
		
		MutableCaretEvent()
		{
			super(TextArea.this);
		} 

		
		@Override
		public int getDot()
		{
			return getCaretPosition();
		} 

		
		@Override
		public int getMark()
		{
			return getMarkPosition();
		} 
	} 

	
	private class AdjustHandler implements AdjustmentListener
	{
		
		public void adjustmentValueChanged(AdjustmentEvent evt)
		{
			if(!scrollBarsInitialized)
				return;

			if(evt.getAdjustable() == vertical)
				setFirstLine(vertical.getValue());
			else
				setHorizontalOffset(-horizontal.getValue());
		} 
	} 

	
	private class FocusHandler implements FocusListener
	{
		
		public void focusGained(FocusEvent evt)
		{
			if(bufferChanging)
				return;

			if(match != null)
			{
				if(caretLine < match.startLine)
					invalidateLineRange(caretLine,match.endLine);
				else
					invalidateLineRange(match.startLine,caretLine);
			}
			else
				invalidateLine(caretLine);

			focusedComponent = TextArea.this;
		} 

		
		public void focusLost(FocusEvent evt)
		{
			if(!isShowing())
				return;

			if(match != null)
			{
				if(caretLine < match.startLine)
					invalidateLineRange(caretLine,match.endLine);
				else
					invalidateLineRange(match.startLine,caretLine);
			}
			else
				invalidateLine(caretLine);
		} 
	} 

	
	private class MouseWheelHandler implements MouseWheelListener
	{
		public void mouseWheelMoved(MouseWheelEvent e)
		{
			
			if(e.isAltDown())
			{
				boolean select = e.isShiftDown()
					|| e.isControlDown();
				if(e.getWheelRotation() < 0)
					goToPrevLine(select);
				else
					goToNextLine(select);
			}
			else if(e.getScrollType()
				== MouseWheelEvent.WHEEL_BLOCK_SCROLL)
			{
				if(e.isShiftDown())
				{
					
					_setHorizontalOffset(getHorizontalOffset()
						+ (e.getWheelRotation() > 0 ? 1 : -1) * painter.getWidth());
				}
				else
				{
					if(e.getWheelRotation() > 0)
						scrollDownPage();
					else
						scrollUpPage();
				}
			}
			else if(e.isControlDown() && e.isShiftDown())
			{
				if(e.getWheelRotation() > 0)
					scrollDownPage();
				else
					scrollUpPage();
			}
			else if(e.isControlDown())
			{
				setFirstLine(getFirstLine()
					+ e.getWheelRotation());
			}
			else if(e.getScrollType()
				== MouseWheelEvent.WHEEL_UNIT_SCROLL)
			{
				if(e.isShiftDown())
				{
					_setHorizontalOffset(getHorizontalOffset()
						+ (-charWidth * e.getUnitsToScroll()));
				}
				else
				{
					setFirstLine(getFirstLine()
						+ e.getUnitsToScroll());
				}
			}
			else
			{
				if(e.isShiftDown())
				{
					_setHorizontalOffset(getHorizontalOffset()
						+ (-charWidth * e.getWheelRotation()));
				}
				else
				{
					setFirstLine(getFirstLine()
						+ 3 * e.getWheelRotation());
				}
			}
		}
	} 

	

	
	static
	{
		caretTimer = new Timer(500,new CaretBlinker());
		caretTimer.setInitialDelay(500);
		caretTimer.start();

		structureTimer = new Timer(100,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(focusedComponent != null)
					focusedComponent.updateStructureHighlight();
			}
		});
		structureTimer.setInitialDelay(100);
		structureTimer.setRepeats(false);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.HistoryModel,13,3,0,17,28,52,15,2,13,0.8,135,1.0,1,0.764705882,0.261538462,0,0,9.0,5,1.6923,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.DefaultListModel;
import java.util.*;



public class HistoryModel extends DefaultListModel
	implements MutableListModel
{
	
	
	public HistoryModel(String name)
	{
		this.name = name;
	} 

	
	
	public void addItem(String text)
	{
		if(text == null || text.length() == 0)
			return;

		int index = indexOf(text);
		if(index != -1)
			removeElementAt(index);

		insertElementAt(text,0);

		while(getSize() > max)
			removeElementAt(getSize() - 1);
	} 

	
	public void insertElementAt(Object obj, int index)
	{
		modified = true;
		super.insertElementAt(obj,index);
	} 

	
	
	public String getItem(int index)
	{
		return (String)elementAt(index);
	} 

	
	public boolean removeElement(Object obj)
	{
		modified = true;
		return super.removeElement(obj);
	} 

	
	
	public void clear()
	{
		removeAllElements();
	} 

	
	public void removeAllElements()
	{
		modified = true;
		super.removeAllElements();
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public static HistoryModel getModel(String name)
	{
		if(models == null)
			models = Collections.synchronizedMap(new HashMap<String, HistoryModel>());

		HistoryModel model = models.get(name);
		if(model == null)
		{
			model = new HistoryModel(name);
			models.put(name,model);
		}

		return model;
	} 

	
	public static void loadHistory()
	{
		if (saver != null)
			models = saver.load(models);
	} 

	
	public static void saveHistory()
	{
		if (saver != null && modified && saver.save(models))
			modified = false;
	} 

	
	public static void setMax(int max)
	{
		HistoryModel.max = max;
	} 

	
	public static void setSaver(HistoryModelSaver saver)
	{
		HistoryModel.saver = saver;
	} 

	
	private static int max;

	private String name;
	private static Map<String, HistoryModel> models;

	private static boolean modified;
	private static HistoryModelSaver saver;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.visitors.JEditVisitorAdapter,4,1,5,9,5,6,5,4,4,2.0,10,0.0,0,0.0,0.4375,0,0,1.5,1,0.75,0,"

package org.gjt.sp.jedit.visitors;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;



public class JEditVisitorAdapter implements JEditVisitor
{
	
	public void visit(View view)
	{
	}
		   
	
	public void visit(EditPane editPane)
	{
	}

	
	public void visit(JEditTextArea textArea)
	{
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.PasteFromListDialog,10,7,0,10,69,19,4,10,3,0.740740741,403,1.0,2,0.986466165,0.26,0,0,38.7,4,1.7,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;


public class PasteFromListDialog extends EnhancedDialog
{
	
	public PasteFromListDialog(String name, View view, MutableListModel model)
	{
		super(view,jEdit.getProperty(name + "".title""),true);
		this.view = view;
		this.listModel = model;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel center = new JPanel(new GridLayout(2,1,2,12));

		clips = new JList(model);
		clips.setCellRenderer(new Renderer());
		clips.setVisibleRowCount(12);

		clips.addMouseListener(new MouseHandler());
		clips.addListSelectionListener(new ListHandler());

		insert = new JButton(jEdit.getProperty(""common.insert""));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));

		JLabel label = new JLabel(jEdit.getProperty(name + "".caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);

		JScrollPane scroller = new JScrollPane(clips);
		scroller.setPreferredSize(new Dimension(500,150));
		center.add(scroller);

		clipText = new JTextArea();
		clipText.setEditable(false);
		scroller = new JScrollPane(clipText);
		scroller.setPreferredSize(new Dimension(500,150));
		center.add(scroller);

		content.add(center, BorderLayout.CENTER);

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		panel.add(insert);
		panel.add(Box.createHorizontalStrut(6));
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel, BorderLayout.SOUTH);

		if(model.getSize() >= 1)
			clips.setSelectedIndex(0);
		updateButtons();

		getRootPane().setDefaultButton(insert);
		insert.addActionListener(new ActionHandler());
		cancel.addActionListener(new ActionHandler());

		GUIUtilities.requestFocus(this,clips);

		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} 

	
	public void ok()
	{
		Object[] selected = clips.getSelectedValues();
		if(selected == null || selected.length == 0)
		{
			getToolkit().beep();
			return;
		}

		String text = getSelectedClipText();

		
		for(int i = 0; i < selected.length; i++)
		{
			listModel.removeElement(selected[i]);
			listModel.insertElementAt(selected[i],0);
		}

		view.getTextArea().setSelectedText(text);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	

	
	private View view;
	private MutableListModel listModel;
	private JList clips;
	private JTextArea clipText;
	private JButton insert;
	private JButton cancel;
	

	
	private String getSelectedClipText()
	{
		Object[] selected = clips.getSelectedValues();
		StringBuilder clip = new StringBuilder();
		for(int i = 0; i < selected.length; i++)
		{
			if(i != 0)
				clip.append('\n');
			clip.append(selected[i]);
		}
		return clip.toString();
	}
	

	
	private void updateButtons()
	{
		int selected = clips.getSelectedIndex();
		insert.setEnabled(selected != -1);
	} 

	
	private void showClipText()
	{
		Object[] selected = clips.getSelectedValues();
		if(selected == null || selected.length == 0)
			clipText.setText("""");
		else
			clipText.setText(getSelectedClipText());
		clipText.setCaretPosition(0);
	}
	

	

	
	class Renderer extends DefaultListCellRenderer
	{
		String shorten(String item)
		{
			StringBuilder buf = new StringBuilder();
			
			
			if(item.toLowerCase().startsWith(""<html>""))
				buf.append(' ');
			boolean ws = true;
			for(int i = 0; i < item.length(); i++)
			{
				char ch = item.charAt(i);
				if(Character.isWhitespace(ch))
				{
					if(ws)
						;
					else
					{
						buf.append(' ');
						ws = true;
					}
				}
				else
				{
					ws = false;
					buf.append(ch);
				}
			}

			if(buf.length() == 0)
				return jEdit.getProperty(""paste-from-list.whitespace"");
			return buf.toString();
		}

		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			setText(shorten(value.toString()));

			return this;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == insert)
				ok();
			else if(source == cancel)
				cancel();
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		
		public void valueChanged(ListSelectionEvent evt)
		{
			showClipText();
			updateButtons();
		} 
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			if(evt.getClickCount() == 2)
				ok();
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHVariableDeclarator,3,2,0,11,14,3,3,8,2,1.0,61,0.0,0,0.894736842,0.466666667,1,3,19.0,1,0.6667,0,"


package org.gjt.sp.jedit.bsh;


class BSHVariableDeclarator extends SimpleNode
{
	
    public String name;

    BSHVariableDeclarator(int id) { super(id); }

	
    public Object eval( 
		BSHType typeNode, CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		
		Object value = null;

        if ( jjtGetNumChildren() > 0 ) 
		{
            SimpleNode initializer = (SimpleNode)jjtGetChild(0);

			
			if ( (typeNode != null) 
				&& initializer instanceof BSHArrayInitializer 
			)
            	value = ((BSHArrayInitializer)initializer).eval( 
					typeNode.getBaseType(), typeNode.getArrayDims(), 
					callstack, interpreter);
			else
				value = initializer.eval( callstack, interpreter);
		}

		if ( value == Primitive.VOID )
            throw new EvalError(""Void initializer."", this, callstack );

        return value;
    }

	public String toString() { return ""BSHVariableDeclarator ""+name; }
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.Type,24,1,0,1,41,198,1,0,18,0.824275362,749,0.166666667,9,0.0,0.149758454,0,0,29.20833333,13,2.5833,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;

import java.lang.reflect.Method;



public class Type {

  

  public final static int VOID = 0;

  

  public final static int BOOLEAN = 1;

  

  public final static int CHAR = 2;

  

  public final static int BYTE = 3;

  

  public final static int SHORT = 4;

  

  public final static int INT = 5;

  

  public final static int FLOAT = 6;

  

  public final static int LONG = 7;

  

  public final static int DOUBLE = 8;

  

  public final static int ARRAY = 9;

  

  public final static int OBJECT = 10;

  

  public final static Type VOID_TYPE = new Type(VOID);

  

  public final static Type BOOLEAN_TYPE = new Type(BOOLEAN);

  

  public final static Type CHAR_TYPE = new Type(CHAR);

  

  public final static Type BYTE_TYPE = new Type(BYTE);

  

  public final static Type SHORT_TYPE = new Type(SHORT);

  

  public final static Type INT_TYPE = new Type(INT);

  

  public final static Type FLOAT_TYPE = new Type(FLOAT);

  

  public final static Type LONG_TYPE = new Type(LONG);

  

  public final static Type DOUBLE_TYPE = new Type(DOUBLE);

  
  
  

  

  private final int sort;

  

  private char[] buf;

  

  private int off;

  

  private int len;

  
  
  

  

  private Type (final int sort) {
    this.sort = sort;
    this.len = 1;
  }

  

  private Type (
    final int sort,
    final char[] buf,
    final int off,
    final int len)
  {
    this.sort = sort;
    this.buf = buf;
    this.off = off;
    this.len = len;
  }

  

  public static Type getType (final String typeDescriptor) {
    return getType(typeDescriptor.toCharArray(), 0);
  }

  

  public static Type getType (final Class c) {
    if (c.isPrimitive()) {
      if (c == Integer.TYPE) {
        return INT_TYPE;
      } else if (c == Void.TYPE) {
        return VOID_TYPE;
      } else if (c == Boolean.TYPE) {
        return BOOLEAN_TYPE;
      } else if (c == Byte.TYPE) {
        return BYTE_TYPE;
      } else if (c == Character.TYPE) {
        return CHAR_TYPE;
      } else if (c == Short.TYPE) {
        return SHORT_TYPE;
      } else if (c == Double.TYPE) {
        return DOUBLE_TYPE;
      } else if (c == Float.TYPE) {
        return FLOAT_TYPE;
      } else  {
        return LONG_TYPE;
      }
    } else {
      return getType(getDescriptor(c));
    }
  }

  

  public static Type[] getArgumentTypes (final String methodDescriptor) {
    char[] buf = methodDescriptor.toCharArray();
    int off = 1;
    int size = 0;
    while (true) {
      char car = buf[off++];
      if (car == ')') {
        break;
      } else if (car == 'L') {
        while (buf[off++] != ';') {
        }
        ++size;
      } else if (car != '[') {
        ++size;
      }
    }
    Type[] args = new Type[size];
    off = 1;
    size = 0;
    while (buf[off] != ')') {
      args[size] = getType(buf, off);
      off += args[size].len;
      size += 1;
    }
    return args;
  }

  

  public static Type[] getArgumentTypes (final Method method) {
    Class[] classes = method.getParameterTypes();
    Type[] types = new Type[classes.length];
    for (int i = classes.length - 1; i >= 0; --i) {
      types[i] = getType(classes[i]);
    }
    return types;
  }

  

  public static Type getReturnType (final String methodDescriptor) {
    char[] buf = methodDescriptor.toCharArray();
    return getType(buf, methodDescriptor.indexOf(')') + 1);
  }

  

  public static Type getReturnType (final Method method) {
    return getType(method.getReturnType());
  }

  

  private static Type getType (final char[] buf, final int off) {
    int len;
    switch (buf[off]) {
      case 'V': return VOID_TYPE;
      case 'Z': return BOOLEAN_TYPE;
      case 'C': return CHAR_TYPE;
      case 'B': return BYTE_TYPE;
      case 'S': return SHORT_TYPE;
      case 'I': return INT_TYPE;
      case 'F': return FLOAT_TYPE;
      case 'J': return LONG_TYPE;
      case 'D': return DOUBLE_TYPE;
      case '[':
        len = 1;
        while (buf[off + len] == '[') {
          ++len;
        }
        if (buf[off + len] == 'L') {
          ++len;
          while (buf[off + len] != ';') {
            ++len;
          }
        }
        return new Type(ARRAY, buf, off, len + 1);
      
      default:
        len = 1;
        while (buf[off + len] != ';') {
          ++len;
        }
        return new Type(OBJECT, buf, off, len + 1);
    }
  }

  
  
  

  

  public int getSort () {
    return sort;
  }

  

  public int getDimensions () {
    int i = 1;
    while (buf[off + i] == '[') {
      ++i;
    }
    return i;
  }

  

  public Type getElementType () {
    return getType(buf, off + getDimensions());
  }

  

  public String getClassName () {
    return new String(buf, off + 1, len - 2).replace('/', '.');
  }

  

  public String getInternalName () {
    return new String(buf, off + 1, len - 2);
  }

  
  
  

  

  public String getDescriptor () {
    StringBuilder buf = new StringBuilder();
    getDescriptor(buf);
    return buf.toString();
  }

  

  public static String getMethodDescriptor (
    final Type returnType,
    final Type[] argumentTypes)
  {
    StringBuilder buf = new StringBuilder();
    buf.append('(');
    for (int i = 0; i < argumentTypes.length; ++i) {
      argumentTypes[i].getDescriptor(buf);
    }
    buf.append(')');
    returnType.getDescriptor(buf);
    return buf.toString();
  }

  

  private void getDescriptor(final StringBuilder buf) {
    switch (sort) {
      case VOID:    buf.append('V'); return;
      case BOOLEAN: buf.append('Z'); return;
      case CHAR:    buf.append('C'); return;
      case BYTE:    buf.append('B'); return;
      case SHORT:   buf.append('S'); return;
      case INT:     buf.append('I'); return;
      case FLOAT:   buf.append('F'); return;
      case LONG:    buf.append('J'); return;
      case DOUBLE:  buf.append('D'); return;
      
      
      default:      buf.append(this.buf, off, len);
    }
  }

  
  
  
  

  

  public static String getInternalName (final Class c) {
    return c.getName().replace('.', '/');
  }

  

  public static String getDescriptor (final Class c) {
    StringBuilder buf = new StringBuilder();
    getDescriptor(buf, c);
    return buf.toString();
  }

  

  public static String getMethodDescriptor (final Method m) {
    Class[] parameters = m.getParameterTypes();
    StringBuilder buf = new StringBuilder();
    buf.append('(');
    for (int i = 0; i < parameters.length; ++i) {
      getDescriptor(buf, parameters[i]);
    }
    buf.append(')');
    getDescriptor(buf, m.getReturnType());
    return buf.toString();
  }

  

  private static void getDescriptor (final StringBuilder buf, final Class c) {
    Class d = c;
    while (true) {
      if (d.isPrimitive()) {
        char car;
        if (d == Integer.TYPE) {
          car = 'I';
        } else if (d == Void.TYPE) {
          car = 'V';
        } else if (d == Boolean.TYPE) {
          car = 'Z';
        } else if (d == Byte.TYPE) {
          car = 'B';
        } else if (d == Character.TYPE) {
          car = 'C';
        } else if (d == Short.TYPE) {
          car = 'S';
        } else if (d == Double.TYPE) {
          car = 'D';
        } else if (d == Float.TYPE) {
          car = 'F';
        } else  {
          car = 'J';
        }
        buf.append(car);
        return;
      } else if (d.isArray()) {
        buf.append('[');
        d = d.getComponentType();
      } else {
        buf.append('L');
        String name = d.getName();
        int len = name.length();
        for (int i = 0; i < len; ++i) {
          char car = name.charAt(i);
          buf.append(car == '.' ? '/' : car);
        }
        buf.append(';');
        return;
      }
    }
  }

  
  
  

  

  public int getSize () {
    return (sort == LONG || sort == DOUBLE ? 2 : 1);
  }

  

  public int getOpcode (final int opcode) {
    if (opcode == Constants.IALOAD || opcode == Constants.IASTORE) {
      switch (sort) {
        case VOID:
          return opcode + 5;
        case BOOLEAN:
        case BYTE:
          return opcode + 6;
        case CHAR:
          return opcode + 7;
        case SHORT:
          return opcode + 8;
        case INT:
          return opcode;
        case FLOAT:
          return opcode + 2;
        case LONG:
          return opcode + 1;
        case DOUBLE:
          return opcode + 3;
        
        
        default:
          return opcode + 4;
      }
    } else {
      switch (sort) {
        case VOID:
          return opcode + 5;
        case BOOLEAN:
        case CHAR:
        case BYTE:
        case SHORT:
        case INT:
          return opcode;
        case FLOAT:
          return opcode + 2;
        case LONG:
          return opcode + 1;
        case DOUBLE:
          return opcode + 3;
        
        
        default:
          return opcode + 4;
      }
    }
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.RegisterChanged,4,2,0,6,12,0,2,4,4,0.0,35,1.0,0,0.5,0.5,1,1,7.5,1,0.75,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.Registers;


public class RegisterChanged extends EBMessage
{
	 private char registerName;

	 
	 public RegisterChanged(EBComponent source, char name)
	 {
		 super(source);
		 registerName = name;
	 }
	 
	 public char getRegisterName()
	 {
		 return registerName;
	 }
	 
	 public String getRegisterValue()
	 {
		 return Registers.getRegister(registerName).toString();
	 }
	 
	 public String paramString()
	 {
		 return ""register="" + registerName + "","" + super.paramString();
	 }
}
"
jEdit,4.3,org.gjt.sp.jedit.options.TextAreaOptionPane,5,6,0,6,42,0,1,6,3,0.727272727,523,1.0,10,0.994056464,0.5,4,6,99.2,3,1.4,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.*;
import org.gjt.sp.jedit.textarea.AntiAlias;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.gui.ColorWellButton;



public class TextAreaOptionPane extends AbstractOptionPane
{
	
	public TextAreaOptionPane()
	{
		super(""textarea"");
	} 

	
	public void _init()
	{
		
		font = new FontSelector(jEdit.getFontProperty(""view.font""));

		addComponent(jEdit.getProperty(""options.textarea.font""),font);

		
		addComponent(jEdit.getProperty(""options.textarea.foreground""),
			foregroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.fgColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.textarea.background""),
			backgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.bgColor"")),
			GridBagConstraints.VERTICAL);

		
		blinkCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blinkCaret""));
		blinkCaret.setSelected(jEdit.getBooleanProperty(""view.caretBlink""));

		blockCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blockCaret""));
		blockCaret.setSelected(jEdit.getBooleanProperty(""view.blockCaret""));

		thickCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".thickCaret""));
		thickCaret.setSelected(jEdit.getBooleanProperty(""view.thickCaret""));

		Box caretSettings = new Box(BoxLayout.X_AXIS);
		caretSettings.add(new JLabel(jEdit.getProperty(
			""options.textarea.caret"")));
		caretSettings.add(Box.createHorizontalStrut(6));
		caretSettings.add(blinkCaret);
		caretSettings.add(blockCaret);
		caretSettings.add(thickCaret);

		addComponent(caretSettings,caretColor = new ColorWellButton(
			jEdit.getColorProperty(""view.caretColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.textarea.selection""),
			selectionColor = new ColorWellButton(
			jEdit.getColorProperty(""view.selectionColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.textarea.multipleSelection""),
			multipleSelectionColor = new ColorWellButton(
			jEdit.getColorProperty(""view.multipleSelectionColor"")),
			GridBagConstraints.VERTICAL);

		
		lineHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".lineHighlight""));
		lineHighlight.setSelected(jEdit.getBooleanProperty(""view.lineHighlight""));
		addComponent(lineHighlight,lineHighlightColor = new ColorWellButton(
			jEdit.getColorProperty(""view.lineHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		structureHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".structureHighlight""));
		structureHighlight.setSelected(jEdit.getBooleanProperty(
			""view.structureHighlight""));
		addComponent(structureHighlight,structureHighlightColor = new ColorWellButton(
			jEdit.getColorProperty(""view.structureHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		eolMarkers = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".eolMarkers""));
		eolMarkers.setSelected(jEdit.getBooleanProperty(""view.eolMarkers""));
		addComponent(eolMarkers,eolMarkerColor =new ColorWellButton(
			jEdit.getColorProperty(""view.eolMarkerColor"")),
			GridBagConstraints.VERTICAL);

		
		wrapGuide = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".wrapGuide""));
		wrapGuide.setSelected(jEdit.getBooleanProperty(""view.wrapGuide""));
		addComponent(wrapGuide,wrapGuideColor = new ColorWellButton(
			jEdit.getColorProperty(""view.wrapGuideColor"")),
			GridBagConstraints.VERTICAL);

		
		electricBorders = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".electricBorders""));
		electricBorders.setSelected(!""0"".equals(jEdit.getProperty(
			""view.electricBorders"")));
		addComponent(electricBorders);

		

		antiAlias = new JComboBox(AntiAlias.comboChoices);
		antiAlias.setToolTipText(jEdit.getProperty(""options.textarea.antiAlias.tooltip""));
		AntiAlias antiAliasValue = new AntiAlias(jEdit.getProperty(""view.antiAlias""));
		font.setAntiAliasEnabled(antiAliasValue.val()>0);
		antiAlias.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					int idx = antiAlias.getSelectedIndex();
					font.setAntiAliasEnabled(idx > 0);
					font.repaint();
				}
			});
		antiAlias.setSelectedIndex(antiAliasValue.val());
		addComponent(jEdit.getProperty(""options.textarea""+ "".antiAlias""), antiAlias);

		
		fracFontMetrics = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".fracFontMetrics""));
		fracFontMetrics.setSelected(jEdit.getBooleanProperty(""view.fracFontMetrics""));
		addComponent(fracFontMetrics);

		
		stripTrailingEOL = new JCheckBox(jEdit.getProperty(
			""options.textArea.stripTrailingEOL""));
		stripTrailingEOL.setSelected(jEdit.getBooleanProperty(""stripTrailingEOL""));
		addComponent(stripTrailingEOL);

		completeFromAllBuffers = new JCheckBox(jEdit.getProperty(
			""options.textArea.completeFromAllBuffers""));
		completeFromAllBuffers.setSelected(jEdit.getBooleanProperty(""completeFromAllBuffers""));
		addComponent(completeFromAllBuffers);

	} 

	
	public void _save()
	{
		jEdit.setFontProperty(""view.font"",font.getFont());

		jEdit.setColorProperty(""view.fgColor"",foregroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.bgColor"",backgroundColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.caretBlink"",blinkCaret.isSelected());
		jEdit.setBooleanProperty(""view.blockCaret"",blockCaret.isSelected());
		jEdit.setBooleanProperty(""view.thickCaret"",thickCaret.isSelected());
		jEdit.setColorProperty(""view.caretColor"",caretColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.selectionColor"",selectionColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.multipleSelectionColor"",multipleSelectionColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.lineHighlight"",lineHighlight
			.isSelected());
		jEdit.setColorProperty(""view.lineHighlightColor"",
			lineHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.structureHighlight"",structureHighlight
			.isSelected());
		jEdit.setColorProperty(""view.structureHighlightColor"",
			structureHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.eolMarkers"",eolMarkers
			.isSelected());
		jEdit.setColorProperty(""view.eolMarkerColor"",
			eolMarkerColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.wrapGuide"",wrapGuide
			.isSelected());
		jEdit.setColorProperty(""view.wrapGuideColor"",
			wrapGuideColor.getSelectedColor());
		jEdit.setIntegerProperty(""view.electricBorders"",electricBorders
			.isSelected() ? 3 : 0);
		AntiAlias nv = new AntiAlias(jEdit.getProperty(""view.antiAlias""));
		nv.set(antiAlias.getSelectedIndex());
		jEdit.setProperty(""view.antiAlias"", nv.toString());
		jEdit.setBooleanProperty(""view.fracFontMetrics"",fracFontMetrics.isSelected());
		jEdit.setBooleanProperty(""stripTrailingEOL"", stripTrailingEOL.isSelected());
		jEdit.setBooleanProperty(""completeFromAllBuffers"", completeFromAllBuffers.isSelected());
	} 

	
	private FontSelector font;
	private ColorWellButton foregroundColor;
	private ColorWellButton backgroundColor;
	private JCheckBox blinkCaret;
	private JCheckBox blockCaret;
	private JCheckBox thickCaret;
	private ColorWellButton caretColor;
	private ColorWellButton selectionColor;
	private ColorWellButton multipleSelectionColor;
	private JCheckBox lineHighlight;
	private ColorWellButton lineHighlightColor;
	private JCheckBox structureHighlight;
	private ColorWellButton structureHighlightColor;
	private JCheckBox eolMarkers;
	private ColorWellButton eolMarkerColor;
	private JCheckBox wrapGuide;
	private ColorWellButton wrapGuideColor;
	private JCheckBox electricBorders;
	
	private JComboBox antiAlias;
	private JCheckBox fracFontMetrics;
	private JCheckBox stripTrailingEOL;
	private JCheckBox completeFromAllBuffers;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.VFSDirectoryEntryTableModel,19,2,0,13,47,79,5,8,17,0.638888889,552,0.75,1,0.470588235,0.378947368,1,1,27.84210526,6,2.1053,0,"

package org.gjt.sp.jedit.browser;


import javax.swing.table.*;
import java.util.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSFile;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class VFSDirectoryEntryTableModel extends AbstractTableModel
{
	
	public VFSDirectoryEntryTableModel()
	{
		extAttrs = new ArrayList<ExtendedAttribute>();
		sortColumn = 0;
		ascending = true;
	} 

	
	public void setRoot(VFS vfs, List<VFSFile> list)
	{
		extAttrs.clear();
		addExtendedAttributes(vfs);

		

		files = new Entry[list.size()];
		for(int i = 0; i < files.length; i++)
		{
			files[i] = new Entry(list.get(i),0);
		}

		

		Arrays.sort(files, new EntryCompare(getSortAttribute(sortColumn), ascending));
		fireTableStructureChanged();
	} 

	
	public int expand(VFS vfs, Entry entry, List<VFSFile> list)
	{
		int startIndex = -1;
		for(int i = 0; i < files.length; i++)
		{
			if(files[i] == entry)
				startIndex = i;
		}
		if (startIndex != -1)
			collapse(vfs,startIndex);

		addExtendedAttributes(vfs);
		entry.expanded = true;

		if(list != null)
		{
			
			Entry[] newFiles = new Entry[files.length + list.size()];
			Entry[] subdirFiles = new Entry[list.size()];

			for(int i = 0; i < list.size(); i++)
			{
				subdirFiles[i] = new Entry(
					list.get(i),entry.level + 1,entry);
			}

			
			Arrays.sort(subdirFiles, new EntryCompare(
				getSortAttribute(sortColumn), ascending));
			
			
			int nextIndex = startIndex + 1;
			System.arraycopy(files,0,newFiles,0,nextIndex);
			System.arraycopy(subdirFiles,0,newFiles,nextIndex,list.size());
			System.arraycopy(files,nextIndex,newFiles,nextIndex + list.size(),
				files.length - nextIndex);

			this.files = newFiles;

			
		}

		

		fireTableStructureChanged();

		return startIndex;
	} 

	
	public void collapse(VFS vfs, int index)
	{
		Entry entry = files[index];
		if(!entry.expanded)
			return;

		entry.expanded = false;

		int lastIndex = index + 1;
		while(lastIndex < files.length)
		{
			Entry e = files[lastIndex];

			if(e.level <= entry.level)
				break;

			lastIndex++;

			if(e.expanded)
			{
				removeExtendedAttributes(VFSManager.getVFSForPath(
					e.dirEntry.getPath()));
			}
		}

		removeExtendedAttributes(vfs);

		Entry[] newFiles = new Entry[files.length - lastIndex + index + 1];
		System.arraycopy(files,0,newFiles,0,index + 1);
		System.arraycopy(files,lastIndex,newFiles,index + 1,
			files.length - lastIndex);

		files = newFiles;

		

		fireTableStructureChanged();
	} 

	
	public int getColumnCount()
	{
		return 1 + extAttrs.size();
	} 

	
	public int getRowCount()
	{
		if(files == null)
			return 0;
		else
			return files.length;
	} 

	
	public String getColumnName(int col)
	{
		if(col == 0)
			return jEdit.getProperty(""vfs.browser.name"");
		else
			return jEdit.getProperty(""vfs.browser."" + getExtendedAttribute(col));
	} 

	
	public Class getColumnClass(int col)
	{
		return Entry.class;
	} 

	
	public Object getValueAt(int row, int col)
	{
		if(files == null)
			return null;
		else
			return files[row];
	} 

	
	public boolean getAscending()
	{
		return ascending;
	} 

	
	public int getSortColumn()
	{
		return sortColumn;
	} 

	
	public String getSortAttribute(int column)
	{
		return column == 0 ? ""name"" : getExtendedAttribute(column);
	} 

	
	public boolean sortByColumn(int column)
	{
		
		ascending = sortColumn != column || !ascending;

		
		String sortBy = getSortAttribute(column);
		if(sortBy == VFS.EA_STATUS)
			return false;

		Arrays.sort(files, new EntryCompare(sortBy, ascending));

		
		sortColumn = column;
		fireTableStructureChanged();

		return true;
	} 

	
	public String getExtendedAttribute(int index)
	{
		return extAttrs.get(index - 1).name;
	} 

	
	
	public int getColumnWidth(int i)
	{
		String extAttr = getExtendedAttribute(i);
		return jEdit.getIntegerProperty(""vfs.browser.""
			+ extAttr + "".width"",100);
	} 
	
	
	
	public void setColumnWidth(int i, int w)
	{
		String extAttr = getExtendedAttribute(i);
		jEdit.setIntegerProperty(""vfs.browser.""
			+ extAttr + "".width"",w);
	} 
	
	
	public VFSFile[] getFiles()
	{
		VFSFile[] f = new VFSFile[files.length];
		for(int i = 0; i < f.length; i++)
			f[i] = files[i].dirEntry;
		return f;
	} 
	
	
	Entry[] files;
	

	
	private List<ExtendedAttribute> extAttrs;
	private int sortColumn;
	private boolean ascending;

	
	private void addExtendedAttributes(VFS vfs)
	{
		String[] attrs = vfs.getExtendedAttributes();
vfs_attr_loop:	for(int i = 0; i < attrs.length; i++)
		{
			for (ExtendedAttribute attr : extAttrs)
			{
				if (attrs[i].equals(attr.name))
				{
					attr.ref++;
					continue vfs_attr_loop;
				}
			}

			
			
			
			extAttrs.add(new ExtendedAttribute(attrs[i]));
		}
	} 

	
	private void removeExtendedAttributes(VFS vfs)
	{
		String[] attrs = vfs.getExtendedAttributes();
vfs_attr_loop:	for(int i = 0; i < attrs.length; i++)
		{
			Iterator<ExtendedAttribute> iter = extAttrs.iterator();
			while(iter.hasNext())
			{
				ExtendedAttribute attr = iter.next();
				if(attrs[i].equals(attr.name))
				{
					if(--attr.ref == 0)
					{
						
						
						
						iter.remove();
					}

					continue vfs_attr_loop;
				}
			}

			
			
			Log.log(Log.WARNING,this,""We forgot about "" + attrs[i]);
		}
	} 

	

	
	static class Entry
	{
		VFSFile dirEntry;
		
		boolean expanded;
		
		int level;
		
		Entry parent;
		
		String extension;

		Entry(VFSFile dirEntry, int level, Entry parent)
		{
			this(dirEntry,level);
			this.parent = parent;
		}
		
		Entry(VFSFile dirEntry, int level)
		{
			this.dirEntry = dirEntry;
			this.level = level;
			this.extension = MiscUtilities.getFileExtension(dirEntry.getName());
		}
		
		
	} 

	
	static class ExtendedAttribute
	{
		
		int ref;

		String name;

		ExtendedAttribute(String name)
		{
			this.name = name;
			ref = 1;
		}
	} 

	
	
	static class EntryCompare implements Comparator<Entry>
	{
		private boolean sortIgnoreCase, sortMixFilesAndDirs, sortAscending;
		private String sortAttribute;
		
		EntryCompare(String sortBy, boolean ascending)
		{
			this.sortMixFilesAndDirs = jEdit.getBooleanProperty(
				""vfs.browser.sortMixFilesAndDirs"");
			this.sortIgnoreCase = jEdit.getBooleanProperty(
				""vfs.browser.sortIgnoreCase"");
			this.sortAscending = ascending;
			this.sortAttribute = sortBy;
		}

		public int compare(Entry entry1, Entry entry2)
		{
			
			if(entry1.level < entry2.level) 
				return compare(entry1, entry2.parent);
			if(entry1.level > entry2.level)
				return compare(entry1.parent, entry2);

			
			if(entry1.parent != entry2.parent)
				return compare(entry1.parent, entry2.parent);

			
			

			VFSFile file1 = entry1.dirEntry;
			VFSFile file2 = entry2.dirEntry;

			if(!sortMixFilesAndDirs)
			{
				if(file1.getType() != file2.getType())
					return file2.getType() - file1.getType();
			}

			int result;

			
			if(sortAttribute == VFS.EA_MODIFIED)
				result = (
					(Long)((FileVFS.LocalFile)file1).getModified())
					.compareTo(
					(Long)((FileVFS.LocalFile)file2).getModified());
			
			else if(sortAttribute == VFS.EA_SIZE)
				result = (
					(Long)file1.getLength())
					.compareTo(
					(Long)file2.getLength());
			
			else if(sortAttribute == VFS.EA_TYPE)
				result = StandardUtilities.compareStrings(
					entry1.extension,
					entry2.extension,
					sortIgnoreCase);
			
			else
				result = StandardUtilities.compareStrings(
					file1.getName(),
					file2.getName(),
					sortIgnoreCase);
			return sortAscending ? result : -result;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.BufferChanging,2,4,0,5,10,0,1,5,2,0.0,31,1.0,1,0.857142857,0.666666667,0,0,14.0,1,0.5,0,"
 
package org.gjt.sp.jedit.msg;

import java.util.Arrays;

import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.util.Log;


public class BufferChanging extends PositionChanging
{
	
	public BufferChanging(EditPane editPane, Buffer newBuffer)
	{
		super(editPane, EditPaneUpdate.BUFFER_CHANGING);
		if (newBuffer == null)
		{
			String s = Arrays.toString(Thread.currentThread().getStackTrace());
			Log.log (Log.ERROR, this, ""BufferChanging to null Buffer? Emit PositionChanging instead."" + s);
		}
		m_buffer = newBuffer;
	}
	
	
	public Buffer getBuffer()
	{
		return m_buffer;
	}

	private Buffer m_buffer;
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.ScrollLineCount,3,2,0,7,10,3,2,6,2,2.0,52,0.0,0,0.714285714,0.555555556,1,3,16.33333333,3,1.3333,0,"

package org.gjt.sp.jedit.textarea;

import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;


class ScrollLineCount extends Anchor
{
	
	ScrollLineCount(DisplayManager displayManager,
		TextArea textArea)
	{
		super(displayManager,textArea);
	} 

	@Override
	public void changed() {}

	
	@Override
	public void reset()
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""reset()"");

		physicalLine = displayManager.getFirstVisibleLine();
		int scrollLine = 0;
		while(physicalLine != -1)
		{
			scrollLine += displayManager
				.getScreenLineCount(physicalLine);
			physicalLine = displayManager
				.getNextVisibleLine(physicalLine);
		}

		this.scrollLine = scrollLine;
		physicalLine = displayManager.getBuffer().getLineCount();
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.FoldWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.gui.BufferOptions;
import org.gjt.sp.jedit.jEdit;



public class FoldWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view) 
	{
		Widget fold = new FoldWidget(view);
		return fold;
	} 

	
	private static class FoldWidget implements Widget
	{
		private final JLabel fold;
		private final View view;
		public FoldWidget(final View view) 
		{
			fold = new ToolTipLabel();
			this.view = view;
			fold.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
			fold.addMouseListener(new MouseAdapter() 
					      {
						      @Override
						      public void mouseClicked(MouseEvent evt)
						      {
							      if(evt.getClickCount() == 2)
								      new BufferOptions(view,view.getBuffer());
						      }
					      });
		}
		
		public JComponent getComponent() 
		{
			return fold;
		}
		
		public void update() 
		{
			Buffer buffer = view.getBuffer();
			if (buffer.isLoaded())
				fold.setText((String)view.getBuffer().getProperty(""folding""));
		}
		
		public void propertiesChanged()
		{
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.CharsetEncoding,4,1,0,3,12,0,2,1,4,0.0,46,1.0,0,0.0,0.5,0,0,10.25,1,0.75,0,"

package org.gjt.sp.jedit.io;


import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;



public class CharsetEncoding implements Encoding
{
	
	public CharsetEncoding(String name)
	{
		body = Charset.forName(name);
	} 

	
	public Reader getTextReader(InputStream in) throws IOException
	{
		
		
		
		
		return new InputStreamReader(in, body.newDecoder());
	}

	public Writer getTextWriter(OutputStream out) throws IOException
	{
		
		
		return new OutputStreamWriter(out, body.newEncoder());
	}

	public Reader getPermissiveTextReader(InputStream in) throws IOException
	{
		
		
		CharsetDecoder permissive = body.newDecoder();
		permissive.onMalformedInput(CodingErrorAction.REPLACE);
		permissive.onUnmappableCharacter(CodingErrorAction.REPLACE);
		return new InputStreamReader(in, permissive);
	}
	

	
	private final Charset body;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableLayout,15,1,0,3,30,79,1,2,14,0.795238095,923,0.666666667,4,0.0,0.25,0,0,59.53333333,12,2.7333,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;


public class DockableLayout implements LayoutManager2
{
	
	
	static final String CENTER = BorderLayout.CENTER;

	static final String TOP_BUTTONS = ""top-buttons"";
	static final String LEFT_BUTTONS = ""left-buttons"";
	static final String BOTTOM_BUTTONS = ""bottom-buttons"";
	static final String RIGHT_BUTTONS = ""right-buttons"";

	private boolean alternateLayout;
	private Component center;

	
	private DockablePanel top;
	private DockablePanel left;
	private DockablePanel bottom;
	private DockablePanel right;

	private Component topButtons, leftButtons, bottomButtons, rightButtons;

	
	@Deprecated
	public boolean setAlternateLayout()
	{
		return isAlternateLayout();
	}
	
	
	
	
	public boolean isAlternateLayout()
	{
		return alternateLayout;
	} 

	
	public void setAlternateLayout(boolean alternateLayout)
	{
		this.alternateLayout = alternateLayout;
	} 

	
	public void addLayoutComponent(String name, Component comp)
	{
		addLayoutComponent(comp, name);
	} 

	
	public void addLayoutComponent(Component comp, Object cons)
	{
		if(cons == null || CENTER.equals(cons))
			center = comp;
		else if(DockableWindowManager.TOP.equals(cons))
			top = (DockablePanel)comp;
		else if(DockableWindowManager.LEFT.equals(cons))
			left = (DockablePanel)comp;
		else if(DockableWindowManager.BOTTOM.equals(cons))
			bottom = (DockablePanel)comp;
		else if(DockableWindowManager.RIGHT.equals(cons))
			right = (DockablePanel)comp;
		else if(TOP_BUTTONS.equals(cons))
			topButtons = comp;
		else if(LEFT_BUTTONS.equals(cons))
			leftButtons = comp;
		else if(BOTTOM_BUTTONS.equals(cons))
			bottomButtons = comp;
		else if(RIGHT_BUTTONS.equals(cons))
			rightButtons = comp;
	} 

	
	public void removeLayoutComponent(Component comp)
	{
		if(center == comp)
			center = null;
		else if(comp == top)
			top = null;
		else if(comp == left)
			left = null;
		else if(comp == bottom)
			bottom = null;
		else if(comp == right)
			right = null;
	} 

	
	public Dimension preferredLayoutSize(Container parent)
	{
		Dimension prefSize = new Dimension(0,0);
		Dimension _top = top.getPreferredSize();
		Dimension _left = left.getPreferredSize();
		Dimension _bottom = bottom.getPreferredSize();
		Dimension _right = right.getPreferredSize();
		Dimension _topButtons = topButtons.getPreferredSize();
		Dimension _leftButtons = leftButtons.getPreferredSize();
		Dimension _bottomButtons = bottomButtons.getPreferredSize();
		Dimension _rightButtons = rightButtons.getPreferredSize();
		Dimension _center = (center == null
			? new Dimension(0,0)
			: center.getPreferredSize());
		Dimension _topToolbars = new Dimension(0,0);
		Dimension _bottomToolbars = new Dimension(0,0);

		prefSize.height = _top.height + _bottom.height + _center.height
			+ _topButtons.height + _bottomButtons.height
			+ _topToolbars.height + _bottomToolbars.height;
		prefSize.width = _left.width + _right.width
			+ Math.max(_center.width,
			Math.max(_topToolbars.width,_bottomToolbars.width))
			+ _leftButtons.width + _rightButtons.width;

		return prefSize;
	} 

	
	public Dimension minimumLayoutSize(Container parent)
	{
		
		return preferredLayoutSize(parent);
	} 

	
	public Dimension maximumLayoutSize(Container parent)
	{
		return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);
	} 

	
	public void layoutContainer(Container parent)
	{
		Dimension size = parent.getSize();

		Dimension _topToolbars = new Dimension(0,0);
		Dimension _bottomToolbars = new Dimension(0,0);

		int topButtonHeight = -1;
		int bottomButtonHeight = -1;
		int leftButtonWidth = -1;
		int rightButtonWidth = -1;

		Dimension _top = top.getPreferredSize();
		Dimension _left = left.getPreferredSize();
		Dimension _bottom = bottom.getPreferredSize();
		Dimension _right = right.getPreferredSize();

		int topHeight = _top.height;
		int bottomHeight = _bottom.height;
		int leftWidth = _left.width;
		int rightWidth = _right.width;

		boolean topEmpty = ((Container)topButtons)
			.getComponentCount() <= 2;
		boolean leftEmpty = ((Container)leftButtons)
			.getComponentCount() <= 2;
		boolean bottomEmpty = ((Container)bottomButtons)
			.getComponentCount() <= 2;
		boolean rightEmpty = ((Container)rightButtons)
			.getComponentCount() <= 2;

		Dimension closeBoxSize;
		if(((Container)topButtons).getComponentCount() == 0)
			closeBoxSize = new Dimension(0,0);
		else
		{
			closeBoxSize = ((Container)topButtons)
				.getComponent(0).getPreferredSize();
		}

		int closeBoxWidth = Math.max(closeBoxSize.width,
			closeBoxSize.height) + 1;

		if(alternateLayout)
		{
			
			int _width = size.width;

			int padding = (leftEmpty&&rightEmpty)
				? 0 : closeBoxWidth;

			topButtonHeight = top.getWindowContainer()
				.getWrappedDimension(_width
				- closeBoxWidth * 2);
			topButtons.setBounds(
				padding,
				0,
				size.width - padding * 2,
				topButtonHeight);

			bottomButtonHeight = bottom.getWindowContainer()
				.getWrappedDimension(_width);
			bottomButtons.setBounds(
				padding,
				size.height - bottomButtonHeight,
				size.width - padding * 2,
				bottomButtonHeight);

			int _height = size.height
				- topButtonHeight
				- bottomButtonHeight;
			

			
			leftButtonWidth = left.getWindowContainer()
				.getWrappedDimension(_height);
			leftButtons.setBounds(
				0,
				topHeight + topButtonHeight,
				leftButtonWidth,
				_height - topHeight - bottomHeight);

			rightButtonWidth = right.getWindowContainer()
				.getWrappedDimension(_height);
			rightButtons.setBounds(
				size.width - rightButtonWidth,
				topHeight + topButtonHeight,
				rightButtonWidth,
				_height - topHeight - bottomHeight);
			

			int[] dimensions = adjustDockingAreasToFit(
				size,
				topHeight,
				leftWidth,
				bottomHeight,
				rightWidth,
				topButtonHeight,
				leftButtonWidth,
				bottomButtonHeight,
				rightButtonWidth,
				_topToolbars,
				_bottomToolbars);

			topHeight = dimensions[0];
			leftWidth = dimensions[1];
			bottomHeight = dimensions[2];
			rightWidth = dimensions[3];

			
			top.setBounds(
				0,
				topButtonHeight,
				size.width,
				topHeight);

			bottom.setBounds(
				0,
				size.height
				- bottomHeight
				- bottomButtonHeight,
				size.width,
				bottomHeight);

			left.setBounds(
				leftButtonWidth,
				topButtonHeight + topHeight,
				leftWidth,
				_height - topHeight - bottomHeight);

			right.setBounds(
				_width - rightButtonWidth - rightWidth,
				topButtonHeight + topHeight,
				rightWidth,
				_height - topHeight - bottomHeight); 
		}
		else
		{
			
			int _height = size.height;

			int padding = (topEmpty && bottomEmpty
				? 0 : closeBoxWidth);

			leftButtonWidth = left.getWindowContainer()
				.getWrappedDimension(_height
				- closeBoxWidth * 2);
			leftButtons.setBounds(
				0,
				padding,
				leftButtonWidth,
				_height - padding * 2);

			rightButtonWidth = right.getWindowContainer()
				.getWrappedDimension(_height);
			rightButtons.setBounds(
				size.width - rightButtonWidth,
				padding,
				rightButtonWidth,
				_height - padding * 2);

			int _width = size.width
				- leftButtonWidth
				- rightButtonWidth;
			

			
			topButtonHeight = top.getWindowContainer()
				.getWrappedDimension(_width);
			topButtons.setBounds(
				leftButtonWidth + leftWidth,
				0,
				_width - leftWidth - rightWidth,
				topButtonHeight);

			bottomButtonHeight = bottom.getWindowContainer()
				.getWrappedDimension(_width);
			bottomButtons.setBounds(
				leftButtonWidth + leftWidth,
				_height - bottomButtonHeight,
				_width - leftWidth - rightWidth,
				bottomButtonHeight); 

			int[] dimensions = adjustDockingAreasToFit(
				size,
				topHeight,
				leftWidth,
				bottomHeight,
				rightWidth,
				topButtonHeight,
				leftButtonWidth,
				bottomButtonHeight,
				rightButtonWidth,
				_topToolbars,
				_bottomToolbars);

			topHeight = dimensions[0];
			leftWidth = dimensions[1];
			bottomHeight = dimensions[2];
			rightWidth = dimensions[3];

			
			top.setBounds(
				leftButtonWidth + leftWidth,
				topButtonHeight,
				_width - leftWidth - rightWidth,
				topHeight);

			bottom.setBounds(
				leftButtonWidth + leftWidth,
				size.height - bottomHeight - bottomButtonHeight,
				_width - leftWidth - rightWidth,
				bottomHeight);

			left.setBounds(
				leftButtonWidth,
				0,
				leftWidth,
				_height);

			right.setBounds(
				size.width - rightWidth - rightButtonWidth,
				0,
				rightWidth,
				_height); 
		}

		
		if(center != null)
		{
			center.setBounds(
				leftButtonWidth + leftWidth,
				topButtonHeight + topHeight
				+ _topToolbars.height,
				size.width
				- leftWidth
				- rightWidth
				- leftButtonWidth
				- rightButtonWidth,
				size.height
				- topHeight
				- topButtonHeight
				- bottomHeight
				- bottomButtonHeight
				- _topToolbars.height
				- _bottomToolbars.height);
		} 
	} 

	
	private int[] adjustDockingAreasToFit(
		Dimension size,
		int topHeight,
		int leftWidth,
		int bottomHeight,
		int rightWidth,
		int topButtonHeight,
		int leftButtonWidth,
		int bottomButtonHeight,
		int rightButtonWidth,
		Dimension _topToolbars,
		Dimension _bottomToolbars)
	{
		int maxTopHeight = size.height - bottomHeight
			- topButtonHeight - bottomButtonHeight
			- _topToolbars.height - _bottomToolbars.height;
		topHeight = Math.min(Math.max(0,maxTopHeight),
			topHeight);
		leftWidth = Math.min(Math.max(0,
			size.width - leftButtonWidth
			- rightButtonWidth - rightWidth),leftWidth);
		int maxBottomHeight = size.height - topHeight
			- topButtonHeight - bottomButtonHeight
			- _topToolbars.height - _bottomToolbars.height;
		bottomHeight = Math.min(Math.max(0,maxBottomHeight),
			bottomHeight);
		rightWidth = Math.min(Math.max(0,
			size.width - leftButtonWidth
			- rightButtonWidth - leftWidth),rightWidth);

		top.getWindowContainer().setDimension(topHeight);
		left.getWindowContainer().setDimension(leftWidth);
		bottom.getWindowContainer().setDimension(bottomHeight);
		right.getWindowContainer().setDimension(rightWidth);

		return new int[] {
			topHeight,
			leftWidth,
			bottomHeight,
			rightWidth
		};
	} 

	
	public float getLayoutAlignmentX(Container target)
	{
		return 0.5f;
	} 

	
	public float getLayoutAlignmentY(Container target)
	{
		return 0.5f;
	} 

	
	public void invalidateLayout(Container target) {}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.IconTheme,5,1,0,3,12,8,1,2,4,0.75,42,0.0,0,0.0,0.25,0,0,7.2,1,0.6,0,"package org.gjt.sp.jedit.options;

import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;

public class IconTheme extends Object
{
	static final String[] builtIn  = new String[] { ""tango"", ""classic"" };
	
	public static String[] builtInNames()
	{
		return builtIn;
	}

	public static String get() 
	{
		return jEdit.getProperty(""icon-theme"", ""tango"");
	}
	
	public static void set(String name)
	{
		GUIUtilities.setIconPath(""jeditresource:/org/gjt/sp/jedit/icons/themes/"" + name + ""/"");
		jEdit.setProperty(""icon-theme"", name);
	}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.CodeWriter,32,1,0,6,53,0,2,6,17,0.853046595,2884,0.925925926,13,0.0,0.204301075,0,0,88.28125,40,6.5,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



public class CodeWriter implements CodeVisitor {

  

  final static boolean CHECK = false;

  

  CodeWriter next;

  

  private ClassWriter cw;

  

  private Item name;

  

  private Item desc;

  

  private int access;

  

  private int maxStack;

  

  private int maxLocals;

  

  private ByteVector code = new ByteVector();

  

  private int catchCount;

  

  private ByteVector catchTable;

  

  private int exceptionCount;

  

  private int[] exceptions;

  

  private int localVarCount;

  

  private ByteVector localVar;

  

  private int lineNumberCount;

  

  private ByteVector lineNumber;

  

  private boolean resize;

  
  
  
  
  
  
  
  
  

  

  private final boolean computeMaxs;

  

  private int stackSize;

  

  private int maxStackSize;

  

  private Label currentBlock;

  

  private Label blockStack;

  

  private final static int[] SIZE;

  
  
  
  
  
  
  
  
  
  
  

  

  private Edge head;

  

  private Edge tail;

  

  private static Edge pool;

  
  
  

  

  static {
    int i;
    int[] b = new int[202];
    String s =
      ""EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDDCDCDEEEEEEEEE"" +
      ""EEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCDCDCEEEEDDDDDDDCDCDCEFEF"" +
      ""DDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFEDDDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE"";
    for (i = 0; i < b.length; ++i) {
      b[i] = s.charAt(i) - 'E';
    }
    SIZE = b;

    
  }

  
  
  

  

  protected CodeWriter (final ClassWriter cw, final boolean computeMaxs) {
    if (cw.firstMethod == null) {
      cw.firstMethod = this;
      cw.lastMethod = this;
    } else {
      cw.lastMethod.next = this;
      cw.lastMethod = this;
    }
    this.cw = cw;
    this.computeMaxs = computeMaxs;
    if (computeMaxs) {
      
      currentBlock = new Label();
      currentBlock.pushed = true;
      blockStack = currentBlock;
    }
  }

  

  protected void init (
    final int access,
    final String name,
    final String desc,
    final String[] exceptions)
  {
    this.access = access;
    this.name = cw.newUTF8(name);
    this.desc = cw.newUTF8(desc);
    if (exceptions != null && exceptions.length > 0) {
      exceptionCount = exceptions.length;
      this.exceptions = new int[exceptionCount];
      for (int i = 0; i < exceptionCount; ++i) {
        this.exceptions[i] = cw.newClass(exceptions[i]).index;
      }
    }
    if (computeMaxs) {
      
      int size = getArgumentsAndReturnSizes(desc) >> 2;
      if ((access & Constants.ACC_STATIC) != 0) {
        --size;
      }
      if (size > maxLocals) {
        maxLocals = size;
      }
    }
  }

  
  
  

  public void visitInsn (final int opcode) {
    if (computeMaxs) {
      
      int size = stackSize + SIZE[opcode];
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
      
      if ((opcode >= Constants.IRETURN && opcode <= Constants.RETURN) ||
          opcode == Constants.ATHROW)
      {
        if (currentBlock != null) {
          currentBlock.maxStackSize = maxStackSize;
          currentBlock = null;
        }
      }
    }
    
    code.put1(opcode);
  }

  public void visitIntInsn (final int opcode, final int operand) {
    if (computeMaxs && opcode != Constants.NEWARRAY) {
      
      
      int size = stackSize + 1;
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    
    if (opcode == Constants.SIPUSH) {
      code.put12(opcode, operand);
    } else { 
      code.put11(opcode, operand);
    }
  }

  public void visitVarInsn (final int opcode, final int var) {
    if (computeMaxs) {
      
      if (opcode == Constants.RET) {
        
        if (currentBlock != null) {
          currentBlock.maxStackSize = maxStackSize;
          currentBlock = null;
        }
      } else { 
        int size = stackSize + SIZE[opcode];
        if (size > maxStackSize) {
          maxStackSize = size;
        }
        stackSize = size;
      }
      
      int n;
      if (opcode == Constants.LLOAD || opcode == Constants.DLOAD ||
          opcode == Constants.LSTORE || opcode == Constants.DSTORE)
      {
        n = var + 2;
      } else {
        n = var + 1;
      }
      if (n > maxLocals) {
        maxLocals = n;
      }
    }
    
    if (var < 4 && opcode != Constants.RET) {
      int opt;
      if (opcode < Constants.ISTORE) {
        opt = 26  + ((opcode - Constants.ILOAD) << 2) + var;
      } else {
        opt = 59  + ((opcode - Constants.ISTORE) << 2) + var;
      }
      code.put1(opt);
    } else if (var >= 256) {
      code.put1(196 ).put12(opcode, var);
    } else {
      code.put11(opcode, var);
    }
  }

  public void visitTypeInsn (final int opcode, final String desc) {
    if (computeMaxs && opcode == Constants.NEW) {
      
      
      int size = stackSize + 1;
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    
    code.put12(opcode, cw.newClass(desc).index);
  }

  public void visitFieldInsn (
    final int opcode,
    final String owner,
    final String name,
    final String desc)
  {
    if (computeMaxs) {
      int size;
      
      char c = desc.charAt(0);
      switch (opcode) {
        case Constants.GETSTATIC:
          size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);
          break;
        case Constants.PUTSTATIC:
          size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);
          break;
        case Constants.GETFIELD:
          size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);
          break;
        
        default:
          size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);
          break;
      }
      
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    
    code.put12(opcode, cw.newField(owner, name, desc).index);
  }

  public void visitMethodInsn (
    final int opcode,
    final String owner,
    final String name,
    final String desc)
  {
    Item i;
    if (opcode == Constants.INVOKEINTERFACE) {
      i = cw.newItfMethod(owner, name, desc);
    } else {
      i = cw.newMethod(owner, name, desc);
    }
    int argSize = i.intVal;
    if (computeMaxs) {
      
      
      
      
      
      if (argSize == 0) {
        
        argSize = getArgumentsAndReturnSizes(desc);
        
        i.intVal = argSize;
      }
      int size;
      if (opcode == Constants.INVOKESTATIC) {
        size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;
      } else {
        size = stackSize - (argSize >> 2) + (argSize & 0x03);
      }
      
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    
    if (opcode == Constants.INVOKEINTERFACE) {
      if (!computeMaxs) {
        if (argSize == 0) {
          argSize = getArgumentsAndReturnSizes(desc);
          i.intVal = argSize;
        }
      }
      code.put12(Constants.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);
    } else {
      code.put12(opcode, i.index);
    }
  }

  public void visitJumpInsn (final int opcode, final Label label) {
    if (CHECK) {
      if (label.owner == null) {
        label.owner = this;
      } else if (label.owner != this) {
        throw new IllegalArgumentException();
      }
    }
    if (computeMaxs) {
      if (opcode == Constants.GOTO) {
        
        if (currentBlock != null) {
          currentBlock.maxStackSize = maxStackSize;
          addSuccessor(stackSize, label);
          currentBlock = null;
        }
      } else if (opcode == Constants.JSR) {
        if (currentBlock != null) {
          addSuccessor(stackSize + 1, label);
        }
      } else {
        
        
        stackSize += SIZE[opcode];
        if (currentBlock != null) {
          addSuccessor(stackSize, label);
        }
      }
    }
    
    if (label.resolved && label.position - code.length < Short.MIN_VALUE) {
      
      
      
      
      
      if (opcode == Constants.GOTO) {
        code.put1(200); 
      } else if (opcode == Constants.JSR) {
        code.put1(201); 
      } else {
        code.put1(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);
        code.put2(8);   
        code.put1(200); 
      }
      label.put(this, code, code.length - 1, true);
    } else {
      
      
      
      code.put1(opcode);
      label.put(this, code, code.length - 1, false);
    }
  }

  public void visitLabel (final Label label) {
    if (CHECK) {
      if (label.owner == null) {
        label.owner = this;
      } else if (label.owner != this) {
        throw new IllegalArgumentException();
      }
    }
    if (computeMaxs) {
      if (currentBlock != null) {
        
        currentBlock.maxStackSize = maxStackSize;
        addSuccessor(stackSize, label);
      }
      
      
      currentBlock = label;
      stackSize = 0;
      maxStackSize = 0;
    }
    
    resize |= label.resolve(this, code.length, code.data);
  }

  public void visitLdcInsn (final Object cst) {
    Item i = cw.newCst(cst);
    if (computeMaxs) {
      int size;
      
      if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {
        size = stackSize + 2;
      } else {
        size = stackSize + 1;
      }
      
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    
    int index = i.index;
    if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {
      code.put12(20 , index);
    } else if (index >= 256) {
      code.put12(19 , index);
    } else {
      code.put11(Constants.LDC, index);
    }
  }

  public void visitIincInsn (final int var, final int increment) {
    if (computeMaxs) {
      
      int n = var + 1;
      if (n > maxLocals) {
        maxLocals = n;
      }
    }
    
    if ((var > 255) || (increment > 127) || (increment < -128)) {
      code.put1(196 ).put12(Constants.IINC, var).put2(increment);
    } else {
      code.put1(Constants.IINC).put11(var, increment);
    }
  }

  public void visitTableSwitchInsn (
    final int min,
    final int max,
    final Label dflt,
    final Label labels[])
  {
    if (computeMaxs) {
      
      --stackSize;
      
      if (currentBlock != null) {
        currentBlock.maxStackSize = maxStackSize;
        addSuccessor(stackSize, dflt);
        for (int i = 0; i < labels.length; ++i) {
          addSuccessor(stackSize, labels[i]);
        }
        currentBlock = null;
      }
    }
    
    int source = code.length;
    code.put1(Constants.TABLESWITCH);
    while (code.length % 4 != 0) {
      code.put1(0);
    }
    dflt.put(this, code, source, true);
    code.put4(min).put4(max);
    for (int i = 0; i < labels.length; ++i) {
      labels[i].put(this, code, source, true);
    }
  }

  public void visitLookupSwitchInsn (
    final Label dflt,
    final int keys[],
    final Label labels[])
  {
    if (computeMaxs) {
      
      --stackSize;
      
      if (currentBlock != null) {
        currentBlock.maxStackSize = maxStackSize;
        addSuccessor(stackSize, dflt);
        for (int i = 0; i < labels.length; ++i) {
          addSuccessor(stackSize, labels[i]);
        }
        currentBlock = null;
      }
    }
    
    int source = code.length;
    code.put1(Constants.LOOKUPSWITCH);
    while (code.length % 4 != 0) {
      code.put1(0);
    }
    dflt.put(this, code, source, true);
    code.put4(labels.length);
    for (int i = 0; i < labels.length; ++i) {
      code.put4(keys[i]);
      labels[i].put(this, code, source, true);
    }
  }

  public void visitMultiANewArrayInsn (final String desc, final int dims) {
    if (computeMaxs) {
      
      
      stackSize += 1 - dims;
    }
    
    Item classItem = cw.newClass(desc);
    code.put12(Constants.MULTIANEWARRAY, classItem.index).put1(dims);
  }

  public void visitTryCatchBlock (
    final Label start,
    final Label end,
    final Label handler,
    final String type)
  {
    if (CHECK) {
      if (start.owner != this || end.owner != this || handler.owner != this) {
        throw new IllegalArgumentException();
      }
      if (!start.resolved || !end.resolved || !handler.resolved) {
        throw new IllegalArgumentException();
      }
    }
    if (computeMaxs) {
      
      if (!handler.pushed) {
        handler.beginStackSize = 1;
        handler.pushed = true;
        handler.next = blockStack;
        blockStack = handler;
      }
    }
    ++catchCount;
    if (catchTable == null) {
      catchTable = new ByteVector();
    }
    catchTable.put2(start.position);
    catchTable.put2(end.position);
    catchTable.put2(handler.position);
    catchTable.put2(type != null ? cw.newClass(type).index : 0);
  }

  public void visitMaxs (final int maxStack, final int maxLocals) {
    if (computeMaxs) {
      
      int max = 0;
      
      
      
      
      
      
      
      Label stack = blockStack;
      while (stack != null) {
        
        Label l = stack;
        stack = stack.next;
        
        int start = l.beginStackSize;
        int blockMax = start + l.maxStackSize;
        
        if (blockMax > max) {
          max = blockMax;
        }
        
        Edge b = l.successors;
        while (b != null) {
          l = b.successor;
          
          if (!l.pushed) {
            
            l.beginStackSize = start + b.stackSize;
            
            l.pushed = true;
            l.next = stack;
            stack = l;
          }
          b = b.next;
        }
      }
      this.maxStack = max;
      
      synchronized (SIZE) {
        
        if (tail != null) {
          tail.poolNext = pool;
          pool = head;
        }
      }
    } else {
      this.maxStack = maxStack;
      this.maxLocals = maxLocals;
    }
  }

  public void visitLocalVariable (
    final String name,
    final String desc,
    final Label start,
    final Label end,
    final int index)
  {
    if (CHECK) {
      if (start.owner != this || !start.resolved) {
        throw new IllegalArgumentException();
      }
      if (end.owner != this || !end.resolved) {
        throw new IllegalArgumentException();
      }
    }
    if (localVar == null) {
      cw.newUTF8(""LocalVariableTable"");
      localVar = new ByteVector();
    }
    ++localVarCount;
    localVar.put2(start.position);
    localVar.put2(end.position - start.position);
    localVar.put2(cw.newUTF8(name).index);
    localVar.put2(cw.newUTF8(desc).index);
    localVar.put2(index);
  }

  public void visitLineNumber (final int line, final Label start) {
    if (CHECK) {
      if (start.owner != this || !start.resolved) {
        throw new IllegalArgumentException();
      }
    }
    if (lineNumber == null) {
      cw.newUTF8(""LineNumberTable"");
      lineNumber = new ByteVector();
    }
    ++lineNumberCount;
    lineNumber.put2(start.position);
    lineNumber.put2(line);
  }

  
  
  

  

  private static int getArgumentsAndReturnSizes (final String desc) {
    int n = 1;
    int c = 1;
    while (true) {
      char car = desc.charAt(c++);
      if (car == ')') {
        car = desc.charAt(c);
        return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
      } else if (car == 'L') {
        while (desc.charAt(c++) != ';') {
        }
        n += 1;
      } else if (car == '[') {
        while ((car = desc.charAt(c)) == '[') {
          ++c;
        }
        if (car == 'D' || car == 'J') {
          n -= 1;
        }
      } else if (car == 'D' || car == 'J') {
        n += 2;
      } else {
        n += 1;
      }
    }
  }

  

  private void addSuccessor (final int stackSize, final Label successor) {
    Edge b;
    
    synchronized (SIZE) {
      if (pool == null) {
        b = new Edge();
      } else {
        b = pool;
        
        pool = pool.poolNext;
      }
    }
    
    if (tail == null) {
      tail = b;
    }
    b.poolNext = head;
    head = b;
    
    b.stackSize = stackSize;
    b.successor = successor;
    
    b.next = currentBlock.successors;
    currentBlock.successors = b;
  }

  
  
  

  

  final int getSize () {
    if (resize) {
      
      resizeInstructions(new int[0], new int[0], 0);
    }
    int size = 8;
    if (code.length > 0) {
      cw.newUTF8(""Code"");
      size += 18 + code.length + 8 * catchCount;
      if (localVar != null) {
        size += 8 + localVar.length;
      }
      if (lineNumber != null) {
        size += 8 + lineNumber.length;
      }
    }
    if (exceptionCount > 0) {
      cw.newUTF8(""Exceptions"");
      size += 8 + 2 * exceptionCount;
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      cw.newUTF8(""Synthetic"");
      size += 6;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      cw.newUTF8(""Deprecated"");
      size += 6;
    }
    return size;
  }

  

  final void put (final ByteVector out) {
    out.put2(access).put2(name.index).put2(desc.index);
    int attributeCount = 0;
    if (code.length > 0) {
      ++attributeCount;
    }
    if (exceptionCount > 0) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      ++attributeCount;
    }
    out.put2(attributeCount);
    if (code.length > 0) {
      int size = 12 + code.length + 8 * catchCount;
      if (localVar != null) {
        size += 8 + localVar.length;
      }
      if (lineNumber != null) {
        size += 8 + lineNumber.length;
      }
      out.put2(cw.newUTF8(""Code"").index).put4(size);
      out.put2(maxStack).put2(maxLocals);
      out.put4(code.length).putByteArray(code.data, 0, code.length);
      out.put2(catchCount);
      if (catchCount > 0) {
        out.putByteArray(catchTable.data, 0, catchTable.length);
      }
      attributeCount = 0;
      if (localVar != null) {
        ++attributeCount;
      }
      if (lineNumber != null) {
        ++attributeCount;
      }
      out.put2(attributeCount);
      if (localVar != null) {
        out.put2(cw.newUTF8(""LocalVariableTable"").index);
        out.put4(localVar.length + 2).put2(localVarCount);
        out.putByteArray(localVar.data, 0, localVar.length);
      }
      if (lineNumber != null) {
        out.put2(cw.newUTF8(""LineNumberTable"").index);
        out.put4(lineNumber.length + 2).put2(lineNumberCount);
        out.putByteArray(lineNumber.data, 0, lineNumber.length);
      }
    }
    if (exceptionCount > 0) {
      out.put2(cw.newUTF8(""Exceptions"").index).put4(2 * exceptionCount + 2);
      out.put2(exceptionCount);
      for (int i = 0; i < exceptionCount; ++i) {
        out.put2(exceptions[i]);
      }
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      out.put2(cw.newUTF8(""Synthetic"").index).put4(0);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      out.put2(cw.newUTF8(""Deprecated"").index).put4(0);
    }
  }

  
  
  

  

  protected int[] resizeInstructions (
    final int[] indexes,
    final int[] sizes,
    final int len)
  {
    byte[] b = code.data; 
    int u, v, label;      
    int i, j;             

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    int[] allIndexes = new int[len]; 
    int[] allSizes = new int[len];   
    boolean[] resize;                
    int newOffset;                   

    System.arraycopy(indexes, 0, allIndexes, 0, len);
    System.arraycopy(sizes, 0, allSizes, 0, len);
    resize = new boolean[code.length];

    int state = 3; 
    do {
      if (state == 3) {
        state = 2;
      }
      u = 0;
      while (u < b.length) {
        int opcode = b[u] & 0xFF;  
        int insert = 0;            

        switch (ClassWriter.TYPE[opcode]) {
          case ClassWriter.NOARG_INSN:
          case ClassWriter.IMPLVAR_INSN:
            u += 1;
            break;
          case ClassWriter.LABEL_INSN:
            if (opcode > 201) {
              
              
              opcode = opcode < 218 ? opcode - 49 : opcode - 20;
              label = u + readUnsignedShort(b, u + 1);
            } else {
              label = u + readShort(b, u + 1);
            }
            newOffset = getNewOffset(allIndexes, allSizes, u, label);
            if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {
              if (!resize[u]) {
                if (opcode == Constants.GOTO || opcode == Constants.JSR) {
                  
                  
                  insert = 2;
                } else {
                  
                  
                  
                  
                  
                  insert = 5;
                }
                resize[u] = true;
              }
            }
            u += 3;
            break;
          case ClassWriter.LABELW_INSN:
            u += 5;
            break;
          case ClassWriter.TABL_INSN:
            if (state == 1) {
              
              
              
              
              
              
              newOffset = getNewOffset(allIndexes, allSizes, 0, u);
              insert = -(newOffset & 3);
            } else if (!resize[u]) {
              
              
              
              insert = u & 3;
              resize[u] = true;
            }
            
            u = u + 4 - (u & 3);
            u += 4*(readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;
            break;
          case ClassWriter.LOOK_INSN:
            if (state == 1) {
              
              newOffset = getNewOffset(allIndexes, allSizes, 0, u);
              insert = -(newOffset & 3);
            } else if (!resize[u]) {
              
              insert = u & 3;
              resize[u] = true;
            }
            
            u = u + 4 - (u & 3);
            u += 8*readInt(b, u + 4) + 8;
            break;
          case ClassWriter.WIDE_INSN:
            opcode = b[u + 1] & 0xFF;
            if (opcode == Constants.IINC) {
              u += 6;
            } else {
              u += 4;
            }
            break;
          case ClassWriter.VAR_INSN:
          case ClassWriter.SBYTE_INSN:
          case ClassWriter.LDC_INSN:
            u += 2;
            break;
          case ClassWriter.SHORT_INSN:
          case ClassWriter.LDCW_INSN:
          case ClassWriter.FIELDORMETH_INSN:
          case ClassWriter.TYPE_INSN:
          case ClassWriter.IINC_INSN:
            u += 3;
            break;
          case ClassWriter.ITFMETH_INSN:
            u += 5;
            break;
          
          default:
            u += 4;
            break;
        }
        if (insert != 0) {
          
          int[] newIndexes = new int[allIndexes.length + 1];
          int[] newSizes = new int[allSizes.length + 1];
          System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);
          System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);
          newIndexes[allIndexes.length] = u;
          newSizes[allSizes.length] = insert;
          allIndexes = newIndexes;
          allSizes = newSizes;
          if (insert > 0) {
            state = 3;
          }
        }
      }
      if (state < 3) {
        --state;
      }
    } while (state != 0);

    
    
    

    ByteVector newCode = new ByteVector(code.length);

    u = 0;
    while (u < code.length) {
      for (i = allIndexes.length - 1; i >= 0; --i) {
        if (allIndexes[i] == u) {
          if (i < len) {
            if (sizes[i] > 0) {
              newCode.putByteArray(null, 0, sizes[i]);
            } else {
              newCode.length += sizes[i];
            }
            indexes[i] = newCode.length;
          }
        }
      }
      int opcode = b[u] & 0xFF;
      switch (ClassWriter.TYPE[opcode]) {
        case ClassWriter.NOARG_INSN:
        case ClassWriter.IMPLVAR_INSN:
          newCode.put1(opcode);
          u += 1;
          break;
        case ClassWriter.LABEL_INSN:
          if (opcode > 201) {
            
            
            opcode = opcode < 218 ? opcode - 49 : opcode - 20;
            label = u + readUnsignedShort(b, u + 1);
          } else {
            label = u + readShort(b, u + 1);
          }
          newOffset = getNewOffset(allIndexes, allSizes, u, label);
          if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {
            
            
            
            
            if (opcode == Constants.GOTO) {
              newCode.put1(200); 
            } else if (opcode == Constants.JSR) {
              newCode.put1(201); 
            } else {
              newCode.put1(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);
              newCode.put2(8);   
              newCode.put1(200); 
              newOffset -= 3;    
            }
            newCode.put4(newOffset);
          } else {
            newCode.put1(opcode);
            newCode.put2(newOffset);
          }
          u += 3;
          break;
        case ClassWriter.LABELW_INSN:
          label = u + readInt(b, u + 1);
          newOffset = getNewOffset(allIndexes, allSizes, u, label);
          newCode.put1(opcode);
          newCode.put4(newOffset);
          u += 5;
          break;
        case ClassWriter.TABL_INSN:
          
          v = u;
          u = u + 4 - (v & 3);
          
          int source = newCode.length;
          newCode.put1(Constants.TABLESWITCH);
          while (newCode.length % 4 != 0) {
            newCode.put1(0);
          }
          label = v + readInt(b, u); u += 4;
          newOffset = getNewOffset(allIndexes, allSizes, v, label);
          newCode.put4(newOffset);
          j = readInt(b, u); u += 4;
          newCode.put4(j);
          j = readInt(b, u) - j + 1; u += 4;
          newCode.put4(readInt(b, u - 4));
          for ( ; j > 0; --j) {
            label = v + readInt(b, u); u += 4;
            newOffset = getNewOffset(allIndexes, allSizes, v, label);
            newCode.put4(newOffset);
          }
          break;
        case ClassWriter.LOOK_INSN:
          
          v = u;
          u = u + 4 - (v & 3);
          
          source = newCode.length;
          newCode.put1(Constants.LOOKUPSWITCH);
          while (newCode.length % 4 != 0) {
            newCode.put1(0);
          }
          label = v + readInt(b, u); u += 4;
          newOffset = getNewOffset(allIndexes, allSizes, v, label);
          newCode.put4(newOffset);
          j = readInt(b, u); u += 4;
          newCode.put4(j);
          for ( ; j > 0; --j) {
            newCode.put4(readInt(b, u)); u += 4;
            label = v + readInt(b, u); u += 4;
            newOffset = getNewOffset(allIndexes, allSizes, v, label);
            newCode.put4(newOffset);
          }
          break;
        case ClassWriter.WIDE_INSN:
          opcode = b[u + 1] & 0xFF;
          if (opcode == Constants.IINC) {
            newCode.putByteArray(b, u, 6);
            u += 6;
          } else {
            newCode.putByteArray(b, u, 4);
            u += 4;
          }
          break;
        case ClassWriter.VAR_INSN:
        case ClassWriter.SBYTE_INSN:
        case ClassWriter.LDC_INSN:
          newCode.putByteArray(b, u, 2);
          u += 2;
          break;
        case ClassWriter.SHORT_INSN:
        case ClassWriter.LDCW_INSN:
        case ClassWriter.FIELDORMETH_INSN:
        case ClassWriter.TYPE_INSN:
        case ClassWriter.IINC_INSN:
          newCode.putByteArray(b, u, 3);
          u += 3;
          break;
        case ClassWriter.ITFMETH_INSN:
          newCode.putByteArray(b, u, 5);
          u += 5;
          break;
        
        default:
          newCode.putByteArray(b, u, 4);
          u += 4;
          break;
      }
    }

    
    
    if (catchTable != null) {
      b = catchTable.data;
      u = 0;
      while (u < catchTable.length) {
        writeShort(b, u, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u)));
        writeShort(b, u + 2, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u + 2)));
        writeShort(b, u + 4, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u + 4)));
        u += 8;
      }
    }
    if (localVar != null) {
      b = localVar.data;
      u = 0;
      while (u < localVar.length) {
        label = readUnsignedShort(b, u);
        newOffset = getNewOffset(allIndexes, allSizes, 0, label);
        writeShort(b, u, newOffset);
        label += readUnsignedShort(b, u + 2);
        newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;
        writeShort(b, u, newOffset);
        u += 10;
      }
    }
    if (lineNumber != null) {
      b = lineNumber.data;
      u = 0;
      while (u < lineNumber.length) {
        writeShort(b, u, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u)));
        u += 4;
      }
    }

    
    code = newCode;

    
    return indexes;
  }

  

  static int readUnsignedShort (final byte[] b, final int index) {
    return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
  }

  

  static short readShort (final byte[] b, final int index) {
    return (short)(((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));
  }

  

  static int readInt (final byte[] b, final int index) {
    return ((b[index] & 0xFF) << 24) |
           ((b[index + 1] & 0xFF) << 16) |
           ((b[index + 2] & 0xFF) << 8) |
           (b[index + 3] & 0xFF);
  }

  

  static void writeShort (final byte[] b, final int index, final int s) {
    b[index] = (byte)(s >>> 8);
    b[index + 1] = (byte)s;
  }

  

  static int getNewOffset (
    final int[] indexes,
    final int[] sizes,
    final int begin,
    final int end)
  {
    int offset = end - begin;
    for (int i = 0; i < indexes.length; ++i) {
      if (begin < indexes[i] && indexes[i] <= end) { 
        offset += sizes[i];
      } else if (end < indexes[i] && indexes[i] <= begin) { 
        offset -= sizes[i];
      }
    }
    return offset;
  }

  

  protected int getCodeSize () {
    return code.length;
  }

  

  protected byte[] getCode () {
    return code.data;
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.PluginListHandler,11,2,0,7,38,23,1,7,7,0.8,541,1.0,4,0.62962963,0.285714286,1,3,46.09090909,12,3.4545,0,"

package org.gjt.sp.jedit.pluginmgr;


import java.util.Stack;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;



class PluginListHandler extends DefaultHandler
{
	
	PluginListHandler(PluginList pluginList, String path)
	{
		this.pluginList = pluginList;
		this.path = path;

		author = new StringBuilder();
		description = new StringBuilder();
		pluginSetEntry = new StringBuilder();
		download = new StringBuilder();
		downloadSource = new StringBuilder();
	} 

	
	public InputSource resolveEntity(String publicId, String systemId)
	{
		return XMLUtilities.findEntity(systemId, ""plugins.dtd"", getClass());
	} 

	
	public void attribute(String aname, String value, boolean isSpecified)
	{
		if(aname == ""NAME"")
			name = value;
		else if(aname == ""JAR"")
			jar = value;
		else if(aname == ""VERSION"")
			version = value;
		else if(aname == ""DATE"")
			date = value;
		else if(aname == ""OBSOLETE"")
			obsolete = (""TRUE"".equals(value));
		else if(aname == ""WHAT"")
			depWhat = value;
		else if(aname == ""FROM"")
			depFrom = value;
		else if(aname == ""TO"")
			depTo = value;
		else if(aname == ""PLUGIN"")
			depPlugin = value;
		else if(aname == ""SIZE"")
		{
			size = Integer.parseInt(value);
			if(size == 0)
				Log.log(Log.WARNING,this,""SIZE = 0"");
		}
	} 

	
	public void characters(char[] c, int off, int len)
	{
		String tag = peekElement();

		if(tag.equals(""DESCRIPTION""))
		{
			description.append(c, off, len);
		}
		else if(tag.equals(""PLUGIN_SET_ENTRY""))
			pluginSetEntry.append(c, off, len);
		else if(tag.equals(""AUTHOR""))
		{
			if(author.length() != 0)
				author.append("", "");
			author.append(c, off, len);
		}
		else if(tag.equals(""DOWNLOAD""))
			download.append(c, off, len);
		else if(tag.equals(""DOWNLOAD_SOURCE""))
			downloadSource.append(c, off, len);
	} 

	
	public void startElement(String uri, String localName,
				 String tag, Attributes attrs)
	{
		for (int i = 0; i < attrs.getLength(); i++)
		{
			String aName = attrs.getQName(i);
			String aValue = attrs.getValue(i);
			attribute(aName, aValue, true);
		}


		tag = pushElement(tag);

		if(tag.equals(""PLUGIN_SET""))
		{
			description.setLength(0);
			pluginSet = new PluginList.PluginSet();
			pluginSet.name = name;
		}
		else if(tag.equals(""PLUGIN""))
		{
			description.setLength(0);
			author.setLength(0);
			branch = null;
			plugin = new PluginList.Plugin();
		}
		else if(tag.equals(""BRANCH""))
		{
			download.setLength(0);
			branch = new PluginList.Branch();
		}
		else if(tag.equals(""DOWNLOAD""))
			downloadSize = size;
		else if(tag.equals(""DOWNLOAD_SOURCE""))
			downloadSourceSize = size;
	} 

	
	public void endElement(String uri, String localName, String tag)
	{
		popElement();

		if(tag.equals(""PLUGIN_SET""))
		{
			pluginList.addPluginSet(pluginSet);
			pluginSet = null;
			pluginSetEntry.setLength(0);
		}
		else if(tag.equals(""PLUGIN_SET_ENTRY""))
		{
			pluginSet.plugins.add(pluginSetEntry.toString());
			pluginSetEntry.setLength(0);
		}
		else if(tag.equals(""PLUGIN""))
		{
			plugin.jar = jar;
			plugin.name = name;
			plugin.author = author.toString();
			plugin.description = description.toString();
			pluginList.addPlugin(plugin);
			jar = null;
			name = null;
			author.setLength(0);
			description.setLength(0);
		}
		else if(tag.equals(""BRANCH""))
		{
			branch.version = version;
			branch.date = date;
			branch.download = download.toString();
			branch.downloadSize = downloadSize;
			branch.downloadSource = downloadSource.toString();
			branch.downloadSourceSize = downloadSourceSize;
			branch.obsolete = obsolete;
			plugin.branches.add(branch);
			version = null;
			download.setLength(0);
			downloadSource.setLength(0);
			obsolete = false;
		}
		else if(tag.equals(""DEPEND""))
		{
			PluginList.Dependency dep = new PluginList.Dependency(
				depWhat,depFrom,depTo,depPlugin);
			branch.deps.add(dep);
			depWhat = null;
			depFrom = null;
			depTo = null;
			depPlugin = null;
		}
	} 

	
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, this, e);
		}
	} 

	
	public void endDocument()
	{
		pluginList.finished();
	} 

	

	
	
	
	private final String path;

	private final PluginList pluginList;

	private PluginList.PluginSet pluginSet;
	private final StringBuilder pluginSetEntry;

	private PluginList.Plugin plugin;
	private String jar;
	private StringBuilder author;

	private PluginList.Branch branch;
	private boolean obsolete;
	private String version;
	private String date;
	private StringBuilder download;
	private int downloadSize;
	private StringBuilder downloadSource;
	private int downloadSourceSize;
	private int size;
	private String depWhat;
	private String depFrom;
	private String depTo;
	private String depPlugin;

	private String name;
	private StringBuilder description;

	private final Stack<String> stateStack = new Stack<String>();
	

	
	private String pushElement(String name)
	{
		stateStack.push(name);
		return name;
	} 

	
	private String peekElement()
	{
		return stateStack.peek();
	} 

	
	private String popElement()
	{
		return stateStack.pop();
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.StatusBarOptionPane,12,6,0,9,72,32,3,8,1,0.843434343,657,1.0,9,0.983823529,0.5,2,5,52.25,7,1.6667,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;



public class StatusBarOptionPane extends AbstractOptionPane
{
	
	public StatusBarOptionPane()
	{
		super(""status"");
	} 

	
	@Override
	protected void _init()
	{
		setLayout(new BorderLayout());

		
		JPanel panel = new JPanel(new GridLayout(2,1));
		showStatusbar = new JCheckBox(jEdit.getProperty(
			""options.status.visible""));
		showStatusbar.setSelected(jEdit.getBooleanProperty(""view.status.visible""));
		panel.add(showStatusbar);
		showStatusbarPlain = new JCheckBox(jEdit.getProperty(
			""options.status.plainview.visible""));
		showStatusbarPlain.setSelected(jEdit.getBooleanProperty(""view.status.plainview.visible""));
		panel.add(showStatusbarPlain);
		panel.add(new JLabel(jEdit.getProperty(
			""options.status.caption"")));
		add(panel, BorderLayout.NORTH);
		

		
		AbstractOptionPane optionsPanel = new AbstractOptionPane(""Status Options"");
		
		optionsPanel.addComponent(jEdit.getProperty(""options.status.foreground""),
			foregroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.foreground"")),
			GridBagConstraints.VERTICAL);

		
		optionsPanel.addComponent(jEdit.getProperty(""options.status.background""),
			backgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.background"")),
			GridBagConstraints.VERTICAL);

		
		optionsPanel.addComponent(jEdit.getProperty(""options.status.memory.foreground""),
			memForegroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.memory.foreground"")),
			GridBagConstraints.VERTICAL);

		
		optionsPanel.addComponent(jEdit.getProperty(""options.status.memory.background""),
			memBackgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.memory.background"")),
			GridBagConstraints.VERTICAL);

		optionsPanel.addSeparator();
		optionsPanel.addComponent(new JLabel(jEdit.getProperty(""options.status.caret.title"", ""Caret position display options:"")));

		
		showCaretLineNumber = new JCheckBox(jEdit.getProperty(""options.status.caret.linenumber"", ""Show caret line number""),
			jEdit.getBooleanProperty(""view.status.show-caret-linenumber"", true));
		showCaretLineNumber.setName(""showCaretLineNumber"");
		showCaretDot = new JCheckBox(jEdit.getProperty(""options.status.caret.dot"", ""Show caret offset from start of line""),
			jEdit.getBooleanProperty(""view.status.show-caret-dot"", true));
		showCaretDot.setName(""showCaretDot"");
		showCaretVirtual = new JCheckBox(jEdit.getProperty(""options.status.caret.virtual"", ""Show caret virtual offset from start of line""),
			jEdit.getBooleanProperty(""view.status.show-caret-virtual"", true));
		showCaretVirtual.setName(""showCaretVirtual"");
		showCaretOffset = new JCheckBox(jEdit.getProperty(""options.status.caret.offset"", ""Show caret offset from start of file""),
			jEdit.getBooleanProperty(""view.status.show-caret-offset"", true));
		showCaretOffset.setName(""showCaretOffset"");
		showCaretBufferLength = new JCheckBox(jEdit.getProperty(""options.status.caret.bufferlength"", ""Show length of file""),
			jEdit.getBooleanProperty(""view.status.show-caret-bufferlength"", true));
		showCaretBufferLength.setName(""showCaretBufferLength"");
		optionsPanel.addComponent(showCaretLineNumber);
		optionsPanel.addComponent(showCaretDot);
		optionsPanel.addComponent(showCaretVirtual);
		optionsPanel.addComponent(showCaretOffset);
		optionsPanel.addComponent(showCaretBufferLength);

		


		
		String statusbar = jEdit.getProperty(""view.status"");
		StringTokenizer st = new StringTokenizer(statusbar);
		listModel = new DefaultListModel();
		while (st.hasMoreTokens())
		{
			String token = st.nextToken();
			listModel.addElement(token);
		}


		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());

		JPanel widgetsPanel = new JPanel(new BorderLayout());
		widgetsPanel.add(new JScrollPane(list), BorderLayout.CENTER);
		

		
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.status.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.status.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""options.status.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""options.status.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createHorizontalStrut(6));
		edit = new RolloverButton(GUIUtilities.loadIcon(""ButtonProperties.png""));
		edit.setToolTipText(jEdit.getProperty(""options.status.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());
		

		updateButtons();
		widgetsPanel.add(buttons, BorderLayout.SOUTH);


		JTabbedPane tabs = new JTabbedPane();
		tabs.addTab(""Options"",optionsPanel);
		tabs.add(""Widgets"", widgetsPanel);

		add(tabs, BorderLayout.CENTER);
	} 

	
	@Override
	protected void _save()
	{
		jEdit.setColorProperty(""view.status.foreground"",foregroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.status.background"",backgroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.status.memory.foreground"",memForegroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.status.memory.background"",memBackgroundColor
			.getSelectedColor());

		jEdit.setBooleanProperty(""view.status.visible"",showStatusbar
			.isSelected());

		jEdit.setBooleanProperty(""view.status.plainview.visible"",showStatusbarPlain
			.isSelected());

		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');

			String widgetName = (String) listModel.elementAt(i);
			buf.append(widgetName);
		}
		jEdit.setProperty(""view.status"",buf.toString());

		jEdit.setBooleanProperty(""view.status.show-caret-linenumber"", showCaretLineNumber.isSelected());
		jEdit.setBooleanProperty(""view.status.show-caret-dot"", showCaretDot.isSelected());
		jEdit.setBooleanProperty(""view.status.show-caret-virtual"", showCaretVirtual.isSelected());
		jEdit.setBooleanProperty(""view.status.show-caret-offset"", showCaretOffset.isSelected());
		jEdit.setBooleanProperty(""view.status.show-caret-bufferlength"", showCaretBufferLength.isSelected());

	} 

	

	
	private ColorWellButton foregroundColor;
	private ColorWellButton backgroundColor;
	private ColorWellButton memForegroundColor;
	private ColorWellButton memBackgroundColor;
	private JCheckBox showStatusbar;
	private JCheckBox showStatusbarPlain;
	private DefaultListModel listModel;
	private JList list;
	private RolloverButton add;
	private RolloverButton remove;
	private RolloverButton moveUp, moveDown;
	private RolloverButton edit;

	private JCheckBox showCaretLineNumber;
	private JCheckBox showCaretDot;
	private JCheckBox showCaretVirtual;
	private JCheckBox showCaretOffset;
	private JCheckBox showCaretBufferLength;
	

	
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
		edit.setEnabled(index != -1);
	} 

	

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == add)
			{
				String value = selectWidget();
				if (value == null)
					return;


				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;

				listModel.insertElementAt(value,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				if(listModel.getSize() != 0)
				{
					if(listModel.getSize() == index)
						list.setSelectedIndex(index-1);
					else
						list.setSelectedIndex(index);
				}
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
			else if(source == edit)
			{
				String value = selectWidget();
				if (value == null)
					return;

				int index = list.getSelectedIndex();

				listModel.insertElementAt(value,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
		}

		private String selectWidget()
		{
			WidgetSelectionDialog dialog = new WidgetSelectionDialog(StatusBarOptionPane.this);
			String value = dialog.getValue();
			if (value != null && value.length() == 0)
				value = null;
			return value;
		}
	} 

	
	private class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	} 

	

	
	private class WidgetSelectionDialog extends EnhancedDialog
	{
		private JButton ok;
		private JButton cancel;
		private JTextField labelField;
		private JLabel labelLabel;
		private JRadioButton labelRadio;
		private JComboBox widgetCombo;
		private JLabel widgetLabel;
		private JRadioButton widgetRadio;
		private String value;

		
		WidgetSelectionDialog(Component comp)
		{
			super(GUIUtilities.getParentDialog(comp),
			      jEdit.getProperty(""options.status.edit.title""),
			      true);
			ButtonGroup buttonGroup = new ButtonGroup();
			labelRadio = new JRadioButton(jEdit.getProperty(""options.status.edit.labelRadioButton""));
			widgetRadio = new JRadioButton(jEdit.getProperty(""options.status.edit.widgetRadioButton""));
			buttonGroup.add(labelRadio);
			buttonGroup.add(widgetRadio);

			labelLabel = new JLabel(jEdit.getProperty(""options.status.edit.labelLabel""));
			labelField = new JTextField();

			widgetLabel = new JLabel(jEdit.getProperty(""options.status.edit.widgetLabel""));
			widgetCombo = new JComboBox(ServiceManager.getServiceNames(""org.gjt.sp.jedit.gui.statusbar.StatusWidget""));

			ActionHandler actionHandler = new ActionHandler();
			labelRadio.addActionListener(actionHandler);
			widgetRadio.addActionListener(actionHandler);
			
			JPanel southPanel = new JPanel();
			southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
			southPanel.setBorder(new EmptyBorder(12,0,0,0));
			southPanel.add(Box.createGlue());
			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(actionHandler);
			getRootPane().setDefaultButton(ok);
			southPanel.add(ok);
			southPanel.add(Box.createHorizontalStrut(6));
			cancel = new JButton(jEdit.getProperty(""common.cancel""));
			cancel.addActionListener(actionHandler);
			southPanel.add(cancel);
			southPanel.add(Box.createGlue());
			

			labelField.setEnabled(false);
			widgetRadio.setSelected(true);


			JPanel content = new JPanel(new BorderLayout());
			content.setBorder(new EmptyBorder(12,12,12,12));
			setContentPane(content);
			JPanel center = new JPanel();
			center.setLayout(new BoxLayout(center,BoxLayout.Y_AXIS));

			center.add(labelRadio);
			JPanel p = new JPanel(new BorderLayout());
			p.add(labelLabel, BorderLayout.WEST);
			p.add(labelField);
			center.add(p);
			center.add(widgetRadio);
			p = new JPanel(new BorderLayout());
			p.add(widgetLabel, BorderLayout.WEST);
			p.add(widgetCombo);
			center.add(p);



			getContentPane().add(center, BorderLayout.CENTER);
			getContentPane().add(southPanel, BorderLayout.SOUTH);
			pack();
			setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
			setVisible(true);
		} 

		
		@Override
		public void ok()
		{
			if (widgetRadio.isSelected())
			{
				value = (String) widgetCombo.getSelectedItem();
			}
			else
			{
				value = labelField.getText().trim();
			}
			dispose();
		} 

		
		@Override
		public void cancel()
		{
			value = null;
			dispose();
		} 

		
		public String getValue()
		{
			return value;
		} 

		
		private class ActionHandler implements ActionListener
		{
			
			public void actionPerformed(ActionEvent evt)
			{
				Object source = evt.getSource();
				if (source == ok)
				{
					ok();
				}
				else if (source == cancel)
				{
					cancel();
				}
				else if (source == labelRadio)
				{
					labelField.setEnabled(true);
					widgetCombo.setEnabled(false);
					validate();
				}
				else if (source == widgetRadio)
				{
					labelField.setEnabled(false);
					widgetCombo.setEnabled(true);
					validate();
				}
			} 

		} 

	} 

}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.EvalError,12,3,2,57,25,14,56,3,9,0.606060606,216,0.0,2,0.607142857,0.395833333,1,2,16.75,3,1.6667,0,"


package org.gjt.sp.jedit.bsh;


public class EvalError extends Exception 
{
	SimpleNode node;

	
	String message;

	CallStack callstack;

	public EvalError( String s, SimpleNode node, CallStack callstack ) {
		setMessage(s);
		this.node = node;
		
		if ( callstack != null )
			this.callstack = callstack.copy();
	}

	
	public String toString() 
	{
		String trace;
		if ( node != null )
			trace = "" : at Line: ""+ node.getLineNumber() 
				+ "" : in file: ""+ node.getSourceFile()
				+ "" : ""+node.getText();
		else
			
			trace = "": <at unknown location>"";

		if ( callstack != null )
			trace = trace +""\n"" + getScriptStackTrace();

		return getMessage() + trace;
	}

	
	public void reThrow( String msg ) 
		throws EvalError 
	{
		prependMessage( msg );
		throw this;
	}

	
	SimpleNode getNode() {
		return node;
	}

	void setNode( SimpleNode node ) {
		this.node = node;
	}

	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return ""<unknown error>"";
	}

	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}

	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return ""<unknown file>"";
	}

	public String getScriptStackTrace() 
	{
		if ( callstack == null )
			return ""<Unknown>"";

		String trace = """";
		CallStack stack = callstack.copy();
		while ( stack.depth() > 0 ) 
		{
			NameSpace ns = stack.pop();
			SimpleNode node = ns.getNode();
			if ( ns.isMethod )
			{
				trace = trace + ""\nCalled from method: "" + ns.getName();
				if ( node != null )
					trace += "" : at Line: ""+ node.getLineNumber() 
						+ "" : in file: ""+ node.getSourceFile()
						+ "" : ""+node.getText();
			}
		}

		return trace;
	}

	
	public String getMessage() { return message; }

	public void setMessage( String s ) { message = s; }

	
	protected void prependMessage( String s ) 
	{ 
		if ( s == null )
			return;

		if ( message == null )
			message = s;
		else
			message = s + "" : ""+ message;
	}

}

"
jEdit,4.3,org.gjt.sp.jedit.textarea.ChunkCache,27,1,0,20,65,65,9,13,0,0.683760684,1240,1.0,4,0.0,0.25462963,0,0,44.59259259,24,3.7407,0,"

package org.gjt.sp.jedit.textarea;


import java.util.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.util.Log;



class ChunkCache
{
	
	ChunkCache(TextArea textArea)
	{
		this.textArea = textArea;
		out = new ArrayList<Chunk>();
		tokenHandler = new DisplayTokenHandler();
	} 

	
	
	int getMaxHorizontalScrollWidth()
	{
		int max = 0;
		for(int i = 0; i < firstInvalidLine; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.width > max)
				max = info.width;
		}
		return max;
	} 

	
	
	int getScreenLineOfOffset(int line, int offset)
	{
		if(lineInfo.length == 0)
			return -1;
		if(line < textArea.getFirstPhysicalLine())
			return -1;
		if(line == textArea.getFirstPhysicalLine()
			&& offset < getLineInfo(0).offset)
			return -1;
		if(line > textArea.getLastPhysicalLine())
			return -1;
		
		if(line == lastScreenLineP)
		{
			LineInfo last = getLineInfo(lastScreenLine);

			if(offset >= last.offset
				&& offset < last.offset + last.length)
			{
				return lastScreenLine;
			}
		}

		int screenLine = -1;

		
		for(int i = 0; i < textArea.getVisibleLines(); i++)
		{
			LineInfo info = getLineInfo(i);
			if(info.physicalLine > line)
			{
				
				return i - 1;
				
			}
			if(info.physicalLine == line)
			{
				if(offset >= info.offset
					&& offset < info.offset + info.length)
				{
					screenLine = i;
					break;
				}
			}
		}

		if(screenLine == -1)
			return -1;


		lastScreenLineP = line;
		lastScreenLine = screenLine;

		return screenLine;
	} 

	
	
	void recalculateVisibleLines()
	{
		LineInfo[] newLineInfo = new LineInfo[textArea.getVisibleLines()];

		int start;
		if(lineInfo == null)
			start = 0;
		else
		{
			start = Math.min(lineInfo.length,newLineInfo.length);
			System.arraycopy(lineInfo,0,newLineInfo,0,start);
		}

		for(int i = start; i < newLineInfo.length; i++)
			newLineInfo[i] = new LineInfo();

		lineInfo = newLineInfo;

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void setBuffer(JEditBuffer buffer)
	{
		this.buffer = buffer;
		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void scrollDown(int amount)
	{
		int visibleLines = textArea.getVisibleLines();

		System.arraycopy(lineInfo,amount,lineInfo,0,visibleLines - amount);

		for(int i = visibleLines - amount; i < visibleLines; i++)
		{
			lineInfo[i] = new LineInfo();
		}

		firstInvalidLine -= amount;
		if(firstInvalidLine < 0)
			firstInvalidLine = 0;

		if(Debug.CHUNK_CACHE_DEBUG)
		{
			System.err.println(""f > t.f: only "" + amount
				+ "" need updates"");
		}

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void scrollUp(int amount)
	{
		System.arraycopy(lineInfo,0,lineInfo,amount,
			textArea.getVisibleLines() - amount);

		for(int i = 0; i < amount; i++)
		{
			lineInfo[i] = new LineInfo();
		}

		
		int oldFirstInvalidLine = firstInvalidLine;
		firstInvalidLine = 0;
		updateChunksUpTo(amount);
		firstInvalidLine = oldFirstInvalidLine + amount;
		if(firstInvalidLine > textArea.getVisibleLines())
			firstInvalidLine = textArea.getVisibleLines();

		if(Debug.CHUNK_CACHE_DEBUG)
		{
			Log.log(Log.DEBUG,this,""f > t.f: only "" + amount
				+ "" need updates"");
		}

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void invalidateAll()
	{
		firstInvalidLine = 0;
		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void invalidateChunksFromPhys(int physicalLine)
	{
		for(int i = 0; i < firstInvalidLine; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.physicalLine == -1 || info.physicalLine >= physicalLine)
			{
				firstInvalidLine = i;
				if(i <= lastScreenLine)
					lastScreenLine = lastScreenLineP = -1;
				break;
			}
		}
	} 

	
	
	LineInfo getLineInfo(int screenLine)
	{
		updateChunksUpTo(screenLine);
		return lineInfo[screenLine];
	} 

	
	
	int getLineSubregionCount(int physicalLine)
	{
		if(!textArea.softWrap)
			return 1;

		out.clear();
		lineToChunkList(physicalLine,out);

		int size = out.size();
		if(size == 0)
			return 1;
		else
			return size;
	} 

	
	
	static int getSubregionOfOffset(int offset, LineInfo[] lineInfos)
	{
		for(int i = 0; i < lineInfos.length; i++)
		{
			LineInfo info = lineInfos[i];
			if(offset >= info.offset && offset < info.offset + info.length)
				return i;
		}

		return -1;
	} 

	
	
	int xToSubregionOffset(int physicalLine, int subregion, int x,
		boolean round)
	{
		LineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);
		if(subregion == -1)
			subregion += infos.length;
		return xToSubregionOffset(infos[subregion],x,round);
	} 

	
	
	static int xToSubregionOffset(LineInfo info, int x,
		boolean round)
	{
		int offset = Chunk.xToOffset(info.chunks,x,round);
		if(offset == -1 || offset == info.offset + info.length)
			offset = info.offset + info.length - 1;

		return offset;
	} 

	
	
	int subregionOffsetToX(int physicalLine, int offset)
	{
		LineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);
		LineInfo info = infos[getSubregionOfOffset(offset,infos)];
		return subregionOffsetToX(info,offset);
	} 

	
	
	static int subregionOffsetToX(LineInfo info, int offset)
	{
		return (int)Chunk.offsetToX(info.chunks,offset);
	} 

	
	
	int getSubregionStartOffset(int line, int offset)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(line);
		LineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];
		return textArea.getLineStartOffset(info.physicalLine)
			+ info.offset;
	} 

	
	
	int getSubregionEndOffset(int line, int offset)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(line);
		LineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];
		return textArea.getLineStartOffset(info.physicalLine)
			+ info.offset + info.length;
	} 

	
	
	int getBelowPosition(int physicalLine, int offset, int x,
		boolean ignoreWrap)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);

		int subregion = getSubregionOfOffset(offset,lineInfos);

		if(subregion != lineInfos.length - 1 && !ignoreWrap)
		{
			return textArea.getLineStartOffset(physicalLine)
				+ xToSubregionOffset(lineInfos[subregion + 1],
				x,true);
		}
		else
		{
			int nextLine = textArea.displayManager
				.getNextVisibleLine(physicalLine);

			if(nextLine == -1)
				return -1;
			else
			{
				return textArea.getLineStartOffset(nextLine)
					+ xToSubregionOffset(nextLine,0,
					x,true);
			}
		}
	} 

	
	
	int getAbovePosition(int physicalLine, int offset, int x,
		boolean ignoreWrap)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);

		int subregion = getSubregionOfOffset(offset,lineInfos);

		if(subregion != 0 && !ignoreWrap)
		{
			return textArea.getLineStartOffset(physicalLine)
				+ xToSubregionOffset(lineInfos[subregion - 1],
				x,true);
		}
		else
		{
			int prevLine = textArea.displayManager
				.getPrevVisibleLine(physicalLine);

			if(prevLine == -1)
				return -1;
			else
			{
				return textArea.getLineStartOffset(prevLine)
					+ xToSubregionOffset(prevLine,-1,
					x,true);
			}
		}
	} 

	
	
	boolean needFullRepaint()
	{
		boolean retVal = needFullRepaint;
		needFullRepaint = false;
		return retVal;
	} 

	
	LineInfo[] getLineInfosForPhysicalLine(int physicalLine)
	{
		out.clear();

		if(!buffer.isLoading())
			lineToChunkList(physicalLine,out);

		if(out.isEmpty())
			out.add(null);

		List<LineInfo> returnValue = new ArrayList<LineInfo>(out.size());
		getLineInfosForPhysicalLine(physicalLine,returnValue);
		return returnValue.toArray(new LineInfo[out.size()]);
	} 

	

	
	private final TextArea textArea;
	private JEditBuffer buffer;
	
	private LineInfo[] lineInfo;
	private final List<Chunk> out;

	
	private int firstInvalidLine;
	private int lastScreenLineP;
	private int lastScreenLine;

	private boolean needFullRepaint;

	private final DisplayTokenHandler tokenHandler;
	

	
	private void getLineInfosForPhysicalLine(int physicalLine, List<LineInfo> list)
	{
		for(int i = 0; i < out.size(); i++)
		{
			Chunk chunks = out.get(i);
			LineInfo info = new LineInfo();
			info.physicalLine = physicalLine;
			if(i == 0)
			{
				info.firstSubregion = true;
				info.offset = 0;
			}
			else
				info.offset = chunks.offset;

			if(i == out.size() - 1)
			{
				info.lastSubregion = true;
				info.length = textArea.getLineLength(physicalLine)
					- info.offset + 1;
			}
			else
			{
				info.length = out.get(i + 1).offset
					- info.offset;
			}

			info.chunks = chunks;

			list.add(info);
		}
	} 

	
	
	private int getFirstScreenLine()
	{
		for(int i = firstInvalidLine - 1; i >= 0; i--)
		{
			if(lineInfo[i].lastSubregion)
				return i + 1;
		}

		return 0;
	} 

	
	
	private int getUpdateStartLine(int firstScreenLine)
	{
		
		
		if(firstScreenLine == 0)
		{
			return textArea.getFirstPhysicalLine();
		}
		
		else
		{
			int prevPhysLine = lineInfo[
				firstScreenLine - 1]
				.physicalLine;
			
			
			if(prevPhysLine == -1)
				return -1;
			else
			{
				return textArea.displayManager
					.getNextVisibleLine(prevPhysLine);
			}
		}
	} 

	
	private void updateChunksUpTo(int lastScreenLine)
	{
		
		if(lastScreenLine >= lineInfo.length)
			throw new ArrayIndexOutOfBoundsException(lastScreenLine);

		
		
		if(lastScreenLine < firstInvalidLine)
			return;

		int firstScreenLine = getFirstScreenLine();
		int physicalLine = getUpdateStartLine(firstScreenLine);

		if(Debug.CHUNK_CACHE_DEBUG)
		{
			Log.log(Log.DEBUG,this,""Updating chunks from "" + firstScreenLine
				+ "" to "" + lastScreenLine);
		}

		
		
		
		

		out.clear();

		int offset;
		int length;

		for(int i = firstScreenLine; i <= lastScreenLine; i++)
		{
			LineInfo info = lineInfo[i];

			Chunk chunks;

			
			if(out.isEmpty())
			{
				
				
				if(physicalLine != -1 && i != firstScreenLine)
				{
					physicalLine = textArea.displayManager
						.getNextVisibleLine(physicalLine);
				}

				
				if(physicalLine == -1)
				{
					info.chunks = null;
					info.physicalLine = -1;
					
					
					
					info.width = 0;
					continue;
				}

				
				lineToChunkList(physicalLine,out);

				info.firstSubregion = true;

				
				if(out.isEmpty())
				{
					if(i == 0)
					{
						if(textArea.displayManager.firstLine.skew > 0)
						{
							Log.log(Log.ERROR,this,""BUG: skew="" + textArea.displayManager.firstLine.skew + "",out.size()="" + out.size());
							textArea.displayManager.firstLine.skew = 0;
							needFullRepaint = true;
							lastScreenLine = lineInfo.length - 1;
						}
					}
					chunks = null;
					offset = 0;
					length = 1;
				}
				
				else
				{
					if(i == 0)
					{
						int skew = textArea.displayManager.firstLine.skew;
						if(skew >= out.size())
						{
							
							
							Log.log(Log.ERROR,this,""BUG: skew="" + skew + "",out.size()="" + out.size());
							needFullRepaint = true;
							lastScreenLine = lineInfo.length - 1;
						}
						else if(skew > 0)
						{
							info.firstSubregion = false;
							for(int j = 0; j < skew; j++)
								out.remove(0);
						}
					}
					chunks = out.remove(0);
					offset = chunks.offset;
					if (!out.isEmpty())
						length = out.get(0).offset - offset;
					else
						length = textArea.getLineLength(physicalLine) - offset + 1;
				}
			}
			else
			{
				info.firstSubregion = false;

				chunks = out.remove(0);
				offset = chunks.offset;
				if (!out.isEmpty())
					length = out.get(0).offset - offset;
				else
					length = textArea.getLineLength(physicalLine) - offset + 1;
			}

			boolean lastSubregion = out.isEmpty();

			if(i == lastScreenLine
				&& lastScreenLine != lineInfo.length - 1)
			{
				
				if(tokenHandler.getLineContext() !=
					info.lineContext)
				{
					lastScreenLine++;
					needFullRepaint = true;
				}
				
				else if(info.physicalLine != physicalLine
					|| info.lastSubregion != lastSubregion)
				{
					lastScreenLine++;
					needFullRepaint = true;
				}
				
				else if (!out.isEmpty())
					lastScreenLine++;
			}

			info.physicalLine = physicalLine;
			info.lastSubregion = lastSubregion;
			info.offset = offset;
			info.length = length;
			info.chunks = chunks;
			info.lineContext = tokenHandler.getLineContext();
		}

		firstInvalidLine = Math.max(lastScreenLine + 1,firstInvalidLine);
	} 

	
	private void lineToChunkList(int physicalLine, List<Chunk> out)
	{
		TextAreaPainter painter = textArea.getPainter();

		tokenHandler.init(painter.getStyles(),
			painter.getFontRenderContext(),
			painter,out,
			textArea.softWrap
			? textArea.wrapMargin : 0.0f);
		buffer.markTokens(physicalLine,tokenHandler);
	} 

	

	
	
	static class LineInfo
	{
		
		int physicalLine;
		
		int offset;
		
		int length;
		
		boolean firstSubregion;
		
		boolean lastSubregion;
		Chunk chunks;
		
		int width;
		TokenMarker.LineContext lineContext;

		@Override
		public String toString()
		{
			return ""LineInfo["" + physicalLine + ',' + offset + ','
			       + length + ',' + firstSubregion + ',' +
			       lastSubregion + ""]"";
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.util.IntegerArray,8,1,0,5,10,4,5,0,8,0.5,75,1.0,0,0.0,0.75,0,0,8.125,2,0.875,0,"

package org.gjt.sp.util;


public class IntegerArray
{
	
	public IntegerArray()
	{
		this(2000);
	} 

	
	public IntegerArray(int initialSize)
	{
		array = new int[initialSize];
	} 

	
	public void add(int num)
	{
		if(len >= array.length)
		{
			int[] arrayN = new int[len * 2];
			System.arraycopy(array,0,arrayN,0,len);
			array = arrayN;
		}

		array[len++] = num;
	} 

	
	public final int get(int index)
	{
		return array[index];
	} 

	
	public final int getSize()
	{
		return len;
	} 

	
	public final void setSize(int len)
	{
		this.len = len;
	} 

	
	public final void clear()
	{
		len = 0;
	} 

	
	public int[] getArray()
	{
		return array;
	} 

	
	private int[] array;
	private int len;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHFormalParameter,4,2,0,9,9,4,3,6,2,1.0,47,0.0,0,0.894736842,0.6,1,1,10.0,2,0.75,0,"

package org.gjt.sp.jedit.bsh;


class BSHFormalParameter extends SimpleNode
{
	public static final Class UNTYPED = null;
	public String name;
	
	public Class type;

	BSHFormalParameter(int id) { super(id); }

	public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
	{
		if ( jjtGetNumChildren() > 0 )
			return ((BSHType)jjtGetChild(0)).getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
		else
			
			return ""Ljava/lang/Object;"";  
	}

	
	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		if ( jjtGetNumChildren() > 0 )
			type = ((BSHType)jjtGetChild(0)).getType( callstack, interpreter );
		else
			type = UNTYPED;

		return type;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.options.PluginOptions,6,8,0,10,26,13,1,9,4,0.8,177,1.0,1,0.997028232,0.5,1,2,28.33333333,7,1.3333,0,"

package org.gjt.sp.jedit.options;


import java.awt.Dialog;
import java.awt.Frame;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class PluginOptions extends OptionsDialog
{
	
	public PluginOptions(Frame frame)
	{
		super(frame,""plugin-options"",jEdit.getProperty(""plugin-options.last""));
	} 

	
	public PluginOptions(Frame frame, String pane)
	{
		super(frame,""plugin-options"",pane);
	} 

	
	public PluginOptions(Dialog dialog)
	{
		super(dialog,""plugin-options"",jEdit.getProperty(""plugin-options.last""));
	} 

	
	public PluginOptions(Dialog dialog, String pane)
	{
		super(dialog,""plugin-options"",pane);
	} 

	
	protected OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();

		
		pluginsGroup = new OptionGroup(""plugins"");
		pluginsGroup.setSort(true);

		
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin ep = plugins[i];
			if(ep instanceof EditPlugin.Broken)
				continue;

			String className = ep.getClassName();
			if(jEdit.getProperty(""plugin."" + className + "".activate"") == null)
			{
				
				try
				{
					ep.createOptionPanes(this);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR, ep,
						""Error creating option pane"");
					Log.log(Log.ERROR, ep, t);
				}
			}
			else
			{
				String optionPane = jEdit.getProperty(
					""plugin."" + className + "".option-pane"");
				if(optionPane != null)
					pluginsGroup.addOptionPane(optionPane);
				else
				{
					String options = jEdit.getProperty(
						""plugin."" + className
						+ "".option-group"");
					if(options != null)
					{
						pluginsGroup.addOptionGroup(
							new OptionGroup(
							""plugin."" + className,
							jEdit.getProperty(""plugin.""
							+ className + "".name""),
							options)
						);
					}
				}
			}
		}

		
		if (pluginsGroup.getMemberCount() == 0)
			pluginsGroup.addOptionPane(new NoPluginsPane());

		rootGroup.addOptionGroup(pluginsGroup);

		return paneTreeModel;
	} 

	
	protected OptionGroup getDefaultGroup()
	{
		return pluginsGroup;
	} 

	
	private OptionGroup pluginsGroup;
	

	
	public static class NoPluginsPane extends AbstractOptionPane
	{
		public NoPluginsPane()
		{
			super(""no-plugins"");
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.FileVFS,21,2,0,19,87,208,10,11,20,1.0,665,0.5,0,0.672413793,0.344444444,1,3,30.57142857,8,2.8095,0,"

package org.gjt.sp.jedit.io;


import javax.swing.filechooser.FileSystemView;
import javax.swing.*;
import java.awt.Component;
import java.io.*;
import java.text.*;
import java.util.Date;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class FileVFS extends VFS
{
	public static final String PERMISSIONS_PROPERTY = ""FileVFS__perms"";

	
	public FileVFS()
	{
		super(""file"",READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP
			| RENAME_CAP | MKDIR_CAP | LOW_LATENCY_CAP
			| (OperatingSystem.isCaseInsensitiveFS()
			? CASE_INSENSITIVE_CAP : 0),
			new String[] { EA_TYPE, EA_SIZE, EA_STATUS,
			EA_MODIFIED });
	} 

	
	@Override
	public String getParentOfPath(String path)
	{
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return FileRootsVFS.PROTOCOL + ':';
			else if(path.length() == 3 && path.endsWith("":\\""))
				return FileRootsVFS.PROTOCOL + ':';
			else if(path.startsWith(""\\\\"") && path.indexOf('\\',2) == -1)
				return path;
		}

		return super.getParentOfPath(path);
	} 

	
	@Override
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(File.separator)
			|| parent.endsWith(""/""))
			return parent + path;
		else
			return parent + File.separator + path;
	} 

	
	@Override
	public char getFileSeparator()
	{
		return File.separatorChar;
	} 

	
	
	@Override
	public String getTwoStageSaveName(String path)
	{
		File parent = new File(getParentOfPath(path));
		
		
		
		
		
		
		
		
		return (parent.canWrite() || OperatingSystem.isWindows())
			? super.getTwoStageSaveName(path)
			: null;
	} 

	
	@Override
	public boolean save(View view, Buffer buffer, String path)
	{
		if(OperatingSystem.isUnix())
		{
			int permissions = getPermissions(buffer.getPath());
			Log.log(Log.DEBUG,this,buffer.getPath() + "" has permissions 0""
				+ Integer.toString(permissions,8));
			buffer.setIntegerProperty(PERMISSIONS_PROPERTY,permissions);
		}

		return super.save(view,buffer,path);
	} 

	
	@Override
	public boolean insert(View view, Buffer buffer, String path)
	{
		File file = new File(path);

		
		if(!file.exists())
			return false;

		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.open-directory"",null);
			return false;
		}

		if(!file.canRead())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-read"",null);
			return false;
		} 

		return super.insert(view,buffer,path);
	} 

	
	
	public static boolean recursiveDelete(File path)
	{
		if (path.exists())
		{
			File[] files = path.listFiles();
			for (int i = 0; i < files.length; i++)
			{
				if (files[i].isDirectory())
				{
					recursiveDelete(files[i]);
				}
				else
				{
					files[i].delete();
				}
			}
		}
		return path.delete();
	} 

	
	
	@Override
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return MiscUtilities.canonPath(path);
	} 

	
	public static class LocalFile extends VFSFile
	{
		private File file;

		
		public static DateFormat DATE_FORMAT
			= DateFormat.getInstance();

		
		@Deprecated
		public long modified;

		
		public LocalFile(File file)
		{
			this.file = file;

			
			setName(file.getName());
			String path = file.getPath();
			setPath(path);
			setDeletePath(path);
			setHidden(file.isHidden());
			setType(file.isDirectory()
				? VFSFile.DIRECTORY
				: VFSFile.FILE);
		} 

		
		@Override
		public String getExtendedAttribute(String name)
		{
			fetchAttrs();
			if (name.equals(EA_MODIFIED))
			{
				return DATE_FORMAT.format(new Date(modified));
			}
			else
			{
				return super.getExtendedAttribute(name);
			}
		} 

		
		
		@Override
		protected void fetchAttrs()
		{
			if(fetchedAttrs())
				return;

			super.fetchAttrs();

			setSymlinkPath(MiscUtilities.resolveSymlinks(
				file.getPath()));
			setReadable(file.canRead());
			setWriteable(file.canWrite());
			setLength(file.length());
			setModified(file.lastModified());
		} 

		
		
		@Override
		public Icon getIcon(boolean expanded, boolean openBuffer)
		{
			if (icon == null)
			{
				if (fsView == null)
					fsView = FileSystemView.getFileSystemView();

				icon = fsView.getSystemIcon(file);
			}
			return icon;  
		} 

		
		@Override
		public String getSymlinkPath()
		{
			fetchAttrs();
			return super.getSymlinkPath();
		} 

		
		@Override
		public long getLength()
		{
			fetchAttrs();
			return super.getLength();
		} 

		
		@Override
		public boolean isReadable()
		{
			fetchAttrs();
			return super.isReadable();
		} 

		
		@Override
		public boolean isWriteable()
		{
			fetchAttrs();
			return super.isWriteable();
		} 

		
		public long getModified()
		{
			fetchAttrs();
			return modified;
		} 

		
		public void setModified(long modified)
		{
			this.modified = modified;
		} 

		private transient FileSystemView fsView;
		private transient Icon icon;
	} 

	
	@Override
	public VFSFile[] _listFiles(Object session, String path,
		Component comp)
	{
		
		
		if(OperatingSystem.isWindows())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				path = path.concat(File.separator);
		} 

		File directory = new File(path);
		File[] list = null;
		if(directory.exists())
			list = fsView.getFiles(directory,false);

		if(list == null)
		{
			VFSManager.error(comp,path,""ioerror.directory-error-nomsg"",null);
			return null;
		}

		VFSFile[] list2 = new VFSFile[list.length];
		for(int i = 0; i < list.length; i++)
			list2[i] = new LocalFile(list[i]);

		return list2;
	} 

	
	@Override
	public VFSFile _getFile(Object session, String path,
		Component comp)
	{
		if(path.equals(""/"") && OperatingSystem.isUnix())
		{
			return new VFS.DirectoryEntry(path,path,path,
				VFSFile.DIRECTORY,0L,false);
		}

		File file = new File(path);
		if(!file.exists())
			return null;

		return new LocalFile(file);
	} 

	
	@Override
	public boolean _delete(Object session, String path, Component comp)
	{
		File file = new File(path);
		
		
		String canonPath;
		try
		{
			canonPath = file.getCanonicalPath();
		}
		catch(IOException io)
		{
			canonPath = path;
		}
		
		boolean retVal;
		if (!file.isDirectory())
		{
			retVal = file.delete();
		} 
		else 
		{
			retVal = recursiveDelete(file);
		}
		if(retVal)
			VFSManager.sendVFSUpdate(this,canonPath,true);
		return retVal;
	} 

	
	@Override
	public boolean _rename(Object session, String from, String to,
		Component comp)
	{
		File _to = new File(to);

		String toCanonPath;
		try
		{
			toCanonPath = _to.getCanonicalPath();
		}
		catch(IOException io)
		{
			toCanonPath = to;
		}

		
		
		File parent = new File(_to.getParent());
		if(parent.exists())
		{
			if(!parent.isDirectory())
				return false;
		}
		else
		{
			parent.mkdirs();
			if(!parent.exists())
				return false;
		}

		File _from = new File(from);

		String fromCanonPath;
		try
		{
			fromCanonPath = _from.getCanonicalPath();
		}
		catch(IOException io)
		{
			fromCanonPath = from;
		}

		
		if(!fromCanonPath.equalsIgnoreCase(toCanonPath))
			_to.delete();

		boolean retVal = _from.renameTo(_to);
		VFSManager.sendVFSUpdate(this,fromCanonPath,true);
		VFSManager.sendVFSUpdate(this,toCanonPath,true);
		return retVal;
	} 

	
	@Override
	public boolean _mkdir(Object session, String directory, Component comp)
	{
		String parent = getParentOfPath(directory);
		if(!new File(parent).exists())
		{
			if(!_mkdir(session,parent,comp))
				return false;
		}

		File file = new File(directory);

		boolean retVal = file.mkdir();
		String canonPath;
		try
		{
			canonPath = file.getCanonicalPath();
		}
		catch(IOException io)
		{
			canonPath = directory;
		}
		VFSManager.sendVFSUpdate(this,canonPath,true);
		return retVal;
	} 

	
	@Override
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
		
		int backups = jEdit.getIntegerProperty(""backups"",1);

		if(backups == 0)
			return;

		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");

		String backupDirectory = jEdit.getProperty(""backup.directory"");

		int backupTimeDistance = jEdit.getIntegerProperty(""backup.minTime"",0);
		File file = new File(path);

		if (!file.exists())
			return;

		
		
		if(backupDirectory == null || backupDirectory.length() == 0)
			backupDirectory = file.getParent();
		else
		{
			backupDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),backupDirectory);

			
			
			backupDirectory = MiscUtilities.concatPath(
				backupDirectory,file.getParent());

			File dir = new File(backupDirectory);

			if (!dir.exists())
				dir.mkdirs();
		}

		MiscUtilities.saveBackup(file,backups,backupPrefix,
			backupSuffix,backupDirectory,backupTimeDistance);
	} 

	
	@Override
	public InputStream _createInputStream(Object session, String path,
		boolean ignoreErrors, Component comp) throws IOException
	{
		try
		{
			return new FileInputStream(path);
		}
		catch(IOException io)
		{
			if(ignoreErrors)
				return null;
			else
				throw io;
		}
	} 

	
	@Override
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		return new FileOutputStream(path);
	} 

	
	@Override
	public void _saveComplete(Object session, Buffer buffer, String path,
		Component comp)
	{
		int permissions = buffer.getIntegerProperty(PERMISSIONS_PROPERTY,0);
		setPermissions(path,permissions);
	} 

	

	

	
	
	public static int getPermissions(String path)
	{
		int permissions = 0;

		if(jEdit.getBooleanProperty(""chmodDisabled""))
			return permissions;

		if(OperatingSystem.isUnix())
		{
			String[] cmdarray = { ""ls"", ""-ld"", path };

			try
			{
				Process process = Runtime.getRuntime().exec(cmdarray);

				BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

				String output = reader.readLine();

				if(output != null)
				{
					String s = output.substring(1, 10);

					permissions = MiscUtilities
						.parsePermissions(s);
				}
			}

			
			
			
			catch (Throwable t)
			{
			}
		}

		return permissions;
	} 

	
	
	public static void setPermissions(String path, int permissions)
	{
		if(jEdit.getBooleanProperty(""chmodDisabled""))
			return;

		if(permissions != 0)
		{
			if(OperatingSystem.isUnix())
			{
				String[] cmdarray = { ""chmod"", Integer.toString(permissions, 8), path };

				try
				{
					Process process = Runtime.getRuntime().exec(cmdarray);
					process.getInputStream().close();
					process.getOutputStream().close();
					process.getErrorStream().close();
					
					
					
					
				}

				
				
				
				catch (Throwable t)
				{
				}
			}
		}
	} 

	

	
	private static final FileSystemView fsView = FileSystemView.getFileSystemView();
	
}
"
jEdit,4.3,org.gjt.sp.jedit.RegistersListener,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit;


public interface RegistersListener
{
	void registerChanged(char name);
}
"
jEdit,4.3,org.gjt.sp.jedit.SettingsReloader,3,1,0,11,21,3,1,11,1,2.0,119,0.0,0,0.0,0.555555556,0,0,38.66666667,16,6.0,0,"

package org.gjt.sp.jedit;


import java.io.File;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.search.*;


class SettingsReloader implements EBComponent
{
	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof VFSUpdate)
		{
			VFSUpdate vmsg = (VFSUpdate)msg;
			maybeReload(vmsg.getPath());
		}
	} 

	
	private void maybeReload(String path)
	{
		String jEditHome = jEdit.getJEditHome();
		String settingsDirectory = jEdit.getSettingsDirectory();

		if(!MiscUtilities.isURL(path))
			path = MiscUtilities.resolveSymlinks(path);

		
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
			jEditHome = jEditHome.toLowerCase();
			if(settingsDirectory != null)
				settingsDirectory = settingsDirectory.toLowerCase();
		}

		
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		if(fileset instanceof DirectoryListSet)
		{
			DirectoryListSet dirset = (DirectoryListSet)fileset;
			String dir = MiscUtilities.resolveSymlinks(
				dirset.getDirectory());
			if(path.startsWith(dir))
				dirset.invalidateCachedList();
		}

		if(jEditHome != null && path.startsWith(jEditHome))
			path = path.substring(jEditHome.length());
		else if(settingsDirectory != null && path.startsWith(settingsDirectory))
			path = path.substring(settingsDirectory.length());
		else
		{
			
			
			return;
		}

		if(path.startsWith(File.separator) || path.startsWith(""/""))
			path = path.substring(1);

		if(path.startsWith(""macros""))
			Macros.loadMacros();
		else if(path.startsWith(""modes"") && (path.endsWith("".xml"")
			|| path.endsWith(""catalog"")))
			jEdit.reloadModes();
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.visitors.SaveCaretInfoVisitor,2,2,0,4,4,1,2,2,2,2.0,8,0.0,0,0.75,0.75,0,0,3.0,1,0.5,0,"

package org.gjt.sp.jedit.visitors;

import org.gjt.sp.jedit.EditPane;


public class SaveCaretInfoVisitor extends JEditVisitorAdapter
{
	@Override
	public void visit(EditPane editPane)
	{
		editPane.saveCaretInfo();
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.help.HelpSearchPanel,6,5,0,11,30,5,4,9,1,0.7,139,1.0,3,0.992401216,0.388888889,0,0,21.5,2,1.0,0,"

package org.gjt.sp.jedit.help;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class HelpSearchPanel extends JPanel
{
	
	public HelpSearchPanel(HelpViewerInterface helpViewer)
	{
		super(new BorderLayout(6,6));

		this.helpViewer = helpViewer;

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(new JLabel(jEdit.getProperty(""helpviewer.search.caption"")));
		box.add(Box.createHorizontalStrut(6));
		box.add(searchField = new HistoryTextField(""helpviewer.search""));
		searchField.addActionListener(new ActionHandler());

		add(BorderLayout.NORTH,box);

		results = new JList();
		results.addMouseListener(new MouseHandler());
		results.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		results.setCellRenderer(new ResultRenderer());
		add(BorderLayout.CENTER,new JScrollPane(results));
	} 

	
	private HelpViewerInterface helpViewer;
	private HistoryTextField searchField;
	private JList results;
	private HelpIndex index;

	private HelpIndex getHelpIndex()
	{
		if(index == null)
		{
			index = new HelpIndex();
			try
			{
				index.indexEditorHelp();
			}
			catch(Exception e)
			{
				index = null;
				Log.log(Log.ERROR,this,e);
				GUIUtilities.error(helpViewer.getComponent(),""helpviewer.search.error"",
					new String[] { e.toString() });
			}
		}

		return index;
	} 

	
	static class ResultIcon implements Icon
	{
		private static RenderingHints renderingHints;

		static
		{
			Map<RenderingHints.Key, Object> hints = new HashMap<RenderingHints.Key, Object>();

			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

			renderingHints = new RenderingHints(hints);
		}

		private int rank;

		ResultIcon(int rank)
		{
			this.rank = rank;
		}

		public int getIconWidth()
		{
			return 40;
		}

		public int getIconHeight()
		{
			return 9;
		}

		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g.create();
			g2d.setRenderingHints(renderingHints);

			for(int i = 0; i < 4; i++)
			{
				if(rank > i)
					g2d.setColor(UIManager.getColor(""Label.foreground""));
				else
					g2d.setColor(UIManager.getColor(""Label.disabledForeground""));
				g2d.fillOval(x+i*10,y,9,9);
			}
		}
	} 

	
	static class ResultRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,null,index,
				isSelected,cellHasFocus);

			if(value instanceof String)
			{
				setIcon(null);
				setText((String)value);
			}
			else
			{
				Result result = (Result)value;
				setIcon(new ResultIcon(result.rank));
				setText(result.title);
			}

			return this;
		}
	} 

	
	static class Result
	{
		String file;
		String title;
		int rank;

		Result(HelpIndex.HelpFile file, int count)
		{
			this.file = file.file;
			this.title = file.title;
			rank = count;
		}
	} 

	
	static class ResultCompare implements Comparator<Result>
	{
		public int compare(Result r1, Result r2)
		{
			if(r1.rank == r2.rank)
				return r1.title.compareTo(r2.title);
			else
				return r2.rank - r1.rank;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			final HelpIndex index = getHelpIndex();
			if(index == null)
				return;

			results.setListData(new String[] { jEdit.getProperty(
				""helpviewer.searching"") });

			final String text = searchField.getText();
			final Vector<Result> resultModel = new Vector<Result>();

			VFSManager.runInWorkThread(new Runnable()
			{
				public void run()
				{
					StringTokenizer st = new StringTokenizer(text,"",.;:-? "");

					
					int maxRank = 0;

					while(st.hasMoreTokens())
					{
						String word = st.nextToken().toLowerCase();
						HelpIndex.Word lookup = index.lookupWord(word);
						if(lookup == null)
							continue;

						for(int i = 0; i < lookup.occurCount; i++)
						{
							HelpIndex.Word.Occurrence occur = lookup.occurrences[i];

							boolean ok = false;

							HelpIndex.HelpFile file = index.getFile(occur.file);
							for(int j = 0; j < resultModel.size(); j++)
							{
								Result result = resultModel.elementAt(j);
								if(result.file.equals(file.file))
								{
									result.rank += occur.count;
									result.rank += 20; 
									maxRank = Math.max(result.rank,maxRank);
									ok = true;
									break;
								}
							}

							if(!ok)
							{
								maxRank = Math.max(occur.count,maxRank);
								resultModel.addElement(new Result(file,occur.count));
							}
						}
					}

					if(maxRank != 0)
					{
						
						for(int i = 0; i < resultModel.size(); i++)
						{
							Result result = resultModel.elementAt(i);
							result.rank = (int)Math.ceil((double)result.rank * 4 / maxRank);
						}

						Collections.sort(resultModel,new ResultCompare());
					}
				}
			});

			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					if(resultModel.isEmpty())
					{
						results.setListData(new String[] {
							jEdit.getProperty(
							""helpviewer.no-results"") });

						getToolkit().beep();
					}
					else
						results.setListData(resultModel);
				}
			});

		}
	} 

	
	public class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			int row = results.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Result result = (Result)results.getModel()
					.getElementAt(row);
				helpViewer.gotoURL(result.file,true, 0);
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.LineSepWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.buffer.JEditBuffer;


public class LineSepWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view) 
	{
		Widget lineSep = new LineSepWidget(view);
		return lineSep;
	} 
	
	
	private static class LineSepWidget implements Widget
	{
		private final JLabel lineSep;
		private final View view;
		
		
		LineSepWidget(final View view) 
		{
			lineSep = new ToolTipLabel();
			lineSep.setHorizontalAlignment(SwingConstants.CENTER);
			lineSep.setToolTipText(jEdit.getProperty(""view.status.linesep-tooltip""));
			this.view = view;
			lineSep.addMouseListener(new MouseAdapter() 
						 {
							 @Override
							 public void mouseClicked(MouseEvent evt)
							 {
								 view.getBuffer().toggleLineSeparator(view);
							 }
						 });
		} 

		
		
		public JComponent getComponent() 
		{
			return lineSep;
		} 

		
		
		public void update() 
		{
			Buffer buffer = view.getBuffer();
			String lineSep = buffer.getStringProperty(JEditBuffer.LINESEP);
			if(""\n"".equals(lineSep))
				this.lineSep.setText(""U"");
			else if(""\r\n"".equals(lineSep))
				this.lineSep.setText(""W"");
			else if(""\r"".equals(lineSep))
				this.lineSep.setText(""M"");
		} 

		
	        
	        public void propertiesChanged()
		{
			
			Font font = new JLabel().getFont();
			
			FontMetrics fm = lineSep.getFontMetrics(font);
			Dimension dim = new Dimension(Math.max(
							       Math.max(fm.charWidth('U'),
									fm.charWidth('W')),
							       fm.charWidth('M')) + 1,
				fm.getHeight());
			lineSep.setPreferredSize(dim);
			lineSep.setMaximumSize(dim);
		} 
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.ExtensionManager,7,1,0,8,29,0,2,6,0,0.0,248,1.0,0,0.0,0.404761905,0,0,34.28571429,3,2.2857,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;
import java.util.*;
import org.gjt.sp.util.Log;


class ExtensionManager
{
	
	
	void addExtension(int layer, TextAreaExtension ext)
	{
		Entry entry = new Entry(layer,ext);

		int i = 0;
		for (Entry extension : extensions)
		{
			int _layer = extension.layer;
			if (layer < _layer)
			{
				extensions.add(i, entry);
				return;
			}
			i++;
		}

		extensions.add(entry);
	} 

	
	void removeExtension(TextAreaExtension ext)
	{
		Iterator<Entry> iter = extensions.iterator();
		while(iter.hasNext())
		{
			if(iter.next().ext == ext)
			{
				iter.remove();
				return;
			}
		}
	} 

	
	TextAreaExtension[] getExtensions()
	{
		TextAreaExtension[] retVal = new TextAreaExtension[
			extensions.size()];
		Iterator<Entry> iter = extensions.iterator();
		int i = 0;
		while(iter.hasNext())
			retVal[i++] = iter.next().ext;

		return retVal;
	} 

	
	void paintScreenLineRange(TextArea textArea, Graphics2D gfx,
		int firstLine, int lastLine, int y, int lineHeight)
	{
		try
		{
			int[] physicalLines = new int[lastLine - firstLine + 1];
			int[] start = new int[physicalLines.length];
			int[] end = new int[physicalLines.length];

			for(int i = 0; i < physicalLines.length; i++)
			{
				int screenLine = i + firstLine;
				ChunkCache.LineInfo lineInfo = textArea
					.chunkCache.getLineInfo(screenLine);

				if(lineInfo.physicalLine == -1)
					physicalLines[i] = -1;
				else
				{
					physicalLines[i] = lineInfo.physicalLine;
					start[i] = textArea.getScreenLineStartOffset(screenLine);
					end[i] = textArea.getScreenLineEndOffset(screenLine);
				}
			}

			paintScreenLineRange(gfx,firstLine,lastLine,physicalLines,
				start,end,y,lineHeight);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Error repainting line""
				+ "" range {"" + firstLine + ','
					+ lastLine + ""}:"");
			Log.log(Log.ERROR,this,e);
		}
	} 

	
	String getToolTipText(int x, int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = extensions.get(i).ext;
			String toolTip = ext.getToolTipText(x,y);
			if(toolTip != null)
				return toolTip;
		}

		return null;
	} 

	
	private final List<Entry> extensions = new LinkedList<Entry>();

	
	private void paintScreenLineRange(Graphics2D gfx, int firstLine,
		int lastLine, int[] physicalLines, int[] start, int[] end,
		int y, int lineHeight)
	{
		Iterator<Entry> iter = extensions.iterator();
		while(iter.hasNext())
		{
			TextAreaExtension ext = iter.next().ext;
			try
			{
				ext.paintScreenLineRange(gfx,firstLine,lastLine,
					physicalLines,start,end,y,lineHeight);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);

				
				
				iter.remove();
			}
		}
	} 

	

	
	
	static class Entry
	{
		int layer;
		TextAreaExtension ext;

		Entry(int layer, TextAreaExtension ext)
		{
			this.layer = layer;
			this.ext = ext;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.MarkersProvider,3,1,0,8,23,3,1,8,3,2.0,101,0.0,0,0.0,0.666666667,0,0,32.66666667,5,2.0,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.List;

import org.gjt.sp.jedit.*;


public class MarkersProvider implements DynamicMenuProvider
{
	
	public boolean updateEveryTime()
	{
		return true;
	} 

	
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);
		Buffer buffer = view.getBuffer();

		List<Marker> markers = buffer.getMarkers();

		if(markers.isEmpty())
		{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""no-markers.label""));
			mi.setEnabled(false);
			menu.add(mi);
			return;
		}

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

		JMenu current = menu;

		for(int i = 0; i < markers.size(); i++)
		{
			final Marker marker = markers.get(i);
			int lineNo = buffer.getLineOfOffset(marker.getPosition());

			if(current.getItemCount() >= maxItems && i != markers.size() - 1)
			{
				
				JMenu newCurrent = new JMenu(
					jEdit.getProperty(
					""common.more""));
				current.add(newCurrent);
				current = newCurrent;
			}

			JMenuItem mi = new MarkersMenuItem(buffer,
				lineNo,marker.getShortcut());
			mi.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					view.getTextArea().setCaretPosition(
						marker.getPosition());
				}
			});
			current.add(mi);
		}
	} 

	
	static class MarkersMenuItem extends JMenuItem
	{
		
		MarkersMenuItem(Buffer buffer, int lineNo, char shortcut)
		{
			String text = buffer.getLineText(lineNo).trim();
			if(text.length() == 0)
				text = jEdit.getProperty(""markers.blank-line"");
			setText((lineNo + 1) + "": "" + text);

			shortcutProp = ""goto-marker.shortcut"";
			MarkersMenuItem.this.shortcut = shortcut;
		} 

		
		public Dimension getPreferredSize()
		{
			Dimension d = super.getPreferredSize();

			String shortcut = getShortcut();

			if(shortcut != null)
			{
				d.width += (getFontMetrics(acceleratorFont)
					.stringWidth(shortcut) + 15);
			}
			return d;
		} 

		
		public void paint(Graphics g)
		{
			super.paint(g);

			String shortcut = getShortcut();

			if(shortcut != null)
			{
				g.setFont(acceleratorFont);
				g.setColor(getModel().isArmed() ?
					acceleratorSelectionForeground :
					acceleratorForeground);
				FontMetrics fm = g.getFontMetrics();
				Insets insets = getInsets();
				g.drawString(shortcut,getWidth() - (fm.stringWidth(
					shortcut) + insets.right + insets.left + 5),
					getFont().getSize() + (insets.top - 1)
					);
			}
		} 

		
		private String shortcutProp;
		private char shortcut;
		private static Font acceleratorFont;
		private static Color acceleratorForeground;
		private static Color acceleratorSelectionForeground;

		
		private String getShortcut()
		{
			if(shortcut == '\0')
				return null;
			else
			{
				String shortcutPrefix = jEdit.getProperty(shortcutProp);

				if(shortcutPrefix == null)
					return null;
				else
				{
					return shortcutPrefix + ' ' + shortcut;
				}
			}
		} 

		
		static
		{
			acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
			acceleratorFont = new Font(""Monospaced"",
				acceleratorFont.getStyle(),
				acceleratorFont.getSize());
			acceleratorForeground = UIManager
				.getColor(""MenuItem.acceleratorForeground"");
			acceleratorSelectionForeground = UIManager
				.getColor(""MenuItem.acceleratorSelectionForeground"");
		} 

		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.FilteredListModel,23,2,1,3,51,195,3,1,13,0.809090909,300,1.0,0,0.24137931,0.166007905,0,0,11.82608696,7,1.5652,0,"
package org.gjt.sp.jedit.gui;

import javax.swing.*;
import javax.swing.event.*;
import java.util.*;


public abstract class FilteredListModel<E extends ListModel> extends AbstractListModel implements ListDataListener
{
	
	protected E delegated;

	private Vector<Integer> filteredIndices;

	
	private Map<Integer, Integer> invertedIndices;

	private String filter;

	private JList list;

	
	protected FilteredListModel(E delegated)
	{
		this.delegated = delegated;
		delegated.addListDataListener(this);
		resetFilter();
	} 

	
	
	public void setList(JList list)
	{
		if (list.getModel() != this)
			throw new IllegalArgumentException(""The given list "" + list + "" doesn't use this model "" + this);
		this.list = list;
	} 

	
	public E getDelegated()
	{
		return delegated;
	} 

	
	public void setDelegated(E delegated)
	{
		this.delegated.removeListDataListener(this);
		delegated.addListDataListener(this);
		this.delegated = delegated;
	} 

	
	private void resetFilter()
	{
		filteredIndices = null;
	} 

	
	public void setFilter(final String filter)
	{
		Runnable runner = new Runnable()
		{
			public void run()
			{
				Set<Integer> selectedIndices = saveSelection();
				list.clearSelection();
				FilteredListModel.this.filter = filter;
				if (filter != null && filter.length() > 0)
				{
					int size = delegated.getSize();
					String prepped_filter = prepareFilter(filter);
					Vector<Integer> indices = new Vector<Integer>(size);
					Map<Integer, Integer> invertedIndices = new HashMap<Integer, Integer>();
					for (int i = 0; i < size; i++)
					{
						if (passFilter(i, prepped_filter))
						{
							Integer delegatedIndice = Integer.valueOf(i);
							indices.add(delegatedIndice);

							invertedIndices.put(delegatedIndice, indices.size() - 1);
						}
					}
					FilteredListModel.this.invertedIndices = invertedIndices;
					filteredIndices = indices;
				}
				else
					resetFilter();

				fireContentsChanged(this, 0, getSize() - 1);
				restoreSelection(selectedIndices);
			}
		};
		SwingUtilities.invokeLater(runner);
	} 

	
	public String prepareFilter(String filter)
	{
		return filter;
	} 

	
	
	public abstract boolean passFilter(int row, String filter);
	

	
	protected Set<Integer> saveSelection()
	{
		if (list == null)
			return null;
		int[] rows = list.getSelectedIndices();
		if (rows.length == 0)
			return null;

		Set<Integer> selectedRows = new HashSet<Integer>(rows.length);
		for (int row : rows)
		{
			selectedRows.add(getTrueRow(row));
		}
		return selectedRows;
	} 

	
	protected void restoreSelection(Set<Integer> selectedIndices)
	{
		if (selectedIndices == null || getSize() == 0)
			return;

		
		
		
		
		
		
		Vector<Integer> sel = new Vector<Integer>(selectedIndices);
		Collections.sort(sel);
		int from = -1;
		int to = -1;
		for (Integer selectedIndex : sel)
		{
			int i = getInternal2ExternalRow(selectedIndex.intValue());
			if (i != -1)
			{
				if (from == -1)
					from = to = i;
				else if (i == to + 1)
					to = i;
				else
				{
					list.setSelectionInterval(from, to);
					from = to = i;
				}
			}
		}
		if (from != -1)
			list.setSelectionInterval(from, to);
	}  

	
	
	public int getTrueRow(int rowIndex)
	{
		if (filteredIndices == null)
			return rowIndex;
		return filteredIndices.get(rowIndex).intValue();
	} 

	
	
	public int getInternal2ExternalRow(int internalRowIndex)
	{
		if (invertedIndices == null)
			return internalRowIndex;

		Integer externalRowIndex = invertedIndices.get(internalRowIndex);
		if (externalRowIndex == null)
			return -1;

		return externalRowIndex.intValue();
	} 

	
	public Object getElementAt(int index)
	{
		int trueRowIndex = getTrueRow(index);
		return delegated.getElementAt(trueRowIndex);
	} 

	
	public int getSize()
	{
		if (filteredIndices == null)
			return delegated.getSize();
		return filteredIndices.size();
	} 

	
	public void contentsChanged(ListDataEvent e)
	{
		setFilter(filter);
	} 

	
	public void intervalAdded(ListDataEvent e)
	{
		setFilter(filter);
	} 

	
	public void intervalRemoved(ListDataEvent e)
	{
		setFilter(filter);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.Roster,12,1,0,16,39,20,11,8,1,0.666666667,232,1.0,0,0.0,0.202380952,0,0,18.08333333,8,2.0,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.SwingUtilities;
import java.awt.Component;
import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.IOUtilities;

import static org.gjt.sp.jedit.io.FileVFS.recursiveDelete;



class Roster
{
	
	Roster()
	{
		operations = new ArrayList<Operation>();
		toLoad = new ArrayList<String>();
	} 

	
	
	void addRemove(String jar)
	{
		addOperation(new Remove(jar));
	} 

	
	void addInstall(String installed, String url, String installDirectory,
		int size)
	{
		addOperation(new Install(installed,url,installDirectory,size));
	} 

	
	public Operation getOperation(int i)
	{
		return operations.get(i);
	} 

	
	int getOperationCount()
	{
		return operations.size();
	} 

	
	boolean isEmpty()
	{
		return operations.isEmpty();
	} 

	
	void performOperationsInWorkThread(PluginManagerProgress progress)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = operations.get(i);
			op.runInWorkThread(progress);
			progress.done();

			if(Thread.interrupted())
				return;
		}
	} 

	
	void performOperationsInAWTThread(Component comp)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = operations.get(i);
			op.runInAWTThread(comp);
		}

		
		
		for(int i = 0; i < toLoad.size(); i++)
		{
			String pluginName = toLoad.get(i);
			if(jEdit.getPluginJAR(pluginName) != null)
			{
				Log.log(Log.WARNING,this,""Already loaded: ""
					+ pluginName);
			}
			else
				jEdit.addPluginJAR(pluginName);
		}

		for(int i = 0; i < toLoad.size(); i++)
		{
			String pluginName = toLoad.get(i);
			PluginJAR plugin = jEdit.getPluginJAR(pluginName);
			if(plugin != null)
				plugin.checkDependencies();
		}

		
		for(int i = 0; i < toLoad.size(); i++)
		{
			String pluginName = toLoad.get(i);
			PluginJAR plugin = jEdit.getPluginJAR(pluginName);
			if(plugin != null)
				plugin.activatePluginIfNecessary();
		}
	} 

	
	private static File downloadDir;

	private List<Operation> operations;
	private List<String> toLoad;

	
	private void addOperation(Operation op)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			if(operations.get(i).equals(op))
				return;
		}

		operations.add(op);
	} 

	
	private static String getDownloadDir()
	{
		if(downloadDir == null)
		{
			String settings = jEdit.getSettingsDirectory();
			if(settings == null)
				settings = System.getProperty(""user.home"");
			downloadDir = new File(MiscUtilities.constructPath(
				settings,""PluginManager.download""));
			downloadDir.mkdirs();
		}

		return downloadDir.getPath();
	} 

	

	
	abstract static class Operation
	{
		public void runInWorkThread(PluginManagerProgress progress)
		{
		}

		public void runInAWTThread(Component comp)
		{
		}

		public int getMaximum()
		{
			return 0;
		}
	} 

	
	class Remove extends Operation
	{
		
		Remove(String jar)
		{
			this.jar = jar;
		} 

		
		public void runInAWTThread(Component comp)
		{
			
			PluginJAR jar = jEdit.getPluginJAR(this.jar);
			if(jar != null)
			{
				unloadPluginJAR(jar);
			}

			toLoad.remove(this.jar);

			

			
			File jarFile = new File(this.jar);
			File srcFile = new File(this.jar.substring(0, this.jar.length() - 4));

			Log.log(Log.NOTICE,this,""Deleting "" + jarFile);

			boolean ok = jarFile.delete();

			if(srcFile.exists())
			{
				ok &= recursiveDelete(srcFile);
			}

			if(!ok)
			{
				String[] args = {this.jar};
				GUIUtilities.error(comp,""plugin-manager.remove-failed"",args);
			}
		} 

		
		
		private void unloadPluginJAR(PluginJAR jar)
		{
			String[] dependents = jar.getDependentPlugins();
			for (String path: dependents) 
			{
				PluginJAR _jar = jEdit.getPluginJAR(path);
				if(_jar != null)
				{
					toLoad.add(path);
					unloadPluginJAR(_jar);
					
					String cachePath = jar.getCachePath();
					if(cachePath != null)
						new File(cachePath).delete();

				}
			}
			jEdit.removePluginJAR(jar,false);
			
		} 

		
		public boolean equals(Object o)
		{
			return o instanceof Remove
			       && ((Remove) o).jar.equals(jar);
		} 

		
		private final String jar;
		
	} 

	
	class Install extends Operation
	{
		int size;

		
		Install(String installed, String url, String installDirectory,
			int size)
		{
			
			if(url == null)
				throw new NullPointerException();

			this.installed = installed;
			this.url = url;
			this.installDirectory = installDirectory;
			this.size = size;
		} 

		
		public int getMaximum()
		{
			return size;
		} 

		
		public void runInWorkThread(PluginManagerProgress progress)
		{
			String fileName = MiscUtilities.getFileName(url);

			path = download(progress,fileName,url);
		} 

		
		public void runInAWTThread(Component comp)
		{
			
			if(path == null)
				return;

			
			if(installed != null)
				new Remove(installed).runInAWTThread(comp);

			ZipFile zipFile = null;

			try
			{
				zipFile = new ZipFile(path);

				Enumeration<? extends ZipEntry> e = zipFile.entries();
				while(e.hasMoreElements())
				{
					ZipEntry entry = e.nextElement();
					String name = entry.getName().replace('/',File.separatorChar);
					File file = new File(installDirectory,name);
					if(entry.isDirectory())
						file.mkdirs();
					else
					{
						new File(file.getParent()).mkdirs();
						InputStream in = null;
						FileOutputStream out = null;
						try
						{
							in = zipFile.getInputStream(entry);
							out = new FileOutputStream(file);
							IOUtilities.copyStream(4096,
								null,
								in,
								out,false);
						}
						finally
						{
							IOUtilities.closeQuietly(in);
							IOUtilities.closeQuietly(out);
						}
						if(file.getName().toLowerCase().endsWith("".jar""))
							toLoad.add(file.getPath());
					}
				}
			}
			catch(InterruptedIOException iio)
			{
			}
			catch(ZipException e)
			{
				Log.log(Log.ERROR,this,e);
				GUIUtilities.error(null,""plugin-error-download"",new Object[]{""""});
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);

				String[] args = { io.getMessage() };
				GUIUtilities.error(null,""ioerror"",args);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
			finally
			{
				try
				{
					if(zipFile != null)
						zipFile.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}

				if(jEdit.getBooleanProperty(
					""plugin-manager.deleteDownloads""))
				{
					new File(path).delete();
				}
			}
		} 

		
		public boolean equals(Object o)
		{
			return o instanceof Install
			       && ((Install) o).url.equals(url);
		} 

		
		private String installed;
		private final String url;
		private String installDirectory;
		private String path;

		
		private String download(PluginManagerProgress progress,
			String fileName, String url)
		{
			try
			{
				String host = jEdit.getProperty(""plugin-manager.mirror.id"");
				if (host == null || host.equals(MirrorList.Mirror.NONE))
					host = ""default"";
				
				String path = MiscUtilities.constructPath(getDownloadDir(),fileName);
				URLConnection conn = new URL(url).openConnection();
				progress.setStatus(jEdit.getProperty(""plugin-manager.progress"",new String[] {fileName, host}));
				InputStream in = null;
				FileOutputStream out = null;
				try
				{
					in = conn.getInputStream();
					out = new FileOutputStream(path);
					if(!IOUtilities.copyStream(progress,in,out,true))
						return null;
				}
				finally
				{
					IOUtilities.closeQuietly(in);
					IOUtilities.closeQuietly(out);
				}
				
				return path;
			}
			catch(InterruptedIOException iio)
			{
				
				return null;
			}
			catch(FileNotFoundException e)
			{
				Log.log(Log.ERROR,this,e);

				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						GUIUtilities.error(null,""plugin-error-download"",new Object[]{""""});
					}
				});

				return null;
			}
			catch(final IOException io)
			{
				Log.log(Log.ERROR,this,io);

				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						String[] args = { io.getMessage() };
						GUIUtilities.error(null,""plugin-error-download"",args);
					}
				});

				return null;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);

				return null;
			}
		} 

		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.XThis,4,2,0,4,17,4,1,4,4,0.5,94,0.0,0,0.769230769,0.4,1,1,22.0,4,1.5,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.*;
import java.lang.reflect.InvocationHandler;
import java.util.Hashtable;


public class XThis extends This
    {
    
    Hashtable interfaces;

    InvocationHandler invocationHandler = new Handler();

    public XThis( NameSpace namespace, Interpreter declaringInterp ) {
        super( namespace, declaringInterp );
    }

    public String toString() {
        return ""'this' reference (XThis) to Bsh object: "" + namespace;
    }

    
    public Object getInterface( Class clas )
    {
        return getInterface( new Class[] { clas } );
    }

    
    public Object getInterface( Class [] ca )
    {
        if ( interfaces == null )
            interfaces = new Hashtable();

        
        int hash = 21;
        for(int i=0; i<ca.length; i++)
            hash *= ca[i].hashCode() + 3;
        Object hashKey = new Integer(hash);

        Object interf = interfaces.get( hashKey );

        if ( interf == null )
        {
            ClassLoader classLoader = ca[0].getClassLoader(); 
            interf = Proxy.newProxyInstance(
                classLoader, ca, invocationHandler );
            interfaces.put( hashKey, interf );
        }

        return interf;
    }

    
    class Handler implements InvocationHandler, java.io.Serializable
    {
        public Object invoke( Object proxy, Method method, Object[] args )
            throws Throwable
        {
            try {
                return invokeImpl( proxy, method, args );
            } catch ( TargetError te ) {
                
                
                
                throw te.getTarget();
            } catch ( EvalError ee ) {
                
                
                if ( Interpreter.DEBUG )
                    Interpreter.debug( ""EvalError in scripted interface: ""
                    + XThis.this.toString() + "": ""+ ee );
                throw ee;
            }
        }

        public Object invokeImpl( Object proxy, Method method, Object[] args )
            throws EvalError
        {
            String methodName = method.getName();
            CallStack callstack = new CallStack( namespace );

            
            BshMethod equalsMethod = null;
            try {
                equalsMethod = namespace.getMethod(
                    ""equals"", new Class [] { Object.class } );
            } catch ( UtilEvalError e ) { }
            if ( methodName.equals(""equals"" ) && equalsMethod == null ) {
                Object obj = args[0];
                return new Boolean( proxy == obj );
            }

            
            BshMethod toStringMethod = null;
            try {
                toStringMethod =
                    namespace.getMethod( ""toString"", new Class [] { } );
            } catch ( UtilEvalError e ) { }

            if ( methodName.equals(""toString"" ) && toStringMethod == null)
            {
                Class [] ints = proxy.getClass().getInterfaces();
                
                StringBuilder sb = new StringBuilder(
                    XThis.this.toString() + ""\nimplements:"" );
                for(int i=0; i<ints.length; i++)
                    sb.append( "" ""+ ints[i].getName()
                        + ((ints.length > 1)?"","":"""") );
                return sb.toString();
            }

            Class [] paramTypes = method.getParameterTypes();
            return Primitive.unwrap(
                invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );
        }
    };
}



"
jEdit,4.3,org.gjt.sp.jedit.JEditMode,3,2,0,5,13,3,1,4,2,2.0,86,0.0,0,0.909090909,0.833333333,1,3,27.66666667,4,2.3333,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.util.Log;


class JEditMode extends Mode
{
	
	JEditMode(String name)
	{
		super(name);
	} 

	
	
	@Override
	public Object getProperty(String key)
	{
		String prefix = ""mode."" + name + '.';

		
		
			String property = jEdit.getProperty(prefix + key);
			if(property != null)
			{
				Object value;
				try
				{
					value = new Integer(property);
				}
				catch(NumberFormatException nf)
				{
					value = property;
				}
				return value;
			}
		

		Object value = props.get(key);
		if(value != null)
			return value;

		String global = jEdit.getProperty(""buffer."" + key);
		if(global != null)
		{
			try
			{
				return new Integer(global);
			}
			catch(NumberFormatException nf)
			{
				return global;
			}
		}
		else
			return null;
	} 

	
	
	@Override
	public void loadIfNecessary()
	{
		if(marker == null)
		{
			jEdit.loadMode(this);
			if (marker == null)
				Log.log(Log.ERROR, this, ""Mode not correctly loaded, token marker is still null"");
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.AddAbbrevDialog,5,6,0,7,34,2,3,6,1,0.8,203,1.0,2,0.99389313,0.35,0,0,38.6,1,0.8,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;

public class AddAbbrevDialog extends JDialog
{
	public AddAbbrevDialog(View view, String abbrev)
	{
		super(view,jEdit.getProperty(""add-abbrev.title""),true);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setBorder(new EmptyBorder(6,0,12,0));
		content.add(BorderLayout.CENTER,editor);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		global = new JButton(jEdit.getProperty(""add-abbrev.global""));
		global.addActionListener(new ActionHandler());
		box.add(global);
		box.add(Box.createHorizontalStrut(6));
		modeSpecific = new JButton(jEdit.getProperty(""add-abbrev.mode""));
		modeSpecific.addActionListener(new ActionHandler());
		box.add(modeSpecific);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);

		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		if(abbrev == null)
			GUIUtilities.requestFocus(this,editor.getAbbrevField());
		else
			GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());

		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	}

	
	private View view;
	private AbbrevEditor editor;
	private JButton global;
	private JButton modeSpecific;
	private JButton cancel;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == global)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addGlobalAbbrev(_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			else if(source == modeSpecific)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addModeAbbrev(view.getBuffer().getMode().getName(),
					_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}

			dispose();
		}
	}

	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.io.EncodingServer,7,1,0,9,29,21,5,4,7,1.166666667,113,1.0,0,0.0,0.25,0,0,15.0,3,1.2857,0,"

package org.gjt.sp.jedit.io;


import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Arrays;

import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.ServiceManager;



public class EncodingServer
{
	
	
	public static Encoding getEncoding(String name)
	{
		try
		{
			return new CharsetEncoding(name);
		}
		catch (IllegalCharsetNameException e)
		{
			
		}
		catch (UnsupportedCharsetException e)
		{
			
		}

		Object namedService = ServiceManager.getService(serviceClass, name);
		if (namedService != null && namedService instanceof Encoding)
		{
			return (Encoding)namedService;
		}

		
		
		
		throw new UnsupportedCharsetException(""No such encoding: \"""" + name + ""\"""");
	} 

	
	
	public static Set<String> getAvailableNames()
	{
		Set<String> set = new HashSet<String>();
		set.addAll(Charset.availableCharsets().keySet());
		set.addAll(Arrays.asList(ServiceManager.getServiceNames(serviceClass)));
		return set;
	} 

	
	
	public static Set<String> getSelectedNames()
	{
		Set<String> set = getAvailableNames();
		Iterator<String> i = set.iterator();
		while (i.hasNext())
		{
			String name = i.next();
			if (jEdit.getBooleanProperty(""encoding.opt-out."" + name, false))
			{
				i.remove();
			}
		}
		return set;
	} 

	
	
	public static Reader getTextReader(InputStream in, String encoding)
		throws IOException
	{
		return getEncoding(encoding).getTextReader(in);
	} 

	
	
	public static Writer getTextWriter(OutputStream out, String encoding)
		throws IOException
	{
		return getEncoding(encoding).getTextWriter(out);
	} 

	
	
	public static boolean hasEncoding(String name)
	{
		try
		{
			if (Charset.isSupported(name))
			{
				return true;
			}
		}
		catch (IllegalCharsetNameException e)
		{
			
			
		}

		return Arrays.asList(ServiceManager.getServiceNames(serviceClass)).contains(name);
	} 

	
	private static final String serviceClass = ""org.gjt.sp.jedit.io.Encoding"";
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Node,7,1,0,40,7,21,40,0,7,2.0,7,0.0,0,0.0,0.523809524,0,0,0.0,1,1.0,0,"




package org.gjt.sp.jedit.bsh;


interface Node extends java.io.Serializable
{

	public void jjtOpen();


	public void jjtClose();


	public void jjtSetParent(Node n);
	public Node jjtGetParent();


	public void jjtAddChild(Node n, int i);


	public Node jjtGetChild(int i);


	public int jjtGetNumChildren();
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.ClassPathException,1,4,0,3,2,0,2,1,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.bsh;

public class ClassPathException extends UtilEvalError {
	public ClassPathException( String msg ) { super(msg); }
}

"
jEdit,4.3,org.gjt.sp.jedit.OptionGroup,13,1,0,7,33,26,5,2,12,0.604166667,261,1.0,0,0.0,0.252747253,0,0,18.76923077,7,1.4615,0,"

package org.gjt.sp.jedit;

import java.util.*;


public class OptionGroup
{
	
	
	protected final String name;
	protected final String label;
	protected final Vector<Object> members;
	private boolean sort;
	
	
	
	
	public OptionGroup(String name)
	{
		this.name = name;
		label = jEdit.getProperty(""options."" + name + "".label"");
		members = new Vector<Object>();
	} 

	
	
	public OptionGroup(String name, String label, String options)
	{
		this.name = name;
		this.label = label;
		members = new Vector<Object>();

		StringTokenizer st = new StringTokenizer(options);
		while(st.hasMoreTokens())
		{
			String pane = st.nextToken();
			addOptionPane(pane);
		}
	} 

	
	public String getName()
	{
		return name;
	} 

	
	
	public String getLabel()
	{
		return label;
	} 

	
	public void addOptionGroup(OptionGroup group)
	{
		insertionSort(group.getLabel(),group);
	} 

	
	public void addOptionPane(OptionPane pane)
	{
		String label = jEdit.getProperty(""options.""
			+ pane.getName() + "".label"",""NO LABEL PROPERTY: ""
			+ pane.getName());

		insertionSort(label,pane);
	} 

	
	public void addOptionPane(String pane)
	{
		String label = jEdit.getProperty(""options.""
			+ pane + "".label"",""NO LABEL PROPERTY: ""
			+ pane);

		insertionSort(label,pane);
	} 

	
	public Enumeration<Object> getMembers()
	{
		return members.elements();
	} 

	
	public Object getMember(int index)
	{
		return (index >= 0 && index < members.size())
			? members.elementAt(index) : null;
	} 

	
	public int getMemberIndex(Object member)
	{
		return members.indexOf(member);
	} 

	
	public int getMemberCount()
	{
		return members.size();
	} 

	
	
	public void setSort(boolean sort)
	{
		this.sort = sort;
	} 

	


	
	private void insertionSort(String newLabel, Object newObj)
	{
		if(sort)
		{
			for(int i = 0; i < members.size(); i++)
			{
				Object obj = members.elementAt(i);
				String label;
				if(obj instanceof OptionPane)
				{
					String name = ((OptionPane)obj).getName();
					label = jEdit.getProperty(""options.""
						+ name + "".label"",""NO LABEL PROPERTY: ""
						+ name);
				}
				else if(obj instanceof String)
				{
					label = jEdit.getProperty(""options.""
						+ obj + "".label"",""NO LABEL PROPERTY: ""
						+ obj);
				}
				else if(obj instanceof OptionGroup)
					label = ((OptionGroup)obj).getLabel();
				else
					throw new InternalError();

				if(newLabel.compareToIgnoreCase(label) < 0)
				{
					members.insertElementAt(newObj,i);
					return;
				}
			}
		}

		members.addElement(newObj);
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.DelayedEvalBshMethod,5,2,0,12,13,0,2,10,4,0.666666667,94,0.0,4,0.733333333,0.28,1,2,16.6,2,1.0,0,"

package org.gjt.sp.jedit.bsh;

public class DelayedEvalBshMethod extends BshMethod
{
	String returnTypeDescriptor;
	BSHReturnType returnTypeNode;
	String [] paramTypeDescriptors;
	BSHFormalParameters paramTypesNode;

	
	transient CallStack callstack;
	transient Interpreter interpreter;

	
	
	DelayedEvalBshMethod( 
		String name, 
		String returnTypeDescriptor, BSHReturnType returnTypeNode,
		String [] paramNames,
		String [] paramTypeDescriptors, BSHFormalParameters paramTypesNode,
		BSHBlock methodBody, 
		NameSpace declaringNameSpace, Modifiers modifiers,
		CallStack callstack, Interpreter interpreter
	) {
		super( name, null, paramNames, null,
			methodBody, declaringNameSpace, modifiers );

		this.returnTypeDescriptor = returnTypeDescriptor;
		this.returnTypeNode = returnTypeNode;
		this.paramTypeDescriptors = paramTypeDescriptors;
		this.paramTypesNode = paramTypesNode;
		this.callstack = callstack;
		this.interpreter = interpreter;
	}

	public String getReturnTypeDescriptor() { return returnTypeDescriptor; }

	public Class getReturnType() 
	{ 
		if ( returnTypeNode == null )
			return null;

		
		try {
			return returnTypeNode.evalReturnType( callstack, interpreter );
		} catch ( EvalError e ) {
			throw new InterpreterError(""can't eval return type: ""+e);
		}
	}

	public String [] getParamTypeDescriptors() { return paramTypeDescriptors; }

	public Class [] getParameterTypes() 
	{ 
		
		try {
			return (Class [])paramTypesNode.eval( callstack, interpreter );
		} catch ( EvalError e ) {
			throw new InterpreterError(""can't eval param types: ""+e);
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.SettingsXML,9,1,0,7,21,0,5,3,7,0.5,87,1.0,0,0.0,0.240740741,0,0,8.444444444,3,1.0,0,"

package org.gjt.sp.jedit;


import java.io.File;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;

import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.util.XMLUtilities;



public class SettingsXML
{
	
	
	public class Saver extends BufferedWriter
	{
		
		
		public void writeXMLDeclaration() throws IOException
		{
			writeXMLDeclaration(""1.0"");
		} 

		
		
		public void writeXMLDeclaration(String version)
			throws IOException
		{
			write(""<?xml""
				+ "" version=\"""" + version + ""\""""
				+ "" encoding=\"""" + encoding + ""\""""
				+ "" ?>"");
			newLine();
		} 

		
		
		public void finish() throws IOException
		{
			close();
			jEdit.backupSettingsFile(file);
			file.delete();
			twoStageSaveFile.renameTo(file);
			knownLastModified = file.lastModified();
		} 

		
		private File twoStageSaveFile;
		private static final String encoding = ""UTF-8"";

		
		Saver() throws IOException
		{
			this(new File(file.getParentFile(),
				""#"" + file.getName() + ""#save#""));
		}

		
		private Saver(File twoStageSaveFile) throws IOException
		{
			super(new OutputStreamWriter(
				new FileOutputStream(twoStageSaveFile)
				, encoding));
			this.twoStageSaveFile = twoStageSaveFile;
		}

		
	} 

	
	
	public SettingsXML(String settingsDirectory, String name)
	{
		String filename = name + "".xml"";
		file = new File(MiscUtilities.constructPath(
			settingsDirectory, filename));
	} 
	
	public SettingsXML(File f)
	{
		file = f;
	}

	
	
	public boolean fileExists()
	{
		return file.exists();
	} 

	
	
	public void load(DefaultHandler handler) throws IOException
	{
		XMLUtilities.parseXML(new FileInputStream(file), handler);
		knownLastModified = file.lastModified();
	} 

	
	
	public Saver openSaver() throws IOException
	{
		return new Saver();
	} 

	
	
	public boolean hasChangedOnDisk()
	{
		return file.exists()
			&& (file.lastModified() != knownLastModified);
	} 

	
	
	public String toString()
	{
		return file.toString();
	} 

	
	private File file;
	private long knownLastModified;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ErrorListDialog,5,7,0,9,64,6,3,8,3,0.75,312,1.0,0,0.993939394,0.3,2,5,61.0,1,0.8,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.pluginmgr.PluginManager;
import org.gjt.sp.util.Log;


public class ErrorListDialog extends EnhancedDialog
{
	
	public static class ErrorEntry
	{
		String path;
		String[] messages;

		public ErrorEntry(String path, String messageProp, Object[] args)
		{
			this.path = path;

			String message = jEdit.getProperty(messageProp,args);
			if(message == null)
				message = ""Undefined property: "" + messageProp;

			Log.log(Log.ERROR,this,path + "":"");
			Log.log(Log.ERROR,this,message);

			Vector<String> tokenizedMessage = new Vector<String>();
			int lastIndex = -1;
			for(int i = 0; i < message.length(); i++)
			{
				if(message.charAt(i) == '\n')
				{
					tokenizedMessage.addElement(message.substring(
						lastIndex + 1,i));
					lastIndex = i;
				}
			}

			if(lastIndex != message.length())
			{
				tokenizedMessage.addElement(message.substring(
					lastIndex + 1));
			}

			messages = new String[tokenizedMessage.size()];
			tokenizedMessage.copyInto(messages);
		}

		public boolean equals(Object o)
		{
			if(o instanceof ErrorEntry)
			{
				ErrorEntry e = (ErrorEntry)o;
				return e.path.equals(path);
			}
			else
				return false;
		}

		
		
		
		public String toString()
		{
			return path + "":\n"" +
				TextUtilities.join(java.util.Arrays.asList(messages), ""\n"");
		}
	} 

	
	public ErrorListDialog(Frame frame, String title, String caption,
		Vector<ErrorEntry> messages, boolean pluginError)
	{
		super(frame,title,!pluginError);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.errorIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(caption);
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		JTextPane errors = new JTextPane();
		errors.setEditable(false);
		errors.setForeground(jEdit.getColorProperty(""view.fgColor""));
		errors.setBackground(jEdit.getColorProperty(""view.bgColor""));
		errors.setCaretColor(jEdit.getColorProperty(""view.caretColor""));
		errors.setSelectionColor(jEdit.getColorProperty(""view.selectionColor""));
		StyledDocument doc = errors.getStyledDocument();
		Font plainFont = new JLabel().getFont();
		SimpleAttributeSet plainFontAttrSet = new SimpleAttributeSet();
		StyleConstants.setFontFamily(plainFontAttrSet, plainFont.getFamily());
		SimpleAttributeSet boldFontAttrSet = (SimpleAttributeSet) plainFontAttrSet.clone();
		StyleConstants.setBold(boldFontAttrSet, true);
		for (ErrorEntry entry : messages)
		{
			try
			{
				doc.insertString(doc.getLength(), entry.path + "":\n"", boldFontAttrSet);
				for (String s: entry.messages)
					doc.insertString(doc.getLength(), s + ""\n"", plainFontAttrSet);
			}
			catch (BadLocationException e)
			{
			}
		}

		
		
		JScrollPane scrollPane = new JScrollPane(errors,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
		Dimension size = scrollPane.getPreferredSize();
		size.width = Math.min(size.width,400);
		scrollPane.setPreferredSize(size);

		centerPanel.add(BorderLayout.CENTER,scrollPane);

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());

		if(pluginError)
		{
			pluginMgr = new JButton(jEdit.getProperty(""error-list.plugin-manager""));
			pluginMgr.addActionListener(new ActionHandler());
			buttons.add(pluginMgr);
			buttons.add(Box.createHorizontalStrut(6));
		}

		buttons.add(ok);

		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		getRootPane().setDefaultButton(ok);

		pack();
		setLocationRelativeTo(frame);
		setVisible(true);
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private JButton ok, pluginMgr;
	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				dispose();
			else if(evt.getSource() == pluginMgr)
			{
				PluginManager.showPluginManager(JOptionPane.getFrameForComponent(
					ErrorListDialog.this));
			}
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.RectSelectWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,1,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.textarea.JEditTextArea;



public class RectSelectWidgetFactory implements StatusWidgetFactory
{
    
    public Widget getWidget(View view) 
    {
	    Widget rect = new RectSelectWidget(view);
	    return rect;
    } 

    
    private static class RectSelectWidget implements Widget
    {
	    private final JLabel rectSelect;
	    private final View view;
	    RectSelectWidget(final View view)
	    {
		    rectSelect = new ToolTipLabel();
		    rectSelect.setHorizontalAlignment(SwingConstants.CENTER);
		    rectSelect.setToolTipText(jEdit.getProperty(""view.status.rect-tooltip""));
		    this.view = view;
		    rectSelect.addMouseListener(new MouseAdapter()
		    {
			    @Override
			    public void mouseClicked(MouseEvent evt)
			    {
				    JEditTextArea textArea = view.getTextArea();
				    if (textArea != null)
				    	textArea.toggleRectangularSelectionEnabled();
			    }
		    });
	    }
	    
	    public JComponent getComponent() 
	    {
		    return rectSelect;
	    }
	    
	    public void update() 
	    {
		    JEditTextArea textArea = view.getTextArea();
		    if (textArea != null)
		    {
			    rectSelect.setText(textArea.isRectangularSelectionEnabled()
					       ? ""R"" : ""-"");
		    }
	    }
	    
            public void propertiesChanged()
	    {
		    
		    Font font = new JLabel().getFont();
		    
		    FontMetrics fm = rectSelect.getFontMetrics(font);
		    Dimension dim = new Dimension(
						  Math.max(fm.charWidth('-'),fm.charWidth('R')) + 1,
						  fm.getHeight());
		    rectSelect.setPreferredSize(dim);
		    rectSelect.setMaximumSize(dim);
		    
	    }
    } 

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.SplashScreen,7,4,0,3,64,5,1,2,5,0.794871795,427,1.0,0,0.990797546,0.464285714,1,2,58.14285714,3,1.2857,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.*;

import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;



public class SplashScreen extends JComponent
{
	
	public SplashScreen()
	{
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		setBackground(Color.white);

		setFont(defaultFont);
		fm = getFontMetrics(defaultFont);
		image = getToolkit().getImage(
			getClass().getResource(""/org/gjt/sp/jedit/icons/splash.png""));
		MediaTracker tracker = new MediaTracker(this);
		tracker.addImage(image,0);

		try
		{
			tracker.waitForAll();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
		Dimension screen = getToolkit().getScreenSize(); 
		win = new JWindow();
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		GraphicsDevice[] gs = ge.getScreenDevices();
		GraphicsDevice gd = gs[0];
		if (gd != null)
		{
			GraphicsConfiguration gconf = gd.getDefaultConfiguration();
			if (gconf != null)
			{
				Rectangle bounds = gconf.getBounds();
				screen = new Dimension(bounds.width, bounds.height);
			}
		}
		Dimension size = new Dimension(image.getWidth(this) + 2,
			image.getHeight(this) + 2 + PROGRESS_HEIGHT);
		win.setSize(size);

		win.getContentPane().add(this, BorderLayout.CENTER);

		win.setLocation((screen.width - size.width) / 2,
			(screen.height - size.height) / 2);
		win.validate();
		win.setVisible(true);
	} 

	
	public void dispose()
	{
		win.dispose();
	} 

	
	public synchronized void advance()
	{
		logAdvanceTime(null);
		progress++;
		repaint();

		
		
		try
		{
			wait();
		}
		catch(InterruptedException ie)
		{
			Log.log(Log.ERROR,this,ie);
		}
	}

	public synchronized void advance(String label)
	{
		logAdvanceTime(label);
		progress++;
		this.label = label;
		repaint();

		
		
		try
		{
			wait();
		}
		catch(InterruptedException ie)
		{
			Log.log(Log.ERROR,this,ie);
		}
	} 

	
	private void logAdvanceTime(String label)
	{
		long currentTime = System.currentTimeMillis();
		if (lastLabel != null)
		{
			Log.log(Log.DEBUG, SplashScreen.class,
				lastLabel +':'+(currentTime - lastAdvanceTime) + ""ms"");
		}
		if (label != null)
		{
			lastLabel = label;
			lastAdvanceTime = currentTime;

		}
	} 

	
	@Override
	public synchronized void paintComponent(Graphics g)
	{
		Dimension size = getSize();

		g.setColor(Color.black);
		g.drawRect(0,0,size.width - 1,size.height - 1);

		g.drawImage(image,1,1,this);

		
		g.setColor(Color.white);
		g.fillRect(1,image.getHeight(this) + 1,
			((win.getWidth() - 2) * progress) / PROGRESS_COUNT, PROGRESS_HEIGHT);

		g.setColor(Color.black);

		if (label != null)
		{
			int drawOffsetX = (getWidth() - fm.stringWidth(label)) / 2;
			int drawOffsetY = image.getHeight(this) + (PROGRESS_HEIGHT
							      + fm.getAscent() + fm.getDescent()) / 2;

			paintString(g, label, drawOffsetX, drawOffsetY);
		}

		String version = ""version "" + jEdit.getVersion();

		int drawOffsetX = (getWidth() / 2) - (fm.stringWidth(version) / 2);
		int drawOffsetY = image.getHeight(this) - fm.getDescent() - 2;

		paintString(g, version, drawOffsetX, drawOffsetY);

		notify();
	} 

	
	private void paintString(Graphics g, String version, int drawOffsetX,
				 int drawOffsetY)
	{
		g.setFont( labelFont );

		g.setColor( versionColor1 );
		g.drawString( version, drawOffsetX, drawOffsetY );
		
		g.setColor( versionColor2 );
		g.drawString( version, drawOffsetX + 1, drawOffsetY + 1 );
	} 

	
	private final FontMetrics fm;
	private final JWindow win;
	private final Image image;
	private int progress;
	private static final int PROGRESS_HEIGHT = 20;
	private static final int PROGRESS_COUNT = 28;
	private String label;
	private String lastLabel;
	private long lastAdvanceTime = System.currentTimeMillis();
	private Font defaultFont = new Font(""Dialog"",Font.PLAIN,10);
	private Font labelFont = UIManager.getFont(""Label.font"").deriveFont(9.8f);
	private Color versionColor1 = new Color(55, 55, 55);
	private Color versionColor2 = new Color(255, 255, 255, 50);
	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.BufferHandler,12,1,0,12,66,0,1,12,8,0.519480519,675,1.0,3,0.0,0.5,0,0,54.66666667,15,4.9167,0,"

package org.gjt.sp.jedit.textarea;

import java.util.Iterator;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.Debug;


class BufferHandler implements BufferListener
{
	private final DisplayManager displayManager;
	private final TextArea textArea;
	private final JEditBuffer buffer;
	private boolean delayedUpdate;
	private boolean delayedMultilineUpdate;
	private int delayedUpdateStart;
	private int delayedUpdateEnd;

	
	BufferHandler(DisplayManager displayManager,
		TextArea textArea,
		JEditBuffer buffer)
	{
		this.displayManager = displayManager;
		this.textArea = textArea;
		this.buffer = buffer;
	} 

	
	public void bufferLoaded(JEditBuffer buffer)
	{
		displayManager.bufferLoaded();
	} 

	
	public void foldHandlerChanged(JEditBuffer buffer)
	{
		displayManager.foldHandlerChanged();
	} 

	
	public void foldLevelChanged(JEditBuffer buffer, int start, int end)
	{
		

		if(textArea.getDisplayManager() == displayManager
			&& end != 0 && !buffer.isLoading())
		{
			textArea.invalidateLineRange(start - 1,
				textArea.getLastPhysicalLine());
		}
	} 

	
	public void contentInserted(JEditBuffer buffer, int startLine,
		int offset, int numLines, int length)
	{
		if(buffer.isLoading())
			return;

		displayManager.screenLineMgr.contentInserted(startLine,numLines);

		int endLine = startLine + numLines;

		if(numLines != 0)
			delayedMultilineUpdate = true;

		displayManager.folds.contentInserted(startLine,numLines);

		FirstLine firstLine = displayManager.firstLine;
		ScrollLineCount scrollLineCount = displayManager.scrollLineCount;

		if(textArea.getDisplayManager() == displayManager)
		{
			if(numLines != 0)
			{
				firstLine.contentInserted(startLine,numLines);
				scrollLineCount.contentInserted(startLine,numLines);
			}

			if(delayedUpdateEnd >= startLine)
				delayedUpdateEnd += numLines;
			delayUpdate(startLine,endLine);

			
			
			Iterator<Selection> iter = textArea.getSelectionIterator();
			while(iter.hasNext())
			{
				Selection s = iter.next();

				if(s.contentInserted(buffer,startLine,offset,
					numLines,length))
				{
					delayUpdate(s.startLine,s.endLine);
				}
			} 

			int caret = textArea.getCaretPosition();
			if(caret >= offset)
			{
				int scrollMode = textArea.caretAutoScroll()
					? TextArea.ELECTRIC_SCROLL
					: TextArea.NO_SCROLL;
				textArea.moveCaretPosition(
					caret + length,scrollMode);
			}
			else
			{
				int scrollMode = textArea.caretAutoScroll()
					? TextArea.NORMAL_SCROLL
					: TextArea.NO_SCROLL;
				textArea.moveCaretPosition(
					caret,scrollMode);
			}
		}
		else
		{
			firstLine.callReset = true;
			scrollLineCount.callReset = true;
		}
	} 

	
	
	public void preContentInserted(JEditBuffer buffer, int startLine, int offset, int numLines, int length)
	{
		if(textArea.getDisplayManager() == displayManager)
		{
			getReadyToBreakFold(startLine);
		}
	} 

	
	
	public void preContentRemoved(JEditBuffer buffer, int startLine,
		int offset, int numLines, int length)
	{
		if(buffer.isLoading())
			return;

		FirstLine firstLine = displayManager.firstLine;
		ScrollLineCount scrollLineCount = displayManager.scrollLineCount;

		if(textArea.getDisplayManager() == displayManager)
		{
			if(numLines == 0)
			{
				getReadyToBreakFold(startLine);
			}
			else
			{
				int lastLine = startLine + numLines;
				if(!displayManager.isLineVisible(startLine)
				 || !displayManager.isLineVisible(lastLine)
			 	 || offset != buffer.getLineStartOffset(startLine)
				 || offset + length != buffer.getLineStartOffset(lastLine))
				{
					getReadyToBreakFold(startLine);
					getReadyToBreakFold(lastLine);
				}
				else
				{
					
					
					
				}
			}

			if(numLines != 0)
			{
				firstLine.preContentRemoved(startLine,offset, numLines);
				scrollLineCount.preContentRemoved(startLine, offset, numLines);
			}

			if(delayedUpdateEnd >= startLine)
				delayedUpdateEnd -= numLines;
			delayUpdate(startLine,startLine);
		}
		else
		{
			firstLine.callReset = true;
			scrollLineCount.callReset = true;
		}

		displayManager.screenLineMgr.contentRemoved(startLine,numLines);

		if(numLines == 0)
			return;

		delayedMultilineUpdate = true;

		if(displayManager.folds.preContentRemoved(startLine,numLines))
		{
			displayManager.folds.reset(buffer.getLineCount());
			firstLine.callReset = true;
			scrollLineCount.callReset = true;
		}

		if(firstLine.physicalLine
			> displayManager.getLastVisibleLine()
			|| firstLine.physicalLine
			< displayManager.getFirstVisibleLine())
		{
			
			
			
		}
		
		
		
		
		else if(!displayManager.isLineVisible(
			firstLine.physicalLine))
		{
			firstLine.physicalLine =
				displayManager.getNextVisibleLine(
				firstLine.physicalLine);
		}
	} 

	
	public void contentRemoved(JEditBuffer buffer, int startLine,
		int start, int numLines, int length)
	{
		if(buffer.isLoading())
			return;

		if(textArea.getDisplayManager() == displayManager)
		{
			
			int nSel = textArea.getSelectionCount();
			Iterator<Selection> iter = textArea.getSelectionIterator();
			while(iter.hasNext())
			{
				Selection s = iter.next();

				if(s.contentRemoved(buffer,startLine,
					start,numLines,length))
				{
					delayUpdate(s.startLine,s.endLine);
					if(nSel == 1 && s.start == s.end)
						iter.remove();
				}
			} 

			int caret = textArea.getCaretPosition();

			if(caret >= start + length)
			{
				int scrollMode = textArea.caretAutoScroll()
					? TextArea.ELECTRIC_SCROLL
					: TextArea.NO_SCROLL;
				textArea.moveCaretPosition(
					caret - length,
					scrollMode);
			}
			else if(caret >= start)
			{
				int scrollMode = textArea.caretAutoScroll()
					? TextArea.ELECTRIC_SCROLL
					: TextArea.NO_SCROLL;
				textArea.moveCaretPosition(
					start,scrollMode);
			}
			else
			{
				int scrollMode = textArea.caretAutoScroll()
					? TextArea.NORMAL_SCROLL
					: TextArea.NO_SCROLL;
				textArea.moveCaretPosition(caret,scrollMode);
			}
		}
	}
	

	
	public void transactionComplete(JEditBuffer buffer)
	{
		if(textArea.getDisplayManager() != displayManager)
		{
			delayedUpdate = false;
			return;
		}

		if(delayedUpdate)
			doDelayedUpdate();

		textArea._finishCaretUpdate();

		delayedUpdate = false;

		
		if(Debug.SCROLL_VERIFY)
		{
			int line = delayedUpdateStart;
			if(!displayManager.isLineVisible(line))
				line = displayManager.getNextVisibleLine(line);
			System.err.println(delayedUpdateStart + "":"" + delayedUpdateEnd + ':' + textArea.getLineCount());
			int scrollLineCount = 0;
			while(line != -1 && line <= delayedUpdateEnd)
			{
				scrollLineCount += displayManager.getScreenLineCount(line);
				line = displayManager.getNextVisibleLine(line);
			}

			if(scrollLineCount != displayManager.getScrollLineCount())
			{
				throw new InternalError(scrollLineCount
					+ "" != ""
					+ displayManager.getScrollLineCount());
			}
		} 
	} 

	
	private void doDelayedUpdate()
	{
		
		
		
		int line = delayedUpdateStart;
		if(!displayManager.isLineVisible(line))
			line = displayManager.getNextVisibleLine(line);
		while(line != -1 && line <= delayedUpdateEnd)
		{
			displayManager.updateScreenLineCount(line);
			line = displayManager.getNextVisibleLine(line);
		}

		
		
		
		
		displayManager.notifyScreenLineChanges();

		if(delayedMultilineUpdate)
		{
			textArea.invalidateScreenLineRange(
				textArea.chunkCache
				.getScreenLineOfOffset(
				delayedUpdateStart,0),
				textArea.getVisibleLines());
			delayedMultilineUpdate = false;
		}
		else
		{
			textArea.invalidateLineRange(
				delayedUpdateStart,
				delayedUpdateEnd);
		}

		
		int visibleLines = textArea.getVisibleLines();
		if(visibleLines != 0)
		{
			textArea.chunkCache.getLineInfo(
				visibleLines - 1);
		}

		
		

		
		
		
		
		
		

		buffer.getFoldLevel(delayedUpdateEnd);
	} 

	
	private void delayUpdate(int startLine, int endLine)
	{
		textArea.chunkCache.invalidateChunksFromPhys(startLine);

		if(!delayedUpdate)
		{
			delayedUpdateStart = startLine;
			delayedUpdateEnd = endLine;
			delayedUpdate = true;
		}
		else
		{
			delayedUpdateStart = Math.min(
				delayedUpdateStart,
				startLine);
			delayedUpdateEnd = Math.max(
				delayedUpdateEnd,
				endLine);
		}
	} 

	
	
	
	
	
	private void getReadyToBreakFold(int line)
	{
		displayManager.expandFold(line, false);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.BrowserCommandsMenu,7,5,0,16,56,7,6,11,2,0.625,610,1.0,1,0.991678225,0.314285714,0,0,85.57142857,5,1.7143,0,"

package org.gjt.sp.jedit.browser;


import java.awt.event.*;
import java.util.*;
import javax.swing.*;

import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.menu.MenuItemTextComparator;



public class BrowserCommandsMenu extends JPopupMenu
{
	
	public BrowserCommandsMenu(VFSBrowser browser, VFSFile[] files)
	{
		this.browser = browser;

		if(files != null)
		{
			VFS vfs = VFSManager.getVFSForPath(
				files[0].getDeletePath());
			int type = files[0].getType();

			boolean fileOpen = (jEdit.getBuffer(files[0].getPath()) != null);

			
			boolean deletePathOpen = (jEdit.getBuffer(files[0].getDeletePath()) != null);

			boolean delete = !deletePathOpen
				&& (vfs.getCapabilities()
				& VFS.DELETE_CAP) != 0;
			boolean rename = !fileOpen
				&& (vfs.getCapabilities()
				& VFS.RENAME_CAP) != 0;

			for(int i = 1; i < files.length; i++)
			{
				VFSFile file = files[i];

				VFS _vfs = VFSManager.getVFSForPath(file.getDeletePath());
				delete &= (vfs == _vfs) && (_vfs.getCapabilities()
					& VFS.DELETE_CAP) != 0;

				if(type == file.getType())
					;
				else
				{
					
					
					type = -1;
				}

				
				rename = false;

				
				
				if(jEdit.getBuffer(file.getPath()) != null)
					fileOpen = true;
			}

			if(type == VFSFile.DIRECTORY
				|| type == VFSFile.FILESYSTEM)
			{
				if(files.length == 1)
					add(createMenuItem(""browse""));
				if(browser.getMode() == VFSBrowser.BROWSER)
					add(createMenuItem(""browse-window""));
			}
			else if(type == VFSFile.FILE
				&& (browser.getMode() == VFSBrowser.BROWSER
				|| browser.getMode() == VFSBrowser.BROWSER_DIALOG))
			{
				add(createMenuItem(""open""));
				add(GUIUtilities.loadMenu(
					VFSBrowser.getActionContext(),
					""vfs.browser.open-in""));
				add(createMenuItem(""insert""));

				if(fileOpen)
					add(createMenuItem(""close""));
			}
			else if(type != -1)
				add(createMenuItem(""open""));

			if(rename)
				add(createMenuItem(""rename""));

			if(delete)
				add(createMenuItem(""delete""));

			add(createMenuItem(""copy-path""));
			add(createMenuItem(""paste""));
			
			if((files.length == 1) || (browser.getSelectedFiles().length != 0)) 
		   		add(createMenuItem(""properties""));
			
			addSeparator();
		}

		add(createMenuItem(""up""));
		add(createMenuItem(""previous""));
		add(createMenuItem(""next""));
		add(createMenuItem(""reload""));
		add(createMenuItem(""roots""));
		add(createMenuItem(""home""));
		add(createMenuItem(""synchronize""));
		addSeparator();

		if(browser.getMode() == VFSBrowser.BROWSER)
			add(createMenuItem(""new-file""));

		add(createMenuItem(""new-directory""));

		if(browser.getMode() == VFSBrowser.BROWSER)
		{
			addSeparator();
			add(createMenuItem(""search-directory""));
		}

		addSeparator();

		add(createMenuItem(""show-hidden-files""));

		if(browser.getMode() == VFSBrowser.BROWSER
			|| browser.getMode() == VFSBrowser.BROWSER_DIALOG)
		{
			addSeparator();
			add(createEncodingMenu());
		}
		addSeparator();
		add(createPluginMenu(browser));
		update();
	} 

	
	public void update()
	{
		if(encodingMenuItems != null)
		{
			JRadioButtonMenuItem mi = encodingMenuItems.get(
				browser.currentEncoding);
			if(mi != null)
			{
				mi.setSelected(true);
				otherEncoding.setText(jEdit.getProperty(
					""vfs.browser.other-encoding.label""));
			}
			else
			{
				otherEncoding.setSelected(true);
				otherEncoding.setText(jEdit.getProperty(
					""vfs.browser.other-encoding-2.label"",
					new String[] { browser.currentEncoding }));
			}
		}
	} 

	
	private VFSBrowser browser;
	private HashMap<String, JRadioButtonMenuItem> encodingMenuItems;
	private JCheckBoxMenuItem autoDetect;
	private JRadioButtonMenuItem otherEncoding;

	
	private JMenuItem createMenuItem(String name)
	{
		return GUIUtilities.loadMenuItem(VFSBrowser.getActionContext(),
			""vfs.browser."" + name,false);
	} 

	
	private JMenu createEncodingMenu()
	{
		ActionHandler actionHandler = new ActionHandler();

		encodingMenuItems = new HashMap<String, JRadioButtonMenuItem>();
		JMenu encodingMenu = new JMenu(jEdit.getProperty(
			""vfs.browser.commands.encoding.label""));

		JMenu menu = encodingMenu;

		autoDetect = new JCheckBoxMenuItem(
			jEdit.getProperty(
			""vfs.browser.commands.encoding.auto-detect""));
		autoDetect.setSelected(browser.autoDetectEncoding);
		autoDetect.setActionCommand(""auto-detect"");
		autoDetect.addActionListener(actionHandler);
		menu.add(autoDetect);
		menu.addSeparator();

		ButtonGroup grp = new ButtonGroup();

		List<JMenuItem> encodingMenuItemList = new ArrayList<JMenuItem>();
		String[] encodings = MiscUtilities.getEncodings(true);
		for(int i = 0; i < encodings.length; i++)
		{
			String encoding = encodings[i];
			JRadioButtonMenuItem mi = new JRadioButtonMenuItem(encoding);
			mi.setActionCommand(""encoding@"" + encoding);
			mi.addActionListener(actionHandler);
			grp.add(mi);
			encodingMenuItems.put(encoding,mi);
			encodingMenuItemList.add(mi);
		}

		String systemEncoding = System.getProperty(""file.encoding"");
		if(encodingMenuItems.get(systemEncoding) == null)
		{
			JRadioButtonMenuItem mi = new JRadioButtonMenuItem(
				systemEncoding);
			mi.setActionCommand(""encoding@"" + systemEncoding);
			mi.addActionListener(actionHandler);
			grp.add(mi);
			encodingMenuItems.put(systemEncoding,mi);
			encodingMenuItemList.add(mi);
		}

		Collections.sort(encodingMenuItemList,
			new MenuItemTextComparator());

		Iterator iter = encodingMenuItemList.iterator();
		while(iter.hasNext())
		{
			JRadioButtonMenuItem mi = (JRadioButtonMenuItem)
				iter.next();

			if(menu.getMenuComponentCount() > 20)
			{
				JMenu newMenu = new JMenu(
					jEdit.getProperty(""common.more""));
				menu.add(newMenu);
				menu = newMenu;
			}

			menu.add(mi);
		}
		menu.addSeparator();

		otherEncoding = new JRadioButtonMenuItem();
		otherEncoding.setActionCommand(""other-encoding"");
		otherEncoding.addActionListener(actionHandler);
		grp.add(otherEncoding);
		menu.add(otherEncoding);

		return encodingMenu;
	} 

	
	private JMenu createPluginMenu(VFSBrowser browser)
	{
		JMenu pluginMenu = new JMenu(jEdit.getProperty(
			""vfs.browser.plugins.label""));
		return (JMenu)browser.createPluginsMenu(pluginMenu,false);
		
	} 

	
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			String actionCommand = evt.getActionCommand();

			if(actionCommand.equals(""auto-detect""))
			{
				browser.autoDetectEncoding
					= autoDetect.isSelected();
			}
			else if(actionCommand.equals(""other-encoding""))
			{
				String encoding = GUIUtilities.input(browser,
					""encoding-prompt"",null,
					jEdit.getProperty(""buffer.encoding"",
					System.getProperty(""file.encoding"")));
				if(encoding == null)
					return;
				browser.currentEncoding = encoding;
			}
			else if(actionCommand.startsWith(""encoding@""))
			{
				browser.currentEncoding = actionCommand.substring(9);
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.Autosave,4,1,0,4,19,4,1,4,3,0.666666667,82,1.0,0,0.0,0.333333333,0,0,19.25,7,3.25,0,"

package org.gjt.sp.jedit;


import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import org.gjt.sp.util.Log;



class Autosave implements ActionListener
{
	
	public static void setInterval(int interval)
	{
		if(interval == 0)
		{
			if(timer != null)
			{
				timer.stop();
				timer = null;
			}

			return;
		}

		interval *= 1000;

		if(timer == null)
		{
			timer = new Timer(interval,new Autosave());
			timer.start();
		}
		else
			timer.setDelay(interval);
	} 

	
	public static void stop()
	{
		if(timer != null)
			timer.stop();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		if (jEdit.getIntegerProperty(""autosave"",0) == 0)
				return;
		
		

		
		if(jEdit.getViewCount() != 0
			&& PerspectiveManager.isPerspectiveDirty())
		{
			PerspectiveManager.setPerspectiveDirty(false);
			PerspectiveManager.savePerspective(true);
		}
		boolean autosaveUntitled = jEdit.getBooleanProperty(""autosaveUntitled"");
		Buffer[] bufferArray = jEdit.getBuffers();
		for(int i = 0; i < bufferArray.length; i++)
		{
			Buffer buffer = bufferArray[i];
			if (autosaveUntitled || !buffer.isUntitled())
				buffer.autosave();
		}

		
		Log.flushStream();
	} 

	
	private static Timer timer;

	private Autosave() {}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.ScrollLayout,7,1,0,1,19,1,1,0,6,0.75,437,0.5,0,0.0,0.5,0,0,60.0,6,3.0,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.*;
import javax.swing.border.Border;
import javax.swing.JComponent;


public class ScrollLayout implements LayoutManager
{
	public static final String CENTER = ""center"";
	public static final String RIGHT = ""right"";
	public static final String LEFT = ""left"";
	public static final String BOTTOM = ""bottom"";
	public static final String TOP = ""top"";

	
	public void addLayoutComponent(String name, Component comp)
	{
		if(name.equals(CENTER))
			center = comp;
		else if(name.equals(RIGHT))
			right = comp;
		else if(name.equals(LEFT))
			left = comp;
		else if(name.equals(BOTTOM))
			bottom = comp;
		else if(name.equals(TOP))
			top = comp;
	} 

	
	public void removeLayoutComponent(Component comp)
	{
		if(center == comp)
			center = null;
		else if(right == comp)
			right = null;
		else if(left == comp)
			left = null;
		else if(bottom == comp)
			bottom = null;
		else if(top == comp)
			top = null;
	} 

	
	public Dimension preferredLayoutSize(Container parent)
	{
		Dimension dim = new Dimension();
		Insets insets = getInsets(parent);

		dim.width = insets.left + insets.right;
		dim.height = insets.top + insets.bottom;

		Dimension leftPref = left.getPreferredSize();
		dim.width += leftPref.width;
		Dimension centerPref = center.getPreferredSize();
		dim.width += centerPref.width;
		dim.height += centerPref.height;
		Dimension rightPref = right.getPreferredSize();
		dim.width += rightPref.width;
		Dimension bottomPref = bottom.getPreferredSize();
		dim.height += bottomPref.height;
		if(top != null)
		{
			Dimension topPref = top.getPreferredSize();
			dim.height += topPref.height;
		}

		return dim;
	} 

	
	public Dimension minimumLayoutSize(Container parent)
	{
		Dimension dim = new Dimension();
		Insets insets = getInsets(parent);

		dim.width = insets.left + insets.right;
		dim.height = insets.top + insets.bottom;

		Dimension leftPref = left.getMinimumSize();
		dim.width += leftPref.width;
		Dimension centerPref = center.getMinimumSize();
		dim.width += centerPref.width; 
		dim.height += centerPref.height;
		Dimension rightPref = right.getMinimumSize();
		dim.width += rightPref.width;
		Dimension bottomPref = bottom.getMinimumSize();
		dim.height += bottomPref.height;
		if(top != null)
		{
			Dimension topPref = top.getMinimumSize();
			dim.height += topPref.height;
		}
		
		return dim;
	} 

	
	public void layoutContainer(Container parent)
	{
		Dimension size = parent.getSize();
		Insets insets = getInsets(parent);

		int itop = insets.top;
		int ileft = insets.left;
		int ibottom = insets.bottom;
		int iright = insets.right;

		int rightWidth = right.getPreferredSize().width;
		int leftWidth = left.getPreferredSize().width;
		int topHeight;
		if(top != null)
		{
			topHeight = top.getPreferredSize().height;
		}
		else
		{
			topHeight = 0;
		}
		int bottomHeight = bottom.getPreferredSize().height;
		int centerWidth = Math.max(0,size.width - leftWidth
			- rightWidth - ileft - iright);
		int centerHeight = Math.max(0,size.height - topHeight
			- bottomHeight - itop - ibottom);
			
		left.setBounds(
			ileft,
			itop+topHeight,
			leftWidth,
			centerHeight);

		center.setBounds(
			ileft + leftWidth,
			itop+topHeight,
			centerWidth,
			centerHeight);

		right.setBounds(
			ileft + leftWidth + centerWidth,
			itop+topHeight,
			rightWidth,
			centerHeight);

		bottom.setBounds(
			ileft,
			itop + topHeight + centerHeight,
			Math.max(0,size.width - bottom.getHeight()
				- ileft - iright),
			bottomHeight);
		if(top != null)
		{
			top.setBounds(
				ileft,
				itop,
				leftWidth+centerWidth+rightWidth,
				topHeight);
		}
	} 

	
	private Component center;
	private Component left;
	private Component right;
	private Component bottom;
	private Component top;

	
	private Insets getInsets(Component parent)
	{
		Border border = ((JComponent)parent).getBorder();
		if(border == null)
			return new Insets(0,0,0,0);
		else
			return border.getBorderInsets(parent);
	} 
	
	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.PrintOptionPane,3,6,0,3,23,1,0,3,1,0.5,229,1.0,1,0.997019374,1.0,1,3,72.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;


public class PrintOptionPane extends AbstractOptionPane
{
	
	public PrintOptionPane()
	{
		super(""print"");
	} 

	
	protected void _init()
	{
		
		font = new FontSelector(jEdit.getFontProperty(""print.font""));
		addComponent(jEdit.getProperty(""options.print.font""),font);

		
		printHeader = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".header""));
		printHeader.setSelected(jEdit.getBooleanProperty(""print.header""));
		addComponent(printHeader);

		
		printFooter = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".footer""));
		printFooter.setSelected(jEdit.getBooleanProperty(""print.footer""));
		addComponent(printFooter);

		
		printLineNumbers = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".lineNumbers""));
		printLineNumbers.setSelected(jEdit.getBooleanProperty(""print.lineNumbers""));
		addComponent(printLineNumbers);

		
		color = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".color""));
		color.setSelected(jEdit.getBooleanProperty(""print.color""));
		addComponent(color);

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(jEdit.getProperty(""print.tabSize""));
		addComponent(jEdit.getProperty(""options.print.tabSize""),tabSize);


		
		printFolds = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".folds""));
		printFolds.setSelected(jEdit.getBooleanProperty(""print.folds"",true));
		addComponent(printFolds);
		
		addSeparator(""options.print.workarounds"");

		
		glyphVector = new JCheckBox(jEdit.getProperty(
			""options.print.glyphVector""));
		glyphVector.setSelected(jEdit.getBooleanProperty(""print.glyphVector""));
		addComponent(glyphVector);

		
		force13 = new JCheckBox(jEdit.getProperty(
			""options.print.force13""));
		force13.setSelected(jEdit.getBooleanProperty(""print.force13""));
		addComponent(force13);
	} 

	
	protected void _save()
	{
		jEdit.setFontProperty(""print.font"",font.getFont());
		jEdit.setBooleanProperty(""print.header"",printHeader.isSelected());
		jEdit.setBooleanProperty(""print.footer"",printFooter.isSelected());
		jEdit.setBooleanProperty(""print.lineNumbers"",printLineNumbers.isSelected());
		jEdit.setBooleanProperty(""print.color"",color.isSelected());
		jEdit.setProperty(""print.tabSize"",(String)tabSize.getSelectedItem());
		jEdit.setBooleanProperty(""print.glyphVector"",glyphVector.isSelected());
		jEdit.setBooleanProperty(""print.force13"",force13.isSelected());
		jEdit.setBooleanProperty(""print.folds"",printFolds.isSelected());
	} 

	
	private FontSelector font;
	private JCheckBox printHeader;
	private JCheckBox printFooter;
	private JCheckBox printLineNumbers;
	private JCheckBox printFolds;
	private JCheckBox color;
	private JComboBox tabSize;
	private JCheckBox glyphVector;
	private JCheckBox force13;
	
}
"
jEdit,4.3,org.gjt.sp.util.WorkThread,14,2,0,10,33,29,6,5,12,0.721153846,400,1.0,1,0.824324324,0.224489796,0,0,27.0,3,1.2143,0,"

package org.gjt.sp.util;


public class WorkThread extends Thread implements ThreadAbortMonitor
{
	public WorkThread(WorkThreadPool pool, ThreadGroup group, String name)
	{
		super(group, name);
		
		
		setPriority(Thread.MIN_PRIORITY);

		this.pool = pool;
	}

	
	public void setAbortable(boolean abortable)
	{
		synchronized(abortLock)
		{
			this.abortable = abortable;
			if(aborted)
				stop(new Abort());
		}
	}

	
	public boolean isRequestRunning()
	{
		return requestRunning;
	}


	public boolean isAborted()
	{
		synchronized (abortLock)
		{
			return aborted;
		}
	}

	
	public String getStatus()
	{
		return status;
	}

	
	public void setStatus(String status)
	{
		this.status = status;
		pool.fireProgressChanged(this);
	}

	
	public int getProgressValue()
	{
		return progressValue;
	}

	
	public void setProgressValue(int progressValue)
	{
		this.progressValue = progressValue;
		pool.fireProgressChanged(this);
	}

	
	public int getProgressMaximum()
	{
		return progressMaximum;
	}

	
	public void setProgressMaximum(int progressMaximum)
	{
		this.progressMaximum = progressMaximum;
		pool.fireProgressChanged(this);
	}

	
	public void abortCurrentRequest()
	{
		synchronized(abortLock)
		{
			if(abortable && !aborted)
				stop(new Abort());
			aborted = true;
		}
	}

	public void run()
	{
		Log.log(Log.DEBUG,this,""Work request thread starting ["" + getName() + ""]"");

		for(;;)
		{
			doRequests();
		}
	}

	
	private WorkThreadPool pool;
	private final Object abortLock = new Object();
	private boolean requestRunning;
	private boolean abortable;
	private boolean aborted;
	private String status;
	private int progressValue;
	private int progressMaximum;

	private void doRequests()
	{
		WorkThreadPool.Request request;
		for(;;)
		{
			request = pool.getNextRequest();
			if(request == null)
				break;
			else
			{
				requestRunning = true;
				pool.fireStatusChanged(this);
				doRequest(request);
				requestRunning = false;
			}
		}

		pool.fireStatusChanged(this);

		synchronized(pool.waitForAllLock)
		{
			
			pool.waitForAllLock.notifyAll();
		}

		synchronized(pool.lock)
		{
			
			try
			{
				pool.lock.wait();
			}
			catch(InterruptedException ie)
			{
				Log.log(Log.ERROR,this,ie);
			}
		}
	}

	private void doRequest(WorkThreadPool.Request request)
	{
		Log.log(Log.DEBUG,WorkThread.class,""Running in work thread: "" + request);

		try
		{
			request.run.run();
		}
		catch(Abort a)
		{
			Log.log(Log.ERROR,WorkThread.class,""Unhandled abort"", a);
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception in work thread: "", t);
		}
		finally
		{
			synchronized(abortLock)
			{
				aborted = abortable = false;
			}
			status = null;
			progressValue = progressMaximum = 0;
			pool.requestDone();
			pool.fireStatusChanged(this);
		}
	}

	public static class Abort extends Error
	{
		public Abort()
		{
			super(""Work request aborted"");
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.RangeMap,17,1,0,4,31,0,2,2,0,0.25,970,1.0,0,0.0,0.441176471,0,0,55.88235294,13,4.3529,0,"

package org.gjt.sp.jedit.textarea;

import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;


class RangeMap
{
	
	RangeMap()
	{
		fvm = new int[2];
		lastfvmget = -1;
	} 

	
	RangeMap(RangeMap copy)
	{
		this.fvm = copy.fvm.clone();
		this.fvmcount = copy.fvmcount;
	} 

	
	void reset(int lines)
	{
		lastfvmget = -1;
		fvmcount = 2;
		fvm[0] = 0;
		fvm[1] = lines;
	} 

	
	int first()
	{
		return fvm[0];
	} 

	
	int last()
	{
		return fvm[fvmcount - 1] - 1;
	} 

	
	int lookup(int index)
	{
		return fvm[index];
	} 

	
	
	int search(int line)
	{
		if(line < fvm[0])
			return -1;
		if(line >= fvm[fvmcount - 1])
			return fvmcount - 1;

		if(lastfvmget != -1)
		{
			if(line >= fvm[lastfvmget])
			{
				if(lastfvmget == fvmcount - 1
					|| line < fvm[lastfvmget + 1])
				{
					return lastfvmget;
				}
			}
		}

		int start = 0;
		int end = fvmcount - 1;

loop:		for(;;)
		{
			switch(end - start)
			{
			case 0:
				lastfvmget = start;
				break loop;
			case 1:
				int value = fvm[end];
				if(value <= line)
					lastfvmget = end;
				else
					lastfvmget = start;
				break loop;
			default:
				int pivot = (end + start) / 2;
				value = fvm[pivot];
				if(value == line)
				{
					lastfvmget = pivot;
					break loop;
				}
				else if(value < line)
					start = pivot;
				else
					end = pivot - 1;
				break;
			}
		}

		return lastfvmget;
	} 

	
	
	void put(int start, int end, int[] put)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			StringBuilder buf = new StringBuilder(50);
			buf.append(""fvmput("").append(start).append(',');
			buf.append(end).append(',');
			buf.append('{');
			if(put != null)
			{
				for(int i = 0; i < put.length; i++)
				{
					if(i != 0)
						buf.append(',');
					buf.append(put[i]);
				}
			}
			buf.append(""})"");
			Log.log(Log.DEBUG,this,buf.toString());
		}
		int putl = put == null ? 0 : put.length;

		int delta = putl - (end - start);
		if(fvmcount + delta > fvm.length)
		{
			int[] newfvm = new int[(fvm.length << 1) + 1];
			System.arraycopy(fvm,0,newfvm,0,fvmcount);
			fvm = newfvm;
		}

		if(delta != 0)
		{
			System.arraycopy(fvm,end,fvm,start + putl,
				fvmcount - end);
		}

		if(putl != 0)
		{
			System.arraycopy(put,0,fvm,start,put.length);
		}

		fvmcount += delta;

		dump();

		if(fvmcount == 0)
			throw new InternalError();
	} 

	
	
	void put2(int starti, int endi, int start, int end)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			Log.log(Log.DEBUG,this,""*fvmput2("" + starti + "",""
				+ endi + "","" + start + "","" + end + "")"");
		}
		if(starti != -1 && fvm[starti] == start)
		{
			if(endi <= fvmcount - 2 && fvm[endi + 1]
				== end + 1)
			{
				put(starti,endi + 2,null);
			}
			else
			{
				put(starti,endi + 1,
					new int[] { end + 1 });
			}
		}
		else
		{
			if(endi != fvmcount - 1 && fvm[endi + 1]
				== end + 1)
			{
				put(starti + 1,endi + 2,
					new int[] { start });
			}
			else
			{
				put(starti + 1,endi + 1,
					new int[] { start,
					end + 1 });
			}
		}
	} 

	
	int next(int line)
	{
		int index = search(line);
		
		if(index % 2 != 0)
		{
			
			if(fvmcount == index + 1)
				return - 1;
			
			else
				return fvm[index + 1];
		}
		
		else if(line == fvm[index + 1] - 1)
		{
			
			if(fvmcount == index + 2)
				return -1;
			
			else
				return fvm[index + 2];
		}
		
		else
			return line + 1;
	} 

	
	int prev(int line)
	{
		int index = search(line);
		
		if(index == -1)
			return -1;
		
		else if(index % 2 == 1)
		{
			
			return fvm[index] - 1;
		}
		
		else if(line == fvm[index])
		{
			
			if(index == 0)
				return -1;
			
			else
				return fvm[index - 1] - 1;
		}
		
		else
			return line - 1;
	} 

	
	void show(int start, int end)
	{
		int starti = search(start);
		int endi = search(end);

		if(starti % 2 == 0)
		{
			if(endi % 2 == 0)
				put(starti + 1,endi + 1,null);
			else
			{
				if(endi != fvmcount - 1
					&& fvm[endi + 1] == end + 1)
					put(starti + 1,endi + 2,null);
				else
				{
					put(starti + 1,endi,null);
					fvm[starti + 1] = end + 1;
				}
			}
		}
		else
		{
			if(endi % 2 == 0)
			{
				if(starti != -1 && fvm[starti] == start)
					put(starti,endi + 1,null);
				else
				{
					put(starti + 1,endi,null);
					fvm[starti + 1] = start;
				}
			}
			else
				put2(starti,endi,start,end);
		}

		lastfvmget = -1;
	} 
	
	
	void hide(int start, int end)
	{
		int starti = search(start);
		int endi = search(end);

		if(starti % 2 == 0)
		{
			if(endi % 2 == 0)
				put2(starti,endi,start,end);
			else
			{
				if(start == fvm[0])
					put(starti,endi + 1,null);
				else
				{
					put(starti + 1,endi,null);
					fvm[starti + 1] = start;
				}
			}
		}
		else
		{
			if(endi % 2 == 0)
			{
				if(end + 1 == fvm[fvmcount - 1])
					put(starti + 1,endi + 2,null);
				else
				{
					put(starti + 1,endi,null);
					fvm[starti + 1] = end + 1;
				}
			}
			else
				put(starti + 1,endi + 1,null);
		}

		lastfvmget = -1;
	} 

	
	int count()
	{
		return fvmcount;
	} 

	
	void dump()
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			StringBuilder buf = new StringBuilder(""{"");
			for(int i = 0; i < fvmcount; i++)
			{
				if(i != 0)
					buf.append(',');
				buf.append(fvm[i]);
			}
			buf.append('}');
			Log.log(Log.DEBUG,this,""fvm = "" + buf);
		}
	} 

	
	void contentInserted(int startLine, int numLines)
	{
		if(numLines != 0)
		{
			int index = search(startLine);
			int start = index + 1;

			for(int i = start; i < fvmcount; i++)
				fvm[i] += numLines;

			lastfvmget = -1;
			dump();
		}
	} 

	
	
	boolean preContentRemoved(int startLine, int numLines)
	{
		boolean returnValue = false;

		int endLine = startLine + numLines;

		
		int starti = search(startLine);
		int endi = search(endLine);

		
		if(Math.abs(starti % 2) == Math.abs(endi % 2))
		{
			if(endi - starti == fvmcount)
			{
				
				
				
				returnValue = true;
				starti = 1;
			}
			else
			{
				put(starti + 1,endi + 1,null);
				starti++;
			}
		}
		
		else if(starti != -1 && fvm[starti] == startLine)
		{
			if(endi - starti == fvmcount - 1)
			{
				
				
				
				returnValue = true;
				starti = 1;
			}
			else
				put(starti,endi + 1,null);
		}
		
		else
		{
			put(starti + 1,endi,null);
			fvm[starti + 1] = startLine;
			starti += 2;
		}

		
		for(int i = starti; i < fvmcount; i++)
			fvm[i] -= numLines;

		lastfvmget = -1;
		dump();

		return returnValue;
	} 

	
	private int[] fvm;
	private int fvmcount;
	private int lastfvmget;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bufferio.BufferInsertRequest,2,3,0,12,21,1,2,12,2,2.0,336,0.0,0,0.933333333,0.583333333,1,1,167.0,3,1.5,0,"

package org.gjt.sp.jedit.bufferio;


import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class BufferInsertRequest extends BufferIORequest
{
	
	
	public BufferInsertRequest(View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		super(view,buffer,session,vfs,path);
	} 

	
	public void run()
	{
		InputStream in = null;
		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.load"",args));
			setAbortable(true);

			path = vfs._canonPath(session,path,view);

			VFSFile entry = vfs._getFile(
				session,path,view);
			long length;
			if(entry != null)
				length = entry.getLength();
			else
				length = 0L;

			in = vfs._createInputStream(session,path,false,view);
			if(in == null)
				return;

			final SegmentBuffer seg = read(
				autodetect(in),length,true);

			
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					view.getTextArea().setSelectedText(
						seg.toString());
				}
			});
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			String[] pp = { e.toString() };
			VFSManager.error(view,path,""ioerror.read-error"",pp);

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		catch(WorkThread.Abort a)
		{
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			IOUtilities.closeQuietly(in);
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.indent.OpenBracketIndentRule,4,2,0,8,12,6,1,7,2,1.0,80,1.0,0,0.571428571,0.5,0,0,18.75,4,2.5,0,"

package org.gjt.sp.jedit.indent;

import java.util.List;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.TextUtilities;


public class OpenBracketIndentRule extends BracketIndentRule
{
	
	public OpenBracketIndentRule(char openBracket, boolean aligned)
	{
		super(openBracket,
			TextUtilities.getComplementaryBracket(openBracket,null));
		this.aligned = aligned;
	} 

	
	public void apply(JEditBuffer buffer, int thisLineIndex,
		int prevLineIndex, int prevPrevLineIndex,
		List<IndentAction> indentActions)
	{
		int prevOpenBracketCount = getOpenBracketCount(buffer,prevLineIndex);
		if(prevOpenBracketCount != 0)
		{
			handleCollapse(indentActions, true);
			boolean multiple = buffer.getBooleanProperty(
				""multipleBracketIndent"");
			IndentAction increase = new IndentAction.Increase(
				multiple ? prevOpenBracketCount : 1);
			indentActions.add(increase);
		}
		else if(getOpenBracketCount(buffer,thisLineIndex) != 0)
		{
			handleCollapse(indentActions, false);
		}
	} 

	
	private int getOpenBracketCount(JEditBuffer buffer, int line)
	{
		if(line == -1)
			return 0;
		else
			return getBrackets(buffer, line).openCount;
	} 

	
	private static void handleCollapse(List<IndentAction> indentActions,
					   boolean delPrevPrevCollapse)
	{
		if (indentActions.contains(IndentAction.PrevCollapse))
		{
			indentActions.clear();
			return;
		}

		if (delPrevPrevCollapse && indentActions.contains(IndentAction.PrevPrevCollapse))
		{
			indentActions.clear();
			return;
		}
	} 

	private boolean aligned;
}
"
jEdit,4.3,org.gjt.sp.jedit.options.BufferOptionPane,10,6,0,12,57,15,2,11,1,0.829059829,687,1.0,2,0.986725664,0.5,3,5,66.4,9,2.4,0,"

package org.gjt.sp.jedit.options;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Arrays;

import javax.swing.JCheckBox;
import javax.swing.JComboBox;

import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.Mode;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.StandardUtilities;


public class BufferOptionPane extends AbstractOptionPane
{
	private JComboBox encoding;
	private JComboBox lineSeparator;
	private JCheckBox gzipped;
	private Mode[] modes;
	private JComboBox mode;
	private JComboBox folding;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JComboBox checkModStatus;
	private JCheckBox noTabs;
	private Buffer buffer;


	public BufferOptionPane()
	{
		super(""Buffer Options"");
		init();
	}

	
	@Override
	protected void _init()
	{
		buffer = jEdit.getActiveView().getBuffer();
		String filename = buffer.getName();
		setName(""Buffer: "" + filename);
		addComponent(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""buffer-options.caption"")));

		addSeparator(""buffer-options.loading-saving"");

		
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = buffer.getStringProperty(JEditBuffer.LINESEP);
		if(lineSep == null)
			lineSep = System.getProperty(""line.separator"");
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		addComponent(jEdit.getProperty(""buffer-options.lineSeparator""),
			lineSeparator);
		

		
		String[] encodings = MiscUtilities.getEncodings(true);
		Arrays.sort(encodings,new StandardUtilities.StringCompare<String>(true));
		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(buffer.getStringProperty(JEditBuffer.ENCODING));
		addComponent(jEdit.getProperty(""buffer-options.encoding""),
			encoding);
		

		
		gzipped = new JCheckBox(jEdit.getProperty(
			""buffer-options.gzipped""));
		gzipped.setSelected(buffer.getBooleanProperty(Buffer.GZIPPED));
		addComponent(gzipped);
		

		
		
		String[] modCheckOptions = {
			jEdit.getProperty(""options.general.checkModStatus.nothing""),
			jEdit.getProperty(""options.general.checkModStatus.prompt""),
			jEdit.getProperty(""options.general.checkModStatus.reload""),
			jEdit.getProperty(""options.general.checkModStatus.silentReload"")
		};
		checkModStatus = new JComboBox(modCheckOptions);
		if(buffer.getAutoReload())
		{
			if(buffer.getAutoReloadDialog())
				
				checkModStatus.setSelectedIndex(2);
			else	
				checkModStatus.setSelectedIndex(3);
		}
		else
		{
			if(buffer.getAutoReloadDialog())
				
				checkModStatus.setSelectedIndex(1);
			else	
				checkModStatus.setSelectedIndex(0);
		}
		addComponent(jEdit.getProperty(""options.general.checkModStatus""),
			checkModStatus);

		

		addSeparator(""buffer-options.editing"");

		
		modes = jEdit.getModes();
		Arrays.sort(modes,new StandardUtilities.StringCompare<Mode>(true));
		mode = new JComboBox(modes);
		mode.setSelectedItem(buffer.getMode());
		ActionHandler actionListener = new ActionHandler();
		mode.addActionListener(actionListener);
		addComponent(jEdit.getProperty(""buffer-options.mode""),mode);
		

		
		String[] foldModes = FoldHandler.getFoldModes();

		folding = new JComboBox(foldModes);
		folding.setSelectedItem(buffer.getStringProperty(""folding""));
		addComponent(jEdit.getProperty(""options.editing.folding""),
			folding);
		

		
		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};

		wrap = new JComboBox(wrapModes);
		wrap.setSelectedItem(buffer.getStringProperty(""wrap""));
		addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap);
		

		
		String[] lineLengths = { ""0"", ""72"", ""76"", ""80"" };

		maxLineLen = new JComboBox(lineLengths);
		maxLineLen.setEditable(true);
		maxLineLen.setSelectedItem(buffer.getStringProperty(""maxLineLen""));
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen);
		

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(buffer.getStringProperty(""tabSize""));
		addComponent(jEdit.getProperty(""options.editing.tabSize""),tabSize);
		

		
		indentSize = new JComboBox(tabSizes);
		indentSize.setEditable(true);
		indentSize.setSelectedItem(buffer.getStringProperty(""indentSize""));
		addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize);
		

		
		noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs""));
		noTabs.setSelected(buffer.getBooleanProperty(""noTabs""));
		addComponent(noTabs);
		
	} 

	
	@Override
	protected void _save()
	{
		int index = lineSeparator.getSelectedIndex();
		String lineSep;
		if(index == 0)
			lineSep = ""\n"";
		else if(index == 1)
			lineSep = ""\r\n"";
		else if(index == 2)
			lineSep = ""\r"";
		else
			throw new InternalError();

		String oldLineSep = buffer.getStringProperty(JEditBuffer.LINESEP);
		if(oldLineSep == null)
			oldLineSep = System.getProperty(""line.separator"");
		if(!oldLineSep.equals(lineSep))
		{
			buffer.setStringProperty(JEditBuffer.LINESEP, lineSep);
			buffer.setDirty(true);
		}

		String encoding = (String)this.encoding.getSelectedItem();
		String oldEncoding = buffer.getStringProperty(JEditBuffer.ENCODING);
		if(!oldEncoding.equals(encoding))
		{
			buffer.setStringProperty(JEditBuffer.ENCODING,encoding);
			buffer.setDirty(true);
			
			
			buffer.setBooleanProperty(Buffer.ENCODING_AUTODETECT,false);
		}

		boolean gzippedValue = gzipped.isSelected();
		boolean oldGzipped = buffer.getBooleanProperty(
			Buffer.GZIPPED);
		if(gzippedValue != oldGzipped)
		{
			buffer.setBooleanProperty(Buffer.GZIPPED,gzippedValue);
			buffer.setDirty(true);
		}

		buffer.setStringProperty(""folding"",(String)folding.getSelectedItem());

		buffer.setStringProperty(""wrap"",(String)wrap.getSelectedItem());

		try
		{
			buffer.setProperty(""maxLineLen"",new Integer(
				maxLineLen.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		try
		{
			buffer.setProperty(""tabSize"",new Integer(
				tabSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		try
		{
			buffer.setProperty(""indentSize"",new Integer(
				indentSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		buffer.setBooleanProperty(""noTabs"",noTabs.isSelected());

		index = mode.getSelectedIndex();
		buffer.setMode(modes[index]);
		switch(checkModStatus.getSelectedIndex())
		{
		case 0:
			buffer.setAutoReloadDialog(false);
			buffer.setAutoReload(false);
			break;
		case 1:
			buffer.setAutoReloadDialog(true);
			buffer.setAutoReload(false);
			break;
		case 2:
			buffer.setAutoReloadDialog(true);
			buffer.setAutoReload(true);
			break;
		case 3:
			buffer.setAutoReloadDialog(false);
			buffer.setAutoReload(true);
			break;
		}
	} 

	
	private class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == mode)
			{
				Mode _mode = (Mode)mode.getSelectedItem();
				folding.setSelectedItem(_mode.getProperty(
					""folding""));
				wrap.setSelectedItem(_mode.getProperty(
					""wrap""));
				maxLineLen.setSelectedItem(_mode.getProperty(
					""maxLineLen""));
				tabSize.setSelectedItem(_mode.getProperty(
					""tabSize""));
				indentSize.setSelectedItem(_mode.getProperty(
					""indentSize""));
				noTabs.setSelected(_mode.getBooleanProperty(
					""noTabs""));
			}
		} 
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.Macros,27,1,0,19,96,295,6,16,23,0.884615385,745,1.0,2,0.0,0.129370629,0,0,26.33333333,10,2.2222,0,"

package org.gjt.sp.jedit;



import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.msg.DynamicMenuChanged;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;

import javax.swing.*;
import java.awt.*;
import java.io.File;
import java.io.Reader;
import java.util.*;
import java.util.List;
import java.util.regex.Pattern;



public class Macros
{
	
	
	public static void showRunScriptDialog(View view)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,true);
		if(paths != null)
		{
			Buffer buffer = view.getBuffer();
			try
			{
				buffer.beginCompoundEdit();

file_loop:			for(int i = 0; i < paths.length; i++)
					runScript(view,paths[i],false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	
	public static void runScript(View view, String path, boolean ignoreUnknown)
	{
		Handler handler = getHandlerForPathName(path);
		if(handler != null)
		{
			try
			{
				Macro newMacro = handler.createMacro(
					MiscUtilities.getFileName(path), path);
				newMacro.invoke(view);
			}
			catch (Exception e)
			{
				Log.log(Log.ERROR, Macros.class, e);
				return;
			}
			return;
		}

		
		
		
		if(ignoreUnknown)
		{
			Log.log(Log.NOTICE,Macros.class,path +
				"": Cannot find a suitable macro handler"");
		}
		else
		{
			Log.log(Log.ERROR,Macros.class,path +
				"": Cannot find a suitable macro handler, ""
				+ ""assuming BeanShell"");
			getHandler(""beanshell"").createMacro(
				path,path).invoke(view);
		}
	} 

	
	
	public static void message(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();

		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static void error(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();

		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.ERROR_MESSAGE);
	} 

	
	
	public static String input(Component comp, String prompt)
	{
		GUIUtilities.hideSplashScreen();

		return input(comp,prompt,null);
	} 

	
	
	public static String input(Component comp, String prompt, String defaultValue)
	{
		GUIUtilities.hideSplashScreen();

		return (String)JOptionPane.showInputDialog(comp,prompt,
			jEdit.getProperty(""macro-input.title""),
			JOptionPane.QUESTION_MESSAGE,null,null,defaultValue);
	} 

	
	
	public static int confirm(Component comp, String prompt, int buttons)
	{
		GUIUtilities.hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,
			JOptionPane.QUESTION_MESSAGE);
	} 

	
	
	public static int confirm(Component comp, String prompt, int buttons, int type)
	{
		GUIUtilities.hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,type);
	} 

	
	
	public static void loadMacros()
	{
		jEdit.removeActionSet(macroActionSet);
		macroActionSet.removeAllActions();
		macroHierarchy.removeAllElements();
		macroHash.clear();
		
		
		
		String settings = jEdit.getSettingsDirectory();

		if(settings != null)
		{
			userMacroPath = MiscUtilities.constructPath(
				settings,""macros"");
			loadMacros(macroHierarchy,"""",new File(userMacroPath));
		}

		if(jEdit.getJEditHome() != null)
		{
			systemMacroPath = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""macros"");
			loadMacros(macroHierarchy,"""",new File(systemMacroPath));
		}
		jEdit.addActionSet(macroActionSet);
		EditBus.send(new DynamicMenuChanged(""macros""));
	} 

	
	
	public static void registerHandler(Handler handler)
	{
		if (getHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, Macros.class, ""Cannot register more than one macro handler with the same name"");
			return;
		}

		Log.log(Log.DEBUG,Macros.class,""Registered "" + handler.getName()
			+ "" macro handler"");
		macroHandlers.add(handler);
	} 

	
	
	public static Handler[] getHandlers()
	{
		Handler[] handlers = new Handler[macroHandlers.size()];
		return macroHandlers.toArray(handlers);
	} 

	
	
	public static Handler getHandlerForPathName(String pathName)
	{
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			Handler handler = macroHandlers.get(i);
			if (handler.accept(pathName))
				return handler;
		}

		return null;
	} 

	
	
	public static Handler getHandler(String name)
	{
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			Handler handler = macroHandlers.get(i);
			if (handler.getName().equals(name))
				return handler;
		}

		return null;
	}
	

	
	
	public static Vector getMacroHierarchy()
	{
		return macroHierarchy;
	} 

	
	
	public static ActionSet getMacroActionSet()
	{
		return macroActionSet;
	} 

	
	
	public static Macro getMacro(String macro)
	{
		return macroHash.get(macro);
	} 

	
	
	public static Macro getLastMacro()
	{
		return lastMacro;
	} 

	
	
	public static void setLastMacro(Macro macro)
	{
		lastMacro = macro;
	} 

	
	
	public static class Macro extends EditAction
	{
		
		public Macro(Handler handler, String name, String label, String path)
		{
			super(name);
			this.handler = handler;
			this.label = label;
			this.path = path;
		} 

		
		public Handler getHandler()
		{
			return handler;
		}
		

		
		public String getPath()
		{
			return path;
		} 

		
		@Override
		public void invoke(View view)
		{
			setLastMacro(this);

			if(view == null)
				handler.runMacro(null,this);
			else
			{
				try
				{
					view.getBuffer().beginCompoundEdit();
					handler.runMacro(view,this);
				}
				finally
				{
					view.getBuffer().endCompoundEdit();
				}
			}
		} 

		
		@Override
		public String getCode()
		{
			return ""Macros.getMacro(\"""" + getName() + ""\"").invoke(view);"";
		} 

		
		public static String macroNameToLabel(String macroName)
		{
			int index = macroName.lastIndexOf('/');
			return macroName.substring(index + 1).replace('_', ' ');
		}
		

		
		private Handler handler;
		private String path;
		String label;
		
	} 

	
	
	public static void recordTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}

		Buffer buffer = jEdit.openFile((View)null,settings + File.separator
			+ ""macros"",""Temporary_Macro.bsh"",true,null);

		if(buffer == null)
			return;

		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.temp.header""));

		recordMacro(view,buffer,true);
	} 

	
	
	public static void recordMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}

		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}

		String name = GUIUtilities.input(view,""record"",null);
		if(name == null)
			return;

		name = name.replace(' ','_');

		Buffer buffer = jEdit.openFile((View) null,null,
			MiscUtilities.constructPath(settings,""macros"",
			name + "".bsh""),true,null);

		if(buffer == null)
			return;

		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.header""));

		recordMacro(view,buffer,false);
	} 

	
	
	public static void stopRecording(View view)
	{
		Recorder recorder = view.getMacroRecorder();

		if(recorder == null)
			GUIUtilities.error(view,""macro-not-recording"",null);
		else
		{
			view.setMacroRecorder(null);
			if(!recorder.temporary)
				view.setBuffer(recorder.buffer);
			recorder.dispose();
		}
	} 

	
	
	public static void runTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",null);
			return;
		}

		String path = MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(),""macros"",
			""Temporary_Macro.bsh"");

		if(jEdit.getBuffer(path) == null)
		{
			GUIUtilities.error(view,""no-temp-macro"",null);
			return;
		}

		Handler handler = getHandler(""beanshell"");
		Macro temp = handler.createMacro(path,path);

		Buffer buffer = view.getBuffer();

		try
		{
			buffer.beginCompoundEdit();
			temp.invoke(view);
		}
		finally
		{
			
			if(buffer.insideCompoundEdit())
				buffer.endCompoundEdit();
		}
	} 

	

	
	private static String systemMacroPath;
	private static String userMacroPath;

	private static List<Handler> macroHandlers;

	private static ActionSet macroActionSet;
	private static Vector macroHierarchy;
	private static Map<String, Macro> macroHash;

	private static Macro lastMacro;
	

	
	static
	{
		macroHandlers = new ArrayList<Handler>();
		registerHandler(new BeanShellHandler());
		macroActionSet = new ActionSet(jEdit.getProperty(""action-set.macros""));
		jEdit.addActionSet(macroActionSet);
		macroHierarchy = new Vector();
		macroHash = new Hashtable<String, Macro>();
	} 

	
	private static void loadMacros(List vector, String path, File directory)
	{
		lastMacro = null;

		File[] macroFiles = directory.listFiles();
		if(macroFiles == null || macroFiles.length == 0)
			return;

		for(int i = 0; i < macroFiles.length; i++)
		{
			File file = macroFiles[i];
			String fileName = file.getName();
			if(file.isHidden())
			{
				
			}
			else if(file.isDirectory())
			{
				String submenuName = fileName.replace('_',' ');
				List submenu = null;
				
				for(int j = 0; j < vector.size(); j++)
				{
					Object obj = vector.get(j);
					if(obj instanceof List)
					{
						List vec = (List)obj;
						if(submenuName.equals(vec.get(0)))
						{
							submenu = vec;
							break;
						}
					}
				} 
				if(submenu == null)
				{
					submenu = new Vector();
					submenu.add(submenuName);
					vector.add(submenu);
				}

				loadMacros(submenu,path + fileName + '/',file);
			}
			else
			{
				addMacro(file,path,vector);
			}
		}
	} 

	
	private static void addMacro(File file, String path, List vector)
	{
		String fileName = file.getName();
		Handler handler = getHandlerForPathName(file.getPath());

		if(handler == null)
			return;

		try
		{
			
			
			
			String macroName = (path + fileName).replace(' ','_');
			Macro newMacro = handler.createMacro(macroName,
				file.getPath());
			
			
			if(macroHash.get(newMacro.getName()) != null)
				return;

			vector.add(newMacro.getName());
			jEdit.setTemporaryProperty(newMacro.getName()
				+ "".label"",
				newMacro.label);
			jEdit.setTemporaryProperty(newMacro.getName()
				+ "".mouse-over"",
				handler.getLabel() + "" - "" + file.getPath());
			macroActionSet.addAction(newMacro);
			macroHash.put(newMacro.getName(),newMacro);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, Macros.class, e);
			macroHandlers.remove(handler);
		}
	} 

	
	
	private static void recordMacro(View view, Buffer buffer, boolean temporary)
	{
		view.setMacroRecorder(new Recorder(view,buffer,temporary));

		
		
		view.getStatus().setMessage(null);
	} 

	

	
	
	public static class Recorder implements EBComponent
	{
		View view;
		Buffer buffer;
		boolean temporary;

		boolean lastWasInput;
		boolean lastWasOverwrite;
		int overwriteCount;

		
		public Recorder(View view, Buffer buffer, boolean temporary)
		{
			this.view = view;
			this.buffer = buffer;
			this.temporary = temporary;
			EditBus.addToBus(this);
		} 

		
		public void record(String code)
		{
			if (BeanShell.isScriptRunning())
				return;
			flushInput();

			append(""\n"");
			append(code);
		} 

		
		public void record(int repeat, String code)
		{
			if(repeat == 1)
				record(code);
			else
			{
				record(""for(int i = 1; i <= "" + repeat + ""; i++)\n""
					+ ""{\n""
					+ code + '\n'
					+ '}');
			}
		} 

		
		
		public void recordInput(int repeat, char ch, boolean overwrite)
		{
			
			
			if(ch == '\n')
				record(repeat,""textArea.userInput(\'\\n\');"");
			else if(ch == '\t')
				record(repeat,""textArea.userInput(\'\\t\');"");
			else
			{
				StringBuilder buf = new StringBuilder(repeat);
				for(int i = 0; i < repeat; i++)
					buf.append(ch);
				recordInput(buf.toString(),overwrite);
			}
		} 

		
		
		public void recordInput(String str, boolean overwrite)
		{
			String charStr = StandardUtilities.charsToEscapes(str);

			if(overwrite)
			{
				if(lastWasOverwrite)
				{
					overwriteCount++;
					append(charStr);
				}
				else
				{
					flushInput();
					overwriteCount = 1;
					lastWasOverwrite = true;
					append(""\ntextArea.setSelectedText(\"""" + charStr);
				}
			}
			else
			{
				if(lastWasInput)
					append(charStr);
				else
				{
					flushInput();
					lastWasInput = true;
					append(""\ntextArea.setSelectedText(\"""" + charStr);
				}
			}
		} 

		
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof BufferUpdate)
			{
				BufferUpdate bmsg = (BufferUpdate)msg;
				if(bmsg.getWhat() == BufferUpdate.CLOSED)
				{
					if(bmsg.getBuffer() == buffer)
						stopRecording(view);
				}
			}
		} 

		
		private void append(String str)
		{
			buffer.insert(buffer.getLength(),str);
		} 

		
		private void dispose()
		{
			flushInput();

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				buffer.indentLine(i,true);
			}

			EditBus.removeFromBus(this);

			
			
			view.getStatus().setMessage(null);
		} 

		
		
		private void flushInput()
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}

			if(lastWasOverwrite)
			{
				lastWasOverwrite = false;
				append(""\"");\n"");
				append(""offset = buffer.getLineEndOffset(""
					+ ""textArea.getCaretLine()) - 1;\n"");
				append(""buffer.remove(textArea.getCaretPosition(),""
					+ ""Math.min("" + overwriteCount
					+ "",offset - ""
					+ ""textArea.getCaretPosition()));"");
			}
		} 
	} 

	
	
	public abstract static class Handler
	{
		
		public String getName()
		{
			return name;
		} 

		
		public String getLabel()
		{
			return label;
		} 

		
		public boolean accept(String path)
		{
			return filter.matcher(MiscUtilities.getFileName(path)).matches();
		} 

		
		public abstract Macro createMacro(String macroName, String path);
		

		
		
		public abstract void runMacro(View view, Macro macro);
		

		
		
		public void runMacro(View view, Macro macro, boolean ownNamespace)
		{
			runMacro(view,macro);
		} 

		
		protected Handler(String name)
		{
			this.name = name;
			label = jEdit.getProperty(""macro-handler.""
				+ name + "".label"", name);
			try
			{
				filter = Pattern.compile(StandardUtilities.globToRE(
					jEdit.getProperty(
					""macro-handler."" + name + "".glob"")));
			}
			catch (Exception e)
			{
				throw new InternalError(""Missing or invalid glob for handler "" + name);
			}
		} 

		
		private String name;
		private String label;
		private Pattern filter;
		
	} 

	
	private static class BeanShellHandler extends Handler
	{
		
		BeanShellHandler()
		{
			super(""beanshell"");
		} 

		
		@Override
		public Macro createMacro(String macroName, String path)
		{
			
			macroName = macroName.substring(0, macroName.length() - 4);

			return new Macro(this, macroName,
				Macro.macroNameToLabel(macroName), path);
		} 

		
		@Override
		public void runMacro(View view, Macro macro)
		{
			BeanShell.runScript(view,macro.getPath(),null,true);
		} 

		
		@Override
		public void runMacro(View view, Macro macro, boolean ownNamespace)
		{
			BeanShell.runScript(view,macro.getPath(),null,ownNamespace);
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.TokenMarker,14,1,0,17,72,21,9,8,6,0.756410256,1597,1.0,4,0.0,0.18452381,0,0,112.2142857,43,8.2857,0,"

package org.gjt.sp.jedit.syntax;


import javax.swing.text.Segment;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.util.SegmentCharSequence;
import org.gjt.sp.util.StandardUtilities;



public class TokenMarker
{
	
	public TokenMarker()
	{} 

	
	public void addRuleSet(ParserRuleSet rules)
	{
		ruleSets.put(rules.getSetName(), rules);

		if (rules.getSetName().equals(""MAIN""))
			mainRuleSet = rules;
	} 

	
	public ParserRuleSet getMainRuleSet()
	{
		return mainRuleSet;
	} 

	
	public ParserRuleSet getRuleSet(String setName)
	{
		return ruleSets.get(setName);
	} 

	
	
	public ParserRuleSet[] getRuleSets()
	{
		return ruleSets.values().toArray(new ParserRuleSet[ruleSets.size()]);
	} 

	
	
	public synchronized LineContext markTokens(LineContext prevContext,
		TokenHandler tokenHandler, Segment line)
	{
		
		
		
		this.tokenHandler = tokenHandler;
		this.line = line;

		lastOffset = line.offset;
		lineLength = line.count + line.offset;

		context = new LineContext();

		if(prevContext == null)
		{
			context.rules = getMainRuleSet();
			context.escapeRule = context.rules.getEscapeRule();
		}
		else
		{
			context.parent = prevContext.parent;
			context.setInRule(prevContext.inRule);
			context.rules = prevContext.rules;
			context.spanEndSubst = prevContext.spanEndSubst;
		}

		keywords = context.rules.getKeywords();

		seenWhitespaceEnd = false;
		whitespaceEnd = line.offset;
		

		
		int terminateChar = context.rules.getTerminateChar();
		boolean terminated = false;
main_loop:	for(pos = line.offset; pos < lineLength; pos++)
		{
			
			if(terminateChar >= 0 && pos - line.offset >= terminateChar
				&& !terminated)
			{
				terminated = true;
				context = new LineContext(ParserRuleSet
					.getStandardRuleSet(context.rules
					.getDefault()),context);
				keywords = context.rules.getKeywords();
			} 

			
			if (context.escapeRule != null &&
				handleRule(context.escapeRule,false))
			{
				continue main_loop;
			} 

			
			if (context.parent != null
			    && context.parent.inRule != null
			    && checkDelegateEnd(context.parent.inRule))
			{
				seenWhitespaceEnd = true;
				continue main_loop;
			} 

			
			Character ch = Character.valueOf(line.array[pos]);
			List<ParserRule> rules = context.rules.getRules(ch);
			for (ParserRule rule : rules)
			{
				
				if (handleRule(rule,false))
				{
					seenWhitespaceEnd = true;
					continue main_loop;
				}
			} 

			
			if(Character.isWhitespace(ch))
			{
				if(!seenWhitespaceEnd)
					whitespaceEnd = pos + 1;

				if(context.inRule != null)
					handleRule(context.inRule,true);

				handleNoWordBreak();

				markKeyword(false);

				if(lastOffset != pos)
				{
					tokenHandler.handleToken(line,
						context.rules.getDefault(),
						lastOffset - line.offset,
						pos - lastOffset,
						context);
				}

				tokenHandler.handleToken(line,
					context.rules.getDefault(),
					pos - line.offset,1,context);
				lastOffset = pos + 1;
			}
			else
			{
				if(keywords != null || context.rules.getRuleCount() != 0)
				{
					String noWordSep = context.rules.getNoWordSep();

					if(!Character.isLetterOrDigit(ch)
						&& noWordSep.indexOf(ch) == -1)
					{
						if(context.inRule != null)
							handleRule(context.inRule,true);

						handleNoWordBreak();

						markKeyword(true);

						tokenHandler.handleToken(line,
							context.rules.getDefault(),
							lastOffset - line.offset,1,
							context);
						lastOffset = pos + 1;
					}
				}

				seenWhitespaceEnd = true;
			} 
		} 

		
		pos = lineLength;

		if(context.inRule != null)
			handleRule(context.inRule,true);

		handleNoWordBreak();
		markKeyword(true);
		

		
unwind:		while(context.parent != null)
		{
			ParserRule rule = context.parent.inRule;
			if((rule != null && (rule.action
				& ParserRule.NO_LINE_BREAK) == ParserRule.NO_LINE_BREAK)
				|| terminated)
			{
				context = context.parent;
				keywords = context.rules.getKeywords();
				context.setInRule(null);
			}
			else
				break unwind;
		} 

		tokenHandler.handleToken(line,Token.END,
			pos - line.offset,0,context);

		context = context.intern();
		tokenHandler.setLineContext(context);

		
		this.tokenHandler = null;
		this.line = null;

		return context;
	} 

	

	
	private final Map<String, ParserRuleSet> ruleSets = new Hashtable<String, ParserRuleSet>(64);
	private ParserRuleSet mainRuleSet;

	
	
	private TokenHandler tokenHandler;
	
	private Segment line;
	
	private LineContext context;
	private KeywordMap keywords;
	private final Segment pattern = new Segment();
	private int lastOffset;
	private int lineLength;
	private int pos;

	private int whitespaceEnd;
	private boolean seenWhitespaceEnd;
	

	
	private boolean checkDelegateEnd(ParserRule rule)
	{
		if(rule.end == null)
			return false;

		LineContext tempContext = context;
		context = context.parent;
		keywords = context.rules.getKeywords();
		boolean handled = handleRule(rule,true);
		context = tempContext;
		keywords = context.rules.getKeywords();

		if (handled)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);

			markKeyword(true);

			context = (LineContext)context.parent.clone();

			tokenHandler.handleToken(line,
				matchToken(context.inRule, context.inRule, context),
				pos - line.offset,pattern.count,context);

			keywords = context.rules.getKeywords();
			context.setInRule(null);
			lastOffset = pos + pattern.count;

			
			pos += pattern.count - 1;

			return true;
		}

		return false;
	} 

	
	
	private boolean handleRule(ParserRule checkRule, boolean end)
	{
		
		if(!end)
		{
			if (null == checkRule.upHashChars)
			{
				if (checkRule.upHashChar != null &&
				    (pos + checkRule.upHashChar.length() < line.array.length) &&
				    !checkHashString(checkRule))
				{
					return false;
				}
			}
			else
			{
				if (-1 == Arrays.binarySearch(
						checkRule.upHashChars,
						Character.toUpperCase(line.array[pos])))
				{
					return false;
				}
			}
		}

		int offset = (checkRule.action & ParserRule.MARK_PREVIOUS) != 0 ? lastOffset : pos;
		int posMatch = end ? checkRule.endPosMatch : checkRule.startPosMatch;

		if((posMatch & ParserRule.AT_LINE_START)
			== ParserRule.AT_LINE_START)
		{
			if(offset != line.offset)
			{
				return false;
			}
		}
		else if((posMatch & ParserRule.AT_WHITESPACE_END)
			== ParserRule.AT_WHITESPACE_END)
		{
			if(offset != whitespaceEnd)
			{
				return false;
			}
		}
		else if((posMatch & ParserRule.AT_WORD_START)
			== ParserRule.AT_WORD_START)
		{
			if(offset != lastOffset)
			{
				return false;
			}
		} 

		int matchedChars = 1;
		CharSequence charSeq = null;
		Matcher match = null;

		
		if(!end || (checkRule.action & ParserRule.MARK_FOLLOWING) == 0)
		{
			
			if((checkRule.action & ParserRule.REGEXP) == 0 || end)
			{
				if(end)
				{
					if(context.spanEndSubst != null)
						pattern.array = context.spanEndSubst;
					else
						pattern.array = checkRule.end;
				}
				else
					pattern.array = checkRule.start;
				pattern.offset = 0;
				pattern.count = pattern.array.length;
				matchedChars = pattern.count;

				if(!SyntaxUtilities.regionMatches(context.rules
					.getIgnoreCase(),line,pos,pattern.array))
				{
					return false;
				}
			}
			else
			{
				
				
				
				charSeq = new SegmentCharSequence(line, pos - line.offset,
								  line.count - (pos - line.offset));
				match = checkRule.startRegexp.matcher(charSeq);
				if(!match.lookingAt())
				{
					return false;
				}
				else if(match.start() != 0)
				{
					throw new InternalError(""Can't happen"");
				}
				else
				{
					matchedChars = match.end();
					
					if(matchedChars == 0)
						matchedChars = 1;
				}
			}
		} 
		
		if((checkRule.action & ParserRule.IS_ESCAPE) == ParserRule.IS_ESCAPE)
		{
			pos += pattern.count;
		} 
		
		else if(!end)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);

			markKeyword((checkRule.action & ParserRule.MARK_PREVIOUS)
				!= ParserRule.MARK_PREVIOUS);

			switch(checkRule.action & ParserRule.MAJOR_ACTIONS)
			{
			
			case ParserRule.SEQ:
				context.spanEndSubst = null;

				if((checkRule.action & ParserRule.REGEXP) != 0)
				{
					handleTokenWithSpaces(tokenHandler,
						checkRule.token,
						pos - line.offset,
						matchedChars,
						context);
				}
				else
				{
					tokenHandler.handleToken(line,
						checkRule.token,
						pos - line.offset,
						matchedChars,context);
				}

				
				
				if(checkRule.delegate != null)
				{
					context = new LineContext(
						checkRule.delegate,
						context.parent);
					keywords = context.rules.getKeywords();
				}
				break;
			
			
			case ParserRule.SPAN:
			case ParserRule.EOL_SPAN:
				context.setInRule(checkRule);

				byte tokenType = matchToken(checkRule,
							context.inRule, context);

				if((checkRule.action & ParserRule.REGEXP) != 0)
				{
					handleTokenWithSpaces(tokenHandler,
						tokenType,
						pos - line.offset,
						matchedChars,
						context);
				}
				else
				{
					tokenHandler.handleToken(line,tokenType,
						pos - line.offset,
						matchedChars,context);
				}

				char[] spanEndSubst = null;
				
				if(charSeq != null && checkRule.end != null)
				{
					spanEndSubst = substitute(match,
						checkRule.end);
				}

				context.spanEndSubst = spanEndSubst;
				context = new LineContext(
					checkRule.delegate,
					context);
				keywords = context.rules.getKeywords();

				break;
			
			
			case ParserRule.MARK_FOLLOWING:
				tokenHandler.handleToken(line,
					matchToken(checkRule, checkRule, context),
					pos - line.offset,
					pattern.count,context);

				context.spanEndSubst = null;
				context.setInRule(checkRule);
				break;
			
			
			case ParserRule.MARK_PREVIOUS:
				context.spanEndSubst = null;

				if(pos != lastOffset)
				{
					tokenHandler.handleToken(line,
						checkRule.token,
						lastOffset - line.offset,
						pos - lastOffset,
						context);
				}

				tokenHandler.handleToken(line,
					matchToken(checkRule, checkRule, context),
					pos - line.offset,pattern.count,
					context);

				break;
			
			default:
				throw new InternalError(""Unhandled major action"");
			}

			
			pos += matchedChars - 1;
			lastOffset = pos + 1;

			
		} 
		
		else if((context.inRule.action & ParserRule.MARK_FOLLOWING) != 0)
		{
			if(pos != lastOffset)
			{
				tokenHandler.handleToken(line,
					context.inRule.token,
					lastOffset - line.offset,
					pos - lastOffset,context);
			}

			lastOffset = pos;
			context.setInRule(null);
		} 

		return true;
	} 

	
	private void handleNoWordBreak()
	{
		if(context.parent != null)
		{
			ParserRule rule = context.parent.inRule;
			if(rule != null && (context.parent.inRule.action
				& ParserRule.NO_WORD_BREAK) != 0)
			{
				if(pos != lastOffset)
				{
					tokenHandler.handleToken(line,
						rule.token,
						lastOffset - line.offset,
						pos - lastOffset,context);
				}

				lastOffset = pos;
				context = context.parent;
				keywords = context.rules.getKeywords();
				context.setInRule(null);
			}
		}
	} 

	
	private void handleTokenWithSpaces(TokenHandler tokenHandler,
		byte tokenType, int start, int len, LineContext context)
	{
		int last = start;
		int end = start + len;

		for(int i = start; i < end; i++)
		{
			if(Character.isWhitespace(line.array[i + line.offset]))
			{
				if(last != i)
				{
					tokenHandler.handleToken(line,
					tokenType,last,i - last,context);
				}
				tokenHandler.handleToken(line,tokenType,i,1,context);
				last = i + 1;
			}
		}

		if(last != end)
		{
			tokenHandler.handleToken(line,tokenType,last,
				end - last,context);
		}
	} 

	
	private void markKeyword(boolean addRemaining)
	{
		int len = pos - lastOffset;
		if(len == 0)
			return;

		
		if(context.rules.getHighlightDigits())
		{
			boolean digit = false;
			boolean mixed = false;

			for(int i = lastOffset; i < pos; i++)
			{
				char ch = line.array[i];
				if(Character.isDigit(ch))
					digit = true;
				else
					mixed = true;
			}

			if(mixed)
			{
				Pattern digitRE = context.rules.getDigitRegexp();

				
				
				if(digit)
				{
					if(digitRE == null)
					{
						
						
						
						digit = false;
					}
					else
					{
						int oldCount = line.count;
						int oldOffset = line.offset;
						line.offset = lastOffset;
						line.count = len;
						CharSequence seq = new SegmentCharSequence(line);
						digit = digitRE.matcher(seq).matches();
						line.offset = oldOffset;
						line.count = oldCount;
					}
				}
			}

			if(digit)
			{
				tokenHandler.handleToken(line,Token.DIGIT,
					lastOffset - line.offset,
					len,context);
				lastOffset = pos;

				return;
			}
		} 

		
		if(keywords != null)
		{
			byte id = keywords.lookup(line, lastOffset, len);

			if(id != Token.NULL)
			{
				tokenHandler.handleToken(line,id,
					lastOffset - line.offset,
					len,context);
				lastOffset = pos;
				return;
			}
		} 

		
		if(addRemaining)
		{
			tokenHandler.handleToken(line,context.rules.getDefault(),
				lastOffset - line.offset,len,context);
			lastOffset = pos;
		} 
	} 

	
	private static char[] substitute(Matcher match, char[] end)
	{
		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < end.length; i++)
		{
			char ch = end[i];
			if(ch == '$' || ch == '~')
			{
				if(i == end.length - 1)
					buf.append(ch);
				else
				{
					char digit = end[i + 1];
					if(!Character.isDigit(digit))
						buf.append(ch);
					else if (ch == '$')
					{
						buf.append(match.group(
							digit - '0'));
						i++;
					}
					else
					{
						String s = match.group(digit - '0');
						if (s.length() == 1)
						{
							char b = TextUtilities.getComplementaryBracket(s.charAt(0), null);
							if (b == '\0')
								b = s.charAt(0);
							buf.append(b);
						}
						else
							buf.append(ch);
						i++;
					}
				}
			}
			else
				buf.append(ch);
		}

		char[] returnValue = new char[buf.length()];
		buf.getChars(0,buf.length(),returnValue,0);
		return returnValue;
	} 

	
	private byte matchToken(ParserRule rule, ParserRule base, LineContext ctx)
	{
		switch (rule.matchType)
		{
			case ParserRule.MATCH_TYPE_RULE:
				return base.token;

			case ParserRule.MATCH_TYPE_CONTEXT:
				return context.rules.getDefault();

			default:
				return rule.matchType;
		}
	} 

	
	private boolean checkHashString(ParserRule rule)
	{
		for (int i = 0; i < rule.upHashChar.length(); i++)
		{
			if (Character.toUpperCase(line.array[pos+i]) != rule.upHashChar.charAt(i))
			{
				return false;
			}
		}
		return true;
	} 

	

	
	
	public static class LineContext
	{
		private static final Map<LineContext, LineContext> intern = new HashMap<LineContext, LineContext>();

		public LineContext parent;
		public ParserRule inRule;
		public ParserRuleSet rules;
		
		public char[] spanEndSubst;
		public ParserRule escapeRule;

		
		public LineContext(ParserRuleSet rs, LineContext lc)
		{
			rules = rs;
			parent = (lc == null ? null : (LineContext)lc.clone());
			
			if (rs.getModeName() != null)
				escapeRule = rules.getEscapeRule();
			else
				escapeRule = lc.escapeRule;
		} 

		
		public LineContext()
		{
		} 

		
		public LineContext intern()
		{
			LineContext obj = intern.get(this);
			if(obj == null)
			{
				intern.put(this,this);
				return this;
			}
			else
				return obj;
		} 

		
		public int hashCode()
		{
			if(inRule != null)
				return inRule.hashCode();
			else if(rules != null)
				return rules.hashCode();
			else
				return 0;
		} 

		
		public boolean equals(Object obj)
		{
			if(obj instanceof LineContext)
			{
				LineContext lc = (LineContext)obj;
				return lc.inRule == inRule && lc.rules == rules
					&& StandardUtilities.objectsEqual(parent,lc.parent)
					&& charArraysEqual(spanEndSubst,lc.spanEndSubst);
			}
			else
				return false;
		} 

		
		public Object clone()
		{
			LineContext lc = new LineContext();
			lc.inRule = inRule;
			lc.rules = rules;
			lc.parent = (parent == null) ? null : (LineContext) parent.clone();
			lc.spanEndSubst = spanEndSubst;
			lc.escapeRule = escapeRule;

			return lc;
		} 

		
		private static boolean charArraysEqual(char[] c1, char[] c2)
		{
			if(c1 == null)
				return c2 == null;

			
			if(c2 == null)
				return false;

			if(c1.length != c2.length)
				return false;

			for(int i = 0; i < c1.length; i++)
			{
				if(c1[i] != c2[i])
					return false;
			}

			return true;
		} 

		
		
		public void setInRule(ParserRule rule)
		{
			inRule = rule;
			if (rule != null && rule.escapeRule != null)
				escapeRule = rule.escapeRule;
			else if (rules != null && rules.getModeName() != null)
				escapeRule = rules.getEscapeRule();
			else if (parent != null)
				escapeRule = parent.escapeRule;
			else
				escapeRule = null;
		} 

	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaExtension,5,1,8,13,6,10,13,0,5,2.0,54,0.0,0,0.0,0.65,0,0,9.8,3,1.2,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;


public abstract class TextAreaExtension
{
	
	
	public void paintScreenLineRange(Graphics2D gfx, int firstLine,
		int lastLine, int[] physicalLines, int[] start, int[] end,
		int y, int lineHeight)
	{
		for(int i = 0; i < physicalLines.length; i++)
		{
			int screenLine = i + firstLine;
			if(physicalLines[i] == -1)
				paintInvalidLine(gfx,screenLine,y);
			else
			{
				paintValidLine(gfx,screenLine,physicalLines[i],
					start[i],end[i],y);
			}

			y += lineHeight;
		}
	} 

	
	
	public void paintValidLine(Graphics2D gfx, int screenLine,
		int physicalLine, int start, int end, int y) {} 

	
	
	public void paintInvalidLine(Graphics2D gfx, int screenLine,
		int y) {} 

	
	
	public String getToolTipText(int x, int y)
	{
		return null;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.help.HelpViewer,22,6,0,23,115,167,10,22,11,0.813852814,561,1.0,4,0.971385542,0.188311688,1,1,24.0,8,1.3636,2,"

package org.gjt.sp.jedit.help;


import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import java.io.File;
import java.io.IOException;

import java.net.MalformedURLException;
import java.net.URL;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;

import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;

import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLFrameHyperlinkEvent;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;

import org.gjt.sp.jedit.msg.PluginUpdate;
import org.gjt.sp.jedit.msg.PropertiesChanged;

import org.gjt.sp.util.Log;

import static org.gjt.sp.jedit.help.HelpHistoryModel.HistoryEntry;



public class HelpViewer extends JFrame implements HelpViewerInterface, EBComponent, HelpHistoryModelListener
{
	
	
	public HelpViewer()
	{
		this(""welcome.html"");
	} 

	
	
	public HelpViewer(URL url)
	{
		this(url.toString());
	} 

	
	
	public HelpViewer(String url)
	{
		super(jEdit.getProperty(""helpviewer.title""));

		setIconImage(GUIUtilities.getEditorIcon());

		try
		{
			baseURL = new File(MiscUtilities.constructPath(
				jEdit.getJEditHome(),""doc"")).toURL().toString();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			
		}

		ActionHandler actionListener = new ActionHandler();

		JTabbedPane tabs = new JTabbedPane();
		tabs.addTab(jEdit.getProperty(""helpviewer.toc.label""),
			toc = new HelpTOCPanel(this));
		tabs.addTab(jEdit.getProperty(""helpviewer.search.label""),
			new HelpSearchPanel(this));
		tabs.setMinimumSize(new Dimension(0,0));

		JPanel rightPanel = new JPanel(new BorderLayout());

		Box toolBar = new Box(BoxLayout.X_AXIS);
		

		toolBar.add(title = new JLabel());
		toolBar.add(Box.createGlue());
		historyModel = new HelpHistoryModel(25);
		back = new HistoryButton(HistoryButton.BACK,historyModel);
		back.addActionListener(actionListener);
		toolBar.add(back);
		forward = new HistoryButton(HistoryButton.FORWARD,historyModel);
		forward.addActionListener(actionListener);
		toolBar.add(forward);
		back.setPreferredSize(forward.getPreferredSize());
		rightPanel.add(BorderLayout.NORTH,toolBar);

		viewer = new JEditorPane();
		viewer.setEditable(false);
		viewer.addHyperlinkListener(new LinkHandler());
		viewer.setFont(new Font(""Monospaced"",Font.PLAIN,12));
		viewer.addPropertyChangeListener(new PropertyChangeHandler());
		viewer.addKeyListener(new KeyHandler());

		viewerScrollPane = new JScrollPane(viewer);

		rightPanel.add(BorderLayout.CENTER,viewerScrollPane);

		splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
					  jEdit.getBooleanProperty(""appearance.continuousLayout""),
					  tabs,
					  rightPanel);
		splitter.setBorder(null);


		getContentPane().add(BorderLayout.CENTER,splitter);

		historyModel.addHelpHistoryModelListener(this);
		historyUpdated();

		gotoURL(url,true,0);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		getRootPane().setPreferredSize(new Dimension(750,500));

		pack();
		GUIUtilities.loadGeometry(this,""helpviewer"");
		GUIUtilities.addSizeSaver(this,""helpviewer"");

		EditBus.addToBus(this);

		setVisible(true);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				splitter.setDividerLocation(jEdit.getIntegerProperty(
					""helpviewer.splitter"",250));
				viewer.requestFocus();
			}
		});
	} 

	
	
	public void gotoURL(String url, boolean addToHistory, final int scrollPosition)
	{
		
		
		String shortURL;
		if (MiscUtilities.isURL(url))
		{
			if (url.startsWith(baseURL))
			{
				shortURL = url.substring(baseURL.length());
				if(shortURL.startsWith(""/""))
				{
					shortURL = shortURL.substring(1);
				}
			}
			else
			{
				shortURL = url;
			}
		}
		else
		{
			shortURL = url;
			if(baseURL.endsWith(""/""))
			{
				url = baseURL + url;
			}
			else
			{
				url = baseURL + '/' + url;
			}
		}

		
		
		viewer.setCursor(Cursor.getDefaultCursor());

		try
		{
			URL _url = new URL(url);

			if(!_url.equals(viewer.getPage()))
			{
				title.setText(jEdit.getProperty(""helpviewer.loading""));
			}
			else
			{
				
			}

			historyModel.setCurrentScrollPosition(viewer.getPage(),getCurrentScrollPosition());
			viewer.setPage(_url);
			if (0 != scrollPosition)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						viewerScrollPane.getVerticalScrollBar().setValue(scrollPosition);
					}
				});
			}
			if(addToHistory)
			{
				historyModel.addToHistory(url);
			}
		}
		catch(MalformedURLException mf)
		{
			Log.log(Log.ERROR,this,mf);
			String[] args = { url, mf.getMessage() };
			GUIUtilities.error(this,""badurl"",args);
			return;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			String[] args = { url, io.toString() };
			GUIUtilities.error(this,""read-error"",args);
			return;
		}

		this.shortURL = shortURL;

		
		if(shortURL != null)
		{
			toc.selectNode(shortURL);
		}
		
		viewer.requestFocus();
	} 

	
	int getCurrentScrollPosition() {
		return viewerScrollPane.getVerticalScrollBar().getValue();
	} 

	
	URL getCurrentPage() {
		return viewer.getPage();
	} 

	
	public void dispose()
	{
		EditBus.removeFromBus(this);
		jEdit.setIntegerProperty(""helpviewer.splitter"",
			splitter.getDividerLocation());
		super.dispose();
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if(pmsg.getWhat() == PluginUpdate.LOADED
				|| pmsg.getWhat() == PluginUpdate.UNLOADED)
			{
				if(!pmsg.isExiting())
				{
					if(!queuedTOCReload)
						queueTOCReload();
					queuedTOCReload = true;
				}
			}
		}
		else if (msg instanceof PropertiesChanged)
		{
			GUIUtilities.initContinuousLayout(splitter);
		}
	} 

	
	public String getBaseURL()
	{
		return baseURL;
	} 

	
	public String getShortURL()
	{
		return shortURL;
	} 

	
	public void historyUpdated()
	{
		back.setEnabled(historyModel.hasPrevious());
		forward.setEnabled(historyModel.hasNext());
	} 

	
	public Component getComponent()
	{
		return getRootPane();
	} 

	

	
	private String baseURL;
	private String shortURL;
	private HistoryButton back;
	private HistoryButton forward;
	private JEditorPane viewer;
	private JScrollPane viewerScrollPane;
	private JLabel title;
	private JSplitPane splitter;
	private HelpHistoryModel historyModel;
	private HelpTOCPanel toc;
	private boolean queuedTOCReload;
	

	
	public void queueTOCReload()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				queuedTOCReload = false;
				toc.load();
			}
		});
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			String actionCommand = evt.getActionCommand();
			int separatorPosition = actionCommand.lastIndexOf(':');
			String url;
			int scrollPosition;
			if (-1 == separatorPosition)
			{
				url = actionCommand;
				scrollPosition = 0;
			}
			else
			{
				url = actionCommand.substring(0,separatorPosition);
				scrollPosition = Integer.parseInt(actionCommand.substring(separatorPosition+1));
			}
			if (url.length() != 0)
			{
				gotoURL(url,false,scrollPosition);
				return;
			}

			if(source == back)
			{
				HistoryEntry entry = historyModel.back(HelpViewer.this);
				if(entry == null)
				{
					getToolkit().beep();
				}
				else
				{
					gotoURL(entry.url,false,entry.scrollPosition);
				}
			}
			else if(source == forward)
			{
				HistoryEntry entry = historyModel.forward(HelpViewer.this);
				if(entry == null)
				{
					getToolkit().beep();
				}
				else
				{
					gotoURL(entry.url,false,entry.scrollPosition);
				}
			}
		} 
	} 

	
	class LinkHandler implements HyperlinkListener
	{
		
		public void hyperlinkUpdate(HyperlinkEvent evt)
		{
			if(evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
			{
				if(evt instanceof HTMLFrameHyperlinkEvent)
				{
					((HTMLDocument)viewer.getDocument())
						.processHTMLFrameHyperlinkEvent(
						(HTMLFrameHyperlinkEvent)evt);
					historyUpdated();
				}
				else
				{
					URL url = evt.getURL();
					if(url != null)
					{
						gotoURL(url.toString(),true,0);
					}
				}
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED)
			{
				viewer.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.EXITED)
			{
				viewer.setCursor(Cursor.getDefaultCursor());
			}
		} 
	} 

	
	class PropertyChangeHandler implements PropertyChangeListener
	{
		public void propertyChange(PropertyChangeEvent evt)
		{
			if(""page"".equals(evt.getPropertyName()))
			{
				String titleStr = (String)viewer.getDocument()
					.getProperty(""title"");
				if(titleStr == null)
				{
					titleStr = MiscUtilities.getFileName(
						viewer.getPage().toString());
				}
				title.setText(titleStr);
				historyModel.updateTitle(viewer.getPage().toString(),
					titleStr);
			}
		}
	} 

	
	private class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent ke)
		{
			switch (ke.getKeyCode())
			{
			case KeyEvent.VK_UP:
				JScrollBar scrollBar = viewerScrollPane.getVerticalScrollBar();
				scrollBar.setValue(scrollBar.getValue()-scrollBar.getUnitIncrement(-1));
				ke.consume();
				break;
			case KeyEvent.VK_DOWN:
				scrollBar = viewerScrollPane.getVerticalScrollBar();
				scrollBar.setValue(scrollBar.getValue()+scrollBar.getUnitIncrement(1));
				ke.consume();
				break;
			case KeyEvent.VK_LEFT:
				scrollBar = viewerScrollPane.getHorizontalScrollBar();
				scrollBar.setValue(scrollBar.getValue()-scrollBar.getUnitIncrement(-1));
				ke.consume();
				break;
			case KeyEvent.VK_RIGHT:
				scrollBar = viewerScrollPane.getHorizontalScrollBar();
				scrollBar.setValue(scrollBar.getValue()+scrollBar.getUnitIncrement(1));
				ke.consume();
				break;
			}
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHStatementExpressionList,2,2,0,7,6,1,1,6,1,2.0,28,0.0,0,0.944444444,0.625,1,1,13.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

class BSHStatementExpressionList extends SimpleNode
{
	BSHStatementExpressionList(int id) { super(id); }

	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		int n = jjtGetNumChildren();
		for(int i=0; i<n; i++)
		{
			SimpleNode node = ((SimpleNode)jjtGetChild(i));
			node.eval(callstack, interpreter);
		}
		return Primitive.VOID;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.HistoryTextArea,9,6,0,7,40,0,4,3,7,0.0,162,1.0,1,0.989949749,0.333333333,3,4,16.88888889,15,2.8889,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.AbstractBorder;
import javax.swing.border.CompoundBorder;
import javax.swing.event.MouseInputAdapter;
import java.awt.*;
import java.awt.event.*;
import java.util.Collections;
import org.gjt.sp.jedit.*;



public class HistoryTextArea extends JTextArea
{
	
	public HistoryTextArea(String name)
	{
		super(3,15);
		controller = new HistoryText(this,name);
		setFocusTraversalKeys(
			KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
			Collections.singleton(
				KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0)));
		setFocusTraversalKeys(
			KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
			Collections.singleton(
				KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
					InputEvent.SHIFT_MASK)));
	} 

	
	
	public HistoryModel getModel()
	{
		return controller.getModel();
	} 

	
	
	public void setModel(String name)
	{
		controller.setModel(name);
	} 

	
	
	public void setInstantPopups(boolean instantPopups)
	{
		controller.setInstantPopups(instantPopups);
	} 

	
	
	public boolean getInstantPopups()
	{
		return controller.getInstantPopups();
	} 

	
	
	public void addCurrentToHistory()
	{
		controller.addCurrentToHistory();
	} 

	
	
	public void setText(String text)
	{
		super.setText(text);
		controller.setIndex(-1);
	} 

	

	
	protected void processKeyEvent(KeyEvent evt)
	{
		if(!isEnabled())
			return;

		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_ENTER:
				if(evt.isControlDown())
				{
					replaceSelection(""\n"");
					evt.consume();
				}
				break;
			case KeyEvent.VK_TAB:
				if(evt.isControlDown())
				{
					replaceSelection(""\t"");
					evt.consume();
				}
				break;
			case KeyEvent.VK_PAGE_UP:
				if(evt.isShiftDown())
					controller.doBackwardSearch();
				else
					controller.historyPrevious();
				evt.consume();
				break;
			case KeyEvent.VK_PAGE_DOWN:
				if(evt.isShiftDown())
					controller.doForwardSearch();
				else
					controller.historyNext();
				evt.consume();
				break;
			case KeyEvent.VK_UP:
				if(evt.isAltDown())
				{
					controller.showPopupMenu(
						evt.isShiftDown());
					evt.consume();
				}
				break;
			}
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	
	protected void processMouseEvent(MouseEvent evt)
	{
		if(!isEnabled())
			return;

		switch(evt.getID())
		{
		case MouseEvent.MOUSE_PRESSED:
			if(GUIUtilities.isPopupTrigger(evt))
				controller.showPopupMenu(evt.isShiftDown());
			else
				super.processMouseEvent(evt);

			break;
		default:
			super.processMouseEvent(evt);
			break;
		}
	} 
	
	

	
	private HistoryText controller;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.MenuItemTextComparator,3,1,0,9,6,3,7,2,3,2.0,44,0.0,0,0.0,0.555555556,0,0,13.66666667,5,2.0,0,"
package org.gjt.sp.jedit.menu;


import java.util.Comparator;

import javax.swing.JMenuItem;

import org.gjt.sp.util.StandardUtilities;



public class MenuItemTextComparator implements Comparator<JMenuItem>
{

	
	public int compare(JMenuItem obj1, JMenuItem obj2)
	{
		int compareValue = 0;
		boolean obj1E = obj1 instanceof EnhancedMenuItem;
		boolean obj2E = obj2 instanceof EnhancedMenuItem;
		if (obj1E && !obj2E)
		{
			compareValue = 1;
		}
		else if (obj2E && !obj1E)
		{
			compareValue = -1;
		}
		else
		{
			compareValue = StandardUtilities.compareStrings(obj1.getText(), obj2.getText(), true);
		}
		return compareValue;
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ParserTokenManager,51,1,0,5,67,51,1,4,7,0.7648,7188,0.16,1,0.0,0.4,0,0,139.4509804,167,8.902,0,"
package org.gjt.sp.jedit.bsh;

public class ParserTokenManager implements ParserConstants
{
  public  java.io.PrintStream debugStream = System.out;
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2)
{
   switch (pos)
   {
      case 0:
         if ((active1 & 0x200020000000000L) != 0L)
            return 56;
         if ((active0 & 0x3eL) != 0L)
            return 0;
         if ((active1 & 0x10000L) != 0L)
            return 11;
         if ((active0 & 0xffffffffffffc00L) != 0L)
         {
            jjmatchedKind = 69;
            return 35;
         }
         return -1;
      case 1:
         if ((active0 & 0x100600000L) != 0L)
            return 35;
         if ((active0 & 0xffffffeff9ffc00L) != 0L)
         {
            if (jjmatchedPos != 1)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 1;
            }
            return 35;
         }
         return -1;
      case 2:
         if ((active0 & 0xefffecebfdffc00L) != 0L)
         {
            if (jjmatchedPos != 2)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 2;
            }
            return 35;
         }
         if ((active0 & 0x100013040000000L) != 0L)
            return 35;
         return -1;
      case 3:
         if ((active0 & 0xc7ffcae3e5d3c00L) != 0L)
         {
            if (jjmatchedPos != 3)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 3;
            }
            return 35;
         }
         if ((active0 & 0x28002408182c000L) != 0L)
            return 35;
         return -1;
      case 4:
         if ((active0 & 0x86080003c053000L) != 0L)
            return 35;
         if ((active0 & 0x41f7cae02580c00L) != 0L)
         {
            if (jjmatchedPos != 4)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 4;
            }
            return 35;
         }
         return -1;
      case 5:
         if ((active0 & 0x41a1c2a12180c00L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 5;
            return 35;
         }
         if ((active0 & 0x45608400400000L) != 0L)
            return 35;
         return -1;
      case 6:
         if ((active0 & 0x41a102a00080400L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 6;
            return 35;
         }
         if ((active0 & 0xc0012100800L) != 0L)
            return 35;
         return -1;
      case 7:
         if ((active0 & 0x402000000080400L) != 0L)
            return 35;
         if ((active0 & 0x18102a00000000L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 7;
            return 35;
         }
         return -1;
      case 8:
         if ((active0 & 0x8000a00000000L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 8;
            return 35;
         }
         if ((active0 & 0x10102000000000L) != 0L)
            return 35;
         return -1;
      case 9:
         if ((active0 & 0x8000000000000L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 9;
            return 35;
         }
         if ((active0 & 0xa00000000L) != 0L)
            return 35;
         return -1;
      case 10:
         if ((active0 & 0x8000000000000L) != 0L)
         {
            if (jjmatchedPos != 10)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 10;
            }
            return 35;
         }
         return -1;
      case 11:
         if ((active0 & 0x8000000000000L) != 0L)
            return 35;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0, long active1, long active2)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
}
private final int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private final int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 9:
         return jjStartNfaWithStates_0(0, 2, 0);
      case 10:
         return jjStartNfaWithStates_0(0, 5, 0);
      case 12:
         return jjStartNfaWithStates_0(0, 4, 0);
      case 13:
         return jjStartNfaWithStates_0(0, 3, 0);
      case 32:
         return jjStartNfaWithStates_0(0, 1, 0);
      case 33:
         jjmatchedKind = 86;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x80000000L, 0x0L);
      case 37:
         jjmatchedKind = 111;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000000L, 0x0L);
      case 38:
         jjmatchedKind = 106;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x400000400000000L, 0x0L);
      case 40:
         return jjStopAtPos(0, 72);
      case 41:
         return jjStopAtPos(0, 73);
      case 42:
         jjmatchedKind = 104;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L, 0x0L);
      case 43:
         jjmatchedKind = 102;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x40001000000000L, 0x0L);
      case 44:
         return jjStopAtPos(0, 79);
      case 45:
         jjmatchedKind = 103;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x80002000000000L, 0x0L);
      case 46:
         return jjStartNfaWithStates_0(0, 80, 11);
      case 47:
         jjmatchedKind = 105;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000000L, 0x0L);
      case 58:
         return jjStopAtPos(0, 89);
      case 59:
         return jjStopAtPos(0, 78);
      case 60:
         jjmatchedKind = 84;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000008000000L, 0x1L);
      case 61:
         jjmatchedKind = 81;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000L, 0x0L);
      case 62:
         jjmatchedKind = 82;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x14000020000000L, 0x14L);
      case 63:
         return jjStopAtPos(0, 88);
      case 64:
         return jjMoveStringLiteralDfa1_0(0x0L, 0x282a280a50280000L, 0x2aL);
      case 91:
         return jjStopAtPos(0, 76);
      case 93:
         return jjStopAtPos(0, 77);
      case 94:
         jjmatchedKind = 110;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000000000L, 0x0L);
      case 97:
         return jjMoveStringLiteralDfa1_0(0x400L, 0x0L, 0x0L);
      case 98:
         return jjMoveStringLiteralDfa1_0(0x5800L, 0x0L, 0x0L);
      case 99:
         return jjMoveStringLiteralDfa1_0(0xfa000L, 0x0L, 0x0L);
      case 100:
         return jjMoveStringLiteralDfa1_0(0x700000L, 0x0L, 0x0L);
      case 101:
         return jjMoveStringLiteralDfa1_0(0x3800000L, 0x0L, 0x0L);
      case 102:
         return jjMoveStringLiteralDfa1_0(0x7c000000L, 0x0L, 0x0L);
      case 103:
         return jjMoveStringLiteralDfa1_0(0x80000000L, 0x0L, 0x0L);
      case 105:
         return jjMoveStringLiteralDfa1_0(0x3f00000000L, 0x0L, 0x0L);
      case 108:
         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
      case 110:
         return jjMoveStringLiteralDfa1_0(0x38000000000L, 0x0L, 0x0L);
      case 112:
         return jjMoveStringLiteralDfa1_0(0x3c0000000000L, 0x0L, 0x0L);
      case 114:
         return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L, 0x0L);
      case 115:
         return jjMoveStringLiteralDfa1_0(0xf800000000000L, 0x0L, 0x0L);
      case 116:
         return jjMoveStringLiteralDfa1_0(0x1f0000000000000L, 0x0L, 0x0L);
      case 118:
         return jjMoveStringLiteralDfa1_0(0x600000000000000L, 0x0L, 0x0L);
      case 119:
         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L, 0x0L);
      case 123:
         return jjStopAtPos(0, 74);
      case 124:
         jjmatchedKind = 108;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000100000000L, 0x0L);
      case 125:
         return jjStopAtPos(0, 75);
      case 126:
         return jjStopAtPos(0, 87);
      default :
         return jjMoveNfa_0(6, 0);
   }
}
private final int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0, active1, active2);
      return 1;
   }
   switch(curChar)
   {
      case 38:
         if ((active1 & 0x400000000L) != 0L)
            return jjStopAtPos(1, 98);
         break;
      case 43:
         if ((active1 & 0x1000000000L) != 0L)
            return jjStopAtPos(1, 100);
         break;
      case 45:
         if ((active1 & 0x2000000000L) != 0L)
            return jjStopAtPos(1, 101);
         break;
      case 60:
         if ((active1 & 0x1000000000000L) != 0L)
         {
            jjmatchedKind = 112;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x1L);
      case 61:
         if ((active1 & 0x4000000L) != 0L)
            return jjStopAtPos(1, 90);
         else if ((active1 & 0x8000000L) != 0L)
            return jjStopAtPos(1, 91);
         else if ((active1 & 0x20000000L) != 0L)
            return jjStopAtPos(1, 93);
         else if ((active1 & 0x80000000L) != 0L)
            return jjStopAtPos(1, 95);
         else if ((active1 & 0x40000000000000L) != 0L)
            return jjStopAtPos(1, 118);
         else if ((active1 & 0x80000000000000L) != 0L)
            return jjStopAtPos(1, 119);
         else if ((active1 & 0x100000000000000L) != 0L)
            return jjStopAtPos(1, 120);
         else if ((active1 & 0x200000000000000L) != 0L)
            return jjStopAtPos(1, 121);
         else if ((active1 & 0x400000000000000L) != 0L)
            return jjStopAtPos(1, 122);
         else if ((active1 & 0x1000000000000000L) != 0L)
            return jjStopAtPos(1, 124);
         else if ((active1 & 0x4000000000000000L) != 0L)
            return jjStopAtPos(1, 126);
         else if ((active1 & 0x8000000000000000L) != 0L)
            return jjStopAtPos(1, 127);
         break;
      case 62:
         if ((active1 & 0x4000000000000L) != 0L)
         {
            jjmatchedKind = 114;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000000000000L, active2, 0x14L);
      case 97:
         return jjMoveStringLiteralDfa2_0(active0, 0x48004018000L, active1, 0x800000800000000L, active2, 0L);
      case 98:
         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0x280000000000L, active2, 0L);
      case 101:
         return jjMoveStringLiteralDfa2_0(active0, 0x410000100000L, active1, 0L, active2, 0L);
      case 102:
         if ((active0 & 0x100000000L) != 0L)
            return jjStartNfaWithStates_0(1, 32, 35);
         break;
      case 103:
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x40080000L, active2, 0L);
      case 104:
         return jjMoveStringLiteralDfa2_0(active0, 0x860800000020000L, active1, 0L, active2, 0L);
      case 105:
         return jjMoveStringLiteralDfa2_0(active0, 0x18000000L, active1, 0L, active2, 0L);
      case 108:
         return jjMoveStringLiteralDfa2_0(active0, 0x20802000L, active1, 0x2000010200000L, active2, 0x2L);
      case 109:
         return jjMoveStringLiteralDfa2_0(active0, 0x600000000L, active1, 0L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa2_0(active0, 0x3801000000L, active1, 0L, active2, 0L);
      case 111:
         if ((active0 & 0x200000L) != 0L)
         {
            jjmatchedKind = 21;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0x6000040c04c0800L, active1, 0x2000000200000000L, active2, 0L);
      case 114:
         return jjMoveStringLiteralDfa2_0(active0, 0x190180000001000L, active1, 0x28000000000000L, active2, 0x28L);
      case 116:
         return jjMoveStringLiteralDfa2_0(active0, 0x3000000000000L, active1, 0L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa2_0(active0, 0x220000000000L, active1, 0L, active2, 0L);
      case 119:
         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
      case 120:
         return jjMoveStringLiteralDfa2_0(active0, 0x2000000L, active1, 0L, active2, 0L);
      case 121:
         return jjMoveStringLiteralDfa2_0(active0, 0x8000000004000L, active1, 0L, active2, 0L);
      case 124:
         if ((active1 & 0x100000000L) != 0L)
            return jjStopAtPos(1, 96);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(0, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0, active1, active2);
      return 2;
   }
   switch(curChar)
   {
      case 61:
         if ((active2 & 0x1L) != 0L)
            return jjStopAtPos(2, 128);
         else if ((active2 & 0x4L) != 0L)
            return jjStopAtPos(2, 130);
         break;
      case 62:
         if ((active1 & 0x10000000000000L) != 0L)
         {
            jjmatchedKind = 116;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x10L);
      case 97:
         return jjMoveStringLiteralDfa3_0(active0, 0x11000000022000L, active1, 0L, active2, 0L);
      case 98:
         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa3_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
      case 101:
         return jjMoveStringLiteralDfa3_0(active0, 0x1000L, active1, 0x2000000000000L, active2, 0x2L);
      case 102:
         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L, active2, 0L);
      case 105:
         return jjMoveStringLiteralDfa3_0(active0, 0xa04080000000000L, active1, 0x28280000000000L, active2, 0x28L);
      case 108:
         return jjMoveStringLiteralDfa3_0(active0, 0x400020004000000L, active1, 0L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa3_0(active0, 0x80040180c0000L, active1, 0x800000800000000L, active2, 0L);
      case 111:
         return jjMoveStringLiteralDfa3_0(active0, 0x900020000800L, active1, 0L, active2, 0L);
      case 112:
         return jjMoveStringLiteralDfa3_0(active0, 0x600000000L, active1, 0L, active2, 0L);
      case 114:
         if ((active0 & 0x40000000L) != 0L)
            return jjStartNfaWithStates_0(2, 30, 35);
         else if ((active1 & 0x200000000L) != 0L)
         {
            jjmatchedKind = 97;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x62000000000000L, active1, 0x2000000000000000L, active2, 0L);
      case 115:
         return jjMoveStringLiteralDfa3_0(active0, 0x800808400L, active1, 0L, active2, 0L);
      case 116:
         if ((active0 & 0x1000000000L) != 0L)
         {
            jjmatchedKind = 36;
            jjmatchedPos = 2;
         }
         else if ((active1 & 0x80000L) != 0L)
         {
            jjmatchedKind = 83;
            jjmatchedPos = 2;
         }
         else if ((active1 & 0x200000L) != 0L)
         {
            jjmatchedKind = 85;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x40a082014000L, active1, 0x50000000L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x80000001400000L, active1, 0L, active2, 0L);
      case 119:
         if ((active0 & 0x10000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 40, 35);
         break;
      case 121:
         if ((active0 & 0x100000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 56, 35);
         break;
      default :
         break;
   }
   return jjStartNfa_0(1, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(1, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0, active1, active2);
      return 3;
   }
   switch(curChar)
   {
      case 61:
         if ((active2 & 0x10L) != 0L)
            return jjStopAtPos(3, 132);
         break;
      case 95:
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 97:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000038101000L, active1, 0L, active2, 0L);
      case 98:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000L, active1, 0L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa4_0(active0, 0x8000000010000L, active1, 0L, active2, 0L);
      case 100:
         if ((active0 & 0x200000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 57, 35);
         else if ((active1 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 99;
            jjmatchedPos = 3;
         }
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
      case 101:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_0(3, 14, 35);
         else if ((active0 & 0x8000L) != 0L)
            return jjStartNfaWithStates_0(3, 15, 35);
         else if ((active0 & 0x800000L) != 0L)
            return jjStartNfaWithStates_0(3, 23, 35);
         else if ((active0 & 0x80000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 55, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x2002000000L, active1, 0x50000000L, active2, 0L);
      case 102:
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 103:
         if ((active0 & 0x4000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 38, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);
      case 105:
         return jjMoveStringLiteralDfa4_0(active0, 0x2008000000000L, active1, 0L, active2, 0L);
      case 107:
         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
      case 108:
         if ((active0 & 0x20000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 41, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x800200200000800L, active1, 0L, active2, 0L);
      case 109:
         if ((active0 & 0x1000000L) != 0L)
            return jjStartNfaWithStates_0(3, 24, 35);
         break;
      case 110:
         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
      case 111:
         if ((active0 & 0x80000000L) != 0L)
            return jjStartNfaWithStates_0(3, 31, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x60000400000000L, active1, 0L, active2, 0L);
      case 114:
         if ((active0 & 0x20000L) != 0L)
            return jjStartNfaWithStates_0(3, 17, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L, active1, 0L, active2, 0L);
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x4042000L, active1, 0L, active2, 0L);
      case 116:
         return jjMoveStringLiteralDfa4_0(active0, 0x5100800080400L, active1, 0x280000000000L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L, active1, 0L, active2, 0L);
      case 118:
         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(2, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0, active1, active2);
      return 4;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
      case 97:
         return jjMoveStringLiteralDfa5_0(active0, 0xc0800000000L, active1, 0x2000000000000000L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa5_0(active0, 0x6000000000000L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_0(4, 26, 35);
         else if ((active0 & 0x800000000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 59, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x100200000800L, active1, 0L, active2, 0L);
      case 104:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_0(4, 16, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000L, active1, 0x28000000000000L, active2, 0x28L);
      case 105:
         return jjMoveStringLiteralDfa5_0(active0, 0x1200000080000L, active1, 0L, active2, 0L);
      case 107:
         if ((active0 & 0x1000L) != 0L)
            return jjStartNfaWithStates_0(4, 12, 35);
         break;
      case 108:
         if ((active0 & 0x8000000L) != 0L)
         {
            jjmatchedKind = 27;
            jjmatchedPos = 4;
         }
         return jjMoveStringLiteralDfa5_0(active0, 0x10400000L, active1, 0L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa5_0(active0, 0x2000000L, active1, 0L, active2, 0L);
      case 113:
         if ((active1 & 0x10000000L) != 0L)
            return jjStopAtPos(4, 92);
         else if ((active1 & 0x40000000L) != 0L)
            return jjStopAtPos(4, 94);
         break;
      case 114:
         return jjMoveStringLiteralDfa5_0(active0, 0x402400000400L, active1, 0L, active2, 0L);
      case 115:
         if ((active0 & 0x2000L) != 0L)
            return jjStartNfaWithStates_0(4, 13, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
      case 116:
         if ((active0 & 0x40000L) != 0L)
            return jjStartNfaWithStates_0(4, 18, 35);
         else if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_0(4, 29, 35);
         else if ((active0 & 0x800000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 47, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0x2000000000000L, active2, 0x2L);
      case 117:
         return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0L, active2, 0L);
      case 118:
         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0L, active2, 0L);
      case 119:
         if ((active0 & 0x20000000000000L) != 0L)
         {
            jjmatchedKind = 53;
            jjmatchedPos = 4;
         }
         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000000L, active1, 0x280000000000L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(3, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(3, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(4, active0, active1, active2);
      return 5;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 97:
         return jjMoveStringLiteralDfa6_0(active0, 0xc00L, active1, 0x800000000000000L, active2, 0L);
      case 99:
         if ((active0 & 0x200000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 45, 35);
         else if ((active0 & 0x1000000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 48, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
      case 100:
         return jjMoveStringLiteralDfa6_0(active0, 0x2000000L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x400000L) != 0L)
            return jjStartNfaWithStates_0(5, 22, 35);
         else if ((active0 & 0x8000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 39, 35);
         break;
      case 102:
         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
      case 103:
         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
      case 104:
         if ((active0 & 0x4000000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 50, 35);
         break;
      case 105:
         return jjMoveStringLiteralDfa6_0(active0, 0x410000000000000L, active1, 0x280000000000L, active2, 0L);
      case 108:
         return jjMoveStringLiteralDfa6_0(active0, 0x10100000L, active1, 0L, active2, 0L);
      case 109:
         return jjMoveStringLiteralDfa6_0(active0, 0x200000000L, active1, 0L, active2, 0L);
      case 110:
         if ((active0 & 0x400000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 46, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x800080000L, active1, 0L, active2, 0L);
      case 114:
         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      case 115:
         if ((active0 & 0x40000000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 54, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 116:
         if ((active0 & 0x400000000L) != 0L)
            return jjStartNfaWithStates_0(5, 34, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x2080000000000L, active1, 0x28000000000000L, active2, 0x28L);
      default :
         break;
   }
   return jjStartNfa_0(4, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(4, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(5, active0, active1, active2);
      return 6;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);
      case 97:
         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa7_0(active0, 0x800000400L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x40000000000L) != 0L)
            return jjStartNfaWithStates_0(6, 42, 35);
         else if ((active0 & 0x80000000000L) != 0L)
            return jjStartNfaWithStates_0(6, 43, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0x10000200000000L, active1, 0L, active2, 0L);
      case 102:
         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
      case 108:
         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L, active2, 0L);
      case 110:
         if ((active0 & 0x800L) != 0L)
            return jjStartNfaWithStates_0(6, 11, 35);
         break;
      case 111:
         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      case 115:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_0(6, 25, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x2802280000000000L, active2, 0x2L);
      case 116:
         if ((active0 & 0x100000L) != 0L)
            return jjStartNfaWithStates_0(6, 20, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa7_0(active0, 0x80000L, active1, 0L, active2, 0L);
      case 121:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_0(6, 28, 35);
         break;
      default :
         break;
   }
   return jjStartNfa_0(5, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(5, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(6, active0, active1, active2);
      return 7;
   }
   switch(curChar)
   {
      case 99:
         return jjMoveStringLiteralDfa8_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x80000L) != 0L)
            return jjStartNfaWithStates_0(7, 19, 35);
         else if ((active0 & 0x400000000000000L) != 0L)
            return jjStartNfaWithStates_0(7, 58, 35);
         return jjMoveStringLiteralDfa8_0(active0, 0x100800000000L, active1, 0x280000000000L, active2, 0L);
      case 104:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 105:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa8_0(active0, 0x18000200000000L, active1, 0L, active2, 0L);
      case 112:
         if ((active0 & 0x2000000000000L) != 0L)
            return jjStartNfaWithStates_0(7, 49, 35);
         break;
      case 115:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x808000000000000L, active2, 0x8L);
      case 116:
         if ((active0 & 0x400L) != 0L)
            return jjStartNfaWithStates_0(7, 10, 35);
         break;
      case 117:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(6, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(6, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(7, active0, active1, active2);
      return 8;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x280000000000L, active2, 0L);
      case 100:
         if ((active0 & 0x100000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 44, 35);
         break;
      case 101:
         if ((active0 & 0x2000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 37, 35);
         break;
      case 103:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 104:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
      case 105:
         return jjMoveStringLiteralDfa9_0(active0, 0x8000000000000L, active1, 0x802000000000000L, active2, 0x2L);
      case 110:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 111:
         return jjMoveStringLiteralDfa9_0(active0, 0x800000000L, active1, 0L, active2, 0L);
      case 116:
         if ((active0 & 0x10000000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 52, 35);
         return jjMoveStringLiteralDfa9_0(active0, 0x200000000L, active1, 0L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(7, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(7, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(8, active0, active1, active2);
      return 9;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x80000000000L, active2, 0L);
      case 102:
         if ((active0 & 0x800000000L) != 0L)
            return jjStartNfaWithStates_0(9, 35, 35);
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 103:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
      case 105:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
      case 110:
         if ((active1 & 0x2000000000000000L) != 0L)
            return jjStopAtPos(9, 125);
         break;
      case 111:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x200000000000L, active2, 0L);
      case 115:
         if ((active0 & 0x200000000L) != 0L)
            return jjStartNfaWithStates_0(9, 33, 35);
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 122:
         return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(8, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(8, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(9, active0, active1, active2);
      return 10;
   }
   switch(curChar)
   {
      case 101:
         return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      case 102:
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
      case 105:
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 110:
         if ((active1 & 0x800000000000000L) != 0L)
            return jjStopAtPos(10, 123);
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x80000000000L, active2, 0L);
      case 114:
         if ((active1 & 0x200000000000L) != 0L)
            return jjStopAtPos(10, 109);
         break;
      case 116:
         if ((active1 & 0x2000000000000L) != 0L)
         {
            jjmatchedKind = 113;
            jjmatchedPos = 10;
         }
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0L, active2, 0x2L);
      default :
         break;
   }
   return jjStartNfa_0(9, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(9, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(10, active0, active1, active2);
      return 11;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x2L);
      case 100:
         if ((active0 & 0x8000000000000L) != 0L)
            return jjStartNfaWithStates_0(11, 51, 35);
         else if ((active1 & 0x80000000000L) != 0L)
            return jjStopAtPos(11, 107);
         break;
      case 103:
         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 116:
         if ((active1 & 0x8000000000000L) != 0L)
         {
            jjmatchedKind = 115;
            jjmatchedPos = 11;
         }
         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x8L);
      default :
         break;
   }
   return jjStartNfa_0(10, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(10, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(11, 0L, active1, active2);
      return 12;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x8L);
      case 97:
         return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x2L);
      case 110:
         return jjMoveStringLiteralDfa13_0(active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(11, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa13_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(11, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(12, 0L, active1, active2);
      return 13;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x8L);
      case 101:
         return jjMoveStringLiteralDfa14_0(active1, 0x20000000000000L, active2, 0x20L);
      case 115:
         return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x2L);
      default :
         break;
   }
   return jjStartNfa_0(12, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa14_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(12, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(13, 0L, active1, active2);
      return 14;
   }
   switch(curChar)
   {
      case 100:
         return jjMoveStringLiteralDfa15_0(active1, 0x20000000000000L, active2, 0x20L);
      case 115:
         return jjMoveStringLiteralDfa15_0(active1, 0L, active2, 0xaL);
      default :
         break;
   }
   return jjStartNfa_0(13, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa15_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(13, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(14, 0L, active1, active2);
      return 15;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa16_0(active1, 0x20000000000000L, active2, 0x20L);
      case 105:
         return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x2L);
      case 115:
         return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x8L);
      default :
         break;
   }
   return jjStartNfa_0(14, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa16_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(14, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(15, 0L, active1, active2);
      return 16;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x2L);
      case 105:
         return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x8L);
      case 115:
         return jjMoveStringLiteralDfa17_0(active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(15, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa17_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(15, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(16, 0L, active1, active2);
      return 17;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa18_0(active1, 0L, active2, 0x8L);
      case 104:
         return jjMoveStringLiteralDfa18_0(active1, 0x20000000000000L, active2, 0x20L);
      case 110:
         if ((active2 & 0x2L) != 0L)
            return jjStopAtPos(17, 129);
         break;
      default :
         break;
   }
   return jjStartNfa_0(16, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa18_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(16, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(17, 0L, active1, active2);
      return 18;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa19_0(active1, 0x20000000000000L, active2, 0x20L);
      case 110:
         if ((active2 & 0x8L) != 0L)
            return jjStopAtPos(18, 131);
         break;
      default :
         break;
   }
   return jjStartNfa_0(17, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa19_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(17, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(18, 0L, active1, active2);
      return 19;
   }
   switch(curChar)
   {
      case 102:
         return jjMoveStringLiteralDfa20_0(active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(18, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa20_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(18, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(19, 0L, active1, active2);
      return 20;
   }
   switch(curChar)
   {
      case 116:
         if ((active1 & 0x20000000000000L) != 0L)
         {
            jjmatchedKind = 117;
            jjmatchedPos = 20;
         }
         return jjMoveStringLiteralDfa21_0(active1, 0L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(19, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa21_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(19, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(20, 0L, 0L, active2);
      return 21;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa22_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(20, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa22_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(20, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(21, 0L, 0L, active2);
      return 22;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa23_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(21, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa23_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(21, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(22, 0L, 0L, active2);
      return 23;
   }
   switch(curChar)
   {
      case 115:
         return jjMoveStringLiteralDfa24_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(22, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa24_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(22, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(23, 0L, 0L, active2);
      return 24;
   }
   switch(curChar)
   {
      case 115:
         return jjMoveStringLiteralDfa25_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(23, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa25_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(23, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(24, 0L, 0L, active2);
      return 25;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa26_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(24, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa26_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(24, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(25, 0L, 0L, active2);
      return 26;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa27_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(25, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa27_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(25, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(26, 0L, 0L, active2);
      return 27;
   }
   switch(curChar)
   {
      case 110:
         if ((active2 & 0x20L) != 0L)
            return jjStopAtPos(27, 133);
         break;
      default :
         break;
   }
   return jjStartNfa_0(26, 0L, 0L, active2);
}
private final void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private final void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private final void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}
private final void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}
private final void jjCheckNAddStates(int start)
{
   jjCheckNAdd(jjnextStates[start]);
   jjCheckNAdd(jjnextStates[start + 1]);
}
static final long[] jjbitVec0 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec1 = {
   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec3 = {
   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
};
static final long[] jjbitVec4 = {
   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
};
static final long[] jjbitVec5 = {
   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec6 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
};
static final long[] jjbitVec7 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
};
static final long[] jjbitVec8 = {
   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
};
private final int jjMoveNfa_0(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 74;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if ((0x1ffffffffL & l) != 0L)
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAdd(0);
                  }
                  else if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(0, 6);
                  else if (curChar == 47)
                     jjAddStates(7, 9);
                  else if (curChar == 36)
                  {
                     if (kind > 69)
                        kind = 69;
                     jjCheckNAdd(35);
                  }
                  else if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  else if (curChar == 39)
                     jjAddStates(13, 14);
                  else if (curChar == 46)
                     jjCheckNAdd(11);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 1;
                  if ((0x3fe000000000000L & l) != 0L)
                  {
                     if (kind > 60)
                        kind = 60;
                     jjCheckNAddTwoStates(8, 9);
                  }
                  else if (curChar == 48)
                  {
                     if (kind > 60)
                        kind = 60;
                     jjCheckNAddStates(15, 17);
                  }
                  break;
               case 56:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 67;
                  else if (curChar == 47)
                  {
                     if (kind > 7)
                        kind = 7;
                     jjCheckNAddStates(18, 20);
                  }
                  if (curChar == 42)
                     jjCheckNAdd(62);
                  break;
               case 0:
                  if ((0x1ffffffffL & l) == 0L)
                     break;
                  if (kind > 6)
                     kind = 6;
                  jjCheckNAdd(0);
                  break;
               case 1:
                  if (curChar == 33)
                     jjCheckNAddStates(21, 23);
                  break;
               case 2:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     jjCheckNAddStates(21, 23);
                  break;
               case 3:
                  if ((0x2400L & l) != 0L && kind > 8)
                     kind = 8;
                  break;
               case 4:
                  if (curChar == 10 && kind > 8)
                     kind = 8;
                  break;
               case 5:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 7:
                  if ((0x3fe000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(8, 9);
                  break;
               case 8:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(8, 9);
                  break;
               case 10:
                  if (curChar == 46)
                     jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddStates(24, 26);
                  break;
               case 13:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(14);
                  break;
               case 14:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddTwoStates(14, 15);
                  break;
               case 16:
                  if (curChar == 39)
                     jjAddStates(13, 14);
                  break;
               case 17:
                  if ((0xffffff7fffffdbffL & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 18:
                  if (curChar == 39 && kind > 66)
                     kind = 66;
                  break;
               case 20:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 21:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(22, 18);
                  break;
               case 22:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 23:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 24;
                  break;
               case 24:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(22);
                  break;
               case 25:
                  if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  break;
               case 26:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 28:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 29:
                  if (curChar == 34 && kind > 67)
                     kind = 67;
                  break;
               case 30:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(27, 30);
                  break;
               case 31:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 32:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 33:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(31);
                  break;
               case 34:
                  if (curChar != 36)
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 35:
                  if ((0x3ff001000000000L & l) == 0L)
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 36:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(0, 6);
                  break;
               case 37:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(37, 38);
                  break;
               case 38:
                  if (curChar != 46)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddStates(31, 33);
                  break;
               case 39:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddStates(31, 33);
                  break;
               case 41:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(42);
                  break;
               case 42:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddTwoStates(42, 15);
                  break;
               case 43:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(43, 44);
                  break;
               case 45:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(46);
                  break;
               case 46:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddTwoStates(46, 15);
                  break;
               case 47:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(34, 36);
                  break;
               case 49:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(50);
                  break;
               case 50:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(50, 15);
                  break;
               case 51:
                  if (curChar != 48)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddStates(15, 17);
                  break;
               case 53:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(53, 9);
                  break;
               case 54:
                  if ((0xff000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(54, 9);
                  break;
               case 55:
                  if (curChar == 47)
                     jjAddStates(7, 9);
                  break;
               case 57:
                  if ((0xffffffffffffdbffL & l) == 0L)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjCheckNAddStates(18, 20);
                  break;
               case 58:
                  if ((0x2400L & l) != 0L && kind > 7)
                     kind = 7;
                  break;
               case 59:
                  if (curChar == 10 && kind > 7)
                     kind = 7;
                  break;
               case 60:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 59;
                  break;
               case 61:
                  if (curChar == 42)
                     jjCheckNAdd(62);
                  break;
               case 62:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 63:
                  if (curChar == 42)
                     jjCheckNAddStates(37, 39);
                  break;
               case 64:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 65:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 66:
                  if (curChar == 47 && kind > 9)
                     kind = 9;
                  break;
               case 67:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(68, 69);
                  break;
               case 68:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(68, 69);
                  break;
               case 69:
                  if (curChar == 42)
                     jjCheckNAddStates(40, 42);
                  break;
               case 70:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(71, 69);
                  break;
               case 71:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(71, 69);
                  break;
               case 72:
                  if (curChar == 47 && kind > 68)
                     kind = 68;
                  break;
               case 73:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 67;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
               case 35:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 2:
                  jjAddStates(21, 23);
                  break;
               case 9:
                  if ((0x100000001000L & l) != 0L && kind > 60)
                     kind = 60;
                  break;
               case 12:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(43, 44);
                  break;
               case 15:
                  if ((0x5000000050L & l) != 0L && kind > 64)
                     kind = 64;
                  break;
               case 17:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 19:
                  if (curChar == 92)
                     jjAddStates(45, 47);
                  break;
               case 20:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 26:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 27:
                  if (curChar == 92)
                     jjAddStates(48, 50);
                  break;
               case 28:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 40:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(51, 52);
                  break;
               case 44:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(53, 54);
                  break;
               case 48:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(55, 56);
                  break;
               case 52:
                  if ((0x100000001000000L & l) != 0L)
                     jjCheckNAdd(53);
                  break;
               case 53:
                  if ((0x7e0000007eL & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(53, 9);
                  break;
               case 57:
                  if (kind > 7)
                     kind = 7;
                  jjAddStates(18, 20);
                  break;
               case 62:
                  jjCheckNAddTwoStates(62, 63);
                  break;
               case 64:
               case 65:
                  jjCheckNAddTwoStates(65, 63);
                  break;
               case 68:
                  jjCheckNAddTwoStates(68, 69);
                  break;
               case 70:
               case 71:
                  jjCheckNAddTwoStates(71, 69);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAdd(0);
                  }
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                  {
                     if (kind > 69)
                        kind = 69;
                     jjCheckNAdd(35);
                  }
                  break;
               case 0:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 6)
                     kind = 6;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(21, 23);
                  break;
               case 17:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjstateSet[jjnewStateCnt++] = 18;
                  break;
               case 26:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(10, 12);
                  break;
               case 34:
               case 35:
                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 57:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjAddStates(18, 20);
                  break;
               case 62:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 64:
               case 65:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 68:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(68, 69);
                  break;
               case 70:
               case 71:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(71, 69);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 74 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   37, 38, 43, 44, 47, 48, 15, 56, 61, 73, 26, 27, 29, 17, 19, 52, 
   54, 9, 57, 58, 60, 2, 3, 5, 11, 12, 15, 26, 27, 31, 29, 39, 
   40, 15, 47, 48, 15, 63, 64, 66, 69, 70, 72, 13, 14, 20, 21, 23, 
   28, 30, 32, 41, 42, 45, 46, 49, 50, 
};
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         return false;
   }
}
private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         if ((jjbitVec1[i1] & l1) != 0L)
            return true;
         return false;
   }
}
private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec4[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec5[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec6[i2] & l2) != 0L);
      case 51:
         return ((jjbitVec7[i2] & l2) != 0L);
      case 61:
         return ((jjbitVec8[i2] & l2) != 0L);
      default : 
         if ((jjbitVec3[i1] & l1) != 0L)
            return true;
         return false;
   }
}
public static final String[] jjstrLiteralImages = {
"""", null, null, null, null, null, null, null, null, null, 
""\141\142\163\164\162\141\143\164"", ""\142\157\157\154\145\141\156"", ""\142\162\145\141\153"", 
""\143\154\141\163\163"", ""\142\171\164\145"", ""\143\141\163\145"", ""\143\141\164\143\150"", 
""\143\150\141\162"", ""\143\157\156\163\164"", ""\143\157\156\164\151\156\165\145"", 
""\144\145\146\141\165\154\164"", ""\144\157"", ""\144\157\165\142\154\145"", ""\145\154\163\145"", 
""\145\156\165\155"", ""\145\170\164\145\156\144\163"", ""\146\141\154\163\145"", 
""\146\151\156\141\154"", ""\146\151\156\141\154\154\171"", ""\146\154\157\141\164"", ""\146\157\162"", 
""\147\157\164\157"", ""\151\146"", ""\151\155\160\154\145\155\145\156\164\163"", 
""\151\155\160\157\162\164"", ""\151\156\163\164\141\156\143\145\157\146"", ""\151\156\164"", 
""\151\156\164\145\162\146\141\143\145"", ""\154\157\156\147"", ""\156\141\164\151\166\145"", ""\156\145\167"", 
""\156\165\154\154"", ""\160\141\143\153\141\147\145"", ""\160\162\151\166\141\164\145"", 
""\160\162\157\164\145\143\164\145\144"", ""\160\165\142\154\151\143"", ""\162\145\164\165\162\156"", 
""\163\150\157\162\164"", ""\163\164\141\164\151\143"", ""\163\164\162\151\143\164\146\160"", 
""\163\167\151\164\143\150"", ""\163\171\156\143\150\162\157\156\151\172\145\144"", 
""\164\162\141\156\163\151\145\156\164"", ""\164\150\162\157\167"", ""\164\150\162\157\167\163"", ""\164\162\165\145"", 
""\164\162\171"", ""\166\157\151\144"", ""\166\157\154\141\164\151\154\145"", 
""\167\150\151\154\145"", null, null, null, null, null, null, null, null, null, null, null, null, ""\50"", 
""\51"", ""\173"", ""\175"", ""\133"", ""\135"", ""\73"", ""\54"", ""\56"", ""\75"", ""\76"", 
""\100\147\164"", ""\74"", ""\100\154\164"", ""\41"", ""\176"", ""\77"", ""\72"", ""\75\75"", ""\74\75"", 
""\100\154\164\145\161"", ""\76\75"", ""\100\147\164\145\161"", ""\41\75"", ""\174\174"", ""\100\157\162"", 
""\46\46"", ""\100\141\156\144"", ""\53\53"", ""\55\55"", ""\53"", ""\55"", ""\52"", ""\57"", ""\46"", 
""\100\142\151\164\167\151\163\145\137\141\156\144"", ""\174"", ""\100\142\151\164\167\151\163\145\137\157\162"", ""\136"", ""\45"", 
""\74\74"", ""\100\154\145\146\164\137\163\150\151\146\164"", ""\76\76"", 
""\100\162\151\147\150\164\137\163\150\151\146\164"", ""\76\76\76"", 
""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164"", ""\53\75"", ""\55\75"", ""\52\75"", ""\57\75"", ""\46\75"", 
""\100\141\156\144\137\141\163\163\151\147\156"", ""\174\75"", ""\100\157\162\137\141\163\163\151\147\156"", ""\136\75"", ""\45\75"", 
""\74\74\75"", ""\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", 
""\76\76\75"", 
""\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", ""\76\76\76\75"", 
""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156"", };
public static final String[] lexStateNames = {
   ""DEFAULT"", 
};
static final long[] jjtoToken = {
   0x1ffffffffffffc01L, 0xffffffffffffff3dL, 0x3fL, 
};
static final long[] jjtoSkip = {
   0x3feL, 0x0L, 0x0L, 
};
static final long[] jjtoSpecial = {
   0x380L, 0x0L, 0x0L, 
};
protected JavaCharStream input_stream;
private final int[] jjrounds = new int[74];
private final int[] jjstateSet = new int[148];
protected char curChar;
public ParserTokenManager(JavaCharStream stream)
{
   if (JavaCharStream.staticFlag)
      throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
   input_stream = stream;
}
public ParserTokenManager(JavaCharStream stream, int lexState)
{
   this(stream);
   SwitchTo(lexState);
}
public void ReInit(JavaCharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private final void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 74; i-- > 0;)
      jjrounds[i] = 0x80000000;
}
public void ReInit(JavaCharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}
public void SwitchTo(int lexState)
{
   if (lexState >= 1 || lexState < 0)
      throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}

protected Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}

int curLexState = 0;
int defaultLexState = 0;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;

public Token getNextToken() 
{
  int kind;
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {   
   try   
   {     
      curChar = input_stream.BeginToken();
   }     
   catch(java.io.IOException e)
   {        
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }

   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjMoveStringLiteralDfa0_0();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         matchedToken.specialToken = specialToken;
         return matchedToken;
      }
      else
      {
         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
         {
            matchedToken = jjFillToken();
            if (specialToken == null)
               specialToken = matchedToken;
            else
            {
               matchedToken.specialToken = specialToken;
               specialToken = (specialToken.next = matchedToken);
            }
         }
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}

}
"
jEdit,4.3,org.gjt.sp.jedit.indent.BracketIndentRule,5,1,2,7,20,4,3,5,5,0.5,126,1.0,0,0.0,0.44,0,0,23.8,7,2.0,0,"

package org.gjt.sp.jedit.indent;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.jedit.syntax.TokenHandler;
import org.gjt.sp.jedit.syntax.TokenMarker;


public abstract class BracketIndentRule implements IndentRule
{
	
	public BracketIndentRule(char openBracket, char closeBracket)
	{
		this.openBracket = openBracket;
		this.closeBracket = closeBracket;
	} 

	
	public static class Brackets
	{
		int openCount;
		int closeCount;
	} 

	
	
	@Deprecated
	public Brackets getBrackets(String line)
	{
		Brackets brackets = new Brackets();

		for(int i = 0; i < line.length(); i++)
		{
			char ch = line.charAt(i);
			if(ch == openBracket)
			{
				
				if(line.length() - i >= 3)
				{
					if(line.substring(i,i+3).equals(""{{{"")) 
					{
						i += 2;
						continue;
					}
				}
				brackets.openCount++;
			}
			else if(ch == closeBracket)
			{
				if(brackets.openCount != 0)
					brackets.openCount--;
				else
					brackets.closeCount++;
			}
		}

		return brackets;
	} 

	
	public Brackets getBrackets(JEditBuffer buffer, int lineIndex)
	{
		return getBrackets(buffer, lineIndex,
			0, buffer.getLineLength(lineIndex));
	} 

	
	public Brackets getBrackets(JEditBuffer buffer, int lineIndex,
		int begin, int end)
	{
		LineScanner scanner = new LineScanner(begin, end);
		buffer.markTokens(lineIndex, scanner);
		return scanner.result;
	} 

	
	public String toString()
	{
		return getClass().getName() + ""["" + openBracket + "",""
			+ closeBracket + ""]"";
	} 

	protected char openBracket, closeBracket;

	
	private class LineScanner implements TokenHandler
	{
		public final Brackets result;

		private int scannedIndex;
		private final int beginIndex;
		private final int endIndex;

		public LineScanner(int begin, int end)
		{
			this.result = new Brackets();
			this.scannedIndex = 0;
			this.beginIndex = begin;
			this.endIndex = end;
		}

		boolean rejectsToken(byte id)
		{
			
			
			switch (id)
			{
			case Token.COMMENT1:
			case Token.COMMENT2:
			case Token.COMMENT3:
			case Token.COMMENT4:
			case Token.LITERAL1:
			case Token.LITERAL2:
			case Token.LITERAL3:
			case Token.LITERAL4:
				return true;
			default:
				return false;
			}
		}

		private void scan(Segment seg, int offset, int length)
		{
			int index = scannedIndex;
			if (index >= endIndex)
			{
				return;
			}
			if (index < beginIndex)
			{
				int numToSkip = beginIndex - index;
				if (numToSkip >= length)
				{
					return;
				}
				offset += numToSkip;
				length -= numToSkip;
				index = beginIndex;
			}
			if (index + length > endIndex)
			{
				length = endIndex - index;
			}

			for (int i = 0; i < length; ++i)
			{
				char c = seg.array[seg.offset + offset + i];
				if(c == openBracket)
				{
					result.openCount++;
				}
				else if(c == closeBracket)
				{
					if(result.openCount != 0)
						result.openCount--;
					else
						result.closeCount++;
				}
			}
		}

		public void handleToken(Segment seg
			, byte id, int offset, int length
			, TokenMarker.LineContext context)
		{
			if (!rejectsToken(id))
			{
				scan(seg, offset, length);
			}
			scannedIndex += length;
		}

		public void setLineContext(TokenMarker.LineContext lineContext)
		{
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.options.GlobalOptions,8,8,0,12,20,28,3,9,5,2.0,146,0.0,0,0.994074074,0.46875,1,3,17.25,1,0.5,0,"

package org.gjt.sp.jedit.options;


import java.awt.Dialog;
import java.awt.Frame;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.msg.PropertiesChanging;
import org.gjt.sp.jedit.*;


public class GlobalOptions extends OptionsDialog
{
	
	public GlobalOptions(Frame frame)
	{
		super(frame,""options"",jEdit.getProperty(""options.last""));
	} 

	
	public GlobalOptions(Frame frame, String pane)
	{
		super(frame,""options"",pane);
	} 

	
	public GlobalOptions(Dialog dialog)
	{
		super(dialog,""options"",jEdit.getProperty(""options.last""));
	} 

	
	public GlobalOptions(Dialog dialog, String pane)
	{
		super(dialog,""options"",pane);
	} 

	
	protected OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();

		
		OptionGroup jEditGroup = new OptionGroup(""jedit"");

		jEditGroup.addOptionPane(""general"");
		jEditGroup.addOptionPane(""abbrevs"");
		jEditGroup.addOptionPane(""appearance"");
		jEditGroup.addOptionPane(""context"");
		jEditGroup.addOptionPane(""docking"");
		jEditGroup.addOptionPane(""editing"");
		jEditGroup.addOptionPane(""encodings"");
		jEditGroup.addOptionPane(""gutter"");
		jEditGroup.addOptionPane(""mouse"");
		jEditGroup.addOptionPane(""plugin-manager"");
		jEditGroup.addOptionPane(""print"");
		jEditGroup.addOptionPane(""firewall"");
		jEditGroup.addOptionPane(""save-back"");
		jEditGroup.addOptionPane(""shortcuts"");
		jEditGroup.addOptionPane(""status"");
		jEditGroup.addOptionPane(""syntax"");
		jEditGroup.addOptionPane(""textarea"");
		jEditGroup.addOptionPane(""toolbar"");
		jEditGroup.addOptionPane(""view"");
		rootGroup.addOptionGroup(jEditGroup);

		OptionGroup browserGroup = new OptionGroup(""browser"");
		browserGroup.addOptionPane(""browser.general"");
		browserGroup.addOptionPane(""browser.colors"");
		rootGroup.addOptionGroup(browserGroup);

		return paneTreeModel;
	} 

	
	@Override
	public void cancel()
	{
		EditBus.send(
			new PropertiesChanging(null,
				PropertiesChanging.State.CANCELED));
		super.cancel();
	} 

	
	@Override
	protected void init(String name, String pane)
	{
		EditBus.send(
			new PropertiesChanging(null,
				PropertiesChanging.State.LOADING));
		super.init(name, pane);
	} 

	
	protected OptionGroup getDefaultGroup()
	{
		return null;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.search.SearchMatcher,2,1,2,8,4,1,7,1,2,1.0,11,1.0,1,0.0,0.666666667,0,0,4.0,1,0.5,0,"

package org.gjt.sp.jedit.search;


public abstract class SearchMatcher
{
	public SearchMatcher()
	{
		returnValue = new Match();
	}

	
	public abstract Match nextMatch(CharSequence text, boolean start,
		boolean end, boolean firstTime, boolean reverse);

	protected Match returnValue;

	
	public static class Match
	{
		public int start;
		public int end;
		public String[] substitutions;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.ViewUpdate,5,2,0,10,13,4,8,3,4,0.9,55,0.2,0,0.5,0.5,1,1,9.0,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class ViewUpdate extends EBMessage
{
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object CLOSED = ""CLOSED"";

	
	public static final Object EDIT_PANE_CHANGED = ""EDIT_PANE_CHANGED"";

	
	public static final Object ACTIVATED = ""VIEW_ACTIVATED"";

	
	
	public ViewUpdate(View view, Object what)
	{
		super(view);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public View getView()
	{
		return (View)getSource();
	} 

	
	public String paramString()
	{
		return ""what="" + what + "","" + super.paramString();
	} 

	
	private Object what;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHAllocationExpression,11,2,0,22,57,53,1,21,1,0.8,455,1.0,0,0.653846154,0.409090909,1,1,40.27272727,1,0.8182,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;


class BSHAllocationExpression extends SimpleNode
{
    BSHAllocationExpression(int id) { super(id); }
	private static int innerClassCount = 0;
	
    public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        
        SimpleNode type = (SimpleNode)jjtGetChild(0);

        
        SimpleNode args = (SimpleNode)jjtGetChild(1);

        if ( type instanceof BSHAmbiguousName )
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;

            if (args instanceof BSHArguments)
                return objectAllocation(name, (BSHArguments)args, 
					callstack, interpreter );
            else
                return objectArrayAllocation(name, (BSHArrayDimensions)args, 
					callstack, interpreter );
        }
        else
            return primitiveArrayAllocation((BSHPrimitiveType)type,
                (BSHArrayDimensions)args, callstack, interpreter );
    }

    private Object objectAllocation(
		BSHAmbiguousName nameNode, BSHArguments argumentsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
		NameSpace namespace = callstack.top();

        Object[] args = argumentsNode.getArguments( callstack, interpreter );
        if ( args == null)
            throw new EvalError( ""Null args in new."", this, callstack );

		
        Object obj = nameNode.toObject( 
			callstack, interpreter, false );

		

        obj = nameNode.toObject( 
			callstack, interpreter, true );

        Class type = null;
		if ( obj instanceof ClassIdentifier )
        	type = ((ClassIdentifier)obj).getTargetClass();
		else
			throw new EvalError( 
				""Unknown class: ""+nameNode.text, this, callstack );

		
		boolean hasBody = jjtGetNumChildren() > 2;

		if ( hasBody ) 
		{
        	BSHBlock body = (BSHBlock)jjtGetChild(2);
			if ( type.isInterface() )
				return constructWithInterfaceBody( 
					type, args, body, callstack, interpreter );
			else
				return constructWithClassBody( 
					type, args, body, callstack, interpreter );
		} else
			return constructObject( type, args, callstack );
    }

	private Object constructObject( 
		Class type, Object[] args, CallStack callstack ) 
		throws EvalError
	{
		Object obj;
        try {
            obj = Reflect.constructObject( type, args );
        } catch ( ReflectError e) {
            throw new EvalError(
				""Constructor error: "" + e.getMessage(), this, callstack );
        } catch(InvocationTargetException e) {
			
			Interpreter.debug(""The constructor threw an exception:\n\t"" +
				e.getTargetException());
            throw new TargetError(
				""Object constructor"", e.getTargetException(), 
				this, callstack, true);
        }

		String className = type.getName();
		
		if ( className.indexOf(""$"") == -1 )
			return obj;

		
		
		
		

		
		This ths = callstack.top().getThis( null );
		NameSpace instanceNameSpace = 
			Name.getClassNameSpace( ths.getNameSpace() );
		
		
		
		
		
		if ( instanceNameSpace != null 
			&& className.startsWith( instanceNameSpace.getName() +""$"") 
		)
		{
			try {
				ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(
					obj, className, instanceNameSpace );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack );
			}
		}

		return obj;
	}

	private Object constructWithClassBody( 
		Class type, Object[] args, BSHBlock block,
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		String name = callstack.top().getName() + ""$"" + (++innerClassCount);
		Modifiers modifiers = new Modifiers();
		modifiers.addModifier( Modifiers.CLASS, ""public"" );
		Class clas;
		try {
			clas = ClassGenerator.getClassGenerator() .generateClass( 
				name, modifiers, null, type, 
				block, false, callstack, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
		try {
			return Reflect.constructObject( clas, args );
		} catch ( Exception e ) {
			if ( e instanceof InvocationTargetException )
				e = (Exception)((InvocationTargetException)e)
					.getTargetException();
			throw new EvalError(
				""Error constructing inner class instance: ""+e, this, callstack
			);
		}
	}

	private Object constructWithInterfaceBody( 
		Class type, Object[] args, BSHBlock body,
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		NameSpace local = new NameSpace(namespace, ""AnonymousBlock"");
		callstack.push(local);
		body.eval( callstack, interpreter, true );
		callstack.pop();
		
		
		local.importStatic( type );
		try {
			return local.getThis(interpreter).getInterface( type );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}

    private Object objectArrayAllocation(
		BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class type = nameNode.toClass( callstack, interpreter );
        if ( type == null )
            throw new EvalError( ""Class "" + nameNode.getName(namespace) 
				+ "" not found."", this, callstack );

		return arrayAllocation( dimensionsNode, type, callstack, interpreter );
    }

    private Object primitiveArrayAllocation(
		BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
        Class type = typeNode.getType();

		return arrayAllocation( dimensionsNode, type, callstack, interpreter );
    }

	private Object arrayAllocation( 
		BSHArrayDimensions dimensionsNode, Class type, 
		CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		
        Object result = dimensionsNode.eval( type, callstack, interpreter );
        if ( result != Primitive.VOID )
            return result;
		else
			return arrayNewInstance( type, dimensionsNode, callstack );
	}

	
	private Object arrayNewInstance( 
		Class type, BSHArrayDimensions dimensionsNode, CallStack callstack )
		throws EvalError
	{
		if ( dimensionsNode.numUndefinedDims > 0 )
		{
            Object proto = Array.newInstance( 
				type, new int [dimensionsNode.numUndefinedDims] ); 
			type = proto.getClass();
		}

        try {
            return Array.newInstance( 
				type, dimensionsNode.definedDimensions);
        } catch( NegativeArraySizeException e1 ) {
			throw new TargetError( e1, this, callstack );
        } catch( Exception e ) {
            throw new EvalError(""Can't construct primitive array: "" +
                e.getMessage(), this, callstack);
        }
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.TipOfTheDay,8,7,0,6,60,20,2,6,3,0.8,295,1.0,0,0.989441931,0.375,2,5,35.25,5,1.375,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import java.util.Random;

import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class TipOfTheDay extends EnhancedDialog
{
	
	public TipOfTheDay(View view)
	{
		super(view,jEdit.getProperty(""tip.title""),false);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(""tip.caption""));
		label.setFont(new Font(""SansSerif"",Font.PLAIN,24));
		label.setForeground(UIManager.getColor(""Button.foreground""));
		content.add(BorderLayout.NORTH,label);

		tipText = new JEditorPane();
		tipText.setEditable(false);
		tipText.setContentType(""text/html"");

		nextTip();

		JScrollPane scroller = new JScrollPane(tipText);
		scroller.setPreferredSize(new Dimension(150,150));
		content.add(BorderLayout.CENTER,scroller);

		ActionHandler actionHandler = new ActionHandler();

		Box buttons = new Box(BoxLayout.X_AXIS);

		showNextTime = new JCheckBox(jEdit.getProperty(""tip.show-next-time""),
			jEdit.getBooleanProperty(""tip.show""));
		showNextTime.addActionListener(actionHandler);
		buttons.add(showNextTime);

		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(Box.createGlue());

		nextTip = new JButton(jEdit.getProperty(""tip.next-tip""));
		nextTip.addActionListener(actionHandler);
		buttons.add(nextTip);

		buttons.add(Box.createHorizontalStrut(6));

		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(actionHandler);
		buttons.add(close);
		content.getRootPane().setDefaultButton(close);

		Dimension dim = nextTip.getPreferredSize();
		dim.width = Math.max(dim.width,close.getPreferredSize().width);
		nextTip.setPreferredSize(dim);
		close.setPreferredSize(dim);

		content.add(BorderLayout.SOUTH,buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	

	
	private JCheckBox showNextTime;
	private JButton nextTip, close;
	private JEditorPane tipText;
	private int currentTip = -1;
	

	
	private void nextTip()
	{
		File[] tips = new File(MiscUtilities.constructPath(
			jEdit.getJEditHome(),""doc"",""tips"")).listFiles();
		if(tips == null || tips.length == 0)
		{
			tipText.setText(jEdit.getProperty(""tip.not-found""));
			return;
		}

		int count = tips.length;

		
		
		int tipToShow = currentTip;
		while(tipToShow == currentTip || !tips[tipToShow].getName().endsWith("".html""))
			tipToShow = (new Random().nextInt(Integer.MAX_VALUE)) % count;
		try
		{
			tipText.setPage(tips[tipToShow].toURI().toURL());
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == showNextTime)
			{
				jEdit.setBooleanProperty(""tip.show"",showNextTime
					.isSelected());
			}
			else if(source == nextTip)
				nextTip();
			else if(source == close)
				dispose();
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.OperatingSystem,19,1,0,31,50,91,30,1,18,0.949074074,458,1.0,0,0.0,0.055555556,0,0,22.47368421,7,2.4211,0,"

package org.gjt.sp.jedit;

import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.Toolkit;
import javax.swing.UIManager;
import java.io.File;
import java.util.Set;
import java.util.HashSet;

import org.gjt.sp.util.Log;


public class OperatingSystem
{
	
	
	public static Rectangle getScreenBounds()
	{
		int screenX = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();
		int screenY = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();
		int x, y, w, h;
		
		if (isMacOS())
		{
			x = 0;
			y = 22;
			w = screenX;
			h = screenY - y - 4;
		}
		else if (isWindows())
		{
			x = -4;
			y = -4;
			w = screenX - 2*x;
			h = screenY - 2*y;
		}
		else
		{
			x = 0;
			y = 0;
			w = screenX;
			h = screenY;
		}
		
		return new Rectangle(x,y,w,h);
	} 

	
	
	public static Rectangle getScreenBounds(Rectangle window)
	{
		GraphicsDevice[] gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();
		Set<GraphicsConfiguration> intersects = new HashSet<GraphicsConfiguration>();

		
		
		
		for (int i=0; i < gd.length; i++)
		{
			GraphicsConfiguration gc = gd[i]
				.getDefaultConfiguration();
			
			if (window.intersects(gc.getBounds()))
			{
				if (!intersects.contains(gc))
					intersects.add(gc);
			}
		}
		
		GraphicsConfiguration choice = null;
		if (!intersects.isEmpty())
		{
			
			for (GraphicsConfiguration gcc : intersects)
			{
				if (choice == null)
					choice = gcc;
				else
				{
					Rectangle int1 = choice.getBounds().intersection(window);
					Rectangle int2 = gcc.getBounds().intersection(window);
					int area1 = int1.width * int1.height;
					int area2 = int2.width * int2.height;
					if (area2 > area1)
						choice = gcc;
				}
			}
		}
		else
			choice = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();
		
		
		int screenX = choice.getBounds().x;
		int screenY = choice.getBounds().y;
		int screenW = choice.getBounds().width;
		int screenH = choice.getBounds().height;
		int x, y, w, h;
		
		if (isMacOS())
		{
			x = screenX;
			y = screenY + 22;
			w = screenW;
			h = screenH - y - 4;
		}
		else
		{
			x = screenX;
			y = screenY;
			w = screenW;
			h = screenH;
		}
		
		
		return new Rectangle(x,y,w,h);
	} 

	
	
	public static boolean isDOSDerived()
	{
		return isWindows() || isOS2();
	} 

	
	
	public static boolean isWindows()
	{
		return os == WINDOWS_9x || os == WINDOWS_NT;
	} 

	
	
	public static boolean isWindows9x()
	{
		return os == WINDOWS_9x;
	} 

	
	
	public static boolean isWindowsNT()
	{
		return os == WINDOWS_NT;
	} 

	
	
	public static boolean isOS2()
	{
		return os == OS2;
	} 

	
	
	public static boolean isUnix()
	{
		return os == UNIX || os == MAC_OS_X;
	} 

	
	
	public static boolean isMacOS()
	{
		return os == MAC_OS_X;
	} 

	
	
	public static boolean isX11()
	{
		return os == UNIX;
	} 

	
	
	public static boolean isVMS()
	{
		return os == VMS;
	} 

	
	
	public static boolean isMacOSLF()
	{
		return isMacOS() && UIManager.getLookAndFeel().isNativeLookAndFeel();
	} 

	
	
	public static boolean hasScreenMenuBar()
	{
		if(!isMacOS())
			return false;
		else if(hasScreenMenuBar == -1)
		{
			String result = System.getProperty(""apple.laf.useScreenMenuBar"");
			if (result == null)
				result = System.getProperty(""com.apple.macos.useScreenMenuBar"");
			hasScreenMenuBar = ""true"".equals(result) ? 1 : 0;
		}

		return hasScreenMenuBar == 1;
	} 

	
	
	@Deprecated
	public static boolean hasJava14()
	{
		
		
		
		return java14;
	} 

	
	
	@Deprecated
	public static boolean hasJava15()
	{
		return java15;
	} 

	
	
	public static boolean hasJava16()
	{
		return java16;
	} 

	
	
	public static boolean isCaseInsensitiveFS()
	{
		return isDOSDerived() || isMacOS();
	} 
	
	
	private static final int UNIX = 0x31337;
	private static final int WINDOWS_9x = 0x640;
	private static final int WINDOWS_NT = 0x666;
	private static final int OS2 = 0xDEAD;
	private static final int MAC_OS_X = 0xABC;
	private static final int VMS = 0xDEAD2;
	private static final int UNKNOWN = 0xBAD;

	private static int os;
	private static boolean java14;
	private static boolean java15;
	private static boolean java16;
	private static int hasScreenMenuBar = -1;

	
	static
	{
		if(System.getProperty(""mrj.version"") != null)
		{
			os = MAC_OS_X;
		}
		else
		{
			String osName = System.getProperty(""os.name"");
			if(osName.contains(""Windows 9"")
				|| osName.contains(""Windows M""))
			{
				os = WINDOWS_9x;
			}
			else if(osName.contains(""Windows""))
			{
				os = WINDOWS_NT;
			}
			else if(osName.contains(""OS/2""))
			{
				os = OS2;
			}
			else if(osName.contains(""VMS""))
			{
				os = VMS;
			}
			else if(File.separatorChar == '/')
			{
				os = UNIX;
			}
			else
			{
				os = UNKNOWN;
				Log.log(Log.WARNING,OperatingSystem.class,
					""Unknown operating system: "" + osName);
			}
		}

		
		
		String javaVersion = System.getProperty(""jedit.force.java.version"");
		if(javaVersion == null || javaVersion.length() == 0)
			javaVersion = System.getProperty(""java.version"");
		if(javaVersion == null || javaVersion.length() == 0)
			javaVersion = System.getProperty(""java.runtime.version"");
		java14 = javaVersion.compareTo(""1.4"") >= 0;
		java15 = javaVersion.compareTo(""1.5"") >= 0;
		java16 = javaVersion.compareTo(""1.6"") >= 0;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.EditorExitRequested,4,2,0,4,6,4,1,3,4,0.666666667,20,1.0,0,0.5,0.625,0,0,3.75,1,0.75,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.View;


public class EditorExitRequested extends EBMessage
{
	private boolean hasBeenExitCancelled;
	
	
	public EditorExitRequested(View view)
	{
		super(view);
	}

	
	public View getView()
	{
		return (View)getSource();
	}
	
	
	public void cancelExit()
	{
		hasBeenExitCancelled = true;
	}
	
	 
	 public boolean hasBeenExitCancelled()
	 {
		 return hasBeenExitCancelled;
	 }
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.BrowserIORequest,7,2,0,10,29,0,2,9,2,0.621212121,615,0.636363636,2,0.5,0.265306122,0,0,85.28571429,8,3.5714,0,"

package org.gjt.sp.jedit.browser;


import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



class BrowserIORequest extends WorkRequest
{
	
	
	public static final int LIST_DIRECTORY = 0;

	
	public static final int DELETE = 1;

	
	public static final int RENAME = 2;

	
	public static final int MKDIR = 3;
	

	
	
	BrowserIORequest(int type, VFSBrowser browser,
		Object session, VFS vfs, String path1, String path2,
		Object[] loadInfo)
	{
		this.type = type;
		this.browser = browser;
		this.session = session;
		this.vfs = vfs;
		this.path1 = path1;
		this.path2 = path2;
		this.loadInfo = loadInfo;
	} 

	
	public void run()
	{
		switch(type)
		{
		case LIST_DIRECTORY:
			listDirectory();
			break;
		case DELETE:
			delete();
			break;
		case RENAME:
			rename();
			break;
		case MKDIR:
			mkdir();
			break;
		}
	} 

	
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LIST_DIRECTORY:
			typeString = ""LIST_DIRECTORY"";
			break;
		case DELETE:
			typeString = ""DELETE"";
			break;
		case RENAME:
			typeString = ""RENAME"";
			break;
		case MKDIR:
			typeString = ""MKDIR"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
			break;
		}

		return getClass().getName() + ""[type="" + typeString
			+ "",vfs="" + vfs + "",path1="" + path1
			+ "",path2="" + path2 + ""]"";
	} 

	

	
	private int type;
	private VFSBrowser browser;
	private Object session;
	private VFS vfs;
	private String path1;
	private String path2;
	private Object[] loadInfo;
	

	
	private void listDirectory()
	{
		VFSFile[] directory = null;

		String[] args = { path1 };
		setStatus(jEdit.getProperty(""vfs.status.listing-directory"",args));

		String canonPath = path1;

		try
		{
			setAbortable(true);

			canonPath = vfs._canonPath(session,path1,browser);
			directory = vfs._listFiles(session,canonPath,browser);
		}
		catch(IOException io)
		{
			setAbortable(false);
			Log.log(Log.ERROR,this,io);
			String[] pp = { io.toString() };
			VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}

		setAbortable(false);

		loadInfo[0] = canonPath;
		loadInfo[1] = directory;
	} 

	
	private void delete()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.deleting"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);


				if(!vfs._delete(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.delete-error"",null);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} 

	
	private void rename()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1, path2 };
			setStatus(jEdit.getProperty(""vfs.status.renaming"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);
				path2 = vfs._canonPath(session,path2,browser);

				VFSFile file = vfs._getFile(session,path2,browser);
				if(file != null)
				{
					if((OperatingSystem.isCaseInsensitiveFS())
						&& path1.equalsIgnoreCase(path2))
					{
						
						
					}
					else
					{
						VFSManager.error(browser,path1,
							""ioerror.rename-exists"",
							new String[] { path2 });
						return;
					}
				}

				if(!vfs._rename(session,path1,path2,browser))
					VFSManager.error(browser,path1,""ioerror.rename-error"",
						new String[] { path2 });
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} 

	
	private void mkdir()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.mkdir"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);

				if(!vfs._mkdir(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.mkdir-error"",null);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				args[0] = io.toString();
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] args = { io.toString() };
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ColorWellButton,3,6,0,8,14,3,6,3,3,2.0,46,0.0,0,0.997382199,0.833333333,0,0,14.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.OperatingSystem;



public class ColorWellButton extends JButton
{
	
	public ColorWellButton(Color color)
	{
		setIcon(new ColorWell(color));
		setMargin(new Insets(2,2,2,2));
		addActionListener(new ActionHandler());

		
		if(OperatingSystem.isMacOSLF())
			putClientProperty(""JButton.buttonType"",""toolbar"");
	} 

	
	public Color getSelectedColor()
	{
		return ((ColorWell)getIcon()).color;
	} 

	
	public void setSelectedColor(Color color)
	{
		((ColorWell)getIcon()).color = color;
		repaint();
	} 

	
	static class ColorWell implements Icon
	{
		Color color;

		ColorWell(Color color)
		{
			this.color = color;
		}

		public int getIconWidth()
		{
			return 35;
		}

		public int getIconHeight()
		{
			return 10;
		}

		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			if(color == null)
				return;

			g.setColor(color);
			g.fillRect(x,y,getIconWidth(),getIconHeight());
			g.setColor(color.darker());
			g.drawRect(x,y,getIconWidth()-1,getIconHeight()-1);
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			JDialog parent = GUIUtilities.getParentDialog(ColorWellButton.this);
			JDialog dialog;
			if (parent != null)
			{
				dialog = new ColorPickerDialog(parent,
					jEdit.getProperty(""colorChooser.title""),
					true);
			}
			else
			{
				dialog = new ColorPickerDialog(
					JOptionPane.getFrameForComponent(
					ColorWellButton.this),
					jEdit.getProperty(""colorChooser.title""),
					true);
			}
			dialog.pack();
			dialog.setVisible(true);
		}
	} 

	
	
	private class ColorPickerDialog extends EnhancedDialog implements ActionListener
	{
		public ColorPickerDialog(Frame parent, String title, boolean modal)
		{
			super(parent,title,modal);

			init();
		}

		public ColorPickerDialog(Dialog parent, String title, boolean modal)
		{
			super(parent,title,modal);

			getContentPane().setLayout(new BorderLayout());

			init();
		}

		public void ok()
		{
			Color c = chooser.getColor();
			if (c != null)
				setSelectedColor(c);
			setVisible(false);
		}

		public void cancel()
		{
			setVisible(false);
		}

		public void actionPerformed(ActionEvent evt)
		{
			if (evt.getSource() == ok)
				ok();
			else
				cancel();
		}

		
		private JColorChooser chooser;
		private JButton ok;
		private JButton cancel;

		private void init()
		{
			Color c = getSelectedColor();
			if(c == null)
				chooser = new JColorChooser();
			else
				chooser = new JColorChooser(c);

			getContentPane().add(BorderLayout.CENTER, chooser);

			Box buttons = new Box(BoxLayout.X_AXIS);
			buttons.add(Box.createGlue());

			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(this);
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(6));
			getRootPane().setDefaultButton(ok);
			cancel = new JButton(jEdit.getProperty(""common.cancel""));
			cancel.addActionListener(this);
			buttons.add(cancel);
			buttons.add(Box.createGlue());

			getContentPane().add(BorderLayout.SOUTH, buttons);
			pack();
			setLocationRelativeTo(getParent());
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.ScrollListener,2,1,0,3,2,1,3,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;


public interface ScrollListener extends java.util.EventListener
{
	void scrolledVertically(TextArea textArea);
	void scrolledHorizontally(TextArea textArea);
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaMouseHandler,15,3,1,16,87,0,5,12,7,0.664285714,1296,1.0,1,0.363636364,0.4,0,0,84.73333333,25,8.4,0,"
package org.gjt.sp.jedit.textarea;

import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.util.StandardUtilities;

import javax.swing.event.MouseInputAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.InputEvent;
import java.awt.*;


public class TextAreaMouseHandler extends MouseInputAdapter
{
	
	TextAreaMouseHandler(TextArea textArea)
	{
		this.textArea = textArea;
	} 

	
	@Override
	public void mousePressed(MouseEvent evt)
	{
		showCursor();

		control = (OperatingSystem.isMacOS() && evt.isMetaDown())
			|| (!OperatingSystem.isMacOS() && evt.isControlDown());

		ctrlForRectangularSelection = true;

		
		
		textArea.getInputHandler().resetLastActionCount();

		quickCopyDrag = (textArea.isQuickCopyEnabled() &&
			isMiddleButton(evt.getModifiers()));

		if(!quickCopyDrag)
		{
			textArea.requestFocus();
			TextArea.focusedComponent = textArea;
		}

		if(textArea.getBuffer().isLoading())
			return;

		int x = evt.getX();
		int y = evt.getY();

		dragStart = textArea.xyToOffset(x,y,
			!(textArea.getPainter().isBlockCaretEnabled()
			|| textArea.isOverwriteEnabled()));
		dragStartLine = textArea.getLineOfOffset(dragStart);
		dragStartOffset = dragStart - textArea.getLineStartOffset(
			dragStartLine);

		if(isPopupTrigger(evt) && textArea.isRightClickPopupEnabled())
		{
				textArea.handlePopupTrigger(evt);
				return;
		}

		dragged = false;

		textArea.blink = true;
		textArea.invalidateLine(textArea.getCaretLine());

		clickCount = evt.getClickCount();

		if(textArea.isDragEnabled()
			&& textArea.selectionManager.insideSelection(x,y)
			&& clickCount == 1 && !evt.isShiftDown())
		{
			maybeDragAndDrop = true;
			textArea.moveCaretPosition(dragStart,false);
			return;
		}
		maybeDragAndDrop = false;

		if(quickCopyDrag)
		{
			
			doSingleClick(evt);
		}
		else
		{
			switch(clickCount)
			{
			case 1:
				doSingleClick(evt);
				break;
			case 2:
				doDoubleClick();
				break;
			default: 
				doTripleClick();
				break;
			}
		}
	} 

	
	protected void doSingleClick(MouseEvent evt)
	{
		int x = evt.getX();

		int extraEndVirt = 0;
		if(textArea.chunkCache.getLineInfo(
			textArea.getLastScreenLine()).lastSubregion)
		{
			int dragStart = textArea.xyToOffset(x,evt.getY(),
				!textArea.getPainter().isBlockCaretEnabled()
				&& !textArea.isOverwriteEnabled());
			int screenLine = textArea.getScreenLineOfOffset(dragStart);
			ChunkCache.LineInfo lineInfo = textArea.chunkCache.getLineInfo(screenLine);
			int offset = textArea.getScreenLineEndOffset(screenLine);
			if ((1 != offset - dragStart) || (lineInfo.lastSubregion))
			{
				offset--;
			}
			float dragStartLineWidth = textArea.offsetToXY(offset).x;
			if(x > dragStartLineWidth)
			{
				extraEndVirt = (int)(
					(x - dragStartLineWidth)
					/ textArea.charWidth);
				if(!textArea.getPainter().isBlockCaretEnabled()
					&& !textArea.isOverwriteEnabled()
					&& (x - textArea.getHorizontalOffset())
					% textArea.charWidth > textArea.charWidth / 2)
				{
					extraEndVirt++;
				}
			}
		}

		if(((control && ctrlForRectangularSelection) ||
		    textArea.isRectangularSelectionEnabled())
			&& textArea.isEditable())
		{
			int screenLine = (evt.getY() / textArea.getPainter()
				.getFontMetrics().getHeight());
			if(screenLine > textArea.getLastScreenLine())
				screenLine = textArea.getLastScreenLine();
			ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(screenLine);
			if(info.lastSubregion && extraEndVirt != 0)
			{
				
				
				String whitespace = StandardUtilities
					.createWhiteSpace(extraEndVirt,0);
				textArea.getBuffer().insert(dragStart,whitespace);

				dragStart += whitespace.length();
			}
		}

		if(evt.isShiftDown())
		{
			
			textArea.resizeSelection(
				textArea.getMarkPosition(),dragStart,extraEndVirt,
				textArea.isRectangularSelectionEnabled()
				|| (control && ctrlForRectangularSelection));

			if(!quickCopyDrag)
				textArea.moveCaretPosition(dragStart,false);

			
			dragStartLine = textArea.getMarkLine();
			dragStart = textArea.getMarkPosition();
			dragStartOffset = dragStart
				- textArea.getLineStartOffset(dragStartLine);

			
			dragged = true;

			return;
		}

		if(!quickCopyDrag)
			textArea.moveCaretPosition(dragStart,false);

		if(!(textArea.isMultipleSelectionEnabled()
			|| quickCopyDrag))
			textArea.selectNone();
	} 

	
	protected void doDoubleClick()
	{
		
		if(textArea.getLineLength(dragStartLine) == 0)
			return;

		String lineText = textArea.getLineText(dragStartLine);
		String noWordSep = textArea.getBuffer()
			.getStringProperty(""noWordSep"");
		if(dragStartOffset == textArea.getLineLength(dragStartLine))
			dragStartOffset--;

		boolean joinNonWordChars = textArea.getJoinNonWordChars();
		int wordStart = TextUtilities.findWordStart(lineText,dragStartOffset,
			noWordSep,joinNonWordChars,false,false);
		int wordEnd = TextUtilities.findWordEnd(lineText,
			dragStartOffset+1,noWordSep,
			joinNonWordChars,false,false);

		int lineStart = textArea.getLineStartOffset(dragStartLine);
		Selection sel = new Selection.Range(
			lineStart + wordStart,
			lineStart + wordEnd);
		if(textArea.isMultipleSelectionEnabled())
			textArea.addToSelection(sel);
		else
			textArea.setSelection(sel);

		if(quickCopyDrag)
			quickCopyDrag = false;

		textArea.moveCaretPosition(lineStart + wordEnd,false);

		dragged = true;
	} 

	
	protected void doTripleClick()
	{
		int newCaret = textArea.getLineEndOffset(dragStartLine);
		if(dragStartLine == textArea.getLineCount() - 1)
			newCaret--;

		Selection sel = new Selection.Range(
			textArea.getLineStartOffset(dragStartLine),
			newCaret);
		if(textArea.isMultipleSelectionEnabled())
			textArea.addToSelection(sel);
		else
			textArea.setSelection(sel);

		if(quickCopyDrag)
			quickCopyDrag = false;

		textArea.moveCaretPosition(newCaret,false);

		dragged = true;
	} 

	
	@Override
	public void mouseMoved(MouseEvent evt)
	{
		showCursor();
	} 

	
	@Override
	public void mouseDragged(MouseEvent evt)
	{
		if (isPopupTrigger(evt))
			return;

		if(maybeDragAndDrop)
		{
			textArea.startDragAndDrop(evt,control);
			return;
		}

		if(textArea.isDragInProgress())
			return;

		if(textArea.getBuffer().isLoading())
			return;

		TextAreaPainter painter = textArea.getPainter();
		if(evt.getY() < 0)
		{
			int delta = Math.min(-1,evt.getY()
				/ painter.getFontMetrics()
				.getHeight());
			textArea.setFirstLine(textArea.getFirstLine() + delta);
		}
		else if(evt.getY() >= painter.getHeight())
		{
			int delta = Math.max(1,(evt.getY()
				- painter.getHeight()) /
				painter.getFontMetrics()
				.getHeight());
			if(textArea.lastLinePartial)
				delta--;
			textArea.setFirstLine(textArea.getFirstLine() + delta);
		}

		switch(clickCount)
		{
		case 1:
			doSingleDrag(evt);
			break;
		case 2:
			doDoubleDrag(evt);
			break;
		default: 
			doTripleDrag(evt);
			break;
		}
	} 

	
	private void doSingleDrag(MouseEvent evt)
	{
		dragged = true;

		TextAreaPainter painter = textArea.getPainter();

		int x = evt.getX();
		int y = evt.getY();
		if(y < 0)
			y = 0;
		else if(y >= painter.getHeight())
			y = painter.getHeight() - 1;

		int dot = textArea.xyToOffset(x,y,
			(!painter.isBlockCaretEnabled()
			&& !textArea.isOverwriteEnabled())
			|| quickCopyDrag);
		int dotLine = textArea.getLineOfOffset(dot);
		int extraEndVirt = 0;

		if(textArea.chunkCache.getLineInfo(
			textArea.getLastScreenLine())
			.lastSubregion)
		{
			int screenLine = textArea.getScreenLineOfOffset(dot);
			ChunkCache.LineInfo lineInfo = textArea.chunkCache.getLineInfo(screenLine);
			int offset = textArea.getScreenLineEndOffset(screenLine);
			if ((1 != offset - dot) || (lineInfo.lastSubregion))
			{
				offset--;
			}
			float dotLineWidth = textArea.offsetToXY(offset).x;
			if(x > dotLineWidth)
			{
				extraEndVirt = (int)((x - dotLineWidth) / textArea.charWidth);
				if(!painter.isBlockCaretEnabled()
					&& !textArea.isOverwriteEnabled()
					&& (x - textArea.getHorizontalOffset()) % textArea.charWidth > textArea.charWidth / 2)
					extraEndVirt++;
			}
		}

		textArea.resizeSelection(dragStart,dot,extraEndVirt,
			textArea.isRectangularSelectionEnabled()
			|| (control && ctrlForRectangularSelection));

		if(quickCopyDrag)
		{
			
			textArea.scrollTo(dotLine,dot - textArea.getLineStartOffset(dotLine),false);
		}
		else
		{
			if(dot != textArea.getCaretPosition())
				textArea.moveCaretPosition(dot,false);
			if(textArea.isRectangularSelectionEnabled()
				&& extraEndVirt != 0)
			{
				textArea.scrollTo(dotLine,dot - textArea.getLineStartOffset(dotLine)
					+ extraEndVirt,false);
			}
		}
	} 

	
	private void doDoubleDrag(MouseEvent evt)
	{
		int markLineStart = textArea.getLineStartOffset(dragStartLine);
		int markLineLength = textArea.getLineLength(dragStartLine);
		int mark = dragStartOffset;

		TextAreaPainter painter = textArea.getPainter();

		int pos = textArea.xyToOffset(evt.getX(),
			Math.max(0,Math.min(painter.getHeight(),evt.getY())),
			!(painter.isBlockCaretEnabled()
			|| textArea.isOverwriteEnabled()));
		int line = textArea.getLineOfOffset(pos);
		int lineStart = textArea.getLineStartOffset(line);
		int lineLength = textArea.getLineLength(line);
		int offset = pos - lineStart;

		String lineText = textArea.getLineText(line);
		String markLineText = textArea.getLineText(dragStartLine);
		String noWordSep = textArea.getBuffer()
			.getStringProperty(""noWordSep"");
		boolean joinNonWordChars = textArea.getJoinNonWordChars();

		if(markLineStart + dragStartOffset > lineStart + offset)
		{
			if(offset != 0 && offset != lineLength)
			{
				offset = TextUtilities.findWordStart(
					lineText,offset,noWordSep,
					joinNonWordChars);
			}

			if(markLineLength != 0)
			{
				mark = TextUtilities.findWordEnd(
					markLineText,mark,noWordSep,
					joinNonWordChars);
			}
		}
		else
		{
			if(offset != 0 && lineLength != 0)
			{
				offset = TextUtilities.findWordEnd(
					lineText,offset,noWordSep,
					joinNonWordChars);
			}

			if(mark != 0 && mark != markLineLength)
			{
				mark = TextUtilities.findWordStart(
					markLineText,mark,noWordSep,
					joinNonWordChars);
			}
		}

		if(lineStart + offset == textArea.getCaretPosition())
			return;

		textArea.resizeSelection(markLineStart + mark,
			lineStart + offset,0,false);
		textArea.moveCaretPosition(lineStart + offset,false);

		dragged = true;
	} 

	
	private void doTripleDrag(MouseEvent evt)
	{
		TextAreaPainter painter = textArea.getPainter();

		int offset = textArea.xyToOffset(evt.getX(),
			Math.max(0,Math.min(painter.getHeight(),evt.getY())),
			false);
		int mouseLine = textArea.getLineOfOffset(offset);
		int mark;
		int mouse;
		if(dragStartLine > mouseLine)
		{
			mark = textArea.getLineEndOffset(dragStartLine) - 1;
			if(offset == textArea.getLineEndOffset(mouseLine) - 1)
				mouse = offset;
			else
				mouse = textArea.getLineStartOffset(mouseLine);
		}
		else
		{
			mark = textArea.getLineStartOffset(dragStartLine);
			if(offset == textArea.getLineStartOffset(mouseLine))
				mouse = offset;
			else if(offset == textArea.getLineEndOffset(mouseLine) - 1
				&& mouseLine != textArea.getLineCount() - 1)
				mouse = textArea.getLineEndOffset(mouseLine);
			else
				mouse = textArea.getLineEndOffset(mouseLine) - 1;
		}

		mouse = Math.min(textArea.getBuffer().getLength(),mouse);

		if(mouse == textArea.getCaretPosition())
			return;

		textArea.resizeSelection(mark,mouse,0,false);
		textArea.moveCaretPosition(mouse,false);

		dragged = true;
	} 

	
	@Override
	public void mouseReleased(MouseEvent evt)
	{
		if(!dragged && textArea.isQuickCopyEnabled() &&
			isMiddleButton(evt.getModifiers()))
		{
			textArea.requestFocus();
			TextArea.focusedComponent = textArea;

			textArea.setCaretPosition(dragStart,false);
		}
		else if(maybeDragAndDrop
			&& !textArea.isMultipleSelectionEnabled())
		{
			textArea.selectNone();
		}

		dragged = false;
	} 

	
	
	public static boolean isPopupTrigger(MouseEvent evt)
	{
		return isRightButton(evt.getModifiers());
	} 

	
	
	public static boolean isMiddleButton(int modifiers)
	{
		if (OperatingSystem.isMacOS())
		{
			if((modifiers & InputEvent.BUTTON1_MASK) != 0)
				return (modifiers & InputEvent.ALT_MASK) != 0;
			else
				return (modifiers & InputEvent.BUTTON2_MASK) != 0;
		}
		else
			return (modifiers & InputEvent.BUTTON2_MASK) != 0;
	} 

	
	
	public static boolean isRightButton(int modifiers)
	{
		if (OperatingSystem.isMacOS())
		{
			if((modifiers & InputEvent.BUTTON1_MASK) != 0)
				return (modifiers & InputEvent.CTRL_MASK) != 0;
			else
				return (modifiers & InputEvent.BUTTON3_MASK) != 0;
		}
		else
			return (modifiers & InputEvent.BUTTON3_MASK) != 0;
	} 

	
	protected final TextArea textArea;
	protected int dragStartLine;
	protected int dragStartOffset;
	protected int dragStart;
	protected int clickCount;
	protected boolean dragged;
	protected boolean quickCopyDrag;
	protected boolean control;
	protected boolean ctrlForRectangularSelection;
	
	protected boolean maybeDragAndDrop;

	
	protected void showCursor()
	{
		textArea.getPainter().setCursor(
			Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHTernaryExpression,2,2,0,7,6,1,1,6,1,2.0,36,0.0,0,0.944444444,0.625,1,1,17.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;


class BSHTernaryExpression extends SimpleNode {

    BSHTernaryExpression(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        SimpleNode
			cond = (SimpleNode)jjtGetChild(0),
			evalTrue = (SimpleNode)jjtGetChild(1),
			evalFalse = (SimpleNode)jjtGetChild(2);

		if ( BSHIfStatement.evaluateCondition( cond, callstack, interpreter ) )
			return evalTrue.eval( callstack, interpreter );
		else
			return evalFalse.eval( callstack, interpreter );
    }

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHBinaryExpression,4,2,0,11,20,6,1,10,1,1.0,290,0.0,0,0.85,0.45,1,1,71.25,4,2.25,0,"


package org.gjt.sp.jedit.bsh;


class BSHBinaryExpression extends SimpleNode 
	implements ParserConstants 
{
    public int kind;

    BSHBinaryExpression(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        Object lhs = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);

		
        if (kind == INSTANCEOF)
        {
			
			if ( lhs == Primitive.NULL )
				return new Primitive(false);

            Class rhs = ((BSHType)jjtGetChild(1)).getType( 
				callstack, interpreter );
		
			
			if ( lhs instanceof Primitive )
				if ( rhs == org.gjt.sp.jedit.bsh.Primitive.class )
					return new Primitive(true);
				else
					return new Primitive(false);

			
            boolean ret = Types.isJavaBaseAssignable( rhs, lhs.getClass() );
            return new Primitive(ret);
        }


		
		

		
		if ( kind == BOOL_AND || kind == BOOL_ANDX ) {
			Object obj = lhs;
			if ( isPrimitiveValue(lhs) )
				obj = ((Primitive)lhs).getValue();
			if ( obj instanceof Boolean && 
				( ((Boolean)obj).booleanValue() == false ) )
				return new Primitive(false);
		}
		
		if ( kind == BOOL_OR || kind == BOOL_ORX ) {
			Object obj = lhs;
			if ( isPrimitiveValue(lhs) )
				obj = ((Primitive)lhs).getValue();
			if ( obj instanceof Boolean && 
				( ((Boolean)obj).booleanValue() == true ) )
				return new Primitive(true);
		}

		

		
		boolean isLhsWrapper = isWrapper( lhs );
        Object rhs = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
		boolean isRhsWrapper = isWrapper( rhs );
		if ( 
			( isLhsWrapper || isPrimitiveValue( lhs ) )
			&& ( isRhsWrapper || isPrimitiveValue( rhs ) )
		)
        {
			
			if ( (isLhsWrapper && isRhsWrapper && kind == EQ)) 
			{
				
			} else
				try {
					return Primitive.binaryOperation(lhs, rhs, kind);
				} catch ( UtilEvalError e ) {
					throw e.toEvalError( this, callstack  );
				}
        }
	

		
		
        switch(kind)
        {
            case EQ:
                return new Primitive((lhs == rhs));

            case NE:
                return new Primitive((lhs != rhs));

            case PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();

            

            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )
                        throw new EvalError(
				""illegal use of undefined variable, class, or 'void' literal"", 
							this, callstack );
                    else 
					if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                        throw new EvalError(
				""illegal use of null value or 'null' literal"", this, callstack);

                throw new EvalError(""Operator: '"" + tokenImage[kind] +
                    ""' inappropriate for objects"", this, callstack );
        }
    }

	
	private boolean isPrimitiveValue( Object obj ) {
        return ( (obj instanceof Primitive) 
			&& (obj != Primitive.VOID) && (obj != Primitive.NULL) );
	}

	
	private boolean isWrapper( Object obj ) {
        return ( obj instanceof Boolean || 
			obj instanceof Character || obj instanceof Number );
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.ActionListHandler,10,2,0,4,29,17,1,4,6,0.728395062,278,1.0,1,0.653846154,0.3,1,3,25.9,10,2.5,0,"

package org.gjt.sp.jedit;


import java.util.Stack;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;



class ActionListHandler extends DefaultHandler
{
	
	ActionListHandler(String path, JEditActionSet actionSet)
	{
		this.path = path;
		this.actionSet = actionSet;
		stateStack = new Stack<String>();
		code = new StringBuilder();
		isSelected = new StringBuilder();
	} 

	
	@Override
	public InputSource resolveEntity(String publicId, String systemId)
	{
		return XMLUtilities.findEntity(systemId, ""actions.dtd"", getClass());
	} 

	
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();

		if(aname == ""NAME"")
			actionName = value;
		else if(aname == ""NO_REPEAT"")
			noRepeat = (value == ""TRUE"");
		else if(aname == ""NO_RECORD"")
			noRecord = (value == ""TRUE"");
		else if(aname == ""NO_REMEMBER_LAST"")
			noRememberLast = (value == ""TRUE"");
	} 

	
	@Override
	public void characters(char[] c, int off, int len)
	{
		String tag = peekElement();
		if (tag.equals(""CODE""))
		{
			code.append(c, off, len);
		}
		else if (tag.equals(""IS_SELECTED""))
		{
			isSelected.append(c, off, len);
		}
	} 

	
	@Override
	public void startElement(String uri, String localName,
				 String qName, Attributes attrs)
	{
		String tag = pushElement(qName);

		if (tag.equals(""ACTION""))
		{
			actionName = attrs.getValue(""NAME"");
			noRepeat = ""TRUE"".equals(attrs.getValue(""NO_REPEAT""));
			noRecord = ""TRUE"".equals(attrs.getValue(""NO_RECORD""));
			noRememberLast = ""TRUE"".equals(attrs.getValue(""NO_REMEMBER_LAST""));
			code.setLength(0);
			isSelected.setLength(0);
		}
	} 

	
	@Override
	public void endElement(String uri, String localName, String qName)
	{
		String tag = peekElement();

		if (qName.equals(tag))
		{
			if (tag.equals(""ACTION""))
			{
				String selected = (isSelected.length() > 0) ?
					isSelected.toString() : null;
				JEditAbstractEditAction action = 
					actionSet.createBeanShellAction(actionName,
									code.toString(),
									selected,
									noRepeat,
									noRecord,
									noRememberLast);
				actionSet.addAction(action);
				noRepeat = noRecord = noRememberLast = false;
				code.setLength(0);
				isSelected.setLength(0);
			}

			popElement();
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	@Override
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR,this, e);
		}
	} 

	

	
	private String path;
	private JEditActionSet actionSet;

	private String actionName;
	private final StringBuilder code;
	private final StringBuilder isSelected;

	private boolean noRepeat;
	private boolean noRecord;
	private boolean noRememberLast;

	private final Stack<String> stateStack;
	

	
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	} 

	
	private String peekElement()
	{
		return stateStack.peek();
	} 

	
	private String popElement()
	{
		return stateStack.pop();
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHEnhancedForStatement,2,2,0,16,25,1,1,15,1,1.0,179,0.0,0,0.944444444,0.625,1,1,88.0,4,2.0,0,"package org.gjt.sp.jedit.bsh;




class BSHEnhancedForStatement extends SimpleNode implements ParserConstants 
{
	String varName;

    BSHEnhancedForStatement(int id) { super(id); }

    public Object eval( CallStack callstack , Interpreter interpreter )
		throws EvalError 
	{
		Class elementType = null;
		SimpleNode expression, statement=null;

		NameSpace enclosingNameSpace = callstack.top();
		SimpleNode firstNode =((SimpleNode)jjtGetChild(0));
		int nodeCount = jjtGetNumChildren();
		
		if ( firstNode instanceof BSHType ) 
		{
			elementType=((BSHType)firstNode).getType( callstack, interpreter );
			expression=((SimpleNode)jjtGetChild(1));
			if ( nodeCount>2 )
				statement=((SimpleNode)jjtGetChild(2));
		} else 
		{
			expression=firstNode;
			if ( nodeCount>1 )
				statement=((SimpleNode)jjtGetChild(1));
		}

		BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );
		callstack.swap( eachNameSpace );

		final Object iteratee = expression.eval( callstack, interpreter );

		if ( iteratee == Primitive.NULL )
			throw new EvalError(""The collection, array, map, iterator, or "" +
				""enumeration portion of a for statement cannot be null."", 
				this, callstack );

		CollectionManager cm = CollectionManager.getCollectionManager();
		if ( !cm.isBshIterable( iteratee ) )
			throw new EvalError(""Can't iterate over type: ""
				+iteratee.getClass(), this, callstack );
		BshIterator iterator = cm.getBshIterator( iteratee );
		
		Object returnControl = Primitive.VOID;
        while( iterator.hasNext() )
        {
			try {
			if ( elementType != null )
				eachNameSpace.setTypedVariable(
					varName, elementType,
					iterator.next(), new Modifiers() );
			else
				eachNameSpace.setVariable( varName, iterator.next(), false );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					""for loop iterator variable:""+ varName, this, callstack );
			}

            boolean breakout = false; 
            if ( statement != null ) 
            {
                Object ret = statement.eval( callstack, interpreter );

                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case RETURN:
							returnControl = ret;
							breakout = true;
                            break;

                        case CONTINUE:
                            break;

                        case BREAK:
                            breakout = true;
                            break;
                    }
                }
            }

            if (breakout)
                break;
        }

		callstack.swap(enclosingNameSpace);
        return returnControl;
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BshMethod,14,1,1,32,47,55,16,19,9,0.638461538,535,0.7,3,0.0,0.191964286,0,0,36.5,3,0.9286,0,"

package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;



public class BshMethod 
	implements java.io.Serializable 
{
	
	NameSpace declaringNameSpace;

	

	Modifiers modifiers;
	private String name;
	private Class creturnType;

	
	private String [] paramNames;
	private int numArgs;
	private Class [] cparamTypes;

	
	BSHBlock methodBody;

	
	private Method javaMethod;
	private Object javaObject;

	

	BshMethod( 
		BSHMethodDeclaration method, 
		NameSpace declaringNameSpace, Modifiers modifiers ) 
	{
		this( method.name, method.returnType, method.paramsNode.getParamNames(),
			method.paramsNode.paramTypes, method.blockNode, declaringNameSpace,
			modifiers );
	}

	BshMethod( 
		String name, Class returnType, String [] paramNames,
		Class [] paramTypes, BSHBlock methodBody, 
		NameSpace declaringNameSpace, Modifiers modifiers
	) {
		this.name = name;
		this.creturnType = returnType;
		this.paramNames = paramNames;
		if ( paramNames != null )
			this.numArgs = paramNames.length;
		this.cparamTypes = paramTypes;
		this.methodBody = methodBody;
		this.declaringNameSpace = declaringNameSpace;
		this.modifiers = modifiers;
	}

	
	BshMethod( Method method, Object object )
	{
		this( method.getName(), method.getReturnType(), null,
			method.getParameterTypes(), null, 
			null, null );

		this.javaMethod = method;
		this.javaObject = object;
	}


	
	
	public Class [] getParameterTypes() { return cparamTypes; }
	public String [] getParameterNames() { return paramNames; }

	
	
	public Class getReturnType() { return creturnType; }

	public Modifiers getModifiers() { return modifiers; }

	public String getName() { return name; }

	
	public Object invoke( 
		Object[] argValues, Interpreter interpreter ) 
		throws EvalError 
	{
		return invoke( argValues, interpreter, null, null, false );
	}

	
	public Object invoke( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo ) 
		throws EvalError 
	{
		return invoke( argValues, interpreter, callstack, callerInfo, false );
	}

	
	Object invoke( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		if ( argValues != null )
			for (int i=0; i<argValues.length; i++)
				if ( argValues[i] == null )
					throw new Error(""HERE!"");

		if ( javaMethod != null )
			try {
				return Reflect.invokeMethod(
					javaMethod, javaObject, argValues ); 
			} catch ( ReflectError e ) {
				throw new EvalError(
					""Error invoking Java method: ""+e, callerInfo, callstack );
			} catch ( InvocationTargetException e2 ) {
				throw new TargetError( 
					""Exception invoking imported object method."", 
					e2, callerInfo, callstack, true );
			}

		
		if ( modifiers != null && modifiers.hasModifier(""synchronized"") )
		{
			
			
			
			Object lock;
			if ( declaringNameSpace.isClass )
			{
				try {
					lock = declaringNameSpace.getClassInstance();
				} catch ( UtilEvalError e ) {
					throw new InterpreterError(
						""Can't get class instance for synchronized method."");
				}
			} else
				lock = declaringNameSpace.getThis(interpreter); 

			synchronized( lock ) 
			{
				return invokeImpl( 
					argValues, interpreter, callstack, 
					callerInfo, overrideNameSpace );
			}
		} else
			return invokeImpl( argValues, interpreter, callstack, callerInfo,
				overrideNameSpace );
	}

	private Object invokeImpl( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		Class returnType = getReturnType();
		Class [] paramTypes = getParameterTypes();

		
		if ( callstack == null )
			callstack = new CallStack( declaringNameSpace );

		if ( argValues == null )
			argValues = new Object [] { };

		
		if ( argValues.length != numArgs ) 
		{
		
			throw new EvalError( 
				""Wrong number of arguments for local method: "" 
				+ name, callerInfo, callstack );
		}

		
		NameSpace localNameSpace;
		if ( overrideNameSpace )
			localNameSpace = callstack.top();
		else
		{
			localNameSpace = new NameSpace( declaringNameSpace, name );
			localNameSpace.isMethod = true;
		}
		
		localNameSpace.setNode( callerInfo );

		
		for(int i=0; i<numArgs; i++)
		{
			
			if ( paramTypes[i] != null ) 
			{
				try {
					argValues[i] =
						
						Types.castObject( argValues[i], paramTypes[i], Types.ASSIGNMENT );
				}
				catch( UtilEvalError e) {
					throw new EvalError(
						""Invalid argument: "" 
						+ ""`""+paramNames[i]+""'"" + "" for method: "" 
						+ name + "" : "" + 
						e.getMessage(), callerInfo, callstack );
				}
				try {
					localNameSpace.setTypedVariable( paramNames[i], 
						paramTypes[i], argValues[i], null);
				} catch ( UtilEvalError e2 ) {
					throw e2.toEvalError( ""Typed method parameter assignment"", 
						callerInfo, callstack  );
				}
			} 
			
			else  
			{
				
				if ( argValues[i] == Primitive.VOID)
					throw new EvalError(
						""Undefined variable or class name, parameter: "" +
						paramNames[i] + "" to method: "" 
						+ name, callerInfo, callstack );
				else
					try {
						localNameSpace.setLocalVariable(
							paramNames[i], argValues[i],
							interpreter.getStrictJava() );
					} catch ( UtilEvalError e3 ) {
						throw e3.toEvalError( callerInfo, callstack );
					}
			}
		}

		
		if ( !overrideNameSpace )
			callstack.push( localNameSpace );

		
		Object ret = methodBody.eval( 
			callstack, interpreter, true );

		
		CallStack returnStack = callstack.copy();

		
		if ( !overrideNameSpace )
			callstack.pop();

		ReturnControl retControl = null;
		if ( ret instanceof ReturnControl )
		{
			retControl = (ReturnControl)ret;

			
			if ( retControl.kind == retControl.RETURN )
				ret = ((ReturnControl)ret).value;
			else 
				
				throw new EvalError(""'continue' or 'break' in method body"", 
					retControl.returnPoint, returnStack );

			
			
			if ( returnType == Void.TYPE && ret != Primitive.VOID )
				throw new EvalError( ""Cannot return value from void method"", 
				retControl.returnPoint, returnStack);
		}

		if ( returnType != null )
		{
			
			if ( returnType == Void.TYPE )
				return Primitive.VOID;

			
			try {
				ret =
					
					Types.castObject( ret, returnType, Types.ASSIGNMENT );
			} catch( UtilEvalError e )
			{
				
				
				SimpleNode node = callerInfo;
				if ( retControl != null )
					node = retControl.returnPoint;
				throw e.toEvalError(
					""Incorrect type returned from method: "" 
					+ name + e.getMessage(), node, callstack );
			}
		}

		return ret;
	}

	public boolean hasModifier( String name ) {
		return modifiers != null && modifiers.hasModifier(name);
	}

	public String toString() {
		return ""Scripted Method: ""
			+ StringUtil.methodString( name, getParameterTypes() ); 
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.Item,8,1,0,2,11,0,2,0,0,0.688311688,256,0.0,1,0.0,0.265625,0,0,29.625,12,2.75,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



final class Item {

  

  short index;

  

  int type;

  

  int intVal;

  

  long longVal;

  

  float floatVal;

  

  double doubleVal;

  

  String strVal1;

  

  String strVal2;

  

  String strVal3;

  

  int hashCode;

  

  Item next;

  

  Item () {
  }

  

  Item (final short index, final Item i) {
    this.index = index;
    type = i.type;
    intVal = i.intVal;
    longVal = i.longVal;
    floatVal = i.floatVal;
    doubleVal = i.doubleVal;
    strVal1 = i.strVal1;
    strVal2 = i.strVal2;
    strVal3 = i.strVal3;
    hashCode = i.hashCode;
  }

  

  void set (final int intVal) {
    this.type = ClassWriter.INT;
    this.intVal = intVal;
    this.hashCode = type + intVal;
  }

  

  void set (final long longVal) {
    this.type = ClassWriter.LONG;
    this.longVal = longVal;
    this.hashCode = type + (int)longVal;
  }

  

  void set (final float floatVal) {
    this.type = ClassWriter.FLOAT;
    this.floatVal = floatVal;
    this.hashCode = type + (int)floatVal;
  }

  

  void set (final double doubleVal) {
    this.type = ClassWriter.DOUBLE;
    this.doubleVal = doubleVal;
    this.hashCode = type + (int)doubleVal;
  }

  

  void set (
    final int type,
    final String strVal1,
    final String strVal2,
    final String strVal3)
  {
    this.type = type;
    this.strVal1 = strVal1;
    this.strVal2 = strVal2;
    this.strVal3 = strVal3;
    switch (type) {
      case ClassWriter.UTF8:
      case ClassWriter.STR:
      case ClassWriter.CLASS:
        hashCode = type + strVal1.hashCode();
        return;
      case ClassWriter.NAME_TYPE:
        hashCode = type + strVal1.hashCode()*strVal2.hashCode();
        return;
      
      
      
      default:
        hashCode = type + strVal1.hashCode()*strVal2.hashCode()*strVal3.hashCode();
        return;
    }
  }

  

  boolean isEqualTo (final Item i) {
    if (i.type == type) {
      switch (type) {
        case ClassWriter.INT:
          return i.intVal == intVal;
        case ClassWriter.LONG:
          return i.longVal == longVal;
        case ClassWriter.FLOAT:
          return i.floatVal == floatVal;
        case ClassWriter.DOUBLE:
          return i.doubleVal == doubleVal;
        case ClassWriter.UTF8:
        case ClassWriter.STR:
        case ClassWriter.CLASS:
          return i.strVal1.equals(strVal1);
        case ClassWriter.NAME_TYPE:
          return i.strVal1.equals(strVal1) &&
                 i.strVal2.equals(strVal2);
        
        
        
        default:
          return i.strVal1.equals(strVal1) &&
                 i.strVal2.equals(strVal2) &&
                 i.strVal3.equals(strVal3);
      }
    }
    return false;
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHSwitchStatement,3,2,0,11,17,3,1,10,2,2.0,149,0.0,0,0.894736842,0.5,1,1,48.66666667,1,0.6667,0,"

package org.gjt.sp.jedit.bsh;

class BSHSwitchStatement 
	extends SimpleNode 
	implements ParserConstants 
{

	public BSHSwitchStatement(int id) { super(id); }

    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		int numchild = jjtGetNumChildren();
		int child = 0;
		SimpleNode switchExp = ((SimpleNode)jjtGetChild(child++));
		Object switchVal = switchExp.eval( callstack, interpreter );

		
		
		BSHSwitchLabel label;
		Object node;
		ReturnControl returnControl=null;

		
		if ( child >= numchild )
			throw new EvalError(""Empty switch statement."", this, callstack );
		label = ((BSHSwitchLabel)jjtGetChild(child++));

		
		while ( child < numchild && returnControl == null ) 
		{
			
			if ( label.isDefault 
				|| primitiveEquals( 
					switchVal, label.eval( callstack, interpreter ), 
					callstack, switchExp )
				)
			{
				
				while ( child < numchild ) 
				{
					node = jjtGetChild(child++);
					if ( node instanceof BSHSwitchLabel )
						continue;
					
					Object value = 
						((SimpleNode)node).eval( callstack, interpreter ); 

					
					if ( value instanceof ReturnControl ) {
						returnControl = (ReturnControl)value;
						break;
					}
				}
			} else 
			{
				
				while ( child < numchild ) 
				{
					node = jjtGetChild(child++);
					if ( node instanceof BSHSwitchLabel ) {
						label = (BSHSwitchLabel)node;
						break;
					}
				}
			}
		}

		if ( returnControl != null && returnControl.kind == RETURN )
			return returnControl;
		else
			return Primitive.VOID;
	}

	
	private boolean primitiveEquals( 
		Object switchVal, Object targetVal, 
		CallStack callstack, SimpleNode switchExp  ) 
		throws EvalError
	{
		if ( switchVal instanceof Primitive || targetVal instanceof Primitive )
			try {
				
				Object result = Primitive.binaryOperation( 
					switchVal, targetVal, ParserConstants.EQ );
				result = Primitive.unwrap( result ); 
				return result.equals( Boolean.TRUE ); 
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					""Switch value: ""+switchExp.getText()+"": "", 
					this, callstack );
			}
		else
			return switchVal.equals( targetVal );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHTryStatement,2,2,0,17,28,1,1,16,1,2.0,235,0.0,0,0.944444444,0.625,1,1,116.5,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

import java.util.Vector;

class BSHTryStatement extends SimpleNode
{
	BSHTryStatement(int id)
	{
		super(id);
	}

	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		BSHBlock tryBlock = ((BSHBlock)jjtGetChild(0));

		Vector catchParams = new Vector();
		Vector catchBlocks = new Vector();

		int nchild = jjtGetNumChildren();
		Node node = null;
		int i=1;
		while((i < nchild) && ((node = jjtGetChild(i++)) instanceof BSHFormalParameter))
		{
			catchParams.addElement(node);
			catchBlocks.addElement(jjtGetChild(i++));
			node = null;
		}
		
		BSHBlock finallyBlock = null;
		if(node != null)
			finallyBlock = (BSHBlock)node;



		TargetError target = null;
		Throwable thrown = null;
		Object ret = null;

		
		int callstackDepth = callstack.depth();
		try {
			ret = tryBlock.eval(callstack, interpreter);
		}
		catch( TargetError e ) {
			target = e;
			String stackInfo = ""Bsh Stack: "";
			while ( callstack.depth() > callstackDepth )
				stackInfo += ""\t"" + callstack.pop() +""\n"";
		}

		
		if ( target != null )
			thrown = target.getTarget();

		
		
		if (thrown != null) 
		{
			int n = catchParams.size();
			for(i=0; i<n; i++)
			{
				
				BSHFormalParameter fp = 
					(BSHFormalParameter)catchParams.elementAt(i);

				
				
				
				
				fp.eval( callstack, interpreter );

				if ( fp.type == null && interpreter.getStrictJava() )
					throw new EvalError(
						""(Strict Java) Untyped catch block"", this, callstack );

				
				if ( fp.type != null ) 
					try {
						thrown = (Throwable)Types.castObject(
							thrown, fp.type, Types.ASSIGNMENT );
					} catch( UtilEvalError e ) {
						
						continue;
					}

				
				BSHBlock cb = (BSHBlock)(catchBlocks.elementAt(i));

				
				
				

				NameSpace enclosingNameSpace = callstack.top();
				BlockNameSpace cbNameSpace = 
					new BlockNameSpace( enclosingNameSpace );

				try {
					if ( fp.type == BSHFormalParameter.UNTYPED )
						
						cbNameSpace.setBlockVariable( fp.name, thrown );
					else
					{
						
						Modifiers modifiers = new Modifiers();
						cbNameSpace.setTypedVariable(
							fp.name, fp.type, thrown, new Modifiers() );
					}
				} catch ( UtilEvalError e ) {
					throw new InterpreterError(
						""Unable to set var in catch block namespace."" );
				}

				
				callstack.swap( cbNameSpace );
				try {
					ret = cb.eval( callstack, interpreter );
				} finally {
					
					callstack.swap( enclosingNameSpace );
				}

				target = null;  
				break;
			}
		}

		
		if(finallyBlock != null)
			ret = finallyBlock.eval(callstack, interpreter);

		
		if(target != null)
			throw target;

		if(ret instanceof ReturnControl)
			return ret;
		else	
			return Primitive.VOID;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.indent.IndentRuleFactory,9,1,0,7,15,36,0,7,9,2.0,84,0.0,0,0.0,0.333333333,0,0,8.333333333,1,0.8889,0,"

package org.gjt.sp.jedit.indent;

import java.util.regex.PatternSyntaxException;

public class IndentRuleFactory
{
	public static IndentRule indentNextLines(String regexp)
		throws PatternSyntaxException
	{
		return new RegexpIndentRule(regexp,
			null,
			new IndentAction.Increase(),
			null,false);
	}

	public static IndentRule indentNextLine(String regexp)
		throws PatternSyntaxException
	{
		return new RegexpIndentRule(regexp,
			new IndentAction.Decrease(),
			new IndentAction.Increase(),
			null,true);
	}

	public static IndentRule unindentThisLine(String regexp)
		throws PatternSyntaxException
	{
		return new RegexpIndentRule(regexp,
			null,
			new IndentAction.Increase(),
			new IndentAction.Decrease(),
			false);
	}

	public static IndentRule unindentNextLines(String regexp)
		throws PatternSyntaxException
	{
		return new RegexpIndentRule(regexp,
			null,
			new IndentAction.Decrease(),
			null,
			false);
	}

	public static IndentRule indentOpenBracket(char bracket)
		throws PatternSyntaxException
	{
		return new OpenBracketIndentRule(bracket,true);
	}

	public static IndentRule indentCloseBracket(char bracket)
		throws PatternSyntaxException
	{
		return new CloseBracketIndentRule(bracket,true);
	}

	public static IndentRule unalignedOpenBracket(char bracket)
		throws PatternSyntaxException
	{
		return new OpenBracketIndentRule(bracket,false);
	}

	public static IndentRule unalignedCloseBracket(char bracket)
		throws PatternSyntaxException
	{
		return new CloseBracketIndentRule(bracket,false);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Capabilities,7,1,0,8,18,13,7,1,6,0.5,87,1.0,0,0.0,0.166666667,0,0,11.14285714,4,1.1429,0,"

package org.gjt.sp.jedit.bsh;

import java.util.Hashtable;


public class Capabilities 
{
	private static boolean accessibility = false;

	public static boolean haveSwing() {
		
		return classExists( ""javax.swing.JButton"" );
	}

	public static boolean canGenerateInterfaces() {
		
		return classExists( ""java.lang.reflect.Proxy"" );
	}

	
	public static boolean haveAccessibility() 
	{
		return accessibility;
	}

	public static void setAccessibility( boolean b ) 
		throws Unavailable
	{ 
		if ( b == false )
		{
			accessibility = false;
			return;
		}

		if ( !classExists( ""java.lang.reflect.AccessibleObject"" )
			|| !classExists(""org.gjt.sp.jedit.bsh.reflect.ReflectManagerImpl"")  
		)
			throw new Unavailable( ""Accessibility unavailable"" );

		
		try {
			String.class.getDeclaredMethods();
		} catch ( SecurityException e ) {
			throw new Unavailable(""Accessibility unavailable: ""+e);
		}

		accessibility = true; 
	}

	private static Hashtable classes = new Hashtable();
	
	public static boolean classExists( String name ) 
	{
		Object c = classes.get( name );

		if ( c == null ) {
			try {
				
				c = Class.forName( name );
			} catch ( ClassNotFoundException e ) { }

			if ( c != null )
				classes.put(c,""unused"");
		}

		return c != null;
	}

	
	public static class Unavailable extends UtilEvalError
	{
		public Unavailable(String s ){ super(s); }
	}
}


"
jEdit,4.3,org.gjt.sp.jedit.gui.SelectLineRange,5,7,0,8,52,2,0,8,4,0.5,372,1.0,1,0.993939394,0.466666667,0,0,72.4,5,2.0,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;


public class SelectLineRange extends EnhancedDialog implements ActionListener
{
	
	public SelectLineRange(View view)
	{
		super(view,jEdit.getProperty(""selectlinerange.title""),true);
		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,0));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(
			""selectlinerange.caption""));
		label.setBorder(new EmptyBorder(0,0,6,12));
		content.add(BorderLayout.NORTH,label);

		JPanel panel = createFieldPanel();

		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(6,0,0,12));
		panel.add(Box.createGlue());
		panel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		panel.add(cancel);
		panel.add(Box.createGlue());

		content.add(panel,BorderLayout.SOUTH);

		GUIUtilities.requestFocus(this,startField);

		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} 

	
	public void ok()
	{
		int startLine;
		int endLine;

		try
		{
			startLine = Integer.parseInt(startField.getText()) - 1;
			endLine = Integer.parseInt(endField.getText()) - 1;
		}
		catch(NumberFormatException nf)
		{
			getToolkit().beep();
			return;
		}

		Buffer buffer = view.getBuffer();

		if(startLine < 0 || endLine >= buffer.getLineCount()
			|| startLine > endLine)
		{
			getToolkit().beep();
			return;
		}

		JEditTextArea textArea = view.getTextArea();
		Selection s = new Selection.Range(
			buffer.getLineStartOffset(startLine),
			buffer.getLineEndOffset(endLine) - 1);
		if(textArea.isMultipleSelectionEnabled())
			textArea.addToSelection(s);
		else
			textArea.setSelection(s);
		textArea.moveCaretPosition(buffer.getLineEndOffset(endLine) - 1);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
	} 

	

	
	private View view;
	private JTextField startField;
	private JTextField endField;
	private JButton ok;
	private JButton cancel;
	

	
	private JPanel createFieldPanel()
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.insets = new Insets(0,0,6,12);
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		JLabel label = new JLabel(jEdit.getProperty(""selectlinerange.start""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);

		startField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(startField,cons);
		panel.add(startField);

		label = new JLabel(jEdit.getProperty(""selectlinerange.end""),
			SwingConstants.RIGHT);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(label,cons);
		panel.add(label);

		endField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(endField,cons);
		panel.add(endField);

		return panel;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.ModeCatalogHandler,4,2,1,6,21,4,1,5,2,0.666666667,129,1.0,0,0.85,0.625,1,1,30.75,7,2.25,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.jedit.syntax.ModeProvider;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;



class ModeCatalogHandler extends DefaultHandler
{
	
	ModeCatalogHandler(String directory, boolean resource)
	{
		this.directory = directory;
		this.resource = resource;
	} 

	
	public InputSource resolveEntity(String publicId, String systemId)
	{
		return XMLUtilities.findEntity(systemId, ""catalog.dtd"", getClass());
	} 

	
	public void startElement(String uri, String localName,
							 String qName, Attributes attrs)
	{
		if (qName.equals(""MODE""))
		{
			String modeName = attrs.getValue(""NAME"");

			String file = attrs.getValue(""FILE"");
			if(file == null)
			{
				Log.log(Log.ERROR,this,directory + ""catalog:""
					+ "" mode "" + modeName + "" doesn't have""
					+ "" a FILE attribute"");
			}

			String filenameGlob = attrs.getValue(""FILE_NAME_GLOB"");
			String firstlineGlob = attrs.getValue(""FIRST_LINE_GLOB"");


			Mode mode = ModeProvider.instance.getMode(modeName);
			if(mode == null)
			{
				mode = instantiateMode(modeName);
				ModeProvider.instance.addMode(mode);
			}

			Object path;
			if(resource)
				path = jEdit.class.getResource(directory + file);
			else
				path = MiscUtilities.constructPath(directory,file);
			mode.setProperty(""file"",path);

			if(filenameGlob != null)
				mode.setProperty(""filenameGlob"",filenameGlob);
			else
				mode.unsetProperty(""filenameGlob"");

			if(firstlineGlob != null)
				mode.setProperty(""firstlineGlob"",firstlineGlob);
			else
				mode.unsetProperty(""firstlineGlob"");

			mode.init();
		}
	} 

	protected Mode instantiateMode(String modeName)
	{
		return new Mode(modeName);
	}

	private String directory;
	private boolean resource;

}

"
jEdit,4.3,org.gjt.sp.jedit.gui.HistoryModelSaver,2,1,0,3,2,1,3,0,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit.gui;

import java.util.Map;


public interface HistoryModelSaver
{
	Map<String, HistoryModel> load(Map<String, HistoryModel> models);

	boolean save(Map<String, HistoryModel> models);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Primitive,45,1,0,44,85,820,39,7,29,0.636363636,1940,0.25,2,0.0,0.089712919,1,1,42.02222222,14,2.8,0,"


package org.gjt.sp.jedit.bsh;

import java.util.Hashtable;



public final class Primitive implements ParserConstants, java.io.Serializable
{
	
	static Hashtable wrapperMap = new Hashtable();
	static {
		wrapperMap.put( Boolean.TYPE, Boolean.class );
		wrapperMap.put( Byte.TYPE, Byte.class );
		wrapperMap.put( Short.TYPE, Short.class );
		wrapperMap.put( Character.TYPE, Character.class );
		wrapperMap.put( Integer.TYPE, Integer.class );
		wrapperMap.put( Long.TYPE, Long.class );
		wrapperMap.put( Float.TYPE, Float.class );
		wrapperMap.put( Double.TYPE, Double.class );
		wrapperMap.put( Boolean.class, Boolean.TYPE );
		wrapperMap.put( Byte.class, Byte.TYPE );
		wrapperMap.put( Short.class, Short.TYPE );
		wrapperMap.put( Character.class, Character.TYPE );
		wrapperMap.put( Integer.class, Integer.TYPE );
		wrapperMap.put( Long.class, Long.TYPE );
		wrapperMap.put( Float.class, Float.TYPE );
		wrapperMap.put( Double.class, Double.TYPE );
	}

    
    private Object value;

    private static class Special implements java.io.Serializable
    {
        private Special() { }

        public static final Special NULL_VALUE = new Special();
        public static final Special VOID_TYPE = new Special();
    }

    
    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);

    
    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);

    
    public Primitive( Object value )
    {
        if ( value == null )
            throw new InterpreterError(
				""Use Primitve.NULL instead of Primitive(null)"");

		if ( value != Special.NULL_VALUE 
			&& value != Special.VOID_TYPE &&
			!isWrapperType( value.getClass() ) 
		)
            throw new InterpreterError( ""Not a wrapper type: ""+value);

        this.value = value;
    }

    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }

	
    public Object getValue()
    {
        if ( value == Special.NULL_VALUE )
            return null;
        else 
		if ( value == Special.VOID_TYPE )
                throw new InterpreterError(""attempt to unwrap void type"");
        else
            return value;
    }

    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return ""null"";
        else if(value == Special.VOID_TYPE)
            return ""void"";
        else
            return value.toString();
    }

	
    public Class getType()
    {
		if ( this == Primitive.VOID )
			return Void.TYPE;

		
		
		if ( this == Primitive.NULL )
			return null;

		return unboxType( value.getClass() );
    }

	
    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws UtilEvalError
    {
		
        if ( obj1 == NULL || obj2 == NULL )
            throw new UtilEvalError(
				""Null value or 'null' literal in binary operation"");
        if ( obj1 == VOID || obj2 == VOID )
            throw new UtilEvalError(
			""Undefined variable, class, or 'void' literal in binary operation"");

		
		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();

		
        if ( obj1 instanceof Primitive )
            obj1 = ((Primitive)obj1).getValue();
        if ( obj2 instanceof Primitive )
            obj2 = ((Primitive)obj2).getValue();

        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];

        if(lhs.getClass() != rhs.getClass())
            throw new UtilEvalError(""Type mismatch in operator.  "" 
			+ lhs.getClass() + "" cannot be used with "" + rhs.getClass() );

		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new UtilTargetError( ""Arithemetic Exception in binary op"", e);
		}

		
		
		
		if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)
			|| result instanceof Boolean
		)
			return new Primitive( result );
		else
			return result;
    }

    static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws UtilEvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new UtilEvalError(""Invalid types in binary operator"" );
	}

    static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();

        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);

            case NE:
                return new Boolean(lhs != rhs);

            case BOOL_OR:
            case BOOL_ORX:
                return new Boolean( lhs || rhs );

            case BOOL_AND:
            case BOOL_ANDX:
                return new Boolean( lhs && rhs );

            default:
                throw new InterpreterError(""unimplemented binary operator"");
        }
    }

    
    static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();

        switch(kind)
        {
            
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);

            case GT:
            case GTX:
                return new Boolean(lhs > rhs);

            case EQ:
                return new Boolean(lhs == rhs);

            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);

            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);

            case NE:
                return new Boolean(lhs != rhs);

            
            case PLUS:
                return new Long(lhs + rhs);

            case MINUS:
                return new Long(lhs - rhs);

            case STAR:
                return new Long(lhs * rhs);

            case SLASH:
                return new Long(lhs / rhs);

            case MOD:
                return new Long(lhs % rhs);

            
            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);

            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);

            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);

            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);

            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);

            case XOR:
                return new Long(lhs ^ rhs);

            default:
                throw new InterpreterError(
					""Unimplemented binary long operator"");
        }
    }

    
    static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();

        switch(kind)
        {
            
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);

            case GT:
            case GTX:
                return new Boolean(lhs > rhs);

            case EQ:
                return new Boolean(lhs == rhs);

            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);

            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);

            case NE:
                return new Boolean(lhs != rhs);

            
            case PLUS:
                return new Integer(lhs + rhs);

            case MINUS:
                return new Integer(lhs - rhs);

            case STAR:
                return new Integer(lhs * rhs);

            case SLASH:
                return new Integer(lhs / rhs);

            case MOD:
                return new Integer(lhs % rhs);

            
            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);

            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);

            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);

            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);

            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);

            case XOR:
                return new Integer(lhs ^ rhs);

            default:
                throw new InterpreterError(
					""Unimplemented binary integer operator"");
        }
    }

    
    static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws UtilEvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();

        switch(kind)
        {
            
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);

            case GT:
            case GTX:
                return new Boolean(lhs > rhs);

            case EQ:
                return new Boolean(lhs == rhs);

            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);

            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);

            case NE:
                return new Boolean(lhs != rhs);

            
            case PLUS:
                return new Double(lhs + rhs);

            case MINUS:
                return new Double(lhs - rhs);

            case STAR:
                return new Double(lhs * rhs);

            case SLASH:
                return new Double(lhs / rhs);

            case MOD:
                return new Double(lhs % rhs);

            
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError(""Can't shift doubles"");

            default:
                throw new InterpreterError(
					""Unimplemented binary double operator"");
        }
    }
    
    static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws UtilEvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();

        switch(kind)
        {
            
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);

            case GT:
            case GTX:
                return new Boolean(lhs > rhs);

            case EQ:
                return new Boolean(lhs == rhs);

            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);

            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);

            case NE:
                return new Boolean(lhs != rhs);

            
            case PLUS:
                return new Float(lhs + rhs);

            case MINUS:
                return new Float(lhs - rhs);

            case STAR:
                return new Float(lhs * rhs);

            case SLASH:
                return new Float(lhs / rhs);

            case MOD:
                return new Float(lhs % rhs);

            
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError(""Can't shift floats "");

            default:
                throw new InterpreterError(
					""Unimplemented binary float operator"");
        }
    }

	
    static Object promoteToInteger(Object wrapper )
    {
        if(wrapper instanceof Character)
            return new Integer(((Character)wrapper).charValue());
        else if((wrapper instanceof Byte) || (wrapper instanceof Short))
            return new Integer(((Number)wrapper).intValue());

        return wrapper;
    }

	
    static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);

        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;

            boolean b;

            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }

        return new Object[] { lhs, rhs };
    }

    public static Primitive unaryOperation(Primitive val, int kind)
        throws UtilEvalError
    {
        if (val == NULL)
            throw new UtilEvalError(
				""illegal use of null object or 'null' literal"");
        if (val == VOID)
            throw new UtilEvalError(
				""illegal use of undefined object or 'void' literal"");

        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());

        if ( operand instanceof Boolean )
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);

            
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }

            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(
				""An error occurred.  Please call technical support."");
    }

    static boolean booleanUnaryOperation(Boolean B, int kind) 
		throws UtilEvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new UtilEvalError(""Operator inappropriate for boolean"");
        }
    }

    static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();

        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError(""bad integer unaryOperation"");
        }
    }

    static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();

        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError(""bad long unaryOperation"");
        }
    }

    static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();

        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError(""bad float unaryOperation"");
        }
    }

    static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();

        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError(""bad double unaryOperation"");
        }
    }

    public int intValue() throws UtilEvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new UtilEvalError(""Primitive not a number"");
    }

    public boolean booleanValue() throws UtilEvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new UtilEvalError(""Primitive not a boolean"");
    }

	
	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}

    public Number numberValue() throws UtilEvalError
    {
		Object value = this.value;

		
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());

        if (value instanceof Number)
            return (Number)value;
        else
            throw new UtilEvalError(""Primitive not a number"");
    }

	
	public boolean equals( Object obj ) 
	{
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return false;
	}

	
	public int hashCode() 
	{
		return this.value.hashCode() * 21; 
	}

	
	public static Object unwrap( Object obj ) 
	{
        
        if (obj == Primitive.VOID)
            return null;

        
        if (obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}

    
    public static Object [] unwrap( Object[] args )
    {
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = unwrap( args[i] );
		return oa;
    }

    
    public static Object [] wrap( Object[] args, Class [] paramTypes )
    {
		if ( args == null )
			return null;

		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = wrap( args[i], paramTypes[i] );
		return oa;
    }

	
    public static Object wrap(
		Object value, Class type )
    {
        if ( type == Void.TYPE )
            return Primitive.VOID;

        if ( value == null )
            return Primitive.NULL;

		if ( type.isPrimitive() )
			return new Primitive( value );

		return value;
    }


	
	public static Primitive getDefaultValue( Class type )
	{
		if ( type == null || !type.isPrimitive() )
			return Primitive.NULL;
		if ( type == Boolean.TYPE )
			return new Primitive( false );

		
		try {
			return new Primitive((int)0).castToType( type, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError( ""bad cast"" );
		}
	}

	
	public static Class boxType( Class primitiveType )
	{
		Class c = (Class)wrapperMap.get( primitiveType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			""Not a primitive type: ""+ primitiveType );
	}

	
	public static Class unboxType( Class wrapperType )
	{
		Class c = (Class)wrapperMap.get( wrapperType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			""Not a primitive wrapper type: ""+wrapperType );
	}

	
	public Primitive castToType( Class toType, int operation ) 
		throws UtilEvalError
	{
		return castPrimitive( 
			toType, getType(), this, 
			false, operation );
	}

	
	static Primitive castPrimitive( 
		Class toType, Class fromType, Primitive fromValue, 
		boolean checkOnly, int operation ) 
		throws UtilEvalError
	{
		
		if ( checkOnly && fromValue != null )
			throw new InterpreterError(""bad cast param 1"");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError(""bad cast param 2"");
		if ( fromType != null && !fromType.isPrimitive() )
			throw new InterpreterError(""bad fromType:"" +fromType);
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError(""inconsistent args 1"");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError(""inconsistent args 2"");

		
		if ( fromType == Void.TYPE )
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( Reflect.normalizeClassName(toType), 
					""void value"", operation );

		
		Object value = null; 
		if ( fromValue != null )
			value = fromValue.getValue();

		if ( toType.isPrimitive() )
		{
			
			if ( fromType == null )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError(
						""primitive type:"" + toType, ""Null value"", operation );

			
		} else
		{
			
			
			if ( fromType == null )
				return checkOnly ? Types.VALID_CAST : 
					Primitive.NULL;

			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError(
						""object type:"" + toType, ""primitive value"", operation);
		}

		
		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError( toType, fromType, operation );

			return checkOnly ? Types.VALID_CAST :
				fromValue;
		}

		

		
		if ( operation == Types.ASSIGNMENT 
			&& !Types.isJavaAssignable( toType, fromType ) 
		) {
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( toType, fromType, operation );
		}

		return checkOnly ? Types.VALID_CAST :
			new Primitive( castWrapper(toType, value) );
	}

	public static boolean isWrapperType( Class type )
	{
		return wrapperMap.get( type ) != null && !type.isPrimitive();
	}

	
	static Object castWrapper( 
		Class toType, Object value ) 
	{
		if ( !toType.isPrimitive() )
			throw new InterpreterError(""invalid type in castWrapper: ""+toType);
		if ( value == null )
			throw new InterpreterError(""null value in castWrapper, guard"");
		if ( value instanceof Boolean )
		{
			if ( toType != Boolean.TYPE )
				throw new InterpreterError(""bad wrapper cast of boolean"");
			else
				return value;
		}

		
		if ( value instanceof Character )
			value = new Integer(((Character)value).charValue());

		if ( !(value instanceof Number) )
			throw new InterpreterError(""bad type in cast"");

		Number number = (Number)value;

		if (toType == Byte.TYPE)
			return new Byte(number.byteValue());
		if (toType == Short.TYPE)
			return new Short(number.shortValue());
		if (toType == Character.TYPE)
			return new Character((char)number.intValue());
		if (toType == Integer.TYPE)
			return new Integer(number.intValue());
		if (toType == Long.TYPE)
			return new Long(number.longValue());
		if (toType == Float.TYPE)
			return new Float(number.floatValue());
		if (toType == Double.TYPE)
			return new Double(number.doubleValue());

		throw new InterpreterError(""error in wrapper cast"");
	}

}
"
jEdit,4.3,org.gjt.sp.util.PropertiesBean,8,1,0,1,47,10,0,1,3,0.357142857,473,1.0,0,0.0,0.354166667,0,0,57.875,20,6.125,0,"
package org.gjt.sp.util;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.Properties;
import java.util.StringTokenizer;


public abstract class PropertiesBean
{

	

	
	protected PropertiesBean(String root)
	{
		this(root, ':');
	}

	
	protected PropertiesBean(String root, char arraysep)
	{
		if (root == null)
			throw new IllegalArgumentException(""root cannot be null"");
		this.root = root;
		this.arraysep = arraysep;
	}

	

	
	public void load(Properties p)
	{
		try
		{
			PropertyDescriptor[] _props = getPropertyDescriptors();
			for (int i = 0; i < _props.length; i++)
			{
				if (""class"".equals(_props[i].getName()))
					continue;

				Method _set = _props[i].getWriteMethod();
				if (_set != null)
				{
					String _pname = root + ""."" + _props[i].getName();
					Object _val = p.getProperty(_pname);
					if (_val != null)
						_val = parse((String)_val, _props[i].getPropertyType());
					try
					{
						_set.invoke(this, _val);
					}
					catch (IllegalArgumentException iae)
					{
						
					}
				}
			}
		}
		catch (Exception e)
		{
			
			
			
			Log.log(Log.ERROR, this, e);
		}
	}

	
	public void save(Properties p)
	{
		try
		{
			PropertyDescriptor[] _props = getPropertyDescriptors();
			for (int i = 0; i < _props.length; i++)
			{
				if (""class"".equals(_props[i].getName()))
					continue;

				Method _get = _props[i].getReadMethod();
				if (_get != null)
				{
					Object _val = _get.invoke(this);
					String _pname = root + ""."" + _props[i].getName();
					if (_val != null)
						p.setProperty(_pname, encode(_val));
					else
						p.remove(_pname);
				}
			}
		}
		catch (Exception e)
		{
			
			
			
			Log.log(Log.ERROR, this, e);
		}
	}

	
	public void clean(Properties p)
	{

		try
		{
			PropertyDescriptor[] _props = getPropertyDescriptors();
			for (int i = 0; i < _props.length; i++)
			{
				if (""class"".equals(_props[i].getName()))
					continue;

				String _pname = root + ""."" + _props[i].getName();
				p.remove(_pname);
			}
		}
		catch (Exception e)
		{
			
			
			
			Log.log(Log.ERROR, this, e);
		}
	}

	

	private PropertyDescriptor[] getPropertyDescriptors()
		throws IntrospectionException
	{
		BeanInfo _info = Introspector.getBeanInfo(getClass());
		return _info.getPropertyDescriptors();
	}

	private String encode(Object value)
	{
		Class _class = value.getClass();
		if (_class.isArray())
		{
			StringBuilder _val = new StringBuilder();
			int _len = Array.getLength(value);
			for (int i = 0; i < _len; i++)
			{
				String _str = encode(Array.get(value, i));
				if (_str == null)
					return null;
				_val.append(_str);
				if (i < _len - 1)
					_val.append(arraysep);
			}
			return _val.toString();
		}
		else
		{
			
			if (_class != Boolean.class && _class != Boolean.TYPE
			    && _class != Character.class && _class != Character.TYPE
			    && _class != Double.class && _class != Double.TYPE
			    && _class != Float.class && _class != Float.TYPE
			    && _class != Integer.class && _class != Integer.TYPE
			    && _class != Long.class && _class != Long.TYPE
			    && _class != Short.class && _class != Short.TYPE
			    && _class != String.class)
			{
				Log.log(Log.WARNING, this, ""unsupported type: "" + _class.getName());
				return null;
			}
			return value.toString();
		}
	}

	private Object parse(String value, Class<?> _class)
	{
		Object _ret = null;
		if (_class.isArray())
		{
			StringTokenizer st = new StringTokenizer(value, String.valueOf(arraysep));
			Class _type = _class.getComponentType();
			_ret = Array.newInstance(_type, st.countTokens());
			int _cnt = st.countTokens();
			for (int i = 0; i < _cnt; i++)
			{
				Object _val = parse(st.nextToken(), _type);
				if (_val == null)
					return null;
				Array.set(_ret, i, _val);
			}
		}
		else
		{
			if (_class == Boolean.class || _class == Boolean.TYPE)
				_ret = Boolean.valueOf(value);
			else if (_class == Character.class || _class == Character.TYPE)
				_ret = Character.valueOf(value.charAt(0));
			else if (_class == Double.class || _class == Double.TYPE)
				_ret = Double.valueOf(value);
			else if (_class == Float.class || _class == Float.TYPE)
				_ret = Float.valueOf(value);
			else if (_class == Integer.class || _class == Integer.TYPE)
				_ret = Integer.valueOf(value);
			else if (_class == Long.class || _class == Long.TYPE)
				_ret = Long.valueOf(value);
			else if (_class == Short.class || _class == Short.TYPE)
				_ret = Short.valueOf(value);
			else if (_class == String.class)
				_ret = value;
			else
				Log.log(Log.WARNING, this, ""unsupported type: "" + _class.getName());

		}
		return _ret;
	}

	

	private final char		arraysep;
	private final String 	root;

}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.TargetError,10,4,0,16,25,23,11,6,10,0.5,135,0.0,0,0.777777778,0.328571429,1,2,12.3,2,1.1,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.InvocationTargetException;

import java.io.PrintStream;


public class TargetError extends EvalError 
{
	Throwable target;
	boolean inNativeCode;

	public TargetError(
		String msg, Throwable t, SimpleNode node, CallStack callstack, 
		boolean inNativeCode )
	{
		super( msg, node, callstack );
		target = t;
		this.inNativeCode = inNativeCode;
	}

	public TargetError( Throwable t, SimpleNode node, CallStack callstack )
	{
		this(""TargetError"", t, node, callstack, false);
	}

	public Throwable getTarget()
	{
		
		if(target instanceof InvocationTargetException)
			return((InvocationTargetException)target).getTargetException();
		else
			return target;
	}

	public String toString() 
	{
		return super.toString() 
			+ ""\nTarget exception: "" + 
			printTargetError( target );
	}

    public void printStackTrace() { 
		printStackTrace( false, System.err );
	}

    public void printStackTrace( PrintStream out ) { 
		printStackTrace( false, out );
	}

    public void printStackTrace( boolean debug, PrintStream out ) {
		if ( debug ) {
			super.printStackTrace( out );
			out.println(""--- Target Stack Trace ---"");
		}
		target.printStackTrace( out );
	}

	
	public String printTargetError( Throwable t ) 
	{
		String s = target.toString();

		if ( Capabilities.canGenerateInterfaces() )
			s += ""\n"" + xPrintTargetError( t );

		return s;
	}

	
	public String xPrintTargetError( Throwable t ) 
	{
		String getTarget =
			""import java.lang.reflect.UndeclaredThrowableException;""+
			""String result=\""\"";""+
			""while ( target instanceof UndeclaredThrowableException ) {""+
			""	target=target.getUndeclaredThrowable(); "" +
			""	result+=\""Nested: \""+target.toString();"" +
			""}""+
			""return result;"";
		Interpreter i = new Interpreter();
		try {
			i.set(""target"", t);
			return (String)i.eval( getTarget );
		} catch ( EvalError e ) {
			throw new InterpreterError(""xprintarget: ""+e.toString() );
		}
	}

	
	public boolean inNativeCode() { 
		return inNativeCode; 
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.ToolTipLabel,2,5,1,11,5,1,11,0,2,2.0,12,0.0,0,0.998529412,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;

import java.awt.Point;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;


public class ToolTipLabel extends JLabel
{
	
	@Override
	public Point getToolTipLocation(MouseEvent event)
	{
		return new Point(event.getX(),-20);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHCastExpression,2,2,0,10,10,1,1,9,2,2.0,41,0.0,0,0.944444444,0.625,1,1,19.5,1,0.5,0,"


package org.gjt.sp.jedit.bsh;


class BSHCastExpression extends SimpleNode {

    public BSHCastExpression(int id) { super(id); }

	
	public Object eval(
		CallStack callstack, Interpreter interpreter ) throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class toType = ((BSHType)jjtGetChild(0)).getType( 
			callstack, interpreter );
		SimpleNode expression = (SimpleNode)jjtGetChild(1);

        
        Object fromValue = expression.eval(callstack, interpreter);
        Class fromType = fromValue.getClass();

		
		
		try {
			return Types.castObject( fromValue, toType, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack  );
		}
    }

}
"
jEdit,4.3,org.gjt.sp.jedit.options.PluginManagerOptionPane,8,6,0,9,68,8,3,8,1,0.814285714,457,1.0,1,0.98964497,0.5,5,6,54.875,7,2.375,0,"

package org.gjt.sp.jedit.options;

import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.io.*;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.pluginmgr.*;
import org.gjt.sp.util.*;


public class PluginManagerOptionPane extends AbstractOptionPane
{
	
	public PluginManagerOptionPane()
	{
		super(""plugin-manager"");
	} 

	
	protected void _init()
	{
		setLayout(new BorderLayout());


		mirrorLabel = new JLabel();
		updateMirrorLabel();
		JPanel buttonPanel = new JPanel();
		buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.Y_AXIS));
		JPanel spinnerPanel = null;
		if(jEdit.getSettingsDirectory() != null)
		{
			settingsDir = new JRadioButton(jEdit.getProperty(
				""options.plugin-manager.settings-dir""));
			settingsDir.setToolTipText(MiscUtilities.constructPath(
				jEdit.getSettingsDirectory(),""jars""));
			int delay = jEdit.getIntegerProperty(""plugin-manager.list-cache.minutes"", 10);
			spinnerModel = new SpinnerNumberModel(delay, 0, 240, 5);
			cacheForSpinner = new JSpinner(spinnerModel);
			spinnerPanel = new JPanel();
			spinnerPanel.setLayout(new BoxLayout(spinnerPanel, BoxLayout.X_AXIS));
			spinnerPanel.add(new JLabel(""Cache plugin list for: (minutes)""));
			spinnerPanel.add(cacheForSpinner);
			spinnerPanel.add(Box.createGlue());
			
		}
		JRadioButton appDir = new JRadioButton(jEdit.getProperty(
				""options.plugin-manager.app-dir""));
		appDir.setToolTipText(MiscUtilities.constructPath(
			jEdit.getJEditHome(),""jars""));

		miraList = new JList(miraModel = new MirrorModel());
		miraList.setSelectionModel(new SingleSelectionModel());

		
		add(BorderLayout.NORTH,mirrorLabel);
		add(BorderLayout.CENTER,new JScrollPane(miraList));


		buttonPanel.add(Box.createVerticalStrut(6));

		
		updateMirrors = new JButton(jEdit.getProperty(
			""options.plugin-manager.updateMirrors""));
		updateMirrors.addActionListener(new ActionHandler());
		updateMirrors.setEnabled(false);
		VFSManager.runInWorkThread(new UpdateMirrorsThread(false));
		JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		panel.add(updateMirrors);
		if (spinnerPanel != null) panel.add(spinnerPanel);
		panel.add(updateStatus);
		panel.setAlignmentX(Component.LEFT_ALIGNMENT);
		buttonPanel.add(panel);

		buttonPanel.add(Box.createVerticalStrut(6));

		
		downloadSource = new JCheckBox(jEdit.getProperty(
			""options.plugin-manager.downloadSource""));
		downloadSource.setSelected(jEdit.getBooleanProperty(""plugin-manager.downloadSource""));
		downloadSource.setAlignmentX(Component.LEFT_ALIGNMENT);
		buttonPanel.add(downloadSource);

		buttonPanel.add(Box.createVerticalStrut(6));

		
		deleteDownloads = new JCheckBox(jEdit.getProperty(
			""options.plugin-manager.deleteDownloads""));
		deleteDownloads.setSelected(jEdit.getBooleanProperty(""plugin-manager.deleteDownloads""));
		deleteDownloads.setAlignmentX(Component.LEFT_ALIGNMENT);
		buttonPanel.add(deleteDownloads);

		buttonPanel.add(Box.createVerticalStrut(6));

		
		ButtonGroup locGrp = new ButtonGroup();
		if(jEdit.getSettingsDirectory() != null)
			locGrp.add(settingsDir);
		locGrp.add(appDir);
		JPanel locPanel = new JPanel();
		locPanel.setLayout(new BoxLayout(locPanel,BoxLayout.Y_AXIS));
		
		if(jEdit.getSettingsDirectory() != null)
		{
			locPanel.add(settingsDir);
			locPanel.add(Box.createVerticalStrut(3));
		}
		locPanel.setBorder(new TitledBorder(
			jEdit.getProperty(""options.plugin-manager.location"")));
		locPanel.add(appDir);
		locPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
		buttonPanel.add(locPanel);

		buttonPanel.add(Box.createGlue());
		add(BorderLayout.SOUTH,buttonPanel);

		if (jEdit.getBooleanProperty(""plugin-manager.installUser"")
			&& jEdit.getSettingsDirectory() != null)
			settingsDir.setSelected(true);
		else
			appDir.setSelected(true);
	} 

	
	protected void _save()
	{
		jEdit.setBooleanProperty(""plugin-manager.installUser"",
			settingsDir != null && settingsDir.isSelected());
		jEdit.setBooleanProperty(""plugin-manager.downloadSource"",downloadSource.isSelected());
		jEdit.setBooleanProperty(""plugin-manager.deleteDownloads"",deleteDownloads.isSelected());
		jEdit.setIntegerProperty(""plugin-manager.list-cache.minutes"", spinnerModel.getNumber().intValue());
		if(miraList.getSelectedIndex() != -1)
		{
			String currentMirror = miraModel.getID(miraList.getSelectedIndex());
			String previousMirror = jEdit.getProperty(""plugin-manager.mirror.id"");

			if (!previousMirror.equals(currentMirror))
			{
				jEdit.setProperty(""plugin-manager.mirror.id"",currentMirror);
				jEdit.setProperty(""plugin-manager.mirror.name"",(String) miraModel.getElementAt(miraList.getSelectedIndex()));
				updateMirrorLabel();
				
			}
		}
	} 

	

	
	private JLabel mirrorLabel;

	private JRadioButton settingsDir;
	private JCheckBox downloadSource;
	private JCheckBox deleteDownloads;
	private JSpinner cacheForSpinner;
	private SpinnerNumberModel spinnerModel;

	private MirrorModel miraModel;
	private JList miraList;
	
	private JButton updateMirrors;
	
	private final JLabel updateStatus = new JLabel();
	

	
	private void updateMirrorLabel()
	{
		String currentMirror = jEdit.getProperty(""plugin-manager.mirror.id"");
		String mirrorName;
		if (currentMirror.equals(MirrorList.Mirror.NONE))
		{
			mirrorName = ""Plugin Central default"";
		}
		else
		{
			mirrorName = jEdit.getProperty(""plugin-manager.mirror.name"");
			if (mirrorName == null) mirrorName = currentMirror;
		}
		mirrorLabel.setText(jEdit.getProperty(
			""options.plugin-manager.mirror"") + ' ' + mirrorName);
	} 

	

	
	static class MirrorModel extends AbstractListModel
	{
		private List<MirrorList.Mirror> mirrors;

		MirrorModel()
		{
			mirrors = new ArrayList<MirrorList.Mirror>();
		}

		public String getID(int index)
		{
			return mirrors.get(index).id;
		}

		public int getSize()
		{
			return mirrors.size();
		}

		public Object getElementAt(int index)
		{
			MirrorList.Mirror mirror = mirrors.get(index);
			if(mirror.id.equals(MirrorList.Mirror.NONE))
				return jEdit.getProperty(""options.plugin-manager.none"");
			else
				return mirror.continent+"": ""+mirror.description+"" (""+mirror.location+')';
		}

		public void setList(List<MirrorList.Mirror> mirrors)
		{
			this.mirrors = mirrors;
			fireContentsChanged(this,0,mirrors.size() - 1);
		}
	} 

	
	static class SingleSelectionModel extends DefaultListSelectionModel
	{
		SingleSelectionModel()
		{
			setSelectionMode(SINGLE_SELECTION);
		}

		public void removeSelectionInterval(int index0, int index1) {}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			updateMirrors.setEnabled(false);
			updateStatus.setText(jEdit.getProperty(""options.plugin-manager.workthread""));
			VFSManager.runInWorkThread(new UpdateMirrorsThread(true));
		}
	} 

	
	
	class UpdateMirrorsThread extends WorkRequest
	{
		private boolean download;

		UpdateMirrorsThread(boolean download)
		{
			this.download = download;
		}

		
		public void run()
		{
			try
			{
				setStatus(jEdit.getProperty(""options.plugin-manager.workthread""));
				setMaximum(3);
				setValue(0);

				final List<MirrorList.Mirror> mirrors = new ArrayList<MirrorList.Mirror>();
				try
				{
					MirrorList mirrorList = new MirrorList(download, this);
					if (download)
						saveMirrorList(mirrorList.xml);

					mirrors.addAll(mirrorList.mirrors);
				}
				catch (Exception ex)
				{
					if (download)
					{
						Log.log(Log.ERROR,this,ex);
						GUIUtilities.error(PluginManagerOptionPane.this,
								""ioerror"",new String[] { ex.toString() });
					}
				}

				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						miraModel.setList(mirrors);

						String id = jEdit.getProperty(""plugin-manager.mirror.id"");
						int size = miraModel.getSize();
						for (int i=0; i < size; i++)
						{
							if (size == 1 || miraModel.getID(i).equals(id))
							{
								miraList.setSelectedIndex(i);
								break;
							}
						}
					}
				});

				setValue(3);
			}
			finally
			{
				updateMirrors.setEnabled(true);
				updateStatus.setText(null);
			}
		} 

		
		private void saveMirrorList(String xml)
		{
			String settingsDirectory = jEdit.getSettingsDirectory();
			if(settingsDirectory == null)
				return;

			File mirrorList = new File(MiscUtilities.constructPath(
				settingsDirectory,""mirrorList.xml""));
			OutputStream out = null;

			try
			{
				out = new BufferedOutputStream(new FileOutputStream(mirrorList));
				IOUtilities.copyStream(null, new ByteArrayInputStream(xml.getBytes()), out, false);
			}
			catch (IOException e)
			{
				Log.log(Log.ERROR,this, ""Unable to write cached mirror list : "" + mirrorList);
			}
			finally
			{
				IOUtilities.closeQuietly(out);
			}
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.BufferOptions,5,7,0,9,30,4,4,6,3,0.85,156,1.0,3,0.993939394,0.35,0,0,29.2,1,0.8,0,"

package org.gjt.sp.jedit.gui;




import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

import java.util.Arrays;

import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.options.BufferOptionPane;

import org.gjt.sp.jedit.*;





public class BufferOptions extends EnhancedDialog
{
	

	public BufferOptions(View view, Buffer buffer)
	{
		super(view,jEdit.getProperty(""buffer-options.title""),true);
		this.view = view;
		this.buffer = buffer;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionListener = new ActionHandler();
		panel = new BufferOptionPane();

		content.add(BorderLayout.NORTH,panel);

		

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionListener);
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);

		buttons.add(Box.createHorizontalStrut(6));

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionListener);
		buttons.add(cancel);

		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		

		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} 



	

	public void ok()
	{
		panel.save();
		dispose();
	} 

	

	public void cancel()
	{
		dispose();
	} 

	

	private View view;
	private Buffer buffer;
	private BufferOptionPane panel;
	private JButton ok;
	private JButton cancel;

	

	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
		} 

	} 

	
}

"
jEdit,4.3,org.gjt.sp.jedit.proto.jeditresource.Handler,2,2,0,1,5,1,0,1,2,2.0,14,0.0,0,0.923076923,0.75,0,0,6.0,1,0.5,0,"

package org.gjt.sp.jedit.proto.jeditresource;

import java.io.IOException;
import java.net.*;

public class Handler extends URLStreamHandler
{
	
	public URLConnection openConnection(URL url)
		throws IOException
	{
		PluginResURLConnection c = new PluginResURLConnection(url);
		c.connect();
		return c;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.ShapedFoldPainter,5,1,2,5,11,10,2,3,4,2.0,175,0.0,0,0.0,0.666666667,0,0,34.0,5,2.2,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;

import org.gjt.sp.jedit.buffer.JEditBuffer;



public abstract class ShapedFoldPainter implements FoldPainter {

	
	public void paintFoldEnd(Gutter gutter, Graphics2D gfx, int screenLine,
			int physicalLine, int y, int lineHeight, JEditBuffer buffer)
	{
		gfx.setColor(gutter.getFoldColor());
		int _y = y + lineHeight / 2;
		int _x = 5;
		gfx.drawLine(_x,y,_x,_y+3);
		gfx.drawLine(_x,_y+3,_x+4,_y+3);
		boolean nested = (physicalLine < buffer.getLineCount() - 1 &&
			buffer.getFoldLevel(physicalLine + 1) > 0);
		if (nested)
			gfx.drawLine(_x,y+4,_x,y+lineHeight-1);
	}

	
	public void paintFoldMiddle(Gutter gutter, Graphics2D gfx, int screenLine,
			int physicalLine, int y, int lineHeight, JEditBuffer buffer)
	{
		gfx.setColor(gutter.getFoldColor());
		gfx.drawLine(5,y,5,y+lineHeight-1);
	}

	
	public void paintFoldStart(Gutter gutter, Graphics2D gfx, int screenLine,
			int physicalLine, boolean nextLineVisible, int y, int lineHeight,
			JEditBuffer buffer)
	{
		int _y = y + lineHeight / 2;
		int _x = 5;
		gfx.setColor(gutter.getFoldColor());
		paintFoldShape(gfx, _y - 4, _y + 4);
		gfx.drawLine(_x-2,_y,_x+2,_y);
		boolean nested = (buffer.getFoldLevel(physicalLine) > 0);
		if (nested)
			gfx.drawLine(_x,y,_x,_y-5);
		if (nextLineVisible)
			gfx.drawLine(_x,_y+5,_x,y+lineHeight-1);
		else
		{
			gfx.drawLine(_x,_y-2,_x,_y+2);
			if (nested)
				gfx.drawLine(_x,_y+4,_x,y+lineHeight-1);
		}
	}

	abstract protected void paintFoldShape(Graphics2D gfx, int top, int bottom);

} 
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHBlock,4,2,0,21,12,0,11,11,2,0.0,170,0.0,0,0.85,0.583333333,1,1,41.25,1,0.75,0,"


package org.gjt.sp.jedit.bsh;

class BSHBlock extends SimpleNode
{
	public boolean isSynchronized = false;

	BSHBlock(int id) { super(id); }

	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		return eval( callstack, interpreter, false );
	}

	
	public Object eval( 
		CallStack callstack, Interpreter interpreter, 
		boolean overrideNamespace ) 
		throws EvalError
	{
		Object syncValue = null;
		if ( isSynchronized ) 
		{
			
			SimpleNode exp = ((SimpleNode)jjtGetChild(0));
			syncValue = exp.eval(callstack, interpreter);
		}

		Object ret;
		if ( isSynchronized ) 
			synchronized( syncValue )
			{
				ret = evalBlock( 
					callstack, interpreter, overrideNamespace, null);
			}
		else
				ret = evalBlock( 
					callstack, interpreter, overrideNamespace, null );

		return ret;
	}

	Object evalBlock( 
		CallStack callstack, Interpreter interpreter, 
		boolean overrideNamespace, NodeFilter nodeFilter ) 
		throws EvalError
	{	
		Object ret = Primitive.VOID;
		NameSpace enclosingNameSpace = null;
		if ( !overrideNamespace ) 
		{
			enclosingNameSpace= callstack.top();
			BlockNameSpace bodyNameSpace = 
				new BlockNameSpace( enclosingNameSpace );

			callstack.swap( bodyNameSpace );
		}

		int startChild = isSynchronized ? 1 : 0;
		int numChildren = jjtGetNumChildren();

		try {
			
			for(int i=startChild; i<numChildren; i++)
			{
				SimpleNode node = ((SimpleNode)jjtGetChild(i));

				if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
					continue;

				if ( node instanceof BSHClassDeclaration )
					node.eval( callstack, interpreter );
			}
			for(int i=startChild; i<numChildren; i++)
			{
				SimpleNode node = ((SimpleNode)jjtGetChild(i));
				if ( node instanceof BSHClassDeclaration )
					continue;

				
				if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
					continue;

				ret = node.eval( callstack, interpreter );

				
				if ( ret instanceof ReturnControl )
					break;
			}
		} finally {
			
			if ( !overrideNamespace ) 
				callstack.swap( enclosingNameSpace );
		}
		return ret;
	}

	public interface NodeFilter {
		public boolean isVisible( SimpleNode node );
	}

}

"
jEdit,4.3,org.gjt.sp.jedit.gui.StyleEditor,7,7,0,7,48,13,3,4,6,0.444444444,401,1.0,2,0.992435703,0.346938776,0,0,55.0,6,2.5714,0,"
package org.gjt.sp.jedit.gui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;

import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.syntax.SyntaxStyle;


public class StyleEditor extends EnhancedDialog implements ActionListener
{
	
	public StyleEditor(JDialog parent, SyntaxStyle style, String styleName)
	{
		super(parent, jEdit.getProperty(""style-editor.title""),true);
		initialize(parent, style, styleName);
	}
	public StyleEditor(JFrame parent, SyntaxStyle style, String styleName)
	{
		super(parent, jEdit.getProperty(""style-editor.title""),true);
		initialize(parent, style, styleName);
	}
	private void initialize(Component comp, SyntaxStyle style, String styleName)
	{
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel panel = new JPanel(new GridLayout(5,2,12,12));

		panel.add(new JLabel(jEdit.getProperty(""style-editor.tokenType"")));
		panel.add(new JLabel(styleName));
		
		italics = new JCheckBox(jEdit.getProperty(""style-editor.italics""));
		italics.setSelected(style.getFont().isItalic());
		panel.add(italics);
		panel.add(new JLabel());

		bold = new JCheckBox(jEdit.getProperty(""style-editor.bold""));
		bold.setSelected(style.getFont().isBold());
		panel.add(bold);
		panel.add(new JLabel());

		Color fg = style.getForegroundColor();

		fgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.fgColor""));
		fgColorCheckBox.setSelected(fg != null);
		fgColorCheckBox.addActionListener(this);
		panel.add(fgColorCheckBox);

		fgColor = new ColorWellButton(fg);
		fgColor.setEnabled(fg != null);
		panel.add(fgColor);

		Color bg = style.getBackgroundColor();
		bgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.bgColor""));
		bgColorCheckBox.setSelected(bg != null);
		bgColorCheckBox.addActionListener(this);
		panel.add(bgColorCheckBox);

		bgColor = new ColorWellButton(bg);
		bgColor.setEnabled(bg != null);
		panel.add(bgColor);

		content.add(BorderLayout.CENTER,panel);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		box.add(ok = new JButton(jEdit.getProperty(""common.ok"")));
		getRootPane().setDefaultButton(ok);
		ok.addActionListener(this);
		box.add(Box.createHorizontalStrut(6));
		box.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(this);
		box.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,box);

		pack();
		setLocationRelativeTo(comp);

		setResizable(false);
		setVisible(true);
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
		else if(source == fgColorCheckBox)
			fgColor.setEnabled(fgColorCheckBox.isSelected());
		else if(source == bgColorCheckBox)
			bgColor.setEnabled(bgColorCheckBox.isSelected());
	} 

	
	public void ok()
	{
		okClicked = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public SyntaxStyle getStyle()
	{
		if(!okClicked)
			return null;

		Color foreground = (fgColorCheckBox.isSelected()
			? fgColor.getSelectedColor()
			: null);

		Color background = (bgColorCheckBox.isSelected()
			? bgColor.getSelectedColor()
			: null);

		return new SyntaxStyle(foreground,background,
				new Font(""Dialog"",
				(italics.isSelected() ? Font.ITALIC : 0)
				| (bold.isSelected() ? Font.BOLD : 0),
				12));
	} 

	
	private JCheckBox italics;
	private JCheckBox bold;
	private JCheckBox fgColorCheckBox;
	private ColorWellButton fgColor;
	private JCheckBox bgColorCheckBox;
	private ColorWellButton bgColor;
	private JButton ok;
	private JButton cancel;
	private boolean okClicked;
	
} 
"
jEdit,4.3,org.gjt.sp.jedit.gui.StatusBar,19,5,0,39,108,111,26,19,12,0.85978836,790,0.904761905,10,0.973174367,0.197368421,1,7,39.47368421,15,2.6842,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.text.Segment;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.statusbar.StatusWidgetFactory;
import org.gjt.sp.jedit.gui.statusbar.Widget;
import org.gjt.sp.jedit.gui.statusbar.ToolTipLabel;
import org.gjt.sp.util.*;



public class StatusBar extends JPanel implements WorkThreadProgressListener
{
	
	public StatusBar(View view)
	{
		super(new BorderLayout());
		setName(""StatusBar"");
		setBorder(new CompoundBorder(new EmptyBorder(4,0,0,
			(OperatingSystem.isMacOS() ? 18 : 0)),
			UIManager.getBorder(""TextField.border"")));

		this.view = view;

		panel = new JPanel(new BorderLayout());
		box = new Box(BoxLayout.X_AXIS);
		panel.add(BorderLayout.EAST,box);
		add(BorderLayout.CENTER,panel);

		MouseHandler mouseHandler = new MouseHandler();

		caretStatus = new ToolTipLabel();
		caretStatus.setName(""caretStatus"");
		caretStatus.setToolTipText(jEdit.getProperty(""view.status.caret-tooltip""));
		caretStatus.addMouseListener(mouseHandler);

		message = new JLabel("" "");
		setMessageComponent(message);

		modeWidget = _getWidget(""mode"");
		foldWidget = _getWidget(""fold"");
		encodingWidget = _getWidget(""encoding"");
		wrapWidget = _getWidget(""wrap"");
		multiSelectWidget = _getWidget(""multiSelect"");
		rectSelectWidget = _getWidget(""rectSelect"");
		overwriteWidget = _getWidget(""overwrite"");
		lineSepWidget = _getWidget(""lineSep"");
	} 

	
	public void propertiesChanged()
	{
		Color fg = jEdit.getColorProperty(""view.status.foreground"");
		Color bg = jEdit.getColorProperty(""view.status.background"");

		showCaretStatus = jEdit.getBooleanProperty(""view.status.show-caret-status"");

		panel.setBackground(bg);
		panel.setForeground(fg);
		caretStatus.setBackground(bg);
		caretStatus.setForeground(fg);
		message.setBackground(bg);
		message.setForeground(fg);

		
		Font font = new JLabel().getFont();
		
		FontMetrics fm = getFontMetrics(font);

		if (showCaretStatus)
		{
			panel.add(BorderLayout.WEST,caretStatus);

			caretStatus.setFont(font);

			Dimension dim = new Dimension(fm.stringWidth(caretTestStr),
					fm.getHeight());
			caretStatus.setPreferredSize(dim);
			updateCaretStatus();
		}
		else
			panel.remove(caretStatus);

		String statusBar = jEdit.getProperty(""view.status"");
		if (!StandardUtilities.objectsEqual(currentBar, statusBar))
		{
			box.removeAll();
			StringTokenizer tokenizer = new StringTokenizer(statusBar);
			while (tokenizer.hasMoreTokens())
			{
				String token = tokenizer.nextToken();
				if (Character.isLetter(token.charAt(0)))
				{
					Widget widget = getWidget(token);
					if (widget == null)
					{
						Log.log(Log.WARNING, this, ""Widget "" + token + "" doesn't exist"");
						continue;
					}
					Component c = widget.getComponent();
					c.setBackground(bg);
					c.setForeground(fg);
					box.add(c);
					widget.update();
					widget.propertiesChanged();
				}
				else
				{
					JLabel label = new JLabel(token);
					label.setBackground(bg);
					label.setForeground(fg);
					box.add(label);
				}
			}
			currentBar = statusBar;
		}
		updateBufferStatus();
		updateMiscStatus();
	} 

	
	@Override
	public void addNotify()
	{
		super.addNotify();
		VFSManager.getIOThreadPool().addProgressListener(this);
	} 

	
	@Override
	public void removeNotify()
	{
		super.removeNotify();
		VFSManager.getIOThreadPool().removeProgressListener(this);
	} 

	

	
	public void statusUpdate(final WorkThreadPool threadPool, int threadIndex)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				
				if(message != null && !"""".equals(message.getText().trim())
					&& !currentMessageIsIO)
					return;

				int requestCount = threadPool.getRequestCount();
				if(requestCount == 0)
				{
					setMessageAndClear(jEdit.getProperty(
						""view.status.io.done""));
					currentMessageIsIO = true;
				}
				else if(requestCount == 1)
				{
					setMessage(jEdit.getProperty(
						""view.status.io-1""));
					currentMessageIsIO = true;
				}
				else
				{
					Object[] args = {Integer.valueOf(requestCount)};
					setMessage(jEdit.getProperty(
						""view.status.io"",args));
					currentMessageIsIO = true;
				}
			}
		});
	} 

	
	public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
	{
	} 

	

	
	
	public String getMessage()
	{
		return message.getText();
	} 

	
	
	public void setMessageAndClear(String message)
	{
		setMessage(message);

		tempTimer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				
				if(isShowing())
					setMessage(null);
			}
		});

		tempTimer.setInitialDelay(10000);
		tempTimer.setRepeats(false);
		tempTimer.start();
	} 

	
	
	public void setMessage(String message)
	{
		if(tempTimer != null)
		{
			tempTimer.stop();
			tempTimer = null;
		}

		setMessageComponent(this.message);

		if(message == null)
		{
			if(view.getMacroRecorder() != null)
				this.message.setText(jEdit.getProperty(""view.status.recording""));
			else
				this.message.setText("" "");
		}
		else
			this.message.setText(message);
	} 

	
	public void setMessageComponent(Component comp)
	{
		currentMessageIsIO = false;

		if (comp == null || messageComp == comp)
		{
			return;
		}

		messageComp = comp;
		panel.add(BorderLayout.CENTER, messageComp);
	} 

	
	public void updateCaretStatus()
	{
		if (showCaretStatus)
		{
			Buffer buffer = view.getBuffer();

			if(!buffer.isLoaded() ||
				
				buffer != view.getTextArea().getBuffer())
			{
				caretStatus.setText("" "");
				return;
			}

			JEditTextArea textArea = view.getTextArea();

			int caretPosition = textArea.getCaretPosition();
			int currLine = textArea.getCaretLine();

			
			
			
			
			
			if(currLine >= buffer.getLineCount())
				return; 

			int start = textArea.getLineStartOffset(currLine);
			int dot = caretPosition - start;

 			if(dot < 0)
 				return;
 
			int bufferLength = buffer.getLength();

 			buffer.getText(start,dot,seg);
 			int virtualPosition = StandardUtilities.getVirtualWidth(seg,
 				buffer.getTabSize());
			
			seg.array = null;
			seg.count = 0;
 
			
			
			
			if (jEdit.getBooleanProperty(""view.status.show-caret-linenumber"", true))
			{
				buf.append(currLine + 1);
				buf.append(',');
			}
			if (jEdit.getBooleanProperty(""view.status.show-caret-dot"", true))
			{
				buf.append(dot + 1);
			}
			if (jEdit.getBooleanProperty(""view.status.show-caret-virtual"", true) &&
				virtualPosition != dot)
			{
				buf.append('-');
				buf.append(virtualPosition + 1);
			}
			if (buf.length() > 0) 
			{
				buf.append(' ');
			}
			if (jEdit.getBooleanProperty(""view.status.show-caret-offset"", true) &&
				jEdit.getBooleanProperty(""view.status.show-caret-bufferlength"", true))
			{
				buf.append('(');
				buf.append(caretPosition);
				buf.append('/');
				buf.append(bufferLength);
				buf.append(')');
			}
			else if (jEdit.getBooleanProperty(""view.status.show-caret-offset"", true))
			{
				buf.append('(');
				buf.append(caretPosition);
				buf.append(')');
			}
			else if (jEdit.getBooleanProperty(""view.status.show-caret-bufferlength"", true))
			{
				buf.append('(');
				buf.append(bufferLength);
				buf.append(')');
			}
				
 			caretStatus.setText(buf.toString());
 			buf.setLength(0);
 		}			
	} 

	
	public void updateBufferStatus()
	{
		wrapWidget.update();
		lineSepWidget.update();
		modeWidget.update();
		foldWidget.update();
		encodingWidget.update();
	} 

	
	public void updateMiscStatus()
	{
		multiSelectWidget.update();
		rectSelectWidget.update();
		overwriteWidget.update();
	} 

	
	private String currentBar;
	private final View view;
	private final JPanel panel;
	private final Box box;
	private final ToolTipLabel caretStatus;
	private Component messageComp;
	private final JLabel message;
	private final Widget modeWidget;
	private final Widget foldWidget;
	private final Widget encodingWidget;
	private final Widget wrapWidget;
	private final Widget multiSelectWidget;
	private final Widget rectSelectWidget;
	private final Widget overwriteWidget;
	private final Widget lineSepWidget;
	 StringBuilder buf = new StringBuilder();
	private Timer tempTimer;
	private boolean currentMessageIsIO;

	private final Segment seg = new Segment();

	private boolean showCaretStatus;
	

	
	static final String caretTestStr = ""9999,999-999 (99999999/99999999)"";

	
	private Widget getWidget(String name)
	{
		if (""mode"".equals(name))
			return modeWidget;
		if (""fold"".equals(name))
			return foldWidget;
		if (""encoding"".equals(name))
			return encodingWidget;
		if (""wrap"".equals(name))
			return wrapWidget;
		if (""multiSelect"".equals(name))
			return multiSelectWidget;
		if (""rectSelect"".equals(name))
			return rectSelectWidget;
		if (""overwrite"".equals(name))
			return overwriteWidget;
		if (""lineSep"".equals(name))
			return lineSepWidget;

		return _getWidget(name);
	} 

	
	private Widget _getWidget(String name)
	{
		StatusWidgetFactory widgetFactory =
		(StatusWidgetFactory) ServiceManager.getService(""org.gjt.sp.jedit.gui.statusbar.StatusWidget"", name);
		if (widgetFactory == null)
		{
			Log.log(Log.ERROR, this, ""Widget "" + name + "" doesn't exist"");
			return null;
		}
		return widgetFactory.getWidget(view);
	} 

	
	private class MouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			Object source = evt.getSource();
			if(source == caretStatus && evt.getClickCount() == 2)
			{
				view.getTextArea().showGoToLineDialog();
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.CompletionPopup,20,5,1,14,75,104,7,13,8,0.589473684,391,0.8,3,0.972712681,0.204678363,3,4,18.3,5,1.9,0,"

package org.gjt.sp.jedit.gui;


import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowEvent;
import java.awt.event.WindowFocusListener;

import javax.swing.AbstractListModel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JWindow;
import javax.swing.ListSelectionModel;
import javax.swing.ListCellRenderer;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.View;



public class CompletionPopup extends JWindow
{
	
	
	public interface Candidates
	{
		
		public int getSize();

		
		public boolean isValid();

		
		public void complete(int index);
	
		
		public Component getCellRenderer(JList list, int index,
			boolean isSelected, boolean cellHasFocus);

		
		public String getDescription(int index);
	} 

	
	 
	public CompletionPopup(View view)
	{
		super(view);
		this.view = view;
		this.keyHandler = new KeyHandler();
		this.candidates = null;
		this.list = new JList();

		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.setCellRenderer(new CellRenderer());
		list.addKeyListener(keyHandler);
		list.addMouseListener(new MouseHandler());

		JPanel content = new JPanel(new BorderLayout());
		content.setFocusTraversalKeysEnabled(false);
		
		
		JScrollPane scroller = new JScrollPane(list,
			ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
			ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		content.add(scroller, BorderLayout.CENTER);
		setContentPane(content);
		addWindowFocusListener(new WindowFocusHandler());
	}

	public CompletionPopup(View view, Point location)
	{
		this(view);
		if (location != null)
		{
			setLocation(location);
		}
	} 

	
	
	public void dispose()
	{
		if (isDisplayable())
		{
			if (view.getKeyEventInterceptor() == keyHandler)
			{
				view.setKeyEventInterceptor(null);
			}
			super.dispose();

			
			
			
			
			
			
			
			
			
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					view.getTextArea().requestFocus();
				}
			});
		}
	} 

	
	
	public void reset(Candidates candidates, boolean active)
	{
		if(candidates == null || !candidates.isValid()
			|| candidates.getSize() <= 0)
		{
			dispose();
			return;
		}

		this.candidates = candidates;
		list.setModel(new CandidateListModel());
		list.setVisibleRowCount(Math.min(candidates.getSize(),8));
		pack();
		setLocation(fitInScreen(getLocation(null),this,
			view.getTextArea().getPainter().getFontMetrics().getHeight()));
		if (active)
		{
			setSelectedIndex(0);
			GUIUtilities.requestFocus(this,list);
		}
		setVisible(true);
		view.setKeyEventInterceptor(keyHandler);
	} 

	
	
	public Candidates getCandidates()
	{
		return candidates;
	} 

	
	
	public int getSelectedIndex()
	{
		return list.getSelectedIndex();
	} 

	
	
	public void setSelectedIndex(int index)
	{
		if (candidates != null
			&& 0 <= index && index < candidates.getSize())
		{
			list.setSelectedIndex(index);
			list.ensureIndexIsVisible(index);
			String description = candidates.getDescription(index);
			if (description != null)
			{
				view.getStatus().setMessageAndClear(description);
			}
		}
	} 

	
	
	public boolean doSelectedCompletion()
	{
		int selected = list.getSelectedIndex();
		if (candidates != null &&
			0 <= selected && selected < candidates.getSize())
		{
			candidates.complete(selected);
			dispose();
			return true;
		}
		return false;
	} 

	
	
	protected void keyPressed(KeyEvent e)
	{
	} 

	
	
	protected void keyTyped(KeyEvent e)
	{
	} 

	

	
	private final View view;
	private final KeyHandler keyHandler;
	private Candidates candidates;
	private final JList list;
	

	
	private static Point fitInScreen(Point p, Window w, int lineHeight)
	{
		Rectangle screenSize = w.getGraphicsConfiguration().getBounds();
		if(p.y + w.getHeight() >= screenSize.height)
			p.y = p.y - w.getHeight() - lineHeight;
		return p;
	} 

	
	private void moveRelative(int n)
	{
		int selected = list.getSelectedIndex();

		int newSelect = selected + n;
		if (newSelect < 0)
		{
			newSelect = 0;
		}
		else
		{
			int numItems = list.getModel().getSize();
			if(numItems < 1)
			{
				return;
			}
			if(newSelect >= numItems)
			{
				newSelect = numItems - 1;
			}
		}

		if(newSelect != selected)
		{
			setSelectedIndex(newSelect);
		}
	} 

	
	private void moveRelativePages(int n)
	{
		int pageSize = list.getVisibleRowCount() - 1;
		moveRelative(pageSize * n);
	} 

	
	private void passKeyEventToView(KeyEvent e)
	{
		
		assert (view.getKeyEventInterceptor() == keyHandler);
		view.setKeyEventInterceptor(null);

		
		
		
		view.getInputHandler().processKeyEvent(e, View.ACTION_BAR, false);

		
		
		if (this.isDisplayable())
		{
			view.setKeyEventInterceptor(keyHandler);
		}
	} 

	
	private class CandidateListModel extends AbstractListModel
	{
		public int getSize()
		{
			return candidates.getSize();
		}

		public Object getElementAt(int index)
		{
			
			
			
			return candidates;
		}
	} 

	
	private class CellRenderer implements ListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			return candidates.getCellRenderer(list, index,
				isSelected, cellHasFocus);
		}
	} 

	
	private class KeyHandler extends KeyAdapter
	{
		
		public void keyPressed(KeyEvent e)
		{
			CompletionPopup.this.keyPressed(e);

			if (candidates == null || !candidates.isValid())
			{
				dispose();
			}
			else if (!e.isConsumed())
			{
				switch(e.getKeyCode())
				{
				case KeyEvent.VK_TAB:
				case KeyEvent.VK_ENTER:
					if (doSelectedCompletion())
					{
						e.consume();
					}
					else
					{
						dispose();
					}
					break;
				case KeyEvent.VK_ESCAPE:
					dispose();
					e.consume();
					break;
				case KeyEvent.VK_UP:
					moveRelative(-1);
					e.consume();
					break;
				case KeyEvent.VK_DOWN:
					moveRelative(1);
					e.consume();
					break;
				case KeyEvent.VK_PAGE_UP:
					moveRelativePages(-1);
					e.consume();
					break;
				case KeyEvent.VK_PAGE_DOWN:
					moveRelativePages(1);
					e.consume();
					break;
				default:
					if(e.isActionKey()
						|| e.isControlDown()
						|| e.isAltDown()
						|| e.isMetaDown())
					{
						dispose();
					}
					break;
				}
			}

			if (!e.isConsumed())
			{
				passKeyEventToView(e);
			}
		} 

		
		public void keyTyped(KeyEvent e)
		{
			CompletionPopup.this.keyTyped(e);

			if (candidates == null || !candidates.isValid())
			{
				dispose();
			}

			if (!e.isConsumed())
			{
				passKeyEventToView(e);
			}
		} 
	} 

	
	private class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent e)
		{
			if (doSelectedCompletion())
			{
				e.consume();
			}
			else
			{
				dispose();
			}
		}
	} 

	
	private class WindowFocusHandler implements WindowFocusListener
	{
		public void windowGainedFocus(WindowEvent e)
		{
		}

		public void windowLostFocus(WindowEvent e)
		{
			dispose();
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.Mode,21,1,1,29,50,156,22,8,18,0.85,601,1.0,1,0.0,0.244897959,0,0,27.23809524,11,2.4286,0,"

package org.gjt.sp.jedit;


import java.lang.reflect.Method;
import java.util.Hashtable;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import org.gjt.sp.jedit.indent.DeepIndentRule;
import org.gjt.sp.jedit.indent.IndentRule;
import org.gjt.sp.jedit.indent.IndentRuleFactory;
import org.gjt.sp.jedit.indent.WhitespaceRule;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.jedit.syntax.ModeProvider;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class Mode
{
	
	
	public Mode(String name)
	{
		this.name = name;
		this.ignoreWhitespace = true;
		props = new Hashtable<String, Object>();
	} 

	
	
	public void init()
	{
		try
		{
			String filenameGlob = (String)getProperty(""filenameGlob"");
			if(filenameGlob != null && filenameGlob.length() != 0)
			{
				filenameRE = Pattern.compile(StandardUtilities.globToRE(filenameGlob),
							     Pattern.CASE_INSENSITIVE);
			}

			String firstlineGlob = (String)getProperty(""firstlineGlob"");
			if(firstlineGlob != null && firstlineGlob.length() != 0)
			{
				firstlineRE = Pattern.compile(StandardUtilities.globToRE(firstlineGlob),
							      Pattern.CASE_INSENSITIVE);
			}
		}
		catch(PatternSyntaxException re)
		{
			Log.log(Log.ERROR,this,""Invalid filename/firstline""
				+ "" globs in mode "" + name);
			Log.log(Log.ERROR,this,re);
		}

		
		
		
		
		
		
		marker = null;
	} 

	
	
	public TokenMarker getTokenMarker()
	{
		loadIfNecessary();
		return marker;
	} 

	
	
	public void setTokenMarker(TokenMarker marker)
	{
		this.marker = marker;
	} 

	
	
	public void loadIfNecessary()
	{
		if(marker == null)
		{
			ModeProvider.instance.loadMode(this);
			if (marker == null)
				Log.log(Log.ERROR, this, ""Mode not correctly loaded, token marker is still null"");
		}
	} 

	
	
	public Object getProperty(String key)
	{
		Object value = props.get(key);
		if(value != null)
			return value;
		return null;
	} 

	
	
	public boolean getBooleanProperty(String key)
	{
		Object value = getProperty(key);
		return StandardUtilities.getBoolean(value, false);
	} 

	
	
	public void setProperty(String key, Object value)
	{
		props.put(key,value);
	} 

	
	
	public void unsetProperty(String key)
	{
		props.remove(key);
	} 

	
	
	public void setProperties(Map props)
	{
		if(props == null)
			props = new Hashtable<String, Object>();

		ignoreWhitespace = !""false"".equalsIgnoreCase(
					(String)props.get(""ignoreWhitespace""));

		
		
		
		String filenameGlob = (String)this.props.get(""filenameGlob"");
		String firstlineGlob = (String)this.props.get(""firstlineGlob"");
		String filename = (String)this.props.get(""file"");
		this.props = props;
		if(filenameGlob != null)
			props.put(""filenameGlob"",filenameGlob);
		if(firstlineGlob != null)
			props.put(""firstlineGlob"",firstlineGlob);
		if(filename != null)
			props.put(""file"",filename);
	} 

	
	
	public boolean accept(String fileName, String firstLine)
	{
		return acceptFilename(fileName) || acceptFirstLine(firstLine);
	} 

	
	
	public boolean acceptFilename(String fileName)
	{
		return filenameRE != null && filenameRE.matcher(fileName).matches();
	} 

	
	
	public boolean acceptFirstLine(String firstLine)
	{
		return firstlineRE != null && firstlineRE.matcher(firstLine).matches();
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public String toString()
	{
		return name;
	} 

	
	public boolean getIgnoreWhitespace()
	{
		return ignoreWhitespace;
	} 

	

	public synchronized List<IndentRule> getIndentRules()
	{
		if (indentRules == null)
		{
			initIndentRules();
		}
		return indentRules;
	}

	public synchronized boolean isElectricKey(char ch)
	{
		if (electricKeys == null)
		{
			String[] props = {
				""indentOpenBrackets"",
				""indentCloseBrackets"",
				""electricKeys""
			};

			StringBuilder buf = new StringBuilder();
			for(int i = 0; i < props.length; i++)
			{
				String prop = (String) getProperty(props[i]);
				if (prop != null)
					buf.append(prop);
			}

			electricKeys = buf.toString();
		}

		return (electricKeys.indexOf(ch) >= 0);
	}

	private void initIndentRules()
	{
		List<IndentRule> rules = new LinkedList<IndentRule>();

		String[] regexpProps = {
			""indentNextLine"",
			""indentNextLines""
		};

		for(int i = 0; i < regexpProps.length; i++)
		{
			IndentRule rule = createRegexpIndentRule(regexpProps[i]);
			if(rule != null)
				rules.add(rule);
		}

		String[] bracketProps = {
			""indentOpenBracket"",
			""indentCloseBracket"",
			""unalignedOpenBracket"",
			""unalignedCloseBracket"",
		};

		for(int i = 0; i < bracketProps.length; i++)
		{
			createBracketIndentRules(bracketProps[i], rules);
		}

		String[] finalProps = {
			""unindentThisLine"",
			""unindentNextLines""
		};

		for(int i = 0; i < finalProps.length; i++)
		{
			IndentRule rule = createRegexpIndentRule(finalProps[i]);
			if(rule != null)
				rules.add(rule);
		}

		if (getBooleanProperty(""deepIndent""))
		{
			String unalignedOpenBrackets = (String) getProperty(""unalignedOpenBrackets"");
			if (unalignedOpenBrackets != null)
			{
				for (int i = 0 ; i < unalignedOpenBrackets.length();i++)
				{
					char openChar = unalignedOpenBrackets.charAt(i);
					char closeChar = TextUtilities.getComplementaryBracket(openChar, null);
					if (closeChar != '\0')
						rules.add(new DeepIndentRule(openChar, closeChar));
				}
			}
		}

		if (!getIgnoreWhitespace())
			rules.add(new WhitespaceRule());

		indentRules = Collections.unmodifiableList(rules);
	}

	private IndentRule createRegexpIndentRule(String prop)
	{
		String value = (String) getProperty(prop);

		try
		{
			if(value != null)
			{
				Method m = IndentRuleFactory.class.getMethod(
					prop,new Class[] { String.class });
				return (IndentRule)m.invoke(null, value);
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Bad indent rule "" + prop
				+ '=' + value + ':');
			Log.log(Log.ERROR,this,e);
		}

		return null;
	}

	private void createBracketIndentRules(String prop,
						List<IndentRule> rules)
	{
		String value = (String) getProperty(prop + 's');

		try
		{
			if(value != null)
			{
				for(int i = 0; i < value.length(); i++)
				{
					char ch = value.charAt(i);

					Method m = IndentRuleFactory.class.getMethod(
						prop,new Class[] { char.class });
					rules.add((IndentRule) m.invoke(null, ch));
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Bad indent rule "" + prop
				+ '=' + value + ':');
			Log.log(Log.ERROR,this,e);
		}
	}

	

	
	protected String name;
	protected Map<String, Object> props;
	private Pattern firstlineRE;
	private Pattern filenameRE;
	protected TokenMarker marker;
	private List<IndentRule> indentRules;
	private String electricKeys;
	private boolean ignoreWhitespace;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bufferio.MarkersSaveRequest,3,2,0,9,28,0,1,9,2,0.571428571,177,0.857142857,3,0.75,0.428571429,0,0,55.66666667,2,1.0,0,"

package org.gjt.sp.jedit.bufferio;


import java.io.*;
import java.util.List;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.util.*;




public class MarkersSaveRequest extends WorkRequest
{
	
	public static final String ERROR_OCCURRED = ""MarkersSaveRequest__error"";
	

	
	
	public MarkersSaveRequest(View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		this.view = view;
		this.buffer = buffer;
		this.session = session;
		this.vfs = vfs;
		this.path = path;
		this.markersPath = Buffer.getMarkersPath(vfs, path);

	} 

	
	public void run()
	{
		OutputStream out = null;

		try
		{
			
			setAbortable(true);
			try
			{
				
				
				if((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)
				{
					if(buffer.getMarkers().isEmpty())
						vfs._delete(session,markersPath,view);
					else
					{
						String[] args = { vfs.getFileName(path) };
						setStatus(jEdit.getProperty(""vfs.status.save-markers"",args));
						setValue(0);
						out = vfs._createOutputStream(session,markersPath,view);
						if(out != null)
							writeMarkers(out);
						}
				}
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
		catch(WorkThread.Abort a)
		{
			IOUtilities.closeQuietly(out);
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
	} 

	
	private void writeMarkers(OutputStream out)
		throws IOException
	{
		Writer o = new BufferedWriter(new OutputStreamWriter(out));
		try
		{
			List<Marker> markers = buffer.getMarkers();
			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = markers.get(i);
				o.write('!');
				o.write(marker.getShortcut());
				o.write(';');

				String pos = String.valueOf(marker.getPosition());
				o.write(pos);
				o.write(';');
				o.write(pos);
				o.write('\n');
			}
		}
		finally
		{
			o.close();
		}
	} 

	
	protected View view;
	protected Buffer buffer;
	protected Object session;
	protected VFS vfs;
	protected String path;
	protected String markersPath;
	

}
"
jEdit,4.3,org.gjt.sp.jedit.JEditActionSet,19,1,2,16,55,0,10,8,14,0.722222222,398,0.8,1,0.0,0.201388889,0,0,19.68421053,3,1.6316,0,"

package org.gjt.sp.jedit;

import java.io.*;
import java.net.URL;
import java.util.*;

import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.jedit.input.InputHandlerProvider;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;


public abstract class JEditActionSet<E extends JEditAbstractEditAction> implements InputHandlerProvider
{
	
	
	public JEditActionSet()
	{
		actions = new Hashtable<String, Object>();
		loaded = true;
	} 
	
	
	
	public JEditActionSet(String[] cachedActionNames, URL uri)
	{
		this();
		this.uri = uri;
		if(cachedActionNames != null)
		{
			for(int i = 0; i < cachedActionNames.length; i++)
			{
				actions.put(cachedActionNames[i],placeholder);
			}
		}
		loaded = false;
	} 

	
	
	public void addAction(E action)
	{
		actions.put(action.getName(),action);
		if(context != null)
		{
			context.actionNames = null;
			context.actionHash.put(action.getName(),this);
		}
	} 

	
	
	public void removeAction(String name)
	{
		actions.remove(name);
		if(context != null)
		{
			context.actionNames = null;
			context.actionHash.remove(name);
		}
	} 

	
	
	public void removeAllActions()
	{
		if(context != null)
		{
			context.actionNames = null;
			String[] actions = getActionNames();
			for(int i = 0; i < actions.length; i++)
			{
				context.actionHash.remove(actions[i]);
			}
		}
		this.actions.clear();
	} 

	
	
	public E getAction(String name)
	{
		Object obj = actions.get(name);
		if(obj == placeholder)
		{
			load();
			obj = actions.get(name);
			if(obj == placeholder)
			{
				Log.log(Log.WARNING,this,""Outdated cache"");
				obj = null;
			}
		}

		return (E) obj;
	} 

	
	
	public int getActionCount()
	{
		return actions.size();
	} 

	
	
	public String[] getActionNames()
	{
		String[] retVal = new String[actions.size()];
		Enumeration e = actions.keys();
		int i = 0;
		while(e.hasMoreElements())
		{
			retVal[i++] = (String)e.nextElement();
		}
		return retVal;
	} 

	
	
	public String[] getCacheableActionNames()
	{
		LinkedList<String> retVal = new LinkedList<String>();
		Enumeration e = actions.elements();
		while(e.hasMoreElements())
		{
			Object obj = e.nextElement();
			if(obj == placeholder)
			{
				
				
				Log.log(Log.WARNING,this,""Action set not up ""
					+ ""to date"");
			}
			else if(obj instanceof JEditBeanShellAction)
				retVal.add(((JEditBeanShellAction)obj).getName());
		}
		return retVal.toArray(new String[retVal.size()]);
	} 
	
	
	
	protected abstract E[] getArray(int size);		
	

	
	
	public E[] getActions()
	{
		load();
		E[] retVal = getArray(actions.size());
		Enumeration e = actions.elements();
		int i = 0;
		while(e.hasMoreElements())
		{
			retVal[i++] = (E) e.nextElement();
		}
		return retVal;
	} 

	
	
	public boolean contains(String action)
	{
		boolean retval = actions.containsKey(action);
		return retval;

	} 

	
	
	public int size()
	{
		return actions.size();
	} 

	
	
	public void load()
	{
		if(loaded)
			return;

		loaded = true;
		

		if (uri == null)
			return;
		try
		{
			Log.log(Log.DEBUG,this,""Loading actions from "" + uri);
			ActionListHandler ah = new ActionListHandler(uri.toString(),this);
			if ( XMLUtilities.parseXML(uri.openStream(), ah))
			{
				Log.log(Log.ERROR, this, ""Unable to parse: "" + uri);
			}
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,this,uri,e);
		}
	} 
	
	
	
	protected abstract JEditAbstractEditAction createBeanShellAction(String actionName,
									   String code,
									   String selected,
									   boolean noRepeat,
									   boolean noRecord,
									   boolean noRememberLast);
	
	
	
	
	public void initKeyBindings()
	{
		AbstractInputHandler inputHandler = getInputHandler();

		Iterator<Map.Entry<String,Object>> iter = actions.entrySet().iterator();
		while(iter.hasNext())
		{
			Map.Entry<String,Object> entry = iter.next();
			String name = entry.getKey();

			String shortcut1 = getProperty(name + "".shortcut"");
			if(shortcut1 != null)
				inputHandler.addKeyBinding(shortcut1,name);

			String shortcut2 = getProperty(name + "".shortcut2"");
			if(shortcut2 != null)
				inputHandler.addKeyBinding(shortcut2,name);
		}
	} 
	
	
	
	protected abstract String getProperty(String name);
	

	
	JEditActionContext context;

	
	void getActionNames(List<String> vec)
	{
		Enumeration<String> e = actions.keys();
		while(e.hasMoreElements())
			vec.add(e.nextElement());
	} 

	

	
	protected Hashtable<String,Object> actions;
	protected URL uri;
	protected boolean loaded;

	protected static final Object placeholder = new Object();

	
}
"
jEdit,4.3,org.gjt.sp.jedit.help.HelpIndex,11,1,0,11,57,23,3,8,7,0.533333333,515,1.0,0,0.0,0.35,0,0,45.54545455,3,1.1818,0,"

package org.gjt.sp.jedit.help;


import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class HelpIndex
{
	
	public HelpIndex()
	{
		words = new HashMap<String, Object>();
		files = new ArrayList<HelpFile>();

		ignoreWord(""a"");
		ignoreWord(""an"");
		ignoreWord(""and"");
		ignoreWord(""are"");
		ignoreWord(""as"");
		ignoreWord(""be"");
		ignoreWord(""by"");
		ignoreWord(""can"");
		ignoreWord(""do"");
		ignoreWord(""for"");
		ignoreWord(""from"");
		ignoreWord(""how"");
		ignoreWord(""i"");
		ignoreWord(""if"");
		ignoreWord(""in"");
		ignoreWord(""is"");
		ignoreWord(""it"");
		ignoreWord(""not"");
		ignoreWord(""of"");
		ignoreWord(""on"");
		ignoreWord(""or"");
		ignoreWord(""s"");
		ignoreWord(""that"");
		ignoreWord(""the"");
		ignoreWord(""this"");
		ignoreWord(""to"");
		ignoreWord(""will"");
		ignoreWord(""with"");
		ignoreWord(""you"");
	} 

	
	public void indexEditorHelp()
	{
		try
		{
			String jEditHome = jEdit.getJEditHome();
			if(jEditHome != null)
			{
				indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""users-guide""));
				indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""FAQ""));
				indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""news43""));
			}
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,""Error indexing editor help"");
			Log.log(Log.ERROR,this,e);
		}

		PluginJAR[] jars = jEdit.getPluginJARs();
		for(int i = 0; i < jars.length; i++)
		{
			try
			{
				indexJAR(jars[i].getZipFile());
			}
			catch(Throwable e)
			{
				Log.log(Log.ERROR,this,""Error indexing JAR: ""
					+ jars[i].getPath());
				Log.log(Log.ERROR,this,e);
			}
		}

		Log.log(Log.DEBUG,this,""Indexed "" + words.size() + "" words"");
	} 

	
	
	public void indexDirectory(String dir) throws Exception
	{
		String[] files = VFSManager.getFileVFS()
			._listDirectory(null,dir,""*.{html,txt}"",true,null);

		for(int i = 0; i < files.length; i++)
		{
			indexURL(files[i]);
		}
	} 

	
	
	public void indexJAR(ZipFile jar) throws Exception
	{
		Enumeration e = jar.entries();
		while(e.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)e.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.endsWith("".html""))
			{
				
				String url = ""jeditresource:/"" +
					MiscUtilities.getFileName(jar.getName())
					+ ""!/"" + name;
				Log.log(Log.DEBUG,this,url);
				indexStream(jar.getInputStream(entry),url);
			}
		}
	} 

	
	
	public void indexURL(String url) throws Exception
	{
		InputStream _in;

		if(MiscUtilities.isURL(url))
			_in =  new URL(url).openStream();
		else
		{
			_in = new FileInputStream(url);
			
			url = ""file:"" + url;
		}

		indexStream(_in,url);
	} 

	
	public Word lookupWord(String word)
	{
		Object o = words.get(word);
		if(o == IGNORE)
			return null;
		else
			return (Word)o;
	} 

	
	public HelpFile getFile(int index)
	{
		return files.get(index);
	} 

	
	
	private static Object IGNORE = new Object();
	private Map<String, Object> words;
	private List<HelpFile> files;

	
	private void ignoreWord(String word)
	{
		words.put(word,IGNORE);
	} 

	
	
	private void indexStream(InputStream _in, String fileName)
		throws Exception
	{
		HelpFile file = new HelpFile(fileName);
		files.add(file);
		int index = files.size() - 1;

		StringBuilder titleText = new StringBuilder();

		BufferedReader in = new BufferedReader(
			new InputStreamReader(_in));

		try
		{
			StringBuilder word = new StringBuilder();
			boolean insideTag = false;
			boolean insideEntity = false;

			boolean title = false;

			int c;
			while((c = in.read()) != -1)
			{
				char ch = (char)c;
				if(insideTag)
				{
					if(ch == '>')
					{
						if(word.toString().equals(""title""))
							title = true;
						insideTag = false;
						word.setLength(0);
					}
					else
						word.append(ch);
				}
				else if(insideEntity)
				{
					if(ch == ';')
						insideEntity = false;
				}
				else if(ch == '<')
				{
					if(title)
						title = false;

					if(word.length() != 0)
					{
						addWord(word.toString(),index,title);
						word.setLength(0);
					}

					insideTag = true;
				}
				else if(ch == '&')
					insideEntity = true;
				else if(title)
					titleText.append(ch);
				else if(!Character.isLetterOrDigit(ch))
				{
					if(word.length() != 0)
					{
						addWord(word.toString(),index,title);
						word.setLength(0);
					}
				}
				else
					word.append(ch);
			}
		}
		finally
		{
			in.close();
		}

		if(titleText.length() == 0)
			file.title = fileName;
		else
			file.title = titleText.toString();
	} 

	
	private void addWord(String word, int file, boolean title)
	{
		word = word.toLowerCase();

		Object o = words.get(word);
		if(o == IGNORE)
			return;

		if(o == null)
			words.put(word,new Word(word,file,title));
		else
			((Word)o).addOccurrence(file,title);
	} 

	

	
	static class Word
	{
		
		static final int TITLE_OCCUR = 10;

		
		String word;

		
		int occurCount = 0;
		Occurrence[] occurrences;

		Word(String word, int file, boolean title)
		{
			this.word = word;
			occurrences = new Occurrence[5];
			addOccurrence(file,title);
		}

		void addOccurrence(int file, boolean title)
		{
			for(int i = 0; i < occurCount; i++)
			{
				if(occurrences[i].file == file)
				{
					occurrences[i].count += (title ? TITLE_OCCUR : 1);
					return;
				}
			}

			if(occurCount >= occurrences.length)
			{
				Occurrence[] newOccur = new Occurrence[occurrences.length * 2];
				System.arraycopy(occurrences,0,newOccur,0,occurCount);
				occurrences = newOccur;
			}

			occurrences[occurCount++] = new Occurrence(file,title);
		}

		static class Occurrence
		{
			int file;
			int count;

			Occurrence(int file, boolean title)
			{
				this.file = file;
				this.count = (title ? TITLE_OCCUR : 1);
			}
		}
	} 

	
	static class HelpFile
	{
		String file;
		String title;

		HelpFile(String file)
		{
			this.file = file;
		}

		public String toString()
		{
			return title;
		}

		public boolean equals(Object o)
		{
			if(o instanceof HelpFile)
				return ((HelpFile)o).file.equals(file);
			else
				return false;
		}
	} 
}"
jEdit,4.3,org.gjt.sp.jedit.buffer.JEditBuffer,119,1,1,90,279,5913,72,28,97,0.886101695,4045,0.84,8,0.0,0.103641457,0,0,32.78151261,17,2.9076,1,"

package org.gjt.sp.jedit.buffer;


import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.Mode;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.jedit.indent.IndentAction;
import org.gjt.sp.jedit.indent.IndentRule;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;

import javax.swing.text.Position;
import javax.swing.text.Segment;
import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Pattern;



public class JEditBuffer
{
	
	public static final String LINESEP = ""lineSeparator"";

	
	public static final String ENCODING = ""encoding"";

	
	public JEditBuffer(Map props)
	{
		bufferListeners = new Vector<Listener>();
		lock = new ReentrantReadWriteLock();
		contentMgr = new ContentManager();
		lineMgr = new LineManager();
		positionMgr = new PositionManager(this);
		undoMgr = new UndoManager(this);
		integerArray = new IntegerArray();
		propertyLock = new Object();
		properties = new HashMap<Object, PropValue>();

		
		Set<Map.Entry> set = props.entrySet();
		for (Map.Entry entry : set)
		{
			properties.put(entry.getKey(),new PropValue(entry.getValue(),false));
		} 

		
		
		if(getProperty(ENCODING) == null)
			properties.put(ENCODING,new PropValue(System.getProperty(""file.encoding""),false));
		if(getProperty(LINESEP) == null)
			properties.put(LINESEP,new PropValue(System.getProperty(""line.separator""),false));
	}

	
	public JEditBuffer()
	{
		bufferListeners = new Vector<Listener>();
		lock = new ReentrantReadWriteLock();
		contentMgr = new ContentManager();
		lineMgr = new LineManager();
		positionMgr = new PositionManager(this);
		undoMgr = new UndoManager(this);
		integerArray = new IntegerArray();
		propertyLock = new Object();
		properties = new HashMap<Object, PropValue>();

		properties.put(""wrap"",new PropValue(""none"",false));
		properties.put(""folding"",new PropValue(""none"",false));
		tokenMarker = new TokenMarker();
		tokenMarker.addRuleSet(new ParserRuleSet(""text"",""MAIN""));
		setTokenMarker(tokenMarker);

		loadText(null,null);
		
		if(getProperty(ENCODING) == null)
			properties.put(ENCODING,new PropValue(System.getProperty(""file.encoding""),false));
		if(getProperty(LINESEP) == null)
			properties.put(LINESEP,new PropValue(System.getProperty(""line.separator""),false));

		setFoldHandler(new DummyFoldHandler());
	} 

	

	
	
	public boolean isDirty()
	{
		return dirty;
	} 

	
	public boolean isLoading()
	{
		return loading;
	} 

	
	public void setLoading(boolean loading)
	{
		this.loading = loading;
	} 

	
	
	public boolean isPerformingIO()
	{
		return isLoading() || io;
	} 

	
	
	public void setPerformingIO(boolean io)
	{
		this.io = io;
	} 

	
	
	public boolean isEditable()
	{
		return !(isReadOnly() || isPerformingIO());
	} 

	
	
	public boolean isReadOnly()
	{
		return readOnly || readOnlyOverride;
	} 

	
	
	public void setReadOnly(boolean readOnly)
	{
		readOnlyOverride = readOnly;
	} 

	
	
	public void setDirty(boolean d)
	{
		boolean editable = isEditable();

		if(d)
		{
			if(editable)
				dirty = true;
		}
		else
		{
			dirty = false;

			
			
			if(!isUndoInProgress())
			{
				
				
				undoMgr.resetClearDirty();
			}
		}
	} 

	

	

	
	
	public void readLock()
	{
		lock.readLock().lock();
	} 

	
	
	public void readUnlock()
	{
		lock.readLock().unlock();
	} 

	
	
	public void writeLock()
	{
		lock.writeLock().lock();
	} 

	
	
	public void writeUnlock()
	{
		lock.writeLock().unlock();
	} 

	

	

	
	
	public int getLength()
	{
		
		return contentMgr.getLength();
	} 

	
	
	public int getLineCount()
	{
		
		return lineMgr.getLineCount();
	} 

	
	
	public int getLineOfOffset(int offset)
	{
		try
		{
			readLock();

			if(offset < 0 || offset > getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			return lineMgr.getLineOfOffset(offset);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineStartOffset(int line)
	{
		try
		{
			readLock();

			if(line < 0 || line >= lineMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);
			else if(line == 0)
				return 0;

			return lineMgr.getLineEndOffset(line - 1);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineEndOffset(int line)
	{
		try
		{
			readLock();

			if(line < 0 || line >= lineMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);

			return lineMgr.getLineEndOffset(line);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineLength(int line)
	{
		try
		{
			readLock();

			return getLineEndOffset(line)
				- getLineStartOffset(line) - 1;
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getPriorNonEmptyLine(int lineIndex)
	{
		int returnValue = -1;

		if (!mode.getIgnoreWhitespace())
		{
			return lineIndex - 1;
		}

		for(int i = lineIndex - 1; i >= 0; i--)
		{
			Segment seg = new Segment();
			getLineText(i,seg);
			if(seg.count != 0)
				returnValue = i;
			for(int j = 0; j < seg.count; j++)
			{
				char ch = seg.array[seg.offset + j];
				if(!Character.isWhitespace(ch))
					return i;
			}
		}

		
		
		return returnValue;
	} 

	

	

	
	
	public String getLineText(int line)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			readLock();

			int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);
			int end = lineMgr.getLineEndOffset(line);

			return getText(start,end - start - 1);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	public void getLineText(int line, Segment segment)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			readLock();

			int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);
			int end = lineMgr.getLineEndOffset(line);

			getText(start,end - start - 1,segment);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public CharSequence getLineSegment(int line)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			readLock();

			int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);
			int end = lineMgr.getLineEndOffset(line);

			return getSegment(start,end - start - 1);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public String getText(int start, int length)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			return contentMgr.getText(start,length);
		}
		finally
		{
			readUnlock();
		}
	}

	
	public void getText(int start, int length, Segment seg)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			contentMgr.getText(start,length,seg);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public CharSequence getSegment(int start, int length)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			return contentMgr.getSegment(start,length);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void insert(int offset, String str)
	{
		if(str == null)
			return;

		int len = str.length();

		if(len == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			contentMgr.insert(offset,str);

			integerArray.clear();

			for(int i = 0; i < len; i++)
			{
				if(str.charAt(i) == '\n')
					integerArray.add(i + 1);
			}

			if(!undoInProgress)
			{
				undoMgr.contentInserted(offset,len,str,!dirty);
			}

			contentInserted(offset,len,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	}

	
	public void insert(int offset, Segment seg)
	{
		if(seg.count == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			contentMgr.insert(offset,seg);

			integerArray.clear();

			for(int i = 0; i < seg.count; i++)
			{
				if(seg.array[seg.offset + i] == '\n')
					integerArray.add(i + 1);
			}

			if(!undoInProgress)
			{
				undoMgr.contentInserted(offset,seg.count,
					seg.toString(),!dirty);
			}

			contentInserted(offset,seg.count,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void remove(int offset, int length)
	{
		if(length == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			transaction = true;

			writeLock();

			if(offset < 0 || length < 0
				|| offset + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset + "":"" + length);

			int startLine = lineMgr.getLineOfOffset(offset);
			int endLine = lineMgr.getLineOfOffset(offset + length);

			int numLines = endLine - startLine;

			if(!undoInProgress && !loading)
			{
				undoMgr.contentRemoved(offset,length,
					getText(offset,length),
					!dirty);
			}

			firePreContentRemoved(startLine,offset,numLines,length);

			contentMgr.remove(offset,length);
			lineMgr.contentRemoved(startLine,offset,numLines,length);
			positionMgr.contentRemoved(offset,length);

			setDirty(true);

			fireContentRemoved(startLine,offset,numLines,length);

			
			if(!undoInProgress && !insideCompoundEdit())
				fireTransactionComplete();

		}
		finally
		{
			transaction = false;

			writeUnlock();
		}
	} 

	

	

	
	
	public void removeTrailingWhiteSpace(int[] lines)
	{
		try
		{
			beginCompoundEdit();

			for(int i = 0; i < lines.length; i++)
			{
				int pos, lineStart, lineEnd, tail;
				Segment seg = new Segment();
				getLineText(lines[i],seg);

				
				if (seg.count == 0) continue;

				lineStart = seg.offset;
				lineEnd = seg.offset + seg.count - 1;

				for (pos = lineEnd; pos >= lineStart; pos--)
				{
					if (!Character.isWhitespace(seg.array[pos]))
						break;
				}

				tail = lineEnd - pos;

				
				if (tail == 0) continue;

				remove(getLineEndOffset(lines[i]) - 1 - tail,tail);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void shiftIndentLeft(int[] lines)
	{
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");

		try
		{
			beginCompoundEdit();

			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				CharSequence line = getLineSegment(lines[i]);
				int whiteSpace = StandardUtilities
					.getLeadingWhiteSpace(line);
				if(whiteSpace == 0)
					continue;
				int whiteSpaceWidth = Math.max(0,StandardUtilities
					.getLeadingWhiteSpaceWidth(line,tabSize)
					- indentSize);

				insert(lineStart + whiteSpace,StandardUtilities
					.createWhiteSpace(whiteSpaceWidth,
					noTabs ? 0 : tabSize));
				remove(lineStart,whiteSpace);
			}

		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void shiftIndentRight(int[] lines)
	{
		try
		{
			beginCompoundEdit();

			int tabSize = getTabSize();
			int indentSize = getIndentSize();
			boolean noTabs = getBooleanProperty(""noTabs"");
			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				CharSequence line = getLineSegment(lines[i]);
				int whiteSpace = StandardUtilities
					.getLeadingWhiteSpace(line);

				
				
				

				int whiteSpaceWidth = StandardUtilities
					.getLeadingWhiteSpaceWidth(
					line,tabSize) + indentSize;
				insert(lineStart + whiteSpace,StandardUtilities
					.createWhiteSpace(whiteSpaceWidth,
					noTabs ? 0 : tabSize));
				remove(lineStart,whiteSpace);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void indentLines(int start, int end)
	{
		try
		{
			beginCompoundEdit();
			for(int i = start; i <= end; i++)
				indentLine(i,true);
		}
		finally
		{
			endCompoundEdit();
		}
	}

	
	public void indentLines(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
				indentLine(lines[i],true);
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	 @Deprecated
	 public boolean indentLine(int lineIndex, boolean canIncreaseIndent,
		boolean canDecreaseIndent)
	{
		return indentLine(lineIndex,canDecreaseIndent);
	}

	
	public boolean indentLine(int lineIndex, boolean canDecreaseIndent)
	{
		int[] whitespaceChars = new int[1];
		int currentIndent = getCurrentIndentForLine(lineIndex,
			whitespaceChars);
		int prevLineIndex = getPriorNonEmptyLine(lineIndex);
		int prevLineIndent = (prevLineIndex == -1) ? 0 :
			StandardUtilities.getLeadingWhiteSpaceWidth(getLineSegment(
				prevLineIndex), getTabSize());
		int idealIndent = getIdealIndentForLine(lineIndex, prevLineIndex,
			prevLineIndent);

		if (idealIndent == -1 || idealIndent == currentIndent ||
			(!canDecreaseIndent && idealIndent < currentIndent))
			return false;

		
		try
		{
			beginCompoundEdit();

			int start = getLineStartOffset(lineIndex);

			remove(start,whitespaceChars[0]);
			String prevIndentString = (prevLineIndex >= 0) ?
				StandardUtilities.getIndentString(getLineText(
					prevLineIndex)) : null;
			String indentString;
			if (prevIndentString == null)
			{
				indentString = StandardUtilities.createWhiteSpace(
					idealIndent,
					getBooleanProperty(""noTabs"") ? 0 : getTabSize());
			}
			else if (idealIndent == prevLineIndent)
				indentString = prevIndentString;
			else if (idealIndent < prevLineIndent)
				indentString = StandardUtilities.truncateWhiteSpace(
					idealIndent, getTabSize(), prevIndentString);
			else
				indentString = prevIndentString +
					StandardUtilities.createWhiteSpace(
						idealIndent - prevLineIndent,
						getBooleanProperty(""noTabs"") ? 0 : getTabSize(),
						prevLineIndent);
			insert(start, indentString);
		}
		finally
		{
			endCompoundEdit();
		}

		return true;
	} 

	
	
	public int getCurrentIndentForLine(int lineIndex, int[] whitespaceChars)
	{
		Segment seg = new Segment();
		getLineText(lineIndex,seg);

		int tabSize = getTabSize();

		int currentIndent = 0;
loop:		for(int i = 0; i < seg.count; i++)
		{
			char c = seg.array[seg.offset + i];
			switch(c)
			{
			case ' ':
				currentIndent++;
				if(whitespaceChars != null)
					whitespaceChars[0]++;
				break;
			case '\t':
				currentIndent += tabSize - (currentIndent
					% tabSize);
				if(whitespaceChars != null)
					whitespaceChars[0]++;
				break;
			default:
				break loop;
			}
		}

		return currentIndent;
	} 

	
	
	public int getIdealIndentForLine(int lineIndex)
	{
		int prevLineIndex = getPriorNonEmptyLine(lineIndex);
		int oldIndent = prevLineIndex == -1 ? 0 :
			StandardUtilities.getLeadingWhiteSpaceWidth(
			getLineSegment(prevLineIndex),
			getTabSize());
		return getIdealIndentForLine(lineIndex, prevLineIndex,
			oldIndent);
	} 

	
	
	private int getIdealIndentForLine(int lineIndex, int prevLineIndex,
		int oldIndent)
	{
		int prevPrevLineIndex = prevLineIndex < 0 ? -1
			: getPriorNonEmptyLine(prevLineIndex);
		int newIndent = oldIndent;

		List<IndentRule> indentRules = getIndentRules(lineIndex);
		List<IndentAction> actions = new LinkedList<IndentAction>();
		for (int i = 0;i<indentRules.size();i++)
		{
			IndentRule rule = indentRules.get(i);
			rule.apply(this,lineIndex,prevLineIndex,
				prevPrevLineIndex,actions);
		}


		for (IndentAction action : actions)
		{
			newIndent = action.calculateIndent(this, lineIndex,
					oldIndent, newIndent);
			if (!action.keepChecking())
				break;
		}
		if (newIndent < 0)
			newIndent = 0;

		return newIndent;
	} 

	
	
	public int getVirtualWidth(int line, int column)
	{
		try
		{
			readLock();

			int start = getLineStartOffset(line);
			Segment seg = new Segment();
			getText(start,column,seg);

			return StandardUtilities.getVirtualWidth(seg,getTabSize());
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getOffsetOfVirtualColumn(int line, int column,
		int[] totalVirtualWidth)
	{
		try
		{
			readLock();

			Segment seg = new Segment();
			getLineText(line,seg);

			return StandardUtilities.getOffsetOfVirtualColumn(seg,
				getTabSize(),column,totalVirtualWidth);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void insertAtColumn(int line, int col, String str)
	{
		try
		{
			writeLock();

			int[] total = new int[1];
			int offset = getOffsetOfVirtualColumn(line,col,total);
			if(offset == -1)
			{
				offset = getLineEndOffset(line) - 1;
				str = StandardUtilities.createWhiteSpace(col - total[0],0) + str;
			}
			else
				offset += getLineStartOffset(line);

			insert(offset,str);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public int insertIndented(int offset, String text)
	{
		try
		{
			beginCompoundEdit();

			
			int firstLine = getLineOfOffset(offset);
			CharSequence lineText = getLineSegment(firstLine);
			int leadingIndent
				= StandardUtilities.getLeadingWhiteSpaceWidth(
				lineText,getTabSize());

			String whiteSpace = StandardUtilities.createWhiteSpace(
				leadingIndent,getBooleanProperty(""noTabs"")
				? 0 : getTabSize());

			insert(offset,text);

			int lastLine = getLineOfOffset(offset + text.length());

			
			
			for(int i = firstLine + 1; i <= lastLine; i++)
			{
				insert(getLineStartOffset(i),whiteSpace);
			}

			return whiteSpace.length();
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public boolean isElectricKey(char ch)
	{
		return mode.isElectricKey(ch);
	}

	
	public boolean isElectricKey(char ch, int line)
	{
		TokenMarker.LineContext ctx = lineMgr.getLineContext(line);
		Mode mode = ModeProvider.instance.getMode(ctx.rules.getModeName());

		
		if (mode == null)
			return false;
		return mode.isElectricKey(ch);
	} 

	

	

	
	
	public void markTokens(int lineIndex, TokenHandler tokenHandler)
	{
		Segment seg = new Segment();

		if(lineIndex < 0 || lineIndex >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(lineIndex);

		int firstInvalidLineContext = lineMgr.getFirstInvalidLineContext();
		int start;
		if(textMode || firstInvalidLineContext == -1)
		{
			start = lineIndex;
		}
		else
		{
			start = Math.min(firstInvalidLineContext,
				lineIndex);
		}

		if(Debug.TOKEN_MARKER_DEBUG)
			Log.log(Log.DEBUG,this,""tokenize from "" + start + "" to "" + lineIndex);
		TokenMarker.LineContext oldContext = null;
		TokenMarker.LineContext context = null;
		for(int i = start; i <= lineIndex; i++)
		{
			getLineText(i,seg);

			oldContext = lineMgr.getLineContext(i);

			TokenMarker.LineContext prevContext = (
				(i == 0 || textMode) ? null
				: lineMgr.getLineContext(i - 1)
			);

			context = tokenMarker.markTokens(prevContext,
				(i == lineIndex ? tokenHandler
				: DummyTokenHandler.INSTANCE), seg);
			lineMgr.setLineContext(i,context);
		}

		int lineCount = lineMgr.getLineCount();
		if(lineCount - 1 == lineIndex)
			lineMgr.setFirstInvalidLineContext(-1);
		else if(oldContext != context)
			lineMgr.setFirstInvalidLineContext(lineIndex + 1);
		else if(firstInvalidLineContext == -1)
			;
		else
		{
			lineMgr.setFirstInvalidLineContext(Math.max(
				firstInvalidLineContext,lineIndex + 1));
		}
	} 

	
	public TokenMarker getTokenMarker()
	{
		return tokenMarker;
	} 

	
	public void setTokenMarker(TokenMarker tokenMarker)
	{
		TokenMarker oldTokenMarker = this.tokenMarker;

		this.tokenMarker = tokenMarker;

		
		if(oldTokenMarker != null && tokenMarker != oldTokenMarker)
		{
			lineMgr.setFirstInvalidLineContext(0);
		}
	} 

	
	
	public Position createPosition(int offset)
	{
		try
		{
			readLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			return positionMgr.createPosition(offset);
		}
		finally
		{
			readUnlock();
		}
	} 

	

	

	
	
	public void propertiesChanged()
	{
		String folding = getStringProperty(""folding"");
		FoldHandler handler = FoldHandler.getFoldHandler(folding);

		if(handler != null)
		{
			setFoldHandler(handler);
		}
		else
		{
			if (folding != null)
				Log.log(Log.WARNING, this, ""invalid 'folding' property: "" + folding);
			setFoldHandler(new DummyFoldHandler());
		}
	} 

	
	
	public int getTabSize()
	{
		int tabSize = getIntegerProperty(""tabSize"",8);
		if(tabSize <= 0)
			return 8;
		else
			return tabSize;
	} 

	
	
	public int getIndentSize()
	{
		int indentSize = getIntegerProperty(""indentSize"",8);
		if(indentSize <= 0)
			return 8;
		else
			return indentSize;
	} 

	
	
	public Object getProperty(Object name)
	{
		synchronized(propertyLock)
		{
			
			PropValue o = properties.get(name);
			if(o != null)
				return o.value;

			
			if(!(name instanceof String))
				return null;

			Object retVal = getDefaultProperty((String)name);

			if(retVal == null)
				return null;
			else
			{
				properties.put(name,new PropValue(retVal,true));
				return retVal;
			}
		}
	} 

	
	public Object getDefaultProperty(String key)
	{
		return null;
	} 

	
	
	public void setProperty(String name, Object value)
	{
		if(value == null)
			properties.remove(name);
		else
		{
			PropValue test = properties.get(name);
			if(test == null)
				properties.put(name,new PropValue(value,false));
			else if(test.value.equals(value))
			{
				
			}
			else
			{
				test.value = value;
				test.defaultValue = false;
			}
		}
	} 

	
	public void setDefaultProperty(String name, Object value)
	{
		properties.put(name,new PropValue(value,true));
	} 

	
	
	public void unsetProperty(String name)
	{
		properties.remove(name);
	} 

	
	public void resetCachedProperties()
	{
		
		
		Iterator<PropValue> iter = properties.values().iterator();
		while(iter.hasNext())
		{
			PropValue value = iter.next();
			if(value.defaultValue)
				iter.remove();
		}
	} 

	
	
	public String getStringProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj != null)
			return obj.toString();
		else
			return null;
	} 

	
	
	public void setStringProperty(String name, String value)
	{
		setProperty(name,value);
	} 

	
	
	public boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name, false);
	}

	
	public boolean getBooleanProperty(String name, boolean def)
	{
		Object obj = getProperty(name);
		return StandardUtilities.getBoolean(obj, def);
	} 

	
	
	public void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? Boolean.TRUE : Boolean.FALSE);
	} 

	
	
	public int getIntegerProperty(String name, int defaultValue)
	{
		boolean defaultValueFlag;
		Object obj;
		PropValue value = properties.get(name);
		if(value != null)
		{
			obj = value.value;
			defaultValueFlag = value.defaultValue;
		}
		else
		{
			obj = getProperty(name);
			
			defaultValueFlag = true;
		}

		if(obj == null)
			return defaultValue;
		else if(obj instanceof Number)
			return ((Number)obj).intValue();
		else
		{
			try
			{
				int returnValue = Integer.parseInt(
					obj.toString().trim());
				properties.put(name,new PropValue(
					returnValue,
					defaultValueFlag));
				return returnValue;
			}
			catch(Exception e)
			{
				return defaultValue;
			}
		}
	} 

	
	
	public void setIntegerProperty(String name, int value)
	{
		setProperty(name,value);
	} 

	
	
	public Pattern getPatternProperty(String name, int flags)
	{
		synchronized(propertyLock)
		{
			boolean defaultValueFlag;
			Object obj;
			PropValue value = properties.get(name);
			if(value != null)
			{
				obj = value.value;
				defaultValueFlag = value.defaultValue;
			}
			else
			{
				obj = getProperty(name);
				
				defaultValueFlag = true;
			}

			if(obj == null)
				return null;
			else if (obj instanceof Pattern)
				return (Pattern) obj;
			else
			{
				Pattern re = Pattern.compile(obj.toString(),flags);
				properties.put(name,new PropValue(re,
					defaultValueFlag));
				return re;
			}
		}
	} 

	
	
	public ParserRuleSet getRuleSetAtOffset(int offset)
	{
		int line = getLineOfOffset(offset);
		offset -= getLineStartOffset(line);
		if(offset != 0)
			offset--;

		DefaultTokenHandler tokens = new DefaultTokenHandler();
		markTokens(line,tokens);
		Token token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);
		return token.rules;
	} 

	
	
	public KeywordMap getKeywordMapAtOffset(int offset)
	{
		return getRuleSetAtOffset(offset).getKeywords();
	} 

	
	
	public String getContextSensitiveProperty(int offset, String name)
	{
		ParserRuleSet rules = getRuleSetAtOffset(offset);

		Object value = null;

		Map<String, String> rulesetProps = rules.getProperties();
		if(rulesetProps != null)
			value = rulesetProps.get(name);

		if(value == null)
			return null;
		else
			return String.valueOf(value);
	} 

	
	
	public Mode getMode()
	{
		return mode;
	} 

	
	
	public void setMode(String mode)
	{
		setMode(ModeProvider.instance.getMode(mode));
	}

	
	public void setMode(Mode mode)
	{
		
		if(mode == null)
			throw new NullPointerException(""Mode must be non-null"");

		this.mode = mode;

		textMode = ""text"".equals(mode.getName());

		setTokenMarker(mode.getTokenMarker());

		resetCachedProperties();
		propertiesChanged();
	} 

	

	

	
	
	public boolean isFoldStart(int line)
	{
		return line != getLineCount() - 1
			&& getFoldLevel(line) < getFoldLevel(line + 1);
	} 

	
	
	public boolean isFoldEnd(int line)
	{
		return line != getLineCount() - 1
			&& getFoldLevel(line) > getFoldLevel(line + 1);
	} 

	
	
	public void invalidateCachedFoldLevels()
	{
		lineMgr.setFirstInvalidFoldLevel(0);
		fireFoldLevelChanged(0,getLineCount());
	} 

	
	
	public int getFoldLevel(int line)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		if(foldHandler instanceof DummyFoldHandler)
			return 0;

		int firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel();
		if(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)
		{
			return lineMgr.getFoldLevel(line);
		}
		else
		{
			if(Debug.FOLD_DEBUG)
				Log.log(Log.DEBUG,this,""Invalid fold levels from "" + firstInvalidFoldLevel + "" to "" + line);

			int newFoldLevel = 0;
			boolean changed = false;
			int firstUpdatedFoldLevel = firstInvalidFoldLevel;

			for(int i = firstInvalidFoldLevel; i <= line; i++)
			{
				Segment seg = new Segment();
				newFoldLevel = foldHandler.getFoldLevel(this,i,seg);
				if(newFoldLevel != lineMgr.getFoldLevel(i))
				{
					if(Debug.FOLD_DEBUG)
						Log.log(Log.DEBUG,this,i + "" fold level changed"");
					changed = true;
					
					if (i == firstInvalidFoldLevel)
					{
						List<Integer> precedingFoldLevels =
							foldHandler.getPrecedingFoldLevels(
								this,i,seg,newFoldLevel);
						if (precedingFoldLevels != null)
						{
							int j = i;
							for (Integer foldLevel: precedingFoldLevels)
							{
								j--;
								lineMgr.setFoldLevel(j,foldLevel.intValue());
							}
							if (j < firstUpdatedFoldLevel)
								firstUpdatedFoldLevel = j;
						}
					}
				}
				lineMgr.setFoldLevel(i,newFoldLevel);
			}

			if(line == lineMgr.getLineCount() - 1)
				lineMgr.setFirstInvalidFoldLevel(-1);
			else
				lineMgr.setFirstInvalidFoldLevel(line + 1);

			if(changed)
			{
				if(Debug.FOLD_DEBUG)
					Log.log(Log.DEBUG,this,""fold level changed: "" + firstUpdatedFoldLevel + ',' + line);
				fireFoldLevelChanged(firstUpdatedFoldLevel,line);
			}

			return newFoldLevel;
		}
	} 

	
	
	public int[] getFoldAtLine(int line)
	{
		int start, end;

		if(isFoldStart(line))
		{
			start = line;
			int foldLevel = getFoldLevel(line);

			line++;

			while(getFoldLevel(line) > foldLevel)
			{
				line++;

				if(line == getLineCount())
					break;
			}

			end = line - 1;
		}
		else
		{
			start = line;
			int foldLevel = getFoldLevel(line);
			while(getFoldLevel(start) >= foldLevel)
			{
				if(start == 0)
					break;
				else
					start--;
			}

			end = line;
			while(getFoldLevel(end) >= foldLevel)
			{
				end++;

				if(end == getLineCount())
					break;
			}

			end--;
		}

		while(getLineLength(end) == 0 && end > start)
			end--;

		return new int[] { start, end };
	} 

	
	
	public FoldHandler getFoldHandler()
	{
		return foldHandler;
	} 

	
	
	public void setFoldHandler(FoldHandler foldHandler)
	{
		FoldHandler oldFoldHandler = this.foldHandler;

		if(foldHandler.equals(oldFoldHandler))
			return;

		this.foldHandler = foldHandler;

		lineMgr.setFirstInvalidFoldLevel(0);

		fireFoldHandlerChanged();
	} 

	

	

	
	
	public void undo(TextArea textArea)
	{
		if(undoMgr == null)
			return;

		if(!isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		try
		{
			writeLock();

			undoInProgress = true;
			fireBeginUndo();
			int caret = undoMgr.undo();
			if(caret == -1)
				textArea.getToolkit().beep();
			else
				textArea.setCaretPosition(caret);

			fireEndUndo();
			fireTransactionComplete();
		}
		finally
		{
			undoInProgress = false;

			writeUnlock();
		}
	} 

	
	
	public void redo(TextArea textArea)
	{
		if(undoMgr == null)
			return;

		if(!isEditable())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}

		try
		{
			writeLock();

			undoInProgress = true;
			fireBeginRedo();
			int caret = undoMgr.redo();
			if(caret == -1)
				textArea.getToolkit().beep();
			else
				textArea.setCaretPosition(caret);

			fireEndRedo();
			fireTransactionComplete();
		}
		finally
		{
			undoInProgress = false;

			writeUnlock();
		}
	} 

	
	
	public boolean isTransactionInProgress()
	{
		return transaction || undoInProgress || insideCompoundEdit();
	} 

	
	
	public void beginCompoundEdit()
	{
		try
		{
			writeLock();

			undoMgr.beginCompoundEdit();
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void endCompoundEdit()
	{
		try
		{
			writeLock();

			undoMgr.endCompoundEdit();

			if(!insideCompoundEdit())
				fireTransactionComplete();
		}
		finally
		{
			writeUnlock();
		}
	}

	
	
	public boolean insideCompoundEdit()
	{
		return undoMgr.insideCompoundEdit();
	} 

	
	
	public boolean isUndoInProgress()
	{
		return undoInProgress;
	} 

	
	
	public Object getUndoId()
	{
		return undoMgr.getUndoId();
	} 

	

	
	public static final int NORMAL_PRIORITY = 0;
	public static final int HIGH_PRIORITY = 1;

	static class Listener
	{
		BufferListener listener;
		int priority;

		Listener(BufferListener listener, int priority)
		{
			this.listener = listener;
			this.priority = priority;
		}
	}

	
	
	public void addBufferListener(BufferListener listener,
		int priority)
	{
		Listener l = new Listener(listener,priority);
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			Listener _l = bufferListeners.get(i);
			if(_l.priority < priority)
			{
				bufferListeners.add(i,l);
				return;
			}
		}
		bufferListeners.add(l);
	}

	
	public void addBufferListener(BufferListener listener)
	{
		addBufferListener(listener,NORMAL_PRIORITY);
	} 

	
	
	public void removeBufferListener(BufferListener listener)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			if(bufferListeners.get(i).listener == listener)
			{
				bufferListeners.remove(i);
				return;
			}
		}
	} 

	
	
	public BufferListener[] getBufferListeners()
	{
		BufferListener[] returnValue
			= new BufferListener[
			bufferListeners.size()];
		for(int i = 0; i < returnValue.length; i++)
		{
			returnValue[i] = bufferListeners.get(i).listener;
		}
		return returnValue;
	} 

	
	
	public void setUndoLimit(int limit)
	{
		if (undoMgr != null)
			undoMgr.setLimit(limit);
	} 

	
	
	public boolean canUndo()
	{
		if (undoMgr == null)
			return false;
		return undoMgr.canUndo();
	} 

	
	
	public boolean canRedo()
	{
		if (undoMgr == null)
			return false;
		return undoMgr.canRedo();
	} 

	

	

	protected Mode mode;
	protected boolean textMode;
	protected UndoManager undoMgr;

	

	
	protected void fireFoldLevelChanged(int start, int end)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.foldLevelChanged(this,start,end);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireContentInserted(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.contentInserted(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireContentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.contentRemoved(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void firePreContentInserted(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.preContentInserted(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void firePreContentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.preContentRemoved(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireBeginUndo()
	{
	} 

	
	protected void fireEndUndo()
	{
	} 

	
	protected void fireBeginRedo()
	{
	} 
	
	
	protected void fireEndRedo()
	{
	} 
	
	
	protected void fireTransactionComplete()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.transactionComplete(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireFoldHandlerChanged()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.foldHandlerChanged(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	protected void fireBufferLoaded()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			BufferListener listener = getListener(i);
			try
			{
				listener.bufferLoaded(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+ listener +"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	

	
	protected boolean isFileReadOnly()
	{
		return readOnly;
	} 

	
	protected void setFileReadOnly(boolean readOnly)
	{
		this.readOnly = readOnly;
	} 

	
	protected void loadText(Segment seg, IntegerArray endOffsets)
	{
		if(seg == null)
			seg = new Segment(new char[1024],0,0);

		if(endOffsets == null)
		{
			endOffsets = new IntegerArray();
			endOffsets.add(1);
		}

		try
		{
			writeLock();

			
			
			int length = getLength();

			firePreContentRemoved(0,0,getLineCount()
				- 1,length);

			contentMgr.remove(0,length);
			lineMgr.contentRemoved(0,0,getLineCount()
				- 1,length);
			positionMgr.contentRemoved(0,length);
			fireContentRemoved(0,0,getLineCount()
				- 1,length);

			firePreContentInserted(0, 0, endOffsets.getSize() - 1, seg.count - 1);
			
			
			
			contentMgr._setContent(seg.array,seg.count);

			lineMgr._contentInserted(endOffsets);
			positionMgr.contentInserted(0,seg.count);

			fireContentInserted(0,0,
				endOffsets.getSize() - 1,
				seg.count - 1);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	protected void invalidateFoldLevels()
	{
		lineMgr.setFirstInvalidFoldLevel(0);
	} 

	
	protected void parseBufferLocalProperties()
	{
		int lastLine = Math.min(9,getLineCount() - 1);
		parseBufferLocalProperties(getSegment(0,getLineEndOffset(lastLine) - 1));

		
		
		int firstLine = Math.max(lastLine + 1, getLineCount() - 10);
		if(firstLine < getLineCount())
		{
			int length = getLineEndOffset(getLineCount() - 1)
				- (getLineStartOffset(firstLine) + 1);
			parseBufferLocalProperties(getSegment(getLineStartOffset(firstLine),length));
		}
	} 

	
	protected static class PropValue
	{
		PropValue(Object value, boolean defaultValue)
		{
			if(value == null)
				throw new NullPointerException();
			this.value = value;
			this.defaultValue = defaultValue;
		}

		Object value;

		
		boolean defaultValue;

		
		public String toString()
		{
			return value.toString();
		}
	} 

	

	
	private List<Listener> bufferListeners;
	private final ReentrantReadWriteLock lock;
	private ContentManager contentMgr;
	private LineManager lineMgr;
	private PositionManager positionMgr;
	private FoldHandler foldHandler;
	private IntegerArray integerArray;
	private TokenMarker tokenMarker;
	private boolean undoInProgress;
	private boolean dirty;
	private boolean readOnly;
	private boolean readOnlyOverride;
	private boolean transaction;
	private boolean loading;
	private boolean io;
	private final Map<Object, PropValue> properties;
	private final Object propertyLock;

	
	private BufferListener getListener(int index)
	{
		return bufferListeners.get(index).listener;
	} 

	
	private void contentInserted(int offset, int length,
		IntegerArray endOffsets)
	{
		try
		{
			transaction = true;

			int startLine = lineMgr.getLineOfOffset(offset);
			int numLines = endOffsets.getSize();

			if (!loading)
			{
				firePreContentInserted(startLine, offset, numLines, length);
			}

			lineMgr.contentInserted(startLine,offset,numLines,length,
				endOffsets);
			positionMgr.contentInserted(offset,length);

			setDirty(true);

			if(!loading)
			{
				fireContentInserted(startLine,offset,numLines,length);

				if(!undoInProgress && !insideCompoundEdit())
					fireTransactionComplete();
			}

		}
		finally
		{
			transaction = false;
		}
	} 

	
	private void parseBufferLocalProperties(CharSequence prop)
	{
		StringBuilder buf = new StringBuilder();
		String name = null;
		boolean escape = false;
		for(int i = 0; i < prop.length(); i++)
		{
			char c = prop.charAt(i);
			switch(c)
			{
			case ':':
				if(escape)
				{
					escape = false;
					buf.append(':');
					break;
				}
				if(name != null)
				{
					
					
					
					
					
					properties.put(name,new PropValue(buf.toString(),false));
					name = null;
				}
				buf.setLength(0);
				break;
			case '=':
				if(escape)
				{
					escape = false;
					buf.append('=');
					break;
				}
				name = buf.toString();
				buf.setLength(0);
				break;
			case '\\':
				if(escape)
					buf.append('\\');
				escape = !escape;
				break;
			case 'n':
				if(escape)
				{	buf.append('\n');
					escape = false;
					break;
				}
			case 'r':
				if(escape)
				{	buf.append('\r');
					escape = false;
					break;
				}
			case 't':
				if(escape)
				{
					buf.append('\t');
					escape = false;
					break;
				}
			default:
				buf.append(c);
				break;
			}
		}
	} 

	
	private List<IndentRule> getIndentRules(int line)
	{
		String modeName = null;
		TokenMarker.LineContext ctx = lineMgr.getLineContext(line);
		if (ctx != null && ctx.rules != null)
			modeName = ctx.rules.getModeName();
		if (modeName == null)
			modeName = tokenMarker.getMainRuleSet().getModeName();
		return ModeProvider.instance.getMode(modeName).getIndentRules();
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.FirewallOptionPane,12,6,0,3,31,28,1,3,3,0.818181818,269,1.0,0,0.983823529,0.5,2,4,20.66666667,1,0.9167,0,"

package org.gjt.sp.jedit.options;

 
import java.awt.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;


public class FirewallOptionPane extends AbstractOptionPane {

	
	public FirewallOptionPane()
	{
		super(""firewall"");
	} 

	
	public void _init()
	{
		
		addComponent(httpEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.http.enabled"")));
		
		addComponent(jEdit.getProperty(""options.firewall.http.host""), 
			httpHost = new JTextField(jEdit.getProperty(""firewall.host""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.port""), 
			httpPort = new JTextField(jEdit.getProperty(""firewall.port""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.user""),
			httpUser = new JTextField(jEdit.getProperty(""firewall.user""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.password""),
			httpPass = new JPasswordField(jEdit.getProperty(""firewall.password""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.nonProxy""),
			httpNonProxy = new JTextField(jEdit.getProperty(""firewall.nonProxyHosts""), 15));

		boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
		httpEnabled.setSelected(enabled);
		httpHost.setEnabled(enabled);
		httpPort.setEnabled(enabled);
		httpUser.setEnabled(enabled);
		httpPass.setEnabled(enabled);
		httpNonProxy.setEnabled(enabled);

		httpEnabled.addActionListener(new ActionHandler());

		
		addComponent(socksEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.socks.enabled"")));
		
		addComponent(jEdit.getProperty(""options.firewall.socks.host""), 
			socksHost = new JTextField(jEdit.getProperty(""firewall.socks.host""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.socks.port""), 
			socksPort = new JTextField(jEdit.getProperty(""firewall.socks.port""), 15));

		enabled = jEdit.getBooleanProperty(""firewall.socks.enabled"");
		socksEnabled.setSelected(enabled);
		socksHost.setEnabled(enabled);
		socksPort.setEnabled(enabled);

		socksEnabled.addActionListener(new ActionHandler());
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(""firewall.enabled"", httpEnabled.isSelected());
		jEdit.setProperty(""firewall.host"", httpHost.getText());
		jEdit.setProperty(""firewall.port"", httpPort.getText());
		jEdit.setProperty(""firewall.user"", httpUser.getText());
		jEdit.setProperty(""firewall.password"", new String(httpPass.getPassword()));
		jEdit.setProperty(""firewall.nonProxyHosts"", httpNonProxy.getText());

		jEdit.setBooleanProperty(""firewall.socks.enabled"", socksEnabled.isSelected());
		jEdit.setProperty(""firewall.socks.host"", socksHost.getText());
		jEdit.setProperty(""firewall.socks.port"", socksPort.getText());
	} 

	
	private JCheckBox httpEnabled;
	private JTextField httpHost;
	private JTextField httpPort;
	private JTextField httpUser;
	private JPasswordField httpPass;
	private JTextField httpNonProxy;
	private JCheckBox socksEnabled;
	private JTextField socksHost;
	private JTextField socksPort;
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			httpHost.setEnabled(httpEnabled.isSelected());
			httpPort.setEnabled(httpEnabled.isSelected());
			httpUser.setEnabled(httpEnabled.isSelected());
			httpPass.setEnabled(httpEnabled.isSelected());
			httpNonProxy.setEnabled(httpEnabled.isSelected());
			socksHost.setEnabled(socksEnabled.isSelected());
			socksPort.setEnabled(socksEnabled.isSelected());
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.Edge,1,1,0,2,2,0,2,1,0,2.0,8,0.0,3,0.0,1.0,0,0,3.0,0,0.0,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



class Edge {

  

  int stackSize;

  

  Label successor;

  

  Edge next;

  

  Edge poolNext;
}
"
jEdit,4.3,org.gjt.sp.jedit.View,90,6,0,234,339,3509,207,55,65,0.969731713,3081,0.551020408,12,0.878746594,0.069082126,3,13,32.68888889,10,2.7667,1,"

package org.gjt.sp.jedit;


import java.awt.AWTEvent;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.SwingUtilities;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;

import org.gjt.sp.jedit.bufferset.BufferSet;
import org.gjt.sp.jedit.bufferset.BufferSetManager;
import org.gjt.sp.jedit.gui.ActionBar;
import org.gjt.sp.jedit.gui.CloseDialog;
import org.gjt.sp.jedit.gui.DefaultInputHandler;
import org.gjt.sp.jedit.gui.DockableWindowFactory;
import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.jedit.gui.HistoryModel;
import org.gjt.sp.jedit.gui.DockingFrameworkProvider;
import org.gjt.sp.jedit.gui.InputHandler;
import org.gjt.sp.jedit.gui.StatusBar;
import org.gjt.sp.jedit.gui.ToolBarManager;
import org.gjt.sp.jedit.gui.VariableGridLayout;
import org.gjt.sp.jedit.gui.DockableWindowManager.DockingLayout;
import org.gjt.sp.jedit.input.InputHandlerProvider;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.msg.EditPaneUpdate;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.options.GeneralOptionPane;
import org.gjt.sp.jedit.search.CurrentBufferSet;
import org.gjt.sp.jedit.search.SearchAndReplace;
import org.gjt.sp.jedit.search.SearchBar;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.textarea.ScrollListener;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.jedit.visitors.JEditVisitor;
import org.gjt.sp.jedit.visitors.JEditVisitorAdapter;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class View extends JFrame implements EBComponent, InputHandlerProvider
{
	

	

	public static final String VIEW_DOCKING_FRAMEWORK_PROPERTY = ""view.docking.framework"";
	private static final String ORIGINAL_DOCKING_FRAMEWORK = ""Original"";
	public static final String DOCKING_FRAMEWORK_PROVIDER_SERVICE =
		""org.gjt.sp.jedit.gui.DockingFrameworkProvider"";
	private static DockingFrameworkProvider dockingFrameworkProvider;

	
	
	public static final int TOP_GROUP = 0;

	
	public static final int BOTTOM_GROUP = 1;
	public static final int DEFAULT_GROUP = TOP_GROUP;
	

	

	
	
	public static final int TOP_LAYER = Integer.MAX_VALUE;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int BOTTOM_LAYER = Integer.MIN_VALUE;

	
	
	public static final int ABOVE_SYSTEM_BAR_LAYER = 150;

	
	public static final int SYSTEM_BAR_LAYER = 100;

	
	public static final int BELOW_SYSTEM_BAR_LAYER = 75;

	
	public static final int SEARCH_BAR_LAYER = 75;

	
	public static final int BELOW_SEARCH_BAR_LAYER = 50;

	
	
	@Deprecated
	public static final int ABOVE_ACTION_BAR_LAYER = -50;

	
	public static final int ACTION_BAR_LAYER = -75;

	
	public static final int STATUS_BAR_LAYER = -100;

	
	public static final int BELOW_STATUS_BAR_LAYER = -150;
	

	

	
	
	public DockableWindowManager getDockableWindowManager()
	{
		return dockableWindowManager;
	} 

	
	public static String getDockingFrameworkName()
	{
		String framework = jEdit.getProperty(
				VIEW_DOCKING_FRAMEWORK_PROPERTY, ORIGINAL_DOCKING_FRAMEWORK);
		return framework;
	} 

	
	public static DockingFrameworkProvider getDockingFrameworkProvider()
	{
		if (dockingFrameworkProvider == null)
		{
			String framework = getDockingFrameworkName();
			dockingFrameworkProvider = (DockingFrameworkProvider)
				ServiceManager.getService(
					DOCKING_FRAMEWORK_PROVIDER_SERVICE, framework);

			if (dockingFrameworkProvider == null)
			{
				Log.log(Log.ERROR, View.class, ""No docking framework "" + framework +
							       "" available, using the original one"");
				dockingFrameworkProvider = (DockingFrameworkProvider)
				ServiceManager.getService(
					DOCKING_FRAMEWORK_PROVIDER_SERVICE, ORIGINAL_DOCKING_FRAMEWORK);
			}
		}
		return dockingFrameworkProvider;
	} 

	
	
	public Container getToolBar()
	{
		return toolBar;
	} 

	
	
	public void addToolBar(Component toolBar)
	{
		addToolBar(DEFAULT_GROUP, DEFAULT_LAYER, toolBar);
	} 

	
	
	public void addToolBar(int group, Component toolBar)
	{
		addToolBar(group, DEFAULT_LAYER, toolBar);
	} 

	
	
	public void addToolBar(int group, int layer, Component toolBar)
	{
		toolBarManager.addToolBar(group, layer, toolBar);
		getRootPane().revalidate();
	} 

	
	
	public void removeToolBar(Component toolBar)
	{
		if (toolBarManager == null) return;
		if (toolBar == null) return;
		toolBarManager.removeToolBar(toolBar);
		getRootPane().revalidate();
	} 

	
	
	public synchronized void showWaitCursor()
	{
		if(waitCount++ == 0)
		{
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			setCursor(cursor);
			visit(new SetCursorVisitor(cursor));
		}
	} 

	
	
	public synchronized void hideWaitCursor()
	{
		if(waitCount > 0)
			waitCount--;

		if(waitCount == 0)
		{
			
			
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			setCursor(cursor);

			visit(new SetCursorVisitor(cursor));
		}
	} 

	
	
	public final SearchBar getSearchBar()
	{
		return searchBar;
	} 

	
	
	public final ActionBar getActionBar()
	{
		return actionBar;
	} 

	
	
	public StatusBar getStatus()
	{
		return status;
	} 

	
	
	public void quickIncrementalSearch(boolean word)
	{
		if(searchBar == null)
			searchBar = new SearchBar(this,true);
		if(searchBar.getParent() == null)
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);

		searchBar.setHyperSearch(false);

		JEditTextArea textArea = getTextArea();

		if(word)
		{
			String text = textArea.getSelectedText();
			if(text == null)
			{
				textArea.selectWord();
				text = textArea.getSelectedText();
			}
			else if(text.indexOf('\n') != -1)
				text = null;

			if(text != null && SearchAndReplace.getRegexp())
				text = SearchAndReplace.escapeRegexp(text,false);

			searchBar.getField().setText(text);
		}

		searchBar.getField().requestFocus();
		searchBar.getField().selectAll();
	} 

	
	
	public void quickHyperSearch(boolean word)
	{
		JEditTextArea textArea = getTextArea();

		if(word)
		{
			String text = textArea.getSelectedText();
			if(text == null)
			{
				textArea.selectWord();
				text = textArea.getSelectedText();
			}

			if(text != null && text.indexOf('\n') == -1)
			{
				if(SearchAndReplace.getRegexp())
				{
					text = SearchAndReplace.escapeRegexp(
						text,false);
				}

				HistoryModel.getModel(""find"").addItem(text);
				SearchAndReplace.setSearchString(text);
				SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
				SearchAndReplace.hyperSearch(this);

				return;
			}
		}

		if(searchBar == null)
			searchBar = new SearchBar(this,true);
		if(searchBar.getParent() == null)
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);

		searchBar.setHyperSearch(true);
		searchBar.getField().setText(null);
		searchBar.getField().requestFocus();
		searchBar.getField().selectAll();
	} 

	
	
	public void actionBar()
	{
		if(actionBar == null)
			actionBar = new ActionBar(this,true);
		if(actionBar.getParent() == null)
			addToolBar(BOTTOM_GROUP,ACTION_BAR_LAYER,actionBar);

		actionBar.goToActionBar();
	} 

	

	

	
	
	public KeyListener getKeyEventInterceptor()
	{
		return inputHandler.getKeyEventInterceptor();
	} 

	
	
	public void setKeyEventInterceptor(KeyListener listener)
	{
		inputHandler.setKeyEventInterceptor(listener);
	} 

	
	
	public InputHandler getInputHandler()
	{
		return inputHandler;
	} 



	
	
	public void setInputHandler(InputHandler inputHandler)
	{
		this.inputHandler = inputHandler;
	} 

	
	
	public Macros.Recorder getMacroRecorder()
	{
		return recorder;
	} 

	
	
	public void setMacroRecorder(Macros.Recorder recorder)
	{
		this.recorder = recorder;
	} 

	
	
	@Override
	public void processKeyEvent(KeyEvent evt)
	{
		inputHandler.processKeyEvent(evt,VIEW, false);
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	
	
	public void processKeyEvent(KeyEvent evt, boolean calledFromTextArea)
	{
		processKeyEvent(evt,calledFromTextArea
			? TEXT_AREA
			: VIEW);
	} 

	
	public static final int VIEW = 0;
	public static final int TEXT_AREA = 1;
	public static final int ACTION_BAR = 2;
	
	public void processKeyEvent(KeyEvent evt, int from)
	{
		processKeyEvent(evt,from,false);
	}
	
	@Deprecated
	public void processKeyEvent(KeyEvent evt, int from, boolean global)
	{
		inputHandler.processKeyEvent(evt, from, global);
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 


	

	

	
	
	public EditPane splitHorizontally()
	{
		return split(JSplitPane.VERTICAL_SPLIT);
	} 

	
	
	public EditPane splitVertically()
	{
		return split(JSplitPane.HORIZONTAL_SPLIT);
	} 

	
	
	public EditPane split(int orientation)
	{
		PerspectiveManager.setPerspectiveDirty(true);

		editPane.saveCaretInfo();
		EditPane oldEditPane = editPane;
		String action = jEdit.getProperty(""editpane.bufferset.new"");
		BufferSetManager.NewBufferSetAction bufferSetAction = BufferSetManager.NewBufferSetAction.fromString(action);
		EditPane newEditPane;
		if (bufferSetAction == BufferSetManager.NewBufferSetAction.empty)
			newEditPane = createEditPane(null);
		else
			newEditPane = createEditPane(oldEditPane.getBuffer());

		newEditPane.loadCaretInfo();

		JComponent oldParent = (JComponent)oldEditPane.getParent();

		final JSplitPane newSplitPane = new JSplitPane(orientation,
							       jEdit.getBooleanProperty(""appearance.continuousLayout""));
		newSplitPane.setOneTouchExpandable(true);
		newSplitPane.setBorder(null);
		newSplitPane.setMinimumSize(new Dimension(0,0));
		newSplitPane.setResizeWeight(0.5);

		int parentSize = orientation == JSplitPane.VERTICAL_SPLIT
			? oldEditPane.getHeight() : oldEditPane.getWidth();
		final int dividerPosition = (int)((parentSize
			- newSplitPane.getDividerSize()) * 0.5);
		newSplitPane.setDividerLocation(dividerPosition);

		if(oldParent instanceof JSplitPane)
		{
			JSplitPane oldSplitPane = (JSplitPane)oldParent;
			int dividerPos = oldSplitPane.getDividerLocation();

			Component left = oldSplitPane.getLeftComponent();

			if(left == oldEditPane)
				oldSplitPane.setLeftComponent(newSplitPane);
			else
				oldSplitPane.setRightComponent(newSplitPane);

			newSplitPane.setLeftComponent(oldEditPane);
			newSplitPane.setRightComponent(newEditPane);

			oldSplitPane.setDividerLocation(dividerPos);
		}
		else
		{
			splitPane = newSplitPane;

			newSplitPane.setLeftComponent(oldEditPane);
			newSplitPane.setRightComponent(newEditPane);

			setMainContent(newSplitPane);

		}

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				newSplitPane.setDividerLocation(dividerPosition);
			}
		});

		newEditPane.focusOnTextArea();

		return newEditPane;
	} 

	
	
	public void unsplit()
	{
		if(splitPane != null)
		{
			lastSplitConfig = getSplitConfig();

			PerspectiveManager.setPerspectiveDirty(true);

			for(EditPane _editPane: getEditPanes())
			{
				if(editPane != _editPane)
				{
					mergeBufferSets(editPane, _editPane);
					_editPane.close();
				}
			}

			setMainContent(editPane);

			splitPane = null;
			updateTitle();

			editPane.focusOnTextArea();
		}
		else
			getToolkit().beep();
	} 

	
	
	public void unsplitCurrent()
	{
		if(splitPane != null)
		{
			lastSplitConfig = getSplitConfig();

			PerspectiveManager.setPerspectiveDirty(true);

			
			Component comp = editPane;
			while(!(comp instanceof JSplitPane) && comp != null)
			{
				comp = comp.getParent();
			}

			
			
			for(EditPane _editPane: getEditPanes())
			{
				if(GUIUtilities.isAncestorOf(comp,_editPane)
					&& _editPane != editPane)
				{
					mergeBufferSets(editPane, _editPane);
					_editPane.close();
				}
			}

			JComponent parent = comp == null ? null : (JComponent)comp.getParent();

			if(parent instanceof JSplitPane)
			{
				JSplitPane parentSplit = (JSplitPane)parent;
				int pos = parentSplit.getDividerLocation();
				if(parentSplit.getLeftComponent() == comp)
					parentSplit.setLeftComponent(editPane);
				else
					parentSplit.setRightComponent(editPane);
				parentSplit.setDividerLocation(pos);
				parent.revalidate();
			}
			else
			{
				setMainContent(editPane);
				splitPane = null;
			}

			updateTitle();

			editPane.focusOnTextArea();
		}
		else
			getToolkit().beep();
	} 

	
	
	public void resplit()
	{
		if(lastSplitConfig == null)
			getToolkit().beep();
		else
			setSplitConfig(null,lastSplitConfig);
	} 

	
	
	public String getSplitConfig()
	{
		StringBuilder splitConfig = new StringBuilder();

		if(splitPane != null)
			getSplitConfig(splitPane,splitConfig);
		else
		{
			appendToSplitConfig(splitConfig, editPane);
		}

		return splitConfig.toString();
	} 

	
	
	public void setSplitConfig(Buffer buffer, String splitConfig)
	{
		try
		{
			Component comp = restoreSplitConfig(buffer,splitConfig);
			setMainContent(comp);
			updateTitle();
		}
		catch(IOException e)
		{
			
			throw new InternalError();
		}
	} 

	
	
	public void nextTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == editPanes.length - 1)
					editPanes[0].focusOnTextArea();
				else
					editPanes[i+1].focusOnTextArea();
				break;
			}
		}
	} 

	
	
	public void prevTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == 0)
					editPanes[editPanes.length - 1].focusOnTextArea();
				else
					editPanes[i-1].focusOnTextArea();
				break;
			}
		}
	} 

	
	
	public JSplitPane getSplitPane()
	{
		return splitPane;
	} 

	
	
	public Buffer getBuffer()
	{
		if(editPane == null)
			return null;
		else
			return editPane.getBuffer();
	} 

	
	
	public void setBuffer(Buffer buffer)
	{
		setBuffer(buffer,false);
	} 

	
	
	public void setBuffer(Buffer buffer, boolean disableFileStatusCheck)
	{
		setBuffer(buffer, disableFileStatusCheck, true);
	} 

	
	
	public void setBuffer(Buffer buffer, boolean disableFileStatusCheck, boolean focus)
	{
		editPane.setBuffer(buffer, focus);
		int check = jEdit.getIntegerProperty(""checkFileStatus"");
		if(!disableFileStatusCheck && (check == GeneralOptionPane.checkFileStatus_all ||
						  check == GeneralOptionPane.checkFileStatus_operations ||
						  check == GeneralOptionPane.checkFileStatus_focusBuffer))
			jEdit.checkBufferStatus(this, true);
	} 

	
	
	public EditPane goToBuffer(Buffer buffer)
	{
		return showBuffer(buffer, true);
	} 

	
	
	public EditPane showBuffer(Buffer buffer)
	{
		return showBuffer(buffer, false);
	} 

	
	
	public JEditTextArea getTextArea()
	{
		if(editPane == null)
			return null;
		else
			return editPane.getTextArea();
	} 

	
	
	public EditPane getEditPane()
	{
		return editPane;
	} 

	
	
	public EditPane[] getEditPanes()
	{
		if(splitPane == null)
		{
			EditPane[] ep = { editPane };
			return ep;
		}
		else
		{
			List<EditPane> vec = new ArrayList<EditPane>();
			getEditPanes(vec,splitPane);
			EditPane[] ep = new EditPane[vec.size()];
			vec.toArray(ep);
			return ep;
		}
	} 

	
	public BufferSet getLocalBufferSet()
	{
		return localBufferSet;
	}

	
	
	public ViewConfig getViewConfig()
	{
		ViewConfig config = new ViewConfig();
		config.plainView = isPlainView();
		config.splitConfig = getSplitConfig();
		config.extState = getExtendedState();
		config.docking = dockableWindowManager.getDockingLayout(config);
		String prefix = config.plainView ? ""plain-view"" : ""view"";
		switch (config.extState)
		{
			case Frame.MAXIMIZED_BOTH:
			case Frame.ICONIFIED:
				config.x = jEdit.getIntegerProperty(prefix + "".x"",getX());
				config.y = jEdit.getIntegerProperty(prefix + "".y"",getY());
				config.width = jEdit.getIntegerProperty(prefix + "".width"",getWidth());
				config.height = jEdit.getIntegerProperty(prefix + "".height"",getHeight());
				break;

			case Frame.MAXIMIZED_VERT:
				config.x = getX();
				config.y = jEdit.getIntegerProperty(prefix + "".y"",getY());
				config.width = getWidth();
				config.height = jEdit.getIntegerProperty(prefix + "".height"",getHeight());
				break;

			case Frame.MAXIMIZED_HORIZ:
				config.x = jEdit.getIntegerProperty(prefix + "".x"",getX());
				config.y = getY();
				config.width = jEdit.getIntegerProperty(prefix + "".width"",getWidth());
				config.height = getHeight();
				break;

			case Frame.NORMAL:
			default:
				config.x = getX();
				config.y = getY();
				config.width = getWidth();
				config.height = getHeight();
				break;
		}
		return config;
	} 

	

	
	
	public boolean isClosed()
	{
		return closed;
	} 

	
	
	public boolean isPlainView()
	{
		return plainView;
	} 

	
	
	public View getNext()
	{
		return next;
	} 

	
	
	public View getPrev()
	{
		return prev;
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof SearchSettingsChanged)
		{
			if(searchBar != null)
				searchBar.update();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof EditPaneUpdate)
			handleEditPaneUpdate((EditPaneUpdate)msg);
	} 

	
	@Override
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	
	
	public void setWaitSocket(Socket waitSocket)
	{
		this.waitSocket = waitSocket;
	} 

	
	@Override
	public String toString()
	{
		return getClass().getName() + '['
			+ (jEdit.getActiveView() == this
			? ""active"" : ""inactive"")
			+ ']';
	} 

	
	
	public void updateTitle()
	{
		List<Buffer> buffers = new ArrayList<Buffer>();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			Buffer buffer = editPanes[i].getBuffer();
			if(!buffers.contains(buffer))
				buffers.add(buffer);
		}

		StringBuilder title = new StringBuilder();

		
		if(!OperatingSystem.isMacOS())
			title.append(jEdit.getProperty(""view.title""));

		for(int i = 0; i < buffers.size(); i++)
		{
			if(i != 0)
				title.append("", "");

			Buffer buffer = buffers.get(i);
			title.append(showFullPath && !buffer.isNewFile()
				? buffer.getPath(true) : buffer.getName());
			if(buffer.isDirty())
				title.append(jEdit.getProperty(""view.title.dirty""));
		}

		setTitle(title.toString());
	} 

	
	public Component getPrefixFocusOwner()
	{
		return prefixFocusOwner;
	} 

	
	public void setPrefixFocusOwner(Component prefixFocusOwner)
	{
		this.prefixFocusOwner = prefixFocusOwner;
	} 

	
	
	public void visit(JEditVisitor visitor)
	{
		EditPane[] panes = getEditPanes();
		for (int i = 0; i < panes.length; i++)
		{
			EditPane editPane = panes[i];
			visitor.visit(editPane);
			visitor.visit(editPane.getTextArea());
		}
	} 

	
	View prev;
	View next;

	
	View(Buffer buffer, ViewConfig config)
	{
		fullScreenMode = false;
		menuBar = null;
		plainView = config.plainView;

		enableEvents(AWTEvent.KEY_EVENT_MASK);

		setIconImage(GUIUtilities.getEditorIcon());

		mainPanel = new JPanel();
		mainPanel.setLayout(new BorderLayout());
		dockableWindowManager = getDockingFrameworkProvider().create(this,
			DockableWindowFactory.getInstance(), config);
		dockableWindowManager.setMainPanel(mainPanel);

		topToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));
		bottomToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));

		toolBarManager = new ToolBarManager(topToolBars, bottomToolBars);

		status = new StatusBar(this);

		inputHandler = new DefaultInputHandler(this,(DefaultInputHandler)
			jEdit.getInputHandler());

		localBufferSet = new BufferSet();

		setSplitConfig(buffer,config.splitConfig);

		getContentPane().add(BorderLayout.CENTER,dockableWindowManager);

		dockableWindowManager.init();

		
		
		propertiesChanged();

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());

		setFocusTraversalPolicy(new MyFocusTraversalPolicy());

		EditBus.addToBus(this);

		GUIUtilities.addSizeSaver(this, null, plainView ? ""plain-view"" : ""view"");
	} 

	
	public void updateFullScreenProps()
	{
		boolean alternateLayout = jEdit.getBooleanProperty(
			""view.toolbar.alternateLayout"");
		boolean showMenu = jEdit.getBooleanProperty(""fullScreenIncludesMenu"");
		boolean showToolbars = jEdit.getBooleanProperty(""fullScreenIncludesToolbar"");
		boolean showStatus = jEdit.getBooleanProperty(""fullScreenIncludesStatus"");
		if (! showMenu)
		{
			menuBar = getJMenuBar();
			setJMenuBar(null);
		}
		else if (menuBar != null)
			setJMenuBar(menuBar);
		if (alternateLayout)
		{
			
			if (! showToolbars)
				getContentPane().remove(topToolBars);
			else
				getContentPane().add(BorderLayout.NORTH,topToolBars);
			if (! showStatus)
				removeToolBar(status);
			else
				addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);
		}
		else
		{
			
			if (! showToolbars)
				mainPanel.remove(topToolBars);
			else
				mainPanel.add(topToolBars, BorderLayout.NORTH);
			if (! showStatus)
				getContentPane().remove(status);
			else
				getContentPane().add(BorderLayout.SOUTH,status);
		}
	} 

	
	public void toggleFullScreen()
	{
		fullScreenMode = (! fullScreenMode);
		GraphicsDevice sd = getGraphicsConfiguration().getDevice();
		dispose();
		if (fullScreenMode)
		{
			updateFullScreenProps();
			windowedBounds = getBounds();
			setUndecorated(true);
			setBounds(sd.getDefaultConfiguration().getBounds());
			validate();
		}
		else
		{
			boolean showStatus = plainView ? jEdit.getBooleanProperty(""view.status.plainview.visible"") :
				jEdit.getBooleanProperty(""view.status.visible"");
			if ((menuBar != null) && (getJMenuBar() != menuBar))
				setJMenuBar(menuBar);
			boolean alternateLayout = jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"");
			if (alternateLayout)
			{
				getContentPane().add(BorderLayout.NORTH,topToolBars);
				if (showStatus)
					addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);
			}
			else
			{
				mainPanel.add(topToolBars, BorderLayout.NORTH);
				if (showStatus)
					getContentPane().add(BorderLayout.SOUTH,status);
			}
			setUndecorated(false);
			setBounds(windowedBounds);
		}
		setVisible(true);
		toFront();
		
		editPane.getTextArea().requestFocus();
	} 

	
	
	boolean confirmToCloseDirty()
	{
		Set<Buffer> checkingBuffers = getOpenBuffers();
		for (View view: jEdit.getViews())
		{
			if (view != this)
			{
				checkingBuffers.removeAll(
					view.getOpenBuffers());
			}
		}
		for (Buffer buffer: checkingBuffers)
		{
			if (buffer.isDirty())
			{
				return new CloseDialog(this, checkingBuffers).isOK();
			}
		}
		return true;
	} 

	
	void close()
	{
		EditBus.send(new ViewUpdate(this,ViewUpdate.CLOSED));
		closed = true;

		
		dockableWindowManager.close();

		EditBus.removeFromBus(this);
		dispose();

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].close();

		
		
		toolBarManager = null;
		toolBar = null;
		searchBar = null;
		splitPane = null;
		inputHandler = null;
		recorder = null;

		getContentPane().removeAll();

		
		if(waitSocket != null)
		{
			try
			{
				waitSocket.getOutputStream().write('\0');
				waitSocket.getOutputStream().flush();
				waitSocket.getInputStream().close();
				waitSocket.getOutputStream().close();
				waitSocket.close();
			}
			catch(IOException io)
			{
				
			}
		}
	} 

	

	

	
	private boolean closed;

	private DockableWindowManager dockableWindowManager;
	private JPanel mainPanel;

	private JPanel topToolBars;
	private JPanel bottomToolBars;
	private ToolBarManager toolBarManager;

	private Container toolBar;
	private SearchBar searchBar;
	private ActionBar actionBar;

	private EditPane editPane;
	private JSplitPane splitPane;
	private String lastSplitConfig;
	private final BufferSet localBufferSet;

	private StatusBar status;

	private InputHandler inputHandler;
	private Macros.Recorder recorder;
	private Component prefixFocusOwner;

	private int waitCount;

	private boolean showFullPath;

	private boolean plainView;

	private Socket waitSocket;
	private Component mainContent;

	private boolean fullScreenMode;
	private Rectangle windowedBounds;
	private JMenuBar menuBar;

	

	
	private void setMainContent(Component c)
	{
		if (mainContent != null)
			mainPanel.remove(mainContent);
		mainContent = c;
		mainPanel.add(mainContent, BorderLayout.CENTER);
		if (c instanceof JSplitPane) {
			splitPane = (JSplitPane)c;	
			editPane = null;
		}
		else {
			splitPane = null;
			editPane = (EditPane)c;
		}
		mainPanel.revalidate();
		mainPanel.repaint();
	} 

	
	private static void getEditPanes(List<EditPane> vec, Component comp)
	{
		if(comp instanceof EditPane)
			vec.add((EditPane) comp);
		else if(comp instanceof JSplitPane)
		{
			JSplitPane split = (JSplitPane)comp;
			getEditPanes(vec,split.getLeftComponent());
			getEditPanes(vec,split.getRightComponent());
		}
	} 

	
	private EditPane showBuffer(Buffer buffer, boolean focus)
	{
		if(editPane.getBuffer() == buffer
			&& editPane.getTextArea().getVisibleLines() > 1)
		{
			if (focus)
				editPane.focusOnTextArea();
			return editPane;
		}

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			EditPane ep = editPanes[i];
			if(ep.getBuffer() == buffer
				
				&& ep.getTextArea().getVisibleLines() > 1)
			{
				setEditPane(ep);
				if (focus)
					ep.focusOnTextArea();
				return ep;
			}
		}

		setBuffer(buffer,false, focus);
		return editPane;
	} 

	
	
	private static void getSplitConfig(JSplitPane splitPane,
		StringBuilder splitConfig)
	{
		Component right = splitPane.getRightComponent();
		appendToSplitConfig(splitConfig, right);

		splitConfig.append(' ');

		Component left = splitPane.getLeftComponent();
		appendToSplitConfig(splitConfig, left);

		splitConfig.append(' ');
		splitConfig.append(splitPane.getDividerLocation());
		splitConfig.append(' ');
		splitConfig.append(splitPane.getOrientation()
			== JSplitPane.VERTICAL_SPLIT ? ""vertical"" : ""horizontal"");
	} 

	
	
	private static void appendToSplitConfig(StringBuilder splitConfig, Component component)
	{
		if(component instanceof JSplitPane)
		{
			
			getSplitConfig((JSplitPane)component,splitConfig);
		}
		else
		{
			
			EditPane editPane = (EditPane) component;
			splitConfig.append('""');
			splitConfig.append(StandardUtilities.charsToEscapes(
				editPane.getBuffer().getPath()));
			splitConfig.append(""\"" buffer"");
			BufferSet bufferSet = editPane.getBufferSet();
			Buffer[] buffers = bufferSet.getAllBuffers();
			for (Buffer buffer : buffers)
			{
				if (!buffer.isNewFile())
				{
					splitConfig.append("" \"""");
					splitConfig.append(StandardUtilities.charsToEscapes(
						buffer.getPath()));
					splitConfig.append(""\"" buff"");
				}
			}
			splitConfig.append("" \"""");
			splitConfig.append(editPane.getBufferSetScope());
			splitConfig.append(""\"" bufferset"");
		}
	} 

	
	private Component restoreSplitConfig(Buffer buffer, String splitConfig)
		throws IOException
	
	
	{
		if(buffer != null)
		{
			return editPane = createEditPane(buffer);
		}
		else if(splitConfig == null)
		{
			return editPane = createEditPane(jEdit.getFirstBuffer());
		}
		Buffer[] buffers = jEdit.getBuffers();

		Stack<Object> stack = new Stack<Object>();

		
		
		StreamTokenizer st = new StreamTokenizer(new StringReader(
			splitConfig));
		st.whitespaceChars(0,' ');
		
		st.wordChars('#','~');
		st.commentChar('!');
		st.quoteChar('""');
		st.eolIsSignificant(false);
		boolean continuousLayout = jEdit.getBooleanProperty(""appearance.continuousLayout"");
		List<Buffer> editPaneBuffers = new ArrayList<Buffer>();
loop:		while (true)
		{
			switch(st.nextToken())
			{
			case StreamTokenizer.TT_EOF:
				break loop;
			case StreamTokenizer.TT_WORD:
				if(st.sval.equals(""vertical"") ||
					st.sval.equals(""horizontal""))
				{
					int orientation
						= st.sval.equals(""vertical"")
						? JSplitPane.VERTICAL_SPLIT
						: JSplitPane.HORIZONTAL_SPLIT;
					int divider = ((Integer)stack.pop())
						.intValue();
					Object obj1 = stack.pop();
					Object obj2 = stack.pop();
					
					if (obj1 instanceof Buffer)
					{
						Buffer b1 = buffer = (Buffer) obj1;
						jEdit.getGlobalBufferSet().addBufferAt(b1, -1);
						obj1 = editPane = createEditPane(b1, BufferSet.Scope.global);
					}
					if (obj2 instanceof Buffer)
					{
						Buffer b2 = (Buffer) obj2;
						jEdit.getGlobalBufferSet().addBufferAt(b2, -1);
						obj2 = createEditPane(b2, BufferSet.Scope.global);
					}
					stack.push(splitPane = new JSplitPane(
						orientation,
						continuousLayout,
						(Component)obj1,
						(Component)obj2));
					splitPane.setOneTouchExpandable(true);
					splitPane.setBorder(null);
					splitPane.setMinimumSize(
						new Dimension(0,0));
					splitPane.setDividerLocation(divider);
				}
				else if(st.sval.equals(""buffer""))
				{
					Object obj = stack.pop();
					if(obj instanceof Integer)
					{
						int index = ((Integer)obj).intValue();
						if(index >= 0 && index < buffers.length)
							buffer = buffers[index];
					}
					else if(obj instanceof String)
					{
						String path = (String)obj;
						buffer = jEdit.getBuffer(path);
						if (buffer == null)
						{
							int untitledCount = jEdit.getNextUntitledBufferId();
							buffer = jEdit.openFile(this,null,""Untitled-"" + untitledCount,true,null);
						}
					}

					if(buffer == null)
						buffer = jEdit.getFirstBuffer();
					stack.push(buffer);
				}
				else if (st.sval.equals(""buff""))
				{

					String path = (String)stack.pop();
					buffer = jEdit.getBuffer(path);
					if (buffer == null)
					{
						Log.log(Log.WARNING, this, ""Buffer "" + path + "" doesn't exist"");
					}
					else
					{
						editPaneBuffers.add(buffer);
					}
				}
				else if (st.sval.equals(""bufferset""))
				{
					BufferSet.Scope scope = BufferSet.Scope.fromString((String) stack.pop());
					buffer = (Buffer) stack.pop();
					editPane = createEditPane(buffer, scope);
					stack.push(editPane);
					BufferSetManager bufferSetManager = jEdit.getBufferSetManager();
					BufferSet bufferSet = editPane.getBufferSet();
					int i = 0;
					for (Buffer buff : editPaneBuffers)
					{
						if (buff == buffer)
							bufferSet.addBufferAt(buffer, i);
						else
							bufferSetManager.addBuffer(bufferSet, buff);
						i++;
					}
					editPaneBuffers.clear();
				}
				break;
			case StreamTokenizer.TT_NUMBER:
				stack.push((int)st.nval);
				break;
			case '""':
				stack.push(st.sval);
				break;
			}
		}

		
		Object obj = stack.peek();
		if (obj instanceof Buffer)
		{
			jEdit.getGlobalBufferSet().addBufferAt((Buffer)obj, -1);
			obj = editPane = createEditPane((Buffer)obj,
				BufferSet.Scope.global);
		}

		updateGutterBorders();

		return (Component)obj;
	} 

	
	
	private void propertiesChanged()
	{
		setJMenuBar(GUIUtilities.loadMenuBar(""view.mbar""));

		loadToolBars();

		showFullPath = jEdit.getBooleanProperty(""view.showFullPath"");
		updateTitle();

		status.propertiesChanged();

		removeToolBar(status);
		getContentPane().remove(status);

		boolean showStatus = plainView ? jEdit.getBooleanProperty(""view.status.plainview.visible"") :
				    jEdit.getBooleanProperty(""view.status.visible"");
		if (jEdit.getBooleanProperty(""view.toolbar.alternateLayout""))
		{
			getContentPane().add(BorderLayout.NORTH,topToolBars);
			getContentPane().add(BorderLayout.SOUTH,bottomToolBars);
			if (showStatus)
				addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);
		}
		else
		{
			mainPanel.add(topToolBars, BorderLayout.NORTH);
			mainPanel.add(bottomToolBars, BorderLayout.SOUTH);
			if (showStatus)
				getContentPane().add(BorderLayout.SOUTH,status);
		}
		updateBufferSwitcherStates();

		getRootPane().revalidate();

		if (splitPane != null)
			GUIUtilities.initContinuousLayout(splitPane);
		

		if (fullScreenMode)
			updateFullScreenProps();
	} 

	
	
	public void updateBufferSwitcherStates()
	{
		boolean show = jEdit.getBooleanProperty(""view.showBufferSwitcher"");
		JMenuBar menubar = getJMenuBar();
		if (menubar == null)
		{
			return;
		}
		String viewmenu_label = jEdit.getProperty(""view.label"");
		viewmenu_label = viewmenu_label.replace(""$"", """");
		String sbs_label = jEdit.getProperty(""focus-buffer-switcher.label"");
		sbs_label = sbs_label.replace(""$"", """");
		JMenu viewmenu = null;
		for (int i = 0; i < menubar.getMenuCount(); i++)
		{
			JMenu menu = menubar.getMenu(i);
			if (menu.getText().equals(viewmenu_label))
			{
				viewmenu = menu;
				break;
			}
		}
		if (viewmenu != null)
		{
			for (int i = 0; i < viewmenu.getMenuComponentCount(); i++)
			{
				Component item = viewmenu.getMenuComponent(i);
				if (item instanceof JMenuItem && ((JMenuItem)item).getText().equals(sbs_label))
				{
					((JMenuItem)item).setEnabled(show);
					
				}
			}
		}
		
		for (View v: jEdit.getViews())
			for (EditPane ep: v.getEditPanes())
				ep.loadBufferSwitcher();
	} 


	
	private void loadToolBars()
	{
		if(jEdit.getBooleanProperty(""view.showToolbar"") && !plainView)
		{
			if(toolBar != null)
				toolBarManager.removeToolBar(toolBar);

			toolBar = GUIUtilities.loadToolBar(""view.toolbar"");

			addToolBar(TOP_GROUP, SYSTEM_BAR_LAYER, toolBar);
		}
		else if(toolBar != null)
		{
			removeToolBar(toolBar);
			toolBar = null;
		}

		if(searchBar != null)
		{
			searchBar.propertiesChanged();
			removeToolBar(searchBar);
		}

		if(jEdit.getBooleanProperty(""view.showSearchbar"") && !plainView)
		{
			if(searchBar == null)
				searchBar = new SearchBar(this,false);
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);
		}
	} 

	
	private EditPane createEditPane(Buffer buffer)
	{
		return createEditPane(buffer, BufferSet.Scope.fromString(
			jEdit.getProperty(""editpane.bufferset.default"")));
	}

	private EditPane createEditPane(Buffer buffer, BufferSet.Scope scope)
	{
		EditPane editPane = new EditPane(this,buffer, scope);
		JEditTextArea textArea = editPane.getTextArea();
		textArea.addFocusListener(new FocusHandler());
		textArea.addCaretListener(new CaretHandler());
		textArea.addScrollListener(new ScrollHandler());
		EditBus.send(new EditPaneUpdate(editPane,EditPaneUpdate.CREATED));
		return editPane;
	} 

	
	private void setEditPane(EditPane editPane)
	{
		this.editPane = editPane;
		status.updateCaretStatus();
		status.updateBufferStatus();
		status.updateMiscStatus();

		
		
		updateGutterBorders();

		EditBus.send(new ViewUpdate(this,ViewUpdate.EDIT_PANE_CHANGED));
	} 

	
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED
			|| msg.getWhat() == BufferUpdate.LOADED)
		{
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				if(editPanes[i].getBuffer() == buffer)
				{
					updateTitle();
					break;
				}
			}
		}
	} 

	
	private void handleEditPaneUpdate(EditPaneUpdate msg)
	{
		EditPane editPane = msg.getEditPane();
		if(editPane.getView() == this
			&& msg.getWhat() == EditPaneUpdate.BUFFER_CHANGED
			&& editPane.getBuffer().isLoaded())
		{
			closeDuplicateBuffers(msg);
			status.updateCaretStatus();
			status.updateBufferStatus();
			status.updateMiscStatus();
		}
	} 

	
	private void closeDuplicateBuffers(EditPaneUpdate epu)
	{
		if (!jEdit.getBooleanProperty(""buffersets.exclusive""))
			return;
		EditPane ep = epu.getEditPane();
		
		if (ep.getView() != this) return;
		Buffer b = ep.getBuffer();
		for (View v: jEdit.getViews())
		{
			for (EditPane epc : v.getEditPanes())
			{
				
				if (epc == ep) continue;
				
				if ((epc.getBufferSetScope() == BufferSet.Scope.view)
					&&  (v == this)) continue;
				
				if (epc.getBufferSet() == jEdit.getGlobalBufferSet()) continue;
				
				if (epc.getBufferSet().indexOf(b) < 0) continue;
				
				jEdit.getBufferSetManager().removeBuffer(epc, b);
			}
		}
	} 

	
	
	private void updateGutterBorders()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].getTextArea().getGutter().updateBorder();
	} 

	
	private Set<Buffer> getOpenBuffers()
	{
		Set<Buffer> openBuffers = new HashSet<Buffer>();
		for (EditPane editPane: getEditPanes())
		{
			openBuffers.addAll(Arrays.asList(
				editPane.getBufferSet().getAllBuffers()));
		}
		return openBuffers;
	} 

	
	
	static private void mergeBufferSets(EditPane target, EditPane source)
	{
		BufferSet sourceBufferSet = source.getBufferSet();
		BufferSet targetBufferSet = target.getBufferSet();
		if (sourceBufferSet != targetBufferSet)
		{
			jEdit.getBufferSetManager().mergeBufferSet(
				targetBufferSet, sourceBufferSet);
		}
	} 

	

	

	
	private class CaretHandler implements CaretListener
	{
		public void caretUpdate(CaretEvent evt)
		{
			if(evt.getSource() == getTextArea())
				status.updateCaretStatus();
		}
	} 

	
	private class FocusHandler extends FocusAdapter
	{
		@Override
		public void focusGained(FocusEvent evt)
		{
			
			Component comp = (Component)evt.getSource();
			while(!(comp instanceof EditPane))
			{
				if(comp == null)
					return;

				comp = comp.getParent();
			}

			if(comp != editPane)
				setEditPane((EditPane)comp);
			else
				updateGutterBorders();
		}
	} 

	
	private class ScrollHandler implements ScrollListener
	{
		public void scrolledVertically(TextArea textArea)
		{
			if(getTextArea() == textArea)
				status.updateCaretStatus();
		}

		public void scrolledHorizontally(TextArea textArea) {}
	} 

	
	private class WindowHandler extends WindowAdapter
	{
		@Override
		public void windowActivated(WindowEvent evt)
		{
			boolean editPaneChanged =
				jEdit.getActiveViewInternal() != View.this;
			jEdit.setActiveView(View.this);

			
			
			
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					int check = jEdit.getIntegerProperty(""checkFileStatus"");
					if(check == GeneralOptionPane.checkFileStatus_focus ||
					   check == GeneralOptionPane.checkFileStatus_all)
						jEdit.checkBufferStatus(View.this,false);
					else if(check == GeneralOptionPane.checkFileStatus_focusBuffer)
						jEdit.checkBufferStatus(View.this,true);
				}
			});

			if (editPaneChanged)
			{
				EditBus.send(new ViewUpdate(View.this,ViewUpdate
					.ACTIVATED));
			}
		}

		@Override
		public void windowClosing(WindowEvent evt)
		{
			jEdit.closeView(View.this);
		}
	} 

	
	public static class ViewConfig
	{
		public int x, y, width, height, extState;
		public boolean plainView;
		public String splitConfig;
		public DockingLayout docking;

		public ViewConfig()
		{
		}

		public ViewConfig(boolean plainView)
		{
			this.plainView = plainView;
			String prefix = plainView ? ""plain-view"" : ""view"";
			x = jEdit.getIntegerProperty(prefix + "".x"",0);
			y = jEdit.getIntegerProperty(prefix + "".y"",0);
			width = jEdit.getIntegerProperty(prefix + "".width"",0);
			height = jEdit.getIntegerProperty(prefix + "".height"",0);
			extState = jEdit.getIntegerProperty(prefix + "".extendedState"", Frame.NORMAL);
		}

		public ViewConfig(boolean plainView, String splitConfig,
			int x, int y, int width, int height, int extState)
		{
			this.plainView = plainView;
			this.splitConfig = splitConfig;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.extState = extState;
		}
	} 

	
	private boolean isInsideScreen(View parent, Rectangle r)
	{
		Rectangle bounds;
		if (parent == null)
			bounds = GUIUtilities.getScreenBounds();
		else
			bounds = parent.getGraphicsConfiguration().getBounds();
		int minWidth = jEdit.getIntegerProperty(""view.minStartupWidth"");
		int minHeight = jEdit.getIntegerProperty(""view.minStartupHeight"");
		return (r.x < bounds.width - minWidth &&
				r.x + r.width > minWidth &&
				r.y < bounds.height - minHeight &&
				r.y + r.height > minHeight);
	}

	public void adjust(View parent, ViewConfig config)
	{
		if(config.width != 0 && config.height != 0)
		{
			Rectangle desired = new Rectangle(
					config.x, config.y, config.width, config.height);
			if (! isInsideScreen(parent, desired))
				setLocationRelativeTo(parent);
			else
			{
				if(OperatingSystem.isX11() && Debug.GEOMETRY_WORKAROUND)
					new GUIUtilities.UnixWorkaround(this,""view"",desired,config.extState);
				else
				{
					setBounds(desired);
					setExtendedState(config.extState);
				}
			}
		}
		else
			setLocationRelativeTo(parent);
	}

	
	private static class MyFocusTraversalPolicy extends LayoutFocusTraversalPolicy
	{
		@Override
		public Component getDefaultComponent(Container focusCycleRoot)
		{
			return GUIUtilities.getView(focusCycleRoot).getTextArea();
		}
	} 

	
	private static class SetCursorVisitor extends JEditVisitorAdapter
	{
		private final Cursor cursor;

		SetCursorVisitor(Cursor cursor)
		{
			this.cursor = cursor;
		}

		@Override
		public void visit(EditPane editPane)
		{
			editPane.setCursor(cursor);
		}
	}
	

}
"
jEdit,4.3,org.gjt.sp.jedit.io.EncodingWithBOM,6,1,0,3,24,0,1,2,4,0.72,218,1.0,1,0.0,0.4,0,0,34.5,1,0.6667,0,"

package org.gjt.sp.jedit.io;


import java.io.InputStream;
import java.io.SequenceInputStream;
import java.io.ByteArrayInputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.nio.charset.UnsupportedCharsetException;
import java.nio.charset.MalformedInputException;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;



public class EncodingWithBOM implements Encoding
{
	
	public EncodingWithBOM(String plain)
	{
		byte[] bom = bomMap.get(plain);
		if (bom == null)
		{
			throw new UnsupportedCharsetException(plain + "" with BOM"");
		}
		this.plain = new CharsetEncoding(plain);
		this.bom = bom;
	} 

	
	public Reader getTextReader(InputStream in) throws IOException
	{
		byte[] actualMark = new byte[bom.length];
		int count = in.read(actualMark);
		if (count < bom.length || !Arrays.equals(actualMark, bom))
		{
			throw new MalformedInputException(0);
		}
		return plain.getTextReader(in);
	}

	public Writer getTextWriter(OutputStream out) throws IOException
	{
		out.write(bom);
		return plain.getTextWriter(out);
	}

	public Reader getPermissiveTextReader(InputStream in) throws IOException
	{
		byte[] actualMark = new byte[bom.length];
		int count = in.read(actualMark);
		if (count < bom.length || !Arrays.equals(actualMark, bom))
		{
			
			
			
			in = new SequenceInputStream(
				new ByteArrayInputStream(actualMark, 0, count),
				in);
		}
		return plain.getPermissiveTextReader(in);
	}
	

	
	public static class Detector implements EncodingDetector
	{
		public String detectEncoding(InputStream sample) throws IOException
		{
			byte[] mark = new byte[4];
			int count = sample.read(mark);
	
			byte low = (byte)(BOM16 & 0xff);
			byte high = (byte)((BOM16 >> 8) & 0xff);
			if (count >= 4)
			{
				if (mark[0] == low && mark[1] == high
					&& mark[2] == 0x00 && mark[3] == 0x00)
				{
					return ""X-UTF-32LE-BOM"";
				}
				else if (mark[0] == 0x00 && mark[1] == 0x00
					&& mark[2] == high && mark[3] == low)
				{
					return ""X-UTF-32BE-BOM"";
				}
			}
			if (count >= 2)
			{
				if (mark[0] == low && mark[1] == high)
				{
					return ""x-UTF-16LE-BOM"";
				}
				else if (mark[0] == high && mark[1] == low)
				{
					
					
					
					
					return ""UTF-16"";
				}
			}
	
			if (count >= UTF8BOM.length)
			{
				int i = 0;
				while (i < UTF8BOM.length)
				{
					if (mark[i] != UTF8BOM[i])
					{
						break;
					}
					++i;
				}
				if (i == UTF8BOM.length)
				{
					return ""UTF-8Y"";
				}
			}
	
			return null;
		}
	} 

	

	
	private static final int BOM16 = 0xfeff;
	private static final byte[] UTF8BOM
		= { (byte)0xef, (byte)0xbb, (byte)0xbf };

	private static final Map<String, byte[]> bomMap
		= new HashMap<String, byte[]>();

	static
	{
		bomMap.put(""UTF-8"", UTF8BOM);

		byte low = (byte)(BOM16 & 0xff);
		byte high = (byte)((BOM16 >> 8) & 0xff);
		bomMap.put(""UTF-16LE"", new byte[] { low, high });
		bomMap.put(""UTF-16BE"", new byte[] { high, low });
		bomMap.put(""UTF-32LE"", new byte[] { low, high, 0x00, 0x00 });
		bomMap.put(""UTF-32BE"", new byte[] { 0x00, 0x00, high, low });
	}
	

	
	private final CharsetEncoding plain;
	private final byte[] bom;
	

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ContextAddDialog,11,7,0,9,71,29,2,8,4,0.814285714,408,1.0,0,0.984984985,0.363636364,0,0,35.45454545,4,1.3636,0,"

package org.gjt.sp.jedit.gui;


import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Collections;
import java.util.TreeSet;
import java.util.Vector;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.border.EmptyBorder;

import org.gjt.sp.jedit.ActionSet;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;




public class ContextAddDialog extends EnhancedDialog
{
	
	public ContextAddDialog(Component comp)
	{
		super(GUIUtilities.getParentDialog(comp),
		      jEdit.getProperty(""options.context.add.title""),
		      true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();

		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
					 jEdit.getProperty(""options.context.add.caption"")));

		separator = new JRadioButton(jEdit.getProperty(""options.context""
							       + "".add.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);

		action = new JRadioButton(jEdit.getProperty(""options.context""
							    + "".add.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		action.setSelected(true);
		typePanel.add(action);

		content.add(BorderLayout.NORTH,typePanel);

		JPanel actionPanel = new JPanel(new BorderLayout(6,6));

		ActionSet[] actionsList = jEdit.getActionSets();
		TreeSet<ActionSet> actionSets = new TreeSet<ActionSet>();
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				actionSets.add(actionSet);
		}
		combo = new JComboBox(actionSets.toArray());
		combo.setSelectedIndex(jEdit.getIntegerProperty(""contextAddDialog.lastSelection"",1));
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);

		list = new JList();
		list.setVisibleRowCount(8);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));

		content.add(BorderLayout.CENTER,actionPanel);

		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,southPanel);

		updateList();

		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		setVisible(true);
	} 

	
	public void ok()
	{
		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public String getSelection()
	{
		if(!isOK)
			return null;

		if(separator.isSelected())
			return ""-"";
		else if(action.isSelected())
		{
			return ((AbstractContextOptionPane.MenuItem)list.getSelectedValue())
			.actionName;
		}
		else
			throw new InternalError();
	} 


	
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JButton ok, cancel;

	
	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		jEdit.setIntegerProperty(""contextAddDialog.lastSelection"", combo.getSelectedIndex());

		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;

			listModel.addElement(new AbstractContextOptionPane.MenuItem(
										    action.getName(),label));
		}

		Collections.sort(listModel,new AbstractContextOptionPane.MenuItemCompare());

		list.setListData(listModel);
	} 
	


	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
			{
				combo.setEnabled(action.isSelected());
				list.setEnabled(action.isSelected());
			}
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
		}
	} 

}

"
jEdit,4.3,org.gjt.sp.jedit.io.XMLEncodingDetector,3,1,0,2,18,3,0,2,2,2.0,117,0.0,0,0.0,0.444444444,0,0,38.0,6,2.3333,0,"

package org.gjt.sp.jedit.io;


import java.io.InputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;

import org.gjt.sp.util.Log;



public class XMLEncodingDetector implements EncodingDetector
{
	
	public String detectEncoding(InputStream sample) throws IOException
	{
		
		
		final int XML_PI_LENGTH = 50;
		
		byte[] _xmlPI = new byte[XML_PI_LENGTH];
		int offset = 0;
		int count;
		while((count = sample.read(_xmlPI,offset,
			XML_PI_LENGTH - offset)) != -1)
		{
			offset += count;
			if(offset == XML_PI_LENGTH)
				break;
		}
		return getXMLEncoding(new String(_xmlPI,0,offset,""ASCII""));
	} 

	
	
	private static String getXMLEncoding(String xmlPI)
	{
		if(!xmlPI.startsWith(""<?xml""))
			return null;

		int index = xmlPI.indexOf(""encoding="");
		if(index == -1 || index + 9 == xmlPI.length())
			return null;

		char ch = xmlPI.charAt(index + 9);
		int endIndex = xmlPI.indexOf(ch,index + 10);
		if(endIndex == -1)
			return null;

		String encoding = xmlPI.substring(index + 10,endIndex);

		try
		{
			if(Charset.isSupported(encoding))
			{
				return encoding;
			}
			else
			{
				Log.log(Log.WARNING, XMLEncodingDetector.class,
					""XML PI specifies unsupported encoding: "" + encoding);
			}
		}
		catch(IllegalCharsetNameException e)
		{
			Log.log(Log.WARNING, XMLEncodingDetector.class,
				""XML PI specifies illegal encoding: "" + encoding,
				e);
		}
		return null;
	}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.UtilTargetError,3,4,0,10,9,1,5,5,3,0.0,44,0.0,0,0.95,0.6,1,1,13.33333333,2,0.6667,0,"


package org.gjt.sp.jedit.bsh;


public class UtilTargetError extends UtilEvalError
{
	public Throwable t;

	public UtilTargetError( String message, Throwable t ) {
		super( message );
		this.t = t;
	}

	public UtilTargetError( Throwable t ) {
		this( null, t );
	}

	
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  ) 
	{
		if ( msg == null )
			msg = getMessage();
		else
			msg = msg + "": "" + getMessage();

		return new TargetError( msg, t, node, callstack, false );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.MemoryStatusWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;
import java.awt.geom.Rectangle2D;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.Timer;
import javax.swing.ToolTipManager;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;



public class MemoryStatusWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view) 
	{
		Widget memory = new MemoryStatusWidget(view);
		return memory;
	} 
	
	
	private static class MemoryStatusWidget implements Widget
	{
		private final MemoryStatus memoryStatus;
		public MemoryStatusWidget(View view) 
		{
			memoryStatus = new MemoryStatus(view);
		}
		
		public JComponent getComponent() 
		{
			return memoryStatus;
		}
		
		public void update() 
		{
		}
		
		public void propertiesChanged()
		{
		}
	} 

	
	private static class MemoryStatus extends JComponent implements ActionListener
	{
		private View view;
		
		MemoryStatus(View view)
		{
			this.view = view;
			
			Font font = new JLabel().getFont();
			
			MemoryStatus.this.setFont(font);

			FontRenderContext frc = new FontRenderContext(
				null,false,false);
			Rectangle2D bounds = font.getStringBounds(
				memoryTestStr,frc);
			Dimension dim = new Dimension((int)bounds.getWidth(),
				(int)bounds.getHeight());
			setPreferredSize(dim);
			setMaximumSize(dim);
			lm = font.getLineMetrics(memoryTestStr,frc);

			setForeground(jEdit.getColorProperty(""view.status.foreground""));
			setBackground(jEdit.getColorProperty(""view.status.background""));

			progressForeground = jEdit.getColorProperty(
				""view.status.memory.foreground"");
			progressBackground = jEdit.getColorProperty(
				""view.status.memory.background"");

			addMouseListener(new MouseHandler());
		} 

		
		@Override
		public void addNotify()
		{
			super.addNotify();
			timer = new Timer(2000,this);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		@Override
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
			super.removeNotify();
		} 

		
		@Override
		public String getToolTipText()
		{
			Runtime runtime = Runtime.getRuntime();
			long free = runtime.freeMemory();
			long total = runtime.totalMemory();
			long used = total - free;
			args[0] = (int) (used / 1024);
			args[1] = (int) (total / 1024);
			return jEdit.getProperty(""view.status.memory-tooltip"",args);
		} 

		
		@Override
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} 

		
		public void actionPerformed(ActionEvent evt)
		{
			MemoryStatus.this.repaint();
		} 

		
		@Override
		public void paintComponent(Graphics g)
		{
			Insets insets = new Insets(0,0,0,0);

			Runtime runtime = Runtime.getRuntime();
			long free = runtime.freeMemory();
			long total = runtime.totalMemory();
			long used = total - free;

			int width = MemoryStatus.this.getWidth()
				- insets.left - insets.right;
			int height = MemoryStatus.this.getHeight()
				- insets.top - insets.bottom - 1;

			float fraction = ((float)used) / total;

			g.setColor(progressBackground);

			g.fillRect(insets.left,insets.top,
				(int)(width * fraction),
				height);

			String str = (used / 1024 / 1024) + ""/""
				+ (total / 1024 / 1024) + ""Mb"";

			FontRenderContext frc = new FontRenderContext(null,false,false);

			Rectangle2D bounds = g.getFont().getStringBounds(str,frc);

			Graphics g2 = g.create();
			g2.setClip(insets.left,insets.top,
				(int)(width * fraction),
				height);

			g2.setColor(progressForeground);

			g2.drawString(str,
				insets.left + ((int) (width - bounds.getWidth()) / 2),
				(int)(insets.top + lm.getAscent()));

			g2.dispose();

			g2 = g.create();

			g2.setClip(insets.left + (int)(width * fraction),
				insets.top,MemoryStatus.this.getWidth()
				- insets.left - (int)(width * fraction),
				height);

			g2.setColor(MemoryStatus.this.getForeground());

			g2.drawString(str,
				insets.left + ((int) (width - bounds.getWidth()) >> 1),
				(int)(insets.top + lm.getAscent()));

			g2.dispose();
		} 

		
		private static final String memoryTestStr = ""999/999Mb"";

		private final LineMetrics lm;
		private final Color progressForeground;
		private final Color progressBackground;

		private final Integer[] args = new Integer[2];


		private Timer timer;
		

		
		class MouseHandler extends MouseAdapter
		{
			@Override
			public void mousePressed(MouseEvent evt)
			{
				if(evt.getClickCount() == 2)
				{
					jEdit.showMemoryDialog(view);
					repaint();
				}
			}
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ExtendedGridLayoutConstraints,19,1,0,1,32,35,1,0,11,0.583333333,443,0.9,1,0.0,0.280701754,1,1,21.78947368,6,1.7895,0,"

package org.gjt.sp.jedit.gui;

import java.awt.Component;


public class ExtendedGridLayoutConstraints
{
	
	public static final int REMAINDER = Integer.MAX_VALUE;
	
	
	private int row;
	
	
	private int col;
	
	
	private int colspan;
	
	
	private int effectiveColspan;
	
	
	private int rowspan;
	
	
	private int effectiveRowspan;
	
	
	private boolean placeholder;
	
	
	private ExtendedGridLayoutConstraints mainConstraints;
	
	
	private Component component;
	
	
	public ExtendedGridLayoutConstraints(Component component)
	{
		this(0,0,1,1,component,false,null);
	}
	
	
	public ExtendedGridLayoutConstraints(int row, Component component)
	{
		this(row,0,1,1,component,false,null);
	}
	
	
	public ExtendedGridLayoutConstraints(int row, int colspan, int rowspan, Component component)
	{
		this(row,0,colspan,rowspan,component,false,null);
	}
	
	
	private ExtendedGridLayoutConstraints(int row, int col, int colspan, int rowspan, Component component, boolean placeholder, ExtendedGridLayoutConstraints mainConstraints)
	{
		if (row < 0)
		{
			throw new IllegalArgumentException(""row must be non-negative ("" + row + ')');
		}
		if (col < 0)
		{
			throw new IllegalArgumentException(""col must be non-negative ("" + col + ')');
		}
		if (colspan < 1)
		{
			throw new IllegalArgumentException(""colspan must be at least 1 ("" + colspan + ')');
		}
		if (rowspan < 1)
		{
			throw new IllegalArgumentException(""rowspan must be at least 1 ("" + rowspan + ')');
		}
		this.row = row;
		this.col = col;
		this.colspan = colspan;
		effectiveColspan = 1;
		this.rowspan = rowspan;
		effectiveRowspan = 1;
		this.component = component;
		this.placeholder = placeholder;
		this.mainConstraints = mainConstraints;
	}
	
	
	ExtendedGridLayoutConstraints getColspanPlaceholder(boolean forUsage)
	{
		if (1 == colspan)
		{
			return null;
		}
		ExtendedGridLayoutConstraints result = new ExtendedGridLayoutConstraints(row,col+1,colspan==REMAINDER ? REMAINDER : colspan-1,rowspan,component,true,null == mainConstraints ? this : mainConstraints);
		if (forUsage && (result.mainConstraints.row == row))
		{
			result.mainConstraints.effectiveColspan++;
		}
		return result;
	}
	
	
	ExtendedGridLayoutConstraints getRowspanPlaceholder(boolean forUsage)
	{
		if (1 == rowspan)
		{
			return null;
		}
		ExtendedGridLayoutConstraints result = new ExtendedGridLayoutConstraints(row+1,col,colspan,rowspan==REMAINDER ? REMAINDER : rowspan-1,component,true,null == mainConstraints ? this : mainConstraints);
		if (forUsage && (result.mainConstraints.col == col))
		{
			result.mainConstraints.effectiveRowspan++;
		}
		return result;
	}
	
	
	public int getRow()
	{
		return row;
	}
	
	
	public int getCol()
	{
		return col;
	}
	
	
	void setCol(int col)
	{
		if (col < 0)
		{
			throw new IllegalArgumentException(""col must be non-negative ("" + col + ')');
		}
		this.col = col;
	}
	
	
	public int getColspan()
	{
		return colspan;
	}
	
	
	int getEffectiveColspan()
	{
		return null == mainConstraints ? effectiveColspan : mainConstraints.effectiveColspan;
	}
	
	
	public int getRowspan()
	{
		return rowspan;
	}
	
	
	int getEffectiveRowspan()
	{
		return null == mainConstraints ? effectiveRowspan : mainConstraints.effectiveRowspan;
	}
	
	
	Component getComponent()
	{
		return component;
	}
	
	
	public boolean isPlaceholder()
	{
		return placeholder;
	}
	
	
	ExtendedGridLayoutConstraints getWorkCopy()
	{
		return new ExtendedGridLayoutConstraints(row,col,colspan,rowspan,component,placeholder,(null == mainConstraints ? null : mainConstraints.getWorkCopy()));
	}
	
	
	public boolean equals(Object o)
	{
		if ((o == null) ||
		    (!(o instanceof ExtendedGridLayoutConstraints)))
		{
			return false;
		}
		if (component == null)
		{
			return ((ExtendedGridLayoutConstraints)o).component == null;
		}
		return component.equals(((ExtendedGridLayoutConstraints)o).component);
	}
	
	
	public int hashCode()
	{
		if (null == component)
		{
			return 0;
		}
		return component.hashCode();
	}
	
	
	public String toString()
	{
		return getClass().getName() + ""[row="" + row + "",col="" + col
			+ "",colspan="" + colspan + "",effectiveColspan="" + effectiveColspan
			+ "",rowspan="" + rowspan + "",effectiveRowspan="" + effectiveRowspan
			+ "",placeholder="" + placeholder + "",component="" + component
			+ "",mainConstraints="" + mainConstraints + ""]"";
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHImportDeclaration,2,2,0,10,12,1,1,9,1,1.0,67,0.0,0,0.944444444,0.625,1,1,31.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

class BSHImportDeclaration extends SimpleNode
{
	public boolean importPackage;
	public boolean staticImport;
	public boolean superImport;

	BSHImportDeclaration(int id) { super(id); }

	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		if ( superImport )
			try {
				namespace.doSuperImport();
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack  );
			}
		else 
		{
			if ( staticImport )
			{
				if ( importPackage )
				{
					Class clas = ((BSHAmbiguousName)jjtGetChild(0)).toClass( 
						callstack, interpreter );
					namespace.importStatic( clas );
				} else
					throw new EvalError( 
						""static field imports not supported yet"", 
						this, callstack );
			} else 
			{
				String name = ((BSHAmbiguousName)jjtGetChild(0)).text;
				if ( importPackage )
					namespace.importPackage(name);
				else
					namespace.importClass(name);
			}
		}

        return Primitive.VOID;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.help.HelpHistoryModelListener,1,1,0,2,1,0,2,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.help;


public interface HelpHistoryModelListener
{
	public void historyUpdated();
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHMethodDeclaration,8,2,0,17,25,4,4,14,2,0.482142857,252,0.0,4,0.708333333,0.45,1,1,29.5,4,1.375,0,"

package org.gjt.sp.jedit.bsh;

class BSHMethodDeclaration extends SimpleNode
{
	public String name;

	

	BSHReturnType returnTypeNode;
	BSHFormalParameters paramsNode;
	BSHBlock blockNode;
	
	int firstThrowsClause;

	

	public Modifiers modifiers;

	
	Class returnType;  
	int numThrows = 0;

	BSHMethodDeclaration(int id) { super(id); }

	
	synchronized void insureNodesParsed() 
	{
		if ( paramsNode != null ) 
			return;

		Object firstNode = jjtGetChild(0);
		firstThrowsClause = 1;
		if ( firstNode instanceof BSHReturnType )
		{
			returnTypeNode = (BSHReturnType)firstNode;
			paramsNode = (BSHFormalParameters)jjtGetChild(1);
			if ( jjtGetNumChildren() > 2+numThrows )
				blockNode = (BSHBlock)jjtGetChild(2+numThrows); 
			++firstThrowsClause;
		}
		else
		{
			paramsNode = (BSHFormalParameters)jjtGetChild(0);
			blockNode = (BSHBlock)jjtGetChild(1+numThrows); 
		}
	}

	
	Class evalReturnType( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		insureNodesParsed();
		if ( returnTypeNode != null )
			return returnTypeNode.evalReturnType( callstack, interpreter );
		else 
			return null;
	}

	String getReturnTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage )
	{
		insureNodesParsed();
		if ( returnTypeNode == null )
			return null;
		else
			return returnTypeNode.getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
	}

	BSHReturnType getReturnTypeNode() {
		insureNodesParsed();
		return returnTypeNode;
	}

	
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		returnType = evalReturnType( callstack, interpreter );
		evalNodes( callstack, interpreter );

		
		






		NameSpace namespace = callstack.top();
		BshMethod bshMethod = new BshMethod( this, namespace, modifiers );
		try {
			namespace.setMethod( name, bshMethod );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(this,callstack);
		}

		return Primitive.VOID;
	}

	private void evalNodes( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		insureNodesParsed();
		
		
		for(int i=firstThrowsClause; i<numThrows+firstThrowsClause; i++)
			((BSHAmbiguousName)jjtGetChild(i)).toClass( 
				callstack, interpreter );

		paramsNode.eval( callstack, interpreter );

		
		if ( interpreter.getStrictJava() )
		{
			for(int i=0; i<paramsNode.paramTypes.length; i++)
				if ( paramsNode.paramTypes[i] == null )
					
					
					throw new EvalError(
				""(Strict Java Mode) Undeclared argument type, parameter: "" +
					paramsNode.getParamNames()[i] + "" in method: "" 
					+ name, this, null );

			if ( returnType == null )
				
				
				throw new EvalError(
				""(Strict Java Mode) Undeclared return type for method: ""
					+ name, this, null );
		}
	}

	public String toString() {
		return ""MethodDeclaration: ""+name;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ParserTreeConstants,1,1,0,2,1,0,2,0,0,2.0,196,0.0,0,0.0,0.0,0,0,156.0,0,0.0,0,"

package org.gjt.sp.jedit.bsh;

public interface ParserTreeConstants
{
  public int JJTVOID = 0;
  public int JJTCLASSDECLARATION = 1;
  public int JJTMETHODDECLARATION = 2;
  public int JJTPACKAGEDECLARATION = 3;
  public int JJTIMPORTDECLARATION = 4;
  public int JJTVARIABLEDECLARATOR = 5;
  public int JJTARRAYINITIALIZER = 6;
  public int JJTFORMALPARAMETERS = 7;
  public int JJTFORMALPARAMETER = 8;
  public int JJTTYPE = 9;
  public int JJTRETURNTYPE = 10;
  public int JJTPRIMITIVETYPE = 11;
  public int JJTAMBIGUOUSNAME = 12;
  public int JJTASSIGNMENT = 13;
  public int JJTTERNARYEXPRESSION = 14;
  public int JJTBINARYEXPRESSION = 15;
  public int JJTUNARYEXPRESSION = 16;
  public int JJTCASTEXPRESSION = 17;
  public int JJTPRIMARYEXPRESSION = 18;
  public int JJTMETHODINVOCATION = 19;
  public int JJTPRIMARYSUFFIX = 20;
  public int JJTLITERAL = 21;
  public int JJTARGUMENTS = 22;
  public int JJTALLOCATIONEXPRESSION = 23;
  public int JJTARRAYDIMENSIONS = 24;
  public int JJTBLOCK = 25;
  public int JJTFORMALCOMMENT = 26;
  public int JJTSWITCHSTATEMENT = 27;
  public int JJTSWITCHLABEL = 28;
  public int JJTIFSTATEMENT = 29;
  public int JJTWHILESTATEMENT = 30;
  public int JJTFORSTATEMENT = 31;
  public int JJTENHANCEDFORSTATEMENT = 32;
  public int JJTTYPEDVARIABLEDECLARATION = 33;
  public int JJTSTATEMENTEXPRESSIONLIST = 34;
  public int JJTRETURNSTATEMENT = 35;
  public int JJTTHROWSTATEMENT = 36;
  public int JJTTRYSTATEMENT = 37;


  public String[] jjtNodeName = {
    ""void"",
    ""ClassDeclaration"",
    ""MethodDeclaration"",
    ""PackageDeclaration"",
    ""ImportDeclaration"",
    ""VariableDeclarator"",
    ""ArrayInitializer"",
    ""FormalParameters"",
    ""FormalParameter"",
    ""Type"",
    ""ReturnType"",
    ""PrimitiveType"",
    ""AmbiguousName"",
    ""Assignment"",
    ""TernaryExpression"",
    ""BinaryExpression"",
    ""UnaryExpression"",
    ""CastExpression"",
    ""PrimaryExpression"",
    ""MethodInvocation"",
    ""PrimarySuffix"",
    ""Literal"",
    ""Arguments"",
    ""AllocationExpression"",
    ""ArrayDimensions"",
    ""Block"",
    ""FormalComment"",
    ""SwitchStatement"",
    ""SwitchLabel"",
    ""IfStatement"",
    ""WhileStatement"",
    ""ForStatement"",
    ""EnhancedForStatement"",
    ""TypedVariableDeclaration"",
    ""StatementExpressionList"",
    ""ReturnStatement"",
    ""ThrowStatement"",
    ""TryStatement"",
  };
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.GutterPopupHandler,1,1,0,4,1,0,4,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit.textarea;

public interface GutterPopupHandler {
	void handlePopup(int x, int y, int line);
}
"
jEdit,4.3,org.gjt.sp.jedit.OptionPane,4,1,0,5,4,6,5,0,4,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;

import java.awt.Component;


public interface OptionPane
{
	
	String getName();

	
	Component getComponent();

	
	void init();

	
	void save();
}
"
jEdit,4.3,org.gjt.sp.util.WorkRequest,7,1,8,11,13,19,9,2,7,0.833333333,102,1.0,0,0.0,0.371428571,0,0,13.42857143,3,2.0,0,"

package org.gjt.sp.util;


public abstract class WorkRequest implements Runnable, ProgressObserver
{
	
	private boolean largeValues;

	
	public void setAbortable(boolean abortable)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setAbortable(abortable);
	}

	
	public void setStatus(String status)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setStatus(status);
	}

	
	public void setProgressValue(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressValue(value);
	}

	
	public void setProgressMaximum(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressMaximum(value);
	}

	
	
	public void setValue(long value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
		{
			if (largeValues)
			{
				((WorkThread)thread).setProgressValue((int) (value >> 10));
			}
			else
			{
				((WorkThread)thread).setProgressValue((int) value);
			}
		}
	} 

	
	
	public void setMaximum(long value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
		{
			if (value > Integer.MAX_VALUE)
			{
				largeValues = true;
				((WorkThread)thread).setProgressMaximum((int) (value >> 10));
			}
			else
			{
				largeValues = false;
				((WorkThread)thread).setProgressMaximum((int) value);
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.PluginsProvider,4,1,0,6,37,6,0,6,3,2.0,325,0.0,0,0.0,0.4375,0,0,80.25,19,5.75,0,"

package org.gjt.sp.jedit.menu;

import javax.swing.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

public class PluginsProvider implements DynamicMenuProvider
{
	
	public boolean updateEveryTime()
	{
		return false;
	} 

	
	public void update(JMenu menu)
	{
		
		
		int count = 0;

		List<JMenuItem>[] letters = (List<JMenuItem>[])new List[26];
		for(int i = 0; i < letters.length; i++)
		{
			letters[i] = new ArrayList<JMenuItem>();
		}

		Vector<JMenuItem> pluginMenuItems = new Vector<JMenuItem>();

		PluginJAR[] pluginArray = jEdit.getPluginJARs();
		for(int i = 0; i < pluginArray.length; i++)
		{
			PluginJAR jar = pluginArray[i];
			EditPlugin plugin = jar.getPlugin();
			if(plugin == null)
				continue;

			JMenuItem menuItem = plugin.createMenuItems();
			if(menuItem != null)
			{
				addToLetterMap(letters,menuItem);
				count++;
			}
			
			else if(jEdit.getProperty(""plugin.""
				+ plugin.getClassName()
				+ "".activate"") == null)
			{
				try
				{
					pluginMenuItems.clear();
					plugin.createMenuItems(pluginMenuItems);

					Iterator<JMenuItem> iter
						= pluginMenuItems.iterator();
					while(iter.hasNext())
					{
						addToLetterMap(letters,
							iter.next());
						count++;
					}
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,
						""Error creating menu items""
						+ "" for plugin"");
					Log.log(Log.ERROR,this,t);
				}
			} 
		}

		if(count == 0)
		{
			JMenuItem menuItem = new JMenuItem(
				jEdit.getProperty(""no-plugins.label""));
			menuItem.setEnabled(false);
			menu.add(menuItem);
			return;
		}

		
		for(int i = 0; i < letters.length; i++)
		{
			Collections.sort(letters[i],new MenuItemTextComparator());
		}

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

		
		if(count <= maxItems)
		{
			for(int i = 0; i < letters.length; i++)
			{
				Iterator<JMenuItem> iter
					= letters[i].iterator();
				while(iter.hasNext())
				{
					menu.add(iter.next());
				}
			}

			return;
		}

		
		count = 0;
		char first = 'A';
		JMenu submenu = new JMenu();
		menu.add(submenu);

		for(int i = 0; i < letters.length; i++)
		{
			List<JMenuItem> letter = letters[i];

			if(count + letter.size() > maxItems && count != 0)
			{
				char last = (char)(i + 'A' - 1);
				if(last == first)
					submenu.setText(String.valueOf(first));
				else
					submenu.setText(first + "" - "" + last);
				first = (char)(i + 'A');
				count = 0;
				submenu = null;
			}

			Iterator<JMenuItem> iter = letter.iterator();
			while(iter.hasNext())
			{
				if(submenu == null)
				{
					submenu = new JMenu();
					menu.add(submenu);
				}
				submenu.add(iter.next());
			}

			count += letter.size();
		}

		if(submenu != null)
		{
			char last = 'Z';
			if(last == first)
				submenu.setText(String.valueOf(first));
			else
				submenu.setText(first + "" - "" + last);
		}
	} 

	
	private void addToLetterMap(List<JMenuItem>[] letters, JMenuItem item)
	{
		char ch = item.getText().charAt(0);
		ch = Character.toUpperCase(ch);
		if(ch < 'A' || ch > 'Z')
		{
			Log.log(Log.ERROR,this,""Plugin menu item label must ""
				+ ""begin with A - Z, or a - z: ""
				+ item.getText());
		}
		else
			letters[ch - 'A'].add(item);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.ParserRule,17,1,0,5,46,130,4,2,15,0.699596774,819,0.0,3,0.0,0.522875817,0,0,45.35294118,21,2.1765,0,"

package org.gjt.sp.jedit.syntax;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;


public class ParserRule
{

	
	public static final int MAJOR_ACTIONS = 0x000000FF;
	public static final int SEQ = 0;
	public static final int SPAN = 1 << 1;
	public static final int MARK_PREVIOUS = 1 << 2;
	public static final int MARK_FOLLOWING = 1 << 3;
	public static final int EOL_SPAN = 1 << 4;
	

	
	public static final int ACTION_HINTS = 0x0000FF00;

	@Deprecated
	public static final int EXCLUDE_MATCH = 1 << 8;

	public static final int NO_LINE_BREAK = 1 << 9;
	public static final int NO_WORD_BREAK = 1 << 10;
	public static final int IS_ESCAPE = 1 << 11;

	@Deprecated
	public static final int NO_ESCAPE = 1 << 12;

	public static final int REGEXP = 1 << 13;
	

	
	public static final byte MATCH_TYPE_CONTEXT 	= -1;
	public static final byte MATCH_TYPE_RULE 	= -2;
	

	
	public static final int AT_LINE_START = 1 << 1;
	public static final int AT_WHITESPACE_END = 1 << 2;
	public static final int AT_WORD_START = 1 << 3;
	

	
	public final String upHashChar;
	public final char[] upHashChars;
	public final int startPosMatch;
	public final char[] start;
	public final Pattern startRegexp;

	public final int endPosMatch;
	public final char[] end;

	public final int action;
	public final byte token;

	
	public final byte matchType;

	
	public final ParserRule escapeRule;

	public ParserRuleSet delegate;

	
	public ParserRule next;
	

	
	public static final ParserRule createSequenceRule(
		int posMatch, String seq, ParserRuleSet delegate, byte id)
	{
		return new ParserRule(SEQ, seq.substring(0,1),
			posMatch, seq.toCharArray(), null,
			0, null, delegate, id, MATCH_TYPE_CONTEXT, null);
	} 

	
	
	public static final ParserRule createRegexpSequenceRule(
		char hashChar, int posMatch, String seq,
		ParserRuleSet delegate, byte id, boolean ignoreCase)
		throws PatternSyntaxException
	{
		return createRegexpSequenceRule(String.valueOf(hashChar), posMatch,
			seq, delegate, id, ignoreCase);
	} 

	
	public static final ParserRule createRegexpSequenceRule(
		String hashChar, int posMatch, String seq,
		ParserRuleSet delegate, byte id, boolean ignoreCase)
		throws PatternSyntaxException
	{
		return new ParserRule(SEQ | REGEXP, hashChar, posMatch,
			null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),
			0, null, delegate, id, MATCH_TYPE_CONTEXT, null);
	} 

	
	public static final ParserRule createRegexpSequenceRule(
		int posMatch, char[] hashChars, String seq,
		ParserRuleSet delegate, byte id, boolean ignoreCase)
		throws PatternSyntaxException
	{
		return new ParserRule(hashChars, SEQ | REGEXP, posMatch,
			null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),
			0, null, delegate, id, MATCH_TYPE_CONTEXT, null);
	} 

	
	public static final ParserRule createSpanRule(
		int startPosMatch, String start, int endPosMatch, String end,
		ParserRuleSet delegate, byte id, byte matchType,
		boolean noLineBreak, boolean noWordBreak, String escape)
	{
		int ruleAction = SPAN |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0);

		return new ParserRule(ruleAction, start.substring(0,1), startPosMatch,
			start.toCharArray(), null,
			endPosMatch, end.toCharArray(),
			delegate, id, matchType, escape);
	} 

	
	public static final ParserRule createRegexpSpanRule(
		String hashChar, int startPosMatch, String start,
		int endPosMatch, String end, ParserRuleSet delegate, byte id,
		byte matchType, boolean noLineBreak, boolean noWordBreak,
		boolean ignoreCase, String escape)
		throws PatternSyntaxException
	{
		int ruleAction = SPAN | REGEXP |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0);

		return new ParserRule(ruleAction, hashChar, startPosMatch, null,
			Pattern.compile(start,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),
			endPosMatch, end.toCharArray(), delegate, id, matchType,
			escape);
	} 

	
	public static final ParserRule createRegexpSpanRule(
		int startPosMatch, char[] hashChars, String start,
		int endPosMatch, String end, ParserRuleSet delegate, byte id,
		byte matchType, boolean noLineBreak, boolean noWordBreak,
		boolean ignoreCase, String escape)
		throws PatternSyntaxException
	{
		int ruleAction = SPAN | REGEXP |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0);

		return new ParserRule(hashChars, ruleAction, startPosMatch, null,
			Pattern.compile(start,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),
			endPosMatch, end.toCharArray(), delegate, id,
			matchType, escape);
	} 

	
	public static final ParserRule createEOLSpanRule(
		int posMatch, String seq, ParserRuleSet delegate, byte id,
		byte matchType)
	{
		int ruleAction = EOL_SPAN | NO_LINE_BREAK;

		return new ParserRule(ruleAction, seq.substring(0,1), posMatch,
			seq.toCharArray(), null, 0, null,
			delegate, id, matchType, null);
	} 

	
	
	public static final ParserRule createRegexpEOLSpanRule(
		char hashChar, int posMatch, String seq, ParserRuleSet delegate,
		byte id, byte matchType, boolean ignoreCase)
		throws PatternSyntaxException
	{
		return createRegexpEOLSpanRule(String.valueOf(hashChar),
			posMatch,seq,delegate,id,matchType,ignoreCase);
	} 

	
	public static final ParserRule createRegexpEOLSpanRule(
		String hashChar, int posMatch, String seq, ParserRuleSet delegate,
		byte id, byte matchType, boolean ignoreCase)
		throws PatternSyntaxException
	{
		int ruleAction = EOL_SPAN | REGEXP | NO_LINE_BREAK;

		return new ParserRule(ruleAction, hashChar, posMatch,
			null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),
			0, null, delegate, id, matchType, null);
	} 

	
	public static final ParserRule createRegexpEOLSpanRule(
		int posMatch, char[] hashChars, String seq, ParserRuleSet delegate,
		byte id, byte matchType, boolean ignoreCase)
		throws PatternSyntaxException
	{
		int ruleAction = EOL_SPAN | REGEXP | NO_LINE_BREAK;

		return new ParserRule(hashChars, ruleAction, posMatch,
			null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),
			0, null, delegate, id, matchType, null);
	} 

	
	public static final ParserRule createMarkFollowingRule(
		int posMatch, String seq, byte id, byte matchType)
	{
		int ruleAction = MARK_FOLLOWING;

		return new ParserRule(ruleAction, seq.substring(0,1), posMatch,
			seq.toCharArray(), null, 0, null, null, id, matchType,
			null);
	} 

	
	public static final ParserRule createMarkPreviousRule(
		int posMatch, String seq, byte id, byte matchType)
	{
		int ruleAction = MARK_PREVIOUS;

		return new ParserRule(ruleAction, seq.substring(0,1), posMatch,
			seq.toCharArray(), null, 0, null, null, id, matchType,
			null);
	} 

	
	public static final ParserRule createEscapeRule(String seq)
	{
		int ruleAction = IS_ESCAPE;

		return new ParserRule(ruleAction, seq.substring(0,1),
			0, seq.toCharArray(), null, 0, null,
			null, Token.NULL, MATCH_TYPE_CONTEXT, null);
	} 

	
	public String toString()
	{
		StringBuilder result = new StringBuilder();
		result.append(getClass().getName()).append(""[action="");
		switch (action & MAJOR_ACTIONS)
		{
			case SEQ: result.append(""SEQ""); break;
			case SPAN: result.append(""SPAN""); break;
			case MARK_PREVIOUS: result.append(""MARK_PREVIOUS""); break;
			case MARK_FOLLOWING: result.append(""MARK_FOLLOWING""); break;
			case EOL_SPAN: result.append(""EOL_SPAN""); break;
			default: result.append(""UNKNOWN""); break;
		}
		int actionHints = action & ACTION_HINTS;
		result.append(""[matchType="").append(matchType == MATCH_TYPE_CONTEXT ? ""MATCH_TYPE_CONTEXT"" : (matchType == MATCH_TYPE_RULE ? ""MATCH_TYPE_RULE"" : Token.tokenToString(matchType)));
		result.append("",NO_LINE_BREAK="").append((actionHints & NO_LINE_BREAK) != 0);
		result.append("",NO_WORD_BREAK="").append((actionHints & NO_WORD_BREAK) != 0);
		result.append("",IS_ESCAPE="").append((actionHints & IS_ESCAPE) != 0);
		result.append("",REGEXP="").append((actionHints & REGEXP) != 0);
		result.append(""],upHashChar="").append(upHashChar);
		result.append("",upHashChars="").append(Arrays.toString(upHashChars));
		result.append("",startPosMatch="");
		result.append(""[AT_LINE_START="").append((startPosMatch & AT_LINE_START) != 0);
		result.append("",AT_WHITESPACE_END="").append((startPosMatch & AT_WHITESPACE_END) != 0);
		result.append("",AT_WORD_START="").append((startPosMatch & AT_WORD_START) != 0);
		result.append(""],start="").append(null==start?null:String.valueOf(start));
		result.append("",startRegexp="").append(startRegexp);
		result.append("",endPosMatch="");
		result.append(""[AT_LINE_START="").append((endPosMatch & AT_LINE_START) != 0);
		result.append("",AT_WHITESPACE_END="").append((endPosMatch & AT_WHITESPACE_END) != 0);
		result.append("",AT_WORD_START="").append((endPosMatch & AT_WORD_START) != 0);
		result.append(""],end="").append(null==end?null:String.valueOf(end));
		result.append("",delegate="").append(delegate);
		result.append("",escapeRule="").append(escapeRule);
		result.append("",token="").append(Token.tokenToString(token)).append(']');
		return result.toString();
	} 

	
	private ParserRule(int action, String hashChar,
		int startPosMatch, char[] start, Pattern startRegexp,
		int endPosMatch, char[] end,
		ParserRuleSet delegate, byte token, byte matchType,
		String escape)
	{
		this.action = action;
		this.upHashChar = null == hashChar ? null : hashChar.toUpperCase();
		this.upHashChars = null;
		this.startPosMatch = startPosMatch;
		this.start = start;
		this.startRegexp = startRegexp;
		this.endPosMatch = endPosMatch;
		this.end = end;
		this.delegate = delegate;
		this.token = token;
		this.matchType = matchType;
		this.escapeRule = (escape != null && escape.length() > 0) ?
					createEscapeRule(escape) : null;

		if(this.delegate == null)
		{
			if((action & MAJOR_ACTIONS) != SEQ)
			{
				this.delegate = ParserRuleSet.getStandardRuleSet(token);
			}
		}
	}

	private ParserRule(char[] hashChars, int action,
		int startPosMatch, char[] start, Pattern startRegexp,
		int endPosMatch, char[] end,
		ParserRuleSet delegate, byte token, byte matchType,
		String escape)
	{
		this.action = action;
		this.upHashChar = null;
		Set<Character> hashCharsSet = new HashSet<Character>();
		for (char c : hashChars)
		{
			hashCharsSet.add(Character.toUpperCase(c));
		}
		this.upHashChars = new char[hashCharsSet.size()];
		int i = 0;
		for (Character c : hashCharsSet)
		{
			this.upHashChars[i++] = c;
		}
		Arrays.sort(this.upHashChars);
		this.startPosMatch = startPosMatch;
		this.start = start;
		this.startRegexp = startRegexp;
		this.endPosMatch = endPosMatch;
		this.end = end;
		this.delegate = delegate;
		this.token = token;
		this.matchType = matchType;
		this.escapeRule = (escape != null && escape.length() > 0) ?
					createEscapeRule(escape) : null;

		if(this.delegate == null)
		{
			if((action & MAJOR_ACTIONS) != SEQ)
			{
				this.delegate = ParserRuleSet.getStandardRuleSet(token);
			}
		}
	} 
}

"
jEdit,4.3,org.gjt.sp.jedit.browser.BrowserListener,2,1,0,4,2,1,3,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.browser;

import java.util.EventListener;

import org.gjt.sp.jedit.io.VFSFile;


public interface BrowserListener extends EventListener
{
	
	void filesSelected(VFSBrowser browser, VFSFile[] files);

	
	void filesActivated(VFSBrowser browser, VFSFile[] files);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.NameSource,2,1,0,3,2,1,3,1,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.bsh;


public interface NameSource
{
    public String [] getAllNames();
    public void addNameSourceListener( NameSource.Listener listener );

    public static interface Listener {
        public void nameSourceChanged( NameSource src );
        
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.options.ShortcutsOptionPane,14,6,0,18,90,59,7,18,1,0.807692308,470,1.0,1,0.980938416,0.271428571,4,12,32.14285714,5,1.6429,0,"

package org.gjt.sp.jedit.options;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.FilteredTableModel;
import org.gjt.sp.jedit.gui.GrabKeyDialog;
import org.gjt.sp.jedit.gui.GrabKeyDialog.KeyBinding;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.AbstractTableModel;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Vector;



public class ShortcutsOptionPane extends AbstractOptionPane
{
	
	public ShortcutsOptionPane()
	{
		super(""shortcuts"");
	} 

	
	@Override
	protected void _init()
	{
		allBindings = new Vector<KeyBinding>();

		setLayout(new BorderLayout(12,12));

		initModels();

		selectModel = new JComboBox(models);
		selectModel.addActionListener(new ActionHandler());
		selectModel.setToolTipText(jEdit.getProperty(""options.shortcuts.select.tooltip""));
		Box north = Box.createHorizontalBox();
		north.add(new JLabel(jEdit.getProperty(
			""options.shortcuts.select.label"")));
		north.add(Box.createHorizontalStrut(6));
		north.add(selectModel);

		filterTF = new JTextField(40);
		filterTF.setToolTipText(jEdit.getProperty(""options.shortcuts.filter.tooltip""));
		filterTF.getDocument().addDocumentListener(new DocumentListener()
		{
			public void changedUpdate(DocumentEvent e)
			{
				setFilter();
			}

			public void insertUpdate(DocumentEvent e)
			{
				setFilter();
			}

			public void removeUpdate(DocumentEvent e)
			{
				setFilter();
			}
		});
		JButton clearButton = new JButton(jEdit.getProperty(
				""options.shortcuts.clear.label""));
		clearButton.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent arg0)
			{
				filterTF.setText("""");
				filterTF.requestFocus();
			}
		});

		JPanel filterPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		filterPanel.add(new JLabel(jEdit.getProperty(""options.shortcuts.filter.label"")));
		filterPanel.add(filterTF);
		filterPanel.add(clearButton);

		keyTable = new JTable(filteredModel);
		filteredModel.setTable(keyTable);
		keyTable.getTableHeader().setReorderingAllowed(false);
		keyTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		keyTable.addMouseListener(new TableMouseHandler());
		Dimension d = keyTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(keyTable);
		scroller.setPreferredSize(d);
		JPanel tableFilterPanel = new JPanel(new BorderLayout());
		tableFilterPanel.add(BorderLayout.NORTH,filterPanel);
		tableFilterPanel.add(BorderLayout.CENTER,scroller);

		add(BorderLayout.NORTH,north);
		add(BorderLayout.CENTER,tableFilterPanel);
		try
		{
			selectModel.setSelectedIndex(jEdit.getIntegerProperty(""options.shortcuts.select.index"", 0));
		}
		catch (IllegalArgumentException eae) {}
	} 

	
	@Override
	protected void _save()
	{
		if(keyTable.getCellEditor() != null)
			keyTable.getCellEditor().stopCellEditing();

		for (ShortcutsModel model : models)
			model.save();

		Macros.loadMacros();
	} 

	
	private JTable keyTable;
	private Vector<ShortcutsModel> models;
	private FilteredTableModel<ShortcutsModel> filteredModel;
	private JComboBox selectModel;
	private List<KeyBinding> allBindings;
	private JTextField filterTF;

	
	private void setFilter()
	{
		filteredModel.setFilter(filterTF.getText());
	} 

	
	private void initModels()
	{
		List<KeyBinding[]> allBindings = new Vector<KeyBinding[]>();
		models = new Vector<ShortcutsModel>();
		ActionSet[] actionSets = jEdit.getActionSets();
		for(int i = 0; i < actionSets.length; i++)
		{
			ActionSet actionSet = actionSets[i];
			if(actionSet.getActionCount() != 0)
			{
				String modelLabel = actionSet.getLabel();
				if(modelLabel == null)
				{
					Log.log(Log.ERROR,this,""Empty action set: ""
						+ actionSet.getPluginJAR());
				}
				ShortcutsModel model = createModel(modelLabel,
						actionSet.getActionNames());
				models.addElement(model);
				allBindings.addAll(model.getBindings());
			}
		}
		if (models.size() > 1)
			models.addElement(new ShortcutsModel(""All"", allBindings));
		Collections.sort(models,new StandardUtilities.StringCompare<ShortcutsModel>(true));
		ShortcutsModel currentModel = models.elementAt(0);
		filteredModel = new FilteredTableModel<ShortcutsModel>(currentModel)
		{
			@Override
			public String prepareFilter(String filter)
			{
				return filter.toLowerCase();
			}

			@Override
			public boolean passFilter(int row, String filter)
			{
				String name = delegated.getBindingAt(row, 0).label.toLowerCase();
				return name.contains(filter);
			}
		};
	} 

	
	private ShortcutsModel createModel(String modelLabel, String[] actions)
	{
		List<GrabKeyDialog.KeyBinding[]> bindings = new Vector<GrabKeyDialog.KeyBinding[]>(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			String name = actions[i];
			EditAction ea = jEdit.getAction(name);
			String label = ea.getLabel();
			
			if(label == null)
				continue;

			label = GUIUtilities.prettifyMenuLabel(label);
			addBindings(name,label,bindings);
		}

		return new ShortcutsModel(modelLabel,bindings);
	} 

	
	private void addBindings(String name, String label, List<GrabKeyDialog.KeyBinding[]> bindings)
	{
		GrabKeyDialog.KeyBinding[] b = new GrabKeyDialog.KeyBinding[2];

		b[0] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut""));
		b[1] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut2""));

		bindings.add(b);
	} 

	
	private GrabKeyDialog.KeyBinding createBinding(String name,
		String label, String shortcut)
	{
		if(shortcut != null && shortcut.length() == 0)
			shortcut = null;

		GrabKeyDialog.KeyBinding binding
			= new GrabKeyDialog.KeyBinding(name,label,shortcut,false);

		allBindings.add(binding);
		return binding;
	} 

	

	
	private class HeaderMouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			ShortcutsModel shortcutsModel = filteredModel.getDelegated();
			switch(keyTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				shortcutsModel.sort(0);
				break;
			case 1:
				shortcutsModel.sort(1);
				break;
			case 2:
				shortcutsModel.sort(2);
				break;
			}
			setFilter();
		}
	} 

	
	private class TableMouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			int row = keyTable.getSelectedRow();
			int col = keyTable.getSelectedColumn();
			if(col != 0 && row != -1)
			{
				 GrabKeyDialog gkd = new GrabKeyDialog(
					GUIUtilities.getParentDialog(
					ShortcutsOptionPane.this),
					filteredModel.getDelegated().getBindingAt(filteredModel.getTrueRow(row), col - 1),
					allBindings,null);
				if(gkd.isOK())
					filteredModel.setValueAt(
						gkd.getShortcut(),row,col);
			}
		}
	} 

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			ShortcutsModel newModel
				= (ShortcutsModel)selectModel.getSelectedItem();
			if(filteredModel.getDelegated() != newModel)
			{
				jEdit.setIntegerProperty(""options.shortcuts.select.index"", selectModel.getSelectedIndex());
				filteredModel.setDelegated(newModel);
				setFilter();
			}
		}
	} 

	
	private class ShortcutsModel extends AbstractTableModel
	{
		private List<GrabKeyDialog.KeyBinding[]> bindings;
		private String name;

		ShortcutsModel(String name, List<GrabKeyDialog.KeyBinding[]> bindings)
		{
			this.name = name;
			this.bindings = bindings;
			sort(0);
		}

		public List<GrabKeyDialog.KeyBinding[]> getBindings()
		{
			return bindings;
		}

		public void sort(int col)
		{
			Collections.sort(bindings,new KeyCompare(col));
		}

		public int getColumnCount()
		{
			return 3;
		}

		public int getRowCount()
		{
			return bindings.size();
		}

		public Object getValueAt(int row, int col)
		{
			switch(col)
			{
			case 0:
				return getBindingAt(row,0).label;
			case 1:
				return getBindingAt(row,0).shortcut;
			case 2:
				return getBindingAt(row,1).shortcut;
			default:
				return null;
			}
		}

		@Override
		public void setValueAt(Object value, int row, int col)
		{
			if(col == 0)
				return;

			getBindingAt(row,col-1).shortcut = (String)value;

			
			
			fireTableDataChanged();
		}

		@Override
		public String getColumnName(int index)
		{
			switch(index)
			{
			case 0:
				return jEdit.getProperty(""options.shortcuts.name"");
			case 1:
				return jEdit.getProperty(""options.shortcuts.shortcut1"");
			case 2:
				return jEdit.getProperty(""options.shortcuts.shortcut2"");
			default:
				return null;
			}
		}

		public void save()
		{
			for (GrabKeyDialog.KeyBinding[] binding : bindings)
			{
				jEdit.setProperty(
					binding[0].name + "".shortcut"",
					binding[0].shortcut);
				jEdit.setProperty(
					binding[1].name + "".shortcut2"",
					binding[1].shortcut);
			}
		}

		public GrabKeyDialog.KeyBinding getBindingAt(int row, int nr)
		{
			GrabKeyDialog.KeyBinding[] binding = bindings.get(row);
			return binding[nr];
		}

		@Override
		public String toString()
		{
			return name;
		}

		private class KeyCompare implements Comparator<GrabKeyDialog.KeyBinding[]>
		{
			private int col;

			KeyCompare(int col)
			{
				this.col = col;
			}

			public int compare(GrabKeyDialog.KeyBinding[] k1, GrabKeyDialog.KeyBinding[] k2)
			{
				String label1 = k1[0].label.toLowerCase();
				String label2 = k2[0].label.toLowerCase();

				if(col == 0)
					return StandardUtilities.compareStrings(
						label1,label2,true);
				else
				{
					String shortcut1, shortcut2;
					if(col == 1)
					{
						shortcut1 = k1[0].shortcut;
						shortcut2 = k2[0].shortcut;
					}
					else
					{
						shortcut1 = k1[1].shortcut;
						shortcut2 = k2[1].shortcut;
					}

					if(shortcut1 == null && shortcut2 != null)
						return 1;
					else if(shortcut2 == null && shortcut1 != null)
						return -1;
					else if(shortcut1 == null)
						return StandardUtilities.compareStrings(label1,label2,true);
					else
						return StandardUtilities.compareStrings(shortcut1,shortcut2,true);
				}
			}
		}
	} 
	
	
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.ContentManager,13,1,0,2,23,0,1,1,10,0.229166667,498,1.0,0,0.0,0.371794872,0,0,37.0,4,2.0,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;


public class ContentManager
{
	
	public final int getLength()
	{
		return length;
	} 

	
	public String getText(int start, int len)
	{
		if(start >= gapStart)
			return new String(text,start + gapEnd - gapStart,len);
		else if(start + len <= gapStart)
			return new String(text,start,len);
		else
		{
			return new String(text,start,gapStart - start)
				.concat(new String(text,gapEnd,start + len - gapStart));
		}
	}

	
	public void getText(int start, int len, Segment seg)
	{
		if(start >= gapStart)
		{
			seg.array = text;
			seg.offset = start + gapEnd - gapStart;
			seg.count = len;
		}
		else if(start + len <= gapStart)
		{
			seg.array = text;
			seg.offset = start;
			seg.count = len;
		}
		else
		{
			seg.array = new char[len];

			
			System.arraycopy(text,start,seg.array,0,gapStart - start);

			
			System.arraycopy(text,gapEnd,seg.array,gapStart - start,
				len + start - gapStart);

			seg.offset = 0;
			seg.count = len;
		}
	} 

	
	
	public CharSequence getSegment(int start, int len)
	{
		if(start >= gapStart)
			return new BufferSegment(text,start + gapEnd - gapStart,len);
		else if(start + len <= gapStart)
			return new BufferSegment(text,start,len);
		else
		{
			return new BufferSegment(text,start,gapStart - start,
				new BufferSegment(text,gapEnd,start + len - gapStart));
		}
	} 

	
	public void insert(int start, String str)
	{
		int len = str.length();
		moveGapStart(start);
		if(gapEnd - gapStart < len)
		{
			ensureCapacity(length + len + 1024);
			moveGapEnd(start + len + 1024);
		}

		str.getChars(0,len,text,start);
		gapStart += len;
		length += len;
	}

	
	public void insert(int start, CharSequence str)
	{
		int len = str.length();
		moveGapStart(start);
		if(gapEnd - gapStart < len)
		{
			ensureCapacity(length + len + 1024);
			moveGapEnd(start + len + 1024);
		}

		for (int i = 0; i < len; i++)
		{
			text[start+i] = str.charAt(i);
		}
		gapStart += len;
		length += len;
	}

	public void insert(int start, Segment seg)
	{
		moveGapStart(start);
		if(gapEnd - gapStart < seg.count)
		{
			ensureCapacity(length + seg.count + 1024);
			moveGapEnd(start + seg.count + 1024);
		}

		System.arraycopy(seg.array,seg.offset,text,start,seg.count);
		gapStart += seg.count;
		length += seg.count;
	} 

	
	public void _setContent(char[] text, int length)
	{
		this.text = text;
		this.gapStart = this.gapEnd = 0;
		this.length = length;
	} 

	
	public void remove(int start, int len)
	{
		moveGapStart(start);
		gapEnd += len;
		length -= len;
	} 

	
	private char[] text;
	private int gapStart;
	private int gapEnd;
	private int length;

	
	private void moveGapStart(int newStart)
	{
		int newEnd = gapEnd + (newStart - gapStart);

		if(newStart == gapStart)
		{
			
		}
		else if(newStart > gapStart)
		{
			System.arraycopy(text,gapEnd,text,gapStart,
				newStart - gapStart);
		}
		else if(newStart < gapStart)
		{
			System.arraycopy(text,newStart,text,newEnd,
				gapStart - newStart);
		}

		gapStart = newStart;
		gapEnd = newEnd;
	} 

	
	private void moveGapEnd(int newEnd)
	{
		System.arraycopy(text,gapEnd,text,newEnd,length - gapStart);
		gapEnd = newEnd;
	} 

	
	private void ensureCapacity(int capacity)
	{
		if(capacity >= text.length)
		{
			char[] textN = new char[capacity * 2];
			System.arraycopy(text,0,textN,0,length + (gapEnd - gapStart));
			text = textN;
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.TextUtilities,27,1,0,21,69,351,17,5,25,1.038461538,1201,0.375,0,0.0,0.200617284,0,0,43.18518519,25,5.7778,0,"

package org.gjt.sp.jedit;


import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.util.StandardUtilities;



public class TextUtilities
{
	
	public static final int BRACKET_MATCH_LIMIT = 10000;

	
	
	public static Token getTokenAtOffset(Token tokens, int offset)
	{
		if(offset == 0 && tokens.id == Token.END)
			return tokens;

		for(;;)
		{
			if(tokens.id == Token.END)
				throw new ArrayIndexOutOfBoundsException(""offset > line length"");

			if(tokens.offset + tokens.length > offset)
				return tokens;
			else
				tokens = tokens.next;
		}
	} 

	
	
	public static char getComplementaryBracket(char ch, boolean[] direction)
	{
		switch(ch)
		{
		case '(': if (direction != null) direction[0] = true;  return ')';
		case ')': if (direction != null) direction[0] = false; return '(';
		case '[': if (direction != null) direction[0] = true;  return ']';
		case ']': if (direction != null) direction[0] = false; return '[';
		case '{': if (direction != null) direction[0] = true;  return '}';
		case '}': if (direction != null) direction[0] = false; return '{';
		case '<': if (direction != null) direction[0] = true;  return '>';
		case '>': if (direction != null) direction[0] = false; return '<';
		default:  return '\0';
		}
	} 

	
	
	public static int findMatchingBracket(JEditBuffer buffer, int line, int offset)
	{
		if(offset < 0 || offset >= buffer.getLineLength(line))
		{
			throw new ArrayIndexOutOfBoundsException(offset + "":""
				+ buffer.getLineLength(line));
		}

		Segment lineText = new Segment();
		buffer.getLineText(line,lineText);

		char c = lineText.array[lineText.offset + offset];
		
		boolean[] direction = new boolean[1];

		
		char cprime = getComplementaryBracket(c,direction);

		if( cprime == '\0' )
		{ 
			return -1;
		}

		
		int count = 1;

		DefaultTokenHandler tokenHandler = new DefaultTokenHandler();
		buffer.markTokens(line,tokenHandler);

		
		
		
		byte idOfBracket = getTokenAtOffset(tokenHandler.getTokens(),offset).id;

		boolean haveTokens = true;

		int startLine = line;

		
		if(direction[0])
		{
			offset++;

			for(;;)
			{
				for(int i = offset; i < lineText.count; i++)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}

				
				line++;
				if(line >= buffer.getLineCount() || (line - startLine) > BRACKET_MATCH_LIMIT)
					break;
				buffer.getLineText(line,lineText);
				offset = 0;
				haveTokens = false;
				
			}
		} 
		
		else
		{
			offset--;

			for(;;)
			{
				for(int i = offset; i >= 0; i--)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}

				
				line--;
				if(line < 0 || (startLine - line) > BRACKET_MATCH_LIMIT)
					break;
				buffer.getLineText(line,lineText);
				offset = lineText.count - 1;
				haveTokens = false;
				
			}
		} 

		
		return -1;
	} 

	
	
	public static int findWordStart(String line, int pos, String noWordSep)
	{
		return findWordStart(line, pos, noWordSep, true, false);
	} 

	
	
	public static int findWordStart(CharSequence line,
					int pos,
					String noWordSep)
	{
		return findWordStart(line, pos, noWordSep, true, false, false);
	} 


	
	public static String join(Collection<String> c, String delim)
	{
		StringBuilder retval = new StringBuilder();
		Iterator<String> itr = c.iterator();
		if (itr.hasNext())
			retval.append( itr.next() );
		else 
			return """";
		while (itr.hasNext())
		{
			retval.append(delim);
			retval.append(itr.next());
		}
		return retval.toString();
	}

	
	
	public static int findWordStart(String line, int pos, String noWordSep,
		boolean joinNonWordChars)
	{
		return findWordStart(line,pos,noWordSep,joinNonWordChars,false);
	} 

	
	
	public static int findWordStart(String line, int pos, String noWordSep,
		boolean joinNonWordChars, boolean eatWhitespace)
	{
		return findWordStart(line, pos, noWordSep, joinNonWordChars, false, eatWhitespace);
	} 

	
	
	public static int findWordStart(String line, int pos, String noWordSep,
		boolean joinNonWordChars, boolean camelCasedWords,
		boolean eatWhitespace)
	{
		return findWordStart((CharSequence) line, pos, noWordSep,
				     joinNonWordChars, camelCasedWords,
				     eatWhitespace);
	} 

	
	
	public static int findWordStart(CharSequence line,
					int pos,
					String noWordSep,
					boolean joinNonWordChars,
					boolean camelCasedWords,
					boolean eatWhitespace)
	{
		char ch = line.charAt(pos);

		if(noWordSep == null)
			noWordSep = """";

		
		int type = getCharType(ch, noWordSep);
		

		for(int i = pos; i >= 0; i--)
		{
			char lastCh = ch;
			ch = line.charAt(i);
			switch(type)
			{
			
			case WHITESPACE:
				
				if(Character.isWhitespace(ch))
					break;
				
				else
					return i + 1; 
			
			case WORD_CHAR:
				
				
				if (camelCasedWords && Character.isUpperCase(ch) && !Character.isUpperCase(lastCh)
						&& Character.isLetterOrDigit(lastCh))
				{
					return i;
				}
				
				
				else if (camelCasedWords && !Character.isUpperCase(ch) && Character.isUpperCase(lastCh))
				{
					return i + 1;
				}
				
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				
				else if(Character.isWhitespace(ch)
					&& eatWhitespace)
				{
					type = WHITESPACE;
					break;
				}
				else
					return i + 1; 
			
			case SYMBOL:
				if(!joinNonWordChars && pos != i)
					return i + 1;

				
				if(Character.isWhitespace(ch))
				{
					if(eatWhitespace)
					{
						type = WHITESPACE;
						break;
					}
					else
						return i + 1;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					return i + 1;
				}
				else
				{
					break;
				} 
			}
		}

		return 0;
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep)
	{
		return findWordEnd(line, pos, noWordSep, true);
	} 

	
	
	public static int findWordEnd(CharSequence line,
				      int pos,
				      String noWordSep)
	{
		return findWordEnd(line, pos, noWordSep, true, false, false);
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep,
		boolean joinNonWordChars)
	{
		return findWordEnd(line,pos,noWordSep,joinNonWordChars,false);
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep,
		boolean joinNonWordChars, boolean eatWhitespace)
	{
		return findWordEnd(line, pos, noWordSep, joinNonWordChars, false, eatWhitespace);
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep,
		boolean joinNonWordChars, boolean camelCasedWords,
		boolean eatWhitespace)
	{
		return findWordEnd((CharSequence)line, pos, noWordSep,
				   joinNonWordChars, camelCasedWords,
				   eatWhitespace);
	} 

	
	
	public static int findWordEnd(CharSequence line,
				      int pos,
				      String noWordSep,
				      boolean joinNonWordChars,
				      boolean camelCasedWords,
				      boolean eatWhitespace)
	{
		if(pos != 0)
			pos--;

		char ch = line.charAt(pos);

		if(noWordSep == null)
			noWordSep = """";

		
		int type = getCharType(ch, noWordSep);
		

		for(int i = pos; i < line.length(); i++)
		{
			char lastCh = ch;
			ch = line.charAt(i);
			switch(type)
			{
			
			case WHITESPACE:
				
				if(Character.isWhitespace(ch))
					break;
				else
					return i; 
			
			case WORD_CHAR:
				
				
				if (camelCasedWords && i > pos + 1 && !Character.isUpperCase(ch) && Character.isLetterOrDigit(ch)
						&& Character.isUpperCase(lastCh))
				{
					return i - 1;
				}
				
				else if (camelCasedWords && Character.isUpperCase(ch) && !Character.isUpperCase(lastCh))
				{
					return i;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				
				else if(Character.isWhitespace(ch)
					&& eatWhitespace)
				{
					type = WHITESPACE;
					break;
				}
				else
					return i; 
			
			case SYMBOL:
				if(!joinNonWordChars && i != pos)
					return i;

				
				if(Character.isWhitespace(ch))
				{
					if(eatWhitespace)
					{
						type = WHITESPACE;
						break;
					}
					else
						return i;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					return i;
				}
				else
				{
					break;
				} 
			}
		}

		return line.length();
	} 

	
	private static int getCharType(char ch, String noWordSep)
	{
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		return type;
	}

	
	
	public static String spacesToTabs(String in, int tabSize)
	{
		StringBuilder buf = new StringBuilder();
		int width = 0;
		int whitespace = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case ' ':
				whitespace++;
				width++;
				break;
			case '\t':
				int tab = tabSize - (width % tabSize);
				width += tab;
				whitespace += tab;
				break;
			case '\n':
				if(whitespace != 0)
				{
					buf.append(StandardUtilities
						.createWhiteSpace(whitespace,tabSize,
						width - whitespace));
				}
				whitespace = 0;
				width = 0;
				buf.append('\n');
				break;
			default:
				if(whitespace != 0)
				{
					buf.append(StandardUtilities
						.createWhiteSpace(whitespace,tabSize,
						width - whitespace));
					whitespace = 0;
				}
				buf.append(in.charAt(i));
				width++;
				break;
			}
		}

		if(whitespace != 0)
		{
			buf.append(StandardUtilities.createWhiteSpace(whitespace,tabSize,
				width - whitespace));
		}

		return buf.toString();
	} 

	
	
	public static String tabsToSpaces(String in, int tabSize)
	{
		StringBuilder buf = new StringBuilder();
		int width = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case '\t':
				int count = tabSize - (width % tabSize);
				width += count;
				while(--count >= 0)
					buf.append(' ');
				break;
			case '\n':
				width = 0;
				buf.append(in.charAt(i));
				break;
			default:
				width++;
				buf.append(in.charAt(i));
				break;
			}
		}
		return buf.toString();
	} 

	
	
	public static String format(String text, int maxLineLength, int tabSize)
	{
		StringBuilder buf = new StringBuilder();

		int index = 0;

		for(;;)
		{
			int newIndex = text.indexOf(""\n\n"",index);
			if(newIndex == -1)
				break;

			formatParagraph(text.substring(index,newIndex),
				maxLineLength,tabSize,buf);
			buf.append(""\n\n"");
			index = newIndex + 2;
		}

		if(index != text.length())
		{
			formatParagraph(text.substring(index),
				maxLineLength,tabSize,buf);
		}

		return buf.toString();
	} 

	
	
	public static int indexIgnoringWhitespace(String str, int index)
	{
		int j = 0;
		for(int i = 0; i < index; i++)
			if(!Character.isWhitespace(str.charAt(i))) j++;
		return j;
	} 

	
	
	public static int ignoringWhitespaceIndex(String str, int index)
	{
		int j = 0;
		for(int i = 0;;i++)
		{
			if(!Character.isWhitespace(str.charAt(i))) j++;

			if(j > index)
				return i;
			if(i == str.length() - 1)
				return i + 1;
		}
	} 

	
	public static final int MIXED = 0;
	public static final int LOWER_CASE = 1;
	public static final int UPPER_CASE = 2;
	public static final int TITLE_CASE = 3;

	
	public static int getStringCase(String str)
	{
		if(str.length() == 0)
			return MIXED;

		int state = -1;

		char ch = str.charAt(0);
		if(Character.isLetter(ch))
		{
			if(Character.isUpperCase(ch))
				state = UPPER_CASE;
			else
				state = LOWER_CASE;
		}

		for(int i = 1; i < str.length(); i++)
		{
			ch = str.charAt(i);
			if(!Character.isLetter(ch))
				continue;

			switch(state)
			{
			case UPPER_CASE:
				if(Character.isLowerCase(ch))
				{
					if(i == 1)
						state = TITLE_CASE;
					else
						return MIXED;
				}
				break;
			case LOWER_CASE:
			case TITLE_CASE:
				if(Character.isUpperCase(ch))
					return MIXED;
				break;
			}
		}

		return state;
	} 

	
	
	public static String toTitleCase(String str)
	{
		if(str.length() == 0)
			return str;
		else
		{
			return Character.toUpperCase(str.charAt(0))
				+ str.substring(1).toLowerCase();
		}
	} 

	
	private static final int WHITESPACE = 0;
	private static final int WORD_CHAR = 1;
	private static final int SYMBOL = 2;

	
	private static void formatParagraph(String text, int maxLineLength,
		int tabSize, StringBuilder buf)
	{
		
		int leadingWhitespaceCount = StandardUtilities.getLeadingWhiteSpace(text);
		String leadingWhitespace = text.substring(0,leadingWhitespaceCount);
		int leadingWhitespaceWidth = StandardUtilities.getLeadingWhiteSpaceWidth(text,tabSize);

		buf.append(leadingWhitespace);

		int lineLength = leadingWhitespaceWidth;
		StringTokenizer st = new StringTokenizer(text);
		while(st.hasMoreTokens())
		{
			String word = st.nextToken();
			if(lineLength == leadingWhitespaceWidth)
			{
				
			}
			else if(lineLength + word.length() + 1 > maxLineLength)
			{
				buf.append('\n');
				buf.append(leadingWhitespace);
				lineLength = leadingWhitespaceWidth;
			}
			else
			{
				buf.append(' ');
				lineLength++;
			}
			buf.append(word);
			lineLength += word.length();
		}
	} 

	
	public static void indexIgnoringWhitespace(String text, int maxLineLength,
		int tabSize, StringBuffer buf)
	{
		
		int leadingWhitespaceCount = StandardUtilities.getLeadingWhiteSpace(text);
		String leadingWhitespace = text.substring(0,leadingWhitespaceCount);
		int leadingWhitespaceWidth = StandardUtilities.getLeadingWhiteSpaceWidth(text,tabSize);

		buf.append(leadingWhitespace);

		int lineLength = leadingWhitespaceWidth;
		StringTokenizer st = new StringTokenizer(text);
		while(st.hasMoreTokens())
		{
			String word = st.nextToken();
			if(lineLength == leadingWhitespaceWidth)
			{
				
			}
			else if(lineLength + word.length() + 1 > maxLineLength)
			{
				buf.append('\n');
				buf.append(leadingWhitespace);
				lineLength = leadingWhitespaceWidth;
			}
			else
			{
				buf.append(' ');
				lineLength++;
			}
			buf.append(word);
			lineLength += word.length();
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableWindowManagerProvider,3,1,0,8,6,3,0,8,3,2.0,17,0.0,0,0.0,0.5,0,0,4.666666667,1,0.6667,0,"package org.gjt.sp.jedit.gui;

import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.View.ViewConfig;
import org.gjt.sp.jedit.gui.DockableWindowManager.DockingLayout;


   
public class DockableWindowManagerProvider implements DockingFrameworkProvider
{
	public DockableWindowManager create(View view,
			DockableWindowFactory instance, ViewConfig config)
	{
		return new DockableWindowManagerImpl(view, instance, config);
	}

	public DockingLayout createDockingLayout()
	{
		return new DockableWindowManagerImpl.DockableWindowConfig();
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ActionBar,17,5,0,23,77,76,11,18,3,0.785714286,498,1.0,5,0.978229318,0.196428571,2,5,27.88235294,11,2.0,0,"

package org.gjt.sp.jedit.gui;


import org.gjt.sp.jedit.bsh.NameSpace;
import java.awt.event.*;
import java.awt.*;
import java.util.ArrayList;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.StandardUtilities;



public class ActionBar extends JToolBar
{
	
	public ActionBar(View view, boolean temp)
	{
		this.view = view;
		this.temp = temp;
		
		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
		setFloatable(false);
		add(Box.createHorizontalStrut(2));

		JLabel label = new JLabel(jEdit.getProperty(""view.action.prompt""));
		add(label);
		add(Box.createHorizontalStrut(12));
		add(action = new ActionTextField());
		action.setEnterAddsToHistory(false);
		Dimension max = action.getPreferredSize();
		max.width = Integer.MAX_VALUE;
		action.setMaximumSize(max);
		action.addActionListener(new ActionHandler());
		action.getDocument().addDocumentListener(new DocumentHandler());

		if(temp)
		{
			close = new RolloverButton(GUIUtilities.loadIcon(""closebox.gif""));
			close.addActionListener(new ActionHandler());
			close.setToolTipText(jEdit.getProperty(
				""view.action.close-tooltip""));
			add(close);
		}

		
		this.temp = temp;
	} 

	
	public HistoryTextField getField()
	{
		return action;
	} 

	
	public void goToActionBar()
	{
		repeatCount = view.getInputHandler().getRepeatCount();
		action.setText(null);
		action.requestFocus();
	} 

	

	private static NameSpace namespace = new NameSpace(
		BeanShell.getNameSpace(),""action bar namespace"");

	
	private View view;
	private boolean temp;
	private int repeatCount;
	private HistoryTextField action;
	private CompletionPopup popup;
	private RolloverButton close;
	

	
	private void invoke()
	{
		String cmd;
		if(popup != null)
			cmd = popup.list.getSelectedValue().toString();
		else
		{
			cmd = action.getText().trim();
			int index = cmd.indexOf('=');
			if(index != -1)
			{
				action.addCurrentToHistory();
				String propName = cmd.substring(0,index).trim();
				String propValue = cmd.substring(index + 1).trim();
				String code;
				
				if(propName.startsWith(""buffer.""))
				{
					if(propName.equals(""buffer.mode""))
					{
						code = ""buffer.setMode(\""""
							+ StandardUtilities.charsToEscapes(
							propValue) + ""\"");"";
					}
					else
					{
						code = ""buffer.setStringProperty(\""""
							+ StandardUtilities.charsToEscapes(
							propName.substring(""buffer."".length())
							) + ""\"",\""""
							+ StandardUtilities.charsToEscapes(
							propValue) + ""\"");"";
					}

					code += ""\nbuffer.propertiesChanged();"";
				}
				else if(propName.startsWith(""!buffer.""))
				{
					code = ""jEdit.setProperty(\""""
						+ StandardUtilities.charsToEscapes(
						propName.substring(1)) + ""\"",\""""
						+ StandardUtilities.charsToEscapes(
						propValue) + ""\"");\n""
						+ ""jEdit.propertiesChanged();"";
				}
				else
				{
					code = ""jEdit.setProperty(\""""
						+ StandardUtilities.charsToEscapes(
						propName) + ""\"",\""""
						+ StandardUtilities.charsToEscapes(
						propValue) + ""\"");\n""
						+ ""jEdit.propertiesChanged();"";
				}

				Macros.Recorder recorder = view.getMacroRecorder();
				if(recorder != null)
					recorder.record(code);
				BeanShell.eval(view,namespace,code);
				cmd = null;
			}
			else if(cmd.length() != 0)
			{
				String[] completions = getCompletions(cmd);
				if(completions.length != 0)
				{
					cmd = completions[0];
				}
			}
			else
				cmd = null;
		}

		if(popup != null)
		{
			popup.dispose();
			popup = null;
		}

		final String finalCmd = cmd;
		final EditAction act = (finalCmd == null ? null : jEdit.getAction(finalCmd));
		if(temp)
			view.removeToolBar(this);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				view.getTextArea().requestFocus();
				if(act == null)
				{
					if(finalCmd != null)
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(
							""view.action.no-completions""));
					}
				}
				else
				{
					view.getInputHandler().setRepeatCount(repeatCount);
					view.getInputHandler().invokeAction(act);
				}
			}
		});
	} 

	
	private static String[] getCompletions(String str)
	{
		str = str.toLowerCase();
		String[] actions = jEdit.getActionNames();
		ArrayList<String> returnValue = new ArrayList<String>(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			if(actions[i].toLowerCase().contains(str))
				returnValue.add(actions[i]);
		}

		return returnValue.toArray(new String[returnValue.size()]);
	} 

	
	private void complete(boolean insertLongestPrefix)
	{
		String text = action.getText().trim();
		String[] completions = getCompletions(text);
		if(completions.length == 1)
		{
			if(insertLongestPrefix)
				action.setText(completions[0]);
		}
		else if(completions.length != 0)
		{
			if(insertLongestPrefix)
			{
				String prefix = MiscUtilities.getLongestPrefix(
					completions,true);
				if(prefix.contains(text))
					action.setText(prefix);
			}

			if(popup != null)
				popup.setModel(completions);
			else
				popup = new CompletionPopup(completions);
			return;
		}

		if(popup != null)
		{
			popup.dispose();
			popup = null;
		}
	} 

	

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == close)
				view.removeToolBar(ActionBar.this);
			else
				invoke();
		}
	} 

	
	private class DocumentHandler implements DocumentListener
	{
		
		public void insertUpdate(DocumentEvent evt)
		{
			if(popup != null)
				complete(false);
		} 

		
		public void removeUpdate(DocumentEvent evt)
		{
			if(popup != null)
				complete(false);
		} 

		
		public void changedUpdate(DocumentEvent evt) {}
		
	} 

	
	private class ActionTextField extends HistoryTextField
	{
		boolean repeat;
		boolean nonDigit;

		ActionTextField()
		{
			super(""action"");
			setSelectAllOnFocus(true);
		}

		@Override
		public boolean isManagingFocus()
		{
			return false;
		}

		@Override
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		}

		@Override
		public void processKeyEvent(KeyEvent evt)
		{
			evt = KeyEventWorkaround.processKeyEvent(evt);
			if(evt == null)
				return;

			switch(evt.getID())
			{
			case KeyEvent.KEY_TYPED:
				char ch = evt.getKeyChar();
				if(!nonDigit && Character.isDigit(ch))
				{
					super.processKeyEvent(evt);
					repeat = true;
					repeatCount = Integer.parseInt(action.getText());
				}
				else
				{
					nonDigit = true;
					if(repeat)
					{
						passToView(evt);
					}
					else
						super.processKeyEvent(evt);
				}
				break;
			case KeyEvent.KEY_PRESSED:
				int keyCode = evt.getKeyCode();
				if(evt.isActionKey()
					|| evt.isControlDown()
					|| evt.isAltDown()
					|| evt.isMetaDown()
					|| keyCode == KeyEvent.VK_BACK_SPACE
					|| keyCode == KeyEvent.VK_DELETE
					|| keyCode == KeyEvent.VK_ENTER
					|| keyCode == KeyEvent.VK_TAB
					|| keyCode == KeyEvent.VK_ESCAPE)
				{
					nonDigit = true;
					if(repeat)
					{
						passToView(evt);
						break;
					}
					else if(keyCode == KeyEvent.VK_TAB)
					{
						complete(true);
						evt.consume();
					}
					else if(keyCode == KeyEvent.VK_ESCAPE)
					{
						evt.consume();
						if(popup != null)
						{
							popup.dispose();
							popup = null;
							action.requestFocus();
						}
						else
						{
							if(temp)
								view.removeToolBar(ActionBar.this);
							view.getEditPane().focusOnTextArea();
						}
						break;
					}
					else if((keyCode == KeyEvent.VK_UP
						|| keyCode == KeyEvent.VK_DOWN)
						&& popup != null)
					{
						popup.list.processKeyEvent(evt);
						break;
					}
				}
				super.processKeyEvent(evt);
				break;
			}
		}

		private void passToView(final KeyEvent evt)
		{
			if(temp)
				view.removeToolBar(ActionBar.this);
			view.getTextArea().requestFocus();
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					view.getTextArea().requestFocus();
					view.getInputHandler().setRepeatCount(repeatCount);
					view.getInputHandler().processKeyEvent(evt,
						View.ACTION_BAR, false);
				}
			});
		}

		@Override
		public void addNotify()
		{
			super.addNotify();
			repeat = nonDigit = false;
		}
	} 

	
	private class CompletionPopup extends JWindow
	{
		CompletionList list;

		
		CompletionPopup(String[] actions)
		{
			super(view);

			setContentPane(new JPanel(new BorderLayout())
			{
				
				@Override
				public boolean isManagingFocus()
				{
					return false;
				}

				
				@Override
				public boolean getFocusTraversalKeysEnabled()
				{
					return false;
				}
			});

			list = new CompletionList(actions);
			list.setVisibleRowCount(8);
			list.addMouseListener(new MouseHandler());
			list.setSelectedIndex(0);
			list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

			
			
			JScrollPane scroller = new JScrollPane(list,
				ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

			getContentPane().add(scroller, BorderLayout.CENTER);

			GUIUtilities.requestFocus(this,list);

			pack();
			Point p = new Point(0,-getHeight());
			SwingUtilities.convertPointToScreen(p,action);
			setLocation(p);
			setVisible(true);

			KeyHandler keyHandler = new KeyHandler();
			addKeyListener(keyHandler);
			list.addKeyListener(keyHandler);
		} 

		
		void setModel(String[] actions)
		{
			list.setListData(actions);
			list.setSelectedIndex(0);
		} 

		
		private class MouseHandler extends MouseAdapter
		{
			@Override
			public void mouseClicked(MouseEvent evt)
			{
				invoke();
			}
		} 

		
		class CompletionList extends JList
		{
			CompletionList(Object[] data)
			{
				super(data);
			}

			
			@Override
			public void processKeyEvent(KeyEvent evt)
			{
				super.processKeyEvent(evt);
			}
		} 

		
		private class KeyHandler extends KeyAdapter
		{
			@Override
			public void keyTyped(KeyEvent evt)
			{
				action.processKeyEvent(evt);
			}

			@Override
			public void keyPressed(KeyEvent evt)
			{
				int keyCode = evt.getKeyCode();
				if(keyCode == KeyEvent.VK_ESCAPE)
					action.processKeyEvent(evt);
				else if(keyCode == KeyEvent.VK_ENTER)
					invoke();
				else if(keyCode == KeyEvent.VK_UP)
				{
					int selected = list.getSelectedIndex();
					if(selected == 0)
					{
						list.setSelectedIndex(
							list.getModel().getSize()
							- 1);
						evt.consume();
					}
				}
				else if(keyCode == KeyEvent.VK_DOWN)
				{
					int selected = list.getSelectedIndex();
					if(selected == list.getModel().getSize() - 1)
					{
						list.setSelectedIndex(0);
						evt.consume();
					}
				}
			}
		} 
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.VFSBrowser,68,5,0,75,291,1812,39,59,42,0.937619594,2351,0.666666667,7,0.909470752,0.113662457,4,15,33.0,21,2.5441,0,"

package org.gjt.sp.jedit.browser;


import org.gjt.sp.jedit.bsh.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import java.util.List;

import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.menu.MenuItemTextComparator;



public class VFSBrowser extends JPanel implements EBComponent,
	DefaultFocusComponent, DockableWindow
{
	public static final String NAME = ""vfs.browser"";

	
	
	public static final int OPEN_DIALOG = 0;

	
	public static final int SAVE_DIALOG = 1;
	
	public static final int BROWSER_DIALOG = 4;
	
	public static final int CHOOSE_DIRECTORY_DIALOG = 3;

	
	public static final int BROWSER = 2;
	

	
	
	public static void browseDirectoryInNewWindow(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		if(path != null)
		{
			
			jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
		}
		wm.floatDockableWindow(""vfs.browser"");
		jEdit.unsetProperty(""vfs.browser.path.tmp"");
	} 

	
	
	public static void browseDirectory(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		VFSBrowser browser = (VFSBrowser)wm.getDockable(NAME);
		if(browser != null)
		{
			wm.showDockableWindow(NAME);
			browser.setDirectory(path);
		}
		else
		{
			if(path != null)
			{
				
				jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
			}
			wm.addDockableWindow(""vfs.browser"");
			jEdit.unsetProperty(""vfs.browser.path.tmp"");
		}
	} 

	
	
	public static ActionContext getActionContext()
	{
		return actionContext;
	} 

	
	
	public VFSBrowser(View view, String position)
	{
		this(view,null,BROWSER,true,position);
	} 

	
	
	public VFSBrowser(View view, String path, int mode,
		boolean multipleSelection, String position)
	{
		super(new BorderLayout());

		listenerList = new EventListenerList();

		this.mode = mode;
		this.multipleSelection = multipleSelection;
		this.view = view;

		DockableWindowManager dwm = view.getDockableWindowManager();
		KeyListener keyListener = dwm.closeListener(NAME);
		addKeyListener(keyListener);
		
		currentEncoding = jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding""));
		autoDetectEncoding = jEdit.getBooleanProperty(
			""buffer.encodingAutodetect"");

		ActionHandler actionHandler = new ActionHandler();

		topBox = new Box(BoxLayout.Y_AXIS);
		horizontalLayout = (mode != BROWSER
			|| DockableWindowManager.TOP.equals(position)
			|| DockableWindowManager.BOTTOM.equals(position));

		toolbarBox = new Box(horizontalLayout
			? BoxLayout.X_AXIS
			: BoxLayout.Y_AXIS);

		topBox.add(toolbarBox);

		GridBagLayout layout = new GridBagLayout();
		pathAndFilterPanel = new JPanel(layout);
		if(isHorizontalLayout())
			pathAndFilterPanel.setBorder(new EmptyBorder(12,12,12,12));

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.EAST;
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.path""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		pathAndFilterPanel.add(label);

		pathField = new HistoryTextField(""vfs.browser.path"");
		pathField.setName(""path"");
		pathField.addKeyListener(keyListener);
		pathField.setInstantPopups(true);
		pathField.setEnterAddsToHistory(false);
		pathField.setSelectAllOnFocus(true);
		
		if (mode == BROWSER)
		{
			pathField.addKeyListener(new KeyAdapter()
			{
				public void keyReleased(KeyEvent e)
				{
					if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
					{
						pathField.setText(VFSBrowser.this.path);
					}
				}
			});
		}

		
		
		
		Dimension prefSize = pathField.getPreferredSize();
		prefSize.width = 0;
		pathField.setPreferredSize(prefSize);
		pathField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0;
		cons.gridwidth = GridBagConstraints.REMAINDER;

		layout.setConstraints(pathField,cons);
		pathAndFilterPanel.add(pathField);

		filterCheckbox = new JCheckBox(jEdit.getProperty(""vfs.browser.filter""));
		filterCheckbox.setMargin(new Insets(0,0,0,0));

		filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));
		filterCheckbox.setSelected(jEdit.getBooleanProperty(
			""vfs.browser.filter-enabled""));

		filterCheckbox.addActionListener(actionHandler);
		filterCheckbox.addKeyListener(keyListener);
		filterCheckbox.setName(""filter-checkbox"");
		if(mode != CHOOSE_DIRECTORY_DIALOG)
		{
			cons.gridwidth = 1;
			cons.gridx = 0;
			cons.weightx = 0.0;
			cons.gridy = 1;
			layout.setConstraints(filterCheckbox,cons);
			pathAndFilterPanel.add(filterCheckbox);
		}

		filterField = new JComboBox();
		filterEditor = new HistoryComboBoxEditor(""vfs.browser.filter"");
		filterEditor.setToolTipText(jEdit.getProperty(""glob.tooltip""));
		filterEditor.setInstantPopups(true);
		filterEditor.setSelectAllOnFocus(true);
		filterEditor.addActionListener(actionHandler);
		filterEditor.addKeyListener(keyListener);
		filterField.setName(""filter-field"");
		String filter;
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			filter = jEdit.getProperty(""vfs.browser.last-filter"");
			if(filter == null)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
		}
		else
		{
			String ext = MiscUtilities.getFileExtension(
				view.getBuffer().getName());
			if(ext.length() == 0)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
			else
				filter = '*' + ext;
		}

		
		
		filterEditor.setItem(new GlobVFSFileFilter(filter));
		filterField.addItem(filterEditor.getItem());
		filterField.addItemListener(actionHandler);
		filterField.setRenderer(new VFSFileFilterRenderer());

		
		String[] _filters = ServiceManager.getServiceNames(VFSFileFilter.SERVICE_NAME);
		for (int i = 0; i < _filters.length; i++)
		{
			VFSFileFilter _filter = (VFSFileFilter)
				ServiceManager.getService(VFSFileFilter.SERVICE_NAME, _filters[i]);
			filterField.addItem(_filter);
		}

		if(mode != CHOOSE_DIRECTORY_DIALOG)
		{
			cons.gridwidth = GridBagConstraints.REMAINDER;
			cons.fill = GridBagConstraints.HORIZONTAL;
			cons.gridx = 1;
			cons.weightx = 1.0;
			if (filterField.getItemCount() > 1)
			{
				filterField.setEditor(filterEditor);
				filterField.setEditable(true);
				layout.setConstraints(filterField,cons);
				pathAndFilterPanel.add(filterField);
			}
			else
			{
				layout.setConstraints(filterEditor,cons);
				pathAndFilterPanel.add(filterEditor);
			}
		}

		topBox.add(pathAndFilterPanel);
		add(BorderLayout.NORTH,topBox);

		add(BorderLayout.CENTER,browserView = new BrowserView(this));
		if(isHorizontalLayout())
			browserView.setBorder(new EmptyBorder(0,12,0,12));
		defaultFocusComponent = browserView.getTable();
		propertiesChanged();

		updateFilterEnabled();

		setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		
		if(path == null)
			path = jEdit.getProperty(""vfs.browser.path.tmp"");

		if(path == null || path.length() == 0)
		{
			String userHome = System.getProperty(""user.home"");
			String defaultPath = jEdit.getProperty(""vfs.browser.defaultPath"");
			if(""home"".equals(defaultPath))
				path = userHome;
			else if(""working"".equals(defaultPath))
				path = System.getProperty(""user.dir"");
			else if(""buffer"".equals(defaultPath))
			{
				Buffer buffer = view.getBuffer();
				path = buffer.getDirectory();
			}
			else if(""last"".equals(defaultPath))
			{
				HistoryModel pathModel = HistoryModel.getModel(""vfs.browser.path"");
				if(pathModel.getSize() == 0)
					path = ""~"";
				else
					path = pathModel.getItem(0);
			}
			else if(""favorites"".equals(defaultPath))
				path = ""favorites:"";
			else
			{
				
				path = userHome;
			}
		}

		final String _path = path;

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				setDirectory(_path);
			}
		});
	} 

	
	public void focusOnDefaultComponent()
	{
		
		defaultFocusComponent.requestFocus();
	} 

	
	
	void setDefaultFocusComponent(JComponent c) 
	{
		defaultFocusComponent = c;
	}
	
	
	@Override
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} 

	
	@Override
	public void removeNotify()
	{
		super.removeNotify();
		jEdit.setBooleanProperty(""vfs.browser.filter-enabled"",
			filterCheckbox.isSelected());
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			VFSFileFilter selectedFilter =
				(VFSFileFilter) filterField.getSelectedItem();
			if (selectedFilter instanceof GlobVFSFileFilter)
				jEdit.setProperty(""vfs.browser.last-filter"",
					((GlobVFSFileFilter)selectedFilter).getGlob());
		}
		EditBus.removeFromBus(this);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			if(bmsg.getWhat() == BufferUpdate.CREATED
				|| bmsg.getWhat() == BufferUpdate.CLOSED)
				browserView.updateFileView();
		}
		else if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if((pmsg.getWhat() == PluginUpdate.LOADED ||
			   pmsg.getWhat() == PluginUpdate.UNLOADED) &&
				plugins != null )
			{
				plugins.updatePopupMenu();
			}
		}
		else if(msg instanceof VFSUpdate)
		{
			maybeReloadDirectory(((VFSUpdate)msg).getPath());
		}
	} 

	
	public View getView()
	{
		return view;
	} 

	
	public int getMode()
	{
		return mode;
	} 

	
	public boolean isMultipleSelectionEnabled()
	{
		return multipleSelection;
	} 

	
	public boolean isHorizontalLayout()
	{
		return horizontalLayout;
	} 

	
	public boolean getShowHiddenFiles()
	{
		return showHiddenFiles;
	} 

	
	public void setShowHiddenFiles(boolean showHiddenFiles)
	{
		this.showHiddenFiles = showHiddenFiles;
	} 

	
	
	@Deprecated
	public String getFilenameFilter()
	{
		if(filterCheckbox.isSelected())
		{
			String filter = filterField.getSelectedItem().toString();
			if(filter.length() == 0)
				return ""*"";
			else
				return filter;
		}
		else
			return ""*"";
	} 

	
	
	public VFSFileFilter getVFSFileFilter()
	{
		if (mode == CHOOSE_DIRECTORY_DIALOG)
			return new DirectoriesOnlyFilter();
		return 	(VFSFileFilter) filterField.getSelectedItem();
	} 

	
	
	public void addVFSFileFilter(VFSFileFilter filter)
	{
		filterField.addItem(filter);
		if (filterField.getItemCount() == 2)
		{
			filterField.setEditor(filterEditor);
			filterField.setEditable(true);

			GridBagLayout layout = (GridBagLayout) pathAndFilterPanel.getLayout();
			GridBagConstraints cons =layout.getConstraints(filterEditor);
			cons.gridwidth = GridBagConstraints.REMAINDER;
			cons.fill = GridBagConstraints.HORIZONTAL;
			cons.gridx = 1;
			cons.weightx = 1;

			pathAndFilterPanel.remove(filterEditor);
			layout.setConstraints(filterField, cons);
			pathAndFilterPanel.add(filterField);
			pathAndFilterPanel.validate();
			pathAndFilterPanel.repaint();
		}
	} 

	
	public void setFilenameFilter(String filter)
	{
		if(filter == null || filter.length() == 0 || ""*"".equals(filter))
			filterCheckbox.setSelected(false);
		else
		{
			filterCheckbox.setSelected(true);
			filterEditor.setItem(new GlobVFSFileFilter(filter));
		}
	} 

	
	public HistoryTextField getDirectoryField()
	{
		return pathField;
	} 

	
	public String getDirectory()
	{
		return path;
	} 

	
	
	public void previousDirectory() 
	{
		if (historyStack.size() > 1)
		{
			historyStack.pop();
			nextDirectoryStack.push(path);
			setDirectory(historyStack.peek());
			historyStack.pop();
		}
	}
	
	
	
	public void nextDirectory() 
	{
		if (!nextDirectoryStack.isEmpty())
		{
			setDirectory(nextDirectoryStack.pop());
		}
	}
	
	
	
	public void setDirectory(String path)
	{
		if(path.startsWith(""file:""))
			path = path.substring(5);
		path = MiscUtilities.expandVariables(path);
		pathField.setText(path);

		if(!startRequest())
			return;

		historyStack.push(path);
		browserView.saveExpansionState();
		browserView.loadDirectory(null,path,true);
		this.path = path;

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} 

	
	public static String getRootDirectory()
	{
		if(OperatingSystem.isMacOS() || OperatingSystem.isDOSDerived())
			return FileRootsVFS.PROTOCOL + ':';
		else
			return ""/"";
	} 

	
	
	public void rootDirectory()
	{
		setDirectory(getRootDirectory());
	} 

	
	public void reloadDirectory()
	{
		
		VFSManager.getVFSForPath(path).reloadDirectory(path);

		browserView.saveExpansionState();
		browserView.loadDirectory(null,path,false);
	} 

	
	
	public void delete(VFSFile[] files)
	{
		String dialogType;

		if(MiscUtilities.isURL(files[0].getDeletePath())
			&& FavoritesVFS.PROTOCOL.equals(
			MiscUtilities.getProtocolOfURL(files[0].getDeletePath())))
		{
			dialogType = ""vfs.browser.delete-favorites"";
		}
		else
		{
			dialogType = ""vfs.browser.delete-confirm"";
		}

		StringBuilder buf = new StringBuilder();
		String typeStr = ""files"";
		for(int i = 0; i < files.length; i++)
		{
			buf.append(files[i].getPath());
			buf.append('\n');
			if (files[i].getType() == VFSFile.DIRECTORY)
				typeStr = ""directories and their contents"";
		}

		Object[] args = { buf.toString(), typeStr};
		
		int result = GUIUtilities.confirm(this,dialogType,args,
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE);
		if(result != JOptionPane.YES_OPTION)
			return;

		VFS vfs = VFSManager.getVFSForPath(files[0].getDeletePath());

		if(!startRequest())
			return;

		for(int i = 0; i < files.length; i++)
		{
			Object session = vfs.createVFSSession(files[i].getDeletePath(),this);
			if(session == null)
				continue;

			VFSManager.runInWorkThread(new BrowserIORequest(
				BrowserIORequest.DELETE,this,
				session,vfs,files[i].getDeletePath(),
				null,null));
		}

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} 

	
	public void rename(String from)
	{
		VFS vfs = VFSManager.getVFSForPath(from);

		String filename = vfs.getFileName(from);
		String[] args = { filename };
		String to = GUIUtilities.input(this,""vfs.browser.rename"",
			args,filename);
		if(to == null)
			return;

		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);

		Object session = vfs.createVFSSession(from,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.RENAME,this,
			session,vfs,from,to,null));

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} 

	
	public void rename(String from, String newname)
	{
		VFS vfs = VFSManager.getVFSForPath(from);

		String filename = vfs.getFileName(from);
		String[] args = { filename };
		String to = newname;
		
		if(to == null || filename.equals(newname))
			return;

		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);

		Object session = vfs.createVFSSession(from,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.RENAME,this,
			session,vfs,from,to,null));

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} 

	
	public void mkdir()
	{
		String newDirectory = GUIUtilities.input(this,""vfs.browser.mkdir"",null);
		if(newDirectory == null)
			return;

		
		
		final VFSFile[] selected = getSelectedFiles();
		String parent;
		if(selected.length == 0)
			parent = path;
		else if(selected[0].getType() == VFSFile.FILE)
		{
			parent = selected[0].getPath();
			parent = VFSManager.getVFSForPath(parent)
				.getParentOfPath(parent);
		}
		else
			parent = selected[0].getPath();

		VFS vfs = VFSManager.getVFSForPath(parent);

		
		newDirectory = MiscUtilities.constructPath(parent,newDirectory);

		Object session = vfs.createVFSSession(newDirectory,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.MKDIR,this,
			session,vfs,newDirectory,null,null));

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
				if (selected.length != 0 && selected[0].getType() != VFSFile.FILE)
				{
					VFSDirectoryEntryTable directoryEntryTable = browserView.getTable();
					int selectedRow = directoryEntryTable.getSelectedRow();
					VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel) directoryEntryTable.getModel();
					VFSDirectoryEntryTableModel.Entry entry = model.files[selectedRow];
					if (!entry.expanded)
					{
						browserView.clearExpansionState();
						browserView.loadDirectory(entry,entry.dirEntry.getPath(),
							false);
					}
				}
			}
		});
	} 

	
	
	public void newFile()
	{
		VFSFile[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFSFile file = selected[0];
			if(file.getType() == VFSFile.DIRECTORY)
				jEdit.newFile(view,file.getPath());
			else
			{
				VFS vfs = VFSManager.getVFSForPath(file.getPath());
				jEdit.newFile(view,vfs.getParentOfPath(file.getPath()));
			}
		}
		else
			jEdit.newFile(view,path);
	} 

	
	
	public void fileProperties(VFSFile[] files)
	{
		new FilePropertiesDialog(view, this, files);
	} 
		
	
	
	public void searchInDirectory()
	{
		VFSFile[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFSFile file = selected[0];
			searchInDirectory(file.getPath(),file.getType() != VFSFile.FILE);
		}
		else
		{
			searchInDirectory(path,true);
		}
	} 

	
	
	public void searchInDirectory(String path, boolean directory)
	{
		String filter;
		VFSFileFilter vfsff = getVFSFileFilter();
		if (vfsff instanceof GlobVFSFileFilter)
			filter = ((GlobVFSFileFilter)vfsff).getGlob();
		else
			filter = ""*"";

		if (!directory)
		{
			String name = MiscUtilities.getFileName(path);
			String ext = MiscUtilities.getFileExtension(name);
			filter = (ext == null || ext.length() == 0
				? filter : '*' + ext);
			path = MiscUtilities.getParentOfPath(path);
		}

		SearchAndReplace.setSearchFileSet(new DirectoryListSet(
			path,filter,true));
		SearchDialog.showSearchDialog(view,null,SearchDialog.DIRECTORY);
	} 

	
	BrowserView getBrowserView()
	{
		return browserView;
	} 

	
	
	public VFSFile[] getSelectedFiles()
	{
		return browserView.getSelectedFiles();
	} 

	
	
	public void locateFile(final String path)
	{
		VFSFileFilter filter = getVFSFileFilter();
		if(!filter.accept(MiscUtilities.getFileName(path)))
			setFilenameFilter(null);

		setDirectory(MiscUtilities.getParentOfPath(path));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				browserView.getTable().selectFile(path);
			}
		});
	} 

	
	public JComponent createPluginsMenu(JComponent pluginMenu, boolean showManagerOptions)
	{
		ActionHandler actionHandler = new ActionHandler();
		if(showManagerOptions && getMode() == BROWSER)
		{
			pluginMenu.add(GUIUtilities.loadMenuItem(""plugin-manager"",false));
			pluginMenu.add(GUIUtilities.loadMenuItem(""plugin-options"",false));
			if (pluginMenu instanceof JMenu)
				((JMenu)pluginMenu).addSeparator();
			else if (pluginMenu instanceof JPopupMenu)
				((JPopupMenu)pluginMenu).addSeparator();

		}
		else
			;

		List<JMenuItem> vec = new ArrayList<JMenuItem>();

		
		Enumeration<VFS> e = VFSManager.getFilesystems();

		while(e.hasMoreElements())
		{
			VFS vfs = e.nextElement();
			if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)
				continue;

				JMenuItem menuItem = new JMenuItem(jEdit.getProperty(
						""vfs."" + vfs.getName() + "".label""));
				menuItem.setActionCommand(vfs.getName());
				menuItem.addActionListener(actionHandler);
				vec.add(menuItem);
		} 

		
		EditPlugin[] plugins = jEdit.getPlugins();
		for (int i = 0; i < plugins.length; i++)
		{
			JMenuItem menuItem = plugins[i].createBrowserMenuItems();
			if(menuItem != null)
				vec.add(menuItem);
		} 

		if (!vec.isEmpty())
		{
			Collections.sort(vec,new MenuItemTextComparator());
			for(int i = 0; i < vec.size(); i++)
				pluginMenu.add(vec.get(i));
		}
		else
		{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(
					""vfs.browser.plugins.no-plugins.label""));
			mi.setEnabled(false);
			pluginMenu.add(mi);
		}

		return pluginMenu;
	} 

	
	public void addBrowserListener(BrowserListener l)
	{
		listenerList.add(BrowserListener.class,l);
	} 

	
	public void removeBrowserListener(BrowserListener l)
	{
		listenerList.remove(BrowserListener.class,l);
	} 

	
	
	public static final int M_OPEN = 0;
	public static final int M_OPEN_NEW_VIEW = 1;
	public static final int M_OPEN_NEW_PLAIN_VIEW = 2;
	public static final int M_OPEN_NEW_SPLIT = 3;
	public static final int M_INSERT = 4;

	
	public void filesActivated(int mode, boolean canDoubleClickClose)
	{
		VFSFile[] selectedFiles = browserView.getSelectedFiles();

		Buffer buffer = null;

check_selected: for(int i = 0; i < selectedFiles.length; i++)
		{
			VFSFile file = selectedFiles[i];

			if(file.getType() == VFSFile.DIRECTORY
				|| file.getType() == VFSFile.FILESYSTEM)
			{
				if(mode == M_OPEN_NEW_VIEW && this.mode == BROWSER)
					browseDirectoryInNewWindow(view,file.getPath());
				else
					setDirectory(file.getPath());
			}
			else if(this.mode == BROWSER || this.mode == BROWSER_DIALOG)
			{
				if(mode == M_INSERT)
				{
					view.getBuffer().insertFile(view,
						file.getPath());
					continue check_selected;
				}

				Buffer _buffer = jEdit.getBuffer(file.getPath());
				if(_buffer == null)
				{
					Hashtable<String, Object> props = new Hashtable<String, Object>();
					props.put(JEditBuffer.ENCODING,currentEncoding);
					props.put(Buffer.ENCODING_AUTODETECT,
						  Boolean.valueOf(autoDetectEncoding));
					_buffer = jEdit.openFile(view, null,
						file.getPath(),false,props);
				}
				else if(doubleClickClose && canDoubleClickClose
					&& this.mode != BROWSER_DIALOG
					&& selectedFiles.length == 1)
				{
					
					
					EditPane[] editPanes = view.getEditPanes();
					for(int j = 0; j < editPanes.length; j++)
					{
						if(editPanes[j].getBuffer() == _buffer)
						{
							jEdit.closeBuffer(view,_buffer);
							return;
						}
					}
				}

				if(_buffer != null)
					buffer = _buffer;
			}
			else
			{
				
				
				
			}
		}

		if(buffer != null)
		{
			switch(mode)
			{
			case M_OPEN:
				view.setBuffer(buffer);
				break;
			case M_OPEN_NEW_VIEW:
				jEdit.newView(view,buffer,false);
				break;
			case M_OPEN_NEW_PLAIN_VIEW:
				jEdit.newView(view,buffer,true);
				break;
			case M_OPEN_NEW_SPLIT:
				view.splitHorizontally().setBuffer(buffer);
				break;
			}
		}

		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesActivated(this,selectedFiles);
			}
		}
	} 


	
	public void move(String newPosition)
	{
		boolean horz = (mode != BROWSER
				|| DockableWindowManager.TOP.equals(newPosition)
				|| DockableWindowManager.BOTTOM.equals(newPosition));
		if (horz == horizontalLayout)
			return;
		horizontalLayout = horz;
		topBox.remove(toolbarBox);
		toolbarBox = new Box(horizontalLayout
				? BoxLayout.X_AXIS
				: BoxLayout.Y_AXIS);
		topBox.add(toolbarBox, 0);
		propertiesChanged();
	} 
	
	
	String currentEncoding;
	boolean autoDetectEncoding;

	
	void directoryLoaded(Object node, Object[] loadInfo,
		boolean addToHistory)
	{
		VFSManager.runInAWTThread(new DirectoryLoadedAWTRequest(
			node,loadInfo,addToHistory));
	} 

	
	void filesSelected()
	{
		VFSFile[] selectedFiles = browserView.getSelectedFiles();

		if(mode == BROWSER)
		{
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFSFile file = selectedFiles[i];
				Buffer buffer = jEdit.getBuffer(file.getPath());
				if(buffer != null && view != null)
					view.setBuffer(buffer);
			}
		}

		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesSelected(this,selectedFiles);
			}
		}
	} 

	
	void endRequest()
	{
		requestRunning = false;
	} 

	

	

	private static final ActionContext actionContext;

	static
	{
		actionContext = new BrowserActionContext();

		ActionSet builtInActionSet = new ActionSet(null,null,null,
			jEdit.class.getResource(""browser.actions.xml""));
		builtInActionSet.setLabel(jEdit.getProperty(""action-set.browser""));
		builtInActionSet.load();
		actionContext.addActionSet(builtInActionSet);
	}

	
	private EventListenerList listenerList;
	private View view;
	private boolean horizontalLayout;
	private String path;
	private JPanel pathAndFilterPanel;
	private HistoryTextField pathField;
	private JComponent defaultFocusComponent;
	private JCheckBox filterCheckbox;
	private HistoryComboBoxEditor filterEditor;
	private JComboBox filterField;
	private Box toolbarBox;
	private Box topBox;
	private FavoritesMenuButton favorites;
	private PluginsMenuButton plugins;
	private BrowserView browserView;
	private int mode;
	private boolean multipleSelection;

	private boolean showHiddenFiles;
	private boolean sortMixFilesAndDirs;
	private boolean sortIgnoreCase;
	private boolean doubleClickClose;

	private boolean requestRunning;
	private boolean maybeReloadRequestRunning;
	
	private Stack<String> historyStack = new Stack<String>();
	private Stack<String> nextDirectoryStack = new Stack<String>();
	

	
	private Container createMenuBar()
	{
		JToolBar menuBar = new JToolBar();
		menuBar.setFloatable(false);

		menuBar.add(new CommandsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(plugins = new PluginsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(favorites = new FavoritesMenuButton());

		return menuBar;
	} 

	
	private Container createToolBar()
	{
		if(mode == BROWSER)
			return GUIUtilities.loadToolBar(actionContext,
				""vfs.browser.toolbar-browser"");
		else
			return GUIUtilities.loadToolBar(actionContext,
				""vfs.browser.toolbar-dialog"");
	} 

	
	private void propertiesChanged()
	{
		showHiddenFiles = jEdit.getBooleanProperty(""vfs.browser.showHiddenFiles"");
		sortMixFilesAndDirs = jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs"");
		sortIgnoreCase = jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"");
		doubleClickClose = jEdit.getBooleanProperty(""vfs.browser.doubleClickClose"");

		browserView.propertiesChanged();

		toolbarBox.removeAll();

		if(jEdit.getBooleanProperty(""vfs.browser.showToolbar""))
		{
			Container toolbar = createToolBar();
			if(horizontalLayout)
				toolbarBox.add(toolbar);
			else
			{
				toolbarBox.add(toolbar);
			}
		}

		if(jEdit.getBooleanProperty(""vfs.browser.showMenubar""))
		{
			Container menubar = createMenuBar();
			if(horizontalLayout)
			{
				toolbarBox.add(menubar,0);
			}
			else
			{
				menubar.add(Box.createGlue());
				toolbarBox.add(menubar);
			}
		}
		else
		{
			plugins = null;
			favorites = null;
		}

		revalidate();

		if(path != null)
			reloadDirectory();
	} 

	

	
	private boolean startRequest()
	{
		if(requestRunning)
		{
			
			Log.log(Log.DEBUG,this,new Throwable(""For debugging purposes""));

			GUIUtilities.error(this,""browser-multiple-io"",null);
			return false;
		}
		else
		{
			requestRunning = true;
			return true;
		}
	} 

	
	private void updateFilterEnabled()
	{
		filterField.setEnabled(filterCheckbox.isSelected());
		filterEditor.setEnabled(filterCheckbox.isSelected());
	} 

	
	private void maybeReloadDirectory(String dir)
	{
		if(MiscUtilities.isURL(dir)
			&& MiscUtilities.getProtocolOfURL(dir).equals(
			FavoritesVFS.PROTOCOL))
		{
			if(favorites != null)
				favorites.popup = null;
		}

		
		
		
		
		
		
		
		
		if(maybeReloadRequestRunning)
		{
			
			return;
		}

		
		
		
		
		if(path != null)
		{
			try
			{
				maybeReloadRequestRunning = true;

				browserView.maybeReloadDirectory(dir);
			}
			finally
			{
				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						maybeReloadRequestRunning = false;
					}
				});
			}
		}
	} 

	

	

	
	class ActionHandler implements ActionListener, ItemListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if (isProcessingEvent)
				return;

			Object source = evt.getSource();

			if (source == pathField
			    || source == filterCheckbox)
			{
				isProcessingEvent = true;
				resetLater();

				updateFilterEnabled();

				String p = pathField.getText();
				
				if(p != null)
					setDirectory(p);
				browserView.focusOnFileView();
			}

			else if (source == filterField.getEditor())
			{
				
				filterField.getEditor().setItem(
					filterField.getEditor().getItem());
			}

			
			
			else if (source == filterEditor)
			{
				
				filterEditor.setItem(
					filterEditor.getItem());
				filterField.setSelectedItem(
					filterEditor.getItem());
				
				
				itemStateChanged(new ItemEvent(filterField,
					ItemEvent.ITEM_STATE_CHANGED,
					filterEditor.getItem(),
					ItemEvent.SELECTED));
			}
		}

		public void itemStateChanged(ItemEvent e)
		{
			if (isProcessingEvent)
				return;

			if (e.getStateChange() != ItemEvent.SELECTED)
				return;

			isProcessingEvent = true;
			resetLater();

			filterField.setEditable(e.getItem() instanceof GlobVFSFileFilter);
			updateFilterEnabled();
			String path = pathField.getText();
			if(path != null)
				setDirectory(path);

			browserView.focusOnFileView();
		}

		
		private void resetLater()
		{
			SwingUtilities.invokeLater(
				new Runnable()
				{
					public void run()
					{
						isProcessingEvent = false;
					}
				}
			);
		}

		private boolean isProcessingEvent;

	} 

	
	class CommandsMenuButton extends RolloverButton
	{
		
		CommandsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.commands.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
			setHorizontalTextPosition(SwingConstants.LEADING);
			setName(""commands"");
			
			popup = new BrowserCommandsMenu(VFSBrowser.this,null);

			CommandsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			CommandsMenuButton.this.addMouseListener(new MouseHandler());

			if(OperatingSystem.isMacOSLF())
				CommandsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} 

		BrowserCommandsMenu popup;

		
		class MouseHandler extends MouseAdapter
		{
			@Override
			public void mousePressed(MouseEvent evt)
			{
				if(!popup.isVisible())
				{
					popup.update();

					GUIUtilities.showPopupMenu(
						popup,CommandsMenuButton.this,0,
						CommandsMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} 
	} 

	
	class PluginsMenuButton extends RolloverButton
	{
		
		PluginsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.plugins.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
			setHorizontalTextPosition(SwingConstants.LEADING);
			setName(""plugins"");
			
			PluginsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			PluginsMenuButton.this.addMouseListener(new MouseHandler());

			if(OperatingSystem.isMacOSLF())
				PluginsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} 

		JPopupMenu popup;

		
		void updatePopupMenu()
		{
			popup = null;
		} 

		
		private void createPopupMenu()
		{
			if(popup != null)
				return;

			popup = (JPopupMenu)createPluginsMenu(new JPopupMenu(),true);
		} 

		
		class MouseHandler extends MouseAdapter
		{
			@Override
			public void mousePressed(MouseEvent evt)
			{
				createPopupMenu();

				if(!popup.isVisible())
				{
					GUIUtilities.showPopupMenu(
						popup,PluginsMenuButton.this,0,
						PluginsMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} 
	} 

	
	class FavoritesMenuButton extends RolloverButton
	{
		
		FavoritesMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.favorites.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
			setHorizontalTextPosition(SwingConstants.LEADING);
			setName(""favorites"");
			
			FavoritesMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			FavoritesMenuButton.this.addMouseListener(new MouseHandler());

			if(OperatingSystem.isMacOSLF())
				FavoritesMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} 

		JPopupMenu popup;

		
		void createPopupMenu()
		{
			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();

			JMenuItem mi = new JMenuItem(
				jEdit.getProperty(
				""vfs.browser.favorites""
				+ "".add-to-favorites.label""));
			mi.setActionCommand(""add-to-favorites"");
			mi.addActionListener(actionHandler);
			popup.add(mi);

			mi = new JMenuItem(
				jEdit.getProperty(
				""vfs.browser.favorites""
				+ "".edit-favorites.label""));
			mi.setActionCommand(""dir@favorites:"");
			mi.addActionListener(actionHandler);
			popup.add(mi);

			popup.addSeparator();

			VFSFile[] favorites = FavoritesVFS.getFavorites();
			if(favorites.length == 0)
			{
				mi = new JMenuItem(
					jEdit.getProperty(
					""vfs.browser.favorites""
					+ "".no-favorites.label""));
				mi.setEnabled(false);
				popup.add(mi);
			}
			else
			{
				Arrays.sort(favorites,
					new VFS.DirectoryEntryCompare(
					sortMixFilesAndDirs,
					sortIgnoreCase));
				for(int i = 0; i < favorites.length; i++)
				{
					VFSFile favorite = favorites[i];
					mi = new JMenuItem(favorite.getPath());
					mi.setIcon(FileCellRenderer
						.getIconForFile(
						favorite,false));
					String cmd = (favorite.getType() ==
						VFSFile.FILE
						? ""file@"" : ""dir@"")
						+ favorite.getPath();
					mi.setActionCommand(cmd);
					mi.addActionListener(actionHandler);
					popup.add(mi);
				}
			}
		} 

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				String actionCommand = evt.getActionCommand();
				if(""add-to-favorites"".equals(actionCommand))
				{
					
					
					VFSFile[] selected = getSelectedFiles();
					if(selected == null || selected.length == 0)
					{
						if(path.equals(FavoritesVFS.PROTOCOL + ':'))
						{
							GUIUtilities.error(VFSBrowser.this,
								""vfs.browser.recurse-favorites"",
								null);
						}
						else
						{
							FavoritesVFS.addToFavorites(path,
								VFSFile.DIRECTORY);
						}
					}
					else
					{
						for(int i = 0; i < selected.length; i++)
						{
							VFSFile file = selected[i];
							FavoritesVFS.addToFavorites(file.getPath(),
								file.getType());
						}
					}
				}
				else if(actionCommand.startsWith(""dir@""))
				{
					setDirectory(actionCommand.substring(4));
				}
				else if(actionCommand.startsWith(""file@""))
				{
					switch(getMode())
					{
					case BROWSER:
						jEdit.openFile(view,actionCommand.substring(5));
						break;
					default:
						locateFile(actionCommand.substring(5));
						break;
					}
				}
			}
		} 

		
		class MouseHandler extends MouseAdapter
		{
			@Override
			public void mousePressed(MouseEvent evt)
			{
				if(popup != null && popup.isVisible())
				{
					popup.setVisible(false);
					return;
				}

				if(popup == null)
					createPopupMenu();

				GUIUtilities.showPopupMenu(
					popup,FavoritesMenuButton.this,0,
					FavoritesMenuButton.this.getHeight(),
					false);
			}
		} 
	} 

	
	class DirectoryLoadedAWTRequest implements Runnable
	{
		private Object node;
		private Object[] loadInfo;
		private boolean addToHistory;

		DirectoryLoadedAWTRequest(Object node, Object[] loadInfo,
			boolean addToHistory)
		{
			this.node = node;
			this.loadInfo = loadInfo;
			this.addToHistory = addToHistory;
		}

		public void run()
		{
			String path = (String)loadInfo[0];
			if(path == null)
			{
				
				return;
			}

			VFSFile[] list = (VFSFile[])loadInfo[1];

			if(node == null)
			{
				
				VFSBrowser.this.path = path;
				if(!pathField.getText().equals(path))
					pathField.setText(path);
				if(path.endsWith(""/"") ||
					path.endsWith(File.separator))
				{
					
					
					
					path = path.substring(0,
						path.length() - 1);
				}

				if(addToHistory)
				{
					HistoryModel.getModel(""vfs.browser.path"")
						.addItem(path);
				}
			}

			boolean filterEnabled = filterCheckbox.isSelected();

			List<VFSFile> directoryList = new ArrayList<VFSFile>();

			int directories = 0;
			int files = 0;
			int invisible = 0;

			if(list != null)
			{
				VFSFileFilter filter = getVFSFileFilter();

				for(int i = 0; i < list.length; i++)
				{
					VFSFile file = list[i];
					if(file.isHidden() && !showHiddenFiles)
					{
						invisible++;
						continue;
					}

					if (filter != null && (filterEnabled || filter instanceof DirectoriesOnlyFilter)
					    && !filter.accept(file))
					{
						invisible++;
						continue;
					}

					if(file.getType() == VFSFile.FILE)
						files++;
					else
						directories++;

					directoryList.add(file);
				}

				Collections.sort(directoryList,
					new VFS.DirectoryEntryCompare(
					sortMixFilesAndDirs,
					sortIgnoreCase));
			}

			browserView.directoryLoaded(node,path,
				directoryList);

			
			

			
			
			

			
			
			
			if(mode == CHOOSE_DIRECTORY_DIALOG)
				filesSelected();
		}

		@Override
		public String toString()
		{
			return (String)loadInfo[0];
		}
	} 

	
	static class BrowserActionContext extends ActionContext
	{
		
		private static VFSFile[] getSelectedFiles(EventObject evt,
			VFSBrowser browser)
		{
			Component source = (Component)evt.getSource();

			if(GUIUtilities.getComponentParent(source, BrowserView.ParentDirectoryList.class)
				!= null)
			{
				Object[] selected = browser.getBrowserView()
					.getParentDirectoryList()
					.getSelectedValues();
				VFSFile[] returnValue = new VFSFile[
					selected.length];
				System.arraycopy(selected,0,returnValue,0,
					selected.length);
				return returnValue;
			}
			else
			{
				return browser.getSelectedFiles();
			}
		}

		@Override
		public void invokeAction(EventObject evt, EditAction action)
		{
			VFSBrowser browser = (VFSBrowser)
				GUIUtilities.getComponentParent(
				(Component)evt.getSource(),
				VFSBrowser.class);

			VFSFile[] files = getSelectedFiles(evt,browser);

			
			
			

			
			
			
			NameSpace global = BeanShell.getNameSpace();
			try
			{
				global.setVariable(""browser"",browser);
				global.setVariable(""files"",files);

				View view = browser.getView();
				
				
				
				
				
				
				
				if(view == null)
					view = jEdit.getActiveView();
				action.invoke(view);
			}
			catch(UtilEvalError err)
			{
				Log.log(Log.ERROR,this,err);
			}
			finally
			{
				try
				{
					global.setVariable(""browser"",null);
					global.setVariable(""files"",null);
				}
				catch(UtilEvalError err)
				{
					Log.log(Log.ERROR,this,err);
				}
			}
		}
	} 

	
	private static class HistoryComboBoxEditor
				extends HistoryTextField
				implements ComboBoxEditor
	{

		HistoryComboBoxEditor(String key)
		{
			super(key);
		}

		public Object getItem()
		{
			if (current == null)
			{
				current = new GlobVFSFileFilter(getText());
			}

			if (!current.getGlob().equals(getText()))
			{
				current.setGlob(getText());
			}

			return current;
		}

		public void setItem(Object item)
		{
			if (item == current)
			{
				
				
				
				
				
				if (item != null)
				{
					GlobVFSFileFilter filter = (GlobVFSFileFilter) item;
					current = new GlobVFSFileFilter(filter.getGlob());
					setText(current.getGlob());
				}
				return;
			}

			
			
			
			
			if (!(item instanceof GlobVFSFileFilter))
				return;

			if (item != null)
			{
				GlobVFSFileFilter filter = (GlobVFSFileFilter) item;
				filter = new GlobVFSFileFilter(filter.getGlob());
				setText(filter.getGlob());
				addCurrentToHistory();
				current = filter;
			}
			else
			{
				setText(""*"");
				current = new GlobVFSFileFilter(""*"");
			}
		}

		@Override
		protected void processFocusEvent(FocusEvent e)
		{
			
			
			
			if (e.getID() != FocusEvent.FOCUS_LOST)
				super.processFocusEvent(e);
			else 
			{
				setCaretPosition(0);
				getCaret().setVisible(false);
			}
		}

		public Component getEditorComponent()
		{
			return this;
		}

		private GlobVFSFileFilter current;

	} 

	
	private static class VFSFileFilterRenderer extends DefaultListCellRenderer
	{

		@Override
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			assert value instanceof VFSFileFilter : ""Filter is not a VFSFileFilter"";
			super.getListCellRendererComponent(
				list, value, index, isSelected, cellHasFocus);
			setText(((VFSFileFilter)value).getDescription());
			return this;
		}

	} 

	
	public static class DirectoriesOnlyFilter implements VFSFileFilter
	{

		public boolean accept(VFSFile file)
		{
			return file.getType() == VFSFile.DIRECTORY
				|| file.getType() == VFSFile.FILESYSTEM;
		}

		public boolean accept(String url)
		{
			return false;
		}

		public String getDescription()
		{
			return jEdit.getProperty(""vfs.browser.file_filter.dir_only"");
		}

	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.DockingOptionPane,10,6,0,6,58,17,2,6,3,0.922222222,269,0.8,1,0.986725664,0.45,4,12,24.9,1,0.9,0,"

package org.gjt.sp.jedit.options;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Vector;

import javax.swing.Box;
import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.util.StandardUtilities;



@SuppressWarnings(""serial"")
public class DockingOptionPane extends AbstractOptionPane
{
	
	public DockingOptionPane()
	{
		super(""docking"");
	} 

	
	public void _init()
	{
		setLayout(new BorderLayout());
		add(BorderLayout.NORTH,createDockingOptionsPanel());
		add(BorderLayout.CENTER,createWindowTableScroller());
		dockableSetSelection.setModel(
			new DefaultComboBoxModel(windowModel.getDockableSets()));
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(AUTO_LOAD_MODE_LAYOUT_PROP, autoLoadModeLayout.isSelected());
		jEdit.setBooleanProperty(AUTO_SAVE_MODE_LAYOUT_PROP, autoSaveModeLayout.isSelected());
		windowModel.save();
	} 

	

	
	private JTable windowTable;
	private WindowTableModel windowModel;
	private JCheckBox autoLoadModeLayout;
	private JCheckBox autoSaveModeLayout;
	private JComboBox dockableSetSelection;
	

	private static final String DOCKING_OPTIONS_PREFIX = ""options.docking."";
	public static final String AUTO_LOAD_MODE_LAYOUT_PROP = DOCKING_OPTIONS_PREFIX + ""autoLoadModeLayout"";
	private static final String AUTO_LOAD_MODE_LAYOUT_LABEL = AUTO_LOAD_MODE_LAYOUT_PROP + "".label"";
	public static final String AUTO_SAVE_MODE_LAYOUT_PROP = DOCKING_OPTIONS_PREFIX + ""autoSaveModeLayout"";
	private static final String AUTO_SAVE_MODE_LAYOUT_LABEL = AUTO_SAVE_MODE_LAYOUT_PROP + "".label"";
	
	private JPanel createDockingOptionsPanel()
	{
		JPanel p = new JPanel();
		p.setLayout(new GridLayout(0, 1));
		boolean autoLoadModeLayoutProp = jEdit.getBooleanProperty(
			AUTO_LOAD_MODE_LAYOUT_PROP, false);
		autoLoadModeLayout = new JCheckBox(
			jEdit.getProperty(AUTO_LOAD_MODE_LAYOUT_LABEL),
			autoLoadModeLayoutProp);
		p.add(autoLoadModeLayout);
		autoSaveModeLayout = new JCheckBox(
			jEdit.getProperty(AUTO_SAVE_MODE_LAYOUT_LABEL),
			jEdit.getBooleanProperty(AUTO_SAVE_MODE_LAYOUT_PROP, false));
		p.add(autoSaveModeLayout);
		autoSaveModeLayout.setEnabled(autoLoadModeLayoutProp);
		autoLoadModeLayout.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent e)
			{
				autoSaveModeLayout.setEnabled(autoLoadModeLayout.isSelected());
			}
		});
		Box vSetSelection = Box.createVerticalBox();
		p.add(vSetSelection);
		Box setSelection = Box.createHorizontalBox();
		vSetSelection.add(setSelection);
		setSelection.add(Box.createHorizontalStrut(6));
		setSelection.add(new JLabel(jEdit.getProperty(
			""options.docking.selectSet.label"")));
		setSelection.add(Box.createHorizontalStrut(6));
		dockableSetSelection = new JComboBox();
		setSelection.add(dockableSetSelection);
		dockableSetSelection.addItemListener(new ItemListener()
		{
			public void itemStateChanged(ItemEvent e)
			{
				windowModel.showSet((String) dockableSetSelection.getSelectedItem());
			}
		});
		setSelection.add(Box.createHorizontalStrut(6));
		vSetSelection.add(Box.createVerticalStrut(6));
		return p;
	}
	
	private JScrollPane createWindowTableScroller()
	{
		windowModel = createWindowModel();
		windowTable = new JTable(windowModel);
		windowTable.getTableHeader().setReorderingAllowed(false);
		windowTable.setColumnSelectionAllowed(false);
		windowTable.setRowSelectionAllowed(false);
		windowTable.setCellSelectionEnabled(false);

		DockPositionCellRenderer comboBox = new DockPositionCellRenderer();
		windowTable.setRowHeight(comboBox.getPreferredSize().height);
		TableColumn column = windowTable.getColumnModel().getColumn(1);
		column.setCellRenderer(comboBox);
		column.setCellEditor(new DefaultCellEditor(new DockPositionCellRenderer()));

		Dimension d = windowTable.getPreferredSize();
		d.height = Math.min(d.height,50);
		JScrollPane scroller = new JScrollPane(windowTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private static WindowTableModel createWindowModel()
	{
		return new WindowTableModel();
	} 

	

	
	static class DockPositionCellRenderer extends JComboBox
		implements TableCellRenderer
	{
		DockPositionCellRenderer()
		{
			super(new String[] {
				DockableWindowManager.FLOATING,
				DockableWindowManager.TOP,
				DockableWindowManager.LEFT,
				DockableWindowManager.BOTTOM,
				DockableWindowManager.RIGHT
			});
			DockPositionCellRenderer.this.setRequestFocusEnabled(false);
		}

		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus,
			int row, int column)
		{
			setSelectedItem(value);
			return this;
		}
	} 
} 


@SuppressWarnings(""serial"")
class WindowTableModel extends AbstractTableModel
{
	private static final String PLUGIN_SET_PREFIX = ""Plugin: "";
	private static final String CORE_DOCKABLE_SET = ""Core"";
	private static final String ALL_DOCKABLE_SET = ""All"";
	private HashMap<String, Vector<Entry>> dockableSets;
	private Vector<Entry> windows;

	
	WindowTableModel()
	{
		dockableSets = new HashMap<String, Vector<Entry>>();
		Vector<Entry> all = new Vector<Entry>();
		dockableSets.put(ALL_DOCKABLE_SET, all);
		windows = new Vector<Entry>();
		String[] dockables = DockableWindowManager.getRegisteredDockableWindows();
		for (String dockable: dockables)
		{
			String plugin = DockableWindowManager.
				getDockableWindowPluginName(dockable);
			String set;
			if (plugin != null)
				set = PLUGIN_SET_PREFIX + plugin;
			else
				set = CORE_DOCKABLE_SET; 
			Vector<Entry> currentSetDockables = dockableSets.get(set);
			if (currentSetDockables == null)
			{
				currentSetDockables = new Vector<Entry>();
				dockableSets.put(set, currentSetDockables);
			}
			Entry entry = new Entry(dockable);
			currentSetDockables.add(entry);
			all.add(entry);
		}
		showSet(ALL_DOCKABLE_SET);
	} 

	public Vector<String> getDockableSets()
	{
		Vector<String> sets = new Vector<String>();
		for (String set: dockableSets.keySet())
			sets.add(set);
		sets.remove(ALL_DOCKABLE_SET);
		sets.remove(CORE_DOCKABLE_SET);
		Collections.sort(sets);
		sets.insertElementAt(CORE_DOCKABLE_SET, 0);
		sets.insertElementAt(ALL_DOCKABLE_SET, 0);
		return sets;
	}

	
	public void showSet(String set)
	{
		windows = dockableSets.get(set);
		Collections.sort(windows,new WindowCompare());
		fireTableDataChanged();
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return windows.size();
	} 

	
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	} 

	
	public Object getValueAt(int row, int col)
	{
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 0:
			return window.title;
		case 1:
			return window.dockPosition;
		default:
			throw new InternalError();
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return col != 0;
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
			return;

		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 1:
			window.dockPosition = (String)value;
			break;
		default:
			throw new InternalError();
		}

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.docking.title"");
		case 1:
			return jEdit.getProperty(""options.docking.dockPosition"");
		default:
			throw new InternalError();
		}
	} 

	
	public void save()
	{
		for(int i = 0; i < windows.size(); i++)
		{
			((Entry)windows.elementAt(i)).save();
		}
	} 

	
	static class Entry
	{
		String name;
		String title;
		String dockPosition;

		Entry(String name)
		{
			this.name = name;
			title = jEdit.getProperty(name + "".title"");
			if(title == null)
				title = name;

			dockPosition = jEdit.getProperty(name + "".dock-position"");
			if(dockPosition == null)
				dockPosition = DockableWindowManager.FLOATING;
		}

		void save()
		{
			jEdit.setProperty(name + "".dock-position"",dockPosition);
		}
	} 

	
	static class WindowCompare implements Comparator<Object>
	{
		public int compare(Object obj1, Object obj2)
		{
			Entry e1 = (Entry)obj1;
			Entry e2 = (Entry)obj2;

			return StandardUtilities.compareStrings(
				e1.title,e2.title,true);
		}
	} 
} 
"
jEdit,4.3,org.gjt.sp.jedit.indent.RegexpIndentRule,5,1,0,7,20,0,1,6,4,0.6,132,1.0,3,0.0,0.4,0,0,24.4,11,2.8,0,"

package org.gjt.sp.jedit.indent;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import javax.swing.text.Segment;

import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.jedit.syntax.TokenHandler;
import org.gjt.sp.jedit.syntax.TokenMarker;


public class RegexpIndentRule implements IndentRule
{
	
	
	public RegexpIndentRule(String regexp, IndentAction prevPrev,
		IndentAction prev, IndentAction thisLine, boolean collapse)
	throws PatternSyntaxException
	{
		prevPrevAction = prevPrev;
		prevAction = prev;
		thisAction = thisLine;
		this.regexp = Pattern.compile(regexp, Pattern.CASE_INSENSITIVE );
		this.collapse = collapse;
	} 

	
	public void apply(JEditBuffer buffer, int thisLineIndex,
		int prevLineIndex, int prevPrevLineIndex,
		List<IndentAction> indentActions)
	{
		if(thisAction != null
			&& lineMatches(buffer, thisLineIndex))
		{
			indentActions.add(thisAction);
		}
		if(prevAction != null
			&& prevLineIndex != -1
			&& lineMatches(buffer, prevLineIndex))
		{
			indentActions.add(prevAction);
			if (collapse)
				indentActions.add(IndentAction.PrevCollapse);
		}
		if(prevPrevAction != null
			&& prevPrevLineIndex != -1
			&& lineMatches(buffer, prevPrevLineIndex))
		{
			indentActions.add(prevPrevAction);
			if (collapse)
				indentActions.add(IndentAction.PrevPrevCollapse);
		}
	} 

	
	
	@Deprecated
	public boolean isMatch(String line)
	{
		Matcher m = regexp.matcher(line);

		return m.matches();
	} 

	
	public String toString()
	{
		return getClass().getName() + '[' + regexp + ']';
	} 

	private IndentAction prevPrevAction, prevAction, thisAction;
	private Pattern regexp;
	private boolean collapse;

	
	
	private static class TokenFilter implements TokenHandler
	{
		public StringBuilder result;

		public TokenFilter(int originalLength)
		{
			result = new StringBuilder(originalLength);
		}

		public void handleToken(Segment seg
			, byte id, int offset, int length
			, TokenMarker.LineContext context)
		{
			
			
			if (length <= 0)
			{
				return;
			}
			
			switch (id)
			{
			case Token.COMMENT1:
			case Token.COMMENT2:
			case Token.COMMENT3:
			case Token.COMMENT4:
				
				
				result.append(' ');
				break;
			case Token.LITERAL1:
			case Token.LITERAL2:
			case Token.LITERAL3:
			case Token.LITERAL4:
				
				
				
				result.append('0');
				break;
			default:
				result.append(seg.array
					, seg.offset + offset
					, length);
				break;
			}
		}

		public void setLineContext(TokenMarker.LineContext lineContext)
		{
		}
	} 

	
	private boolean lineMatches(JEditBuffer buffer, int lineIndex)
	{
		TokenFilter filter
			= new TokenFilter(buffer.getLineLength(lineIndex));
		buffer.markTokens(lineIndex, filter);
		return regexp.matcher(filter.result).matches();
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.JARClassLoader,20,2,0,12,84,46,9,6,10,0.756578947,798,1.0,1,0.8,0.248120301,1,8,38.5,8,2.2,0,"

package org.gjt.sp.jedit;


import java.io.InputStream;
import java.io.IOException;
import java.net.URL;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.gjt.sp.util.Log;

import java.util.jar.Manifest;
import java.util.jar.JarFile;
import java.net.MalformedURLException;
import java.util.jar.Attributes;
import java.util.jar.Attributes.Name;



public class JARClassLoader extends ClassLoader
{
	
	
	public JARClassLoader()
	{
		this(true);
	}

	
	public JARClassLoader(boolean delegateFirst)
	{
		this.delegateFirst = delegateFirst;
		
		id = INDEX++;
		live++;
	} 

	
	
	public Class loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		ClassNotFoundException pending = null;
		if (delegateFirst)
		{
			try
			{
				return loadFromParent(clazz);
			}
			catch (ClassNotFoundException cnf)
			{
				
				pending = cnf;
			}
		}

		Object obj = classHash.get(clazz);
		if(obj == NO_CLASS)
		{
			
			
			
			throw new ClassNotFoundException(clazz);
		}
		else if(obj instanceof JARClassLoader)
		{
			JARClassLoader classLoader = (JARClassLoader)obj;
			try
			{
				return classLoader._loadClass(clazz,resolveIt);
			} catch (ClassNotFoundException cnf2)
			{
				classHash.put(clazz,NO_CLASS);
				throw cnf2;
			}
		}
		else if (delegateFirst)
		{
			
			
			
			throw pending;
		}

		return loadFromParent(clazz);
	} 

	
	public InputStream getResourceAsStream(String name)
	{
		try
		{
			
			if(jar != null)
			{
				ZipFile zipFile = jar.getZipFile();
				ZipEntry entry = zipFile.getEntry(name);
				if(entry != null)
				{
					return zipFile.getInputStream(entry);
				}
			}
			
			Object obj = resourcesHash.get(name);
			if(obj instanceof JARClassLoader)
			{
				JARClassLoader classLoader = (JARClassLoader)obj;
				return classLoader.getResourceAsStream(name);
			}
			
			return getSystemResourceAsStream(name);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);

			return null;
		}
	} 

	
	
	public URL getResource(String name)
	{
		try
		{
			if(jar != null)
			{
				ZipFile zipFile = jar.getZipFile();
				ZipEntry entry = zipFile.getEntry(name);
				if(entry != null)
				{
					return new URL(getResourceAsPath(name));
				}
			}
			
			Object obj = resourcesHash.get(name);
			if(obj instanceof JARClassLoader)
			{
				JARClassLoader classLoader = (JARClassLoader)obj;
				return classLoader.getResource(name);
			} else
			{
				URL ret = getSystemResource(name); 
				if(ret != null)
				{
					Log.log(Log.DEBUG,JARClassLoader.class,""Would have returned null for getResource(""+name+"")"");
					Log.log(Log.DEBUG,JARClassLoader.class,""returning(""+ret+"")"");
				}
				return ret;
			}
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			return null;
		}
	} 

	
	
	public String getResourceAsPath(String name)
	{
		
		if(jar == null)
			throw new UnsupportedOperationException(
				""don't call getResourceAsPath() on anonymous JARClassLoader"");

		if(!name.startsWith(""/""))
			name = '/' + name;

		return ""jeditresource:/"" + MiscUtilities.getFileName(
			jar.getPath()) + '!' + name;
	} 

	
	
	public ZipFile getZipFile()
	{
		try
		{
			return jar.getZipFile();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			return null;
		}
	} 

	
	
	public static void dump()
	{
		Log.log(Log.DEBUG,JARClassLoader.class,
			""Total instances created: "" + INDEX);
		Log.log(Log.DEBUG,JARClassLoader.class,
			""Live instances: "" + live);
		synchronized(classHash)
		{
			for (Map.Entry<String, Object> entry : classHash.entrySet())
			{
				if (entry.getValue() != NO_CLASS)
				{
					Log.log(Log.DEBUG, JARClassLoader.class,
						entry.getKey() + "" ==> ""
							+ entry.getValue());
				}
			}
		}
	} 

	
	public String toString()
	{
		if(jar == null)
			return ""<anonymous>("" + id + ')';
		else
			return jar.getPath() + "" ("" + id + ')';
	} 

	
	
	public Enumeration getResources(String name) throws IOException
	{
		class SingleElementEnumeration implements Enumeration
		{
			private Object element;

			SingleElementEnumeration(Object element)
			{
				this.element = element;
			}

			public boolean hasMoreElements()
			{
				return element != null;
			}

			public Object nextElement()
			{
				if(element != null)
				{
					Object retval = element;
					element = null;
					return retval;
				}
				else
					throw new NoSuchElementException();
			}
		}

		URL resource = getResource(name);
		return new SingleElementEnumeration(resource);
	} 

	
	protected void finalize()
	{
		live--;
	} 

	

	
	
	JARClassLoader(PluginJAR jar)
	{
		this();
		this.jar = jar;
	} 

	
	void activate()
	{
		if (jar.getPlugin() != null)
		{
			String _delegate = jEdit.getProperty(
				""plugin."" + jar.getPlugin().getClassName() + "".class_loader_delegate"");
			delegateFirst = _delegate == null || ""true"".equals(_delegate);
		}

		String[] classes = jar.getClasses();
		if(classes != null)
		{
			for(int i = 0; i < classes.length; i++)
			{
				classHash.put(classes[i],this);
			}
		}

		String[] resources = jar.getResources();
		if(resources != null)
		{
			for(int i = 0; i < resources.length; i++)
			{
				resourcesHash.put(resources[i],this);
			}
		}
	} 

	
	void deactivate()
	{
		String[] classes = jar.getClasses();
		if(classes != null)
		{
			for(int i = 0; i < classes.length; i++)
			{
				Object loader = classHash.get(classes[i]);
				if(loader == this)
					classHash.remove(classes[i]);
				else
					;
			}
		}

		String[] resources = jar.getResources();
		if(resources == null)
			return;

		for(int i = 0; i < resources.length; i++)
		{
			Object loader = resourcesHash.get(resources[i]);
			if(loader == this)
				resourcesHash.remove(resources[i]);
			else
				;
		}
	} 

	

	

	
	private static final Object NO_CLASS = new Object();

	private static int INDEX;
	private static int live;
	private static Map<String, Object> classHash = new Hashtable<String, Object>();
	private static Map<String, Object> resourcesHash = new HashMap<String, Object>();

	private int id;
	private boolean delegateFirst;
	private PluginJAR jar;

	
	
	private synchronized Class _loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		jar.activatePlugin();

		synchronized(this)
		{
			Class cls = findLoadedClass(clazz);
			if(cls != null)
			{
				if(resolveIt)
					resolveClass(cls);
				return cls;
			}

			String name = MiscUtilities.classToFile(clazz);

			try
			{
				definePackage(clazz);
				ZipFile zipFile = jar.getZipFile();
				ZipEntry entry = zipFile.getEntry(name);

				if(entry == null)
					throw new ClassNotFoundException(clazz);

				InputStream in = zipFile.getInputStream(entry);

				int len = (int)entry.getSize();
				byte[] data = new byte[len];
				int success = 0;
				int offset = 0;
				while(success < len)
				{
					len -= success;
					offset += success;
					success = in.read(data,offset,len);
					if(success == -1)
					{
						Log.log(Log.ERROR,this,""Failed to load class ""
							+ clazz + "" from "" + zipFile.getName());
						throw new ClassNotFoundException(clazz);
					}
				}

				cls = defineClass(clazz,data,0,data.length);

				if(resolveIt)
					resolveClass(cls);

				return cls;
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);

				throw new ClassNotFoundException(clazz);
			}
		}
	} 

	
	private void definePackage(String clazz) throws IOException
	{
		int idx = clazz.lastIndexOf('.');
		if (idx != -1)
		{
			String name = clazz.substring(0, idx);
			if (getPackage(name) == null) definePackage(name, new JarFile(jar.getFile()).getManifest());
		}
	} 

	
	private static String getMfValue(Attributes sectionAttrs, Attributes mainAttrs, Attributes.Name name)
	{
		String value=null;
		if (sectionAttrs != null)
			value = sectionAttrs.getValue(name);
		else if (mainAttrs != null)
		{
			value = mainAttrs.getValue(name);
		}
		return value;
	}
	

	
	private void definePackage(String name, Manifest mf)
	{
		if (mf==null)
		{
			definePackage(name, null, null, null, null, null,
			null, null);
			return;
		}

		Attributes sa = mf.getAttributes(name.replace('.', '/') + '/');
		Attributes ma = mf.getMainAttributes();

		URL sealBase = null;
		if (Boolean.valueOf(getMfValue(sa, ma, Name.SEALED)).booleanValue())
		{
			try
			{
				sealBase = jar.getFile().toURL();
			}
			catch (MalformedURLException e) {}
		}

		Package pkg=definePackage(
			name,
			getMfValue(sa, ma, Name.SPECIFICATION_TITLE),
			getMfValue(sa, ma, Name.SPECIFICATION_VERSION),
			getMfValue(sa, ma, Name.SPECIFICATION_VENDOR),
			getMfValue(sa, ma, Name.IMPLEMENTATION_TITLE),
			getMfValue(sa, ma, Name.IMPLEMENTATION_VERSION),
			getMfValue(sa, ma, Name.IMPLEMENTATION_VENDOR),
			sealBase);
	} 

	
	private Class loadFromParent(String clazz)
		throws ClassNotFoundException
	{
		Class cls;

		ClassLoader parentLoader = getClass().getClassLoader();
		if (parentLoader != null)
			cls = parentLoader.loadClass(clazz);
		else
			cls = findSystemClass(clazz);

		return cls;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.EditingOptionPane,12,6,0,9,58,26,1,9,1,0.480519481,748,1.0,3,0.983823529,0.5,2,4,59.58333333,3,1.4167,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;

import java.awt.event.*;
import java.util.Arrays;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.util.StandardUtilities;



public class EditingOptionPane extends AbstractOptionPane
{
	
	public EditingOptionPane()
	{
		super(""editing"");
	} 

	
	@Override
	protected void _init()
	{
		Mode[] modes = jEdit.getModes();
		Arrays.sort(modes,new StandardUtilities.StringCompare<Mode>(true));

		global = new ModeProperties();
		modeProps = new ModeProperties[modes.length];

		String[] modeNames = new String[modes.length + 1];
		modeNames[0] = jEdit.getProperty(""options.editing.global"");

		for(int i = 0; i < modes.length; i++)
		{
			modeProps[i] = new ModeProperties(modes[i]);
			modeNames[i + 1] = modes[i].getName();
		}

		mode = new JComboBox(modeNames);
		mode.addActionListener(new ActionHandler());

		captionBox = new Box(BoxLayout.X_AXIS);
		addComponent(captionBox);

		addComponent(jEdit.getProperty(""options.editing.mode""),mode);

		useDefaults = new JCheckBox(jEdit.getProperty(""options.editing.useDefaults""));
		useDefaults.addActionListener(new ActionHandler());
		addComponent(useDefaults);

		addComponent(jEdit.getProperty(""options.editing.noWordSep""),
			noWordSep = new JTextField());

		addComponent(camelCasedWords = new JCheckBox(jEdit.getProperty(
			""options.editing.camelCasedWords"")));

		String[] foldModes = FoldHandler.getFoldModes();
		addComponent(jEdit.getProperty(""options.editing.folding""),
			folding = new JComboBox(foldModes));

		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),
			collapseFolds = new JTextField());

		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};
		addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap = new JComboBox(wrapModes));

		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		maxLineLen = new JComboBox(lineLens);
		maxLineLen.setToolTipText(jEdit.getProperty(""options.editing.maxLineLen.tooltip""));
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""), maxLineLen);
		maxLineLen.setEditable(true);

		String[] tabSizes = { ""2"", ""4"", ""8"" };
		addComponent(jEdit.getProperty(""options.editing.tabSize""),
			tabSize = new JComboBox(tabSizes));
		tabSize.setEditable(true);

		addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize = new JComboBox(tabSizes));
		indentSize.setEditable(true);

		addComponent(noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs"")));

		addComponent(deepIndent = new JCheckBox(jEdit.getProperty(
			""options.editing.deepIndent"")));

		filenameGlob = new JTextField();
		filenameGlob.setToolTipText(jEdit.getProperty(""glob.tooltip""));
		addComponent(jEdit.getProperty(""options.editing.filenameGlob""),
			filenameGlob);

		addComponent(jEdit.getProperty(""options.editing.firstlineGlob""),
			firstlineGlob = new JTextField());

		selectMode();

		addSeparator();

		defaultMode = new JComboBox(modes);
		defaultMode.setSelectedItem(jEdit.getMode(
			jEdit.getProperty(""buffer.defaultMode"")));
		addComponent(jEdit.getProperty(""options.editing.defaultMode""),
			defaultMode);

		undoCount = new JTextField(jEdit.getProperty(""buffer.undoCount""));
		addComponent(jEdit.getProperty(""options.editing.undoCount""),undoCount);

		
		resetUndoOnSave = new JCheckBox(jEdit.getProperty(""options.general.resetUndo""));
		resetUndoOnSave.setSelected(jEdit.getBooleanProperty(""resetUndoOnSave""));
		addComponent(resetUndoOnSave);
		

	} 

	
	@Override
	protected void _save()
	{
		jEdit.setProperty(""buffer.defaultMode"",
			((Mode)defaultMode.getSelectedItem()).getName());
		jEdit.setProperty(""buffer.undoCount"",undoCount.getText());
		jEdit.setBooleanProperty(""resetUndoOnSave"", resetUndoOnSave.isSelected());

		saveMode();

		global.save();

		for(int i = 0; i < modeProps.length; i++)
		{
			modeProps[i].save();
		}
	} 

	

	
	private JComboBox defaultMode;
	private JTextField undoCount;
	private JCheckBox resetUndoOnSave;
	private ModeProperties global;
	private ModeProperties[] modeProps;
	private ModeProperties current;
	private Box captionBox;
	private JComboBox mode;
	private JCheckBox useDefaults;
	private JTextField filenameGlob;
	private JTextField firstlineGlob;
	private JTextField noWordSep;
	private JCheckBox camelCasedWords;
	private JComboBox folding;
	private JTextField collapseFolds;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	private JCheckBox deepIndent;
	

	
	private void saveMode()
	{
		current.useDefaults = useDefaults.isSelected();
		current.filenameGlob = filenameGlob.getText();
		current.firstlineGlob = firstlineGlob.getText();
		current.noWordSep = noWordSep.getText();
		current.camelCasedWords = camelCasedWords.isSelected();
		current.folding = (String)folding.getSelectedItem();
		current.collapseFolds = collapseFolds.getText();
		current.wrap = (String)wrap.getSelectedItem();
		current.maxLineLen = (String)maxLineLen.getSelectedItem();
		current.tabSize = (String)tabSize.getSelectedItem();
		current.indentSize = (String)indentSize.getSelectedItem();
		current.noTabs = noTabs.isSelected();
		current.deepIndent = deepIndent.isSelected();
	} 

	
	private void selectMode()
	{
		int index = mode.getSelectedIndex();
		current = index == 0 ? global : modeProps[index - 1];
		current.edited = true;
		current.load();

		captionBox.removeAll();
		captionBox.add(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""options.editing.caption-""
			+ (index == 0 ? ""0"" : ""1""))));

		useDefaults.setSelected(current.useDefaults);
		filenameGlob.setText(current.filenameGlob);
		firstlineGlob.setText(current.firstlineGlob);
		noWordSep.setText(current.noWordSep);
		camelCasedWords.setSelected(current.camelCasedWords);
		folding.setSelectedItem(current.folding);
		collapseFolds.setText(current.collapseFolds);
		wrap.setSelectedItem(current.wrap);
		maxLineLen.setSelectedItem(current.maxLineLen);
		tabSize.setSelectedItem(current.tabSize);
		indentSize.setSelectedItem(current.indentSize);
		noTabs.setSelected(current.noTabs);
		deepIndent.setSelected(current.deepIndent);

		updateEnabled();
		revalidate();
	} 

	
	private void updateEnabled()
	{
		boolean enabled;
		if(current == global)
		{
			enabled = true;
			useDefaults.setEnabled(false);
			filenameGlob.setEnabled(false);
			firstlineGlob.setEnabled(false);
		}
		else
		{
			enabled = !modeProps[mode.getSelectedIndex() - 1]
				.useDefaults;
			useDefaults.setEnabled(true);
			filenameGlob.setEnabled(enabled);
			firstlineGlob.setEnabled(enabled);
		}

		noWordSep.setEnabled(enabled);
		camelCasedWords.setEnabled(enabled);
		folding.setEnabled(enabled);
		collapseFolds.setEnabled(enabled);
		wrap.setEnabled(enabled);
		maxLineLen.setEnabled(enabled);
		tabSize.setEnabled(enabled);
		indentSize.setEnabled(enabled);
		noTabs.setEnabled(enabled);
		deepIndent.setEnabled(enabled);
	} 

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == mode)
			{
				saveMode();
				selectMode();
			}
			else if(source == useDefaults)
			{
				modeProps[mode.getSelectedIndex() - 1].useDefaults =
					useDefaults.isSelected();
				updateEnabled();
			}
		}
	} 

	
	private static class ModeProperties
	{
		
		Mode mode;
		boolean edited;
		boolean loaded;

		boolean useDefaults;
		String filenameGlob;
		String firstlineGlob;
		String noWordSep;
		boolean camelCasedWords;
		String folding;
		String collapseFolds;
		String wrap;
		String maxLineLen;
		String tabSize;
		String indentSize;
		boolean noTabs;
		boolean deepIndent;
		

		
		ModeProperties()
		{
		} 

		
		ModeProperties(Mode mode)
		{
			this.mode = mode;
		} 

		
		void load()
		{
			if(loaded)
				return;

			loaded = true;

			if(mode != null)
			{
				mode.loadIfNecessary();

				useDefaults = !jEdit.getBooleanProperty(""mode.""
					+ mode.getName() + "".customSettings"");
				filenameGlob = (String)mode.getProperty(""filenameGlob"");
				firstlineGlob = (String)mode.getProperty(""firstlineGlob"");
				noWordSep = (String)mode.getProperty(""noWordSep"");
				camelCasedWords = mode.getBooleanProperty(""camelCasedWords"");
				folding = mode.getProperty(""folding"").toString();
				collapseFolds = mode.getProperty(""collapseFolds"").toString();
				wrap = mode.getProperty(""wrap"").toString();
				maxLineLen = mode.getProperty(""maxLineLen"").toString();
				tabSize = mode.getProperty(""tabSize"").toString();
				indentSize = mode.getProperty(""indentSize"").toString();
				noTabs = mode.getBooleanProperty(""noTabs"");
				deepIndent = mode.getBooleanProperty(""deepIndent"");
			}
			else
			{
				noWordSep = jEdit.getProperty(""buffer.noWordSep"");
				camelCasedWords = jEdit.getBooleanProperty(""buffer.camelCasedWords"");
				folding = jEdit.getProperty(""buffer.folding"");
				collapseFolds = jEdit.getProperty(""buffer.collapseFolds"");
				wrap = jEdit.getProperty(""buffer.wrap"");
				maxLineLen = jEdit.getProperty(""buffer.maxLineLen"");
				tabSize = jEdit.getProperty(""buffer.tabSize"");
				indentSize = jEdit.getProperty(""buffer.indentSize"");
				noTabs = jEdit.getBooleanProperty(""buffer.noTabs"");
				deepIndent = jEdit.getBooleanProperty(""buffer.deepIndent"");
			}
		} 

		
		void save()
		{
			
			
			if(!edited)
				return;

			String prefix;
			if(mode != null)
			{
				prefix = ""mode."" + mode.getName() + '.';
				jEdit.setBooleanProperty(prefix + ""customSettings"",!useDefaults);

				
				
				String oldFilenameGlob = (String)mode.getProperty(""filenameGlob"");
				String oldFirstlineGlob = (String)mode.getProperty(""firstlineGlob"");
				if(useDefaults)
				{
					jEdit.resetProperty(prefix + ""filenameGlob"");
					jEdit.resetProperty(prefix + ""firstlineGlob"");
					jEdit.resetProperty(prefix + ""noWordSep"");
					jEdit.resetProperty(prefix + ""camelCasedWords"");
					jEdit.resetProperty(prefix + ""folding"");
					jEdit.resetProperty(prefix + ""collapseFolds"");
					jEdit.resetProperty(prefix + ""wrap"");
					jEdit.resetProperty(prefix + ""maxLineLen"");
					jEdit.resetProperty(prefix + ""tabSize"");
					jEdit.resetProperty(prefix + ""indentSize"");
					jEdit.resetProperty(prefix + ""noTabs"");
					jEdit.resetProperty(prefix + ""deepIndent"");

					if(!(StandardUtilities.objectsEqual(oldFilenameGlob,
						mode.getProperty(""filenameGlob""))
						&& StandardUtilities.objectsEqual(oldFirstlineGlob,
						mode.getProperty(""firstlineGlob""))))
					{
						mode.init();
					}

					return;
				}
				else
				{
					jEdit.setProperty(prefix + ""filenameGlob"",filenameGlob);
					jEdit.setProperty(prefix + ""firstlineGlob"",firstlineGlob);

					if(!(StandardUtilities.objectsEqual(oldFilenameGlob,
						filenameGlob)
						&& StandardUtilities.objectsEqual(oldFirstlineGlob,
						firstlineGlob)))
					{
						mode.init();
					}
				}
			}
			else
			{
				prefix = ""buffer."";
			}

			jEdit.setProperty(prefix + ""noWordSep"",noWordSep);
			jEdit.setBooleanProperty(prefix + ""camelCasedWords"",camelCasedWords);
			jEdit.setProperty(prefix + ""folding"",folding);
			jEdit.setProperty(prefix + ""collapseFolds"",collapseFolds);
			jEdit.setProperty(prefix + ""wrap"",wrap);
			jEdit.setProperty(prefix + ""maxLineLen"",maxLineLen);
			jEdit.setProperty(prefix + ""tabSize"",tabSize);
			jEdit.setProperty(prefix + ""indentSize"",indentSize);
			jEdit.setBooleanProperty(prefix + ""noTabs"",noTabs);
			jEdit.setBooleanProperty(prefix + ""deepIndent"",deepIndent);
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.GrabKeyDialog,22,6,0,10,75,195,4,9,8,0.823809524,532,1.0,3,0.970193741,0.161157025,3,8,22.72727273,7,1.9091,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.lang.reflect.Field;
import java.util.List;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.util.Log;



public class GrabKeyDialog extends JDialog
{
	
	
	@Deprecated
	public static String toString(KeyEvent evt)
	{
		return AbstractInputHandler.toString(evt);
	} 

	
	
	public GrabKeyDialog(Dialog parent, KeyBinding binding,
		List<KeyBinding> allBindings, Buffer debugBuffer)
	{
		super(parent,jEdit.getProperty(""grab-key.title""),true);

		init(binding,allBindings,debugBuffer);
	} 

	
	
	public GrabKeyDialog(Frame parent, KeyBinding binding,
		List<KeyBinding> allBindings, Buffer debugBuffer)
	{
		super(parent,jEdit.getProperty(""grab-key.title""),true);

		init(binding,allBindings,debugBuffer);
	} 

	
	
	public String getShortcut()
	{
		if(isOK)
			return shortcut.getText();
		else
			return null;
	} 

	
	
	public boolean isOK()
	{
		return isOK;
	} 

	
	
	public boolean isManagingFocus()
	{
		return false;
	} 

	
	
	@Override
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	
	@Override
	protected void processKeyEvent(KeyEvent evt)
	{
		shortcut.processKeyEvent(evt);
	} 

	

	
	private InputPane shortcut; 
	private JLabel assignedTo;
	private JButton ok;
	private JButton remove;
	private JButton cancel;
	private JButton clear;
	private boolean isOK;
	private KeyBinding binding;
	private List<KeyBinding> allBindings;
	private Buffer debugBuffer;
	

	
	private void init(KeyBinding binding, List<KeyBinding> allBindings, Buffer debugBuffer)
	{
		this.binding = binding;
		this.allBindings = allBindings;
		this.debugBuffer = debugBuffer;

		enableEvents(AWTEvent.KEY_EVENT_MASK);

		
		
		JPanel content = new JPanel(new GridLayout(0,1,0,6))
		{
			
			@Override
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		};
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(
			debugBuffer == null ? jEdit.getProperty(
			""grab-key.caption"",new String[] { binding.label })
			: jEdit.getProperty(""grab-key.keyboard-test""));

		Box input = Box.createHorizontalBox();

		shortcut = new InputPane();
		Dimension size = shortcut.getPreferredSize();
		size.width = Integer.MAX_VALUE;
		shortcut.setMaximumSize(size);
		input.add(shortcut);
		input.add(Box.createHorizontalStrut(12));

		clear = new JButton(jEdit.getProperty(""grab-key.clear""));
		clear.addActionListener(new ActionHandler());
		input.add(clear);

		assignedTo = new JLabel();
		if(debugBuffer == null)
			updateAssignedTo(null);

		Box buttons = Box.createHorizontalBox();
		buttons.add(Box.createGlue());

		if(debugBuffer == null)
		{
			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(new ActionHandler());
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(12));

			if(binding.isAssigned())
			{
				
				remove = new JButton(jEdit.getProperty(""grab-key.remove""));
				remove.addActionListener(new ActionHandler());
				buttons.add(remove);
				buttons.add(Box.createHorizontalStrut(12));
			}
		}

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());

		content.add(label);
		content.add(input);
		if(debugBuffer == null)
			content.add(assignedTo);
		content.add(buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		pack();
		setLocationRelativeTo(getParent());
		setResizable(false);
		setVisible(true);
	} 

	
	public static String getSymbolicName(int keyCode)
	{
		if (Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,GrabKeyDialog.class,""getSymbolicName(""+keyCode+"")."");
		}

		if(keyCode == KeyEvent.VK_UNDEFINED)
			return null;
		

		if(keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
			return String.valueOf(Character.toLowerCase((char)keyCode));

		try
		{
			Field[] fields = KeyEvent.class.getFields();
			for(int i = 0; i < fields.length; i++)
			{
				Field field = fields[i];
				String name = field.getName();
				if(name.startsWith(""VK_"")
					&& field.getInt(null) == keyCode)
				{
					return name.substring(3);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,GrabKeyDialog.class,e);
		}

		return null;
	} 

	
	private void updateAssignedTo(String shortcut)
	{
		String text = jEdit.getProperty(""grab-key.assigned-to.none"");
		KeyBinding kb = getKeyBinding(shortcut);

		if(kb != null)
			if(kb.isPrefix)
				text = jEdit.getProperty(
					""grab-key.assigned-to.prefix"",
					new String[] { shortcut });
			else
				text = kb.label;

		if(ok != null)
			ok.setEnabled(kb == null || !kb.isPrefix);

		assignedTo.setText(
			jEdit.getProperty(""grab-key.assigned-to"",
				new String[] { text }));
	} 

	
	private KeyBinding getKeyBinding(String shortcut)
	{
		if(shortcut == null || shortcut.length() == 0)
			return null;

		String spacedShortcut = shortcut + ' ';

		for (KeyBinding kb : allBindings)
		{
			if (!kb.isAssigned())
				continue;

			String spacedKbShortcut = kb.shortcut + ' ';

			
			if (spacedShortcut.startsWith(spacedKbShortcut))
				return kb;

			
			if (spacedKbShortcut.startsWith(spacedShortcut))
			{
				
				
				return new KeyBinding(kb.name, kb.label,
						      shortcut, true);
			}
		}

		return null;
	} 

	

	
	
	public static class KeyBinding
	{
		public KeyBinding(String name, String label,
			String shortcut, boolean isPrefix)
		{
			this.name = name;
			this.label = label;
			this.shortcut = shortcut;
			this.isPrefix = isPrefix;
		}

		public String name;
		public String label;
		public String shortcut;
		public boolean isPrefix;

		public boolean isAssigned()
		{
			return shortcut != null && shortcut.length() > 0;
		}
	} 

	
	private class InputPane extends JTextField
	{
		
		
		@Override
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		} 

		
		@Override
		protected void processKeyEvent(KeyEvent _evt)
		{
			KeyEvent evt = KeyEventWorkaround.processKeyEvent(_evt);
			if(!KeyEventWorkaround.isBindable(_evt.getKeyCode()))
				evt = null;

			if(debugBuffer != null)
			{
				debugBuffer.insert(debugBuffer.getLength(),
					""Event "" + AbstractInputHandler.toString(_evt)
					+ (evt == null ? "" filtered\n""
					: "" passed\n""));
			}

			if(evt == null)
				return;

			evt.consume();

			KeyEventTranslator.Key key = KeyEventTranslator
				.translateKeyEvent(evt);

			if (Debug.DUMP_KEY_EVENTS)
			{
				Log.log(Log.DEBUG,GrabKeyDialog.class,""processKeyEvent() key=""+key+"", _evt=""+_evt+'.');
			}

			if(key == null)
				return;

			if(debugBuffer != null)
			{
				debugBuffer.insert(debugBuffer.getLength(),
					""==> Translated to "" + key + '\n');
			}

			StringBuilder keyString = new StringBuilder(getText());

			if(getDocument().getLength() != 0)
				keyString.append(' ');

			if(key.modifiers != null)
			{
				keyString.append(key.modifiers).append('+');
			}

			String symbolicName = getSymbolicName(key.key);

			if(symbolicName != null)
			{
				keyString.append(symbolicName);
			}
			else
			{
				if (key.input != '\0')
				{
					if (key.input == ' ')
					{
						keyString.append(""SPACE"");
					}
					else
					{
						keyString.append(key.input);
					}
				}
				else
				{
					return;
				}
			}

			setText(keyString.toString());
			if(debugBuffer == null)
				updateAssignedTo(keyString.toString());
		} 
	} 

	
	private class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(canClose())
					dispose();
			}
			else if(evt.getSource() == remove)
			{
				shortcut.setText(null);
				isOK = true;
				dispose();
			}
			else if(evt.getSource() == cancel)
				dispose();
			else if(evt.getSource() == clear)
			{
				shortcut.setText(null);
				if(debugBuffer == null)
					updateAssignedTo(null);
				shortcut.requestFocus();
			}
		} 

		
		private boolean canClose()
		{
			String shortcutString = shortcut.getText();
			if(shortcutString.length() == 0
				&& binding.isAssigned())
			{
				
				int answer = GUIUtilities.confirm(
					GrabKeyDialog.this,
					""grab-key.remove-ask"",
					null,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.QUESTION_MESSAGE);
				if(answer == JOptionPane.YES_OPTION)
				{
					shortcut.setText(null);
					isOK = true;
				}
				else
					return false;
			}

			
			KeyBinding other = getKeyBinding(shortcutString);
			if(other == null || other == binding)
			{
				isOK = true;
				return true;
			}

			
			if(other.name == binding.name)
			{
				
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.duplicate-alt-shortcut"",
					null);
				return false;
			}

			
			if(other.isPrefix)
			{
				
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.prefix-shortcut"",
					null);
				return false;
			}

			
			int answer = GUIUtilities.confirm(GrabKeyDialog.this,
				""grab-key.duplicate-shortcut"",
				new Object[] { other.label },
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(answer == JOptionPane.YES_OPTION)
			{
				if(other.shortcut != null
					&& shortcutString.startsWith(other.shortcut))
				{
					other.shortcut = null;
				}
				isOK = true;
				return true;
			}
			else
				return false;
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.GUIUtilities,74,1,0,154,228,2673,138,26,66,0.95890411,2274,0.5,1,0.0,0.0793379,0,0,29.59459459,11,2.2162,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.jedit.browser.VFSFileChooserDialog;
import org.gjt.sp.jedit.gui.DynamicContextMenuService;
import org.gjt.sp.jedit.gui.EnhancedButton;
import org.gjt.sp.jedit.gui.FloatingWindowContainer;
import org.gjt.sp.jedit.gui.SplashScreen;
import org.gjt.sp.jedit.gui.VariableGridLayout;
import org.gjt.sp.jedit.menu.EnhancedCheckBoxMenuItem;
import org.gjt.sp.jedit.menu.EnhancedMenu;
import org.gjt.sp.jedit.menu.EnhancedMenuItem;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.textarea.TextAreaMouseHandler;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.SyntaxUtilities;


import java.net.URL;
import java.util.*;
import java.util.List;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JToolBar;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;


import java.awt.*;
import java.awt.event.*;



public class GUIUtilities
{
	
	
	@Deprecated
	public static Icon NEW_BUFFER_ICON;

	
	@Deprecated
	public static Icon DIRTY_BUFFER_ICON;

	
	@Deprecated
	public static Icon READ_ONLY_BUFFER_ICON;

	
	@Deprecated
	public static Icon NORMAL_BUFFER_ICON;

	
	@Deprecated
	public static Icon WINDOW_ICON;
	

	

	
	
	public static void setIconPath(String iconPath)
	{
		GUIUtilities.iconPath = iconPath;
		if(icons != null)
			icons.clear();
	} 

	
	
	public static Icon loadIcon(String iconName)
	{
		if(iconName == null)
			return null;

		
		if(deprecatedIcons != null && deprecatedIcons.containsKey(iconName))
			iconName = deprecatedIcons.get(iconName);

		if(icons == null)
			icons = new Hashtable<String, Icon>();

		
		Icon icon = icons.get(iconName);
		if(icon != null)
			return icon;

		URL url;

		try
		{
			
			if(MiscUtilities.isURL(iconName))
				url = new URL(iconName);
			else
				url = new URL(iconPath + iconName);
		}
		catch(Exception e)
		{
			try
			{
				url = new URL(defaultIconPath + iconName);
			}
			catch(Exception ex)
			{
				Log.log(Log.ERROR,GUIUtilities.class,
					""Icon not found: "" + iconName);
				Log.log(Log.ERROR,GUIUtilities.class,ex);
				return null;
			}
		}

		icon = new ImageIcon(url);

		icons.put(iconName,icon);
		return icon;
	} 

	
	
	public static Image getEditorIcon()
	{
		return ((ImageIcon)loadIcon(jEdit.getProperty(""logo.icon.medium""))).getImage();
	} 

	
	
	public static Image getPluginIcon()
	{
		return getEditorIcon();
	} 

	

	

	
	
	public static JMenuBar loadMenuBar(String name)
	{
		return loadMenuBar(jEdit.getActionContext(),name);
	} 

	
	
	public static JMenuBar loadMenuBar(ActionContext context, String name)
	{
		String menus = jEdit.getProperty(name);
		StringTokenizer st = new StringTokenizer(menus);

		JMenuBar mbar = new JMenuBar();

		while(st.hasMoreTokens())
		{
			String menuName = st.nextToken();
			mbar.add(loadMenu(context, menuName));
		}

		return mbar;
	} 

	
	
	public static JMenu loadMenu(String name)
	{
		return loadMenu(jEdit.getActionContext(),name);
	} 

	
	
	public static JMenu loadMenu(ActionContext context, String name)
	{
		return new EnhancedMenu(name,
			jEdit.getProperty(name.concat("".label"")),
			context);
	} 

	
	
	public static JPopupMenu loadPopupMenu(String name, JEditTextArea textArea, MouseEvent evt)
	{
		return loadPopupMenu(jEdit.getActionContext(), name, textArea, evt);
	} 

	
	
	public static JPopupMenu loadPopupMenu(String name)
	{
		return loadPopupMenu(jEdit.getActionContext(),name);
	} 

	
	
	public static JPopupMenu loadPopupMenu(ActionContext context, String name)
	{
		return loadPopupMenu(context, name, null, null);
	}

	
	
	public static JPopupMenu loadPopupMenu(ActionContext context, String name, JEditTextArea textArea, MouseEvent evt)
	{
		JPopupMenu menu = new JPopupMenu();

		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					menu.addSeparator();
				else
					menu.add(loadMenuItem(context,menuItemName,false));
			}
		}
		
		if (textArea != null)
		{
			List<JMenuItem> list = GUIUtilities.getServiceContextMenuItems(textArea, evt);
			if (!list.isEmpty())
			{
				menu.addSeparator();
			}
			for (JMenuItem mi : list)
			{
				menu.add(mi);
			}
		}

		return menu;
	} 
	
	
	public static List<JMenuItem> getServiceContextMenuItems(JEditTextArea textArea, MouseEvent evt)
	{
		List<JMenuItem> list = new ArrayList<JMenuItem>();
		String serviceClassName =  DynamicContextMenuService.class.getName();
		String[] menuServiceList = ServiceManager.getServiceNames(serviceClassName);
		for (String menuServiceName : menuServiceList)
		{
			if (menuServiceName != null && menuServiceName.trim().length() > 0)
			{
				DynamicContextMenuService dcms = (DynamicContextMenuService)
						ServiceManager.getService(serviceClassName, menuServiceName);
				if (dcms != null)
				{
					JMenuItem[] items = dcms.createMenu(textArea, evt);
					if (items != null)
					{
						list.addAll(Arrays.asList(items));
					}
				}
			}
		}
		return list;
	} 

	
	
	public static JMenuItem loadMenuItem(String name)
	{
		return loadMenuItem(jEdit.getActionContext(),name,true);
	} 

	
	
	public static JMenuItem loadMenuItem(String name, boolean setMnemonic)
	{
		return loadMenuItem(jEdit.getActionContext(),name,setMnemonic);
	} 

	
	
	public static JMenuItem loadMenuItem(ActionContext context, String name,
		boolean setMnemonic)
	{
		if(name.charAt(0) == '%')
			return loadMenu(context,name.substring(1));

		return _loadMenuItem(name, context, setMnemonic);
	} 

	
	public static JMenuItem loadMenuItem(EditAction editAction,
		boolean setMnemonic)
	{
		String name = editAction.getName();
		ActionContext context = jEdit.getActionContext();

		return _loadMenuItem(name, context, setMnemonic);
	} 

	
	
	public static Container loadToolBar(String name)
	{
		return loadToolBar(jEdit.getActionContext(),name);
	} 

	
	
	public static Container loadToolBar(ActionContext context, String name)
	{
		JPanel toolBar = new JPanel(new BorderLayout());
		JToolBar toolB = new JToolBar();
		toolB.setFloatable(false);
		toolB.setMargin(new Insets(0,0,0,0));

		String buttons = jEdit.getProperty(name);
		if(buttons != null)
		{
			StringTokenizer st = new StringTokenizer(buttons);
			while(st.hasMoreTokens())
			{
				String button = st.nextToken();
				if(button.equals(""-""))
				{
					toolB.addSeparator(new Dimension(12,12));
				}
				else
				{
					JButton b = loadToolButton(context,button);
					if(b != null)
						toolB.add(b);
				}
			}
		}

		toolBar.add(toolB);
		return toolBar;
	} 

	
	
	public static EnhancedButton loadToolButton(String name)
	{
		return loadToolButton(jEdit.getActionContext(),name);
	} 

	
	
	public static EnhancedButton loadToolButton(ActionContext context,
		String name)
	{
		String label = jEdit.getProperty(name + "".label"");

		if(label == null)
			label = name;

		Icon icon;
		String iconName = jEdit.getProperty(name + "".icon"");
		if(iconName == null)
			icon = loadIcon(jEdit.getProperty(""broken-image.icon""));
		else
		{
			icon = loadIcon(iconName);
			if(icon == null)
				icon = loadIcon(jEdit.getProperty(""broken-image.icon""));
		}

		String toolTip = prettifyMenuLabel(label);
		String shortcutLabel = getShortcutLabel(name);
		if(shortcutLabel != null)
		{
			toolTip = toolTip + "" ("" + shortcutLabel + ')';
		}

		EnhancedButton b = new EnhancedButton(icon,toolTip,name,context);
		b.setPreferredSize(new Dimension(32,32));
		return b;
	} 

	
	
	public static String prettifyMenuLabel(String label)
	{
		int index = label.indexOf('$');
		if(index != -1)
		{
			label = label.substring(0,index)
				.concat(label.substring(index + 1));
		}
		return label;
	} 

	
	
	public static String getShortcutLabel(String action)
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(action + "".shortcut"");
			String shortcut2 = jEdit.getProperty(action + "".shortcut2"");

			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} 

	

	

	

	
	
	public static void message(Component comp, String name, Object[] args)
	{
		hideSplashScreen();

		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static void error(Component comp, String name, Object[] args)
	{
		hideSplashScreen();

		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.ERROR_MESSAGE);
	} 

	
	
	public static String input(Component comp, String name, Object def)
	{
		return input(comp,name,null,def);
	} 

	
	
	public static String inputProperty(Component comp, String name,
		String def)
	{
		return inputProperty(comp,name,null,def);
	} 

	
	
	public static String input(Component comp, String name,
		Object[] args, Object def)
	{
		hideSplashScreen();

		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,null,null,def);
		return retVal;
	} 

	
	
	public static String inputProperty(Component comp, String name,
		Object[] args, String def)
	{
		hideSplashScreen();

		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,
			null,null,jEdit.getProperty(def));
		if(retVal != null)
			jEdit.setProperty(def,retVal);
		return retVal;
	} 

	
	
	public static int confirm(Component comp, String name,
		Object[] args, int buttons, int type)
	{
		hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,
			jEdit.getProperty(name + "".message"",args),
			jEdit.getProperty(name + "".title""),buttons,type);
	} 

	
	
	public static int listConfirm(Component comp, String name, String[] args,
		Object[] listModel)
	{
		JList list = new JList(listModel);
		list.setVisibleRowCount(8);

		Object[] message = {
			jEdit.getProperty(name + "".message"",args),
			new JScrollPane(list)
		};

		return JOptionPane.showConfirmDialog(comp,
			message,
			jEdit.getProperty(name + "".title""),
			JOptionPane.YES_NO_OPTION,
			JOptionPane.QUESTION_MESSAGE);
	} 

	
	
	public static int listConfirm(Component comp, String name, String[] args,
		Object[] listModel, List selectedItems)
	{
		JList list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		list.setVisibleRowCount(8);
		list.addSelectionInterval(0,listModel.length - 1);

		Object[] message = {
			jEdit.getProperty(name + "".message"",args),
			new JScrollPane(list)
		};

		int ret = JOptionPane.showConfirmDialog(comp,
							message,
							jEdit.getProperty(name + "".title""),
							JOptionPane.YES_NO_OPTION,
							JOptionPane.QUESTION_MESSAGE);
		Object[] selectedValues = list.getSelectedValues();
		selectedItems.addAll(Arrays.asList(selectedValues));
		return ret;
	} 

	
	
	public static String[] showVFSFileDialog(View view, String path,
		int type, boolean multipleSelection)
	{
		
		if(view == null)
		{
			Log.log(Log.WARNING,GUIUtilities.class,
			""showVFSFileDialog(): given null view, assuming jEdit.getActiveView()"");
			view = jEdit.getActiveView();
		}

		hideSplashScreen();

		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			view,path,type,multipleSelection);
		return fileChooser.getSelectedFiles();
	}

	
	public static String[] showVFSFileDialog(Dialog parent, View view,
		String path, int type, boolean multipleSelection)
	{
		hideSplashScreen();

		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			parent, view, path, type, multipleSelection, true);
		return fileChooser.getSelectedFiles();
	}

	
	public static String[] showVFSFileDialog(Frame parent, View view,
		String path, int type, boolean multipleSelection)
	{
		hideSplashScreen();
		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			parent, view, path, type, multipleSelection, true);
		return fileChooser.getSelectedFiles();
	} 

	

	

	
	
	public static Color parseColor(String name)
	{
		return SyntaxUtilities.parseColor(name, Color.black);
	} 

	
	
	@Deprecated
	public static Color parseColor(String name, Color defaultColor)
	{
		return SyntaxUtilities.parseColor(name, defaultColor);
	} 

	
	
	@Deprecated
	public static String getColorHexString(Color c)
	{
		return SyntaxUtilities.getColorHexString(c);
	} 

	
	
	public static SyntaxStyle parseStyle(String str, String family, int size)
		throws IllegalArgumentException
	{
		return SyntaxUtilities.parseStyle(str,family,size,true);
	} 

	
	
	@Deprecated
	public static SyntaxStyle parseStyle(String str, String family, int size,
		boolean color)
		throws IllegalArgumentException
	{
		return SyntaxUtilities.parseStyle(str,family,size,color);
	} 

	
	
	public static String getStyleString(SyntaxStyle style)
	{
		StringBuilder buf = new StringBuilder();

		if (style.getForegroundColor() != null)
		{
			buf.append(""color:"").append(SyntaxUtilities.getColorHexString(style.getForegroundColor()));
		}

		if (style.getBackgroundColor() != null)
		{
			buf.append("" bgColor:"").append(SyntaxUtilities.getColorHexString(style.getBackgroundColor()));
		}

		Font font = style.getFont();
		if (!font.isPlain())
		{
			buf.append("" style:"");
			if (font.isItalic())
				buf.append('i');
			if (font.isBold())
				buf.append('b');
		}

		return buf.toString();
	} 

	
	
	@Deprecated
	public static SyntaxStyle[] loadStyles(String family, int size)
	{
		return SyntaxUtilities.loadStyles(family,size,true);
	}

	
	@Deprecated
	public static SyntaxStyle[] loadStyles(String family, int size, boolean color)
	{
		return SyntaxUtilities.loadStyles(family, size, color);
	} 

	

	

	
	
	public static void loadGeometry(Window win, Container parent, String name )
	{
		Dimension size = win.getSize();
		int width = jEdit.getIntegerProperty(name + "".width"", size.width);
		int height = jEdit.getIntegerProperty(name + "".height"", size.height);
		int x = jEdit.getIntegerProperty(name + "".x"",50);
		int y = jEdit.getIntegerProperty(name + "".y"",50);
		if(parent != null)
		{
			Point location = parent.getLocation();
			x = location.x + x;
			y = location.y + y;
		}

		int extState = jEdit.getIntegerProperty(name + "".extendedState"", Frame.NORMAL);

		Rectangle desired = new Rectangle(x,y,width,height);
		try
		{
			if(!Debug.DISABLE_MULTIHEAD)
				adjustForScreenBounds(desired);
		}
		catch(Exception e)
		{
			
			Log.log(Log.ERROR,GUIUtilities.class,e);
		}

		if(OperatingSystem.isX11() && Debug.GEOMETRY_WORKAROUND)
			new UnixWorkaround(win,name,desired,extState);
		else
		{
			win.setBounds(desired);
			if(win instanceof Frame)
				((Frame)win).setExtendedState(extState);
		}

	} 

	
	
	public static void loadGeometry(Window win, String name)
	{
		loadGeometry(win, win.getParent(), name);
	} 

	
	
	public static void adjustForScreenBounds(Rectangle desired)
	{
		
		Rectangle osbounds = OperatingSystem.getScreenBounds(desired);

		if (desired.width > osbounds.width)
		{
			desired.width = osbounds.width;
		}
		if (desired.x < osbounds.x)
		{
			desired.x = osbounds.x;
		}
		if (desired.x + desired.width > osbounds.x + osbounds.width)
		{
			desired.x = osbounds.x + osbounds.width - desired.width;
		}
		if (desired.height > osbounds.height)
		{
			desired.height = osbounds.height;
		}
		if (desired.y < osbounds.y)
		{
			desired.y = osbounds.y;
		}
		if (desired.y + desired.height > osbounds.y + osbounds.height)
		{
			desired.y = osbounds.y + osbounds.height - desired.height;
		}
	} 

	
	public static class UnixWorkaround
	{
		Window win;
		String name;
		Rectangle desired;
		Rectangle required;
		long start;
		boolean windowOpened;

		
		public UnixWorkaround(Window win, String name, Rectangle desired,
			int extState)
		{
			this.win = win;
			this.name = name;
			this.desired = desired;

			int adjust_x = jEdit.getIntegerProperty(name + "".dx"",0);
			int adjust_y = jEdit.getIntegerProperty(name + "".dy"",0);
			int adjust_width = jEdit.getIntegerProperty(name + "".d-width"",0);
			int adjust_height = jEdit.getIntegerProperty(name + "".d-height"",0);

			required = new Rectangle(
				desired.x - adjust_x,
				desired.y - adjust_y,
				desired.width - adjust_width,
				desired.height - adjust_height);

			Log.log(Log.DEBUG,GUIUtilities.class,""Window "" + name
				+ "": desired geometry is "" + desired);
			Log.log(Log.DEBUG,GUIUtilities.class,""Window "" + name
				+ "": setting geometry to "" + required);

			start = System.currentTimeMillis();

			win.setBounds(required);
			if(win instanceof Frame)
				((Frame)win).setExtendedState(extState);

			win.addComponentListener(new ComponentHandler());
			win.addWindowListener(new WindowHandler());
		} 

		
		private class ComponentHandler extends ComponentAdapter
		{
			
			@Override
			public void componentMoved(ComponentEvent evt)
			{
				if(System.currentTimeMillis() - start < 1000L)
				{
					Rectangle r = win.getBounds();
					if(!windowOpened && r.equals(required))
						return;

					if(!r.equals(desired))
					{
						Log.log(Log.DEBUG,GUIUtilities.class,
							""Window resize blocked: "" + win.getBounds());
						win.setBounds(desired);
					}
				}

				win.removeComponentListener(this);
			} 

			
			@Override
			public void componentResized(ComponentEvent evt)
			{
				if(System.currentTimeMillis() - start < 1000L)
				{
					Rectangle r = win.getBounds();
					if(!windowOpened && r.equals(required))
						return;

					if(!r.equals(desired))
					{
						Log.log(Log.DEBUG,GUIUtilities.class,
							""Window resize blocked: "" + win.getBounds());
						win.setBounds(desired);
					}
				}

				win.removeComponentListener(this);
			} 
		} 

		
		private class WindowHandler extends WindowAdapter
		{
			
			@Override
			public void windowOpened(WindowEvent evt)
			{
				windowOpened = true;

				Rectangle r = win.getBounds();
				Log.log(Log.DEBUG,GUIUtilities.class,""Window ""
					+ name + "": bounds after opening: "" + r);

				jEdit.setIntegerProperty(name + "".dx"",
					r.x - required.x);
				jEdit.setIntegerProperty(name + "".dy"",
					r.y - required.y);
				jEdit.setIntegerProperty(name + "".d-width"",
					r.width - required.width);
				jEdit.setIntegerProperty(name + "".d-height"",
					r.height - required.height);

				win.removeWindowListener(this);
			} 
		} 
	} 

	
	
	public static void saveGeometry(Window win, String name)
	{
		saveGeometry (win, win.getParent(), name);
	} 

	
	
	public static void saveGeometry(Window win, Container parent, String name)
	{
		if(win instanceof Frame)
		{
			jEdit.setIntegerProperty(name + "".extendedState"",
				((Frame)win).getExtendedState());
		}

		Rectangle bounds = win.getBounds();
		int x = bounds.x;
		int y = bounds.y;
		if (parent != null)
		{
			Rectangle parentBounds = parent.getBounds();
			x -= parentBounds.x;
			y -= parentBounds.y;
		}
		jEdit.setIntegerProperty(name + "".x"",x);
		jEdit.setIntegerProperty(name + "".y"",y);
		jEdit.setIntegerProperty(name + "".width"", bounds.width);
		jEdit.setIntegerProperty(name + "".height"", bounds.height);
	} 

	
	
	@Deprecated
	public static void centerOnScreen(Window win)
	{
		GraphicsDevice gd = GraphicsEnvironment
			.getLocalGraphicsEnvironment()
			.getDefaultScreenDevice();
		Rectangle gcbounds = gd.getDefaultConfiguration().getBounds();
		int x = gcbounds.x + (gcbounds.width - win.getWidth()) / 2;
		int y = gcbounds.y + (gcbounds.height - win.getHeight()) / 2;
		win.setLocation(x,y);
	} 

	

	
	
	public static void hideSplashScreen()
	{
		if(splash != null)
		{
			splash.dispose();
			splash = null;
		}
	} 

	
	
	public static JComponent createMultilineLabel(String str)
	{
		JPanel panel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1,1,1));
		int lastOffset = 0;
		while(true)
		{
			int index = str.indexOf('\n',lastOffset);
			if(index == -1)
				break;
			else
			{
				panel.add(new JLabel(str.substring(lastOffset,index)));
				lastOffset = index + 1;
			}
		}

		if(lastOffset != str.length())
			panel.add(new JLabel(str.substring(lastOffset)));

		return panel;
	} 

	
	
	public static void requestFocus(final Window win, final Component comp)
	{
		win.addWindowFocusListener(new WindowAdapter()
		{
			@Override
			public void windowGainedFocus(WindowEvent evt)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
						public void run()
						{
							comp.requestFocusInWindow();
						}
				});
				win.removeWindowFocusListener(this);
			}
		});
	} 

	
	
	public static boolean isPopupTrigger(MouseEvent evt)
	{
		return TextAreaMouseHandler.isRightButton(evt.getModifiers());
	} 

	
	
	public static boolean isMiddleButton(int modifiers)
	{
		return TextAreaMouseHandler.isMiddleButton(modifiers);
	} 

	
	
	public static boolean isRightButton(int modifiers)
	{
		return TextAreaMouseHandler.isRightButton(modifiers);
	} 

	
	
	public static Rectangle getScreenBounds()
	{
		Rectangle bounds = GraphicsEnvironment.getLocalGraphicsEnvironment().
			getMaximumWindowBounds();
		GraphicsDevice [] devices = GraphicsEnvironment.
			getLocalGraphicsEnvironment().getScreenDevices();
		if (devices.length > 1)
		{
			for (GraphicsDevice device: devices)
			{
				for (GraphicsConfiguration config: device.getConfigurations())
					bounds = bounds.union(config.getBounds());
			}
		}
		return bounds;
	}

	
	
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y)
	{
		showPopupMenu(popup,comp,x,y,true);
	} 

	
	
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y, boolean point)
	{
		int offsetX = 0;
		int offsetY = 0;

		int extraOffset = point ? 1 : 0;

		Component win = comp;
		while(!(win instanceof Window || win == null))
		{
			offsetX += win.getX();
			offsetY += win.getY();
			win = win.getParent();
		}

		if(win != null)
		{
			Dimension size = popup.getPreferredSize();

			Rectangle screenSize = getScreenBounds();

			if(x + offsetX + size.width + win.getX() > screenSize.width
				&& x + offsetX + win.getX() >= size.width)
			{
				
				if(point)
					x -= size.width + extraOffset;
				else
					x = win.getWidth() - size.width - offsetX + extraOffset;
			}
			else
			{
				x += extraOffset;
			}

			
			
			
			if(y + offsetY + size.height + win.getY() > screenSize.height
				&& y + offsetY + win.getY() >= size.height)
			{
				if(point)
					y = win.getHeight() - size.height - offsetY + extraOffset;
				else
					y = -size.height - 1;
			}
			else
			{
				y += extraOffset;
			}

			popup.show(comp,x,y);
		}
		else
			popup.show(comp,x + extraOffset,y + extraOffset);

	} 

	
	
	public static boolean isAncestorOf(Component comp1, Component comp2)
	{
		while(comp2 != null)
		{
			if(comp1 == comp2)
				return true;
			else
				comp2 = comp2.getParent();
		}

		return false;
	} 

	
	
	public static JDialog getParentDialog(Component c)
	{
		return (JDialog) SwingUtilities.getAncestorOfClass(JDialog.class, c);
	} 

	
	
	public static Component getComponentParent(Component comp, Class clazz)
	{
		while(true)
		{
			if(comp == null)
				break;

			if(comp instanceof JComponent)
			{
				Component real = (Component)((JComponent)comp)
					.getClientProperty(""KORTE_REAL_FRAME"");
				if(real != null)
					comp = real;
			}

			if(comp.getClass().equals(clazz))
				return comp;
			else if(comp instanceof JPopupMenu)
				comp = ((JPopupMenu)comp).getInvoker();
			else if(comp instanceof FloatingWindowContainer)
			{
				comp = ((FloatingWindowContainer)comp)
					.getDockableWindowManager();
			}
			else
				comp = comp.getParent();
		}
		return null;
	} 

	
	
	public static void setEnabledRecursively(Container c, boolean enabled)
	{
		for (Component child: c.getComponents())
		{
			if (child instanceof Container)
				setEnabledRecursively((Container)child, enabled);
			else
				child.setEnabled(enabled);
		}
		c.setEnabled(enabled);
	} 

	
	
	public static View getView(Component comp)
	{
		return (View)getComponentParent(comp,View.class);
	} 

	
	
	public static void addSizeSaver(Frame frame, String name)
	{
		addSizeSaver(frame,frame.getParent(),name);
	} 

	
	
	public static void addSizeSaver(Frame frame, Container parent, String name)
	{
		SizeSaver ss = new SizeSaver(frame,parent,name);
		frame.addWindowStateListener(ss);
		frame.addComponentListener(ss);
	} 

	
	
	public static void initContinuousLayout(JSplitPane split)
	{
		boolean continuousLayout = split.isContinuousLayout();
		if (continuousLayout != jEdit.getBooleanProperty(""appearance.continuousLayout""))
			split.setContinuousLayout(!continuousLayout);
	} 

	

	
	
	private static void initializeDeprecatedIcons()
	{
		deprecatedIcons.put(""File.png"",       ""16x16/mimetypes/text-x-generic.png"");
		deprecatedIcons.put(""Folder.png"",     ""16x16/places/folder.png"");
		deprecatedIcons.put(""OpenFolder.png"", ""16x16/status/folder-open.png"");
		deprecatedIcons.put(""OpenFile.png"",   ""16x16/actions/edit-select-all.png"");
		deprecatedIcons.put(""ReloadSmall.png"",""16x16/actions/view-refresh.png"");
		deprecatedIcons.put(""DriveSmall.png"", ""16x16/devices/drive-harddisk.png"");
		deprecatedIcons.put(""New.png"",        ""22x22/actions/document-new.png"");
		deprecatedIcons.put(""NewDir.png"",     ""22x22/actions/folder-new.png"");
		deprecatedIcons.put(""Reload.png"",     ""22x22/actions/view-refresh.png"");
		deprecatedIcons.put(""Load.png"",       ""22x22/places/plugins.png"");
		deprecatedIcons.put(""Save.png"",       ""22x22/actions/document-save.png"");
		deprecatedIcons.put(""SaveAs.png"",     ""22x22/actions/document-save-as.png"");
		deprecatedIcons.put(""SaveAll.png"",    ""22x22/actions/document-save-all.png"");
		deprecatedIcons.put(""Open.png"",       ""22x22/actions/document-open.png"");
		deprecatedIcons.put(""Print.png"",      ""22x22/actions/document-print.png"");
		deprecatedIcons.put(""Drive.png"",      ""22x22/devices/drive-harddisk.png"");
		deprecatedIcons.put(""Clear.png"",      ""22x22/actions/edit-clear.png"");
		deprecatedIcons.put(""Run.png"",        ""22x22/actions/application-run.png"");
		deprecatedIcons.put(""RunAgain.png"",   ""22x22/actions/application-run-again.png"");
		deprecatedIcons.put(""RunToBuffer.png"",  ""22x22/actions/run-to-buffer.png"");
		deprecatedIcons.put(""CopyToBuffer.png"", ""22x22/actions/copy-to-buffer.png"");
		deprecatedIcons.put(""Plus.png"",       ""22x22/actions/list-add.png"");
		deprecatedIcons.put(""Minus.png"",      ""22x22/actions/list-remove.png"");
		deprecatedIcons.put(""Find.png"",       ""22x22/actions/edit-find.png"");
		deprecatedIcons.put(""FindAgain.png"",  ""22x22/actions/edit-find-next.png"");
		deprecatedIcons.put(""FindInDir.png"",  ""22x22/actions/edit-find-in-folder.png"");
		deprecatedIcons.put(""Parse.png"",      ""22x22/actions/document-reload2.png"");
		deprecatedIcons.put(""Delete.png"",     ""22x22/actions/edit-delete.png"");
		deprecatedIcons.put(""Paste.png"",      ""22x22/actions/edit-paste.png"");
		deprecatedIcons.put(""Cut.png"",        ""22x22/actions/edit-cut.png"");
		deprecatedIcons.put(""Copy.png"",       ""22x22/actions/edit-copy.png"");
		deprecatedIcons.put(""Undo.png"",       ""22x22/actions/edit-undo.png"");
		deprecatedIcons.put(""Redo.png"",       ""22x22/actions/edit-redo.png"");
		deprecatedIcons.put(""CurrentDir.png"", ""22x22/status/folder-visiting.png"");
		deprecatedIcons.put(""ParentDir.png"",  ""22x22/actions/go-parent.png"");
		deprecatedIcons.put(""PageSetup.png"",  ""22x22/actions/printer-setup.png"");
		deprecatedIcons.put(""Plugins.png"",    ""22x22/apps/system-installer.png"");
		deprecatedIcons.put(""Floppy.png"",     ""22x22/devices/media-floppy.png"");
		deprecatedIcons.put(""Stop.png"",       ""22x22/actions/process-stop.png"");
		deprecatedIcons.put(""Cancel.png"",     ""22x22/actions/process-stop.png"");
		deprecatedIcons.put(""Home.png"",       ""22x22/actions/go-home.png"");
		deprecatedIcons.put(""Help.png"",       ""22x22/apps/help-browser.png"");
		deprecatedIcons.put(""Properties.png"", ""22x22/actions/document-properties.png"");
		deprecatedIcons.put(""Preferences.png"",""22x22/categories/preferences-system.png"");
		deprecatedIcons.put(""ZoomIn.png"",     ""22x22/actions/zoom-in.png"");
		deprecatedIcons.put(""ZoomOut.png"",    ""22x22/actions/zoom-out.png"");
		deprecatedIcons.put(""BrokenImage.png"",""22x22/status/image-missing.png"");
		deprecatedIcons.put(""AdjustWidth.png"",""22x22/actions/resize-horisontal.png"");
		deprecatedIcons.put(""ToolbarMenu.gif"",""ToolbarMenu.gif"");

		deprecatedIcons.put(""Play.png"",""22x22/actions/media-playback-start.png"");
		deprecatedIcons.put(""Pause.png"",""22x22/actions/media-playback-pause.png"");

		deprecatedIcons.put(""MultipleResults.png"", ""22x22/actions/edit-find-multiple.png"");
		deprecatedIcons.put(""SingleResult.png"",    ""22x22/actions/edit-find-single.png"");

		deprecatedIcons.put(""NextFile.png"",    ""22x22/go-last.png"");
		deprecatedIcons.put(""PreviousFile.png"",""22x22/go-first.png"");

		deprecatedIcons.put(""closebox.gif"",   ""10x10/actions/close.png"");
		deprecatedIcons.put(""normal.gif"",   ""10x10/status/document-unmodified.png"");
		deprecatedIcons.put(""readonly.gif"",   ""10x10/emblem/emblem-readonly.png"");
		deprecatedIcons.put(""dirty.gif"",    ""10x10/status/document-modified.png"");
		deprecatedIcons.put(""new.gif"",    ""10x10/status/document-new.png"");

		deprecatedIcons.put(""ArrowU.png"", ""22x22/actions/go-up.png"");
		deprecatedIcons.put(""ArrowR.png"", ""22x22/actions/go-next.png"");
		deprecatedIcons.put(""ArrowD.png"", ""22x22/actions/go-down.png"");
		deprecatedIcons.put(""ArrowL.png"", ""22x22/actions/go-previous.png"");
		deprecatedIcons.put(""arrow1.png"", ""16x16/actions/group-expand.png"");
		deprecatedIcons.put(""arrow2.png"", ""16x16/actions/group-collapse.png"");

		deprecatedIcons.put(""NewView.png"", ""22x22/actions/window-new.png"");
		deprecatedIcons.put(""UnSplit.png"", ""22x22/actions/window-unsplit.png"");
		deprecatedIcons.put(""SplitVertical.png"", ""22x22/actions/window-split-vertical.png"");
		deprecatedIcons.put(""SplitHorizontal.png"", ""22x22/actions/window-split-horizontal.png"");

		deprecatedIcons.put(""ButtonProperties.png"", ""22x22/actions/document-properties.png"");

	}
	

	
	static void init()
	{
		initializeDeprecatedIcons();

		
		String theme = jEdit.getProperty(""icon-theme"", ""tango"");
		Log.log(Log.DEBUG, GUIUtilities.class, ""Icon theme set to: ""+theme);
		setIconPath(""jeditresource:/org/gjt/sp/jedit/icons/themes/"" + theme + '/');
		Log.log(Log.DEBUG, GUIUtilities.class, ""Loading icon theme from: ""+iconPath);

		
		
		NEW_BUFFER_ICON = loadIcon(""new.gif"");
		DIRTY_BUFFER_ICON = loadIcon(""dirty.gif"");
		READ_ONLY_BUFFER_ICON = loadIcon(""readonly.gif"");
		NORMAL_BUFFER_ICON = loadIcon(""normal.gif"");
		WINDOW_ICON = loadIcon(jEdit.getProperty(""logo.icon.medium""));
	} 

	
	static void showSplashScreen()
	{
		splash = new SplashScreen();
	} 

	
	static void advanceSplashProgress()
	{
		if(splash != null)
			splash.advance();
	} 

	
	static void advanceSplashProgress(String label)
	{
		if(splash != null)
			splash.advance(label);
	} 

	

	
	private static SplashScreen splash;
	private static Map<String, Icon> icons;
	private static String iconPath = ""jeditresource:/org/gjt/sp/jedit/icons/themes/"";
	private static final String defaultIconPath = ""jeditresource:/org/gjt/sp/jedit/icons/themes/"";
	private static final HashMap<String, String> deprecatedIcons = new HashMap<String, String>();

	
	private static JMenuItem _loadMenuItem(String name, ActionContext context, boolean setMnemonic)
	{

		String label = jEdit.getProperty(name + "".label"");
		if (label == null)
		{
			label = name;
		}
		char mnemonic;
		int index = label.indexOf('$');
		if (index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0, index).concat(label.substring(++index));
		}
		else
		{
			mnemonic = '\0';
		}
		JMenuItem mi;
		if (jEdit.getBooleanProperty(name + "".toggle""))
		{
			mi = new EnhancedCheckBoxMenuItem(label, name, context);
		}
		else
		{
			mi = new EnhancedMenuItem(label, name, context);
		}
		if (!OperatingSystem.isMacOS() && setMnemonic && mnemonic != '\0')
		{
			mi.setMnemonic(mnemonic);
		}
		Icon itemIcon = loadIcon(jEdit.getProperty(name + "".icon.small""));
		if(itemIcon != null)
		{
			mi.setIcon(itemIcon);
		}

		return mi;
	} 

	private GUIUtilities() {}
	

	

	
	
	private static class SizeSaver extends ComponentAdapter implements WindowStateListener
	{
		private Frame frame;
		private Container parent;
		private String name;

		
		
		SizeSaver(Frame frame, Container parent, String name)
		{
			if (frame == null || name == null)
			{
				throw new NullPointerException();
			}
			this.frame = frame;
			this.parent = parent;
			this.name = name;
		} 

		
		public void windowStateChanged(WindowEvent wse)
		{
			int extendedState = wse.getNewState();
			jEdit.setIntegerProperty(name + "".extendedState"",extendedState);
			Rectangle bounds = frame.getBounds();
			save(extendedState, bounds);
		} 

		
		private void save(int extendedState, Rectangle bounds)
		{
			switch (extendedState)
			{
				case Frame.MAXIMIZED_VERT:
					jEdit.setIntegerProperty(name + "".x"",bounds.x);
					jEdit.setIntegerProperty(name + "".width"",bounds.width);
					break;

				case Frame.MAXIMIZED_HORIZ:
					jEdit.setIntegerProperty(name + "".y"",bounds.y);
					jEdit.setIntegerProperty(name + "".height"",bounds.height);
					break;

				case Frame.NORMAL:
					saveGeometry(frame,parent,name );
					break;
			}
		} 

		
		@Override
		public void componentResized(ComponentEvent ce)
		{
			componentMoved(ce);
		} 

		
		@Override
		public void componentMoved(ComponentEvent ce)
		{
			final Rectangle bounds = frame.getBounds();
			final Runnable sizeSaver = new Runnable()
			{
				public void run()
				{
					int extendedState = frame.getExtendedState();
					save(extendedState, bounds);
				}
			};
			new Thread(""Sizesavingdelay"")
			{
				@Override
				public void run()
				{
					try
					{
						Thread.sleep(500L);
					}
					catch (InterruptedException ie)
					{
					}
					SwingUtilities.invokeLater(sizeSaver);
				}
			}.start();
		} 
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.classpath.DiscreteFilesClassLoader,3,5,0,5,13,0,1,4,3,0.0,47,0.0,1,0.977272727,0.5,2,4,14.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.bsh.classpath;

import java.util.*;

import org.gjt.sp.jedit.bsh.BshClassManager;
import org.gjt.sp.jedit.bsh.classpath.BshClassPath.ClassSource;


public class DiscreteFilesClassLoader extends BshClassLoader 
{
	
	ClassSourceMap map;

	public static class ClassSourceMap extends HashMap 
	{
		public void put( String name, ClassSource source ) {
			super.put( name, source );
		}
		public ClassSource get( String name ) {
			return (ClassSource)super.get( name );
		}
	}
	
	public DiscreteFilesClassLoader( 
		BshClassManager classManager, ClassSourceMap map ) 
	{
		super( classManager );
		this.map = map;
	}

	
	public Class findClass( String name ) throws ClassNotFoundException 
	{
		
		ClassSource source = map.get( name );

		if ( source != null )
		{
			byte [] code = source.getCode( name );
			return defineClass( name, code, 0, code.length );
		} else
			
			
			return super.findClass( name );
	}

	public String toString() {
		return super.toString() + ""for files: ""+map;
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.KeyEventWorkaround,7,1,0,10,23,19,6,4,7,1.083333333,216,1.0,0,0.0,0.285714286,0,0,29.28571429,85,25.1429,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.util.Log;



public class KeyEventWorkaround
{
	
	public static boolean isBindable(int keyCode)
	{
		switch(keyCode)
		{
		case KeyEvent.VK_ALT:
		case KeyEvent.VK_ALT_GRAPH:
		case KeyEvent.VK_CONTROL:
		case KeyEvent.VK_SHIFT:
		case KeyEvent.VK_META:
		case KeyEvent.VK_DEAD_GRAVE:
		case KeyEvent.VK_DEAD_ACUTE:
		case KeyEvent.VK_DEAD_CIRCUMFLEX:
		case KeyEvent.VK_DEAD_TILDE:
		case KeyEvent.VK_DEAD_MACRON:
		case KeyEvent.VK_DEAD_BREVE:
		case KeyEvent.VK_DEAD_ABOVEDOT:
		case KeyEvent.VK_DEAD_DIAERESIS:
		case KeyEvent.VK_DEAD_ABOVERING:
		case KeyEvent.VK_DEAD_DOUBLEACUTE:
		case KeyEvent.VK_DEAD_CARON:
		case KeyEvent.VK_DEAD_CEDILLA:
		case KeyEvent.VK_DEAD_OGONEK:
		case KeyEvent.VK_DEAD_IOTA:
		case KeyEvent.VK_DEAD_VOICED_SOUND:
		case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:
			return false;
		default:
			return true;
		}
	} 

	
	
	public static boolean isPrintable(int keyCode)
	{
		switch(keyCode)
		{
		
		case KeyEvent.VK_SPACE:
		case KeyEvent.VK_COMMA:
		case KeyEvent.VK_MINUS:
		case KeyEvent.VK_PERIOD:
		case KeyEvent.VK_SLASH:
		case KeyEvent.VK_0:
		case KeyEvent.VK_1:
		case KeyEvent.VK_2:
		case KeyEvent.VK_3:
		case KeyEvent.VK_4:
		case KeyEvent.VK_5:
		case KeyEvent.VK_6:
		case KeyEvent.VK_7:
		case KeyEvent.VK_8:
		case KeyEvent.VK_9:
		case KeyEvent.VK_SEMICOLON:
		case KeyEvent.VK_EQUALS   :
		case KeyEvent.VK_A:
		case KeyEvent.VK_B:
		case KeyEvent.VK_C:
		case KeyEvent.VK_D:
		case KeyEvent.VK_E:
		case KeyEvent.VK_F:
		case KeyEvent.VK_G:
		case KeyEvent.VK_H:
		case KeyEvent.VK_I:
		case KeyEvent.VK_J:
		case KeyEvent.VK_K:
		case KeyEvent.VK_L:
		case KeyEvent.VK_M:
		case KeyEvent.VK_N:
		case KeyEvent.VK_O:
		case KeyEvent.VK_P:
		case KeyEvent.VK_Q:
		case KeyEvent.VK_R:
		case KeyEvent.VK_S:
		case KeyEvent.VK_T:
		case KeyEvent.VK_U:
		case KeyEvent.VK_V:
		case KeyEvent.VK_W:
		case KeyEvent.VK_X:
		case KeyEvent.VK_Y:
		case KeyEvent.VK_Z:
		case KeyEvent.VK_OPEN_BRACKET :
		case KeyEvent.VK_BACK_SLASH   :
		case KeyEvent.VK_CLOSE_BRACKET:
	
		case KeyEvent.VK_BACK_QUOTE:
		case KeyEvent.VK_QUOTE:
		case KeyEvent.VK_DEAD_GRAVE:
		case KeyEvent.VK_DEAD_ACUTE:
		case KeyEvent.VK_DEAD_CIRCUMFLEX:
		case KeyEvent.VK_DEAD_TILDE:
		case KeyEvent.VK_DEAD_MACRON:
		case KeyEvent.VK_DEAD_BREVE:
		case KeyEvent.VK_DEAD_ABOVEDOT:
		case KeyEvent.VK_DEAD_DIAERESIS:
		case KeyEvent.VK_DEAD_ABOVERING:
		case KeyEvent.VK_DEAD_DOUBLEACUTE:
		case KeyEvent.VK_DEAD_CARON:
		case KeyEvent.VK_DEAD_CEDILLA:
		case KeyEvent.VK_DEAD_OGONEK:
		case KeyEvent.VK_DEAD_IOTA:
		case KeyEvent.VK_DEAD_VOICED_SOUND:
		case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:
		case KeyEvent.VK_AMPERSAND:
		case KeyEvent.VK_ASTERISK:
		case KeyEvent.VK_QUOTEDBL:
		case KeyEvent.VK_LESS:
		case KeyEvent.VK_GREATER:
		case KeyEvent.VK_BRACELEFT:
		case KeyEvent.VK_BRACERIGHT:
		case KeyEvent.VK_AT:
		case KeyEvent.VK_COLON:
		case KeyEvent.VK_CIRCUMFLEX:
		case KeyEvent.VK_DOLLAR:
		case KeyEvent.VK_EURO_SIGN:
		case KeyEvent.VK_EXCLAMATION_MARK:
		case KeyEvent.VK_INVERTED_EXCLAMATION_MARK:
		case KeyEvent.VK_LEFT_PARENTHESIS:
		case KeyEvent.VK_NUMBER_SIGN:
		case KeyEvent.VK_PLUS:
		case KeyEvent.VK_RIGHT_PARENTHESIS:
		case KeyEvent.VK_UNDERSCORE:
			return true;
		default:
			return false;
		}
	} 

	
	
	public static boolean isMacControl(KeyEvent evt)
	{
		return (OperatingSystem.isMacOS() &&
			(evt.getModifiers() & InputEvent.CTRL_MASK) != 0
			&& evt.getKeyChar() <= 0x2B);
	} 

	
	public static boolean isNumericKeypad(int keyCode)
	{
		switch(keyCode)
		{
		case KeyEvent.VK_NUMPAD0:
		case KeyEvent.VK_NUMPAD1:
		case KeyEvent.VK_NUMPAD2:
		case KeyEvent.VK_NUMPAD3:
		case KeyEvent.VK_NUMPAD4:
		case KeyEvent.VK_NUMPAD5:
		case KeyEvent.VK_NUMPAD6:
		case KeyEvent.VK_NUMPAD7:
		case KeyEvent.VK_NUMPAD8:
		case KeyEvent.VK_NUMPAD9:
		case KeyEvent.VK_MULTIPLY:
		case KeyEvent.VK_ADD:
		
		case KeyEvent.VK_SUBTRACT:
		case KeyEvent.VK_DECIMAL:
		case KeyEvent.VK_DIVIDE:
			return true;
		default:
			return false;
		}
	} 

	
	public static KeyEvent processKeyEvent(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		char ch = evt.getKeyChar();
		int modifiers = evt.getModifiers();

		switch(evt.getID())
		{
		
		case KeyEvent.KEY_PRESSED:
			
			switch(keyCode)
			{
			case '\0':
				return null;
			case KeyEvent.VK_ALT:
			case KeyEvent.VK_ALT_GRAPH:
			case KeyEvent.VK_CONTROL:
			case KeyEvent.VK_SHIFT:
			case KeyEvent.VK_META:
				break;
			default:
				if(!evt.isMetaDown())
				{
					if(!evt.isControlDown()
						&& !evt.isAltDown())
					{
						if(isPrintable(keyCode))
						{
							return null;
						}
					}
				}

				if(Debug.ALT_KEY_PRESSED_DISABLED)
				{
					
					
					if((modifiers & InputEvent.ALT_MASK) != 0)
						return null;
				}

				if(isNumericKeypad(keyCode))
					last = LAST_NUMKEYPAD;
				else
					last = LAST_NOTHING;

				break;
			}
			break;
		
		
		case KeyEvent.KEY_TYPED:
			
			
			if(!isMacControl(evt)
				&& (ch < 0x20 || ch == 0x7f || ch == 0xff)
				&& ch != '\b' && ch != '\t' && ch != '\n')
			{
				return null;
			}

			if(Debug.DUMP_KEY_EVENTS)
			{
				Log.log(Log.DEBUG,""KEWa"",""Key event (working around): ""
					+ AbstractInputHandler.toString(evt)+"": last=""+last+""."");
			}

			if(!Debug.ALTERNATIVE_DISPATCHER)
			{
				if(((modifiers & InputEvent.CTRL_MASK) != 0
					^ (modifiers & InputEvent.ALT_MASK) != 0)
					|| (modifiers & InputEvent.META_MASK) != 0)
				{
					return null;
				}
			}

			
			
			if(last == LAST_NUMKEYPAD)
			{
				last = LAST_NOTHING;
				if((ch >= '0' && ch <= '9') || ch == '.'
					|| ch == '/' || ch == '*'
					|| ch == '-' || ch == '+')
				{
					return null;
				}
			}
			
			else if(last == LAST_ALT)
			{
				last = LAST_NOTHING;
				switch(ch)
				{
				case 'B':
				case 'M':
				case 'X':
				case 'c':
				case '!':
				case ',':
				case '?':
					return null;
				}
			}
			break;
		
		
		case KeyEvent.KEY_RELEASED:
			switch(keyCode)
			{
			case KeyEvent.VK_ALT:
				
				
				
				evt.consume();
				break;
			case KeyEvent.VK_ALT_GRAPH:
			case KeyEvent.VK_CONTROL:
			case KeyEvent.VK_SHIFT:
			case KeyEvent.VK_META:
				break;
			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
			case KeyEvent.VK_PAGE_UP:
			case KeyEvent.VK_PAGE_DOWN:
			case KeyEvent.VK_END:
			case KeyEvent.VK_HOME:
				
				if(modifiers == InputEvent.ALT_MASK)
					last = LAST_ALT;
				break;
			}
			break;
		
		}
		return evt;
	} 

	
	
	public static void numericKeypadKey()
	{
		last = LAST_NOTHING;
	} 

	
	private static int last;
	private static final int LAST_NOTHING = 0;
	private static final int LAST_NUMKEYPAD = 1;
	private static final int LAST_ALT = 2;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.EditPane,39,5,0,79,244,231,46,48,30,0.702631579,1783,1.0,8,0.945007236,0.118343195,1,2,44.46153846,27,4.0513,1,"

package org.gjt.sp.jedit;


import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.util.HashMap;
import java.util.Map;

import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.bufferset.BufferSet;
import org.gjt.sp.jedit.bufferset.BufferSetListener;
import org.gjt.sp.jedit.bufferset.BufferSetManager;
import org.gjt.sp.jedit.gui.BufferSwitcher;
import org.gjt.sp.jedit.gui.StatusBar;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.BufferChanging;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.msg.EditPaneUpdate;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.options.GutterOptionPane;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.textarea.AntiAlias;
import org.gjt.sp.jedit.textarea.Gutter;
import org.gjt.sp.jedit.textarea.GutterPopupHandler;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.textarea.MouseHandler;
import org.gjt.sp.jedit.textarea.Selection;
import org.gjt.sp.jedit.textarea.StatusListener;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.jedit.textarea.TextAreaExtension;
import org.gjt.sp.jedit.textarea.TextAreaPainter;
import org.gjt.sp.jedit.textarea.TextAreaTransferHandler;
import org.gjt.sp.util.SyntaxUtilities;




public class EditPane extends JPanel implements EBComponent, BufferSetListener
{
	
	
	public View getView()
	{
		return view;
	} 

	
	
	public static EditPane get(TextArea ta)
	{
		if (ta == null) return null;
		return (EditPane)SwingUtilities.getAncestorOfClass(EditPane.class, ta);
	} 

	
	
	public Buffer getBuffer()
	{
		return buffer;
	} 

	
	
	public void setBuffer(Buffer buffer)
	{
		setBuffer(buffer, true);
	}

	
	public void setBuffer(final Buffer buffer, boolean requestFocus)
	{

		if(buffer == null)
			throw new NullPointerException();

		if(this.buffer == buffer)
			return;

		if (bufferSet.indexOf(buffer) == -1)
		{
			jEdit.getBufferSetManager().addBuffer(this, buffer);
		}
		
		
		EditBus.send(new BufferChanging(this, buffer));
		if (bufferSet.indexOf(this.buffer) != -1)
		{
			
			
			
			recentBuffer = this.buffer;
		}
		if(recentBuffer != null)
			saveCaretInfo();
		this.buffer = buffer;

		textArea.setBuffer(buffer);

		if(!init)
		{
			view.updateTitle();

			if(bufferSwitcher != null)
			{
				if(bufferSwitcher.getSelectedItem() != buffer)
					bufferSwitcher.setSelectedItem(buffer);
				bufferSwitcher.setToolTipText(buffer.getPath());
			}

			EditBus.send(new EditPaneUpdate(this,EditPaneUpdate
				.BUFFER_CHANGED));
		}

		if (requestFocus)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					
					if(view.getEditPane() == EditPane.this
						&& (bufferSwitcher == null
						|| !bufferSwitcher.isPopupVisible()))
					{
						textArea.requestFocus();
					}
				}
			});
		}

		
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				
				
				if(buffer == getBuffer())
					loadCaretInfo();
			}
		};

		if(buffer.isPerformingIO())
			VFSManager.runInAWTThread(runnable);
		else
			runnable.run();
	} 

	
	
	public void prevBuffer()
	{
		Buffer buffer = bufferSet.getPreviousBuffer(bufferSet.indexOf(this.buffer));
		setBuffer(buffer);
	} 

	
	
	public void nextBuffer()
	{
		Buffer buffer = bufferSet.getNextBuffer(bufferSet.indexOf(this.buffer));
		setBuffer(buffer);
	} 

	
	
	public void recentBuffer()
	{
		if(recentBuffer != null)
			setBuffer(recentBuffer);
		else
			getToolkit().beep();
	} 

	
	
	public void focusOnTextArea()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				textArea.requestFocus();
			}
		});
	} 

	
	
	public JEditTextArea getTextArea()
	{
		return textArea;
	} 

	
	
	public BufferSwitcher getBufferSwitcher()
	{
		return bufferSwitcher;
	} 

	
	
	public void focusBufferSwitcher()
	{
		if(bufferSwitcher == null)
			getToolkit().beep();
		else
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					bufferSwitcher.requestFocus();
					bufferSwitcher.showPopup();
				}

			});
		}
	} 

	
	
	public void saveCaretInfo()
	{
		if(!buffer.isLoaded())
			return;

		buffer.setIntegerProperty(Buffer.CARET,
			textArea.getCaretPosition());

		CaretInfo caretInfo = caretsForPath.get(buffer.getPath());
		if (caretInfo == null)
		{
			caretInfo = new CaretInfo();
			caretsForPath.put(buffer.getPath(), caretInfo);
		}
		caretInfo.caret = textArea.getCaretPosition();


		Selection[] selection = textArea.getSelection();
		for(int i = 0; i < selection.length; i++)
			selection[i] = (Selection)selection[i].clone();
		buffer.setProperty(Buffer.SELECTION,selection);
		caretInfo.selection = selection;

		caretInfo.rectangularSelection = textArea.isRectangularSelectionEnabled();
		caretInfo.multipleSelection = textArea.isMultipleSelectionEnabled();

		buffer.setIntegerProperty(Buffer.SCROLL_VERT,
			textArea.getFirstPhysicalLine());
		caretInfo.scrollVert = textArea.getFirstPhysicalLine();
		buffer.setIntegerProperty(Buffer.SCROLL_HORIZ,
			textArea.getHorizontalOffset());
		caretInfo.scrollHoriz = textArea.getHorizontalOffset();
		if (!buffer.isUntitled())
		{
			BufferHistory.setEntry(buffer.getPath(), textArea.getCaretPosition(),
				(Selection[])buffer.getProperty(Buffer.SELECTION),
				buffer.getStringProperty(JEditBuffer.ENCODING),
				buffer.getMode().getName());
		}
	} 

	
	
	public void loadCaretInfo()
	{
		
		
		CaretInfo caretInfo = caretsForPath.get(buffer.getPath());
		if (caretInfo == null)
		{
			caretInfo = new CaretInfo();
		}

		
		
		
		
		
		int caret = caretInfo.caret;
		if (caret == -1 || buffer.getBooleanProperty(Buffer.CARET_POSITIONED))
		{
			Integer i = (Integer) buffer.getProperty(Buffer.CARET);
			caret = i == null ? -1 : i;
		}
		buffer.unsetProperty(Buffer.CARET_POSITIONED);


		if(caret != -1)
			textArea.setCaretPosition(Math.min(caret,
				buffer.getLength()));

		
		Selection[] selection = caretInfo.selection;
		if ( selection == null )
		{
			selection = (Selection[]) buffer.getProperty(Buffer.SELECTION);
		}
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				int max = buffer.getLength();
				if(s.getStart() > max || s.getEnd() > max)
					selection[i] = null;
			}
		}
		textArea.setSelection(selection);
		textArea.setRectangularSelectionEnabled(caretInfo.rectangularSelection);
		textArea.setMultipleSelectionEnabled(caretInfo.multipleSelection);
		
		int firstLine = caretInfo.scrollVert;
		if ( firstLine == -1 )
		{
			Integer i = (Integer) buffer.getProperty(Buffer.SCROLL_VERT);
			firstLine = i == null ? -1 : i;
		}

		if(firstLine != -1)
			textArea.setFirstPhysicalLine(firstLine);

		
		int horizontalOffset = caretInfo.scrollHoriz;
		if (horizontalOffset == -1)
		{
			Integer i = (Integer) buffer.getProperty(Buffer.SCROLL_HORIZ);
			horizontalOffset = i == null ? -1 : i;
		}

		if(horizontalOffset != -1)
			textArea.setHorizontalOffset(horizontalOffset);

		
		view.getStatus().setMessage(null);
	} 

	
	
	void bufferRenamed(String oldPath, String newPath)
	{
		CaretInfo caretInfo = caretsForPath.remove(oldPath);
		if (caretInfo != null)
			caretsForPath.put(newPath, caretInfo);

	} 

	
	
	private static class CaretInfo
	{
		public int caret = -1;
		public Selection[] selection;
		public int scrollVert = -1;
		public int scrollHoriz = -1;
		public boolean rectangularSelection;
		public boolean multipleSelection;
	} 

	
	
	public void goToNextMarker(boolean select)
	{
		java.util.List<Marker> markers = buffer.getMarkers();
		if(markers.isEmpty())
		{
			getToolkit().beep();
			return;
		}

		Marker marker = null;

		int caret = textArea.getCaretPosition();

		for(int i = 0; i < markers.size(); i++)
		{
			Marker _marker = markers.get(i);
			if(_marker.getPosition() > caret)
			{
				marker = _marker;
				break;
			}
		}
		
		if(marker == null)
			marker = markers.get(0);

		if(select)
			textArea.extendSelection(caret,marker.getPosition());
		else if(!textArea.isMultipleSelectionEnabled())
			textArea.selectNone();
		textArea.moveCaretPosition(marker.getPosition());
	} 

	
	
	public void goToPrevMarker(boolean select)
	{
		java.util.List<Marker> markers = buffer.getMarkers();
		if(markers.isEmpty())
		{
			getToolkit().beep();
			return;
		}

		int caret = textArea.getCaretPosition();

		Marker marker = null;
		for(int i = markers.size() - 1; i >= 0; i--)
		{
			Marker _marker = markers.get(i);
			if(_marker.getPosition() < caret)
			{
				marker = _marker;
				break;
			}
		}

		if(marker == null)
			marker = markers.get(markers.size() - 1);

		if(select)
			textArea.extendSelection(caret,marker.getPosition());
		else if(!textArea.isMultipleSelectionEnabled())
			textArea.selectNone();
		textArea.moveCaretPosition(marker.getPosition());
	} 

	
	
	public void goToMarker(char shortcut, boolean select)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}

		int pos = marker.getPosition();

		if(select)
			textArea.extendSelection(textArea.getCaretPosition(),pos);
		else if(!textArea.isMultipleSelectionEnabled())
			textArea.selectNone();
		textArea.moveCaretPosition(pos);
	} 

	
	
	public void addMarker()
	{
		int caretLine = textArea.getCaretLine();

		
		Selection[] selection = textArea.getSelection();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			int startLine = s.getStartLine();
			if(startLine != s.getEndLine() && startLine != caretLine)
			{
				buffer.addMarker('\0',s.getStart());
			}

			if(s.getEndLine() != caretLine)
				buffer.addMarker('\0',s.getEnd());
		}

		
		buffer.addOrRemoveMarker('\0',textArea.getCaretPosition());
	} 

	
	
	public void swapMarkerAndCaret(char shortcut)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}

		int caret = textArea.getCaretPosition();

		textArea.setCaretPosition(marker.getPosition());
		buffer.addMarker(shortcut,caret);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
		{
			propertiesChanged();
			loadBufferSwitcher();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
	} 

	
	
	@Override
	public final Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	
	
	public BufferSet getBufferSet()
	{
		return bufferSet;
	} 

	
	
	public BufferSet.Scope getBufferSetScope()
	{
		return bufferSetScope;
	} 

	
	
	public void setBufferSetScope(BufferSet.Scope scope)
	{
		if (this.bufferSetScope != scope)
		{
			BufferSet oldBufferSet = this.bufferSet;
			BufferSet newBufferSet;
			switch (scope)
			{
				case editpane:
					newBufferSet = new BufferSet();
					break;
				case view:
					newBufferSet = view.getLocalBufferSet();
					break;
				default:
					scope = BufferSet.Scope.global;
				case global:
					newBufferSet = jEdit.getGlobalBufferSet();
					break;
			}

			BufferSetManager bufferSetManager = jEdit.getBufferSetManager();

			if (jEdit.isStartupDone())	
			{
				String action = jEdit.getProperty(""editpane.bufferset.new"");
				BufferSetManager.NewBufferSetAction bufferSetAction = BufferSetManager.NewBufferSetAction.fromString(action);
				View activeView = jEdit.getActiveView();
				switch (bufferSetAction)
				{
					case copy:
						if (oldBufferSet == null)
						{
							EditPane editPane = view.getEditPane();
							if (editPane == null)
							{
								if (activeView != null)
									editPane = activeView.getEditPane();

							}
							if (editPane == null)
							{
								bufferSetManager.addAllBuffers(newBufferSet);
							}
							else
							{
								bufferSetManager.mergeBufferSet(newBufferSet, editPane.bufferSet);
							}
						}
						else
							bufferSetManager.mergeBufferSet(newBufferSet, oldBufferSet);
						break;
					case empty:
						break;
					case currentbuffer:
						if (activeView == null)
							break;
						EditPane editPane = activeView.getEditPane();
						Buffer buffer = editPane.getBuffer();
						bufferSetManager.addBuffer(newBufferSet,buffer);
						break;
				}
			}
			if (buffer != null)
				bufferSetManager.addBuffer(newBufferSet, buffer);


			this.bufferSet = newBufferSet;
			this.bufferSetScope = scope;
			if (newBufferSet.size() == 0)
			{
				jEdit.newFile(this);
			}

			
			
			
			if (oldBufferSet != null)
			{
				oldBufferSet.removeBufferSetListener(this);
			}

			newBufferSet.addBufferSetListener(this);
			if (bufferSwitcher != null)
			{
				bufferSwitcher.updateBufferList();
			}
			EditBus.send(new EditPaneUpdate(this, EditPaneUpdate.BUFFERSET_CHANGED));
			if (newBufferSet.indexOf(recentBuffer) == -1)
			{
				
				recentBuffer =  null;
			}
			if (newBufferSet.indexOf(buffer) == -1)
			{
				
				if (recentBuffer != null)
					setBuffer(recentBuffer);
				else
				{
					setBuffer(newBufferSet.getBuffer(0));
				}
			}
			if (jEdit.isStartupDone())	
				PerspectiveManager.setPerspectiveDirty(true);
		}
	} 

	
	
	public void bufferAdded(Buffer buffer, int index)
	{
		if (buffer == null)
			return;
		if (bufferSwitcher != null)
			bufferSwitcher.updateBufferList();
		if (bufferSet.indexOf(this.buffer) == -1)
		{
			
			
			setBuffer(buffer);
		}
	} 

	
	
	public void bufferRemoved(Buffer buffer, int index)
	{
		if (buffer.isUntitled())
		{
			
			caretsForPath.remove(buffer.getPath());
		}
		if (buffer == this.buffer)
		{
			
			Buffer newBuffer = recentBuffer != null ?
				recentBuffer : bufferSet.getPreviousBuffer(index);

			if(newBuffer != null && !newBuffer.isClosed())
			{
				setBuffer(newBuffer);
				if (bufferSet.size() > 1)
				{
					recentBuffer = bufferSet.getPreviousBuffer(index -1);
				}
			}
			else if(bufferSet.size() != 0)
			{
				setBuffer(bufferSet.getBuffer(0));
				recentBuffer = null;
			}
		}
		if(buffer == recentBuffer)
			recentBuffer = null;
		if (bufferSwitcher != null)
			bufferSwitcher.updateBufferList();
	} 

	
	
	public void bufferMoved(Buffer buffer, int oldIndex, int newIndex)
	{
		if (bufferSwitcher != null)
			bufferSwitcher.updateBufferList();
	} 

	
	
	public void bufferSetSorted()
	{
		if (bufferSwitcher != null)
			bufferSwitcher.updateBufferList();
	} 

	
	@Override
	public String toString()
	{
		return getClass().getName() + '['
			+ (view.getEditPane() == this
			? ""active"" : ""inactive"")
			+ ',' + bufferSetScope + ']';
	} 

	

	
	EditPane(View view, Buffer buffer, BufferSet.Scope scope)
	{
		super(new BorderLayout());

		init = true;

		this.view = view;


		textArea = new JEditTextArea(view);
		textArea.getPainter().setAntiAlias(new AntiAlias(jEdit.getProperty(""view.antiAlias"")));
		textArea.setMouseHandler(new MouseHandler(textArea));
		textArea.setTransferHandler(new TextAreaTransferHandler());
		markerHighlight = new MarkerHighlight();
		Gutter gutter = textArea.getGutter();
		gutter.setGutterEnabled(GutterOptionPane.isGutterEnabled());
		gutter.setMinLineNumberDigitCount(GutterOptionPane.getMinLineNumberDigits());
		gutter.setSelectionAreaEnabled(GutterOptionPane.isSelectionAreaEnabled());
		gutter.addExtension(markerHighlight);
		gutter.setSelectionPopupHandler(
			new GutterPopupHandler()
			{
				public void handlePopup(int x, int y, int line)
				{
					Buffer buffer = getBuffer();
					buffer.addOrRemoveMarker('\0',
						buffer.getLineStartOffset(line));
				}
			});

		textArea.addStatusListener(new StatusHandler());
		add(BorderLayout.CENTER,textArea);

		propertiesChanged();
		this.buffer = buffer;
		setBufferSetScope(scope);
		this.buffer = null;
		if(buffer == null)
		{
			setBuffer(jEdit.getFirstBuffer());
		}
		else
			setBuffer(buffer);

		loadBufferSwitcher();

		init = false;
		EditBus.addToBus(this);
	} 

	
	void close()
	{
		saveCaretInfo();
		EditBus.send(new EditPaneUpdate(this,EditPaneUpdate.DESTROYED));
		bufferSet.removeBufferSetListener(this);
		EditBus.removeFromBus(this);
		textArea.dispose();
	} 


	

	

	
	private boolean init;
	
	private final View view;

	private BufferSet bufferSet;
	private BufferSet.Scope bufferSetScope;

	
	private Buffer buffer;
	private Buffer recentBuffer;
	private BufferSwitcher bufferSwitcher;

	
	private final JEditTextArea textArea;
	private final MarkerHighlight markerHighlight;

	
	
	
	
	
	private final Map<String, CaretInfo> caretsForPath = new HashMap<String, CaretInfo>();

	

	
	private void propertiesChanged()
	{
		TextAreaPainter painter = textArea.getPainter();

		initPainter(painter);
		Gutter gutter = textArea.getGutter();
		gutter.setExpanded(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		int interval = jEdit.getIntegerProperty(
			""view.gutter.highlightInterval"",5);
		gutter.setHighlightInterval(interval);
		gutter.setCurrentLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		gutter.setStructureHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.structureHighlight""));
		gutter.setStructureHighlightColor(
			jEdit.getColorProperty(""view.gutter.structureHighlightColor""));
		gutter.setBackground(
			jEdit.getColorProperty(""view.gutter.bgColor""));
		gutter.setForeground(
			jEdit.getColorProperty(""view.gutter.fgColor""));
		gutter.setHighlightedForeground(
			jEdit.getColorProperty(""view.gutter.highlightColor""));
		gutter.setFoldColor(
			jEdit.getColorProperty(""view.gutter.foldColor""));
		markerHighlight.setMarkerHighlightColor(
			jEdit.getColorProperty(""view.gutter.markerColor""));
		markerHighlight.setMarkerHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		gutter.setCurrentLineForeground(
			jEdit.getColorProperty(""view.gutter.currentLineColor""));
		String alignment = jEdit.getProperty(
			""view.gutter.numberAlignment"");
		if (""right"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.RIGHT);
		}
		else if (""center"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.CENTER);
		}
		else 
		{
			gutter.setLineNumberAlignment(Gutter.LEFT);
		}

		gutter.setFont(jEdit.getFontProperty(""view.gutter.font""));
		gutter.setGutterEnabled(GutterOptionPane.isGutterEnabled());
		gutter.setMinLineNumberDigitCount(
			GutterOptionPane.getMinLineNumberDigits());
		gutter.setSelectionAreaEnabled(
			GutterOptionPane.isSelectionAreaEnabled());
		gutter.setSelectionAreaBackground(
			GutterOptionPane.getSelectionAreaBackground());
		gutter.setSelectionAreaWidth(
				GutterOptionPane.getSelectionAreaWidth());

		int width = jEdit.getIntegerProperty(
			""view.gutter.borderWidth"",3);
		gutter.setBorder(width,
			jEdit.getColorProperty(""view.gutter.focusBorderColor""),
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor""),
			textArea.getPainter().getBackground());
		gutter.setFoldPainter(textArea.getFoldPainter());

		textArea.setCaretBlinkEnabled(jEdit.getBooleanProperty(
			""view.caretBlink""));

		textArea.setElectricScroll(jEdit.getIntegerProperty(
			""view.electricBorders"",0));

		
		textArea.createPopupMenu(null);

		
		textArea.setQuickCopyEnabled(jEdit.getBooleanProperty(
			""view.middleMousePaste""));

		textArea.setDragEnabled(jEdit.getBooleanProperty(
			""view.dragAndDrop""));

		textArea.setJoinNonWordChars(jEdit.getBooleanProperty(
			""view.joinNonWordChars""));

		textArea.setCtrlForRectangularSelection(jEdit.getBooleanProperty(
			""view.ctrlForRectangularSelection""));

		textArea.propertiesChanged();

		if (bufferSwitcher != null)
		{
			bufferSwitcher.setMaximumRowCount(jEdit.getIntegerProperty(
				""bufferSwitcher.maxRowCount"",10));
		}
	} 

	
	
	public static void initPainter(TextAreaPainter painter)
	{
		painter.setFont(jEdit.getFontProperty(""view.font""));
		painter.setStructureHighlightEnabled(jEdit.getBooleanProperty(
			""view.structureHighlight""));
		painter.setStructureHighlightColor(
			jEdit.getColorProperty(""view.structureHighlightColor""));
		painter.setEOLMarkersPainted(jEdit.getBooleanProperty(
			""view.eolMarkers""));
		painter.setEOLMarkerColor(
			jEdit.getColorProperty(""view.eolMarkerColor""));
		painter.setWrapGuidePainted(jEdit.getBooleanProperty(
			""view.wrapGuide""));
		painter.setWrapGuideColor(
			jEdit.getColorProperty(""view.wrapGuideColor""));
		painter.setCaretColor(
			jEdit.getColorProperty(""view.caretColor""));
		painter.setSelectionColor(
			jEdit.getColorProperty(""view.selectionColor""));
		painter.setMultipleSelectionColor(
			jEdit.getColorProperty(""view.multipleSelectionColor""));
		painter.setBackground(
			jEdit.getColorProperty(""view.bgColor""));
		painter.setForeground(
			jEdit.getColorProperty(""view.fgColor""));
		painter.setBlockCaretEnabled(jEdit.getBooleanProperty(
			""view.blockCaret""));
		painter.setThickCaretEnabled(jEdit.getBooleanProperty(
			""view.thickCaret""));
		painter.setLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.lineHighlight""));
		painter.setLineHighlightColor(
			jEdit.getColorProperty(""view.lineHighlightColor""));
		painter.setAntiAlias(new AntiAlias(jEdit.getProperty(""view.antiAlias"")));
		painter.setFractionalFontMetricsEnabled(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));

		String defaultFont = jEdit.getProperty(""view.font"");
		int defaultFontSize = jEdit.getIntegerProperty(""view.fontsize"",12);
		painter.setStyles(SyntaxUtilities.loadStyles(defaultFont,defaultFontSize));

		SyntaxStyle[] foldLineStyle = new SyntaxStyle[4];
		for(int i = 0; i <= 3; i++)
		{
			foldLineStyle[i] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.foldLine."" + i),
				defaultFont,defaultFontSize);
		}
		painter.setFoldLineStyle(foldLineStyle);
	} 

	
	void loadBufferSwitcher()
	{
		if(jEdit.getBooleanProperty(""view.showBufferSwitcher""))
		{
			if(bufferSwitcher == null)
			{
				bufferSwitcher = new BufferSwitcher(this);
				add(BorderLayout.NORTH,bufferSwitcher);
				bufferSwitcher.updateBufferList();
				revalidate();
			}
		}
		else if(bufferSwitcher != null)
		{
			remove(bufferSwitcher);
			revalidate();
			bufferSwitcher = null;
		}
	} 

	
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer _buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.CREATED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();

			
			if(buffer.isClosed())
			{
				
				
				recentBuffer = null;
			}
		}
		else if(msg.getWhat() == BufferUpdate.CLOSED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();

			if(_buffer == buffer)
			{
				
				Buffer newBuffer = recentBuffer != null ?
					recentBuffer : _buffer.getPrev();

				if(newBuffer != null && !newBuffer.isClosed())
				{
					setBuffer(newBuffer);
					recentBuffer = newBuffer.getPrev();
				}
			}
			else if(_buffer == recentBuffer)
				recentBuffer = null;

			Buffer closedBuffer = msg.getBuffer();
			if (closedBuffer.isUntitled())
			{
				
				caretsForPath.remove(closedBuffer.getPath());
			}
		}
		else if(msg.getWhat() == BufferUpdate.LOAD_STARTED)
		{
			if(_buffer == buffer)
			{
				textArea.setCaretPosition(0);
				textArea.getPainter().repaint();
			}
		}
		else if(msg.getWhat() == BufferUpdate.LOADED)
		{
			if(_buffer == buffer)
			{
				textArea.repaint();
				if(bufferSwitcher != null)
					bufferSwitcher.updateBufferList();

				if(view.getEditPane() == this)
				{
					StatusBar status = view.getStatus();
					status.updateCaretStatus();
					status.updateBufferStatus();
					status.updateMiscStatus();
				}

				loadCaretInfo();
			}

		}
		else if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(_buffer == buffer && bufferSwitcher != null)
			{
				if(buffer.isDirty())
					bufferSwitcher.repaint();
				else
					bufferSwitcher.updateBufferList();
			}
		}
		else if(msg.getWhat() == BufferUpdate.MARKERS_CHANGED)
		{
			if(_buffer == buffer)
				textArea.getGutter().repaint();
		}
		else if(msg.getWhat() == BufferUpdate.PROPERTIES_CHANGED)
		{
			if(_buffer == buffer && buffer.isLoaded())
			{
				textArea.propertiesChanged();
				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.SAVED && _buffer == buffer)
		{
			textArea.propertiesChanged();
		}
	} 

	

	
	class StatusHandler implements StatusListener
	{
		public void statusChanged(org.gjt.sp.jedit.textarea.TextArea textArea, int flag, boolean value)
		{
			StatusBar status = view.getStatus();
			if(status == null)
				return;

			switch(flag)
			{
			case OVERWRITE_CHANGED:
				status.setMessageAndClear(
					jEdit.getProperty(""view.status.overwrite-changed"",
					new Integer[] { value ? 1 : 0 }));
				break;
			case MULTI_SELECT_CHANGED:
				status.setMessageAndClear(
					jEdit.getProperty(""view.status.multi-changed"",
					new Integer[] { value ? 1 : 0 }));
				break;
			case RECT_SELECT_CHANGED:
				status.setMessageAndClear(
					jEdit.getProperty(""view.status.rect-select-changed"",
					new Integer[] { value ? 1 : 0 }));
				break;
			}

			status.updateMiscStatus();
		}

		public void bracketSelected(org.gjt.sp.jedit.textarea.TextArea textArea, int line, String text)
		{
			StatusBar status = view.getStatus();
			if(status == null)
				return;

			status.setMessageAndClear(jEdit.getProperty(
				""view.status.bracket"",new Object[] {
				line, text }));
		}

		public void narrowActive(org.gjt.sp.jedit.textarea.TextArea textArea)
		{
			StatusBar status = view.getStatus();
			if(status == null)
				return;

			status.setMessageAndClear(
				jEdit.getProperty(""view.status.narrow""));
		}
	} 

	
	class MarkerHighlight extends TextAreaExtension
	{
		private boolean markerHighlight;
		private Color markerHighlightColor;

		
		public Color getMarkerHighlightColor()
		{
			return markerHighlightColor;
		} 

		
		public void setMarkerHighlightColor(Color markerHighlightColor)
		{
			this.markerHighlightColor = markerHighlightColor;
		} 

		
		public boolean isMarkerHighlightEnabled()
		{
			return markerHighlight;
		} 

		
		public void setMarkerHighlightEnabled(boolean markerHighlight)
		{
			this.markerHighlight = markerHighlight;
		} 

		
		@Override
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				Buffer buffer = (Buffer)textArea.getBuffer();
				if(buffer.getMarkerInRange(start,end) != null)
				{
					gfx.setColor(getMarkerHighlightColor());
					FontMetrics fm = textArea.getPainter().getFontMetrics();
					gfx.fillRect(0,y,textArea.getGutter()
						.getWidth(),fm.getHeight());
				}
			}
		} 

		
		@Override
		public String getToolTipText(int x, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				int lineHeight = textArea.getPainter().getFontMetrics().getHeight();
				if(lineHeight == 0)
					return null;

				int line = y / lineHeight;
				int start = textArea.getScreenLineStartOffset(line);
				int end = textArea.getScreenLineEndOffset(line);
				if(start == -1 || end == -1)
					return null;

				Buffer buffer = (Buffer)textArea.getBuffer();
				Marker marker = buffer.getMarkerInRange(start,end);
				if(marker != null)
				{
					char shortcut = marker.getShortcut();
					if(shortcut == '\0')
						return jEdit.getProperty(""view.gutter.marker.no-name"");
					else
					{
						String[] args = { String.valueOf(shortcut) };
						return jEdit.getProperty(""view.gutter.marker"",args);
					}
				}
			}

			return null;
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.FilesChangedDialog,16,7,0,8,91,82,3,8,3,0.777777778,780,1.0,1,0.977645306,0.21875,2,2,47.1875,13,2.125,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;



public class FilesChangedDialog extends EnhancedDialog
{
	
	public FilesChangedDialog(View view, int[] states,
		boolean alreadyReloaded)
	{
		super(view,jEdit.getProperty(""files-changed.title""),false);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.warningIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(jEdit.getProperty(""files-changed.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		DefaultMutableTreeNode deleted = new DefaultMutableTreeNode(
			jEdit.getProperty(""files-changed.deleted""),true);
		DefaultMutableTreeNode changed = new DefaultMutableTreeNode(
			jEdit.getProperty(""files-changed.changed""
			+ (alreadyReloaded ? ""-auto"" : """")),true);
		DefaultMutableTreeNode changedDirty = new DefaultMutableTreeNode(
			jEdit.getProperty(""files-changed.changed-dirty""
			+ (alreadyReloaded ? ""-auto"" : """")),true);
		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < states.length; i++)
		{
			Buffer buffer = buffers[i];
			DefaultMutableTreeNode addTo;
			switch(states[i])
			{
			case Buffer.FILE_DELETED:
				addTo = deleted;
				break;
			case Buffer.FILE_CHANGED:
				addTo = buffer.isDirty() ? changedDirty : changed;
				break;
			default:
				addTo = null;
				break;
			}

			if(addTo != null)
			{
				addTo.add(new DefaultMutableTreeNode(
					buffer.getPath()));
			}
		}

		root = new DefaultMutableTreeNode("""",true);
		if(deleted.getChildCount() != 0)
		{
			root.add(deleted);
		}
		if(changed.getChildCount() != 0)
		{
			root.add(changed);
		}
		if(changedDirty.getChildCount() != 0)
		{
			root.add(changedDirty);
		}

		bufferTreeModel = new DefaultTreeModel(root);
		bufferTree = new JTree(bufferTreeModel);
		bufferTree.setRootVisible(false);
		bufferTree.setVisibleRowCount(10);
		bufferTree.setCellRenderer(new Renderer());
		bufferTree.getSelectionModel().addTreeSelectionListener(new TreeHandler());
		bufferTree.getSelectionModel().setSelectionMode(
			TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);

		centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferTree));

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());

		if(!alreadyReloaded)
		{
			selectAll = new JButton(jEdit.getProperty(
				""files-changed.select-all""));
			selectAll.setMnemonic(jEdit.getProperty(
				""files-changed.select-all.mnemonic"").charAt(0));
			buttons.add(selectAll);
			selectAll.addActionListener(new ActionHandler());

			buttons.add(Box.createHorizontalStrut(12));

			reload = new JButton(jEdit.getProperty(
				""files-changed.reload""));
			reload.setMnemonic(jEdit.getProperty(
				""files-changed.reload.mnemonic"").charAt(0));
			buttons.add(reload);
			reload.addActionListener(new ActionHandler());

			buttons.add(Box.createHorizontalStrut(12));

			ignore = new JButton(jEdit.getProperty(""files-changed.ignore""));
			ignore.setMnemonic(jEdit.getProperty(
				""files-changed.ignore.mnemonic"").charAt(0));
			buttons.add(ignore);
			ignore.addActionListener(new ActionHandler());

			buttons.add(Box.createHorizontalStrut(12));
		}

		close = new JButton(jEdit.getProperty(""common.close""));
		getRootPane().setDefaultButton(close);
		buttons.add(close);
		close.addActionListener(new ActionHandler());

		buttons.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,buttons);

		bufferTree.expandPath(new TreePath(
			new Object[] {
				root,
				deleted
			}));
		bufferTree.expandPath(new TreePath(
			new Object[] {
				root,
				changed
			}));
		bufferTree.expandPath(new TreePath(
			new Object[] {
				root,
				changedDirty
			}));

		GUIUtilities.requestFocus(this,bufferTree);

		updateEnabled();

		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private View view;
	private JTree bufferTree;
	private DefaultTreeModel bufferTreeModel;
	private DefaultMutableTreeNode root;
	private JButton selectAll;

	
	private boolean selectAllInProgress;

	private JButton reload;
	private JButton ignore;
	private JButton close;

	
	private void updateEnabled()
	{
		TreePath[] paths = bufferTree
			.getSelectionPaths();
		boolean enabled = false;
		if(paths != null)
		{
			for(int i = 0; i < paths.length; i++)
			{
				Object[] path = paths[i].getPath();
				if(path.length == 3)
					enabled = true;
			}
		}

		if(reload != null)
			reload.setEnabled(enabled);

		if (ignore != null)
			ignore.setEnabled(enabled);
	} 

	
	private void selectAll()
	{
		selectAllInProgress = true;

		TreeNode[] path = new TreeNode[3];
		path[0] = root;
		for(int i = 0; i < root.getChildCount(); i++)
		{
			DefaultMutableTreeNode node =
				(DefaultMutableTreeNode)
				root.getChildAt(i);
			path[1] = node;
			for(int j = 0; j < node.getChildCount(); j++)
			{
				DefaultMutableTreeNode node2 =
					(DefaultMutableTreeNode)
					node.getChildAt(j);
				path[2] = node2;
				bufferTree.getSelectionModel()
					.addSelectionPath(
					new TreePath(path));
			}
		}

		selectAllInProgress = false;

		updateEnabled();
	} 

	
	private void action(String action)
	{
		TreePath[] paths = bufferTree
			.getSelectionPaths();
		if(paths == null || paths.length == 0)
			return;

		int row = bufferTree.getRowForPath(paths[0]);

		for(int i = 0; i < paths.length; i++)
		{
			TreePath path = paths[i];

			
			if(path.getPathCount() == 2)
				continue;

			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(!(node.getUserObject() instanceof String))
			{
				return;
			}

			Buffer buffer = jEdit.getBuffer(
				(String)node.getUserObject());
			if(buffer == null)
				return;

			if (""RELOAD"".equals(action))
				buffer.reload(view);
			else
			{
				buffer.setAutoReload(false);
				buffer.setAutoReloadDialog(false);
			}

			DefaultMutableTreeNode parent =
				(DefaultMutableTreeNode)
				node.getParent();
			parent.remove(node);
		}

		bufferTreeModel.reload(root);

		
		
		TreeNode[] nodes = { root, null };

		
		for(int j = 0; j < root.getChildCount(); j++)
		{
			DefaultMutableTreeNode node
				= (DefaultMutableTreeNode)
				root.getChildAt(j);
			if(root.getChildAt(j)
				.getChildCount() == 0)
			{
				root.remove(j);
				j--;
			}
			else
			{
				nodes[1] = node;
				bufferTree.expandPath(
					new TreePath(nodes));
			}
		}

		if(root.getChildCount() == 0)
			dispose();
		else
		{
			if(row >= bufferTree.getRowCount())
				row = bufferTree.getRowCount() - 1;
			TreePath path = bufferTree.getPathForRow(row);
			if(path.getPathCount() == 2)
			{
				
				bufferTree.setSelectionRow(row + 1);
			}
			else
				bufferTree.setSelectionPath(path);
		}
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
				selectAll();
			else if(source == reload)
				action(""RELOAD"");
			else if(source == close)
				dispose();
			else if (source == ignore)
				action(""IGNORE"");
		}
	} 

	
	class TreeHandler implements TreeSelectionListener
	{
		public void valueChanged(TreeSelectionEvent evt)
		{
			if(selectAllInProgress)
				return;

			updateEnabled();

			TreePath[] paths = bufferTree
				.getSelectionPaths();
			if(paths == null || paths.length == 0)
				return;
			TreePath path = paths[paths.length - 1];
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(node.getUserObject() instanceof String)
			{
				Buffer buffer = jEdit.getBuffer(
					(String)node.getUserObject());
				if(buffer != null)
					view.showBuffer(buffer);
			}
		}
	} 

	
	static class Renderer extends DefaultTreeCellRenderer
	{
		Renderer()
		{
			entryFont = UIManager.getFont(""Tree.font"");
			if(entryFont == null)
				entryFont = jEdit.getFontProperty(""metal.secondary.font"");
			groupFont = entryFont.deriveFont(Font.BOLD);
		}

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);

			DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;

			if(node.getParent() == tree.getModel().getRoot())
				setFont(groupFont);
			else
				setFont(entryFont);

			setIcon(null);

			return this;
		}

		private Font entryFont;
		private Font groupFont;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.search.CurrentBufferSet,6,1,0,6,9,15,4,3,6,2.0,34,0.0,0,0.0,0.611111111,0,0,4.666666667,2,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.*;


public class CurrentBufferSet implements SearchFileSet
{
	
	public String getFirstFile(View view)
	{
		return view.getBuffer().getPath();
	} 

	
	public String getNextFile(View view, String file)
	{
		if(file == null)
			return view.getBuffer().getPath();
		else
			return null;
	} 

	
	public String[] getFiles(View view)
	{
		return new String[] { view.getBuffer().getPath() };
	} 

	
	public int getFileCount(View view)
	{
		return 1;
	} 

	
	public String getCode()
	{
		return ""new CurrentBufferSet()"";
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHArrayDimensions,5,2,0,10,21,4,2,8,4,0.625,187,0.0,0,0.80952381,0.44,1,1,35.6,1,0.8,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Array;


class BSHArrayDimensions extends SimpleNode
{
	public Class baseType;
    public int numDefinedDims;
    public int numUndefinedDims;
	
	public int [] definedDimensions;  

    BSHArrayDimensions(int id) { super(id); }

    public void addDefinedDimension() { numDefinedDims++; }
    public void addUndefinedDimension() { numUndefinedDims++; }

    public Object eval( 
			Class type, CallStack callstack, Interpreter interpreter ) 
		throws EvalError 
	{
		if ( Interpreter.DEBUG ) Interpreter.debug(""array base type = ""+type);
		baseType = type;
		return eval( callstack, interpreter );
	}

	
    public Object eval( CallStack callstack, Interpreter interpreter )  
		throws EvalError
    {
		SimpleNode child = (SimpleNode)jjtGetChild(0);

		
		if (child instanceof BSHArrayInitializer)
		{
			if ( baseType == null )
				throw new EvalError( 
					""Internal Array Eval err:  unknown base type"", 
					this, callstack );

			Object initValue = ((BSHArrayInitializer)child).eval(
				baseType, numUndefinedDims, callstack, interpreter);

			Class arrayClass = initValue.getClass();
			int actualDimensions = Reflect.getArrayDimensions(arrayClass);
			definedDimensions = new int[ actualDimensions ];

			
			
			if ( definedDimensions.length != numUndefinedDims )
				throw new EvalError(
				""Incompatible initializer. Allocation calls for a "" + 
				numUndefinedDims+ "" dimensional array, but initializer is a "" +
					actualDimensions + "" dimensional array"", this, callstack );

			
			Object arraySlice = initValue;
			for ( int i = 0; i < definedDimensions.length; i++ ) {
				definedDimensions[i] = Array.getLength( arraySlice );
				if ( definedDimensions[i] > 0 )
					arraySlice = Array.get(arraySlice, 0);
			}

			return initValue;
		}
		else 
		
		{
			definedDimensions = new int[ numDefinedDims ];

			for(int i = 0; i < numDefinedDims; i++)
			{
				try {
					Object length = ((SimpleNode)jjtGetChild(i)).eval(
						callstack, interpreter);
					definedDimensions[i] = ((Primitive)length).intValue();
				}
				catch(Exception e)
				{
					throw new EvalError(
						""Array index: "" + i + 
						"" does not evaluate to an integer"", this, callstack );
				}
			}
		}

        return Primitive.VOID;
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableWindowManagerImpl,31,6,0,35,121,283,16,29,25,0.824242424,1546,0.727272727,5,0.958677686,0.108870968,5,19,48.51612903,13,3.3548,0,"

package org.gjt.sp.jedit.gui;


import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;

import javax.swing.AbstractButton;
import javax.swing.JComponent;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.PluginJAR;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View.ViewConfig;
import org.gjt.sp.jedit.msg.DockableWindowUpdate;
import org.gjt.sp.jedit.msg.PluginUpdate;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.IOUtilities;
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;



public class DockableWindowManagerImpl extends DockableWindowManager
{
	
	
	public static class DockableWindowConfig extends DockingLayout
	{
		
		public class PerspectiveHandler extends DefaultHandler
		{
			public void startElement(String uri, String localName,
					 String qName, Attributes attrs)
			{
				for (int i = 0; i < attrs.getLength(); i++)
					attribute(attrs.getQName(i), attrs.getValue(i));
			}

			private void attribute(String aname, String value)
			{
				if(aname.equals(""TOP""))
					top = value;
				else if(aname.equals(""LEFT""))
					left = value;
				else if(aname.equals(""BOTTOM""))
					bottom = value;
				else if(aname.equals(""RIGHT""))
					right = value;
				else if(aname.equals(""TOP_POS""))
					topPos = Integer.parseInt(value);
				else if(aname.equals(""LEFT_POS""))
					leftPos = Integer.parseInt(value);
				else if(aname.equals(""BOTTOM_POS""))
					bottomPos = Integer.parseInt(value);
				else if(aname.equals(""RIGHT_POS""))
					rightPos = Integer.parseInt(value);
			}
		} 
		
		
		public String top, left, bottom, right;
		public int topPos, leftPos, bottomPos, rightPos;

		public DefaultHandler getPerspectiveHandler()
		{
			return new PerspectiveHandler();
		}

		public boolean saveLayout(String baseName, int viewIndex)
		{
			String lineSep = System.getProperty(""line.separator"");
			String filename = getLayoutFilename(baseName, viewIndex);
			BufferedWriter out = null;
			try
			{
				out = new BufferedWriter(new FileWriter(filename));
				out.write(""<DOCKING LEFT=\"""");
				out.write(left == null ? """" : left);
				out.write(""\"" TOP=\"""");
				out.write(top == null ? """" : top);
				out.write(""\"" RIGHT=\"""");
				out.write(right == null ? """" : right);
				out.write(""\"" BOTTOM=\"""");
				out.write(bottom == null ? """" : bottom);
				out.write(""\"" LEFT_POS=\"""");
				out.write(String.valueOf(leftPos));
				out.write(""\"" TOP_POS=\"""");
				out.write(String.valueOf(topPos));
				out.write(""\"" RIGHT_POS=\"""");
				out.write(String.valueOf(rightPos));
				out.write(""\"" BOTTOM_POS=\"""");
				out.write(String.valueOf(bottomPos));
				out.write(""\"" />"");
				out.write(lineSep);
			}
			catch (IOException e)
			{
				Log.log(Log.ERROR, this, e, e);
				return false;
			}
			finally
			{
				IOUtilities.closeQuietly(out);
			}
			return true;
		}

		@Override
		public boolean loadLayout(String baseName, int viewIndex)
		{
			String filename = getLayoutFilename(baseName, viewIndex);
			DefaultHandler handler = getPerspectiveHandler();
			try
			{
				
				XMLUtilities.parseXML(new FileInputStream(filename), handler);
			}
			catch (FileNotFoundException e)
			{
				return false;
			}
			catch (IOException e)
			{
				return false;
			}
			return true;
		}
		
		@Override
		public String getName()
		{
			return ""DockableWindowManager"";
		}

	} 

	
	
	private Map<String, Entry> windows;
	private PanelWindowContainer left;
	private PanelWindowContainer right;
	private PanelWindowContainer top;
	private PanelWindowContainer bottom;
	private List<Entry> clones;
	private Entry lastEntry;
	public Stack<String> showStack = new Stack<String>();
	

	
	public void setDockingLayout(DockingLayout docking)
	{
		DockableWindowConfig config = (DockableWindowConfig) docking;
		if (config == null)
			return;
		if(config.top != null && config.top.length() != 0)
				showDockableWindow(config.top);

		if(config.left != null && config.left.length() != 0)
				showDockableWindow(config.left);

		if(config.bottom != null && config.bottom.length() != 0)
				showDockableWindow(config.bottom);

		if(config.right != null && config.right.length() != 0)
				showDockableWindow(config.right);
		
	} 
	
	
	@Override
	public DockingLayout getDockingLayout(ViewConfig config)
	{
		DockableWindowConfig docking = new DockableWindowConfig();
		
		docking.top = getTopDockingArea().getCurrent();
		docking.left = getLeftDockingArea().getCurrent();
		docking.bottom = getBottomDockingArea().getCurrent();
		docking.right = getRightDockingArea().getCurrent();

		docking.topPos = getTopDockingArea().getDimension();
		docking.leftPos = getLeftDockingArea().getDimension();
		docking.bottomPos = getBottomDockingArea().getDimension();
		docking.rightPos = getRightDockingArea().getDimension();
		return docking;
	} 

	
	
	public DockableWindowManagerImpl(View view, DockableWindowFactory factory,
		View.ViewConfig config)
	{
		super(view, factory, config);
		setLayout(new DockableLayout());

		windows = new HashMap<String, Entry>();
		clones = new ArrayList<Entry>();

		DockableWindowConfig docking = (DockableWindowConfig) config.docking;
		if (docking == null)
			docking = new DockableWindowConfig();
		top = new PanelWindowContainer(this,TOP,docking.topPos);
		left = new PanelWindowContainer(this,LEFT,docking.leftPos);
		bottom = new PanelWindowContainer(this,BOTTOM,docking.bottomPos);
		right = new PanelWindowContainer(this,RIGHT,docking.rightPos);

		add(DockableLayout.TOP_BUTTONS,top.buttonPanel);
		add(DockableLayout.LEFT_BUTTONS,left.buttonPanel);
		add(DockableLayout.BOTTOM_BUTTONS,bottom.buttonPanel);
		add(DockableLayout.RIGHT_BUTTONS,right.buttonPanel);

		add(TOP,top.dockablePanel);
		add(LEFT,left.dockablePanel);
		add(BOTTOM,bottom.dockablePanel);
		add(RIGHT,right.dockablePanel);
	} 

	
	public void setMainPanel(JPanel panel) 
	{
		add(panel, 0);
	} 

	
	
	
	public void init()
	{
		super.init();
		Iterator<DockableWindowFactory.Window> entries = factory.getDockableWindowIterator();

		while(entries.hasNext())
			addEntry(entries.next());

		propertiesChanged();
	} 

	
	
	public JComponent floatDockableWindow(String name)
	{
		Entry entry = windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return null;
		}
		
		
		Entry newEntry = new Entry(entry.factory,FLOATING);
		newEntry.win = newEntry.factory.createDockableWindow(view,FLOATING);
		
		if(newEntry.win != null)
		{
			FloatingWindowContainer fwc = new FloatingWindowContainer(this,true); 
			newEntry.container = fwc;
			newEntry.container.register(newEntry);
			newEntry.container.show(newEntry);
			
			
		}
		clones.add(newEntry);
		return newEntry.win;
	} 

	
	
	public void showDockableWindow(String name)
	{
		lastEntry = windows.get(name);
		if(lastEntry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}

		if(lastEntry.win == null)
		{
			lastEntry.win = lastEntry.factory.createDockableWindow(
				view,lastEntry.position);
		}

		if(lastEntry.win != null)
		{
			if(lastEntry.position.equals(FLOATING)
				&& lastEntry.container == null)
			{
				FloatingWindowContainer fwc = new FloatingWindowContainer(
					this,view.isPlainView()); 
				lastEntry.container = fwc;
				lastEntry.container.register(lastEntry);
			}
			showStack.push(name);
			lastEntry.container.show(lastEntry);
			Object reason = DockableWindowUpdate.ACTIVATED;
			EditBus.send(new DockableWindowUpdate(this, reason, name));
		}
		else
			;
	} 

	
	
	public void hideDockableWindow(String name)
	{
		Entry entry = windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}
		if(entry.win == null)
			return;
		entry.container.show(null);
	} 

	
	
	public JComponent getDockable(String name)
	{
		Entry entry = windows.get(name);
		if(entry == null || entry.win == null)
			return null;
		else
			return entry.win;
	} 

	
	
	public boolean isDockableWindowVisible(String name)
	{
		Entry entry = windows.get(name);
		if(entry == null || entry.win == null)
			return false;
		else
			return entry.container.isVisible(entry);
	} 

	
	
	public boolean isDockableWindowDocked(String name)
	{
		Entry entry = windows.get(name);
		if(entry == null)
			return false;
		else
			return !entry.position.equals(FLOATING);
	} 

	
	
	public void closeCurrentArea()
	{
		
		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				
				try
				{
					String dockableName = showStack.pop();
					hideDockableWindow(dockableName);
					return;
				}
				catch (Exception e) {}
				
				Component comp = view.getFocusOwner();
				while(comp != null)
				{
					
					if(comp instanceof DockablePanel)
					{
						DockablePanel panel = (DockablePanel) comp;
						
						PanelWindowContainer container = panel.getWindowContainer();
						
						container.show((DockableWindowManagerImpl.Entry) null);
						return;
					}

					comp = comp.getParent();
				}

				getToolkit().beep();
			}
		});
	} 

	
	
	public void close()
	{
		super.close();

		for (Entry entry : windows.values())
		{
			if (entry.win != null)
				entry.container.unregister(entry);
		}

		for (Entry clone : clones)
		{
			if (clone.win != null)
				clone.container.unregister(clone);
		}
	} 

	
	public PanelWindowContainer getTopDockingArea()
	{
		return top;
	} 

	
	public PanelWindowContainer getLeftDockingArea()
	{
		return left;
	} 

	
	public PanelWindowContainer getBottomDockingArea()
	{
		return bottom;
	} 

	
	public PanelWindowContainer getRightDockingArea()
	{
		return right;
	} 

	
	public JPopupMenu createPopupMenu(
		final DockableWindowContainer container,
		final String dockable,
		final boolean clone)
	{
		JPopupMenu popup = new JPopupMenu();
		if(dockable == null && container instanceof PanelWindowContainer)
		{
			ActionListener listener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					showDockableWindow(evt.getActionCommand());
				}
			};

			String[] dockables = ((PanelWindowContainer)
				container).getDockables();
			Map<String,String> dockableMap = new TreeMap<String, String>();
			for (int i = 0; i < dockables.length; i++)
			{
				String action = dockables[i];
				dockableMap.put(getDockableTitle(action), action);
			}
			for (Map.Entry<String, String> entry : dockableMap.entrySet())
			{
				JMenuItem item = new JMenuItem(entry.getKey());
				item.setActionCommand(entry.getValue());
				item.addActionListener(listener);
				popup.add(item);
			}
		}
		else
		{
			JMenuItem caption = new JMenuItem(getDockableTitle(dockable));
			caption.setEnabled(false);
			popup.add(caption);
			popup.addSeparator();
			String currentPos = jEdit.getProperty(dockable + "".dock-position"",FLOATING);
			if(!clone)
			{
				String[] positions = { FLOATING, TOP, LEFT, BOTTOM, RIGHT };
				for(int i = 0; i < positions.length; i++)
				{
					final String pos = positions[i];
					if(pos.equals(currentPos))
						continue;

					JMenuItem moveMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-""
						+ pos));

					moveMenuItem.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent evt)
						{
							jEdit.setProperty(dockable + "".dock-position"",pos);
							EditBus.send(new DockableWindowUpdate(
								DockableWindowManagerImpl.this,
								DockableWindowUpdate.PROPERTIES_CHANGED,
								dockable
							));
							showDockableWindow(dockable);
						}
					});
					popup.add(moveMenuItem);
				}

				popup.addSeparator();
			}

			JMenuItem cloneMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-clone""));

			cloneMenuItem.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					floatDockableWindow(dockable);
				}
			});
			popup.add(cloneMenuItem);

			popup.addSeparator();

			JMenuItem closeMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-close""));

			closeMenuItem.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					if(clone)
						((FloatingWindowContainer)container).dispose();
					else
						removeDockableWindow(dockable);
				}
			});
			popup.add(closeMenuItem);

			if(!(clone || currentPos.equals(FLOATING)))
			{
				JMenuItem undockMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-undock""));

				undockMenuItem.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent evt)
					{
						jEdit.setProperty(dockable + "".dock-position"",FLOATING);
						EditBus.send(new DockableWindowUpdate(
							DockableWindowManagerImpl.this,
							DockableWindowUpdate.PROPERTIES_CHANGED,
							dockable
						));
						
						
						Entry entry = windows.get(dockable);
						if (entry == null)
							Log.log(Log.ERROR,this,""Unknown dockable window: "" + dockable);
						else
							entry.win = null;
					}
				});
				popup.add(undockMenuItem);
			}
		}

		return popup;
	} 

	
	public void paintChildren(Graphics g)
	{
		super.paintChildren(g);

		if(resizeRect != null)
		{
			g.setColor(Color.darkGray);
			g.fillRect(resizeRect.x,resizeRect.y,
				resizeRect.width,resizeRect.height);
		}
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof DockableWindowUpdate)
		{
			if(((DockableWindowUpdate)msg).getWhat()
				== DockableWindowUpdate.PROPERTIES_CHANGED)
				propertiesChanged();
		}
		else if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if(pmsg.getWhat() == PluginUpdate.LOADED)
			{
				Iterator<DockableWindowFactory.Window> iter = factory.getDockableWindowIterator();

				while(iter.hasNext())
				{
					DockableWindowFactory.Window w = iter.next();
					if(w.plugin == pmsg.getPluginJAR())
						addEntry(w);
				}

				propertiesChanged();
			}
			else if(pmsg.isExiting())
			{
				
			}
			else if(pmsg.getWhat() == PluginUpdate.DEACTIVATED)
			{
				Iterator<Entry> iter = getAllPluginEntries(
					pmsg.getPluginJAR(),false);
				while(iter.hasNext())
				{
					Entry entry = iter.next();
					if(entry.container != null)
						entry.container.remove(entry);
				}
			}
			else if(pmsg.getWhat() == PluginUpdate.UNLOADED)
			{
				Iterator<Entry> iter = getAllPluginEntries(
					pmsg.getPluginJAR(),true);
				while(iter.hasNext())
				{
					Entry entry = iter.next();
					if(entry.container != null)
					{
						entry.container.unregister(entry);
						entry.win = null;
						entry.container = null;
					}
				}
			}
		}
	} 

	
	int resizePos;
	
	Rectangle resizeRect;

	
	void setResizePos(int resizePos, PanelWindowContainer resizing)
	{
		this.resizePos = resizePos;

		if(resizePos < 0)
			resizePos = 0;

		if (continuousLayout)
			return;

		Rectangle newResizeRect = new Rectangle(0,0,
			PanelWindowContainer.SPLITTER_WIDTH - 2,
			PanelWindowContainer.SPLITTER_WIDTH - 2);
		if(resizing == top)
		{
			resizePos = Math.min(resizePos,getHeight()
				- top.buttonPanel.getHeight()
				- bottom.dockablePanel.getHeight()
				- bottom.buttonPanel.getHeight()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = top.dockablePanel.getX() + 1;
			newResizeRect.y = resizePos + top.buttonPanel.getHeight() + 1;
			newResizeRect.width = top.dockablePanel.getWidth() - 2;
		}
		else if(resizing == left)
		{
			resizePos = Math.min(resizePos,getWidth()
				- left.buttonPanel.getWidth()
				- right.dockablePanel.getWidth()
				- right.buttonPanel.getWidth()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = resizePos + left.buttonPanel.getWidth() + 1;
			newResizeRect.y = left.dockablePanel.getY() + 1;
			newResizeRect.height = left.dockablePanel.getHeight() - 2;
		}
		else if(resizing == bottom)
		{
			resizePos = Math.min(resizePos,getHeight()
				- bottom.buttonPanel.getHeight()
				- top.dockablePanel.getHeight()
				- top.buttonPanel.getHeight()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = bottom.dockablePanel.getX() + 1;
			newResizeRect.y = getHeight() - bottom.buttonPanel.getHeight() - resizePos
				- PanelWindowContainer.SPLITTER_WIDTH + 2;
			newResizeRect.width = bottom.dockablePanel.getWidth() - 2;
		}
		else if(resizing == right)
		{
			resizePos = Math.min(resizePos,getWidth()
				- right.buttonPanel.getWidth()
				- left.dockablePanel.getWidth()
				- left.buttonPanel.getWidth()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = getWidth() - right.buttonPanel.getWidth() - resizePos
				- PanelWindowContainer.SPLITTER_WIDTH + 1;
			newResizeRect.y = right.dockablePanel.getY() + 1;
			newResizeRect.height = right.dockablePanel.getHeight() - 2;
		}

		Rectangle toRepaint;
		if(resizeRect == null)
			toRepaint = newResizeRect;
		else
			toRepaint = resizeRect.union(newResizeRect);
		resizeRect = newResizeRect;
		repaint(toRepaint);
	} 

	
	void finishResizing()
	{
		resizeRect = null;
		repaint();
	} 

	

	
	protected void propertiesChanged()
	{
		if(view.isPlainView())
			return;

		((DockableLayout)getLayout()).setAlternateLayout(
			jEdit.getBooleanProperty(""view.docking.alternateLayout""));

		String[] windowList = factory.getRegisteredDockableWindows();

		for(int i = 0; i < windowList.length; i++)
		{
			String dockable = windowList[i];
			Entry entry = windows.get(dockable);

			String newPosition = jEdit.getProperty(dockable
				+ "".dock-position"",FLOATING);
			if(newPosition.equals(entry.position))
			{
				continue;
			}

			entry.position = newPosition;
			if(entry.container != null)
			{
				entry.container.unregister(entry);
				entry.container = null;
				if (entry.factory.movable && (! newPosition.equals(FLOATING)))
				{
					if (entry.win instanceof DockableWindow)
						((DockableWindow)entry.win).move(newPosition);
				}
				else
					entry.win = null;
			}

			if(newPosition.equals(FLOATING)) 
			{
			}
				
			else
			{
				if(newPosition.equals(TOP))
					entry.container = top;
				else if(newPosition.equals(LEFT))
					entry.container = left;
				else if(newPosition.equals(BOTTOM))
					entry.container = bottom;
				else if(newPosition.equals(RIGHT))
					entry.container = right;
				else
				{
					Log.log(Log.WARNING,this,
						""Unknown position: ""
						+ newPosition);
					continue;
				}

				entry.container.register(entry);
			}
		}

		top.sortDockables();
		left.sortDockables();
		bottom.sortDockables();
		right.sortDockables();

		continuousLayout = jEdit.getBooleanProperty(""appearance.continuousLayout"");
		revalidate();
		repaint();
	} 

	
	private void addEntry(DockableWindowFactory.Window factory)
	{
		Entry e;
		if(view.isPlainView())
		{
			
			e = new Entry(factory,FLOATING);
		}
		else
		{
			e = new Entry(factory);
			if(e.position.equals(FLOATING))
				;
			else if(e.position.equals(TOP))
				e.container = top;
			else if(e.position.equals(LEFT))
				e.container = left;
			else if(e.position.equals(BOTTOM))
				e.container = bottom;
			else if(e.position.equals(RIGHT))
				e.container = right;
			else
			{
				Log.log(Log.WARNING,this,
					""Unknown position: ""
					+ e.position);
			}

			if(e.container != null)
				e.container.register(e);
		}
		windows.put(factory.name,e);
	} 

	
	
	private Iterator<Entry> getAllPluginEntries(PluginJAR plugin, boolean remove)
	{
		List<Entry> returnValue = new LinkedList<Entry>();
		Iterator<Entry> iter = windows.values().iterator();
		while(iter.hasNext())
		{
			Entry entry = iter.next();
			if(entry.factory.plugin == plugin)
			{
				returnValue.add(entry);
				if(remove)
					iter.remove();
			}
		}

		iter = clones.iterator();
		while(iter.hasNext())
		{
			Entry entry = iter.next();
			if(entry.factory.plugin == plugin)
			{
				returnValue.add(entry);
				iter.remove();
			}
		}

		return returnValue.iterator();
	} 

	private boolean continuousLayout;

	
	class Entry
	{
		DockableWindowFactory.Window factory;


		String position;
		DockableWindowContainer container;

		
		JComponent win;

		
		AbstractButton btn;

		
		Entry(DockableWindowFactory.Window factory)
		{
			this(factory,jEdit.getProperty(factory.name
				+ "".dock-position"",FLOATING));
		} 

		
		
		public String longTitle() 
		{
			String title = jEdit.getProperty(factory.name + "".longtitle"");
			if (title == null) return shortTitle();
			else return title;
			
		}
		
		
		public String shortTitle() 
		{
			
			String title = jEdit.getProperty(factory.name + "".title"");
			if(title == null)
				return ""NO TITLE PROPERTY: "" + factory.name;
			else
				return title;
		}

		
		public String label()
		{
			String retval = jEdit.getProperty(factory.name + "".label"");
			retval = retval.replaceAll(""\\$"", """");
			return retval; 
		}

		
		Entry(DockableWindowFactory.Window factory, String position)
		{
			this.factory = factory;
			this.position = position;

			
			
			
			
		} 
	} 

	@Override
	public void disposeDockableWindow(String name)
	{
		
		
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.AboutDialog,4,6,0,5,34,6,2,5,2,2.0,150,0.0,0,0.995412844,0.375,0,0,36.5,1,0.75,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.image.BufferedImage;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class AboutDialog extends JDialog implements ActionListener
{
	
	public AboutDialog(View view)
	{
		super(view,jEdit.getProperty(""about.title""), true);
		setResizable(false);
		JButton closeBtn = new JButton(jEdit.getProperty(""common.close""));
		closeBtn.addActionListener(this);
		getRootPane().setDefaultButton(closeBtn);

		JPanel p = new JPanel(new BorderLayout());
		final AboutPanel aboutPanel = new AboutPanel();
		JPanel flowP = new JPanel(new FlowLayout());
		flowP.add(closeBtn);
		flowP.add(Box.createRigidArea(new Dimension(40, 40)));
		Dimension dim = new Dimension(10, 0);
		p.add(BorderLayout.WEST, Box.createRigidArea(dim));
		p.add(BorderLayout.EAST, Box.createRigidArea(dim));
		p.add(BorderLayout.NORTH, Box.createRigidArea(new Dimension(10, 10)));
		p.add(BorderLayout.SOUTH, flowP);
		p.add(BorderLayout.CENTER, aboutPanel);

		closeBtn.setToolTipText(jEdit.getProperty(""about.navigate""));
		closeBtn.addKeyListener(new KeyAdapter()
		{
			public void keyPressed(KeyEvent e)
			{
				aboutPanel.handleKeyEvent(e);
			}
		});

		setContentPane(p);
		pack();
		setLocationRelativeTo(jEdit.getActiveView());
		addWindowListener(new WindowAdapter()
		{
			@Override
			public void windowClosing(WindowEvent e)
			{
				closeDialog();
			}
		});
		setVisible(true);
	} 

	
	public void actionPerformed(ActionEvent e)
	{
		closeDialog();
	} 

	
	private void closeDialog()
	{
		AboutPanel.stopThread();
		dispose();
	} 


	
	private static class AboutPanel extends JComponent implements Runnable
	{
		private BufferedImage bufImage;
		private Graphics2D g;
		private static final Font defaultFont = UIManager.getFont(""Label.font"");
		private final Font bottomLineFont = defaultFont.deriveFont(9.8f);
		private final String sBottomLine;
		private final ImageIcon image;
		private final Vector<String> vLines;
		private static boolean doWork;
		private Thread th;
		private final FontMetrics fm;
		private int iLineHeight = 0, iListHeight, iLineCount = 0,
			iBottomLineXOffset = 0, iBottomLineYOffset = 0,
			iPipeLineCount = 0, w = 0, h = 0, y = 0;
		private static final int
			SLEEP_TIME = 30,
			iBottomPadding = 36,
			iTopPadding = 120;
		private static Rectangle2D.Float rectangle;
		private static GradientPaint gradientPaint;
		private boolean skipDrain = false;

		AboutPanel()
		{
			String mode;
			if (jEdit.getEditServer() != null)
			{
				if (jEdit.isBackgroundModeEnabled())
					mode = jEdit.getProperty(""about.mode.server-background"");
				else
					mode = jEdit.getProperty(""about.mode.server"");
			}
			else
				mode = jEdit.getProperty(""about.mode.standalone"");
			String[] args = { jEdit.getVersion(), mode, System.getProperty(""java.version"") };
			sBottomLine = jEdit.getProperty(""about.version"",args);
			setFont(defaultFont);
			fm = getFontMetrics(defaultFont);
			FontMetrics fmBottom = getFontMetrics(bottomLineFont);
			iLineHeight = fm.getHeight();
			vLines = new Vector<String>(50);
			image = (ImageIcon)GUIUtilities.loadIcon(""about.png"");
			MediaTracker tracker = new MediaTracker(this);
			tracker.addImage(image.getImage(), 0);

			try
			{
				tracker.waitForID(0);
			}
			catch(Exception exc)
			{
				tell(""AboutPanel: "" + exc);
			}

			Dimension d = new Dimension(image.getIconWidth(), image.getIconHeight());
			setSize(d);
			setPreferredSize(d);
			w = d.width;
			h = d.height;
			iBottomLineXOffset = (w / 2) - (fmBottom.stringWidth(sBottomLine) / 2);
			iBottomLineYOffset = h-iLineHeight/2;
			StringTokenizer st = new StringTokenizer(
				jEdit.getProperty(""about.text""),""\n"");
			while(st.hasMoreTokens())
			{
				vLines.add(st.nextToken());
			}

			iLineCount = vLines.size();
			iListHeight = iLineCount * iLineHeight;
			startThread();
			updateUI();
		}

		private void handleKeyEvent(KeyEvent e)
		{
			if (e.getKeyCode() == KeyEvent.VK_DOWN)
			{
				skipDrain = false;
				Collections.rotate(vLines, -1);
			}
			else if (e.getKeyCode() == KeyEvent.VK_UP)
			{
				skipDrain = false;
				Collections.rotate(vLines, 1);
			}
			else if ((e.getKeyCode() == KeyEvent.VK_LEFT) ||
					(e.getKeyCode() == KeyEvent.VK_RIGHT) ||
					(e.getKeyCode() == KeyEvent.VK_ESCAPE))
			{
				skipDrain = ! skipDrain;
			}
		}

		private void drain()
		{
			if (skipDrain)
				return;
			if (bufImage == null)
			{
				
				Dimension d = getSize();
				bufImage = new BufferedImage(d.width, d.height,
					BufferedImage.TYPE_INT_RGB);
				g = bufImage.createGraphics();
				rectangle = new Rectangle2D.Float(0, iTopPadding,
					d.width, d.height-iBottomPadding-iTopPadding);
				
				
				iPipeLineCount = 1 + (int)Math.ceil(rectangle.height/iLineHeight);
				y = d.height+iBottomPadding;
				g.setFont(defaultFont);
				gradientPaint = new GradientPaint(
					rectangle.width/2, iTopPadding+80, new Color(80, 80, 80),
					rectangle.width/2, iTopPadding, new Color(205, 205, 205)
					);
				g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			}

			g.drawImage(image.getImage(), 0, 0, w, h, this);

			g.setFont(bottomLineFont);

			g.setPaint(new Color(55, 55, 55));
			g.drawString(sBottomLine, iBottomLineXOffset, iBottomLineYOffset);
			
			g.setPaint(new Color(255, 255, 255, 50));
			g.drawString(sBottomLine, iBottomLineXOffset + 1, iBottomLineYOffset + 1);

			g.setFont(defaultFont);
			g.setPaint(Color.black);


			g.drawRect(0, 0, w-1, h-1);
			g.clip(rectangle);
			g.setPaint(gradientPaint);
			int iDrawnLinesCount = 0, yCoor = 0;

			for (int i=0; i<iLineCount; i++)
			{
				
				yCoor = y+ i * iLineHeight;
				if (yCoor < iTopPadding)
				{
					continue;
				}

				
				String sLine = vLines.get(i);
				int x = (w - fm.stringWidth(sLine))/2;
				g.drawString(sLine, x, yCoor);
				if (++iDrawnLinesCount >= iPipeLineCount)
				{
					break;
				}
			}

			y--;
			paint(getGraphics());

			
			
			if ((y + iListHeight) < iTopPadding)
			{
				y = h+iBottomPadding;
			}
		}

		@Override
		public void update(Graphics g)
		{
			paint(g);
		}

		@Override
		public void paint(Graphics panelGraphics)
		{
			if (panelGraphics != null && bufImage != null)
			{
				panelGraphics.drawImage(bufImage, 0, 0, w, h, this);
			}
		}

		public void run()
		{
			try
			{
				while(doWork)
				{
					drain();
					Thread.sleep(SLEEP_TIME);
				}
			}
			catch(Exception exc)
			{
				Log.log(Log.ERROR, this, exc);
			}

			doWork = false;
			th = null;
		}

		public void startThread()
		{
			if (th == null)
			{
				th = new Thread(this);
				doWork = true;
				th.start();
			}
		}

		public static void stopThread()
		{
			doWork = false;
		}

		public static void tell(Object obj)
		{
			String str = obj == null ? ""NULL"" : obj.toString();
			JOptionPane.showMessageDialog(jEdit.getActiveView(), str, ""Title"", 1);
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.collection.CollectionManagerImpl,5,2,0,4,11,10,0,4,5,2.0,44,0.0,0,0.6,0.9,1,1,7.8,2,1.0,0,"

package org.gjt.sp.jedit.bsh.collection;

import java.util.Iterator;
import java.util.Collection;
import java.util.Map;

import org.gjt.sp.jedit.bsh.BshIterator;


public class CollectionManagerImpl extends org.gjt.sp.jedit.bsh.CollectionManager
{
	public BshIterator getBshIterator( Object obj ) 
		throws IllegalArgumentException
	{
		if ( obj instanceof Collection || obj instanceof Iterator )
			return new CollectionIterator( obj ); 
		else
			return new org.gjt.sp.jedit.bsh.CollectionManager.BasicBshIterator( obj );
	}

	public boolean isMap( Object obj ) 
	{
		if ( obj instanceof Map )
			return true;
		else
			return super.isMap( obj );
	}

	public Object getFromMap( Object map, Object key ) 
	{
		
		return ((Map)map).get(key);
	}
	public Object putInMap( Object map, Object key, Object value ) 
	{
		
		return ((Map)map).put(key, value);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.This,11,1,2,20,37,29,12,13,8,0.45,353,0.0,2,0.0,0.214876033,0,0,30.90909091,7,1.6364,0,"


package org.gjt.sp.jedit.bsh;


public class This implements java.io.Serializable, Runnable
{
    
    NameSpace namespace;

    
    transient Interpreter declaringInterpreter;

    
    static This getThis(
        NameSpace namespace, Interpreter declaringInterpreter )
    {
        try {
            Class c;
            if ( Capabilities.canGenerateInterfaces() )
                c = Class.forName( ""org.gjt.sp.jedit.bsh.XThis"" );
            else if ( Capabilities.haveSwing() )
                c = Class.forName( ""org.gjt.sp.jedit.bsh.JThis"" );
            else
                return new This( namespace, declaringInterpreter );

            return (This)Reflect.constructObject( c,
                new Object [] { namespace, declaringInterpreter } );

        } catch ( Exception e ) {
            throw new InterpreterError(""internal error 1 in This: ""+e);
        }
    }

    
    
    public Object getInterface( Class clas )
        throws UtilEvalError
    {
        if ( clas.isInstance( this ) )
            return this;
        else
            throw new UtilEvalError( ""Dynamic proxy mechanism not available. ""
            + ""Cannot construct interface type: ""+clas );
    }

    
    public Object getInterface( Class [] ca )
        throws UtilEvalError
    {
        for(int i=0; i<ca.length; i++)
            if ( !(ca[i].isInstance( this )) )
                throw new UtilEvalError(
                    ""Dynamic proxy mechanism not available. ""
                    + ""Cannot construct interface type: ""+ca[i] );

        return this;
    }

    
    protected This( NameSpace namespace, Interpreter declaringInterpreter ) {
        this.namespace = namespace;
        this.declaringInterpreter = declaringInterpreter;
        
    }

    public NameSpace getNameSpace() {
        return namespace;
    }

    public String toString() {
        return ""'this' reference to Bsh object: "" + namespace;
    }

    public void run() {
        try {
            invokeMethod( ""run"", new Object[0] );
        } catch( EvalError e ) {
            declaringInterpreter.error(
                ""Exception in runnable:"" + e );
        }
    }

    
    public Object invokeMethod( String name, Object [] args )
        throws EvalError
    {
        
        return invokeMethod(
            name, args, null, null, null,
            false );
    }

    
    
    public Object invokeMethod(
        String methodName, Object [] args,
        Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,
        boolean declaredOnly  )
        throws EvalError
    {
        
        if ( args != null )
        {
            Object [] oa = new Object [args.length];
            for(int i=0; i<args.length; i++)
                oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );
            args = oa;
        }

        if ( interpreter == null )
            interpreter = declaringInterpreter;
        if ( callstack == null )
            callstack = new CallStack( namespace );
        if ( callerInfo == null )
            callerInfo = SimpleNode.JAVACODE;

        
        Class [] types = Types.getTypes( args );
        BshMethod bshMethod = null;
        try {
            bshMethod = namespace.getMethod( methodName, types, declaredOnly );
        } catch ( UtilEvalError e ) {
            
        }

        if ( bshMethod != null )
            return bshMethod.invoke( args, interpreter, callstack, callerInfo );

        
        
        if ( methodName.equals(""toString"" ) )
            return toString();

        
        if ( methodName.equals(""hashCode"" ) )
            return new Integer(this.hashCode());

        
        if ( methodName.equals(""equals"" ) ) {
            Object obj = args[0];
            return new Boolean( this == obj );
        }

        
        
        
        try {
            bshMethod = namespace.getMethod(
                ""invoke"", new Class [] { null, null } );
        } catch ( UtilEvalError e ) {  }

        
        if ( bshMethod != null )
            return bshMethod.invoke( new Object [] { methodName, args },
                interpreter, callstack, callerInfo );

        throw new EvalError(""Method "" +
            StringUtil.methodString( methodName, types ) +
            "" not found in bsh scripted object: ""+ namespace.getName(),
            callerInfo, callstack );
    }

    
    public static void bind(
        This ths, NameSpace namespace, Interpreter declaringInterpreter )
    {
        ths.namespace.setParent( namespace );
        ths.declaringInterpreter = declaringInterpreter;
    }

    
    static boolean isExposedThisMethod( String name )
    {
        return
            name.equals(""getClass"")
            || name.equals(""invokeMethod"")
            || name.equals(""getInterface"")
            
            || name.equals(""wait"")
            || name.equals(""notify"")
            || name.equals(""notifyAll"");
    }

}

"
jEdit,4.3,org.gjt.sp.jedit.buffer.KillRing,18,1,1,6,32,75,4,2,12,0.573529412,453,1.0,2,0.0,0.235294118,0,0,23.94444444,10,2.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.event.ListDataListener;
import java.util.List;

import org.gjt.sp.jedit.gui.MutableListModel;


public class KillRing implements MutableListModel
{
	
	public static KillRing getInstance()
	{
		return killRing;
	} 

	
	public static void setInstance(KillRing killRing)
	{
		KillRing.killRing = killRing;
	} 

	
	public void propertiesChanged(int historySize)
	{
		int newSize = Math.max(1, historySize);
		if(ring == null)
			ring = new UndoManager.RemovedContent[newSize];
		else if(newSize != ring.length)
		{
			UndoManager.RemovedContent[] newRing = new UndoManager.RemovedContent[
				newSize];
			int newCount = Math.min(getSize(),newSize);
			for(int i = 0; i < newCount; i++)
			{
				newRing[i] = (UndoManager.RemovedContent)getElementAt(i);
			}
			ring = newRing;
			count = newCount;
			wrap = false;
		}

		if(count == ring.length)
		{
			count = 0;
			wrap = true;
		}
	} 

	public void load() {}

	public void save() {}

	
	
	protected void reset(List source)
	{
		UndoManager.RemovedContent[] newRing
			= new UndoManager.RemovedContent[source.size()];
		int i = 0;
		for(Object x: source)
		{
			UndoManager.RemovedContent element;
			if(x instanceof String)
			{
				element = new UndoManager.RemovedContent(
					(String)x);
			}
			else
			{
				element = (UndoManager.RemovedContent)x;
			}
			newRing[i++] = element;
		}
		ring = newRing;
		count = 0;
		wrap = true;
	} 

	
	public void addListDataListener(ListDataListener listener) {}

	public void removeListDataListener(ListDataListener listener) {}

	
	public Object getElementAt(int index)
	{
		return ring[virtualToPhysicalIndex(index)];
	} 

	
	public int getSize()
	{
		if(wrap)
			return ring.length;
		else
			return count;
	} 

	
	public boolean removeElement(Object value)
	{
		for(int i = 0; i < getSize(); i++)
		{
			if(ring[i].equals(value))
			{
				remove(i);
				return true;
			}
		}
		return false;
	} 

	
	public void insertElementAt(Object value, int index)
	{
		
		remove(index);
		add((UndoManager.RemovedContent)value);
	} 

	

	

	
	void changed(UndoManager.RemovedContent rem)
	{
		if(rem.inKillRing)
		{
			
			int length = (wrap ? ring.length : count);
			int kill = -1;

			for(int i = 0; i < length; i++)
			{
				if(ring[i] != rem
					&& ring[i].hashcode == rem.hashcode
					&& ring[i].str.equals(rem.str))
				{
					
					
					kill = i;
					break;
				}
			}

			if(kill != -1)
				remove(kill);
		}
		else
			add(rem);
	} 

	
	void add(UndoManager.RemovedContent rem)
	{
		
		int length = (wrap ? ring.length : count);
		for(int i = 0; i < length; i++)
		{
			if(ring[i].hashcode == rem.hashcode)
			{
				
				if(ring[i].str.equals(rem.str))
				{
					
					
					return;
				}
			}
		}

		
		boolean allWhitespace = true;
		for(int i = 0; i < rem.str.length(); i++)
		{
			if(!Character.isWhitespace(rem.str.charAt(i)))
			{
				allWhitespace = false;
				break;
			}
		}

		if(allWhitespace)
			return;

		rem.inKillRing = true;

		if(ring[count] != null)
			ring[count].inKillRing = false;

		ring[count] = rem;
		if(++count >= ring.length)
		{
			wrap = true;
			count = 0;
		}
	} 

	
	void remove(int i)
	{
		if(wrap)
		{
			UndoManager.RemovedContent[] newRing = new UndoManager.RemovedContent[
				ring.length];
			int newCount = 0;
			for(int j = 0; j < ring.length; j++)
			{
				int index = virtualToPhysicalIndex(j);

				if(i == index)
				{
					ring[index].inKillRing = false;
					continue;
				}

				newRing[newCount++] = ring[index];
			}
			ring = newRing;
			count = newCount;
			wrap = false;
		}
		else
		{
			System.arraycopy(ring,i + 1,ring,i,count - i - 1);
			count--;
		}
	} 

	

	
	private UndoManager.RemovedContent[] ring;
	private int count;
	private boolean wrap;
	private static KillRing killRing = new KillRing();

	
	
	private int virtualToPhysicalIndex(int index)
	{
		if(wrap)
		{
			if(index < count)
				return count - index - 1;
			else
				return count + ring.length - index - 1;
		}
		else
			return count - index - 1;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.FavoritesProvider,3,1,0,10,20,3,2,10,3,2.0,89,0.0,0,0.0,0.666666667,0,0,28.66666667,4,1.6667,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.awt.event.*;
import java.util.Arrays;

import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;


public class FavoritesProvider implements DynamicMenuProvider
{
	
	public boolean updateEveryTime()
	{
		return false;
	} 

	
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);

		
		ActionListener fileListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
			}
		};

		ActionListener dirListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,
					evt.getActionCommand());
			}
		}; 

		VFSFile[] favorites = FavoritesVFS.getFavorites();
		if(favorites.length == 0)
		{
			JMenuItem mi = new JMenuItem(
				jEdit.getProperty(
				""vfs.browser.favorites""
				+ "".no-favorites.label""));
			mi.setEnabled(false);
			menu.add(mi);
		}
		else
		{
			Arrays.sort(favorites,
				new VFS.DirectoryEntryCompare(
				jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs""),
				jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"")));
			for(int i = 0; i < favorites.length; i++)
			{
				VFSFile favorite = favorites[i];
				JMenuItem mi = new JMenuItem(
					favorite.getPath());
				mi.setIcon(FileCellRenderer
					.getIconForFile(
					favorite,false));
				if(favorite.getType() == VFSFile.FILE)
				{
					mi.addActionListener(fileListener);
				}
				else
				{
					mi.addActionListener(dirListener);
				}
				menu.add(mi);
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.UtilEvalError,4,3,3,51,12,6,48,4,3,2.0,50,0.0,0,0.894736842,0.625,0,0,11.5,3,1.0,0,"


package org.gjt.sp.jedit.bsh;


public class UtilEvalError extends Exception
{
    protected UtilEvalError() {
    }

    public UtilEvalError( String s ) {
        super(s);
    }

    
    public EvalError toEvalError(
        String msg, SimpleNode node, CallStack callstack  )
    {
        if ( Interpreter.DEBUG )
            printStackTrace();

        if ( msg == null )
            msg = """";
        else
            msg = msg + "": "";
        return new EvalError( msg+getMessage(), node, callstack );
    }

    public EvalError toEvalError ( SimpleNode node, CallStack callstack )
    {
        return toEvalError( null, node, callstack );
    }

}

"
jEdit,4.3,org.gjt.sp.jedit.textarea.StructureMatcher,2,1,0,4,2,1,4,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.*;
import org.gjt.sp.jedit.TextUtilities;



public interface StructureMatcher
{
	
	
	Match getMatch(TextArea textArea);
	

	
	
	void selectMatch(TextArea textArea);
	

	
	static class BracketMatcher implements StructureMatcher
	{
		public Match getMatch(TextArea textArea)
		{
			int offset = textArea.getCaretPosition()
				- textArea.getLineStartOffset(
				textArea.getCaretLine());

			if(offset != 0)
			{
				int bracketOffset = TextUtilities.findMatchingBracket(
					textArea.getBuffer(),
					textArea.getCaretLine(),
					offset - 1);
				if(bracketOffset != -1)
				{
					int bracketLine = textArea
						.getLineOfOffset(
						bracketOffset);
					return new Match(this,
						bracketLine,
						bracketOffset,
						bracketLine,
						bracketOffset + 1);
				}
			}

			return null;
		}

		public void selectMatch(TextArea textArea)
		{
			textArea.selectToMatchingBracket();
		}
	} 

	
	
	public static class Match
	{
		public StructureMatcher matcher;
		public int startLine;
		public int start;
		public int endLine;
		public int end;

		public Match() {}

		public Match(StructureMatcher matcher)
		{
			this.matcher = matcher;
		}

		public Match(StructureMatcher matcher, int startLine,
			int start, int endLine, int end)
		{
			this(matcher);
			this.startLine = startLine;
			this.start = start;
			this.endLine = endLine;
			this.end = end;
		}
	} 

	
	
	static class Highlight extends TextAreaExtension
	{
		Highlight(TextArea textArea)
		{
			this.textArea = textArea;
		}

		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(!textArea.getPainter().isStructureHighlightEnabled())
				return;

			Match match = textArea.getStructureMatch();
			if(match != null)
			{
				paintHighlight(gfx,screenLine,
					start,end,y,match);
			}
		}

		private int[] getOffsets(int screenLine, Match match)
		{
			int x1, x2;

			int matchStartLine = textArea.getScreenLineOfOffset(
				match.start);
			int matchEndLine = textArea.getScreenLineOfOffset(
				match.end);

			if(matchStartLine == screenLine)
			{
				x1 = match.start;
			}
			else
			{
				x1 = textArea.getScreenLineStartOffset(
					screenLine);
			}

			if(matchEndLine == screenLine)
			{
				x2 = match.end;
			}
			else
			{
				x2 = textArea.getScreenLineEndOffset(
					screenLine) - 1;
			}

			return new int[] {
				textArea.offsetToXY(x1).x,
				textArea.offsetToXY(x2).x
			};
		}
	
		private void paintHighlight(Graphics gfx, int screenLine,
			int start, int end, int y,
			Match match)
		{
			if(!textArea.isStructureHighlightVisible())
				return;

			if(match.start >= end || match.end < start)
			{
				return;
			}

			int matchStartLine = textArea.getScreenLineOfOffset(
				match.start);
			int matchEndLine = textArea.getScreenLineOfOffset(
				match.end);

			FontMetrics fm = textArea.getPainter().getFontMetrics();
			int height = fm.getHeight();

			int[] offsets = getOffsets(screenLine,match);
			int x1 = offsets[0];
			int x2 = offsets[1];

			gfx.setColor(textArea.getPainter().getStructureHighlightColor());

			gfx.drawLine(x1,y,x1,y + height - 1);
			gfx.drawLine(x2,y,x2,y + height - 1);

			if(matchStartLine == screenLine || screenLine == 0)
				gfx.drawLine(x1,y,x2,y);
			else
			{
				offsets = getOffsets(screenLine - 1,match);
				int prevX1 = offsets[0];
				int prevX2 = offsets[1];

				gfx.drawLine(Math.min(x1,prevX1),y,
					Math.max(x1,prevX1),y);
				gfx.drawLine(Math.min(x2,prevX2),y,
					Math.max(x2,prevX2),y);
			}

			if(matchEndLine == screenLine)
			{
				gfx.drawLine(x1,y + height - 1,
					x2,y + height - 1);
			}
		}

		private TextArea textArea;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.EditAction,13,2,6,31,22,66,29,4,13,2.0,99,0.0,0,0.3125,0.243589744,1,1,6.615384615,2,0.9231,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.util.Log;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;



public abstract class EditAction extends JEditAbstractEditAction<View>
{
	
	
	public EditAction(String name)
	{
		super(name);
	}
	
	public EditAction(String name, Object[] newArgs) 
	{
		super(name, newArgs);
	} 
			
	
	
	public String getLabel()
	{
		if (args != null)
		{
			return jEdit.getProperty(name + "".label"", args);
		}
		return jEdit.getProperty(name + "".label"");
	} 

	
	
	public final String getMouseOverText()
	{
		return jEdit.getProperty(name + "".mouse-over"");
	} 

	
	
	abstract public void invoke(View view);
	
	
	
	public static View getView(Component comp)
	{
		
		return GUIUtilities.getView(comp);
	} 

	
	
	public final boolean isToggle()
	{
		return jEdit.getBooleanProperty(name + "".toggle"");
	} 

	
	
	public boolean isSelected(Component comp)
	{
		return false;
	} 

	
	
	public boolean noRepeat()
	{
		return false;
	} 

	
	
	public boolean noRecord()
	{
		return false;
	} 

	
	
	public boolean noRememberLast()
	{
		return false;
	} 

	
	
	public String getCode() 
	{
		return ""jEdit.getAction("" + name + "").invoke(view); "";
	}
	
	
	
	
	public static class Wrapper implements ActionListener
	{

		private final ActionContext context;
		private final String actionName;
		
		
		public Wrapper(ActionContext context, String actionName)
		{
			this.context = context;
			this.actionName = actionName;
		}

		
		public void actionPerformed(ActionEvent evt)
		{
			EditAction action = context.getAction(actionName);
			if(action == null)
			{
				Log.log(Log.WARNING,this,""Unknown action: ""
					+ actionName);
			}
			else
				context.invokeAction(evt,action);
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.DirectoryProvider,3,1,0,11,35,1,2,11,3,0.5,228,1.0,0,0.0,0.555555556,0,0,74.66666667,18,6.3333,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.awt.event.*;
import java.io.File;
import java.util.Arrays;

import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.StandardUtilities;



public class DirectoryProvider implements DynamicMenuProvider
{
	
	public DirectoryProvider(String dir)
	{
		this.dir = dir;
	} 

	
	public boolean updateEveryTime()
	{
		return true;
	} 

	
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);

		String path;
		if(dir == null)
		{
			path = view.getBuffer().getDirectory();
		}
		else
			path = dir;

		JMenuItem mi = new JMenuItem(path + ':');
		mi.setActionCommand(path);
		mi.setIcon(FileCellRenderer.openDirIcon);

		
		ActionListener fileListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
			}
		};

		ActionListener dirListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,
					evt.getActionCommand());
			}
		}; 

		mi.addActionListener(dirListener);

		menu.add(mi);
		menu.addSeparator();

		if(dir == null && !(view.getBuffer().getVFS() instanceof FileVFS))
		{
			mi = new JMenuItem(jEdit.getProperty(
				""directory.not-local""));
			mi.setEnabled(false);
			menu.add(mi);
			return;
		}

		File directory = new File(path);

		JMenu current = menu;

		
		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");

		File[] list = directory.listFiles();
		if(list == null || list.length == 0)
		{
			mi = new JMenuItem(jEdit.getProperty(
				""directory.no-files""));
			mi.setEnabled(false);
			menu.add(mi);
		}
		else
		{
			int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

			Arrays.sort(list,
				new StandardUtilities.StringCompare<File>(true));
			for(int i = 0; i < list.length; i++)
			{
				File file = list[i];

				String name = file.getName();

				
				if(name.endsWith("".marks""))
					continue;

				
				if(name.startsWith(""#"") && name.endsWith(""#""))
					continue;

				
				if((backupPrefix.length() != 0
					&& name.startsWith(backupPrefix))
					|| (backupSuffix.length() != 0
					&& name.endsWith(backupSuffix)))
					continue;

				
				
				

				mi = new JMenuItem(name);
				mi.setActionCommand(file.getPath());
				mi.addActionListener(file.isDirectory()
					? dirListener
					: fileListener);
				mi.setIcon(file.isDirectory()
					? FileCellRenderer.dirIcon
					: FileCellRenderer.fileIcon);

				if(current.getItemCount() >= maxItems && i != list.length - 1)
				{
					
					JMenu newCurrent = new JMenu(
						jEdit.getProperty(
						""common.more""));
					current.add(newCurrent);
					current = newCurrent;
				}
				current.add(mi);
			}
		}
	} 

	
	private final String dir;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaBorder,3,2,0,1,12,3,1,0,3,2.0,88,0.0,0,0.818181818,0.583333333,0,0,28.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import javax.swing.plaf.metal.MetalLookAndFeel;

public class TextAreaBorder extends AbstractBorder
{
	
	public void paintBorder(Component c, Graphics g, int x, int y,
		int width, int height)
	{
		g.translate(x,y);

		g.setColor(MetalLookAndFeel.getControlDarkShadow());
		g.drawRect(0,0,width-2,height-2);

		g.setColor(MetalLookAndFeel.getControlHighlight());
		g.drawLine(width-1,1,width-1,height-1);
		g.drawLine(1,height-1,width-1,height-1);

		g.setColor(MetalLookAndFeel.getControl());
		g.drawLine(width-2,2,width-2,2);
		g.drawLine(1,height-2,1,height-2);

		g.translate(-x,-y);
	} 

	
	public Insets getBorderInsets(Component c)
	{
		return new Insets(1,1,2,2);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.FileRootsVFS,7,2,0,4,21,15,1,4,4,0.833333333,141,0.5,0,0.886363636,0.458333333,1,2,18.85714286,5,1.5714,0,"

package org.gjt.sp.jedit.io;


import javax.swing.filechooser.FileSystemView;
import java.awt.Component;
import java.io.File;
import java.util.LinkedList;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.OperatingSystem;



public class FileRootsVFS extends VFS
{
	public static final String PROTOCOL = ""roots"";

	
	public FileRootsVFS()
	{
		super(""roots"",LOW_LATENCY_CAP | BROWSE_CAP, new String[] {
			EA_TYPE });
	} 

	
	public String getParentOfPath(String path)
	{
		return PROTOCOL + ':';
	} 

	
	public VFSFile[] _listFiles(Object session, String url,
		Component comp)
	{
		File[] roots = listRoots();

		if(roots == null)
			return null;

		VFSFile[] rootDE = new VFSFile[roots.length];
		for(int i = 0; i < roots.length; i++)
			rootDE[i] = new Root(roots[i]);

		return rootDE;
	} 

	
	public VFSFile _getFile(Object session, String path,
		Component comp)
	{
		return new Root(new File(path));
	} 

	
	private static FileSystemView fsView = FileSystemView.getFileSystemView();

	
	private static File[] listRoots()
	{
		if (OperatingSystem.isMacOS())
		{
			
			File[] volumes = new File(""/Volumes"").listFiles();
			LinkedList<File> roots = new LinkedList<File>();

			roots.add(new File(""/""));

			for (int i=0; i<volumes.length; i++)
			{
				
				if (volumes[i].isDirectory())
					roots.add(volumes[i]);
			}

			return roots.toArray(new File[roots.size()]);
		}
		else
		{
			File[] roots = File.listRoots();
			File[] desktop = fsView.getRoots();

			if(desktop == null)
				return roots;

			File[] rootsPlus = new File[roots.length + desktop.length];
			System.arraycopy(desktop, 0, rootsPlus, 0, desktop.length);
			System.arraycopy(roots, 0, rootsPlus, 1, roots.length);
			return rootsPlus;
		}
	} 

	

	
	static class Root extends VFSFile
	{
		Root(File file)
		{
			
			

			String path = file.getPath();
			setPath(path);
			setDeletePath(path);
			setSymlinkPath(path);

			if(fsView.isFloppyDrive(file))
			{
				setType(VFSFile.FILESYSTEM);
				setName(path);
			}
			else if(fsView.isDrive(file))
			{
				setType(VFSFile.FILESYSTEM);
				setName(path + ' '
					+ fsView.getSystemDisplayName(file));
			}
			else if(file.isDirectory())
			{
				if(fsView.isFileSystemRoot(file))
					setType(VFSFile.DIRECTORY);
				else
					setType(VFSFile.FILESYSTEM);

				if(OperatingSystem.isMacOS())
					setName(MiscUtilities.getFileName(path));
				else
					setName(path);
			}
			else
				setType(VFSFile.FILE);
		}

		public String getExtendedAttribute(String name)
		{
			if(name.equals(EA_TYPE))
				return super.getExtendedAttribute(name);
			else
			{
				
				
				return null;
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.ParserRuleSet,32,1,0,13,65,408,12,2,31,0.924098672,559,1.0,3,0.0,0.120967742,0,0,15.9375,11,1.7188,0,"

package org.gjt.sp.jedit.syntax;


import java.util.*;
import java.util.regex.Pattern;



public class ParserRuleSet
{
	
	
	public static ParserRuleSet getStandardRuleSet(byte id)
	{
		return standard[id];
	} 

	
	public ParserRuleSet(String modeName, String setName)
	{
		this.modeName = modeName;
		this.setName = setName;
		ruleMap = new HashMap<Character, List<ParserRule>>();
		imports = new ArrayList<ParserRuleSet>();
	} 

	
	public String getModeName()
	{
		return modeName;
	} 

	
	public String getSetName()
	{
		return setName;
	} 

	
	public String getName()
	{
		return modeName + ""::"" + setName;
	} 

	
	public Hashtable<String, String> getProperties()
	{
		return props;
	} 

	
	public void setProperties(Hashtable<String, String> props)
	{
		this.props = props;
		_noWordSep = null;
	} 

	
	
	public void resolveImports()
	{
		for (ParserRuleSet ruleset : imports)
		{
			if (!ruleset.imports.isEmpty())
			{
				
				ruleset.imports.remove(this);
				ruleset.resolveImports();
			}

			for (List<ParserRule> rules : ruleset.ruleMap.values())
			{
				for (ParserRule rule : rules)
				{
					addRule(rule);
				}
			}

			if (ruleset.keywords != null)
			{
				if (keywords == null)
					keywords = new KeywordMap(ignoreCase);
				keywords.add(ruleset.keywords);
			}
		}
		imports.clear();
	} 

	
	
	public void addRuleSet(ParserRuleSet ruleset)
	{
		imports.add(ruleset);
	} 

	
	public void addRule(ParserRule r)
	{
		ruleCount++;
		Character[] keys;
		if (null == r.upHashChars)
		{
			keys = new Character[1];
			if ((null == r.upHashChar) || (0 >= r.upHashChar.length()))
			{
				keys[0] = null;
			}
			else
			{
				keys[0] = Character.valueOf(r.upHashChar.charAt(0));
			}
		}
		else
		{
			keys = new Character[r.upHashChars.length];
			int i = 0;
			for (char upHashChar : r.upHashChars)
			{
				keys[i++] = upHashChar;
			}
		}
		for (Character key : keys)
		{
			List<ParserRule> rules = ruleMap.get(key);
			if (null == rules)
			{
				rules = new ArrayList<ParserRule>();
				ruleMap.put(key,rules);
			}
			int ruleAmount = rules.size();
			rules.add(r);
			
			if (ruleAmount > 0)
			{
				rules.get(ruleAmount).next = r;
			}
		}
	} 

	
	
	@Deprecated
	public ParserRule getRules(char ch)
	{
		List<ParserRule> rules = getRules(Character.valueOf(ch));
		return rules.get(0);
	} 

	
	public List<ParserRule> getRules(Character key)
	{
		List<ParserRule> rulesForNull = ruleMap.get(null);
		boolean emptyForNull = (rulesForNull == null) || (rulesForNull.size() == 0);
		Character upperKey = null == key ? null : Character.valueOf(Character.toUpperCase(key.charValue()));
		List<ParserRule> rulesForKey = null == upperKey ? null : ruleMap.get(upperKey);
		boolean emptyForKey = (rulesForKey == null) || (rulesForKey.size() == 0);
		if (emptyForNull && emptyForKey)
		{
			return Collections.emptyList();
		}
		else if (emptyForKey)
		{
			return rulesForNull;
		}
		else if (emptyForNull)
		{
			return rulesForKey;
		}
		else
		{
			int size = rulesForNull.size() + rulesForKey.size();
			ArrayList<ParserRule> mixed = new ArrayList<ParserRule>(size);
			mixed.addAll(rulesForKey);
			mixed.addAll(rulesForNull);
			
			rulesForKey.get(rulesForKey.size() - 1).next = rulesForNull.get(0);
			return mixed;
		}
	} 

	
	public int getRuleCount()
	{
		return ruleCount;
	} 

	
	
	public int getTerminateChar()
	{
		return terminateChar;
	} 

	
	public void setTerminateChar(int atChar)
	{
		terminateChar = (atChar >= 0) ? atChar : -1;
	} 

	
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	public void setIgnoreCase(boolean b)
	{
		ignoreCase = b;
	} 

	
	public KeywordMap getKeywords()
	{
		return keywords;
	} 

	
	public void setKeywords(KeywordMap km)
	{
		keywords = km;
		_noWordSep = null;
	} 

	
	public boolean getHighlightDigits()
	{
		return highlightDigits;
	} 

	
	public void setHighlightDigits(boolean highlightDigits)
	{
		this.highlightDigits = highlightDigits;
	} 

	
	public Pattern getDigitRegexp()
	{
		return digitRE;
	} 

	
	public void setDigitRegexp(Pattern digitRE)
	{
		this.digitRE = digitRE;
	} 

	
	public ParserRule getEscapeRule()
	{
		return escapeRule;
	} 

	
	public void setEscapeRule(ParserRule escapeRule)
	{
		this.escapeRule = escapeRule;
	} 

	
	public byte getDefault()
	{
		return defaultToken;
	} 

	
	public void setDefault(byte def)
	{
		defaultToken = def;
	} 

	
	public String getNoWordSep()
	{
		if(_noWordSep == null)
		{
			_noWordSep = noWordSep;
			if(noWordSep == null)
				noWordSep = """";
			if(keywords != null)
				noWordSep += keywords.getNonAlphaNumericChars();
		}
		return noWordSep;
	} 

	
	public void setNoWordSep(String noWordSep)
	{
		this.noWordSep = noWordSep;
		_noWordSep = null;
	} 

	
	
	public boolean isBuiltIn()
	{
		return builtIn;
	} 

	
	@Override
	public String toString()
	{
		return getClass().getName() + '[' + modeName + ""::"" + setName + ']';
	} 

	
	private static ParserRuleSet[] standard;

	static
	{
		standard = new ParserRuleSet[Token.ID_COUNT];
		for(byte i = 0; i < Token.ID_COUNT; i++)
		{
			standard[i] = new ParserRuleSet(null,null);
			standard[i].setDefault(i);
			standard[i].builtIn = true;
		}
	}

	private String modeName, setName;
	private Hashtable<String, String> props;

	private KeywordMap keywords;

	private int ruleCount;

	private Map<Character, List<ParserRule>> ruleMap;

	private final List<ParserRuleSet> imports;

	
	private int terminateChar = -1;
	private boolean ignoreCase = true;
	private byte defaultToken;
	private ParserRule escapeRule;

	private boolean highlightDigits;
	private Pattern digitRE;

	private String _noWordSep;
	private String noWordSep;

	private boolean builtIn;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.help.HistoryButton,10,5,0,8,30,31,4,5,4,0.930555556,158,0.75,3,0.986404834,0.2,1,1,14.0,1,0.9,0,"

package org.gjt.sp.jedit.help;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.RolloverButton;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;



public class HistoryButton extends JPanel implements ActionListener
{
	public static final int BACK    = 0;
	public static final int FORWARD = 1;

	
	private int type;
	private HelpHistoryModel history;
	private RolloverButton arrow_button;
	private RolloverButton drop_button;
	private JPopupMenu historyList;
	private ActionListener arrowActionListener;
	

	
	public HistoryButton(int type, HelpHistoryModel model)
	{
		super();
		arrow_button = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(type==BACK
						? ""helpviewer.back.icon""
						: ""helpviewer.forward.icon"")));
		arrow_button.setToolTipText(
			jEdit.getProperty(type==BACK
						? ""helpviewer.back.label""
						: ""helpviewer.forward.label""));
		Box box = new Box(BoxLayout.X_AXIS);
		drop_button = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
		drop_button.addActionListener(new DropActionHandler());
		box.add(arrow_button);
		box.add(drop_button);
		this.setMaximumSize(new Dimension(
			drop_button.getPreferredSize().width +
			arrow_button.getPreferredSize().width +
			5,
			arrow_button.getPreferredSize().height + 10)
			);
		this.add(box);
		this.type = type;
		this.history = model;
	} 

	
	public void setEnabled(boolean state)
	{
		super.setEnabled(state);
		drop_button.setEnabled(state);
		arrow_button.setEnabled(state);
	} 

	
	public void addActionListener(ActionListener al)
	{
		arrow_button.addActionListener(this);
		arrowActionListener = al;
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		arrowActionListener.actionPerformed(
			new ActionEvent(this,
				ActionEvent.ACTION_PERFORMED,
				evt.getActionCommand(),
				evt.getWhen(),
				evt.getModifiers()
				)
			);
	} 

	
	private HistoryButton getParentHistoryButton()
	{
		return this;
	} 

	

	
	class DropActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			historyList = new JPopupMenu();
			HelpHistoryModel.HistoryEntry[] urls;
			if (type == BACK)
			{
				urls = history.getPreviousURLs();
			}
			else
			{
				urls = history.getNextURLs();
			}
			if (urls != null)
			{
				if (type == BACK) {
					for (int i=urls.length-1 ; i>=0 ; i--)
					{
						if (urls[i] != null)
						{
							historyList.add(new HistoryListActionHandler(urls[i]));
						}
					}
				}
				else
				{
					for (int i=0 ; i<urls.length ; i++)
					{
						if (urls[i] != null)
						{
							historyList.add(new HistoryListActionHandler(urls[i]));
						}
					}
				}

				historyList.show((JComponent)evt.getSource(),0,0);
			}
		} 
	} 

	
	class HistoryListActionHandler extends AbstractAction
	{
		HelpHistoryModel.HistoryEntry entry;

		
		HistoryListActionHandler(HelpHistoryModel.HistoryEntry entry)
		{
			super(entry.title);
			this.entry = entry;
			this.putValue(Action.ACTION_COMMAND_KEY,entry.url + ':' + entry.scrollPosition);
		} 

		
		public void actionPerformed(ActionEvent ae)
		{
			getParentHistoryButton().actionPerformed(ae);
			history.setCurrentEntry(entry);
		} 
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.TokenMgrError,6,3,0,2,19,15,2,0,4,1.12,184,0.0,0,0.85,0.5,1,1,28.83333333,14,2.8333,0,"
package org.gjt.sp.jedit.bsh;

public class TokenMgrError extends Error
{
   

   
   static final int LEXICAL_ERROR = 0;

   
   static final int STATIC_LEXER_ERROR = 1;

   
   static final int INVALID_LEXICAL_STATE = 2;

   
   static final int LOOP_DETECTED = 3;

   
   int errorCode;

   
   protected static final String addEscapes(String str) {
	  StringBuilder retval = new StringBuilder();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

   
   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
      return(""Lexical error at line "" +
           errorLine + "", column "" +
           errorColumn + "".  Encountered: "" +
           (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
           ""after : \"""" + addEscapes(errorAfter) + ""\"""");
   }

   
   public String getMessage() {
      return super.getMessage();
   }

   

   public TokenMgrError() {
   }

   public TokenMgrError(String message, int reason) {
      super(message);
      errorCode = reason;
   }

   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchRequest,9,2,0,23,69,12,4,23,1,0.75,519,1.0,4,0.428571429,0.234567901,0,0,55.88888889,16,3.6667,0,"

package org.gjt.sp.jedit.search;


import javax.swing.tree.*;
import javax.swing.*;

import org.gjt.sp.jedit.textarea.Selection;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.*;



class HyperSearchRequest extends WorkRequest
{
	
	HyperSearchRequest(View view, SearchMatcher matcher,
		HyperSearchResults results, Selection[] selection)
	{
		this.view = view;
		this.matcher = matcher;

		this.results = results;
		searchString = SearchAndReplace.getSearchString();
		rootSearchNode = new DefaultMutableTreeNode(new HyperSearchOperationNode(searchString, matcher));

		this.selection = selection;
	} 

	
	public void run()
	{
		setStatus(jEdit.getProperty(""hypersearch-status""));

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		String[] files = fileset.getFiles(view);
		if(files == null || files.length == 0)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""empty-fileset"",null);
					results.searchDone(rootSearchNode);
				}
			});
			return;
		}

		setMaximum(fileset.getFileCount(view));

		
		

		
		String searchingCaption = jEdit.getProperty(""hypersearch-results.searching"",
				new String[] { SearchAndReplace.getSearchString() }) + ' ';
		try
		{
			if(selection != null)
			{
				Buffer buffer = view.getBuffer();

				searchInSelection(buffer);
			}
			else
			{
				int current = 0;

				long lastStatusTime = 0;
				int resultCount = 0;
				boolean asked = false;
				int maxResults = jEdit.getIntegerProperty(""hypersearch.maxWarningResults"");
loop:				for(int i = 0; i < files.length; i++)
				{
					if(jEdit.getBooleanProperty(""hyperSearch-stopButton""))
					{
						jEdit.setTemporaryProperty(""hyperSearch-stopButton"", ""false"");
						Log.log(Log.MESSAGE, this, ""Search stopped by user action (stop button)"");
						break;
					}
					if (!asked && resultCount > maxResults && maxResults != 0)
					{
						Log.log(Log.DEBUG, this, ""Search in progress, "" + resultCount +
									 "" occurrences found, asking the user to stop"");
						asked = true;
						int ret = GUIUtilities.confirm(view, ""hypersearch.tooManyResults"",
									       new Object[]{resultCount},
									       JOptionPane.YES_NO_OPTION,
									       JOptionPane.QUESTION_MESSAGE);
						if (ret == JOptionPane.YES_OPTION)
						{
							Log.log(Log.MESSAGE, this, ""Search stopped by user action"");
							break;
						}
					}
					String file = files[i];
					current++;

					long currentTime = System.currentTimeMillis();
					if(currentTime - lastStatusTime > 250)
					{
						setValue(current);
						lastStatusTime = currentTime;
						results.setSearchStatus(searchingCaption + file);
					}

					Buffer buffer = jEdit.openTemporary(null,null,file,false);
					if(buffer == null)
						continue loop;

					resultCount += doHyperSearch(buffer, 0, buffer.getLength());
				}
				Log.log(Log.MESSAGE, this, resultCount +"" OCCURENCES"");
			}
		}
		catch(final Exception e)
		{
			Log.log(Log.ERROR,this,e);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					SearchAndReplace.handleError(view,e);
				}
			});
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					results.searchDone(rootSearchNode, selectNode);
				}
			});
		}
	} 

	

	
	private View view;
	private SearchMatcher matcher;
	private HyperSearchResults results;
	private DefaultMutableTreeNode rootSearchNode;
	private Selection[] selection;
	private String searchString;
	private DefaultMutableTreeNode selectNode;
	

	
	private int searchInSelection(Buffer buffer) throws Exception
	{
		setAbortable(false);

		int resultCount = 0;

		try
		{
			buffer.readLock();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Rect)
				{
					for(int j = s.getStartLine();
						j <= s.getEndLine(); j++)
					{
						resultCount += doHyperSearch(buffer,
							s.getStart(buffer,j),
							s.getEnd(buffer,j));
					}
				}
				else
				{
					resultCount += doHyperSearch(buffer,
						s.getStart(),s.getEnd());
				}
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		setAbortable(true);

		return resultCount;
	} 

	
	private int doHyperSearch(Buffer buffer, int start, int end)
		throws Exception
	{
		setAbortable(false);

		HyperSearchFileNode hyperSearchFileNode = new HyperSearchFileNode(buffer.getPath());
		DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(hyperSearchFileNode);

		int resultCount = doHyperSearch(buffer,start,end,bufferNode);
		hyperSearchFileNode.setCount(resultCount);
		if(resultCount != 0)
			rootSearchNode.insert(bufferNode,rootSearchNode.getChildCount());

		setAbortable(true);

		return resultCount;
	} 

	
	private int doHyperSearch(Buffer buffer, int start, int end,
		DefaultMutableTreeNode bufferNode)
	{
		int resultCount = 0;
		JEditTextArea textArea = jEdit.getActiveView().getTextArea();
		int caretLine = textArea.getBuffer() == buffer ? textArea.getCaretLine() : -1;
		try
		{
			buffer.readLock();

			boolean endOfLine = buffer.getLineEndOffset(
				buffer.getLineOfOffset(end)) - 1 == end;

			int offset = start;

			HyperSearchResult lastResult = null;
loop:			for(int counter = 0; ; counter++)
			{
				boolean startOfLine = buffer.getLineStartOffset(
					buffer.getLineOfOffset(offset)) == offset;

				SearchMatcher.Match match = matcher.nextMatch(
					buffer.getSegment(offset, end - offset),
					startOfLine,endOfLine,counter == 0,
					false);
				if(match == null)
					break loop;

				int newLine = buffer.getLineOfOffset(
					offset + match.start);
				if(lastResult == null || lastResult.line != newLine)
				{
					lastResult = new HyperSearchResult(
						buffer,newLine);
					DefaultMutableTreeNode child = new DefaultMutableTreeNode(
						lastResult, false);
					if (lastResult.line == caretLine)
						selectNode = child;
					bufferNode.add(child);
				}

				lastResult.addOccur(offset + match.start,
					offset + match.end);

				offset += match.end;
				resultCount++;
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		return resultCount;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.BufferUpdate,6,2,0,11,14,5,10,3,5,0.933333333,86,0.166666667,1,0.428571429,0.4,1,1,11.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class BufferUpdate extends EBMessage
{
	
	
	public static final Object CREATED = ""CREATED"";
	
	
	public static final Object CLOSING = ""CLOSING"";
	
	public static final Object LOAD_STARTED = ""LOAD_STARTED"";

	
	public static final Object LOADED = ""LOADED"";

	
	public static final Object CLOSED = ""CLOSED"";

	
	public static final Object DIRTY_CHANGED = ""DIRTY_CHANGED"";

	
	public static final Object MARKERS_CHANGED = ""MARKERS_CHANGED"";

	
	public static final Object SAVING = ""SAVING"";

	
	public static final Object SAVED = ""SAVED"";

	
	public static final Object PROPERTIES_CHANGED = ""PROPERTIES_CHANGED"";
	

	
	
	public BufferUpdate(Buffer buffer, View view, Object what)
	{
		super(buffer);

		this.view = view;

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public Buffer getBuffer()
	{
		return (Buffer)getSource();
	} 

	
	
	public View getView()
	{
		return view;
	} 

	
	public String paramString()
	{
		return ""what="" + what + "",view="" + view + "",""
			+ super.paramString();
	} 

	
	private Object what;
	private View view;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.ClassVisitor,5,1,0,2,5,10,1,1,5,2.0,5,0.0,0,0.0,0.64,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



public interface ClassVisitor {

  

  void visit (
    int access,
    String name,
    String superName,
    String[] interfaces,
    String sourceFile);

  

  void visitInnerClass (
    String name,
    String outerName,
    String innerName,
    int access);

  

  void visitField (int access, String name, String desc, Object value);

  

  CodeVisitor visitMethod (
    int access,
    String name,
    String desc,
    String[] exceptions);

  

  void visitEnd ();
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.CodeVisitor,17,1,0,5,17,136,4,1,17,2.0,17,0.0,0,0.0,0.394957983,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



public interface CodeVisitor {

  

  void visitInsn (int opcode);

  

  void visitIntInsn (int opcode, int operand);

  

  void visitVarInsn (int opcode, int var);

  

  void visitTypeInsn (int opcode, String desc);

  

  void visitFieldInsn (int opcode, String owner, String name, String desc);

  

  void visitMethodInsn (int opcode, String owner, String name, String desc);

  

  void visitJumpInsn (int opcode, Label label);

  

  void visitLabel (Label label);

  
  
  

  

  void visitLdcInsn (Object cst);

  

  void visitIincInsn (int var, int increment);

  

  void visitTableSwitchInsn (int min, int max, Label dflt, Label labels[]);

  

  void visitLookupSwitchInsn (Label dflt, int keys[], Label labels[]);

  

  void visitMultiANewArrayInsn (String desc, int dims);

  
  
  

  

  void visitTryCatchBlock (Label start, Label end, Label handler, String type);

  

  void visitMaxs (int maxStack, int maxLocals);

  
  
  

  

  void visitLocalVariable (
    String name,
    String desc,
    Label start,
    Label end,
    int index);

  

  void visitLineNumber (int line, Label start);
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaTransferHandler,9,2,0,17,71,24,1,17,4,0.7,667,1.0,1,0.68,0.462962963,2,8,72.55555556,11,3.5556,0,"

package org.gjt.sp.jedit.textarea;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.bufferset.BufferSetManager;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkRequest;

import javax.swing.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.io.File;
import java.net.URI;
import java.util.List;



public class TextAreaTransferHandler extends TransferHandler
{
	
	private static JEditTextArea dragSource;
	private static boolean compoundEdit;
	private static boolean sameTextArea;
	private static int insertPos;
	private static int insertOffset;
	
	
	

	
	@Override
	protected Transferable createTransferable(JComponent c)
	{
		Log.log(Log.DEBUG,this,""createTransferable()"");
		JEditTextArea textArea = (JEditTextArea)c;
		if(textArea.getSelectionCount() == 0)
			return null;
		else
		{
			dragSource = textArea;
			return new TextAreaSelection(textArea);
		}
	} 

	
	@Override
	public int getSourceActions(JComponent c)
	{
		return COPY_OR_MOVE;
	} 

	
	@Override
	public boolean importData(JComponent c, Transferable t)
	{
		Log.log(Log.DEBUG,this,""Import data"");

		if(!canImport(c,t.getTransferDataFlavors()))
			return false;

		boolean returnValue;

		try
		{
			if(t.isDataFlavorSupported(DataFlavor.javaFileListFlavor))
			{
				returnValue = importFile(c,t);
			}
			else
			{
				DataFlavor uriListStringDataFlavor = null;
				DataFlavor[] dataFlavors = t.getTransferDataFlavors();
				
				for (int i = 0;i<dataFlavors.length;i++)
				{
					DataFlavor dataFlavor = dataFlavors[i];
					if (""text"".equals(dataFlavor.getPrimaryType()) &&
					    ""uri-list"".equals(dataFlavor.getSubType()) &&
					    dataFlavor.getRepresentationClass() == String.class)
					{
						uriListStringDataFlavor = dataFlavor;
						break;
					}
 				}
				
				if (uriListStringDataFlavor != null &&t.isDataFlavorSupported(uriListStringDataFlavor))
				{
					returnValue = importURIList(c,t,uriListStringDataFlavor);
				}
				else
				{
					returnValue = importText(c,t);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			returnValue = false;
		}

		GUIUtilities.getView(c).toFront();
		GUIUtilities.getView(c).requestFocus();
		c.requestFocus();

		return returnValue;
	} 

	
	private boolean importFile(JComponent c, Transferable t)
		throws Exception
	{
		Log.log(Log.DEBUG,this,""=> File list"");
		EditPane editPane = (EditPane)
			GUIUtilities.getComponentParent(
			c,EditPane.class);
		View view = editPane.getView();
		Buffer buffer = null;

		List<File> data = (List<File>) t.getTransferData(DataFlavor.javaFileListFlavor);

		boolean browsedDirectory = false;
		BufferSetManager bufferSetManager = jEdit.getBufferSetManager();
		for (File file : data)
		{
			if (file.isDirectory())
			{
				if (!browsedDirectory)
				{
					VFSBrowser.browseDirectory(view, file.getPath());
					browsedDirectory = true;
				}
				continue;
			}
			Buffer _buffer = jEdit.openFile(editPane, file.getPath());
			if (_buffer != null)
			{
				buffer = _buffer;
				bufferSetManager.addBuffer(editPane, buffer);
			}
		}

		if(buffer != null)
			editPane.setBuffer(buffer);
		view.toFront();
		view.requestFocus();
		editPane.requestFocus();

		return true;
	} 

	
	private boolean importURIList(JComponent c, Transferable t,DataFlavor uriListStringDataFlavor)
		throws Exception
	{
		String str = (String) t.getTransferData(uriListStringDataFlavor);

		Log.log(Log.DEBUG,this,""=> URIList \""""+str+ '\""');
		EditPane editPane = (EditPane) GUIUtilities.getComponentParent(c, EditPane.class);
		View view = editPane.getView();
		JEditTextArea textArea = (JEditTextArea) c;
		if (dragSource == null)
		{
			boolean found = false;
			String[] components = str.split(""\r\n"");

			boolean browsedDirectory = false;
			for (int i = 0;i<components.length;i++)
			{
				String str0 = components[i];

				if (str0.length() > 0)
				{
					URI uri = new URI(str0); 

					if (""file"".equals(uri.getScheme()))
					{
						File file = new File(uri.getPath());
						if (file.isDirectory())
						{
							if (!browsedDirectory)
							{
								VFSBrowser.browseDirectory(view, file.getPath());
								browsedDirectory = true;
							}
						}
						else
						{
							VFSManager.runInWorkThread(new DraggedURLLoader(textArea,uri.getPath()));
						}
						found = true;
					}
					else
					{
						Log.log(Log.DEBUG,this,""I do not know how to handle this URI ""+uri+"", ignoring."");
					}
				}
				else
				{
					
					if (i!=components.length-1)
					{
						Log.log(Log.DEBUG,this,""Odd: there is an empty line in the uri list which is not the last line."");
					}
				}
			}

			if (found)
			{
				return true;
			}
		}
		
		return true;
	} 
	
	
	private boolean importText(JComponent c, Transferable t)
		throws Exception
	{
		String str = (String)t.getTransferData(
			DataFlavor.stringFlavor);
		str = str.trim();
		Log.log(Log.DEBUG,this,""=> String \""""+str+ '\""');
		
		JEditTextArea textArea = (JEditTextArea)c;
		if (dragSource == null)
		{
			boolean found = false;
			String[] components = str.split(""\n"");

			for (int i = 0;i<components.length;i++)
			{
				String str0 = components[i];
				
				
				VFS vfs = VFSManager.getVFSForPath(str0);
				if (!(vfs instanceof FileVFS) || str.startsWith(""file:
				{

					if (str0.startsWith(""file:
					{
						str0 = str0.substring(7);
					}

					VFSManager.runInWorkThread(new DraggedURLLoader(textArea,str0));
				}
				found = true;
				
			}
			
			if (found)
				return true;
		}

		if(dragSource != null
			&& textArea.getBuffer()
			== dragSource.getBuffer())
		{
			compoundEdit = true;
			textArea.getBuffer().beginCompoundEdit();
		}
		
		
		sameTextArea = textArea == dragSource;

		int caret = textArea.getCaretPosition();
		Selection s = textArea.getSelectionAtOffset(caret);

		
		if(s != null)
		{
			if(sameTextArea)
				return false;
			
			int startPos = s.start;
			textArea.setSelectedText(s,str);
			textArea.setSelection(new Selection.Range(startPos,startPos+str.length()));
		}
		
		else
		{
			if (sameTextArea)
			{
				insertPos = caret;
				insertOffset = 0;
				Selection[] selections = textArea.getSelection();
				for (int i=0;i<selections.length;i++)
				{
					if (selections[i].end < insertPos + insertOffset)
						insertOffset -= selections[i].end - selections[i].start;
				}
			}
			else
			{
				textArea.getBuffer().insert(caret,str);
				textArea.setSelection(new Selection.Range(caret,caret+str.length()));
			}
		}
		textArea.scrollToCaret(true);

		return true;
	} 

	
	@Override
	protected void exportDone(JComponent c, Transferable t,
		int action)
	{
		Log.log(Log.DEBUG,this,""Export done"");

		JEditTextArea textArea = (JEditTextArea)c;

		try
		{
			
			if (action == NONE)
			{
				Log.log(Log.DEBUG,this,""Export impossible"");
				return;
			}

			if(t == null)
			{
				Log.log(Log.DEBUG,this,""=> Null transferrable"");
				textArea.selectNone();
			}
			else if(t.isDataFlavorSupported(
				DataFlavor.stringFlavor))
			{
				Log.log(Log.DEBUG,this,""=> String"");
				if (sameTextArea)
				{
					if(action == MOVE)
					{
						textArea.setSelectedText(null,false);
						insertPos += insertOffset;
					} 
					try
					{
						String str = (String)t.getTransferData(DataFlavor.stringFlavor);
						textArea.getBuffer().insert(insertPos,str);
						textArea.setSelection(new Selection.Range(insertPos,insertPos+str.length()));
					}
					catch(Exception e)
					{
						Log.log(Log.DEBUG,this,""exportDone in sameTextArea"");
						Log.log(Log.DEBUG,this,e);
					}
				}
				else
				{
					if(action == MOVE)
						textArea.setSelectedText(null,false);
					else
						textArea.selectNone();
				}
			}
		}
		finally
		{
			if(compoundEdit)
			{
				compoundEdit = false;
				textArea.getBuffer().endCompoundEdit();
			}
		}

		dragSource = null;
	} 

	
	@Override
	public boolean canImport(TransferSupport support)
	{
		if (support.getTransferable() instanceof TextAreaSelection)
			return true;
		else
		{
			support.setDropAction(COPY);
			return super.canImport(support);
		}
	}

	@Override
	public boolean canImport(JComponent c, DataFlavor[] flavors)
	{
		JEditTextArea textArea = (JEditTextArea)c;

		
		
		boolean returnValue = false;

		for(int i = 0; i < flavors.length; i++)
		{
			if(flavors[i].equals(
				DataFlavor.javaFileListFlavor))
			{
				returnValue = true;
			}
			else if(flavors[i].equals(
				DataFlavor.stringFlavor))
			{
				if(textArea.isEditable())
					returnValue = true;
			}
			else if (flavors[i].getRepresentationClass().equals(java.io.InputStream.class))
			{
				
				
				returnValue = true;
				break;
			}
		}

		Log.log(Log.DEBUG,this,""canImport() returning ""
			+ returnValue);
		return returnValue;
	} 

	
	private static class TextAreaSelection extends StringSelection
	{
		final JEditTextArea textArea;

		TextAreaSelection(JEditTextArea textArea)
		{
			super(textArea.getSelectedText());
			this.textArea = textArea;
		}
	} 

	
	private static class DraggedURLLoader extends WorkRequest
	{
		private final JEditTextArea textArea;
		private final String url;
		
		DraggedURLLoader(JEditTextArea textArea, String url)
		{
			this.textArea = textArea;
			this.url = url;
		}
		public void run()
		{
			EditPane editPane = EditPane.get(textArea);
			jEdit.openFile(editPane,url);
		}
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.Chunk,11,2,0,11,40,0,7,4,10,0.73,584,0.2,1,0.272727273,0.266666667,0,0,51.18181818,10,4.0909,0,"

package org.gjt.sp.jedit.syntax;


import javax.swing.text.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;

import org.gjt.sp.jedit.Debug;



public class Chunk extends Token
{
	
	private static final char[] EMPTY_TEXT = new char[0];
	

	
	
	public static float paintChunkList(Chunk chunks,
		Graphics2D gfx, float x, float y, boolean glyphVector)
	{
		Rectangle clipRect = gfx.getClipBounds();

		float _x = 0.0f;

		while(chunks != null)
		{
			
			if(x + _x + chunks.width > clipRect.x
				&& x + _x < clipRect.x + clipRect.width)
			{
				
				if(Debug.CHUNK_PAINT_DEBUG)
				{
					gfx.draw(new Rectangle2D.Float(x + _x,y - 10,
						chunks.width,10));
				}

				if(chunks.accessable && chunks.visible)
				{
					gfx.setFont(chunks.style.getFont());
					gfx.setColor(chunks.style.getForegroundColor());

					if(glyphVector && chunks.gv != null)
						gfx.drawGlyphVector(chunks.gv,x + _x,y);
					else if(chunks.str != null)
					{
						gfx.drawString(chunks.str,
							(int)(x + _x),(int)y);
					}
				}
			}

			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}

		return _x;
	} 

	
	
	public static float paintChunkBackgrounds(Chunk chunks,
		Graphics2D gfx, float x, float y)
	{
		Rectangle clipRect = gfx.getClipBounds();

		float _x = 0.0f;

		FontMetrics forBackground = gfx.getFontMetrics();

		int ascent = forBackground.getAscent();
		int height = forBackground.getHeight();

		while(chunks != null)
		{
			
			if(x + _x + chunks.width > clipRect.x
				&& x + _x < clipRect.x + clipRect.width)
			{
				if(chunks.accessable)
				{
					
					Color bgColor = chunks.background;
					if(bgColor != null)
					{
						gfx.setColor(bgColor);

						gfx.fill(new Rectangle2D.Float(
							x + _x,y - ascent,
							_x + chunks.width - _x,
							height));
					} 
				}
			}

			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}

		return _x;
	} 

	
	
	public static float offsetToX(Chunk chunks, int offset)
	{
		if(chunks != null && offset < chunks.offset)
		{
			throw new ArrayIndexOutOfBoundsException(offset + "" < ""
				+ chunks.offset);
		}

		float x = 0.0f;

		while(chunks != null)
		{
			if(chunks.accessable && offset < chunks.offset + chunks.length)
				return x + chunks.offsetToX(offset - chunks.offset);

			x += chunks.width;
			chunks = (Chunk)chunks.next;
		}

		return x;
	} 

	
	
	public static int xToOffset(Chunk chunks, float x, boolean round)
	{
		float _x = 0.0f;

		while(chunks != null)
		{
			if(chunks.accessable && x < _x + chunks.width)
				return chunks.xToOffset(x - _x,round);

			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}

		return -1;
	} 

	
	public boolean accessable;
	public boolean visible;
	public boolean initialized;

	
	public SyntaxStyle style;
	
	
	public Color background;
	public float width;
	public GlyphVector gv;
	public String str;
	

	
	public Chunk(float width, int offset, ParserRuleSet rules)
	{
		super(Token.NULL,offset,0,rules);
		this.width = width;
	} 

	
	public Chunk(byte id, int offset, int length, ParserRuleSet rules,
		SyntaxStyle[] styles, byte defaultID)
	{
		super(id,offset,length,rules);
		accessable = true;
		style = styles[id];
		background = style.getBackgroundColor();
		if(background == null)
			background = styles[defaultID].getBackgroundColor();
	} 

	
	public final float[] getPositions()
	{
		if(gv == null)
			return null;

		if(positions == null)
			positions = gv.getGlyphPositions(0,length,null);

		return positions;
	} 

	
	public final float offsetToX(int offset)
	{
		if(!visible)
			return 0.0f;
		else
			return getPositions()[offset * 2];
	} 

	
	public final int xToOffset(float x, boolean round)
	{
		if (!visible)
		{
			if (round && width - x < x)
				return offset + length;
			else
				return offset;
		}

		float[] pos = getPositions();

		for(int i = 0; i < length; i++)
		{
			float glyphX = pos[i*2];
			float nextX = (i == length - 1
				? width : pos[i*2+2]);

			if(nextX > x)
			{
				if(!round || nextX - x > x - glyphX)
					return offset + i;
				else
					return offset + i + 1;
			}
		}

		
		return -1;
	} 

	
	public void init(Segment seg, TabExpander expander, float x,
		FontRenderContext fontRenderContext)
	{
		initialized = true;

		if(!accessable)
		{
			
		}
		else if(length == 1 && seg.array[seg.offset + offset] == '\t')
		{
			visible = false;
			float newX = expander.nextTabStop(x,offset + length);
			width = newX - x;
		}
		else
		{
			visible = true;

			str = new String(seg.array,seg.offset + offset,length);

			char[] textArray = seg.array;
			int textStart = seg.offset + offset;
			
			
			if (SUN_JAVA_5)
			{
				
				
				
				char[] copy = new char[length];
				System.arraycopy(textArray, textStart,
					copy, 0, length);
				textArray = copy;
				textStart = 0;
			} 
			int textLimit = textStart + length;
			
			int layoutFlags = Font.LAYOUT_LEFT_TO_RIGHT
				| Font.LAYOUT_NO_START_CONTEXT
				| Font.LAYOUT_NO_LIMIT_CONTEXT;
			Font font = style.getFont();
			gv = font.layoutGlyphVector(
				fontRenderContext,
				textArray, textStart, textLimit, layoutFlags);
			
			
			
			font.layoutGlyphVector(fontRenderContext, EMPTY_TEXT, 0, 0,
			                       layoutFlags);
			Rectangle2D logicalBounds = gv.getLogicalBounds();

			width = (float)logicalBounds.getWidth();
		}
	} 

	
	private float[] positions;

	
	private static final boolean SUN_JAVA_5;
	static
	{
		boolean sun_java_5 = false;
		String vendor = System.getProperty(""java.vendor"");
		
		
		if (vendor != null && (vendor.startsWith(""Sun"") ||
					vendor.startsWith(""Apple"")))
		{
			String version = System.getProperty(""java.version"");
			if (version != null && version.startsWith(""1.5""))
			{
				sun_java_5 = true;
			}
		}
		SUN_JAVA_5 = sun_java_5;
	}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.BufferHistory,15,1,0,19,74,47,5,16,7,0.595238095,561,1.0,1,0.0,0.130952381,0,0,36.2,8,2.2,0,"

package org.gjt.sp.jedit;


import java.io.IOException;
import java.util.*;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.msg.DynamicMenuChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.IOUtilities;



public class BufferHistory
{
	
	
	public static class Entry
	{
		public String path;
		public int caret;
		public String selection;
		public String encoding;
		public String mode;

		public Selection[] getSelection()
		{
			return stringToSelection(selection);
		}

		public Entry(String path, int caret, String selection, String encoding, String mode)
		{
			this.path = path;
			this.caret = caret;
			this.selection = selection;
			this.encoding = encoding;
			this.mode = mode;
		}

		public String toString()
		{
			return path + "": "" + caret;
		}
	} 

	
	public static Entry getEntry(String path)
	{
		historyLock.readLock().lock();
		try
		{
			for (Entry entry : history)
			{
				if(MiscUtilities.pathsEqual(entry.path,path))
					return entry;
			}
		}
		finally
		{
			historyLock.readLock().unlock();
		}

		return null;
	} 

	
	public static void setEntry(String path, int caret, Selection[] selection,
		String encoding, String mode)
	{
		Entry entry = new Entry(path,caret,
			selectionToString(selection), encoding, mode);
		historyLock.writeLock().lock();
		try
		{
			removeEntry(path);
			addEntry(entry);
		}
		finally
		{
			historyLock.writeLock().unlock();
		}
		notifyChange();
	} 

	
	
	public static void clear()
	{
		historyLock.writeLock().lock();
		try
		{
			history.clear();
		}
		finally
		{
			historyLock.writeLock().unlock();
		}
		notifyChange();
	} 

	
	
	public static List<Entry> getHistory()
	{
		
		
		
		

		historyLock.readLock().lock();
		try
		{
			return (List<Entry>)history.clone();
		}
		finally
		{
			historyLock.readLock().unlock();
		}
	} 

	
	public static void load()
	{
		if(recentXML == null)
			return;

		if(!recentXML.fileExists())
			return;

		Log.log(Log.MESSAGE,BufferHistory.class,""Loading "" + recentXML);

		RecentHandler handler = new RecentHandler();
		try
		{
			recentXML.load(handler);
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
		trimToLimit(handler.result);
		history = handler.result;
	} 

	
	public static void save()
	{
		if(recentXML == null)
			return;

		if(recentXML.hasChangedOnDisk())
		{
			Log.log(Log.WARNING,BufferHistory.class,recentXML
				+ "" changed on disk; will not save recent""
				+ "" files"");
			return;
		}

		Log.log(Log.MESSAGE,BufferHistory.class,""Saving "" + recentXML);

		String lineSep = System.getProperty(""line.separator"");

		SettingsXML.Saver out = null;

		try
		{
			out = recentXML.openSaver();
			out.writeXMLDeclaration();

			out.write(""<!DOCTYPE RECENT SYSTEM \""recent.dtd\"">"");
			out.write(lineSep);
			out.write(""<RECENT>"");
			out.write(lineSep);

			
			
			List<Entry> snapshot = getHistory();

			for (Entry entry : snapshot)
			{
				out.write(""<ENTRY>"");
				out.write(lineSep);

				out.write(""<PATH>"");
				out.write(XMLUtilities.charsToEntities(entry.path,false));
				out.write(""</PATH>"");
				out.write(lineSep);

				out.write(""<CARET>"");
				out.write(String.valueOf(entry.caret));
				out.write(""</CARET>"");
				out.write(lineSep);

				if(entry.selection != null
					&& entry.selection.length() > 0)
				{
					out.write(""<SELECTION>"");
					out.write(entry.selection);
					out.write(""</SELECTION>"");
					out.write(lineSep);
				}

				if(entry.encoding != null)
				{
					out.write(""<ENCODING>"");
					out.write(entry.encoding);
					out.write(""</ENCODING>"");
					out.write(lineSep);
				}

				if (entry.mode != null)
				{
					out.write(""<MODE>"");
					out.write(entry.mode);
					out.write(""</MODE>"");
					out.write(lineSep);
				}

				out.write(""</ENTRY>"");
				out.write(lineSep);
			}

			out.write(""</RECENT>"");
			out.write(lineSep);

			out.finish();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
		finally
		{
			IOUtilities.closeQuietly(out);
		}
	} 

	
	private static LinkedList<Entry> history;
	private static ReentrantReadWriteLock historyLock;
	private static SettingsXML recentXML;

	
	static
	{
		history = new LinkedList<Entry>();
		historyLock = new ReentrantReadWriteLock();
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			recentXML = new SettingsXML(settingsDirectory, ""recent"");
		}
	} 

	
	private static void addEntry(Entry entry)
	{
		historyLock.writeLock().lock();
		try
		{
			history.addFirst(entry);
			trimToLimit(history);
		}
		finally
		{
			historyLock.writeLock().unlock();
		}
	} 

	
	private static void removeEntry(String path)
	{
		historyLock.writeLock().lock();
		try
		{
			Iterator<Entry> iter = history.iterator();
			while(iter.hasNext())
			{
				Entry entry = iter.next();
				if(MiscUtilities.pathsEqual(path,entry.path))
				{
					iter.remove();
					return;
				}
			}
		}
		finally
		{
			historyLock.writeLock().unlock();
		}
	} 

	
	private static String selectionToString(Selection[] s)
	{
		if(s == null)
			return null;

		StringBuilder buf = new StringBuilder();

		for(int i = 0; i < s.length; i++)
		{
			if(i != 0)
				buf.append(' ');

			Selection sel = s[i];
			if(sel instanceof Selection.Range)
				buf.append(""range "");
			else 
				buf.append(""rect "");
			buf.append(sel.getStart());
			buf.append(' ');
			buf.append(sel.getEnd());
		}

		return buf.toString();
	} 

	
	private static Selection[] stringToSelection(String s)
	{
		if(s == null)
			return null;

		List<Selection> selection = new ArrayList<Selection>();
		StringTokenizer st = new StringTokenizer(s);

		while(st.hasMoreTokens())
		{
			String type = st.nextToken();
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			if(end < start)
			{
				
				
				
				continue;
			}

			Selection sel;
			if(type.equals(""range""))
				sel = new Selection.Range(start,end);
			else 
				sel = new Selection.Rect(start,end);

			selection.add(sel);
		}

		Selection[] returnValue = new Selection[selection.size()];
		returnValue = selection.toArray(returnValue);
		return returnValue;
	} 

	
	private static void trimToLimit(LinkedList<Entry> list)
	{
		int max = jEdit.getIntegerProperty(""recentFiles"",50);
		while(list.size() > max)
			list.removeLast();
	} 

	
	private static void notifyChange()
	{
		EditBus.send(new DynamicMenuChanged(""recent-files""));
	} 

	
	private static class RecentHandler extends DefaultHandler
	{
		public LinkedList<Entry> result = new LinkedList<Entry>();

		public InputSource resolveEntity(String publicId, String systemId)
		{
			return XMLUtilities.findEntity(systemId, ""recent.dtd"", getClass());
		}

		public void endElement(String uri, String localName, String name)
		{
			if(name.equals(""ENTRY""))
			{
				result.addLast(new Entry(
					path,caret,selection,
					encoding,
					mode));
				path = null;
				caret = 0;
				selection = null;
				encoding = null;
				mode = null;
			}
			else if(name.equals(""PATH""))
				path = charData.toString();
			else if(name.equals(""CARET""))
				caret = Integer.parseInt(charData.toString());
			else if(name.equals(""SELECTION""))
				selection = charData.toString();
			else if(name.equals(""ENCODING""))
				encoding = charData.toString();
			else if(name.equals(""MODE""))
				mode = charData.toString();
			charData.setLength(0);
		}

		public void characters(char[] ch, int start, int length)
		{
			charData.append(ch,start,length);
		}

		

		
		private String path;
		private int caret;
		private String selection;
		private String encoding;
		private String mode;
		private StringBuilder charData = new StringBuilder();
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.classpath.BshClassPath,49,1,0,13,128,1014,3,11,29,0.851190476,1254,0.5,4,0.0,0.10058309,0,0,24.30612245,8,2.0204,0,"

package org.gjt.sp.jedit.bsh.classpath;

import java.util.*;
import java.util.zip.*;
import java.io.*;
import java.net.*;
import java.io.File;

import org.gjt.sp.jedit.bsh.StringUtil;
import org.gjt.sp.jedit.bsh.ClassPathException;
import java.lang.ref.WeakReference;
import org.gjt.sp.jedit.bsh.NameSource;


public class BshClassPath 
	implements ClassPathListener, NameSource
{
	String name;

	
	private List path;
	
	private List compPaths;

	
	private Map packageMap;
	
	private Map classSource;
	
	private boolean mapsInitialized;

	private UnqualifiedNameTable unqNameTable;

	
	private boolean nameCompletionIncludesUnqNames = true;

	Vector listeners = new Vector();

	

	public BshClassPath( String name ) { 
		this.name = name;
		reset();
	}

	public BshClassPath(  String name, URL [] urls ) {
		this( name );
		add( urls );
	}

	

	

	public void setPath( URL[] urls ) {
		reset();
		add( urls );
	}

	
	public void addComponent( BshClassPath bcp ) { 
		if ( compPaths == null )
			compPaths = new ArrayList();
		compPaths.add( bcp );
		bcp.addListener( this );
	}

	public void add( URL [] urls ) { 
		path.addAll( Arrays.asList(urls) );
		if ( mapsInitialized )
			map( urls );
	}

	public void add( URL url ) throws IOException { 
		path.add(url);
		if ( mapsInitialized )
			map( url );
	}

	
	public URL [] getPathComponents() {
		return (URL[])getFullPath().toArray( new URL[0] );
	}

	
	synchronized public Set getClassesForPackage( String pack ) {
		insureInitialized();
		Set set = new HashSet();
		Collection c = (Collection)packageMap.get( pack );
		if ( c != null )
			set.addAll( c );

		if ( compPaths != null )
			for (int i=0; i<compPaths.size(); i++) {
				c = ((BshClassPath)compPaths.get(i)).getClassesForPackage( 
					pack );
				if ( c != null )
					set.addAll( c );
			}
		return set;
	}

	
	synchronized public ClassSource getClassSource( String className ) 
	{
		
		
		
		ClassSource cs = (ClassSource)classSource.get( className );
		if ( cs != null )
			return cs;

		insureInitialized(); 

		cs = (ClassSource)classSource.get( className );
		if ( cs == null && compPaths != null )
			for (int i=0; i<compPaths.size() && cs==null; i++)
				cs = ((BshClassPath)compPaths.get(i)).getClassSource(className);
		return cs;
	}

	
	synchronized public void setClassSource( String className, ClassSource cs ) 
	{
		classSource.put( className, cs );
	}

	
	public void insureInitialized() 
	{
		insureInitialized( true );
	}

	
	protected synchronized void insureInitialized( boolean topPath ) 
	{
		
		
		if ( topPath && !mapsInitialized )
			startClassMapping();

		
		if ( compPaths != null )
			for (int i=0; i< compPaths.size(); i++)
				((BshClassPath)compPaths.get(i)).insureInitialized( false );

		
		if ( !mapsInitialized ) 
			map( (URL[])path.toArray( new URL[0] ) );

		if ( topPath && !mapsInitialized )
			endClassMapping();

		mapsInitialized = true;
	}

	
	protected List getFullPath() 
	{
		List list = new ArrayList();
		if ( compPaths != null ) {
			for (int i=0; i<compPaths.size(); i++) {
				List l = ((BshClassPath)compPaths.get(i)).getFullPath();
				
				
				Iterator it = l.iterator();
				while ( it.hasNext() ) {
					Object o = it.next();
					if ( !list.contains(o) )
						list.add( o );
				}
			}
		}
		list.addAll( path );
		return list;
	}


	
	public String getClassNameByUnqName( String name ) 
		throws ClassPathException
	{
		insureInitialized();
		UnqualifiedNameTable unqNameTable = getUnqualifiedNameTable();

		Object obj = unqNameTable.get( name );
		if ( obj instanceof AmbiguousName )
			throw new ClassPathException(""Ambigous class names: ""+
				((AmbiguousName)obj).get() );

		return (String)obj;
	}

	
	private UnqualifiedNameTable getUnqualifiedNameTable() {
		if ( unqNameTable == null )
			unqNameTable = buildUnqualifiedNameTable();
		return unqNameTable;
	}

	private UnqualifiedNameTable buildUnqualifiedNameTable() 
	{
		UnqualifiedNameTable unqNameTable = new UnqualifiedNameTable();

		
		if ( compPaths != null )
			for (int i=0; i<compPaths.size(); i++) {
				Set s = ((BshClassPath)compPaths.get(i)).classSource.keySet();
				Iterator it = s.iterator();
				while(it.hasNext()) 
					unqNameTable.add( (String)it.next() );
			}

		
		Iterator it = classSource.keySet().iterator();
		while(it.hasNext()) 
			unqNameTable.add( (String)it.next() );
		
		return unqNameTable;
	}

	public String [] getAllNames() 
	{
		insureInitialized();

		List names = new ArrayList();
		Iterator it = getPackagesSet().iterator();
		while( it.hasNext() ) {
			String pack = (String)it.next();
			names.addAll( 
				removeInnerClassNames( getClassesForPackage( pack ) ) ); 
		}

		if ( nameCompletionIncludesUnqNames )
			names.addAll( getUnqualifiedNameTable().keySet() );

		return (String [])names.toArray(new String[0]);
	}

	
	synchronized void map( URL [] urls ) 
	{ 
		for(int i=0; i< urls.length; i++)
			try{
				map( urls[i] );
			} catch ( IOException e ) {
				String s = ""Error constructing classpath: "" +urls[i]+"": ""+e;
				errorWhileMapping( s );
			}
	}

	synchronized void map( URL url ) 
		throws IOException 
	{ 
		String name = url.getFile();
		File f = new File( name );

		if ( f.isDirectory() ) {
			classMapping( ""Directory ""+ f.toString() );
			map( traverseDirForClasses( f ), new DirClassSource(f) );
		} else if ( isArchiveFileName( name ) ) {
			classMapping(""Archive: ""+url );
			map( searchJarForClasses( url ), new JarClassSource(url) );
		} 
		
		else {
			String s = ""Not a classpath component: ""+ name ;
			errorWhileMapping( s );
		}
	}

	private void map( String [] classes, Object source ) {
		for(int i=0; i< classes.length; i++) {
			
			mapClass( classes[i], source );
		}
	}

	private void mapClass( String className, Object source ) 
	{
		
		String [] sa = splitClassname( className );
		String pack = sa[0];
		String clas = sa[1];
		Set set = (Set)packageMap.get( pack );
		if ( set == null ) {
			set = new HashSet();
			packageMap.put( pack, set );
		}
		set.add( className );

		
		Object obj = classSource.get( className );
		
		
		if ( obj == null )
			classSource.put( className, source );
	}

	
	synchronized private void reset() {
		path = new ArrayList();
		compPaths = null;
		clearCachedStructures();
	}

	
	synchronized private void clearCachedStructures() {
		mapsInitialized = false;
		packageMap = new HashMap();
		classSource = new HashMap();
		unqNameTable = null;
		nameSpaceChanged();
	}

	public void classPathChanged() {
		clearCachedStructures();
		notifyListeners();	
	}



	

	static String [] traverseDirForClasses( File dir ) 
		throws IOException	
	{
		List list = traverseDirForClassesAux( dir, dir );
		return (String[])list.toArray( new String[0] );
	}

	static List traverseDirForClassesAux( File topDir, File dir ) 
		throws IOException
	{
		List list = new ArrayList();
		String top = topDir.getAbsolutePath();

		File [] children = dir.listFiles();
		for (int i=0; i< children.length; i++)	{
			File child = children[i];
			if ( child.isDirectory() )
				list.addAll( traverseDirForClassesAux( topDir, child ) );
			else {
				String name = child.getAbsolutePath();
				if ( isClassFileName( name ) ) {
					
					if ( name.startsWith( top ) )
						name = name.substring( top.length()+1 );
					else
						throw new IOException( ""problem parsing paths"" );

					name = canonicalizeClassName(name);
					list.add( name );
				}
			}
		}
		
		
		return list;
	}

	
	static String [] searchJarForClasses( URL jar ) 
		throws IOException 
	{
		Vector v = new Vector();
		InputStream in = jar.openStream(); 
		ZipInputStream zin = new ZipInputStream(in);

		ZipEntry ze;
		while( (ze= zin.getNextEntry()) != null ) {
			String name=ze.getName();
			if ( isClassFileName( name ) )
				v.addElement( canonicalizeClassName(name) );
		}
		zin.close();

		String [] sa = new String [v.size()];
		v.copyInto(sa);
		return sa;
	}

	public static boolean isClassFileName( String name ){
		return ( name.toLowerCase().endsWith("".class"") );
			
	}

	public static boolean isArchiveFileName( String name ){
		name = name.toLowerCase();
		return ( name.endsWith("".jar"") || name.endsWith("".zip"") );
	}

	
	public static String canonicalizeClassName( String name ) 
	{
		String classname=name.replace('/', '.');
		classname=classname.replace('\\', '.');
		if ( classname.startsWith(""class "") )
			classname=classname.substring(6);
		if ( classname.endsWith("".class"") )
			classname=classname.substring(0,classname.length()-6);
		return classname;
	}

	
	public static String [] splitClassname ( String classname ) {
		classname = canonicalizeClassName( classname );

		int i=classname.lastIndexOf(""."");
		String classn, packn;
		if ( i == -1 )  {
			
			classn = classname;
			packn=""<unpackaged>"";
		} else {
			packn = classname.substring(0,i);
			classn = classname.substring(i+1);
		}
		return new String [] { packn, classn };
	}

	
	public static Collection removeInnerClassNames( Collection col ) {
		List list = new ArrayList();
		list.addAll(col);
		Iterator it = list.iterator();
		while(it.hasNext()) {
			String name =(String)it.next();
			if (name.indexOf(""$"") != -1 )
				it.remove();
		}
		return list;
	}
	
	

	static URL [] userClassPathComp;
	public static URL [] getUserClassPathComponents() 
		throws ClassPathException
	{
		if ( userClassPathComp != null )
			return userClassPathComp;

		String cp=System.getProperty(""java.class.path"");
		String [] paths=StringUtil.split(cp, File.pathSeparator);

		URL [] urls = new URL[ paths.length ];
		try {
			for ( int i=0; i<paths.length; i++)
				
				
				
				urls[i] = new File( 
					new File(paths[i]).getCanonicalPath() ).toURL();
		} catch ( IOException e ) {
			throw new ClassPathException(""can't parse class path: ""+e);
		}

		userClassPathComp = urls;
		return urls;
	}

	
	public Set getPackagesSet() 
	{
		insureInitialized();
		Set set = new HashSet();
		set.addAll( packageMap.keySet() );

		if ( compPaths != null )
			for (int i=0; i<compPaths.size(); i++)
				set.addAll( 
					((BshClassPath)compPaths.get(i)).packageMap.keySet() );
		return set;
	}

	public void addListener( ClassPathListener l ) {
		listeners.addElement( new WeakReference(l) );
	}
	public void removeListener( ClassPathListener l ) {
		listeners.removeElement( l );
	}

	
	void notifyListeners() {
		for (Enumeration e = listeners.elements(); e.hasMoreElements(); ) {
			WeakReference wr = (WeakReference)e.nextElement();
			ClassPathListener l = (ClassPathListener)wr.get();
			if ( l == null )  
				listeners.removeElement( wr );
			else
				l.classPathChanged();
		}
	}

	static BshClassPath userClassPath;
	
	public static BshClassPath getUserClassPath() 
		throws ClassPathException
	{
		if ( userClassPath == null )
			userClassPath = new BshClassPath( 
				""User Class Path"", getUserClassPathComponents() );
		return userClassPath;
	}

	static BshClassPath bootClassPath;
	
	public static BshClassPath getBootClassPath() 
		throws ClassPathException
	{
		if ( bootClassPath == null )
		{
			try 
			{
				
				String rtjar = getRTJarPath();
				URL url = new File( rtjar ).toURL();
				bootClassPath = new BshClassPath( 
					""Boot Class Path"", new URL[] { url } );
			} catch ( MalformedURLException e ) {
				throw new ClassPathException("" can't find boot jar: ""+e);
			}
		}
		return bootClassPath;
	}


	private static String getRTJarPath()
	{
		String urlString =
			Class.class.getResource(""/java/lang/String.class"").toExternalForm();

		if ( !urlString.startsWith(""jar:file:"") )
			return null;

		int i = urlString.indexOf(""!"");
		if ( i == -1 )
			return null;

		return urlString.substring( ""jar:file:"".length(), i );
	}

	public abstract static class ClassSource { 
		Object source;
		abstract byte [] getCode( String className );
	}

	public static class JarClassSource extends ClassSource { 
		JarClassSource( URL url ) { source = url; }
		public URL getURL() { return (URL)source; }
		
		public byte [] getCode( String className ) {
			throw new Error(""Unimplemented"");
		}
		public String toString() { return ""Jar: ""+source; }
	}

	public static class DirClassSource extends ClassSource 
	{ 
		DirClassSource( File dir ) { source = dir; }
		public File getDir() { return (File)source; }
		public String toString() { return ""Dir: ""+source; }

		public byte [] getCode( String className ) {
			return readBytesFromFile( getDir(), className );
		}

		public static byte [] readBytesFromFile( File base, String className ) 
		{
			String n = className.replace( '.', File.separatorChar ) + "".class"";
			File file = new File( base, n );

			if ( file == null || !file.exists() )
				return null;

			byte [] bytes;
			try {
				FileInputStream fis = new FileInputStream(file);
				DataInputStream dis = new DataInputStream( fis );
		 
				bytes = new byte [ (int)file.length() ];

				dis.readFully( bytes );
				dis.close();
			} catch(IOException ie ) {
				throw new RuntimeException(""Couldn't load file: ""+file);
			}

			return bytes;
		}

	}

	public static class GeneratedClassSource extends ClassSource 
	{
		GeneratedClassSource( byte [] bytecode ) { source = bytecode; }
		public byte [] getCode( String className ) {
			return (byte [])source; 
		}
	}

	public static void main( String [] args ) throws Exception {
		URL [] urls = new URL [ args.length ];
		for(int i=0; i< args.length; i++)
			urls[i] =  new File(args[i]).toURL();
		BshClassPath bcp = new BshClassPath( ""Test"", urls );
	}

	public String toString() {
		return ""BshClassPath ""+name+""(""+super.toString()+"") path= ""+path +""\n""
			+ ""compPaths = {"" + compPaths +"" }"";
	}


	
	static class UnqualifiedNameTable extends HashMap {
		void add( String fullname ) {
			String name = splitClassname( fullname )[1];
			Object have = super.get( name );

			if ( have == null )
				super.put( name, fullname );
			else
				if ( have instanceof AmbiguousName )
					((AmbiguousName)have).add( fullname );
				else  
				{
					AmbiguousName an = new AmbiguousName();
					an.add( (String)have );
					an.add( fullname );
					super.put( name, an );
				}
		}
	}

	public static class AmbiguousName {
		List list = new ArrayList();
		public void add( String name ) { 
			list.add( name ); 
		}
		public List get() {
			
			return list;
		}
	}

	
	void nameSpaceChanged() 
	{
		if ( nameSourceListeners == null )
			return;

		for(int i=0; i<nameSourceListeners.size(); i++)
			((NameSource.Listener)(nameSourceListeners.get(i)))
				.nameSourceChanged( this );
	}

	List nameSourceListeners;
	
	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new ArrayList();
		nameSourceListeners.add( listener );
	}

	
	static MappingFeedback mappingFeedbackListener;

	
	public static void addMappingFeedback( MappingFeedback mf ) 
	{
		if ( mappingFeedbackListener != null )
			throw new RuntimeException(""Unimplemented: already a listener"");
		mappingFeedbackListener = mf;
	}

	void startClassMapping() {
		if ( mappingFeedbackListener != null )
			mappingFeedbackListener.startClassMapping();
		else
			System.err.println( ""Start ClassPath Mapping"" );
	}

	void classMapping( String msg ) {
		if ( mappingFeedbackListener != null ) {
			mappingFeedbackListener.classMapping( msg );
		} else
			System.err.println( ""Mapping: ""+msg );
	}

	void errorWhileMapping( String s ) {
		if ( mappingFeedbackListener != null )
			mappingFeedbackListener.errorWhileMapping( s );
		else
			System.err.println( s );
	}

	void endClassMapping() {
		if ( mappingFeedbackListener != null )
			mappingFeedbackListener.endClassMapping();
		else
			System.err.println( ""End ClassPath Mapping"" );
	}
	
	public static interface MappingFeedback
	{
		public void startClassMapping();

		

		
		public void classMapping( String msg );

		public void errorWhileMapping( String msg );

		public void endClassMapping();
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.MouseActions,2,1,0,4,9,0,1,3,1,0.0,59,1.0,1,0.0,0.75,0,0,27.5,2,1.0,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.event.MouseEvent;
import org.gjt.sp.jedit.gui.KeyEventTranslator;
import org.gjt.sp.jedit.IPropertyManager;

public class MouseActions implements MouseActionsProvider
{
	private IPropertyManager propertyManager;

	
	MouseActions(IPropertyManager propertyManager, String name)
	{
		this.propertyManager = propertyManager;
		this.name = name;
	} 

	
	public String getActionForEvent(MouseEvent evt, String variant)
	{
		String modStr = KeyEventTranslator.getModifierString(evt);
		if(modStr == null)
		{
			return propertyManager.getProperty(""view."" + name + '.'
				+ variant + ""Click"");
		}
		else
		{
			return propertyManager.getProperty(""view."" + name + '.'
				+ KeyEventTranslator.getModifierString(evt)
				+ variant + ""Click"");
		}
	} 

	private String name;
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.ModeProvider,10,1,1,13,44,25,10,6,8,0.666666667,230,0.5,1,0.0,0.377777778,0,0,21.8,5,1.7,0,"
package org.gjt.sp.jedit.syntax;


import org.gjt.sp.jedit.Mode;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.Log;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;



public class ModeProvider
{
	public static ModeProvider instance = new ModeProvider();

	private List<Mode> modes = new ArrayList<Mode>(180);

	
	public void removeAll()
	{
		modes = new ArrayList<Mode>(180);
	} 

	
	
	public Mode getMode(String name)
	{
		for(int i = 0; i < modes.size(); i++)
		{
			Mode mode = modes.get(i);
			if(mode.getName().equals(name))
				return mode;
		}
		return null;
	} 

	
	
	public Mode getModeForFile(String filename, String firstLine)
	{
		String nogzName = filename.substring(0,filename.length() -
			(filename.endsWith("".gz"") ? 3 : 0));
		Mode[] modes = getModes();

		
		
		for(int i = modes.length - 1; i >= 0; i--)
		{
			if(modes[i].accept(nogzName,firstLine))
			{
				return modes[i];
			}
		}
		return null;
	} 

	
	
	
	public Mode[] getModes()
	{
		Mode[] array = new Mode[modes.size()];
		modes.toArray(array);
		return array;
	} 

	
	
	public void addMode(Mode mode)
	{
		modes.add(mode);
	} 

	
	public void loadMode(Mode mode, XModeHandler xmh)
	{
		String fileName = (String)mode.getProperty(""file"");

		Log.log(Log.NOTICE,this,""Loading edit mode "" + fileName);

		XMLReader parser;
		try
		{
			parser = XMLReaderFactory.createXMLReader();
		} catch (SAXException saxe)
		{
			Log.log(Log.ERROR, this, saxe);
			return;
		}
		mode.setTokenMarker(xmh.getTokenMarker());

		InputStream grammar;

		try
		{
			grammar = new BufferedInputStream(
					new FileInputStream(fileName));
		}
		catch (FileNotFoundException e1)
		{
			InputStream resource = ModeProvider.class.getResourceAsStream(fileName);
			if (resource == null)
				error(fileName, e1);
			grammar = new BufferedInputStream(resource);
		}

		try
		{
			InputSource isrc = new InputSource(grammar);
			isrc.setSystemId(""jedit.jar"");
			parser.setContentHandler(xmh);
			parser.setDTDHandler(xmh);
			parser.setEntityResolver(xmh);
			parser.setErrorHandler(xmh);
			parser.parse(isrc);

			mode.setProperties(xmh.getModeProperties());
		}
		catch (Throwable e)
		{
			error(fileName, e);
		}
		finally
		{
			IOUtilities.closeQuietly(grammar);
		}
	} 

	
	public void loadMode(Mode mode)
	{
		XModeHandler xmh = new XModeHandler(mode.getName())
		{
			@Override
			public void error(String what, Object subst)
			{
				Log.log(Log.ERROR, this, subst);
			}

			@Override
			public TokenMarker getTokenMarker(String modeName)
			{
				Mode mode = getMode(modeName);
				if(mode == null)
					return null;
				else
					return mode.getTokenMarker();
			}
		};
		loadMode(mode, xmh);
	} 

	
	protected void error(String file, Throwable e)
	{
		Log.log(Log.ERROR, this, e);
	} 
}
"
jEdit,4.3,org.gjt.sp.util.SegmentCharSequence,7,1,0,1,10,0,1,0,7,0.333333333,100,1.0,0,0.0,0.5,0,0,12.71428571,2,0.8571,0,"
package org.gjt.sp.util;

import java.io.Serializable;
import javax.swing.text.Segment;


public class SegmentCharSequence implements CharSequence, Serializable
{

	public SegmentCharSequence(Segment seg)
	{
		this(seg, false);
	}

	
	@Deprecated
	public SegmentCharSequence(Segment seg, boolean reverse)
	{
		this(seg, 0, seg.count);
		this.reverse = reverse;
	}

	public SegmentCharSequence(Segment seg, int off, int len)
	{
		this.offset = off;
		this.length = len;
		this.seg = seg;
	}

	public char charAt(int index)
	{
		if (reverse)
			index = length - index - 1;
		return seg.array[seg.offset + offset + index];
	}

	public int length()
	{
		return length;
	}

	public CharSequence subSequence(int start, int end)
	{
		if (reverse)
			throw new IllegalStateException(""reverse sub-sequences are not supported"");
		return new SegmentCharSequence(seg, offset + start, end - start);
	}

	public String toString()
	{
		return new String(seg.array, offset+seg.offset, length);
	}

	private boolean reverse;
	private int 	offset;
	private int 	length;
	private Segment seg;

}

"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableWindowManager,44,5,1,35,88,884,20,18,34,0.97127223,658,0.705882353,2,0.938218391,0.175,0,0,13.56818182,12,1.8182,0,"package org.gjt.sp.jedit.gui;


import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.File;
import java.io.FilenameFilter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.Map.Entry;

import javax.swing.JComponent;
import javax.swing.JPanel;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.PluginJAR;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View.ViewConfig;
import org.gjt.sp.jedit.gui.KeyEventTranslator.Key;
import org.gjt.sp.jedit.msg.DockableWindowUpdate;
import org.gjt.sp.jedit.msg.PluginUpdate;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;


@SuppressWarnings(""serial"")


 public abstract class DockableWindowManager extends JPanel implements EBComponent
{

	
	
	public static final String FLOATING = ""floating"";

	
	public static final String TOP = ""top"";

	
	public static final String LEFT = ""left"";

	
	public static final String BOTTOM = ""bottom"";

	
	public static final String RIGHT = ""right"";
	

	
	private final Map<PluginJAR, Set<String>> plugins = new HashMap<PluginJAR, Set<String>>(); 
	private final Map<String, String> positions = new HashMap<String, String>();
	protected View view;
	protected DockableWindowFactory factory;
	protected Map<String, JComponent> windows = new HashMap<String, JComponent>();

	
	private boolean tBottom, tTop, tLeft, tRight;
	private boolean closeToggle = true;

	private static final String ALTERNATE_LAYOUT_PROP = ""view.docking.alternateLayout"";
	private boolean alternateLayout;
	

	
	public DockableWindowManager(View view, DockableWindowFactory instance,
			ViewConfig config)
	{
		this.view = view;
		this.factory = instance;
		alternateLayout = jEdit.getBooleanProperty(ALTERNATE_LAYOUT_PROP);
	} 

	
	public abstract void setMainPanel(JPanel panel);
	public abstract void showDockableWindow(String name);
	public abstract void hideDockableWindow(String name);

	
	public abstract void disposeDockableWindow(String name);
	public abstract JComponent floatDockableWindow(String name);
	public abstract boolean isDockableWindowDocked(String name);
	public abstract boolean isDockableWindowVisible(String name);
	public abstract void closeCurrentArea();
	public abstract DockingLayout getDockingLayout(ViewConfig config);
	public abstract DockingArea getLeftDockingArea();
	public abstract DockingArea getRightDockingArea();
	public abstract DockingArea getTopDockingArea();
	public abstract DockingArea getBottomDockingArea();
	

	
	
	public void init()
	{
		EditBus.addToBus(this);

		Iterator<DockableWindowFactory.Window> entries = factory.getDockableWindowIterator();
		while(entries.hasNext())
		{
			DockableWindowFactory.Window window = entries.next();
			String dockable = window.name;
			positions.put(dockable, getDockablePosition(dockable));
			addPluginDockable(window.plugin, dockable);
		}
	} 

	
	public void close()
	{
		EditBus.removeFromBus(this);
	} 

	
	public void applyDockingLayout(DockingLayout docking)
	{
		
		Iterator<Entry<String, String>> iterator = positions.entrySet().iterator();
		while (iterator.hasNext())
		{
			Entry<String, String> entry = iterator.next();
			String dockable = entry.getKey();
			String position = entry.getValue();
			if (! position.equals(FLOATING))
				showDockableWindow(dockable);
		}
	} 

	
	
	public void addDockableWindow(String name)
	{
		showDockableWindow(name);
	} 

	
	
	public void removeDockableWindow(String name)
	{
		hideDockableWindow(name);
	} 

	
	
	public void toggleDockableWindow(String name)
	{
		if(isDockableWindowVisible(name))
			removeDockableWindow(name);
		else
			addDockableWindow(name);
	} 

	
	
	public JComponent getDockableWindow(String name)
	{
		return getDockable(name);
	} 

	
	
	public void toggleDockAreas()
	{
		if (closeToggle)
		{
			tTop = getTopDockingArea().getCurrent() != null;
			tLeft = getLeftDockingArea().getCurrent() != null;
			tRight = getRightDockingArea().getCurrent() != null;
			tBottom = getBottomDockingArea().getCurrent() != null;
			getBottomDockingArea().show(null);
			getTopDockingArea().show(null);
			getRightDockingArea().show(null);
			getLeftDockingArea().show(null);
		}
		else
		{
			if (tBottom) getBottomDockingArea().showMostRecent();
			if (tLeft) getLeftDockingArea().showMostRecent();
			if (tRight) getRightDockingArea().showMostRecent();
			if (tTop) getTopDockingArea().showMostRecent();
		}
		closeToggle = !closeToggle;
		view.getTextArea().requestFocus();
	} 

	
	public void dockableTitleChanged(String dockable, String newTitle)
	{
	} 

	
	
	public KeyListener closeListener(String dockableName)
	{
		return new KeyHandler(dockableName);
	}
	

	
	
	public View getView()
	{
		return view;
	} 

	
	
	public JComponent getDockable(String name)
	{
		return windows.get(name);
	} 

	
	
	public String getDockableTitle(String name)
	{
		return longTitle(name);
	}

	
	
	public void setDockableTitle(String dockable, String title)
	{
		String propName = getLongTitlePropertyName(dockable);
		String oldTitle = jEdit.getProperty(propName);
		jEdit.setProperty(propName, title);
		firePropertyChange(propName, oldTitle, title);
		dockableTitleChanged(dockable, title);
	}
	

	
	public static String[] getRegisteredDockableWindows()
	{
		return DockableWindowFactory.getInstance()
			.getRegisteredDockableWindows();
	} 

	
	public static String getDockableWindowPluginName(String name)
	{
		String pluginClass =
			DockableWindowFactory.getInstance().getDockableWindowPluginClass(name);
		if (pluginClass == null)
			return null;
		return jEdit.getProperty(""plugin."" + pluginClass + "".name"");
	} 

	
	public void setDockingLayout(DockingLayout docking)
	{
		applyDockingLayout(docking);
		applyAlternateLayout(alternateLayout);
	} 

	
	private void addPluginDockable(PluginJAR plugin, String name)
	{
		Set<String> dockables = plugins.get(plugin);
		if (dockables == null)
		{
			dockables = new HashSet<String>();
			plugins.put(plugin, dockables);
		}
		dockables.add(name);
	}
	
	
	
	public void handleMessage(EBMessage msg)
	{
		if (msg instanceof DockableWindowUpdate)
		{
			if(((DockableWindowUpdate)msg).getWhat() == DockableWindowUpdate.PROPERTIES_CHANGED)
				propertiesChanged();
		}
		else if (msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if (pmsg.getWhat() == PluginUpdate.LOADED)
			{
				Iterator<DockableWindowFactory.Window> iter = factory.getDockableWindowIterator();
				while (iter.hasNext())
				{
					DockableWindowFactory.Window w = iter.next();
					if (w.plugin == pmsg.getPluginJAR())
					{
						String position = getDockablePosition(w.name);
						positions.put(w.name, position);
						addPluginDockable(w.plugin, w.name);
						dockableLoaded(w.name, position);
					}
				}
				propertiesChanged();
			}
			else if(pmsg.isExiting())
			{
				
			}
			else if(pmsg.getWhat() == PluginUpdate.DEACTIVATED ||
					pmsg.getWhat() == PluginUpdate.UNLOADED)
			{
				Set<String> dockables = plugins.remove(pmsg.getPluginJAR());
				if (dockables != null)
				{
					for (String dockable: dockables)
					{
						disposeDockableWindow(dockable);
						windows.remove(dockable);
					}
				}
			}
		}
	} 

	
	public String longTitle(String name)
	{
		String title = jEdit.getProperty(getLongTitlePropertyName(name));
		if (title == null)
			return shortTitle(name);
		return title;
	} 

	
	public String shortTitle(String name)
	{
		String title = jEdit.getProperty(name + "".title"");
		if(title == null)
			return ""NO TITLE PROPERTY: "" + name;
		return title;
	} 

	

	
	
	protected void applyAlternateLayout(boolean alternateLayout)
	{
	} 

	
	protected void dockableLoaded(String dockableName, String position)
	{
	}
	
	
	
	protected void dockingPositionChanged(String dockableName,
		String oldPosition, String newPosition)
	{
	} 

	
	protected boolean getAlternateLayoutProp()
	{
		return alternateLayout;
	} 

	
	protected void propertiesChanged()
	{
		if(view.isPlainView())
			return;

		boolean newAlternateLayout = jEdit.getBooleanProperty(ALTERNATE_LAYOUT_PROP);
		if (newAlternateLayout != alternateLayout)
		{
			alternateLayout = newAlternateLayout;
			applyAlternateLayout(newAlternateLayout);
		}

		String[] dockables = factory.getRegisteredDockableWindows();
		for(int i = 0; i < dockables.length; i++)
		{
			String dockable = dockables[i];
			String oldPosition = positions.get(dockable);
			String newPosition = getDockablePosition(dockable);
			if (oldPosition == null || !newPosition.equals(oldPosition))
			{
				positions.put(dockable, newPosition);
				dockingPositionChanged(dockable, oldPosition, newPosition);
			}
		}

	} 

	
	protected JComponent createDockable(String name)
	{
		DockableWindowFactory.Window wf = factory.getDockableWindowFactory(name);
		if (wf == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return null;
		}
		String position = getDockablePosition(name);
		JComponent window = wf.createDockableWindow(view, position);
		if (window != null)
			windows.put(name, window);
		return window;
	} 

	
	protected String getDockablePosition(String name)
	{
		return jEdit.getProperty(name + "".dock-position"", FLOATING);
	} 

	
	protected void focusDockable(String name)
	{
		JComponent c = getDockable(name);
		if (c == null)
			return;
		if (c instanceof DefaultFocusComponent)
			((DefaultFocusComponent)c).focusOnDefaultComponent();
		else
			c.requestFocus();
	} 

	
	protected String getLongTitlePropertyName(String dockableName)
	{
		return dockableName + "".longtitle"";
	} 
	


	
	
	public interface DockingArea
	{
		void showMostRecent();
		String getCurrent();
		void show(String name);
		String [] getDockables();
	}
	

	
	
	class KeyHandler extends KeyAdapter
	{
		static final String action = ""close-docking-area"";
		Vector<Key> b1, b2;
		String name;
		int match1, match2;

		public KeyHandler(String dockableName)
		{
			String shortcut1=jEdit.getProperty(action + "".shortcut"");
			String shortcut2=jEdit.getProperty(action + "".shortcut2"");
			if (shortcut1 != null)
				b1 = parseShortcut(shortcut1);
			if (shortcut2 != null)
				b2 = parseShortcut(shortcut2);
			name = dockableName;
			match1 = match2 = 0;
		}

		@Override
		public void keyTyped(KeyEvent e)
		{
			if (b1 != null)
				match1 = match(e, b1, match1);
			if (b2 != null)
				match2 = match(e, b2, match2);
			if ((match1 > 0 && match1 == b1.size()) ||
				(match2 > 0 && match2 == b2.size()))
			{
				hideDockableWindow(name);
				match1 = match2 = 0;
			}
		}

		private int match(KeyEvent e, Vector<Key> shortcut, int index)
		{
			char c = e.getKeyChar();
			if (shortcut != null && c == shortcut.get(index).key)
				return index + 1;
			return 0;
		}

		private Vector<Key> parseShortcut(String shortcut)
		{
			Vector<Key> keys = new Vector<Key>();
			String [] parts = shortcut.split(""\\s+"");
			for (String part: parts)
			{
				if (part.length() > 0)
					keys.add(KeyEventTranslator.parseKey(part));
			}
			return keys;
		}
	} 

	
	
	public abstract static class DockingLayout
	{
		public static final int NO_VIEW_INDEX = -1;
		public abstract boolean loadLayout(String baseName, int viewIndex);
		public abstract boolean saveLayout(String baseName, int viewIndex);
		public abstract String getName();

		public void setPlainView(boolean plain)
		{
		}

		public String [] getSavedLayouts()
		{
			String layoutDir = getLayoutDirectory();
			if (layoutDir == null)
				return null;
			File dir = new File(layoutDir);
			File[] files = dir.listFiles(new FilenameFilter()
			{
				public boolean accept(File dir, String name)
				{
					return name.endsWith("".xml"");
				}
			});
			String[] layouts = new String[files.length];
			for (int i = 0; i < files.length; i++)
				layouts[i] = fileToLayout(files[i].getName());
			return layouts;
		}

		private static String fileToLayout(String filename)
		{
			return filename.replaceFirst("".xml"", """");
		}

		private static String layoutToFile(String baseName, int viewIndex)
		{
			StringBuilder name = new StringBuilder(baseName);
			if (viewIndex != NO_VIEW_INDEX)
				name.append(""-view"").append(viewIndex);
			name.append("".xml"");
			return name.toString();
		}

		public String getLayoutFilename(String baseName, int viewIndex)
		{
			String dir = getLayoutDirectory();
			if (dir == null)
				return null;
			return dir + File.separator + layoutToFile(baseName, viewIndex);
		}

		private String getLayoutDirectory()
		{
			String name = getName();
			if (name == null)
				return null;
			String dir = jEdit.getSettingsDirectory();
			if (dir == null)
				return null;
			dir = dir + File.separator + name;
			File d = new File(dir);
			if (!d.exists())
				d.mkdir();
			return dir;
		}
	} 

} 
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ClassGeneratorImpl,8,2,0,29,64,28,0,29,6,2.0,441,0.0,0,0.363636364,0.375,0,0,54.125,4,1.25,0,"package org.gjt.sp.jedit.bsh;

import java.io.*;
import java.util.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;


public class ClassGeneratorImpl extends ClassGenerator
{
	public Class generateClass( 
		String name, Modifiers modifiers, 
		Class [] interfaces, Class superClass, BSHBlock block, 
		boolean isInterface, CallStack callstack, Interpreter interpreter 
	)
		throws EvalError
	{
		
		return generateClassImpl( name, modifiers, interfaces, superClass,
			block, isInterface, callstack, interpreter );
	}

	public Object invokeSuperclassMethod(
		BshClassManager bcm, Object instance, String methodName, Object [] args
	)
        throws UtilEvalError, ReflectError, InvocationTargetException
	{
		
		return invokeSuperclassMethodImpl( bcm, instance, methodName, args );
	}

	
	
	public void setInstanceNameSpaceParent( 
		Object instance, String className, NameSpace parent )
	{
		This ithis = 
			ClassGeneratorUtil.getClassInstanceThis( instance, className );
		ithis.getNameSpace().setParent( parent );
	}

	
	public static Class generateClassImpl( 
		String name, Modifiers modifiers, 
		Class [] interfaces, Class superClass, BSHBlock block, 
		boolean isInterface, CallStack callstack, Interpreter interpreter 
	)
		throws EvalError
	{
		
		
		try {
			Capabilities.setAccessibility( true );
		} catch ( Capabilities.Unavailable e )
		{
			throw new EvalError( 
				""Defining classes currently requires reflective Accessibility."",
				block, callstack );
		}

		NameSpace enclosingNameSpace = callstack.top();
		String packageName = enclosingNameSpace.getPackage();
		String className =  enclosingNameSpace.isClass ?  
			( enclosingNameSpace.getName()+""$""+name ) : name;
		String fqClassName = 
			packageName == null ? className : packageName + ""."" + className;

		BshClassManager bcm = interpreter.getClassManager();
		
		bcm.definingClass( fqClassName );

		
		NameSpace classStaticNameSpace = 
			new NameSpace( enclosingNameSpace, className);
		classStaticNameSpace.isClass = true;

		callstack.push( classStaticNameSpace );

		
		
		block.evalBlock( 
			callstack, interpreter, true, 
			ClassNodeFilter.CLASSCLASSES );

		
		Variable [] variables = 
			getDeclaredVariables( block, callstack, interpreter, packageName );
		DelayedEvalBshMethod [] methods =
			getDeclaredMethods( block, callstack, interpreter, packageName );

		ClassGeneratorUtil classGenerator = new ClassGeneratorUtil( 
			modifiers, className, packageName, superClass, interfaces, 
			variables, methods, classStaticNameSpace, isInterface );
		byte [] code = classGenerator.generateClass();

		
		String dir = System.getProperty(""debugClasses"");
		if ( dir != null )
		try {
			FileOutputStream out= 
				new FileOutputStream( dir+""/""+className+"".class"" );
			out.write(code);
			out.close();
		} catch ( IOException e ) { }

		
		Class genClass = bcm.defineClass( fqClassName, code );

		
		enclosingNameSpace.importClass( fqClassName.replace('$','.') );

		try {
			classStaticNameSpace.setLocalVariable( 
				ClassGeneratorUtil.BSHINIT, block, false );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError(""unable to init static: ""+e );
		}

		
		
		classStaticNameSpace.setClassStatic( genClass );

		
		block.evalBlock( 
			callstack, interpreter, true, 
			ClassNodeFilter.CLASSSTATIC );

		callstack.pop();

		if ( !genClass.isInterface() )
		{
		
		String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC+className;
		try {
			LHS lhs = Reflect.getLHSStaticField( genClass, bshStaticFieldName );
			lhs.assign( 
				classStaticNameSpace.getThis( interpreter ), false );
		} catch ( Exception e ) {
			throw new InterpreterError(""Error in class gen setup: ""+e );
		}
		}

		bcm.doneDefiningClass( fqClassName );
		return genClass;
	}

	static Variable [] getDeclaredVariables( 
		BSHBlock body, CallStack callstack, Interpreter interpreter, 
		String defaultPackage 
	) 
	{
		List vars = new ArrayList();
		for( int child=0; child<body.jjtGetNumChildren(); child++ )
		{
			SimpleNode node = (SimpleNode)body.jjtGetChild(child);
			if ( node instanceof BSHTypedVariableDeclaration )
			{
				BSHTypedVariableDeclaration tvd = 
					(BSHTypedVariableDeclaration)node;
				Modifiers modifiers = tvd.modifiers;

				String type = tvd.getTypeDescriptor( 
					callstack, interpreter, defaultPackage );

				BSHVariableDeclarator [] vardec = tvd.getDeclarators();
				for( int i = 0; i< vardec.length; i++)
				{
					String name = vardec[i].name;
					try {
						Variable var = new Variable( 
							name, type, null, modifiers );
						vars.add( var );
					} catch ( UtilEvalError e ) {
						
					}
				}
			}
		}

		return (Variable [])vars.toArray( new Variable[0] );
	}

	static DelayedEvalBshMethod [] getDeclaredMethods( 
		BSHBlock body, CallStack callstack, Interpreter interpreter,
		String defaultPackage 
	)
		throws EvalError
	{
		List methods = new ArrayList();
		for( int child=0; child<body.jjtGetNumChildren(); child++ )
		{
			SimpleNode node = (SimpleNode)body.jjtGetChild(child);
			if ( node instanceof BSHMethodDeclaration )
			{
				BSHMethodDeclaration md = (BSHMethodDeclaration)node;
				md.insureNodesParsed();
				Modifiers modifiers = md.modifiers;
				String name = md.name;
				String returnType = md.getReturnTypeDescriptor( 
					callstack, interpreter, defaultPackage );
				BSHReturnType returnTypeNode = md.getReturnTypeNode();
				BSHFormalParameters paramTypesNode = md.paramsNode;
				String [] paramTypes = paramTypesNode.getTypeDescriptors( 
					callstack, interpreter, defaultPackage );

				DelayedEvalBshMethod bm = new DelayedEvalBshMethod( 
					name, 
					returnType, returnTypeNode,
					md.paramsNode.getParamNames(), 
					paramTypes, paramTypesNode,
					md.blockNode, null,
					modifiers, callstack, interpreter 
				);

				methods.add( bm );
			}
		}

		return (DelayedEvalBshMethod [])methods.toArray( 
			new DelayedEvalBshMethod[0] );
	}

	
	static class ClassNodeFilter implements BSHBlock.NodeFilter
	{
		public static final int STATIC=0, INSTANCE=1, CLASSES=2;

		public static ClassNodeFilter CLASSSTATIC = 
			new ClassNodeFilter( STATIC );
		public static ClassNodeFilter CLASSINSTANCE = 
			new ClassNodeFilter( INSTANCE );
		public static ClassNodeFilter CLASSCLASSES = 
			new ClassNodeFilter( CLASSES );

		int context;

		private ClassNodeFilter( int context ) { this.context = context; }

		public boolean isVisible( SimpleNode node ) 
		{
			if ( context == CLASSES )
				return node instanceof BSHClassDeclaration;

			
			if ( node instanceof BSHClassDeclaration )
				return false;

			if ( context == STATIC )
				return isStatic( node );

			if ( context == INSTANCE )
				return !isStatic( node );

			
			return true;
		}

		boolean isStatic( SimpleNode node ) 
		{
			if ( node instanceof BSHTypedVariableDeclaration )
				return ((BSHTypedVariableDeclaration)node).modifiers != null
					&& ((BSHTypedVariableDeclaration)node).modifiers
						.hasModifier(""static"");

			if ( node instanceof BSHMethodDeclaration )
				return ((BSHMethodDeclaration)node).modifiers != null
					&& ((BSHMethodDeclaration)node).modifiers
						.hasModifier(""static"");

			
			if ( node instanceof BSHBlock)
				return false;

			return false;
		}
	}

	public static Object invokeSuperclassMethodImpl(
		BshClassManager bcm, Object instance, String methodName, Object [] args
	)
        throws UtilEvalError, ReflectError, InvocationTargetException
	{
		String superName = ClassGeneratorUtil.BSHSUPER+methodName;
		
		
		Class clas = instance.getClass();
		Method superMethod = Reflect.resolveJavaMethod(
			bcm, clas, superName, Types.getTypes(args), false );
		if ( superMethod != null )
			return Reflect.invokeMethod(
				superMethod, instance, args );

		
		
		Class superClass = clas.getSuperclass();
		superMethod = Reflect.resolveExpectedJavaMethod(
			bcm, superClass, instance, methodName, args, 
			false );
		return Reflect.invokeMethod( superMethod, instance, args );
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.JEditRegisterSaver,3,1,0,11,27,0,1,11,2,0.0,204,1.0,1,0.0,1.0,0,0,66.66666667,9,4.0,0,"
package org.gjt.sp.jedit;

import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.IOUtilities;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Attributes;

import java.io.IOException;


class JEditRegisterSaver implements RegisterSaver
{
	
	JEditRegisterSaver()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			registersXML = new SettingsXML(settingsDirectory, ""registers"");
		}
	} 

	
	public void loadRegisters()
	{
		if(registersXML == null)
			return;

		if(!registersXML.fileExists())
			return;

		Log.log(Log.MESSAGE,jEdit.class,""Loading "" + registersXML);

		RegistersHandler handler = new RegistersHandler();
		try
		{
			Registers.setLoading(true);
			registersXML.load(handler);
		}
		catch (IOException ioe)
		{
			Log.log(Log.ERROR, Registers.class, ioe);
		}
		finally
		{
			Registers.setLoading(false);
		}
	} 

	
	public void saveRegisters()
	{
		if(registersXML == null)
			return;

		if(registersXML.hasChangedOnDisk())
		{
			Log.log(Log.WARNING,Registers.class,registersXML
				+ "" changed on disk; will not save registers"");
			return;
		}

		Log.log(Log.MESSAGE,Registers.class,""Saving "" + registersXML);

		String lineSep = System.getProperty(""line.separator"");

		SettingsXML.Saver out = null;

		try
		{
			out = registersXML.openSaver();
			out.writeXMLDeclaration();

			out.write(""<!DOCTYPE REGISTERS SYSTEM \""registers.dtd\"">"");
			out.write(lineSep);
			out.write(""<REGISTERS>"");
			out.write(lineSep);

			Registers.Register[] registers = Registers.getRegisters();
			for(int i = 0; i < registers.length; i++)
			{
				Registers.Register register = registers[i];
				if(register == null ||
				   i == '$' ||
				   i == '%' ||
				   register.toString().length() == 0)
					continue;

				out.write(""<REGISTER NAME=\"""");
				if(i == '""')
					out.write(""&quot;"");
				else
					out.write((char)i);
				out.write(""\"">"");

				out.write(XMLUtilities.charsToEntities(
					register.toString(), false));

				out.write(""</REGISTER>"");
				out.write(lineSep);
			}

			out.write(""</REGISTERS>"");
			out.write(lineSep);

			out.finish();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,Registers.class,e);
		}
		finally
		{
			IOUtilities.closeQuietly(out);
		}
	} 

	
	private SettingsXML registersXML;

	
	private static class RegistersHandler extends DefaultHandler
	{
		
		@Override
		public InputSource resolveEntity(String publicId, String systemId)
		{
			return XMLUtilities.findEntity(systemId, ""registers.dtd"", getClass());
		} 

		
		@Override
		public void startElement(String uri, String localName,
					 String qName, Attributes attrs)
		{
			registerName = attrs.getValue(""NAME"");
			inRegister = ""REGISTER"".equals(qName);
		} 

		
		@Override
		public void endElement(String uri, String localName, String name)
		{
			if(""REGISTER"".equals(name))
			{
				if(registerName == null || registerName.length() != 1)
					Log.log(Log.ERROR,this,""Malformed NAME: "" + registerName);
				else
					Registers.setRegister(registerName.charAt(0),charData.toString());
				inRegister = false;
				charData.setLength(0);
			}
		} 

		
		@Override
		public void characters(char[] ch, int start, int length)
		{
			if (inRegister)
				charData.append(ch, start, length);
		} 

		
		private String registerName;
		private final StringBuilder charData = new StringBuilder();
		private boolean inRegister;
		
	} 
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.EnhancedButton,3,7,0,5,14,1,2,4,2,0.5,64,1.0,0,0.99739922,0.4,1,1,20.0,1,0.6667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class EnhancedButton extends RolloverButton
{
	
	public EnhancedButton(Icon icon, String toolTip, String action,
		ActionContext context)
	{
		super(icon);

		this.action = action;

		if(action != null)
		{
			
			
			
			
			int iSuffix = action.lastIndexOf('.');
			if(iSuffix<0 || iSuffix == action.length()-1)
			{
				setName(action);
			}
			else
			{
				setName(action.substring(iSuffix+1));
			}
			
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(context,action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);

		setToolTipText(toolTip);
	} 

	
	public boolean isFocusTraversable()
	{
		return false;
	} 

	
	private String action;
	

	
	class MouseHandler extends MouseAdapter
	{
		boolean msgSet = false;

		public void mouseReleased(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}

		public void mouseEntered(MouseEvent evt)
		{
			String msg = jEdit.getProperty(action + "".mouse-over"");
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
				msgSet = true;
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.print.BufferPrinter1_3,5,1,0,4,33,0,0,4,4,0.375,161,1.0,0,0.0,0.25,0,0,30.8,3,1.6,0,"

package org.gjt.sp.jedit.print;


import java.awt.print.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class BufferPrinter1_3
{
	
	private static PrinterJob getPrintJob()
	{
		job = PrinterJob.getPrinterJob();

		int orientation = jEdit.getIntegerProperty(""print.orientation"",PageFormat.PORTRAIT);
		double width = jEdit.getDoubleProperty(""print.width"",0);
		double height = jEdit.getDoubleProperty(""print.height"",0);
		double x = jEdit.getDoubleProperty(""print.x"",0);
		double y = jEdit.getDoubleProperty(""print.y"",0);
		double pagewidth = jEdit.getDoubleProperty(""print.pagewidth"",0);
		double pageheight = jEdit.getDoubleProperty(""print.pageheight"",0);

		format = job.defaultPage();
		
		if(width!=0 && height!=0 )
		{
			Paper pap = format.getPaper();
			pap.setImageableArea(x,y,width,height);
			pap.setSize(pagewidth,pageheight);
			format.setPaper(pap);
		}
		format.setOrientation(orientation);
		return job;

	}

	
	public static void pageSetup(View view)
	{
		job = getPrintJob();

		PageFormat newFormat = job.pageDialog(format);
		if(newFormat != null)
		{
			format = newFormat;
			jEdit.setIntegerProperty(""print.orientation"",format.getOrientation());
			Paper paper=format.getPaper();

			jEdit.setDoubleProperty(""print.width"",paper.getImageableWidth());
			jEdit.setDoubleProperty(""print.height"",paper.getImageableHeight());
			jEdit.setDoubleProperty(""print.x"",paper.getImageableX());
			jEdit.setDoubleProperty(""print.y"",paper.getImageableY());
			jEdit.setDoubleProperty(""print.pagewidth"",paper.getWidth());
			jEdit.setDoubleProperty(""print.pageheight"",paper.getHeight());
		}
	} 

	
	public static void print(final View view, final Buffer buffer, boolean selection)
	{
		job = getPrintJob();
		job.setJobName(buffer.getPath());
		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = jEdit.getFontProperty(""print.font"");

		BufferPrintable printable = new BufferPrintable(job,null,view,
			buffer,font,header,footer,lineNumbers,color);
		job.setPrintable(printable,format);

		if(!job.printDialog())
			return;

		printable.print();
	} 

	
	public static PageFormat getPageFormat()
	{
		return format;
	} 

	
	private static PageFormat format;
	private static PrinterJob job;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.ReloadWithEncodingProvider,4,1,0,7,39,4,0,7,4,0.666666667,235,1.0,1,0.0,0.5,0,0,57.5,6,3.0,0,"

package org.gjt.sp.jedit.menu;


import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import java.util.Arrays;
import java.util.Hashtable;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;

import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.io.EncodingServer;



public class ReloadWithEncodingProvider implements ActionListener, DynamicMenuProvider
{	
	private View view;

	
	public boolean updateEveryTime()
	{
		return false;
	} 

	
	public void update(JMenu menu)
	{
		view = GUIUtilities.getView(menu);

		
		JMenuItem auto = new JMenuItem(
			jEdit.getProperty(""vfs.browser.commands.encoding.auto-detect""));
		auto.setActionCommand(""auto-detect"");
		auto.addActionListener(this);
		menu.add(auto);
		menu.addSeparator();
		
		String[] encodings = MiscUtilities.getEncodings(true);
		String systemEncoding = System.getProperty(""file.encoding"");

		if (Arrays.binarySearch(encodings, systemEncoding) < 0)
		{
			String[] tmp_a = new String[encodings.length + 1];
			System.arraycopy(encodings, 0, tmp_a, 0, encodings.length);
			tmp_a[encodings.length] = systemEncoding;
			encodings = tmp_a;
		}

		Arrays.sort(encodings);

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);
		for (int i = 0; i < encodings.length; i++)
		{
			JMenuItem mi = new JMenuItem(encodings[i]);
			mi.setActionCommand(""encoding@"" + encodings[i]);
			mi.addActionListener(this);
			if ((menu.getMenuComponentCount() >= maxItems) && (i < encodings.length))
			{
				JMenu newMenu = new JMenu(jEdit.getProperty(""common.more""));
				menu.add(newMenu);
				menu = newMenu;
			}
			menu.add(mi);
		}

		menu.addSeparator();

		
		JMenuItem other = new JMenuItem(
			jEdit.getProperty(""vfs.browser.other-encoding.label""));
		other.setActionCommand(""other-encoding"");
		other.addActionListener(this);
		menu.add(other);
	} 

	
	public void actionPerformed(ActionEvent ae)
	{
		JMenuItem mi = (JMenuItem) ae.getSource();
		String action = mi.getActionCommand();
		String encoding = null;
		Hashtable props = null;

		if (action.startsWith(""encoding@""))
		{
			encoding = action.substring(9);
		}
		else if (action.equals(""other-encoding""))
		{
			encoding = JOptionPane.showInputDialog(view,
				jEdit.getProperty(""encoding-prompt.message""),
				jEdit.getProperty(""encoding-prompt.title""),
				JOptionPane.QUESTION_MESSAGE);
			if (encoding == null)
				return;

			if (!EncodingServer.hasEncoding(encoding))
			{
				String msg = jEdit.getProperty(""reload-encoding.error"",
						new Object[] { encoding });
				JOptionPane.showMessageDialog(view,
					msg,
					jEdit.getProperty(""common.error""),
					JOptionPane.ERROR_MESSAGE);
				return;
			}
		}

		if (encoding != null)
		{
			props = new Hashtable();
			props.put(Buffer.ENCODING, encoding);
			
			
			props.put(Buffer.ENCODING_AUTODETECT, false);
			view.getBuffer().setStringProperty(Buffer.ENCODING, encoding);
		}

		String path = view.getBuffer().getPath();
		jEdit.closeBuffer(view, view.getBuffer());
		jEdit.openFile(view,null,path,false,props);
	} 
}

"
jEdit,4.3,org.gjt.sp.util.WorkThreadPool,20,1,0,15,45,62,14,5,9,0.845864662,603,0.785714286,5,0.0,0.172222222,0,0,28.45,14,3.0,0,"

package org.gjt.sp.util;


import javax.swing.event.EventListenerList;
import javax.swing.SwingUtilities;



public class WorkThreadPool
{
	
	
	public WorkThreadPool(String name, int count)
	{
		listenerList = new EventListenerList();

		if(count != 0)
		{
			threadGroup = new ThreadGroup(name);
			threads = new WorkThread[count];
			for(int i = 0; i < threads.length; i++)
			{
				threads[i] = new WorkThread(this,threadGroup,name + "" #"" + (i+1));
			}
		}
		else
			Log.log(Log.WARNING,this,""Async I/O disabled"");
	} 

	
	
	public void start()
	{
		
		synchronized(lock)
		{
			started = true;

			if(awtRequestCount != 0 && requestCount == 0)
				queueAWTRunner();
		}

		if(threads != null)
		{
			for(int i = 0; i < threads.length; i++)
			{
				threads[i].start();
			}
		}
	} 

	
	
	public void addWorkRequest(Runnable run, boolean inAWT)
	{
		if(threads == null)
		{
			run.run();
			return;
		}

		synchronized(lock)
		{
			
			if(started && inAWT && requestCount == 0 && awtRequestCount == 0)
			{


				if(SwingUtilities.isEventDispatchThread())
					run.run();
				else
					SwingUtilities.invokeLater(run);

				return;
			} 

			Request request = new Request(run);

			
			if(inAWT)
			{
				if(firstAWTRequest == null && lastAWTRequest == null)
					firstAWTRequest = lastAWTRequest = request;
				else
				{
					lastAWTRequest.next = request;
					lastAWTRequest = request;
				}

				awtRequestCount++;

				
				
				
				if(started && requestCount == 0)
					queueAWTRunner();
			} 
			
			else
			{
				if(firstRequest == null && lastRequest == null)
					firstRequest = lastRequest = request;
				else
				{
					lastRequest.next = request;
					lastRequest = request;
				}

				requestCount++;
			} 

			lock.notifyAll();
		}
	} 

	
	
	public void waitForRequests()
	{
		if(threads == null)
			return;

		synchronized(waitForAllLock)
		{
			while(requestCount != 0)
			{
				try
				{
					waitForAllLock.wait();
				}
				catch(InterruptedException ie)
				{
					Log.log(Log.ERROR,this,ie);
				}
			}
		}

		if(SwingUtilities.isEventDispatchThread())
		{
			
			doAWTRequests();
		}
		else
		{
			try
			{
				SwingUtilities.invokeAndWait(new RunRequestsInAWTThread());
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
	} 

	
	
	public int getRequestCount()
	{
		return requestCount;
	} 

	
	
	public int getThreadCount()
	{
		if(threads == null)
			return 0;
		else
			return threads.length;
	} 

	
	
	public WorkThread getThread(int index)
	{
		return threads[index];
	} 

	
	
	public void addProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.add(WorkThreadProgressListener.class,listener);
	} 

	
	
	public void removeProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.remove(WorkThreadProgressListener.class,listener);
	} 

	
	final Object lock = new Object();
	final Object waitForAllLock = new Object();

	
	void fireStatusChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}

			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.statusUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} 

	
	void fireProgressChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}

			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.progressUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} 

	
	void requestDone()
	{
		synchronized(lock)
		{
			requestCount--;

			if(requestCount == 0 && firstAWTRequest != null)
				queueAWTRunner();
		}
	} 

	
	Request getNextRequest()
	{
		synchronized(lock)
		{
			Request request = firstRequest;
			if(request == null)
				return null;

			firstRequest = firstRequest.next;
			if(firstRequest == null)
				lastRequest = null;

			if(request.alreadyRun)
				throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
			request.alreadyRun = true;

			

			return request;
		}
	} 

	

	

	
	private boolean started;
	private ThreadGroup threadGroup;
	private WorkThread[] threads;

	
	private Request firstRequest;
	private Request lastRequest;
	private int requestCount;

	
	private boolean awtRunnerQueued;
	private Request firstAWTRequest;
	private Request lastAWTRequest;
	private int awtRequestCount;

	private EventListenerList listenerList;
	

	
	
	private void doAWTRequests()
	{
		while(requestCount == 0 && firstAWTRequest != null)
		{
			doAWTRequest(getNextAWTRequest());
		}
	} 

	
	
	private void doAWTRequest(Request request)
	{


		try
		{
			request.run.run();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in AWT thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}

		awtRequestCount--;
	} 

	
	
	private void queueAWTRunner()
	{
		if(!awtRunnerQueued)
		{
			awtRunnerQueued = true;
			SwingUtilities.invokeLater(new RunRequestsInAWTThread());

		}
	} 

	
	private Request getNextAWTRequest()
	{
		Request request = firstAWTRequest;
		firstAWTRequest = firstAWTRequest.next;
		if(firstAWTRequest == null)
			lastAWTRequest = null;

		if(request.alreadyRun)
			throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
		request.alreadyRun = true;

		

		return request;
	} 

	

	static int ID;

	
	static class Request
	{
		int id = ++ID;

		Runnable run;

		boolean alreadyRun;

		Request next;

		Request(Runnable run)
		{
			this.run = run;
		}

		public String toString()
		{
			return ""[id="" + id + "",run="" + run + ""]"";
		}
	} 

	
	class RunRequestsInAWTThread implements Runnable
	{
		public void run()
		{
			synchronized(lock)
			{
				awtRunnerQueued = false;
				if(requestCount == 0)
					doAWTRequests();
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHClassDeclaration,3,2,0,12,16,1,3,10,2,1.0,123,0.0,1,0.894736842,0.5,1,2,38.0,1,0.6667,0,"

package org.gjt.sp.jedit.bsh;


class BSHClassDeclaration extends SimpleNode
{
	
	static final String CLASSINITNAME = ""_bshClassInit"";

	String name;
	Modifiers modifiers;
	int numInterfaces;
	boolean extend;
	boolean isInterface;

	BSHClassDeclaration(int id) { super(id); }

	
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		int child = 0;

		
		Class superClass = null;
		if ( extend ) 
		{
			BSHAmbiguousName superNode = (BSHAmbiguousName)jjtGetChild(child++);
			superClass = superNode.toClass( callstack, interpreter );
		}

		
		Class [] interfaces = new Class[numInterfaces];
		for( int i=0; i<numInterfaces; i++) {
			BSHAmbiguousName node = (BSHAmbiguousName)jjtGetChild(child++);
			interfaces[i] = node.toClass(callstack, interpreter);
			if ( !interfaces[i].isInterface() )
				throw new EvalError(
					""Type: ""+node.text+"" is not an interface!"", 
					this, callstack );
		}

		BSHBlock block;
		
		if ( child < jjtGetNumChildren() )
			block = (BSHBlock)jjtGetChild(child);
		else
			block = new BSHBlock( ParserTreeConstants.JJTBLOCK );

		try {
			return ClassGenerator.getClassGenerator().generateClass( 
				name, modifiers, interfaces, superClass, block, isInterface,
				callstack, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}

	}

	public String toString() {
		return ""ClassDeclaration: ""+name;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.CompleteWord,13,6,0,16,86,50,1,16,2,0.716666667,638,1.0,3,0.981102362,0.192307692,3,5,47.69230769,15,4.2308,0,"

package org.gjt.sp.jedit.gui;


import java.awt.Component;
import java.awt.Font;
import java.awt.Point;

import java.awt.event.KeyEvent;

import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;
import java.util.Arrays;
import java.util.Collection;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JList;
import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.jedit.visitors.JEditVisitorAdapter;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.jedit.View;

import org.gjt.sp.jedit.syntax.KeywordMap;

import org.gjt.sp.jedit.textarea.JEditTextArea;

import org.gjt.sp.util.StandardUtilities;



public class CompleteWord extends CompletionPopup
{
	
	public static void completeWord(View view)
	{
		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();
		int caretLine = textArea.getCaretLine();
		int caret = textArea.getCaretPosition();

		if(!buffer.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
		String noWordSep = getNonAlphaNumericWordChars(
			buffer,keywordMap);
		String word = getWordToComplete(buffer,caretLine,
			caret,noWordSep);
		if(word == null)
		{
			textArea.getToolkit().beep();
			return;
		}

		Completion[] completions = getCompletions(buffer,word,caret);

		if(completions.length == 0)
		{
			textArea.getToolkit().beep();
		}
		
		else if(completions.length == 1)
		{
			Completion c = completions[0];

			if(c.text.equals(word))
			{
				textArea.getToolkit().beep();
			}
			else
			{
				textArea.replaceSelection(c.text.substring(
					word.length()));
			}
		} 
		
		else
		{
			String longestPrefix = MiscUtilities.getLongestPrefix(
				completions,
				keywordMap != null
				? keywordMap.getIgnoreCase()
				: false);

			if (word.length() < longestPrefix.length())
			{
				buffer.insert(caret,longestPrefix.substring(
					word.length()));
			}

			textArea.scrollToCaret(false);
			Point location = textArea.offsetToXY(
				caret - word.length());
			location.y += textArea.getPainter().getFontMetrics()
				.getHeight();

			SwingUtilities.convertPointToScreen(location,
				textArea.getPainter());
			new CompleteWord(view,longestPrefix,
				completions,location,noWordSep);
		} 
	} 

	
	public CompleteWord(View view, String word, Completion[] completions,
		Point location, String noWordSep)
	{
		super(view, location);

		this.noWordSep = noWordSep;
		this.view = view;
		this.textArea = view.getTextArea();
		this.buffer = view.getBuffer();
		this.word = word;

		reset(new Words(completions), true);
	} 

	

	
	private static String getNonAlphaNumericWordChars(Buffer buffer,
		KeywordMap keywordMap)
	{
		
		
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		if(noWordSep == null)
			noWordSep = """";
		if(keywordMap != null)
		{
			String keywordNoWordSep = keywordMap.getNonAlphaNumericChars();
			if(keywordNoWordSep != null)
				noWordSep += keywordNoWordSep;
		}

		return noWordSep;
	} 

	
	private static String getWordToComplete(Buffer buffer, int caretLine,
		int caret, String noWordSep)
	{
		CharSequence line = buffer.getLineSegment(caretLine);
		int dot = caret - buffer.getLineStartOffset(caretLine);
		if(dot == 0)
			return null;

		char ch = line.charAt(dot-1);
		if(!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1)
		{
			
			return null;
		}

		int wordStart = TextUtilities.findWordStart(line,dot-1,noWordSep);
		CharSequence word = line.subSequence(wordStart,dot);
		if(word.length() == 0)
			return null;

		return word.toString();
	} 
	
	
	private static Collection<Buffer> getVisibleBuffers()
	{
		final Set<Buffer> buffers = new HashSet<Buffer>();
		jEdit.visit(new JEditVisitorAdapter()
			{
				@Override
				public void visit(EditPane editPane)
				{
					buffers.add(editPane.getBuffer());
				}
			});
		return buffers;
	} 

	
	private static Completion[] getCompletions(final Buffer buffer, final String word,
		final int caret)
	{
		
		
		final Set<Completion> completions = new TreeSet<Completion>(new StandardUtilities
			.StringCompare<Completion>());

		
		final KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
		final String noWordSep = getNonAlphaNumericWordChars(
			buffer,keywordMap);
		
		final Collection<Buffer> sourceBuffers = 
			jEdit.getBooleanProperty(""completeFromAllBuffers"") ?
				Arrays.asList(jEdit.getBuffers()) :
				getVisibleBuffers();

		for (Buffer b : sourceBuffers)
		{
			
			KeywordMap _keywordMap;
			if(b == buffer)
				_keywordMap = keywordMap;
			else
				_keywordMap = null;

			int offset = (b == buffer ? caret : 0);

			getCompletions(b,word,keywordMap,noWordSep,
					offset,completions);
		}

		Completion[] completionArray = completions
			.toArray(new Completion[completions.size()]);

		return completionArray;
	} 

	
	private static void getCompletions(Buffer buffer, String word,
		KeywordMap keywordMap, String noWordSep, int caret,
		Set<Completion> completions)
	{
		int wordLen = word.length();

		
		if(keywordMap != null)
		{
			String[] keywords = keywordMap.getKeywords();
			for(int i = 0; i < keywords.length; i++)
			{
				String _keyword = keywords[i];
				if(_keyword.regionMatches(keywordMap.getIgnoreCase(),
					0,word,0,wordLen))
				{
					Completion keyword = new Completion(_keyword,true);
					if(!completions.contains(keyword))
					{
						completions.add(keyword);
					}
				}
			}
		} 

		
		for(int i = 0; i < buffer.getLineCount(); i++)
		{
			CharSequence line = buffer.getLineSegment(i);
			int start = buffer.getLineStartOffset(i);

			

			if (StandardUtilities.startsWith(line, word) &&
			    caret != start + word.length())
			{
				String _word = completeWord(line,0,noWordSep);
				Completion comp = new Completion(_word,false);

				
				if(!completions.contains(comp))
				{
					completions.add(comp);
				}
			}

			
			int len = line.length() - word.length();
			for(int j = 0; j < len; j++)
			{
				char c = line.charAt(j);
				if(!Character.isLetterOrDigit(c) && noWordSep.indexOf(c) == -1)
				{
					if (StandardUtilities.regionMatches(line,j + 1,word,0,wordLen)
						&& caret != start + j + word.length() + 1)
					{
						String _word = completeWord(line,j + 1,noWordSep);
						Completion comp = new Completion(_word,false);

						
						if(!completions.contains(comp))
						{
							completions.add(comp);
						}
					}
				}
			}
		} 
	} 

	
	private static String completeWord(CharSequence line, int offset, String noWordSep)
	{
		
		int wordEnd = TextUtilities.findWordEnd(line,offset + 1,noWordSep);
		return line.subSequence(offset,wordEnd).toString();
	} 

	
	private View view;
	private JEditTextArea textArea;
	private Buffer buffer;
	private String word;
	private String noWordSep;
	

	
	private static class Completion
	{
		final String text;
		final boolean keyword;

		Completion(String text, boolean keyword)
		{
			this.text = text;
			this.keyword = keyword;
		}

		public String toString()
		{
			return text;
		}

		public int hashCode()
		{
			return text.hashCode();
		}

		public boolean equals(Object obj)
		{
			if(obj instanceof Completion)
				return ((Completion)obj).text.equals(text);
			else
				return false;
		}
	} 

	
	private class Words implements Candidates
	{
		private final DefaultListCellRenderer renderer;
		private final Completion[] completions;

		public Words(Completion[] completions)
		{
			this.renderer = new DefaultListCellRenderer();
			this.completions = completions;
		}

		public int getSize()
		{
			return completions.length;
		}

		public boolean isValid()
		{
			return true;
		}

		public void complete(int index)
		{
			String insertion = completions[index].toString().substring(word.length());
			textArea.replaceSelection(insertion);
		}

		public Component getCellRenderer(JList list, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			renderer.getListCellRendererComponent(list,
				null, index, isSelected, cellHasFocus);

			Completion comp = completions[index];

			String text = comp.text;
			Font font = list.getFont();

			if(index < 9)
				text = (index + 1) + "": "" + text;
			else if(index == 9)
				text = ""0: "" + text;

			if(comp.keyword)
				font = font.deriveFont(Font.BOLD);

			renderer.setText(text);
			renderer.setFont(font);
			return renderer;
		}

		public String getDescription(int index)
		{
			return null;
		}
	} 

	
	private void resetWords(String newWord)
	{
		int caret = textArea.getCaretPosition();
		Completion[] completions = getCompletions(
			buffer,newWord,caret);
		if(completions.length > 0)
		{
			word = newWord;
			reset(new Words(completions), true);
		}
		else
		{
			dispose();
		}
	} 

	

	
	protected void keyPressed(KeyEvent e)
	{
		if (e.getKeyCode() == KeyEvent.VK_BACK_SPACE)
		{
			textArea.backspace();
			e.consume();

			if(word.length() == 1)
			{
				dispose();
			}
			else
			{
				resetWords(word.substring(0,word.length() - 1));
			}
		}
	} 

	
	protected void keyTyped(KeyEvent e)
	{
		char ch = e.getKeyChar();
		if(Character.isDigit(ch))
		{
			int index = ch - '0';
			if(index == 0)
				index = 9;
			else
				index--;
			if(index < getCandidates().getSize())
			{
				setSelectedIndex(index);
				if(doSelectedCompletion())
				{
					e.consume();
					dispose();
				}
				return;
			}
			else
				;
		}

		
		if(ch != '\b' && ch != '\t')
		{
			
			if(!Character.isLetterOrDigit(ch) && noWordSep.indexOf(ch) == -1)
			{
				doSelectedCompletion();
				textArea.userInput(ch);
				e.consume();
				dispose();
				return;
			}

			textArea.userInput(ch);
			e.consume();
			resetWords(word + ch);
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.EnhancedDialog,7,6,19,22,18,15,22,3,6,0.5,69,1.0,1,0.992378049,0.4,0,0,8.571428571,1,0.7143,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.awt.*;


public abstract class EnhancedDialog extends JDialog
{
	public EnhancedDialog(Frame parent, String title, boolean modal)
	{
		super(parent,title,modal);
		_init();
	}
	
	public EnhancedDialog(Dialog parent, String title, boolean modal)
	{
		super(parent,title,modal);
		_init();
	}

	public boolean getEnterEnabled()
	{
		return enterEnabled;
	}

	public void setEnterEnabled(boolean enterEnabled)
	{
		this.enterEnabled = enterEnabled;
	}
	
	public abstract void ok();
	public abstract void cancel();

	
	private void _init()
	{
		((Container)getLayeredPane()).addContainerListener(
			new ContainerHandler());
		getContentPane().addContainerListener(new ContainerHandler());

		keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		addWindowListener(new WindowHandler());

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		
		enterEnabled = true;
	}
	
	
	
	protected KeyHandler keyHandler;
	protected boolean enterEnabled;

	
	class ContainerHandler extends ContainerAdapter
	{
		public void componentAdded(ContainerEvent evt)
		{
			componentAdded(evt.getChild());
		}

		public void componentRemoved(ContainerEvent evt)
		{
			componentRemoved(evt.getChild());
		}

		private void componentAdded(Component comp)
		{
			comp.addKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.addContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentAdded(comps[i]);
				}
			}
		}

		private void componentRemoved(Component comp)
		{
			comp.removeKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.removeContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentRemoved(comps[i]);
				}
			}
		}
	}

	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.isConsumed())
				return;

			if(evt.getKeyCode() == KeyEvent.VK_ENTER
				&& enterEnabled)
			{
				Component comp = getFocusOwner();
				while(comp != null)
				{
					if(comp instanceof JComboBox)
					{
						JComboBox combo = (JComboBox)comp;
						if(combo.isEditable())
						{
							Object selected = combo.getEditor().getItem();
							if(selected != null)
								combo.setSelectedItem(selected);
						}
						break;
					}

					comp = comp.getParent();
				}

				ok();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				cancel();
				evt.consume();
			}
		}
	}

	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			cancel();
		}
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHPrimitiveType,2,2,0,4,3,1,3,1,1,1.0,10,0.0,0,0.944444444,0.75,0,0,3.5,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

class BSHPrimitiveType extends SimpleNode
{
	public Class type;

	BSHPrimitiveType(int id) { super(id); }
	public Class getType() { return type; }
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.ByteVector,11,1,0,3,17,0,3,0,10,0.1,514,0.0,0,0.0,0.4,0,0,45.54545455,11,2.4545,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



final class ByteVector {

  

  byte[] data;

  

  int length;

  

  public ByteVector () {
    data = new byte[64];
  }

  

  public ByteVector (final int initialSize) {
    data = new byte[initialSize];
  }

  

  public ByteVector put1 (final int b) {
    int length = this.length;
    if (length + 1 > data.length) {
      enlarge(1);
    }
    data[length++] = (byte)b;
    this.length = length;
    return this;
  }

  

  public ByteVector put11 (final int b1, final int b2) {
    int length = this.length;
    if (length + 2 > data.length) {
      enlarge(2);
    }
    byte[] data = this.data;
    data[length++] = (byte)b1;
    data[length++] = (byte)b2;
    this.length = length;
    return this;
  }

  

  public ByteVector put2 (final int s) {
    int length = this.length;
    if (length + 2 > data.length) {
      enlarge(2);
    }
    byte[] data = this.data;
    data[length++] = (byte)(s >>> 8);
    data[length++] = (byte)s;
    this.length = length;
    return this;
  }

  

  public ByteVector put12 (final int b, final int s) {
    int length = this.length;
    if (length + 3 > data.length) {
      enlarge(3);
    }
    byte[] data = this.data;
    data[length++] = (byte)b;
    data[length++] = (byte)(s >>> 8);
    data[length++] = (byte)s;
    this.length = length;
    return this;
  }

  

  public ByteVector put4 (final int i) {
    int length = this.length;
    if (length + 4 > data.length) {
      enlarge(4);
    }
    byte[] data = this.data;
    data[length++] = (byte)(i >>> 24);
    data[length++] = (byte)(i >>> 16);
    data[length++] = (byte)(i >>> 8);
    data[length++] = (byte)i;
    this.length = length;
    return this;
  }

  

  public ByteVector put8 (final long l) {
    int length = this.length;
    if (length + 8 > data.length) {
      enlarge(8);
    }
    byte[] data = this.data;
    int i = (int)(l >>> 32);
    data[length++] = (byte)(i >>> 24);
    data[length++] = (byte)(i >>> 16);
    data[length++] = (byte)(i >>> 8);
    data[length++] = (byte)i;
    i = (int)l;
    data[length++] = (byte)(i >>> 24);
    data[length++] = (byte)(i >>> 16);
    data[length++] = (byte)(i >>> 8);
    data[length++] = (byte)i;
    this.length = length;
    return this;
  }

  

  public ByteVector putUTF (final String s) {
    int charLength = s.length();
    int byteLength = 0;
    for (int i = 0; i < charLength; ++i) {
      char c = s.charAt(i);
      if (c >= '\001' && c <= '\177') {
        byteLength++;
      } else if (c > '\u07FF') {
        byteLength += 3;
      } else {
        byteLength += 2;
      }
    }
    if (byteLength > 65535) {
      throw new IllegalArgumentException();
    }
    int length = this.length;
    if (length + 2 + byteLength > data.length) {
      enlarge(2 + byteLength);
    }
    byte[] data = this.data;
    data[length++] = (byte)(byteLength >>> 8);
    data[length++] = (byte)(byteLength);
    for (int i = 0; i < charLength; ++i) {
      char c = s.charAt(i);
      if (c >= '\001' && c <= '\177') {
        data[length++] = (byte)c;
      } else if (c > '\u07FF') {
        data[length++] = (byte)(0xE0 | c >> 12 & 0xF);
        data[length++] = (byte)(0x80 | c >> 6 & 0x3F);
        data[length++] = (byte)(0x80 | c & 0x3F);
      } else {
        data[length++] = (byte)(0xC0 | c >> 6 & 0x1F);
        data[length++] = (byte)(0x80 | c & 0x3F);
      }
    }
    this.length = length;
    return this;
  }

  

  public ByteVector putByteArray (
    final byte[] b,
    final int off,
    final int len)
  {
    if (length + len > data.length) {
      enlarge(len);
    }
    if (b != null) {
      System.arraycopy(b, off, data, length, len);
    }
    length += len;
    return this;
  }

  

  private void enlarge (final int size) {
    byte[] newData = new byte[Math.max(2*data.length, length + size)];
    System.arraycopy(data, 0, newData, 0, length);
    data = newData;
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.JEditRegistersListener,2,1,0,6,5,1,1,5,1,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"
package org.gjt.sp.jedit;

import org.gjt.sp.jedit.msg.RegisterChanged;


class JEditRegistersListener implements RegistersListener
{
	public void registerChanged(char name)
	{
		EditBus.send(new RegisterChanged(null, name));
	}
}
"
jEdit,4.3,org.gjt.sp.util.ThreadAbortMonitor,1,1,0,1,1,0,1,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.util;


public interface ThreadAbortMonitor
{
	boolean isAborted();
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.RegisterViewer,18,5,0,19,78,119,5,18,6,0.857142857,424,1.0,2,0.974626866,0.173611111,2,8,22.16666667,9,2.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.Registers.Register;
import org.gjt.sp.jedit.msg.RegisterChanged;
import org.gjt.sp.jedit.msg.PropertiesChanged;


public class RegisterViewer extends JPanel implements EBComponent, ActionListener,
	DockableWindow
{
	
	public RegisterViewer(View view, String position)
	{
		super(new BorderLayout());
		this.view = view;
		Box toolBar = new Box(BoxLayout.X_AXIS);
		JLabel label = new JLabel(
			jEdit.getProperty(""view-registers.title""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		toolBar.add(label);
		
		toolBar.add(Box.createGlue());

		RolloverButton pasteRegister = new RolloverButton(
			GUIUtilities.loadIcon(""Paste.png""));
		pasteRegister.setToolTipText(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""paste-string-register.label"")));
		pasteRegister.addActionListener(this);
		pasteRegister.setActionCommand(""paste-string-register"");
		toolBar.add(pasteRegister);

		RolloverButton clearRegister = new RolloverButton(
			GUIUtilities.loadIcon(""Clear.png""));
		clearRegister.setToolTipText(GUIUtilities.prettifyMenuLabel(
			jEdit.getProperty(""clear-string-register.label"")));
		clearRegister.addActionListener(this);
		clearRegister.setActionCommand(""clear-string-register"");
		toolBar.add(clearRegister);

		
		add(BorderLayout.NORTH,toolBar);

		DefaultListModel registerModel = new DefaultListModel();
		registerList = new JList(registerModel);
		registerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		registerList.setCellRenderer(new Renderer());
		registerList.addListSelectionListener(new ListHandler());
		registerList.addMouseListener(new MouseHandler());

		contentTextArea = new JTextArea(10,20);
		contentTextArea.setEditable(true);
		documentHandler = new DocumentHandler();
		
		contentTextArea.addFocusListener(new FocusHandler());

		int orientation = JSplitPane.HORIZONTAL_SPLIT;
		if (position.equals(DockableWindowManager.LEFT) ||
			position.equals(DockableWindowManager.RIGHT))
			orientation = JSplitPane.VERTICAL_SPLIT;

		add(BorderLayout.CENTER,splitPane = new JSplitPane(orientation,
			jEdit.getBooleanProperty(""appearance.continuousLayout""),
			new JScrollPane(registerList),
			new JScrollPane(contentTextArea)));

		refreshList();
	} 
	
	
	public void actionPerformed(ActionEvent evt)
	{
		String cmd = evt.getActionCommand();
		if (cmd.equals(""paste-string-register""))
			insertRegister();
		else if (cmd.equals(""clear-string-register""))
			clearSelectedIndex();
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if (msg instanceof RegisterChanged)
		{
			if (((RegisterChanged)msg).getRegisterName() != '%')
				refreshList();
		}
		else if (msg instanceof PropertiesChanged)
		{
			GUIUtilities.initContinuousLayout(splitPane);
		}

	}

	
	@Override
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} 

	
	@Override
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	} 

	
	public void move(String newPosition)
	{
		int orientation = JSplitPane.HORIZONTAL_SPLIT;
		if (newPosition.equals(DockableWindowManager.LEFT) ||
			newPosition.equals(DockableWindowManager.RIGHT))
			orientation = JSplitPane.VERTICAL_SPLIT;
		splitPane.setOrientation(orientation);
		revalidate();
	} 

	

	
	private void clearSelectedIndex()
	{
		Object o = registerList.getSelectedValue();
		if (o != null && o instanceof Character)
		{
			Registers.clearRegister(((Character)o).charValue());
			refreshList();
		}
	} 

	
	private JList registerList;
	private JTextArea contentTextArea;
	private DocumentHandler documentHandler;
	private View view;
	private boolean editing;
	private JSplitPane splitPane;
	private JPopupMenu popup;
	

	
	private void refreshList()
	{
		DefaultListModel registerModel = (DefaultListModel)registerList.getModel();
		Object o = registerList.getSelectedValue();
		int selected = -1;
		if (o != null && o instanceof Character)
			selected = ((Character)o).charValue();

		registerModel.removeAllElements();
		Registers.Register[] registers = Registers.getRegisters();

		int index = 0;
		for(int i = 0; i < registers.length; i++)
		{
			Registers.Register reg = registers[i];
			if(reg == null)
				continue;
			if (i == '%')
				continue;

			String value = reg.toString();
			if(value == null) 
				continue;
			if (i == selected)
				index = registerModel.size();
			registerModel.addElement(Character.valueOf((char)i));
		}

		if(registerModel.getSize() == 0)
		{
			registerModel.addElement(jEdit.getProperty(""view-registers.none""));
			registerList.setEnabled(false);
		}
		else
			registerList.setEnabled(true);
		registerList.setSelectedIndex(index);
	} 

	
	private void insertRegister()
	{
		Object o = registerList.getSelectedValue();
		if (o == null || !(o instanceof Character))
			return;
		Registers.Register reg = Registers.getRegister(((Character)o).charValue());
		view.getTextArea().setSelectedText(reg.toString());
		view.getTextArea().requestFocus();
	} 

	

	

	
	static class Renderer extends DefaultListCellRenderer
	{
		@Override
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,
			index,isSelected,cellHasFocus);

			if(value instanceof Character)
			{
				char name = ((Character)value).charValue();

				String label;

				if(name == '\n')
					label = ""\n"";
				else if(name == '\t')
					label = ""\t"";
				else if(name == '$')
					label = jEdit.getProperty(""view-registers.clipboard"");
				else if(name == '%')
					label = jEdit.getProperty(""view-registers.selection"");
				else
					label = String.valueOf(name);
				Register register = Registers.getRegister(name);
				String registerValue;
				if (register == null)
				{
					
					
					registerValue = jEdit.getProperty(""view-registers.undefined"");
				}
				else
				{
					registerValue = register.toString();
					if (registerValue.length() > 100)
						registerValue = registerValue.substring(0,100)+""..."";
					registerValue = registerValue.replaceAll(""\n"","" "");
					registerValue = registerValue.replaceAll(""\t"","" "");
				}
				setText(label + "" : "" + registerValue);
			}

			return this;

		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{			
			Object value = registerList.getSelectedValue();
			if(!(value instanceof Character))
			{
				if (!editing)
				{
					contentTextArea.setText("""");
					contentTextArea.setEditable(false);
				}
				return;
			}

			char name = ((Character)value).charValue();

			Registers.Register reg = Registers.getRegister(name);
			if(reg == null)
			{
				if (!editing)
				{
					contentTextArea.setText("""");
					contentTextArea.setEditable(false);
				}	
				return;
			}
			
			
			if (!editing)
			{
				contentTextArea.setText(reg.toString());
				contentTextArea.setEditable(true);
				contentTextArea.setCaretPosition(0);
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			int i = registerList.locationToIndex(evt.getPoint());
			if (i != -1)
				registerList.setSelectedIndex(i);
			if (GUIUtilities.isPopupTrigger(evt))
			{
				if (popup == null)
				{
					popup = new JPopupMenu();
					JMenuItem item = GUIUtilities.loadMenuItem(""paste"");
					popup.add(item);
					item = new JMenuItem(jEdit.getProperty(""clear-string-register.label""));
					item.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							clearSelectedIndex();
						}
					});
					popup.add(item);
				}
				GUIUtilities.showPopupMenu(popup, registerList, evt.getX(), evt.getY(), false);
			}
			else if (evt.getClickCount() % 2 == 0)
				insertRegister();
		}
	} 

	
	class DocumentHandler implements DocumentListener
	{
		public void changedUpdate(DocumentEvent e)
		{
			updateRegisterSafely();
		}

		public void insertUpdate(DocumentEvent e)
		{
			updateRegisterSafely();
		}

		public void removeUpdate(DocumentEvent e)
		{
			updateRegisterSafely();
		}

		private void updateRegisterSafely()
		{
			try
			{
				editing = true;
				updateRegister();
			}
			finally
			{
				editing = false;
			}
		}
		
		private void updateRegister()
		{
			Object value = registerList.getSelectedValue();
			if(!(value instanceof Character))
				return;
			char name = ((Character)value).charValue();
			Registers.setRegister(name,contentTextArea.getText());
		}
	} 

	
	class FocusHandler implements FocusListener
	{
		public void focusGained(FocusEvent e)
		{
			contentTextArea.getDocument().addDocumentListener(documentHandler);
		}
		public void focusLost(FocusEvent e)
		{
			contentTextArea.getDocument().removeDocumentListener(documentHandler);
		}
	}

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ReflectError,2,3,0,9,4,1,9,0,2,2.0,9,0.0,0,1.0,0.75,0,0,3.5,0,0.0,0,"


package org.gjt.sp.jedit.bsh;

class ReflectError extends Exception
{
	public ReflectError() { super(); }
	public ReflectError(String s) { super(s); }
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.FloatingWindowContainer,14,6,0,11,57,57,5,10,10,0.8,260,0.8,2,0.980243161,0.261904762,4,4,17.21428571,4,1.2857,0,"

package org.gjt.sp.jedit.gui;


import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPopupMenu;
import javax.swing.JSeparator;
import javax.swing.SwingUtilities;

import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;



public class FloatingWindowContainer extends JFrame implements DockableWindowContainer,
	PropertyChangeListener
{
	String dockableName = null;
	
	public FloatingWindowContainer(DockableWindowManagerImpl dockableWindowManager,
		boolean clone)
	{
		this.dockableWindowManager = dockableWindowManager;

		dockableWindowManager.addPropertyChangeListener(this);
		this.clone = clone;
		setIconImage(GUIUtilities.getPluginIcon());
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		Box caption = new Box(BoxLayout.X_AXIS);
		caption.add(menu = new RolloverButton(GUIUtilities
			.loadIcon(jEdit.getProperty(""dropdown-arrow.icon""))));
		menu.addMouseListener(new MouseHandler());
		menu.setToolTipText(jEdit.getProperty(""docking.menu.label""));
		Box separatorBox = new Box(BoxLayout.Y_AXIS);
		separatorBox.add(Box.createVerticalStrut(3));
		separatorBox.add(new JSeparator(JSeparator.HORIZONTAL));
		separatorBox.add(Box.createVerticalStrut(3));
		caption.add(separatorBox);
		getContentPane().add(BorderLayout.NORTH,caption);
	
		
	} 

	
	public void register(DockableWindowManagerImpl.Entry entry)
	{
		this.entry = entry;
		dockableName = entry.factory.name;
		
		setTitle(entry.shortTitle());

		getContentPane().add(BorderLayout.CENTER,entry.win);

		pack();
		Container parent = dockableWindowManager.getView();
		GUIUtilities.loadGeometry(this, parent, dockableName);
		GUIUtilities.addSizeSaver(this, parent, dockableName);
		KeyListener listener = dockableWindowManager.closeListener(dockableName);
		addKeyListener(listener);
		getContentPane().addKeyListener(listener);
		menu.addKeyListener(listener);
		entry.win.addKeyListener(listener);
		setVisible(true);
		if (! entry.win.isVisible())
			entry.win.setVisible(true);
	} 

	
	public void remove(DockableWindowManagerImpl.Entry entry)
	{
		dispose();
	} 

	
	public void unregister(DockableWindowManagerImpl.Entry entry)
	{
		this.entry = null;
		entry.btn = null;
		entry.container = null;
		
		
		
		super.dispose();
	} 

	
	public void show(final DockableWindowManagerImpl.Entry entry)
	{
		if(entry == null)
			dispose();
		else
		{
			setTitle(entry.longTitle());
			toFront();
			requestFocus();
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(entry.win instanceof DefaultFocusComponent)
					{
						((DefaultFocusComponent)entry.win)
							.focusOnDefaultComponent();
					}
					else
					{
						entry.win.requestFocus();
					}
				}
			});
		}
	} 

	
	public boolean isVisible(DockableWindowManagerImpl.Entry entry)
	{
		return true;
	} 

	
	@Override
	public void dispose()
	{
		entry.container = null;
		entry.win = null;
		super.dispose();
	} 

	
	public DockableWindowManagerImpl getDockableWindowManager()
	{
		return dockableWindowManager;
	} 

	
	@Override
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	
	private final DockableWindowManagerImpl dockableWindowManager;
	private final boolean clone;
	private DockableWindowManagerImpl.Entry entry;
	private final JButton menu;
	

	
	class MouseHandler extends MouseAdapter
	{
		JPopupMenu popup;

		@Override
		public void mousePressed(MouseEvent evt)
		{
			if(popup != null && popup.isVisible())
				popup.setVisible(false);
			else
			{
				popup = dockableWindowManager.createPopupMenu(
					FloatingWindowContainer.this,
					entry.factory.name,clone);
				GUIUtilities.showPopupMenu(popup,
					menu,menu.getX(),menu.getY() + menu.getHeight(),
					false);
			}
		}
	} 
	public void propertyChange(PropertyChangeEvent evt)
	{
		if (dockableName == null) return;
		String pn = evt.getPropertyName();
		if (pn.startsWith(dockableName) && pn.endsWith(""title""))
			setTitle(evt.getNewValue().toString());
	}
	
}

"
jEdit,4.3,org.gjt.sp.jedit.search.BufferListSet,8,1,2,8,14,8,2,6,7,0.428571429,175,1.0,0,0.0,0.4375,0,0,20.75,11,3.125,0,"

package org.gjt.sp.jedit.search;


import java.awt.Component;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.util.StandardUtilities;



public abstract class BufferListSet implements SearchFileSet
{
	
	public synchronized String getFirstFile(View view)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null || files.length == 0)
			return null;
		else
			return files[0];
	} 

	
	public synchronized String getNextFile(View view, String path)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null || files.length == 0)
			return null;

		if(path == null)
		{
			path = view.getBuffer().getSymlinkPath();
			VFS vfs = VFSManager.getVFSForPath(path);
			boolean ignoreCase = ((vfs.getCapabilities()
				& VFS.CASE_INSENSITIVE_CAP) != 0);

			for(int i = 0; i < files.length; i++)
			{
				if(StandardUtilities.compareStrings(
					files[i],path,ignoreCase) == 0)
				{
					return path;
				}
			}

			return getFirstFile(view);
		}
		else
		{
			
			VFS vfs = VFSManager.getVFSForPath(path);
			boolean ignoreCase = ((vfs.getCapabilities()
				& VFS.CASE_INSENSITIVE_CAP) != 0);

			for(int i = 0; i < files.length - 1; i++)
			{
				if(StandardUtilities.compareStrings(
					files[i],path,ignoreCase) == 0)
				{
					return files[i+1];
				}
			}

			return null;
		}
	} 

	
	public synchronized String[] getFiles(View view)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null || files.length == 0)
			return null;
		else
			return files;
	} 

	
	public synchronized int getFileCount(View view)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null)
			return 0;
		else
			return files.length;
	} 

	
	public String getCode()
	{
		
		return null;
	} 

	
	public void invalidateCachedList()
	{
		files = null;
	} 

	
	protected abstract String[] _getFiles(Component comp);

	private String[] files;
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.DefaultTokenHandler,9,1,2,10,12,28,6,4,6,0.75,91,1.0,3,0.0,0.37037037,0,0,8.777777778,3,1.3333,0,"

package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;


public class DefaultTokenHandler implements TokenHandler
{
	
	
	public void init()
	{
		lastToken = firstToken = null;
	} 

	
	
	public Token getTokens()
	{
		return firstToken;
	} 

	
	
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		Token token = createToken(id,offset,length,context);
		if(token != null)
			addToken(token,context);
	} 

	
	
	public TokenMarker.LineContext getLineContext()
	{
		return lineContext;
	} 

	
	
	public void setLineContext(TokenMarker.LineContext lineContext)
	{
		this.lineContext = lineContext;
	} 

	
	protected Token firstToken, lastToken;
	protected TokenMarker.LineContext lineContext;

	
	protected ParserRuleSet getParserRuleSet(TokenMarker.LineContext context)
	{
		while(context != null)
		{
			if(!context.rules.isBuiltIn())
				return context.rules;

			context = context.parent;
		}

		return null;
	} 

	
	protected Token createToken(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		return new Token(id,offset,length,getParserRuleSet(context));
	} 

	
	protected void addToken(Token token, TokenMarker.LineContext context)
	{
		if(firstToken == null)
		{
			firstToken = lastToken = token;
		}
		else
		{
			lastToken.next = token;
			lastToken = lastToken.next;
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.bufferset.BufferSetManager,15,1,0,20,63,105,10,18,12,2.0,397,0.0,0,0.0,0.259259259,0,0,25.46666667,6,2.2,0,"
package org.gjt.sp.jedit.bufferset;


import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.msg.EditPaneUpdate;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;

import java.util.*;



public class BufferSetManager implements EBComponent
{
	
	public enum NewBufferSetAction
	{
		empty, copy, currentbuffer;

		public static NewBufferSetAction fromString(String s)
		{
			NewBufferSetAction[] newBufferSetActions = values();
			for (NewBufferSetAction newBufferSetAction : newBufferSetActions)
			{
				if (newBufferSetAction.getName().equals(s))
					return newBufferSetAction;
			}

			return currentbuffer;
		}

		public String getName()
		{
			return super.toString();
		}

		@Override
		public String toString()
		{
			return jEdit.getProperty(""options.editpane.bufferset.newbufferset."" + getName());
		}
	} 

	
	public BufferSetManager()
	{
		EditBus.addToBus(this);
	} 

	
	public void handleMessage(EBMessage message)
	{
		if (message instanceof ViewUpdate)
		{
			ViewUpdate viewUpdate = (ViewUpdate) message;
			if (viewUpdate.getWhat() == ViewUpdate.CLOSED)
			{
				View view = viewUpdate.getView();
				
				BufferSet viewBufferSet = view.getLocalBufferSet();
				viewBufferSet.getAllBuffers(new BufferSetClosed(viewBufferSet));
			}
		}
		else if (message instanceof EditPaneUpdate)
		{
			EditPaneUpdate editPaneUpdate = (EditPaneUpdate) message;
			if (editPaneUpdate.getWhat() == EditPaneUpdate.DESTROYED)
			{
				EditPane editPane = editPaneUpdate.getEditPane();
				
				if (editPane.getBufferSetScope() == BufferSet.Scope.editpane)
				{
					BufferSet editPaneBufferSet = editPane.getBufferSet();
					editPaneBufferSet.getAllBuffers(new BufferSetClosed(editPaneBufferSet));
				}
			}
		}
		else if (message instanceof PropertiesChanged)
		{
			
			
			visit(new BufferSetVisitor()
			{
				public void visit(BufferSet bufferSet)
				{
					bufferSet.handleMessage();
				}
			});
		}

	} 

	
	
	public void mergeBufferSet(BufferSet target, BufferSet source)
	{
		Buffer[] buffers = source.getAllBuffers();
		for (Buffer buffer : buffers)
		{
			addBuffer(target, buffer);
		}
	} 

	
	
	public int countBufferSets(Buffer buffer)
	{
		return getOwners(buffer).size();
	} 

	
	
	public void addBuffer(View view, Buffer buffer)
	{
		EditPane editPane = view == null ? null : view.getEditPane();
		addBuffer(editPane, buffer);
	}

	
	public void addBuffer(EditPane editPane, Buffer buffer)
	{
		if (editPane == null)
		{
			addBuffer(jEdit.getGlobalBufferSet(), buffer);
		}
		else
		{
			BufferSet bufferSet = editPane.getBufferSet();
			addBuffer(bufferSet, buffer);
		}
	}

	
	public void addBuffer(BufferSet bufferSet, Buffer buffer)
	{
		bufferSet.addBuffer(buffer);
	} 

	
	
	public void addAllBuffers(BufferSet bufferSet)
	{
		Buffer[] buffers = jEdit.getBuffers();
		for (Buffer buffer : buffers)
		{
			if (!buffer.isClosed())
				addBuffer(bufferSet, buffer);
		}
	} 

	
	
	public void moveBuffer(EditPane editPane,
		int oldPosition, int newPosition)
	{
		editPane.getBufferSet().moveBuffer(oldPosition, newPosition);
	} 

	
	
	public void removeBuffer(EditPane editPane, Buffer buffer)
	{
		BufferSet bufferSet = editPane.getBufferSet();
		removeBuffer(bufferSet, buffer);
	}

	
	void removeBuffer(BufferSet bufferSet, Buffer buffer)
	{
		Log.log(Log.DEBUG, this, ""removeBuffer(""+bufferSet+','+buffer+')');
		Set<BufferSet> owners = getOwners(buffer);
		owners.remove(bufferSet);
		bufferSet.removeBuffer(buffer);

		if (owners.isEmpty())
		{
			Log.log(Log.DEBUG, this, ""Buffer:""+buffer+"" is in no bufferSet anymore, closing it"");
			jEdit._closeBuffer(null, buffer);
		}
		if (bufferSet.size() == 0 && bufferSet.hasListeners())
		{
			int untitledCount = jEdit.getNextUntitledBufferId();
			Buffer newEmptyBuffer = jEdit.openTemporary(jEdit.getActiveView(), null,
								    ""Untitled-"" + untitledCount,true, null);
			jEdit.commitTemporary(newEmptyBuffer);
			jEdit.getBufferSetManager().addBuffer(bufferSet, newEmptyBuffer);
		}
	} 

	
	
	public void removeBuffer(Buffer buffer)
	{
		for (BufferSet bufferSet : getOwners(buffer))
		{
			bufferSet.removeBuffer(buffer);
			if (bufferSet.size() == 0 && bufferSet.hasListeners())
			{
				int untitledCount = jEdit.getNextUntitledBufferId();
				Buffer newEmptyBuffer = jEdit.openTemporary(jEdit.getActiveView(), null,
									    ""Untitled-"" + untitledCount,true, null);
				jEdit.commitTemporary(newEmptyBuffer);
				jEdit.getBufferSetManager().addBuffer(bufferSet, newEmptyBuffer);
			}
		}

	} 

	
	
	public void visit(BufferSetVisitor visitor)
	{
		BufferSet global = jEdit.getGlobalBufferSet();
		visitor.visit(jEdit.getGlobalBufferSet());
		for (View view: jEdit.getViews())
		{
			BufferSet viewLocal = view.getLocalBufferSet();
			if (viewLocal != null)
			{
				visitor.visit(viewLocal);
			}
			for (EditPane editPane: view.getEditPanes())
			{
				BufferSet used = editPane.getBufferSet();
				if (used != global && used != viewLocal)
				{
					visitor.visit(used);
				}
			}
		}
	} 

	

	
	
	private Set<BufferSet> getOwners(Buffer buffer)
	{
		final Set<BufferSet> candidates = new HashSet<BufferSet>();
		
		visit(new BufferSetVisitor()
		{
			public void visit(BufferSet bufferSet)
			{
				candidates.add(bufferSet);
			}
		});
		
		Iterator<BufferSet> i = candidates.iterator();
		while (i.hasNext())
		{
			if (i.next().indexOf(buffer) == -1)
			{
				i.remove();
			}
		}
		
		return candidates;
	} 

	
	public static interface BufferSetVisitor
	{
		void visit(BufferSet bufferSet);
	} 

	
	private class BufferSetClosed extends BufferSetAdapter
	{
		
		private final BufferSet closedBufferSet;

		
		private BufferSetClosed(BufferSet closedBufferSet)
		{
			this.closedBufferSet = closedBufferSet;
		} 

		
		@Override
		public void bufferAdded(Buffer buffer, int index)
		{
			Set<BufferSet> owners = getOwners(buffer);
			owners.remove(closedBufferSet);
			if (owners.isEmpty())
			{
				Log.log(Log.MESSAGE, this, ""The buffer "" +
					buffer + "" was removed from a BufferSet, closing it"");
				jEdit._closeBuffer(null, buffer);
			}
		} 

	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.OverwriteWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,1,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.textarea.JEditTextArea;



public class OverwriteWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view)
	{
		Widget overwrite = new OverwriteWidget(view);
		return overwrite;
	} 

	
	private static class OverwriteWidget implements Widget
	{
		private final JLabel overwrite;
		private final View view;

		OverwriteWidget(final View view)
		{
			overwrite = new ToolTipLabel();
			overwrite.setHorizontalAlignment(SwingConstants.CENTER);
			overwrite.setToolTipText(jEdit.getProperty(""view.status.overwrite-tooltip""));
			this.view = view;
			overwrite.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent evt)
				{
					JEditTextArea textArea = view.getTextArea();
					if (textArea != null)
						textArea.toggleOverwriteEnabled();
				}
			});
		}

		
		public JComponent getComponent()
		{
			return overwrite;
		} 


		
		public void update()
		{
			JEditTextArea textArea = view.getTextArea();
			if (textArea != null)
				overwrite.setText(textArea.isOverwriteEnabled()
						  ? ""O"" : ""-"");
		} 


		
		public void propertiesChanged()
		{
			
			Font font = new JLabel().getFont();
			
			FontMetrics fm = overwrite.getFontMetrics(font);
			Dimension dim = new Dimension(
						      Math.max(fm.charWidth('-'),fm.charWidth('O')) + 1,
						      fm.getHeight());
			overwrite.setPreferredSize(dim);
			overwrite.setMaximumSize(dim);
		} 

	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.Token,5,1,1,14,12,6,13,1,4,1.166666667,169,0.0,2,0.0,0.35,0,0,27.4,2,0.8,0,"
package org.gjt.sp.jedit.syntax;

import java.lang.reflect.Field;


public class Token
{
	
	
	public static byte stringToToken(String value)
	{
		try
		{
			Field f = Token.class.getField(value);
			return f.getByte(null);
		}
		catch(Exception e)
		{
			return -1;
		}
	} 

	
	
	public static String tokenToString(byte token)
	{
		return (token == Token.END) ? ""END"" : TOKEN_TYPES[token];
	} 

	
	public static final String[] TOKEN_TYPES = new String[] {
		""NULL"",
		""COMMENT1"",
		""COMMENT2"",
		""COMMENT3"",
		""COMMENT4"",
		""DIGIT"",
		""FUNCTION"",
		""INVALID"",
		""KEYWORD1"",
		""KEYWORD2"",
		""KEYWORD3"",
		""KEYWORD4"",
		""LABEL"",
		""LITERAL1"",
		""LITERAL2"",
		""LITERAL3"",
		""LITERAL4"",
		""MARKUP"",
		""OPERATOR""
	};

	public static final byte NULL = 0;

	public static final byte COMMENT1 = 1;
	public static final byte COMMENT2 = 2;
	public static final byte COMMENT3 = 3;
	public static final byte COMMENT4 = 4;
	public static final byte DIGIT = 5;
	public static final byte FUNCTION = 6;
	public static final byte INVALID = 7;
	public static final byte KEYWORD1 = 8;
	public static final byte KEYWORD2 = 9;
	public static final byte KEYWORD3 = 10;
	public static final byte KEYWORD4 = 11;
	public static final byte LABEL = 12;
	public static final byte LITERAL1 = 13;
	public static final byte LITERAL2 = 14;
	public static final byte LITERAL3 = 15;
	public static final byte LITERAL4 = 16;
	public static final byte MARKUP = 17;
	public static final byte OPERATOR = 18;
	

	public static final byte ID_COUNT = 19;

	
	public static final byte END = 127;

	
	
	public byte id;

	
	public int offset;

	
	public int length;

	
	public ParserRuleSet rules;

	
	public Token next;
	

	
	
	public Token(byte id, int offset, int length, ParserRuleSet rules)
	{
		this.id = id;
		this.offset = offset;
		this.length = length;
		this.rules = rules;
	} 

	
	
	public String toString()
	{
		return ""[id="" + id + "",offset="" + offset + "",length="" + length + ""]"";
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TextAreaPainter,55,4,0,31,132,1121,23,15,52,0.969907407,956,0.15,6,0.924177396,0.121082621,3,20,15.65454545,9,1.5091,1,"

package org.gjt.sp.jedit.textarea;


import javax.swing.text.*;
import javax.swing.JComponent;
import java.awt.event.MouseEvent;
import java.awt.font.*;
import java.awt.geom.AffineTransform;
import java.awt.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.*;
import org.gjt.sp.jedit.buffer.IndentFoldHandler;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.syntax.Chunk;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.jedit.Debug;

import org.gjt.sp.util.Log;



public class TextAreaPainter extends JComponent implements TabExpander
{
	
	
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;

	
	public static final int BACKGROUND_LAYER = -60;

	
	public static final int LINE_BACKGROUND_LAYER = -50;

	
	public static final int BELOW_SELECTION_LAYER = -40;

	
	public static final int SELECTION_LAYER = -30;

	
	public static final int WRAP_GUIDE_LAYER = -20;

	
	public static final int BELOW_MOST_EXTENSIONS_LAYER = -10;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int BLOCK_CARET_LAYER = 50;

	
	public static final int BRACKET_HIGHLIGHT_LAYER = 100;

	
	public static final int TEXT_LAYER = 200;

	
	public static final int CARET_LAYER = 300;

	
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	

	
	
	@Override
	public void setBounds(int x, int y, int width, int height)
	{
		if(x == getX() && y == getY() && width == getWidth()
			&& height == getHeight())
		{
			return;
		}

		super.setBounds(x,y,width,height);

		textArea.recalculateVisibleLines();
		if(!textArea.getBuffer().isLoading())
			textArea.recalculateLastPhysicalLine();
		textArea.propertiesChanged();
		textArea.updateMaxHorizontalScrollWidth();
		textArea.scrollBarsInitialized = true;
	} 

	
	
	@Override
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	

	
	
	public final SyntaxStyle[] getStyles()
	{
		return styles;
	} 

	
	
	public final void setStyles(SyntaxStyle[] styles)
	{
		
		
		
		fonts.clear();

		this.styles = styles;
		styles[Token.NULL] = new SyntaxStyle(getForeground(),null,getFont());
		repaint();
	} 

	
	
	public final Color getCaretColor()
	{
		return caretColor;
	} 

	
	
	public final void setCaretColor(Color caretColor)
	{
		this.caretColor = caretColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final Color getSelectionColor()
	{
		return selectionColor;
	} 

	
	
	public final void setSelectionColor(Color selectionColor)
	{
		this.selectionColor = selectionColor;
		textArea.repaint();
	} 

	
	
	public final Color getMultipleSelectionColor()
	{
		return multipleSelectionColor;
	} 

	
	
	public final void setMultipleSelectionColor(Color multipleSelectionColor)
	{
		this.multipleSelectionColor = multipleSelectionColor;
		textArea.repaint();
	} 

	
	
	public final Color getLineHighlightColor()
	{
		return lineHighlightColor;
	} 

	
	
	public final void setLineHighlightColor(Color lineHighlightColor)
	{
		this.lineHighlightColor = lineHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final boolean isLineHighlightEnabled()
	{
		return lineHighlight;
	} 

	
	
	public final void setLineHighlightEnabled(boolean lineHighlight)
	{
		this.lineHighlight = lineHighlight;
		textArea.repaint();
	} 

	
	
	public final Color getStructureHighlightColor()
	{
		return structureHighlightColor;
	} 

	
	
	public final void setStructureHighlightColor(
		Color structureHighlightColor)
	{
		this.structureHighlightColor = structureHighlightColor;
		textArea.invalidateStructureMatch();
	} 

	
	
	public final boolean isStructureHighlightEnabled()
	{
		return structureHighlight;
	} 

	
	
	public final void setStructureHighlightEnabled(boolean structureHighlight)
	{
		this.structureHighlight = structureHighlight;
		textArea.invalidateStructureMatch();
	} 

	
	
	public final boolean isBlockCaretEnabled()
	{
		return blockCaret;
	} 

	
	
	public final void setBlockCaretEnabled(boolean blockCaret)
	{
		this.blockCaret = blockCaret;
		extensionMgr.removeExtension(caretExtension);
		if(blockCaret)
			addExtension(BLOCK_CARET_LAYER,caretExtension);
		else
			addExtension(CARET_LAYER,caretExtension);
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final boolean isThickCaretEnabled()
	{
		return thickCaret;
	} 

	
	
	public final void setThickCaretEnabled(boolean thickCaret)
	{
		this.thickCaret = thickCaret;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final Color getEOLMarkerColor()
	{
		return eolMarkerColor;
	} 

	
	
	public final void setEOLMarkerColor(Color eolMarkerColor)
	{
		this.eolMarkerColor = eolMarkerColor;
		repaint();
	} 

	
	
	public final boolean getEOLMarkersPainted()
	{
		return eolMarkers;
	} 

	
	
	public final void setEOLMarkersPainted(boolean eolMarkers)
	{
		this.eolMarkers = eolMarkers;
		repaint();
	} 

	
	
	public final Color getWrapGuideColor()
	{
		return wrapGuideColor;
	} 

	
	
	public final void setWrapGuideColor(Color wrapGuideColor)
	{
		this.wrapGuideColor = wrapGuideColor;
		repaint();
	} 

	
	
	public final boolean isWrapGuidePainted()
	{
		return wrapGuide;
	} 

	
	
	public final void setWrapGuidePainted(boolean wrapGuide)
	{
		this.wrapGuide = wrapGuide;
		repaint();
	} 

	
	
	public final SyntaxStyle[] getFoldLineStyle()
	{
		return foldLineStyle;
	} 

	
	
	public final void setFoldLineStyle(SyntaxStyle[] foldLineStyle)
	{
		this.foldLineStyle = foldLineStyle;
		repaint();
	} 

	
	
	@Deprecated
	public void setAntiAliasEnabled(boolean isEnabled)
	{
		setAntiAlias(new AntiAlias(isEnabled));
	}
	
	public void setAntiAlias(AntiAlias newValue)
	{
		antiAlias = newValue;
		updateRenderingHints();
	} 

	
	public AntiAlias getAntiAlias()
	{
		return antiAlias;
	}

	
	
	@Deprecated
	public boolean isAntiAliasEnabled()
	{
		return antiAlias.val() > 0;
	} 

	
	
	public void setFractionalFontMetricsEnabled(boolean fracFontMetrics)
	{
		this.fracFontMetrics = fracFontMetrics;
		updateRenderingHints();
	} 

	
	
	public boolean isFractionalFontMetricsEnabled()
	{
		return fracFontMetrics;
	} 

	
	
	public FontRenderContext getFontRenderContext()
	{
		return fontRenderContext;
	} 

	

	
	
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} 

	
	
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} 

	
	
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} 

	
	
	public TextAreaExtension[] getExtensions()
	{
		return extensionMgr.getExtensions();
	} 

	
	
	@Override
	public String getToolTipText(MouseEvent evt)
	{
		if(textArea.getBuffer().isLoading())
			return null;

		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} 

	
	
	public FontMetrics getFontMetrics()
	{
		return fm;
	} 

	
	
	@Override
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		textArea.recalculateVisibleLines();
		if(textArea.getBuffer() != null
			&& !textArea.getBuffer().isLoading())
			textArea.recalculateLastPhysicalLine();
		
	} 

	
	
	public float getStringWidth(String str)
	{
		if(textArea.charWidth != 0)
			return textArea.charWidth * str.length();
		else
		{
			return (float)getFont().getStringBounds(
				str,getFontRenderContext()).getWidth();
		}
	} 

	
	
	@Override
	public void update(Graphics _gfx)
	{
		paint(_gfx);
	} 

	
	
	@Override
	public void paint(Graphics _gfx)
	{
		assert _gfx instanceof Graphics2D;
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setRenderingHints(renderingHints);
		fontRenderContext = gfx.getFontRenderContext();

		Rectangle clipRect = gfx.getClipBounds();
		int lineHeight = fm.getHeight();
		if(lineHeight == 0 || textArea.getBuffer().isLoading())
		{
			gfx.setColor(getBackground());
			gfx.fillRect(clipRect.x,clipRect.y,clipRect.width,clipRect.height);
		}
		else
		{
			long prepareTime = System.nanoTime();
			
			
			
			int firstLine = clipRect.y / lineHeight;
			int lastLine = (clipRect.y + clipRect.height - 1) / lineHeight;
			gfx.setColor(getBackground());
			gfx.setFont(getFont());
			prepareTime = System.nanoTime() - prepareTime;

			long linesTime = System.nanoTime();
			int numLines = lastLine - firstLine + 1;
			int y = firstLine * lineHeight;
			gfx.fillRect(0,y,getWidth(),numLines * lineHeight);
			extensionMgr.paintScreenLineRange(textArea,gfx,
				firstLine,lastLine,y,lineHeight);
			linesTime = System.nanoTime() - linesTime;

			if(Debug.PAINT_TIMER && numLines >= 1)
				Log.log(Log.DEBUG,this,""repainting "" + numLines + "" lines took "" + prepareTime + ""/"" + linesTime + "" ns"");
		}

		textArea.updateMaxHorizontalScrollWidth();
	} 

	
	
	public float nextTabStop(float x, int tabOffset)
	{
		int ntabs = (int)(x / textArea.tabSize);
		return (ntabs + 1) * textArea.tabSize;
	} 

	
	
	@Override
	public Dimension getPreferredSize()
	{
		Dimension dim = new Dimension();

		char[] foo = new char[80];
		for(int i = 0; i < foo.length; i++)
			foo[i] = ' ';
		dim.width = (int)getStringWidth(new String(foo));
		dim.height = fm.getHeight() * 25;
		return dim;
	} 

	
	
	@Override
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} 

	

	
	
	TextArea textArea;

	SyntaxStyle[] styles;
	Color caretColor;
	Color selectionColor;
	Color multipleSelectionColor;
	Color lineHighlightColor;
	Color structureHighlightColor;
	Color eolMarkerColor;
	Color wrapGuideColor;

	SyntaxStyle[] foldLineStyle;

	boolean blockCaret;
	boolean thickCaret;
	boolean lineHighlight;
	boolean structureHighlight;
	boolean eolMarkers;
	boolean wrapGuide;
	AntiAlias antiAlias;
	boolean fracFontMetrics;
	RenderingHints renderingHints;
	
	FontMetrics fm;
	

	
	
	TextAreaPainter(TextArea textArea)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK
			| AWTEvent.KEY_EVENT_MASK
			| AWTEvent.MOUSE_EVENT_MASK);

		this.textArea = textArea;
		antiAlias = new AntiAlias(0);
		fonts = new HashMap();
		extensionMgr = new ExtensionManager();

		setAutoscrolls(true);
		setOpaque(true);
		setRequestFocusEnabled(false);
		setDoubleBuffered(false);

		setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));

		fontRenderContext = new FontRenderContext(null,false,false);

		addExtension(LINE_BACKGROUND_LAYER,new PaintLineBackground());
		addExtension(SELECTION_LAYER,new PaintSelection());
		addExtension(WRAP_GUIDE_LAYER,new PaintWrapGuide());
		addExtension(BRACKET_HIGHLIGHT_LAYER,new StructureMatcher
			.Highlight(textArea));
		addExtension(TEXT_LAYER,new PaintText());
		caretExtension = new PaintCaret();
	} 

	

	

	
	private final ExtensionManager extensionMgr;
	private final PaintCaret caretExtension;
	private FontRenderContext fontRenderContext;
	private final Map fonts;
	

	private static Object sm_hrgbRender;
	private static Constructor<FontRenderContext> sm_frcConstructor;

	static
	{
		try
		{
			Field f = RenderingHints.class.getField(""VALUE_TEXT_ANTIALIAS_LCD_HRGB"");
			sm_hrgbRender = f.get(null);
			Class[] fracFontMetricsTypeList = {AffineTransform.class, Object.class, Object.class};
			sm_frcConstructor = FontRenderContext.class.getConstructor(fracFontMetricsTypeList);
		}
		catch (NullPointerException npe) {}
		catch (SecurityException se) {}
		catch (NoSuchFieldException nsfe) {}
		catch (IllegalArgumentException iae) {}
		catch (IllegalAccessException iae) {}
		catch (NoSuchMethodException nsme) {}
	}
	
	private void updateRenderingHints()
	{
		Map<RenderingHints.Key,Object> hints = new HashMap<RenderingHints.Key,Object>();

		hints.put(RenderingHints.KEY_FRACTIONALMETRICS,
			fracFontMetrics ? RenderingHints.VALUE_FRACTIONALMETRICS_ON
				: RenderingHints.VALUE_FRACTIONALMETRICS_OFF);

		if (antiAlias.val() == 0)
		{
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
			fontRenderContext = new FontRenderContext(null, antiAlias.val() > 0, fracFontMetrics);
		}
		
		else if (antiAlias.val() == 2 && sm_hrgbRender != null )
		{
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, sm_hrgbRender);
			Object fontRenderHint = fracFontMetrics ?
				RenderingHints.VALUE_FRACTIONALMETRICS_ON :
				RenderingHints.VALUE_FRACTIONALMETRICS_OFF;
			Object[] paramList = {null, sm_hrgbRender, fontRenderHint};
			try
			{
				fontRenderContext = sm_frcConstructor.newInstance(paramList);
			}
			catch (Exception e)
			{
				fontRenderContext = new FontRenderContext(null, antiAlias.val() > 0, fracFontMetrics);
			}
		}
		else 
		{
			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
			fontRenderContext = new FontRenderContext(null, antiAlias.val() > 0, fracFontMetrics);
		}

		renderingHints = new RenderingHints(hints);


	} 

	

	

	
	private class PaintLineBackground extends TextAreaExtension
	{
		
		private boolean shouldPaintLineHighlight(int caret, int start, int end)
		{
			if(!isLineHighlightEnabled()
				|| caret < start || caret >= end)
			{
				return false;
			}

			int count = textArea.getSelectionCount();
			if(count == 1)
			{
				Selection s = textArea.getSelection(0);
				return s.getStartLine() == s.getEndLine();
			}
			else
				return count == 0;
		} 

		
		@Override
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			
			TextArea textArea = TextAreaPainter.this.textArea;
			JEditBuffer buffer = textArea.getBuffer();

			
			boolean collapsedFold =
				physicalLine < buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine)
				&& !textArea.displayManager
				.isLineVisible(physicalLine + 1);

			SyntaxStyle foldLineStyle = null;
			if(collapsedFold)
			{
				int level = buffer.getFoldLevel(physicalLine + 1);
				if(buffer.getFoldHandler() instanceof IndentFoldHandler)
					level = Math.max(1,level / buffer.getIndentSize());
				if(level > 3)
					level = 0;
				foldLineStyle = TextAreaPainter.this.foldLineStyle[level];
			}

			int caret = textArea.getCaretPosition();
			boolean paintLineHighlight = shouldPaintLineHighlight(
				caret,start,end);

			Color bgColor;
			if(paintLineHighlight)
				bgColor = lineHighlightColor;
			else if(collapsedFold)
			{
				bgColor = foldLineStyle.getBackgroundColor();
				if(bgColor == null)
					bgColor = getBackground();
			}
			else
				bgColor = getBackground();

			if(paintLineHighlight || collapsedFold)
			{
				gfx.setColor(bgColor);
				gfx.fillRect(0,y,getWidth(),fm.getHeight());
			} 

			
			ChunkCache.LineInfo lineInfo = textArea.chunkCache
				.getLineInfo(screenLine);

			if(lineInfo.chunks != null)
			{
				float baseLine = y + fm.getHeight()
					- (fm.getLeading()+1) - fm.getDescent();
				Chunk.paintChunkBackgrounds(
					lineInfo.chunks,gfx,
					textArea.getHorizontalOffset(),
					baseLine);
			} 
		} 
	} 

	
	private class PaintSelection extends TextAreaExtension
	{
		
		@Override
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(textArea.getSelectionCount() == 0)
				return;

			gfx.setColor(textArea.isMultipleSelectionEnabled()
				? getMultipleSelectionColor()
				: getSelectionColor());

			Iterator<Selection> iter = textArea.getSelectionIterator();
			while(iter.hasNext())
			{
				Selection s = iter.next();
				paintSelection(gfx,screenLine,physicalLine,y,s);
			}
		} 

		
		private void paintSelection(Graphics2D gfx, int screenLine,
			int physicalLine, int y, Selection s)
		{
			int[] selectionStartAndEnd
				= textArea.selectionManager
				.getSelectionStartAndEnd(
				screenLine,physicalLine,s);
			if(selectionStartAndEnd == null)
				return;

			int x1 = selectionStartAndEnd[0];
			int x2 = selectionStartAndEnd[1];

			gfx.fillRect(x1,y,x2 - x1,fm.getHeight());
		} 
	} 

	
	private class PaintWrapGuide extends TextAreaExtension
	{
		@Override
		public void paintScreenLineRange(Graphics2D gfx, int firstLine,
			int lastLine, int[] physicalLines, int[] start,
			int[] end, int y, int lineHeight)
		{
			if(textArea.wrapMargin != 0
				&& !textArea.wrapToWidth
				&& isWrapGuidePainted())
			{
				gfx.setColor(getWrapGuideColor());
				int x = textArea.getHorizontalOffset()
					+ textArea.wrapMargin;
				gfx.drawLine(x,y,x,y + (lastLine - firstLine
					+ 1) * lineHeight);
			}
		}

		@Override
		public String getToolTipText(int x, int y)
		{
			if(textArea.wrapMargin != 0
				&& !textArea.wrapToWidth
				&& isWrapGuidePainted())
			{
				int wrapGuidePos = textArea.wrapMargin
					+ textArea.getHorizontalOffset();
				if(Math.abs(x - wrapGuidePos) < 5)
				{
					return String.valueOf(textArea.getBuffer()
						.getProperty(""maxLineLen""));
				}
			}

			return null;
		}
	} 

	
	private class PaintText extends TextAreaExtension
	{
		@Override
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			ChunkCache.LineInfo lineInfo = textArea.chunkCache
				.getLineInfo(screenLine);

			Font defaultFont = getFont();
			Color defaultColor = getForeground();

			gfx.setFont(defaultFont);
			gfx.setColor(defaultColor);

			int x = textArea.getHorizontalOffset();
			int originalX = x;

			float baseLine = y + fm.getHeight()
				- (fm.getLeading()+1) - fm.getDescent();

			if(lineInfo.chunks != null)
			{
				x += Chunk.paintChunkList(lineInfo.chunks,
					gfx,textArea.getHorizontalOffset(),
					baseLine,!Debug.DISABLE_GLYPH_VECTOR);
			}

			JEditBuffer buffer = textArea.getBuffer();

			if(!lineInfo.lastSubregion)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString("":"",Math.max(x,
					textArea.getHorizontalOffset()
					+ textArea.wrapMargin + textArea.charWidth),
					baseLine);
				x += textArea.charWidth;
			}
			else if(physicalLine < buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine)
				&& !textArea.displayManager
				.isLineVisible(physicalLine + 1))
			{
				int level = buffer.getFoldLevel(physicalLine + 1);
				if(buffer.getFoldHandler() instanceof IndentFoldHandler)
					level = Math.max(1,level / buffer.getIndentSize());
				if(level > 3)
					level = 0;
				SyntaxStyle foldLineStyle = TextAreaPainter.this.foldLineStyle[level];

				Font font = foldLineStyle.getFont();
				gfx.setFont(font);
				gfx.setColor(foldLineStyle.getForegroundColor());

				int nextLine;
				int nextScreenLine = screenLine + 1;
				if(nextScreenLine < textArea.getVisibleLines())
				{
					nextLine = textArea.chunkCache.getLineInfo(nextScreenLine)
						.physicalLine;
				}
				else
				{
					nextLine = textArea.displayManager
						.getNextVisibleLine(physicalLine);
				}

				if(nextLine == -1)
					nextLine = textArea.getLineCount();

				int count = nextLine - physicalLine - 1;
				String str = "" ["" + count + "" lines]"";

				float width = getStringWidth(str);

				gfx.drawString(str,x,baseLine);
				x += width;
			}
			else if(eolMarkers)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString(""."",x,baseLine);
				x += textArea.charWidth;
			}

			lineInfo.width = x - originalX;
		}
	} 

	
	private class PaintCaret extends TextAreaExtension
	{
		@Override
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(!textArea.isCaretVisible())
				return;

			int caret = textArea.getCaretPosition();
			if(caret < start || caret >= end)
				return;

			int offset = caret - textArea.getLineStartOffset(physicalLine);
			textArea.offsetToXY(physicalLine,
					    offset, textArea.offsetXY);
			int caretX = textArea.offsetXY.x;
			int lineHeight = fm.getHeight();

			gfx.setColor(caretColor);

			if(textArea.isOverwriteEnabled())
			{
				gfx.drawLine(caretX,y + lineHeight - 1,
					     caretX + textArea.charWidth,
					     y + lineHeight - 1);
			}
			else if(blockCaret)
				gfx.drawRect(caretX,y,textArea.charWidth - 1,
					     lineHeight - 1);
			else
			{
				if (thickCaret)
					gfx.drawRect(caretX, y,
						1, lineHeight - 1);
				else
					gfx.drawLine(caretX,y,
						caretX,y + lineHeight - 1);
			}
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.util.StandardUtilities,20,1,0,47,45,190,47,0,19,2.0,841,0.0,0,0.0,0.1875,0,0,41.05,23,5.75,0,"

package org.gjt.sp.util;



import javax.swing.text.Segment;
import java.util.Comparator;
import java.util.Stack;



public class StandardUtilities
{

	

	
	
	public static String charsToEscapes(String str)
	{
		return charsToEscapes(str,""\n\t\\\""'"");
	} 

	
	
	public static String charsToEscapes(String str, String toEscape)
	{
		StringBuilder buf = new StringBuilder();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			if(toEscape.indexOf(c) != -1)
			{
				if(c == '\n')
					buf.append(""\\n"");
				else if(c == '\t')
					buf.append(""\\t"");
				else
				{
					buf.append('\\');
					buf.append(c);
				}
			}
			else
				buf.append(c);
		}
		return buf.toString();
	} 

	
	
	public static String getIndentString(String str)
	{
		StringBuilder indentString = new StringBuilder();
		for (int i = 0; i < str.length(); i++)
		{
			char ch = str.charAt(i);
			if (! Character.isWhitespace(ch))
				break;
			indentString.append(ch);
		}
		return indentString.toString();

	} 

	
	
	public static int getLeadingWhiteSpace(String str)
	{
		return getLeadingWhiteSpace((CharSequence)str);
	} 

	
	
	public static int getLeadingWhiteSpace(CharSequence str)
	{
		int whitespace = 0;
loop:		for(;whitespace < str.length();)
		{
			switch(str.charAt(whitespace))
			{
			case ' ':
			case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getTrailingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(int i = str.length() - 1; i >= 0; i--)
		{
			switch(str.charAt(i))
			{
				case ' ':
				case '\t':
					whitespace++;
					break;
				default:
					break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getLeadingWhiteSpaceWidth(String str, int tabSize)
	{
		return getLeadingWhiteSpaceWidth((CharSequence)str, tabSize);
	} 

	
	
	public static int getLeadingWhiteSpaceWidth(CharSequence str, int tabSize)
	{
		int whitespace = 0;
loop:		for(int i = 0; i < str.length(); i++)
		{
			switch(str.charAt(i))
			{
				case ' ':
					whitespace++;
					break;
				case '\t':
					whitespace += tabSize -
						whitespace % tabSize;
					break;
				default:
					break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static String createWhiteSpace(int len, int tabSize)
	{
		return createWhiteSpace(len,tabSize,0);
	} 

	
	public static String truncateWhiteSpace(int len, int tabSize,
		String indentStr)
	{
		StringBuilder buf = new StringBuilder();
		int indent = 0;
		for (int i = 0; indent < len && i < indentStr.length(); i++)
		{
			char c = indentStr.charAt(i);
			if (c == ' ')
			{
				indent++;
				buf.append(c);
			}
			else if (c == '\t')
			{
				int withTab = indent + tabSize - (indent % tabSize);
				if (withTab > len)
				{
					for (; indent < len; indent++)
						buf.append(' ');
				}
				else
				{
					indent = withTab;
					buf.append(c);
				}
			}
		}
		return buf.toString();
	} 
	
	
	
	public static String createWhiteSpace(int len, int tabSize, int start)
	{
		StringBuilder buf = new StringBuilder();
		if(tabSize == 0)
		{
			while(len-- > 0)
				buf.append(' ');
		}
		else if(len == 1)
			buf.append(' ');
		else
		{
			int count = (len + start % tabSize) / tabSize;
			if(count != 0)
				len += start;
			while(count-- > 0)
				buf.append('\t');
			count = len % tabSize;
			while(count-- > 0)
				buf.append(' ');
		}
		return buf.toString();
	} 

	
	
	public static int getVirtualWidth(Segment seg, int tabSize)
	{
		int virtualPosition = 0;

		for (int i = 0; i < seg.count; i++)
		{
			char ch = seg.array[seg.offset + i];

			if (ch == '\t')
			{
				virtualPosition += tabSize
					- virtualPosition % tabSize;
			}
			else
			{
				++virtualPosition;
			}
		}

		return virtualPosition;
	} 

	
	
	public static int getOffsetOfVirtualColumn(Segment seg, int tabSize,
					    int column, int[] totalVirtualWidth)
	{
		int virtualPosition = 0;

		for (int i = 0; i < seg.count; i++)
		{
			char ch = seg.array[seg.offset + i];

			if (ch == '\t')
			{
				int tabWidth = tabSize
					- virtualPosition % tabSize;
				if(virtualPosition >= column)
					return i;
				else
					virtualPosition += tabWidth;
			}
			else
			{
				if(virtualPosition >= column)
					return i;
				else
					++virtualPosition;
			}
		}

		if(totalVirtualWidth != null)
			totalVirtualWidth[0] = virtualPosition;
		return -1;
	} 

	
	
	public static int compareStrings(String str1, String str2, boolean ignoreCase)
	{
		char[] char1 = str1.toCharArray();
		char[] char2 = str2.toCharArray();

		int len = Math.min(char1.length,char2.length);

		for(int i = 0, j = 0; i < len && j < len; i++, j++)
		{
			char ch1 = char1[i];
			char ch2 = char2[j];
			if(Character.isDigit(ch1) && Character.isDigit(ch2)
				&& ch1 != '0' && ch2 != '0')
			{
				int _i = i + 1;
				int _j = j + 1;

				for(; _i < char1.length; _i++)
				{
					if(!Character.isDigit(char1[_i]))
					{
						
						break;
					}
				}

				for(; _j < char2.length; _j++)
				{
					if(!Character.isDigit(char2[_j]))
					{
						
						break;
					}
				}

				int len1 = _i - i;
				int len2 = _j - j;
				if(len1 > len2)
					return 1;
				else if(len1 < len2)
					return -1;
				else
				{
					for(int k = 0; k < len1; k++)
					{
						ch1 = char1[i + k];
						ch2 = char2[j + k];
						if(ch1 != ch2)
							return ch1 - ch2;
					}
				}

				i = _i - 1;
				j = _j - 1;
			}
			else
			{
				if(ignoreCase)
				{
					ch1 = Character.toLowerCase(ch1);
					ch2 = Character.toLowerCase(ch2);
				}

				if(ch1 != ch2)
					return ch1 - ch2;
			}
		}

		return char1.length - char2.length;
	} 

	
	
	public static class StringCompare<E> implements Comparator<E>
	{
		private boolean icase;

		public StringCompare(boolean icase)
		{
			this.icase = icase;
		}

		public StringCompare()
		{
		}

		public int compare(E obj1, E obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),icase);
		}
	} 

	
	
	public static boolean objectsEqual(Object o1, Object o2)
	{
		if(o1 == null)
		{
			if(o2 == null)
				return true;
			else
				return false;
		}
		else if(o2 == null)
			return false;
		else
			return o1.equals(o2);
	} 

	
	
	public static String globToRE(String glob)
	{
		if (glob.startsWith(""(re)""))
		{
			return glob.substring(4);
		}

		final Object NEG = new Object();
		final Object GROUP = new Object();
		Stack<Object> state = new Stack<Object>();

		StringBuilder buf = new StringBuilder();
		boolean backslash = false;

		for(int i = 0; i < glob.length(); i++)
		{
			char c = glob.charAt(i);
			if(backslash)
			{
				buf.append('\\');
				buf.append(c);
				backslash = false;
				continue;
			}

			switch(c)
			{
			case '\\':
				backslash = true;
				break;
			case '?':
				buf.append('.');
				break;
			case '.':
			case '+':
			case '(':
			case ')':
				buf.append('\\');
				buf.append(c);
				break;
			case '*':
				buf.append("".*"");
				break;
			case '|':
				if(backslash)
					buf.append(""\\|"");
				else
					buf.append('|');
				break;
			case '{':
				buf.append('(');
				if(i + 1 != glob.length() && glob.charAt(i + 1) == '!')
				{
					buf.append('?');
					state.push(NEG);
				}
				else
					state.push(GROUP);
				break;
			case ',':
				if(!state.isEmpty() && state.peek() == GROUP)
					buf.append('|');
				else
					buf.append(',');
				break;
			case '}':
				if(!state.isEmpty())
				{
					buf.append(')');
					if(state.pop() == NEG)
						buf.append("".*"");
				}
				else
					buf.append('}');
				break;
			default:
				buf.append(c);
			}
		}

		return buf.toString();
	} 

	
	
	public static boolean regionMatches(CharSequence seq,
					    int toff,
					    CharSequence other,
					    int ooff,
					    int len)
	{

		if (toff < 0 || ooff < 0 || len < 0)
			return false;

		boolean ret = true;
		for (int i = 0; i < len; i++)
		{
			char c1;

			if (i + toff < seq.length())
				c1 = seq.charAt(i + toff);
			else
			{
				ret = false;
				break;
			}

			char c2;
			if (i + ooff < other.length())
				c2 = other.charAt(i + ooff);
			else
			{
				ret = false;
				break;
			}

			if (c1 != c2)
			{
				ret = false;
				break;
			}
		}

		return ret;
	} 

	
	
	public static boolean startsWith(CharSequence seq, String str)
	{
		boolean ret = true;
		for (int i = 0; i < str.length(); i++)
		{
			if (i >= seq.length() ||
			    seq.charAt(i) != str.charAt(i))
			{
				ret = false;
				break;
			}
		}
		return ret;
	} 

	
	
	public static boolean getBoolean(Object obj, boolean def)
	{
		if(obj == null)
			return def;
		else if(obj instanceof Boolean)
			return ((Boolean)obj).booleanValue();
		else if(""true"".equals(obj) || ""yes"".equals(obj)
			|| ""on"".equals(obj))
			return true;
		else if(""false"".equals(obj) || ""no"".equals(obj)
			|| ""off"".equals(obj))
			return false;

		return def;
	} 

	
	private StandardUtilities(){}
}
"
jEdit,4.3,org.gjt.sp.jedit.options.BrowserColorsOptionPane,13,6,0,9,56,44,3,9,1,0.763888889,316,1.0,1,0.982378855,0.384615385,4,12,22.84615385,5,1.2308,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import java.util.List;

import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.*;




public class BrowserColorsOptionPane extends AbstractOptionPane
{
	
	public BrowserColorsOptionPane()
	{
		super(""browser.colors"");
	} 

	

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		colorsModel = new BrowserColorsModel();
		colorsTable = new JTable(colorsModel);
		colorsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		colorsTable.getTableHeader().setReorderingAllowed(false);
		colorsTable.addMouseListener(new MouseHandler());
		colorsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		TableColumnModel tcm = colorsTable.getColumnModel();
		tcm.getColumn(1).setCellRenderer(new BrowserColorsModel.ColorRenderer());
		Dimension d = colorsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(colorsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);

		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""common.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""common.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""common.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""common.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());

		add(BorderLayout.SOUTH,buttons);

		updateEnabled();
	} 

	
	protected void _save()
	{
		colorsModel.save();
	} 

	

	
	private BrowserColorsModel colorsModel;
	private JTable colorsTable;
	private JButton add;
	private JButton remove;
	private JButton moveUp;
	private JButton moveDown;

	
	private void updateEnabled()
	{
		int selectedRow = colorsTable.getSelectedRow();
		remove.setEnabled(selectedRow != -1);
		moveUp.setEnabled(selectedRow > 0);
		moveUp.setEnabled(selectedRow != -1 && selectedRow !=
			colorsModel.getRowCount());
	} 

	
	private void setSelectedRow(int row)
	{
		colorsTable.getSelectionModel().setSelectionInterval(row,row);
		colorsTable.scrollRectToVisible(colorsTable.getCellRect(row,0,true));
	} 

	

	
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				colorsModel.add();
			}
			else if(source == remove)
			{
				int selectedRow = colorsTable.getSelectedRow();
				colorsModel.remove(selectedRow);
				updateEnabled();
			}
			else if(source == moveUp)
			{
				int selectedRow = colorsTable.getSelectedRow();
				if(selectedRow != 0)
				{
					colorsModel.moveUp(selectedRow);
					setSelectedRow(selectedRow - 1);
				}
				updateEnabled();
			}
			else if(source == moveDown)
			{
				int selectedRow = colorsTable.getSelectedRow();
				if(selectedRow != colorsTable.getRowCount() - 1)
				{
					colorsModel.moveDown(selectedRow);
					setSelectedRow(selectedRow + 1);
				}
				updateEnabled();
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Point p = evt.getPoint();
			int row = colorsTable.rowAtPoint(p);
			int column = colorsTable.columnAtPoint(p);
			if(row == -1 || column != 1)
				return;

			Color color = JColorChooser.showDialog(
				BrowserColorsOptionPane.this,
				jEdit.getProperty(""colorChooser.title""),
				(Color)colorsModel.getValueAt(row,1));
			if(color != null)
				colorsModel.setValueAt(color,row,1);
		}
	} 
} 


class BrowserColorsModel extends AbstractTableModel
{
	
	BrowserColorsModel()
	{
		entries = new ArrayList<Entry>();

		int i = 0;
		String glob;
		while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
		{
			entries.add(new Entry(glob,
				jEdit.getColorProperty(
				""vfs.browser.colors."" + i + "".color"",
				Color.black)));
			i++;
		}
	} 

	
	void add()
	{
		entries.add(new Entry("""",UIManager.getColor(""Tree.foreground"")));
		fireTableRowsInserted(entries.size() - 1,entries.size() - 1);
	} 

	
	void remove(int index)
	{
		entries.remove(index);
		fireTableRowsDeleted(entries.size(),entries.size());
	} 

	
	public void moveUp(int index)
	{
		Entry entry = entries.get(index);
		entries.remove(index);
		entries.add(index - 1,entry);
		fireTableRowsUpdated(index - 1,index);
	} 

	
	public void moveDown(int index)
	{
		Entry entry = entries.get(index);
		entries.remove(index);
		entries.add(index + 1,entry);
		fireTableRowsUpdated(index,index + 1);
	} 

	
	void save()
	{
		int i;
		for(i = 0; i < entries.size(); i++)
		{
			Entry entry = entries.get(i);
			jEdit.setProperty(""vfs.browser.colors."" + i + "".glob"",
				entry.glob);
			jEdit.setColorProperty(""vfs.browser.colors."" + i + "".color"",
				entry.color);
		}
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".glob"");
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".color"");
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return entries.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		Entry entry = entries.get(row);

		switch(col)
		{
		case 0:
			return entry.glob;
		case 1:
			return entry.color;
		default:
			return null;
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return col == 0;
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		Entry entry = entries.get(row);

		if(col == 0)
			entry.glob = (String)value;
		else
			entry.color = (Color)value;

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.browser.colors.glob"");
		case 1:
			return jEdit.getProperty(""options.browser.colors.color"");
		default:
			return null;
		}
	} 

	
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return String.class;
		case 1:
			return Color.class;
		default:
			throw new InternalError();
		}
	} 

	private List<Entry> entries;

	
	private static class Entry
	{
		String glob;
		Color color;

		Entry(String glob, Color color)
		{
			this.glob = glob;
			this.color = color;
		}
	} 

	
	static class ColorRenderer extends JLabel
		implements TableCellRenderer
	{
		
		ColorRenderer()
		{
			setOpaque(true);
			setBorder(SyntaxHiliteOptionPane.noFocusBorder);
		} 

		
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (isSelected)
			{
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			}
			else
			{
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}

			if (value != null)
				setBackground((Color)value);

			setBorder(cellHasFocus ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: SyntaxHiliteOptionPane.noFocusBorder);
			return this;
		} 
	} 
} 
"
jEdit,4.3,org.gjt.sp.jedit.EditBus,11,1,0,48,37,23,41,8,6,0.55,187,0.5,1,0.0,0.18,0,0,15.81818182,7,1.3636,0,"

package org.gjt.sp.jedit;

import java.lang.annotation.*;
import java.lang.reflect.Method;
import java.util.*;
import org.gjt.sp.util.Log;


public class EditBus
{

	
	
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.METHOD)
	public static @interface EBHandler
	{
		
		boolean exact() default false;
	} 

	
	
	public static void addToBus(EBComponent comp)
	{
		addToBus((Object)comp);
	} 

	
	
	public static void addToBus(Object comp)
	{
		components.addComponent(comp);
	} 

	
	
	public static void removeFromBus(EBComponent comp)
	{
		removeFromBus((Object) comp);
	} 

	
	
	public static void removeFromBus(Object comp)
	{
		components.removeComponent(comp);
	} 

	
	
	@Deprecated
	public static EBComponent[] getComponents()
	{
		return new EBComponent[0];
	} 

	
	
	public static void send(EBMessage message)
	{
		Log.log(Log.DEBUG,EditBus.class,message.toString());

		components.lock();
		try
		{
			sendImpl(message);
		}
		finally
		{
			components.unlock();
		}
	} 

	
	private static final HandlerList components = new HandlerList();

	
	private EditBus() {}

	
	private static void dispatch(EBMessageHandler emh,
				     EBMessage msg)
		throws Exception
	{
		if (emh.handler != null)
			emh.handler.invoke(emh.comp, msg);
		else
		{
			assert (emh.comp instanceof EBComponent);
			((EBComponent)emh.comp).handleMessage(msg);
		}
	} 

	
	private static void sendImpl(EBMessage message)
	{
		boolean isExact = true;
		Class<?> type = message.getClass();
		while (!type.equals(Object.class))
		{
			List<EBMessageHandler> handlers = components.get(type);
			if (handlers != null)
			{
				try
				{
					for (EBMessageHandler emh : handlers)
					{
						if (!isExact &&
						    emh.source != null &&
						    emh.source.exact())
						{
							continue;
						}
						if(Debug.EB_TIMER)
						{
							long start = System.nanoTime();
							dispatch(emh, message);
							long time = System.nanoTime() - start;
							if(time >= 1000000)
							{
								Log.log(Log.DEBUG,EditBus.class,emh.comp + "": "" + time + "" ns"");
							}
						}
						else
							dispatch(emh, message);
					}
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,EditBus.class,""Exception""
						+ "" while sending message on EditBus:"");
					Log.log(Log.ERROR,EditBus.class,t);
				}
			}
			type = type.getSuperclass();
			isExact = false;
		}
	} 

	

	
	private static class EBMessageHandler
	{

		EBMessageHandler(Object comp,
				 Method handler,
				 EBHandler source)
		{
			this.comp = comp;
			this.handler = handler;
			this.source = source;
		}

		Object comp;
		Method handler;
		EBHandler source;
	} 

	
	
	private static class HandlerList
		extends HashMap<Class<?>, List<EBMessageHandler>>
	{

		public List<EBMessageHandler> safeGet(Class<?> type)
		{
			List<EBMessageHandler> lst = super.get(type);
			if (lst == null) {
				lst = new LinkedList<EBMessageHandler>();
				super.put(type, lst);
			}
			return lst;
		}


		public synchronized void lock()
		{
			lock++;
		}


		public synchronized void unlock()
		{
			lock--;
			if (lock == 0)
			{
				for (Object comp : add)
					addComponent(comp);
				for (Object comp : remove)
					removeComponent(comp);
				add.clear();
				remove.clear();
			}
		}


		public synchronized void removeComponent(Object comp)
		{
			if (lock != 0)
			{
				remove.add(comp);
				return;
			}

			for (Class<?> msg : keySet())
			{
				List<EBMessageHandler> handlers = get(msg);
				if (handlers == null)
					continue;
				for (Iterator<EBMessageHandler> it = handlers.iterator();
				     it.hasNext(); )
				{
					EBMessageHandler emh = it.next();
					if (emh.comp == comp)
						it.remove();
				}
			}
		}


		public synchronized void addComponent(Object comp)
		{
			if (lock != 0)
			{
				add.add(comp);
				return;
			}

			for (Method m : comp.getClass().getMethods())
			{
				EBHandler source = m.getAnnotation(EBHandler.class);
				if (source == null)
					continue;

				Class[] params = m.getParameterTypes();

				if (params.length != 1)
				{
					Log.log(Log.ERROR, EditBus.class,
						""Invalid EBHandler method "" + m.getName() +
						"" in class "" + comp.getClass().getName() +
						"": too many parameters."");
					continue;
				}

				if (!EBMessage.class.isAssignableFrom(params[0]))
				{
					Log.log(Log.ERROR, EditBus.class,
						""Invalid parameter "" + params[0].getName() +
						"" in method "" + m.getName() +
						"" of class "" + comp.getClass().getName());
					continue;
				}

				synchronized (components)
				{
					safeGet(params[0]).add(new EBMessageHandler(comp, m, source));
				}
			}

			
			if (comp instanceof EBComponent)
				safeGet(EBMessage.class).add(new EBMessageHandler(comp, null, null));
		}


		private int lock;
		private List<Object> add = new LinkedList<Object>();
		private List<Object> remove = new LinkedList<Object>();
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.msg.EditorExiting,1,2,0,3,2,0,1,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class EditorExiting extends EBMessage
{
	
	public EditorExiting(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.3,org.gjt.sp.util.SyntaxUtilities,7,1,0,11,31,21,7,4,6,0.833333333,300,0.0,1,0.0,0.457142857,0,0,41.71428571,17,3.2857,0,"

package org.gjt.sp.util;



import java.awt.Color;
import java.awt.Font;
import java.util.Locale;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.jedit.IPropertyManager;



public class SyntaxUtilities
{
	public static IPropertyManager propertyManager;
	
	
	
	
	public static String getColorHexString(Color c)
	{
		String colString = Integer.toHexString(c.getRGB() & 0xffffff);
		return ""#000000"".substring(0,7 - colString.length()).concat(colString);
	} 
	
	
	
	public static Color parseColor(String name, Color defaultColor)
	{
		if(name == null || name.length() == 0)
			return defaultColor;
		else if(name.charAt(0) == '#')
		{
			try
			{
				return Color.decode(name);
			}
			catch(NumberFormatException nf)
			{
				return defaultColor;
			}
		}
		else if(""red"".equals(name))
			return Color.red;
		else if(""green"".equals(name))
			return Color.green;
		else if(""blue"".equals(name))
			return Color.blue;
		else if(""yellow"".equals(name))
			return Color.yellow;
		else if(""orange"".equals(name))
			return Color.orange;
		else if(""white"".equals(name))
			return Color.white;
		else if(""lightGray"".equals(name))
			return Color.lightGray;
		else if(""gray"".equals(name))
			return Color.gray;
		else if(""darkGray"".equals(name))
			return Color.darkGray;
		else if(""black"".equals(name))
			return Color.black;
		else if(""cyan"".equals(name))
			return Color.cyan;
		else if(""magenta"".equals(name))
			return Color.magenta;
		else if(""pink"".equals(name))
			return Color.pink;
		else
			return defaultColor;
	} 
	
	
	
	public static SyntaxStyle parseStyle(String str, String family, int size,
		boolean color, Color defaultFgColor)
		throws IllegalArgumentException
	{
		Color fgColor = defaultFgColor;
		Color bgColor = null;
		boolean italic = false;
		boolean bold = false;
		StringTokenizer st = new StringTokenizer(str);
		while(st.hasMoreTokens())
		{
			String s = st.nextToken();
			if(s.startsWith(""color:""))
			{
				if(color)
					fgColor = parseColor(s.substring(6), Color.black);
			}
			else if(s.startsWith(""bgColor:""))
			{
				if(color)
					bgColor = parseColor(s.substring(8), null);
			}
			else if(s.startsWith(""style:""))
			{
				for(int i = 6; i < s.length(); i++)
				{
					if(s.charAt(i) == 'i')
						italic = true;
					else if(s.charAt(i) == 'b')
						bold = true;
					else
						throw new IllegalArgumentException(
								""Invalid style: "" + s);
				}
			}
			else
				throw new IllegalArgumentException(
						""Invalid directive: "" + s);
		}
		return new SyntaxStyle(fgColor,bgColor,
				new Font(family,
						(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0),
						size));
	} 
		
	
	
	public static SyntaxStyle parseStyle(String str, String family, int size,
		boolean color)
		throws IllegalArgumentException
	{
		return parseStyle(str, family, size, color, Color.black);
	} 
	
	
	
	public static SyntaxStyle[] loadStyles(String family, int size)
	{
		return loadStyles(family,size,true);
	}
	
	
	public static SyntaxStyle[] loadStyles(String family, int size, boolean color)
	{
		SyntaxStyle[] styles = new SyntaxStyle[Token.ID_COUNT];

		
		for(int i = 1; i < styles.length; i++)
		{
			try
			{
				String styleName = ""view.style.""
					+ Token.tokenToString((byte)i)
					.toLowerCase(Locale.ENGLISH);
				styles[i] = parseStyle(
					propertyManager.getProperty(styleName),
					family,size,color);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,StandardUtilities.class,e);
			}
		}

		return styles;
	} 
	
	private SyntaxUtilities(){}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.RolloverButton,8,6,8,26,25,24,26,1,7,0.714285714,100,1.0,0,0.993481095,0.392857143,2,10,11.25,2,0.875,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.plaf.basic.BasicButtonUI;
import javax.swing.plaf.basic.BasicBorders.ButtonBorder;
import org.gjt.sp.jedit.OperatingSystem;




public class RolloverButton extends JButton
{
	
	
	public RolloverButton()
	{
		
		addMouseListener(new MouseOverHandler());
	} 

	
	
	public RolloverButton(Icon icon)
	{
		this();

		setIcon(icon);
	} 

	
	public void updateUI()
	{
		super.updateUI();
		
		setBorderPainted(false);
		setRequestFocusEnabled(false);
		setMargin(new Insets(1,1,1,1));
	} 

	
	public void setEnabled(boolean b)
	{
		super.setEnabled(b);
		setBorderPainted(false);
		repaint();
	} 

	
	public void setBorderPainted(boolean b)
	{
		try
		{
			revalidateBlocked = true;
			super.setBorderPainted(b);
			setContentAreaFilled(b);
		}
		finally
		{
			revalidateBlocked = false;
		}
	} 

	
	
	public void revalidate()
	{
		if(!revalidateBlocked)
			super.revalidate();
	} 

	
	public void paint(Graphics g)
	{
		if(isEnabled())
			super.paint(g);
		else
		{
			Graphics2D g2 = (Graphics2D)g;
			g2.setComposite(c);
			super.paint(g2);
		}
	} 

	
	private static final AlphaComposite c = AlphaComposite.getInstance(
		AlphaComposite.SRC_OVER, 0.5f);

	private boolean revalidateBlocked;

	
	
	class MouseOverHandler extends MouseAdapter
	{
		public void mouseEntered(MouseEvent e)
		{
			setContentAreaFilled(true);
			setBorderPainted(isEnabled());
		}

		public void mouseExited(MouseEvent e)
		{
			setContentAreaFilled(false);
			setBorderPainted(false);
		}
	} 
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.ShortcutPrefixActiveEvent,7,3,0,4,19,5,3,1,6,0.611111111,100,1.0,0,0.285714286,0.375,0,0,12.85714286,2,0.8571,0,"
package org.gjt.sp.jedit.gui;


import java.util.Hashtable;

import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;

import org.gjt.sp.util.Log;



public class ShortcutPrefixActiveEvent extends ChangeEvent
{

	
	protected Hashtable bindings;
	
	protected boolean active;

	
	protected static EventListenerList listenerList = new EventListenerList();

	
	
	public ShortcutPrefixActiveEvent(Hashtable bindings, boolean active)
	{
		super(new Object());
		this.bindings = bindings;
		this.active = active;
	} 

	
	
	public static void addChangeEventListener(ChangeListener l)
	{
		listenerList.add(ChangeListener.class, l);
		Log.log(Log.DEBUG, ShortcutPrefixActiveEvent.class, ""Listener added.  "" + listenerList.getListenerList().length + "" left."");
	}

	
	
	public static void removeChangeEventListener(ChangeListener l)
	{
		listenerList.remove(ChangeListener.class, l);
		Log.log(Log.DEBUG, ShortcutPrefixActiveEvent.class, ""Listener removed.  "" + listenerList.getListenerList().length + "" left."");
	}

	
	
	public static void firePrefixStateChange(Hashtable bindings, boolean listeningForShortcutCompletion)
	{
		
		
		Object[] listeners = listenerList.getListenerList();
		
		
		
		for (int i = listeners.length - 2; i >= 0; i -= 2)
		{
			
			ChangeEvent event = new ShortcutPrefixActiveEvent(bindings, listeningForShortcutCompletion);
			((ChangeListener) listeners[i + 1]).stateChanged(event);
		}
	}


	
	
	public Hashtable getBindings()
	{
		return bindings;
	}

	
	
	public boolean getActive()
	{
		return active;
	}
	
}

"
jEdit,4.3,org.gjt.sp.jedit.BeanShellAction,8,3,0,12,26,14,1,11,8,0.8,195,1.0,2,0.695652174,0.270833333,3,4,22.75,2,1.0,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.jedit.bsh.*;
import java.lang.ref.SoftReference;
import java.awt.Component;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.util.Log;


public class BeanShellAction extends EditAction
{
	
	public BeanShellAction(String name, String code, String isSelected,
		boolean noRepeat, boolean noRecord, boolean noRememberLast)
	{
		super(name);

		
		String sanitizedName = name.replace('.','_').replace('-','_');
		this.code = new CachedBshMethod(""action_"" + sanitizedName, code);
		if (isSelected != null)
		{
			this.isSelected = new CachedBshMethod(""selected_"" + sanitizedName, isSelected);
		}
		this.noRepeat = noRepeat;
		this.noRecord = noRecord;
		this.noRememberLast = noRememberLast;

		jEdit.setTemporaryProperty(name + "".toggle"",
			isSelected != null ? ""true"" : ""false"");
	} 

	
	public void invoke(View view)
	{
		try
		{
			BeanShell.runCachedBlock(code.get(),view,
				new NameSpace(BeanShell.getNameSpace(),
				""BeanShellAction.invoke()""));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			new BeanShellErrorDialog(view,e);
		}
	} 

	
	public boolean isSelected(Component comp)
	{
		if(isSelected == null)
			return false;

		NameSpace global = BeanShell.getNameSpace();

		try
		{
			View view = GUIUtilities.getView(comp);

			
			
			global.setVariable(""_comp"",comp);

			return Boolean.TRUE.equals(BeanShell.runCachedBlock(
				isSelected.get(),view,
				new NameSpace(BeanShell.getNameSpace(),
				""BeanShellAction.isSelected()"")));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			
			

			
			
			isSelected = null;

			return false;
		}
		finally
		{
			try
			{
				global.setVariable(""_comp"",null);
			}
			catch(UtilEvalError err)
			{
				Log.log(Log.ERROR,this,err);
			}
		}
	} 

	
	public boolean noRepeat()
	{
		return noRepeat;
	} 

	
	public boolean noRecord()
	{
		return noRecord;
	} 

	
	
	public boolean noRememberLast()
	{
		return noRememberLast;
	} 

	
	public String getCode()
	{
		return code.getSource().trim();
	} 

	
	private boolean noRepeat;
	private boolean noRecord;
	private boolean noRememberLast;
	private CachedBshMethod code;
	private CachedBshMethod isSelected;

	
	private static class CachedBshMethod
	{
		private final String name;
		private final String source;
		private SoftReference<BshMethod> cache;

		public CachedBshMethod(String name, String source)
		{
			this.name = name;
			this.source = source;
			this.cache = null;
		}

		public BshMethod get() throws java.lang.Exception
		{
			if (cache != null)
			{
				BshMethod cached = cache.get();
				if (cached != null)
				{
					return cached;
				}
			}
			BshMethod newOne = BeanShell.cacheBlock(name, source, true);
			cache = new SoftReference<BshMethod>(newOne);
			return newOne;
		}

		public String getSource()
		{
			return source;
		}
	}

	
}
"
jEdit,4.3,org.gjt.sp.jedit.ServiceListHandler,10,2,0,5,32,21,1,5,6,0.777777778,164,1.0,1,0.653846154,0.271428571,1,1,14.7,3,1.3,0,"

package org.gjt.sp.jedit;


import java.net.URL;
import java.util.*;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.Log;



class ServiceListHandler extends DefaultHandler
{
	
	ServiceListHandler(PluginJAR plugin, URL uri)
	{
		this.plugin = plugin;
		this.uri = uri;
		code = new StringBuilder();
		stateStack = new Stack<String>();
		cachedServices = new LinkedList<ServiceManager.Descriptor>();
	} 

	
	public InputSource resolveEntity(String publicId, String systemId)
	{
		return XMLUtilities.findEntity(systemId, ""services.dtd"", getClass());
	} 

	
	public void characters(char[] c, int off, int len)
	{
		String tag = peekElement();
		if (tag == ""SERVICE"")
			code.append(c, off, len);
	} 

	
	public void startElement(String uri, String localName,
				 String tag, Attributes attrs)
	{
		tag = pushElement(tag);
		serviceName = attrs.getValue(""NAME"");
		serviceClass = attrs.getValue(""CLASS"");
	} 

	
	public void endElement(String uri, String localName, String name)
	{
		String tag = peekElement();

		if(name.equals(tag))
		{
			if (tag.equals(""SERVICE""))
			{
				ServiceManager.Descriptor d =
					new ServiceManager.Descriptor(
					serviceClass,serviceName,code.toString(),plugin);
				ServiceManager.registerService(d);
				cachedServices.add(d);
				code.setLength(0);
			}

			popElement();
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, e, e);
		}
	} 

	
	public ServiceManager.Descriptor[] getCachedServices()
	{
		return cachedServices.toArray(
			new ServiceManager.Descriptor[cachedServices.size()]);
	} 

	

	
	private PluginJAR plugin;
	private URL uri;

	private String serviceName;
	private String serviceClass;
	private StringBuilder code;

	private Stack<String> stateStack;

	private List<ServiceManager.Descriptor> cachedServices;
	

	
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	} 

	
	private String peekElement()
	{
		return stateStack.peek();
	} 

	
	private String popElement()
	{
		return stateStack.pop();
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.BufferAdapter,9,1,1,3,10,36,1,2,9,2.0,20,0.0,0,0.0,0.814814815,0,0,1.222222222,1,0.8889,0,"

package org.gjt.sp.jedit.buffer;


public abstract class BufferAdapter implements BufferListener
{
	
	
	public void foldLevelChanged(JEditBuffer buffer, int start, int end)
	{
	} 

	
	
	public void contentInserted(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	public void preContentInserted(JEditBuffer buffer, int startLine, int offset, int numLines, int length)
	{
	}

	
	
	public void preContentRemoved(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void contentRemoved(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void transactionComplete(JEditBuffer buffer) {}
	

	
	
	public void foldHandlerChanged(JEditBuffer buffer) {}
	

	
	
	public void bufferLoaded(JEditBuffer buffer) {}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.jEdit,148,1,0,346,510,10050,291,101,109,0.938994953,5420,1.0,13,0.0,0.045548654,0,0,35.41216216,61,3.2905,0,"

package org.gjt.sp.jedit;


import org.gjt.sp.jedit.visitors.JEditVisitor;
import java.awt.Color;
import java.awt.Component;
import java.awt.DefaultKeyboardFocusManager;
import java.awt.Font;
import java.awt.Frame;
import java.awt.KeyboardFocusManager;
import java.awt.Toolkit;
import java.awt.Window;

import org.gjt.sp.jedit.View.ViewConfig;
import org.gjt.sp.jedit.bsh.UtilEvalError;
import javax.swing.*;
import java.awt.event.KeyEvent;
import java.io.*;
import java.net.*;
import java.text.MessageFormat;
import java.util.*;

import org.xml.sax.SAXParseException;

import org.gjt.sp.jedit.bufferio.BufferIORequest;
import org.gjt.sp.jedit.buffer.KillRing;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.help.HelpViewer;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.pluginmgr.PluginManager;
import org.gjt.sp.jedit.search.SearchAndReplace;
import org.gjt.sp.jedit.syntax.ModeProvider;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.jedit.syntax.XModeHandler;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.visitors.SaveCaretInfoVisitor;
import org.gjt.sp.jedit.bufferset.BufferSetManager;
import org.gjt.sp.jedit.bufferset.BufferSet;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.SyntaxUtilities;



public class jEdit
{
	
	
	public static String getVersion()
	{
		return MiscUtilities.buildToVersion(getBuild());
	} 

	
	
	public static String getBuild()
	{
		
		return ""04.03.99.03"";
	} 

	
	
	public static void main(String[] args)
	{
		
		String javaVersion = System.getProperty(""java.version"");
		if(javaVersion.compareTo(""1.5"") < 0)
		{
			System.err.println(""You are running Java version ""
				+ javaVersion + '.');
			System.err.println(""jEdit requires Java 1.5 or later."");
			System.exit(1);
		} 

		startupDone.add(false);

		
		
		mainThread = Thread.currentThread();

		settingsDirectory = "".jedit"";
		
		if(OperatingSystem.isMacOS())
			settingsDirectory = ""Library/jEdit"";

		
		
		background = OperatingSystem.isMacOS();

		
		boolean endOpts = false;
		int level = Log.WARNING;
		String portFile = ""server"";
		boolean restore = true;
		boolean newView = true;
		boolean newPlainView = false;
		boolean gui = true; 
		boolean loadPlugins = true;
		boolean runStartupScripts = true;
		boolean quit = false;
		boolean wait = false;
		boolean shouldRelocateSettings = true;
		String userDir = System.getProperty(""user.dir"");

		
		String scriptFile = null;

		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.length() == 0)
				args[i] = null;
			else if(arg.startsWith(""-"") && !endOpts)
			{
				if(arg.equals(""--""))
					endOpts = true;
				else if(arg.equals(""-usage""))
				{
					version();
					System.err.println();
					usage();
					System.exit(1);
				}
				else if(arg.equals(""-version""))
				{
					version();
					System.exit(1);
				}
				else if(arg.startsWith(""-log=""))
				{
					try
					{
						level = Integer.parseInt(arg.substring(""-log="".length()));
					}
					catch(NumberFormatException nf)
					{
						System.err.println(""Malformed option: "" + arg);
					}
				}
				else if(arg.equals(""-nosettings""))
					settingsDirectory = null;
				else if(arg.startsWith(""-settings=""))
				{
					settingsDirectory = arg.substring(10);
					shouldRelocateSettings = false;
				}
				else if(arg.startsWith(""-noserver""))
					portFile = null;
				else if(arg.equals(""-server""))
					portFile = ""server"";
				else if(arg.startsWith(""-server=""))
					portFile = arg.substring(8);
				else if(arg.startsWith(""-background""))
					background = true;
				else if(arg.startsWith(""-nobackground""))
					background = false;
				else if(arg.equals(""-gui""))
					gui = true;
				else if(arg.equals(""-nogui""))
					gui = false;
				else if(arg.equals(""-newview""))
					newView = true;
				else if(arg.equals(""-newplainview""))
					newPlainView = true;
				else if(arg.equals(""-reuseview""))
					newPlainView = newView = false;
				else if(arg.equals(""-restore""))
					restore = true;
				else if(arg.equals(""-norestore""))
					restore = false;
				else if(arg.equals(""-plugins""))
					loadPlugins = true;
				else if(arg.equals(""-noplugins""))
					loadPlugins = false;
				else if(arg.equals(""-startupscripts""))
					runStartupScripts = true;
				else if(arg.equals(""-nostartupscripts""))
					runStartupScripts = false;
				else if(arg.startsWith(""-run=""))
					scriptFile = arg.substring(5);
				else if(arg.equals(""-wait""))
					wait = true;
				else if(arg.equals(""-quit""))
					quit = true;
				else
				{
					System.err.println(""Unknown option: ""
						+ arg);
					usage();
					System.exit(1);
				}
				args[i] = null;
			}
		} 

		
		if(settingsDirectory != null)
		{
			settingsDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),
				settingsDirectory);
			settingsDirectory = MiscUtilities.resolveSymlinks(
				settingsDirectory);
		}

		if(settingsDirectory != null && portFile != null)
			portFile = MiscUtilities.constructPath(settingsDirectory,portFile);
		else
			portFile = null;

		Log.init(true,level);
		

		
		if(portFile != null && new File(portFile).exists())
		{
			try
			{
				BufferedReader in = new BufferedReader(new FileReader(portFile));
				String check = in.readLine();
				if(!check.equals(""b""))
					throw new Exception(""Wrong port file format"");

				int port = Integer.parseInt(in.readLine());
				int key = Integer.parseInt(in.readLine());

				Socket socket = new Socket(InetAddress.getByName(""127.0.0.1""),port);
				DataOutputStream out = new DataOutputStream(
					socket.getOutputStream());
				out.writeInt(key);

				String script;
				if(quit)
				{
					script = ""socket.close();\n""
						+ ""jEdit.exit(null,true);\n"";
				}
				else
				{
					script = makeServerScript(wait,restore,
						newView,newPlainView,args,
						scriptFile);
				}

				out.writeUTF(script);

				Log.log(Log.DEBUG,jEdit.class,""Waiting for server"");
				
				try
				{
					socket.getInputStream().read();
				}
				catch(Exception e)
				{
				}

				in.close();
				out.close();

				System.exit(0);
			}
			catch(Exception e)
			{
				
				
				
				Log.log(Log.NOTICE,jEdit.class,""An error occurred""
					+ "" while connecting to the jEdit server instance."");
				Log.log(Log.NOTICE,jEdit.class,""This probably means that""
					+ "" jEdit crashed and/or exited abnormally"");
				Log.log(Log.NOTICE,jEdit.class,""the last time it was run."");
				Log.log(Log.NOTICE,jEdit.class,""If you don't""
					+ "" know what this means, don't worry."");
				Log.log(Log.NOTICE,jEdit.class,e);
			}
		}

		if(quit)
		{
			
			
			System.exit(0);
		} 

		
		
		if(!new File(settingsDirectory,""nosplash"").exists())
			GUIUtilities.showSplashScreen();

		
		if(OperatingSystem.isMacOS() && shouldRelocateSettings && settingsDirectory != null)
		{
			relocateSettings();
		}
		

		
		Writer stream;
		if(settingsDirectory != null)
		{
			File _settingsDirectory = new File(settingsDirectory);
			if(!_settingsDirectory.exists())
				_settingsDirectory.mkdirs();
			File _macrosDirectory = new File(settingsDirectory,""macros"");
			if(!_macrosDirectory.exists())
				_macrosDirectory.mkdir();

			String logPath = MiscUtilities.constructPath(
				settingsDirectory,""activity.log"");

			backupSettingsFile(new File(logPath));

			try
			{
				stream = new BufferedWriter(new FileWriter(logPath));

				
				String lineSep = System.getProperty(""line.separator"");
				stream.write(""Log file created on "" + new Date());
				stream.write(lineSep);
				stream.write(""IMPORTANT:"");
				stream.write(lineSep);
				stream.write(""Because updating this file after ""
					+ ""every log message would kill"");
				stream.write(lineSep);
				stream.write(""performance, it will be *incomplete* ""
					+ ""unless you invoke the"");
				stream.write(lineSep);
				stream.write(""Utilities->Troubleshooting->Update ""
					+ ""Activity Log on Disk command!"");
				stream.write(lineSep);
			}
			catch(Exception e)
			{
				e.printStackTrace();
				stream = null;
			}
		}
		else
		{
			stream = null;
		} 

		Log.setLogWriter(stream);

		Log.log(Log.NOTICE,jEdit.class,""jEdit version "" + getVersion());
		Log.log(Log.MESSAGE,jEdit.class,""Settings directory is ""
			+ settingsDirectory);

		
		GUIUtilities.advanceSplashProgress(""init"");
		initMisc();
		GUIUtilities.advanceSplashProgress(""init system properties"");
		initSystemProperties();

		GUIUtilities.advanceSplashProgress(""init beanshell"");
		BeanShell.init();

		GUIUtilities.advanceSplashProgress(""loading site properties"");
		if(jEditHome != null)
			initSiteProperties();

		GUIUtilities.advanceSplashProgress(""loading user properties"");
		initUserProperties();

		GUIUtilities.advanceSplashProgress(""init GUI"");
		GUIUtilities.init();

		globalBufferSet = new BufferSet();
		bufferSetManager = new BufferSetManager();

		
		

		
		if(portFile != null)
		{
			GUIUtilities.advanceSplashProgress(""init server"");
			server = new EditServer(portFile);
			if(!server.isOK())
				server = null;
		}
		else
		{
			GUIUtilities.advanceSplashProgress();
			if(background)
			{
				background = false;
				Log.log(Log.WARNING,jEdit.class,""You cannot specify both the""
					+ "" -background and -noserver switches"");
			}
		} 

		
		GUIUtilities.advanceSplashProgress(""init look and feel"");
		initPLAF();
		GUIUtilities.advanceSplashProgress(""init VFS Manager"");
		VFSManager.init();
		GUIUtilities.advanceSplashProgress(""init resources"");
		initResources();
		SearchAndReplace.load();



		if(loadPlugins)
		{
			GUIUtilities.advanceSplashProgress(""init plugins"");
			initPlugins();
		}
		else
			GUIUtilities.advanceSplashProgress();

		Registers.setSaver(new JEditRegisterSaver());
		Registers.setListener(new JEditRegistersListener());
		GUIUtilities.advanceSplashProgress(""init history model"");
		HistoryModel.setSaver(new JEditHistoryModelSaver());
		HistoryModel.loadHistory();
		GUIUtilities.advanceSplashProgress(""init buffer history"");
		BufferHistory.load();
		GUIUtilities.advanceSplashProgress(""init killring"");
		KillRing.setInstance(new JEditKillRing());
		KillRing.getInstance().load();
		GUIUtilities.advanceSplashProgress(""init various properties"");
		propertiesChanged();

		GUIUtilities.advanceSplashProgress(""init modes"");

		
		sortBuffers = getBooleanProperty(""sortBuffers"");
		sortByName = getBooleanProperty(""sortByName"");

		reloadModes();

		GUIUtilities.advanceSplashProgress(""activate plugins"");
		

		
		for(int i = 0; i < jars.size(); i++)
		{
			jars.elementAt(i).activatePluginIfNecessary();
		} 

		
		GUIUtilities.advanceSplashProgress(""init macros"");
		Macros.loadMacros();
		Macros.getMacroActionSet().initKeyBindings();

		if(runStartupScripts && jEditHome != null)
		{
			String path = MiscUtilities.constructPath(jEditHome,""startup"");
			File file = new File(path);
			if(file.exists())
			{
				runStartupScripts(file);
			}
			else
				GUIUtilities.advanceSplashProgress();
		}
		else
			GUIUtilities.advanceSplashProgress(""run startup scripts"");

		if(runStartupScripts && settingsDirectory != null)
		{
			String path = MiscUtilities.constructPath(settingsDirectory,""startup"");
			File file = new File(path);
			if (file.exists())
			{
				GUIUtilities.advanceSplashProgress(""run startup scripts"");
				runStartupScripts(file);
			}
			else
			{
				GUIUtilities.advanceSplashProgress();
				file.mkdirs();
			}
		}
		else
		{
			GUIUtilities.advanceSplashProgress();
		} 

		
		if(scriptFile != null)
		{
			GUIUtilities.advanceSplashProgress(""run script file"");
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			try
			{
				BeanShell.getNameSpace().setVariable(""args"",args);
			}
			catch(UtilEvalError e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
			BeanShell.runScript(null,scriptFile,null,false);
		}
		else
		{
			GUIUtilities.advanceSplashProgress();
		}
		

		GUIUtilities.advanceSplashProgress();

		
		
		
		
		DockingLayoutManager.init();

		
		SyntaxUtilities.propertyManager = jEdit.propertyManager;
		finishStartup(gui,restore,newPlainView,userDir,args);
	} 

	

	
	
	public static Properties getProperties()
	{
		return propMgr.getProperties();
	} 

	
	
	public static String getProperty(String name)
	{
		return propMgr.getProperty(name);
	} 

	
	
	public static String getProperty(String name, String def)
	{
		String value = propMgr.getProperty(name);
		if(value == null)
			return def;
		else
			return value;
	} 

	
	
	public static String getProperty(String name, Object[] args)
	{
		if(name == null)
			return null;
		if(args == null)
			return getProperty(name);
		else
		{
			String value = getProperty(name);
			if(value == null)
				return null;
			else
				return MessageFormat.format(value,args);
		}
	} 

	
	
	public static boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name,false);
	} 

	
	
	public static boolean getBooleanProperty(String name, boolean def)
	{
		String value = getProperty(name);
		return StandardUtilities.getBoolean(value, def);
	} 

	
	
	public static int getIntegerProperty(String name)
	{
		return getIntegerProperty(name,0);
	} 

	
	
	public static int getIntegerProperty(String name, int def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Integer.parseInt(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	} 

	
	public static double getDoubleProperty(String name, double def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Double.parseDouble(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	}
	

	
	
	public static Font getFontProperty(String name)
	{
		return getFontProperty(name,null);
	} 

	
	
	public static Font getFontProperty(String name, Font def)
	{
		String family = getProperty(name);
		String sizeString = getProperty(name + ""size"");
		String styleString = getProperty(name + ""style"");

		if(family == null || sizeString == null || styleString == null)
			return def;
		else
		{
			int size, style;

			try
			{
				size = Integer.parseInt(sizeString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			try
			{
				style = Integer.parseInt(styleString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			return new Font(family,style,size);
		}
	} 

	
	
	public static Color getColorProperty(String name)
	{
		return getColorProperty(name,Color.black);
	} 

	
	
	public static Color getColorProperty(String name, Color def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
			return SyntaxUtilities.parseColor(value, def);
	} 

	
	
	public static void setColorProperty(String name, Color value)
	{
		setProperty(name, SyntaxUtilities.getColorHexString(value));
	} 

	
	
	public static void setProperty(String name, String value)
	{
		propMgr.setProperty(name,value);
	} 

	
	
	public static void setTemporaryProperty(String name, String value)
	{
		propMgr.setTemporaryProperty(name,value);
	} 

	
	
	public static void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? ""true"" : ""false"");
	} 

	
	
	public static void setIntegerProperty(String name, int value)
	{
		setProperty(name,String.valueOf(value));
	} 

	
	public static void setDoubleProperty(String name, double value)
	{
		setProperty(name,String.valueOf(value));
	}
	

	
	
	public static void setFontProperty(String name, Font value)
	{
		setProperty(name,value.getFamily());
		setIntegerProperty(name + ""size"",value.getSize());
		setIntegerProperty(name + ""style"",value.getStyle());
	} 

	
	
	public static void unsetProperty(String name)
	{
		propMgr.unsetProperty(name);
	} 

	
	
	public static void resetProperty(String name)
	{
		propMgr.resetProperty(name);
	} 

	
	
	public static void propertiesChanged()
	{
		initKeyBindings();

		Autosave.setInterval(getIntegerProperty(""autosave"",30));

		saveCaret = getBooleanProperty(""saveCaret"");

		UIDefaults defaults = UIManager.getDefaults();

		
		Font font = getFontProperty(""view.font"");

		
		defaults.put(""TextArea.font"",font);
		defaults.put(""TextPane.font"",font);

		
		ToolTipManager.sharedInstance().setEnabled(
			jEdit.getBooleanProperty(""showTooltips""));

		initProxy();

		
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			buffer.resetCachedProperties();
			buffer.propertiesChanged();
			buffer = buffer.next;
		}

		HistoryModel.setMax(getIntegerProperty(""history"",25));
		KillRing.getInstance().propertiesChanged(getIntegerProperty(""history"",25));

		EditBus.send(new PropertiesChanged(null));
	} 

	

	

	
	
	public static String[] getNotLoadedPluginJARs()
	{
		List<String> returnValue = new ArrayList<String>();

		if(jEditHome != null)
		{
			String systemPluginDir = MiscUtilities
				.constructPath(jEditHome,""jars"");

			String[] list = new File(systemPluginDir).list();
			if(list != null)
				getNotLoadedPluginJARs(returnValue,systemPluginDir,list);
		}

		if(settingsDirectory != null)
		{
			String userPluginDir = MiscUtilities
				.constructPath(settingsDirectory,""jars"");
			String[] list = new File(userPluginDir).list();
			if(list != null)
			{
				getNotLoadedPluginJARs(returnValue,
					userPluginDir,list);
			}
		}

		String[] _returnValue = new String[returnValue.size()];
		returnValue.toArray(_returnValue);
		return _returnValue;
	} 

	
	
	public static EditPlugin getPlugin(String name)
	{
		return getPlugin(name, false);
	} 

	
	
	public static EditPlugin getPlugin(String name, boolean loadIfNecessary)
	{
		EditPlugin[] plugins = getPlugins();
		EditPlugin plugin = null;
		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClassName().equals(name))
				plugin = plugins[i];
			if(loadIfNecessary)
			{
				if(plugin instanceof EditPlugin.Deferred)
				{
					plugin.getPluginJAR().activatePlugin();
					plugin = plugin.getPluginJAR().getPlugin();
					break;
				}
			}
		}
		if (!loadIfNecessary) return plugin;
		String jarPath = PluginJAR.findPlugin(name);
		PluginJAR pjar = PluginJAR.load(jarPath, true);
		return pjar.getPlugin();
	} 

	
	
	public static EditPlugin[] getPlugins()
	{
		List<EditPlugin> pluginList = new ArrayList<EditPlugin>();
		for(int i = 0; i < jars.size(); i++)
		{
			EditPlugin plugin = jars.elementAt(i).getPlugin();
			if(plugin != null)
				pluginList.add(plugin);
		}

		EditPlugin[] array = new EditPlugin[pluginList.size()];
		pluginList.toArray(array);
		return array;
	} 

	
	
	public static PluginJAR[] getPluginJARs()
	{
		PluginJAR[] array = new PluginJAR[jars.size()];
		jars.copyInto(array);
		return array;
	} 

	
	
	public static PluginJAR getPluginJAR(String path)
	{
		for(int i = 0; i < jars.size(); i++)
		{
			PluginJAR jar = jars.elementAt(i);
			if(jar.getPath().equals(path))
				return jar;
		}

		return null;
	} 

	
	
	public static void addPluginJAR(String path)
	{
		PluginJAR jar = new PluginJAR(new File(path));
		jars.addElement(jar);
		jar.init();
		jEdit.unsetProperty(""plugin-blacklist.""+MiscUtilities.getFileName(path));
		EditBus.send(new PluginUpdate(jar,PluginUpdate.LOADED,false));
		if(!isMainThread())
		{
			EditBus.send(new DynamicMenuChanged(""plugins""));
			initKeyBindings();
		}
	} 

	
	
	private static void addPluginJARsFromDirectory(String directory)
	{
		Log.log(Log.NOTICE,jEdit.class,""Loading plugins from ""
			+ directory);

		File file = new File(directory);
		if(!(file.exists() && file.isDirectory()))
			return;
		String[] plugins = file.list();
		if(plugins == null)
			return;

		for(int i = 0; i < plugins.length; i++)
		{
			String plugin = plugins[i];
			if(!plugin.toLowerCase().endsWith("".jar""))
				continue;

			String path = MiscUtilities.constructPath(directory,plugin);
			if (jEdit.getBooleanProperty(""plugin-blacklist.""+plugin))
				continue;
			
			if(plugin.equals(""EditBuddy.jar"")
				|| plugin.equals(""PluginManager.jar"")
				|| plugin.equals(""Firewall.jar"")
				|| plugin.equals(""Tidy.jar"")
				|| plugin.equals(""DragAndDrop.jar""))
			{
				pluginError(path,""plugin-error.obsolete"",null);
				continue;
			}

			addPluginJAR(path);
		}
	} 

	
	
	public static void removePluginJAR(PluginJAR jar, boolean exit)
	{
		if(exit)
		{
			jar.uninit(true);
		}
		else
		{
			jar.uninit(false);
			jars.removeElement(jar);
			initKeyBindings();
		}

		EditBus.send(new PluginUpdate(jar,PluginUpdate.UNLOADED,exit));
		if(!isMainThread() && !exit)
			EditBus.send(new DynamicMenuChanged(""plugins""));
	} 

	

	

	
	
	public static ActionContext getActionContext()
	{
		return actionContext;
	} 

	
	
	public static void addActionSet(ActionSet actionSet)
	{
		actionContext.addActionSet(actionSet);
	} 

	
	
	public static void removeActionSet(ActionSet actionSet)
	{
		actionContext.removeActionSet(actionSet);
	} 

	
	
	public static ActionSet getBuiltInActionSet()
	{
		return builtInActionSet;
	} 

	
	
	public static ActionSet[] getActionSets()
	{
		return actionContext.getActionSets();
	} 

	
	
	public static EditAction getAction(String name)
	{
		return actionContext.getAction(name);
	} 

	
	
	public static ActionSet getActionSetForAction(String action)
	{
		return actionContext.getActionSetForAction(action);
	} 

	
	
	@Deprecated
	public static ActionSet getActionSetForAction(EditAction action)
	{
		return actionContext.getActionSetForAction(action.getName());
	} 

	
	
	@Deprecated
	public static EditAction[] getActions()
	{
		String[] names = actionContext.getActionNames();
		EditAction[] actions = new EditAction[names.length];
		for(int i = 0; i < actions.length; i++)
		{
			actions[i] = actionContext.getAction(names[i]);
			if(actions[i] == null)
				Log.log(Log.ERROR,jEdit.class,""wtf: "" + names[i]);
		}
		return actions;
	} 

	
	
	public static String[] getActionNames()
	{
		return actionContext.getActionNames();
	} 

	

	

	
	
	public static void reloadModes()
	{
		
		ModeProvider.instance.removeAll();

		
		if(jEditHome == null)
			loadModeCatalog(""/modes/catalog"",true);
		else
		{
			loadModeCatalog(MiscUtilities.constructPath(jEditHome,
				""modes"",""catalog""),false);
		} 

		
		if(settingsDirectory != null)
		{
			File userModeDir = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes""));
			if(!userModeDir.exists())
				userModeDir.mkdirs();

			File userCatalog = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes"",""catalog""));
			if(!userCatalog.exists())
			{
				
				FileWriter out = null;
				try
				{
					out = new FileWriter(userCatalog);
					out.write(jEdit.getProperty(""defaultCatalog""));
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}
				finally
				{
					IOUtilities.closeQuietly(out);
				}
			}

			loadModeCatalog(userCatalog.getPath(),false);
		} 

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			
			
			buffer.setMode();

			buffer = buffer.next;
		}
	} 

	
	
	public static Mode getMode(String name)
	{
		return ModeProvider.instance.getMode(name);
	} 

	
	
	public static Mode[] getModes()
	{
		return ModeProvider.instance.getModes();
	} 

	

	

	
	
	public static Buffer openFiles(View view, String parent, String[] args)
	{
		Buffer retVal = null;
		Buffer lastBuffer = null;

		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.startsWith(""+line:"") || arg.startsWith(""+marker:""))
			{
				if(lastBuffer != null)
					gotoMarker(view,lastBuffer,arg);
				continue;
			}

			lastBuffer = openFile((View)null,parent,arg,false,null);

			if(retVal == null && lastBuffer != null)
				retVal = lastBuffer;
		}

		if(view != null && retVal != null)
			view.setBuffer(retVal,true);

		return retVal;
	} 

	
	
	public static Buffer openFile(View view, String path)
	{
		return openFile(view,null,path,false,new Hashtable());
	}
	
	@Deprecated
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile)
	{
		return openFile(view,parent,path,newFile,new Hashtable());
	}
	
	@Deprecated
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile,
		Hashtable props)
	{
		return openFile(view,parent,path,newFile,props);
	}

	
	public static Buffer openFile(View view, String parent,
		String path, boolean newFile, Hashtable props)
	{
		return openFile(view == null ? null : view.getEditPane(), parent, path, newFile, props);
	}

	
	public static Buffer openFile(EditPane editPane, String path)
	{
		return openFile(editPane,null,path,false,new Hashtable());
	}

	
	public static Buffer openFile(EditPane editPane, String parent,
		String path, boolean newFile, Hashtable props)
	{
		PerspectiveManager.setPerspectiveDirty(true);

		if(editPane != null && parent == null && editPane.getBuffer() != null)
			parent = editPane.getBuffer().getDirectory();

		try
		{
			URL u = new URL(path);
			if (u.getProtocol().equals(""file""))
				path = URLDecoder.decode(u.getPath());
		}
		catch (MalformedURLException mue)
		{
			path = MiscUtilities.constructPath(parent,path);
		}


		if(props == null)
			props = new Hashtable();
		composeBufferPropsFromHistory(props, path);

		Buffer newBuffer;

		synchronized (editBusOrderingLock)
		{
			View view = editPane == null ? null : editPane.getView();
			synchronized(bufferListLock)
			{
				Buffer buffer = getBuffer(path);
				if(buffer != null)
				{
					if(editPane != null)
						editPane.setBuffer(buffer,true);

					return buffer;
				}

				newBuffer = new Buffer(path,newFile,false,props);

				if(!newBuffer.load(view,false))
					return null;
				addBufferToList(newBuffer);
				if (editPane != null)
					bufferSetManager.addBuffer(editPane.getBufferSet(), newBuffer);
				else
					bufferSetManager.addBuffer(jEdit.getActiveView(), newBuffer);
			}

			EditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));
		}

		if(editPane != null)
			editPane.setBuffer(newBuffer,true);

		return newBuffer;
	} 

	
	
	public static Buffer openTemporary(View view, String parent,
		String path, boolean newFile)
	{
		return openTemporary(view, parent, path, newFile, null);
	}
	
	public static Buffer openTemporary(View view, String parent,
		String path, boolean newFile, Hashtable props)
	{
		if(view != null && parent == null)
			parent = view.getBuffer().getDirectory();

		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}

		path = MiscUtilities.constructPath(parent,path);

		if(props == null)
			props = new Hashtable();
		composeBufferPropsFromHistory(props, path);

		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
				return buffer;

			buffer = new Buffer(path,newFile,true,props);
			buffer.setBooleanProperty(Buffer.ENCODING_AUTODETECT, true);
			if(!buffer.load(view,false))
				return null;
			else
				return buffer;
		}
	} 

	
	
	public static void commitTemporary(Buffer buffer)
	{
		if(!buffer.isTemporary())
			return;

		PerspectiveManager.setPerspectiveDirty(true);

		addBufferToList(buffer);
		buffer.commitTemporary();

		
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOAD_STARTED));
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOADED));
	} 

	
	
	public static Buffer newFile(View view)
	{
		return newFile(view == null ? null : view.getEditPane());
	}

	
	public static Buffer newFile(View view, String dir)
	{
		EditPane editPane = null;
		if (view != null)
		{
			editPane = view.getEditPane();
		}
		else
		{
			View v = getActiveView();
			if (v != null)
			{
				editPane = v.getEditPane();
			}
		}
		return newFile(editPane, dir);
	}

	
	public static Buffer newFile(EditPane editPane)
	{
		String path;

		if(editPane != null && editPane.getBuffer() != null)
		{
			path = editPane.getBuffer().getDirectory();
			VFS vfs = VFSManager.getVFSForPath(path);
			
			
			if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
				path = System.getProperty(""user.home"");
		}
		else
			path = null;

		return newFile(editPane,path);
	}

	
	public static Buffer newFile(EditPane editPane, String dir)
	{
		if (editPane != null)
		{
			BufferSet bufferSet = editPane.getBufferSet();
			Buffer[] buffers = bufferSet.getAllBuffers();
			for (Buffer buf:buffers)
			{
				if (buf.isUntitled() && !buf.isDirty())
				{

					if (!MiscUtilities.getParentOfPath(buf.getPath()).equals(dir))
					{
						
						int untitledCount = getNextUntitledBufferId();

						Buffer newBuffer = openFile(editPane,dir,""Untitled-"" + untitledCount,true,null);
						jEdit.closeBuffer(editPane, buf);
						return newBuffer;
					}
					
					int l = buf.getLength();
					if (l > 0)
						buf.remove(0, l);
					editPane.setBuffer(buf);
					return buf;
				}
			}
		}

		
		int untitledCount = getNextUntitledBufferId();

		return openFile(editPane,dir,""Untitled-"" + untitledCount,true,null);
	} 

	

	

	
	
	public static boolean closeBuffer(View view, Buffer buffer)
	{
		
		if(buffer.isPerformingIO())
		{
			VFSManager.waitForRequests();
			if(VFSManager.errorOccurred())
				return false;
		}

		if(buffer.isDirty())
		{
			Object[] args = { buffer.getName() };
			int result = GUIUtilities.confirm(view,""notsaved"",args,
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				if(!buffer.save(view,null,true))
					return false;

				VFSManager.waitForRequests();
				if(buffer.getBooleanProperty(BufferIORequest
					.ERROR_OCCURRED))
				{
					return false;
				}
			}
			else if(result != JOptionPane.NO_OPTION)
				return false;
		}

		_closeBuffer(view,buffer);

		return true;
	} 

	
	
	public static void closeBuffer(EditPane editPane, Buffer buffer)
	{
		int bufferSetsCount = bufferSetManager.countBufferSets(buffer);
		if (bufferSetsCount < 2)
		{
			closeBuffer(editPane.getView(), buffer);
		}
		else
		{
			bufferSetManager.removeBuffer(editPane, buffer);
		}
	} 

	
	
	public static void _closeBuffer(View view, Buffer buffer)
	{
		if(buffer.isClosed())
		{
			
			
			return;
		}

		PerspectiveManager.setPerspectiveDirty(true);

		if(!buffer.isNewFile())
		{
			if(view != null)
				view.getEditPane().saveCaretInfo();
			Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
			int caret = _caret == null ? 0 : _caret.intValue();

			BufferHistory.setEntry(buffer.getPath(),caret,
				(Selection[])buffer.getProperty(Buffer.SELECTION),
				buffer.getStringProperty(JEditBuffer.ENCODING),
				buffer.getMode().getName());
		}

		String path = buffer.getSymlinkPath();
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
		}
		EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSING));
		bufferHash.remove(path);
		removeBufferFromList(buffer);
		buffer.close();
		DisplayManager.bufferClosed(buffer);
		bufferSetManager.removeBuffer(buffer);
		EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));
		if(jEdit.getBooleanProperty(""persistentMarkers""))
			buffer.updateMarkersFile(view);
	} 

	
	
	public static boolean closeAllBuffers(View view)
	{
		return closeAllBuffers(view,false);
	}
	
	public static boolean closeAllBuffers(View view, boolean isExiting)
	{
		if(view != null)
			view.getEditPane().saveCaretInfo();

		boolean dirty = false;

		boolean saveRecent = !(isExiting && jEdit.getBooleanProperty(""restore""));

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				dirty = true;
				break;
			}
			buffer = buffer.next;
		}

		if(dirty)
		{
			boolean ok = new CloseDialog(view).isOK();
			if(!ok)
				return false;
		}

		
		VFSManager.waitForRequests();
		if(VFSManager.errorOccurred())
			return false;

		
		

		buffer = buffersFirst;

		
		buffersFirst = buffersLast = null;
		bufferHash.clear();
		bufferCount = 0;

		while(buffer != null)
		{
			if(!buffer.isNewFile() && saveRecent)
			{
				Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
				int caret = _caret == null ? 0 : _caret.intValue();
				BufferHistory.setEntry(buffer.getPath(),caret,
					(Selection[])buffer.getProperty(Buffer.SELECTION),
					buffer.getStringProperty(JEditBuffer.ENCODING),
					buffer.getMode().getName());
			}

			buffer.close();
			DisplayManager.bufferClosed(buffer);
			if(!isExiting)
			{
				bufferSetManager.removeBuffer(buffer);
				EditBus.send(new BufferUpdate(buffer,view,
					BufferUpdate.CLOSED));
			}
			if(jEdit.getBooleanProperty(""persistentMarkers""))
				buffer.updateMarkersFile(view);
			buffer = buffer.next;
		}

		PerspectiveManager.setPerspectiveDirty(true);

		return true;
	} 

	
	
	public static void saveAllBuffers(View view)
	{
		saveAllBuffers(view,jEdit.getBooleanProperty(""confirmSaveAll""));
	} 

	
	
	public static void saveAllBuffers(View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""saveall"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		Buffer current = view.getBuffer();

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				if(buffer.isNewFile())
					view.setBuffer(buffer,true);
				buffer.save(view,null,true,true);
			}

			buffer = buffer.next;
		}

		view.setBuffer(current,true);
	} 

	
	
	public static void reloadAllBuffers(View view, boolean confirm)
	{
		boolean hasDirty = false;
		Buffer[] buffers = jEdit.getBuffers();

		for(int i = 0; i < buffers.length && !hasDirty; i++)
			hasDirty = !buffers[i].isUntitled() && buffers[i].isDirty();

		if(confirm && hasDirty)
		{
			int result = GUIUtilities.confirm(view,""reload-all"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		
		visit(new SaveCaretInfoVisitor());


		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if (buffer.isUntitled())
				continue;
			buffer.load(view,true);
		}
	} 

	
	
	public static Buffer _getBuffer(String path)
	{
		
		
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
		}

		synchronized(bufferListLock)
		{
			return bufferHash.get(path);
		}
	} 

	
	
	public static Buffer getBuffer(String path)
	{
		return _getBuffer(MiscUtilities.resolveSymlinks(path));
	} 

	
	
	public static Buffer[] getBuffers()
	{
		synchronized(bufferListLock)
		{
			Buffer[] buffers = new Buffer[bufferCount];
			Buffer buffer = buffersFirst;
			for(int i = 0; i < bufferCount; i++)
			{
				buffers[i] = buffer;
				buffer = buffer.next;
			}
			return buffers;
		}
	} 

	
	
	public static int getBufferCount()
	{
		return bufferCount;
	} 

	
	
	public static Buffer getFirstBuffer()
	{
		return buffersFirst;
	} 

	
	
	public static Buffer getLastBuffer()
	{
		return buffersLast;
	} 

	
	
	public static void moveBuffer(EditPane editPane,
		int oldPosition, int newPosition)
	{
		bufferSetManager.moveBuffer(editPane, oldPosition, newPosition);
	} 

	
	
	public static BufferSet getGlobalBufferSet()
	{
		return globalBufferSet;
	} 

	
	
	public static BufferSetManager getBufferSetManager()
	{
		return bufferSetManager;
	} 

	
	
	public static JEditPropertyManager getPropertyManager()
	{
		return propertyManager;
	} 

	
	
	public static void checkBufferStatus(View view)
	{
		checkBufferStatus(view,false);
	}

	
	public static void checkBufferStatus(View view, boolean currentBuffer)
	{
		
		
		

		
		boolean autoReload = getBooleanProperty(""autoReload"");

		
		
		
		visit(new SaveCaretInfoVisitor());

		Buffer buffer;
		buffer = buffersFirst;

		int[] states = new int[bufferCount];
		int i = 0;
		boolean notifyFileChanged = false;
		while(buffer != null)
		{
			if(currentBuffer && buffer != view.getBuffer())
			{
				buffer = buffer.next;
				i++;
				continue;
			}

			states[i] = buffer.checkFileStatus(view);

			switch(states[i])
			{
			case Buffer.FILE_CHANGED:
				if(buffer.getAutoReload())
				{
					if(buffer.isDirty())
						notifyFileChanged = true;
					else
						buffer.load(view,true);
				}
				else	
					autoReload = false;
				
				if(buffer.getAutoReloadDialog())
					notifyFileChanged = true;
				break;
			case Buffer.FILE_DELETED:
				notifyFileChanged = true;
				break;
			}

			buffer = buffer.next;
			i++;
		}

		if(notifyFileChanged)
			new FilesChangedDialog(view,states,autoReload);
	} 

	

	

	
	
	public static InputHandler getInputHandler()
	{
		return inputHandler;
	} 

	

	
	
	public static View newView(View view)
	{
		return newView(view,null,false);
	}
	
	public static View newView(View view, Buffer buffer)
	{
		return newView(view,buffer,false);
	}
	
	public static View newView(View view, Buffer buffer, boolean plainView)
	{
		View.ViewConfig config;
		if(view != null && (plainView == view.isPlainView()))
		{
			config = view.getViewConfig();
			config.x -= 20;
			config.y += 20;
		}
		else
		{
			config = new View.ViewConfig(plainView);
		}
		return newView(view,buffer,config);
	}

	
	public static View newView(View view, Buffer buffer, View.ViewConfig config)
	{
		
		
		if (isStartupDone())
			PerspectiveManager.setPerspectiveDirty(true);

		try
		{
			if(view != null)
			{
				view.showWaitCursor();
				view.getEditPane().saveCaretInfo();
			}

			View newView = new View(buffer,config);
			addViewToList(newView);

			newView.pack();
			newView.adjust(view, config);

			EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));

			newView.setVisible(true);

			if(!config.plainView)
			{
				int index;
				synchronized (startupDone)
				{
					index = startupDone.size();
					startupDone.add(false);
				}
				SwingUtilities.invokeLater(new DockingLayoutSetter(
					newView, config, index));
			}

			
			if(newView == viewsFirst)
			{
				newView.getTextArea().requestFocus();

				
				
				if(settingsDirectory != null && getBooleanProperty(""firstTime""))
					new HelpViewer(""welcome.html"");
				else if(jEdit.getBooleanProperty(""tip.show""))
					new TipOfTheDay(newView);

				setBooleanProperty(""firstTime"",false);
			}
			else
				GUIUtilities.requestFocus(newView,newView.getTextArea());

			return newView;
		}
		finally
		{
			if(view != null)
				view.hideWaitCursor();
		}
	} 

	
	
	public static void closeView(View view)
	{
		closeView(view,true);
	} 

	
	
	public static View[] getViews()
	{
		View[] views = new View[viewCount];
		View view = viewsFirst;
		for(int i = 0; i < viewCount; i++)
		{
			views[i] = view;
			view = view.next;
		}
		return views;
	} 

	
	
	public static int getViewCount()
	{
		return viewCount;
	} 

	
	
	public static View getFirstView()
	{
		return viewsFirst;
	} 

	
	
	public static View getLastView()
	{
		return viewsLast;
	} 

	
	
	public static View getActiveView()
	{
		if(activeView == null)
		{
			
			return viewsFirst;
		}
		else
			return activeView;
	} 

	

	

	
	public static void relocateSettings()
	{
		String oldSettingsPath = MiscUtilities.constructPath(
				System.getProperty(""user.home""),
				"".jedit"");
		File oldSettingsDir = new File(oldSettingsPath);
		File newSettingsDir = new File(settingsDirectory);
		if(oldSettingsDir.exists() && !newSettingsDir.exists())
		{
			Log.log(Log.NOTICE,jEdit.class,""Old settings directory found (HOME/.jedit). Moving to new location (""+newSettingsDir+"")"");
			try
			{
				oldSettingsDir.renameTo(newSettingsDir);
			}
			catch(SecurityException se)
			{
				Log.log(Log.ERROR,jEdit.class,se);
			}
		}
	}
	

	
	
	public static boolean isStartupDone()
	{
		return (! startupDone.contains(false));
	} 

	
	
	public static boolean isMainThread()
	{
		return Thread.currentThread() == mainThread;
	} 

	
	
	public static boolean isBackgroundModeEnabled()
	{
		return background;
	} 

	
	
	public static void showMemoryDialog(View view)
	{
		Runtime rt = Runtime.getRuntime();
		long usedBefore = rt.totalMemory() - rt.freeMemory();
		System.gc();
		long free = rt.freeMemory();
		long total = rt.totalMemory();
		long used = total - free;

		int totalKb = (int) (total / 1024);
		int usedKb = (int) (used / 1024);
		JProgressBar progress = new JProgressBar(0,totalKb);
		progress.setValue(usedKb);
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""memory-status.use"",
			new Object[] { usedKb, totalKb }));

		Object[] message = new Object[4];
		message[0] = getProperty(""memory-status.gc"",
			new Object[] { (usedBefore - used) / 1024 });
		message[1] = Box.createVerticalStrut(12);
		message[2] = progress;
		message[3] = Box.createVerticalStrut(6);

		JOptionPane.showMessageDialog(view,message,
			jEdit.getProperty(""memory-status.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static String getJEditHome()
	{
		return jEditHome;
	} 

	
	
	public static String getSettingsDirectory()
	{
		return settingsDirectory;
	} 

	
	
	public static String getJARCacheDirectory()
	{
		return jarCacheDirectory;
	} 

	
	
	public static void backupSettingsFile(File file)
	{
		if(settingsDirectory == null || !file.exists())
			return;

		String backupDir = MiscUtilities.constructPath(
			settingsDirectory,""settings-backup"");
		File dir = new File(backupDir);
		if(!dir.exists())
			dir.mkdirs();

		
		

		MiscUtilities.saveBackup(file,5,null,""~"",backupDir);
	} 

	
	
	public static void saveSettings()
	{
		if(settingsDirectory == null)
			return;

		Abbrevs.save();
		FavoritesVFS.saveFavorites();
		HistoryModel.saveHistory();
		Registers.saveRegisters();
		SearchAndReplace.save();
		BufferHistory.save();
		KillRing.getInstance().save();

		File file1 = new File(MiscUtilities.constructPath(
			settingsDirectory,""#properties#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			settingsDirectory,""properties""));
		if(file2.exists() && file2.lastModified() != propsModTime)
		{
			Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
				+ "" on disk; will not save user properties"");
		}
		else
		{
			backupSettingsFile(file2);
			OutputStream out = null;
			try
			{
				out = new FileOutputStream(file1);
				propMgr.saveUserProps(out);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,io);
			}
			finally
			{
				IOUtilities.closeQuietly(out);
			}
			file2.delete();
			if (! file1.renameTo(file2))
			{
				Log.log(Log.ERROR,jEdit.class,""Failed to rename \"""" + file1 +
					""\"" to the user properties file \"""" + file2 + ""\""."");
			}
			propsModTime = file2.lastModified();
		}
	} 

	
	
	@Deprecated
	public static TextArea createTextArea()
	{
		return new JEditEmbeddedTextArea();
	} 

	
	
	public static void exit(View view, boolean reallyExit)
	{
		
		if(view == null)
			view = activeView;

		
		VFSManager.waitForRequests();

		
		EditorExitRequested eer = new EditorExitRequested(view);

		
		EditBus.send(eer);

		
		
		if (eer.hasBeenExitCancelled())
		{
			Log.log(Log.MESSAGE, jEdit.class, ""Exit has been cancelled"");
			return;
		}

		
		
		reallyExit |= !background;

		PerspectiveManager.savePerspective(false);

		try
		{
			PerspectiveManager.setPerspectiveEnabled(false);

			
			if(!closeAllBuffers(view,reallyExit))
				return;
		}
		finally
		{
			PerspectiveManager.setPerspectiveEnabled(true);
		}

		
		
		if(!reallyExit)
		{
			
			
			
			view = viewsFirst;
			while(view != null)
			{
				closeView(view,false);
				view = view.next;
			}

			
			
			saveSettings();
		}
		else
		{

			
			EditBus.send(new EditorExiting(null));

			
			if(view != null)
			{
				view.close();
				removeViewFromList(view);
			}

			
			Autosave.stop();

			
			if(server != null)
				server.stopServer();

			
			PluginJAR[] plugins = getPluginJARs();
			for(int i = 0; i < plugins.length; i++)
			{
				removePluginJAR(plugins[i],true);
			}


			
			saveSettings();

			
			Log.closeStream();

			
			System.exit(0);
		}
	} 

	
	
	public static EditServer getEditServer()
	{
		return server;
	} 

	
	
	public static void visit(JEditVisitor visitor)
	{
		View view = jEdit.getFirstView();
		while (view != null)
		{
			visitor.visit(view);
			view.visit(visitor);
			view = view.getNext();
		}
	} 

	
	
	public static String getRegisterStatusPrompt(String action)
	{
		String registerNameString = Registers.getRegisterNameString();
		return jEdit.getProperty(""view.status."" + action,
			new String[] {registerNameString == null ?
				      jEdit.getProperty(""view.status.no-registers"") :
				      registerNameString});
	} 

	

	

	
	
	static void updatePosition(String oldPath, Buffer buffer)
	{
		if((VFSManager.getVFSForPath(oldPath).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			oldPath = oldPath.toLowerCase();
		}

		bufferHash.remove(oldPath);

		String path = buffer.getSymlinkPath();
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
		}

		bufferHash.put(path,buffer);

		if(sortBuffers)
		{
			removeBufferFromList(buffer);
			addBufferToList(buffer);
		}
	} 

	
	
	 static void loadMode(Mode mode)
	{
		final String fileName = (String)mode.getProperty(""file"");
		XModeHandler xmh = new XModeHandler(mode.getName())
		{
			@Override
			public void error(String what, Object subst)
			{
				String msg;

				Object line = ""<unknown>"";
				if(subst == null)
					msg = jEdit.getProperty(""xmode-error."" + what);
				else
				{
					msg = jEdit.getProperty(""xmode-error."" + what,
						new String[] { subst.toString() });
					if(subst instanceof Throwable)
						Log.log(Log.ERROR,this,subst);
					if (subst instanceof SAXParseException)
					{
						line = ((SAXParseException)subst).getLineNumber();
					}
				}

				Object[] args = { fileName, line, null, msg };
				GUIUtilities.error(null,""xmode-error"",args);
			}

			@Override
			public TokenMarker getTokenMarker(String modeName)
			{
				Mode mode = getMode(modeName);
				if(mode == null)
					return null;
				else
					return mode.getTokenMarker();
			}
		};
		ModeProvider.instance.loadMode(mode, xmh);
	} 

	
	static void addPluginProps(Properties map)
	{
		propMgr.addPluginProps(map);
	} 

	
	static void removePluginProps(Properties map)
	{
		propMgr.removePluginProps(map);
	} 

	
	
	static void pluginError(String path, String messageProp,
		Object[] args)
	{
		synchronized(pluginErrorLock)
		{
			if(pluginErrors == null)
				pluginErrors = new Vector<ErrorListDialog.ErrorEntry>();

			ErrorListDialog.ErrorEntry newEntry =
				new ErrorListDialog.ErrorEntry(
				path,messageProp,args);

			for(int i = 0; i < pluginErrors.size(); i++)
			{
				if(pluginErrors.get(i).equals(newEntry))
					return;
			}
			pluginErrors.addElement(newEntry);

			if(isStartupDone())
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						showPluginErrorDialog();
					}
				});
			}
		}
	} 

	
	static void setActiveView(View view)
	{
		jEdit.activeView = view;
	} 

	
	
	public static View getActiveViewInternal()
	{
		return activeView;
	} 

	

	

	
	private static String jEditHome;
	private static String settingsDirectory;
	private static String jarCacheDirectory;
	private static long propsModTime;
	private static PropertyManager propMgr;
	private static EditServer server;
	private static boolean background;
	private static ActionContext actionContext;
	private static ActionSet builtInActionSet;
	private static Vector<ErrorListDialog.ErrorEntry> pluginErrors;
	private static final Object pluginErrorLock = new Object();
	private static Vector<PluginJAR> jars;

	private static boolean saveCaret;
	private static InputHandler inputHandler;

	private static BufferSet globalBufferSet;
	private static BufferSetManager bufferSetManager;

	
	private static boolean sortBuffers;
	private static boolean sortByName;
	private static int bufferCount;
	private static Buffer buffersFirst;
	private static Buffer buffersLast;
	private static Map<String, Buffer> bufferHash;

	
	private static final Object bufferListLock = new Object();

	private static final Object editBusOrderingLock	= new Object();

	
	private static int viewCount;
	private static View viewsFirst;
	private static View viewsLast;
	private static View activeView;

	private static Vector<Boolean> startupDone = new Vector<Boolean>();

	private static Thread mainThread;
	

	private jEdit() {}

	
	private static void usage()
	{
		System.out.println(""Usage: jedit [<options>] [<files>]"");

		System.out.println(""	<file> +marker:<marker>: Positions caret""
			+ "" at marker <marker>"");
		System.out.println(""	<file> +line:<line>: Positions caret""
			+ "" at line number <line>"");
		System.out.println(""	<file> +line:<line>,<column>: Positions caret""
			+ "" at line number <line> and column number <column>"");
		System.out.println(""	--: End of options"");
		System.out.println(""	-background: Run in background mode"");
		System.out.println(""	-nobackground: Disable background mode (default)"");
		System.out.println(""	-gui: Only if running in background mode; open initial view (default)"");
		System.out.println(""	-nogui: Only if running in background mode; don't open initial view"");
		System.out.println(""	-log=<level>: Log messages with level equal to or higher than this to"");
		System.out.println(""	 standard error. <level> must be between 1 and 9. Default is 7."");
		System.out.println(""	-newplainview: Client instance opens a new plain view"");
		System.out.println(""	-newview: Client instance opens a new view (default)"");
		System.out.println(""	-plugins: Load plugins (default)"");
		System.out.println(""	-noplugins: Don't load any plugins"");
		System.out.println(""	-restore: Restore previously open files (default)"");
		System.out.println(""	-norestore: Don't restore previously open files"");
		System.out.println(""	-reuseview: Client instance reuses existing view"");
		System.out.println(""	-quit: Quit a running instance"");
		System.out.println(""	-run=<script>: Run the specified BeanShell script"");
		System.out.println(""	-server: Read/write server info from/to $HOME/.jedit/server (default)"");
		System.out.println(""	-server=<name>: Read/write server info from/to $HOME/.jedit/<name>"");
		System.out.println(""	-noserver: Don't start edit server"");
		System.out.println(""	-settings=<path>: Load user-specific settings from <path>"");
		System.out.println(""	-nosettings: Don't load user-specific settings"");
		System.out.println(""	-startupscripts: Run startup scripts (default)"");
		System.out.println(""	-nostartupscripts: Don't run startup scripts"");
		System.out.println(""	-usage: Print this message and exit"");
		System.out.println(""	-version: Print jEdit version and exit"");
		System.out.println(""	-wait: Wait until the user closes the specified buffer in the server"");
		System.out.println(""	 instance. Does nothing if passed to the initial jEdit instance."");
		System.out.println();
		System.out.println(""Report bugs to http:
	} 

	
	private static void version()
	{
		System.out.println(""jEdit "" + getVersion());
	} 

	
	
	private static String makeServerScript(boolean wait,
		boolean restore, boolean newView,
		boolean newPlainView, String[] args,
		String scriptFile)
	{
		StringBuilder script = new StringBuilder();

		String userDir = System.getProperty(""user.dir"");

		script.append(""parent = \"""");
		script.append(StandardUtilities.charsToEscapes(userDir));
		script.append(""\"";\n"");

		script.append(""args = new String["");
		script.append(args.length);
		script.append(""];\n"");

		for(int i = 0; i < args.length; i++)
		{
			script.append(""args["");
			script.append(i);
			script.append(""] = "");

			if(args[i] == null)
				script.append(""null"");
			else
			{
				script.append('""');
				script.append(StandardUtilities.charsToEscapes(args[i]));
				script.append('""');
			}

			script.append("";\n"");
		}

		script.append(""view = jEdit.getLastView();\n"");
		script.append(""buffer = EditServer.handleClient("");
		script.append(restore).append(',').append(newView).append(',').append(newPlainView);
		script.append("",parent,args);\n"");
		script.append(""if(buffer != null && "").append(wait).append("") {\n"");
		script.append(""\tbuffer.setWaitSocket(socket);\n"");
		script.append(""\tdoNotCloseSocket = true;\n"");
		script.append(""}\n"");
		script.append(""if(view != jEdit.getLastView() && "").append(wait).append("") {\n"");
		script.append(""\tjEdit.getLastView().setWaitSocket(socket);\n"");
		script.append(""\tdoNotCloseSocket = true;\n"");
		script.append(""}\n"");
		script.append(""if(doNotCloseSocket == void)\n"");
		script.append(""\tsocket.close();\n"");

		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			script.append(""BeanShell.runScript(view,\"""")
				.append(StandardUtilities.charsToEscapes(scriptFile))
				.append(""\"",null,this.namespace);\n"");
		}

		return script.toString();
	} 

	
	
	private static void initMisc()
	{
		ModeProvider.instance = new ModeProvider()
		{
			@Override
			protected void error(String fileName, Throwable e)
			{
				Log.log(Log.ERROR, this, e);
				if (e instanceof SAXParseException)
				{
					String message = e.getMessage();
					int line = ((SAXParseException)e).getLineNumber();
					int col = ((SAXParseException)e).getColumnNumber();

					Object[] args = { fileName, line, col, message };
					GUIUtilities.error(null,""xmode-error"",args);
				}
			}
		};
		jars = new Vector<PluginJAR>();
		FoldHandler.foldHandlerProvider = new ServiceManager.ServiceFoldHandlerProvider();
		actionContext = new ActionContext()
		{
			@Override
			public void invokeAction(EventObject evt,
				EditAction action)
			{
				View view = GUIUtilities.getView(
					(Component)evt.getSource());

				boolean actionBarVisible;
				if(view.getActionBar() == null
					|| !view.getActionBar().isShowing())
					actionBarVisible = false;
				else
				{
					actionBarVisible = view.getActionBar()
						.isVisible();
				}

				view.getInputHandler().invokeAction(action);

				if(actionBarVisible)
				{
					
					ActionBar actionBar = view
						.getActionBar();
					if(actionBar != null)
						view.removeToolBar(actionBar);
				}
			}
		};

		bufferHash = new HashMap<String, Buffer>();

		inputHandler = new DefaultInputHandler(null);
		
		System.getProperties().put(""java.protocol.handler.pkgs"",
			""org.gjt.sp.jedit.proto|"" +
			System.getProperty(""java.protocol.handler.pkgs"",""""));

		
		String userAgent = ""jEdit/"" + getVersion()
			+ "" (Java "" + System.getProperty(""java.version"")
			+ "". "" + System.getProperty(""java.vendor"")
			+ ""; "" + System.getProperty(""os.arch"") + ')';
		System.getProperties().put(""http.agent"",userAgent);

		
		jEditHome = System.getProperty(""jedit.home"");
		if(jEditHome == null)
		{
			String classpath = System
				.getProperty(""java.class.path"");
			int index = classpath.toLowerCase()
				.indexOf(""jedit.jar"");
			int start = classpath.lastIndexOf(File
				.pathSeparator,index) + 1;
			
			if(start == index)
			{
				jEditHome = System.getProperty(""user.dir"");
			}
			else if(index > start)
			{
				jEditHome = classpath.substring(start,
					index - 1);
			}
			else
			{
				
				
				{
					
					jEditHome = System.getProperty(""user.dir"");

					Log.log(Log.WARNING,jEdit.class,""jedit.jar not in class path!"");
					Log.log(Log.WARNING,jEdit.class,""Assuming jEdit is installed in ""
						+ jEditHome + '.');
					Log.log(Log.WARNING,jEdit.class,""Override with jedit.home ""
						+ ""system property."");
				}
			}
		}

		jEditHome = MiscUtilities.resolveSymlinks(jEditHome);

		Log.log(Log.MESSAGE,jEdit.class,""jEdit home directory is "" + jEditHome);

		if(settingsDirectory != null)
		{
			jarCacheDirectory = MiscUtilities.constructPath(
				settingsDirectory,""jars-cache"");
			new File(jarCacheDirectory).mkdirs();
		}

		
		

		
		
		EditBus.addToBus(new SettingsReloader());

		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				Thread.currentThread().setContextClassLoader(
					new JARClassLoader());
			}
		});
		
		
		
		Thread.currentThread().setContextClassLoader(new JARClassLoader());
	} 

	
	
	private static void initSystemProperties()
	{
		propMgr = new PropertyManager();

		try
		{
			propMgr.loadSystemProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit.props""));
			propMgr.loadSystemProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_gui.props""));
			propMgr.loadSystemProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_keys.props""));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,
				""Error while loading system properties!"");
			Log.log(Log.ERROR,jEdit.class,
				""One of the following property files could not be loaded:\n""
				+ ""- jedit.props\n""
				+ ""- jedit_gui.props\n""
				+ ""- jedit_keys.props\n""
				+ ""jedit.jar is probably corrupt."");
			Log.log(Log.ERROR,jEdit.class,e);
			System.exit(1);
		}
	} 

	
	
	private static void initSiteProperties()
	{
		
		

		String siteSettingsDirectory = MiscUtilities.constructPath(
			jEditHome, ""properties"");
		File siteSettings = new File(siteSettingsDirectory);

		if (!(siteSettings.exists() && siteSettings.isDirectory()))
			return;

		String[] snippets = siteSettings.list();
		if (snippets == null)
			return;

		Arrays.sort(snippets,
			new StandardUtilities.StringCompare<String>(true));

		for (int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".props""))
				continue;

			try
			{
				String path = MiscUtilities.constructPath(
					siteSettingsDirectory,snippet);
				Log.log(Log.DEBUG,jEdit.class,
					""Loading site snippet: "" + path);

				propMgr.loadSiteProps(new FileInputStream(new File(path)));
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load site snippet ""
					+ snippet);
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	private static void initResources()
	{
		builtInActionSet = new ActionSet(null,null,null,
			jEdit.class.getResource(""actions.xml""));
		builtInActionSet.setLabel(getProperty(""action-set.jEdit""));
		builtInActionSet.load();

		actionContext.addActionSet(builtInActionSet);

		DockableWindowFactory.getInstance()
			.loadDockableWindows(null,
			jEdit.class.getResource(""dockables.xml""),
			null);

		ServiceManager.loadServices(null,
			jEdit.class.getResource(""services.xml""),
			null);
	} 

	
	
	private static void initPlugins()
	{
		if(jEditHome != null)
		{
			addPluginJARsFromDirectory(MiscUtilities.constructPath(
				jEditHome,""jars""));
		}

		if(settingsDirectory != null)
		{
			File jarsDirectory = new File(settingsDirectory,""jars"");
			if(!jarsDirectory.exists())
				jarsDirectory.mkdir();
			addPluginJARsFromDirectory(jarsDirectory.getPath());
		}

		PluginJAR[] jars = getPluginJARs();
		for(int i = 0; i < jars.length; i++)
		{
			jars[i].checkDependencies();
		}
	} 

	
	
	private static void initUserProperties()
	{
		if(settingsDirectory != null)
		{
			File file = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			propsModTime = file.lastModified();

			try
			{
				propMgr.loadUserProps(
					new FileInputStream(file));
			}
			catch(FileNotFoundException fnf)
			{
				
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	private static String fontStyleToString(int style)
	{
		if(style == 0)
			return ""PLAIN"";
		else if(style == Font.BOLD)
			return ""BOLD"";
		else if(style == Font.ITALIC)
			return ""ITALIC"";
		else if(style == (Font.BOLD | Font.ITALIC))
			return ""BOLDITALIC"";
		else
			throw new RuntimeException(""Invalid style: "" + style);
	} 

	
	private static String fontToString(Font font)
	{
		return font.getFamily()
			+ '-'
			+ fontStyleToString(font.getStyle())
			+ '-'
			+ font.getSize();
	} 

	
	
	private static void initPLAF()
	{
		Font primaryFont = jEdit.getFontProperty(
			""metal.primary.font"");
		if(primaryFont != null)
		{
			String primaryFontString =
				fontToString(primaryFont);

			System.getProperties().put(
				""swing.plaf.metal.controlFont"",
				primaryFontString);
			System.getProperties().put(
				""swing.plaf.metal.menuFont"",
				primaryFontString);
		}

		Font secondaryFont = jEdit.getFontProperty(
			""metal.secondary.font"");
		if(secondaryFont != null)
		{
			String secondaryFontString =
				fontToString(secondaryFont);

			System.getProperties().put(
				""swing.plaf.metal.systemFont"",
				secondaryFontString);
			System.getProperties().put(
				""swing.plaf.metal.userFont"",
				secondaryFontString);
		}

		try
		{
			String lf = getProperty(""lookAndFeel"");
			if(lf != null && lf.length() != 0)
				UIManager.setLookAndFeel(lf);
			else if(OperatingSystem.isMacOS())
			{
				UIManager.setLookAndFeel(UIManager
					.getSystemLookAndFeelClassName());
			}
			else
			{
				UIManager.setLookAndFeel(UIManager
					.getCrossPlatformLookAndFeelClassName());
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		UIDefaults defaults = UIManager.getDefaults();

		
		if(jEdit.getBooleanProperty(""textColors""))
		{
			Color background = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.bgColor""));
			Color foreground = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.fgColor""));
			Color caretColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.caretColor""));
			Color selectionColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.selectionColor""));

			String[] prefixes = { ""PasswordField"", ""TextField"", ""TextArea"", ""List"", ""Table"" };
			for(int i = 0; i < prefixes.length; i++)
			{
				String prefix = prefixes[i];
				defaults.put(prefix + "".foreground"",foreground);
				defaults.put(prefix + "".background"",background);
				defaults.put(prefix + "".disabledForeground"",foreground);
				defaults.put(prefix + "".disabledBackground"",background);
				defaults.put(prefix + "".caretForeground"",caretColor);
				defaults.put(prefix + "".selectionForeground"",foreground);
				defaults.put(prefix + "".selectionBackground"",selectionColor);
			}

			defaults.put(""ComboBox.foreground"",foreground);
			defaults.put(""ComboBox.background"",background);
			defaults.put(""ComboBox.disabledForeground"",foreground);
			defaults.put(""ComboBox.disabledBackground"",background);
			defaults.put(""ComboBox.selectedForeground"",foreground);
			defaults.put(""ComboBox.selectedBackground"",selectionColor);

			defaults.put(""Tree.background"",background);
			defaults.put(""Tree.foreground"",foreground);
			defaults.put(""Tree.textBackground"",background);
			defaults.put(""Tree.textForeground"",foreground);
			defaults.put(""Tree.selectionForeground"",foreground);
			defaults.put(""Tree.selectionBackground"",selectionColor);
		}

		defaults.remove(""SplitPane.border"");
		defaults.remove(""SplitPaneDivider.border"");

		JFrame.setDefaultLookAndFeelDecorated(
			getBooleanProperty(""decorate.frames""));
		JDialog.setDefaultLookAndFeelDecorated(
			getBooleanProperty(""decorate.dialogs""));

		KeyboardFocusManager.setCurrentKeyboardFocusManager(
			new MyFocusManager());
	} 

	
	public static int getNextUntitledBufferId()
	{
		int untitledCount = 0;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.getName().startsWith(""Untitled-""))
			{
				try
				{
					untitledCount = Math.max(untitledCount,
						Integer.parseInt(buffer.getName()
						.substring(9)));
				}
				catch(NumberFormatException nf)
				{
				}
			}
			buffer = buffer.next;
		}
		return untitledCount + 1;
	} 

	
	
	private static void runStartupScripts(File directory)
	{
		if (!directory.isDirectory())
			return;

		File[] snippets = directory.listFiles();
		if (snippets == null)
			return;

		Arrays.sort(snippets,
			new StandardUtilities.StringCompare<File>(true));

		
		String defaultEncoding = getProperty(""buffer.encoding"");
		setProperty(""buffer.encoding"", ""UTF-8"");

		for(int i = 0; i < snippets.length; ++i)
		{
			File snippet = snippets[i];

			Macros.Handler handler = Macros.getHandlerForPathName(
				snippet.getPath());
			if(handler == null)
				continue;

			try
			{
				Macros.Macro newMacro = handler.createMacro(
					snippet.getName(),
					snippet.getPath());
				handler.runMacro(null,newMacro,false);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}

		setProperty(""buffer.encoding"", defaultEncoding);
	} 

	
	private static void initProxy()
	{
		boolean socksEnabled = jEdit.getBooleanProperty(""socks.enabled"");
		if(!socksEnabled)
		{
			Log.log(Log.DEBUG,jEdit.class,""SOCKS proxy disabled"");
			System.getProperties().remove(""socksProxyHost"");
			System.getProperties().remove(""socksProxyPort"");
		}
		else
		{
			String socksHost = jEdit.getProperty(""firewall.socks.host"");
			if( socksHost != null )
			{
				System.setProperty(""socksProxyHost"", socksHost);
				Log.log(Log.DEBUG, jEdit.class,
					""SOCKS proxy enabled: "" + socksHost);
			}

			String socksPort = jEdit.getProperty(""firewall.socks.port"");
			if(socksPort != null)
				System.setProperty(""socksProxyPort"", socksPort);
		}

		boolean httpEnabled = jEdit.getBooleanProperty(""firewall.enabled"");
		if (!httpEnabled)
		{
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy disabled"");
			System.getProperties().remove(""proxySet"");
			System.getProperties().remove(""proxyHost"");
			System.getProperties().remove(""proxyPort"");
			System.getProperties().remove(""http.proxyHost"");
			System.getProperties().remove(""http.proxyPort"");
			System.getProperties().remove(""http.nonProxyHosts"");
			Authenticator.setDefault(null);
		}
		else
		{
			
			String host = jEdit.getProperty(""firewall.host"");
			if (host == null)
				return;

			System.setProperty(""http.proxyHost"", host);
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy enabled: "" + host);
			
			String port = jEdit.getProperty(""firewall.port"");
			if (port != null)
				System.setProperty(""http.proxyPort"", port);

			
			String nonProxyHosts = jEdit.getProperty(""firewall.nonProxyHosts"");
			if (nonProxyHosts != null)
				System.setProperty(""http.nonProxyHosts"", nonProxyHosts);

			
			String username = jEdit.getProperty(""firewall.user"");
			String password = jEdit.getProperty(""firewall.password"");

			
			if(password == null)
				password = """";

			if(username == null || username.length()==0)
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy without user"");
				Authenticator.setDefault(new FirewallAuthenticator(null));
			}
			else
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy user: "" + username);
				PasswordAuthentication pw = new PasswordAuthentication(
					username,password.toCharArray()
				);
				Authenticator.setDefault(new FirewallAuthenticator(pw));
			}
		}
	} 

	
	static class FirewallAuthenticator extends Authenticator
	{
		PasswordAuthentication pw;

		FirewallAuthenticator(PasswordAuthentication pw)
		{
			this.pw = pw;
		}

		@Override
		protected PasswordAuthentication getPasswordAuthentication()
		{
			return pw;
		}
	} 

	
	private static void finishStartup(final boolean gui, final boolean restore,
		final boolean newPlainView, final String userDir, final String[] args)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				int count = getBufferCount();

				boolean restoreFiles = restore
					&& jEdit.getBooleanProperty(""restore"")
					&& (count == 0 ||
					jEdit.getBooleanProperty(""restore.cli""));

				if(gui || count != 0)
				{
					View view;
					if (newPlainView)
						view = newView(null,null,true);
					else
						view = PerspectiveManager.loadPerspective(restoreFiles);

					if(view == null)
						view = newView(null,null);

					Buffer buffer = openFiles(null,userDir,args);
					if(buffer != null)
						view.setBuffer(buffer,true);
				}
				else
				{
					openFiles(null,userDir,args);
				}

				
				EditBus.send(new EditorStarted(null));

				VFSManager.start();

				
				if(server != null)
					server.start();

				GUIUtilities.hideSplashScreen();

				Log.log(Log.MESSAGE,jEdit.class,""Startup ""
					+ ""complete"");

				
				if(pluginErrors != null)
				{
					showPluginErrorDialog();
				} 

				startupDone.set(0, true);

				
				
				
				
				Toolkit.getDefaultToolkit();
			}
		});
	} 

	
	private static void showPluginErrorDialog()
	{
		if(pluginErrors == null)
			return;

		String caption = getProperty(
			""plugin-error.caption"" + (pluginErrors.size() == 1
			? ""-1"" : """"));

		Frame frame = (PluginManager.getInstance() == null
			? viewsFirst
			: PluginManager.getInstance());

		new ErrorListDialog(frame,
			getProperty(""plugin-error.title""),
			caption,pluginErrors,true);
		pluginErrors = null;
	} 

	
	private static void getNotLoadedPluginJARs(List<String> returnValue,
		String dir, String[] list)
	{
loop:		for(int i = 0; i < list.length; i++)
		{
			String name = list[i];
			if(!name.toLowerCase().endsWith("".jar""))
				continue loop;

			String path = MiscUtilities.constructPath(dir,name);

			for(int j = 0; j < jars.size(); j++)
			{
				PluginJAR jar = jars.elementAt(j);
				String jarPath = jar.getPath();
				String jarName = MiscUtilities.getFileName(jarPath);

				if(path.equals(jarPath))
					continue loop;
				else if(!new File(jarPath).exists()
					&& name.equals(jarName))
					continue loop;
			}

			returnValue.add(path);
		}
	} 

	
	private static void gotoMarker(final View view, final Buffer buffer,
		final String marker)
	{
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				int pos;

				
				if(marker.startsWith(""+line:""))
				{
					try
					{
						String arg = marker.substring(6);
						String[] lineCol = arg.split("","");
						int line, col;
						if(lineCol.length > 1)
						{
							line = Integer.parseInt(lineCol[0]);
							col = Integer.parseInt(lineCol[1]);
						}
						else
						{
							line = Integer.parseInt(marker.substring(6));
							col = 1;
						}
						pos = buffer.getLineStartOffset(line - 1) + (col - 1);
					}
					catch(Exception e)
					{
						return;
					}
				}
				
				else if(marker.startsWith(""+marker:""))
				{
					if(marker.length() != 9)
						return;

					Marker m = buffer.getMarker(marker.charAt(8));
					if(m == null)
						return;
					pos = m.getPosition();
				}
				
				else
					throw new InternalError();

				if(view != null && view.getBuffer() == buffer)
				{
					view.getTextArea().setCaretPosition(pos);
					buffer.setIntegerProperty(Buffer.CARET,pos);
					buffer.setBooleanProperty(Buffer.CARET_POSITIONED,true);
				}
				else
				{
					buffer.setIntegerProperty(Buffer.CARET,pos);
					buffer.setBooleanProperty(Buffer.CARET_POSITIONED,true);
					buffer.unsetProperty(Buffer.SCROLL_VERT);
				}
			}
		});
	} 

	
	private static void addBufferToList(Buffer buffer)
	{
		synchronized(bufferListLock)
		{
			String symlinkPath = buffer.getSymlinkPath();
			if((VFSManager.getVFSForPath(symlinkPath).getCapabilities()
				& VFS.CASE_INSENSITIVE_CAP) != 0)
			{
				symlinkPath = symlinkPath.toLowerCase();
			}

			bufferCount++;

			bufferHash.put(symlinkPath,buffer);

			if(buffersFirst == null)
			{
				buffersFirst = buffersLast = buffer;
				return;
			}
			
			else if(sortBuffers)
			{
				String str11, str12;
				if(sortByName)
				{
					str11 = buffer.getName();
					str12 = buffer.getDirectory();
				}
				else
				{
					str11 = buffer.getDirectory();
					str12 = buffer.getName();
				}

				Buffer _buffer = buffersFirst;
				while(_buffer != null)
				{
					String str21, str22;
					if(sortByName)
					{
						str21 = _buffer.getName();
						str22 = _buffer.getDirectory();
					}
					else
					{
						str21 = _buffer.getDirectory();
						str22 = _buffer.getName();
					}

					int comp = StandardUtilities.compareStrings(str11,str21,true);
					if(comp < 0 || (comp == 0 && StandardUtilities.compareStrings(str12,str22,true) < 0))
					{
						buffer.next = _buffer;
						buffer.prev = _buffer.prev;
						_buffer.prev = buffer;
						if(_buffer != buffersFirst)
							buffer.prev.next = buffer;
						else
							buffersFirst = buffer;
						return;
					}

					_buffer = _buffer.next;
				}
			} 

			buffer.prev = buffersLast;
			
			
			buffer.next = null;
			buffersLast.next = buffer;
			buffersLast = buffer;
		}
	} 

	
	private static void removeBufferFromList(Buffer buffer)
	{
		synchronized(bufferListLock)
		{
			bufferCount--;

			String path = buffer.getPath();
			if(OperatingSystem.isCaseInsensitiveFS())
				path = path.toLowerCase();

			bufferHash.remove(path);

			if(buffer == buffersFirst && buffer == buffersLast)
			{
				buffersFirst = buffersLast = null;
				return;
			}

			if(buffer == buffersFirst)
			{
				buffersFirst = buffer.next;
				buffer.next.prev = null;
			}
			else
			{
				if (buffer.prev != null)
					buffer.prev.next = buffer.next;
			}

			if(buffer == buffersLast)
			{
				buffersLast = buffersLast.prev;
				buffer.prev.next = null;
			}
			else
			{
				if (buffer.next != null)
					buffer.next.prev = buffer.prev;
			}

			
			
			buffer.next = buffer.prev = null;
		}
	} 

	
	private static void addViewToList(View view)
	{
		viewCount++;

		if(viewsFirst == null)
			viewsFirst = viewsLast = view;
		else
		{
			view.prev = viewsLast;
			viewsLast.next = view;
			viewsLast = view;
		}
	} 

	
	private static void removeViewFromList(View view)
	{
		viewCount--;

		if(viewsFirst == viewsLast)
		{
			viewsFirst = viewsLast = null;
			return;
		}

		if(view == viewsFirst)
		{
			viewsFirst = view.next;
			view.next.prev = null;
		}
		else
		{
			view.prev.next = view.next;
		}

		if(view == viewsLast)
		{
			viewsLast = viewsLast.prev;
			view.prev.next = null;
		}
		else
		{
			view.next.prev = view.prev;
		}
	} 

	
	
	private static boolean closeView(View view, boolean callExit)
	{
		PerspectiveManager.setPerspectiveDirty(true);

		if(viewsFirst == viewsLast && callExit)
		{
			exit(view,false); 
			
			return false;
		}
		else
		{
			if (!view.confirmToCloseDirty())
				return false;

			view.close();
			view.dispose();
			removeViewFromList(view);

			if(view == activeView)
				activeView = null;

			return true;
		}
	} 

	
	
	private static void loadModeCatalog(String path, boolean resource)
	{
		Log.log(Log.MESSAGE,jEdit.class,""Loading mode catalog file "" + path);

		ModeCatalogHandler handler = new ModeCatalogHandler(
			MiscUtilities.getParentOfPath(path),resource)
		{
			@Override
			protected Mode instantiateMode(String modeName)
			{
				return new JEditMode(modeName);
			}
		};
		try
		{
			InputStream _in;
			if(resource)
				_in = jEdit.class.getResourceAsStream(path);
			else
				_in = new FileInputStream(path);
			XMLUtilities.parseXML(_in, handler);
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
	} 

	
	
	private static void initKeyBindings()
	{
		inputHandler.removeAllKeyBindings();

		ActionSet[] actionSets = getActionSets();
		for (int i = 0; i < actionSets.length; i++)
		{
			actionSets[i].initKeyBindings();
		}
	} 

	
	
	private static void composeBufferPropsFromHistory(Map props, String path)
	{
		BufferHistory.Entry entry = BufferHistory.getEntry(path);

		if(entry != null && saveCaret && props.get(Buffer.CARET) == null)
		{
			props.put(Buffer.CARET, entry.caret);
			
		}

		if(entry != null && props.get(JEditBuffer.ENCODING) == null)
		{
			if(entry.encoding != null)
				props.put(JEditBuffer.ENCODING,entry.encoding);
		}

		if (entry != null && props.get(""mode"") == null)
		{
			if (entry.mode != null)
				props.put(""mode"", entry.mode);
		}
	} 

	

	
	private static class MyFocusManager extends DefaultKeyboardFocusManager
	{
		MyFocusManager()
		{
			setDefaultFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		}

		@Override
		public boolean postProcessKeyEvent(KeyEvent evt)
		{
			if(!evt.isConsumed())
			{
				Component comp = (Component)evt.getSource();
				if(!comp.isShowing())
					return true;

				for(;;)
				{
					if(comp instanceof View)
					{
						((View)comp).getInputHandler().processKeyEvent(evt,
							View.VIEW, false);
						return true;
					}
					else if(comp == null || comp instanceof Window
						|| comp instanceof JEditTextArea)
					{
						if (comp instanceof PluginManager)
						{
							evt.setSource(comp);
							((PluginManager)comp).processKeyEvents(evt);
						}
						break;
					}
					else
						comp = comp.getParent();
				}
			}

			return super.postProcessKeyEvent(evt);
		}
	} 

	
	public static class JEditPropertyManager implements IPropertyManager
	{
		public String getProperty(String name)
		{
			return jEdit.getProperty(name);
		}
	} 

	
	private static class DockingLayoutSetter implements Runnable
	{
		private View view;
		private ViewConfig config;
		private int startupDoneIndex;

		DockingLayoutSetter(View view, ViewConfig config, int startupDoneIndex)
		{
			this.view = view;
			this.config = config;
			this.startupDoneIndex = startupDoneIndex;
		}

		public void run()
		{
			DockableWindowManager wm = view.getDockableWindowManager();
			wm.setDockingLayout(config.docking);
			startupDone.set(startupDoneIndex, true);
		}
	} 

	private static final JEditPropertyManager propertyManager = new JEditPropertyManager();
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.MultiSelectWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,1,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.textarea.JEditTextArea;



public class MultiSelectWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view)
	{
		Widget multiSelect = new MultiSelectWidget(view);
		return multiSelect;
	} 

	
	private static class MultiSelectWidget implements Widget
	{
		private final JLabel multiSelect;
		private final View view;
		MultiSelectWidget(final View view)
		{
			multiSelect = new ToolTipLabel();
			multiSelect.setHorizontalAlignment(SwingConstants.CENTER);
			multiSelect.setToolTipText(jEdit.getProperty(""view.status.multi-tooltip""));
			this.view = view;
			multiSelect.addMouseListener(new MouseAdapter()
						     {
							     @Override
							     public void mouseClicked(MouseEvent e)
							     {
								     JEditTextArea textArea = view.getTextArea();
								     if (textArea != null)
									     textArea.toggleMultipleSelectionEnabled();
							     }
						     });
		}

		public JComponent getComponent()
		{
			return multiSelect;
		}

		public void update()
		{
			JEditTextArea textArea = view.getTextArea();
			if (textArea != null)
			{
				multiSelect.setText(textArea.isMultipleSelectionEnabled()
						    ? ""M"" : ""-"");
			}
		}

		public void propertiesChanged()
		{
			
			Font font = new JLabel().getFont();
			
			FontMetrics fm = multiSelect.getFontMetrics(font);
			Dimension dim = new Dimension(
						      Math.max(fm.charWidth('-'),fm.charWidth('M')) + 1,
						      fm.getHeight());
			multiSelect.setPreferredSize(dim);
			multiSelect.setMaximumSize(dim);
		}
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.Types,13,1,0,17,38,72,13,7,2,1.008333333,644,0.0,2,0.0,0.208333333,0,0,47.76923077,33,5.0769,0,"

package org.gjt.sp.jedit.bsh;


class Types 
{
	
	static final int CAST=0, ASSIGNMENT=1;
	
	static final int 
		JAVA_BASE_ASSIGNABLE = 1,
		JAVA_BOX_TYPES_ASSIGABLE = 2,
		JAVA_VARARGS_ASSIGNABLE = 3,
		BSH_ASSIGNABLE = 4;

	static final int
		FIRST_ROUND_ASSIGNABLE = JAVA_BASE_ASSIGNABLE,
		LAST_ROUND_ASSIGNABLE = BSH_ASSIGNABLE;

	
	static Primitive VALID_CAST = new Primitive(1);
	static Primitive INVALID_CAST = new Primitive(-1);

	
    public static Class[] getTypes( Object[] args )
    {
        if ( args == null )
            return new Class[0];

        Class[] types = new Class[ args.length ];

        for( int i=0; i<args.length; i++ )
        {
			if ( args[i] == null )
				types[i] = null;
            else
			if ( args[i] instanceof Primitive )
                types[i] = ((Primitive)args[i]).getType();
            else
                types[i] = args[i].getClass();
        }

        return types;
    }

	
	
	static boolean isSignatureAssignable( Class[] from, Class[] to, int round )
	{
		if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )
			return false;

		switch ( round )
		{
			case JAVA_BASE_ASSIGNABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isJavaBaseAssignable( to[i], from[i] ) )
						return false;
				return true;
			case JAVA_BOX_TYPES_ASSIGABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )
						return false;
				return true;
			case JAVA_VARARGS_ASSIGNABLE:
				return isSignatureVarargsAssignable( from, to );
			case BSH_ASSIGNABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isBshAssignable( to[i], from[i] ) )
						return false;
				return true;
			default:
				throw new InterpreterError(""bad case"");
		}
	}

	private static boolean isSignatureVarargsAssignable(
		Class[] from, Class[] to )
	{
		return false;
	}

	
	static boolean isJavaAssignable( Class lhsType, Class rhsType ) {
		return isJavaBaseAssignable( lhsType, rhsType )
			|| isJavaBoxTypesAssignable( lhsType, rhsType );
	}

	
	static boolean isJavaBaseAssignable( Class lhsType, Class rhsType )
	{
		
		if ( lhsType == null )
			return false;

		
		
		if ( rhsType == null )
			return !lhsType.isPrimitive();

		if ( lhsType.isPrimitive() && rhsType.isPrimitive() )
		{
			if ( lhsType == rhsType )
				return true;

			
			if ( (rhsType == Byte.TYPE) &&
				(lhsType == Short.TYPE || lhsType == Integer.TYPE
				|| lhsType == Long.TYPE || lhsType == Float.TYPE
				|| lhsType == Double.TYPE))
                    return true;

            if ( (rhsType == Short.TYPE) &&
				(lhsType == Integer.TYPE || lhsType == Long.TYPE ||
                lhsType == Float.TYPE || lhsType == Double.TYPE))
                    return true;

            if ((rhsType == Character.TYPE) &&
				(lhsType == Integer.TYPE || lhsType == Long.TYPE ||
                lhsType == Float.TYPE || lhsType == Double.TYPE))
                    return true;

            if ((rhsType == Integer.TYPE) &&
				(lhsType == Long.TYPE || lhsType == Float.TYPE ||
                lhsType == Double.TYPE))
                    return true;

            if ((rhsType == Long.TYPE) &&
				(lhsType == Float.TYPE || lhsType == Double.TYPE))
                return true;

            if ((rhsType == Float.TYPE) && (lhsType == Double.TYPE))
                return true;
        }
        else
            if ( lhsType.isAssignableFrom(rhsType) )
                return true;

        return false;
    }

	
	static boolean isJavaBoxTypesAssignable(
		Class lhsType, Class rhsType )
	{
		
		if ( lhsType == null )
			return false;

		
		if ( lhsType == Object.class )
			return true;

		
		if ( lhsType == Number.class
			&& rhsType != Character.TYPE
			&& rhsType != Boolean.TYPE
		)
			return true;

		
		
		
		
		if ( Primitive.wrapperMap.get( lhsType ) == rhsType )
			return true;

		return false;
	}

	
	static boolean isBshAssignable( Class toType, Class fromType )
	{
		try {
			return castObject(
				toType, fromType, null,
				ASSIGNMENT, true
			) == VALID_CAST;
		} catch ( UtilEvalError e ) {
			
			throw new InterpreterError(""err in cast check: ""+e);
		}
	}

	
	public static Object castObject(
		Object fromValue, Class toType, int operation )
		throws UtilEvalError
	{
		if ( fromValue == null )
			throw new InterpreterError(""null fromValue"");

		Class fromType =
			fromValue instanceof Primitive ?
				((Primitive)fromValue).getType()
				: fromValue.getClass();

		return castObject(
			toType, fromType, fromValue, operation, false );
	}

	
	
	private static Object castObject(
		Class toType, Class fromType, Object fromValue,
		int operation, boolean checkOnly )
		throws UtilEvalError
	{
		
		if ( checkOnly && fromValue != null )
			throw new InterpreterError(""bad cast params 1"");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError(""bad cast params 2"");
		if ( fromType == Primitive.class )
			throw new InterpreterError(""bad from Type, need to unwrap"");
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError(""inconsistent args 1"");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError(""inconsistent args 2"");
		if ( toType == Void.TYPE )
			throw new InterpreterError(""loose toType should be null"");
		
		
		if ( toType == null || toType == fromType )
			return checkOnly ? VALID_CAST :
				fromValue;

		
        if ( toType.isPrimitive() )
		{
			if ( fromType == Void.TYPE || fromType == null 
				|| fromType.isPrimitive() )
			{
				
				return Primitive.castPrimitive( 
					toType, fromType, (Primitive)fromValue, 
					checkOnly, operation );
			} else
			{
				if ( Primitive.isWrapperType( fromType ) )
				{
					
					

					
					Class unboxedFromType = Primitive.unboxType( fromType );
					Primitive primFromValue;
					if ( checkOnly ) 
						primFromValue = null; 
					else
						primFromValue = (Primitive)Primitive.wrap( 
							fromValue, unboxedFromType );

					return Primitive.castPrimitive( 
						toType, unboxedFromType, primFromValue, 
						checkOnly, operation );
				} else
				{
					
					if ( checkOnly )
						return INVALID_CAST;
					else
						throw castError( toType, fromType, operation );
				}
			}
        }

		

		
		if ( fromType == Void.TYPE || fromType == null
			|| fromType.isPrimitive() )
		{
			
			if ( Primitive.isWrapperType( toType )
				&& fromType != Void.TYPE && fromType != null )
			{
				
				return checkOnly ? VALID_CAST :
					Primitive.castWrapper( 
						Primitive.unboxType(toType), 
						((Primitive)fromValue).getValue() );
			}

			
			if ( toType == Object.class 
				&& fromType != Void.TYPE && fromType != null )
			{
				
				return checkOnly ? VALID_CAST :
					((Primitive)fromValue).getValue();
			}

			
			
			
			return Primitive.castPrimitive( 
				toType, fromType, (Primitive)fromValue, checkOnly, operation );
		}

		
		
		
		if ( toType.isAssignableFrom( fromType ) )
			return checkOnly ? VALID_CAST : 
				fromValue;

		
		
		if ( toType.isInterface() 
			&& org.gjt.sp.jedit.bsh.This.class.isAssignableFrom( fromType )
			&& Capabilities.canGenerateInterfaces() 
		)
			return checkOnly ? VALID_CAST : 
				((org.gjt.sp.jedit.bsh.This)fromValue).getInterface( toType );

		
		
		if ( Primitive.isWrapperType( toType ) 
			&& Primitive.isWrapperType( fromType ) 
		)
			return checkOnly ? VALID_CAST :
				Primitive.castWrapper( toType, fromValue );
		
		if ( checkOnly )
			return INVALID_CAST;
		else
			throw castError( toType, fromType , operation  );
	}

	
    static UtilEvalError castError( 
		Class lhsType, Class rhsType, int operation   ) 
    {
		return castError( 
			Reflect.normalizeClassName(lhsType),
			Reflect.normalizeClassName(rhsType), operation  );
    }

    static UtilEvalError castError( 
		String lhs, String rhs, int operation   ) 
    {
		if ( operation == ASSIGNMENT )
			return new UtilEvalError (
				""Can't assign "" + rhs + "" to ""+ lhs );

		Exception cce = new ClassCastException(
			""Cannot cast "" + rhs + "" to "" + lhs );
		return new UtilTargetError( cce );
    }

}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.TriangleFoldPainter,4,1,0,4,8,6,2,3,4,2.0,145,0.0,0,0.0,0.708333333,0,0,35.25,2,1.0,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;
import org.gjt.sp.jedit.buffer.JEditBuffer;


public class TriangleFoldPainter implements FoldPainter {

	
	public void paintFoldStart(Gutter gutter, Graphics2D gfx, int screenLine,
			int physicalLine, boolean nextLineVisible, int y, int lineHeight,
			JEditBuffer buffer)
	{
		int _y = y + lineHeight / 2;
		gfx.setColor(gutter.getFoldColor());
		if (nextLineVisible)
		{
			gfx.drawLine(1,_y - 3,10,_y - 3);
			gfx.drawLine(2,_y - 2,9,_y - 2);
			gfx.drawLine(3,_y - 1,8,_y - 1);
			gfx.drawLine(4,_y,7,_y);
			gfx.drawLine(5,_y + 1,6,_y + 1);
		}
		else
		{
			gfx.drawLine(4,_y - 5,4,_y + 4);
			gfx.drawLine(5,_y - 4,5,_y + 3);
			gfx.drawLine(6,_y - 3,6,_y + 2);
			gfx.drawLine(7,_y - 2,7,_y + 1);
			gfx.drawLine(8,_y - 1,8,_y);
		}
	} 

	
	public void paintFoldEnd(Gutter gutter, Graphics2D gfx, int screenLine,
			int physicalLine, int y, int lineHeight, JEditBuffer buffer)
	{
		gfx.setColor(gutter.getFoldColor());
		int _y = y + lineHeight / 2;
		gfx.drawLine(4,_y,4,_y + 3);
		gfx.drawLine(4,_y + 3,7,_y + 3);
	} 

	
	public void paintFoldMiddle(Gutter gutter, Graphics2D gfx, int screenLine,
			int physicalLine, int y, int lineHeight, JEditBuffer buffer)
	{
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.EBMessage,5,1,15,60,15,0,60,1,3,0.0,57,1.0,0,0.0,0.466666667,0,0,10.2,1,0.6,0,"

package org.gjt.sp.jedit;


public abstract class EBMessage
{
	
	
	protected EBMessage(Object source)
	{
		this.source = source;
	} 

	
	
	protected EBMessage(EBComponent source)
	{
		this.source = source;
	} 

	
	
	public Object getSource()
	{
		return source;
	} 

	
	
	@Override
	public String toString()
	{
		String className = getClass().getName();
		int index = className.lastIndexOf('.');
		return className.substring(index + 1)
			+ '[' + paramString() + ']';
	} 

	
	
	public String paramString()
	{
		return ""source="" + source;
	} 

	
	private Object source;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.AbbrevsOptionPane,16,6,0,15,101,80,4,15,1,0.791666667,577,1.0,1,0.978070175,0.3125,4,13,34.5625,5,1.625,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import java.util.List;

import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.StandardUtilities;




public class AbbrevsOptionPane extends AbstractOptionPane
{
	
	public AbbrevsOptionPane()
	{
		super(""abbrevs"");
	} 

	
	@Override
	protected void _init()
	{
		setLayout(new BorderLayout());

		JPanel panel = new JPanel(new BorderLayout(6,6));

		expandOnInput = new JCheckBox(jEdit.getProperty(""options.abbrevs""
			+ "".expandOnInput""),Abbrevs.getExpandOnInput());

		panel.add(expandOnInput,BorderLayout.NORTH);

		JPanel panel2 = new JPanel();
		panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));
		panel2.setBorder(new EmptyBorder(0,0,6,0));
		panel2.add(Box.createGlue());
		JLabel label = new JLabel(jEdit.getProperty(""options.abbrevs.set""));
		label.setBorder(new EmptyBorder(0,0,0,12));
		panel2.add(label);

		Map<String,Hashtable<String,String>> _modeAbbrevs = Abbrevs.getModeAbbrevs();
		modeAbbrevs = new HashMap<String,AbbrevsModel>();
		Mode[] modes = jEdit.getModes();
		Arrays.sort(modes,new StandardUtilities.StringCompare<Mode>(true));
		String[] sets = new String[modes.length + 1];
		sets[0] = ""global"";
		for(int i = 0; i < modes.length; i++)
		{
			String name = modes[i].getName();
			sets[i+1] = name;
			modeAbbrevs.put(name,new AbbrevsModel(_modeAbbrevs.get(name)));
		}

		setsComboBox = new JComboBox(sets);
		ActionHandler actionHandler = new ActionHandler();
		setsComboBox.addActionListener(actionHandler);
		panel2.add(setsComboBox);
		panel2.add(Box.createGlue());
		panel.add(panel2,BorderLayout.SOUTH);

		add(BorderLayout.NORTH,panel);

		globalAbbrevs = new AbbrevsModel(Abbrevs.getGlobalAbbrevs());
		abbrevsTable = new JTable(globalAbbrevs);
		abbrevsTable.getColumnModel().getColumn(1).setCellRenderer(
			new Renderer());
		abbrevsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		abbrevsTable.getTableHeader().setReorderingAllowed(false);
		abbrevsTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		abbrevsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		abbrevsTable.getSelectionModel().setSelectionMode(
			ListSelectionModel.SINGLE_SELECTION);
		abbrevsTable.addMouseListener(new TableMouseHandler());
		Dimension d = abbrevsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(abbrevsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(6,0,0,0));

		add = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.abbrevs.add.icon"")));
		add.setToolTipText(jEdit.getProperty(""options.abbrevs.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		remove = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.abbrevs.remove.icon"")));
		remove.setToolTipText(jEdit.getProperty(""options.abbrevs.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		edit = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.abbrevs.edit.icon"")));
		edit.setToolTipText(jEdit.getProperty(""options.abbrevs.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());

		add(BorderLayout.SOUTH,buttons);
		setsComboBox.setSelectedIndex(jEdit.getIntegerProperty(""options.abbrevs.combobox.index"", 0));
		updateEnabled();
	} 

	
	@Override
	protected void _save()
	{
		if(abbrevsTable.getCellEditor() != null)
			abbrevsTable.getCellEditor().stopCellEditing();

		Abbrevs.setExpandOnInput(expandOnInput.isSelected());

		Abbrevs.setGlobalAbbrevs(globalAbbrevs.toHashtable());

		Hashtable<String,Hashtable<String,String>> modeHash = new Hashtable<String,Hashtable<String,String>>();
		Set<Map.Entry<String,AbbrevsModel>> entrySet = modeAbbrevs.entrySet();
		for (Map.Entry<String,AbbrevsModel> entry : entrySet)
		{
			modeHash.put(entry.getKey(),entry.getValue().toHashtable());
		}
		Abbrevs.setModeAbbrevs(modeHash);
	} 

	

	
	private JComboBox setsComboBox;
	private JCheckBox expandOnInput;
	private JTable abbrevsTable;
	private AbbrevsModel globalAbbrevs;
	private Map<String,AbbrevsModel> modeAbbrevs;
	private JButton add;
	private JButton edit;
	private JButton remove;
	

	
	private void updateEnabled()
	{
		int selectedRow = abbrevsTable.getSelectedRow();
		edit.setEnabled(selectedRow != -1);
		remove.setEnabled(selectedRow != -1);
	} 

	
	private void edit()
	{
		AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();

		int row = abbrevsTable.getSelectedRow();

		String abbrev = (String)abbrevsModel.getValueAt(row,0);
		String expansion = (String)abbrevsModel.getValueAt(row,1);
		String oldAbbrev = abbrev;

		EditAbbrevDialog dialog = new EditAbbrevDialog(
			GUIUtilities.getParentDialog(AbbrevsOptionPane.this),
			abbrev,expansion,abbrevsModel.toHashtable());
		abbrev = dialog.getAbbrev();
		expansion = dialog.getExpansion();
		if(abbrev != null && expansion != null)
		{
			for(int i = 0; i < abbrevsModel.getRowCount(); i++)
			{
				if(abbrevsModel.getValueAt(i,0).equals(oldAbbrev))
				{
					abbrevsModel.remove(i);
					break;
				}
			}

			add(abbrevsModel,abbrev,expansion);
		}
	} 

	
	private void add(AbbrevsModel abbrevsModel, String abbrev,
		String expansion)
	{
		for(int i = 0; i < abbrevsModel.getRowCount(); i++)
		{
			if(abbrevsModel.getValueAt(i,0).equals(abbrev))
			{
				abbrevsModel.remove(i);
				break;
			}
		}

		abbrevsModel.add(abbrev,expansion);
		updateEnabled();
	} 

	

	
	private class HeaderMouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			switch(abbrevsTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				((AbbrevsModel)abbrevsTable.getModel()).sort(0);
				break;
			case 1:
				((AbbrevsModel)abbrevsTable.getModel()).sort(1);
				break;
			}
		}
	} 

	
	private class TableMouseHandler extends MouseAdapter
	{
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			if(evt.getClickCount() == 2)
				edit();
		}
	} 

	
	private class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} 

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();

			Object source = evt.getSource();
			if(source == setsComboBox)
			{
				jEdit.setIntegerProperty(""options.abbrevs.combobox.index"", setsComboBox.getSelectedIndex());
				String selected = (String)setsComboBox.getSelectedItem();
				if(selected.equals(""global""))
				{
					abbrevsTable.setModel(globalAbbrevs);
				}
				else
				{
					abbrevsTable.setModel(modeAbbrevs.get(selected));
				}
				updateEnabled();
			}
			else if(source == add)
			{
				EditAbbrevDialog dialog = new EditAbbrevDialog(
					GUIUtilities.getParentDialog(AbbrevsOptionPane.this),
					null,null,abbrevsModel.toHashtable());
				String abbrev = dialog.getAbbrev();
				String expansion = dialog.getExpansion();
				if(abbrev != null && abbrev.length() != 0
					&& expansion != null
					&& expansion.length() != 0)
				{
					add(abbrevsModel,abbrev,expansion);
				}
			}
			else if(source == edit)
			{
				edit();
			}
			else if(source == remove)
			{
				int selectedRow = abbrevsTable.getSelectedRow();
				abbrevsModel.remove(selectedRow);
				updateEnabled();
			}
		}
	} 

	
	private static class Renderer extends DefaultTableCellRenderer
	{
		@Override
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			String valueStr = value.toString();

			
			
			if(valueStr.toLowerCase().startsWith(""<html>""))
				valueStr = ' ' + valueStr;
			return super.getTableCellRendererComponent(table,valueStr,
				isSelected,cellHasFocus,row,col);
		}
	} 

	
	private static class AbbrevsModel extends AbstractTableModel
	{
		List<Abbrev> abbrevs;
		int lastSort;

		
		AbbrevsModel(Map<String,String> abbrevHash)
		{
			abbrevs = new Vector<Abbrev>();

			if(abbrevHash != null)
			{
				Set<Map.Entry<String,String>> entrySet = abbrevHash.entrySet();
				for (Map.Entry<String,String> entry : entrySet)
				{
					abbrevs.add(new Abbrev(entry.getKey(),
					                       entry.getValue()));
				}
				sort(0);
			}
		} 

		
		void sort(int col)
		{
			lastSort = col;
			Collections.sort(abbrevs,new AbbrevCompare(col));
			fireTableDataChanged();
		} 

		
		void add(String abbrev, String expansion)
		{
			abbrevs.add(new Abbrev(abbrev,expansion));
			sort(lastSort);
		} 

		
		void remove(int index)
		{
			abbrevs.remove(index);
			fireTableStructureChanged();
		} 

		
		public Hashtable<String,String> toHashtable()
		{
			Hashtable<String,String> hash = new Hashtable<String,String>();
			for(int i = 0; i < abbrevs.size(); i++)
			{
				Abbrev abbrev = abbrevs.get(i);
				if(abbrev.abbrev.length() > 0
				   && abbrev.expand.length() > 0)
				{
					hash.put(abbrev.abbrev,abbrev.expand);
				}
			}
			return hash;
		} 

		
		public int getColumnCount()
		{
			return 2;
		} 

		
		public int getRowCount()
		{
			return abbrevs.size();
		} 

		
		public Object getValueAt(int row, int col)
		{
			Abbrev abbrev = abbrevs.get(row);
			switch(col)
			{
				case 0:
					return abbrev.abbrev;
				case 1:
					return abbrev.expand;
				default:
					return null;
			}
		} 

		
		@Override
		public void setValueAt(Object value, int row, int col)
		{
			if(value == null)
				value = """";

			Abbrev abbrev = abbrevs.get(row);

			if(col == 0)
				abbrev.abbrev = (String)value;
			else
				abbrev.expand = (String)value;

			fireTableRowsUpdated(row,row);
		} 

		
		@Override
		public String getColumnName(int index)
		{
			switch(index)
			{
				case 0:
					return jEdit.getProperty(""options.abbrevs.abbrev"");
				case 1:
					return jEdit.getProperty(""options.abbrevs.expand"");
				default:
					return null;
			}
		} 

		
		private static class AbbrevCompare implements Comparator<Abbrev>
		{
			private int col;

			AbbrevCompare(int col)
			{
				this.col = col;
			}

			public int compare(Abbrev a1, Abbrev a2)
			{
				if(col == 0)
				{
					String abbrev1 = a1.abbrev.toLowerCase();
					String abbrev2 = a2.abbrev.toLowerCase();

					return StandardUtilities.compareStrings(
						abbrev1,abbrev2,true);
				}
				else
				{
					String expand1 = a1.expand.toLowerCase();
					String expand2 = a2.expand.toLowerCase();

					return StandardUtilities.compareStrings(
						expand1,expand2,true);
				}
			}
		} 

		
		private static class Abbrev
		{
			Abbrev() {}

			Abbrev(String abbrev, String expand)
			{
				this.abbrev = abbrev;
				this.expand = expand;
			}

			String abbrev;
			String expand;
		} 

	} 

} 
"
jEdit,4.3,org.gjt.sp.jedit.gui.CloseDialog,15,7,0,8,62,81,4,8,5,0.841269841,368,0.888888889,1,0.980568012,0.253333333,0,0,22.93333333,3,1.0,0,"

package org.gjt.sp.jedit.gui;


import java.util.Collection;
import java.util.Arrays;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.bufferio.BufferIORequest;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class CloseDialog extends EnhancedDialog
{
	
	public CloseDialog(View view)
	{
		this(view, Arrays.asList(jEdit.getBuffers()));
	}

	public CloseDialog(View view, Collection<Buffer> buffers)
	{
		super(view,jEdit.getProperty(""close.title""),true);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.warningIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(jEdit.getProperty(""close.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		bufferList = new JList(bufferModel = new DefaultListModel());
		bufferList.setVisibleRowCount(10);
		bufferList.addListSelectionListener(new ListHandler());

		for(Buffer buffer: buffers)
		{
			if(buffer.isDirty()) 
				bufferModel.addElement(buffer.getPath()); 
		}

		centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferList));

		content.add(BorderLayout.CENTER,centerPanel);

		ActionHandler actionListener = new ActionHandler();

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		buttons.add(selectAll = new JButton(jEdit.getProperty(""close.selectAll"")));
		selectAll.setMnemonic(jEdit.getProperty(""close.selectAll.mnemonic"").charAt(0));
		selectAll.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(save = new JButton(jEdit.getProperty(""close.save"")));
		save.setMnemonic(jEdit.getProperty(""close.save.mnemonic"").charAt(0));
		save.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(discard = new JButton(jEdit.getProperty(""close.discard"")));
		discard.setMnemonic(jEdit.getProperty(""close.discard.mnemonic"").charAt(0));
		discard.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(actionListener);
		buttons.add(Box.createGlue());
		bufferList.setSelectedIndex(0);
		content.add(BorderLayout.SOUTH,buttons);
		content.getRootPane().setDefaultButton(cancel);
		GUIUtilities.requestFocus(this,bufferList);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} 

	
	public boolean isOK()
	{
		return ok;
	} 

	
	@Override
	public void ok()
	{
		
	} 

	
	@Override
	public void cancel()
	{
		dispose();
	} 

	
	private final View view;
	private final JList bufferList;
	private final DefaultListModel bufferModel;
	private final JButton selectAll;
	private final JButton save;
	private final JButton discard;
	private final JButton cancel;

	private boolean ok; 

	boolean selectAllFlag;

	private void updateButtons()
	{
		int index = bufferList.getSelectedIndex();
		save.getModel().setEnabled(index != -1);
		discard.getModel().setEnabled(index != -1);
	} 

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
			{
				
				
				try
				{
					selectAllFlag = true;

					bufferList.setSelectionInterval(0,
						bufferModel.getSize() - 1);
				}
				finally
				{
					selectAllFlag = false;
				}
				bufferList.requestFocus();
			}
			else if(source == save)
			{
				Object[] paths = bufferList.getSelectedValues();

				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					if(!buffer.save(view,null,true,true))
						return;
					VFSManager.waitForRequests();
					if(buffer.getBooleanProperty(BufferIORequest
						.ERROR_OCCURRED))
						return;
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}

				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == discard)
			{
				Object[] paths = bufferList.getSelectedValues();

				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}

				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == cancel)
				cancel();
		}
	} 

	
	private class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			if(selectAllFlag)
				return;

			int index = bufferList.getSelectedIndex();
			if(index != -1)
			{
				String path = (String) bufferModel.getElementAt(index);
				Buffer buffer = jEdit.getBuffer(path);
				if (buffer == null)
				{
					
					Log.log(Log.DEBUG, this, ""Buffer "" + path + "" is already closed"");
					bufferModel.removeElementAt(index);
				}
				else
				{
					view.showBuffer(buffer);
				}
			}

			updateButtons();
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.EncodingWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.gui.BufferOptions;
import org.gjt.sp.jedit.jEdit;



public class EncodingWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view) 
	{
		EncodingWidget mode = new EncodingWidget(view);
		return mode;
	} 

	
	private static class EncodingWidget implements Widget
	{
		private final JLabel encoding;
		private final View view;
		public EncodingWidget(final View view) 
		{
			encoding = new ToolTipLabel();
			this.view = view;
			encoding.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
			encoding.addMouseListener(new MouseAdapter() 
						  {
							  @Override
							  public void mouseClicked(MouseEvent evt)
							  {
								  if(evt.getClickCount() == 2)
									  new BufferOptions(view,view.getBuffer());
							  }
						  });
		}
		
		public JComponent getComponent() 
		{
			return encoding;
		}
		
		public void update() 
		{
			Buffer buffer = view.getBuffer();
			if (buffer.isLoaded())
				encoding.setText(buffer.getStringProperty(""encoding""));
		}
		
		public void propertiesChanged()
		{
		}
		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ReflectManager,4,1,1,4,12,6,3,1,4,0.666666667,37,1.0,1,0.0,0.5,0,0,8.0,1,0.75,0,"

package org.gjt.sp.jedit.bsh;

import org.gjt.sp.jedit.bsh.Capabilities.Unavailable;


public abstract class ReflectManager
{
	private static ReflectManager rfm;

	
	public static ReflectManager getReflectManager() 
		throws Unavailable
	{
		if ( rfm == null ) 
		{
			Class clas;
			try {
				clas = Class.forName( ""org.gjt.sp.jedit.bsh.reflect.ReflectManagerImpl"" );
				rfm = (ReflectManager)clas.newInstance();
			} catch ( Exception e ) {
				throw new Unavailable(""Reflect Manager unavailable: ""+e);
			}
		}
	
		return rfm;
	}

	
	public static boolean RMSetAccessible( Object obj ) 
		throws Unavailable
	{
		return getReflectManager().setAccessible( obj );
	}

	
	public abstract boolean setAccessible( Object o );
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.JThis,86,2,0,9,97,3649,0,9,84,2.0,709,0.0,0,0.105263158,0.05620155,1,1,7.244186047,3,1.0233,0,"


package org.gjt.sp.jedit.bsh;

import java.awt.event.*;
import javax.swing.event.*;
import java.beans.*;


class JThis extends This implements
	
	ActionListener, AdjustmentListener, ComponentListener,
	ContainerListener, FocusListener, ItemListener, KeyListener,
	MouseListener, MouseMotionListener, TextListener, WindowListener,
	PropertyChangeListener, 
	
	AncestorListener, CaretListener, CellEditorListener, ChangeListener,
	DocumentListener, HyperlinkListener, 
	InternalFrameListener, ListDataListener, ListSelectionListener, 
	MenuDragMouseListener, MenuKeyListener, MenuListener, MouseInputListener, 
	PopupMenuListener, TableColumnModelListener, TableModelListener, 
	TreeExpansionListener, TreeModelListener, TreeSelectionListener, 
	TreeWillExpandListener, UndoableEditListener
{

	JThis( NameSpace namespace, Interpreter declaringInterp ) { 
		super( namespace, declaringInterp );
	}

	public String toString() {
		return ""'this' reference (JThis) to Bsh object: "" + namespace.getName();
	}

	void event(String name, Object event)
	{
		CallStack callstack = new CallStack( namespace );
		BshMethod method = null;

		
		try {
			method = namespace.getMethod( 
				""handleEvent"", new Class [] { null } );
		} catch ( UtilEvalError e ) {  }

		if (method != null)
			try {
				method.invoke( 
					new Object[] { event }, declaringInterpreter, callstack, null );
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event hander method invocation error:"" + e );
			}

		
		try {
			method = namespace.getMethod( name, new Class [] { null } );
		} catch ( UtilEvalError e ) {  }
		if (method != null)
			try {
				method.invoke( 
					new Object[] { event }, declaringInterpreter, callstack, null );
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event hander method invocation error:"" + e );
			}
	}

	

    public void ancestorAdded(AncestorEvent e) { event(""ancestorAdded"", e); }
    public void ancestorRemoved(AncestorEvent e) { event(""ancestorRemoved"", e); }
    public void ancestorMoved(AncestorEvent e) { event(""ancestorMoved"", e); }
    public void caretUpdate(CaretEvent e) { event(""caretUpdate"", e); }
    public void editingStopped(ChangeEvent e) { event(""editingStopped"", e); }
    public void editingCanceled(ChangeEvent e) { event(""editingCanceled"", e); }
    public void stateChanged(ChangeEvent e) { event(""stateChanged"", e); }
    public void insertUpdate(DocumentEvent e) { event(""insertUpdate"", e); }
    public void removeUpdate(DocumentEvent e) { event(""removeUpdate"", e); }
    public void changedUpdate(DocumentEvent e) { event(""changedUpdate"", e); }
    public void hyperlinkUpdate(HyperlinkEvent e) { event(""internalFrameOpened"", e); }
    public void internalFrameOpened(InternalFrameEvent e) { event(""internalFrameOpened"", e); }
    public void internalFrameClosing(InternalFrameEvent e) { event(""internalFrameClosing"", e); }
    public void internalFrameClosed(InternalFrameEvent e) { event(""internalFrameClosed"", e); }
    public void internalFrameIconified(InternalFrameEvent e) { event(""internalFrameIconified"", e); }
    public void internalFrameDeiconified(InternalFrameEvent e) { event(""internalFrameDeiconified"", e); }
    public void internalFrameActivated(InternalFrameEvent e) { event(""internalFrameActivated"", e); }
    public void internalFrameDeactivated(InternalFrameEvent e) { event(""internalFrameDeactivated"", e); }
    public void intervalAdded(ListDataEvent e) { event(""intervalAdded"", e); }
    public void intervalRemoved(ListDataEvent e) { event(""intervalRemoved"", e); }
    public void contentsChanged(ListDataEvent e) { event(""contentsChanged"", e); }
  	public void valueChanged(ListSelectionEvent e) { event(""valueChanged"", e); }
    public void menuDragMouseEntered(MenuDragMouseEvent e) { event(""menuDragMouseEntered"", e); }
    public void menuDragMouseExited(MenuDragMouseEvent e) { event(""menuDragMouseExited"", e); }
    public void menuDragMouseDragged(MenuDragMouseEvent e) { event(""menuDragMouseDragged"", e); }
    public void menuDragMouseReleased(MenuDragMouseEvent e) { event(""menuDragMouseReleased"", e); }
    public void menuKeyTyped(MenuKeyEvent e) { event(""menuKeyTyped"", e); }
    public void menuKeyPressed(MenuKeyEvent e) { event(""menuKeyPressed"", e); }
    public void menuKeyReleased(MenuKeyEvent e) { event(""menuKeyReleased"", e); }
    public void menuSelected(MenuEvent e) { event(""menuSelected"", e); }
    public void menuDeselected(MenuEvent e) { event(""menuDeselected"", e); }
    public void menuCanceled(MenuEvent e) { event(""menuCanceled"", e); }
    public void popupMenuWillBecomeVisible(PopupMenuEvent e) { event(""popupMenuWillBecomeVisible"", e); }
    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) { event(""popupMenuWillBecomeInvisible"", e); }
    public void popupMenuCanceled(PopupMenuEvent e) { event(""popupMenuCanceled"", e); }
    public void columnAdded(TableColumnModelEvent e) { event(""columnAdded"", e); }
    public void columnRemoved(TableColumnModelEvent e) { event(""columnRemoved"", e); }
    public void columnMoved(TableColumnModelEvent e) { event(""columnMoved"", e); }
    public void columnMarginChanged(ChangeEvent e) { event(""columnMarginChanged"", e); }
    public void columnSelectionChanged(ListSelectionEvent e) { event(""columnSelectionChanged"", e); }
    public void tableChanged(TableModelEvent e) { event(""tableChanged"", e); }
    public void treeExpanded(TreeExpansionEvent e) { event(""treeExpanded"", e); }
    public void treeCollapsed(TreeExpansionEvent e) { event(""treeCollapsed"", e); }
    public void treeNodesChanged(TreeModelEvent e) { event(""treeNodesChanged"", e); }
    public void treeNodesInserted(TreeModelEvent e) { event(""treeNodesInserted"", e); }
    public void treeNodesRemoved(TreeModelEvent e) { event(""treeNodesRemoved"", e); }
    public void treeStructureChanged(TreeModelEvent e) { event(""treeStructureChanged"", e); }
    public void valueChanged(TreeSelectionEvent e) { event(""valueChanged"", e); }
    public void treeWillExpand(TreeExpansionEvent e) { event(""treeWillExpand"", e); }
    public void treeWillCollapse(TreeExpansionEvent e) { event(""treeWillCollapse"", e); }
    public void undoableEditHappened(UndoableEditEvent e) { event(""undoableEditHappened"", e); }

	
	public void actionPerformed(ActionEvent e) { event(""actionPerformed"", e); }
	public void adjustmentValueChanged(AdjustmentEvent e) { event(""adjustmentValueChanged"", e); }
	public void componentResized(ComponentEvent e) { event(""componentResized"", e); }
	public void componentMoved(ComponentEvent e) { event(""componentMoved"", e); }
	public void componentShown(ComponentEvent e) { event(""componentShown"", e); }
	public void componentHidden(ComponentEvent e) { event(""componentHidden"", e); }
	public void componentAdded(ContainerEvent e) { event(""componentAdded"", e); }
	public void componentRemoved(ContainerEvent e) { event(""componentRemoved"", e); }
	public void focusGained(FocusEvent e) { event(""focusGained"", e); }
	public void focusLost(FocusEvent e) { event(""focusLost"", e); }
	public void itemStateChanged(ItemEvent e) { event(""itemStateChanged"", e); }
	public void keyTyped(KeyEvent e) { event(""keyTyped"", e); }
	public void keyPressed(KeyEvent e) { event(""keyPressed"", e); }
	public void keyReleased(KeyEvent e) { event(""keyReleased"", e); }
	public void mouseClicked(MouseEvent e) { event(""mouseClicked"", e); }
	public void mousePressed(MouseEvent e) { event(""mousePressed"", e); }
	public void mouseReleased(MouseEvent e) { event(""mouseReleased"", e); }
	public void mouseEntered(MouseEvent e) { event(""mouseEntered"", e); }
	public void mouseExited(MouseEvent e) { event(""mouseExited"", e); }
	public void mouseDragged(MouseEvent e) { event(""mouseDragged"", e); }
	public void mouseMoved(MouseEvent e) { event(""mouseMoved"", e); }
	public void textValueChanged(TextEvent e) { event(""textValueChanged"", e); }
	public void windowOpened(WindowEvent e) { event(""windowOpened"", e); }
	public void windowClosing(WindowEvent e) { event(""windowClosing"", e); }
	public void windowClosed(WindowEvent e) { event(""windowClosed"", e); }
	public void windowIconified(WindowEvent e) { event(""windowIconified"", e); }
	public void windowDeiconified(WindowEvent e) { event(""windowDeiconified"", e); }
	public void windowActivated(WindowEvent e) { event(""windowActivated"", e); }
	public void windowDeactivated(WindowEvent e) { event(""windowDeactivated"", e); }

	public void propertyChange(PropertyChangeEvent e) { 
		event(""propertyChange"", e ); }
    public void vetoableChange(PropertyChangeEvent e) {
		event(""vetoableChange"", e ); }

    public boolean imageUpdate(java.awt.Image img, int infoflags,
                               int x, int y, int width, int height) {

		BshMethod method = null;
		try {
			method = namespace.getMethod( ""imageUpdate"",
				new Class [] { null, null, null, null, null, null } );
		} catch ( UtilEvalError e ) { }

		if(method != null)
			try {
				CallStack callstack = new CallStack( namespace );
				method.invoke( 
					new Object[] { 
						img, new Primitive(infoflags), new Primitive(x), 
						new Primitive(y), new Primitive(width), 
						new Primitive(height) }, 
					declaringInterpreter, callstack, null
				);
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event handler imageUpdate: method invocation error:"" + e );
			}
		return true;
	}

}

"
jEdit,4.3,org.gjt.sp.jedit.search.SearchDialog,39,7,0,33,190,535,9,30,7,0.819078947,2164,0.90625,5,0.946608947,0.14619883,3,4,53.66666667,17,2.5641,0,"

package org.gjt.sp.jedit.search;


import javax.swing.border.*;
import javax.swing.*;

import java.awt.*;
import java.awt.event.*;
import java.util.HashMap;
import java.util.Map;

import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.*;



public class SearchDialog extends EnhancedDialog implements EBComponent
{
	
	
	public static final int CURRENT_BUFFER = 0;
	public static final int ALL_BUFFERS = 1;
	public static final int DIRECTORY = 2;
	

	
	public static SearchDialog getSearchDialog(View view)
	{
		if(Debug.DISABLE_SEARCH_DIALOG_POOL)
			return new SearchDialog(view);
		else
		{

			SearchDialog searchDialog = viewHash.get(view);
			if (searchDialog == null)
			{
				searchDialog = new SearchDialog(view);
				viewHash.put(view, searchDialog);
			}
			return searchDialog;
		}
	} 

	
	
	public static void showSearchDialog(View view, String searchString,
		int searchIn)
	{
		final SearchDialog dialog = getSearchDialog(view);

		dialog.setSearchString(searchString,searchIn);

		
		if(OperatingSystem.isUnix() && !OperatingSystem.isMacOS())
			dialog.setVisible(false);

		
		
		
		SwingUtilities.invokeLater(new Runnable() 
		{
			public void run() 
			{
				dialog.toFront();
				dialog.requestFocus();
					
					
				dialog.find.requestFocus();
					
					
			}
		});
		dialog.setVisible(true);
	} 

	
	
	public void setSearchString(String searchString, int searchIn)
	{
		find.setText(null);
		replace.setText(null);

		if(searchString == null)
		{
			searchCurrentBuffer.setSelected(true);
			HistoryModel model = find.getModel();
			if (!model.isEmpty())
			{
				find.setText(model.getItem(0));
				find.selectAll();
			}
		}
		else
		{
			if(searchString.indexOf('\n') == -1)
			{
				if(SearchAndReplace.getRegexp())
				{
					find.setText(SearchAndReplace.escapeRegexp(
						searchString,true));
				}
				else
					find.setText(searchString);
				find.selectAll();
				searchCurrentBuffer.setSelected(true);
			}
			else if(searchIn == CURRENT_BUFFER)
			{
				searchSelection.setSelected(true);
				hyperSearch.setSelected(true);
			}
		}

		if(searchIn == CURRENT_BUFFER)
		{
			if(!searchSelection.isSelected())
			{
				
				searchCurrentBuffer.setSelected(true);

				
				hyperSearch.setSelected(jEdit.getBooleanProperty(
					""search.hypersearch.toggle""));
			}
		}
		else if(searchIn == ALL_BUFFERS)
		{
			searchAllBuffers.setSelected(true);
			hyperSearch.setSelected(true);
		}
		else if(searchIn == DIRECTORY)
		{
			SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

			if(fileset instanceof DirectoryListSet)
			{
				filter.setText(((DirectoryListSet)fileset)
					.getFileFilter());
				directory.setText(((DirectoryListSet)fileset)
					.getDirectory());
				searchSubDirectories.setSelected(((DirectoryListSet)fileset)
					.isRecursive());
			}

			hyperSearch.setSelected(true);
			searchDirectory.setSelected(true);
		}

		updateEnabled();
	} 

	
	public void ok()
	{
		try
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

			if(!save(false))
				return;

			if(searchSelection.isSelected()
				&& view.getTextArea().getSelectionCount() == 0)
			{
				GUIUtilities.error(view,""search-no-selection"",null);
				return;
			}

			if(hyperSearch.isSelected() || searchSelection.isSelected())
			{
				if(SearchAndReplace.hyperSearch(view,
					searchSelection.isSelected()))
					closeOrKeepDialog();
			}
			else
			{
				if(SearchAndReplace.find(view))
					closeOrKeepDialog();
				else
				{
					toFront();
					requestFocus();
					find.requestFocus();
				}
			}
		}
		finally
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		}
	} 

	
	public void cancel()
	{
		save(true);
		GUIUtilities.saveGeometry(this,""search"");
		setVisible(false);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof SearchSettingsChanged)
		{
			if(!saving)
				load();
		}
	} 

	
	@Override
	public void dispose()
	{
		EditBus.removeFromBus(this);
		viewHash.remove(view);
		super.dispose();
	} 

	

	private static final Map<View, SearchDialog> viewHash = new HashMap<View, SearchDialog>();

	
	private final View view;

	
	private HistoryTextArea find, replace;

	private JRadioButton stringReplace, beanShellReplace;

	
	private JCheckBox keepDialog, ignoreCase, regexp, hyperSearch,
		wrap;
	private JRadioButton searchBack, searchForward;
	private JRadioButton searchSelection, searchCurrentBuffer,
		searchAllBuffers, searchDirectory;

	
	private HistoryTextField filter, directory;
	private JCheckBox searchSubDirectories;
	private JCheckBox skipBinaryFiles;
	private JCheckBox skipHidden;
	
	private JButton choose;
	private JButton synchronize;

	
	private JButton findBtn,  replaceAndFindBtn, replaceAllBtn,
		closeBtn;

	private boolean saving;
	

	
	
	private SearchDialog(View view)
	{
		super(view,jEdit.getProperty(""search.title""),false);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(0,12,12,12));
		setContentPane(content);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.add(BorderLayout.CENTER,createFieldPanel());
		centerPanel.add(BorderLayout.SOUTH,createSearchSettingsPanel());
		content.add(BorderLayout.CENTER,centerPanel);
		content.add(BorderLayout.SOUTH,createMultiFilePanel());

		content.add(BorderLayout.EAST,createButtonsPanel());

		pack();
		jEdit.unsetProperty(""search.width"");
		jEdit.unsetProperty(""search.d-width"");
		jEdit.unsetProperty(""search.height"");
		jEdit.unsetProperty(""search.d-height"");
		GUIUtilities.loadGeometry(this,""search"");

		load();

		EditBus.addToBus(this);
	} 

	
	private void createFindLabelAndField(JPanel fieldPanel,
		GridBagConstraints cons)
	{
		JLabel label = new JLabel(jEdit.getProperty(""search.find""));
		
		label.setDisplayedMnemonic(jEdit.getProperty(""search.find.mnemonic"")
			.charAt(0));
		find = new HistoryTextArea(""find"");
		find.setName(""find"");
		find.setColumns(25);
		find.setToolTipText(jEdit.getProperty(""search.find.tooltip""));
		label.setToolTipText(jEdit.getProperty(""search.find.tooltip""));
		label.setLabelFor(find);
		label.setBorder(new EmptyBorder(12,0,2,0));

		cons.gridx = 0;
		cons.weightx = 0.0;
		cons.weighty = 0.0;
		fieldPanel.add(label,cons);
		cons.gridy++;
		cons.weightx = 1.0;
		cons.weighty = 1.0;
		fieldPanel.add(new JScrollPane(find),cons);
		cons.gridy++;
	} 

	
	private void createReplaceLabelAndField(JPanel fieldPanel,
		GridBagConstraints cons)
	{
		JLabel label = new JLabel(jEdit.getProperty(""search.replace""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.replace.mnemonic"")
			.charAt(0));
		label.setBorder(new EmptyBorder(12,0,0,0));

		cons.gridx = 0;
		cons.weightx = 0.0;
		cons.weighty = 0.0;
		fieldPanel.add(label,cons);
		cons.gridy++;

		ButtonGroup grp = new ButtonGroup();
		ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler();

		
		
		
		

		stringReplace = new MyJRadioButton(jEdit.getProperty(
			""search.string-replace-btn""));
		stringReplace.addActionListener(replaceActionHandler);
		grp.add(stringReplace);
		cons.gridwidth = 1;
		fieldPanel.add(stringReplace,cons);
		cons.gridx++;
		cons.insets = new Insets(0,12,0,0);

		beanShellReplace = new MyJRadioButton(jEdit.getProperty(
			""search.beanshell-replace-btn""));
		beanShellReplace.addActionListener(replaceActionHandler);
		grp.add(beanShellReplace);
		fieldPanel.add(beanShellReplace,cons);
		cons.gridx = 0;
		cons.gridwidth = 2;
		cons.insets = new Insets(0,0,0,0);

		replace = new HistoryTextArea(""replace"");
		replace.setName(""replace"");
		replace.setToolTipText(jEdit.getProperty(""search.find.tooltip""));
		label.setLabelFor(replace);

		cons.gridx = 0;
		cons.gridy++;
		cons.weightx = 1.0;
		cons.weighty = 1.0;
		fieldPanel.add(new JScrollPane(replace),cons);
		cons.gridy++;
	} 

	
	private JPanel createFieldPanel()
	{
		JPanel fieldPanel = new JPanel(new GridBagLayout());
		fieldPanel.setBorder(new EmptyBorder(0,0,12,12));

		GridBagConstraints cons = new GridBagConstraints();
		cons.fill = GridBagConstraints.BOTH;
		cons.gridy = 0;
		cons.gridwidth = 2;

		createFindLabelAndField(fieldPanel,cons);
		createReplaceLabelAndField(fieldPanel,cons);

		return fieldPanel;
	} 

	
	private JPanel createSearchSettingsPanel()
	{
		JPanel searchSettings = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,3));
		searchSettings.setBorder(new EmptyBorder(0,0,12,12));

		SettingsActionHandler actionHandler = new SettingsActionHandler();
		ButtonGroup fileset = new ButtonGroup();
		ButtonGroup direction = new ButtonGroup();

		searchSettings.add(new JLabel(jEdit.getProperty(""search.fileset"")));

		searchSettings.add(new JLabel(jEdit.getProperty(""search.settings"")));

		searchSettings.add(new JLabel(jEdit.getProperty(""search.direction"")));

		searchSelection = new JRadioButton(jEdit.getProperty(""search.selection""));
		searchSelection.setMnemonic(jEdit.getProperty(""search.selection.mnemonic"")
			.charAt(0));
		fileset.add(searchSelection);
		searchSettings.add(searchSelection);
		searchSelection.addActionListener(actionHandler);

		keepDialog = new JCheckBox(jEdit.getProperty(""search.keep""));
		keepDialog.setMnemonic(jEdit.getProperty(""search.keep.mnemonic"")
			.charAt(0));
		searchSettings.add(keepDialog);

		searchBack = new JRadioButton(jEdit.getProperty(""search.back""));
		searchBack.setMnemonic(jEdit.getProperty(""search.back.mnemonic"")
			.charAt(0));
		direction.add(searchBack);
		searchSettings.add(searchBack);
		searchBack.addActionListener(actionHandler);

		searchCurrentBuffer = new JRadioButton(jEdit.getProperty(""search.current""));
		searchCurrentBuffer.setMnemonic(jEdit.getProperty(""search.current.mnemonic"")
			.charAt(0));
		fileset.add(searchCurrentBuffer);
		searchSettings.add(searchCurrentBuffer);
		searchCurrentBuffer.addActionListener(actionHandler);

		ignoreCase = new JCheckBox(jEdit.getProperty(""search.case""));
		ignoreCase.setMnemonic(jEdit.getProperty(""search.case.mnemonic"")
			.charAt(0));
		searchSettings.add(ignoreCase);
		ignoreCase.addActionListener(actionHandler);

		searchForward = new JRadioButton(jEdit.getProperty(""search.forward""));
		searchForward.setMnemonic(jEdit.getProperty(""search.forward.mnemonic"")
			.charAt(0));
		direction.add(searchForward);
		searchSettings.add(searchForward);
		searchForward.addActionListener(actionHandler);

		searchAllBuffers = new JRadioButton(jEdit.getProperty(""search.all""));
		searchAllBuffers.setMnemonic(jEdit.getProperty(""search.all.mnemonic"")
			.charAt(0));
		fileset.add(searchAllBuffers);
		searchSettings.add(searchAllBuffers);
		searchAllBuffers.addActionListener(actionHandler);

		regexp = new JCheckBox(jEdit.getProperty(""search.regexp""));
		regexp.setMnemonic(jEdit.getProperty(""search.regexp.mnemonic"")
			.charAt(0));
		searchSettings.add(regexp);
		regexp.addActionListener(actionHandler);

		wrap = new JCheckBox(jEdit.getProperty(""search.wrap""));
		wrap.setMnemonic(jEdit.getProperty(""search.wrap.mnemonic"")
			.charAt(0));
		searchSettings.add(wrap);
		wrap.addActionListener(actionHandler);

		searchDirectory = new JRadioButton(jEdit.getProperty(""search.directory""));
		searchDirectory.setMnemonic(jEdit.getProperty(""search.directory.mnemonic"")
			.charAt(0));
		fileset.add(searchDirectory);
		searchSettings.add(searchDirectory);
		searchDirectory.addActionListener(actionHandler);

		hyperSearch = new JCheckBox(jEdit.getProperty(""search.hypersearch""));
		hyperSearch.setMnemonic(jEdit.getProperty(""search.hypersearch.mnemonic"")
			.charAt(0));
		searchSettings.add(hyperSearch);
		hyperSearch.addActionListener(actionHandler);

		return searchSettings;
	} 

	
	private JPanel createMultiFilePanel()
	{
		JPanel multifile = new JPanel();

		GridBagLayout layout = new GridBagLayout();
		multifile.setLayout(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = cons.gridwidth = cons.gridheight = 1;
		cons.anchor = GridBagConstraints.WEST;
		cons.fill = GridBagConstraints.HORIZONTAL;

		MultiFileActionHandler actionListener = new MultiFileActionHandler();
		filter = new HistoryTextField(""search.filter"");
		
		filter.setToolTipText(jEdit.getProperty(""glob.tooltip""));
		filter.addActionListener(actionListener);

		cons.insets = new Insets(0,0,3,0);

		JLabel label = new JLabel(jEdit.getProperty(""search.filterField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.filterField.mnemonic"")
			.charAt(0));
		label.setLabelFor(filter);
		cons.weightx = 0.0;
		layout.setConstraints(label,cons);
		multifile.add(label);

		cons.gridwidth = 2;
		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0;
		layout.setConstraints(filter,cons);
		multifile.add(filter);

		cons.gridwidth = 1;
		cons.weightx = 0.0;
		cons.insets = new Insets(0,0,3,0);

		synchronize = new JButton(jEdit.getProperty(
			""search.synchronize""));
		synchronize.setToolTipText(jEdit.getProperty(
			""search.synchronize.tooltip""));
		synchronize.setMnemonic(jEdit.getProperty(
			""search.synchronize.mnemonic"")
			.charAt(0));
		synchronize.addActionListener(actionListener);
		layout.setConstraints(synchronize,cons);
		multifile.add(synchronize);

		cons.gridy++;

		directory = new HistoryTextField(""search.directory"");
		directory.setColumns(25);
		directory.addActionListener(actionListener);

		label = new JLabel(jEdit.getProperty(""search.directoryField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));

		label.setDisplayedMnemonic(jEdit.getProperty(""search.directoryField.mnemonic"")
			.charAt(0));
		label.setLabelFor(directory);
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0;
		layout.setConstraints(label,cons);
		multifile.add(label);

		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0;
		cons.gridwidth = 2;
		layout.setConstraints(directory,cons);
		multifile.add(directory);

		choose = new JButton(jEdit.getProperty(""search.choose""));
		choose.setMnemonic(jEdit.getProperty(""search.choose.mnemonic"")
			.charAt(0));
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0;
		cons.gridwidth = 1;
		layout.setConstraints(choose,cons);
		multifile.add(choose);
		choose.addActionListener(actionListener);

		cons.insets = new Insets(0,0,0,0);
		cons.gridy++;
		cons.gridwidth = 3;

		JPanel dirCheckBoxPanel = new JPanel();
 		searchSubDirectories = new JCheckBox(jEdit.getProperty(
 			""search.subdirs""));
 		String mnemonic = jEdit.getProperty(
			""search.subdirs.mnemonic"");
		searchSubDirectories.setMnemonic(mnemonic.charAt(0));
		searchSubDirectories.setSelected(jEdit.getBooleanProperty(""search.subdirs.toggle""));
		skipHidden = new JCheckBox(jEdit.getProperty(""search.skipHidden""));
		skipHidden.setSelected(jEdit.getBooleanProperty(""search.skipHidden.toggle"", true));
		skipBinaryFiles = new JCheckBox(jEdit.getProperty(""search.skipBinary""));
		skipBinaryFiles.setSelected(jEdit.getBooleanProperty(""search.skipBinary.toggle"", true));
		dirCheckBoxPanel.add(searchSubDirectories);
		dirCheckBoxPanel.add(skipHidden);
		dirCheckBoxPanel.add(skipBinaryFiles);

		cons.insets = new Insets(0, 0, 0, 0);
		cons.gridy++;
		cons.gridwidth = 4;
		layout.setConstraints(dirCheckBoxPanel, cons);

 		multifile.add(dirCheckBoxPanel);

		return multifile;
	} 

	
	private Box createButtonsPanel()
	{
		Box box = new Box(BoxLayout.Y_AXIS);

		ButtonActionHandler actionHandler = new ButtonActionHandler();

		box.add(Box.createVerticalStrut(12));

		JPanel grid = new JPanel(new GridLayout(5,1,0,12));

		findBtn = new JButton(jEdit.getProperty(""search.findBtn""));
		
		getRootPane().setDefaultButton(findBtn);
		grid.add(findBtn);
		findBtn.addActionListener(actionHandler);

		

		replaceAndFindBtn = new JButton(jEdit.getProperty(""search.replaceAndFindBtn""));
		replaceAndFindBtn.setMnemonic(jEdit.getProperty(""search.replaceAndFindBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAndFindBtn);
		replaceAndFindBtn.addActionListener(actionHandler);

		replaceAllBtn = new JButton(jEdit.getProperty(""search.replaceAllBtn""));
		replaceAllBtn.setMnemonic(jEdit.getProperty(""search.replaceAllBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAllBtn);
		replaceAllBtn.addActionListener(actionHandler);

		closeBtn = new JButton(jEdit.getProperty(""common.close""));
		grid.add(closeBtn);
		closeBtn.addActionListener(actionHandler);

		grid.setMaximumSize(grid.getPreferredSize());

		box.add(grid);
		box.add(Box.createGlue());

		return box;
	} 

	
	private void updateEnabled()
	{
		wrap.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());

		boolean reverseEnabled = !hyperSearch.isSelected()
			&& searchCurrentBuffer.isSelected();
		searchBack.setEnabled(reverseEnabled);
		searchForward.setEnabled(reverseEnabled);
		if(!reverseEnabled)
			searchForward.setSelected(true);

		filter.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());

		boolean searchDirs = searchDirectory.isSelected();
		directory.setEnabled(searchDirs);
		choose.setEnabled(searchDirs);
		searchSubDirectories.setEnabled(searchDirs);
		skipHidden.setEnabled(searchDirs);
		skipBinaryFiles.setEnabled(searchDirs);
		
		synchronize.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());

		findBtn.setEnabled(!searchSelection.isSelected()
			|| hyperSearch.isSelected());
		replaceAndFindBtn.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());
	} 

	
	
	private boolean save(boolean cancel)
	{
		try
		{
			
			
			saving = true;
			SearchAndReplace.setIgnoreCase(ignoreCase.isSelected());
			SearchAndReplace.setRegexp(regexp.isSelected());
			SearchAndReplace.setReverseSearch(searchBack.isSelected());
			SearchAndReplace.setAutoWrapAround(wrap.isSelected());
			jEdit.setBooleanProperty(""search.subdirs.toggle"", searchSubDirectories.isSelected());
			jEdit.setBooleanProperty(""search.skipHidden.toggle"", skipHidden.isSelected());
			jEdit.setBooleanProperty(""search.skipBinary.toggle"", skipBinaryFiles.isSelected());

			String filter = this.filter.getText();
			this.filter.addCurrentToHistory();
			if(filter.length() == 0)
				filter = ""*"";

			SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

			boolean recurse = searchSubDirectories.isSelected();

			if(searchSelection.isSelected())
				fileset = new CurrentBufferSet();
			else if(searchCurrentBuffer.isSelected())
			{
				fileset = new CurrentBufferSet();

				jEdit.setBooleanProperty(""search.hypersearch.toggle"",
					hyperSearch.isSelected());
			}
			else if(searchAllBuffers.isSelected())
				fileset = new AllBufferSet(filter);
			else if(searchDirectory.isSelected())
			{
				String directory = this.directory.getText();
				this.directory.addCurrentToHistory();
				directory = MiscUtilities.constructPath(
					view.getBuffer().getDirectory(),directory);

				if((VFSManager.getVFSForPath(directory).getCapabilities()
					& VFS.LOW_LATENCY_CAP) == 0)
				{
					if(cancel)
						return false;

					int retVal = GUIUtilities.confirm(
						this,""remote-dir-search"",
						null,JOptionPane.YES_NO_OPTION,
						JOptionPane.WARNING_MESSAGE);
					if(retVal != JOptionPane.YES_OPTION)
						return false;
				}

				if(fileset instanceof DirectoryListSet)
				{
					DirectoryListSet dset = (DirectoryListSet)fileset;
					dset.setDirectory(directory);
					dset.setFileFilter(filter);
					dset.setRecursive(recurse);
					EditBus.send(new SearchSettingsChanged(null));
				}
				else
					fileset = new DirectoryListSet(directory,filter,recurse);
			}
			else
			{
				
				fileset = null;
			}

			jEdit.setBooleanProperty(""search.subdirs.toggle"",
				recurse);
			jEdit.setBooleanProperty(""search.keepDialog.toggle"",
				keepDialog.isSelected());

			SearchAndReplace.setSearchFileSet(fileset);

			replace.addCurrentToHistory();
			SearchAndReplace.setReplaceString(replace.getText());

			if(find.getText().length() == 0)
			{
				if(!cancel)
					getToolkit().beep();
				return false;
			}

			find.addCurrentToHistory();
			SearchAndReplace.setSearchString(find.getText());

			return true;
		}
		finally
		{
			saving = false;
		}
	} 

	
	private void closeOrKeepDialog()
	{
		if(keepDialog.isSelected())
		{
			
			

			
			
			if(!hyperSearch.isSelected())
			{
				toFront();
				requestFocus();
				find.requestFocus();
			}
		}
		else
		{
			GUIUtilities.saveGeometry(this,""search"");
			setVisible(false);
		}
	} 

	
	private void load()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		wrap.setSelected(SearchAndReplace.getAutoWrapAround());

		if(SearchAndReplace.getReverseSearch())
			searchBack.setSelected(true);
		else
			searchForward.setSelected(true);

		if(SearchAndReplace.getBeanShellReplace())
		{
			replace.setModel(""replace.script"");
			beanShellReplace.setSelected(true);
		}
		else
		{
			replace.setModel(""replace"");
			stringReplace.setSelected(true);
		}

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

		HistoryModel model = filter.getModel();
		if(model.getSize() != 0)
			filter.setText(model.getItem(0));
		else
		{
			filter.setText('*' + MiscUtilities
				.getFileExtension(view.getBuffer()
				.getName()));
		}
		model = directory.getModel();
		if(model.getSize() != 0)
			directory.setText(model.getItem(0));
		else
			directory.setText(view.getBuffer().getDirectory());

		searchSubDirectories.setSelected(jEdit.getBooleanProperty(
			""search.subdirs.toggle""));

		if(fileset instanceof DirectoryListSet)
		{
			filter.setText(((DirectoryListSet)fileset)
				.getFileFilter());
			directory.setText(((DirectoryListSet)fileset)
				.getDirectory());
			searchSubDirectories.setSelected(((DirectoryListSet)fileset)
				.isRecursive());
		}
		else if(fileset instanceof AllBufferSet)
		{
			filter.setText(((AllBufferSet)fileset)
				.getFileFilter());
		}

		directory.addCurrentToHistory();

		keepDialog.setSelected(jEdit.getBooleanProperty(
			""search.keepDialog.toggle""));
	} 

	

	

	

	
	
	
	static class MyJRadioButton extends JRadioButton
	{
		MyJRadioButton(String label)
		{
			super(label);
		}

		@Override
		public boolean isFocusable()
		{
			return false;
		}
	} 

	
	class ReplaceActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			replace.setModel(beanShellReplace.isSelected()
				? ""replace.script""
				: ""replace"");
			SearchAndReplace.setBeanShellReplace(
				beanShellReplace.isSelected());
		}
	} 

	
	class SettingsActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == searchCurrentBuffer)
				hyperSearch.setSelected(false);
			else if(source == searchSelection
				|| source == searchAllBuffers
				|| source == searchDirectory)
				hyperSearch.setSelected(true);

			save(true);
			updateEnabled();
		}
	} 

	
	class MultiFileActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == choose)
			{
				String[] dirs = GUIUtilities.showVFSFileDialog(
					SearchDialog.this,
					view,directory.getText(),
					VFSBrowser.CHOOSE_DIRECTORY_DIALOG,
					false);
				if(dirs != null)
					directory.setText(dirs[0]);
			}
			else if(evt.getSource() == synchronize)
			{
				synchronizeMultiFileSettings();
			}
			else 
			{
				
				
				ok();
			}
		}


		
		private void synchronizeMultiFileSettings()
		{
			directory.setText(view.getBuffer().getDirectory());

			SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

			if(fileset instanceof AllBufferSet)
			{
				filter.setText(((AllBufferSet)fileset)
					.getFileFilter());
			}
			else
			{
				filter.setText('*' + MiscUtilities
					.getFileExtension(view.getBuffer()
					.getName()));
			}
		} 
	} 

	
	class ButtonActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == closeBtn)
				cancel();
			else if(source == findBtn || source == find
				|| source == replace)
			{
				ok();
			}
			else if(source == replaceAndFindBtn)
			{
				save(false);
				if(SearchAndReplace.replace(view))
					ok();
				else
					getToolkit().beep();
			}
			else if(source == replaceAllBtn)
			{
				if(searchSelection.isSelected() &&
					view.getTextArea().getSelectionCount()
					== 0)
				{
					GUIUtilities.error(view,""search-no-selection"",null);
					return;
				}

				setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

				if(!save(false))
				{
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					getToolkit().beep();
					return;
				}

				if(searchSelection.isSelected())
				{
					if(SearchAndReplace.replace(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}
				else
				{
					if(SearchAndReplace.replaceAll(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}

				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			}
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.DisplayManager,33,1,0,21,108,70,13,13,15,0.659375,1485,0.6,7,0.0,0.232142857,0,0,43.6969697,19,4.0909,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.Toolkit;
import java.util.*;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;



public class DisplayManager
{
	

	
	static DisplayManager getDisplayManager(JEditBuffer buffer,
		TextArea textArea)
	{
		List<DisplayManager> l = bufferMap.get(buffer);
		if(l == null)
		{
			l = new LinkedList<DisplayManager>();
			bufferMap.put(buffer,l);
		}

		
		DisplayManager copy = null;
		Iterator<DisplayManager> liter = l.iterator();
		DisplayManager dmgr;
		while(liter.hasNext())
		{
			dmgr = liter.next();
			copy = dmgr;
			if(!dmgr.inUse && dmgr.textArea == textArea)
			{
				dmgr.inUse = true;
				return dmgr;
			}
		}

		
		dmgr = new DisplayManager(buffer,textArea,copy);
		dmgr.inUse = true;
		l.add(dmgr);

		return dmgr;
	} 

	
	void release()
	{
		inUse = false;
	} 

	
	public static void bufferClosed(JEditBuffer buffer)
	{
		bufferMap.remove(buffer);
	} 

	
	static void textAreaDisposed(TextArea textArea)
	{
		for (List<DisplayManager> l : bufferMap.values())
		{
			Iterator<DisplayManager> liter = l.iterator();
			while(liter.hasNext())
			{
				DisplayManager dmgr = liter.next();
				if(dmgr.textArea == textArea)
				{
					dmgr.dispose();
					liter.remove();
				}
			}
		}
	} 

	private static final Map<JEditBuffer, List<DisplayManager>> bufferMap = new HashMap<JEditBuffer, List<DisplayManager>>();
	

	
	
	public JEditBuffer getBuffer()
	{
		return buffer;
	} 

	
	
	public final boolean isLineVisible(int line)
	{
		return folds.search(line) % 2 == 0;
	} 

	
	
	public int getFirstVisibleLine()
	{
		return folds.first();
	} 

	
	
	public int getLastVisibleLine()
	{
		return folds.last();
	} 

	
	
	public int getNextVisibleLine(int line)
	{
		if(line < 0 || line >= buffer.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		return folds.next(line);
	} 

	
	
	public int getPrevVisibleLine(int line)
	{
		if(line < 0 || line >= buffer.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		return folds.prev(line);
	} 

	
	
	public final int getScreenLineCount(int line)
	{
		updateScreenLineCount(line);
		return screenLineMgr.getScreenLineCount(line);
	} 

	
	
	public final int getScrollLineCount()
	{
		return scrollLineCount.scrollLine;
	} 

	
	
	public void collapseFold(int line)
	{
		int lineCount = buffer.getLineCount();
		int end = lineCount - 1;

		
		
		if(line != 0
			&& line != buffer.getLineCount() - 1
			&& buffer.isFoldStart(line)
			&& !isLineVisible(line + 1))
		{
			line--;
		}

		int initialFoldLevel = buffer.getFoldLevel(line);

		
		int start = 0;
		if(line != lineCount - 1
			&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
		{
			
			start = line + 1;

			for(int i = line + 1; i < lineCount; i++)
			{
				if(buffer.getFoldLevel(i) <= initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		}
		else
		{
			boolean ok = false;

			
			for(int i = line - 1; i >= 0; i--)
			{
				if(buffer.getFoldLevel(i) < initialFoldLevel)
				{
					start = i + 1;
					ok = true;
					break;
				}
			}

			if(!ok)
			{
				
				return;
			}

			for(int i = line + 1; i < lineCount; i++)
			{
				if(buffer.getFoldLevel(i) < initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		} 

		
		hideLineRange(start,end);

		notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} 

	
	
	public int expandFold(int line, boolean fully)
	{
		
		int returnValue = -1;

		int lineCount = buffer.getLineCount();
		int end = lineCount - 1;

		if (line == lineCount - 1)
		{
			return -1;
		}
		while (!isLineVisible(line))
		{
			int prevLine = folds.lookup(folds.search(line)) - 1;
			if (!isLineVisible(prevLine))
			{
				return -1;
			}
			expandFold(prevLine, fully);
			if (!isLineVisible(prevLine + 1))
			{
				return -1;
			}
		}
		if (isLineVisible(line+1) && !fully)
		{
			return -1;
		}

		
		int start;
		int initialFoldLevel = buffer.getFoldLevel(line);
		if (buffer.getFoldLevel(line + 1) > initialFoldLevel)
		{
			
			start = line;
			if (!isLineVisible(line + 1) && folds.search(line + 1) != folds.count() - 1)
			{
				int index = folds.search(line + 1);
				end = folds.lookup(index + 1) - 1;
			}
			else
			{
				for (int i = line + 1; i < lineCount; i++)
				{
					if (buffer.getFoldLevel(i) <= initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			}
		}
		else
		{
			if (!fully)
			{
				return -1;
			}
			start = line;
			while (start > 0 && buffer.getFoldLevel(start) >= initialFoldLevel)
			{
				start--;
			}
			initialFoldLevel = buffer.getFoldLevel(start);
			for (int i = line + 1; i < lineCount; i++)
			{
				if (buffer.getFoldLevel(i) <= initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		} 

		
		if(fully)
		{
			showLineRange(start,end);
		}
		else
		{
			for (int i = start + 1; i <= end;)
			{
				if (returnValue == -1 && buffer.isFoldStart(i))
				{
					returnValue = i;
				}

				showLineRange(i, i);
				int fold = buffer.getFoldLevel(i);
				i++;
				while (i <= end && buffer.getFoldLevel(i) > fold)
				{
					i++;
				}
			}
		} 

		notifyScreenLineChanges();
		textArea.foldStructureChanged();

		return returnValue;
	} 

	
	
	public void expandAllFolds()
	{
		showLineRange(0,buffer.getLineCount() - 1);
		notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} 

	
	
	public void expandFolds(char digit)
	{
		if(digit < '1' || digit > '9')
		{
			Toolkit.getDefaultToolkit().beep();
		}
		else
			expandFolds((digit - '1') + 1);
	} 

	
	
	public void expandFolds(int foldLevel)
	{
		if(buffer.getFoldHandler() instanceof IndentFoldHandler)
			foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;

		showLineRange(0,buffer.getLineCount() - 1);

		
		boolean seenVisibleLine = false;

		int firstInvisible = 0;

		for(int i = 0; i < buffer.getLineCount(); i++)
		{
			if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)
			{
				if(firstInvisible != i)
				{
					hideLineRange(firstInvisible,
						i - 1);
				}
				firstInvisible = i + 1;
				seenVisibleLine = true;
			}
		}

		if(firstInvisible != buffer.getLineCount())
			hideLineRange(firstInvisible,buffer.getLineCount() - 1);

		notifyScreenLineChanges();
		if(textArea.getDisplayManager() == this)
		{
			textArea.foldStructureChanged();
		}
	} 

	
	
	public void narrow(int start, int end)
	{
		if(start > end || start < 0 || end >= buffer.getLineCount())
			throw new ArrayIndexOutOfBoundsException(start + "", "" + end);

		if(start < getFirstVisibleLine() || end > getLastVisibleLine())
			expandAllFolds();

		if(start != 0)
			hideLineRange(0,start - 1);
		if(end != buffer.getLineCount() - 1)
			hideLineRange(end + 1,buffer.getLineCount() - 1);

		
		if(start != buffer.getLineCount() - 1
			&& !isLineVisible(start + 1))
			expandFold(start,false);

		textArea.fireNarrowActive();

		notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} 

	
	final FirstLine firstLine;
	final ScrollLineCount scrollLineCount;
	final ScreenLineManager screenLineMgr;
	RangeMap folds;

	
	void init()
	{
		if(initialized)
		{
			if(!buffer.isLoading())
				resetAnchors();
		}
		else
		{
			initialized = true;
			folds = new RangeMap();
			if(buffer.isLoading())
				folds.reset(buffer.getLineCount());
			else
				bufferHandler.foldHandlerChanged(buffer);
			notifyScreenLineChanges();
		}
	} 

	
	void notifyScreenLineChanges()
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""notifyScreenLineChanges()"");

		
		
		if(textArea.getDisplayManager() != this)
			return;

		try
		{
			if(firstLine.callReset)
				firstLine.reset();
			else if(firstLine.callChanged)
				firstLine.changed();

			if(scrollLineCount.callReset)
			{
				scrollLineCount.reset();
				firstLine.ensurePhysicalLineIsVisible();
			}
			else if(scrollLineCount.callChanged)
				scrollLineCount.changed();
			
			if(firstLine.callChanged || scrollLineCount.callReset
				|| scrollLineCount.callChanged)
			{
				textArea.updateScrollBar();
				textArea.recalculateLastPhysicalLine();
			}
		}
		finally
		{
			firstLine.callReset = firstLine.callChanged = false;
			scrollLineCount.callReset = scrollLineCount.callChanged = false;
		}
	} 

	
	void setFirstLine(int oldFirstLine, int firstLine)
	{
		int visibleLines = textArea.getVisibleLines();

		if(firstLine >= oldFirstLine + visibleLines)
		{
			this.firstLine.scrollDown(firstLine - oldFirstLine);
			textArea.chunkCache.invalidateAll();
		}
		else if(firstLine <= oldFirstLine - visibleLines)
		{
			this.firstLine.scrollUp(oldFirstLine - firstLine);
			textArea.chunkCache.invalidateAll();
		}
		else if(firstLine > oldFirstLine)
		{
			this.firstLine.scrollDown(firstLine - oldFirstLine);
			textArea.chunkCache.scrollDown(firstLine - oldFirstLine);
		}
		else if(firstLine < oldFirstLine)
		{
			this.firstLine.scrollUp(oldFirstLine - firstLine);
			textArea.chunkCache.scrollUp(oldFirstLine - firstLine);
		}

		notifyScreenLineChanges();
	} 

	
	
	void setFirstPhysicalLine(int amount, int skew)
	{
		int oldFirstLine = textArea.getFirstLine();

		if(amount == 0)
		{
			skew -= this.firstLine.skew;

			
			
			if(skew < 0)
				this.firstLine.scrollUp(-skew);
			else if(skew > 0)
				this.firstLine.scrollDown(skew);
			else
			{
				
				return;
			}
		}
		else if(amount > 0)
			this.firstLine.physDown(amount,skew);
		else if(amount < 0)
			this.firstLine.physUp(-amount,skew);

		int firstLine = textArea.getFirstLine();
		int visibleLines = textArea.getVisibleLines();

		if(firstLine == oldFirstLine)
			;
		else if(firstLine >= oldFirstLine + visibleLines
			|| firstLine <= oldFirstLine - visibleLines)
		{
			textArea.chunkCache.invalidateAll();
		}
		else if(firstLine > oldFirstLine)
		{
			textArea.chunkCache.scrollDown(firstLine - oldFirstLine);
		}
		else if(firstLine < oldFirstLine)
		{
			textArea.chunkCache.scrollUp(oldFirstLine - firstLine);
		}

		
		notifyScreenLineChanges();
	} 

	
	void invalidateScreenLineCounts()
	{
		screenLineMgr.invalidateScreenLineCounts();
		firstLine.callReset = true;
		scrollLineCount.callReset = true;
	} 

	
	void updateScreenLineCount(int line)
	{
		if(!screenLineMgr.isScreenLineCountValid(line))
		{
			int newCount = textArea.chunkCache
				.getLineSubregionCount(line);

			setScreenLineCount(line,newCount);
		}
	} 

	
	void bufferLoaded()
	{
		folds.reset(buffer.getLineCount());
		screenLineMgr.reset();

		if(textArea.getDisplayManager() == this)
		{
			textArea.propertiesChanged();
			init();
		}

		int collapseFolds = buffer.getIntegerProperty(
			""collapseFolds"",0);
		if(collapseFolds != 0)
			expandFolds(collapseFolds);
	} 

	
	void foldHandlerChanged()
	{
		if(buffer.isLoading())
			return;

		folds.reset(buffer.getLineCount());
		resetAnchors();

		int collapseFolds = buffer.getIntegerProperty(
			""collapseFolds"",0);
		if(collapseFolds != 0)
			expandFolds(collapseFolds);
	} 

	

	
	private boolean initialized;
	private boolean inUse;
	private final JEditBuffer buffer;
	private final TextArea textArea;
	private final BufferHandler bufferHandler;

	
	private DisplayManager(JEditBuffer buffer, TextArea textArea,
		DisplayManager copy)
	{
		this.buffer = buffer;
		this.screenLineMgr = new ScreenLineManager(buffer);
		this.textArea = textArea;

		scrollLineCount = new ScrollLineCount(this,textArea);
		firstLine = new FirstLine(this,textArea);

		bufferHandler = new BufferHandler(this,textArea,buffer);
		
		buffer.addBufferListener(bufferHandler, JEditBuffer.HIGH_PRIORITY);

		if(copy != null)
		{
			folds = new RangeMap(copy.folds);
			initialized = true;
		}
	} 

	
	private void resetAnchors()
	{
		firstLine.callReset = true;
		scrollLineCount.callReset = true;
		notifyScreenLineChanges();
	} 

	
	private void dispose()
	{
		buffer.removeBufferListener(bufferHandler);
	} 

	
	private void showLineRange(int start, int end)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			Log.log(Log.DEBUG,this,""showLineRange("" + start
				+ ',' + end + ')');
		}

		for(int i = start; i <= end; i++)
		{
			
			if(!isLineVisible(i))
			{
				
				int screenLines = getScreenLineCount(i);
				if(firstLine.physicalLine >= i)
				{
					firstLine.scrollLine += screenLines;
					firstLine.callChanged = true;
				}
				scrollLineCount.scrollLine += screenLines;
				scrollLineCount.callChanged = true;
			}
		}

		
		folds.show(start,end);
	} 

	
	private void hideLineRange(int start, int end)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			Log.log(Log.DEBUG,this,""hideLineRange("" + start
				+ ',' + end + ')');
		}

		int i = start;
		if(!isLineVisible(i))
			i = getNextVisibleLine(i);
		while(i != -1 && i <= end)
		{
			int screenLines = getScreenLineCount(i);
			if(i < firstLine.physicalLine)
			{
				firstLine.scrollLine -= screenLines;
				firstLine.skew = 0;
				firstLine.callChanged = true;
			}

			scrollLineCount.scrollLine -= screenLines;
			scrollLineCount.callChanged = true;

			i = getNextVisibleLine(i);
		}

		
		folds.hide(start,end);

		if(!isLineVisible(firstLine.physicalLine))
		{
			int firstVisible = getFirstVisibleLine();
			if(firstLine.physicalLine < firstVisible)
			{
				firstLine.physicalLine = firstVisible;
				firstLine.scrollLine = 0;
			}
			else
			{
				firstLine.physicalLine = getPrevVisibleLine(
					firstLine.physicalLine);
				firstLine.scrollLine -= getScreenLineCount(
					firstLine.physicalLine);
			}
			firstLine.callChanged = true;
		}
	} 

	
	
	private void setScreenLineCount(int line, int count)
	{
		int oldCount = screenLineMgr.getScreenLineCount(line);

		
		

		screenLineMgr.setScreenLineCount(line,count);

		if(count == oldCount)
			return;

		if(!isLineVisible(line))
			return;

		if(firstLine.physicalLine >= line)
		{
			if(firstLine.physicalLine == line)
				firstLine.callChanged = true;
			else
			{
				firstLine.scrollLine += count - oldCount;
				firstLine.callChanged = true;
			}
		}

		scrollLineCount.scrollLine += count - oldCount;
		scrollLineCount.callChanged = true;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.EditPaneUpdate,5,2,1,10,13,4,8,3,4,0.928571429,61,0.142857143,0,0.5,0.5,1,1,9.8,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class EditPaneUpdate extends EBMessage
{
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object DESTROYED = ""DESTROYED"";
	
	public static final Object BUFFER_CHANGED = ""BUFFER_CHANGED"";
	
	public static final Object POSITION_CHANGING = ""POSITION_CHANGING"";
	
	public static final Object BUFFER_CHANGING = ""BUFFER_CHANGING"";

	
	public static final Object BUFFERSET_CHANGED = ""BUFFERSET_CHANGED"";
	
	
	public EditPaneUpdate(EditPane editPane, Object what)
	{
		super(editPane);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	}

	
	public Object getWhat()
	{
		return what;
	}

	
	public EditPane getEditPane()
	{
		return (EditPane)getSource();
	}

	public String paramString()
	{
		return ""what="" + what + "","" + super.paramString();
	}
	
	
	private Object what;

}
"
jEdit,4.3,org.gjt.sp.jedit.help.HelpTOCPanel,12,5,0,18,61,36,6,16,3,0.690909091,377,1.0,1,0.983433735,0.3,0,0,30.0,6,1.5,1,"

package org.gjt.sp.jedit.help;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.util.*;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.browser.FileCellRenderer; 
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.XMLUtilities;

import static javax.swing.tree.TreeSelectionModel.SINGLE_TREE_SELECTION;


public class HelpTOCPanel extends JPanel
{
	
	public HelpTOCPanel(HelpViewerInterface helpViewer)
	{
		super(new BorderLayout());

		this.helpViewer = helpViewer;
		nodes = new Hashtable();

		toc = new TOCTree();

		
		if(!OperatingSystem.isMacOSLF())
			toc.putClientProperty(""JTree.lineStyle"", ""Angled"");

		toc.setCellRenderer(new TOCCellRenderer());
		toc.setEditable(false);
		toc.setShowsRootHandles(true);

		add(BorderLayout.CENTER,new JScrollPane(toc));

		load();
	} 

	
	public void selectNode(String shortURL)
	{
		if(tocModel == null)
			return;

		DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.get(shortURL);

		if(node == null)
			return;

		TreePath path = new TreePath(tocModel.getPathToRoot(node));
		toc.expandPath(path);
		toc.setSelectionPath(path);
		toc.scrollPathToVisible(path);
	} 

	
	public void load()
	{
		DefaultTreeModel empty = new DefaultTreeModel(
			new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.loading"")));
		toc.setModel(empty);
		toc.setRootVisible(true);

		VFSManager.runInWorkThread(new Runnable()
		{
			public void run()
			{
				createTOC();
				tocModel.reload(tocRoot);
				toc.setModel(tocModel);
				toc.setRootVisible(false);
				for(int i = 0; i <tocRoot.getChildCount(); i++)
				{
					DefaultMutableTreeNode node =
						(DefaultMutableTreeNode)
						tocRoot.getChildAt(i);
					toc.expandPath(new TreePath(
						node.getPath()));
				}
				if(helpViewer.getShortURL() != null)
					selectNode(helpViewer.getShortURL());
			}
		});
	} 

	
	private HelpViewerInterface helpViewer;
	private DefaultTreeModel tocModel;
	private DefaultMutableTreeNode tocRoot;
	private JTree toc;
	private Hashtable nodes;

	
	private DefaultMutableTreeNode createNode(String href, String title)
	{
		DefaultMutableTreeNode node = new DefaultMutableTreeNode(
			new HelpNode(href,title),true);
		nodes.put(href,node);
		return node;
	} 

	
	private void createTOC()
	{
		EditPlugin[] plugins = jEdit.getPlugins();
		Arrays.sort(plugins,new PluginCompare());
		tocRoot = new DefaultMutableTreeNode();

		tocRoot.add(createNode(""welcome.html"",
			jEdit.getProperty(""helpviewer.toc.welcome"")));

		tocRoot.add(createNode(""README.txt"",
			jEdit.getProperty(""helpviewer.toc.readme"")));
		tocRoot.add(createNode(""CHANGES.txt"",
			jEdit.getProperty(""helpviewer.toc.changes"")));
		tocRoot.add(createNode(""TODO.txt"",
			jEdit.getProperty(""helpviewer.toc.todo"")));
		tocRoot.add(createNode(""COPYING.txt"",
			jEdit.getProperty(""helpviewer.toc.copying"")));
		tocRoot.add(createNode(""COPYING.DOC.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-doc"")));
		tocRoot.add(createNode(""Apache.LICENSE.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-apache"")));
		tocRoot.add(createNode(""COPYING.PLUGINS.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-plugins"")));

		loadTOC(tocRoot,""news43/toc.xml"");
		loadTOC(tocRoot,""users-guide/toc.xml"");
		loadTOC(tocRoot,""FAQ/toc.xml"");


		DefaultMutableTreeNode pluginTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.plugins""),true);

		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];

			String name = plugin.getClassName();

			String docs = jEdit.getProperty(""plugin."" + name + "".docs"");
			String label = jEdit.getProperty(""plugin."" + name + "".name"");
			if(docs != null)
			{
				if(label != null && docs != null)
				{
					String path = plugin.getPluginJAR()
						.getClassLoader()
						.getResourceAsPath(docs);
					pluginTree.add(createNode(
						path,label));
				}
			}
		}

		if(pluginTree.getChildCount() != 0)
			tocRoot.add(pluginTree);
		else
		{
			
			pluginTree = null;
		}
		loadTOC(tocRoot,""api/toc.xml"");
		tocModel = new DefaultTreeModel(tocRoot);
	} 

	
	private void loadTOC(DefaultMutableTreeNode root, String path)
	{
		TOCHandler h = new TOCHandler(root,MiscUtilities.getParentOfPath(path));
		try
		{
			XMLUtilities.parseXML(
				new URL(helpViewer.getBaseURL()
					+ '/' + path).openStream(), h);
		}
		catch(FileNotFoundException e)
		{
			
			if(""api/toc.xml"".equals(path))
			{
				Log.log(Log.NOTICE,this,
					""The API docs for jEdit will not be available (reinstall jEdit if you want them)"");
				root.add(
					createNode(""http:
						jEdit.getProperty(""helpviewer.toc.online-apidocs"")));
			}
			else
			{
				Log.log(Log.ERROR,this,e);
			}
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} 

	

	
	static class HelpNode
	{
		String href, title;

		
		HelpNode(String href, String title)
		{
			this.href = href;
			this.title = title;
		} 

		
		public String toString()
		{
			return title;
		} 
	} 

	
	class TOCHandler extends DefaultHandler
	{
		String dir;

		
		TOCHandler(DefaultMutableTreeNode root, String dir)
		{
			nodes = new Stack();
			node = root;
			this.dir = dir;
		} 

		
		public void characters(char[] c, int off, int len)
		{
			if(tag.equals(""TITLE""))
			{
				boolean firstNonWhitespace = false;
				for(int i = 0; i < len; i++)
				{
					char ch = c[off + i];
					if (!firstNonWhitespace && Character.isWhitespace(ch)) continue;
					firstNonWhitespace = true;
					title.append(ch);
				}
			}


		} 

		
		public void startElement(String uri, String localName,
					 String name, Attributes attrs)
		{
			tag = name;
			if (name.equals(""ENTRY""))
				href = attrs.getValue(""HREF"");
		} 

		
		public void endElement(String uri, String localName, String name)
		{
			if(name == null)
				return;

			if(name.equals(""TITLE""))
			{
				DefaultMutableTreeNode newNode = createNode(
					dir + href,title.toString());
				node.add(newNode);
				nodes.push(node);
				node = newNode;
				title.setLength(0);
			}
			else if(name.equals(""ENTRY""))
			{
				node = (DefaultMutableTreeNode)nodes.pop();
				href = null;
			}
		} 

		
		private String tag;
		private StringBuilder title = new StringBuilder();
		private String href;
		private DefaultMutableTreeNode node;
		private Stack nodes;
		
	} 

	
	class TOCTree extends JTree
	{
		
		TOCTree()
		{
			ToolTipManager.sharedInstance().registerComponent(this);
			selectionModel.setSelectionMode(SINGLE_TREE_SELECTION);
		} 

		
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		} 

		
		 

		
		public void processKeyEvent(KeyEvent evt)
		{
			if ((KeyEvent.KEY_PRESSED == evt.getID()) &&
			    (KeyEvent.VK_ENTER == evt.getKeyCode()))
			{
				TreePath path = getSelectionPath();
				if(path != null)
				{
					Object obj = ((DefaultMutableTreeNode)
						path.getLastPathComponent())
						.getUserObject();
					if(!(obj instanceof HelpNode))
					{
						this.expandPath(path);
						return;
					}

					HelpNode node = (HelpNode)obj;
					helpViewer.gotoURL(node.href,true,0);
				}
				evt.consume();
			}
			else
			{
				super.processKeyEvent(evt);
			}
		} 

		
		protected void processMouseEvent(MouseEvent evt)
		{
			

			switch(evt.getID())
			{
			
			case MouseEvent.MOUSE_CLICKED:
				TreePath path = getPathForLocation(evt.getX(),evt.getY());
				if(path != null)
				{
					if(!isPathSelected(path))
						setSelectionPath(path);

					Object obj = ((DefaultMutableTreeNode)
						path.getLastPathComponent())
						.getUserObject();
					if(!(obj instanceof HelpNode))
					{
						this.expandPath(path);
						return;
					}

					HelpNode node = (HelpNode)obj;

					helpViewer.gotoURL(node.href,true,0);
				}

				super.processMouseEvent(evt);
				break;
			default:
				super.processMouseEvent(evt);
				break;
			}
		} 

		
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = TOCTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		} 
	} 

	
	class TOCCellRenderer extends DefaultTreeCellRenderer
	{
		EmptyBorder border = new EmptyBorder(1,0,1,1);

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean focus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,focus);
			setIcon(leaf ? FileCellRenderer.fileIcon
				: (expanded ? FileCellRenderer.openDirIcon
				: FileCellRenderer.dirIcon));
			setBorder(border);

			return this;
		}
	} 

	
	static class PluginCompare implements Comparator
	{
		public int compare(Object o1, Object o2)
		{
			EditPlugin p1 = (EditPlugin)o1;
			EditPlugin p2 = (EditPlugin)o2;
			return StandardUtilities.compareStrings(
				jEdit.getProperty(""plugin."" + p1.getClassName() + "".name""),
				jEdit.getProperty(""plugin."" + p2.getClassName() + "".name""),
				true);
		}
	} 
}"
jEdit,4.3,org.gjt.sp.jedit.gui.NumericTextField,3,6,0,2,9,1,2,0,2,0.0,37,1.0,0,0.998738966,0.583333333,3,3,11.0,5,1.6667,0,"
package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.KeyEvent;


public class NumericTextField extends JTextField
{
	private final boolean positiveOnly;

	public NumericTextField(String text)
	{
		this(text, false);
	}

	public NumericTextField(String text, boolean positiveOnly)
	{
		super(text);
		this.positiveOnly = positiveOnly;
	}

	@Override
	protected void processKeyEvent(KeyEvent e)
	{
		if (e.getID() == KeyEvent.KEY_TYPED)
		{
			if (!Character.isDigit(e.getKeyChar()) && !(!positiveOnly && e.getKeyChar() == '-'))
			{
				e.consume();
			}
		}
		super.processKeyEvent(e);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.indent.DeepIndentRule,5,1,0,6,18,6,2,5,2,0.75,161,1.0,0,0.0,0.314285714,0,0,30.8,8,2.8,0,"

package org.gjt.sp.jedit.indent;

import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.jedit.buffer.JEditBuffer;

import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.jedit.syntax.TokenHandler;
import org.gjt.sp.jedit.syntax.TokenMarker;

import java.util.List;
import java.util.Stack;
import javax.swing.text.Segment;


public class DeepIndentRule implements IndentRule
{
	private final char openChar;
	private final char closeChar;

	public DeepIndentRule(char openChar, char closeChar)
	{
		this.openChar = openChar;
		this.closeChar = closeChar;
	}

	
	public void apply(JEditBuffer buffer, int thisLineIndex,
			  int prevLineIndex, int prevPrevLineIndex,
			  List<IndentAction> indentActions)
	{
		if (prevLineIndex == -1)
			return;

		int lineIndex = prevLineIndex;
		int oldLineIndex = lineIndex;
		CharSequence lineText = buffer.getLineSegment(lineIndex);
		int searchPos = -1;
		while (true)
		{
			if (lineIndex != oldLineIndex)
			{
				lineText = buffer.getLineSegment(lineIndex);
				oldLineIndex = lineIndex;
			}
			Parens parens = new Parens(buffer, lineIndex, searchPos);

			
			if (parens.openOffset == -1 && parens.closeOffset == -1)
			{
				
				if (prevPrevLineIndex != -1) {
					searchPos = -1;
					lineIndex = prevPrevLineIndex;
					prevPrevLineIndex = -1;
					continue;
				}
				return;
			}

			
			
			if (parens.closeOffset == -1)
			{
				
				int indent = parens.openOffset + getIndent(lineText, buffer.getTabSize()) - lineText.length();
				indentActions.clear();
				indentActions.add(new IndentAction.AlignParameter(indent));
				return;
			}

			
			
			int openParenOffset = TextUtilities.findMatchingBracket(buffer, lineIndex, parens.closeOffset);
			if (openParenOffset >= 0)
			{
				
				prevPrevLineIndex = -1;
				lineIndex = buffer.getLineOfOffset(openParenOffset);
				searchPos = openParenOffset - buffer.getLineStartOffset(lineIndex) - 1;
				if (searchPos < 0)
					break;
			}
			else
				break;
		}
	} 


	
	private int getIndent(CharSequence line, int tabSize)
	{
		int cnt = 0;
		for (int i = 0;  i < line.length(); i++)
		{
			if (line.charAt(i) == '\t')
			{
				cnt += tabSize;
			}
			else
			{
				if (!Character.isWhitespace(line.charAt(i)))
				{
					cnt += (line.length() - i);
					break;
				}
				cnt++;
			}
		}
		return cnt;
	}


	
	private class Parens implements TokenHandler
	{
		int openOffset;
		int closeOffset;

		private int searchPos;
		private Stack<Integer> open;
		private Stack<Integer> close;

		Parens(JEditBuffer b, int line, int pos)
		{
			this.searchPos = pos;
			this.open = new Stack<Integer>();
			this.close = new Stack<Integer>();
			b.markTokens(line, this);
			openOffset = (open.isEmpty()) ? -1 : open.pop();
			closeOffset = (close.isEmpty()) ? -1 : close.pop();
		}

		public void handleToken(Segment seg,
					byte id,
					int offset,
					int length,
					TokenMarker.LineContext context)
		{
			if (length <= 0 ||
			    (searchPos != -1 && searchPos < offset))
			{
				return;
			}

			if (searchPos != -1 && offset + length > searchPos)
			{
				length = searchPos - offset + 1;
			}

			switch (id)
			{
			case Token.COMMENT1:
			case Token.COMMENT2:
			case Token.COMMENT3:
			case Token.COMMENT4:
			case Token.LITERAL1:
			case Token.LITERAL2:
			case Token.LITERAL3:
			case Token.LITERAL4:
				
				break;
			default:
				for (int i = offset; i < offset + length; i++)
				{
					if (seg.array[seg.offset + i] == openChar)
					{
						if (open.isEmpty() && !close.isEmpty())
							close.pop();
						else
							open.push(i);
					}
					else if (seg.array[seg.offset + i] == closeChar)
					{
						if (close.isEmpty() && !open.isEmpty())
							open.pop();
						else
							close.push(i);
					}
				}
				break;
			}
		}

		public void setLineContext(TokenMarker.LineContext lineContext)
		{
			
		}

		@Override
		public String toString()
		{
			return ""Parens("" + openOffset + ',' + closeOffset + ')';
		}
	} 

}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.Name,20,1,0,23,79,102,7,19,8,0.771929825,1583,0.555555556,1,0.0,0.252631579,0,0,77.7,5,1.8,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;



class Name implements java.io.Serializable
{
	
	public NameSpace namespace;
	String value = null;
	
	
	
	

	
	
	private String evalName;
	
	private String lastEvalName;
	private static String FINISHED = null; 
	private Object evalBaseObject;	

	private int callstackDepth;		

	
	
	

	
	

	
	

	
	Class asClass;

	
	Class classOfStaticMethod;

	

	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
	}

	
	
	Name( NameSpace namespace, String s )
	{
		this.namespace = namespace;
		value = s;
	}

	
	public Object toObject( CallStack callstack, Interpreter interpreter ) 
		throws UtilEvalError
	{
		return toObject( callstack, interpreter, false );
	}

	
	synchronized public Object toObject( 
		CallStack callstack, Interpreter interpreter, boolean forceClass ) 
		throws UtilEvalError
	{
		reset();

		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField( 
				callstack, interpreter, forceClass, false  );

		if ( obj == null )
			throw new InterpreterError(""null value in toObject()"");

		return obj;
	}

	private Object completeRound( 
		String lastEvalName, String nextEvalName, Object returnObject )
	{
		if ( returnObject == null )
			throw new InterpreterError(""lastEvalName = ""+lastEvalName);
		this.lastEvalName = lastEvalName;
		this.evalName = nextEvalName;
		this.evalBaseObject = returnObject;
		return returnObject;
	}

	
	private Object consumeNextObjectField( 	
		CallStack callstack, Interpreter interpreter, 
		boolean forceClass, boolean autoAllocateThis ) 
		throws UtilEvalError
	{
		
		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( 
				callstack, namespace, interpreter, evalName, false );

			if ( obj != Primitive.VOID )
				return completeRound( evalName, FINISHED, obj );
		}

		
		String varName = prefix(evalName, 1);
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug(""trying to resolve variable: "" + varName);

			Object obj;
			
			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference( 
					callstack, namespace, interpreter, varName, false );
			} else {
				obj = resolveThisFieldReference( 
					callstack, ((This)evalBaseObject).namespace, 
					interpreter, varName, true );
			}

			if ( obj != Primitive.VOID ) 
			{
				
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( ""resolved variable: "" + varName + 
					"" in namespace: ""+namespace);

				return completeRound( varName, suffix(evalName), obj );
			}
		}

		
		if ( evalBaseObject == null ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( ""trying class: "" + evalName);
			
			
			Class clas = null;
			int i = 1;
			String className = null;
			for(; i <= countParts(evalName); i++)
			{
				className = prefix(evalName, i);
				if ( (clas = namespace.getClass(className)) != null )
					break;
			}
		
			if ( clas != null )  {
				return completeRound(
					className,
					suffix( evalName, countParts(evalName)-i ),
					new ClassIdentifier(clas) 
				);
			}
			
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( ""not a class, trying var prefix ""+evalName );
		}

		
		
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass && autoAllocateThis )
		{
			NameSpace targetNameSpace = 
				( evalBaseObject == null ) ?  
					namespace : ((This)evalBaseObject).namespace;
			Object obj = new NameSpace( 
				targetNameSpace, ""auto: ""+varName ).getThis( interpreter );
			targetNameSpace.setVariable( varName, obj, false );
			return completeRound( varName, suffix(evalName), obj );
		}

		
		if ( evalBaseObject == null ) {
			if ( !isCompound(evalName) ) {
				return completeRound( evalName, FINISHED, Primitive.VOID );
			} else
				throw new UtilEvalError(
					""Class or variable not found: "" + evalName);
		}

		

		

		if ( evalBaseObject == Primitive.NULL) 
			throw new UtilTargetError( new NullPointerException( 
				""Null Pointer while evaluating: "" +value ) );

		if ( evalBaseObject == Primitive.VOID) 
			throw new UtilEvalError(
				""Undefined variable or class name while evaluating: ""+value);

		if ( evalBaseObject instanceof Primitive)
			throw new UtilEvalError(""Can't treat primitive like an object. ""+
			""Error while evaluating: ""+value);

		
		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);

			
			
			if ( field.equals(""this"") )
			{
				
				NameSpace ns = namespace;
				while ( ns != null )
				{
					
					if ( ns.classInstance != null 
						&& ns.classInstance.getClass() == clas 
					)
						return completeRound( 
							field, suffix(evalName), ns.classInstance );
					ns=ns.getParent();
				}
				throw new UtilEvalError(
					""Can't find enclosing 'this' instance of class: ""+clas);
			}

			Object obj = null;
			
			try {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug(""Name call to getStaticFieldValue, class: ""
						+clas+"", field:""+field);
				obj = Reflect.getStaticFieldValue(clas, field);
			} catch( ReflectError e ) { 
				if ( Interpreter.DEBUG ) 
					Interpreter.debug(""field reflect error: ""+e);
			}

			
			if ( obj == null ) {
				String iclass = clas.getName()+""$""+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}

			if ( obj == null )
				throw new UtilEvalError(
					""No static field or inner class: "" 
					+ field + "" of "" + clas );

			return completeRound( field, suffix(evalName), obj );
		}

		
		if ( forceClass )
			throw new UtilEvalError( 
				value +"" does not resolve to a class name."" );

		

		String field = prefix(evalName, 1);

		
		if ( field.equals(""length"") && evalBaseObject.getClass().isArray() )
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			return completeRound( field, suffix(evalName), obj );
		}

		
		
		try {
			Object obj = Reflect.getObjectFieldValue(evalBaseObject, field);
			return completeRound( field, suffix(evalName), obj );
		} catch(ReflectError e) {  }
	
		
		throw new UtilEvalError(
			""Cannot access field: "" + field + "", on object: "" + evalBaseObject);
	}

	
	Object resolveThisFieldReference( 
		CallStack callstack, NameSpace thisNameSpace, Interpreter interpreter, 
		String varName, boolean specialFieldsVisible ) 
		throws UtilEvalError
	{
		if ( varName.equals(""this"") ) 
		{
			
			if ( specialFieldsVisible )
				throw new UtilEvalError(""Redundant to call .this on This type"");

			
			
	
			This ths = thisNameSpace.getThis( interpreter );
			thisNameSpace= ths.getNameSpace();
			Object result = ths;

			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				if ( isCompound( evalName ) )
					result = classNameSpace.getThis( interpreter );
				else
					result = classNameSpace.getClassInstance();
			}

			return result;
		}

		
		if ( varName.equals(""super"") ) 
		{
			
			

			
			This ths = thisNameSpace.getSuper( interpreter );
			thisNameSpace = ths.getNameSpace();
			

	
	
			
			
			if ( 
				thisNameSpace.getParent() != null 
				&& thisNameSpace.getParent().isClass
			)
				ths = thisNameSpace.getParent().getThis( interpreter );

			return ths;
		}

		Object obj = null;

		if ( varName.equals(""global"") )
			obj = thisNameSpace.getGlobal( interpreter );

		if ( obj == null && specialFieldsVisible ) 
		{
			if (varName.equals(""namespace""))
				obj = thisNameSpace;
			else if (varName.equals(""variables""))
				obj = thisNameSpace.getVariableNames();
			else if (varName.equals(""methods""))
				obj = thisNameSpace.getMethodNames();
			else if ( varName.equals(""interpreter"") )
				if ( lastEvalName.equals(""this"") )
					obj = interpreter;
				else
					throw new UtilEvalError(
						""Can only call .interpreter on literal 'this'"");
		}

		if ( obj == null && specialFieldsVisible && varName.equals(""caller"") )
		{
			if ( lastEvalName.equals(""this"") || lastEvalName.equals(""caller"") ) 
			{
				
				if ( callstack == null )
					throw new InterpreterError(""no callstack"");
				obj = callstack.get( ++callstackDepth ).getThis( 
					interpreter ); 
			}
			else
				throw new UtilEvalError(
				""Can only call .caller on literal 'this' or literal '.caller'"");

			
			return obj;
		}

		if ( obj == null && specialFieldsVisible 
			&& varName.equals(""callstack"") )
		{
			if ( lastEvalName.equals(""this"") ) 
			{
				
				if ( callstack == null )
					throw new InterpreterError(""no callstack"");
				obj = callstack;
			}
			else
				throw new UtilEvalError(
				""Can only call .callstack on literal 'this'"");
		}


		if ( obj == null )
			obj = thisNameSpace.getVariable(varName);

		if ( obj == null )
			throw new InterpreterError(""null this field ref:""+varName);

		return obj;
	}

	
	static NameSpace getClassNameSpace( NameSpace thisNameSpace ) 
	{
		
		
		if ( thisNameSpace.isClass )
			return thisNameSpace;

		if ( thisNameSpace.isMethod 
			&& thisNameSpace.getParent() != null 
			
			&& thisNameSpace.getParent().isClass
		)
			return thisNameSpace.getParent();

		return null;
	}

	
	synchronized public Class toClass() 
		throws ClassNotFoundException, UtilEvalError
	{
		if ( asClass != null )
			return asClass;

		reset();

		
		if ( evalName.equals(""var"") )
			return asClass = null;

		
		Class clas = namespace.getClass( evalName );

		if ( clas == null ) 
		{
			
			Object obj = null;
			try {
				
				
				obj = toObject( null, null, true );  
			} catch ( UtilEvalError  e ) { }; 
		
			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}

		if ( clas == null )
			throw new ClassNotFoundException(
				""Class: "" + value+ "" not found in namespace"");

		asClass = clas;
		return asClass;
	}

	
	synchronized public LHS toLHS( 
		CallStack callstack, Interpreter interpreter )
		throws UtilEvalError
	{
		
		reset();
		LHS lhs;

		
		if ( !isCompound(evalName) ) 
		{
			if ( evalName.equals(""this"") )
				throw new UtilEvalError(""Can't assign to 'this'."" );

			
			lhs = new LHS( namespace, evalName, false);
			return lhs;
		}

		
		Object obj = null;
		try {
			while( evalName != null && isCompound( evalName ) )
			{
				obj = consumeNextObjectField( callstack, interpreter, 
					false, true );
			}
		} 
		catch( UtilEvalError e ) {
			throw new UtilEvalError( ""LHS evaluation: "" + e.getMessage() );
		}

		
		if ( evalName == null && obj instanceof ClassIdentifier )
			throw new UtilEvalError(""Can't assign to class: "" + value );

		if ( obj == null )
			throw new UtilEvalError(""Error in LHS: "" + value );

		
		if ( obj instanceof This )
		{
			
			if ( 
				evalName.equals(""namespace"")
				|| evalName.equals(""variables"")
				|| evalName.equals(""methods"")
				|| evalName.equals(""caller"")
			)
				throw new UtilEvalError(
					""Can't assign to special variable: ""+evalName );

			Interpreter.debug(""found This reference evaluating LHS"");
			
			boolean localVar = !lastEvalName.equals(""super"");
			return new LHS( ((This)obj).namespace, evalName, localVar );
		}

		if ( evalName != null )
		{
			try {
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					lhs = Reflect.getLHSStaticField(clas, evalName);
					return lhs;
				} else {
					lhs = Reflect.getLHSObjectField(obj, evalName);
					return lhs;
				}
			} catch(ReflectError e) {
				throw new UtilEvalError(""Field access: ""+e);
			}
		}

		throw new InterpreterError(""Internal error in lhs..."");
	}
	
    
    public Object invokeMethod(
		Interpreter interpreter, Object[] args, CallStack callstack,
		SimpleNode callerInfo
	)
        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException
    {
        String methodName = Name.suffix(value, 1);
		BshClassManager bcm = interpreter.getClassManager();
		NameSpace namespace = callstack.top();

		
		
		
        if ( classOfStaticMethod != null )
		{
			return Reflect.invokeStaticMethod( 
				bcm, classOfStaticMethod, methodName, args );
		}

		if ( !Name.isCompound(value) )
			return invokeLocalMethod( 
				interpreter, args, callstack, callerInfo );

		
		
		
		
		

        String prefix = Name.prefix(value);

		
		if ( prefix.equals(""super"") && Name.countParts(value) == 2 )
		{
			
			This ths = namespace.getThis( interpreter );
			NameSpace thisNameSpace = ths.getNameSpace();
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				Object instance = classNameSpace.getClassInstance();
				return ClassGenerator.getClassGenerator()
					.invokeSuperclassMethod( bcm, instance, methodName, args );
			}
		}

        
        Name targetName = namespace.getNameResolver( prefix );
        Object obj = targetName.toObject( callstack, interpreter );

		if ( obj == Primitive.VOID ) 
			throw new UtilEvalError( ""Attempt to resolve method: ""+methodName
					+""() on undefined variable or class name: ""+targetName);

        
        if ( !(obj instanceof ClassIdentifier) ) {

            if (obj instanceof Primitive) {

                if (obj == Primitive.NULL)
                    throw new UtilTargetError( new NullPointerException( 
						""Null Pointer in Method Invocation"" ) );

                
                
                
                
				if ( Interpreter.DEBUG )
                	interpreter.debug(
					""Attempt to access method on primitive..."" 
					+ "" allowing bsh.Primitive to peek through for debugging"");
            }

            
            return Reflect.invokeObjectMethod(
				obj, methodName, args, interpreter, callstack, callerInfo );
        }

		

        
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug(""invokeMethod: trying static - "" + targetName);

        Class clas = ((ClassIdentifier)obj).getTargetClass();

		
		classOfStaticMethod = clas;
		
        if ( clas != null )
			return Reflect.invokeStaticMethod( bcm, clas, methodName, args );

        
		throw new UtilEvalError(""invokeMethod: unknown target: "" + targetName);
    }

	
	
    private Object invokeLocalMethod( 
		Interpreter interpreter, Object[] args, CallStack callstack,
		SimpleNode callerInfo
	)
        throws EvalError
    {
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug( ""invokeLocalMethod: "" + value );
		if ( interpreter == null )
			throw new InterpreterError(
				""invokeLocalMethod: interpreter = null"");

		String commandName = value;
		Class [] argTypes = Types.getTypes( args );

        
        BshMethod meth = null;
		try {
			meth = namespace.getMethod( commandName, argTypes );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(
				""Local method invocation"", callerInfo, callstack );
		}

		
        if ( meth != null )
			return meth.invoke( args, interpreter, callstack, callerInfo );

		BshClassManager bcm = interpreter.getClassManager();

		

		Object commandObject;
		try {
			commandObject = namespace.getCommand( 
				commandName, argTypes, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(""Error loading command: "", 
				callerInfo, callstack );
		}

		
		if ( commandObject == null )
		{
			
			
			
			BshMethod invokeMethod = null;
			try {
				invokeMethod = namespace.getMethod( 
					""invoke"", new Class [] { null, null } );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					""Local method invocation"", callerInfo, callstack );
			}

			if ( invokeMethod != null )
				return invokeMethod.invoke( 
					new Object [] { commandName, args }, 
					interpreter, callstack, callerInfo );

            throw new EvalError( ""Command not found: "" 
				+StringUtil.methodString( commandName, argTypes ), 
				callerInfo, callstack );
		}

		if ( commandObject instanceof BshMethod )
			return ((BshMethod)commandObject).invoke( 
				args, interpreter, callstack, callerInfo );

		if ( commandObject instanceof Class )
			try {
				return Reflect.invokeCompiledCommand( 
					((Class)commandObject), args, interpreter, callstack );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(""Error invoking compiled command: "",
				callerInfo, callstack );
			}

		throw new InterpreterError(""invalid command type"");
    }



	
	

	public static boolean isCompound(String value)
	{
		return value.indexOf('.') != -1 ;
		
	}

	static int countParts(String value)
	{
		if(value == null)
			return 0;

		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}

	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;

		return prefix(value, countParts(value) - 1);
	}

	static String prefix(String value, int parts)
	{
		if (parts < 1 )
			return null;

		int count = 0;
		int index = -1;

		while( ((index = value.indexOf('.', index + 1)) != -1) 
			&& (++count < parts) )
		{ ; }

		return (index == -1) ? value : value.substring(0, index);
	}

	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;

		return suffix(name, countParts(name) - 1);
	}

	public static String suffix(String value, int parts)
	{
		if (parts < 1)
			return null;

		int count = 0;
		int index = value.length() + 1;

		while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 
			&& (++count < parts) );

		return (index == -1) ? value : value.substring(index + 1);
	}

	


	public String toString() { return value; }

}

"
jEdit,4.3,org.gjt.sp.jedit.menu.MacrosProvider,4,1,0,6,25,6,0,6,3,2.0,124,0.0,0,0.0,0.5,0,0,30.0,6,2.25,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.util.Collections;
import java.util.Vector;
import org.gjt.sp.jedit.*;


public class MacrosProvider implements DynamicMenuProvider
{
	
	public boolean updateEveryTime()
	{
		return false;
	} 

	
	public void update(JMenu menu)
	{
		Vector macroVector = Macros.getMacroHierarchy();

		int count = menu.getMenuComponentCount();

		createMacrosMenu(menu,macroVector,0);

		if(count == menu.getMenuComponentCount())
		{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""no-macros.label""));
			mi.setEnabled(false);
			menu.add(mi);
		}
	} 

	
	private void createMacrosMenu(JMenu menu, Vector vector, int start)
	{
		Vector<JMenuItem> menuItems = new Vector<JMenuItem>();

		for(int i = start; i < vector.size(); i++)
		{
			Object obj = vector.elementAt(i);
			if(obj instanceof String)
			{
				menuItems.add(new EnhancedMenuItem(
					jEdit.getProperty(obj + "".label""),
					(String)obj,jEdit.getActionContext()));
			}
			else if(obj instanceof Vector)
			{
				Vector subvector = (Vector)obj;
				String name = (String)subvector.elementAt(0);
				JMenu submenu = new JMenu(name);
				createMacrosMenu(submenu,subvector,1);
				if(submenu.getMenuComponentCount() != 0)
					menuItems.add(submenu);
			}
		}

		Collections.sort(menuItems, new MenuItemTextComparator());
		for(int i = 0; i < menuItems.size(); i++)
		{
			menu.add(menuItems.get(i));
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.FilteredTableModel,20,2,1,5,55,60,5,0,16,0.684210526,320,1.0,0,0.457142857,0.23125,1,1,14.75,5,1.7,0,"
package org.gjt.sp.jedit.gui;

import javax.swing.*;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;
import java.util.*;


public abstract class FilteredTableModel<E extends TableModel> extends AbstractTableModel implements TableModelListener
{
	
	protected E delegated;

	private Vector<Integer> filteredIndices;

	
	private Map<Integer, Integer> invertedIndices;

	private String filter;

	private JTable table;

	
	protected FilteredTableModel(E delegated)
	{
		this.delegated = delegated;
		delegated.addTableModelListener(this);
		resetFilter();
	} 

	
	
	public void setTable(JTable table)
	{
		if (table.getModel() != this)
			throw new IllegalArgumentException(""The given table "" + table + "" doesn't use this model "" + this);
		this.table = table;
	} 


	
	public E getDelegated()
	{
		return delegated;
	} 

	
	public void setDelegated(E delegated)
	{
		this.delegated.removeTableModelListener(this);
		delegated.addTableModelListener(this);
		this.delegated = delegated;
	} 

	
	private void resetFilter()
	{
		filteredIndices = null;
	} 

	
	public void setFilter(String filter)
	{
		Set<Integer> selectedIndices = saveSelection();
		this.filter = filter;
		if (filter != null && filter.length() > 0)
		{
			int size = delegated.getRowCount();
			filter = prepareFilter(filter);
			Vector<Integer> indices = new Vector<Integer>(size);
			Map<Integer, Integer> invertedIndices = new HashMap<Integer, Integer>();
			for (int i = 0; i < size; i++)
			{
				if (passFilter(i, filter))
				{
					Integer delegatedIndice = Integer.valueOf(i);
					indices.add(delegatedIndice);

					invertedIndices.put(delegatedIndice, indices.size() - 1);
				}
			}
			this.invertedIndices = invertedIndices;
			filteredIndices = indices;
		}
		else
			resetFilter();

		fireTableDataChanged();
		restoreSelection(selectedIndices);
	} 

	
	public String prepareFilter(String filter)
	{
		return filter;
	} 

	
	
	public abstract boolean passFilter(int row, String filter);
	

	

	private Set<Integer> saveSelection()
	{
		if (table == null)
			return null;
		int[] rows = table.getSelectedRows();
		if (rows.length == 0)
			return null;

		Set<Integer> selectedRows = new HashSet<Integer>(rows.length);
		for (int row : rows)
		{
			selectedRows.add(getTrueRow(row));
		}
		return selectedRows;
	} 

	
	private void restoreSelection(Set<Integer> selectedIndices)
	{
		if (selectedIndices == null || getRowCount() == 0)
			return; 
		
		for (Integer selectedIndex : selectedIndices)
		{
			int i = getInternal2ExternalRow(selectedIndex.intValue());
			if (i != -1)
				table.getSelectionModel().setSelectionInterval(i, i);
		}
	}  

	
	public int getRowCount()
	{
		if (filteredIndices == null)
			return delegated.getRowCount();
		return filteredIndices.size();
	} 

	
	public int getColumnCount()
	{
		return delegated.getColumnCount();
	} 

	
	public String getColumnName(int columnIndex)
	{
		return delegated.getColumnName(columnIndex);
	} 

	
	public Class<?> getColumnClass(int columnIndex)
	{
		return delegated.getColumnClass(columnIndex);
	} 

	
	public boolean isCellEditable(int rowIndex, int columnIndex)
	{
		int trueRowIndex = getTrueRow(rowIndex);
		return delegated.isCellEditable(trueRowIndex, columnIndex);
	} 

	
	public Object getValueAt(int rowIndex, int columnIndex)
	{
		int trueRowIndex = getTrueRow(rowIndex);
		return delegated.getValueAt(trueRowIndex, columnIndex);
	} 

	
	public void setValueAt(Object aValue, int rowIndex, int columnIndex)
	{
		int trueRowIndex = getTrueRow(rowIndex);
		delegated.setValueAt(aValue, trueRowIndex, columnIndex);
	} 

	
	
	public int getTrueRow(int rowIndex)
	{
		if (filteredIndices == null)
			return rowIndex;
		return filteredIndices.get(rowIndex).intValue();
	} 

	
	
	public int getInternal2ExternalRow(int internalRowIndex)
	{
		if (invertedIndices == null)
			return internalRowIndex;

		Integer externalRowIndex = invertedIndices.get(internalRowIndex);
		if (externalRowIndex == null)
			return -1;

		return externalRowIndex.intValue();
	} 

	
	public void tableChanged(TableModelEvent e)
	{
		setFilter(filter);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.TokenHandler,2,1,0,15,2,1,14,1,2,2.0,2,0.0,0,0.0,0.7,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;


public interface TokenHandler
{
	
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context);

	
	public void setLineContext(TokenMarker.LineContext lineContext);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.classpath.ClassManagerImpl,22,2,0,14,90,73,2,13,18,0.720238095,663,0.875,3,0.603773585,0.204545455,1,6,28.77272727,15,2.0,0,"

package org.gjt.sp.jedit.bsh.classpath;

import java.net.*;
import java.util.*;
import java.lang.ref.*;
import java.io.IOException;
import java.io.*;
import org.gjt.sp.jedit.bsh.classpath.BshClassPath.ClassSource;
import org.gjt.sp.jedit.bsh.classpath.BshClassPath.JarClassSource;
import org.gjt.sp.jedit.bsh.classpath.BshClassPath.GeneratedClassSource;
import org.gjt.sp.jedit.bsh.BshClassManager;
import org.gjt.sp.jedit.bsh.ClassPathException;
import org.gjt.sp.jedit.bsh.Interpreter;  
import org.gjt.sp.jedit.bsh.UtilEvalError;


public class ClassManagerImpl extends BshClassManager
{
	static final String BSH_PACKAGE = ""org.gjt.sp.jedit.bsh"";
	
	private BshClassPath baseClassPath;
	private boolean superImport;

	
	private BshClassPath fullClassPath;

	
	private Vector listeners = new Vector();
	private ReferenceQueue refQueue = new ReferenceQueue();

	
	private BshClassLoader baseLoader;

	
	private Map loaderMap;

	
	public ClassManagerImpl() {
		reset();
	}

	
	public Class classForName( String name )
	{
		
		Class c = (Class)absoluteClassCache.get(name);
		if (c != null )
			return c;

		
		if ( absoluteNonClasses.get(name)!=null ) {
			if ( Interpreter.DEBUG )
				Interpreter.debug(""absoluteNonClass list hit: ""+name);
			return null;
		}

		if ( Interpreter.DEBUG )
			Interpreter.debug(""Trying to load class: ""+name);

		
		ClassLoader overlayLoader = getLoaderForClass( name );
		if ( overlayLoader != null )
		{
			try {
				c = overlayLoader.loadClass(name);
			} catch ( Exception e ) {
			
			
			} catch ( NoClassDefFoundError e2 ) {
				throw noClassDefFound( name, e2 );
			}

			
			
		}

		
		if ( c == null ) {
			if ( name.startsWith( BSH_PACKAGE ) )
				try {
					c = Interpreter.class.getClassLoader().loadClass( name );
				} catch ( ClassNotFoundException e ) {}
		}

		
		if ( c == null ) {
			if ( baseLoader != null )
				try {
					c = baseLoader.loadClass( name );
				} catch ( ClassNotFoundException e ) {}
		}

		
		if ( c == null ) {
			if ( externalClassLoader != null )
				try {
					c = externalClassLoader.loadClass( name );
				} catch ( ClassNotFoundException e ) {}
		}

		
		
		
		
		if ( c ==  null )
		{
			try {
				ClassLoader contextClassLoader = 
					Thread.currentThread().getContextClassLoader();
				if ( contextClassLoader != null )
					c = Class.forName( name, true, contextClassLoader );
			} catch ( ClassNotFoundException e ) { 
			} catch ( SecurityException e ) { } 
		}

		
		if ( c == null )
			try {
				c = plainClassForName( name );
			} catch ( ClassNotFoundException e ) {}

		
		if ( c == null )
			c = loadSourceClass( name );

		
		
		
		cacheClassInfo( name, c );

		return c;
	}

	
	public URL getResource( String path ) 
	{
		URL url = null;
		if ( baseLoader != null )
			
			url = baseLoader.getResource( path.substring(1) );
		if ( url == null )
			url = super.getResource( path );
		return url;
	}

	
	public InputStream getResourceAsStream( String path ) 
	{
		InputStream in = null;
		if ( baseLoader != null )
		{
			
			in = baseLoader.getResourceAsStream( path.substring(1) );
		}
		if ( in == null )
		{
			in = super.getResourceAsStream( path );
		}
		return in;
	}

	ClassLoader getLoaderForClass( String name ) {
		return (ClassLoader)loaderMap.get( name );
	}

	

	
	public void addClassPath( URL path ) 
		throws IOException 
	{
		if ( baseLoader == null )
			setClassPath( new URL [] { path } );
		else {
			
			baseLoader.addURL( path );
			baseClassPath.add( path );
			classLoaderChanged();
		}
	}

	
	public void reset()
	{
		baseClassPath = new BshClassPath(""baseClassPath"");
		baseLoader = null;
		loaderMap = new HashMap();
		classLoaderChanged(); 
	}

	
	public void setClassPath( URL [] cp ) {
		baseClassPath.setPath( cp );
		initBaseLoader();
		loaderMap = new HashMap();
		classLoaderChanged();
	}

	
	public void reloadAllClasses() throws ClassPathException 
	{
		BshClassPath bcp = new BshClassPath(""temp"");
		bcp.addComponent( baseClassPath );
		bcp.addComponent( BshClassPath.getUserClassPath() );
		setClassPath( bcp.getPathComponents() );
	}

	
	private void initBaseLoader() {
		baseLoader = new BshClassLoader( this, baseClassPath );
	}

	

	
	public void reloadClasses( String [] classNames ) 
		throws ClassPathException
	{
		

		
		if ( baseLoader == null )
			initBaseLoader();

		DiscreteFilesClassLoader.ClassSourceMap map = 
			new DiscreteFilesClassLoader.ClassSourceMap();

		for (int i=0; i< classNames.length; i++) {
			String name = classNames[i];

			
			ClassSource classSource = baseClassPath.getClassSource( name );

			
			if ( classSource == null ) {
				BshClassPath.getUserClassPath().insureInitialized();
				classSource = BshClassPath.getUserClassPath().getClassSource( 
					name );
			}

			
			
				
			if ( classSource == null )
				throw new ClassPathException(""Nothing known about class: ""
					+name );

			
			
			
			if ( classSource instanceof JarClassSource )
				throw new ClassPathException(""Cannot reload class: ""+name+
					"" from source: ""+ classSource );

			map.put( name, classSource );
		}

		
		ClassLoader cl = new DiscreteFilesClassLoader( this, map );

		
		Iterator it = map.keySet().iterator();
		while ( it.hasNext() )
			loaderMap.put( (String)it.next(), cl );

		classLoaderChanged();
	}

	
	public void reloadPackage( String pack ) 
		throws ClassPathException 
	{
		Collection classes = 
			baseClassPath.getClassesForPackage( pack );

		if ( classes == null )
			classes = 
				BshClassPath.getUserClassPath().getClassesForPackage( pack );

		

		if ( classes == null )
			throw new ClassPathException(""No classes found for package: ""+pack);

		reloadClasses( (String[])classes.toArray( new String[0] ) );
	}

	

	

	
	public BshClassPath getClassPath() throws ClassPathException
	{
		if ( fullClassPath != null )
			return fullClassPath;
	
		fullClassPath = new BshClassPath(""BeanShell Full Class Path"");
		fullClassPath.addComponent( BshClassPath.getUserClassPath() );
		try {
			fullClassPath.addComponent( BshClassPath.getBootClassPath() );
		} catch ( ClassPathException e ) { 
			System.err.println(""Warning: can't get boot class path"");
		}
		fullClassPath.addComponent( baseClassPath );

		return fullClassPath;
	}

	
	public void doSuperImport() 
		throws UtilEvalError
	{
		

		try {
			getClassPath().insureInitialized();
			
			getClassNameByUnqName( """" ) ;

			
			

		} catch ( ClassPathException e ) {
			throw new UtilEvalError(""Error importing classpath ""+ e );
		}

		superImport = true;
	}

	protected boolean hasSuperImport() { return superImport; }

	
	public String getClassNameByUnqName( String name ) 
		throws ClassPathException
	{
		return getClassPath().getClassNameByUnqName( name );
	}

	public void addListener( Listener l ) {
		listeners.addElement( new WeakReference( l, refQueue) );

		
		Reference deadref;
		while ( (deadref = refQueue.poll()) != null ) {
			boolean ok = listeners.removeElement( deadref );
			if ( ok ) {
				
			} else {
				if ( Interpreter.DEBUG ) Interpreter.debug(
					""tried to remove non-existent weak ref: ""+deadref);
			}
		}
	}

	public void removeListener( Listener l ) {
		throw new Error(""unimplemented"");
	}

	public ClassLoader getBaseLoader() {
		return baseLoader;
	}

	

	
	public Class defineClass( String name, byte [] code ) 
	{
		baseClassPath.setClassSource( name, new GeneratedClassSource( code ) );
		try {
			reloadClasses( new String [] { name } );
		} catch ( ClassPathException e ) {
			throw new org.gjt.sp.jedit.bsh.InterpreterError(""defineClass: ""+e);
		}
		return classForName( name );
	}

	
	protected void classLoaderChanged() 
	{
		
		clearCaches();

		Vector toRemove = new Vector(); 
		for ( Enumeration e = listeners.elements(); e.hasMoreElements(); ) 
		{
			WeakReference wr = (WeakReference)e.nextElement();
			Listener l = (Listener)wr.get();
			if ( l == null )  
			  toRemove.add( wr );
			else
			  l.classLoaderChanged();
		}
		for( Enumeration e = toRemove.elements(); e.hasMoreElements(); ) 
			listeners.removeElement( e.nextElement() );
	}

	public void dump( PrintWriter i ) 
	{
		i.println(""Bsh Class Manager Dump: "");
		i.println(""----------------------- "");
		i.println(""baseLoader = ""+baseLoader);
		i.println(""loaderMap= ""+loaderMap);
		i.println(""----------------------- "");
		i.println(""baseClassPath = ""+baseClassPath);
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.AbstractContextOptionPane,17,6,1,9,59,92,3,8,0,0.847222222,417,1.0,0,0.976642336,0.323529412,2,4,23.0,6,1.5882,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.StandardUtilities;


public abstract class AbstractContextOptionPane extends AbstractOptionPane
{

    
    protected AbstractContextOptionPane(String name, String caption)
    {
        super(name);
        this.caption = new JLabel(caption);
    }

    
    protected void _init()
    {
        setLayout(new BorderLayout());

        add(BorderLayout.NORTH,caption);

		listModel = new DefaultListModel();
		reloadContextList(getContextMenu());
		
        list = new JList(listModel);
        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        list.addListSelectionListener(new ListHandler());

        add(BorderLayout.CENTER,new JScrollPane(list));

        buttons = new JPanel();
        buttons.setBorder(new EmptyBorder(3,0,0,0));
        buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
        ActionHandler actionHandler = new ActionHandler();
        add = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.context.add.icon"")));
        add.setToolTipText(jEdit.getProperty(""common.add""));
        add.addActionListener(actionHandler);
        buttons.add(add);
        buttons.add(Box.createHorizontalStrut(6));
        remove = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.context.remove.icon"")));
        remove.setToolTipText(jEdit.getProperty(""common.remove""));
        remove.addActionListener(actionHandler);
        buttons.add(remove);
        buttons.add(Box.createHorizontalStrut(6));
        moveUp = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.context.moveUp.icon"")));
        moveUp.setToolTipText(jEdit.getProperty(""common.moveUp""));
        moveUp.addActionListener(actionHandler);
        buttons.add(moveUp);
        buttons.add(Box.createHorizontalStrut(6));
        moveDown = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.context.moveDown.icon"")));
        moveDown.setToolTipText(jEdit.getProperty(""common.moveDown""));
        moveDown.addActionListener(actionHandler);
        buttons.add(moveDown);
        buttons.add(Box.createGlue());

		
		reset = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty(""options.context.reset.icon"")));
		reset.setToolTipText(jEdit.getProperty(""options.context.reset""));
		reset.addActionListener(actionHandler);
		buttons.add(reset);
		
        updateButtons();
        add(BorderLayout.SOUTH,buttons);
    }

    
    protected abstract String getContextMenu();

    
    protected abstract void saveContextMenu(String menu);

    
    protected void addButton(JComponent c)
    {
        buttons.add(c);
    }

    static class MenuItemCompare implements Comparator<MenuItem>
    {
        public int compare(MenuItem obj1, MenuItem obj2)
        {
            return StandardUtilities.compareStrings(obj1.label, obj2.label, true);
        }
    }

    protected void _save()
    {
    	StringBuilder buf = new StringBuilder();
        for(int i = 0; i < listModel.getSize(); i++)
        {
            if(i != 0)
                buf.append(' ');
            buf.append(((MenuItem)listModel.elementAt(i)).actionName);
        }
        saveContextMenu(buf.toString());
    }

    
    private DefaultListModel listModel;
    private JList list;
    private JButton add;
    private JButton remove;
    private JButton moveUp, moveDown;
    private JButton reset;
    private JLabel caption;
    private JPanel buttons;

    private void updateButtons()
    {
        int index = list.getSelectedIndex();
        remove.setEnabled(index != -1 && listModel.getSize() != 0);
        moveUp.setEnabled(index > 0);
        moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
    }
	
	private void reloadContextList(String contextMenu)
	{
		listModel.clear();
		StringTokenizer st = new StringTokenizer(contextMenu);
		while(st.hasMoreTokens())
		{
			String actionName = st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new AbstractContextOptionPane.MenuItem(""-"",""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;
				listModel.addElement(new AbstractContextOptionPane.MenuItem(actionName,label));
			}
		}
	}

    static class MenuItem
    {
        String actionName;
        String label;

        MenuItem(String actionName, String label)
        {
            this.actionName = actionName;
            this.label = GUIUtilities.prettifyMenuLabel(label);
        }

        public String toString()
        {
            return label;
        }
    }

    class ActionHandler implements ActionListener
    {
        public void actionPerformed(ActionEvent evt)
        {
            Object source = evt.getSource();

            if(source == add)
            {
                ContextAddDialog dialog = new ContextAddDialog(
                    AbstractContextOptionPane.this);
                String selection = dialog.getSelection();
                if(selection == null)
                    return;

                int index = list.getSelectedIndex();
                if(index == -1)
                    index = listModel.getSize();
                else
                    index++;

                MenuItem menuItem;
                if(selection.equals(""-""))
                    menuItem = new AbstractContextOptionPane.MenuItem(""-"",""-"");
                else
                {
                    menuItem = new AbstractContextOptionPane.MenuItem(selection,
                        jEdit.getAction(selection)
                        .getLabel());
                }

                listModel.insertElementAt(menuItem,index);
                list.setSelectedIndex(index);
                list.ensureIndexIsVisible(index);
            }
            else if(source == remove)
            {
                int index = list.getSelectedIndex();
                listModel.removeElementAt(index);
                if(listModel.getSize() != 0)
                {
                    list.setSelectedIndex(
                        Math.min(listModel.getSize()-1,
                        index));
                }
                updateButtons();
            }
            else if(source == moveUp)
            {
                int index = list.getSelectedIndex();
                Object selected = list.getSelectedValue();
                listModel.removeElementAt(index);
                listModel.insertElementAt(selected,index-1);
                list.setSelectedIndex(index-1);
                list.ensureIndexIsVisible(index - 1);
            }
            else if(source == moveDown)
            {
                int index = list.getSelectedIndex();
                Object selected = list.getSelectedValue();
                listModel.removeElementAt(index);
                listModel.insertElementAt(selected,index+1);
                list.setSelectedIndex(index+1);
                list.ensureIndexIsVisible(index+1);
            }
			else if(source == reset)
			{
				String dialogType = ""options.context.reset.dialog"";
				int result = GUIUtilities.confirm(list,dialogType,null,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				
				if(result == JOptionPane.YES_OPTION)
				{
					
					
					
					
					String orgContext = jEdit.getProperty(""view.context"");
					jEdit.resetProperty(""view.context"");
					String defaultContext = jEdit.getProperty(""view.context"");
					jEdit.setProperty(""view.context"", orgContext);
					reloadContextList(defaultContext);
					
					
					list.setSelectedIndex(0);
					list.ensureIndexIsVisible(0);
					updateButtons();
				}
			}
        }
    }

    class ListHandler implements ListSelectionListener
    {
        public void valueChanged(ListSelectionEvent evt)
        {
            updateButtons();
        }
    }
}

"
jEdit,4.3,org.gjt.sp.jedit.textarea.StatusListener,3,1,0,3,3,3,3,1,3,1.5,6,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;



public interface StatusListener extends java.util.EventListener
{
	int OVERWRITE_CHANGED = 0;
	int MULTI_SELECT_CHANGED = 1;
	int RECT_SELECT_CHANGED = 2;

	void statusChanged(TextArea textArea, int flag, boolean value);

	void bracketSelected(TextArea textArea, int line, String text);

	void narrowActive(TextArea textArea);
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchTreeNodeCallback,1,1,0,6,1,0,6,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit.search;

import javax.swing.tree.DefaultMutableTreeNode;


public interface HyperSearchTreeNodeCallback {
	public boolean processNode(DefaultMutableTreeNode node);
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.VFSFileChooserDialog,19,7,0,21,110,115,8,19,9,0.746031746,685,1.0,3,0.977645306,0.289473684,2,3,34.68421053,13,2.3684,0,"

package org.gjt.sp.jedit.browser;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.BorderLayout;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Dialog;
import java.awt.Frame;
import java.io.File;
import java.io.IOException;
import java.util.*;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.*;



public class VFSFileChooserDialog extends EnhancedDialog
{

	
	public VFSFileChooserDialog(View view, String path,
		int mode, boolean multipleSelection)
	{
		this(view,path,mode,multipleSelection,true);
	} 

	
	
	public VFSFileChooserDialog(View view, String path,
		int mode, boolean multipleSelection, boolean autoshow)
	{
		super(view,getDefaultTitle(),true);
		setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		_init(view,path,mode,multipleSelection,autoshow);
	} 

	
	
	public VFSFileChooserDialog(Dialog parent, View view, String path,
		int mode, boolean multipleSelection, boolean autoshow)
	{
		super(parent,getDefaultTitle(),true);
		setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());		
		_init(view,path,mode,multipleSelection,autoshow);
	} 

	
	public VFSFileChooserDialog(Frame parent, View view, String path,
		int mode, boolean multipleSelection, boolean autoshow)
	{
		super(parent, getDefaultTitle(),true);
		setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());		
		_init(view,path,mode,multipleSelection,autoshow);
	} 


	
	
	public VFSBrowser getBrowser()
	{
		return browser;
	} 

	
	@Override
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""vfs.browser.dialog"");
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.dispose();
	} 

	
	@Override
	public void ok()
	{
		VFSFile[] files = browser.getSelectedFiles();
		filename = filenameField.getText();
		boolean choosingDir = (browser.getMode() ==
			VFSBrowser.CHOOSE_DIRECTORY_DIALOG);

		if(files.length != 0)
		{
			if(choosingDir)
			{
				isOK = true;
				dispose();
			}
			else
				browser.filesActivated(VFSBrowser.M_OPEN,false);
			return;
		}
		else if(choosingDir && (filename == null || filename.length() == 0))
		{
			isOK = true;
			dispose();
			return;
		}
		else if(filename == null || filename.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		String bufferDir = browser.getView().getBuffer()
			.getDirectory();
		if(filename.equals(""-""))
			filename = bufferDir;
		else if(filename.startsWith(""-/"")
			|| filename.startsWith('-' + File.separator))
		{
			filename = MiscUtilities.constructPath(
				bufferDir,filename.substring(2));
		}

		final int[] type = { -1 };
		filename = MiscUtilities.expandVariables(filename);
		final String path = MiscUtilities.constructPath(
			browser.getDirectory(),filename);
		final VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;

		VFSManager.runInWorkThread(new GetFileTypeRequest(
			vfs,session,path,type));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				switch(type[0])
				{
				case VFSFile.FILE:
					if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
						break;

					if(vfs instanceof FileVFS)
					{
						if(doFileExistsWarning(path))
							break;
					}
					isOK = true;
					if(browser.getMode() == VFSBrowser.BROWSER_DIALOG)
					{
						Hashtable props = new Hashtable();
						props.put(JEditBuffer.ENCODING,browser.currentEncoding);
						jEdit.openFile(browser.getView(),
							browser.getDirectory(),
							path,false,props);
					}
					dispose();
					break;
				case VFSFile.DIRECTORY:
				case VFSFile.FILESYSTEM:
					browser.setDirectory(path);
					break;
				}
			}
		});
	} 

	
	@Override
	public void cancel()
	{
		dispose();
	} 

	
	public String[] getSelectedFiles()
	{
		if(!isOK)
			return null;

		if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
		{
			if(browser.getSelectedFiles().length > 0)
			{
				return getSelectedFiles(VFSFile.DIRECTORY,
					VFSFile.FILESYSTEM);
			}
			else
				return new String[] { browser.getDirectory() };
		}
		else if(filename != null && filename.length() != 0)
		{
			String path = browser.getDirectory();
			return new String[] { MiscUtilities.constructPath(
				path,filename) };
		}
		else
			return getSelectedFiles(VFSFile.FILE,VFSFile.FILE);
	} 

	

	
	private VFSBrowser browser;
	private VFSFileNameField filenameField;
	private String filename;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	private WorkThreadHandler workThreadHandler;
	

	
	private static String getDefaultTitle()
	{
		return jEdit.getProperty(""vfs.browser.title"");
	}

	
	private void _init(View view, String path,
		int mode, boolean multipleSelection, boolean autoshow)
	{
		JPanel content = new JPanel(new BorderLayout());
		setContentPane(content);

		String name;
		if(mode == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
			name = null;
		else if(path == null || path.endsWith(File.separator)
			|| path.endsWith(""/""))
		{
			name = null;
		}
		else
		{
			VFS vfs = VFSManager.getVFSForPath(path);
			name = vfs.getFileName(path);
			path = vfs.getParentOfPath(path);
			if ((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)
			{
				path = null;
			}
		}

		browser = new VFSBrowser(view, path, mode, multipleSelection, null);
		
		browser.addBrowserListener(new BrowserHandler());
		content.add(BorderLayout.CENTER,browser);

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,12,12,12));
		
		filenameField = new VFSFileNameField(browser,null);
		filenameField.setText(name);
		filenameField.selectAll();
		filenameField.setName(""filename"");
		browser.setDefaultFocusComponent(filenameField);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		box.add(filenameField);
		box.add(Box.createGlue());

		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.dialog.filename""));
		label.setDisplayedMnemonic(jEdit.getProperty(
			""vfs.browser.dialog.filename.mnemonic"").charAt(0));
		label.setLabelFor(filenameField);
		panel.add(label);
		panel.add(Box.createHorizontalStrut(12));

		panel.add(box);

		panel.add(Box.createHorizontalStrut(12));

		ok = new JButton();
		ok.setName(""ok"");
		getRootPane().setDefaultButton(ok);

		switch(mode)
		{
		case VFSBrowser.OPEN_DIALOG:
		case VFSBrowser.BROWSER_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.open""));
			break;
		case VFSBrowser.CHOOSE_DIRECTORY_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.choose-dir""));
			
			Dimension dim = ok.getPreferredSize();
			ok.setPreferredSize(dim);
			break;
		case VFSBrowser.SAVE_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.save""));
			break;
		}

		ok.addActionListener(new ActionHandler());
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.setName(""cancel"");
		cancel.addActionListener(new ActionHandler());
		panel.add(cancel);

		content.add(BorderLayout.SOUTH,panel);

		VFSManager.getIOThreadPool().addProgressListener(
			workThreadHandler = new WorkThreadHandler());

		pack();
		GUIUtilities.loadGeometry(this,""vfs.browser.dialog"");
		GUIUtilities.requestFocus(this,filenameField);
		if (autoshow)
			setVisible(true);
	} 

	
	
	
	private boolean doFileExistsWarning(String filename)
	{
		if(browser.getMode() == VFSBrowser.SAVE_DIALOG
			&& new File(filename).exists())
		{
			String[] args = { MiscUtilities.getFileName(filename) };
			int result = GUIUtilities.confirm(browser,
				""fileexists"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return true;
		}

		return false;
	} 

	
	private String[] getSelectedFiles(int type1, int type2)
	{
		List<String> l = new ArrayList<String>();
		VFSFile[] selectedFiles = browser.getSelectedFiles();
		for(int i = 0; i < selectedFiles.length; i++)
		{
			VFSFile file = selectedFiles[i];
			if(file.getType() == type1 || file.getType() == type2)
				l.add(file.getPath());
		}
		return l.toArray(new String[l.size()]);
	} 

	

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	} 

	
	private class BrowserHandler implements BrowserListener
	{
		
		public void filesSelected(VFSBrowser browser, VFSFile[] files)
		{
			boolean choosingDir = (browser.getMode()
				== VFSBrowser.CHOOSE_DIRECTORY_DIALOG);

			if(files.length == 0)
			{
				if(choosingDir)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.choose-dir""));
				}
			}
			else if(files.length == 1)
			{
				if(choosingDir)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.choose-dir""));
				}

				VFSFile file = files[0];
				if(file.getType() == VFSFile.FILE)
				{
					String path = file.getPath();
					String directory = browser.getDirectory();
					String parent = MiscUtilities
						.getParentOfPath(path);
					if(MiscUtilities.pathsEqual(parent,directory))
						path = file.getName();

					filenameField.setText(path);
					filenameField.selectAll();
				}
			}
			else
			{
				if(choosingDir)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.choose-dir""));
				}

				filenameField.setText(null);
			}
		} 

		
		public void filesActivated(VFSBrowser browser, VFSFile[] files)
		{
			filenameField.selectAll();

			if(files.length == 0)
			{
				
				
				
				ok();
				return;
			}

			for(int i = 0; i < files.length; i++)
			{
				if(files[i].getType() == VFSFile.FILE)
				{
					String path = files[i].getPath();
					VFS vfs = VFSManager.getVFSForPath(path);
					if(browser.getMode() == VFSBrowser.SAVE_DIALOG
						&& vfs instanceof FileVFS)
					{
						if(doFileExistsWarning(path))
							return;
					}

					isOK = true;
					filenameField.setText(null);
					if(browser.getMode() != VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
					{
						dispose();
					}
					return;
				}
				else
					return;
			}
		} 
	} 

	
	private class WorkThreadHandler implements WorkThreadProgressListener
	{
		
		public void statusUpdate(final WorkThreadPool threadPool,
			int threadIndex)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					int requestCount = threadPool.getRequestCount();
					if(requestCount == 0)
					{
						getContentPane().setCursor(
							Cursor.getDefaultCursor());
					}
					else if(requestCount >= 1)
					{
						getContentPane().setCursor(
							Cursor.getPredefinedCursor(
							Cursor.WAIT_CURSOR));
					}
				}
			});
		} 

		
		public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
		{
		} 
	} 

	
	private class GetFileTypeRequest implements Runnable
	{
		VFS    vfs;
		Object session;
		String path;
		int[]  type;

		GetFileTypeRequest(VFS vfs, Object session,
			String path, int[] type)
		{
			this.vfs     = vfs;
			this.session = session;
			this.path    = path;
			this.type    = type;
		}

		public void run()
		{
			try
			{
				VFSFile entry = vfs._getFile(
						session,
						path,
						browser);
				if(entry == null)
				{
					
					type[0] = VFSFile.FILE;
				}
				else
					type[0] = entry.getType();
			}
			catch(IOException e)
			{
				VFSManager.error(e,path,browser);
			}
			finally
			{
				try
				{
					vfs._endVFSSession(
						session,
						browser);
				}
				catch(IOException e)
				{
					VFSManager.error(e,path,browser);
				}
			}
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.JEditActionContext,8,1,2,8,32,0,6,3,8,0.571428571,224,0.25,0,0.0,0.35,0,0,26.5,3,1.875,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.util.StandardUtilities;

import java.lang.reflect.Array;
import java.util.*;


public abstract class JEditActionContext<F extends JEditAbstractEditAction, E extends JEditActionSet<F>>
{
	
	
	public abstract void invokeAction(EventObject evt, F action);
	

	
	
	public void addActionSet(E actionSet)
	{
		actionNames = null;
		actionSets.addElement(actionSet);
		actionSet.context = this;
		String[] actions = actionSet.getActionNames();
		for(int i = 0; i < actions.length; i++)
		{
			
			if (actionHash.containsKey(actions[i])) 
			{
				
				E oldAction = actionHash.get(actions[i]);
				overriddenActions.put(actions[i], oldAction);
			}
			actionHash.put(actions[i],actionSet);
		}
	} 

	
	
	public void removeActionSet(E actionSet)
	{
		actionNames = null;
		actionSets.removeElement(actionSet);
		actionSet.context = null;
		String[] actions = actionSet.getActionNames();
		for(int i = 0; i < actions.length; i++)
		{
			actionHash.remove(actions[i]);
			if (overriddenActions.containsKey(actions[i])) 
			{
				E oldAction = overriddenActions.remove(actions[i]);
				actionHash.put(actions[i], oldAction);
			}
		}
	} 

	
	
	public E[] getActionSets()
	{
		if (actionSets.isEmpty())
			return null;
		Class clazz = actionSets.get(0).getClass();
		E[] retVal =(E[]) Array.newInstance(clazz, actionSets.size());
		actionSets.copyInto(retVal);
		return retVal;
	} 

	
	
	public F getAction(String name)
	{
		E set = actionHash.get(name);
		if(set == null)
			return null;
		else
			return set.getAction(name);
	} 

	
	
	public E getActionSetForAction(String action)
	{
		return actionHash.get(action);
	} 

	
	
	public String[] getActionNames()
	{
		if(actionNames == null)
		{
			List<String> vec = new LinkedList<String>();
			for(int i = 0; i < actionSets.size(); i++)
				(actionSets.elementAt(i)).getActionNames(vec);

			actionNames = vec.toArray(new String[vec.size()]);
			Arrays.sort(actionNames,
				new StandardUtilities.StringCompare<String>(true));
		}

		return actionNames;
	} 

	
	String[] actionNames;
	
	Hashtable<String, E> actionHash = new Hashtable<String, E>();
	
	
	Hashtable<String, E> overriddenActions = new Hashtable<String, E>(); 
	

	
	private final Vector<E> actionSets = new Vector<E>();
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.OptionsDialog,17,7,2,15,117,100,4,12,8,0.701388889,878,1.0,1,0.977645306,0.176470588,4,9,50.11764706,15,2.9412,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;


import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public abstract class OptionsDialog extends EnhancedDialog
	implements ActionListener, TreeSelectionListener
{
	
	private String name;
	private JSplitPane splitter;
	protected JTree paneTree;
	private JScrollPane stage;
	private JButton ok;
	private JButton cancel;
	private JButton apply;
	protected OptionPane currentPane;
	private Map<Object, OptionPane> deferredOptionPanes;
	

	
	
	protected OptionsDialog(Frame frame, String name, String pane)
	{
		super(frame, jEdit.getProperty(name + "".title""), true);
		init(name,pane);
	} 

	
	protected OptionsDialog(Dialog dialog, String name, String pane)
	{
		super(dialog, jEdit.getProperty(name + "".title""), true);
		init(name,pane);
	} 

	
	public void addOptionGroup(OptionGroup group)
	{
		getDefaultGroup().addOptionGroup(group);
	} 

	
	public void addOptionPane(OptionPane pane)
	{
		getDefaultGroup().addOptionPane(pane);
	} 

	
	public void ok()
	{
		if(currentPane != null)
			jEdit.setProperty(name + "".last"",currentPane.getName());
		ok(true);
	} 

	
	public void cancel()
	{
		if(currentPane != null)
			jEdit.setProperty(name + "".last"",currentPane.getName());
		dispose();
	} 

	
	public void ok(boolean dispose)
	{
		OptionTreeModel m = (OptionTreeModel) paneTree
			.getModel();
		save(m.getRoot());

		
		jEdit.propertiesChanged();

		
		jEdit.saveSettings();

		
		if(dispose)
			dispose();
	} 

	
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,name);
		jEdit.setIntegerProperty(name + "".splitter"",splitter.getDividerLocation());
		super.dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();

		if(source == ok)
		{
			ok();
		}
		else if(source == cancel)
		{
			cancel();
		}
		else if(source == apply)
		{
			ok(false);
		}
	} 

	
	public void valueChanged(TreeSelectionEvent evt)
	{
		TreePath path = evt.getPath();

		if(path == null)
			return;

		Object lastPathComponent = path.getLastPathComponent();
		if(!(lastPathComponent instanceof String
			|| lastPathComponent instanceof OptionPane))
		{
			return;
		}

		Object[] nodes = path.getPath();

		StringBuilder buf = new StringBuilder();

		OptionPane optionPane = null;

		int lastIdx = nodes.length - 1;

		for (int i = paneTree.isRootVisible() ? 0 : 1;
			i <= lastIdx; i++)
		{
			String label;
			Object node = nodes[i];
			if (node instanceof OptionPane)
			{
				optionPane = (OptionPane)node;
				label = jEdit.getProperty(""options.""
					+ optionPane.getName()
					+ "".label"");
			}
			else if (node instanceof OptionGroup)
			{
				label = ((OptionGroup)node).getLabel();
			}
			else if (node instanceof String)
			{
				label = jEdit.getProperty(""options.""
					+ node + "".label"");
				optionPane = deferredOptionPanes.get(node);
				if(optionPane == null)
				{
					String propName = ""options."" + node + "".code"";
					String code = jEdit.getProperty(propName);
					if(code != null)
					{
						optionPane = (OptionPane)
							BeanShell.eval(
							jEdit.getActiveView(),
							BeanShell.getNameSpace(),
							code
						);

						if(optionPane != null)
						{
							deferredOptionPanes.put(
								node,optionPane);
						}
						else
							continue;
					}
					else
					{
						Log.log(Log.ERROR,this,propName
							+ "" not defined"");
						continue;
					}
				}
			}
			else
			{
				continue;
			}

			buf.append(label);

			if (i != lastIdx)
				buf.append("": "");
		}

		if(optionPane == null)
			return;

		setTitle(jEdit.getProperty(""options.title-template"",
			new Object[] { jEdit.getProperty(name + "".title""),
			buf.toString() }));

		try
		{
			optionPane.init();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,this,""Error initializing options:"");
			Log.log(Log.ERROR,this,t);
		}

		currentPane = optionPane;
		stage.setViewportView(currentPane.getComponent());
		stage.revalidate();
		stage.repaint();

		if(!isShowing())
			addNotify();

		updateSize();

		currentPane = optionPane;
	} 

	
	
	
	protected abstract OptionTreeModel createOptionTreeModel();
	

	protected abstract OptionGroup getDefaultGroup();
	

	
	
	protected void init(String name, String pane)
	{
		this.name = name;

		deferredOptionPanes = new HashMap<Object, OptionPane>();

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		stage = new JScrollPane();

		paneTree = new JTree(createOptionTreeModel());
		paneTree.setVisibleRowCount(1);
		paneTree.setCellRenderer(new PaneNameRenderer());

		
		if(!OperatingSystem.isMacOSLF())
			paneTree.putClientProperty(""JTree.lineStyle"", ""Angled"");

		paneTree.setShowsRootHandles(true);
		paneTree.setRootVisible(false);

		JScrollPane scroller = new JScrollPane(paneTree,
						       ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
						       ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		scroller.setMinimumSize(new Dimension(100, 0));
		splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
					  jEdit.getBooleanProperty(""appearance.continuousLayout""),
					  scroller,
					  stage);
		content.add(splitter, BorderLayout.CENTER);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		getRootPane().setDefaultButton(ok);
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		buttons.add(cancel);
		buttons.add(Box.createHorizontalStrut(6));
		apply = new JButton(jEdit.getProperty(""common.apply""));
		apply.addActionListener(this);
		buttons.add(apply);

		buttons.add(Box.createGlue());

		content.add(buttons, BorderLayout.SOUTH);

		
		
		
		paneTree.getSelectionModel().addTreeSelectionListener(this);

		OptionGroup rootNode = (OptionGroup)paneTree.getModel().getRoot();
		for(int i = 0; i < rootNode.getMemberCount(); i++)
		{
			paneTree.expandPath(new TreePath(
			new Object[] { rootNode, rootNode.getMember(i) }));
		}

		
		
		if(!selectPane(rootNode, pane))
			selectPane(rootNode,null);

		splitter.setDividerLocation(paneTree.getPreferredSize().width
			+ scroller.getVerticalScrollBar().getPreferredSize()
			.width);

		GUIUtilities.loadGeometry(this,name);
		int dividerLocation = jEdit.getIntegerProperty(name + "".splitter"",-1);
		if(dividerLocation != -1)
			splitter.setDividerLocation(dividerLocation);

		
		updateSize();

		setVisible(true);
	} 

	

	
	private boolean selectPane(OptionGroup node, String name)
	{
		return selectPane(node,name,new ArrayList<Object>());
	} 

	
	private boolean selectPane(OptionGroup node, String name, List<Object> path)
	{
		path.add(node);

		Enumeration<Object> e = node.getMembers();
		while(e.hasMoreElements())
		{
			Object obj = e.nextElement();
			if(obj instanceof OptionGroup)
			{
				OptionGroup grp = (OptionGroup)obj;
				if(grp.getName().equals(name))
				{
					path.add(grp);
					path.add(grp.getMember(0));
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
				else if(selectPane((OptionGroup)obj,name,path))
					return true;
			}
			else if(obj instanceof OptionPane)
			{
				OptionPane pane = (OptionPane)obj;
				if(pane.getName().equals(name)
					|| name == null)
				{
					path.add(pane);
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
			}
			else if(obj instanceof String)
			{
				String pane = (String)obj;
				if(pane.equals(name)
					|| name == null)
				{
					path.add(pane);
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
			}
		}

		path.remove(node);

		return false;
	} 

	
	private void save(Object obj)
	{
		if(obj instanceof OptionGroup)
		{
			OptionGroup grp = (OptionGroup)obj;
			Enumeration<Object> members = grp.getMembers();
			while(members.hasMoreElements())
			{
				save(members.nextElement());
			}
		}
		else if(obj instanceof OptionPane)
		{
			try
			{
				((OptionPane)obj).save();
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error saving options:"");
				Log.log(Log.ERROR,this,t);
			}
		}
		else if(obj instanceof String)
		{
			save(deferredOptionPanes.get(obj));
		}
	} 

	
	private void updateSize()
	{
		Dimension currentSize = getSize();
		Dimension requestedSize = getPreferredSize();
		Dimension newSize = new Dimension(
			Math.max(currentSize.width,requestedSize.width),
			Math.max(currentSize.height,requestedSize.height)
		);
		if(newSize.width < 300)
			newSize.width = 300;
		if(newSize.height < 200)
			newSize.height = 200;
		setSize(newSize);
		validate();
	} 

	

	
	public static class PaneNameRenderer extends DefaultTreeCellRenderer
	{
		public PaneNameRenderer()
		{
			paneFont = UIManager.getFont(""Tree.font"");
			if(paneFont == null)
				paneFont = jEdit.getFontProperty(""metal.secondary.font"");
			groupFont = paneFont.deriveFont(Font.BOLD);
		}

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);

			String name = null;

			if (value instanceof OptionGroup)
			{
				setText(((OptionGroup)value).getLabel());
				setFont(groupFont);
			}
			else if (value instanceof OptionPane)
			{
				name = ((OptionPane)value).getName();
				setFont(paneFont);
			}
			else if (value instanceof String)
			{
				name = (String) value;
				setFont(paneFont);
			}

			if (name != null)
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");

				if (label == null)
				{
					setText(""NO LABEL PROPERTY: "" + name);
				}
				else
				{
					setText(label);
				}
			}

			setIcon(null);

			return this;
		}

		private Font paneFont;
		private final Font groupFont;
	} 

	
	public class OptionTreeModel implements TreeModel
	{
		public OptionTreeModel()
		{
			this(new OptionGroup(null));
		}

		public OptionTreeModel(OptionGroup root)
		{
			this.root = root;
		}

		public void addTreeModelListener(TreeModelListener l)
		{
			listenerList.add(TreeModelListener.class, l);
		}

		public void removeTreeModelListener(TreeModelListener l)
		{
			listenerList.remove(TreeModelListener.class, l);
		}

		public Object getChild(Object parent, int index)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMember(index);
			}
			else
			{
				return null;
			}
		}

		public int getChildCount(Object parent)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMemberCount();
			}
			else
			{
				return 0;
			}
		}

		public int getIndexOfChild(Object parent, Object child)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent)
					.getMemberIndex(child);
			}
			else
			{
				return -1;
			}
		}

		public Object getRoot()
		{
			return root;
		}

		public boolean isLeaf(Object node)
		{
			return !(node instanceof OptionGroup);
		}

		public void valueForPathChanged(TreePath path, Object newValue)
		{
			
		}

		protected void fireNodesChanged(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesChanged(modelEvent);
			}
		}

		protected void fireNodesInserted(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesInserted(modelEvent);
			}
		}

		protected void fireNodesRemoved(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesRemoved(modelEvent);
			}
		}

		protected void fireTreeStructureChanged(Object source,
			Object[] path, int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeStructureChanged(modelEvent);
			}
		}

		private final OptionGroup root;
		private final EventListenerList listenerList = new EventListenerList();
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.menu.EnhancedCheckBoxMenuItem,5,7,0,7,34,0,3,7,3,0.666666667,159,1.0,1,0.995043371,0.32,3,13,30.2,4,1.6,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem
{
	
	
	public EnhancedCheckBoxMenuItem(String label, String action,
		ActionContext context)
	{
		this.context = context;
		this.action = action;
		this.shortcut = GUIUtilities.getShortcutLabel(action);
		if(OperatingSystem.hasScreenMenuBar() && shortcut != null)
		{
			setText(label + "" ("" + shortcut + "")"");
			shortcut = null;
		}
		else
			setText(label);

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(context,action));

			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);

		setModel(new Model());
	} 

	
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();

		if(shortcut != null)
		{
			d.width += (getFontMetrics(EnhancedMenuItem.acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} 

	
	public void paint(Graphics g)
	{
		super.paint(g);

		if(shortcut != null)
		{
			g.setFont(EnhancedMenuItem.acceleratorFont);
			g.setColor(getModel().isArmed() ?
				EnhancedMenuItem.acceleratorSelectionForeground :
				EnhancedMenuItem.acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 
				(OperatingSystem.isMacOSLF() ? 0 : 1))
				);
		}
	} 

	

	
	private ActionContext context;
	private String shortcut;
	private String action;
	

	

	
	class Model extends DefaultButtonModel
	{
		public boolean isSelected()
		{
			if(!isShowing())
				return false;

			EditAction a = context.getAction(action);
			if(a == null)
			{
				Log.log(Log.WARNING,this,""Unknown action: ""
					+ action);
				return false;
			}

			try
			{
				return a.isSelected(EnhancedCheckBoxMenuItem.this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);
				return false;
			}
		}

		public void setSelected(boolean b) {}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		boolean msgSet = false;

		public void mouseReleased(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}

		public void mouseEntered(MouseEvent evt)
		{
			String msg = jEdit.getProperty(action + "".mouse-over"");
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
				msgSet = true;
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.ExplicitFoldHandler,2,2,0,3,5,1,1,2,2,2.0,74,0.0,0,0.888888889,0.625,0,0,36.0,9,4.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;


public class ExplicitFoldHandler extends FoldHandler
{
	
	public ExplicitFoldHandler()
	{
		super(""explicit"");
	} 

	
	
	public int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg)
	{
		if(lineIndex == 0)
			return 0;
		else
		{
			int foldLevel = buffer.getFoldLevel(lineIndex - 1);

			buffer.getLineText(lineIndex - 1,seg);

			int offset = seg.offset;
			int count = seg.count;

			int openingBrackets = 0, closingBrackets = 0;
			for(int i = 0; i < count; i++)
			{
				switch(seg.array[offset + i])
				{
				case '{':
					closingBrackets = 0;
					openingBrackets++;
					if(openingBrackets == 3)
					{
						foldLevel++;
						openingBrackets = 0;
					}
					break;
				case '}':
					openingBrackets = 0;
					closingBrackets++;
					if(closingBrackets == 3)
					{
						if(foldLevel > 0)
							foldLevel--;
						closingBrackets = 0;
					}
					break;
				default:
					closingBrackets = openingBrackets = 0;
					break;
				}
			}

			return foldLevel;
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHPrimaryExpression,4,2,0,13,14,6,4,9,2,2.0,113,0.0,0,0.85,0.6,1,1,27.25,1,0.75,0,"


package org.gjt.sp.jedit.bsh;

class BSHPrimaryExpression extends SimpleNode
{
	BSHPrimaryExpression(int id) { super(id); }

	
	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		return eval( false, callstack, interpreter );
	}

	
	public LHS toLHS( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = eval( true, callstack, interpreter );

		if ( ! (obj instanceof LHS) )
			throw new EvalError(""Can't assign to:"", this, callstack );
		else
			return (LHS)obj;
	}

	
	private Object eval( boolean toLHS, 
		CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = jjtGetChild(0);
		int numChildren = jjtGetNumChildren(); 

		for(int i=1; i<numChildren; i++)
			obj = ((BSHPrimarySuffix)jjtGetChild(i)).doSuffix(
				obj, toLHS, callstack, interpreter);

		
		if ( obj instanceof SimpleNode )
			if ( obj instanceof BSHAmbiguousName )
				if ( toLHS )
					obj = ((BSHAmbiguousName)obj).toLHS(
						callstack, interpreter);
				else
					obj = ((BSHAmbiguousName)obj).toObject(
						callstack, interpreter);
			else 
				
				if ( toLHS )
					
					throw new EvalError(""Can't assign to prefix."", 
						this, callstack );
				else
					obj = ((SimpleNode)obj).eval(callstack, interpreter);	

		
		if ( obj instanceof LHS )
			if ( toLHS )
				return obj;
			else
				try {
					return ((LHS)obj).getValue();
				} catch ( UtilEvalError e ) {
					throw e.toEvalError( this, callstack );
				}
		else
			return obj;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.DefaultFocusComponent,1,1,0,6,1,0,6,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui;


public interface DefaultFocusComponent
{
	
	void focusOnDefaultComponent();
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.JJTParserState,12,1,0,3,25,0,2,1,0,0.436363636,212,1.0,0,0.0,0.395833333,0,0,16.25,3,1.3333,0,"

package org.gjt.sp.jedit.bsh;

class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;

  private int sp;		
  private int mk;		
  private boolean node_created;

  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }

  
  boolean nodeCreated() {
    return node_created;
  }

  
  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }

  
  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }

  
  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }

  
  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }

  
  Node peekNode() {
    return (Node)nodes.peek();
  }

  
  int nodeArity() {
    return sp - mk;
  }


  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }


  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }


  
  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }


  
  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHType,9,2,0,20,27,18,10,10,7,0.8125,288,0.75,0,0.68,0.277777778,0,0,30.55555556,12,2.8889,0,"


package org.gjt.sp.jedit.bsh;

import java.lang.reflect.Array;

class BSHType extends SimpleNode 
	implements BshClassManager.Listener
{
	
	private Class baseType;
	
    private int arrayDims;

	
    private Class type;

	String descriptor;

    BSHType(int id) { 
		super(id); 
	}

	
    public void addArrayDimension() { 
		arrayDims++; 
	}

	SimpleNode getTypeNode() {
        return (SimpleNode)jjtGetChild(0);
	}

    
    public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
    {
        
		if ( descriptor != null )
			return descriptor;

		String descriptor;
        
        SimpleNode node = getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            descriptor = getTypeDescriptor( ((BSHPrimitiveType)node).type );
        else 
		{
            String clasName = ((BSHAmbiguousName)node).text;
			BshClassManager bcm = interpreter.getClassManager();
			
			
			
			
			String definingClass = bcm.getClassBeingDefined( clasName );

            Class clas = null;
			if ( definingClass == null )
			{
				try {
					clas = ((BSHAmbiguousName)node).toClass( 
						callstack, interpreter );
				} catch ( EvalError e ) {
					
					
					
				}
			} else
				clasName = definingClass;

			if ( clas != null )
			{
				
            	descriptor = getTypeDescriptor( clas );
			}else
			{
				if ( defaultPackage == null || Name.isCompound( clasName ) )
            		descriptor = ""L"" + clasName.replace('.','/') + "";"";
				else
            		descriptor = 
						""L""+defaultPackage.replace('.','/')+""/""+clasName + "";"";
			}
		}

		for(int i=0; i<arrayDims; i++)
			descriptor = ""[""+descriptor;

		this.descriptor = descriptor;
	
        return descriptor;
    }

    public Class getType( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
        
		if ( type != null )
			return type;

        
        SimpleNode node = getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            baseType = ((BSHPrimitiveType)node).getType();
        else 
            baseType = ((BSHAmbiguousName)node).toClass( 
				callstack, interpreter );

        if ( arrayDims > 0 ) {
            try {
                
				
                int[] dims = new int[arrayDims]; 
                Object obj = Array.newInstance(baseType, dims);
                type = obj.getClass(); 
            } catch(Exception e) {
                throw new EvalError(""Couldn't construct array type"", 
					this, callstack );
            }
        } else
            type = baseType;

		
		
		interpreter.getClassManager().addListener(this);

        return type;
    }

	
	public Class getBaseType() {
		return baseType;
	}
	
	public int getArrayDims() {
		return arrayDims;
	}

	public void classLoaderChanged() {
		type = null;
		baseType = null;
	}

	public static String getTypeDescriptor( Class clas ) 
	{
		if ( clas == Boolean.TYPE ) return ""Z"";
		if ( clas == Character.TYPE ) return ""C""; 
		if ( clas == Byte.TYPE ) return ""B"";
		if ( clas == Short.TYPE ) return ""S"";
		if ( clas == Integer.TYPE ) return ""I"";
		if ( clas == Long.TYPE ) return ""J"";
		if ( clas == Float.TYPE ) return ""F"";
		if ( clas == Double.TYPE ) return ""D"";
		if ( clas == Void.TYPE ) return ""V"";
	
		String name = clas.getName().replace('.','/');

		if ( name.startsWith(""["") || name.endsWith("";"") )
			return name;
		else
			return ""L""+ name.replace('.','/') +"";"";
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.JCheckBoxList,10,5,0,8,44,43,4,5,9,0.666666667,218,1.0,0,0.990654206,0.375,1,1,20.7,4,1.6,0,"

package org.gjt.sp.jedit.gui;


import java.awt.Component;
import java.awt.Font;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;
import javax.swing.table.*;



public class JCheckBoxList extends JTable
{
	
	
	public JCheckBoxList(Object[] items)
	{
		setModel(items);
	} 

	
	
	public JCheckBoxList(Vector items)
	{
		setModel(items);
	} 

	
	
	public void setModel(Object[] items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	} 

	
	
	public void setModel(Vector items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	} 

	
	public Object[] getCheckedValues()
	{
		List<Object> values = new ArrayList<Object>();
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = model.items.get(i);
			if(entry.checked && !entry.caption)
			{
				values.add(entry.value);
			}
		}

		Object[] retVal = new Object[values.size()];
		return values.toArray(retVal);
	} 

	
	@Override
	public void selectAll()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = model.items.elementAt(i);
			if(!entry.caption)
				entry.checked = true;
		}

		model.fireTableRowsUpdated(0,model.getRowCount());
	} 

	
	public Entry[] getValues()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		Entry[] retVal = new Entry[model.items.size()];
		model.items.copyInto(retVal);
		return retVal;
	} 

	
	public Object getSelectedValue()
	{
		int row = getSelectedRow();
		if(row == -1)
		{
			return null;
		}
		else
		{
			return getModel().getValueAt(row,1);
		}
	} 

	
	@Override
	public TableCellRenderer getCellRenderer(int row, int column)
	{
		if(column == 0)
		{
			Entry entry = ((CheckBoxListModel)getModel()).items.get(row);
			if(entry.caption)
				return dummy;
		}

		return super.getCellRenderer(row,column);
	} 

	
	private TableCellRenderer dummy;

	
	private void init()
	{
		dummy = new DummyRenderer();
		getSelectionModel().setSelectionMode(ListSelectionModel
			.SINGLE_SELECTION);
		setShowGrid(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
		TableColumn column = getColumnModel().getColumn(0);
		int checkBoxWidth = new JCheckBox().getPreferredSize().width;
		column.setPreferredWidth(checkBoxWidth);
		column.setMinWidth(checkBoxWidth);
		column.setWidth(checkBoxWidth);
		column.setMaxWidth(checkBoxWidth);
		column.setResizable(false);

		column = getColumnModel().getColumn(1);
		column.setCellRenderer(new LabelRenderer());
	} 

	

	
	
	public static class Entry
	{
		boolean checked;
		boolean caption;
		Object value;

		public Entry(Object value)
		{
			this.caption = true;
			this.value = value;
		}

		public Entry(boolean checked, Object value)
		{
			this.checked = checked;
			this.value = value;
		}

		public boolean isChecked()
		{
			return checked;
		}

		public Object getValue()
		{
			return value;
		}
	} 

	
	private static class DummyRenderer extends DefaultTableCellRenderer
	{
		@Override
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			return super.getTableCellRendererComponent(table,null ,
				isSelected,false ,row,column);
		}
	} 

	
	private class LabelRenderer extends DefaultTableCellRenderer
	{
		Font plainFont, boldFont;

		LabelRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = plainFont.deriveFont(Font.BOLD);
		}

		@Override
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table,value,isSelected,
				hasFocus,row,column);

			Entry entry = ((CheckBoxListModel)getModel()).items.get(row);
			if(entry.caption)
				setFont(boldFont);
			else
				setFont(plainFont);
			return this;
		}
	} 
}


class CheckBoxListModel extends AbstractTableModel
{
	Vector<JCheckBoxList.Entry> items;

	CheckBoxListModel(Vector _items)
	{
		items = new Vector<JCheckBoxList.Entry>(_items.size());
		for(int i = 0; i < _items.size(); i++)
		{
			items.add(createEntry(_items.elementAt(i)));
		}
	}

	CheckBoxListModel(Object[] _items)
	{
		items = new Vector<JCheckBoxList.Entry>(_items.length);
		for(int i = 0; i < _items.length; i++)
		{
			items.add(createEntry(_items[i]));
		}
	}

	private static JCheckBoxList.Entry createEntry(Object obj)
	{
		if(obj instanceof JCheckBoxList.Entry)
			return (JCheckBoxList.Entry)obj;
		else
			return new JCheckBoxList.Entry(false,obj);
	}

	public int getRowCount()
	{
		return items.size();
	}

	public int getColumnCount()
	{
		return 2;
	}

	@Override
	public String getColumnName(int col)
	{
		return null;
	}

	public Object getValueAt(int row, int col)
	{
		JCheckBoxList.Entry entry = items.get(row);
		switch(col)
		{
		case 0:
			return Boolean.valueOf(entry.checked);
		case 1:
			return entry.value;
		default:
			throw new InternalError();
		}
	}

	@Override
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return Boolean.class;
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	}

	@Override
	public boolean isCellEditable(int row, int col)
	{
		JCheckBoxList.Entry entry = items.get(row);
		return col == 0 && !entry.caption;
	}

	@Override
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
		{
			JCheckBoxList.Entry entry = items.get(row);
			if(!entry.caption)
			{
				entry.checked = value.equals(Boolean.TRUE);
				fireTableRowsUpdated(row,row);
			}
		}
	}
} 
"
jEdit,4.3,org.gjt.sp.jedit.bsh.CollectionManager,7,1,1,8,19,21,4,4,7,1.0,70,1.0,1,0.0,0.785714286,0,0,8.857142857,4,1.2857,0,"

package org.gjt.sp.jedit.bsh;

import java.util.Enumeration;
import java.util.Vector;
import java.util.Hashtable;
import java.lang.reflect.Array;


public class CollectionManager
{
    private static CollectionManager manager;

    public synchronized static CollectionManager getCollectionManager()
    {
        if ( manager == null
            && Capabilities.classExists(""java.util.Collection"") )
        {
            Class clas;
            try {
                clas = Class.forName( ""org.gjt.sp.jedit.bsh.collection.CollectionManagerImpl"" );
                manager = (CollectionManager)clas.newInstance();
            } catch ( Exception e ) {
                Interpreter.debug(""unable to load CollectionManagerImpl: ""+e);
            }
        }

        if ( manager == null )
            manager = new CollectionManager(); 

        return manager;
    }

    
    public boolean isBshIterable( Object obj )
    {
        
        try {
            getBshIterator( obj );
            return true;
        } catch( IllegalArgumentException e ) {
            return false;
        }
    }

    public BshIterator getBshIterator( Object obj )
        throws IllegalArgumentException
    {
        return new BasicBshIterator( obj );
    }

    public boolean isMap( Object obj ) {
        return obj instanceof Hashtable;
    }

    public Object getFromMap( Object map, Object key ) {
        return ((Hashtable)map).get(key);
    }

    public Object putInMap( Object map, Object key, Object value )
    {
        return ((Hashtable)map).put(key, value);
    }

    

    
    public static class BasicBshIterator implements BshIterator
    {
        Enumeration enumeration;

        
        public BasicBshIterator(Object iterateOverMe) {
            enumeration = createEnumeration(iterateOverMe);
        }

        
        protected Enumeration createEnumeration( Object iterateOverMe )
        {
            if(iterateOverMe==null)
                throw new NullPointerException(""Object arguments passed to "" +
                    ""the BasicBshIterator constructor cannot be null."");

            if (iterateOverMe instanceof Enumeration)
                return (Enumeration)iterateOverMe;

            if (iterateOverMe instanceof Vector)
                return ((Vector)iterateOverMe).elements();

            if (iterateOverMe.getClass().isArray()) {
                final Object array = iterateOverMe;
                return new Enumeration() {
                    int index = 0, length = Array.getLength(array);
                    public Object nextElement() {
                        return Array.get(array, index++);
                    }
                    public boolean hasMoreElements() { return index<length; }
                };
            }

            if (iterateOverMe instanceof String)
                return createEnumeration(((String)iterateOverMe).toCharArray());

            if (iterateOverMe instanceof StringBuffer)
                return createEnumeration(
                    iterateOverMe.toString().toCharArray());

            if (iterateOverMe instanceof StringBuilder)
                return createEnumeration(
                    iterateOverMe.toString().toCharArray());

            throw new IllegalArgumentException(
                ""Cannot enumerate object of type ""+iterateOverMe.getClass());
        }

        
        public Object next() {
            return 	enumeration.nextElement();
        }

        
        public boolean hasNext() {
            return enumeration.hasMoreElements();
        }
    }
}
"
jEdit,4.3,org.gjt.sp.jedit.search.BoyerMooreSearchMatcher,7,2,0,3,18,0,1,2,4,0.619047619,366,1.0,0,0.142857143,0.428571429,0,0,50.28571429,11,4.2857,0,"

package org.gjt.sp.jedit.search;


public class BoyerMooreSearchMatcher extends SearchMatcher
{
	
	
	public BoyerMooreSearchMatcher(String pattern, boolean ignoreCase)
	{
		this.pattern = pattern.toCharArray();
		if(ignoreCase)
		{
			for(int i = 0; i < this.pattern.length; i++)
			{
				this.pattern[i] = Character.toUpperCase(
					this.pattern[i]);
			}
		}

		this.ignoreCase = ignoreCase;

		pattern_end = this.pattern.length - 1;
	} 

	
	
	public SearchMatcher.Match nextMatch(CharSequence text,
		boolean start, boolean end, boolean firstTime,
		boolean reverse)
	{
		int pos = match(text,reverse);

		if (pos == -1)
		{
			return null;
		}
		else
		{
			returnValue.start = pos;
			returnValue.end = pos + pattern.length;
			return returnValue;
		}
	} 

	
	
	public int match(CharSequence text, boolean reverse)
	{
		
		
		
		int[] skip, suffix;
		if(reverse)
		{
			if(back_skip == null)
			{
				back_skip = generateSkipArray(true);
				back_suffix = generateSuffixArray(true);
			}
			skip = back_skip;
			suffix = back_suffix;
		}
		else
		{
			if(fwd_skip == null)
			{
				fwd_skip = generateSkipArray(false);
				fwd_suffix = generateSuffixArray(false);
			}
			skip = fwd_skip;
			suffix = fwd_suffix;
		} 

		
		int pos;

		
		int anchor = 0;

		
		
		
		
		
		

		char ch = 0;

		int bad_char;
		int good_suffix;

		
		
		
		
		
		
		
		
		
		
		SEARCH:
		while (anchor + pattern_end < text.length())
		{
			for (pos = pattern_end; pos >= 0; --pos)
			{
				ch = text.charAt(pos + anchor);
				if(ignoreCase)
					ch = Character.toUpperCase(ch);

				
				if ((reverse ? ch != pattern[pattern_end - pos]
					: ch != pattern[pos]))
				{
					

					
					bad_char = pos - skip[getSkipIndex(ch)];

					
					good_suffix = suffix[pos];

					
					
					int skip_index = (bad_char > good_suffix) ? bad_char : good_suffix;
					anchor += skip_index;

					
					continue SEARCH;
				}
			}

			
			return anchor;
		}

		
		return -1;
	} 

	
	public String toString()
	{
		return ""BoyerMooreSearchMatcher["" + new String(pattern) + ',' + ignoreCase + ']';
	} 

	
	private char[] pattern;
	private int pattern_end;
	private boolean ignoreCase;

	
	private int[] fwd_skip;
	private int[] fwd_suffix;
	private int[] back_skip;
	private int[] back_suffix;

	

	
	
	private int[] generateSkipArray(boolean reverse)
	{
		
		int[] skip = new int[256];

		
		if (pattern.length == 0)
			return skip;

		int pos = 0;

		do
		{
			skip[getSkipIndex(pattern[reverse ? pattern_end - pos : pos])] = pos;
		}
		while (++pos < pattern.length);

		return skip;
	} 

	
	
	private static final int getSkipIndex(char ch)
	{
		return ch & 0x000000FF;
	} 

	
	
	private int[] generateSuffixArray(boolean reverse)
	{
		int m = pattern.length;

		int j = m + 1;

		int[] suffix = new int[j];
		int[] tmp = new int[j];
		tmp[m] = j;

		for (int i = m; i > 0; --i)
		{
			while (j <= m && pattern[reverse ? pattern_end - i + 1 : i - 1]
				!= pattern[reverse ? pattern_end - j + 1 : j - 1])
			{
				if (suffix[j] == 0)
				{
					suffix[j] = j - i;
				}

				j = tmp[j];
			}

			tmp[i - 1] = --j;
		}

		int k = tmp[0];

		for (j = 0; j <= m; j++)
		{
			
			
			
			if (j > 0)
			{
				suffix[j - 1] = (suffix[j] == 0) ? k : suffix[j];
			}

			if (j == k)
			{
				k = tmp[k];
			}
		}

		return suffix;
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.proto.jeditresource.PluginResURLConnection,4,2,0,5,25,0,1,4,4,0.333333333,187,1.0,0,0.950819672,0.5,1,7,45.0,8,2.5,0,"

package org.gjt.sp.jedit.proto.jeditresource;


import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;


public class PluginResURLConnection extends URLConnection
{
	public PluginResURLConnection(URL url)
		throws IOException
	{
		super(url);

		String file = url.getFile();

		int index = file.indexOf('!',0);
		if(index == -1)
		{
			plugin = null;
			resource = file;
		}
		else
		{
			int start;
			if(file.charAt(0) == '/')
				start = 1;
			else
				start = 0;

			plugin = file.substring(start,index);
			resource = file.substring(index + 1);
		}

		if(plugin != null && resource.startsWith(""/""))
			resource = resource.substring(1);
	}

	public void connect() throws IOException
	{
		if(!connected)
		{
			if(plugin == null)
			{
				in = jEdit.class.getResourceAsStream(resource);
			}
			else
			{
				PluginJAR[] plugins = jEdit.getPluginJARs();
				for(int i = 0; i < plugins.length; i++)
				{
					PluginJAR jar = plugins[i];
					String jarName =MiscUtilities.getFileName(jar.getPath()).toLowerCase(); 
					if(plugin.equalsIgnoreCase(jarName))
					{
						in = jar.getClassLoader()
						            .getResourceAsStream(resource);
						break;
					}
				}
			}

			if(in == null)
			{
				throw new IOException(""Resource not found: "" + plugin + ""!"" 
					+ resource);
			}

			connected = true;
		}
	}

	public InputStream getInputStream()
		throws IOException
	{
		connect();
		return in;
	}

	public String getHeaderField(String name)
	{
		if(name.equals(""content-type""))
		{
			String lcResource = resource.toLowerCase();
			if(lcResource.endsWith("".html""))
				return ""text/html"";
			else if(lcResource.endsWith("".txt""))
				return ""text/plain"";
			else if(lcResource.endsWith("".rtf""))
				return ""text/rtf"";
			else if(lcResource.endsWith("".gif""))
				return ""image/gif"";
			else if(lcResource.endsWith("".jpg"")
				|| lcResource.endsWith("".jpeg""))
				return ""image/jpeg"";
			else
				return null;
		}
		else
			return null;
	}

	
	private InputStream in;
	private String plugin;
	private String resource;
}
"
jEdit,4.3,org.gjt.sp.jedit.options.BrowserOptionPane,3,6,0,2,17,1,0,2,3,0.5,325,1.0,0,0.997019374,1.0,2,4,104.0,6,2.3333,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import org.gjt.sp.jedit.*;




public class BrowserOptionPane extends AbstractOptionPane
{
	
	public BrowserOptionPane()
	{
		super(""browser.general"");
	} 

	
	public void _init()
	{
		
		String[] dirs = {
			jEdit.getProperty(""options.browser.general.defaultPath.favorites""),
			jEdit.getProperty(""options.browser.general.defaultPath.home""),
			jEdit.getProperty(""options.browser.general.defaultPath.last""),
			jEdit.getProperty(""options.browser.general.defaultPath.buffer""),
			jEdit.getProperty(""options.browser.general.defaultPath.working"")
		};

		defaultDirectory = new JComboBox(dirs);
		String defaultDir = jEdit.getProperty(""vfs.browser.defaultPath"");
		if(""favorites"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(0);
		else if(""home"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(1);
		else if(""last"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(2);
		else if(""buffer"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(3);
		else if(""working"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(4);
		addComponent(jEdit.getProperty(""options.browser.general.defaultPath""),
			defaultDirectory);

		
		showToolbar = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showToolbar""));
		addComponent(showToolbar);

		
		showMenubar = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showMenubar""));
		showMenubar.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showMenubar""));
		addComponent(showMenubar);

		
		showIcons = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showIcons""));
		showIcons.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showIcons""));
		addComponent(showIcons);

		
		showHiddenFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showHiddenFiles""));
		showHiddenFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showHiddenFiles""));
		addComponent(showHiddenFiles);

		
		sortIgnoreCase = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortIgnoreCase""));
		sortIgnoreCase.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortIgnoreCase""));
		addComponent(sortIgnoreCase);

		
		sortMixFilesAndDirs = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortMixFilesAndDirs""));
		sortMixFilesAndDirs.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortMixFilesAndDirs""));
		addComponent(sortMixFilesAndDirs);

		
		doubleClickClose = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.doubleClickClose""));
		doubleClickClose.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".doubleClickClose""));
		addComponent(doubleClickClose);

		
		currentBufferFilter = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.currentBufferFilter""));
		currentBufferFilter.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".currentBufferFilter""));
		addComponent(currentBufferFilter);

		
		useDefaultIcons = new JCheckBox(jEdit.getProperty(""options.browser.general.useDefaultIcons""));
		useDefaultIcons.setSelected(jEdit.getBooleanProperty(""vfs.browser.useDefaultIcons""));
		addComponent(useDefaultIcons);
	} 

	
	public void _save()
	{
		String[] dirs = { ""favorites"", ""home"", ""last"", ""buffer"", ""working""};
		jEdit.setProperty(""vfs.browser.defaultPath"",dirs[defaultDirectory
			.getSelectedIndex()]);
		jEdit.setBooleanProperty(""vfs.browser.showToolbar"",
			showToolbar.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showMenubar"",
			showMenubar.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showIcons"",
			showIcons.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showHiddenFiles"",
			showHiddenFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortIgnoreCase"",
			sortIgnoreCase.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortMixFilesAndDirs"",
			sortMixFilesAndDirs.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.doubleClickClose"",
			doubleClickClose.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.currentBufferFilter"",
			currentBufferFilter.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.useDefaultIcons"",
			useDefaultIcons.isSelected());
	} 

	
	private JComboBox defaultDirectory;
	private JCheckBox showToolbar;
	private JCheckBox showMenubar;
	private JCheckBox showIcons;
	private JCheckBox showHiddenFiles;
	private JCheckBox sortIgnoreCase;
	private JCheckBox sortMixFilesAndDirs;
	private JCheckBox doubleClickClose;
	private JCheckBox currentBufferFilter;
	private JCheckBox useDefaultIcons;
	
} 
"
jEdit,4.3,org.gjt.sp.jedit.textarea.Anchor,6,1,2,7,19,7,2,5,1,0.866666667,141,0.333333333,2,0.0,0.416666667,0,0,21.5,7,2.1667,0,"

package org.gjt.sp.jedit.textarea;

import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;


abstract class Anchor
{
	protected final DisplayManager displayManager;
	protected final TextArea textArea;
	
	int physicalLine;
	
	int scrollLine;
	
	boolean callChanged;
	
	boolean callReset;

	
	protected Anchor(DisplayManager displayManager,
		TextArea textArea)
	{
		this.displayManager = displayManager;
		this.textArea = textArea;
	} 

	
	abstract void reset();
	abstract void changed();

	
	@Override
	public String toString()
	{
		return getClass().getName() + '[' + physicalLine + ','
		       + scrollLine + ']';
	} 

	
	
	void contentInserted(int startLine, int numLines)
	{
		
		if(physicalLine >= startLine)
		{
			if(physicalLine != startLine)
				physicalLine += numLines;
			callChanged = true;
		}
	} 

	
	
	void preContentRemoved(int startLine, int offset, int numLines)
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""preContentRemoved() before:"" + this);
		
		if(physicalLine >= startLine)
		{
			if(physicalLine == startLine)
				callChanged = true;
			else
			{
				int end = Math.min(startLine + numLines, physicalLine);
				
				

				

				
				
				

				for(int i = startLine + 1; i <= end; i++)
				{
					
					if(displayManager.isLineVisible(i))
					{
						scrollLine -=
							displayManager
								.screenLineMgr
								.getScreenLineCount(i);
					}
				}
				physicalLine -= end - startLine;
				callChanged = true;
			}
		}
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""preContentRemoved() after:"" + this);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ConsoleInterface,6,1,0,1,6,15,1,0,6,2.0,6,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"


package org.gjt.sp.jedit.bsh;

import java.io.*;


public interface ConsoleInterface {
    public Reader getIn();
    public PrintStream getOut();
    public PrintStream getErr();
    public void println( Object o );
    public void print( Object o );
    public void error( Object o );
}

"
jEdit,4.3,org.gjt.sp.jedit.Registers,23,1,0,21,69,175,10,11,18,0.712121212,533,1.0,3,0.0,0.151515152,0,0,21.91304348,8,2.8696,0,"

package org.gjt.sp.jedit;


import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.io.*;

import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.gui.HistoryModel;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.jedit.textarea.Selection;
import org.gjt.sp.util.Log;



public class Registers
{
	
	
	public static void copy(TextArea textArea, char register)
	{
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;

		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);

	} 

	
	
	public static void cut(TextArea textArea, char register)
	{
		if(textArea.isEditable())
		{
			String selection = textArea.getSelectedText();
			if(selection == null)
				return;

			setRegister(register,selection);
			HistoryModel.getModel(""clipboard"").addItem(selection);

			textArea.setSelectedText("""");
		}
		else
			textArea.getToolkit().beep();
	} 

	
	
	public static void append(TextArea textArea, char register)
	{
		append(textArea,register,""\n"",false);
	} 

	
	
	public static void append(TextArea textArea, char register,
		String separator)
	{
		append(textArea,register,separator,false);
	} 

	
	
	public static void append(TextArea textArea, char register,
		String separator, boolean cut)
	{
		if(cut && !textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		String selection = textArea.getSelectedText();
		if(selection == null)
			return;

		Register reg = getRegister(register);

		if(reg != null)
		{
			String registerContents = reg.toString();
			if(registerContents != null)
			{
				if(registerContents.endsWith(separator))
					selection = registerContents + selection;
				else
					selection = registerContents + separator + selection;
			}
		}

		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);

		if(cut)
			textArea.setSelectedText("""");
	} 

	
	
	public static void paste(TextArea textArea, char register)
	{
		paste(textArea,register,false);
	}

	
	public static void paste(TextArea textArea, char register,
		boolean vertical)
	{
		if(!textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		Register reg = getRegister(register);

		if(reg == null)
		{
			textArea.getToolkit().beep();
			return;
		}

		String selection = reg.toString();
		if(selection == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		JEditBuffer buffer = textArea.getBuffer();
		try
		{
			buffer.beginCompoundEdit();

			
			if(vertical && textArea.getSelectionCount() == 0)
			{
				int caret = textArea.getCaretPosition();
				int caretLine = textArea.getCaretLine();
				Selection.Rect rect = new Selection.Rect(
					caretLine,caret,caretLine,caret);
				textArea.setSelectedText(rect,selection);
				caretLine = textArea.getCaretLine();

				if(caretLine != textArea.getLineCount() - 1)
				{

					int startColumn = rect.getStartColumn(
						buffer);
					int offset = buffer
						.getOffsetOfVirtualColumn(
						caretLine + 1,startColumn,null);
					if(offset == -1)
					{
						buffer.insertAtColumn(caretLine + 1,startColumn,"""");
						textArea.setCaretPosition(
							buffer.getLineEndOffset(
							caretLine + 1) - 1);
					}
					else
					{
						textArea.setCaretPosition(
							buffer.getLineStartOffset(
							caretLine + 1) + offset);
					}
				}
			}
			else 
			{
				textArea.replaceSelection(selection);
			}
		}
		finally {
			buffer.endCompoundEdit();
		}
		HistoryModel.getModel(""clipboard"").addItem(selection);
	} 

	
	
	public static Register getRegister(char name)
	{
		if(name != '$' && name != '%')
		{
			if(!loaded)
				loadRegisters();
		}

		if(registers == null || name >= registers.length)
			return null;
		else
			return registers[name];
	} 

	
	
	public static void setRegister(char name, Register newRegister)
	{
		touchRegister(name);

		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16, name<<1)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
		}

		registers[name] = newRegister;
		if (listener != null)
			listener.registerChanged(name);
	} 

	
	
	public static void setRegister(char name, String value)
	{
		touchRegister(name);
		Register register = getRegister(name);
		if(register != null)
		{
			register.setValue(value);
			if (listener != null)
				listener.registerChanged(name);
		}
		else
			setRegister(name,new StringRegister(value));
	} 

	
	
	public static void clearRegister(char name)
	{
		if(name >= registers.length)
			return;

		Register register = registers[name];
		if(name == '$' || name == '%')
			register.setValue("""");
		else
		{
			registers[name] = null;
			modified = true;
			if (listener != null)
				listener.registerChanged(name);
		}
	} 

	
	
	public static Register[] getRegisters()
	{
		if(!loaded)
			loadRegisters();
		return registers;
	} 

	
	
	public static String getRegisterNameString()
	{
		if(!loaded)
			loadRegisters();

		StringBuilder buf = new StringBuilder(registers.length << 1);
		for(int i = 0; i < registers.length; i++)
		{
			if(registers[i] != null)
			{
				if(buf.length() != 0)
					buf.append(' ');
				buf.append((char)i);
			}
		}

		if(buf.length() == 0)
			return null;
		else
			return buf.toString();
	} 

	
	public static void saveRegisters()
	{
		if(!loaded || !modified)
			return;

		if (saver != null)
		{
			saver.saveRegisters();
			modified = false;
		}
	} 

	
	public static void setListener(RegistersListener listener)
	{
		Registers.listener = listener;
	} 

	
	public static void setSaver(RegisterSaver saver)
	{
		Registers.saver = saver;
	} 

	
	public static boolean isLoading()
	{
		return loading;
	} 

	
	public static void setLoading(boolean loading)
	{
		Registers.loading = loading;
	} 

	
	private static Register[] registers;
	private static boolean loaded, loading;
	private static RegisterSaver saver;
	private static RegistersListener listener;
	
	private static boolean modified;

	private Registers() {}

	static
	{
		registers = new Register[256];
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		registers['$'] = new ClipboardRegister(
			toolkit.getSystemClipboard());
		Clipboard selection = toolkit.getSystemSelection();
		if(selection != null)
			registers['%'] = new ClipboardRegister(selection);
	}

	
	private static void touchRegister(char name)
	{
		if(name == '%' || name == '$')
			return;

		if(!loaded)
			loadRegisters();

		if(!loading)
			modified = true;
	} 

	
	private static void loadRegisters()
	{
		if (saver != null)
		{
			loaded = true;
			saver.loadRegisters();
		}
	} 

	

	

	
	
	public interface Register
	{
		
		String toString();

		
		void setValue(String value);
	} 

	
	
	public static class ClipboardRegister implements Register
	{
		Clipboard clipboard;

		public ClipboardRegister(Clipboard clipboard)
		{
			this.clipboard = clipboard;
		}

		
		public void setValue(String value)
		{
			StringSelection selection = new StringSelection(value);
			clipboard.setContents(selection,null);
		}

		
		@Override
		public String toString()
		{
			try
			{

				if (false)
				{
					
					Log.log(Log.DEBUG,this,""clipboard.getContents(this)=""+clipboard.getContents(this)+'.');
					debugListDataFlavors(clipboard.getContents(this));
				}

				String selection = (String)clipboard
					.getContents(this).getTransferData(
					DataFlavor.stringFlavor);

				boolean trailingEOL = selection.endsWith(""\n"")
					|| selection.endsWith(System.getProperty(
					""line.separator""));

				
				
				
				BufferedReader in = new BufferedReader(
					new StringReader(selection));
				StringBuilder buf = new StringBuilder();
				String line;
				while((line = in.readLine()) != null)
				{
					
					
					if(line.endsWith(""\0""))
					{
						line = line.substring(0,
							line.length() - 1);
					}
					buf.append(line);
					buf.append('\n');
				}
				
				if(!trailingEOL && buf.length() != 0)
					buf.setLength(buf.length() - 1);
				return buf.toString();
			}
			catch(Exception e)
			{
				Log.log(Log.NOTICE,this,e);
				return null;
			}
		}
	} 

	
	protected static void debugListDataFlavors(Transferable transferable)
	{
		DataFlavor[] dataFlavors = transferable.getTransferDataFlavors();

		for (int i = 0;i<dataFlavors.length;i++)
		{
			DataFlavor dataFlavor = dataFlavors[i];
			Log.log(Log.DEBUG,Registers.class,
				""debugListDataFlavors(): dataFlavor=""+
				dataFlavor+'.');
		}

		if (dataFlavors.length == 0)
		{
			Log.log(Log.DEBUG,Registers.class,
				""debugListDataFlavors(): no dataFlavor supported."");
		}
	} 


	
	
	public static class StringRegister implements Register
	{
		private String value;

		
		public StringRegister(String value)
		{
			this.value = value;
		}

		
		public void setValue(String value)
		{
			this.value = value;
		}

		
		@Override
		public String toString()
		{
			return value;
		}

		
		public void dispose() {}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.DockableWindowUpdate,5,2,0,7,12,0,5,3,4,0.8,60,0.4,0,0.5,0.4375,1,1,10.0,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.jedit.*;


public class DockableWindowUpdate extends EBMessage
{
	
	
	public static final Object PROPERTIES_CHANGED = ""PROPERTIES_CHANGED"";

	
	public static final Object ACTIVATED = ""ACTIVATED"";

	
	public static final Object DEACTIVATED = ""DEACTIVATED"";
	

	
	
	public DockableWindowUpdate(DockableWindowManager wm, Object what,
		String dockable)
	{
		super(wm);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
		this.dockable = dockable;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public String getDockable()
	{
		return dockable;
	} 

	
	public String paramString()
	{
		return ""what="" + what
			+ "",dockable="" + dockable
			+ "","" + super.paramString();
	} 

	
	private Object what;
	private String dockable;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.search.DirectoryListSet,10,2,0,11,29,0,5,7,8,0.666666667,178,1.0,0,0.4375,0.32,1,1,16.3,5,1.3,0,"

package org.gjt.sp.jedit.search;


import javax.swing.SwingUtilities;
import java.awt.Component;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;



public class DirectoryListSet extends BufferListSet
{
	
	public DirectoryListSet(String directory, String glob, boolean recurse)
	{
		this.directory = directory;
		this.glob = glob;
		this.recurse = recurse;
		this.skipBinary = jEdit.getBooleanProperty(""search.skipBinary.toggle"");
		this.skipHidden = jEdit.getBooleanProperty(""search.skipHidden.toggle"");
	} 



	
	public String getDirectory()
	{
		return directory;
	} 

	
	
	public void setDirectory(String directory)
	{
		this.directory = directory;
		invalidateCachedList();
	} 

	
	public String getFileFilter()
	{
		return glob;
	} 

	
	
	public void setFileFilter(String glob)
	{
		this.glob = glob;
		invalidateCachedList();
	} 

	
	public boolean isRecursive()
	{
		return recurse;
	} 

	
	
	public void setRecursive(boolean recurse)
	{
		this.recurse = recurse;
		invalidateCachedList();
	} 

	
	@Override
	public String getCode()
	{
		return ""new DirectoryListSet(\"""" + StandardUtilities.charsToEscapes(directory)
			+ ""\"",\"""" + StandardUtilities.charsToEscapes(glob) + ""\"",""
			+ recurse + ')';
	} 

	
	@Override
	protected String[] _getFiles(final Component comp)
	{
		skipBinary = jEdit.getBooleanProperty(""search.skipBinary.toggle"");
		skipHidden = jEdit.getBooleanProperty(""search.skipHidden.toggle"");
		final VFS vfs = VFSManager.getVFSForPath(directory);
		Object session;
		if(SwingUtilities.isEventDispatchThread())
		{
			session = vfs.createVFSSession(directory,comp);
		}
		else
		{
			final Object[] returnValue = new Object[1];

			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						returnValue[0] = vfs.createVFSSession(directory,comp);
					}
				});
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}

			session = returnValue[0];
		}

		if(session == null)
			return null;

		try
		{
			try
			{
				return vfs._listDirectory(session,directory,glob,recurse,comp, skipBinary, skipHidden);
			}
			finally
			{
				vfs._endVFSSession(session, comp);
			}
		}
		catch(IOException io)
		{
			VFSManager.error(comp,directory,""ioerror"",new String[]
				{ io.toString() });
			return null;
		}
	} 

	
	private String directory;
	private String glob;
	private boolean recurse;
	private boolean skipHidden;
	private boolean skipBinary;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHSwitchLabel,2,2,0,7,5,1,2,5,2,1.0,22,0.0,0,0.944444444,0.625,1,1,9.5,1,0.5,0,"

package org.gjt.sp.jedit.bsh;

class BSHSwitchLabel extends SimpleNode {
	boolean isDefault;

	public BSHSwitchLabel(int id) { super(id); }

	public Object eval(
		CallStack callstack, Interpreter interpreter) throws EvalError
	{
		if ( isDefault )
			return null; 
		SimpleNode label = ((SimpleNode)jjtGetChild(0));
		return label.eval( callstack, interpreter );
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.FileCellRenderer,8,6,0,15,52,10,9,7,5,0.868131868,339,0.307692308,1,0.991428571,0.242857143,2,3,39.75,9,2.625,0,"

package org.gjt.sp.jedit.browser;


import java.awt.*;
import java.awt.font.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.table.*;
import org.gjt.sp.jedit.io.VFSFile;
import org.gjt.sp.jedit.*;



public class FileCellRenderer extends DefaultTableCellRenderer
{
	public static Icon fileIcon = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.file.icon""));
	public static Icon openFileIcon = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.open-file.icon""));
	public static Icon dirIcon = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.dir.icon""));
	public static Icon openDirIcon = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.open-dir.icon""));
	public static Icon filesystemIcon = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.filesystem.icon""));
	public static Icon loadingIcon = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.loading.icon""));

	
	public FileCellRenderer()
	{
		plainFont = UIManager.getFont(""Tree.font"");
		if(plainFont == null)
			plainFont = jEdit.getFontProperty(""metal.secondary.font"");
		boldFont = plainFont.deriveFont(Font.BOLD);
	} 

	
	public Component getTableCellRendererComponent(JTable table,
		Object value, boolean isSelected, boolean hasFocus, 
		int row, int column)
	{
		super.getTableCellRendererComponent(table,value,isSelected,
			hasFocus,row,column);

		if(value instanceof VFSDirectoryEntryTableModel.Entry)
		{
			VFSDirectoryEntryTableModel.Entry entry =
				(VFSDirectoryEntryTableModel.Entry)value;
			VFSFile file = entry.dirEntry;

			setFont(file.getType() == VFSFile.FILE
				? plainFont : boldFont);

			this.isSelected = isSelected;
			this.file = file;

			if(column == 0)
			{
				
				
				
				String path;
				if(file.getSymlinkPath() == null)
					path = file.getPath();
				else
					path = file.getSymlinkPath();
				openBuffer = jEdit._getBuffer(path) != null;

				setIcon(showIcons
					? getIconForFile(file,entry.expanded,
					openBuffer) : null);
				setText(file.getName());

				int state;
				if(file.getType() == VFSFile.FILE)
					state = ExpansionToggleBorder.STATE_NONE;
				else if(entry.expanded)
					state = ExpansionToggleBorder.STATE_EXPANDED;
				else
					state = ExpansionToggleBorder.STATE_COLLAPSED;

				setBorder(new ExpansionToggleBorder(
					state,entry.level));
			}
			else
			{
				VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)table.getModel();
				String extAttr = model.getExtendedAttribute(column);

				openBuffer = false;
				setIcon(null);
				setText(file.getExtendedAttribute(extAttr));
				setBorder(new EmptyBorder(1,1,1,1));
			}
		}

		return this;
	} 

	
	public void paintComponent(Graphics g)
	{
		if(!isSelected)
		{
			Color color = file.getColor();

			setForeground(color == null
				? UIManager.getColor(""Tree.foreground"")
				: color);
		}

		super.paintComponent(g);

		if(openBuffer)
		{
			Font font = getFont();

			FontMetrics fm = getFontMetrics(font);
			int x, y;
			if(getIcon() == null)
			{
				x = 0;
				y = fm.getAscent() + 2;
			}
			else
			{
				x = getIcon().getIconWidth() + getIconTextGap();
				y = Math.max(fm.getAscent() + 2,16);
			}

			Insets border = getBorder().getBorderInsets(this);
			x += border.left;

			g.setColor(getForeground());
			g.drawLine(x,y,x + fm.stringWidth(getText()),y);
		}
	} 

	
	
	public static Icon getIconForFile(VFSFile file,
		boolean expanded)
	{
		return getIconForFile(file,expanded,
			jEdit._getBuffer(file.getSymlinkPath()) != null);
	} 

	
	public static Icon getIconForFile(VFSFile file,
		boolean expanded, boolean openBuffer)
	{
		if (defaultIcons)
			return file.getDefaultIcon(expanded, openBuffer);
		return file.getIcon(expanded, openBuffer);
	} 

	
	Font plainFont;
	Font boldFont;
	boolean showIcons;
	private static boolean defaultIcons = true;

	
	void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		defaultIcons = jEdit.getBooleanProperty(""vfs.browser.useDefaultIcons"");
	} 

	
	int getEntryWidth(VFSDirectoryEntryTableModel.Entry entry,
		Font font, FontRenderContext fontRenderContext)
	{
		String name = entry.dirEntry.getName();
		int width = (int)font.getStringBounds(name,fontRenderContext)
			.getWidth();
		width += ExpansionToggleBorder.ICON_WIDTH
			+ entry.level * ExpansionToggleBorder.LEVEL_WIDTH
			+ 3;
		if(showIcons)
		{
			width += fileIcon.getIconWidth();
			width += getIconTextGap();
		}
		return width;
	} 

	

	
	private boolean openBuffer;
	private boolean isSelected;
	private VFSFile file;
	

	
	static class ExpansionToggleBorder implements Border
	{
		static final Icon COLLAPSE_ICON;
		static final Icon EXPAND_ICON;
		static final int ICON_WIDTH;

		static final int LEVEL_WIDTH = 10;

		static final int STATE_NONE = 0;
		static final int STATE_COLLAPSED = 1;
		static final int STATE_EXPANDED = 2;

		
		ExpansionToggleBorder(int state, int level)
		{
			this.state = state;
			this.level = level;
		} 

		
		public void paintBorder(Component c, Graphics g,
			int x, int y, int width, int height)
		{
			
			switch(state)
			{
			case STATE_COLLAPSED:
				EXPAND_ICON.paintIcon(c,g,
					x + level * LEVEL_WIDTH + 2,
					y + (height - EXPAND_ICON.getIconHeight()) / 2);
				break;
			case STATE_EXPANDED:
				COLLAPSE_ICON.paintIcon(c,g,
					x + level * LEVEL_WIDTH + 2,
					y + (height - COLLAPSE_ICON.getIconHeight()) / 2);
				break;
			}
		} 

		
		public Insets getBorderInsets(Component c)
		{
			return new Insets(1,level * LEVEL_WIDTH
				+ ICON_WIDTH + 4,1,1);
		} 

		
		public boolean isBorderOpaque()
		{
			return false;
		} 

		
		public static boolean isExpansionToggle(int level, int x)
		{
			return (x >= level * LEVEL_WIDTH)
				&& (x <= level * LEVEL_WIDTH + ICON_WIDTH);
		} 

		
		private int state;
		private int level;

		static
		{
			COLLAPSE_ICON = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.collapse.icon""));
			EXPAND_ICON = GUIUtilities.loadIcon(jEdit.getProperty(""vfs.browser.expand.icon""));
			ICON_WIDTH = Math.max(COLLAPSE_ICON.getIconWidth(), EXPAND_ICON.getIconWidth());
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ExternalNameSpace,15,2,0,7,40,49,0,7,11,0.285714286,195,1.0,0,0.845238095,0.224242424,1,10,11.93333333,3,1.0,0,"package org.gjt.sp.jedit.bsh;

import java.util.*;



public class ExternalNameSpace extends NameSpace
{
	private Map externalMap;

    public ExternalNameSpace() 
	{
		this( null, ""External Map Namespace"", null );
	}

	
    public ExternalNameSpace( NameSpace parent, String name, Map externalMap ) 
	{
		super( parent, name );

		if ( externalMap == null )
			externalMap = new HashMap();
			
		this.externalMap = externalMap;

	}

	
	public Map getMap() { return externalMap; }

	
	public void setMap( Map map ) 
	{ 
		
		
		this.externalMap = null; 
		clear();
		this.externalMap = map ; 
	}

	
    void setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		super.setVariable( name, value, strictJava, recurse );
		putExternalMap( name, value );
	}

	
	public void unsetVariable( String name )
	{
		super.unsetVariable( name );
		externalMap.remove( name );
	}

	
	public String [] getVariableNames() 
	{
		
		Set nameSet = new HashSet();
		String [] nsNames = super.getVariableNames();
		nameSet.addAll( Arrays.asList( nsNames ) );
		nameSet.addAll( externalMap.keySet() );
		return (String [])nameSet.toArray( new String[0] );
	}

	
	
    protected Variable getVariableImpl( String name, boolean recurse ) 
		throws UtilEvalError
	{
		
		Object value = externalMap.get( name );

		Variable var;
		if ( value == null ) 
		{
			
			
			
			super.unsetVariable( name ); 

			
			var = super.getVariableImpl( name, recurse );
		} else
		{
			
			
			Variable localVar = super.getVariableImpl( name, false );

			
			
			
			if ( localVar == null ) 
				var = new Variable( name, (Class)null, value, (Modifiers)null );
			else
				var = localVar;
		}

		return var;
    }
	
	
	
	public Variable [] getDeclaredVariables() 
	{
		return super.getDeclaredVariables();
	}

    
    public void	setTypedVariable(
		String	name, Class type, Object value,	Modifiers modifiers )
		throws UtilEvalError 
	{
		super.setTypedVariable( name, type, value, modifiers );
		putExternalMap( name, value );
    }

	
    public void	setMethod( String name, BshMethod method )
		throws UtilEvalError
	{
		super.setMethod( name, method );
    }

	
    public BshMethod getMethod( 
		String name, Class [] sig, boolean declaredOnly ) 
		throws UtilEvalError
	{
		return super.getMethod( name, sig, declaredOnly );
    }


	
	protected void getAllNamesAux( Vector vec ) 
	{
		super.getAllNamesAux( vec );
	}

	
	public void clear() 
	{
		super.clear();
		externalMap.clear();
	}

	
	protected void putExternalMap( String name, Object value ) 
	{
		if ( value instanceof Variable )
			try {
				value = unwrapVariable( (Variable)value );
			} catch ( UtilEvalError ute ) {
				
				
				
				throw new InterpreterError(""unexpected UtilEvalError"");
			}

		if ( value instanceof Primitive )
			value = Primitive.unwrap( (Primitive)value );

		externalMap.put( name, value );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.CallStack,13,1,0,57,28,0,56,2,13,0.0,161,1.0,0,0.0,0.487179487,0,0,11.30769231,2,1.0769,0,"

package org.gjt.sp.jedit.bsh;

import java.util.Vector;


public class CallStack 
{
	private Vector<NameSpace> stack = new Vector<NameSpace>(2);

	public CallStack() { }

	public CallStack( NameSpace namespace ) { 
		push( namespace );
	}

	public void clear() {
		stack.removeAllElements();
	}

	public void push( NameSpace ns ) {
		stack.insertElementAt( ns, 0 );
	}

	public NameSpace top() {
		return get(0);
	}

	
	public NameSpace get(int depth) {
		if ( depth >= depth() )
			return NameSpace.JAVACODE;
		else
			return (NameSpace)(stack.elementAt(depth));
	}
	
	
	public void set(int depth, NameSpace ns) {
		stack.setElementAt(ns, depth );
	}

	public NameSpace pop() {
		if ( depth() < 1 )
			throw new InterpreterError(""pop on empty CallStack"");
		NameSpace top = top();
		stack.removeElementAt(0);
		return top;
	}

	
	public NameSpace swap( NameSpace newTop ) {
		NameSpace oldTop = (NameSpace)(stack.elementAt(0));
		stack.setElementAt( newTop, 0 );
		return oldTop;
	}

	public int depth() {
		return stack.size();
	}

	public NameSpace [] toArray() {
		NameSpace [] nsa = new NameSpace [ depth() ];
		stack.copyInto( nsa );
		return nsa;
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(""CallStack:\n"");
		NameSpace [] nsa = toArray();
		for(int i=0; i<nsa.length; i++)
			sb.append(""\t""+nsa[i]+""\n"");

		return sb.toString();
	}

	
	@SuppressWarnings(""unchecked"")
	public CallStack copy() {
		CallStack cs = new CallStack();
		cs.stack = (Vector<NameSpace>) stack.clone();
		return cs;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.syntax.KeywordMap,12,1,0,7,28,16,5,2,10,0.545454545,259,1.0,1,0.0,0.270833333,0,0,20.25,5,1.8333,0,"
package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;
import java.util.List;
import java.util.ArrayList;


public class KeywordMap
{
	
	
	public KeywordMap(boolean ignoreCase)
	{
		this(ignoreCase, 52);
		this.ignoreCase = ignoreCase;
		noWordSep = new StringBuilder();
	} 

	
	
	public KeywordMap(boolean ignoreCase, int mapLength)
	{
		this.mapLength = mapLength;
		this.ignoreCase = ignoreCase;
		map = new Keyword[mapLength];
	} 

	
	
	public byte lookup(Segment text, int offset, int length)
	{
		if(length == 0)
			return Token.NULL;
		Keyword k = map[getSegmentMapKey(text, offset, length)];
		while(k != null)
		{
			if(length != k.keyword.length)
			{
				k = k.next;
				continue;
			}
			if(SyntaxUtilities.regionMatches(ignoreCase,text,offset,
				k.keyword))
				return k.id;
			k = k.next;
		}
		return Token.NULL;
	} 

	
	
	public void add(String keyword, byte id)
	{
		add(keyword.toCharArray(),id);
	} 

	
	
	public void add(char[] keyword, byte id)
	{
		int key = getStringMapKey(keyword);

		
		
loop:		for(int i = 0; i < keyword.length; i++)
		{
			char ch = keyword[i];
			if(!Character.isLetterOrDigit(ch))
			{
				for(int j = 0; j < noWordSep.length(); j++)
				{
					if(noWordSep.charAt(j) == ch)
						continue loop;
				}

				noWordSep.append(ch);
			}
		}

		map[key] = new Keyword(keyword,id,map[key]);
	} 

	
	
	public String getNonAlphaNumericChars()
	{
		return noWordSep.toString();
	} 

	
	
	public String[] getKeywords()
	{
		List<String> vector = new ArrayList<String>(100);
		for(int i = 0; i < map.length; i++)
		{
			Keyword keyword = map[i];
			while(keyword != null)
			{
				vector.add(new String(keyword.keyword));
				keyword = keyword.next;
			}
		}
		String[] retVal = new String[vector.size()];
		vector.toArray(retVal);
		return retVal;
	} 

	
	
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	
	public void setIgnoreCase(boolean ignoreCase)
	{
		this.ignoreCase = ignoreCase;
	} 

	
	
	public void add(KeywordMap map)
	{
		for(int i = 0; i < map.map.length; i++)
		{
			Keyword k = map.map[i];
			while(k != null)
			{
				add(k.keyword,k.id);
				k = k.next;
			}
		}
	} 

	

	
	private int mapLength;
	private Keyword[] map;
	private boolean ignoreCase;
	private StringBuilder noWordSep;
	

	
	private int getStringMapKey(char[] s)
	{
		return (Character.toUpperCase(s[0]) +
				Character.toUpperCase(s[s.length-1]))
				% mapLength;
	} 

	
	protected int getSegmentMapKey(Segment s, int off, int len)
	{
		return (Character.toUpperCase(s.array[off]) +
				Character.toUpperCase(s.array[off + len - 1]))
				% mapLength;
	} 

	

	
	private static class Keyword
	{
		Keyword(char[] keyword, byte id, Keyword next)
		{
			this.keyword = keyword;
			this.id = id;
			this.next = next;
		}

		public char[] keyword;
		public byte id;
		public Keyword next;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DefaultInputHandler,8,3,0,9,29,10,2,8,8,2.0,216,0.0,0,0.875,0.25,3,12,26.0,23,3.625,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.InputEvent;
import java.awt.Toolkit;
import java.util.Hashtable;
import org.gjt.sp.jedit.*;



public class DefaultInputHandler extends InputHandler
{
	
	
	public DefaultInputHandler(View view, Hashtable bindings)
	{
		super(view);

		if(bindings == null)
			throw new NullPointerException();
		this.bindings = this.currentBindings = bindings;
	} 

	
	
	public DefaultInputHandler(View view)
	{
		this(view,new Hashtable());
	} 

	
	
	public DefaultInputHandler(View view, DefaultInputHandler copy)
	{
		this(view,copy.bindings);
	} 

	
	
	@Override
	public boolean isPrefixActive()
	{
		return bindings != currentBindings
			|| super.isPrefixActive();
	} 

	
	@Override
	public void setCurrentBindings(Hashtable bindings)
	{
		view.getStatus().setMessage((String)bindings.get(PREFIX_STR));
		currentBindings = bindings;
	} 

	
	
	public boolean handleKey(KeyEventTranslator.Key keyStroke,boolean dryRun)
	{
		char input = '\0';
		if(keyStroke.modifiers == null
			|| keyStroke.modifiers.equals(""S""))
		{
			switch(keyStroke.key)
			{
			case '\n':
			case '\t':
				input = (char)keyStroke.key;
				break;
			default:
				input = keyStroke.input;
				break;
			}
		}

		if(readNextChar != null)
		{
			if(input != '\0')
			{
				if (!dryRun)
				{
					setCurrentBindings(bindings);
					invokeReadNextChar(input);
					repeatCount = 1;
				}
				return true;
			}
			else
			{
				if (!dryRun) 
				{
					readNextChar = null;
					view.getStatus().setMessage(null);
				}
			}
		}

		Object o = currentBindings.get(keyStroke);
		if(o == null)
		{
			if (!dryRun) 
			{
				
				
				
				
				if(currentBindings != bindings)
				{
					Toolkit.getDefaultToolkit().beep();
					
					
					repeatCount = 1;
					setCurrentBindings(bindings);
				}
				else if(input != '\0') 
				{
					if (!keyStroke.isFromGlobalContext()) 
					{ 
						userInput(input);
					}
				} 
				else
				{
					
					
					if(KeyEventWorkaround.isNumericKeypad(keyStroke.key))
						KeyEventWorkaround.numericKeypadKey();
				}
				sendShortcutPrefixOff();
			}
		}
		else if(o instanceof Hashtable)
		{
			if (!dryRun) 
			{
				setCurrentBindings((Hashtable)o);
				ShortcutPrefixActiveEvent.firePrefixStateChange(currentBindings, true);
				shortcutOn = true;
			}
			return true;
		}
		else if(o instanceof String)
		{
			if (!dryRun) 
			{
				setCurrentBindings(bindings);
				sendShortcutPrefixOff();
				invokeAction((String)o);
			}
			return true;
		}
		else if(o instanceof EditAction)
		{
			if (!dryRun)
			{
				setCurrentBindings(bindings);
				sendShortcutPrefixOff();
				invokeAction((EditAction)o);
			}
			return true;
		}
		if (!dryRun)
		{
			sendShortcutPrefixOff();
		}
		return false;
	} 
	
	
	
	public static char getSymbolicModifierName(int mod)
	{
		return KeyEventTranslator.getSymbolicModifierName(mod);
	} 

	
	
	public static String getModifierString(InputEvent evt)
	{
		return KeyEventTranslator.getModifierString(evt);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHPackageDeclaration,18,2,0,9,38,153,1,8,18,2.0,96,0.0,0,0.5,0.268518519,1,5,4.333333333,1,0.9444,0,"


package org.gjt.sp.jedit.bsh;

public class BSHPackageDeclaration extends SimpleNode 
{

  public BSHPackageDeclaration(int id) {
    super(id);
  }

	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		BSHAmbiguousName name = (BSHAmbiguousName)jjtGetChild(0);
		NameSpace namespace = callstack.top();
		namespace.setPackage( name.text );
		
		namespace.importPackage( name.text );
		return Primitive.VOID;
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.PropertyManager,16,1,0,1,33,4,1,0,2,0.516666667,258,1.0,0,0.0,0.375,0,0,14.875,5,1.5,0,"

package org.gjt.sp.jedit;

import java.io.*;
import java.util.*;

class PropertyManager
{
	
	Properties getProperties()
	{
		Properties total = new Properties();
		total.putAll(system);
		for (Properties plugin : plugins)
			total.putAll(plugin);
		total.putAll(site);
		total.putAll(user);
		return total;
	} 

	
	void loadSystemProps(InputStream in)
		throws IOException
	{
		loadProps(system,in);
	} 

	
	void loadSiteProps(InputStream in)
		throws IOException
	{
		loadProps(site,in);
	} 

	
	void loadUserProps(InputStream in)
		throws IOException
	{
		loadProps(user,in);
	} 

	
	void saveUserProps(OutputStream out)
		throws IOException
	{
		user.store(out,""jEdit properties"");
	} 

	
	Properties loadPluginProps(InputStream in)
		throws IOException
	{
		Properties plugin = new Properties();
		loadProps(plugin,in);
		plugins.add(plugin);
		return plugin;
	} 

	
	void addPluginProps(Properties props)
	{
		plugins.add(props);
	} 

	
	void removePluginProps(Properties props)
	{
		plugins.remove(props);
	} 

	
	String getProperty(String name)
	{
		String value = user.getProperty(name);
		if(value != null)
			return value;
		else
			return getDefaultProperty(name);
	} 

	
	void setProperty(String name, String value)
	{
		String prop = getDefaultProperty(name);

		
		if(value == null)
		{
			if(prop == null || prop.length() == 0)
				user.remove(name);
			else
				user.setProperty(name,"""");
		}
		else
		{
			if(value.equals(prop))
				user.remove(name);
			else
				user.setProperty(name,value);
		}
	} 

	
	public void setTemporaryProperty(String name, String value)
	{
		user.remove(name);
		system.setProperty(name,value);
	} 

	
	void unsetProperty(String name)
	{
		if(getDefaultProperty(name) != null)
			user.setProperty(name,"""");
		else
			user.remove(name);
	} 

	
	public void resetProperty(String name)
	{
		user.remove(name);
	} 

	
	private Properties system = new Properties();
	private List<Properties> plugins = new LinkedList<Properties>();
	private Properties site = new Properties();
	private Properties user = new Properties();

	
	private String getDefaultProperty(String name)
	{
		String value = site.getProperty(name);
		if(value != null)
			return value;

		for (Properties plugin : plugins)
		{
			value = plugin.getProperty(name);
			if (value != null)
				return value;
		}

		return system.getProperty(name);
	} 

	
	private static void loadProps(Properties into, InputStream in)
		throws IOException
	{
		try
		{
			into.load(in);
		}
		finally
		{
			in.close();
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.VariableGridLayout,19,1,0,5,48,151,3,2,16,0.604166667,1417,0.875,0,0.0,0.231578947,0,0,72.73684211,33,4.3684,0,"

package org.gjt.sp.jedit.gui;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager2;

import java.util.Arrays;


public class VariableGridLayout implements LayoutManager2, java.io.Serializable
{
	public static final int FIXED_NUM_ROWS = 1;
	public static final int FIXED_NUM_COLUMNS = 2;

	private static enum LayoutSize { MINIMUM, MAXIMUM, PREFERRED }

	
	public VariableGridLayout(int mode, int size, int hgap, int vgap, boolean takeSizesIntoAccount, Insets distanceToBorders)
	{
		if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS)
		{
			throw new IllegalArgumentException(""illegal mode; value is "" + mode);
		}
		if (size <= 0)
		{
			throw new IllegalArgumentException(""size cannot be zero or less; value is "" + size);
		}
		if (hgap < 0)
		{
			throw new IllegalArgumentException(""hgap cannot be negative; value is "" + hgap);
		}
		if (vgap < 0)
		{
			throw new IllegalArgumentException(""vgap cannot be negative; value is "" + vgap);
		}
		this.mode = mode;
		this.size = size;
		this.hgap = hgap;
		this.vgap = vgap;
		this.takeSizesIntoAccount = takeSizesIntoAccount;
		this.distanceToBorders = (Insets)distanceToBorders.clone();
	}

	
	public VariableGridLayout(int mode, int size, int hgap, int vgap, boolean takeSizesIntoAccount)
	{
		this(mode, size, hgap, vgap, takeSizesIntoAccount, new Insets(0,0,0,0));
	}

	
	public VariableGridLayout(int mode, int size, int hgap, int vgap)
	{
		this(mode, size, hgap, vgap, false, new Insets(0,0,0,0));
	}

	
	public VariableGridLayout(int mode, int size)
	{
		this(mode, size, 0, 0, false, new Insets(0,0,0,0));
	}

	
	public VariableGridLayout()
	{
		this(FIXED_NUM_ROWS, 1, 0, 0, false, new Insets(0,0,0,0));
	}

	
	public void addLayoutComponent(String name, Component component)
	{
	}

	
	public void addLayoutComponent(Component component, Object constraints)
	{
	}

	
	public void removeLayoutComponent(Component component)
	{
	}

	
	public float getLayoutAlignmentX(Container container)
	{
		return 0.5f;
	}

	
	public float getLayoutAlignmentY(Container container)
	{
		return 0.5f;
	}

	public Dimension preferredLayoutSize(Container parent)
	{
		return getLayoutSize(parent,LayoutSize.PREFERRED);
	}

	public Dimension minimumLayoutSize(Container parent)
	{
		return getLayoutSize(parent,LayoutSize.MINIMUM);
	}

	public Dimension maximumLayoutSize(Container parent)
	{
		return getLayoutSize(parent,LayoutSize.MAXIMUM);
	}

	public void layoutContainer(Container parent)
	{
		synchronized (parent.getTreeLock())
		{
			update(parent);

			int ncomponents = parent.getComponentCount();

			if (ncomponents == 0)
			{
				return;
			}

			
			int total_height = 0;
			Arrays.fill(row_heights,0);
			Arrays.fill(col_widths,0);
			if (takeSizesIntoAccount)
			{
				Arrays.fill(minimum_row_heights,0);
				Arrays.fill(minimum_col_widths,0);
				Arrays.fill(maximum_row_heights,Integer.MAX_VALUE);
				Arrays.fill(maximum_col_widths,Integer.MAX_VALUE);
			}
			for (int r = 0, i = 0; r < nrows; r++)
			{
				for (int c = 0; c < ncols; c++, i++)
				{
					if (i < ncomponents)
					{
						Component comp = parent.getComponent(i);
						Dimension d = comp.getPreferredSize();
						row_heights[r] = Math.max(row_heights[r], d.height);
						col_widths[c] = Math.max(col_widths[c], d.width);
						if (takeSizesIntoAccount)
						{
							d = comp.getMinimumSize();
							minimum_row_heights[r] = Math.max(minimum_row_heights[r], d.height);
							minimum_col_widths[c] = Math.max(minimum_col_widths[c], d.width);
							d = comp.getMaximumSize();
							maximum_row_heights[r] = Math.min(maximum_row_heights[r], d.height);
							maximum_col_widths[c] = Math.min(maximum_col_widths[c], d.width);
						}
					}
					else
					{
						break;
					}
				}
				if (takeSizesIntoAccount)
				{
					
					
					
					if (minimum_row_heights[r] >= maximum_row_heights[r])
					{
						maximum_row_heights[r] = minimum_row_heights[r];
						row_heights[r] = minimum_row_heights[r];
					}
					else if (row_heights[r] < minimum_row_heights[r])
					{
						row_heights[r] = minimum_row_heights[r];
					}
					else if (row_heights[r] > maximum_row_heights[r])
					{
						row_heights[r] = maximum_row_heights[r];
					}
				}
				total_height += row_heights[r];
			}

			int total_width = 0;
			for (int c = 0; c < ncols; c++)
			{
				if (takeSizesIntoAccount)
				{
					
					
					
					if (minimum_col_widths[c] >= maximum_col_widths[c])
					{
						maximum_col_widths[c] = minimum_col_widths[c];
						col_widths[c] = minimum_col_widths[c];
					}
					else if (col_widths[c] < minimum_col_widths[c])
					{
						col_widths[c] = minimum_col_widths[c];
					}
					else if (col_widths[c] > maximum_col_widths[c])
					{
						col_widths[c] = maximum_col_widths[c];
					}
				}
				total_width += col_widths[c];
			}

			
			Dimension parent_size = parent.getSize();
			Insets insets = parent.getInsets();
			int free_height = parent_size.height
					  - insets.top - insets.bottom
					  - (nrows - 1) * vgap
					  - distanceToBorders.top - distanceToBorders.bottom;
			int free_width = parent_size.width
					 - insets.left - insets.right
					 - (ncols - 1) * hgap
					 - distanceToBorders.left - distanceToBorders.right;

			redistributeSpace(total_height,free_height,
					  takeSizesIntoAccount,
					  nrows,row_heights,
					  minimum_row_heights,
					  maximum_row_heights);

			redistributeSpace(total_width,free_width,
					  takeSizesIntoAccount,
					  ncols,col_widths,
					  minimum_col_widths,
					  maximum_col_widths);

			
			for (int r = 0, y = insets.top + distanceToBorders.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++)
			{
				for (int c = 0, x = insets.left + distanceToBorders.left; c < ncols; x += col_widths[c] + hgap, c++, i++)
				{
					if (i < ncomponents)
					{
						Component comp = parent.getComponent(i);
						Dimension d = comp.getMaximumSize();
						int width = col_widths[c];
						int height = row_heights[r];
						int xCorrection = 0;
						int yCorrection = 0;
						if (width > d.width)
						{
							xCorrection = (int)((width - d.width) * comp.getAlignmentX());
							width = d.width;
						}
						if (height > d.height)
						{
							yCorrection = (int)((height-d.height) * comp.getAlignmentY());
							height = d.height;
						}
						
						comp.setBounds(x + xCorrection, y + yCorrection, width, height);
					}
				}
			}
		} 
	}

	public void invalidateLayout(Container container)
	{
	}

	
	public String toString()
	{
		return getClass().getName() + ""[mode=""
			+ ((FIXED_NUM_ROWS == mode) ? ""FIXED_NUM_ROWS""
			   : ((FIXED_NUM_COLUMNS == mode) ? ""FIXED_NUM_COLUMNS""
			      : ""UNKNOWN("" + mode + "")"")) + "",size="" + size
			+ "",hgap="" + hgap + "",vgap="" + vgap
			+ "",takeSizesIntoAccount="" + takeSizesIntoAccount
			+ "",distanceToBorders="" + distanceToBorders + ""]"";
	}

	
	private Dimension getLayoutSize(Container parent, LayoutSize which)
	{
		synchronized (parent.getTreeLock())
		{
			update(parent);

			int ncomponents = parent.getComponentCount();
			long h = 0;
			long w = 0;

			for (int r = 0, i = 0; r < nrows; r++)
			{
				int row_height = 0;
				for (int c = 0; c < ncols; c++, i++)
				{
					if (i < ncomponents)
					{
						switch (which)
						{
							case MINIMUM:
								row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);
								break;
							
							case MAXIMUM:
								row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);
								break;
							
							case PREFERRED:
								row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);
								break;
							
							default:
								throw new InternalError(""Missing case branch for LayoutSize: "" + which);
						}
					}
				}
				h += row_height;
			}

			for (int c = 0; c < ncols; c++)
			{
				int col_width = 0;
				for (int r = 0; r < nrows; r++)
				{
					int i = r * ncols + c;
					if (i < ncomponents)
					{
						switch (which)
						{
							case MINIMUM:
								col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);
								break;
							
							case MAXIMUM:
								col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);
								break;
							
							case PREFERRED:
								col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);
								break;
							
							default:
								throw new InternalError(""Missing case branch for LayoutSize: "" + which);
						}
					}
				}
				w += col_width;
			}

			Insets insets = parent.getInsets();
			w += insets.left + insets.right + ((ncols - 1) * hgap) + distanceToBorders.left + distanceToBorders.right;
			h += insets.top + insets.bottom + ((nrows - 1) * vgap) + distanceToBorders.top + distanceToBorders.bottom;
			if (w > Integer.MAX_VALUE)
			{
				w = Integer.MAX_VALUE;
			}
			if (h > Integer.MAX_VALUE)
			{
				h = Integer.MAX_VALUE;
			}
			return new Dimension((int)w,(int)h);
		}
	}

	private void update(Container container)
	{
		int ncomponents = container.getComponentCount();
		int old_nrows = nrows;
		int old_ncols = ncols;
		if (this.mode == FIXED_NUM_ROWS)
		{
			nrows = this.size;
			ncols = (ncomponents + nrows - 1) / nrows;
		}
		else
		{
			ncols = this.size;
			nrows = (ncomponents + ncols - 1) / ncols;
		}
		if (old_nrows != nrows)
		{
			row_heights = new int[nrows];
			if (takeSizesIntoAccount)
			{
				minimum_row_heights = new int[nrows];
				maximum_row_heights = new int[nrows];
			}
		}
		if (old_ncols != ncols)
		{
			col_widths = new int[ncols];
			if (takeSizesIntoAccount)
			{
				minimum_col_widths = new int[ncols];
				maximum_col_widths = new int[ncols];
			}
		}
	}

	private void redistributeSpace(int total_size, int free_size, boolean takeSizesIntoAccount,
				       int nelements, int[] element_sizes,
				       int[] minimum_element_sizes, int[] maximum_element_sizes)
	{
		if (total_size != free_size)
		{
			if (takeSizesIntoAccount)
			{
				boolean grow = total_size < free_size;
				
				free_size = (free_size - total_size) * (grow ? 1 : -1);
				while (free_size != 0)
				{
					
					
					int modifyableAmount = 0;
					int modifySize = 0;
					for (int i = 0 ; i < nelements ; i++)
					{
						if ((grow && (element_sizes[i] < maximum_element_sizes[i])) ||
						    (!grow && (element_sizes[i] > minimum_element_sizes[i])))
						{
							modifyableAmount++;
							modifySize += element_sizes[i];
						}
					}
					boolean checkBounds = true;
					
					if (0 == modifyableAmount)
					{
						for (int i = 0 ; i < nelements ; i++)
						{
							modifySize += element_sizes[i];
						}
						checkBounds = false;
						modifyableAmount = nelements;
					}
					
					if (modifySize == 0)
					{
						break;
					}
					
					if (free_size < modifyableAmount)
					{
						for (int i = 0 ; i < nelements ; i++)
						{
							if ((free_size != 0) &&
							    (!checkBounds ||
							     (checkBounds &&
							      (grow && (element_sizes[i] < maximum_element_sizes[i])) ||
							      (!grow && (element_sizes[i] > minimum_element_sizes[i])))))
							{
								element_sizes[i] += (grow ? 1 : -1);
								if (0 > element_sizes[i])
								{
									element_sizes[i] = 0;
								}
								free_size--;
							}
						}
					}
					else
					{
						int modifySizeAddition = 0;
						for (int i = 0 ; i < nelements ; i++)
						{
							int modifyableSize = (checkBounds ? (grow ? maximum_element_sizes[i] - element_sizes[i] : element_sizes[i] - minimum_element_sizes[i]) : Integer.MAX_VALUE - element_sizes[i]);
							int elementModifySize = (int)((double)free_size / (double)modifySize * (double)element_sizes[i]);
							if (elementModifySize <= modifyableSize)
							{
								element_sizes[i] += (grow ? elementModifySize : -elementModifySize);
								modifySizeAddition += (grow ? elementModifySize : -elementModifySize);
								free_size -= elementModifySize;
							}
							else
							{
								element_sizes[i] += (grow ? modifyableSize : -modifyableSize);
								modifySizeAddition += (grow ? modifyableSize : -modifyableSize);
								free_size -= modifyableSize;
							}
							if (0 > element_sizes[i])
							{
								element_sizes[i] = 0;
							}
						}
						modifySize += modifySizeAddition;
					}
				}
			}
			else
			{
				double d = (double)free_size / (double)total_size;
				for (int i = 0; i < nelements; i++)
				{
					element_sizes[i] = (int)(element_sizes[i] * d);
				}
			}
		}
	}

	private int mode;
	private int size;
	private int hgap;
	private int vgap;
	private boolean takeSizesIntoAccount;
	private Insets distanceToBorders;
	private transient int nrows = -1;
	private transient int ncols = -1;
	private transient int[] minimum_row_heights = null;
	private transient int[] minimum_col_widths = null;
	private transient int[] row_heights = null;
	private transient int[] col_widths = null;
	private transient int[] maximum_row_heights = null;
	private transient int[] maximum_col_widths = null;
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.BufferSetWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,0,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.*;
import javax.swing.JComponent;
import javax.swing.JLabel;

import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.msg.EditPaneUpdate;
import org.gjt.sp.jedit.bufferset.BufferSet;



public class BufferSetWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view)
	{
		Widget bufferSetWidget = new BufferSetWidget(view);
		return bufferSetWidget;
	} 

	
	private static class BufferSetWidget implements Widget, EBComponent
	{
		private final JLabel bufferSetLabel;
		private final View view;
		private BufferSet.Scope currentScope;

		BufferSetWidget(final View view)
		{
			bufferSetLabel = new ToolTipLabel()
			{
				@Override
				public void addNotify()
				{
					super.addNotify();
					EditBus.addToBus(BufferSetWidget.this);
				}

				@Override
				public void removeNotify()
				{
					super.removeNotify();
					EditBus.removeFromBus(BufferSetWidget.this);
				}
			};
			this.view = view;
			update();
			bufferSetLabel.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent evt)
				{
					if (evt.getClickCount() == 2)
					{
						EditPane editPane = view.getEditPane();
						BufferSet.Scope scope = editPane.getBufferSetScope();
						switch (scope)
						{
							case global:
								scope = BufferSet.Scope.view;
								break;
							case view:
								scope = BufferSet.Scope.editpane;
								break;
							case editpane:
								scope = BufferSet.Scope.global;
								break;
						}
						editPane.setBufferSetScope(scope);
					}
				}
			});
		}

		
		public JComponent getComponent()
		{
			return bufferSetLabel;
		} 

		
		public void update()
		{
			BufferSet.Scope scope = view.getEditPane().getBufferSetScope();
			if (currentScope == null || !currentScope.equals(scope))
			{
				bufferSetLabel.setText(scope.toString().substring(0,1).toUpperCase());
				bufferSetLabel.setToolTipText(jEdit.getProperty(""view.status.bufferset-tooltip"", new Object[] {scope}));
				currentScope = scope;
			}
		} 

		
		public void propertiesChanged()
		{
			
			Font font = new JLabel().getFont();
			
			FontMetrics fm = bufferSetLabel.getFontMetrics(font);
			Dimension dim = new Dimension(Math.max(fm.charWidth('E'),Math.max(fm.charWidth('V'),
								fm.charWidth('G'))),
								fm.getHeight());
			bufferSetLabel.setPreferredSize(dim);
			bufferSetLabel.setMaximumSize(dim);
		} 

		
		public void handleMessage(EBMessage message)
		{
			if (message instanceof ViewUpdate)
			{
				ViewUpdate viewUpdate = (ViewUpdate) message;
				if (viewUpdate.getWhat() == ViewUpdate.EDIT_PANE_CHANGED)
				{
					update();
				}
			}
			else if (message instanceof EditPaneUpdate)
			{
				EditPaneUpdate editPaneUpdate = (EditPaneUpdate) message;
				if (editPaneUpdate.getEditPane() == view.getEditPane() &&
					editPaneUpdate.getWhat() == EditPaneUpdate.BUFFERSET_CHANGED)
				{
					update();
				}
			}
		} 

	} 

}"
jEdit,4.3,org.gjt.sp.jedit.menu.EnhancedMenuItem,5,6,0,8,35,0,5,5,3,0.65,183,0.4,0,0.996240602,0.35,2,11,34.6,4,1.4,0,"

package org.gjt.sp.jedit.menu;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.StatusBar;



public class EnhancedMenuItem extends JMenuItem
{
	
	
	public EnhancedMenuItem(String label, String action, ActionContext context)
	{
		this.action = action;
		this.shortcut = GUIUtilities.getShortcutLabel(action);
		if(OperatingSystem.hasScreenMenuBar() && shortcut != null)
		{
			setText(label + "" ("" + shortcut + "")"");
			shortcut = null;
		}
		else
			setText(label);

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(context,action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);
	} 

	
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();

		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} 

	
	public void paint(Graphics g)
	{
		super.paint(g);

		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 
				(OperatingSystem.isMacOSLF() ? 0 : 1))
				);
		}
	} 

	
	static Font acceleratorFont;
	static Color acceleratorForeground;
	static Color acceleratorSelectionForeground;
	

	

	
	private String shortcut;
	private String action;
	

	
	static
	{
		String shortcutFont;
		if (OperatingSystem.isMacOSLF())
		{
			shortcutFont = ""Lucida Grande"";
		}
		else
		{
			shortcutFont = ""Monospaced"";
		}
		
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		if(acceleratorFont == null)
		{
			acceleratorFont = new Font(shortcutFont,Font.PLAIN,12);
		}
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		if(acceleratorForeground == null)
		{
			acceleratorForeground = Color.black;
		}

		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
		if(acceleratorSelectionForeground == null)
		{
			acceleratorSelectionForeground = Color.black;
		}
	} 

	

	
	class MouseHandler extends MouseAdapter
	{
		boolean msgSet = false;
		private String msg;

		public void mouseReleased(MouseEvent evt)
		{
			cleanupStatusBar(evt);
		}

		public void mouseEntered(MouseEvent evt)
		{
			msg = jEdit.getProperty(action + "".mouse-over"");
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
				msgSet = true;
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			cleanupStatusBar(evt);
		}

		private void cleanupStatusBar(MouseEvent evt)
		{
			if(msgSet)
			{
				StatusBar statusBar = GUIUtilities.getView((Component) evt.getSource())
					.getStatus();
				if (msg == statusBar.getMessage())
				{
					statusBar.setMessage(null);
				}
				msgSet = false;
				msg = null;
			}
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.DummyFoldHandler,2,2,0,4,3,1,3,2,2,2.0,8,0.0,0,0.888888889,0.625,0,0,3.0,1,0.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;


public class DummyFoldHandler extends FoldHandler
{
	
	public DummyFoldHandler()
	{
		super(""none"");
	}
	

	
	
	public int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg)
	{
		return 0;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.WrapWidgetFactory,2,1,0,4,4,1,0,4,2,2.0,12,0.0,0,0.0,0.75,0,0,5.0,1,0.5,1,"

package org.gjt.sp.jedit.gui.statusbar;


import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;



public class WrapWidgetFactory implements StatusWidgetFactory
{
	
	public Widget getWidget(View view) 
	{
		Widget wrap = new WrapWidget(view);
		return wrap;
	} 
	
	
	private static class WrapWidget implements Widget
	{
		private final JLabel wrap;
		private final View view;
		public WrapWidget(final View view) 
		{
			wrap = new ToolTipLabel();
			wrap.setHorizontalAlignment(SwingConstants.CENTER);
			wrap.setToolTipText(jEdit.getProperty(""view.status.wrap-tooltip""));
			this.view = view;
			wrap.addMouseListener(new MouseAdapter() 
					      {
						      @Override
						      public void mouseClicked(MouseEvent evt)
						      {
							      view.getBuffer().toggleWordWrap(view);
						      }
					      });
		}
		
		public JComponent getComponent() 
		{
			return wrap;
		}
		
		public void update() 
		{
			Buffer buffer = view.getBuffer();
			String wrap = buffer.getStringProperty(""wrap"");
			if(wrap.equals(""none""))
				this.wrap.setText(""-"");
			else if(wrap.equals(""hard""))
				this.wrap.setText(""H"");
			else if(wrap.equals(""soft""))
				this.wrap.setText(""S"");
		}
		
		public void propertiesChanged()
		{
			
			Font font = new JLabel().getFont();
			
			FontMetrics fm = wrap.getFontMetrics(font);
			Dimension dim = new Dimension(Math.max(Math.max(fm.charWidth('-'),
									fm.charWidth('H')),
					fm.charWidth('S')) + 1,
				fm.getHeight());
			wrap.setPreferredSize(dim);
			wrap.setMaximumSize(dim);
		}
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.IndentFoldHandler,4,2,0,6,12,6,4,2,3,2.0,140,0.0,0,0.727272727,0.75,0,0,34.0,6,4.0,0,"

package org.gjt.sp.jedit.buffer;

import java.util.ArrayList;
import java.util.List;

import javax.swing.text.Segment;


public class IndentFoldHandler extends FoldHandler
{
	public IndentFoldHandler()
	{
		super(""indent"");
	}

	
	
	private int getLeadingWhitespaceWidth(Segment seg, int tabSize)
	{
		int offset = seg.offset;
		int count = seg.count;
		int whitespace = 0;

		for(int i = 0; i < count; i++)
		{
			switch(seg.array[offset + i])
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				return whitespace;
			}
		}
		return (-1);
	}

	
	
	public int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg)
	{
		int tabSize = buffer.getTabSize();
		
		int prevLevel = 0;
		for (int index = lineIndex; index < buffer.getLineCount(); index++)
		{
			buffer.getLineText(index,seg);
			int whitespace = getLeadingWhitespaceWidth(seg,tabSize);
			if(whitespace >= 0)	
				return (whitespace > prevLevel) ? whitespace : prevLevel;
			if(index == 0)
				return 0;
			if(index == lineIndex)
				prevLevel = buffer.getFoldLevel(lineIndex - 1);
		}
		
		
		return prevLevel;
	} 

	
	
	public List<Integer> getPrecedingFoldLevels(JEditBuffer buffer,
		int lineIndex, Segment seg, int lineFoldLevel)
	{
		List<Integer> precedingFoldLevels = new ArrayList<Integer>();
		int tabSize = buffer.getTabSize();
		int whitespace = 0;
		int index;
		
		for (index = lineIndex - 1; index > 0; index--)
		{
			buffer.getLineText(index,seg);
			whitespace = getLeadingWhitespaceWidth(seg,tabSize);
			if (whitespace >= 0)
				break;
		}
		int max = (lineFoldLevel > whitespace) ? lineFoldLevel : whitespace;
		for (index++; index < lineIndex; index++)
			precedingFoldLevels.add(Integer.valueOf(max));
		return precedingFoldLevels;
	}
	

}
"
jEdit,4.3,org.gjt.sp.jedit.io.RegexEncodingDetector,3,1,0,2,16,1,0,2,2,0.833333333,84,0.666666667,0,0.0,0.5,0,0,26.0,1,0.6667,0,"

package org.gjt.sp.jedit.io;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.nio.CharBuffer;


public class RegexEncodingDetector implements EncodingDetector
{
	
	public static final String VALID_ENCODING_PATTERN
		= ""\\p{Alnum}[\\p{Alnum}\\-.:_]*"";

	private final Pattern pattern;
	private final String replacement;

	public RegexEncodingDetector(String pattern, String replacement)
	{
		this.pattern = Pattern.compile(pattern);
		this.replacement = replacement;
	}

	public String detectEncoding(InputStream sample) throws IOException
	{
		InputStreamReader reader = new InputStreamReader(sample);
		final int bufferSize = 1024;
		char[] buffer = new char[bufferSize];
		int readSize = reader.read(buffer, 0, bufferSize);
		if (readSize > 0)
		{
			Matcher matcher = pattern.matcher(
				CharBuffer.wrap(buffer, 0, readSize));

			
			
			
			int appendPosition = 0;

			while (matcher.find())
			{
				String extracted = extractReplacement(
					matcher, appendPosition, replacement);
				if (EncodingServer.hasEncoding(extracted))
				{
					return extracted;
				}
				appendPosition = matcher.end();
			}
		}
		return null;
	}

	
	private static String extractReplacement(
		Matcher found, int appendPosition, String replacement)
	{
		
		int found_start = found.start();
		int found_end = found.end();
		int source_length = found_end - found_start;
		int length_before_match = found_start - appendPosition;
		StringBuffer replaced = new StringBuffer(
				length_before_match + (source_length * 2));
		found.appendReplacement(replaced, replacement);
		return replaced.substring(length_before_match);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.HistoryTextField,18,6,3,26,60,69,23,6,15,0.705882353,252,1.0,1,0.982630273,0.277777778,3,7,12.83333333,15,1.9444,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.AbstractBorder;
import javax.swing.border.CompoundBorder;
import javax.swing.event.MouseInputAdapter;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;



public class HistoryTextField extends JTextField
{
	
	
	public HistoryTextField()
	{
		this(null);
	} 

	
	
	public HistoryTextField(String name)
	{
		this(name,false,true);
	} 

	
	
	public HistoryTextField(String name, boolean instantPopups)
	{
		this(name,instantPopups,true);
	} 

	
	
	public HistoryTextField(String name, boolean instantPopups,
		boolean enterAddsToHistory)
	{
		controller = new HistoryText(this,null)
		{
			public void fireActionPerformed()
			{
				HistoryTextField.this.fireActionPerformed();
			}
		};

		setModel(name);
		MouseHandler mouseHandler = new MouseHandler();
		addMouseListener(mouseHandler);
		addMouseMotionListener(mouseHandler);

		setInstantPopups(instantPopups);
		setEnterAddsToHistory(enterAddsToHistory);
	} 

	
	
	public void setInstantPopups(boolean instantPopups)
	{
		controller.setInstantPopups(instantPopups);
	} 

	
	
	public boolean getInstantPopups()
	{
		return controller.getInstantPopups();
	} 

	
	
	public void setEnterAddsToHistory(boolean enterAddsToHistory)
	{
		this.enterAddsToHistory = enterAddsToHistory;
	} 

	
	
	public boolean setEnterAddsToHistory()
	{
		return enterAddsToHistory;
	} 

	
	
	public void setSelectAllOnFocus(boolean selectAllOnFocus)
	{
		this.selectAllOnFocus = selectAllOnFocus;
	} 

	
	
	public boolean setSelectAllOnFocus()
	{
		return selectAllOnFocus;
	} 

	
	
	public HistoryModel getModel()
	{
		return controller.getModel();
	} 

	
	
	public void setModel(String name)
	{
		controller.setModel(name);

		if(name != null)
		{
			setBorder(new CompoundBorder(this.getBorder(), new HistoryBorder()));
		}
		
		repaint();
	} 

	
	
	public void addCurrentToHistory()
	{
		controller.addCurrentToHistory();
	} 

	
	
	public void setText(String text)
	{
		super.setText(text);
		controller.setIndex(-1);
	} 

	
	
	public void fireActionPerformed()
	{
		super.fireActionPerformed();
	} 

	

	
	protected void processKeyEvent(KeyEvent evt)
	{
		if(!isEnabled())
			return;

		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_ENTER:
				if(enterAddsToHistory)
					addCurrentToHistory();

				if(evt.getModifiers() == 0)
				{
					fireActionPerformed();
					evt.consume();
				}
				break;
			case KeyEvent.VK_UP:
				if(evt.isShiftDown())
					controller.doBackwardSearch();
				else
					controller.historyPrevious();
				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				if(evt.isShiftDown())
					controller.doForwardSearch();
				else if(evt.isAltDown())
				{
					controller.showPopupMenu(
						evt.isShiftDown());
				}
				else
					controller.historyNext();
				evt.consume();
				break;
			case KeyEvent.VK_TAB:
				if(evt.isControlDown())
				{
					controller.doBackwardSearch();
					evt.consume();
				}
				break;
			}
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	
	protected void processMouseEvent(MouseEvent evt)
	{
		if(!isEnabled())
			return;

		switch(evt.getID())
		{
		case MouseEvent.MOUSE_PRESSED:
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);

			if(evt.getX() >= getWidth() - insets.right
				|| GUIUtilities.isPopupTrigger(evt))
			{
				controller.showPopupMenu(evt.isShiftDown());
			}
			else
				super.processMouseEvent(evt);

			break;
		case MouseEvent.MOUSE_EXITED:
			setCursor(Cursor.getDefaultCursor());
			super.processMouseEvent(evt);
			break;
		default:
			super.processMouseEvent(evt);
			break;
		}
	} 

	

	

	
	private HistoryText controller;
	private boolean enterAddsToHistory;
	private boolean selectAllOnFocus;
	

	

	

	
	class MouseHandler extends MouseInputAdapter
	{
		boolean selectAll;

		
		public void mousePressed(MouseEvent evt)
		{
			selectAll = (!hasFocus() && selectAllOnFocus);
		} 

		
		public void mouseReleased(MouseEvent evt)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(selectAll)
						selectAll();
				}
			});
		} 

		
		public void mouseMoved(MouseEvent evt)
		{
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);

			if(evt.getX() >= getWidth() - insets.right)
				setCursor(Cursor.getDefaultCursor());
			else
				setCursor(Cursor.getPredefinedCursor(
					Cursor.TEXT_CURSOR));
		} 

		
		public void mouseDragged(MouseEvent evt)
		{
			selectAll = false;
		} 
	} 

	
	static class HistoryBorder extends AbstractBorder
	{
		static final int WIDTH = 16;

		public void paintBorder(Component c, Graphics g,
			int x, int y, int w, int h)
		{
			g.translate(x+w-WIDTH,y-1);

			
			
			
			
			
			

			
			int w2 = WIDTH/2;
			int h2 = h/2;
			g.setColor(UIManager.getColor(c.isEnabled()
				&& ((HistoryTextField)c).getModel() != null
				? ""TextField.foreground"" : ""TextField.disabledForeground""));
			g.drawLine(w2-5,h2-2,w2+4,h2-2);
			g.drawLine(w2-4,h2-1,w2+3,h2-1);
			g.drawLine(w2-3,h2  ,w2+2,h2  );
			g.drawLine(w2-2,h2+1,w2+1,h2+1);
			g.drawLine(w2-1,h2+2,w2  ,h2+2);

			g.translate(-(x+w-WIDTH),-(y-1));
		}

		public Insets getBorderInsets(Component c)
		{
			return new Insets(0,0,0,WIDTH);
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.LogViewer,18,5,0,16,76,89,5,16,6,0.789915966,348,1.0,2,0.974626866,0.233333333,3,16,17.94444444,2,1.1667,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;



public class LogViewer extends JPanel implements DefaultFocusComponent,
EBComponent
{
	
	public LogViewer()
	{
		super(new BorderLayout());

		JPanel caption = new JPanel();
		caption.setLayout(new BoxLayout(caption,BoxLayout.X_AXIS));
		caption.setBorder(new EmptyBorder(6,6,6,6));

		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			String[] args = { MiscUtilities.constructPath(
								      settingsDirectory, ""activity.log"") };
			JLabel label = new JLabel(jEdit.getProperty(
								    ""log-viewer.caption"",args));
			caption.add(label);
		}

		caption.add(Box.createHorizontalGlue());

		tailIsOn = jEdit.getBooleanProperty(""log-viewer.tail"", false);
		tail = new JCheckBox(
				     jEdit.getProperty(""log-viewer.tail.label""),tailIsOn);
		tail.addActionListener(new ActionHandler());


		filter = new JTextField();
		filter.getDocument().addDocumentListener(new DocumentListener()
		{
			public void changedUpdate(DocumentEvent e)
			{
				setFilter();
			}

			public void insertUpdate(DocumentEvent e)
			{
				setFilter();
			}

			public void removeUpdate(DocumentEvent e)
			{
				setFilter();
			}
		});
		caption.add(filter);
		caption.add(tail);

		caption.add(Box.createHorizontalStrut(12));

		copy = new JButton(jEdit.getProperty(""log-viewer.copy""));
		copy.addActionListener(new ActionHandler());
		caption.add(copy);

		ListModel model = Log.getLogListModel();
		listModel = new MyFilteredListModel(model);
		
		
		
		model.removeListDataListener(listModel);

		list = new LogList(listModel);
		listModel.setList(list);
		add(BorderLayout.NORTH,caption);
		JScrollPane scroller = new JScrollPane(list);
		Dimension dim = scroller.getPreferredSize();
		dim.width = Math.min(600,dim.width);
		scroller.setPreferredSize(dim);
		add(BorderLayout.CENTER,scroller);

		propertiesChanged();
	} 

	
	@Override
	public void setBounds(int x, int y, int width, int height)
	{
		list.setCellRenderer( new ColorizerCellRenderer() );
		super.setBounds(x, y, width, height);
		scrollLaterIfRequired();
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
	} 

	
	@Override
	public void addNotify()
	{
		super.addNotify();
		ListModel model = Log.getLogListModel();
		model.addListDataListener(listModel);
		model.addListDataListener(listHandler = new ListHandler());
		if(tailIsOn)
			scrollToTail();

		EditBus.addToBus(this);
	} 

	
	@Override
	public void removeNotify()
	{
		super.removeNotify();
		ListModel model = Log.getLogListModel();
		model.removeListDataListener(listModel);
		model.removeListDataListener(listHandler);
		listHandler = null;
		EditBus.removeFromBus(this);
	} 

	
	public void focusOnDefaultComponent()
	{
		list.requestFocus();
	} 

	
	private ListHandler listHandler;
	private final FilteredListModel listModel;
	private final JList list;
	private final JButton copy;
	private final JCheckBox tail;
	private final JTextField filter;
	private boolean tailIsOn;

	
	private void setFilter()
	{
		listModel.setFilter(filter.getText());
		scrollLaterIfRequired();
	} 

	
	private void propertiesChanged()
	{
		list.setFont(jEdit.getFontProperty(""view.font""));
		list.setFixedCellHeight(list.getFontMetrics(list.getFont())
					.getHeight());
	} 

	
	
	private void scrollToTail()
	{
		int index = list.getModel().getSize();
		if(index != 0)
			list.ensureIndexIsVisible(index - 1);
	} 

	
	private void scrollLaterIfRequired()
	{
		if (tailIsOn)
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					scrollToTail();
				}
			});
	} 

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent e)
		{
			Object src = e.getSource();
			if(src == tail)
			{
				tailIsOn = !tailIsOn;
				jEdit.setBooleanProperty(""log-viewer.tail"",tailIsOn);
				if(tailIsOn)
				{
					scrollToTail();
				}
			}
			else if(src == copy)
			{
				StringBuilder buf = new StringBuilder();
				Object[] selected = list.getSelectedValues();
				if(selected != null && selected.length != 0)
				{
					for(int i = 0; i < selected.length; i++)
					{
						buf.append(selected[i]);
						buf.append('\n');
					}
				}
				else
				{
					ListModel model = list.getModel();
					for(int i = 0; i < model.getSize(); i++)
					{
						buf.append(model.getElementAt(i));
						buf.append('\n');
					}
				}
				Registers.setRegister('$',buf.toString());
			}
		}
	} 

	
	private class ListHandler implements ListDataListener
	{
		public void intervalAdded(ListDataEvent e)
		{
			contentsChanged(e);
		}

		public void intervalRemoved(ListDataEvent e)
		{
			contentsChanged(e);
		}

		public void contentsChanged(ListDataEvent e)
		{
			scrollLaterIfRequired();
		}
	} 

	
	private class LogList extends JList
	{
		LogList(ListModel model)
		{
			super(model);
			setVisibleRowCount(24);
			getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
			setAutoscrolls(true);
		}

		@Override
		public void processMouseEvent(MouseEvent evt)
		{
			if(evt.getID() == MouseEvent.MOUSE_PRESSED)
			{
				startIndex = list.locationToIndex(
								  evt.getPoint());
			}
			super.processMouseEvent(evt);
		}

		@Override
		public void processMouseMotionEvent(MouseEvent evt)
		{
			if(evt.getID() == MouseEvent.MOUSE_DRAGGED)
			{
				int row = list.locationToIndex(evt.getPoint());
				if(row != -1)
				{
					if(startIndex == -1)
					{
						list.setSelectionInterval(row,row);
						startIndex = row;
					}
					else
						list.setSelectionInterval(startIndex,row);
					list.ensureIndexIsVisible(row);
					evt.consume();
				}
			}
			else
				super.processMouseMotionEvent(evt);
		}

		private int startIndex;
	} 

	private static class ColorizerCellRenderer extends JLabel implements ListCellRenderer
	{

		
		
		public Component getListCellRendererComponent(
							      JList list,
							      Object value,              
							      int index,                 
							      boolean isSelected,        
							      boolean cellHasFocus )     
		{
			String s = value.toString();
			setText(s);
			if (isSelected)
			{
				setBackground(list.getSelectionBackground());
				setForeground(list.getSelectionForeground());
			}
			else
			{
				setBackground(list.getBackground());
				Color color = list.getForeground();
				if (s.contains(""[debug]""))
				{
					color = Color.BLUE;
				}
				else if (s.contains(""[notice]""))
				{
					color = Color.GREEN;
				}
				else if (s.contains(""[warning]""))
				{
					color = Color.ORANGE;
				}
				else if (s.contains(""[error]""))
				{
					color = Color.RED;
				}
				setForeground( color );
			}
			setEnabled( list.isEnabled() );
			setFont( list.getFont() );
			setOpaque( true );
			return this;
		}
	}

	private static class MyFilteredListModel extends FilteredListModel
	{
		MyFilteredListModel(ListModel model)
		{
			super(model);
		}

		@Override
		public String prepareFilter(String filter)
		{
			return filter.toLowerCase();
		}

		@Override
		public boolean passFilter(int row, String filter)
		{
			return delegated.getElementAt(row).toString().toLowerCase().contains(filter);
		}
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.buffer.FoldHandlerProvider,2,1,0,5,2,1,5,1,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.buffer;


public interface FoldHandlerProvider
{
	
	FoldHandler getFoldHandler(String name);

	
	String[] getFoldModes();
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.BeanShellErrorDialog,2,8,0,4,3,1,2,2,2,2.0,13,0.0,0,1.0,0.75,0,0,5.5,0,0.0,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;



public class BeanShellErrorDialog extends TextAreaDialog
{
	public BeanShellErrorDialog(Frame frame, Throwable t)
	{
		super(frame,""beanshell-error"",t);
	}

	
	public BeanShellErrorDialog(View view, Throwable t)
	{
		this((Frame)view,t);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.ActionSet,19,2,0,17,38,147,10,9,14,0.805555556,193,1.0,1,0.5,0.167464115,1,3,9.052631579,3,1.0,0,"

package org.gjt.sp.jedit;


import java.net.URL;
import java.util.*;

import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.util.Log;



public class ActionSet extends JEditActionSet<EditAction> implements Comparable
{
	
	
	public ActionSet()
	{
		label = ""<no label set; plugin bug>"";
	} 
	
	
	
	public ActionSet(PluginJAR plugin, String[] cachedActionNames,
		boolean[] cachedActionToggleFlags, URL uri)
	{
		this();
		this.plugin = plugin;
		this.uri = uri;
		if(cachedActionNames != null)
		{
			for(int i = 0; i < cachedActionNames.length; i++)
			{
				actions.put(cachedActionNames[i],placeholder);
				jEdit.setTemporaryProperty(cachedActionNames[i]
					+ "".toggle"",cachedActionToggleFlags[i]
					? ""true"" : ""false"");
			}
		}
		loaded = false;
	} 
	
	
	
	@Override
	public void addAction(EditAction action)
	{
		super.addAction(action);
	} 
	
	
	protected EditAction[] getArray(int size)
	{
		return new EditAction[size];
	} 
	
	
	
	@Override
	public EditAction[] getActions()
	{
		return super.getActions();
	} 

	
	
	public ActionSet(String label)
	{
		this();
		setLabel(label);
	} 

	
	
	public String getLabel()
	{
		return label;
	} 

	
	
	public void setLabel(String label)
	{
		if(label == null)
			throw new NullPointerException();
		this.label = label;
	} 

	
	
	public PluginJAR getPluginJAR()
	{
		return plugin;
	} 

	
	
	@Override
	public String[] getCacheableActionNames()
	{
		LinkedList<String> retVal = new LinkedList<String>();
		Enumeration e = actions.elements();
		while(e.hasMoreElements())
		{
			Object obj = e.nextElement();
			if(obj == placeholder)
			{
				
				
				Log.log(Log.WARNING,this,""Action set not up ""
					+ ""to date"");
			}
			else if(obj instanceof BeanShellAction)
				retVal.add(((BeanShellAction)obj).getName());
		}
		return retVal.toArray(new String[retVal.size()]);
	} 
	
	
	protected String getProperty(String name)
	{
		return jEdit.getProperty(name);
	} 
	
	
	public AbstractInputHandler getInputHandler()
	{
		return jEdit.getInputHandler();
	} 

	
	public int compareTo(Object o)
	{
		return label.compareTo(((ActionSet)o).label);
	}

	
	@Override
	public String toString()
	{
		return label;
	} 
	
	
	
	 protected EditAction createBeanShellAction(String actionName,
						    String code,
						    String selected,
						    boolean noRepeat,
						    boolean noRecord,
						    boolean noRememberLast)
	{
		return new BeanShellAction(actionName,code,selected,noRepeat,noRecord,noRememberLast);
	}
	

	
	private String label;
	private PluginJAR plugin;
	

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockableWindowFactory,10,1,0,13,37,3,9,7,9,0.555555556,222,1.0,1,0.0,0.2625,0,0,21.0,4,1.7,0,"

package org.gjt.sp.jedit.gui;


import java.io.IOException;
import java.net.URL;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Stack;

import javax.swing.JComponent;

import org.gjt.sp.jedit.ActionSet;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.PluginJAR;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.bsh.NameSpace;
import org.gjt.sp.jedit.bsh.UtilEvalError;



public class DockableWindowFactory
{
	
	public static synchronized DockableWindowFactory getInstance()
	{
		if(instance == null)
			instance = new DockableWindowFactory();
		return instance;
	} 

	
	public DockableWindowFactory()
	{
		dockableWindowFactories = new HashMap<String, Window>();
	} 

	
	
	public void loadDockableWindows(PluginJAR plugin, URL uri,
		PluginJAR.PluginCacheEntry cache)
	{
		try
		{
			Log.log(Log.DEBUG,DockableWindowManager.class,
				""Loading dockables from "" + uri);
			DockableListHandler dh = new DockableListHandler(plugin,uri);
			boolean failure = XMLUtilities.parseXML(uri.openStream(), dh);

			if (!failure && cache != null)
			{
				cache.cachedDockableNames = dh.getCachedDockableNames();
				cache.cachedDockableActionFlags = dh.getCachedDockableActionFlags();
				cache.cachedDockableMovableFlags = dh.getCachedDockableMovableFlags();
			}
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,DockableWindowManager.class,e);
		}
	} 

	
	
	public void unloadDockableWindows(PluginJAR plugin)
	{
		Iterator entries = dockableWindowFactories.entrySet().iterator();
		while(entries.hasNext())
		{
			Map.Entry entry = (Map.Entry)entries.next();
			Window factory = (Window)entry.getValue();
			if(factory.plugin == plugin)
				entries.remove();
		}
	} 

	
	
	public void cacheDockableWindows(PluginJAR plugin,
		String[] name, boolean[] actions, boolean[] movable)
	{
		for(int i = 0; i < name.length; i++)
		{
			Window factory = new Window(plugin,
				name[i],null,actions[i],movable[i]);
			dockableWindowFactories.put(name[i],factory);
		}
	} 

	
	public void registerDockableWindow(PluginJAR plugin,
		String name, String code, boolean actions, boolean movable)
	{
		Window factory = dockableWindowFactories.get(name);
		if(factory != null)
		{
			factory.code = code;
			factory.loaded = true;
		}
		else
		{
			factory = new Window(plugin,name,code,actions, movable);
			dockableWindowFactories.put(name,factory);
		}
	} 

	
	public String[] getRegisteredDockableWindows()
	{
		String[] retVal = new String[dockableWindowFactories.size()];
		Iterator<Window> entries = dockableWindowFactories.values().iterator();
		int i = 0;
		while(entries.hasNext())
		{
			Window factory = entries.next();
			retVal[i++] = factory.name;
		}

		return retVal;
	} 

	public Window getDockableWindowFactory(String name)
	{
		return dockableWindowFactories.get(name);
	}
	
	public String getDockableWindowPluginClass(String name)
	{
		Window w = getDockableWindowFactory(name);
		if (w == null || w.plugin == null || w.plugin.getPlugin() == null)
			return null;
		return w.plugin.getPlugin().getClassName();
	}
	
	
	Iterator<Window> getDockableWindowIterator()
	{
		return dockableWindowFactories.values().iterator();
	} 

	
	class DockableListHandler extends DefaultHandler
	{
		
		
		DockableListHandler(PluginJAR plugin, URL uri)
		{
			this.plugin = plugin;
			this.uri = uri;
			stateStack = new Stack<String>();
			actions = true;
			movable = MOVABLE_DEFAULT;

			code = new StringBuilder();
			cachedDockableNames = new LinkedList<String>();
			cachedDockableActionFlags = new LinkedList<Boolean>();
			cachedDockableMovableFlags = new LinkedList<Boolean>();
		} 

		
		@Override
		public InputSource resolveEntity(String publicId, String systemId)
		{
			return XMLUtilities.findEntity(systemId, ""dockables.dtd"", MiscUtilities.class);
		} 

		
		@Override
		public void characters(char[] c, int off, int len)
		{
			String tag = peekElement();
			if (tag.equals(""DOCKABLE""))
				code.append(c, off, len);
		} 

		
		@Override
		public void startElement(String uri, String localName,
					 String qName, Attributes attrs)
		{
			String tag = pushElement(qName);
			if (tag.equals(""DOCKABLE""))
			{
				dockableName = attrs.getValue(""NAME"");
				actions = ""FALSE"".equals(attrs.getValue(""NO_ACTIONS""));
				String movableAttr = attrs.getValue(""MOVABLE"");
				if (movableAttr != null)
					movable = movableAttr.equalsIgnoreCase(""TRUE"");
			}
		} 

		
		@Override
		public void endElement(String uri, String localName, String name)
		{
			if(name == null)
				return;

			String tag = peekElement();

			if(name.equals(tag))
			{
				if(tag.equals(""DOCKABLE""))
				{
					registerDockableWindow(plugin,
						dockableName,code.toString(),actions, movable);
					cachedDockableNames.add(dockableName);
					cachedDockableActionFlags.add(
						Boolean.valueOf(actions));
					cachedDockableMovableFlags.add(
							Boolean.valueOf(movable));
					
					
					actions = true;
					movable = MOVABLE_DEFAULT;
					code.setLength(0);
				}

				popElement();
			}
			else
			{
				
				throw new InternalError();
			}
		} 

		
		@Override
		public void startDocument()
		{
			try
			{
				pushElement(null);
			}
			catch (Exception e)
			{
				Log.log(Log.ERROR, this, e);
			}
		} 

		
		public String[] getCachedDockableNames()
		{
			return cachedDockableNames.toArray(new String[cachedDockableNames.size()]);
		} 

		
		public boolean[] getCachedDockableActionFlags()
		{
			return booleanListToArray(cachedDockableActionFlags);
		} 

		
		public boolean[] getCachedDockableMovableFlags()
		{
			return booleanListToArray(cachedDockableMovableFlags);
		} 
		
		
		
		private boolean[] booleanListToArray(java.util.List<Boolean> list)
		{
			boolean[] returnValue = new boolean[list.size()];
			int i = 0;
			for (Boolean value : list)
			{
				returnValue[i++] = value.booleanValue();
			}

			return returnValue;
		} 

		

		
		private PluginJAR plugin;
		
		private URL uri;

		private java.util.List<String> cachedDockableNames;
		private java.util.List<Boolean> cachedDockableActionFlags;
		private java.util.List<Boolean> cachedDockableMovableFlags;
		
		private String dockableName;
		private StringBuilder code;
		private boolean actions;
		private boolean movable;
		final boolean MOVABLE_DEFAULT = false;
		
		private Stack<String> stateStack;
		

		
		private String pushElement(String name)
		{
			name = (name == null) ? null : name.intern();

			stateStack.push(name);

			return name;
		} 

		
		private String peekElement()
		{
			return stateStack.peek();
		} 

		
		private String popElement()
		{
			return stateStack.pop();
		} 

		
	} 

	
	class Window
	{
		PluginJAR plugin;
		String name;
		String code;
		boolean loaded;
		boolean movable;
		boolean isBeingCreated = false;

		
		Window(PluginJAR plugin, String name, String code,
			boolean actions, boolean movable)
		{
			this.plugin = plugin;
			this.name = name;
			this.code = code;
			this.movable = movable;

			if(code != null)
				loaded = true;

			if(actions)
			{
				ActionSet actionSet = (plugin == null
					? jEdit.getBuiltInActionSet()
					: plugin.getActionSet());
				actionSet.addAction(new OpenAction(name));
				actionSet.addAction(new ToggleAction(name));
				actionSet.addAction(new FloatAction(name));

				String label = jEdit.getProperty(name
					+ "".label"");
				if(label == null)
					label = ""NO LABEL PROPERTY: "" + name;

				String[] args = { label };
				jEdit.setTemporaryProperty(name + "".label"",
					label);
				jEdit.setTemporaryProperty(name
					+ ""-toggle.label"",
					jEdit.getProperty(
					""view.docking.toggle.label"",args));
				jEdit.setTemporaryProperty(name
					+ ""-toggle.toggle"",""true"");
				jEdit.setTemporaryProperty(name
					+ ""-float.label"",
					jEdit.getProperty(
					""view.docking.float.label"",args));
			}
		} 

		
		void load()
		{
			if(loaded)
				return;

			loadDockableWindows(plugin,plugin.getDockablesURI(),null);
		} 

		
		JComponent createDockableWindow(View view, String position)
		{
			
			synchronized(this)
			{
				if (isBeingCreated)
					return null;
				isBeingCreated = true;
			}

			load();

			if(!loaded)
			{
				Log.log(Log.WARNING,this,""Outdated cache"");
				return null;
			}

			NameSpace nameSpace = new NameSpace(
				BeanShell.getNameSpace(),
				""DockableWindowManager.Factory""
				+ "".createDockableWindow()"");
			try
			{
				nameSpace.setVariable(
					""position"",position);
			}
			catch(UtilEvalError e)
			{
				Log.log(Log.ERROR,this,e);
			}
			JComponent win = (JComponent)BeanShell.eval(view,
				nameSpace,code);
			synchronized(this)
			{
				isBeingCreated = false;
			}
			return win;
		} 

		
		class OpenAction extends EditAction
		{
			private String dockable;

			
			OpenAction(String name)
			{
				super(name);
				this.dockable = name;
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.showDockableWindow(dockable);
			} 

			
			@Override
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".showDockableWindow(\"""" + dockable + ""\"");"";
			} 
		} 

		
		class ToggleAction extends EditAction
		{
			private String dockable;

			
			ToggleAction(String name)
			{
				super(name + ""-toggle"");
				this.dockable = name;
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.toggleDockableWindow(dockable);
			} 

			
			public boolean isSelected(View view)
			{
				return view.getDockableWindowManager()
					.isDockableWindowVisible(dockable);
			} 

			
			@Override
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".toggleDockableWindow(\"""" + dockable + ""\"");"";
			} 
		} 

		
		class FloatAction extends EditAction
		{
			private String dockable;

			
			FloatAction(String name)
			{
				super(name + ""-float"");
				this.dockable = name;
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.floatDockableWindow(dockable);
			} 

			
			@Override
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".floatDockableWindow(\"""" + dockable + ""\"");"";
			} 
		} 
	} 

	private static DockableWindowFactory instance;
	private final Map<String, Window> dockableWindowFactories;
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.SimpleNode,19,1,38,62,30,147,57,8,18,0.904761905,242,0.428571429,5,0.0,0.268518519,0,0,11.36842105,6,1.5789,0,"


package org.gjt.sp.jedit.bsh;

class SimpleNode implements Node 
{
	public static SimpleNode JAVACODE =
		new SimpleNode( -1 ) {
			public String getSourceFile() {
				return ""<Called from Java Code>"";
			}

			public int getLineNumber() {
				return -1;
			}

			public String getText()  {
				return ""<Compiled Java Code>"";
			}
		};

	protected Node parent;
	protected Node[] children;
	protected int id;
	Token firstToken, lastToken;

	
	String sourceFile;

	public SimpleNode(int i) {
		id = i;
	}

	public void jjtOpen() { }
	public void jjtClose() { }

	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	

	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}

		children[i] = n;
	}

	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }

	
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + "" "");
				}
			}
		}
	}

	

	
	public void prune() {
		jjtSetParent( null );
	}

	
	public Object eval( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		throw new InterpreterError(
			""Unimplemented or inappropriate for "" + getClass().getName() );
	}

	
	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}

	
	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return ""<unknown file>"";
		else
			return sourceFile;
	}

	
	public int getLineNumber() {
		return firstToken.beginLine;
	}

	

	
	public String getText() 
	{
		StringBuilder text = new StringBuilder();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(""."") )
				text.append("" "");
			if ( t==lastToken ||
				t.image.equals(""{"") || t.image.equals("";"") )
				break;
			t=t.next;
		}
			
		return text.toString();
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.IOProgressMonitor,6,5,0,9,29,5,5,6,3,0.666666667,141,1.0,2,0.992401216,0.5,1,7,22.0,1,0.8333,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class IOProgressMonitor extends JPanel
{
	
	public IOProgressMonitor()
	{
		super(new BorderLayout());
		caption = new JLabel();
		updateCaption();
		add(BorderLayout.NORTH,caption);

		threads = new ThreadProgress[VFSManager.getIOThreadPool()
			.getThreadCount()];

		Box box = new Box(BoxLayout.Y_AXIS);
		for(int i = 0; i < threads.length; i++)
		{
			if(i != 0)
				box.add(Box.createVerticalStrut(6));

			threads[i] = new ThreadProgress(i);
			box.add(threads[i]);
		}

		JPanel threadPanel = new JPanel(new BorderLayout());
		threadPanel.setBorder(new EmptyBorder(6,6,6,6));
		threadPanel.add(BorderLayout.NORTH,box);

		add(BorderLayout.CENTER,new JScrollPane(threadPanel));

		workThreadHandler = new WorkThreadHandler();
	} 

	
	public void addNotify()
	{
		VFSManager.getIOThreadPool().addProgressListener(workThreadHandler);
		super.addNotify();
	} 

	
	public void removeNotify()
	{
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.removeNotify();
	} 

	

	
	private JLabel caption;
	private ThreadProgress[] threads;
	private WorkThreadHandler workThreadHandler;
	

	
	private void updateCaption()
	{
		String[] args = { String.valueOf(VFSManager.getIOThreadPool()
			.getRequestCount()) };
		caption.setText(jEdit.getProperty(""io-progress-monitor.caption"",args));
	} 

	

	
	class WorkThreadHandler implements WorkThreadProgressListener
	{
		public void statusUpdate(final WorkThreadPool threadPool, final int threadIndex)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[threadIndex].update();
				}
			});
		}

		public void progressUpdate(final WorkThreadPool threadPool, final int threadIndex)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[threadIndex].update();
				}
			});
		}
	} 

	
	class ThreadProgress extends JPanel
	{
		
		public ThreadProgress(int index)
		{
			super(new BorderLayout(12,12));

			this.index = index;

			Box box = new Box(BoxLayout.Y_AXIS);
			box.add(Box.createGlue());
			box.add(progress = new JProgressBar());
			progress.setStringPainted(true);
			box.add(Box.createGlue());
			ThreadProgress.this.add(BorderLayout.CENTER,box);

			abort = new JButton(jEdit.getProperty(""io-progress-monitor.abort""));
			abort.addActionListener(new ActionHandler());
			ThreadProgress.this.add(BorderLayout.EAST,abort);

			update();
		} 

		
		public void update()
		{
			WorkThread thread = VFSManager.getIOThreadPool().getThread(index);
			if(thread.isRequestRunning())
			{
				if (progress.isIndeterminate())
				{
					if (thread.getProgressMaximum() != 0)
						progress.setIndeterminate(false);
				}
				else if (thread.getProgressMaximum() == 0)
					progress.setIndeterminate(true);
				
				abort.setEnabled(true);
				String status = thread.getStatus();
				if(status == null)
					status = """";
				progress.setString(status);
				progress.setMaximum(thread.getProgressMaximum());
				
				progress.setValue(thread.getProgressValue());
			}
			else
			{
				abort.setEnabled(false);
				progress.setString(jEdit.getProperty(""io-progress-monitor""
					+ "".idle""));
				progress.setIndeterminate(false);
				progress.setValue(0);
			}
		} 

		
		private int index;
		private JProgressBar progress;
		private JButton abort;
		

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getSource() == abort)
				{
					int result = GUIUtilities.confirm(
						IOProgressMonitor.this,""abort"",null,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					if(result == JOptionPane.YES_OPTION)
					{
						VFSManager.getIOThreadPool().getThread(index)
							.abortCurrentRequest();
					}
				}
			}
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.ParseException,11,4,0,6,23,23,2,4,10,0.533333333,494,0.333333333,1,0.777777778,0.272727273,2,3,43.36363636,14,3.2727,0,"


package org.gjt.sp.jedit.bsh;


 

public class ParseException extends EvalError {


	

	String sourceFile = ""<unknown>"";

	
	public void setErrorSourceFile( String file ) {
		this.sourceFile = file;
	}

	public String getErrorSourceFile() { 
		return sourceFile; 
	}

	

  
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
	
	this();
	
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }

  

  public ParseException() {
	
	this("""");
	
    specialConstructor = false;
  }

  public ParseException(String message) {
	
	
	super( message, null, null );
	
    specialConstructor = false;
  }

  
  protected boolean specialConstructor;

  
  public Token currentToken;

  
  public int[][] expectedTokenSequences;

  
  public String[] tokenImage;

  
  public String	getMessage() {
	return getMessage( false );
  }
  

  
  
  public String getMessage( boolean debug ) {
  
    if (!specialConstructor) {
      return super.getMessage();
    }
    String expected = """";
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected += ""..."";
      }
      expected += eol + ""    "";
    }
	
    String retval = ""In file: ""+ sourceFile +"" Encountered \"""";
	
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += "" "";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn + ""."" + eol;

	
	if ( debug )
	{
		if (expectedTokenSequences.length == 1) {
		  retval += ""Was expecting:"" + eol + ""    "";
		} else {
		  retval += ""Was expecting one of:"" + eol + ""    "";
		}

		retval += expected;
	}
	

    return retval;
  }

  
  protected String eol = System.getProperty(""line.separator"", ""\n"");
 
  
  protected String add_escapes(String str) {
      StringBuilder retval = new StringBuilder();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

	

	public int getErrorLineNumber() 
	{
		return currentToken.next.beginLine;
	}

	public String getErrorText() { 
		
		int	maxSize	= 0;
		for	(int i = 0; i <	expectedTokenSequences.length; i++) {
		  if (maxSize < expectedTokenSequences[i].length)
			maxSize	= expectedTokenSequences[i].length;
		}

		String retval = """";
		Token tok =	currentToken.next;
		for	(int i = 0; i <	maxSize; i++) 
		{
		  if (i != 0) retval += "" "";
		  if (tok.kind == 0) {
			retval += tokenImage[0];
			break;
		  }
		  retval +=	add_escapes(tok.image);
		  tok = tok.next;
		}
		
		return retval;
	}

	public String toString() {
		return getMessage();
	}

	

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.statusbar.StatusWidgetFactory,1,1,0,16,1,0,14,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui.statusbar;

import org.gjt.sp.jedit.View;


public interface StatusWidgetFactory 
{
	
	Widget getWidget(View view);
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.InputHandler,16,2,1,27,87,14,12,19,11,0.266666667,718,1.0,1,0.571428571,0.19375,1,5,43.8125,18,5.125,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.text.JTextComponent;

import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;

import java.awt.event.KeyEvent;
import java.awt.*;



public abstract class InputHandler extends AbstractInputHandler<EditAction>
{
	
	
	protected InputHandler(View view)
	{
		this.view = view;
	} 

	
	
	public final boolean handleKey(KeyEventTranslator.Key keyStroke)
	{
		return handleKey(keyStroke, false);
	} 

	
	
	@Override
	public void processKeyEvent(KeyEvent evt, int from, boolean global)
	{
		if(Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,this,""Key event                 : ""
				+ AbstractInputHandler.toString(evt) + "" from "" + from);
			Log.log(Log.DEBUG,this,view+"".isFocused()=""+view.isFocused()+'.',new Exception());
		}

		if(view.getTextArea().hasFocus() && from == View.VIEW)
			return;

		evt = _preprocessKeyEvent(evt);
		if(evt == null)
			return;

		if(Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,this,""Key event after workaround: ""
				+ AbstractInputHandler.toString(evt) + "" from "" + from);
		}

		Component prefixFocusOwner = view.getPrefixFocusOwner();
		boolean focusOnTextArea = false;
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			
			
			
			if(prefixFocusOwner != null)
			{
				if(prefixFocusOwner.isShowing())
				{
					prefixFocusOwner.requestFocus();
					focusOnTextArea = true;
				}
			}

			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else if(from == View.ACTION_BAR
				|| isPrefixActive()
				|| view.getTextArea().hasFocus())
			{
				processKeyEventKeyStrokeHandling(evt,from,""type "",global);
			}


			processKeyEventSub(focusOnTextArea);

			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else if(KeyEventWorkaround.isBindable(evt.getKeyCode()))
			{
				if(prefixFocusOwner != null)
				{
					if(prefixFocusOwner.isShowing())
					{
						prefixFocusOwner.requestFocus();
						focusOnTextArea = true;
					}
					view.setPrefixFocusOwner(null);
				}

				processKeyEventKeyStrokeHandling(evt,from,""press"",global);

				processKeyEventSub(focusOnTextArea);

			}
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			break;
		}
	} 

	
	private KeyEvent _preprocessKeyEvent(KeyEvent evt)
	{
		if(view.isClosed())
			return null;
		Component focusOwner = view.getFocusOwner();
		if(focusOwner instanceof JComponent)
		{
			JComponent comp = (JComponent)focusOwner;
			InputMap map = comp.getInputMap();
			ActionMap am = comp.getActionMap();

			if(map != null && am != null && comp.isEnabled())
			{
				KeyStroke keyStroke = KeyStroke.getKeyStrokeForEvent(evt);
				Object binding = map.get(keyStroke);
				if(binding != null && am.get(binding) != null)
				{
					return null;
				}
			}
		}
		
		if(focusOwner instanceof JTextComponent)
		{
			
			
			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_ENTER:
				case KeyEvent.VK_TAB:
				case KeyEvent.VK_BACK_SPACE:
				case KeyEvent.VK_SPACE:
					return null;
				}
			}
		}

		if(evt.isConsumed())
			return null;

		if(Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,this,""Key event (preprocessing) : ""
					+ AbstractInputHandler.toString(evt));
		}

		return KeyEventWorkaround.processKeyEvent(evt);
	} 

	
	private void processKeyEventSub(boolean focusOnTextArea)
	{
		
		
		if(view.isClosed())
			return;

		
		
		
		if(isPrefixActive())
		{
			Component focusOwner = view.getFocusOwner();
			if(focusOwner instanceof JTextComponent)
			{
				view.setPrefixFocusOwner(focusOwner);
				view.getTextArea().requestFocus();
			}
			else if(focusOnTextArea)
			{
				view.getTextArea().requestFocus();
			}
			else
			{
				view.setPrefixFocusOwner(null);
			}
		}
		else
		{
			view.setPrefixFocusOwner(null);
		}
	}
	

	
	
	public int getRepeatCount()
	{
		return repeatCount;
	} 

	
	
	public void setRepeatCount(int repeatCount)
	{
		int oldRepeatCount = this.repeatCount;
		this.repeatCount = repeatCount;
		if(oldRepeatCount != repeatCount)
			view.getStatus().setMessage(null);
	} 

	
	
	public EditAction getLastAction()
	{
		return lastAction;
	} 

	
	
	public void readNextChar(String msg, String code)
	{
		view.getStatus().setMessage(msg);
		readNextChar = code;
	} 

	
	
	@Deprecated
	public void readNextChar(String code)
	{
		readNextChar = code;
	} 

	
	
	@Override
	public void invokeAction(String action)
	{
		invokeAction(jEdit.getAction(action));
	} 

	
	
	@Override
	public void invokeAction(EditAction action)
	{
		JEditBuffer buffer = view.getBuffer();

		

		
		if(!action.noRememberLast())
		{
			HistoryModel.getModel(""action"").addItem(action.getName());
			if(lastAction == action)
				lastActionCount++;
			else
			{
				lastAction = action;
				lastActionCount = 1;
			}
		}

		
		int _repeatCount = repeatCount;

		
		if(action.noRepeat() || _repeatCount == 1)
			action.invoke(view);
		else
		{
			
			if(_repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				String label = action.getLabel();
				if(label == null)
					label = action.getName();
				else
					label = GUIUtilities.prettifyMenuLabel(label);

				Object[] pp = { label, _repeatCount };

				if(GUIUtilities.confirm(view,""large-repeat-count"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeatCount = 1;
					view.getStatus().setMessage(null);
					return;
				}
			}

			try
			{
				buffer.beginCompoundEdit();

				for(int i = 0; i < _repeatCount; i++)
					action.invoke(view);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null && !action.noRecord())
			recorder.record(_repeatCount,action.getCode());

		
		
		if(_repeatCount != 1)
		{
			
			
			if(readNextChar != null)
				return;

			repeatCount = 1;
			view.getStatus().setMessage(null);
		}
	} 

	
	public void invokeLastAction()
	{
		if(lastAction == null)
			view.getToolkit().beep();
		else
			invokeAction(lastAction);
	} 

	
	protected final View view;

	

	
	protected void userInput(char ch)
	{
		lastActionCount = 0;

		JEditTextArea textArea = view.getTextArea();

		

		if(repeatCount == 1)
			textArea.userInput(ch);
		else
		{
			
			if(repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				Object[] pp = { String.valueOf(ch),
					repeatCount };

				if(GUIUtilities.confirm(view,
					""large-repeat-count.user-input"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeatCount = 1;
					view.getStatus().setMessage(null);
					return;
				}
			}

			JEditBuffer buffer = view.getBuffer();
			try
			{
				if(repeatCount != 1)
					buffer.beginCompoundEdit();
				for(int i = 0; i < repeatCount; i++)
					textArea.userInput(ch);
			}
			finally
			{
				if(repeatCount != 1)
					buffer.endCompoundEdit();
			}
		}

		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null)
		{
			recorder.recordInput(repeatCount,ch,
				textArea.isOverwriteEnabled());
		}

		repeatCount = 1;
	} 

	
	protected void invokeReadNextChar(char ch)
	{
		JEditBuffer buffer = view.getBuffer();

		

		String charStr = StandardUtilities.charsToEscapes(String.valueOf(ch));

		
		int index;
		while((index = readNextChar.indexOf(""__char__"")) != -1)
		{
			readNextChar = readNextChar.substring(0,index)
				+ '\'' + charStr + '\''
				+ readNextChar.substring(index + 8);
		}

		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(getRepeatCount(),readNextChar);

		view.getStatus().setMessage(null);

		if(getRepeatCount() != 1)
		{
			try
			{
				buffer.beginCompoundEdit();

				BeanShell.eval(view,BeanShell.getNameSpace(),
					""for(int i = 1; i < ""
					+ getRepeatCount() + ""; i++)\n{\n""
					+ readNextChar + ""\n}"");
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		else
			BeanShell.eval(view,BeanShell.getNameSpace(),readNextChar);

		readNextChar = null;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.FirstLine,9,2,0,8,29,0,4,6,3,0.25,708,0.0,0,0.384615385,0.416666667,1,5,77.55555556,9,5.4444,0,"

package org.gjt.sp.jedit.textarea;

import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;


class FirstLine extends Anchor
{
	
	int skew;

	
	FirstLine(DisplayManager displayManager,
		TextArea textArea)
	{
		super(displayManager,textArea);
	} 

	
	@Override
	public void changed()
	{
		
		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""changed() before: ""
				+ physicalLine + ':' + scrollLine
				+ ':' + skew);
		} 

		ensurePhysicalLineIsVisible();

		int screenLines = displayManager
			.getScreenLineCount(physicalLine);
		if(skew >= screenLines)
			skew = screenLines - 1;

		
		if(Debug.SCROLL_VERIFY)
		{
			System.err.println(""SCROLL_VERIFY"");
			int verifyScrollLine = 0;

			for(int i = 0; i < displayManager.getBuffer()
				.getLineCount(); i++)
			{
				if(!displayManager.isLineVisible(i))
					continue;

				if(i >= physicalLine)
					break;

				verifyScrollLine += displayManager
					.getScreenLineCount(i);
			}

			if(verifyScrollLine != scrollLine)
			{
				Exception ex = new Exception(scrollLine + "":"" + verifyScrollLine);
				Log.log(Log.ERROR,this,ex);
			}
		}

		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""changed() after: ""
				+ physicalLine + ':' + scrollLine
				+ ':' + skew);
		} 
	} 

	
	@Override
	public void reset()
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""reset()"");

		int oldPhysicalLine = physicalLine;
		physicalLine = 0;
		scrollLine = 0;

		int i = displayManager.getFirstVisibleLine();

		for(;;)
		{
			if(i >= oldPhysicalLine)
				break;

			scrollLine += displayManager.getScreenLineCount(i);

			int nextLine = displayManager.getNextVisibleLine(i);
			if(nextLine == -1)
				break;
			else
				i = nextLine;
		}

		physicalLine = i;

		int screenLines = displayManager.getScreenLineCount(physicalLine);
		if(skew >= screenLines)
			skew = screenLines - 1;

		textArea.updateScrollBar();
	} 

	
	
	void physDown(int amount, int screenAmount)
	{
		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""physDown() start: ""
				+ physicalLine + ':' + scrollLine);
		}

		skew = 0;

		if(!displayManager.isLineVisible(physicalLine))
		{
			int lastVisibleLine = displayManager.getLastVisibleLine();
			if(physicalLine > lastVisibleLine)
				physicalLine = lastVisibleLine;
			else
			{
				int nextPhysicalLine = displayManager.getNextVisibleLine(physicalLine);
				amount -= nextPhysicalLine - physicalLine;
				scrollLine += displayManager.getScreenLineCount(physicalLine);
				physicalLine = nextPhysicalLine;
			}
		}

		for(;;)
		{
			int nextPhysicalLine = displayManager.getNextVisibleLine(
				physicalLine);
			if(nextPhysicalLine == -1)
				break;
			else if(nextPhysicalLine > physicalLine + amount)
				break;
			else
			{
				scrollLine += displayManager.getScreenLineCount(physicalLine);
				amount -= nextPhysicalLine - physicalLine;
				physicalLine = nextPhysicalLine;
			}
		}

		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""physDown() end: ""
				+ physicalLine + ':' + scrollLine);
		}

		callChanged = true;

		
		
		if(screenAmount < 0)
			scrollUp(-screenAmount);
		else if(screenAmount > 0)
			scrollDown(screenAmount);
	} 

	
	
	void physUp(int amount, int screenAmount)
	{
		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""physUp() start: ""
				+ physicalLine + ':' + scrollLine);
		}

		skew = 0;

		if(!displayManager.isLineVisible(physicalLine))
		{
			int firstVisibleLine = displayManager.getFirstVisibleLine();
			if(physicalLine < firstVisibleLine)
				physicalLine = firstVisibleLine;
			else
			{
				int prevPhysicalLine = displayManager.getPrevVisibleLine(physicalLine);
				amount -= physicalLine - prevPhysicalLine;
			}
		}

		for(;;)
		{
			int prevPhysicalLine = displayManager.getPrevVisibleLine(
				physicalLine);
			if(prevPhysicalLine == -1)
				break;
			else if(prevPhysicalLine < physicalLine - amount)
				break;
			else
			{
				amount -= physicalLine - prevPhysicalLine;
				physicalLine = prevPhysicalLine;
				scrollLine -= displayManager.getScreenLineCount(
					prevPhysicalLine);
			}
		}

		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""physUp() end: ""
				+ physicalLine + ':' + scrollLine);
		}

		callChanged = true;

		
		
		if(screenAmount < 0)
			scrollUp(-screenAmount);
		else if(screenAmount > 0)
			scrollDown(screenAmount);
	} 

	
	
	void scrollDown(int amount)
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""scrollDown()"");

		ensurePhysicalLineIsVisible();

		amount += skew;

		skew = 0;

		while(amount > 0)
		{
			int screenLines = displayManager.getScreenLineCount(physicalLine);
			if(amount < screenLines)
			{
				skew = amount;
				break;
			}
			else
			{
				int nextLine = displayManager.getNextVisibleLine(physicalLine);
				if(nextLine == -1)
					break;
				boolean visible = displayManager.isLineVisible(physicalLine);
				physicalLine = nextLine;
				if(visible)
				{
					amount -= screenLines;
					scrollLine += screenLines;
				}
			}
		}

		callChanged = true;
	} 

	
	
	void scrollUp(int amount)
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""scrollUp() before:"" + this);

		ensurePhysicalLineIsVisible();

		if(amount <= skew)
		{
			
			
			skew -= amount;
		}
		else
		{
			
			amount -= skew;
			skew = 0;

			while(amount > 0)
			{
				int prevLine = displayManager.getPrevVisibleLine(physicalLine);
				if(prevLine == -1)
					break;
				
				physicalLine = prevLine;

				int screenLines = displayManager.getScreenLineCount(physicalLine);
				scrollLine -= screenLines;
				if(amount < screenLines)
				{
					skew = screenLines - amount;
					break;
				}
				else
					amount -= screenLines;
			}
		}

		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""scrollUp() after:"" + this);
		callChanged = true;
	} 

	
	void ensurePhysicalLineIsVisible()
	{
		if(!displayManager.isLineVisible(physicalLine))
		{
			if(physicalLine > displayManager.getLastVisibleLine())
			{
				physicalLine = displayManager.getLastVisibleLine();
				scrollLine = displayManager.getScrollLineCount() - 1;
			}
			else if(physicalLine < displayManager.getFirstVisibleLine())
			{
				physicalLine = displayManager.getFirstVisibleLine();
				scrollLine = 0;
			}
			else
			{
				physicalLine = displayManager.getNextVisibleLine(physicalLine);
				scrollLine += displayManager.getScreenLineCount(physicalLine);
			}
		}
	} 

	
	@Override
	public String toString()
	{
		return ""FirstLine[""+physicalLine+','+scrollLine+','+skew+']';
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.IPropertyManager,1,1,0,10,1,0,10,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;



public interface IPropertyManager
{
	
	String getProperty(String name);
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.PluginManagerProgress,15,6,0,14,47,79,11,11,6,0.897959184,230,1.0,1,0.978947368,0.191666667,0,0,13.86666667,2,1.0,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.ProgressObserver;


class PluginManagerProgress extends JDialog implements ProgressObserver
{
	
	public PluginManagerProgress(PluginManager dialog, Roster roster)
	{
		super(dialog,jEdit.getProperty(""plugin-manager.progress""),true);

		this.roster = roster;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		progress = new JProgressBar();
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""plugin-manager.progress""));

		int maximum = 0;
		count = roster.getOperationCount();
		for(int i = 0; i < count; i++)
		{
			maximum += roster.getOperation(i).getMaximum();
		}

		progress.setMaximum(maximum);
		content.add(BorderLayout.NORTH,progress);

		stop = new JButton(jEdit.getProperty(""plugin-manager.progress.stop""));
		stop.addActionListener(new ActionHandler());
		JPanel panel = new JPanel(new FlowLayout(
			FlowLayout.CENTER,0,0));
		panel.add(stop);
		content.add(BorderLayout.CENTER,panel);

		addWindowListener(new WindowHandler());

		pack();
		setLocationRelativeTo(dialog);
		setVisible(true);
	} 

	

	
	public void setValue(final int value)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				progress.setValue(valueSoFar + value);
			}
		});
	} 

	
	
	public void setValue(final long value)
	{
		SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					progress.setValue(valueSoFar + (int) value);
				}
			});
	} 

	
	
	public void setMaximum(long value) 
	{
	} 

	
	
	 public void setStatus(String status) 
	 {
		 setTitle(status);
		 progress.setString(status);
	} 

	
	public void done()
	{
		try
		{
			if(done == count)
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						dispose();
					}
				});
			}
			else
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						valueSoFar += roster.getOperation(done - 1)
							.getMaximum();
						progress.setValue(valueSoFar);
						done++;
					}
				});
			}
		}
		catch(Exception e)
		{
		}
	} 

	

	
	private Thread thread;

	private JProgressBar progress;
	private JButton stop;
	private int count;
	private int done = 1;

	
	private int valueSoFar;

	private Roster roster;
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == stop)
			{
				thread.stop();
				dispose();
			}
		}
	} 

	
	class WindowHandler extends WindowAdapter
	{
		boolean done;

		public void windowOpened(WindowEvent evt)
		{
			if(done)
				return;

			done = true;
			thread = new RosterThread();
			thread.start();
		}

		public void windowClosing(WindowEvent evt)
		{
			thread.stop();
			dispose();
		}
	} 

	
	class RosterThread extends Thread
	{
		RosterThread()
		{
			super(""Plugin manager thread"");
		}

		public void run()
		{
			roster.performOperationsInWorkThread(PluginManagerProgress.this);
		}
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.BufferChangeAdapter,8,1,0,2,9,28,0,2,8,2.0,18,0.0,0,0.0,0.791666667,0,0,1.25,1,0.875,0,"

package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;


public abstract class BufferChangeAdapter implements BufferChangeListener
{
	
	
	public void foldLevelChanged(Buffer buffer, int start, int end)
	{
	} 

	
	
	public void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void preContentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void transactionComplete(Buffer buffer) {}
	

	
	
	public void foldHandlerChanged(Buffer buffer) {}
	

	
	
	public void bufferLoaded(Buffer buffer) {}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DynamicContextMenuService,2,1,0,2,3,1,1,1,2,2.0,5,0.0,0,0.0,0.666666667,0,0,1.5,1,0.5,0,"package org.gjt.sp.jedit.gui;

import java.awt.event.MouseEvent;

import javax.swing.JMenuItem;

import org.gjt.sp.jedit.textarea.JEditTextArea;


abstract public class DynamicContextMenuService {
	
	public abstract JMenuItem[] createMenu(JEditTextArea ta, MouseEvent evt); 

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.org.objectweb.asm.Constants,0,1,0,1,0,0,1,0,0,2.0,179,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.gjt.sp.jedit.bsh.org.objectweb.asm;



public interface Constants {

  

  int ACC_PUBLIC = 1;
  int ACC_PRIVATE = 2;
  int ACC_PROTECTED = 4;
  int ACC_STATIC = 8;
  int ACC_FINAL = 16;
  int ACC_SYNCHRONIZED = 32;
  int ACC_VOLATILE = 64;
  int ACC_TRANSIENT = 128;
  int ACC_NATIVE = 256;
  int ACC_INTERFACE = 512;
  int ACC_ABSTRACT = 1024;
  int ACC_STRICT = 2048;
  int ACC_SUPER = 32;

  int ACC_SYNTHETIC = 65536;
  int ACC_DEPRECATED = 131072;

  

  int T_BOOLEAN = 4;
  int T_CHAR = 5;
  int T_FLOAT = 6;
  int T_DOUBLE = 7;
  int T_BYTE = 8;
  int T_SHORT = 9;
  int T_INT = 10;
  int T_LONG = 11;

  

  int NOP = 0;                
  int ACONST_NULL = 1;        
  int ICONST_M1 = 2;          
  int ICONST_0 = 3;           
  int ICONST_1 = 4;           
  int ICONST_2 = 5;           
  int ICONST_3 = 6;           
  int ICONST_4 = 7;           
  int ICONST_5 = 8;           
  int LCONST_0 = 9;           
  int LCONST_1 = 10;          
  int FCONST_0 = 11;          
  int FCONST_1 = 12;          
  int FCONST_2 = 13;          
  int DCONST_0 = 14;          
  int DCONST_1 = 15;          
  int BIPUSH = 16;            
  int SIPUSH = 17;            
  int LDC = 18;               
  
  
  int ILOAD = 21;             
  int LLOAD = 22;             
  int FLOAD = 23;             
  int DLOAD = 24;             
  int ALOAD = 25;             
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  int IALOAD = 46;            
  int LALOAD = 47;            
  int FALOAD = 48;            
  int DALOAD = 49;            
  int AALOAD = 50;            
  int BALOAD = 51;            
  int CALOAD = 52;            
  int SALOAD = 53;            
  int ISTORE = 54;            
  int LSTORE = 55;            
  int FSTORE = 56;            
  int DSTORE = 57;            
  int ASTORE = 58;            
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  int IASTORE = 79;           
  int LASTORE = 80;           
  int FASTORE = 81;           
  int DASTORE = 82;           
  int AASTORE = 83;           
  int BASTORE = 84;           
  int CASTORE = 85;           
  int SASTORE = 86;           
  int POP = 87;               
  int POP2 = 88;              
  int DUP = 89;               
  int DUP_X1 = 90;            
  int DUP_X2 = 91;            
  int DUP2 = 92;              
  int DUP2_X1 = 93;           
  int DUP2_X2 = 94;           
  int SWAP = 95;              
  int IADD = 96;              
  int LADD = 97;              
  int FADD = 98;              
  int DADD = 99;              
  int ISUB = 100;             
  int LSUB = 101;             
  int FSUB = 102;             
  int DSUB = 103;             
  int IMUL = 104;             
  int LMUL = 105;             
  int FMUL = 106;             
  int DMUL = 107;             
  int IDIV = 108;             
  int LDIV = 109;             
  int FDIV = 110;             
  int DDIV = 111;             
  int IREM = 112;             
  int LREM = 113;             
  int FREM = 114;             
  int DREM = 115;             
  int INEG = 116;             
  int LNEG = 117;             
  int FNEG = 118;             
  int DNEG = 119;             
  int ISHL = 120;             
  int LSHL = 121;             
  int ISHR = 122;             
  int LSHR = 123;             
  int IUSHR = 124;            
  int LUSHR = 125;            
  int IAND = 126;             
  int LAND = 127;             
  int IOR = 128;              
  int LOR = 129;              
  int IXOR = 130;             
  int LXOR = 131;             
  int IINC = 132;             
  int I2L = 133;              
  int I2F = 134;              
  int I2D = 135;              
  int L2I = 136;              
  int L2F = 137;              
  int L2D = 138;              
  int F2I = 139;              
  int F2L = 140;              
  int F2D = 141;              
  int D2I = 142;              
  int D2L = 143;              
  int D2F = 144;              
  int I2B = 145;              
  int I2C = 146;              
  int I2S = 147;              
  int LCMP = 148;             
  int FCMPL = 149;            
  int FCMPG = 150;            
  int DCMPL = 151;            
  int DCMPG = 152;            
  int IFEQ = 153;             
  int IFNE = 154;             
  int IFLT = 155;             
  int IFGE = 156;             
  int IFGT = 157;             
  int IFLE = 158;             
  int IF_ICMPEQ = 159;        
  int IF_ICMPNE = 160;        
  int IF_ICMPLT = 161;        
  int IF_ICMPGE = 162;        
  int IF_ICMPGT = 163;        
  int IF_ICMPLE = 164;        
  int IF_ACMPEQ = 165;        
  int IF_ACMPNE = 166;        
  int GOTO = 167;             
  int JSR = 168;              
  int RET = 169;              
  int TABLESWITCH = 170;      
  int LOOKUPSWITCH = 171;     
  int IRETURN = 172;          
  int LRETURN = 173;          
  int FRETURN = 174;          
  int DRETURN = 175;          
  int ARETURN = 176;          
  int RETURN = 177;           
  int GETSTATIC = 178;        
  int PUTSTATIC = 179;        
  int GETFIELD = 180;         
  int PUTFIELD = 181;         
  int INVOKEVIRTUAL = 182;    
  int INVOKESPECIAL = 183;    
  int INVOKESTATIC = 184;     
  int INVOKEINTERFACE = 185;  
  
  int NEW = 187;              
  int NEWARRAY = 188;         
  int ANEWARRAY = 189;        
  int ARRAYLENGTH = 190;      
  int ATHROW = 191;           
  int CHECKCAST = 192;        
  int INSTANCEOF = 193;       
  int MONITORENTER = 194;     
  int MONITOREXIT = 195;      
  
  int MULTIANEWARRAY = 197;   
  int IFNULL = 198;           
  int IFNONNULL = 199;        
  
  
}
"
jEdit,4.3,org.gjt.sp.jedit.options.AppearanceOptionPane,7,6,0,11,56,13,1,11,1,0.784313725,522,0.941176471,2,0.992581602,0.5,2,4,71.14285714,7,2.8571,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;

import java.awt.event.*;
import java.io.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.gui.NumericTextField;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.IOUtilities;


public class AppearanceOptionPane extends AbstractOptionPane
{
	
	public static final String[] builtInIconThemes = {""tango"", ""old""};
	
	
	public AppearanceOptionPane()
	{
		super(""appearance"");
	} 

	
	@Override
	protected void _init()
	{
		
		addComponent(new JLabel(jEdit.getProperty(""options.appearance.lf.note"")));

		lfs = UIManager.getInstalledLookAndFeels();
		String[] names = new String[lfs.length];
		String lf = UIManager.getLookAndFeel().getClass().getName();
		int index = 0;
		for(int i = 0; i < names.length; i++)
		{
			names[i] = lfs[i].getName();
			if(lf.equals(lfs[i].getClassName()))
				index = i;
		}

		lookAndFeel = new JComboBox(names);
		lookAndFeel.setSelectedIndex(index);
		lookAndFeel.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				updateEnabled();
			}
		});

		
		addComponent(jEdit.getProperty(""options.appearance.lf""),
			lookAndFeel);
		addDockingFrameworkChooser();

		
		String[] themes = IconTheme.builtInNames();
		iconThemes = new JComboBox(themes);
		addComponent(jEdit.getProperty(""options.appearance.iconTheme""), iconThemes);
		oldTheme = IconTheme.get();
		for (int i=0; i<themes.length; ++i)
		{
			if (themes[i].equals(oldTheme))
			{
				iconThemes.setSelectedIndex(i);
				break;
			}
		}
		
		
		primaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.primary.font""));
		addComponent(jEdit.getProperty(""options.appearance.primaryFont""),
			primaryFont);

		
		secondaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.secondary.font""));
		addComponent(jEdit.getProperty(""options.appearance.secondaryFont""),
			secondaryFont);

		
		updateEnabled();

		
		history = new NumericTextField(jEdit.getProperty(""history""), true);
		addComponent(jEdit.getProperty(""options.appearance.history""),history);

		
		menuSpillover = new NumericTextField(jEdit.getProperty(""menu.spillover""), true);
		addComponent(jEdit.getProperty(""options.appearance.menuSpillover""),menuSpillover);

		continuousLayout = new JCheckBox(jEdit.getProperty(
			""options.appearance.continuousLayout.label""));
		continuousLayout.setSelected(jEdit.getBooleanProperty(""appearance.continuousLayout""));
		addComponent(continuousLayout);

		addSeparator(""options.appearance.startup.label"");

		
		showSplash = new JCheckBox(jEdit.getProperty(
			""options.appearance.showSplash""));
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			showSplash.setSelected(true);
		else
			showSplash.setSelected(!new File(settingsDirectory,""nosplash"").exists());
		addComponent(showSplash);

		
		showTips = new JCheckBox(jEdit.getProperty(
			""options.appearance.showTips""));
		showTips.setSelected(jEdit.getBooleanProperty(""tip.show""));
		addComponent(showTips);

		addSeparator(""options.appearance.experimental.label"");
		addComponent(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""options.appearance.experimental.caption"")));

		
		textColors = new JCheckBox(jEdit.getProperty(
			""options.appearance.textColors""));
		textColors.setSelected(jEdit.getBooleanProperty(""textColors""));
		addComponent(textColors);

		
		decorateFrames = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateFrames""));
		decorateFrames.setSelected(jEdit.getBooleanProperty(""decorate.frames""));
		addComponent(decorateFrames);

		
		decorateDialogs = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateDialogs""));
		decorateDialogs.setSelected(jEdit.getBooleanProperty(""decorate.dialogs""));
		addComponent(decorateDialogs);
	} 

	
	@Override
	protected void _save()
	{
		String lf = lfs[lookAndFeel.getSelectedIndex()].getClassName();
		jEdit.setProperty(""lookAndFeel"",lf);
		jEdit.setFontProperty(""metal.primary.font"",primaryFont.getFont());
		jEdit.setFontProperty(""metal.secondary.font"",secondaryFont.getFont());
		jEdit.setProperty(""history"",history.getText());
		jEdit.setProperty(""menu.spillover"",menuSpillover.getText());
		jEdit.setBooleanProperty(""tip.show"",showTips.isSelected());
		jEdit.setBooleanProperty(""appearance.continuousLayout"",continuousLayout.isSelected());
		IconTheme.set(iconThemes.getSelectedItem().toString());

		jEdit.setProperty(View.VIEW_DOCKING_FRAMEWORK_PROPERTY,
			(String) dockingFramework.getSelectedItem());

		

		
		
		
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			File file = new File(settingsDirectory,""nosplash"");
			if(showSplash.isSelected())
				file.delete();
			else
			{
				FileOutputStream out = null;
				try
				{
					out = new FileOutputStream(file);
					out.write('\n');
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}
				finally
				{
					IOUtilities.closeQuietly(out);
				}
			}
		}
		jEdit.setBooleanProperty(""textColors"",textColors.isSelected());
		jEdit.setBooleanProperty(""decorate.frames"",decorateFrames.isSelected());
		jEdit.setBooleanProperty(""decorate.dialogs"",decorateDialogs.isSelected());
	} 

	

	
	private String oldTheme;
	private UIManager.LookAndFeelInfo[] lfs;
	private JComboBox lookAndFeel;
	private FontSelector primaryFont;
	private FontSelector secondaryFont;
	private JComboBox dockingFramework;
	private JTextField history;
	private JTextField menuSpillover;
	private JCheckBox showTips;
	private JCheckBox continuousLayout;
	private JCheckBox showSplash;
	private JCheckBox textColors;
	private JCheckBox decorateFrames;
	private JCheckBox decorateDialogs;
	private JComboBox antiAliasExtras;
	private JComboBox iconThemes;
	

	
	private void updateEnabled()
	{
		String className = lfs[lookAndFeel.getSelectedIndex()]
			.getClassName();

		if(className.equals(""javax.swing.plaf.metal.MetalLookAndFeel"")
			|| className.equals(""com.incors.plaf.kunststoff.KunststoffLookAndFeel""))
		{
			primaryFont.setEnabled(true);
			secondaryFont.setEnabled(true);
		}
		else
		{
			primaryFont.setEnabled(false);
			secondaryFont.setEnabled(false);
		}
	} 
	private void addDockingFrameworkChooser()
	{	
		String [] frameworks =
			ServiceManager.getServiceNames(View.DOCKING_FRAMEWORK_PROVIDER_SERVICE);
		dockingFramework = new JComboBox(frameworks);
		String framework = View.getDockingFrameworkName();
		for (int i = 0; i < frameworks.length; i++)
		{
			if (frameworks[i].equals(framework))
			{
				dockingFramework.setSelectedIndex(i);
				break;
			}
		}
		addComponent(new JLabel(jEdit.getProperty(""options.appearance.selectFramework.label"")), dockingFramework);
	}

	
}
"
jEdit,4.3,org.gjt.sp.jedit.io.VFSManager,26,1,0,60,81,217,52,16,20,0.876363636,412,0.909090909,3,0.0,0.105,0,0,14.42307692,8,1.6154,0,"

package org.gjt.sp.jedit.io;


import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.awt.Frame;
import java.io.IOException;
import java.util.*;

import org.gjt.sp.jedit.gui.ErrorListDialog;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkThreadPool;
import org.gjt.sp.util.StandardUtilities;



public class VFSManager
{
	
	public static final String SERVICE = ""org.gjt.sp.jedit.io.VFS"";

	
	
	public static void init()
	{
		int count = jEdit.getIntegerProperty(""ioThreadCount"",4);
		ioThreadPool = new WorkThreadPool(""jEdit I/O"",count);
		JARClassLoader classLoader = new JARClassLoader();
		for(int i = 0; i < ioThreadPool.getThreadCount(); i++)
		{
			ioThreadPool.getThread(i).setContextClassLoader(
				classLoader);
		}
	} 

	
	
	public static void start()
	{
		ioThreadPool.start();
	} 

	

	
	
	public static VFS getFileVFS()
	{
		return fileVFS;
	} 

	
	
	public static VFS getUrlVFS()
	{
		return urlVFS;
	} 

	
	
	public static VFS getVFSByName(String name)
	{
		
		VFS vfs = (VFS)ServiceManager.getService(SERVICE,name);
		if(vfs == null)
			return vfsHash.get(name);
		else
			return vfs;
	} 

	
	
	public static VFS getVFSForProtocol(String protocol)
	{
		if(protocol.equals(""file""))
			return fileVFS;
		else
		{
			VFS vfs = (VFS)ServiceManager.getService(SERVICE,protocol);
			if(vfs == null)
				vfs = protocolHash.get(protocol);

			if(vfs != null)
				return vfs;
			else
				return urlVFS;
		}
	} 

	
	
	public static VFS getVFSForPath(String path)
	{
		if(MiscUtilities.isURL(path))
			return getVFSForProtocol(MiscUtilities.getProtocolOfURL(path));
		else
			return fileVFS;
	} 

	
	
	public static void registerVFS(String protocol, VFS vfs)
	{
		Log.log(Log.DEBUG,VFSManager.class,""Registered ""
			+ vfs.getName() + "" filesystem for ""
			+ protocol + "" protocol"");
		vfsHash.put(vfs.getName(),vfs);
		protocolHash.put(protocol,vfs);
	} 

	
	
	public static Enumeration<VFS> getFilesystems()
	{
		return vfsHash.elements();
	} 

	
	
	public static String[] getVFSs()
	{
		
		
		List<String> returnValue = new LinkedList<String>();
		String[] newAPI = ServiceManager.getServiceNames(SERVICE);
		if(newAPI != null)
		{
			for(int i = 0; i < newAPI.length; i++)
			{
				returnValue.add(newAPI[i]);
			}
		}
		Enumeration<String> oldAPI = vfsHash.keys();
		while(oldAPI.hasMoreElements())
			returnValue.add(oldAPI.nextElement());
		return returnValue.toArray(new String[returnValue.size()]);
	} 

	

	

	
	
	public static WorkThreadPool getIOThreadPool()
	{
		return ioThreadPool;
	} 

	
	
	public static void waitForRequests()
	{
		ioThreadPool.waitForRequests();
	} 

	
	
	public static boolean errorOccurred()
	{
		return error;
	} 

	
	
	public static int getRequestCount()
	{
		return ioThreadPool.getRequestCount();
	} 

	
	
	public static void runInAWTThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,true);
	} 

	
	
	public static void runInWorkThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,false);
	} 

	

	
	
	public static void error(IOException e, String path, Component comp)
	{
		Log.log(Log.ERROR,VFSManager.class,e);
		VFSManager.error(comp,path,""ioerror"",new String[] { e.toString() });
	} 

	
	
	public static void error(final Component comp, final String error, final Object[] args)
	{
		
		if(SwingUtilities.isEventDispatchThread())
		{
			GUIUtilities.error(comp,error,args);
			return;
		}

		
		
		
		
		
		
		VFSManager.error = true;

		runInAWTThread(new Runnable()
		{
			public void run()
			{
				VFSManager.error = false;

				if(comp == null || !comp.isShowing())
					GUIUtilities.error(null,error,args);
				else
					GUIUtilities.error(comp,error,args);
			}
		});
	} 

	
	
	public static void error(Component comp,
		final String path,
		String messageProp,
		Object[] args)
	{
		final Frame frame = JOptionPane.getFrameForComponent(comp);

		synchronized(errorLock)
		{
			error = true;

			errors.add(new ErrorListDialog.ErrorEntry(
				path,messageProp,args));

			if(errors.size() == 1)
			{
				

				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						String caption = jEdit.getProperty(
							""ioerror.caption"" + (errors.size() == 1
							? ""-1"" : """"),new Integer[] {
							Integer.valueOf(errors.size())});
						new ErrorListDialog(
							frame.isShowing()
							? frame
							: jEdit.getFirstView(),
							jEdit.getProperty(""ioerror.title""),
							caption,errors,false);
						errors.clear();
						error = false;
					}
				});
			}
		}
	} 

	
	
	public static void sendVFSUpdate(VFS vfs, String path, boolean parent)
	{
		if(parent)
		{
			sendVFSUpdate(vfs,vfs.getParentOfPath(path),false);
			sendVFSUpdate(vfs,path,false);
		}
		else
		{
			
			if(path.length() != 1 && (path.endsWith(""/"")
				|| path.endsWith(java.io.File.separator)))
				path = path.substring(0,path.length() - 1);

			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					VFSUpdate msg = vfsUpdates.get(i);
					if(msg.getPath().equals(path))
					{
						
						
						return;
					}
				}

				vfsUpdates.add(new VFSUpdate(path));

				if(vfsUpdates.size() == 1)
				{
					
					
					
					VFSManager.runInAWTThread(new SendVFSUpdatesSafely());
				}
			}
		}
	} 

	
	static class SendVFSUpdatesSafely implements Runnable
	{
		public void run()
		{
			synchronized(vfsUpdateLock)
			{
				
				
				
				
				
				Collections.sort(vfsUpdates,
					new StandardUtilities.StringCompare<VFSUpdate>()
				);
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					EditBus.send(vfsUpdates.get(i));
				}

				vfsUpdates.clear();
			}
		}
	} 

	

	
	private static WorkThreadPool ioThreadPool;
	private static VFS fileVFS;
	private static VFS urlVFS;
	private static final Hashtable<String, VFS> vfsHash;
	private static final Map<String, VFS> protocolHash;
	private static boolean error;
	private static final Object errorLock = new Object();
	private static final Vector<ErrorListDialog.ErrorEntry> errors;
	private static final Object vfsUpdateLock = new Object();
	private static final List<VFSUpdate> vfsUpdates;
	

	
	static
	{
		errors = new Vector<ErrorListDialog.ErrorEntry>();
		fileVFS = new FileVFS();
		urlVFS = new UrlVFS();
		vfsHash = new Hashtable<String, VFS>();
		protocolHash = new Hashtable<String, VFS>();
		vfsUpdates = new ArrayList<VFSUpdate>(10);
	} 

	private VFSManager() {}
	
}
"
jEdit,4.3,org.gjt.sp.util.ReadWriteLock,6,1,0,0,15,0,0,0,6,0.0,39,1.0,0,0.0,1.0,0,0,5.333333333,1,0.8333,0,"

package org.gjt.sp.util;

import java.util.concurrent.locks.ReentrantReadWriteLock;


public class ReadWriteLock
{
	
	public void readLock()
	{
		body.readLock().lock();
	} 

	
	public void readUnlock()
	{
		body.readLock().unlock();
	} 

	
	public void writeLock()
	{
		body.writeLock().lock();
	} 

	
	public void writeUnlock()
	{
		body.writeLock().unlock();
	} 

	
	public boolean isWriteLocked()
	{
		return body.isWriteLocked();
	} 

	
	private final ReentrantReadWriteLock body = new ReentrantReadWriteLock();
	
}
"
jEdit,4.3,org.gjt.sp.jedit.JEditBeanShellAction,9,2,0,16,23,16,7,9,8,0.805555556,189,1.0,3,0.416666667,0.270833333,1,1,19.0,6,1.4444,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.jedit.bsh.*;
import java.awt.Component;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.util.Log;


public class JEditBeanShellAction extends JEditAbstractEditAction<TextArea>
{
	
	public JEditBeanShellAction(String name, String code, String isSelected,
		boolean noRepeat, boolean noRecord, boolean noRememberLast)
	{
		super(name);

		this.code = code;
		this.isSelected = isSelected;
		this.noRepeat = noRepeat;
		this.noRecord = noRecord;
		this.noRememberLast = noRememberLast;

		
		sanitizedName = name.replace('.','_').replace('-','_');
	} 

	
	public void invoke(TextArea textArea)
	{
		try
		{
			if(cachedCode == null)
			{
				String cachedCodeName = ""action_"" + sanitizedName;
				cachedCode = bsh.cacheBlock(cachedCodeName,code,true);
			}

			bsh.runCachedBlock(cachedCode,textArea,
				new NameSpace(bsh.getNameSpace(),
				""BeanShellAction.invoke()""));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} 

	
	public boolean isSelected(Component comp)
	{
		if(isSelected == null)
			return false;

		NameSpace global = bsh.getNameSpace();

		try
		{
			if(cachedIsSelected == null)
			{
				String cachedIsSelectedName = ""selected_"" + sanitizedName;
				cachedIsSelected = bsh.cacheBlock(cachedIsSelectedName,
					isSelected,true);
			}

			
			
			global.setVariable(""_comp"",comp);

			return Boolean.TRUE.equals(bsh.runCachedBlock(
				cachedIsSelected,null,
				new NameSpace(bsh.getNameSpace(),
				""BeanShellAction.isSelected()"")));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			
			

			
			
			isSelected = null;

			return false;
		}
		finally
		{
			try
			{
				global.setVariable(""_comp"",null);
			}
			catch(UtilEvalError err)
			{
				Log.log(Log.ERROR,this,err);
			}
		}
	} 

	
	public boolean noRepeat()
	{
		return noRepeat;
	} 

	
	public boolean noRecord()
	{
		return noRecord;
	} 

	
	
	public boolean noRememberLast()
	{
		return noRememberLast;
	} 

	
	public String getCode()
	{
		return code.trim();
	} 

	
	private boolean noRepeat;
	private boolean noRecord;
	private boolean noRememberLast;
	private String code;
	private String isSelected;
	private BshMethod cachedCode;
	private BshMethod cachedIsSelected;
	private String sanitizedName;
	private static final BeanShellFacade<TextArea> bsh = new MyBeanShellFacade();
	
	
	
	private static class MyBeanShellFacade extends BeanShellFacade<TextArea>
	{
		@Override
		protected void setupDefaultVariables(NameSpace namespace, TextArea textArea) throws UtilEvalError 
		{
			if(textArea != null)
			{
				namespace.setVariable(""buffer"",textArea.getBuffer(), false);
				namespace.setVariable(""textArea"",textArea, false);
			}
		}

		@Override
		protected void resetDefaultVariables(NameSpace namespace) throws UtilEvalError
		{
			namespace.setVariable(""buffer"",null, false);
			namespace.setVariable(""textArea"",null, false);
		}

		@Override
		protected void handleException(TextArea textArea, String path, Throwable t)
		{
			Log.log(Log.ERROR,this, t, t);

		}
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.help.HelpHistoryModel,14,1,0,8,29,0,6,3,10,0.358974359,378,1.0,1,0.0,0.244897959,0,0,25.78571429,4,2.4286,0,"

package org.gjt.sp.jedit.help;

import java.net.URL;
import java.util.List;
import java.util.ArrayList;


public class HelpHistoryModel
{
	
	public HelpHistoryModel(int size)
	{
		history = new HistoryEntry[size];
		listeners = new ArrayList<HelpHistoryModelListener>();
	} 

	
	HistoryEntry forward(HelpViewer helpViewer)
	{
		if(history.length - historyPos <= 1)
		{
			return null;
		}
		if (history[historyPos] == null)
		{
			return null;
		}
		setCurrentScrollPosition(helpViewer.getCurrentPage(),helpViewer.getCurrentScrollPosition());
		HistoryEntry result = new HistoryEntry(history[historyPos]);
		historyPos++;
		fireUpdate();
		return result;
	} 

	
	public boolean hasNext()
	{
		return !((history.length - historyPos <= 1) ||
			 (history[historyPos] == null));
	} 

	
	HistoryEntry back(HelpViewer helpViewer)
	{
		if (historyPos <= 1)
		{
			return null;
		}
		setCurrentScrollPosition(helpViewer.getCurrentPage(),helpViewer.getCurrentScrollPosition());
		HistoryEntry result = new HistoryEntry(history[--historyPos - 1]);
		fireUpdate();
		return result;
	} 

	
	public boolean hasPrevious()
	{
		return (historyPos>1);
	} 

	
	public void addToHistory(String url)
	{
		history[historyPos] = new HistoryEntry(url,url,0);
		if(historyPos + 1 == history.length)
		{
			System.arraycopy(history,1,history,
					 0,history.length - 1);
			history[historyPos] = null;
		}
		else
		{
			historyPos++;
			for (int i = historyPos ; i<history.length ; i++)
			{
				history[i] = null;
			}
		}
		fireUpdate();
	} 

	
	public void setCurrentScrollPosition(URL currentPage, int scrollPosition)
	{
		if ((null != currentPage) && (historyPos >= 1) &&
		    (currentPage.toString().equals(history[historyPos-1].url)))
		{
			history[historyPos-1].scrollPosition = scrollPosition;
		}
	} 

	
	public void setCurrentEntry(HistoryEntry entry)
	{
		for (int i=0 ; i<history.length ; i++)
		{
			if ((history[i] != null) && (history[i].equals(entry)))
			{
				historyPos = i+1;
				fireUpdate();
				break;
			}
		}
		
	} 

	
	public void updateTitle(String url, String title)
	{
		for (int i=0;i<history.length;i++)
		{
			if ((history[i] != null) && history[i].url.equals(url))
			{
				history[i].title = title;
			}
		}
		fireUpdate();
	}

	
	HistoryEntry[] getPreviousURLs()
	{
		if (historyPos<=1)
		{
			return new HelpHistoryModel.HistoryEntry[0];
		}
		HistoryEntry[] previous = new HistoryEntry[historyPos-1];
		System.arraycopy(history,0,previous,0,historyPos-1);
		return previous;
	} 

	
	HistoryEntry[] getNextURLs()
	{
		if (history.length - historyPos <= 1)
		{
			return new HelpHistoryModel.HistoryEntry[0];
		}
		if (history[historyPos] == null)
		{
			return new HelpHistoryModel.HistoryEntry[0];
		}
		HistoryEntry[] next = new HistoryEntry[history.length-historyPos];
		System.arraycopy(history,historyPos,next,0,history.length-historyPos);
		return next;
	} 

	
	public void addHelpHistoryModelListener(HelpHistoryModelListener hhml)
	{
		listeners.add(hhml);
	} 

	
	public void removeHelpHistoryModelListener(HelpHistoryModelListener hhml)
	{
		listeners.remove(hhml);
	} 

	
	public void fireUpdate()
	{
		for (int i=0 ; i<listeners.size() ; i++)
		{
			listeners.get(i).historyUpdated();
		}
	} 

	
	private int historyPos;
	private HistoryEntry[] history;
	private List<HelpHistoryModelListener> listeners;
	

	

	
	static class HistoryEntry
	{
		String url;
		String title;
		int scrollPosition;

		
		HistoryEntry(String url, String title)
		{
			this(url,title,0);
		} 

		
		HistoryEntry(HistoryEntry original)
		{
			this(original.url,original.title,original.scrollPosition);
		} 

		
		HistoryEntry(String url, String title, int scrollPosition)
		{
			this.url = url;
			this.title = title;
			this.scrollPosition = scrollPosition;
		} 

		
		public boolean equals(HistoryEntry he)
		{
			return he.url.equals(this.url) &&
			       he.title.equals(this.title) &&
			       (he.scrollPosition == scrollPosition);
		} 

		
		public String toString()
		{
			return getClass().getName() + ""[url="" + url + "",title="" + title
			+ "",scrollPosition="" + scrollPosition + ']';
		} 
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.MirrorListHandler,10,2,0,4,27,21,1,4,6,0.765432099,220,1.0,2,0.653846154,0.316666667,1,2,20.1,5,1.6,0,"

package org.gjt.sp.jedit.pluginmgr;

import java.util.*;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.util.XMLUtilities;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.options.PluginOptions;


class MirrorListHandler extends DefaultHandler
{
	
	MirrorListHandler(MirrorList mirrors, String path)
	{
		this.mirrors = mirrors;
		this.path = path;
	} 

	
	public InputSource resolveEntity(String publicId, String systemId)
	{
		return XMLUtilities.findEntity(systemId, ""mirrors.dtd"",
					PluginOptions.class);
	} 

	
	public void characters(char[] c, int off, int len)
	{
		String tag = peekElement();

		if(tag == ""DESCRIPTION"")
			description.append(c, off, len);
		else if(tag == ""LOCATION"")
			location.append(c, off, len);
		else if(tag == ""COUNTRY"")
			country.append(c, off, len);
		else if(tag == ""CONTINENT"")
			continent.append(c, off, len);
	} 

	
	public void startElement(String uri, String localName,
				 String tag, Attributes attrs)
	{
		tag = pushElement(tag);

		if (tag.equals(""MIRROR""))
		{
			mirror = new MirrorList.Mirror();
			id = attrs.getValue(""ID"");
		}
	} 

	
	public void endElement(String uri, String localName, String tag)
	{
		popElement();

		if(tag.equals(""MIRROR""))
		{
			mirror.id = id;
			mirror.description = description.toString();
			mirror.location = location.toString();
			mirror.country = country.toString();
			mirror.continent = continent.toString();
			mirrors.add(mirror);
			description.setLength(0);
			location.setLength(0);
			country.setLength(0);
			continent.setLength(0);
		}
	} 

	
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, this, e);
		}
	} 

	
	public void endDocument()
	{
		mirrors.finished();
	} 

	

	
	private String id;
	private final StringBuilder description = new StringBuilder();
	private final StringBuilder location = new StringBuilder();
	private final StringBuilder country = new StringBuilder();
	private final StringBuilder continent = new StringBuilder();

	private final MirrorList mirrors;
	private MirrorList.Mirror mirror;

	private final Stack<String> stateStack = new Stack<String>();
	private final String path;
	

	private String pushElement(String name)
	{
		name = name == null ? null : name.intern();
		stateStack.push(name);
		return name;
	}

	private String peekElement()
	{
		return stateStack.peek();
	}

	private void popElement()
	{
		stateStack.pop();
	}

	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.MouseHandler,3,4,0,15,53,0,1,14,3,0.0,285,1.0,1,0.916666667,0.666666667,1,7,93.66666667,22,10.6667,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.event.*;

import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.Registers;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.jedit.msg.PositionChanging;



public class MouseHandler extends TextAreaMouseHandler
{
	
	public MouseHandler(JEditTextArea textArea)
	{
		super(textArea);
		this.textArea = textArea;
	} 

	
	@Override
	public void mousePressed(MouseEvent evt)
	{
		showCursor();

		control = (OperatingSystem.isMacOS() && evt.isMetaDown())
			|| (!OperatingSystem.isMacOS() && evt.isControlDown());

		ctrlForRectangularSelection = textArea.isCtrlForRectangularSelection();

		
		
		textArea.getInputHandler().resetLastActionCount();

		quickCopyDrag = (textArea.isQuickCopyEnabled() &&
			isMiddleButton(evt.getModifiers()));

		if(!quickCopyDrag)
		{
			textArea.requestFocus();
			TextArea.focusedComponent = textArea;
		}

		if(textArea.getBuffer().isLoading())
			return;
		EditBus.send(new PositionChanging(textArea));
		int x = evt.getX();
		int y = evt.getY();

		dragStart = textArea.xyToOffset(x,y,
			!(textArea.getPainter().isBlockCaretEnabled()
			|| textArea.isOverwriteEnabled()));
		dragStartLine = textArea.getLineOfOffset(dragStart);
		dragStartOffset = dragStart - textArea.getLineStartOffset(
			dragStartLine);

		if(isPopupTrigger(evt)
			&& textArea.getRightClickPopup() != null)
		{
			if(textArea.isRightClickPopupEnabled())
				textArea.handlePopupTrigger(evt);
			return;
		}

		dragged = false;

		textArea.blink = true;
		textArea.invalidateLine(textArea.getCaretLine());

		clickCount = evt.getClickCount();

		if(textArea.isDragEnabled()
			&& textArea.selectionManager.insideSelection(x,y)
			&& clickCount == 1 && !evt.isShiftDown())
		{
			maybeDragAndDrop = true;

			textArea.moveCaretPosition(dragStart,false);
			return;
		}

		maybeDragAndDrop = false;

		if(quickCopyDrag)
		{
			
			doSingleClick(evt);
		}
		else
		{
			switch(clickCount)
			{
			case 1:
				doSingleClick(evt);
				break;
			case 2:
				doDoubleClick();
				break;
			default: 
				doTripleClick();
				break;
			}
		}
	} 

	
	@Override
	public void mouseReleased(MouseEvent evt)
	{
		
		
		Selection sel = textArea.getSelectionAtOffset(dragStart);
		if(dragged && sel != null)
		{
			Registers.setRegister('%',textArea.getSelectedText(sel));
			if(quickCopyDrag)
			{
				textArea.removeFromSelection(sel);
				Registers.paste(TextArea.focusedComponent,
					'%',sel instanceof Selection.Rect);

				TextArea.focusedComponent.requestFocus();
			}
		}
		else if(!dragged && textArea.isQuickCopyEnabled() &&
			isMiddleButton(evt.getModifiers()))
		{
			textArea.requestFocus();
			TextArea.focusedComponent = textArea;

			textArea.setCaretPosition(dragStart,false);
			if(!textArea.isEditable())
				textArea.getToolkit().beep();
			else
				Registers.paste(textArea,'%',control);
		}
		else if(maybeDragAndDrop
			&& !textArea.isMultipleSelectionEnabled())
		{
			textArea.selectNone();
		}

		maybeDragAndDrop = false;
		dragged = false;
	} 

	
	private JEditTextArea textArea;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.BufferSegment,8,1,0,1,14,8,1,0,6,0.071428571,178,1.0,1,0.0,0.425,0,0,20.75,6,1.875,0,"

package org.gjt.sp.jedit.buffer;


class BufferSegment implements CharSequence
{

	public BufferSegment(char[] data,
			     int offset,
			     int len)
	{
		this(data,offset,len,null);
	}

	public BufferSegment(char[] data,
			      int offset,
			      int len,
			      BufferSegment next)
	{
		this.data = data;
		this.offset = offset;
		this.len = len;
		this.next = next;
	}

	public char charAt(int index)
	{
		if (index < len)
			return data[offset+index];
		else if (next != null)
			return next.charAt(index-len);
		else
			throw new ArrayIndexOutOfBoundsException(index);
	}

	public int length()
	{
		return len + ((next != null) ? next.length() : 0);
	}

	public CharSequence subSequence(int start,
					int end)
	{
		return subSegment(start, end);
	}

	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		toString(sb);
		return sb.toString();
	}

	private void toString(StringBuilder sb)
	{
		sb.append(data,offset,len);
		if (next != null)
			next.toString(sb);
	}

	private BufferSegment subSegment(int start,
					int end)
	{
		if (0 <= start && start <= end)
			if (end <= len)
				return new BufferSegment(data,offset+start,
					end-start);
			else if (next != null)
				if (start < len)
					return new BufferSegment(data,
						offset+start,len-start,
						next.subSegment(0,end-len));
				else
					return next.subSegment(start-len,
						end-len);
			else
				throw new ArrayIndexOutOfBoundsException();
		else
			throw new ArrayIndexOutOfBoundsException();
	}

	private final char[] data;
	private final int offset;
	private final int len;
	private final BufferSegment next;
}

"
jEdit,4.3,org.gjt.sp.jedit.syntax.DisplayTokenHandler,8,2,0,8,19,10,2,6,4,0.766233766,378,0.909090909,2,0.533333333,0.284090909,1,3,44.875,11,3.75,0,"

package org.gjt.sp.jedit.syntax;


import org.gjt.sp.jedit.buffer.JEditBuffer;

import javax.swing.text.*;
import java.awt.font.*;
import java.util.List;



public class DisplayTokenHandler extends DefaultTokenHandler
{
	
	public static final int MAX_CHUNK_LEN = 100;

	
	
	public void init(SyntaxStyle[] styles,
		FontRenderContext fontRenderContext,
		TabExpander expander, List<Chunk> out,
		float wrapMargin)
	{
		super.init();

		x = 0.0f;

		this.styles = styles;
		this.fontRenderContext = fontRenderContext;
		this.expander = expander;

		
		if(wrapMargin != 0.0f)
			this.wrapMargin = wrapMargin += 2.0f;
		else
			this.wrapMargin = 0.0f;

		this.out = out;

		seenNonWhitespace = false;
		endX = endOfWhitespace = 0.0f;
		end = null;
	} 

	
	
	public List<Chunk> getChunkList()
	{
		return out;
	} 

	
	
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		if(id == Token.END)
		{
			if(firstToken != null)
				out.add(merge((Chunk)firstToken,seg));
			return;
		}

		for(int splitOffset = 0; splitOffset < length; splitOffset += MAX_CHUNK_LEN)
		{
			int splitLength = Math.min(length - splitOffset,MAX_CHUNK_LEN);
			Chunk chunk = createChunk(id,offset + splitOffset,splitLength,context);
			addToken(chunk,context);

			if(wrapMargin != 0.0f)
			{
				initChunk(chunk,seg);
				x += chunk.width;

				if(Character.isWhitespace(seg.array[
					seg.offset + chunk.offset]))
				{
					if(seenNonWhitespace)
					{
						end = lastToken;
						endX = x;
					}
					else
						endOfWhitespace = x;
				}
				else
				{
					if(x > wrapMargin
						&& end != null
						&& seenNonWhitespace)
					{
						Chunk nextLine = new Chunk(endOfWhitespace,
							end.offset + end.length,
							getParserRuleSet(context));
						initChunk(nextLine,seg);

						nextLine.next = end.next;
						end.next = null;

						if(firstToken != null)
							out.add(merge((Chunk)firstToken,seg));

						firstToken = nextLine;

						x = x - endX + endOfWhitespace;

						end = null;
						endX = x;
					}

					seenNonWhitespace = true;
				}
			}
		}
	} 

	

	
	private SyntaxStyle[] styles;
	private FontRenderContext fontRenderContext;
	private TabExpander expander;
	private float x;

	private List<Chunk> out;
	private float wrapMargin;
	private float endX;
	private Token end;

	private boolean seenNonWhitespace;
	private float endOfWhitespace;
	

	
	private Chunk createChunk(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		return new Chunk(id,offset,length,
			getParserRuleSet(context),styles,
			context.rules.getDefault());
	} 

	
	protected void initChunk(Chunk chunk, Segment seg)
	{
		chunk.init(seg,expander,x,fontRenderContext);
	} 

	
	private Chunk merge(Chunk first, Segment seg)
	{
		if(first == null)
			return null;

		Chunk chunk = first;
		while(chunk.next != null)
		{
			Chunk next = (Chunk)chunk.next;
			if(canMerge(chunk,next,seg))
			{
				
				chunk.initialized = false;
				chunk.length += next.length;
				chunk.width += next.width;
				chunk.next = next.next;
			}
			else
			{
				if(!chunk.initialized)
				{
					initChunk(chunk,seg);
					if(wrapMargin == 0.0f)
						x += chunk.width;
				}
				chunk = next;
			}
		}

		if(!chunk.initialized)
			initChunk(chunk,seg);

		return first;
	} 

	
	private static boolean canMerge(Chunk c1, Chunk c2, Segment seg)
	{
		if(!c1.accessable || !c2.accessable)
			return false;

		char ch1 = seg.array[seg.offset + c1.offset];
		char ch2 = seg.array[seg.offset + c2.offset];

		return ((c1.style == c2.style)
			&& ch1 != '\t' && ch2 != '\t'
			&& (c1.length + c2.length <= MAX_CHUNK_LEN));
	} 

	
}
"
jEdit,4.3,org.gjt.sp.jedit.RegisterSaver,2,1,0,3,2,1,3,0,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.gjt.sp.jedit;


public interface RegisterSaver
{
	void loadRegisters();

	void saveRegisters();
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.VFSDirectoryEntryTable,20,5,0,27,144,154,13,22,11,0.855263158,1034,0.75,2,0.979214781,0.157894737,3,12,50.3,40,4.25,0,"

package org.gjt.sp.jedit.browser;


import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.*;
import java.util.LinkedList;
import java.util.Set;

import org.gjt.sp.jedit.browser.VFSDirectoryEntryTableModel.Entry;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSFile;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.VFSPathSelected;
import org.gjt.sp.jedit.ActionContext;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;



public class VFSDirectoryEntryTable extends JTable
{
	
	VFSDirectoryEntryTable(BrowserView browserView)
	{
		super(new VFSDirectoryEntryTableModel());
		this.browserView = browserView;
		setShowGrid(false);

		setIntercellSpacing(new Dimension(0,0));

		setDefaultRenderer(Entry.class,
			renderer = new FileCellRenderer());

		header = getTableHeader();
		header.setReorderingAllowed(false);
		addMouseListener(new MainMouseHandler());
		header.addMouseListener(new MouseHandler());
		header.setDefaultRenderer(new HeaderRenderer(
			(DefaultTableCellRenderer)header.getDefaultRenderer()));

		setRowSelectionAllowed(true);

		getColumnModel().addColumnModelListener(new ColumnHandler());

		setAutoResizeMode(AUTO_RESIZE_OFF);
	} 

	
	public boolean selectFile(String path)
	{
		for(int i = 0; i < getRowCount(); i++)
		{
			Entry entry = (Entry) getValueAt(i,1);
			if(entry.dirEntry.getPath().equals(path))
			{
				setSelectedRow(i);
				return true;
			}
		}

		return false;
	} 

	
	public void doTypeSelect(String str, boolean dirsOnly)
	{
		if(str.length() == 0)
			clearSelection();
		else if(getSelectedRow() == -1)
			doTypeSelect(str,0,getRowCount(),dirsOnly);
		else
		{
			int start = getSelectionModel().getMaxSelectionIndex();
			boolean retVal = doTypeSelect(str,start,getRowCount(),
				dirsOnly);

			if(!retVal)
			{
				
				
				doTypeSelect(str,0,start,dirsOnly);
			}
		}
	} 

	
	public VFSFile[] getSelectedFiles()
	{
		VFSDirectoryEntryTableModel model
			= (VFSDirectoryEntryTableModel)getModel();

		java.util.List<VFSFile> returnValue = new LinkedList<VFSFile>();
		int[] selectedRows = getSelectedRows();
		for(int i = 0; i < selectedRows.length; i++)
		{
			returnValue.add(model.files[selectedRows[i]].dirEntry);
		}
		return returnValue.toArray(new VFSFile[returnValue.size()]);
	} 

	
	public void getExpandedDirectories(Set<String> set)
	{
		VFSDirectoryEntryTableModel model
			= (VFSDirectoryEntryTableModel)getModel();

		if(model.files != null)
		{
			for(int i = 0; i < model.files.length; i++)
			{
				if(model.files[i].expanded)
					set.add(model.files[i].dirEntry.getPath());
			}
		}
	} 

	
	public void toggleExpanded(final int row)
	{
		VFSDirectoryEntryTableModel model
		= (VFSDirectoryEntryTableModel)getModel();

		Entry entry = model.files[row];
		if(entry.dirEntry.getType() == VFSFile.FILE)
			return;

		if(entry.expanded)
		{
			model.collapse(VFSManager.getVFSForPath(
				entry.dirEntry.getPath()),row);
			resizeColumns();
		}
		else
		{
			browserView.clearExpansionState();
			browserView.loadDirectory(entry,entry.dirEntry.getPath(),
				false);
		}

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setSelectedRow(row);
			}
		});
	} 

	
	public void setDirectory(VFS vfs, Object node, java.util.List<VFSFile> list,
		Set<String> tmpExpanded)
	{
		timer.stop();
		typeSelectBuffer.setLength(0);

		VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)getModel();
		int startIndex;
		if(node == null)
		{
			startIndex = 0;
			model.setRoot(vfs,list);
		}
		else
		{
			startIndex =
				model.expand(
				vfs,
				(Entry)node,
				list);
			startIndex++;
		}

		for(int i = 0; i < list.size(); i++)
		{
			Entry e = model.files[startIndex + i];
			String path = e.dirEntry.getPath();
			if(tmpExpanded.contains(path))
			{
				browserView.loadDirectory(e,path,false);
				tmpExpanded.remove(path);
			}
		}

		resizeColumns();
	} 

	
	public void maybeReloadDirectory(String path)
	{
		VFSDirectoryEntryTableModel model
		= (VFSDirectoryEntryTableModel)getModel();

		for(int i = 0; i < model.files.length; i++)
		{
			Entry e = model.files[i];
			if(!e.expanded || e.dirEntry.getType() == VFSFile.FILE)
				continue;

			VFSFile dirEntry = e.dirEntry;
			
			String otherPath;
			if(dirEntry.getSymlinkPath() == null)
				otherPath = dirEntry.getPath();
			else
				otherPath = dirEntry.getSymlinkPath();
			if(MiscUtilities.pathsEqual(path,otherPath))
			{
				browserView.saveExpansionState();
				browserView.loadDirectory(e,path,false);
				return;
			}
		}
	} 

	
	public void propertiesChanged()
	{
		renderer.propertiesChanged();

		VFSFile template = new VFSFile(
			""foo"",""foo"",""foo"",VFSFile.FILE,0L,false);
		setRowHeight(renderer.getTableCellRendererComponent(
			this,new Entry(template,0),
			false,false,0,0).getPreferredSize().height);
		Dimension prefSize = getPreferredSize();
		setPreferredScrollableViewportSize(new Dimension(prefSize.width,
			getRowHeight() * 12));
	} 

	
	@Override
	public void scrollRectToVisible(Rectangle rect)
	{
		
		rect.width = 0;
		super.scrollRectToVisible(rect);
	} 

	
	@Override
	public void processKeyEvent(KeyEvent evt)
	{
		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			VFSDirectoryEntryTableModel model =
				(VFSDirectoryEntryTableModel)getModel();
			int row = getSelectedRow();
			ActionContext ac = VFSBrowser.getActionContext();
			ActionContext jac = jEdit.getActionContext();
			EditAction browserUp = ac.getAction(""vfs.browser.up"");			
			VFSBrowser browser = browserView.getBrowser();
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_LEFT:
				evt.consume();
				if ((evt.getModifiers() & InputEvent.ALT_MASK)>0)
				{
					browser.previousDirectory();
				}
				else 
				{
					if(row != -1)
					{
						if(model.files[row].expanded)
						{
							toggleExpanded(row);
							return;
						}

						for(int i = row - 1; i >= 0; i--)
						{
							if(model.files[i].expanded &&
							   model.files[i].level < model.files[row].level)
							{
								setSelectedRow(i);
								return;
							}
						}
					}

					String dir = browserView.getBrowser()
						.getDirectory();
					dir = MiscUtilities.getParentOfPath(dir);
					browserView.getBrowser().setDirectory(dir);
				}
				break;
			case KeyEvent.VK_TAB:
				evt.consume();
				if ((evt.getModifiers() & InputEvent.SHIFT_MASK) > 0)
				{
					browserView.getParentDirectoryList().requestFocus();
				}
				else
				{
					browser.focusOnDefaultComponent();	
				}
				break;
			case KeyEvent.VK_BACK_SPACE:
				evt.consume();
				ac.invokeAction(evt, browserUp);
				break;
			case KeyEvent.VK_UP:
				if ((evt.getModifiers() & InputEvent.ALT_MASK) >0)
				{
					evt.consume();
					ac.invokeAction(evt, browserUp);
				}
				break;
			case KeyEvent.VK_DELETE:
				evt.consume();
				EditAction deleteAct = ac.getAction(""vfs.browser.delete"");
				ac.invokeAction(evt, deleteAct);
				break;
			case KeyEvent.VK_N:
				if ((evt.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK)
				{
					evt.consume();
					EditAction ea = ac.getAction(""vfs.browser.new-file"");
					ac.invokeAction(evt, ea);
				}
				break;
			case KeyEvent.VK_INSERT:
				evt.consume();
				EditAction newDir = ac.getAction(""vfs.browser.new-directory"");
				ac.invokeAction(evt, newDir);
				break;
			case KeyEvent.VK_ESCAPE:
				EditAction cda = jac.getAction(""close-docking-area"");
				cda.invoke(jEdit.getActiveView());
				evt.consume();
				break;
			case KeyEvent.VK_F2:
				EditAction ren = ac.getAction(""vfs.browser.rename"");
				evt.consume();
				ac.invokeAction(evt, ren);
				break;
			case KeyEvent.VK_F5:
				evt.consume();
				EditAction reload= ac.getAction(""vfs.browser.reload"");
				ac.invokeAction(evt, reload);
				break;
			case KeyEvent.VK_F6:
			case KeyEvent.VK_RIGHT:
				evt.consume();
				if ((evt.getModifiers() & InputEvent.ALT_MASK)>0)
				{
					browser.nextDirectory();
				}
				else if(row != -1)
				{
					if(!model.files[row].expanded)
						toggleExpanded(row);
				}
				break;
			case KeyEvent.VK_ENTER:
				evt.consume();
				browserView.getBrowser().filesActivated(
					evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN,false);

				break;
			}
		}
		else if(evt.getID() == KeyEvent.KEY_TYPED)
		{

			if(evt.isControlDown() || evt.isAltDown()
				|| evt.isMetaDown())
			{
				evt.consume();
				return;
			}

			
			if(evt.isShiftDown() && evt.getKeyChar() == '\n')
			{
				evt.consume();
				return;
			}


			VFSBrowser browser = browserView.getBrowser();

			switch(evt.getKeyChar())
			{
			case '~':
				evt.consume();
				if(browser.getMode() == VFSBrowser.BROWSER)
					browser.setDirectory(System.getProperty(
						""user.home""));
				break;
			case '/':
				evt.consume();
				if(browser.getMode() == VFSBrowser.BROWSER)
					browser.rootDirectory();
				break;
			case '-':
				evt.consume();
				if(browser.getMode() == VFSBrowser.BROWSER)
				{
					browser.setDirectory(
						browser.getView().getBuffer()
						.getDirectory());
				}
				break;
			default:
				evt.consume();
				typeSelectBuffer.append(evt.getKeyChar());
				doTypeSelect(typeSelectBuffer.toString(),
					browser.getMode() == VFSBrowser
					.CHOOSE_DIRECTORY_DIALOG);

				timer.stop();
				timer.setInitialDelay(750);
				timer.setRepeats(false);
				timer.start();
				return;
			}
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	
	public void setSelectedRow(int row)
	{
		getSelectionModel().setSelectionInterval(row,row);
		scrollRectToVisible(getCellRect(row,0,true));
	} 

	
	private final BrowserView browserView;
	private final JTableHeader header;
	private final FileCellRenderer renderer;
	private final StringBuffer typeSelectBuffer = new StringBuffer();
	private final Timer timer = new Timer(0,new ClearTypeSelect());
	private boolean resizingColumns;

	
	private boolean doTypeSelect(String str, int start, int end,
		boolean dirsOnly)
	{
		VFSFile[] files = ((VFSDirectoryEntryTableModel)
			getModel()).getFiles();

		int index = VFSFile.findCompletion(files,start,end,str,dirsOnly);
		if(index != -1)
		{
			setSelectedRow(index);
			return true;
		}
		else
			return false;
	} 

	
	private void resizeColumns()
	{
		VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)getModel();

		FontRenderContext fontRenderContext = new FontRenderContext(
			null,false,false);
		int[] widths = new int[model.getColumnCount()];
		for(int i = 0; i < widths.length; i++)
		{
			String columnName = model.getColumnName(i);
			if(columnName != null)
			{
				widths[i] = (int)renderer.plainFont
					.getStringBounds(columnName,
					fontRenderContext).getWidth();
			}
		}

		for(int i = 1; i < widths.length; i++)
		{
			
			widths[i] = Math.max(widths[i],model.getColumnWidth(i));
		}

		for(int i = 0; i < model.files.length; i++)
		{
			Entry entry = model.files[i];
			Font font = entry.dirEntry.getType()
				== VFSFile.FILE
				? renderer.plainFont : renderer.boldFont;

			widths[0] = Math.max(widths[0],renderer.getEntryWidth(
				entry,font,fontRenderContext));
		}

		widths[0] += 10;

		TableColumnModel columns = getColumnModel();

		try
		{
			resizingColumns = true;
			for(int i = 0; i < widths.length; i++)
			{
				columns.getColumn(i).setPreferredWidth(widths[i]);
				columns.getColumn(i).setWidth(widths[i]);
			}
		}
		finally
		{
			resizingColumns = false;
		}

		doLayout();
	} 

	
	private void saveWidths()
	{
		if(resizingColumns)
			return;

		VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)getModel();
		TableColumnModel columns = getColumnModel();

		for(int i = 1; i < model.getColumnCount(); i++)
			model.setColumnWidth(i,columns.getColumn(i).getWidth());
	} 

	

	
	class ClearTypeSelect implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			typeSelectBuffer.setLength(0);
		}
	} 

	
	class ColumnHandler implements TableColumnModelListener
	{
		public void columnAdded(TableColumnModelEvent e) {}
		public void columnRemoved(TableColumnModelEvent e) {}
		public void columnMoved(TableColumnModelEvent e) {}
		public void columnSelectionChanged(ListSelectionEvent e) {}

		public void columnMarginChanged(ChangeEvent e)
		{
			saveWidths();
		}
	} 

	
	class MainMouseHandler extends MouseInputAdapter
	{

		@Override
		public void mouseClicked(MouseEvent e)
		{
			super.mouseClicked(e);
			int ind = getSelectionModel().getMinSelectionIndex();
			Entry node = (Entry) getModel().getValueAt(ind, 0);
			boolean isDir = node.dirEntry.getType() == VFSFile.DIRECTORY;
			EditBus.send(new VFSPathSelected(jEdit.getActiveView(),
							 node.dirEntry.getPath(), isDir));
		}

	} 

	
	class MouseHandler extends MouseInputAdapter
	{
		@Override
		public void mousePressed(MouseEvent evt)
		{
			
			if (evt.getSource() == header && evt.getClickCount() == 2)
			{
				VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel) header.getTable().getModel();
				TableColumnModel columnModel = header.getColumnModel();
				int viewColumn = columnModel.getColumnIndexAtX(evt.getX());
				int column = columnModel.getColumn(viewColumn).getModelIndex();
				saveWidths();
				if(model.sortByColumn(column))
				{
					resizeColumns();
					Log.log(Log.DEBUG,this,""VFSDirectoryEntryTable sorted by ""
					+ model.getColumnName(column)
					+ (model.getAscending() ? "" ascending"" : "" descending"") );
				}
			}
		}
	} 

	
	static class HeaderRenderer extends DefaultTableCellRenderer
	{
		private final DefaultTableCellRenderer tcr;

		HeaderRenderer(DefaultTableCellRenderer tcr)
		{
			this.tcr = tcr;
		}

		@Override
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			JLabel l = (JLabel)tcr.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
			VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)table.getModel();
			Icon icon = column == model.getSortColumn()
				? model.getAscending() ? ASC_ICON : DESC_ICON
				: null;
			l.setIcon(icon);
			
			return l;
		}
	} 

	

	static final Icon ASC_ICON  = GUIUtilities.loadIcon(""arrow-asc.png"");
	static final Icon DESC_ICON = GUIUtilities.loadIcon(""arrow-desc.png"");

	

}
"
jEdit,4.3,org.gjt.sp.util.ProgressObserver,3,1,0,10,3,3,10,0,3,2.0,3,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.util;


public interface ProgressObserver
{
	
	void setValue(long value);
	 
	
	void setMaximum(long value);
	 
	
	void setStatus(String status);
}
"
jEdit,4.3,org.gjt.sp.jedit.options.EncodingsOptionPane,6,6,0,9,58,5,2,9,1,0.771428571,357,1.0,1,0.992581602,0.5,4,12,57.33333333,7,2.1667,0,"

package org.gjt.sp.jedit.options;


import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;
import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.border.TitledBorder;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.gui.JCheckBoxList;
import org.gjt.sp.jedit.gui.JCheckBoxList.Entry;
import org.gjt.sp.util.StandardUtilities;
import static java.awt.GridBagConstraints.BOTH;
import static java.util.Arrays.sort;
import static javax.swing.Box.createHorizontalBox;
import static javax.swing.Box.createHorizontalStrut;
import static org.gjt.sp.jedit.jEdit.getBooleanProperty;
import static org.gjt.sp.jedit.jEdit.getProperty;
import static org.gjt.sp.jedit.jEdit.setBooleanProperty;
import static org.gjt.sp.jedit.jEdit.unsetProperty;
import static org.gjt.sp.jedit.MiscUtilities.getEncodings;




public class EncodingsOptionPane extends AbstractOptionPane
{
	
	private JComboBox defaultEncoding;
	private JCheckBox encodingAutodetect;
	private JTextField encodingDetectors;
	private JTextField fallbackEncodings;
	
	private JCheckBoxList encodingsList;
	private JButton selectAllButton;
	private JButton selectNoneButton;
	

	
	public EncodingsOptionPane()
	{
		super(""encodings"");
	} 

	
	@Override
	protected void _init()
	{
		
		String[] encodings = getEncodings(true);
		sort(encodings,new StandardUtilities.StringCompare<String>(true));
		defaultEncoding = new JComboBox(encodings);
		defaultEncoding.setEditable(true);
		defaultEncoding.setSelectedItem(jEdit.getProperty(""buffer.""+JEditBuffer.ENCODING,
			System.getProperty(""file.encoding"")));
		addComponent(jEdit.getProperty(""options.general.encoding""),defaultEncoding);

		
		encodingAutodetect = new JCheckBox(jEdit.getProperty(
			""options.general.encodingAutodetect""));
		encodingAutodetect.setSelected(jEdit.getBooleanProperty(
			""buffer.encodingAutodetect""));
		addComponent(encodingAutodetect,BOTH);
		
		
		encodingDetectors = new JTextField(jEdit.getProperty(
			""encodingDetectors"",""BOM XML-PI""));
		addComponent(jEdit.getProperty(""options.general.encodingDetectors""),encodingDetectors);

		
		fallbackEncodings = new JTextField(jEdit.getProperty(
			""fallbackEncodings"",""""));
		fallbackEncodings.setToolTipText(jEdit.getProperty(
			""options.general.fallbackEncodings.tooltip""));
		addComponent(jEdit.getProperty(""options.general.fallbackEncodings""),fallbackEncodings);

		
		encodings = getEncodings(false);
		sort(encodings,new StandardUtilities.StringCompare<String>(true));
		Vector<Entry> encodingEntriesVector = new Vector<Entry>();
		boolean enableSelectAll = false;
		boolean enableSelectNone = false;
		for (String encoding : encodings)
		{
			boolean selected = !getBooleanProperty(""encoding.opt-out.""+encoding,false);
			enableSelectAll = enableSelectAll || !selected;
			enableSelectNone = enableSelectNone || selected;
			encodingEntriesVector.add(new Entry(selected,encoding));
		}
		encodingsList = new JCheckBoxList(encodingEntriesVector);
		encodingsList.getModel().addTableModelListener(new TableModelHandler());
		JScrollPane encodingsScrollPane = new JScrollPane(encodingsList);
		encodingsScrollPane.setBorder(
			new TitledBorder(getProperty(""options.encodings.selectEncodings"")));
		Dimension d = encodingsList.getPreferredSize();
		d.height = Math.min(d.height,200);
		encodingsScrollPane.setPreferredSize(d);
		addComponent(encodingsScrollPane,BOTH);

		
		Box buttonsBox = createHorizontalBox();
		buttonsBox.add(createHorizontalStrut(12));
		
		ActionHandler actionHandler = new ActionHandler();
		selectAllButton = new JButton(getProperty(""options.encodings.selectAll""));
		selectAllButton.addActionListener(actionHandler);
		selectAllButton.setEnabled(enableSelectAll);
		buttonsBox.add(selectAllButton);
		buttonsBox.add(createHorizontalStrut(12));

		selectNoneButton = new JButton(getProperty(""options.encodings.selectNone""));
		selectNoneButton.addActionListener(actionHandler);
		selectNoneButton.setEnabled(enableSelectNone);
		buttonsBox.add(selectNoneButton);
		buttonsBox.add(createHorizontalStrut(12));
		
		addComponent(buttonsBox);
	} 

	
	@Override
	protected void _save()
	{
		
		jEdit.setProperty(""buffer.""+ JEditBuffer.ENCODING,(String)
			defaultEncoding.getSelectedItem());
		jEdit.setBooleanProperty(""buffer.encodingAutodetect"",
			encodingAutodetect.isSelected());
		jEdit.setProperty(""encodingDetectors"",encodingDetectors.getText());
		jEdit.setProperty(""fallbackEncodings"",fallbackEncodings.getText());
		
		for (Entry entry : encodingsList.getValues())
		{
			if (entry.isChecked())
			{
				unsetProperty(""encoding.opt-out.""+entry.getValue());
			}
			else
			{
				setBooleanProperty(""encoding.opt-out.""+entry.getValue(),true);
			}
		}
	} 

	

	
	private class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent ae)
		{
			Object source = ae.getSource();
			if (source == selectAllButton)
			{
				encodingsList.selectAll();
			}
			else if (source == selectNoneButton)
			{
				for (int i=0, c=encodingsList.getRowCount() ; i<c ; i++)
				{
					encodingsList.setValueAt(false,i,0);
				}
			}
		}
	} 

	
	private class TableModelHandler implements TableModelListener
	{
		public void tableChanged(TableModelEvent tme)
		{
			int checkedAmount = encodingsList.getCheckedValues().length;
			if (checkedAmount == 0)
			{
				selectNoneButton.setEnabled(false);
			}
			else
			{
				selectNoneButton.setEnabled(true);
			}
			if (encodingsList.getValues().length == checkedAmount)
			{
				selectAllButton.setEnabled(false);
			}
			else
			{
				selectAllButton.setEnabled(true);
			}
		}
	} 

	

} 
"
jEdit,4.3,org.gjt.sp.jedit.msg.DynamicMenuChanged,3,2,0,7,8,0,5,2,3,0.0,29,1.0,0,0.6,0.666666667,1,1,8.333333333,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class DynamicMenuChanged extends EBMessage
{
	
	
	public DynamicMenuChanged(String name)
	{
		super(null);

		this.name = name;
	} 

	
	
	public String getMenuName()
	{
		return name;
	} 

	
	public String paramString()
	{
		return ""menu="" + name + "","" + super.paramString();
	} 

	
	private String name;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.browser.BrowserView,24,5,0,28,106,80,15,21,14,0.782608696,530,1.0,3,0.965976331,0.147727273,1,4,20.79166667,9,1.625,0,"

package org.gjt.sp.jedit.browser;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.*;

import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.util.*;

import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



class BrowserView extends JPanel
{
	
	BrowserView(final VFSBrowser browser)
	{
		this.browser = browser;

		tmpExpanded = new HashSet<String>();
		DockableWindowManager dwm = jEdit.getActiveView().getDockableWindowManager();
		KeyListener keyListener = dwm.closeListener(VFSBrowser.NAME);

		parentDirectories = new ParentDirectoryList();
		parentDirectories.addKeyListener(keyListener);
		parentDirectories.setName(""parent"");
		
		parentDirectories.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		parentDirectories.setCellRenderer(new ParentDirectoryRenderer());
		parentDirectories.setVisibleRowCount(5);
		parentDirectories.addMouseListener(new ParentMouseHandler());

		final JScrollPane parentScroller = new JScrollPane(parentDirectories);
		parentScroller.setMinimumSize(new Dimension(0,0));

		table = new VFSDirectoryEntryTable(this);
		table.addMouseListener(new TableMouseHandler());
		table.setName(""file"");
		JScrollPane tableScroller = new JScrollPane(table);
		tableScroller.setMinimumSize(new Dimension(0,0));
		tableScroller.getViewport().setBackground(table.getBackground());
		tableScroller.getViewport().addMouseListener(new TableMouseHandler());
		splitPane = new JSplitPane(
			browser.isHorizontalLayout()
			? JSplitPane.HORIZONTAL_SPLIT : JSplitPane.VERTICAL_SPLIT,
			jEdit.getBooleanProperty(""appearance.continuousLayout""),
			parentScroller, tableScroller);
		splitPane.setOneTouchExpandable(true);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				String prop = browser.isHorizontalLayout() ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
				int loc = jEdit.getIntegerProperty(prop,-1);
				if(loc == -1)
					loc = parentScroller.getPreferredSize().height;

				splitPane.setDividerLocation(loc);
				parentDirectories.ensureIndexIsVisible(
					parentDirectories.getModel()
					.getSize());
			}
		});

		if(browser.isMultipleSelectionEnabled())
			table.getSelectionModel().setSelectionMode(
				ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		else
			table.getSelectionModel().setSelectionMode(
				ListSelectionModel.SINGLE_SELECTION);

		setLayout(new BorderLayout());

		add(BorderLayout.CENTER,splitPane);

		propertiesChanged();
	} 

	
	public void focusOnFileView()
	{
		table.requestFocus();
	} 

	
	@Override
	public void removeNotify()
	{
		String prop = browser.isHorizontalLayout() ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
		jEdit.setIntegerProperty(prop,splitPane.getDividerLocation());

		super.removeNotify();
	} 

	
	public VFSFile[] getSelectedFiles()
	{
		return table.getSelectedFiles();
	} 

	
	public void selectNone()
	{
		table.clearSelection();
	} 

	
	public void saveExpansionState()
	{
		tmpExpanded.clear();
		table.getExpandedDirectories(tmpExpanded);
	} 

	
	public void clearExpansionState()
	{
		tmpExpanded.clear();
	} 

	
	public void loadDirectory(Object node, String path,
		boolean addToHistory)
	{
		path = MiscUtilities.constructPath(browser.getDirectory(),path);
		VFS vfs = VFSManager.getVFSForPath(path);

		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;

		if(node == null)
		{
			parentDirectories.setListData(new Object[] {
				new LoadingPlaceholder() });
		}

		Object[] loadInfo = new Object[2];

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.LIST_DIRECTORY,browser,
			session,vfs,path,null,loadInfo));
		browser.directoryLoaded(node,loadInfo,addToHistory);
	} 

	
	
	public void directoryLoaded(Object node, String path, java.util.List<VFSFile> directory)
	{
		
		if(node == null)
		{
			DefaultListModel parentList = new DefaultListModel();

			String parent = path;

			for(;;)
			{
				VFS _vfs = VFSManager.getVFSForPath(parent);
				VFSFile file = null;
				if (_vfs instanceof FileVFS)
				{
					Object session = _vfs.createVFSSession(path, browser);
					try
					{
						file = _vfs._getFile(session, parent, browser);
						if (file != null)
						{
							file.setName(_vfs.getFileName(parent));
						}
					}
					catch (IOException e)
					{
						Log.log(Log.ERROR, this, e, e);
					}
				}
				if (file == null)
				{
					
					
					
					
					file = new VFSFile(
							_vfs.getFileName(parent),
							parent,parent,
							VFSFile.DIRECTORY,
							0L,false);
				}


				
				parentList.insertElementAt(file,0);
				String newParent = _vfs.getParentOfPath(parent);

				if(newParent == null ||
					MiscUtilities.pathsEqual(parent,newParent))
					break;
				else
					parent = newParent;
			}

			parentDirectories.setModel(parentList);
			int index = parentList.getSize() - 1;
			parentDirectories.setSelectedIndex(index);
			parentDirectories.ensureIndexIsVisible(index);
		} 

		table.setDirectory(VFSManager.getVFSForPath(path),
			node,directory,tmpExpanded);
	} 

	
	public void updateFileView()
	{
		table.repaint();
	} 

	
	public void maybeReloadDirectory(String path)
	{
		String browserDir = browser.getDirectory();
		String symlinkBrowserDir;
		if(MiscUtilities.isURL(browserDir))
		{
			symlinkBrowserDir = browserDir;
		}
		else
		{
			symlinkBrowserDir = MiscUtilities.resolveSymlinks(
				browserDir);
		}

		if(MiscUtilities.pathsEqual(path,symlinkBrowserDir))
		{
			saveExpansionState();
			loadDirectory(null,browserDir,false);
		}

		
		
		
		
		
		
		
		
		
		
		

		if(!browserDir.startsWith(FavoritesVFS.PROTOCOL)
			&& !browserDir.startsWith(FileRootsVFS.PROTOCOL)
			&& !path.startsWith(symlinkBrowserDir))
			return;

		if(browserDir.startsWith(FileRootsVFS.PROTOCOL)
			&& MiscUtilities.isURL(path)
			&& !MiscUtilities.getProtocolOfURL(path)
			.equals(""file""))
			return;

		table.maybeReloadDirectory(path);
	} 

	
	public void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		table.propertiesChanged();
		GUIUtilities.initContinuousLayout(splitPane);
		splitPane.setBorder(null);
	} 

	
	
	public VFSBrowser getBrowser()
	{
		return browser;
	} 

	
	public VFSDirectoryEntryTable getTable()
	{
		return table;
	} 

	
	public JList getParentDirectoryList()
	{
		return parentDirectories;
	} 

	

	
	private final VFSBrowser browser;

	private final JSplitPane splitPane;
	private final JList parentDirectories;
	private final VFSDirectoryEntryTable table;
	private final Set<String> tmpExpanded;
	private BrowserCommandsMenu popup;
	private boolean showIcons;
	

	
	private void showFilePopup(VFSFile[] files, Component comp,
		Point point)
	{
		popup = new BrowserCommandsMenu(browser,files);
		
		
		
		popup.addPopupMenuListener(new PopupMenuListener()
		{
			public void popupMenuCanceled(PopupMenuEvent e) {}

			public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}

			public void popupMenuWillBecomeInvisible(PopupMenuEvent e)
			{
				
				
				
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						int index = parentDirectories
							.getModel()
							.getSize() - 1;
						parentDirectories.setSelectedIndex(index);
					}
				});
			}
		});
		GUIUtilities.showPopupMenu(popup,comp,point.x,point.y);
	} 

	

	

	
	class ParentDirectoryRenderer extends DefaultListCellRenderer
	{
		private Font plainFont;
		private final Font boldFont;

		ParentDirectoryRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			if(plainFont == null)
				plainFont = jEdit.getFontProperty(""metal.secondary.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		}

		@Override
		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			ParentDirectoryRenderer.this.setBorder(new EmptyBorder(
				1,index * 5 + 1,1,1));

			if(value instanceof LoadingPlaceholder)
			{
				ParentDirectoryRenderer.this.setFont(plainFont);

				setIcon(showIcons ? FileCellRenderer.loadingIcon : null);
				setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			}
			else if(value instanceof VFSFile)
			{
				VFSFile dirEntry = (VFSFile)value;
				ParentDirectoryRenderer.this.setFont(boldFont);

				setIcon(showIcons ? FileCellRenderer.getIconForFile(dirEntry,true)
					: null);
				setText(dirEntry.getName());
			}
			else if(value == null)
				setText(""VFS does not follow VFS API"");

			return this;
		}
	} 

	
	private class ParentMouseHandler extends MouseAdapter
	{
		@Override
		public void mousePressed(MouseEvent evt)
		{
			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentDirectories.getModel()
					.getElementAt(row);
				if(obj instanceof VFSFile)
				{
					VFSFile dirEntry = (VFSFile)obj;
					if(GUIUtilities.isPopupTrigger(evt))
					{
						if(popup != null && popup.isVisible())
						{
							popup.setVisible(false);
							popup = null;
						}
						else
						{
							parentDirectories.setSelectedIndex(row);
							showFilePopup(new VFSFile[] {
								dirEntry },parentDirectories,
								evt.getPoint());
						}
					}
				}
			}
		}

		@Override
		public void mouseReleased(MouseEvent evt)
		{
			if(evt.getClickCount() % 2 != 0 &&
				!GUIUtilities.isMiddleButton(evt.getModifiers()))
				return;

			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentDirectories.getModel()
					.getElementAt(row);
				if(obj instanceof VFSFile)
				{
					VFSFile dirEntry = (VFSFile)obj;
					if(!GUIUtilities.isPopupTrigger(evt))
					{
						browser.setDirectory(dirEntry.getPath());
						if(browser.getMode() == VFSBrowser.BROWSER)
						focusOnFileView();
					}
				}
			}
		}
	} 

	
	private class TableMouseHandler extends MouseAdapter
	{
		
		@Override
		public void mouseClicked(MouseEvent evt)
		{
			Point p = evt.getPoint();
			int row = table.rowAtPoint(p);
			int column = table.columnAtPoint(p);
			if(row == -1)
				return;
			if(column == 0)
			{
				VFSDirectoryEntryTableModel.Entry entry
					= (VFSDirectoryEntryTableModel.Entry)
					table.getModel().getValueAt(row,0);
				if(FileCellRenderer.ExpansionToggleBorder
					.isExpansionToggle(entry.level,p.x))
				{
					return;
				}
			}

			if((evt.getModifiers() & InputEvent.BUTTON1_MASK) != 0
				&& evt.getClickCount() % 2 == 0)
			{
				browser.filesActivated(evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN,true);
			}
			else if(GUIUtilities.isMiddleButton(evt.getModifiers()))
			{
				if(evt.isShiftDown())
					table.getSelectionModel().addSelectionInterval(row,row);
				else
					table.getSelectionModel().setSelectionInterval(row,row);
				browser.filesActivated(evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN,true);
			}
		} 

		
		@Override
		public void mousePressed(MouseEvent evt)
		{
			Point p = evt.getPoint();
			if(evt.getSource() != table)
			{
				p.x -= table.getX();
				p.y -= table.getY();
			}

			int row = table.rowAtPoint(p);
			int column = table.columnAtPoint(p);
			if(column == 0 && row != -1)
			{
				VFSDirectoryEntryTableModel.Entry entry
					= (VFSDirectoryEntryTableModel.Entry)
					table.getModel().getValueAt(row,0);
				if(FileCellRenderer.ExpansionToggleBorder
					.isExpansionToggle(entry.level,p.x))
				{
					table.toggleExpanded(row);
					return;
				}
			}

			if(GUIUtilities.isMiddleButton(evt.getModifiers()))
			{
				if(row == -1)
					;
				else if(evt.isShiftDown())
					table.getSelectionModel().addSelectionInterval(row,row);
				else
					table.getSelectionModel().setSelectionInterval(row,row);
			}
			else if(GUIUtilities.isPopupTrigger(evt))
			{
				if(popup != null && popup.isVisible())
				{
					popup.setVisible(false);
					popup = null;
					return;
				}

				if(row == -1)
					showFilePopup(null,table,evt.getPoint());
				else
				{
					if(!table.getSelectionModel().isSelectedIndex(row))
						table.getSelectionModel().setSelectionInterval(row,row);
					showFilePopup(getSelectedFiles(),table,evt.getPoint());
				}
			}
		} 

		
		@Override
		public void mouseReleased(MouseEvent evt)
		{
			if(!GUIUtilities.isPopupTrigger(evt)
				&& table.getSelectedRow() != -1)
			{
				browser.filesSelected();
			}
		} 
	} 

	private static class LoadingPlaceholder {}
	
	
	class ParentDirectoryList extends JList
	{

		public String getPath(int row)
		{
			Collection<String> components = new LinkedList<String>();
			for (int i=1; i<=row; ++i)
				components.add(getModel().getElementAt(i).toString());
			return getModel().getElementAt(0) + TextUtilities.join(components, File.separator);
		}

		@Override
		protected void processKeyEvent(KeyEvent evt)
		{
			if (evt.getID() == KeyEvent.KEY_PRESSED)
			{
				ActionContext ac = VFSBrowser.getActionContext();
				int row = parentDirectories.getSelectedIndex();
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_DOWN:
					evt.consume();			
					if (row < parentDirectories.getSize().height-1) 
						parentDirectories.setSelectedIndex(++row);
					break;
				case KeyEvent.VK_LEFT:
					if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)
					{
						evt.consume();
						browser.previousDirectory();
					}
					else super.processEvent(evt);
					break;
				case KeyEvent.VK_RIGHT:
					if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)
					{
						evt.consume();
						browser.nextDirectory();
					}
					else super.processEvent(evt);
					break;
				case KeyEvent.VK_TAB:
					evt.consume();
					if ((evt.getModifiers() & KeyEvent.SHIFT_MASK) > 0)
						browser.focusOnDefaultComponent();
					else
						table.requestFocus();
					break;
				case KeyEvent.VK_UP :
					evt.consume();
					if (row > 0)
					{
						parentDirectories.setSelectedIndex(--row);
					}
					break;
				case KeyEvent.VK_BACK_SPACE:
					evt.consume();
					EditAction up = ac.getAction(""vfs.browser.up"");
					ac.invokeAction(evt, up);
					break;
				case KeyEvent.VK_F5: 
					evt.consume();
					EditAction reload = ac.getAction(""vfs.browser.reload"");
					ac.invokeAction(evt, reload);
					break;
				case KeyEvent.VK_ENTER: 
					evt.consume();
					String path = getPath(row);
					getBrowser().setDirectory(path);
					table.requestFocus();
					break;
					
				}
			}
			else if(evt.getID() == KeyEvent.KEY_TYPED)
			{
				if(evt.isControlDown() || evt.isAltDown()
					|| evt.isMetaDown())
				{
					evt.consume();
					return;
				}
				switch(evt.getKeyChar())
				{
				case '~':
					evt.consume();
					if(browser.getMode() == VFSBrowser.BROWSER)
						browser.setDirectory(System.getProperty(
							""user.home""));
					break;
				case '/':
					evt.consume();
					if(browser.getMode() == VFSBrowser.BROWSER)
						browser.rootDirectory();
					break;
				case '-':
					evt.consume();
					if(browser.getMode() == VFSBrowser.BROWSER)
					{
						browser.setDirectory(
							browser.getView().getBuffer()
							.getDirectory());
					}
					break;
				}
			}
			if (!evt.isConsumed())
				super.processKeyEvent(evt);
		}	
	}
	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.SaveBackupOptionPane,4,6,0,6,29,0,1,6,1,0.636363636,315,1.0,0,0.995535714,0.5,3,5,75.0,6,2.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.NumericTextField;
import org.gjt.sp.jedit.browser.VFSBrowser;



public class SaveBackupOptionPane extends AbstractOptionPane
{
	
	public SaveBackupOptionPane()
	{
		super(""save-back"");
	} 

	
	@Override
	protected void _init()
	{
		
		twoStageSave = new JCheckBox(jEdit.getProperty(
			""options.save-back.twoStageSave""));
		twoStageSave.setSelected(jEdit.getBooleanProperty(
			""twoStageSave""));
		twoStageSave.setToolTipText(jEdit.getProperty(
			""options.save-back.twoStageSave.tooltip""));
		addComponent(twoStageSave);

		
		confirmSaveAll = new JCheckBox(jEdit.getProperty(
			""options.save-back.confirmSaveAll""));
		confirmSaveAll.setSelected(jEdit.getBooleanProperty(
			""confirmSaveAll""));
		addComponent(confirmSaveAll);

		
		autosave = new NumericTextField(jEdit.getProperty(""autosave""), true);
		addComponent(jEdit.getProperty(""options.save-back.autosave""),autosave);

		
		autosaveUntitled = new JCheckBox(jEdit.getProperty(
			""options.save-back.autosaveUntitled""));
		autosaveUntitled.setSelected(jEdit.getBooleanProperty(""autosaveUntitled""));
		addComponent(autosaveUntitled);

		suppressNotSavedConfirmUntitled = new JCheckBox(jEdit.getProperty(
			""options.save-back.suppressNotSavedConfirmUntitled""));
		suppressNotSavedConfirmUntitled.setSelected(
			jEdit.getBooleanProperty(""suppressNotSavedConfirmUntitled""));
		addComponent(suppressNotSavedConfirmUntitled);

		useMD5forDirtyCalculation = new JCheckBox(jEdit.getProperty(
			""options.save-back.useMD5forDirtyCalculation""));
		useMD5forDirtyCalculation.setToolTipText(jEdit.getProperty(
			""options.save-back.useMD5forDirtyCalculation.tooltip""));
		useMD5forDirtyCalculation.setSelected(
			jEdit.getBooleanProperty(""useMD5forDirtyCalculation""));
		addComponent(useMD5forDirtyCalculation);




		
		backups = new NumericTextField(jEdit.getProperty(""backups""), true);
		addComponent(jEdit.getProperty(""options.save-back.backups""),backups);

		
		backupDirectory = new JTextField(jEdit.getProperty(
			""backup.directory""));
		JButton browseBackupDirectory = new JButton(""..."");
		browseBackupDirectory.addActionListener(new MyActionListener());
		JPanel panel = new JPanel(new BorderLayout());
		panel.add(backupDirectory);
		panel.add(browseBackupDirectory, BorderLayout.EAST);
		addComponent(jEdit.getProperty(""options.save-back.backupDirectory""),
			panel);

		
		backupPrefix = new JTextField(jEdit.getProperty(""backup.prefix""));
		addComponent(jEdit.getProperty(""options.save-back.backupPrefix""),
			backupPrefix);

		
		backupSuffix = new JTextField(jEdit.getProperty(
			""backup.suffix""));
		addComponent(jEdit.getProperty(""options.save-back.backupSuffix""),
			backupSuffix);

		
		backupEverySave = new JCheckBox(jEdit.getProperty(
			""options.save-back.backupEverySave""));
		backupEverySave.setSelected(jEdit.getBooleanProperty(""backupEverySave""));
		addComponent(backupEverySave);
	} 

	
	@Override
	protected void _save()
	{
		jEdit.setBooleanProperty(""twoStageSave"",twoStageSave.isSelected());
		jEdit.setBooleanProperty(""confirmSaveAll"",confirmSaveAll.isSelected());
		jEdit.setProperty(""autosave"", this.autosave.getText());
		jEdit.setProperty(""backups"",backups.getText());
		jEdit.setProperty(""backup.directory"",backupDirectory.getText());
		jEdit.setProperty(""backup.prefix"",backupPrefix.getText());
		jEdit.setProperty(""backup.suffix"",backupSuffix.getText());
		jEdit.setBooleanProperty(""backupEverySave"", backupEverySave.isSelected());
		boolean newAutosave = autosaveUntitled.isSelected();
		boolean oldAutosave = jEdit.getBooleanProperty(""autosaveUntitled"");
		jEdit.setBooleanProperty(""autosaveUntitled"", newAutosave);
		jEdit.setBooleanProperty(""suppressNotSavedConfirmUntitled"",
				suppressNotSavedConfirmUntitled.isSelected());
		jEdit.setBooleanProperty(""useMD5forDirtyCalculation"",
				useMD5forDirtyCalculation.isSelected());
		if ((!newAutosave || jEdit.getIntegerProperty(""autosave"",0) == 0) && oldAutosave)
		{
			Buffer[] buffers = jEdit.getBuffers();
			for (Buffer buffer : buffers)
			{
				if (buffer.isUntitled())
				{
					buffer.removeAutosaveFile();
				}
			}
		}
	} 

	
	private JCheckBox twoStageSave;
	private JCheckBox confirmSaveAll;
	private JTextField autosave;
	private JCheckBox autosaveUntitled;
	private JCheckBox suppressNotSavedConfirmUntitled;
	private JCheckBox useMD5forDirtyCalculation;
	private JTextField backups;
	private JTextField backupDirectory;
	private JTextField backupPrefix;
	private JTextField backupSuffix;
	private JCheckBox backupEverySave;
	

	
	private class MyActionListener implements ActionListener
	{
		public void actionPerformed(ActionEvent e)
		{
			String[] choosenFolder =
				GUIUtilities.showVFSFileDialog(null,
				   			       backupDirectory.getText(),
				   			       VFSBrowser.CHOOSE_DIRECTORY_DIALOG,
				   			       false);
			if (choosenFolder != null)
				backupDirectory.setText(choosenFolder[0]);
		}
	} 

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHReturnStatement,2,2,0,9,7,1,1,8,1,1.0,29,0.0,0,0.944444444,0.625,1,1,13.0,1,0.5,0,"


package org.gjt.sp.jedit.bsh;

class BSHReturnStatement extends SimpleNode implements ParserConstants
{
	public int kind;

	BSHReturnStatement(int id) { super(id); }

	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object value;
		if(jjtGetNumChildren() > 0)
			value = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		else
			value = Primitive.VOID;

		return new ReturnControl( kind, value, this );
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.io.VFSFileFilter,4,1,0,7,5,6,6,1,3,1.0,9,0.0,0,0.0,0.555555556,0,0,1.0,1,0.75,0,"

package org.gjt.sp.jedit.io;


public interface VFSFileFilter 
{
	public static final String SERVICE_NAME = VFSFileFilter.class.getName();

	
	public boolean accept(VFSFile file);

	
	public boolean accept(String url);

	
	public String getDescription();

}

"
jEdit,4.3,org.gjt.sp.jedit.syntax.XModeHandler,21,2,2,13,86,134,5,10,9,0.875,891,1.0,3,0.459459459,0.226190476,1,2,40.95238095,38,3.4286,0,"

package org.gjt.sp.jedit.syntax;


import java.util.*;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;

import org.gjt.sp.jedit.Mode;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.XMLUtilities;



public abstract class XModeHandler extends DefaultHandler
{
	
	public XModeHandler (String modeName)
	{
		this.modeName = modeName;
		marker = new TokenMarker();
		marker.addRuleSet(new ParserRuleSet(modeName,""MAIN""));
		stateStack = new Stack<TagDecl>();
	} 

	
	public InputSource resolveEntity(String publicId, String systemId)
	{
		return XMLUtilities.findEntity(systemId, ""xmode.dtd"", XModeHandler.class);
	} 

	
	public void characters(char[] c, int off, int len)
	{
		peekElement().setText(c, off, len);
	} 

	
	public void startElement(String uri, String localName,
				 String qName, Attributes attrs)
	{
		TagDecl tag = pushElement(qName, attrs);

		if (qName.equals(""WHITESPACE""))
		{
			Log.log(Log.WARNING,this,modeName + "": WHITESPACE rule ""
				+ ""no longer needed"");
		}
		else if (qName.equals(""KEYWORDS""))
		{
			keywords = new KeywordMap(rules.getIgnoreCase());
		}
		else if (qName.equals(""RULES""))
		{
			if(tag.lastSetName == null)
				tag.lastSetName = ""MAIN"";
			rules = marker.getRuleSet(tag.lastSetName);
			if(rules == null)
			{
				rules = new ParserRuleSet(modeName,tag.lastSetName);
				marker.addRuleSet(rules);
			}
			rules.setIgnoreCase(tag.lastIgnoreCase);
			rules.setHighlightDigits(tag.lastHighlightDigits);
			if(tag.lastDigitRE != null)
			{
				try
				{
					rules.setDigitRegexp(Pattern.compile(tag.lastDigitRE,
						tag.lastIgnoreCase
						? Pattern.CASE_INSENSITIVE : 0));
				}
				catch(PatternSyntaxException e)
				{
					error(""regexp"",e);
				}
			}

			if(tag.lastEscape != null)
				rules.setEscapeRule(ParserRule.createEscapeRule(tag.lastEscape));
			rules.setDefault(tag.lastDefaultID);
			rules.setNoWordSep(tag.lastNoWordSep);
		}
	} 

	
	public void endElement(String uri, String localName, String name)
	{
		TagDecl tag = popElement();
		if (name.equals(tag.tagName))
		{
			if(tag.lastDelegateSet != null
					&& ! tag.tagName.equals(""IMPORT"")
					&& ! tag.lastDelegateSet.getModeName().equals(modeName))
			{
				Mode mode = ModeProvider.instance.getMode(tag.lastDelegateSet.getModeName());
				if( ! reloadModes.contains(mode) )
				{
					reloadModes.add(mode);
				}
			}
			
			if (tag.tagName.equals(""PROPERTY""))
			{
				props.put(propName,propValue);
			} 
			
			else if (tag.tagName.equals(""PROPS""))
			{
				if(peekElement().tagName.equals(""RULES""))
					rules.setProperties(props);
				else
					modeProps = props;

				props = new Hashtable<String, String>();
			} 
			
			else if (tag.tagName.equals(""RULES""))
			{
				rules.setKeywords(keywords);
				keywords = null;
				rules = null;
			} 
			
			else if (tag.tagName.equals(""IMPORT""))
			{
				
				if (!rules.equals(tag.lastDelegateSet))
				{
					rules.addRuleSet(tag.lastDelegateSet);
				}
			} 
			
			else if (tag.tagName.equals(""TERMINATE""))
			{
				rules.setTerminateChar(tag.termChar);
			} 
			
			else if (tag.tagName.equals(""SEQ""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""SEQ"");
					return;
				}

				rules.addRule(ParserRule.createSequenceRule(
					tag.lastStartPosMatch,tag.lastStart.toString(),
					tag.lastDelegateSet,tag.lastTokenID));
			} 
			
			else if (tag.tagName.equals(""SEQ_REGEXP""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""SEQ_REGEXP"");
					return;
				}

				try
				{
					if (null != tag.lastHashChars)
					{
						rules.addRule(ParserRule.createRegexpSequenceRule(
							tag.lastStartPosMatch,tag.lastHashChars.toCharArray(),
							tag.lastStart.toString(),tag.lastDelegateSet,
							tag.lastTokenID,findParent(""RULES"").lastIgnoreCase));
					}
					else
					{
						rules.addRule(ParserRule.createRegexpSequenceRule(
							tag.lastHashChar,tag.lastStartPosMatch,
							tag.lastStart.toString(),tag.lastDelegateSet,
							tag.lastTokenID,findParent(""RULES"").lastIgnoreCase));
					}
				}
				catch(PatternSyntaxException re)
				{
					error(""regexp"",re);
				}
			} 
			
			else if (tag.tagName.equals(""SPAN""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""BEGIN"");
					return;
				}

				if(tag.lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				}

				rules.addRule(ParserRule
					.createSpanRule(
					tag.lastStartPosMatch,tag.lastStart.toString(),
					tag.lastEndPosMatch,tag.lastEnd.toString(),
					tag.lastDelegateSet,
					tag.lastTokenID,tag.lastMatchType,
					tag.lastNoLineBreak,
					tag.lastNoWordBreak,
					tag.lastEscape));
			} 
			
			else if (tag.tagName.equals(""SPAN_REGEXP""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""BEGIN"");
					return;
				}

				if(tag.lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				}

				try
				{
					if (null != tag.lastHashChars)
					{
						rules.addRule(ParserRule
							.createRegexpSpanRule(
							tag.lastStartPosMatch,tag.lastHashChars.toCharArray(),
							tag.lastStart.toString(),
							tag.lastEndPosMatch,tag.lastEnd.toString(),
							tag.lastDelegateSet,
							tag.lastTokenID,
							tag.lastMatchType,
							tag.lastNoLineBreak,
							tag.lastNoWordBreak,
							findParent(""RULES"").lastIgnoreCase,
							tag.lastEscape));
					}
					else
					{
						rules.addRule(ParserRule
							.createRegexpSpanRule(
							tag.lastHashChar,
							tag.lastStartPosMatch,tag.lastStart.toString(),
							tag.lastEndPosMatch,tag.lastEnd.toString(),
							tag.lastDelegateSet,
							tag.lastTokenID,
							tag.lastMatchType,
							tag.lastNoLineBreak,
							tag.lastNoWordBreak,
							findParent(""RULES"").lastIgnoreCase,
							tag.lastEscape));
					}
				}
				catch(PatternSyntaxException re)
				{
					error(""regexp"",re);
				}
			} 
			
			else if (tag.tagName.equals(""EOL_SPAN""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN"");
					return;
				}

				rules.addRule(ParserRule.createEOLSpanRule(
					tag.lastStartPosMatch,tag.lastStart.toString(),
					tag.lastDelegateSet,tag.lastTokenID,
					tag.lastMatchType));
			} 
			
			else if (tag.tagName.equals(""EOL_SPAN_REGEXP""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN_REGEXP"");
					return;
				}

				try
				{
					if (null != tag.lastHashChars)
					{
						rules.addRule(ParserRule.createRegexpEOLSpanRule(
							tag.lastStartPosMatch,tag.lastHashChars.toCharArray(),
							tag.lastStart.toString(),tag.lastDelegateSet,
							tag.lastTokenID,tag.lastMatchType,
							findParent(""RULES"").lastIgnoreCase));
					}
					else
					{
						rules.addRule(ParserRule.createRegexpEOLSpanRule(
							tag.lastHashChar,tag.lastStartPosMatch,
							tag.lastStart.toString(),tag.lastDelegateSet,
							tag.lastTokenID,tag.lastMatchType,
							findParent(""RULES"").lastIgnoreCase));
					}
				}
				catch(PatternSyntaxException re)
				{
					error(""regexp"",re);
				}
			} 
			
			else if (tag.tagName.equals(""MARK_FOLLOWING""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""MARK_FOLLOWING"");
					return;
				}

				rules.addRule(ParserRule
					.createMarkFollowingRule(
					tag.lastStartPosMatch,tag.lastStart.toString(),
					tag.lastTokenID,tag.lastMatchType));
			} 
			
			else if (tag.tagName.equals(""MARK_PREVIOUS""))
			{
				if(tag.lastStart == null)
				{
					error(""empty-tag"",""MARK_PREVIOUS"");
					return;
				}

				rules.addRule(ParserRule
					.createMarkPreviousRule(
					tag.lastStartPosMatch,tag.lastStart.toString(),
					tag.lastTokenID,tag.lastMatchType));
			} 
			
			else if (
				!tag.tagName.equals(""END"")
				&& !tag.tagName.equals(""BEGIN"")
				&& !tag.tagName.equals(""KEYWORDS"")
				&& !tag.tagName.equals(""MODE""))
			{
				byte token = Token.stringToToken(tag.tagName);
				if(token != -1)
					addKeyword(tag.lastKeyword.toString(),token);
			} 
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	public void startDocument()
	{
		props = new Hashtable<String, String>();
		pushElement(null, null);
		reloadModes = new Vector<Mode>();
	} 

	
	public void endDocument()
	{
		ParserRuleSet[] rulesets = marker.getRuleSets();
		for(int i = 0; i < rulesets.length; i++)
		{
			rulesets[i].resolveImports();
		}
		for(Mode mode : reloadModes)
		{
			mode.setTokenMarker(null);
			mode.loadIfNecessary();
		}
	} 

	
	
	public TokenMarker getTokenMarker()
	{
		return marker;
	} 

	
	public Hashtable<String, String> getModeProperties()
	{
		return modeProps;
	} 

	

	
	
	protected abstract void error(String msg, Object subst);
	

	
	
	protected abstract TokenMarker getTokenMarker(String mode);
	

	

	

	
	private String modeName;
	
	private final TokenMarker marker;
	private KeywordMap keywords;
	
	private Stack<TagDecl> stateStack;
	private String propName;
	private String propValue;
	private Hashtable<String, String> props;
	private Hashtable<String, String> modeProps;
	private ParserRuleSet rules;
	
	private Vector<Mode> reloadModes;
	

	
	private void addKeyword(String k, byte id)
	{
		if(k == null)
		{
			error(""empty-keyword"",null);
			return;
		}

		if (keywords == null) return;
		keywords.add(k,id);
	} 

	
	private TagDecl pushElement(String name, Attributes attrs)
	{
		if (name != null)
		{
			TagDecl tag = new TagDecl(name, attrs);
			stateStack.push(tag);
			return tag;
		}
		else
		{
			stateStack.push(null);
			return null;
		}
	} 

	
	private TagDecl peekElement()
	{
		return stateStack.peek();
	} 

	
	private TagDecl popElement()
	{
		return stateStack.pop();
	} 

	
	
	private TagDecl findParent(String tagName)
	{
		for (int idx = stateStack.size() - 1; idx >= 0; idx--)
		{
			TagDecl tag = stateStack.get(idx);
			if (tag.tagName.equals(tagName))
				return tag;
		}
		return null;
	} 

	

	
	private class TagDecl
	{

		public TagDecl(String tagName, Attributes attrs)
		{
			this.tagName = tagName;

			String tmp;

			propName = attrs.getValue(""NAME"");
			propValue = attrs.getValue(""VALUE"");

			tmp = attrs.getValue(""TYPE"");
			if (tmp != null)
			{
				lastTokenID = Token.stringToToken(tmp);
				if(lastTokenID == -1)
					error(""token-invalid"",tmp);
			}

			lastMatchType = ParserRule.MATCH_TYPE_RULE;
			
			
			tmp = attrs.getValue(""EXCLUDE_MATCH"");
			if (tmp != null)
			{
				Log.log(Log.WARNING, this, modeName + "": EXCLUDE_MATCH is deprecated"");
				if (""TRUE"".equalsIgnoreCase(tmp))
				{
					lastMatchType = ParserRule.MATCH_TYPE_CONTEXT;
				}
			}

			
			tmp = attrs.getValue(""MATCH_TYPE"");
			if (tmp != null)
			{
				if (""CONTEXT"".equals(tmp))
				{
					lastMatchType = ParserRule.MATCH_TYPE_CONTEXT;
				}
				else if (""RULE"".equals(tmp))
				{
					lastMatchType = ParserRule.MATCH_TYPE_RULE;
				}
				else
				{
					lastMatchType = Token.stringToToken(tmp);
					if(lastMatchType == -1)
						error(""token-invalid"",tmp);
				}
			}

			lastAtLineStart = ""TRUE"".equals(attrs.getValue(""AT_LINE_START""));
			lastAtWhitespaceEnd = ""TRUE"".equals(attrs.getValue(""AT_WHITESPACE_END""));
			lastAtWordStart = ""TRUE"".equals(attrs.getValue(""AT_WORD_START""));
			lastNoLineBreak = ""TRUE"".equals(attrs.getValue(""NO_LINE_BREAK""));
			lastNoWordBreak = ""TRUE"".equals(attrs.getValue(""NO_WORD_BREAK""));
			lastIgnoreCase = (attrs.getValue(""IGNORE_CASE"") == null ||
					""TRUE"".equals(attrs.getValue(""IGNORE_CASE"")));
			lastHighlightDigits = ""TRUE"".equals(attrs.getValue(""HIGHLIGHT_DIGITS""));
			lastDigitRE = attrs.getValue(""DIGIT_RE"");

			tmp = attrs.getValue(""NO_WORD_SEP"");
			if (tmp != null)
				lastNoWordSep = tmp;

			tmp = attrs.getValue(""AT_CHAR"");
			if (tmp != null)
			{
				try
				{
					termChar = Integer.parseInt(tmp);
				}
				catch (NumberFormatException e)
				{
					error(""termchar-invalid"",tmp);
					termChar = -1;
				}
			}

			lastEscape = attrs.getValue(""ESCAPE"");
			lastSetName = attrs.getValue(""SET"");

			tmp = attrs.getValue(""DELEGATE"");
			if (tmp != null)
			{
				String delegateMode, delegateSetName;

				int index = tmp.indexOf(""::"");

				if(index != -1)
				{
					delegateMode = tmp.substring(0,index);
					delegateSetName = tmp.substring(index + 2);
				}
				else
				{
					delegateMode = modeName;
					delegateSetName = tmp;
				}

				TokenMarker delegateMarker = getTokenMarker(delegateMode);
				if(delegateMarker == null)
					error(""delegate-invalid"",tmp);
				else
				{
					lastDelegateSet = delegateMarker
						.getRuleSet(delegateSetName);
					if(delegateMarker == marker
						&& lastDelegateSet == null)
					{
						
						
						lastDelegateSet = new ParserRuleSet(
							delegateMode,
							delegateSetName);
						lastDelegateSet.setDefault(Token.INVALID);
						marker.addRuleSet(lastDelegateSet);
					}
					else if(lastDelegateSet == null)
						error(""delegate-invalid"",tmp);
				}
			}

			tmp = attrs.getValue(""DEFAULT"");
			if (tmp != null)
			{
				lastDefaultID = Token.stringToToken(tmp);
				if(lastDefaultID == -1)
				{
					error(""token-invalid"",tmp);
					lastDefaultID = Token.NULL;
				}
			}

			lastHashChar = attrs.getValue(""HASH_CHAR"");
			lastHashChars = attrs.getValue(""HASH_CHARS"");
			if ((null != lastHashChar) && (null != lastHashChars))
			{
				error(""hash-char-and-hash-chars-mutually-exclusive"",null);
				lastHashChars = null;
			}
		}

		public void setText(char[] c, int off, int len)
		{
			if (tagName.equals(""EOL_SPAN"") ||
				tagName.equals(""EOL_SPAN_REGEXP"") ||
				tagName.equals(""MARK_PREVIOUS"") ||
				tagName.equals(""MARK_FOLLOWING"") ||
				tagName.equals(""SEQ"") ||
				tagName.equals(""SEQ_REGEXP"") ||
				tagName.equals(""BEGIN"")
			)
			{
				TagDecl target = this;
				if (tagName.equals(""BEGIN""))
					target = stateStack.get(stateStack.size() - 2);

				if (target.lastStart == null)
				{
					target.lastStart = new StringBuffer();
					target.lastStart.append(c, off, len);
					target.lastStartPosMatch = ((target.lastAtLineStart ? ParserRule.AT_LINE_START : 0)
						| (target.lastAtWhitespaceEnd ? ParserRule.AT_WHITESPACE_END : 0)
						| (target.lastAtWordStart ? ParserRule.AT_WORD_START : 0));
					target.lastAtLineStart = false;
					target.lastAtWordStart = false;
					target.lastAtWhitespaceEnd = false;
				}
				else
				{
					target.lastStart.append(c, off, len);
				}
			}
			else if (tagName.equals(""END""))
			{
				TagDecl target = stateStack.get(stateStack.size() - 2);
				if (target.lastEnd == null)
				{
					target.lastEnd = new StringBuffer();
					target.lastEnd.append(c, off, len);
					target.lastEndPosMatch = ((this.lastAtLineStart ? ParserRule.AT_LINE_START : 0)
						| (this.lastAtWhitespaceEnd ? ParserRule.AT_WHITESPACE_END : 0)
						| (this.lastAtWordStart ? ParserRule.AT_WORD_START : 0));
					target.lastAtLineStart = false;
					target.lastAtWordStart = false;
					target.lastAtWhitespaceEnd = false;
				}
				else
				{
					target.lastEnd.append(c, off, len);
				}
			}
			else
			{
				if (lastKeyword == null)
					lastKeyword = new StringBuffer();
				lastKeyword.append(c, off, len);
			}
		}

		public String tagName;
		public StringBuffer lastStart;
		public StringBuffer lastEnd;
		public StringBuffer lastKeyword;
		public String lastSetName;
		public String lastEscape;
		public ParserRuleSet lastDelegateSet;
		public String lastNoWordSep = ""_"";
		public ParserRuleSet rules;
		public byte lastDefaultID = Token.NULL;
		public byte lastTokenID;
		public byte lastMatchType;
		public int termChar = -1;
		public boolean lastNoLineBreak;
		public boolean lastNoWordBreak;
		public boolean lastIgnoreCase = true;
		public boolean lastHighlightDigits;
		public boolean lastAtLineStart;
		public boolean lastAtWhitespaceEnd;
		public boolean lastAtWordStart;
		public int lastStartPosMatch;
		public int lastEndPosMatch;
		public String lastDigitRE;
		public String lastHashChar;
		public String lastHashChars;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.classpath.ClassPathListener,1,1,0,1,1,0,1,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.bsh.classpath;

public interface ClassPathListener {
	public void classPathChanged();
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.BufferChangeListener,7,1,0,3,7,21,3,1,7,2.0,7,0.0,0,0.0,0.857142857,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;


public interface BufferChangeListener
{
	
	
	void foldLevelChanged(Buffer buffer, int startLine, int endLine);
	

	
	
	void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	public void preContentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void transactionComplete(Buffer buffer);
	

	
	
	void foldHandlerChanged(Buffer buffer);
	

	
	
	void bufferLoaded(Buffer buffer);
	
	
	
	public class Adapter implements BufferListener
	{
		private BufferChangeListener delegate;

		
		public Adapter(BufferChangeListener delegate)
		{
			this.delegate = delegate;
		} 
	
		
		public BufferChangeListener getDelegate()
		{
			return delegate;
		} 

		
		
		public void foldLevelChanged(JEditBuffer buffer, int startLine, int endLine)
		{
			delegate.foldLevelChanged((Buffer)buffer,startLine,endLine);
		} 
	
		
		
		public void contentInserted(JEditBuffer buffer, int startLine, int offset,
			int numLines, int length)
		{
			delegate.contentInserted((Buffer)buffer,startLine,offset,numLines,length);
		} 
	
		
		
		public void contentRemoved(JEditBuffer buffer, int startLine, int offset,
			int numLines, int length)
		{
			delegate.contentRemoved((Buffer)buffer,startLine,offset,numLines,length);
		} 

		
		public void preContentInserted(JEditBuffer buffer, int startLine, int offset, int numLines, int length)
		{
		}

		
		
		public void preContentRemoved(JEditBuffer buffer, int startLine, int offset,
			int numLines, int length)
		{
			delegate.preContentRemoved((Buffer)buffer,startLine,offset,numLines,length);
		} 
	
		
		
		public void transactionComplete(JEditBuffer buffer)
		{
			delegate.transactionComplete((Buffer)buffer);
		} 
	
		
		
		public void foldHandlerChanged(JEditBuffer buffer)
		{
			delegate.foldHandlerChanged((Buffer)buffer);
		} 
	
		
		
		public void bufferLoaded(JEditBuffer buffer)
		{
			delegate.bufferLoaded((Buffer)buffer);
		} 
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.Selection,16,1,2,29,26,88,28,1,9,0.833333333,119,0.0,0,0.0,0.322916667,0,0,6.1875,5,1.0625,0,"

package org.gjt.sp.jedit.textarea;


import java.util.ArrayList;
import java.util.List;

import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.util.StandardUtilities;



public abstract class Selection implements Cloneable
{
	
	
	public int getStart()
	{
		return start;
	} 

	
	
	public int getEnd()
	{
		return end;
	} 

	
	
	public abstract int getStart(JEditBuffer buffer, int line);
	

	
	
	public abstract int getEnd(JEditBuffer buffer, int line);
	

	
	
	public int getStartLine()
	{
		return startLine;
	} 

	
	
	public int getEndLine()
	{
		return endLine;
	} 

	
	
	public boolean overlaps(Selection s)
	{
		if((start >= s.start && start <= s.end)
			|| (end >= s.start && end <= s.end))
			return true;
		else
			return false;
	} 

	
	@Override
	public String toString()
	{
		return getClass().getName() + ""[start="" + start
			+ "",end="" + end + "",startLine="" + startLine
			+ "",endLine="" + endLine + ']';
	} 

	
	@Override
	public Object clone()
	{
		try
		{
			return super.clone();
		}
		catch(CloneNotSupportedException e)
		{
			throw new InternalError(""I just drank a whole ""
				+ ""bottle of cough syrup and I feel ""
				+ ""funny!"");
		}
	} 

	
	int start, end;
	int startLine, endLine;

	
	protected Selection()
	{
	} 

	
	protected Selection(Selection sel)
	{
		this.start = sel.start;
		this.end = sel.end;
	} 

	
	protected Selection(int start, int end)
	{
		this.start = start;
		this.end = end;
	} 

	
	abstract void getText(JEditBuffer buffer, StringBuilder buf);

	
	abstract int setText(JEditBuffer buffer, String text);

	
	abstract boolean contentInserted(JEditBuffer buffer, int startLine, int start,
		int numLines, int length);

	
	abstract boolean contentRemoved(JEditBuffer buffer, int startLine, int start,
		int numLines, int length);
	

	
	
	public static class Range extends Selection
	{
		
		public Range()
		{
		} 

		
		public Range(Selection sel)
		{
			super(sel);
		} 

		
		public Range(int start, int end)
		{
			super(start,end);
		} 

		
		@Override
		public int getStart(JEditBuffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
				return buffer.getLineStartOffset(line);
		} 

		
		@Override
		public int getEnd(JEditBuffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
				return buffer.getLineEndOffset(line) - 1;
		} 

		

		
		@Override
		void getText(JEditBuffer buffer, StringBuilder buf)
		{
			buf.append(buffer.getText(start,end - start));
		} 

		
		
		@Override
		int setText(JEditBuffer buffer, String text)
		{
			buffer.remove(start,end - start);
			if(text != null && text.length() != 0)
			{
				buffer.insert(start,text);
				return start + text.length();
			}
			else
				return start;
		} 

		
		@Override
		boolean contentInserted(JEditBuffer buffer, int startLine, int start,
			int numLines, int length)
		{
			boolean changed = false;

			if(this.start >= start)
			{
				this.start += length;
				if(numLines != 0)
					this.startLine = buffer.getLineOfOffset(this.start);
				changed = true;
			}

			if(this.end >= start)
			{
				this.end += length;
				if(numLines != 0)
					this.endLine = buffer.getLineOfOffset(this.end);
				changed = true;
			}

			return changed;
		} 

		
		@Override
		boolean contentRemoved(JEditBuffer buffer, int startLine, int start,
			int numLines, int length)
		{
			int end = start + length;
			boolean changed = false;

			if(this.start > start && this.start <= end)
			{
				this.start = start;
				changed = true;
			}
			else if(this.start > end)
			{
				this.start -= length;
				changed = true;
			}

			if(this.end > start && this.end <= end)
			{
				this.end = start;
				changed = true;
			}
			else if(this.end > end)
			{
				this.end -= length;
				changed = true;
			}

			if(changed && numLines != 0)
			{
				this.startLine = buffer.getLineOfOffset(this.start);
				this.endLine = buffer.getLineOfOffset(this.end);
			}

			return changed;
		} 

		
	} 

	
	
	
	public static class Rect extends Selection
	{
		
		public Rect()
		{
		} 

		
		public Rect(Selection sel)
		{
			super(sel);
		} 

		
		public Rect(int start, int end)
		{
			super(start,end);
		} 

		
		public Rect(int startLine, int start, int endLine, int end)
		{
			this.startLine = startLine;
			this.start = start;
			this.endLine = endLine;
			this.end = end;
		} 

		
		public Rect(JEditBuffer buffer, int startLine, int startColumn,
			int endLine, int endColumn)
		{
			this.startLine = startLine;
			this.endLine = endLine;

			int[] width = new int[1];
			int startOffset = buffer.getOffsetOfVirtualColumn(startLine,
				startColumn,width);
			if(startOffset == -1)
			{
				extraStartVirt = startColumn - width[0];
				
			}
			

			int endOffset = buffer.getOffsetOfVirtualColumn(endLine,
				endColumn,width);
			if(endOffset == -1)
			{
				extraEndVirt = endColumn - width[0];
				
			}
			
		} 

		
		public int getStartColumn(JEditBuffer buffer)
		{
			int virtColStart = buffer.getVirtualWidth(startLine,
				start - buffer.getLineStartOffset(startLine)) + extraStartVirt;
			int virtColEnd = buffer.getVirtualWidth(endLine,
				end - buffer.getLineStartOffset(endLine)) + extraEndVirt;
			return Math.min(virtColStart,virtColEnd);
		} 

		
		public int getEndColumn(JEditBuffer buffer)
		{
			int virtColStart = buffer.getVirtualWidth(startLine,
				start - buffer.getLineStartOffset(startLine)) + extraStartVirt;
			int virtColEnd = buffer.getVirtualWidth(endLine,
				end - buffer.getLineStartOffset(endLine)) + extraEndVirt;
			return Math.max(virtColStart,virtColEnd);
		} 

		
		@Override
		public int getStart(JEditBuffer buffer, int line)
		{
			return getColumnOnOtherLine(buffer,line,
				getStartColumn(buffer));
		} 

		
		@Override
		public int getEnd(JEditBuffer buffer, int line)
		{
			return getColumnOnOtherLine(buffer,line,
				getEndColumn(buffer));
		} 

		
		int extraStartVirt;
		int extraEndVirt;

		
		@Override
		void getText(JEditBuffer buffer, StringBuilder buf)
		{
			int start = getStartColumn(buffer);
			int end = getEndColumn(buffer);

			for(int i = startLine; i <= endLine; i++)
			{
				int lineStart = buffer.getLineStartOffset(i);
				int lineLen = buffer.getLineLength(i);

				int rectStart = buffer.getOffsetOfVirtualColumn(
					i,start,null);
				if(rectStart == -1)
					rectStart = lineLen;

				int rectEnd = buffer.getOffsetOfVirtualColumn(
					i,end,null);
				if(rectEnd == -1)
					rectEnd = lineLen;

				if(rectEnd < rectStart)
					System.err.println(i + "":::"" + start + ':' + end
						+ "" ==> "" + rectStart + ':' + rectEnd);
				buf.append(buffer.getText(lineStart + rectStart,
					rectEnd - rectStart));

				if(i != endLine)
					buf.append('\n');
			}
		} 

		
		
		@Override
		int setText(JEditBuffer buffer, String text)
		{
			int startColumn = getStartColumn(buffer);
			int endColumn = getEndColumn(buffer);

			int tabSize = buffer.getTabSize();

			int maxWidth = 0;
			int totalLines = 0;
			
			List<Object> lines = new ArrayList<Object>();

			
			if(text != null)
			{
				int lastNewline = 0;
				int currentWidth = startColumn;
				for(int i = 0; i < text.length(); i++)
				{
					char ch = text.charAt(i);
					if(ch == '\n')
					{
						totalLines++;
						lines.add(text.substring(
							lastNewline,i));
						lastNewline = i + 1;
						maxWidth = Math.max(maxWidth,currentWidth);
						lines.add(currentWidth);
						currentWidth = startColumn;
					}
					else if(ch == '\t')
						currentWidth += tabSize - (currentWidth % tabSize);
					else
						currentWidth++;
				}

				if(lastNewline != text.length())
				{
					totalLines++;
					lines.add(text.substring(lastNewline));
					lines.add(currentWidth);
					maxWidth = Math.max(maxWidth,currentWidth);
				}
			} 

			
			int endOffset = 0;
			int[] total = new int[1];
			int lastLine = Math.max(startLine + totalLines - 1,endLine);
			for(int i = startLine; i <= lastLine; i++)
			{
				if(i == buffer.getLineCount())
					buffer.insert(buffer.getLength(),""\n"");

				int lineStart = buffer.getLineStartOffset(i);
				int lineLen = buffer.getLineLength(i);

				int rectStart = buffer.getOffsetOfVirtualColumn(
					i,startColumn,total);
				int startWhitespace;
				if(rectStart == -1)
				{
					startWhitespace = startColumn - total[0];
					rectStart = lineLen;
				}
				else
					startWhitespace = 0;

				int rectEnd = buffer.getOffsetOfVirtualColumn(
					i,endColumn,null);
				if(rectEnd == -1)
					rectEnd = lineLen;

				buffer.remove(rectStart + lineStart,rectEnd - rectStart);

				if(startWhitespace != 0)
				{
					buffer.insert(rectStart + lineStart,
						StandardUtilities.createWhiteSpace(startWhitespace,0));
				}

				int endWhitespace;
				if(totalLines == 0)
				{
					if(rectEnd == lineLen)
						endWhitespace = 0;
					else
						endWhitespace = maxWidth - startColumn;
				}
				else
				{
					int index = 2 * ((i - startLine) % totalLines);
					String str = (String)lines.get(index);
					buffer.insert(rectStart + lineStart + startWhitespace,str);
					if(rectEnd == lineLen)
						endWhitespace = 0;
					else
					{
						endWhitespace = maxWidth
							- (Integer) lines.get(index + 1);
					}
					startWhitespace += str.length();
				}

				if(endWhitespace != 0)
				{
					buffer.insert(rectStart + lineStart
						+ startWhitespace,
						StandardUtilities.createWhiteSpace(endWhitespace,0));
				}

				endOffset = rectStart + lineStart
					+ startWhitespace
					+ endWhitespace;
			} 

			
			if(text == null || text.length() == 0)
				return end;
			else
				return endOffset;
			
		} 

		
		@Override
		boolean contentInserted(JEditBuffer buffer, int startLine, int start,
			int numLines, int length)
		{
			if(this.end < start)
				return false;

			this.end += length;

			if(this.startLine > startLine)
			{
				this.start += length;
				if(numLines != 0)
				{
					this.startLine = buffer.getLineOfOffset(
						this.start);
					this.endLine = buffer.getLineOfOffset(
						this.end);
				}
				return true;
			}

			int endVirtualColumn = buffer.getVirtualWidth(
				this.endLine,end
				- buffer.getLineStartOffset(this.endLine));

			if(this.start == start)
			{
				int startVirtualColumn = buffer.getVirtualWidth(
					this.startLine,start
					- buffer.getLineStartOffset(
					this.startLine));

				this.start += length;

				int newStartVirtualColumn
					= buffer.getVirtualWidth(
						startLine,start -
						buffer.getLineStartOffset(
						this.startLine));

				int[] totalVirtualWidth = new int[1];
				int newEnd = buffer.getOffsetOfVirtualColumn(
					this.endLine,endVirtualColumn +
					newStartVirtualColumn -
					startVirtualColumn,
					totalVirtualWidth);

				if(newEnd != -1)
				{
					end = buffer.getLineStartOffset(
						this.endLine) + newEnd;
				}
				else
				{
					end = buffer.getLineEndOffset(
						this.endLine) - 1;
					extraEndVirt = totalVirtualWidth[0]
						- endVirtualColumn;
				}
			}
			else if(this.start > start)
			{
				this.start += length;
				if(numLines != 0)
				{
					this.startLine = buffer.getLineOfOffset(
						this.start);
				}
			}

			if(numLines != 0)
				this.endLine = buffer.getLineOfOffset(this.end);
			int newEndVirtualColumn = buffer.getVirtualWidth(
				endLine,
				end - buffer.getLineStartOffset(this.endLine));
			if(startLine == this.endLine && extraEndVirt != 0)
			{
				extraEndVirt += endVirtualColumn - newEndVirtualColumn;
			}
			else if(startLine == this.startLine
				&& extraStartVirt != 0)
			{
				extraStartVirt += endVirtualColumn - newEndVirtualColumn;
			}

			return true;
		} 

		
		@Override
		boolean contentRemoved(JEditBuffer buffer, int startLine, int start,
			int numLines, int length)
		{
			int end = start + length;
			boolean changed = false;

			if(this.start > start && this.start <= end)
			{
				this.start = start;
				changed = true;
			}
			else if(this.start > end)
			{
				this.start -= length;
				changed = true;
			}

			if(this.end > start && this.end <= end)
			{
				this.end = start;
				changed = true;
			}
			else if(this.end > end)
			{
				this.end -= length;
				changed = true;
			}

			if(changed && numLines != 0)
			{
				this.startLine = buffer.getLineOfOffset(this.start);
				this.endLine = buffer.getLineOfOffset(this.end);
			}

			return changed;
		} 

		

		

		
		private static int getColumnOnOtherLine(JEditBuffer buffer, int line,
			int col)
		{
			int returnValue = buffer.getOffsetOfVirtualColumn(
				line,col,null);
			if(returnValue == -1)
				return buffer.getLineEndOffset(line) - 1;
			else
				return buffer.getLineStartOffset(line) + returnValue;
		} 

		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.buffer.BufferListener,8,1,0,8,8,28,8,1,8,2.0,8,0.0,0,0.0,0.875,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.buffer;


public interface BufferListener
{
	
	
	void foldLevelChanged(JEditBuffer buffer, int startLine, int endLine);
	

	
	
	void contentInserted(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void contentRemoved(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void preContentInserted(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void preContentRemoved(JEditBuffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void transactionComplete(JEditBuffer buffer);
	

	
	
	void foldHandlerChanged(JEditBuffer buffer);
	

	
	
	void bufferLoaded(JEditBuffer buffer);
	
}
"
jEdit,4.3,org.gjt.sp.jedit.Marker,7,1,0,9,10,0,9,1,2,0.625,64,1.0,1,0.0,0.428571429,0,0,7.571428571,2,1.1429,0,"

package org.gjt.sp.jedit;

import javax.swing.text.Position;


public class Marker
{
	
	
	public char getShortcut()
	{
		return shortcut;
	} 

	
	
	public int getPosition()
	{
		return (position == null ? pos : position.getOffset());
	} 

	

	
	Marker(Buffer buffer, char shortcut, int position)
	{
		this.buffer = buffer;
		this.shortcut = shortcut;
		this.pos = position;
	} 

	
	
	void setShortcut(char shortcut)
	{
		this.shortcut = shortcut;
	} 

	
	void createPosition()
	{
		position = buffer.createPosition(pos);
	} 

	
	void removePosition()
	{
		
		if(position != null)
		{
			pos = position.getOffset();
			position = null;
		}
	} 

	
	
	void setPosition(int pos)
	{
		this.pos = pos;
	} 

	

	
	private Buffer buffer;
	private char shortcut;
	private int pos;
	private Position position;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.CircleFoldPainter,2,2,0,1,4,1,0,1,1,2.0,16,0.0,0,0.8,0.666666667,1,1,7.0,1,0.5,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;

public class CircleFoldPainter extends ShapedFoldPainter
{
	@Override
	protected void paintFoldShape(Graphics2D gfx, int top, int bottom)
	{
		gfx.drawArc(1,top,8,(bottom - top),0,360);
	}

}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.commands.dir,5,1,0,3,32,8,0,3,4,0.5,300,0.0,0,0.0,0.375,0,0,58.8,11,2.6,0,"
package org.gjt.sp.jedit.bsh.commands;

import java.io.*;
import org.gjt.sp.jedit.bsh.*;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Calendar;

public class dir 
{
	static final String [] months = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", 
		""May"", ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };

	public static String usage() {
		return ""usage: dir( String dir )\n       dir()"";
	}

	
	public static void invoke( Interpreter env, CallStack callstack ) 
	{
		String dir = ""."";
		invoke( env, callstack, dir );
	}

	
	public static void invoke( 
		Interpreter env, CallStack callstack, String dir ) 
	{
		File file;
		try {
			file =  env.pathToFile( dir );
		} catch (IOException e ) {
			env.println(""error reading path: ""+e);
			return;
		}

		if ( !file.exists() || !file.canRead() ) {
			env.println( ""Can't read "" + file );
			return;
		}
		if ( !file.isDirectory() )  {
			env.println(""'""+dir+""' is not a directory"");
		}

		String [] files = file.list();
		files = StringUtil.bubbleSort(files);

		for( int i=0; i< files.length; i++ ) {
			File f = new File( dir + File.separator + files[i] );
			StringBuilder sb = new StringBuilder();
			sb.append( f.canRead() ? ""r"": ""-"" );
			sb.append( f.canWrite() ? ""w"": ""-"" );
			sb.append( ""_"" );
			sb.append( "" "");

			Date d = new Date(f.lastModified());
			GregorianCalendar c = new GregorianCalendar();
			c.setTime(d);
			int day	= c.get(Calendar.DAY_OF_MONTH);
			sb.append( months[ c.get(Calendar.MONTH) ] + "" "" + day );
			if ( day < 10 ) 
				sb.append("" "");

			sb.append("" "");

			
			int fieldlen = 8;
			StringBuilder len = new StringBuilder();
			for(int j=0; j<fieldlen; j++)
				len.append("" "");
			len.insert(0, f.length());
			len.setLength(fieldlen);
			
			int si = len.toString().indexOf("" "");
			if ( si != -1 ) {
				String pad = len.toString().substring(si);
				len.setLength(si);
				len.insert(0, pad);
			}
			
			sb.append( len.toString() );

			sb.append( "" "" + f.getName() );
			if ( f.isDirectory() ) 
				sb.append(""/"");

			env.println( sb.toString() );
		}
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.bsh.ParserConstants,1,1,0,13,1,0,13,0,0,2.0,672,0.0,0,0.0,0.0,0,0,540.0,0,0.0,0,"
package org.gjt.sp.jedit.bsh;

public interface ParserConstants {

  int EOF = 0;
  int NONPRINTABLE = 6;
  int SINGLE_LINE_COMMENT = 7;
  int HASH_BANG_COMMENT = 8;
  int MULTI_LINE_COMMENT = 9;
  int ABSTRACT = 10;
  int BOOLEAN = 11;
  int BREAK = 12;
  int CLASS = 13;
  int BYTE = 14;
  int CASE = 15;
  int CATCH = 16;
  int CHAR = 17;
  int CONST = 18;
  int CONTINUE = 19;
  int _DEFAULT = 20;
  int DO = 21;
  int DOUBLE = 22;
  int ELSE = 23;
  int ENUM = 24;
  int EXTENDS = 25;
  int FALSE = 26;
  int FINAL = 27;
  int FINALLY = 28;
  int FLOAT = 29;
  int FOR = 30;
  int GOTO = 31;
  int IF = 32;
  int IMPLEMENTS = 33;
  int IMPORT = 34;
  int INSTANCEOF = 35;
  int INT = 36;
  int INTERFACE = 37;
  int LONG = 38;
  int NATIVE = 39;
  int NEW = 40;
  int NULL = 41;
  int PACKAGE = 42;
  int PRIVATE = 43;
  int PROTECTED = 44;
  int PUBLIC = 45;
  int RETURN = 46;
  int SHORT = 47;
  int STATIC = 48;
  int STRICTFP = 49;
  int SWITCH = 50;
  int SYNCHRONIZED = 51;
  int TRANSIENT = 52;
  int THROW = 53;
  int THROWS = 54;
  int TRUE = 55;
  int TRY = 56;
  int VOID = 57;
  int VOLATILE = 58;
  int WHILE = 59;
  int INTEGER_LITERAL = 60;
  int DECIMAL_LITERAL = 61;
  int HEX_LITERAL = 62;
  int OCTAL_LITERAL = 63;
  int FLOATING_POINT_LITERAL = 64;
  int EXPONENT = 65;
  int CHARACTER_LITERAL = 66;
  int STRING_LITERAL = 67;
  int FORMAL_COMMENT = 68;
  int IDENTIFIER = 69;
  int LETTER = 70;
  int DIGIT = 71;
  int LPAREN = 72;
  int RPAREN = 73;
  int LBRACE = 74;
  int RBRACE = 75;
  int LBRACKET = 76;
  int RBRACKET = 77;
  int SEMICOLON = 78;
  int COMMA = 79;
  int DOT = 80;
  int ASSIGN = 81;
  int GT = 82;
  int GTX = 83;
  int LT = 84;
  int LTX = 85;
  int BANG = 86;
  int TILDE = 87;
  int HOOK = 88;
  int COLON = 89;
  int EQ = 90;
  int LE = 91;
  int LEX = 92;
  int GE = 93;
  int GEX = 94;
  int NE = 95;
  int BOOL_OR = 96;
  int BOOL_ORX = 97;
  int BOOL_AND = 98;
  int BOOL_ANDX = 99;
  int INCR = 100;
  int DECR = 101;
  int PLUS = 102;
  int MINUS = 103;
  int STAR = 104;
  int SLASH = 105;
  int BIT_AND = 106;
  int BIT_ANDX = 107;
  int BIT_OR = 108;
  int BIT_ORX = 109;
  int XOR = 110;
  int MOD = 111;
  int LSHIFT = 112;
  int LSHIFTX = 113;
  int RSIGNEDSHIFT = 114;
  int RSIGNEDSHIFTX = 115;
  int RUNSIGNEDSHIFT = 116;
  int RUNSIGNEDSHIFTX = 117;
  int PLUSASSIGN = 118;
  int MINUSASSIGN = 119;
  int STARASSIGN = 120;
  int SLASHASSIGN = 121;
  int ANDASSIGN = 122;
  int ANDASSIGNX = 123;
  int ORASSIGN = 124;
  int ORASSIGNX = 125;
  int XORASSIGN = 126;
  int MODASSIGN = 127;
  int LSHIFTASSIGN = 128;
  int LSHIFTASSIGNX = 129;
  int RSIGNEDSHIFTASSIGN = 130;
  int RSIGNEDSHIFTASSIGNX = 131;
  int RUNSIGNEDSHIFTASSIGN = 132;
  int RUNSIGNEDSHIFTASSIGNX = 133;

  int DEFAULT = 0;

  String[] tokenImage = {
    ""<EOF>"",
    ""\"" \"""",
    ""\""\\t\"""",
    ""\""\\r\"""",
    ""\""\\f\"""",
    ""\""\\n\"""",
    ""<NONPRINTABLE>"",
    ""<SINGLE_LINE_COMMENT>"",
    ""<HASH_BANG_COMMENT>"",
    ""<MULTI_LINE_COMMENT>"",
    ""\""abstract\"""",
    ""\""boolean\"""",
    ""\""break\"""",
    ""\""class\"""",
    ""\""byte\"""",
    ""\""case\"""",
    ""\""catch\"""",
    ""\""char\"""",
    ""\""const\"""",
    ""\""continue\"""",
    ""\""default\"""",
    ""\""do\"""",
    ""\""double\"""",
    ""\""else\"""",
    ""\""enum\"""",
    ""\""extends\"""",
    ""\""false\"""",
    ""\""final\"""",
    ""\""finally\"""",
    ""\""float\"""",
    ""\""for\"""",
    ""\""goto\"""",
    ""\""if\"""",
    ""\""implements\"""",
    ""\""import\"""",
    ""\""instanceof\"""",
    ""\""int\"""",
    ""\""interface\"""",
    ""\""long\"""",
    ""\""native\"""",
    ""\""new\"""",
    ""\""null\"""",
    ""\""package\"""",
    ""\""private\"""",
    ""\""protected\"""",
    ""\""public\"""",
    ""\""return\"""",
    ""\""short\"""",
    ""\""static\"""",
    ""\""strictfp\"""",
    ""\""switch\"""",
    ""\""synchronized\"""",
    ""\""transient\"""",
    ""\""throw\"""",
    ""\""throws\"""",
    ""\""true\"""",
    ""\""try\"""",
    ""\""void\"""",
    ""\""volatile\"""",
    ""\""while\"""",
    ""<INTEGER_LITERAL>"",
    ""<DECIMAL_LITERAL>"",
    ""<HEX_LITERAL>"",
    ""<OCTAL_LITERAL>"",
    ""<FLOATING_POINT_LITERAL>"",
    ""<EXPONENT>"",
    ""<CHARACTER_LITERAL>"",
    ""<STRING_LITERAL>"",
    ""<FORMAL_COMMENT>"",
    ""<IDENTIFIER>"",
    ""<LETTER>"",
    ""<DIGIT>"",
    ""\""(\"""",
    ""\"")\"""",
    ""\""{\"""",
    ""\""}\"""",
    ""\""[\"""",
    ""\""]\"""",
    ""\"";\"""",
    ""\"",\"""",
    ""\"".\"""",
    ""\""=\"""",
    ""\"">\"""",
    ""\""@gt\"""",
    ""\""<\"""",
    ""\""@lt\"""",
    ""\""!\"""",
    ""\""~\"""",
    ""\""?\"""",
    ""\"":\"""",
    ""\""==\"""",
    ""\""<=\"""",
    ""\""@lteq\"""",
    ""\"">=\"""",
    ""\""@gteq\"""",
    ""\""!=\"""",
    ""\""||\"""",
    ""\""@or\"""",
    ""\""&&\"""",
    ""\""@and\"""",
    ""\""++\"""",
    ""\""--\"""",
    ""\""+\"""",
    ""\""-\"""",
    ""\""*\"""",
    ""\""/\"""",
    ""\""&\"""",
    ""\""@bitwise_and\"""",
    ""\""|\"""",
    ""\""@bitwise_or\"""",
    ""\""^\"""",
    ""\""%\"""",
    ""\""<<\"""",
    ""\""@left_shift\"""",
    ""\"">>\"""",
    ""\""@right_shift\"""",
    ""\"">>>\"""",
    ""\""@right_unsigned_shift\"""",
    ""\""+=\"""",
    ""\""-=\"""",
    ""\""*=\"""",
    ""\""/=\"""",
    ""\""&=\"""",
    ""\""@and_assign\"""",
    ""\""|=\"""",
    ""\""@or_assign\"""",
    ""\""^=\"""",
    ""\""%=\"""",
    ""\""<<=\"""",
    ""\""@left_shift_assign\"""",
    ""\"">>=\"""",
    ""\""@right_shift_assign\"""",
    ""\"">>>=\"""",
    ""\""@right_unsigned_shift_assign\"""",
  };

}
"
jEdit,4.3,org.gjt.sp.jedit.gui.MutableListModel,2,1,0,3,2,1,3,0,2,2.0,2,0.0,0,0.0,0.833333333,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui;

public interface MutableListModel extends javax.swing.ListModel
{
	public boolean removeElement(Object elem);
	public void insertElementAt(Object elem, int index);
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.StandaloneTextArea,20,5,0,31,131,178,1,31,7,0.368421053,853,1.0,1,0.979459459,0.194444444,1,3,41.6,8,2.15,0,"
package org.gjt.sp.jedit.textarea;


import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Properties;

import javax.swing.AbstractAction;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.WindowConstants;

import org.gjt.sp.jedit.IPropertyManager;
import org.gjt.sp.jedit.JEditBeanShellAction;
import org.gjt.sp.jedit.Mode;
import org.gjt.sp.jedit.JEditActionSet;
import org.gjt.sp.jedit.input.AbstractInputHandler;
import org.gjt.sp.jedit.buffer.DefaultFoldHandlerProvider;
import org.gjt.sp.jedit.buffer.DummyFoldHandler;
import org.gjt.sp.jedit.buffer.ExplicitFoldHandler;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.buffer.IndentFoldHandler;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.buffer.KillRing;
import org.gjt.sp.jedit.syntax.ModeProvider;
import org.gjt.sp.jedit.syntax.ParserRuleSet;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.SyntaxUtilities;




public class StandaloneTextArea extends TextArea
{

	
	private final IPropertyManager propertyManager;
	

	
	
	public StandaloneTextArea(IPropertyManager propertyManager)
	{
		super(propertyManager, null);
		this.propertyManager = propertyManager;

		initInputHandler();

		setMouseHandler(new TextAreaMouseHandler(this));
		


		JEditActionSet<JEditBeanShellAction> actionSet = new StandaloneActionSet(propertyManager, this, TextArea.class.getResource(""textarea.actions.xml""));

		addActionSet(actionSet);
		actionSet.load();
		actionSet.initKeyBindings();

		
		if (SyntaxUtilities.propertyManager == null)
		{
			SyntaxUtilities.propertyManager = propertyManager;
		}
		

		initTextArea();

		DefaultFoldHandlerProvider foldHandlerProvider = new DefaultFoldHandlerProvider();

		FoldHandler.foldHandlerProvider = foldHandlerProvider;
		foldHandlerProvider.addFoldHandler(new ExplicitFoldHandler());
		foldHandlerProvider.addFoldHandler(new IndentFoldHandler());
		foldHandlerProvider.addFoldHandler(new DummyFoldHandler());
		JEditBuffer buffer = new JEditBuffer();
		TokenMarker tokenMarker = new TokenMarker();
		tokenMarker.addRuleSet(new ParserRuleSet(""text"",""MAIN""));
		buffer.setTokenMarker(tokenMarker);
		setBuffer(buffer);
		String property = propertyManager.getProperty(""buffer.undoCount"");
		int undoCount = 100;
		if (property != null)
			try
			{
				undoCount = Integer.parseInt(property);
			}
			catch (NumberFormatException e)
			{
			}
		this.buffer.setUndoLimit(undoCount);
		Mode mode = new Mode(""text"");
		mode.setTokenMarker(tokenMarker);
		ModeProvider.instance.addMode(mode);
		KillRing.setInstance(new KillRing());
		KillRing.getInstance().propertiesChanged(100);

	} 

	
	
	private void initTextArea()
	{
		initPainter();
		initGutter();

		setCaretBlinkEnabled(getBooleanProperty(
			""view.caretBlink""));

		setElectricScroll(getIntegerProperty(
			""view.electricBorders"",0));

		if (buffer == null)
			return ;

		String property = propertyManager.getProperty(""buffer.undoCount"");
		int undoCount = 100;
		if (property != null)
		{
			try
			{
				undoCount = Integer.parseInt(property);
			}
			catch (NumberFormatException e)
			{
			}
		}
		buffer.setUndoLimit(undoCount);
	} 

	
	private void initGutter()
	{
		Gutter gutter = getGutter();
		gutter.setExpanded(getBooleanProperty(
			""view.gutter.lineNumbers""));
		int interval = getIntegerProperty(
			""view.gutter.highlightInterval"",5);
		gutter.setHighlightInterval(interval);
		gutter.setCurrentLineHighlightEnabled(getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		gutter.setStructureHighlightEnabled(getBooleanProperty(
			""view.gutter.structureHighlight""));
		gutter.setStructureHighlightColor(
			getColorProperty(""view.gutter.structureHighlightColor""));
		gutter.setBackground(
			getColorProperty(""view.gutter.bgColor""));
		gutter.setForeground(
			getColorProperty(""view.gutter.fgColor""));
		gutter.setHighlightedForeground(
			getColorProperty(""view.gutter.highlightColor""));
		gutter.setFoldColor(
			getColorProperty(""view.gutter.foldColor""));
		gutter.setCurrentLineForeground(
			getColorProperty(""view.gutter.currentLineColor""));
		String alignment = getProperty(
			""view.gutter.numberAlignment"");
		if (""right"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.RIGHT);
		}
		else if (""center"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.CENTER);
		}
		else 
		{
			gutter.setLineNumberAlignment(Gutter.LEFT);
		}

		gutter.setFont(getFontProperty(""view.gutter.font""));

		int width = getIntegerProperty(
			""view.gutter.borderWidth"",3);
		gutter.setBorder(width,
			getColorProperty(""view.gutter.focusBorderColor""),
			getColorProperty(""view.gutter.noFocusBorderColor""),
			painter.getBackground());
	} 

	
	
	private void initPainter()
	{
		TextAreaPainter painter = getPainter();
		painter.setBlockCaretEnabled(false);

		painter.setFont(getFontProperty(""view.font""));
		painter.setStructureHighlightEnabled(getBooleanProperty(
			""view.structureHighlight""));
		painter.setStructureHighlightColor(
			getColorProperty(""view.structureHighlightColor""));
		painter.setEOLMarkersPainted(getBooleanProperty(
			""view.eolMarkers""));
		painter.setEOLMarkerColor(
			getColorProperty(""view.eolMarkerColor""));
		painter.setWrapGuidePainted(getBooleanProperty(
			""view.wrapGuide""));
		painter.setWrapGuideColor(
			getColorProperty(""view.wrapGuideColor""));
		painter.setCaretColor(
			getColorProperty(""view.caretColor""));
		painter.setSelectionColor(
			getColorProperty(""view.selectionColor""));
		painter.setMultipleSelectionColor(
			getColorProperty(""view.multipleSelectionColor""));
		painter.setBackground(
			getColorProperty(""view.bgColor""));
		painter.setForeground(
			getColorProperty(""view.fgColor""));
		painter.setBlockCaretEnabled(getBooleanProperty(
			""view.blockCaret""));
		painter.setThickCaretEnabled(getBooleanProperty(
			""view.thickCaret""));
		painter.setLineHighlightEnabled(getBooleanProperty(
			""view.lineHighlight""));
		painter.setLineHighlightColor(
			getColorProperty(""view.lineHighlightColor""));
		painter.setAntiAlias(new AntiAlias(getProperty(""view.antiAlias"")));
		painter.setFractionalFontMetricsEnabled(getBooleanProperty(
			""view.fracFontMetrics""));

		String defaultFont = getProperty(""view.font"");
		int defaultFontSize = getIntegerProperty(""view.fontsize"",12);
		painter.setStyles(SyntaxUtilities.loadStyles(defaultFont,defaultFontSize));

		SyntaxStyle[] foldLineStyle = new SyntaxStyle[4];
		for(int i = 0; i <= 3; i++)
		{
			foldLineStyle[i] = SyntaxUtilities.parseStyle(
				getProperty(""view.style.foldLine."" + i),
				defaultFont,defaultFontSize,true);
		}
		painter.setFoldLineStyle(foldLineStyle);
	} 

	
	
	
	

	
	public String getProperty(String name)
	{
		return propertyManager.getProperty(name);
	} 

	
	
	private boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name,false);
	} 

	
	
	private boolean getBooleanProperty(String name, boolean def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else if(value.equals(""true"") || value.equals(""yes"")
			|| value.equals(""on""))
			return true;
		else if(value.equals(""false"") || value.equals(""no"")
			|| value.equals(""off""))
			return false;
		else
			return def;
	} 

	
	
	private int getIntegerProperty(String name)
	{
		return getIntegerProperty(name,0);
	} 

	
	
	private int getIntegerProperty(String name, int def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Integer.parseInt(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	} 


	
	
	private Font getFontProperty(String name)
	{
		return getFontProperty(name,null);
	}

	
	private Font getFontProperty(String name, Font def)
	{
		String family = getProperty(name);
		String sizeString = getProperty(name + ""size"");
		String styleString = getProperty(name + ""style"");

		if(family == null || sizeString == null || styleString == null)
			return def;
		else
		{
			int size;

			try
			{
				size = Integer.parseInt(sizeString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			int style;
			try
			{
				style = Integer.parseInt(styleString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			return new Font(family,style,size);
		}
	} 

	
	
	private Color getColorProperty(String name)
	{
		return getColorProperty(name,Color.black);
	}

	
	private Color getColorProperty(String name, Color def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
			return SyntaxUtilities.parseColor(value, def);
	} 


	
	
	@Override
	public void propertiesChanged()
	{
		getInputHandler().removeAllKeyBindings();
		JEditActionSet<JEditBeanShellAction>[] actionSets = getActionContext().getActionSets();
		for (JEditActionSet<JEditBeanShellAction> actionSet : actionSets)
		{
			actionSet.initKeyBindings();
		}
		initBuffer();
		initTextArea();
		super.propertiesChanged();
	} 

	
	
	private void initBuffer()
	{
		String[] bufferProperties = {
			""lineSeparator"",
			""encodingAutodetect"",
			""tabSize"",
			""indentSize"",
			""noTabs"",
			""defaultMode"",
			""undoCount"",
			""wrap"",
			""maxLineLen"",
			""wordBreakChars"",
			""noWordSep"",
			""camelCasedWords"",
			""folding"",
			""collapseFolds""
		};
		for (int i = 0; i < bufferProperties.length; i++)
		{
			String value = getProperty(""buffer."" + bufferProperties[i]);
			if (value == null)
				buffer.unsetProperty(bufferProperties[i]);
			else
				buffer.setProperty(bufferProperties[i], value);
		}
		buffer.propertiesChanged();
	} 

	
	
	@Override
	public void createPopupMenu(MouseEvent evt)
	{
		popup = new JPopupMenu();
		addMenuItem(""undo"", ""Undo"");
		addMenuItem(""redo"", ""Redo"");
		popup.addSeparator();
		addMenuItem(""cut"", ""Cut"");
		addMenuItem(""copy"", ""Copy"");
		addMenuItem(""paste"", ""Paste"");
	} 

	
	
	public JMenuItem addMenuItem(String action, String label)
	{
		final JEditBeanShellAction shellAction = getActionContext().getAction(action);
		if (shellAction == null)
			return null ;
		JMenuItem item = new JMenuItem();
		item.setAction(new AbstractAction(label)
		{
			public void actionPerformed(ActionEvent e)
			{
				shellAction.invoke(StandaloneTextArea.this);
			}
		});
		popup.add(item);
		return item;
	} 

	
	
	public static StandaloneTextArea createTextArea()
	{
		final Properties props = new Properties();
		props.putAll(loadProperties(""/org/gjt/sp/jedit/jedit_keys.props""));
		props.putAll(loadProperties(""/org/gjt/sp/jedit/jedit.props""));
		StandaloneTextArea textArea = new StandaloneTextArea(new IPropertyManager()
		{
			public String getProperty(String name)
			{
				return props.getProperty(name);
			}
		});
		textArea.getBuffer().setProperty(""folding"", ""explicit"");
		return textArea;
	} 

	
	private static Properties loadProperties(String fileName)
	{
		Properties props = new Properties();
		InputStream in = TextArea.class.getResourceAsStream(fileName);
		try
		{
			props.load(in);
		}
		catch (IOException e)
		{
			Log.log(Log.ERROR, TextArea.class, e);
		}
		finally
		{
			IOUtilities.closeQuietly(in);
		}
		return props;
	} 

	
	
	protected static class StandaloneActionSet extends JEditActionSet<JEditBeanShellAction>
	{
		private final IPropertyManager iPropertyManager;
		private final TextArea textArea;

		public StandaloneActionSet(IPropertyManager iPropertyManager, TextArea textArea, URL url)
		{
			super(null, url);
			this.iPropertyManager = iPropertyManager;
			this.textArea = textArea;
		}

		@Override
		protected JEditBeanShellAction[] getArray(int size)
		{
			return new JEditBeanShellAction[size];
		}

		@Override
		protected String getProperty(String name)
		{
			return iPropertyManager.getProperty(name);
		}

		public AbstractInputHandler getInputHandler()
		{
			return textArea.getInputHandler();
		}

		@Override
		protected JEditBeanShellAction createBeanShellAction(String actionName,
								     String code,
								     String selected,
								     boolean noRepeat,
								     boolean noRecord,
								     boolean noRememberLast)
		{
			return new JEditBeanShellAction(actionName,code,selected,noRepeat,noRecord,noRememberLast);
		}
	} 

	
	public static void main(String[] args)
	{
		JFrame frame = new JFrame();
		TextArea text = createTextArea();
		Mode mode = new Mode(""xml"");
		mode.setProperty(""file"",""modes/xml.xml"");
		ModeProvider.instance.addMode(mode);
		text.getBuffer().setMode(mode);
		frame.getContentPane().add(text);
		frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		frame.pack();
		frame.setVisible(true);
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchResults,37,5,0,45,139,484,24,31,14,0.897569444,775,0.625,5,0.947750363,0.122850123,3,12,19.51351351,6,1.5135,0,"

package org.gjt.sp.jedit.search;


import javax.swing.*;
import javax.swing.tree.*;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
import java.io.IOException;
import java.util.*;
import org.gjt.sp.jedit.gui.DefaultFocusComponent;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.gui.StyleEditor;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.SearchMatcher.Match;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.SyntaxUtilities;



public class HyperSearchResults extends JPanel implements EBComponent,
	DefaultFocusComponent
{
	public static final String NAME = ""hypersearch-results"";
	public static final String HIGHLIGHT_PROP = ""hypersearch.results.highlight"";

	
	public HyperSearchResults(View view)
	{
		super(new BorderLayout());

		this.view = view;

		caption = new JLabel();

		Box toolBar = new Box(BoxLayout.X_AXIS);
		toolBar.add(caption);
		toolBar.add(Box.createGlue());

		ActionHandler ah = new ActionHandler();

		highlight = new RolloverButton();
		highlight.setToolTipText(jEdit.getProperty(
			""hypersearch-results.highlight.label""));
		highlight.addActionListener(ah);
		toolBar.add(highlight);
		
		clear = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(""hypersearch-results.clear.icon"")));
		clear.setToolTipText(jEdit.getProperty(
			""hypersearch-results.clear.label""));
		clear.addActionListener(ah);
		toolBar.add(clear);

		multi = new RolloverButton();
		multi.setToolTipText(jEdit.getProperty(
			""hypersearch-results.multi.label""));
		multi.addActionListener(ah);
		toolBar.add(multi);

		stop = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(""hypersearch-results.stop.icon"")));
		stop.setToolTipText(jEdit.getProperty(
			""hypersearch-results.stop.label""));
		stop.addActionListener(ah);
		toolBar.add(stop);
		stop.setEnabled(false);

		add(BorderLayout.NORTH, toolBar);

		resultTreeRoot = new DefaultMutableTreeNode();
		resultTreeModel = new DefaultTreeModel(resultTreeRoot);
		resultTree = new HighlightingTree(resultTreeModel);
		resultTree.setToolTipText(null);
		resultTree.setCellRenderer(new ResultCellRenderer());
		resultTree.setVisibleRowCount(16);
		resultTree.setRootVisible(false);
		resultTree.setShowsRootHandles(true);
		
		
		
		KeyStroke keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);
		resultTree.getInputMap().remove(keyStroke);
		
		if(!OperatingSystem.isMacOSLF())
			resultTree.putClientProperty(""JTree.lineStyle"", ""Angled"");

		resultTree.setEditable(false);

		resultTree.addKeyListener(new KeyHandler());
		resultTree.addMouseListener(new MouseHandler());

		JScrollPane scrollPane = new JScrollPane(resultTree);
		Dimension dim = scrollPane.getPreferredSize();
		dim.width = 400;
		scrollPane.setPreferredSize(dim);
		add(BorderLayout.CENTER, scrollPane);
		resultTree.setTransferHandler(new ResultTreeTransferHandler());
	} 

	
	public void focusOnDefaultComponent()
	{
		resultTree.requestFocus();
	} 

	
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
		multiStatus = jEdit.getBooleanProperty(
			""hypersearch-results.multi"");
		updateHighlightStatus();
		updateMultiStatus();
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
		jEdit.setBooleanProperty(""hypersearch-results.multi"",multiStatus);
	} 

	
	private void visitBuffers(final ResultVisitor visitor, final Buffer buffer)
	{
		
		
		traverseNodes(resultTreeRoot, new TreeNodeCallbackAdapter()
		{
			public boolean processNode(DefaultMutableTreeNode node)
			{
				Object userObject = node.getUserObject();
				if (!(userObject instanceof HyperSearchResult))
					return true;
				HyperSearchResult result = (HyperSearchResult) userObject;
				if (result.pathEquals(buffer.getSymlinkPath()))
					visitor.visit(buffer, result);
				return true;
			}
		});
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			Buffer buffer = bmsg.getBuffer();
			Object what = bmsg.getWhat();
			if(what == BufferUpdate.LOADED)
				visitBuffers(new BufferLoadedVisitor(),buffer);
			else if(what == BufferUpdate.CLOSED)
				visitBuffers(new BufferClosedVisitor(),buffer);
		}
	} 

	
	public static boolean traverseNodes(DefaultMutableTreeNode node, 
			HyperSearchTreeNodeCallback callbackInterface)
	{
		if (!callbackInterface.processNode(node))
			return false;
		for (Enumeration e = node.children(); e.hasMoreElements();)
		{
			DefaultMutableTreeNode childNode = (DefaultMutableTreeNode)e.nextElement();
			if (!traverseNodes(childNode, callbackInterface))
				return false;
		}
		return true;
	} 

	
	public DefaultTreeModel getTreeModel()
	{
		return resultTreeModel;
	} 

	
	
	public JTree getTree()
	{
		return resultTree;
	} 

	
	public void searchStarted()
	{
		stop.setEnabled(true);
		caption.setText(jEdit.getProperty(""hypersearch-results.searching"",
				new String[] { SearchAndReplace.getSearchString() }));
	} 

	
	public void setSearchStatus(String status)
	{
		caption.setText(status);
	} 

	
	public void searchFailed()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.no-results"",
				new String[] { SearchAndReplace.getSearchString() }));

		
		for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				resultTreeRoot.getChildAt(i);
			resultTree.collapsePath(new TreePath(new Object[] {
				resultTreeRoot, node }));
		}
	} 

	
	
	public void searchDone(final DefaultMutableTreeNode searchNode, final DefaultMutableTreeNode selectNode)
	{
		stop.setEnabled(false);
		final int nodeCount = searchNode.getChildCount();
		if (nodeCount < 1)
		{
			searchFailed();
			return;
		}

		caption.setText(jEdit.getProperty(""hypersearch-results.done"",
				new String [] { SearchAndReplace.getSearchString() }));

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(!multiStatus)
				{
					for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
					{
						resultTreeRoot.remove(0);
					}
				}

				resultTreeRoot.add(searchNode);
				resultTreeModel.reload(resultTreeRoot);


				for (int i = 0; i < nodeCount; i++)
				{
					TreePath lastNode = new TreePath(
						((DefaultMutableTreeNode)
						searchNode.getChildAt(i))
						.getPath());

					resultTree.expandPath(lastNode);
				}
				TreePath treePath;
				if (selectNode == null)
				{
					treePath = new TreePath(new Object[]{
						resultTreeRoot, searchNode});
				}
				else
				{
					treePath = new TreePath(selectNode.getPath());
				}
				resultTree.setSelectionPath(treePath);
				resultTree.scrollPathToVisible(
					treePath);
			}
		});
	} 

	
	public void searchDone(final DefaultMutableTreeNode searchNode)
	{
		searchDone(searchNode, null);
	} 

	
	private View view;

	private JLabel caption;
	private final JTree resultTree;
	private DefaultMutableTreeNode resultTreeRoot;
	private DefaultTreeModel resultTreeModel;

	private RolloverButton highlight;
	private RolloverButton clear;
	private RolloverButton multi;
	private RolloverButton stop;
	private boolean multiStatus;

	
	private void updateHighlightStatus()
	{
		String prop = jEdit.getProperty(HIGHLIGHT_PROP);
		if (prop != null && prop.length() > 0)
			highlight.setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""hypersearch-results.match.highlight.icon"")));
		else
			highlight.setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""hypersearch-results.match.normal.icon"")));
		resultTree.repaint();
	} 
	
	
	private void updateMultiStatus()
	{
		if(multiStatus)
			multi.setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""hypersearch-results.multi.multiple.icon"")));
		else
			multi.setIcon(GUIUtilities.loadIcon(jEdit.getProperty(""hypersearch-results.multi.single.icon"")));
	} 
	
	
	public static final int M_OPEN = 0;
	public static final int M_OPEN_NEW_VIEW = 1;
	public static final int M_OPEN_NEW_PLAIN_VIEW = 2;
	public static final int M_OPEN_NEW_SPLIT = 3;

	private void goToSelectedNode(int mode)
	{
		TreePath path = resultTree.getSelectionPath();
		if(path == null)
			return;

		DefaultMutableTreeNode node = (DefaultMutableTreeNode)path
			.getLastPathComponent();
		Object value = node.getUserObject();

		
		if(node.getParent() != resultTreeRoot && value instanceof HyperSearchNode)
		{
			HyperSearchNode n = (HyperSearchNode)value;
			Buffer buffer = n.getBuffer(view);
			if(buffer == null)
				return;

			EditPane pane;

			switch(mode)
			{
			case M_OPEN:
				pane = view.goToBuffer(buffer);
				break;
			case M_OPEN_NEW_VIEW:
				pane = jEdit.newView(view,buffer,false).getEditPane();
				break;
			case M_OPEN_NEW_PLAIN_VIEW:
				pane = jEdit.newView(view,buffer,true).getEditPane();
				break;
			case M_OPEN_NEW_SPLIT:
				pane = view.splitHorizontally();
				break;
			default:
				throw new IllegalArgumentException(""Bad mode: "" + mode);
			}

			n.goTo(pane);
		}
	} 

	
	private void removeSelectedNode()
	{
		TreePath path = resultTree.getSelectionPath();
		if(path == null)
			return;

		MutableTreeNode value = (MutableTreeNode)path
			.getLastPathComponent();

		if(path.getPathCount() > 1)
		{
			
			
			TreePath parentPath = path.getParentPath();
			MutableTreeNode parent = (MutableTreeNode)parentPath
				.getLastPathComponent();
			int removingIndex = parent.getIndex(value);
			int nextIndex = removingIndex + 1;
			if(nextIndex < parent.getChildCount())
			{
				TreeNode next = parent.getChildAt(nextIndex);
				resultTree.setSelectionPath(
					parentPath.pathByAddingChild(next));
			}
			else
			{
				resultTree.setSelectionPath(parentPath);
			}

			resultTreeModel.removeNodeFromParent(value);
		}

		HyperSearchOperationNode.removeNodeFromCache(value);
		if (resultTreeRoot.getChildCount() == 0)
		{
			hideDockable();
		}
	} 

	
	private void removeAllNodes()
	{
		resultTreeRoot.removeAllChildren();
		resultTreeModel.reload(resultTreeRoot);
		setSearchStatus(null);
		hideDockable();
	} 

	
	private void hideDockable()
	{
		view.getDockableWindowManager().hideDockableWindow(NAME);
	} 

	
	SyntaxStyle parseHighlightStyle(String style)
	{
		Font f = (resultTree != null) ? resultTree.getFont() :
			UIManager.getFont(""Tree.font"");
		SyntaxStyle s;
		try
		{
			s = SyntaxUtilities.parseStyle(style, f.getFamily(), f.getSize(), true, null);
		}
		catch (Exception e)
		{
			style = ""color:#000000"";
			s = SyntaxUtilities.parseStyle(style, f.getFamily(), f.getSize(), true);
		}
		return s;
	}
	
	
	

	
	public class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == highlight)
			{
				String prop = jEdit.getProperty(HIGHLIGHT_PROP);
				SyntaxStyle style = new StyleEditor(jEdit.getActiveView(), parseHighlightStyle(prop),
					""hypersearch"").getStyle();
				if (style != null)
					jEdit.setProperty(HIGHLIGHT_PROP, GUIUtilities.getStyleString(style));
				updateHighlightStatus();
			}
			else if(source == clear)
			{
				removeAllNodes();
			}
			else if(source == multi)
			{
				multiStatus = !multiStatus;
				updateMultiStatus();

				if(!multiStatus)
				{
					for(int i = resultTreeRoot.getChildCount() - 2; i >= 0; i--)
					{
						resultTreeModel.removeNodeFromParent(
							(MutableTreeNode)resultTreeRoot
							.getChildAt(i));
					}
				}
			}
			else if(source == stop)
			{
				jEdit.setTemporaryProperty(""hyperSearch-stopButton"", ""true"");
			}
		}
	} 

	
	class HighlightingTree extends JTree
	{
		private String prop;
		private String styleTag;
		
		public HighlightingTree(DefaultTreeModel model)
		{
			super(model);
			prop = jEdit.getProperty(HIGHLIGHT_PROP);
			if (prop != null && prop.length() > 0)
				styleTag = style2html(prop);
		}

		@Override
		public String convertValueToText(Object value, boolean selected,
				boolean expanded, boolean leaf, int row, boolean hasFocus)
		{
			String s = super.convertValueToText(value, selected, expanded, leaf,
				row, hasFocus);
			String newProp = jEdit.getProperty(HIGHLIGHT_PROP);
			if (newProp == null || newProp.length() == 0)
				return s;
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
			while ((node != null) &&
				   (! (node.getUserObject() instanceof HyperSearchOperationNode)))
			{
				node = (DefaultMutableTreeNode) node.getParent();
			}
			if (node == null)
				return s;
			if (! newProp.equals(prop))
			{
				prop = newProp;
				styleTag = style2html(prop);
			}
			SearchMatcher matcher =
				((HyperSearchOperationNode) node.getUserObject()).getSearchMatcher();
			StringBuilder sb = new StringBuilder(""<html><style>.highlight {"");
			sb.append(styleTag);
			sb.append(""}</style><body>"");
			int lineTextIndex = s.indexOf("": "");
			if (lineTextIndex > 0)
			{
				lineTextIndex += 2;
				appendString2html(sb, s.substring(0, lineTextIndex));
				s = s.substring(lineTextIndex);
			}
			int i = 0;
			Match m;
			while ((m = matcher.nextMatch(s.substring(i), true, true, true, false)) != null)
			{
				appendString2html(sb, s.substring(i, i + m.start));
				sb.append(""<span class=\""highlight\"">"");
				appendString2html(sb, s.substring(i + m.start, i + m.end));
				sb.append(""</span>"");
				i += m.end;
			}
			appendString2html(sb, s.substring(i));
			sb.append(""</body></html>"");
			return sb.toString();
		}

		private String color2html(Color c)
		{
			StringBuilder cs = new StringBuilder(""rgb("");
			cs.append(c.getRed());
			cs.append("","");
			cs.append(c.getGreen());
			cs.append("","");
			cs.append(c.getBlue());
			cs.append("");"");
			return cs.toString();
		}
		
		private String style2html(String prop)
		{
			StringBuilder tag = new StringBuilder();
			SyntaxStyle style = parseHighlightStyle(prop);
			Font f = style.getFont();
			Color c = style.getForegroundColor();
			if (c != null)
				tag.append(""color:"").append(color2html(c));
			c = style.getBackgroundColor();
			if (c != null)
				tag.append(""background:"").append(color2html(c));
			if (f.isBold())
				tag.append(""font-weight:bold;"");
			if (f.isItalic())
				tag.append(""font-style: italic;"");
			return tag.toString();
		}
		
		private void appendString2html(StringBuilder sb, String s)
		{
			for (int i = 0; i < s.length(); i++)
			{
				char c = s.charAt(i);
				String r;
				switch (c)
				{
				case '""':
					r = ""&quot;"";
					break;
				
				case '&':
					r = ""&amp;"";
					break;
				case '<':
					r = ""&lt;"";
					break;
				case '>':
					r = ""&gt;"";
					break;
				default:
					r = String.valueOf(c);
					break;
				}
				sb.append(r);
			}
		}
	} 
	
	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_SPACE:
				goToSelectedNode(M_OPEN);

				
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						resultTree.requestFocus();
					}
				});

				evt.consume();
				break;
			case KeyEvent.VK_ENTER:
				goToSelectedNode(M_OPEN);
				evt.consume();
				break;
			case KeyEvent.VK_DELETE:
				removeSelectedNode();
				evt.consume();
				break;
			default:
				break;
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		
		public void mousePressed(MouseEvent evt)
		{
			if(evt.isConsumed())
				return;

			TreePath path1 = resultTree.getPathForLocation(
				evt.getX(),evt.getY());
			if(path1 == null)
				return;

			resultTree.setSelectionPath(path1);
			if (GUIUtilities.isPopupTrigger(evt))
				showPopupMenu(evt);
			else
			{
				goToSelectedNode(M_OPEN);
			}
		} 

		
		private JPopupMenu popupMenu;

		
		private void showPopupMenu(MouseEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();
			
			popupMenu = new JPopupMenu();
			Object userObj = node.getUserObject();
			if (userObj instanceof HyperSearchFileNode
					|| userObj instanceof HyperSearchResult)
			{
				popupMenu.add(new GoToNodeAction(
					""hypersearch-results.open"",
					M_OPEN));
				popupMenu.add(new GoToNodeAction(
					""hypersearch-results.open-view"",
					M_OPEN_NEW_VIEW));
				popupMenu.add(new GoToNodeAction(
					""hypersearch-results.open-plain-view"",
					M_OPEN_NEW_PLAIN_VIEW));
				popupMenu.add(new GoToNodeAction(
					""hypersearch-results.open-split"",
					M_OPEN_NEW_SPLIT));
			}
			if (!(userObj instanceof HyperSearchFolderNode))
				popupMenu.add(new RemoveTreeNodeAction());
			popupMenu.add(new ExpandChildTreeNodesAction());
			if (userObj instanceof HyperSearchFolderNode
					|| userObj instanceof HyperSearchOperationNode)
			{
				popupMenu.add(new CollapseChildTreeNodesAction());
				if (userObj instanceof HyperSearchFolderNode)
					popupMenu.add(new NewSearchAction());
			}
			if (userObj instanceof HyperSearchOperationNode)
			{
				popupMenu.add(new JPopupMenu.Separator());
				HyperSearchOperationNode resultNode = (HyperSearchOperationNode)userObj;
				JCheckBoxMenuItem chkItem = 
					new JCheckBoxMenuItem(jEdit.getProperty(""hypersearch-results.tree-view""),
							resultNode.isTreeViewDisplayed());
				chkItem.addActionListener(new TreeDisplayAction());
				popupMenu.add(chkItem);

				popupMenu.add(new RedoSearchAction((HyperSearchOperationNode)userObj));
			}
			popupMenu.add(new CopyToClipboardAction());

			GUIUtilities.showPopupMenu(popupMenu,evt.getComponent(),
				evt.getX(),evt.getY());
			evt.consume();
		} 

		
	} 

	
	class RemoveTreeNodeAction extends AbstractAction
	{
		RemoveTreeNodeAction()
		{
			super(jEdit.getProperty(""hypersearch-results.remove-node""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			removeSelectedNode();
		}
	}

	
	class RemoveAllTreeNodesAction extends AbstractAction
	{
		RemoveAllTreeNodesAction()
		{
			super(jEdit.getProperty(""hypersearch-results.remove-all-nodes""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			removeAllNodes();
		}
	}
	
	
	class NewSearchAction extends AbstractAction
	{
		NewSearchAction()
		{
			super(jEdit.getProperty(""hypersearch-results.new-search""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();
			HyperSearchFolderNode nodeObj = (HyperSearchFolderNode)operNode.getUserObject();
			
			String glob = ""*"";
			SearchFileSet dirList = SearchAndReplace.getSearchFileSet();
			if (dirList instanceof DirectoryListSet)
				glob = ((DirectoryListSet)dirList).getFileFilter();
			SearchAndReplace.setSearchFileSet(new DirectoryListSet(
					nodeObj.getNodeFile().getAbsolutePath(),glob,true));
			SearchDialog.showSearchDialog(view,null,SearchDialog.DIRECTORY);
		}
	}

	
	class ExpandChildTreeNodesAction extends AbstractAction
	{
		ExpandChildTreeNodesAction()
		{
			super(jEdit.getProperty(""hypersearch-results.expand-child-nodes""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();
			expandAllNodes(operNode);
		}
	}

	
	class CopyToClipboardAction extends AbstractAction
	{
		CopyToClipboardAction()
		{
			super(jEdit.getProperty(""hypersearch-results.copy-to-clipboard""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			ToStringNodes toStringNodes = new ToStringNodes();
			traverseNodes(operNode, toStringNodes);
			StringSelection selection = new StringSelection(
				toStringNodes.nodesString.toString());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(selection, null);
		}
	}

	
	class ToStringNodes implements HyperSearchTreeNodeCallback
	{
		StringBuilder nodesString = new StringBuilder();

		public boolean processNode(DefaultMutableTreeNode node)
		{
			Object userObject = node.getUserObject();
			if (userObject instanceof HyperSearchFileNode)
				nodesString.append(((HyperSearchFileNode)userObject).path);
			else if (userObject instanceof HyperSearchResult)
			{
				HyperSearchResult hsr = (HyperSearchResult)userObject;
				
				nodesString.append(hsr.buffer == null ? hsr.toString() : hsr.buffer.getLineText(hsr.line));
			}
			else
				nodesString.append(userObject.toString());
			nodesString.append(System.getProperty(""line.separator""));
			return true;
		}
	}

	
	class CollapseChildTreeNodesAction extends AbstractAction
	{
		CollapseChildTreeNodesAction()
		{
			super(jEdit.getProperty(""hypersearch-results.collapse-child-nodes""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();
			for (Enumeration e = operNode.children(); e.hasMoreElements();)
			{
				DefaultMutableTreeNode node = (DefaultMutableTreeNode)e.nextElement();
				resultTree.collapsePath(new TreePath(node.getPath()));
			}
			resultTree.scrollPathToVisible(
					new TreePath(operNode.getPath()));
		}
	}

	
	class RedoSearchAction extends AbstractAction
	{
		private HyperSearchOperationNode hyperSearchOperationNode;
		public RedoSearchAction(HyperSearchOperationNode hyperSearchOperationNode)
		{
			super(jEdit.getProperty(""hypersearch-results.redo""));
			this.hyperSearchOperationNode = hyperSearchOperationNode;
		}

		
		public void actionPerformed(ActionEvent e)
		{
			SearchAndReplace.setSearchString(hyperSearchOperationNode.getSearchString());
			SearchAndReplace.setSearchMatcher(hyperSearchOperationNode.getSearchMatcher());
			removeSelectedNode();
			SearchAndReplace.hyperSearch(view, false);
		}
	} 

	
	class TreeDisplayAction extends AbstractAction
	{
		public void actionPerformed(ActionEvent evt)
		{
			JCheckBoxMenuItem menuItem = (JCheckBoxMenuItem) evt.getSource();
			boolean curState = menuItem.isSelected();
			
			TreePath path = resultTree.getSelectionPath();
			DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();
			
			HyperSearchOperationNode operNodeObj = (HyperSearchOperationNode)operNode.getUserObject();
			if (curState)
				operNodeObj.cacheResultNodes(operNode);
			operNode.removeAllChildren();
			Exception excp = null;
			if (curState)
			{
				try
				{
					operNodeObj.insertTreeNodes(resultTree, operNode);
				} 
				catch (Exception ex)
				{
					operNodeObj.restoreFlatNodes(resultTree, operNode);
					menuItem.setSelected(false);
					excp = ex;
				}
				finally
				{
					((DefaultTreeModel)resultTree.getModel()).nodeStructureChanged(operNode);
					expandAllNodes(operNode);
					resultTree.scrollPathToVisible(
							new TreePath(operNode.getPath()));					
				}
				if (excp != null)
					throw new RuntimeException(excp);
			}
			else
				operNodeObj.restoreFlatNodes(resultTree, operNode);
			
			operNodeObj.setTreeViewDisplayed(menuItem.isSelected());
		}
	}
	
	
	public void expandAllNodes(DefaultMutableTreeNode node)
	{
		
		traverseNodes(node, new TreeNodeCallbackAdapter()
		{
			public boolean processNode(DefaultMutableTreeNode node)
			{
				resultTree.expandPath(new TreePath(node.getPath()));
				return true;
			}
		});
	} 
	
	
	class GoToNodeAction extends AbstractAction
	{
		private int mode;

		GoToNodeAction(String labelProp, int mode)
		{
			super(jEdit.getProperty(labelProp));
			this.mode = mode;
		}

		public void actionPerformed(ActionEvent evt)
		{
			goToSelectedNode(mode);
		}
	}

	
	class ResultCellRenderer extends DefaultTreeCellRenderer
	{
		Font plainFont, boldFont;
		
		
		ResultCellRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			if(plainFont == null)
				plainFont = jEdit.getFontProperty(""metal.secondary.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,
				plainFont.getSize());
		} 

		
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,hasFocus);
			setIcon(null);
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;

			if (node.getUserObject() instanceof HyperSearchOperationNode)
			{
				setFont(boldFont);

				CountNodes countNodes = new CountNodes();
				traverseNodes(node, countNodes);

				setText(jEdit.getProperty(""hypersearch-results.result-caption"",
							  new Object[] {
							  node.toString(),
							  Integer.valueOf(countNodes.resultCount),
							  Integer.valueOf(countNodes.bufferCount)
				}));
			}
			else if(node.getUserObject() instanceof HyperSearchFolderNode)
			{
				setFont(plainFont);
				setText(node.toString() + "" ("" + node.getChildCount() + "" files/folders)"");
			}
			else if(node.getUserObject() instanceof HyperSearchFileNode)
			{
				
				setFont(boldFont);
				HyperSearchFileNode hyperSearchFileNode = (HyperSearchFileNode) node.getUserObject();
				setText(jEdit.getProperty(""hypersearch-results.file-caption"",
							  new Object[] {
							  hyperSearchFileNode,
							  Integer.valueOf(hyperSearchFileNode.getCount()),
							  Integer.valueOf(node.getChildCount())
				}));
			}
			else
			{
				setFont(plainFont);
			}

			return this;
		} 

		
		class CountNodes implements HyperSearchTreeNodeCallback
		{
			int bufferCount;
			int resultCount;
			public boolean processNode(DefaultMutableTreeNode node)
			{
				Object userObject = node.getUserObject();
				if (userObject instanceof HyperSearchFileNode)
				{
					resultCount += ((HyperSearchFileNode)userObject).getCount();
					bufferCount++;
				}
				return true;
			}
		}
	} 

	
	class ResultTreeTransferHandler extends TransferHandler
	{
		@Override
		public void exportToClipboard(JComponent comp, Clipboard clip,
				int action) throws IllegalStateException
		{
			TreePath [] paths = resultTree.getSelectionPaths();
			ToStringNodes toStringNodes = new ToStringNodes();
			for (TreePath path: paths)
			{
				DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)
					path.getLastPathComponent();
				toStringNodes.processNode(operNode);
			}
			StringSelection selection = new StringSelection(
				toStringNodes.nodesString.toString());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(selection, null);
		}
	} 
	
	
	
	

	
	interface ResultVisitor
	{
		void visit(Buffer buffer, HyperSearchResult result);
	} 

	
	static class BufferLoadedVisitor implements ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result)
		{
			result.bufferOpened(buffer);
		}
	} 

	
	static class BufferClosedVisitor implements ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result)
		{
			result.bufferClosed();
		}
	} 
	
	
	static class TreeNodeCallbackAdapter implements HyperSearchTreeNodeCallback
	{
		public boolean processNode(DefaultMutableTreeNode node)
		{
			return false;
		}
		
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.DockablePanel,8,5,0,6,25,6,5,4,3,0.80952381,173,0.666666667,2,0.989393939,0.275,3,7,20.25,7,2.25,0,"

package org.gjt.sp.jedit.gui;


import org.gjt.sp.jedit.jEdit;

import java.awt.CardLayout;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

import javax.swing.JPanel;
import javax.swing.border.Border;



class DockablePanel extends JPanel
{
	private PanelWindowContainer panel;
	private DockableWindowManagerImpl wm;

	
	DockablePanel(PanelWindowContainer panel)
	{
		super(new CardLayout());

		this.panel = panel;
		this.wm = panel.getDockableWindowManager();

		ResizeMouseHandler resizeMouseHandler = new ResizeMouseHandler();
		addMouseListener(resizeMouseHandler);
		addMouseMotionListener(resizeMouseHandler);
	} 

	
	PanelWindowContainer getWindowContainer()
	{
		return panel;
	} 

	
	void showDockable(String name)
	{
		((CardLayout)getLayout()).show(this,name);
	} 

	
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	
	public Dimension getPreferredSize()
	{
		final String position = panel.getPosition();
		final int dimension = panel.getDimension();

		if(panel.getCurrent() == null)
			return new Dimension(0,0);
		else
		{
			if(position.equals(DockableWindowManager.TOP)
				|| position.equals(DockableWindowManager.BOTTOM))
			{
				if(dimension <= 0)
				{
					int height = super.getPreferredSize().height;
					panel.setDimension(height);
				}
				return new Dimension(0,
					dimension + PanelWindowContainer
					.SPLITTER_WIDTH);
			}
			else
			{
				if(dimension <= 0)
				{
					int width = super.getPreferredSize().width;
					panel.setDimension(width);
				}
				return new Dimension(dimension +
					PanelWindowContainer.SPLITTER_WIDTH,
					0);
			}
		}
	} 

	
	public void setBounds(int x, int y, int width, int height)
	{
		final String position = panel.getPosition();
		final int dimension = panel.getDimension();

		if(position.equals(DockableWindowManager.TOP) ||
			position.equals(DockableWindowManager.BOTTOM))
		{
			if(dimension != 0 && height <= PanelWindowContainer.SPLITTER_WIDTH)
				panel.show((DockableWindowManagerImpl.Entry) null);
			else
				panel.setDimension(height);
		}
		else
		{
			if(dimension != 0 && width <= PanelWindowContainer.SPLITTER_WIDTH)
				panel.show((DockableWindowManagerImpl.Entry) null);
			else
				panel.setDimension(width);
		}

		super.setBounds(x,y,width,height);
	} 

	
	static Point dragStart;
	
	
	class ResizeMouseHandler extends MouseAdapter implements MouseMotionListener
	{
		
		boolean canDrag;

		
		public void mousePressed(MouseEvent evt)
		{
			if(canDrag)
			{
				continuousLayout = jEdit.getBooleanProperty(""appearance.continuousLayout"");
				wm.setResizePos(panel.getDimension(),panel);
				dragStart = evt.getPoint();
			}
		} 

		
		public void mouseReleased(MouseEvent evt)
		{
			if(canDrag)
			{
				if (!continuousLayout)
				{
					panel.setDimension(wm.resizePos
							   + PanelWindowContainer
						.SPLITTER_WIDTH);
				}
				wm.finishResizing();
				dragStart = null;
				wm.revalidate();
			}
		} 

		
		public void mouseMoved(MouseEvent evt)
		{
			Border border = getBorder();
			if(border == null)
			{
				
				return;
			}

			String position = panel.getPosition();

			Insets insets = border.getBorderInsets(DockablePanel.this);
			canDrag = false;
			
			if(position.equals(DockableWindowManager.TOP))
			{
				if(evt.getY() >= getHeight() - insets.bottom)
					canDrag = true;
			} 
			
			else if(position.equals(DockableWindowManager.LEFT))
			{
				if(evt.getX() >= getWidth() - insets.right)
					canDrag = true;
			} 
			
			else if(position.equals(DockableWindowManager.BOTTOM))
			{
				if(evt.getY() <= insets.top)
					canDrag = true;
			} 
			
			else if(position.equals(DockableWindowManager.RIGHT))
			{
				if(evt.getX() <= insets.left)
					canDrag = true;
			} 

			if (dragStart == null)
			{
				if(canDrag)
				{
					wm.setCursor(Cursor.getPredefinedCursor(
						getAppropriateCursor()));
				}
				else
				{
					wm.setCursor(Cursor.getPredefinedCursor(
						Cursor.DEFAULT_CURSOR));
				}
			}
		} 

		
		public void mouseDragged(MouseEvent evt)
		{
			if(!canDrag)
				return;

			if(dragStart == null) 
				return;

			int dimension = panel.getDimension();

			String position = panel.getPosition();

			int newSize = 0;
			
			if(position.equals(DockableWindowManager.TOP))
			{
				newSize = evt.getY();
				wm.setResizePos(
					evt.getY() - dragStart.y
					+ dimension,
					panel);
			} 
			
			else if(position.equals(DockableWindowManager.LEFT))
			{
				newSize = evt.getX();
				wm.setResizePos(evt.getX() - dragStart.x
					+ dimension,
					panel);
			} 
			
			else if(position.equals(DockableWindowManager.BOTTOM))
			{
				newSize = dimension - evt.getY();
				wm.setResizePos(dimension - evt.getY()
					+ dragStart.y,
					panel);
			} 
			
			else if(position.equals(DockableWindowManager.RIGHT))
			{
				newSize = dimension - evt.getX();
				wm.setResizePos(dimension - evt.getX()
					+ dragStart.x,
					panel);
			} 

			if (continuousLayout)
			{
				panel.setDimension(newSize
						   + PanelWindowContainer.SPLITTER_WIDTH);
				wm.revalidate();
			}
		} 

		
		public void mouseExited(MouseEvent evt)
		{
			if (dragStart == null)
			{
				wm.setCursor(Cursor.getPredefinedCursor(
					Cursor.DEFAULT_CURSOR));
			}
		} 

		
		private int getAppropriateCursor()
		{
			String position = panel.getPosition();

			if(position.equals(DockableWindowManager.TOP))
				return Cursor.N_RESIZE_CURSOR;
			else if(position.equals(DockableWindowManager.LEFT))
				return Cursor.W_RESIZE_CURSOR;
			else if(position.equals(DockableWindowManager.BOTTOM))
				return Cursor.S_RESIZE_CURSOR;
			else if(position.equals(DockableWindowManager.RIGHT))
				return Cursor.E_RESIZE_CURSOR;
			else
				throw new InternalError();
		} 

		private boolean continuousLayout;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.io.CopyFileWorker,2,2,0,4,6,0,0,4,2,0.0,44,1.0,0,0.857142857,0.666666667,0,0,19.5,1,0.5,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.io.IOException;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkRequest;



public class CopyFileWorker extends WorkRequest
{
	private final Component comp;
	private final String source;
	
	private final String target;

	
	
	
	public CopyFileWorker(Component comp, String source, String target) 
	{
		if (source == null || target == null)
			throw new NullPointerException(""The source and target cannot be null"");
		this.comp = comp;
		this.source = source;
		this.target = target;
	} 

	
	public void run() 
	{
		try
		{
			VFS.copy(this, source, target, comp, false);
		}
		catch (IOException e)
		{
			Log.log(Log.ERROR,this, e, e);
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.textarea.ScreenLineManager,8,1,0,6,19,0,3,3,2,0.714285714,214,1.0,1,0.0,0.583333333,0,0,25.25,4,2.0,0,"

package org.gjt.sp.jedit.textarea;


import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;



class ScreenLineManager
{
	
	ScreenLineManager(JEditBuffer buffer)
	{
		this.buffer = buffer;
		if(!buffer.isLoading())
			reset();
	} 
	
	
	boolean isScreenLineCountValid(int line)
	{
		return (screenLines[line] & SCREEN_LINES_VALID_MASK) != 0;
	} 

	
	
	int getScreenLineCount(int line)
	{
		return screenLines[line] >> SCREEN_LINES_SHIFT;
	} 

	
	
	void setScreenLineCount(int line, int count)
	{
		if(count > Short.MAX_VALUE)
		{
			
			count = Short.MAX_VALUE;
		}

		if(Debug.SCREEN_LINES_DEBUG)
			Log.log(Log.DEBUG,this,new Exception(""setScreenLineCount("" + line + ',' + count + ')'));
		screenLines[line] = (short)(count << SCREEN_LINES_SHIFT
			| SCREEN_LINES_VALID_MASK);
	} 

	
	void invalidateScreenLineCounts()
	{
		int lineCount = buffer.getLineCount();
		for(int i = 0; i < lineCount; i++)
			screenLines[i] &= ~SCREEN_LINES_VALID_MASK;
	} 

	
	void reset()
	{
		screenLines = new short[buffer.getLineCount()];
	} 

	
	public void contentInserted(int startLine, int numLines)
	{
		int endLine = startLine + numLines;
		screenLines[startLine] &= ~SCREEN_LINES_VALID_MASK;

		int lineCount = buffer.getLineCount();

		if(numLines > 0)
		{
			if(screenLines.length <= lineCount)
			{
				short[] screenLinesN = new short[((lineCount + 1) << 1)];
				System.arraycopy(screenLines,0,screenLinesN,0,
						 screenLines.length);
				screenLines = screenLinesN;
			}

			System.arraycopy(screenLines,startLine,screenLines,
				endLine,lineCount - endLine);

			for(int i = 0; i < numLines; i++)
				screenLines[startLine + i] = 0;
		}
	} 

	
	public void contentRemoved(int startLine, int numLines)
	{
		int endLine = startLine + numLines;
		screenLines[startLine] &= ~SCREEN_LINES_VALID_MASK;

		if(numLines > 0 && endLine != screenLines.length)
		{
			System.arraycopy(screenLines,endLine + 1,screenLines,
				startLine + 1,screenLines.length - endLine - 1);
		}
	} 

	
	private static final int SCREEN_LINES_SHIFT = 1;
	private static final int SCREEN_LINES_VALID_MASK = 1;

	private final JEditBuffer buffer;
	
	private short[] screenLines;
	
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.InterpreterError,1,4,0,24,2,0,24,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"


package org.gjt.sp.jedit.bsh;


public class InterpreterError extends RuntimeException
{
	public InterpreterError(String s)
	{
		super(s);
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.gui.FilePropertiesDialog,13,7,0,12,75,40,2,12,10,0.740740741,814,1.0,3,0.982035928,0.246153846,1,2,60.92307692,7,1.9231,0,"
package org.gjt.sp.jedit.gui;


import java.io.File;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;

import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.io.VFSFile;
import org.gjt.sp.jedit.io.FileVFS.LocalFile;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.IOUtilities;



public class FilePropertiesDialog extends EnhancedDialog
{
	private final VFSBrowser browser;
	private final VFSFile[] selectedFiles;
	private final LocalFile local;

	
	
	public FilePropertiesDialog(View view, VFSBrowser browser, VFSFile[] files)
	{
		super(view,jEdit.getProperty(""vfs.browser.properties.title""),true);
		GUIUtilities.loadGeometry(this,""propdialog"");

		this.browser = browser;

		if (files.length > 0)
			selectedFiles = files;
		else
			selectedFiles = browser.getSelectedFiles();
		local = (LocalFile) selectedFiles[0];
		createAndShowGUI();
	} 

	
	public void addComponentsToPane()
	{
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,5,0,5));
		setContentPane(content);

		if (selectedFiles.length == 1)
		{
			content.add(BorderLayout.NORTH, createNorthPanel());
			content.add(BorderLayout.CENTER, createCenterPanel());
			content.add(BorderLayout.SOUTH, createSouthPanel());
		}
		else if(selectedFiles.length > 1)
		{
			content.add(BorderLayout.NORTH, createNorthPanelAll());
			content.add(BorderLayout.CENTER, createCenterPanelAll());
			content.add(BorderLayout.SOUTH, createSouthPanelAll());
		}
	} 

	
	public JPanel createNorthPanelAll()
	{
		JPanel northPanel = new JPanel(new BorderLayout());

		infoIcon = new JLabel();
		infoIcon.setIcon(UIManager.getIcon(""OptionPane.informationIcon""));
		northPanel.add(BorderLayout.WEST, infoIcon);

		int filesCounter = 0;
		int directoriesCounter = 0;
		for(int i=0;i<selectedFiles.length;i++)
		{
			if(selectedFiles[i].getType() == VFSFile.DIRECTORY)
			{
				directoriesCounter++;
			}
			else if(selectedFiles[i].getType() == VFSFile.FILE)
			{
				filesCounter++;
			}
		}
		JPanel nameField = new JPanel();
		nameField.add(new JLabel(jEdit.getProperty(""fileprop.selectedFiles"")+"": ""+filesCounter+"", ""+
							jEdit.getProperty(""fileprop.selectedDirectories"")+"": ""+directoriesCounter));

		northPanel.add(BorderLayout.CENTER, nameField);
		northPanel.add(BorderLayout.SOUTH, new JPanel());

		return northPanel;
	} 

	
	public JPanel createCenterPanelAll()
	{
		long filesSize = 0L;
		JPanel centerPanel = new JPanel(new BorderLayout());

		for (int i=0;i<selectedFiles.length;i++)
		{
			if(selectedFiles[i].getType() == VFSFile.DIRECTORY)
			{
				File ioFile = new File(selectedFiles[i].getPath());
				filesSize += IOUtilities.fileLength(ioFile);
			}
			else if(selectedFiles[i].getType() == VFSFile.FILE)
			{
				filesSize += selectedFiles[i].getLength();
			}
		}

		JPanel propField = new JPanel();
		propField.setLayout(new GridLayout(2, 1));
		String path = local.getPath();
		if(OperatingSystem.isWindows() || OperatingSystem.isWindows9x() || OperatingSystem.isWindowsNT())
		{
			path = path.substring(0, path.lastIndexOf(92)); 
		}
		else
		{
			path = path.substring(0, path.lastIndexOf('/'));
		}
		propField.add(new JLabel(jEdit.getProperty(""fileprop.path"")+"": ""+path));
		propField.add(new JLabel(jEdit.getProperty(""fileprop.size"")+"": ""+MiscUtilities.formatFileSize(filesSize)));
		Border etch = BorderFactory.createEtchedBorder();
		propField.setBorder(BorderFactory.createTitledBorder(etch, jEdit.getProperty(""fileprop.properties"")));
		centerPanel.add(BorderLayout.CENTER, propField);

		return centerPanel;
	} 

	
	public JPanel createSouthPanelAll()
	{
		ButtonActionHandler actionHandler = new ButtonActionHandler();
		JPanel southPanel = new JPanel(new BorderLayout());

		JPanel buttonsField = new JPanel();
		okButton = new JButton(jEdit.getProperty(""fileprop.okBtn""));
		buttonsField.add(okButton);
		okButton.addActionListener(actionHandler);
		cancelButton = new JButton(jEdit.getProperty(""fileprop.cancelBtn""));
		buttonsField.add(cancelButton);
		cancelButton.addActionListener(actionHandler);

		southPanel.add(BorderLayout.EAST, buttonsField);

		return southPanel;
	} 

	
	public JPanel createNorthPanel()
	{
		JPanel northPanel = new JPanel(new BorderLayout());

		infoIcon = new JLabel();
		infoIcon.setIcon(UIManager.getIcon(""OptionPane.informationIcon""));
		northPanel.add(BorderLayout.WEST, infoIcon);

		JPanel nameField = new JPanel();
		nameField.add(new JLabel(jEdit.getProperty(""fileprop.name"")+"": ""));
		nameTextField = new JTextField(local.getName(), 20);
		nameField.add(nameTextField);
		northPanel.add(BorderLayout.CENTER, nameField);
		northPanel.add(BorderLayout.SOUTH, new JPanel());

		return northPanel;
	} 

	
	public JPanel createCenterPanel()
	{
		SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd hh:mm"");

		JPanel centerPanel = new JPanel(new BorderLayout());

		JPanel propField = new JPanel();
		propField.setLayout(new GridLayout(4, 1));
		propField.add(new JLabel(jEdit.getProperty(""fileprop.name"")+"": ""+local.getName()));
		propField.add(new JLabel(jEdit.getProperty(""fileprop.path"")+"": ""+local.getPath()));
		propField.add(new JLabel(jEdit.getProperty(""fileprop.lastmod"")+"": ""+sdf.format(new Date(local.getModified()))));
		if(local.getType() == VFSFile.DIRECTORY)
		{
			File ioFile = new File(local.getPath());
			propField.add(new JLabel(jEdit.getProperty(""fileprop.size"")+"": ""+MiscUtilities.formatFileSize(IOUtilities.fileLength(ioFile))));
		}
		else
		{
			propField.add(new JLabel(jEdit.getProperty(""fileprop.size"")+"": ""+MiscUtilities.formatFileSize(local.getLength())));
		}
		Border etch = BorderFactory.createEtchedBorder();
		propField.setBorder(BorderFactory.createTitledBorder(etch, jEdit.getProperty(""fileprop.properties"")));
		centerPanel.add(BorderLayout.CENTER, propField);

		JPanel attributeField = new JPanel();
		attributeField.setLayout(new GridLayout(1, 2));
		readable = new JCheckBox(jEdit.getProperty(""fileprop.readable""));
		readable.setSelected(local.isReadable());
		readable.setEnabled(false);
		attributeField.add(readable);

		write = new JCheckBox(jEdit.getProperty(""fileprop.writeable""));
		write.setSelected(local.isWriteable());
		write.setEnabled(false);
		attributeField.add(write);
		attributeField.setBorder(BorderFactory.createTitledBorder(etch, jEdit.getProperty(""fileprop.attribute"")));
		centerPanel.add(BorderLayout.SOUTH, attributeField);

		return centerPanel;
	} 

	
	public JPanel createSouthPanel()
	{
		ButtonActionHandler actionHandler = new ButtonActionHandler();
		JPanel southPanel = new JPanel(new BorderLayout());

		JPanel buttonsField = new JPanel();
		okButton = new JButton(jEdit.getProperty(""fileprop.okBtn""));
		buttonsField.add(okButton);
		okButton.addActionListener(actionHandler);
		cancelButton = new JButton(jEdit.getProperty(""fileprop.cancelBtn""));
		buttonsField.add(cancelButton);
		cancelButton.addActionListener(actionHandler);

		southPanel.add(BorderLayout.EAST, buttonsField);

		return southPanel;
	} 

	
	@Override
	public void ok()
	{
		if(nameTextField != null)
		{
			browser.rename(browser.getSelectedFiles()[0].getPath(), nameTextField.getText());
		}

		GUIUtilities.saveGeometry(this,""propdialog"");
		setVisible(false);
	} 

	
	@Override
	public void cancel()
	{
		GUIUtilities.saveGeometry(this,""propdialog"");
		setVisible(false);
	} 

	
	private JButton okButton;
	private JButton cancelButton;
	private JTextField nameTextField;
	private JLabel infoIcon;
	private JCheckBox readable;
	private JCheckBox write;

	
	private void createAndShowGUI()
	{
		addComponentsToPane();
		pack();

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		setFocusable(true);
		toFront();
		requestFocus();
		setResizable(false);
		setVisible(true);
	} 

	
	private class ButtonActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();


			if(source == okButton)
			{
				ok();
			}
			else if(source == cancelButton)
			{
				cancel();
			}
		}
	} 
	
}
"
jEdit,4.3,org.gjt.sp.jedit.options.MouseOptionPane,4,6,0,2,21,0,0,2,2,0.571428571,264,1.0,0,0.997019374,1.0,2,4,63.25,6,2.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class MouseOptionPane extends AbstractOptionPane
{
	
	public MouseOptionPane()
	{
		super(""mouse"");
	} 

	
	protected void _init()
	{
		
		dragAndDrop = new JCheckBox(jEdit.getProperty(
			""options.mouse.dragAndDrop""));
		dragAndDrop.setSelected(jEdit.getBooleanProperty(
			""view.dragAndDrop""));
		addComponent(dragAndDrop);

		
		joinNonWordChars = new JCheckBox(jEdit.getProperty(
			""options.mouse.joinNonWordChars""));
		joinNonWordChars.setSelected(jEdit.getBooleanProperty(
			""view.joinNonWordChars""));
		addComponent(joinNonWordChars);

		
		middleMousePaste = new JCheckBox(jEdit.getProperty(""options.mouse""
			+ "".middleMousePaste""));
		middleMousePaste.setSelected(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
		addComponent(middleMousePaste);

		
		ctrlForRectangularSelection = new JCheckBox(jEdit.getProperty(
			""options.mouse.ctrlForRectangularSelection""));
		ctrlForRectangularSelection.setSelected(jEdit.getBooleanProperty(
			""view.ctrlForRectangularSelection""));
		addComponent(ctrlForRectangularSelection);

		
		int c = clickActionKeys.length;
		String[] clickActionNames = new String[c];
		for(int i = 0; i < c; i++)
		{
			clickActionNames[i] = jEdit.getProperty(
				""options.mouse.gutter.""+clickActionKeys[i]);
		}

		c = clickModifierKeys.length;
		String[] clickModifierNames = new String[c];
		for(int i = 0; i < c; i++)
		{
			clickModifierNames[i] = jEdit.getProperty(
				""options.mouse.gutter.""+clickModifierKeys[i]);
		}

		gutterClickActions = new JComboBox[c];

		for(int i = 0; i < c; i++)
		{
			JComboBox cb = new JComboBox(clickActionNames);
			gutterClickActions[i] = cb;

			String val = jEdit.getProperty(""view.gutter.""+clickModifierKeys[i]);
			for(int j = 0; j < clickActionKeys.length; j++)
			{
				if(val.equals(clickActionKeys[j]))
				{
					cb.setSelectedIndex(j);
				}
			}

			addComponent(clickModifierNames[i],cb);
		}
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(""view.dragAndDrop"",
					 dragAndDrop.isSelected());
		jEdit.setBooleanProperty(""view.joinNonWordChars"",
					 joinNonWordChars.isSelected());
		jEdit.setBooleanProperty(""view.middleMousePaste"",
					 middleMousePaste.isSelected());
		jEdit.setBooleanProperty(""view.ctrlForRectangularSelection"",
					 ctrlForRectangularSelection.isSelected());

		int c = clickModifierKeys.length;
		for(int i = 0; i < c; i++)
		{
			int idx = gutterClickActions[i].getSelectedIndex();
			jEdit.setProperty(""view.gutter.""+clickModifierKeys[i],
				clickActionKeys[idx]);
		}
	} 

	
	private JCheckBox dragAndDrop;
	private JCheckBox joinNonWordChars;
	private JCheckBox middleMousePaste;
	private JCheckBox ctrlForRectangularSelection;

	private JComboBox[] gutterClickActions;

	
	private static final String[] clickActionKeys = new String[] {
		""toggle-fold"",
		""toggle-fold-fully""
	};
	
	private static final String[] clickModifierKeys = new String[] {
		""foldClick"",
		""SfoldClick""
	}; 
}
"
jEdit,4.3,org.gjt.sp.jedit.gui.PanelWindowContainer,23,1,0,25,98,95,8,22,13,0.842424242,734,0.8,3,0.0,0.217391304,0,0,30.26086957,9,2.2174,0,"

package org.gjt.sp.jedit.gui;


import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.LayoutManager;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.font.LineMetrics;
import java.awt.geom.AffineTransform;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.AbstractButton;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JToggleButton;
import javax.swing.UIManager;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.metal.MetalLookAndFeel;

import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.gui.DockableWindowManager.DockingArea;
import org.gjt.sp.jedit.msg.DockableWindowUpdate;
import org.gjt.sp.util.StandardUtilities;


public class PanelWindowContainer implements DockableWindowContainer, DockingArea
{
	
	public PanelWindowContainer(DockableWindowManagerImpl wm, String position,
		int dimension)
	{
		this.wm = wm;
		this.position = position;

		
		buttonPanel = new JPanel(new ButtonLayout());
		buttonPanel.setBorder(new EmptyBorder(1,1,1,1));

		closeBox = new JButton(GUIUtilities.loadIcon(""closebox.gif""));
		closeBox.setRequestFocusEnabled(false);
		closeBox.setToolTipText(jEdit.getProperty(""view.docking.close-tooltip""));
		if(OperatingSystem.isMacOSLF())
			closeBox.putClientProperty(""JButton.buttonType"",""toolbar"");

		closeBox.setMargin(new Insets(0,0,0,0));

		closeBox.addActionListener(new ActionHandler());

		menuBtn = new JButton(GUIUtilities.loadIcon(jEdit.getProperty(""dropdown-arrow.icon"")));
		menuBtn.setRequestFocusEnabled(false);
		menuBtn.setToolTipText(jEdit.getProperty(""view.docking.menu-tooltip""));
		if(OperatingSystem.isMacOSLF())
			menuBtn.putClientProperty(""JButton.buttonType"",""toolbar"");

		menuBtn.setMargin(new Insets(0,0,0,0));

		menuBtn.addMouseListener(new MenuMouseHandler());

		buttonGroup = new ButtonGroup();
		
		buttonGroup.add(nullButton = new JToggleButton());
		

		dockables = new ArrayList<DockableWindowManagerImpl.Entry>();
		buttons = new ArrayList<AbstractButton>();
		dockablePanel = new DockablePanel(this);

		this.dimension = dimension;
	} 

	
	
	public DockableWindowManagerImpl getDockableWindowManager()
	{
		return wm;
	} 
	
	
	public void register(DockableWindowManagerImpl.Entry entry)
	{
		dockables.add(entry);

		
		int rotation;
		if(position.equals(DockableWindowManagerImpl.TOP)
			|| position.equals(DockableWindowManagerImpl.BOTTOM))
			rotation = RotatedTextIcon.NONE;
		else if(position.equals(DockableWindowManagerImpl.LEFT))
			rotation = RotatedTextIcon.CCW;
		else if(position.equals(DockableWindowManagerImpl.RIGHT))
			rotation = RotatedTextIcon.CW;
		else
			throw new InternalError(""Invalid position: "" + position);

		JToggleButton button = new JToggleButton();
		button.setMargin(new Insets(1,1,1,1));
		button.setRequestFocusEnabled(false);
		button.setIcon(new RotatedTextIcon(rotation,button.getFont(),
			entry.shortTitle()));
		button.setActionCommand(entry.factory.name);
		button.addActionListener(new ActionHandler());
		button.addMouseListener(new MenuMouseHandler());
		if(OperatingSystem.isMacOSLF())
			button.putClientProperty(""JButton.buttonType"",""toolbar"");
		

		buttonGroup.add(button);
		buttons.add(button);
		entry.btn = button;

		wm.revalidate();
	} 

	
	public void unregister(DockableWindowManagerImpl.Entry entry)
	{
		if(entry.factory.name.equals(mostRecent))
			mostRecent = null;

		if(entry.btn != null)
		{
			buttonPanel.remove(entry.btn);
			buttons.remove(entry.btn);
			entry.btn = null;
		}

		dockables.remove(entry);
		if(entry.win != null)
			dockablePanel.remove(entry.win);

		if(current == entry)
		{
			current = null;
			show(current);
		}
		else
		{
			wm.revalidate();
			dockablePanel.repaint();
			buttonPanel.repaint();
		}
	} 

	
	public void remove(DockableWindowManagerImpl.Entry entry)
	{
		if(entry.factory.name.equals(mostRecent))
			mostRecent = null;

		if(entry.win != null)
		{
			dockablePanel.remove(entry.win);
			entry.win = null;
		}

		if(current == entry)
		{
			current = null;
			show(current);
		}
		else
		{
			wm.revalidate();
			dockablePanel.repaint();
		}
	} 

	
	public void showMostRecent()
	{
		if(dockables.isEmpty())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}

		if(mostRecent == null)
		{
			mostRecent = dockables.get(0).factory.name;
		}

		wm.showDockableWindow(mostRecent);
	} 

	
	public void show(DockableWindowManagerImpl.Entry entry)
	{
		if(current == entry)
		{
			if(entry != null)
			{
				if(entry.win instanceof DefaultFocusComponent)
				{
					((DefaultFocusComponent)entry.win)
						.focusOnDefaultComponent();
				}
				else
				{
					entry.win.requestDefaultFocus();
				}
			}
			return;
		}

		if(entry != null)
		{
			if(current == null)
			{
				
				
				dockablePanel.setBorder(new DockBorder(position));
			}

			mostRecent = entry.factory.name;
			this.current = entry;

			if(entry.win.getParent() != dockablePanel)
				dockablePanel.add(entry.factory.name,entry.win);

			dockablePanel.showDockable(entry.factory.name);

			entry.btn.setSelected(true);

			if(entry.win instanceof DefaultFocusComponent)
			{
				((DefaultFocusComponent)entry.win)
					.focusOnDefaultComponent();
			}
			else
			{
				entry.win.requestDefaultFocus();
			}
		}
		else
		{
			if (current != null)
			{
				
				Object reason = DockableWindowUpdate.DEACTIVATED;
				EditBus.send(new DockableWindowUpdate(wm, reason, current.factory.name));
			}
			current = null;
			nullButton.setSelected(true);
			
			dockablePanel.setBorder(null);

			wm.getView().getTextArea().requestFocus();
		}

		wm.revalidate();
		dockablePanel.repaint();
	} 

	
	public boolean isVisible(DockableWindowManagerImpl.Entry entry)
	{
		return current == entry;
	} 

	
	
	public String getCurrent()
	{
		if(current == null)
			return null;
		else
			return current.factory.name;
	} 

	
	
	public int getDimension()
	{
		return dimension;
	} 

	
	
	public String getPosition()
	{
		return position;
	} 

	
	public String[] getDockables()
	{
		String[] retVal = new String[dockables.size()];
		for(int i = 0; i < dockables.size(); i++)
		{
			DockableWindowManagerImpl.Entry entry = dockables.get(i);
			retVal[i] = entry.factory.name;
		}
		return retVal;
	} 

	
	static final int SPLITTER_WIDTH = 10;
	DockablePanel dockablePanel;
	JPanel buttonPanel;

	
	void save()
	{
		jEdit.setIntegerProperty(""view.dock."" + position + "".dimension"",
			dimension);
		if(current == null)
			jEdit.unsetProperty(""view.dock."" + position + "".last"");
		else
		{
			jEdit.setProperty(""view.dock."" + position + "".last"",
				current.factory.name);
		}
	} 

	
	void setDimension(int dimension)
	{
		if(dimension > SPLITTER_WIDTH)
			this.dimension = dimension - SPLITTER_WIDTH;
	} 

	
	void sortDockables()
	{
		buttonPanel.removeAll();
		buttonPanel.add(closeBox);
		buttonPanel.add(menuBtn);
		Collections.sort(buttons,new DockableWindowCompare());
		for(int i = 0; i < buttons.size(); i++)
		{
			buttonPanel.add(buttons.get(i));
		}
	} 

	
	
	int getWrappedDimension(int dimension)
	{
		return ((ButtonLayout)buttonPanel.getLayout())
			.getWrappedDimension(buttonPanel,dimension);
	} 

	

	
	private final DockableWindowManagerImpl wm;
	private final String position;
	private final JButton closeBox;
	private final JButton menuBtn;
	private final ButtonGroup buttonGroup;
	private final JToggleButton nullButton;
	private int dimension;
	private final List<DockableWindowManagerImpl.Entry> dockables;
	private final List<AbstractButton> buttons;
	private DockableWindowManagerImpl.Entry current;
	private JPopupMenu popup;

	
	private String mostRecent;
	

	

	
	static class DockableWindowCompare implements Comparator<AbstractButton>
	{
		public int compare(AbstractButton o1, AbstractButton o2)
		{
			String name1 = o1.getActionCommand();
			String name2 = o2.getActionCommand();
			return StandardUtilities.compareStrings(
				jEdit.getProperty(name1 + "".title"",""""),
				jEdit.getProperty(name2 + "".title"",""""),
				true);
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(popup != null && popup.isVisible())
				popup.setVisible(false);

			if(evt.getSource() == closeBox)
				show((DockableWindowManagerImpl.Entry)null);
			else
			{
				if(wm.isDockableWindowVisible(evt.getActionCommand()))
					show((DockableWindowManagerImpl.Entry)null);
				else
					wm.showDockableWindow(evt.getActionCommand());
			}
		}
	} 

	
	class MenuMouseHandler extends MouseAdapter
	{
		public void mousePressed(MouseEvent evt)
		{
			if(popup != null && popup.isVisible())
			{
				popup.setVisible(false);
				return;
			}

			Component comp = (Component)evt.getSource();
			String dockable;
			if(comp instanceof JToggleButton)
				dockable = ((JToggleButton)comp).getActionCommand();
			else
				dockable = getCurrent();

			if(comp == menuBtn || GUIUtilities.isPopupTrigger(evt))
			{
				if(dockable == null)
				{
					popup = wm.createPopupMenu(PanelWindowContainer.this,null,false);
				}
				else
				{
					popup = wm.createPopupMenu(PanelWindowContainer.this,dockable,false);
				}

				int x, y;
				boolean point;
				if(comp == menuBtn)
				{
					x = 0;
					y = menuBtn.getHeight();
					point = false;
				}
				else
				{
					x = evt.getX();
					y = evt.getY();
					point = true;
				}
				GUIUtilities.showPopupMenu(popup,
					comp,x,y,point);
			}
		}
	} 

	
	static class DockBorder implements Border
	{
		String position;
		Insets insets;
		Color color1;
		Color color2;
		Color color3;

		
		DockBorder(String position)
		{
			this.position = position;
			insets = new Insets(
				position.equals(DockableWindowManagerImpl.BOTTOM)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManagerImpl.RIGHT)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManagerImpl.TOP)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManagerImpl.LEFT)
					? SPLITTER_WIDTH : 0);
		} 

		
		public void paintBorder(Component c, Graphics g,
			int x, int y, int width, int height)
		{
			updateColors();

			if(color1 == null || color2 == null || color3 == null)
				return;

			if(position.equals(DockableWindowManagerImpl.BOTTOM))
				paintHorizBorder(g,x,y,width);
			else if(position.equals(DockableWindowManagerImpl.RIGHT))
				paintVertBorder(g,x,y,height);
			else if(position.equals(DockableWindowManagerImpl.TOP))
			{
				paintHorizBorder(g,x,y + height
					- SPLITTER_WIDTH,width);
			}
			else if(position.equals(DockableWindowManagerImpl.LEFT))
			{
				paintVertBorder(g,x + width
					- SPLITTER_WIDTH,y,height);
			}
		} 

		
		public Insets getBorderInsets(Component c)
		{
			return insets;
		} 

		
		public boolean isBorderOpaque()
		{
			return false;
		} 

		
		private void paintHorizBorder(Graphics g, int x, int y, int width)
		{
			g.setColor(color3);
			g.fillRect(x,y,width,SPLITTER_WIDTH);

			for(int i = 0; i < width / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + (i << 2) + 2,y + 3,
					x + (i << 2) + 2,y + 3);
				g.setColor(color2);
				g.drawLine(x + (i << 2) + 3,y + 4,
					x + (i << 2) + 3,y + 4);
				g.setColor(color1);
				g.drawLine(x + (i << 2) + 4,y + 5,
					x + (i << 2) + 4,y + 5);
				g.setColor(color2);
				g.drawLine(x + (i << 2) + 5,y + 6,
					x + (i << 2) + 5,y + 6);
			}
		} 

		
		private void paintVertBorder(Graphics g, int x, int y, int height)
		{
			g.setColor(color3);
			g.fillRect(x,y,SPLITTER_WIDTH,height);

			for(int i = 0; i < height / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + 3,y + (i << 2) + 2,
					x + 3,y + (i << 2) + 2);
				g.setColor(color2);
				g.drawLine(x + 4,y + (i << 2) + 3,
					x + 4,y + (i << 2) + 3);
				g.setColor(color1);
				g.drawLine(x + 5,y + (i << 2) + 4,
					x + 5,y + (i << 2) + 4);
				g.setColor(color2);
				g.drawLine(x + 6,y + (i << 2) + 5,
					x + 6,y + (i << 2) + 5);
			}
		} 

		
		private void updateColors()
		{
			if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
			{
				color1 = MetalLookAndFeel.getControlHighlight();
				color2 = MetalLookAndFeel.getControlDarkShadow();
				color3 = MetalLookAndFeel.getControl();
			}
			else
			{
				color1 = color2 = color3 = null;
			}
		} 
	} 

	
	public static class RotatedTextIcon implements Icon
	{
		public static final int NONE = 0;
		public static final int CW = 1;
		public static final int CCW = 2;

		
		public RotatedTextIcon(int rotate, Font font, String text)
		{
			this.rotate = rotate;
			this.font = font;

			FontRenderContext fontRenderContext
				= new FontRenderContext(null,true,true);
			glyphs = font.createGlyphVector(fontRenderContext,text);
			width = (int)glyphs.getLogicalBounds().getWidth() + 4;
			

			LineMetrics lineMetrics = font.getLineMetrics(text,fontRenderContext);
			ascent = lineMetrics.getAscent();
			height = (int)lineMetrics.getHeight();

			renderHints = new RenderingHints(
				RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
			renderHints.put(RenderingHints.KEY_FRACTIONALMETRICS,
				RenderingHints.VALUE_FRACTIONALMETRICS_ON);
			renderHints.put(RenderingHints.KEY_RENDERING,
				RenderingHints.VALUE_RENDER_QUALITY);
		} 

		
		public int getIconWidth()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? height : width);
		} 

		
		public int getIconHeight()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? width : height);
		} 

		
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g;
			g2d.setFont(font);
			AffineTransform oldTransform = g2d.getTransform();
			RenderingHints oldHints = g2d.getRenderingHints();

			g2d.setRenderingHints(renderHints);
			g2d.setColor(c.getForeground());

			
			if(rotate == RotatedTextIcon.NONE)
			{
				g2d.drawGlyphVector(glyphs,x + 2,y + ascent);
			} 
			
			else if(rotate == RotatedTextIcon.CW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y + 2);
				trans.rotate(Math.PI / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} 
			
			else if(rotate == RotatedTextIcon.CCW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y - 2);
				trans.rotate(Math.PI * 3 / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} 

			g2d.setTransform(oldTransform);
			g2d.setRenderingHints(oldHints);
		} 

		
		private final int rotate;
		private final Font font;
		private final GlyphVector glyphs;
		private final float width;
		private final float height;
		private final float ascent;
		private final RenderingHints renderHints;
		
	} 

	
	class ButtonLayout implements LayoutManager
	{
		
		public void addLayoutComponent(String name, Component comp) {} 

		
		public void removeLayoutComponent(Component comp) {} 

		
		
		int getWrappedDimension(JComponent parent, int dimension)
		{
			Insets insets = parent.getBorder()
				.getBorderInsets(parent);

			Component[] comp = parent.getComponents();
			if(comp.length <= 2)
				return 0;

			Dimension dim = comp[2].getPreferredSize();

			if(position.equals(DockableWindowManagerImpl.TOP)
				|| position.equals(DockableWindowManagerImpl.BOTTOM))
			{
				int width = dimension - insets.right;
				Dimension returnValue = preferredLayoutSizeLR(insets, comp, dim, width);
				return returnValue.height;
			}
			else
			{
				Dimension returnValue = preferredLayoutSizeTB(dimension, insets, comp, dim);
				return returnValue.width;
			}
		} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets(parent);

			Component[] comp = parent.getComponents();
			if(comp.length <= 2)
			{
				
				return new Dimension(0,0);
			}

			Dimension dim = comp[2].getPreferredSize();

			if(position.equals(DockableWindowManagerImpl.TOP)
				|| position.equals(DockableWindowManagerImpl.BOTTOM))
			{
				int width = parent.getWidth() - insets.right;
				Dimension returnValue = preferredLayoutSizeLR(insets, comp, dim, width);
				return returnValue;
			}
			else
			{
				Dimension returnValue = preferredLayoutSizeTB(parent.getHeight(), insets, comp, dim);
				return returnValue;
			}
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			return preferredLayoutSize(parent);
		} 

		
		public void layoutContainer(Container parent)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets(parent);

			Component[] comp = parent.getComponents();
			if(comp.length <= 2)
			{
				for(int i = 0; i < comp.length; i++)
				{
					comp[i].setVisible(false);
				}
				return;
			}

			comp[0].setVisible(true);
			comp[1].setVisible(true);

			Dimension dim = comp[2].getPreferredSize();

			if(position.equals(DockableWindowManagerImpl.TOP)
				|| position.equals(DockableWindowManagerImpl.BOTTOM))
			{
				int width = parent.getWidth() - insets.right;
				int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);
				int x = (rowHeight << 1) + insets.left;
				int y = insets.top;
				closeBox.setBounds(insets.left,insets.top,rowHeight,rowHeight);
				menuBtn.setBounds(insets.left + rowHeight,insets.top,rowHeight,rowHeight);

				for(int i = 2; i < comp.length; i++)
				{
					int btnWidth = comp[i].getPreferredSize().width;
					if(btnWidth + x > width)
					{
						x = insets.left;
						y += rowHeight;
					}
					comp[i].setBounds(x,y,btnWidth,rowHeight);
					x += btnWidth;
				}

				
			}
			else
			{
				int height = parent.getHeight() - insets.bottom;
				int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);
				int x = insets.left;
				int y = (colWidth << 1) + insets.top;
				closeBox.setBounds(insets.left,insets.top,colWidth,colWidth);
				menuBtn.setBounds(insets.left,insets.top + colWidth,colWidth,colWidth);

				for(int i = 2; i < comp.length; i++)
				{
					int btnHeight = comp[i].getPreferredSize().height;
					if(btnHeight + y > height)
					{
						x += colWidth;
						y = insets.top;
					}
					comp[i].setBounds(x,y,colWidth,btnHeight);
					y += btnHeight;
				}

				
			}
		} 

		
		private Dimension preferredLayoutSizeLR(Insets insets, Component[] comp, Dimension dim, int width)
		{
			int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);
			int x = (rowHeight << 1) + insets.left;
			Dimension returnValue = new Dimension(0,rowHeight
				+ insets.top + insets.bottom);

			for(int i = 2; i < comp.length; i++)
			{
				int btnWidth = comp[i].getPreferredSize().width;
				if(btnWidth + x > width)
				{
					returnValue.height += rowHeight;
					x = insets.left;
				}

				x += btnWidth;
			}
			return returnValue;
		} 

		
		private Dimension preferredLayoutSizeTB(int dimension, Insets insets, Component[] comp, Dimension dim)
		{
			int height = dimension - insets.bottom;
			int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);
			int y = (colWidth << 1) + insets.top;
			Dimension returnValue = new Dimension(colWidth
				+ insets.left + insets.right,0);

			for(int i = 2; i < comp.length; i++)
			{
				int btnHeight = comp[i].getPreferredSize().height;
				if(btnHeight + y > height)
				{
					returnValue.width += colWidth;
					y = insets.top;
				}

				y += btnHeight;
			}
			return returnValue;
		} 
	} 

	public void show(String name)
	{
		DockableWindowManagerImpl.Entry entry = null;
		if (name != null)
		{
			wm.showDockableWindow(name);
			wm.hideDockableWindow(name);
		}
		show(entry);
	}

	
}
"
jEdit,4.3,org.gjt.sp.jedit.pluginmgr.PluginList,8,1,0,13,64,0,4,10,0,0.746031746,485,0.333333333,1,0.0,0.3,0,0,58.5,17,3.875,0,"

package org.gjt.sp.jedit.pluginmgr;


import java.io.*;
import java.net.URL;
import java.util.*;
import java.util.zip.GZIPInputStream;
import org.xml.sax.XMLReader;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.XMLReaderFactory;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;
import org.gjt.sp.util.WorkRequest;
import org.gjt.sp.util.IOUtilities;
import org.gjt.sp.jedit.*;




class PluginList
{
	
	public static final int GZIP_MAGIC_1 = 0x1f;
	public static final int GZIP_MAGIC_2 = 0x8b;

	final List<Plugin> plugins = new ArrayList<Plugin>();
	final Map<String, Plugin> pluginHash = new HashMap<String, Plugin>();
	final List<PluginSet> pluginSets = new ArrayList<PluginSet>();

	
	private final String id;
	private String cachedURL;
	private WorkRequest workRequest;
	String gzipURL;
	
	PluginList(WorkRequest workRequest) 
	{
		id = jEdit.getProperty(""plugin-manager.mirror.id"");
		this.workRequest = workRequest;
		readPluginList(true);
	}
	
	void readPluginList(boolean allowRetry)
	{
		gzipURL = jEdit.getProperty(""plugin-manager.export-url"");	
		if (!id.equals(MirrorList.Mirror.NONE))
			gzipURL += ""?mirror=""+id;		
		String path = null;
		if (jEdit.getSettingsDirectory() == null)
		{
			cachedURL = gzipURL;
		}
		else
		{
			path = jEdit.getSettingsDirectory() + File.separator + ""pluginMgr-Cached.xml.gz"";
			cachedURL = ""file:
		}
		boolean downloadIt = !id.equals(jEdit.getProperty(""plugin-manager.mirror.cached-id""));
		if (path != null)
		{
			try
			{

				File f = new File(path);
				if (!f.canRead()) downloadIt = true;
				long currentTime = System.currentTimeMillis();
				long age = currentTime - f.lastModified();
				
				long interval = jEdit.getIntegerProperty(""plugin-manager.list-cache.minutes"", 5) * 60 * 1000;
				if (age > interval)
				{
					Log.log(Log.MESSAGE, this, ""PluginList cached copy too old. Downloading from mirror. "");
					downloadIt = true;
				}
			}
			catch (Exception e)
			{
				Log.log(Log.MESSAGE, this, ""No cached copy. Downloading from mirror. "");
				downloadIt = true;
			}
		}
		if (downloadIt && cachedURL != gzipURL)
		{
			downloadPluginList();
		}
		InputStream in = null, inputStream = null;
		try
		{
			if (cachedURL != gzipURL) 
				Log.log(Log.MESSAGE, this, ""Using cached pluginlist"");
			inputStream = new URL(cachedURL).openStream();
			XMLReader parser = XMLReaderFactory.createXMLReader();
			PluginListHandler handler = new PluginListHandler(this, cachedURL);
			in = new BufferedInputStream(inputStream);
			if(in.markSupported())
			{
				in.mark(2);
				int b1 = in.read();
				int b2 = in.read();
				in.reset();

				if(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)
					in = new GZIPInputStream(in);
			}
			InputSource isrc = new InputSource(new InputStreamReader(in,""UTF8""));
			isrc.setSystemId(""jedit.jar"");
			parser.setContentHandler(handler);
			parser.setDTDHandler(handler);
			parser.setEntityResolver(handler);
			parser.setErrorHandler(handler);
			parser.parse(isrc);
				
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, this, ""readpluginlist: error"", e);
			if (cachedURL.startsWith(""file:
			{
				Log.log(Log.DEBUG, this, ""Unable to read plugin list, deleting cached file and try again"");
				new File(cachedURL.substring(8)).delete();
				if (allowRetry)
				{
					plugins.clear();
					pluginHash.clear();
					pluginSets.clear();
					readPluginList(false);
				}
			}
		}
		finally
		{
			IOUtilities.closeQuietly(in);
			IOUtilities.closeQuietly(inputStream);
		}
		
	}
	
	
	void downloadPluginList()
	{
		BufferedInputStream is = null;
		BufferedOutputStream out = null;
		try
		{
			
			workRequest.setStatus(jEdit.getProperty(""plugin-manager.list-download""));
			InputStream inputStream = new URL(gzipURL).openStream();
			String fileName = cachedURL.replaceFirst(""file:
			out = new BufferedOutputStream(new FileOutputStream(fileName));
			long start = System.currentTimeMillis();
			is = new BufferedInputStream(inputStream);
			IOUtilities.copyStream(4096, null, is, out, false);
			jEdit.setProperty(""plugin-manager.mirror.cached-id"", id);
			Log.log(Log.MESSAGE, this, ""Updated cached pluginlist "" + (System.currentTimeMillis() - start));
		}
		catch (Exception e)
		{
			Log.log (Log.ERROR, this, ""CacheRemotePluginList: error"", e);
		}
		finally
		{
			IOUtilities.closeQuietly(out);
			IOUtilities.closeQuietly(is);
		}
	}
	
	
	void addPlugin(Plugin plugin)
	{
		plugin.checkIfInstalled();
		plugins.add(plugin);
		pluginHash.put(plugin.name,plugin);
	} 

	
	void addPluginSet(PluginSet set)
	{
		pluginSets.add(set);
	} 

	
	void finished()
	{
		
		
		for(int i = 0; i < plugins.size(); i++)
		{
			Plugin plugin = plugins.get(i);
			for(int j = 0; j < plugin.branches.size(); j++)
			{
				Branch branch = plugin.branches.get(j);
				for(int k = 0; k < branch.deps.size(); k++)
				{
					Dependency dep = branch.deps.get(k);
					if(dep.what.equals(""plugin""))
						dep.plugin = pluginHash.get(dep.pluginName);
				}
			}
		}
	} 

	
	void dump()
	{
		for(int i = 0; i < plugins.size(); i++)
		{
			System.err.println(plugins.get(i));
			System.err.println();
		}
	} 

	
	
	String getMirrorId()
	{
		return id;
	} 

	
	static class PluginSet
	{
		String name;
		String description;
		final List<String> plugins = new ArrayList<String>();

		public String toString()
		{
			return plugins.toString();
		}
	} 

	
	public static class Plugin
	{
		String jar;
		String name;
		String description;
		String author;
		final List<Branch> branches = new ArrayList<Branch>();
		
		

		void checkIfInstalled()
		{
			
		}

		String getInstalledVersion()
		{
			PluginJAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();

				if(MiscUtilities.getFileName(path).equals(jar))
				{
					EditPlugin plugin = jars[i].getPlugin();
					if(plugin != null)
					{
						return jEdit.getProperty(
							""plugin."" + plugin.getClassName()
							+ "".version"");
					}
					else
						return null;
				}
			}

			return null;
		}

		String getInstalledPath()
		{
			PluginJAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();

				if(MiscUtilities.getFileName(path).equals(jar))
					return path;
			}

			return null;
		}

		
		Branch getCompatibleBranch()
		{
			for(int i = 0; i < branches.size(); i++)
			{
				Branch branch = branches.get(i);
				if(branch.canSatisfyDependencies())
					return branch;
			}

			return null;
		}

		boolean canBeInstalled()
		{
			Branch branch = getCompatibleBranch();
			return branch != null && !branch.obsolete
				&& branch.canSatisfyDependencies();
		}

		void install(Roster roster, String installDirectory, boolean downloadSource)
		{
			String installed = getInstalledPath();

			Branch branch = getCompatibleBranch();
			if(branch.obsolete)
			{
				if(installed != null)
					roster.addRemove(installed);
				return;
			}

			
			

			if(installed != null)
			{
				installDirectory = MiscUtilities.getParentOfPath(
					installed);
			}

			roster.addInstall(
				installed,
				downloadSource ? branch.downloadSource : branch.download,
				installDirectory,
				downloadSource ? branch.downloadSourceSize : branch.downloadSize);

		}

		public String toString()
		{
			return name;
		}
	} 

	
	static class Branch
	{
		String version;
		String date;
		int downloadSize;
		String download;
		int downloadSourceSize;
		String downloadSource;
		boolean obsolete;
		final List<Dependency> deps = new ArrayList<Dependency>();

		boolean canSatisfyDependencies()
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = deps.get(i);
				if(!dep.canSatisfy())
					return false;
			}

			return true;
		}

		void satisfyDependencies(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = deps.get(i);
				dep.satisfy(roster,installDirectory,downloadSource);
			}
		}

		public String toString()
		{
			return ""[version="" + version + "",download="" + download
				+ "",obsolete="" + obsolete + "",deps="" + deps + ']';
		}
	} 

	
	static class Dependency
	{
		final String what;
		final String from;
		final String to;
		
		final String pluginName;
		Plugin plugin;

		Dependency(String what, String from, String to, String pluginName)
		{
			this.what = what;
			this.from = from;
			this.to = to;
			this.pluginName = pluginName;
		}

		boolean isSatisfied()
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					String installedVersion = plugin.getInstalledVersion();
					if(installedVersion != null
						&&
					(from == null || StandardUtilities.compareStrings(
						installedVersion,from,false) >= 0)
						&&
						(to == null || StandardUtilities.compareStrings(
						      installedVersion,to,false) <= 0))
					{
						return true;
					}
				}

				return false;
			}
			else if(what.equals(""jdk""))
			{
				String javaVersion = System.getProperty(""java.version"").substring(0,3);

				if((from == null || StandardUtilities.compareStrings(
					javaVersion,from,false) >= 0)
					&&
					(to == null || StandardUtilities.compareStrings(
						     javaVersion,to,false) <= 0))
					return true;
				else
					return false;
			}
			else if(what.equals(""jedit""))
			{
				String build = jEdit.getBuild();

				if((from == null || StandardUtilities.compareStrings(
					build,from,false) >= 0)
					&&
					(to == null || StandardUtilities.compareStrings(
						     build,to,false) <= 0))
					return true;
				else
					return false;
			}
			else
			{
				Log.log(Log.ERROR,this,""Invalid dependency: "" + what);
				return false;
			}
		}

		boolean canSatisfy()
		{
			if(isSatisfied())
				return true;
			if (what.equals(""plugin""))
				return plugin.canBeInstalled();
			return false;
		}

		void satisfy(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			if(what.equals(""plugin""))
			{
				String installedVersion = plugin.getInstalledVersion();
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = plugin.branches.get(i);
					if((installedVersion == null
						||
					StandardUtilities.compareStrings(
						installedVersion,branch.version,false) < 0)
						&&
					(from == null || StandardUtilities.compareStrings(
						branch.version,from,false) >= 0)
						&&
						(to == null || StandardUtilities.compareStrings(
						      branch.version,to,false) <= 0))
					{
						plugin.install(roster,installDirectory,
							downloadSource);
						return;
					}
				}
			}
		}

		public String toString()
		{
			return ""[what="" + what + "",from="" + from
				+ "",to="" + to + "",plugin="" + plugin + ']';
		}
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.indent.IndentRule,1,1,0,7,1,0,7,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.indent;

import java.util.List;
import org.gjt.sp.jedit.buffer.JEditBuffer;


public interface IndentRule
{
	
	void apply(JEditBuffer buffer, int thisLineIndex,
		int prevLineIndex, int prevPrevLineIndex,
		List<IndentAction> indentActions);
}
"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchNode,2,1,0,6,2,1,3,3,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.jedit.View;


public interface HyperSearchNode
{
	Buffer getBuffer(View view);

	void goTo(EditPane editPane);
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.BSHAmbiguousName,8,2,0,20,21,26,11,9,6,0.428571429,89,0.0,0,0.708333333,0.4375,1,1,10.0,1,0.875,0,"


package org.gjt.sp.jedit.bsh;

class BSHAmbiguousName extends SimpleNode
{
    public String text;

    BSHAmbiguousName(int id) { super(id); }
	
    public Name getName( NameSpace namespace )
    {
        return namespace.getNameResolver( text );
    }

    public Object toObject( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		return toObject( callstack, interpreter, false );
    }

    Object toObject( 
		CallStack callstack, Interpreter interpreter, boolean forceClass ) 
		throws EvalError
    {
		try {
        	return 
				getName( callstack.top() ).toObject( 
					callstack, interpreter, forceClass );
		} catch ( UtilEvalError e ) {

			throw e.toEvalError( this, callstack );
		}
    }

    public Class toClass( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		try {
        	return getName( callstack.top() ).toClass();
		} catch ( ClassNotFoundException e ) {
			throw new EvalError( e.getMessage(), this, callstack );
		} catch ( UtilEvalError e2 ) {
			
			throw e2.toEvalError( this, callstack );
		}
    }

    public LHS toLHS( CallStack callstack, Interpreter interpreter)
		throws EvalError
    {
		try {
			return getName( callstack.top() ).toLHS( callstack, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
    }

	
    public Object eval( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		throw new InterpreterError( 
			""Don't know how to eval an ambiguous name!""
			+""  Use toObject() if you want an object."" );
    }

	public String toString() {
		return ""AmbigousName: ""+text;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.JEditAbstractEditAction,7,1,2,19,8,0,19,0,5,0.583333333,41,1.0,0,0.0,0.5,0,0,4.571428571,1,0.7143,0,"

package org.gjt.sp.jedit;


public abstract class JEditAbstractEditAction<E>
{
	
	protected String name;

	protected Object[] args;

	

	
	
	protected JEditAbstractEditAction(String name)
	{
		this.name = name;
	}

	protected JEditAbstractEditAction(String name, Object[] newArgs)
	{
		this.name = name;
		this.args = newArgs;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public void setName(String newName)
	{
		name = newName;
	}

	
	
	public abstract void invoke(E arg);

	
	public final void invoke(E arg, Object[] newArgs)
	{
		args = newArgs;
		invoke(arg);
	} 

	
	@Override
	public String toString()
	{
		return name;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.input.TextAreaInputHandler,11,2,1,12,54,25,1,11,5,0.3,444,1.0,1,0.666666667,0.227272727,2,10,39.27272727,23,5.1818,0,"
package org.gjt.sp.jedit.input;


import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.gui.KeyEventTranslator;
import org.gjt.sp.jedit.gui.KeyEventWorkaround;
import org.gjt.sp.jedit.textarea.TextArea;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StandardUtilities;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.util.Hashtable;
import org.gjt.sp.jedit.JEditBeanShellAction;
import org.gjt.sp.jedit.buffer.JEditBuffer;
import org.gjt.sp.jedit.gui.ShortcutPrefixActiveEvent;



public abstract class TextAreaInputHandler extends AbstractInputHandler<JEditBeanShellAction>
{
	private final TextArea textArea;

	
	protected TextAreaInputHandler(TextArea textArea)
	{
		this.textArea = textArea;
		bindings = currentBindings = new Hashtable();
	} 

	
	
	@Override
	public void processKeyEvent(KeyEvent evt, int from, boolean global)
	{
		if(Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,this,""Key event                 : ""
				+ toString(evt) + "" from "" + from);
		
		}

		evt = _preprocessKeyEvent(evt);
		if(evt == null)
			return;

		if(Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,this,""Key event after workaround: ""
				+ toString(evt) + "" from "" + from);
		}

		boolean focusOnTextArea = false;
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			
			
			


			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else if(isPrefixActive() || textArea.hasFocus())
			{
				processKeyEventKeyStrokeHandling(evt,from,""type "",global);
			}


			processKeyEventSub(focusOnTextArea);

			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else if(KeyEventWorkaround.isBindable(evt.getKeyCode()))
			{
				processKeyEventKeyStrokeHandling(evt,from,""press"",global);

				processKeyEventSub(focusOnTextArea);

			}
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			break;
		}
	} 

	
	
	private KeyEvent _preprocessKeyEvent(KeyEvent evt)
	{
		if(evt.isConsumed())
			return null;

		if(Debug.DUMP_KEY_EVENTS)
		{
			Log.log(Log.DEBUG,this,""Key event (preprocessing) : ""
					+ toString(evt));
		}

		return KeyEventWorkaround.processKeyEvent(evt);
	} 

	
	private void processKeyEventSub(boolean focusOnTextArea)
	{
		
		
		
		if (isPrefixActive() && focusOnTextArea)
		{
			textArea.requestFocus();
		}
	} 

	
	protected abstract JEditBeanShellAction getAction(String action);
	

	
	
	@Override
	public void invokeAction(String action)
	{
		invokeAction(getAction(action));
	} 

	
	
	@Override
	public void invokeAction(JEditBeanShellAction action)
	{
		JEditBuffer buffer = textArea.getBuffer();

		

		
		if(!action.noRememberLast())
		{
			if(lastAction == action)
				lastActionCount++;
			else
			{
				lastAction = action;
				lastActionCount = 1;
			}
		}

		
		int _repeatCount = repeatCount;

		
		if(action.noRepeat() || _repeatCount == 1)
			action.invoke(textArea);
		else
		{
			try
			{
				buffer.beginCompoundEdit();

				for(int i = 0; i < _repeatCount; i++)
					action.invoke(textArea);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		
		
		if(_repeatCount != 1)
		{
			
			
			if(readNextChar != null)
				return;

			repeatCount = 1;
		}
	} 

	
	
	@Override
	public boolean handleKey(KeyEventTranslator.Key keyStroke,boolean dryRun)
	{
		char input = '\0';
		if(keyStroke.modifiers == null
			|| keyStroke.modifiers.equals(""S""))
		{
			switch(keyStroke.key)
			{
			case '\n':
			case '\t':
				input = (char)keyStroke.key;
				break;
			default:
				input = keyStroke.input;
				break;
			}
		}

		if(readNextChar != null)
		{
			if(input != '\0')
			{
				if (!dryRun)
				{
					setCurrentBindings(bindings);
					invokeReadNextChar(input);
					repeatCount = 1;
				}
				return true;
			}
			else
			{
				if (!dryRun)
				{
					readNextChar = null;
				}
			}
		}

		Object o = currentBindings.get(keyStroke);
		if(o == null)
		{
			if (!dryRun)
			{
				
				
				
				
				if(currentBindings != bindings)
				{
					Toolkit.getDefaultToolkit().beep();
					
					
					repeatCount = 1;
					setCurrentBindings(bindings);
				}
				else if(input != '\0')
				{
					if (!keyStroke.isFromGlobalContext())
					{ 
						userInput(input);
					}
				}
				else
				{
					
					
					if(KeyEventWorkaround.isNumericKeypad(keyStroke.key))
						KeyEventWorkaround.numericKeypadKey();
				}
				sendShortcutPrefixOff();
			}
		}
		else if(o instanceof Hashtable)
		{
			if (!dryRun)
			{
				setCurrentBindings((Hashtable)o);
				ShortcutPrefixActiveEvent.firePrefixStateChange(currentBindings, true);
				shortcutOn = true;
			}
			return true;
		}
		else if(o instanceof String)
		{
			if (!dryRun)
			{
				setCurrentBindings(bindings);
				sendShortcutPrefixOff();
				invokeAction((String)o);
			}
			return true;
		}
		else if(o instanceof JEditBeanShellAction)
		{
			if (!dryRun)
			{
				setCurrentBindings(bindings);
				sendShortcutPrefixOff();
				invokeAction((JEditBeanShellAction)o);
			}
			return true;
		}
		if (!dryRun)
		{
			sendShortcutPrefixOff();
		}
		return false;
	} 

	
	protected void userInput(char ch)
	{
		lastActionCount = 0;


		if(repeatCount == 1)
			textArea.userInput(ch);

		repeatCount = 1;
	} 

	
	protected void invokeReadNextChar(char ch)
	{
		String charStr = StandardUtilities.charsToEscapes(String.valueOf(ch));

		
		int index;
		while((index = readNextChar.indexOf(""__char__"")) != -1)
		{
			readNextChar = readNextChar.substring(0,index)
				+ '\'' + charStr + '\''
				+ readNextChar.substring(index + 8);
		}
		readNextChar = null;
	} 
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.VFSUpdate,3,2,0,5,9,0,3,2,3,0.0,36,1.0,0,0.6,0.666666667,1,1,10.66666667,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class VFSUpdate extends EBMessage
{
	
	public VFSUpdate(String path)
	{
		super(null);

		if(path == null)
			throw new NullPointerException(""Path must be non-null"");

		this.path = path;
	}

	
	public String getPath()
	{
		return path;
	}

	public String paramString()
	{
		return ""path="" + path + "","" + super.paramString();
	}

	
	private String path;
}
"
jEdit,4.3,org.gjt.sp.jedit.msg.PositionChanging,3,3,1,7,5,3,4,3,2,2.0,19,0.0,0,1.0,0.583333333,0,0,5.333333333,0,0.0,0,"package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EditPane;
import org.gjt.sp.jedit.textarea.TextArea;



public class PositionChanging extends EditPaneUpdate
{
	
	protected PositionChanging(EditPane editPane, Object whatt)
	{
		super(editPane, whatt);
	}

	public PositionChanging(TextArea textArea)
	{
		super(EditPane.get(textArea), EditPaneUpdate.POSITION_CHANGING);
	}
	
	public PositionChanging(EditPane editPane)
	{
		super (editPane, EditPaneUpdate.POSITION_CHANGING);
	}
}
"
jEdit,4.3,org.gjt.sp.jedit.bsh.reflect.ReflectManagerImpl,2,2,0,1,4,1,0,1,2,2.0,16,0.0,0,0.75,0.75,1,1,7.0,2,1.0,0,"

package org.gjt.sp.jedit.bsh.reflect;

import org.gjt.sp.jedit.bsh.ReflectManager;
import java.lang.reflect.AccessibleObject;


public class ReflectManagerImpl extends ReflectManager
{
	

	public boolean setAccessible( Object obj ) 
	{
		if ( obj instanceof AccessibleObject ) {
			((AccessibleObject)obj).setAccessible(true);
			return true;
		} else
			return false;
	}
}

"
jEdit,4.3,org.gjt.sp.jedit.search.HyperSearchResult,10,1,0,18,33,7,9,11,5,0.685185185,207,0.0,2,0.0,0.257142857,0,0,19.1,5,1.9,0,"

package org.gjt.sp.jedit.search;


import javax.swing.text.Position;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;



public class HyperSearchResult implements HyperSearchNode
{
	public String path;
	public Buffer buffer;
	public int line;
	public String str; 
	public Occur occur;
	public int occurCount;

	
	public Buffer getBuffer(View view)
	{
		if(buffer == null)
			buffer = jEdit.openFile(view,path);
		return buffer;
	} 

	
	
	public Selection[] getSelection()
	{
		if(buffer == null)
			return null;

		Selection[] returnValue = new Selection[occurCount];
		Occur o = occur;
		int i = 0;
		while(o != null)
		{
			Selection.Range s = new Selection.Range(
				o.startPos.getOffset(),
				o.endPos.getOffset()
			);
			returnValue[i++] = s;
			o = o.next;
		}
		return returnValue;
	} 

	
	public void goTo(final EditPane editPane)
	{
		final Buffer buffer = getBuffer(editPane.getView());
		if(buffer == null)
			return;
		editPane.setBuffer(buffer);

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				Selection[] s = getSelection();
				if(s == null)
					return;

				JEditTextArea textArea = editPane.getTextArea();
				if(textArea.isMultipleSelectionEnabled())
					textArea.addToSelection(s);
				else
					textArea.setSelection(s);

				textArea.moveCaretPosition(occur.endPos.getOffset());
			}
		});
	} 

	
	public String toString()
	{
		return str;
	} 

	

	
	HyperSearchResult(Buffer buffer, int line)
	{
		path = buffer.getPath();

		if(!buffer.isTemporary())
			bufferOpened(buffer);

		this.line = line;

		str = (line + 1) + "": "" + buffer.getLineText(line)
			.replace('\t',' ').trim();
	} 

	
	void bufferOpened(Buffer buffer)
	{
		this.buffer = buffer;
		Occur o = occur;
		while(o != null)
		{
			o.bufferOpened();
			o = o.next;
		}
	} 

	
	void bufferClosed()
	{
		buffer = null;
		Occur o = occur;
		while(o != null)
		{
			o.bufferClosed();
			o = o.next;
		}
	} 

	
	void addOccur(int start, int end)
	{
		Occur o = new Occur(start,end);
		o.next = occur;
		occur = o;
		occurCount++;
	} 

	
	
	boolean pathEquals(String path)
	{
		return path.equals(MiscUtilities.resolveSymlinks(this.path));
	} 
	
	
	public boolean equals(Object compareObj)
	{
		if (!(compareObj instanceof HyperSearchResult))
			return false;
		HyperSearchResult otherResult = (HyperSearchResult)compareObj;
		return pathEquals(otherResult.path) && line == otherResult.line
			&& buffer.equals(otherResult.buffer);		
	}

	

	
	public class Occur
	{
		public int start, end;
		public Position startPos, endPos;
		public Occur next;

		
		Occur(int start, int end)
		{
			this.start = start;
			this.end = end;

			if(buffer != null && !buffer.isTemporary())
				bufferOpened();
		} 

		
		void bufferOpened()
		{
			startPos = buffer.createPosition(Math.min(
				buffer.getLength(),start));
			endPos = buffer.createPosition(Math.min(
				buffer.getLength(),end));
		} 

		
		void bufferClosed()
		{
			start = startPos.getOffset();
			end = endPos.getOffset();
			startPos = endPos = null;
		} 
	} 
}
"
